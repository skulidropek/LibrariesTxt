[CompilerGeneratedAttribute]
[EmbeddedAttribute]
internal class Microsoft.CodeAnalysis.EmbeddedAttribute : Attribute {
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ExtensionAttribute]
public static class Superpower.Combinators : object {
    [NullableContextAttribute("2")]
[ExtensionAttribute]
public static TokenListParser`2<TKind, U> Apply(TokenListParser`2<TKind, Token`1<TKind>> parser, Func`2<Token`1<TKind>, TextParser`1<U>> valueParser);
    [ExtensionAttribute]
public static TokenListParser`2<TKind, U> Apply(TokenListParser`2<TKind, Token`1<TKind>> parser, TextParser`1<U> valueParser);
    [ExtensionAttribute]
public static TextParser`1<U> Apply(TextParser`1<TextSpan> parser, TextParser`1<U> valueParser);
    [ExtensionAttribute]
public static TextParser`1<T> AtEnd(TextParser`1<T> parser);
    [ExtensionAttribute]
public static TokenListParser`2<TKind, T> AtEnd(TokenListParser`2<TKind, T> parser);
    [ExtensionAttribute]
public static TokenListParser`2<TKind, T[]> AtLeastOnce(TokenListParser`2<TKind, T> parser);
    [ExtensionAttribute]
public static TextParser`1<T[]> AtLeastOnce(TextParser`1<T> parser);
    [ExtensionAttribute]
public static TokenListParser`2<TKind, T[]> Repeat(TokenListParser`2<TKind, T> parser, int count);
    [ExtensionAttribute]
public static TextParser`1<T[]> Repeat(TextParser`1<T> parser, int count);
    [ExtensionAttribute]
public static TokenListParser`2<TKind, T[]> AtLeastOnceDelimitedBy(TokenListParser`2<TKind, T> parser, TokenListParser`2<TKind, U> delimiter);
    [ExtensionAttribute]
public static TextParser`1<T[]> AtLeastOnceDelimitedBy(TextParser`1<T> parser, TextParser`1<U> delimiter);
    [ExtensionAttribute]
public static TokenListParser`2<TKind, T> Between(TokenListParser`2<TKind, T> parser, TokenListParser`2<TKind, U> left, TokenListParser`2<TKind, U> right);
    [ExtensionAttribute]
public static TextParser`1<T> Between(TextParser`1<T> parser, TextParser`1<U> left, TextParser`1<U> right);
    [ExtensionAttribute]
public static TokenListParser`2<TKind, U> IgnoreThen(TokenListParser`2<TKind, T> first, TokenListParser`2<TKind, U> second);
    [ExtensionAttribute]
public static TextParser`1<U> IgnoreThen(TextParser`1<T> first, TextParser`1<U> second);
    [ExtensionAttribute]
public static TokenListParser`2<TKind, T[]> Many(TokenListParser`2<TKind, T> parser);
    [ExtensionAttribute]
public static TextParser`1<T[]> Many(TextParser`1<T> parser);
    [ExtensionAttribute]
public static TextParser`1<Unit> IgnoreMany(TextParser`1<T> parser);
    [ExtensionAttribute]
public static TokenListParser`2<TKind, T[]> ManyDelimitedBy(TokenListParser`2<TKind, T> parser, TokenListParser`2<TKind, U> delimiter, TokenListParser`2<TKind, U> end);
    [ExtensionAttribute]
public static TextParser`1<T[]> ManyDelimitedBy(TextParser`1<T> parser, TextParser`1<U> delimiter);
    [ExtensionAttribute]
public static TextParser`1<string> Text(TextParser`1<Char[]> parser);
    [ExtensionAttribute]
public static TextParser`1<string> Text(TextParser`1<TextSpan> parser);
    [ExtensionAttribute]
public static TokenListParser`2<TKind, T> Message(TokenListParser`2<TKind, T> parser, string errorMessage);
    [ExtensionAttribute]
public static TextParser`1<T> Message(TextParser`1<T> parser, string errorMessage);
    [ExtensionAttribute]
public static TokenListParser`2<TKind, T> Named(TokenListParser`2<TKind, T> parser, string name);
    [ExtensionAttribute]
public static TextParser`1<T> Named(TextParser`1<T> parser, string name);
    [NullableContextAttribute("0")]
[ExtensionAttribute]
public static TokenListParser`2<TKind, Nullable`1<T>> Optional(TokenListParser`2<TKind, T> parser);
    [NullableContextAttribute("0")]
[ExtensionAttribute]
public static TextParser`1<Nullable`1<T>> Optional(TextParser`1<T> parser);
    [ExtensionAttribute]
public static TokenListParser`2<TKind, T> OptionalOrDefault(TokenListParser`2<TKind, T> parser, T defaultValue);
    [ExtensionAttribute]
public static TextParser`1<T> OptionalOrDefault(TextParser`1<T> parser, T defaultValue);
    [ExtensionAttribute]
public static TokenListParser`2<TKind, T> Or(TokenListParser`2<TKind, T> lhs, TokenListParser`2<TKind, T> rhs);
    [ExtensionAttribute]
public static TextParser`1<T> Or(TextParser`1<T> lhs, TextParser`1<T> rhs);
    [ExtensionAttribute]
public static TokenListParser`2<TKind, U> Select(TokenListParser`2<TKind, T> parser, Func`2<T, U> selector);
    [ExtensionAttribute]
public static TextParser`1<U> Select(TextParser`1<T> parser, Func`2<T, U> selector);
    [ExtensionAttribute]
public static TokenListParser`2<TKind, U> Cast(TokenListParser`2<TKind, T> parser);
    [ExtensionAttribute]
public static TextParser`1<U> Cast(TextParser`1<T> parser);
    [ExtensionAttribute]
public static TokenListParser`2<TKind, T> AsNullable(TokenListParser`2<TKind, T> parser);
    [ExtensionAttribute]
public static TextParser`1<T> AsNullable(TextParser`1<T> parser);
    [ExtensionAttribute]
public static TextParser`1<V> SelectMany(TextParser`1<T> parser, Func`2<T, TextParser`1<U>> selector, Func`3<T, U, V> projector);
    [ExtensionAttribute]
public static TokenListParser`2<TKind, V> SelectMany(TokenListParser`2<TKind, T> parser, Func`2<T, TokenListParser`2<TKind, U>> selector, Func`3<T, U, V> projector);
    [ExtensionAttribute]
public static TokenListParser`2<TKind, U> Then(TokenListParser`2<TKind, T> first, Func`2<T, TokenListParser`2<TKind, U>> second);
    [ExtensionAttribute]
public static TextParser`1<U> Then(TextParser`1<T> first, Func`2<T, TextParser`1<U>> second);
    [ExtensionAttribute]
public static TokenListParser`2<TKind, T> Try(TokenListParser`2<TKind, T> parser);
    [ExtensionAttribute]
public static TextParser`1<T> Try(TextParser`1<T> parser);
    [ExtensionAttribute]
public static TokenListParser`2<TKind, U> Value(TokenListParser`2<TKind, T> parser, U value);
    [ExtensionAttribute]
public static TextParser`1<U> Value(TextParser`1<T> parser, U value);
    [ExtensionAttribute]
public static TokenListParser`2<TKind, T> Where(TokenListParser`2<TKind, T> parser, Func`2<T, bool> predicate, string message);
    [ExtensionAttribute]
public static TextParser`1<T> Where(TextParser`1<T> parser, Func`2<T, bool> predicate, string message);
    [ExtensionAttribute]
public static TextParser`1<TResult> Chain(TextParser`1<TResult> parser, TextParser`1<TOperator> operator, TextParser`1<TOperand> operand, Func`4<TOperator, TResult, TOperand, TResult> apply);
    [ExtensionAttribute]
public static TokenListParser`2<TKind, TResult> Chain(TokenListParser`2<TKind, TResult> parser, TokenListParser`2<TKind, TOperator> operator, TokenListParser`2<TKind, TOperand> operand, Func`4<TOperator, TResult, TOperand, TResult> apply);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal static class Superpower.Display.Presentation : object {
    private static string FormatKind(object kind);
    private static TokenAttribute TryGetTokenAttribute(Type type);
    [NullableContextAttribute("2")]
private static TokenAttribute TryGetTokenAttribute(TKind kind);
    public static string FormatExpectation(TKind kind);
    public static string FormatAppearance(TKind kind, string value);
    public static string FormatLiteral(char literal);
    public static string FormatLiteral(string literal);
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
[AttributeUsageAttribute("260")]
public class Superpower.Display.TokenAttribute : Attribute {
    [CompilerGeneratedAttribute]
private string <Category>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Example>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Description>k__BackingField;
    public string Category { get; public set; }
    public string Example { get; public set; }
    public string Description { get; public set; }
    [CompilerGeneratedAttribute]
public string get_Category();
    [CompilerGeneratedAttribute]
public void set_Category(string value);
    [CompilerGeneratedAttribute]
public string get_Example();
    [CompilerGeneratedAttribute]
public void set_Example(string value);
    [CompilerGeneratedAttribute]
public string get_Description();
    [CompilerGeneratedAttribute]
public void set_Description(string value);
}
[IsReadOnlyAttribute]
public class Superpower.Model.Position : ValueType {
    [CompilerGeneratedAttribute]
private int <Absolute>k__BackingField;
    [CompilerGeneratedAttribute]
private int <Line>k__BackingField;
    [CompilerGeneratedAttribute]
private int <Column>k__BackingField;
    [CompilerGeneratedAttribute]
private static Position <Zero>k__BackingField;
    [CompilerGeneratedAttribute]
private static Position <Empty>k__BackingField;
    public int Absolute { get; }
    public int Line { get; }
    public int Column { get; }
    public static Position Zero { get; }
    public static Position Empty { get; }
    public bool HasValue { get; }
    public Position(int absolute, int line, int column);
    private static Position();
    [CompilerGeneratedAttribute]
public int get_Absolute();
    [CompilerGeneratedAttribute]
public int get_Line();
    [CompilerGeneratedAttribute]
public int get_Column();
    [CompilerGeneratedAttribute]
public static Position get_Zero();
    [CompilerGeneratedAttribute]
public static Position get_Empty();
    public bool get_HasValue();
    public Position Advance(char overChar);
    [NullableContextAttribute("1")]
public virtual string ToString();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public static class Superpower.Model.Result : object {
    [NullableContextAttribute("2")]
public static Result`1<T> Empty(TextSpan remainder);
    public static Result`1<T> Empty(TextSpan remainder, String[] expectations);
    public static Result`1<T> Empty(TextSpan remainder, string errorMessage);
    public static Result`1<T> Value(T value, TextSpan location, TextSpan remainder);
    [NullableContextAttribute("2")]
public static Result`1<U> CastEmpty(Result`1<T> result);
    [NullableContextAttribute("2")]
public static Result`1<T> CombineEmpty(Result`1<T> first, Result`1<T> second);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class Superpower.Model.Result`1 : ValueType {
    private T _value;
    [CompilerGeneratedAttribute]
private TextSpan <Location>k__BackingField;
    [CompilerGeneratedAttribute]
private TextSpan <Remainder>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <HasValue>k__BackingField;
    [NullableAttribute("2")]
[CompilerGeneratedAttribute]
private string <ErrorMessage>k__BackingField;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilerGeneratedAttribute]
private String[] <Expectations>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <Backtrack>k__BackingField;
    public TextSpan Location { get; }
    public TextSpan Remainder { get; }
    public bool HasValue { get; }
    public Position ErrorPosition { get; }
    [NullableAttribute("2")]
public string ErrorMessage { get; }
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public String[] Expectations { get; }
    internal bool Backtrack { get; internal set; }
    public T Value { get; }
    internal Result`1(T value, TextSpan location, TextSpan remainder, bool backtrack);
    [NullableContextAttribute("2")]
internal Result`1(TextSpan location, TextSpan remainder, string errorMessage, String[] expectations, bool backtrack);
    [NullableContextAttribute("2")]
internal Result`1(TextSpan remainder, string errorMessage, String[] expectations, bool backtrack);
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public TextSpan get_Location();
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public TextSpan get_Remainder();
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public bool get_HasValue();
    public Position get_ErrorPosition();
    [IsReadOnlyAttribute]
[NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public string get_ErrorMessage();
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public String[] get_Expectations();
    internal bool IsPartial(TextSpan from);
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
internal bool get_Backtrack();
    [CompilerGeneratedAttribute]
internal void set_Backtrack(bool value);
    public T get_Value();
    public virtual string ToString();
    public string FormatErrorMessageFragment();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[IsReadOnlyAttribute]
[DefaultMemberAttribute("Item")]
public class Superpower.Model.TextSpan : ValueType {
    [NullableAttribute("2")]
[CompilerGeneratedAttribute]
private string <Source>k__BackingField;
    [CompilerGeneratedAttribute]
private Position <Position>k__BackingField;
    [CompilerGeneratedAttribute]
private int <Length>k__BackingField;
    [CompilerGeneratedAttribute]
private static TextSpan <None>k__BackingField;
    [CompilerGeneratedAttribute]
private static TextSpan <Empty>k__BackingField;
    [NullableAttribute("2")]
public string Source { get; }
    public Position Position { get; }
    public int Length { get; }
    public static TextSpan None { get; }
    public static TextSpan Empty { get; }
    public bool IsAtEnd { get; }
    public char Item { get; }
    public TextSpan(string source);
    public TextSpan(string source, Position position, int length);
    private static TextSpan();
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public string get_Source();
    [CompilerGeneratedAttribute]
public Position get_Position();
    [CompilerGeneratedAttribute]
public int get_Length();
    [CompilerGeneratedAttribute]
public static TextSpan get_None();
    [CompilerGeneratedAttribute]
public static TextSpan get_Empty();
    public bool get_IsAtEnd();
    private void EnsureHasValue();
    [NullableContextAttribute("0")]
public Result`1<char> ConsumeChar();
    [NullableContextAttribute("2")]
public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    public sealed virtual bool Equals(TextSpan other);
    public static bool op_Equality(TextSpan lhs, TextSpan rhs);
    public static bool op_Inequality(TextSpan lhs, TextSpan rhs);
    public TextSpan Until(TextSpan next);
    public TextSpan First(int length);
    public TextSpan Skip(int count);
    public virtual string ToString();
    public string ToStringValue();
    public bool EqualsValue(string otherValue);
    public bool EqualsValueIgnoreCase(string otherValue);
    public char get_Item(int index);
    public TextSpan Slice(int index);
    public TextSpan Slice(int index, int count);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class Superpower.Model.Token`1 : ValueType {
    [CompilerGeneratedAttribute]
private TKind <Kind>k__BackingField;
    [CompilerGeneratedAttribute]
private TextSpan <Span>k__BackingField;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilerGeneratedAttribute]
private static Token`1<TKind> <Empty>k__BackingField;
    public TKind Kind { get; }
    public TextSpan Span { get; }
    public Position Position { get; }
    public bool HasValue { get; }
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static Token`1<TKind> Empty { get; }
    public Token`1(TKind kind, TextSpan span);
    private static Token`1();
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public TKind get_Kind();
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public TextSpan get_Span();
    public string ToStringValue();
    public Position get_Position();
    public bool get_HasValue();
    [CompilerGeneratedAttribute]
public static Token`1<TKind> get_Empty();
    public virtual string ToString();
}
public class Superpower.Model.TokenizationState`1 : object {
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilerGeneratedAttribute]
private Nullable`1<Token`1<TKind>> <Previous>k__BackingField;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public Nullable`1<Token`1<TKind>> Previous { get; public set; }
    [CompilerGeneratedAttribute]
public Nullable`1<Token`1<TKind>> get_Previous();
    [CompilerGeneratedAttribute]
public void set_Previous(Nullable`1<Token`1<TKind>> value);
}
[IsReadOnlyAttribute]
public class Superpower.Model.TokenList`1 : ValueType {
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private Token`1[] _tokens;
    [CompilerGeneratedAttribute]
private int <Position>k__BackingField;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilerGeneratedAttribute]
private static TokenList`1<TKind> <Empty>k__BackingField;
    public int Position { get; }
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static TokenList`1<TKind> Empty { get; }
    public bool IsAtEnd { get; }
    public TokenList`1(Token`1[] tokens);
    private TokenList`1(Token`1[] tokens, int position);
    private static TokenList`1();
    [CompilerGeneratedAttribute]
public int get_Position();
    [CompilerGeneratedAttribute]
public static TokenList`1<TKind> get_Empty();
    public bool get_IsAtEnd();
    private void EnsureHasValue();
    public TokenListParserResult`2<TKind, Token`1<TKind>> ConsumeToken();
    [IteratorStateMachineAttribute("Superpower.Model.TokenList`1/<GetEnumerator>d__13")]
public sealed virtual IEnumerator`1<Token`1<TKind>> GetEnumerator();
    [NullableContextAttribute("1")]
private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
    [NullableContextAttribute("2")]
public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    public sealed virtual bool Equals(TokenList`1<TKind> other);
    public static bool op_Equality(TokenList`1<TKind> lhs, TokenList`1<TKind> rhs);
    public static bool op_Inequality(TokenList`1<TKind> lhs, TokenList`1<TKind> rhs);
    [NullableContextAttribute("1")]
public virtual string ToString();
    internal Position ComputeEndOfInputPosition();
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
public static class Superpower.Model.TokenListParserResult : object {
    public static TokenListParserResult`2<TKind, T> Empty(TokenList`1<TKind> remainder);
    public static TokenListParserResult`2<TKind, T> Empty(TokenList`1<TKind> remainder, String[] expectations);
    public static TokenListParserResult`2<TKind, T> Empty(TokenList`1<TKind> remainder, TKind[] expectations);
    public static TokenListParserResult`2<TKind, T> Empty(TokenList`1<TKind> remainder, string errorMessage);
    public static TokenListParserResult`2<TKind, T> Empty(TokenList`1<TKind> remainder, Position errorPosition, string errorMessage);
    public static TokenListParserResult`2<TKind, T> Value(T value, TokenList`1<TKind> location, TokenList`1<TKind> remainder);
    public static TokenListParserResult`2<TKind, U> CastEmpty(TokenListParserResult`2<TKind, T> result);
    public static TokenListParserResult`2<TKind, T> CombineEmpty(TokenListParserResult`2<TKind, T> first, TokenListParserResult`2<TKind, T> second);
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
public class Superpower.Model.TokenListParserResult`2 : ValueType {
    [NullableAttribute("1")]
private T _value;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilerGeneratedAttribute]
private TokenList`1<TKind> <Location>k__BackingField;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilerGeneratedAttribute]
private TokenList`1<TKind> <Remainder>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <HasValue>k__BackingField;
    [CompilerGeneratedAttribute]
private Position <SubTokenErrorPosition>k__BackingField;
    [CompilerGeneratedAttribute]
private string <ErrorMessage>k__BackingField;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilerGeneratedAttribute]
private String[] <Expectations>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <Backtrack>k__BackingField;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public TokenList`1<TKind> Location { get; }
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public TokenList`1<TKind> Remainder { get; }
    public bool HasValue { get; }
    public Position ErrorPosition { get; }
    public Position SubTokenErrorPosition { get; }
    public string ErrorMessage { get; }
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public String[] Expectations { get; }
    [NullableAttribute("1")]
public T Value { get; }
    internal bool Backtrack { get; internal set; }
    [NullableContextAttribute("1")]
internal TokenListParserResult`2(T value, TokenList`1<TKind> location, TokenList`1<TKind> remainder, bool backtrack);
    internal TokenListParserResult`2(TokenList`1<TKind> location, TokenList`1<TKind> remainder, Position errorPosition, string errorMessage, String[] expectations, bool backtrack);
    internal TokenListParserResult`2(TokenList`1<TKind> remainder, Position errorPosition, string errorMessage, String[] expectations, bool backtrack);
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public TokenList`1<TKind> get_Location();
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public TokenList`1<TKind> get_Remainder();
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public bool get_HasValue();
    public Position get_ErrorPosition();
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public Position get_SubTokenErrorPosition();
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public string get_ErrorMessage();
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public String[] get_Expectations();
    [NullableContextAttribute("1")]
public T get_Value();
    internal bool IsPartial(TokenList`1<TKind> from);
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
internal bool get_Backtrack();
    [CompilerGeneratedAttribute]
internal void set_Backtrack(bool value);
    [NullableContextAttribute("1")]
public virtual string ToString();
    [NullableContextAttribute("1")]
public string FormatErrorMessageFragment();
}
public class Superpower.Model.Unit : ValueType {
    [CompilerGeneratedAttribute]
private static Unit <Value>k__BackingField;
    public static Unit Value { get; }
    private static Unit();
    [CompilerGeneratedAttribute]
public static Unit get_Value();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public static class Superpower.Parse : object {
    public static TextParser`1<T> Chain(TextParser`1<TOperator> operator, TextParser`1<T> operand, Func`4<TOperator, T, T, T> apply);
    public static TextParser`1<T> ChainRight(TextParser`1<TOperator> operator, TextParser`1<T> operand, Func`4<TOperator, T, T, T> apply);
    private static TextParser`1<T> ChainRightOperatorRest(T lastOperand, TextParser`1<TOperator> operator, TextParser`1<T> operand, Func`4<TOperator, T, T, T> apply);
    public static TokenListParser`2<TKind, T> Chain(TokenListParser`2<TKind, TOperator> operator, TokenListParser`2<TKind, T> operand, Func`4<TOperator, T, T, T> apply);
    public static TokenListParser`2<TKind, T> ChainRight(TokenListParser`2<TKind, TOperator> operator, TokenListParser`2<TKind, T> operand, Func`4<TOperator, T, T, T> apply);
    private static TokenListParser`2<TKind, T> ChainRightOperatorRest(T lastOperand, TokenListParser`2<TKind, TOperator> operator, TokenListParser`2<TKind, T> operand, Func`4<TOperator, T, T, T> apply);
    public static TextParser`1<Unit> Not(TextParser`1<T> parser);
    public static TokenListParser`2<TKind, Unit> Not(TokenListParser`2<TKind, T> parser);
    public static TextParser`1<T> Ref(Func`1<TextParser`1<T>> reference);
    public static TokenListParser`2<TKind, T> Ref(Func`1<TokenListParser`2<TKind, T>> reference);
    public static TextParser`1<T> Return(T value);
    public static TokenListParser`2<TKind, T> Return(T value);
    [NullableContextAttribute("2")]
public static TokenListParser`2<TKind, ValueTuple`2<T, U>> Sequence(TokenListParser`2<TKind, T> parser1, TokenListParser`2<TKind, U> parser2);
    [NullableContextAttribute("2")]
public static TokenListParser`2<TKind, ValueTuple`3<T, U, V>> Sequence(TokenListParser`2<TKind, T> parser1, TokenListParser`2<TKind, U> parser2, TokenListParser`2<TKind, V> parser3);
    [NullableContextAttribute("2")]
public static TokenListParser`2<TKind, ValueTuple`4<T, U, V, W>> Sequence(TokenListParser`2<TKind, T> parser1, TokenListParser`2<TKind, U> parser2, TokenListParser`2<TKind, V> parser3, TokenListParser`2<TKind, W> parser4);
    [NullableContextAttribute("2")]
public static TokenListParser`2<TKind, ValueTuple`5<T, U, V, W, X>> Sequence(TokenListParser`2<TKind, T> parser1, TokenListParser`2<TKind, U> parser2, TokenListParser`2<TKind, V> parser3, TokenListParser`2<TKind, W> parser4, TokenListParser`2<TKind, X> parser5);
    public static TextParser`1<ValueTuple`2<T, U>> Sequence(TextParser`1<T> parser1, TextParser`1<U> parser2);
    public static TextParser`1<ValueTuple`3<T, U, V>> Sequence(TextParser`1<T> parser1, TextParser`1<U> parser2, TextParser`1<V> parser3);
    public static TextParser`1<ValueTuple`4<T, U, V, W>> Sequence(TextParser`1<T> parser1, TextParser`1<U> parser2, TextParser`1<V> parser3, TextParser`1<W> parser4);
    public static TextParser`1<ValueTuple`5<T, U, V, W, X>> Sequence(TextParser`1<T> parser1, TextParser`1<U> parser2, TextParser`1<V> parser3, TextParser`1<W> parser4, TextParser`1<X> parser5);
    public static TokenListParser`2<TKind, T> OneOf(TokenListParser`2[] parsers);
    public static TextParser`1<T> OneOf(TextParser`1[] parsers);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class Superpower.ParseException : Exception {
    [CompilerGeneratedAttribute]
private Position <ErrorPosition>k__BackingField;
    public Position ErrorPosition { get; }
    public ParseException(string message);
    public ParseException(string message, Exception innerException);
    public ParseException(string message, Position errorPosition);
    public ParseException(string message, Position errorPosition, Exception innerException);
    [CompilerGeneratedAttribute]
public Position get_ErrorPosition();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ExtensionAttribute]
public static class Superpower.ParserExtensions : object {
    [ExtensionAttribute]
public static Result`1<T> TryParse(TextParser`1<T> parser, string input);
    [NullableContextAttribute("2")]
[ExtensionAttribute]
public static TokenListParserResult`2<TKind, T> TryParse(TokenListParser`2<TKind, T> parser, TokenList`1<TKind> input);
    [ExtensionAttribute]
public static T Parse(TextParser`1<T> parser, string input);
    [ExtensionAttribute]
public static T Parse(TokenListParser`2<TKind, T> parser, TokenList`1<TKind> input);
    [ExtensionAttribute]
public static bool IsMatch(TextParser`1<T> parser, TextSpan input);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public static class Superpower.Parsers.Character : object {
    [CompilerGeneratedAttribute]
private static TextParser`1<char> <AnyChar>k__BackingField;
    [CompilerGeneratedAttribute]
private static TextParser`1<char> <WhiteSpace>k__BackingField;
    [CompilerGeneratedAttribute]
private static TextParser`1<char> <Digit>k__BackingField;
    [CompilerGeneratedAttribute]
private static TextParser`1<char> <Letter>k__BackingField;
    [CompilerGeneratedAttribute]
private static TextParser`1<char> <LetterOrDigit>k__BackingField;
    [CompilerGeneratedAttribute]
private static TextParser`1<char> <Lower>k__BackingField;
    [CompilerGeneratedAttribute]
private static TextParser`1<char> <Upper>k__BackingField;
    [CompilerGeneratedAttribute]
private static TextParser`1<char> <Numeric>k__BackingField;
    [CompilerGeneratedAttribute]
private static TextParser`1<char> <HexDigit>k__BackingField;
    public static TextParser`1<char> AnyChar { get; }
    public static TextParser`1<char> WhiteSpace { get; }
    public static TextParser`1<char> Digit { get; }
    public static TextParser`1<char> Letter { get; }
    public static TextParser`1<char> LetterOrDigit { get; }
    public static TextParser`1<char> Lower { get; }
    public static TextParser`1<char> Upper { get; }
    public static TextParser`1<char> Numeric { get; }
    public static TextParser`1<char> HexDigit { get; }
    private static Character();
    private static TextParser`1<char> Matching(Func`2<char, bool> predicate, String[] expectations);
    public static TextParser`1<char> Matching(Func`2<char, bool> predicate, string name);
    public static TextParser`1<char> Except(Func`2<char, bool> predicate, string description);
    public static TextParser`1<char> EqualTo(char ch);
    public static TextParser`1<char> EqualToIgnoreCase(char ch);
    public static TextParser`1<char> In(Char[] chars);
    public static TextParser`1<char> Except(char ch);
    public static TextParser`1<char> ExceptIn(Char[] chars);
    [CompilerGeneratedAttribute]
public static TextParser`1<char> get_AnyChar();
    [CompilerGeneratedAttribute]
public static TextParser`1<char> get_WhiteSpace();
    [CompilerGeneratedAttribute]
public static TextParser`1<char> get_Digit();
    [CompilerGeneratedAttribute]
public static TextParser`1<char> get_Letter();
    [CompilerGeneratedAttribute]
public static TextParser`1<char> get_LetterOrDigit();
    [CompilerGeneratedAttribute]
public static TextParser`1<char> get_Lower();
    [CompilerGeneratedAttribute]
public static TextParser`1<char> get_Upper();
    [CompilerGeneratedAttribute]
public static TextParser`1<char> get_Numeric();
    [CompilerGeneratedAttribute]
public static TextParser`1<char> get_HexDigit();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public static class Superpower.Parsers.Comment : object {
    [CompilerGeneratedAttribute]
private static TextParser`1<TextSpan> <CPlusPlusStyle>k__BackingField;
    [CompilerGeneratedAttribute]
private static TextParser`1<TextSpan> <SqlStyle>k__BackingField;
    [CompilerGeneratedAttribute]
private static TextParser`1<TextSpan> <ShellStyle>k__BackingField;
    public static TextParser`1<TextSpan> CPlusPlusStyle { get; }
    public static TextParser`1<TextSpan> SqlStyle { get; }
    public static TextParser`1<TextSpan> ShellStyle { get; }
    public static TextParser`1<TextSpan> CStyle { get; }
    private static Comment();
    public static TextParser`1<TextSpan> ToEndOfLine(TextParser`1<TextSpan> beginComment);
    [CompilerGeneratedAttribute]
public static TextParser`1<TextSpan> get_CPlusPlusStyle();
    [CompilerGeneratedAttribute]
public static TextParser`1<TextSpan> get_SqlStyle();
    [CompilerGeneratedAttribute]
public static TextParser`1<TextSpan> get_ShellStyle();
    public static TextParser`1<TextSpan> get_CStyle();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public static class Superpower.Parsers.Identifier : object {
    [CompilerGeneratedAttribute]
private static TextParser`1<TextSpan> <CStyle>k__BackingField;
    public static TextParser`1<TextSpan> CStyle { get; }
    private static Identifier();
    [CompilerGeneratedAttribute]
public static TextParser`1<TextSpan> get_CStyle();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public static class Superpower.Parsers.Instant : object {
    [CompilerGeneratedAttribute]
private static TextParser`1<TextSpan> <Iso8601DateTime>k__BackingField;
    public static TextParser`1<TextSpan> Iso8601DateTime { get; }
    private static Instant();
    [CompilerGeneratedAttribute]
public static TextParser`1<TextSpan> get_Iso8601DateTime();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public static class Superpower.Parsers.Numerics : object {
    private static String[] ExpectedDigit;
    private static String[] ExpectedSignOrDigit;
    private static String[] ExpectedHexDigit;
    [CompilerGeneratedAttribute]
private static TextParser`1<TextSpan> <Natural>k__BackingField;
    [CompilerGeneratedAttribute]
private static TextParser`1<UInt32> <NaturalUInt32>k__BackingField;
    [CompilerGeneratedAttribute]
private static TextParser`1<ulong> <NaturalUInt64>k__BackingField;
    [CompilerGeneratedAttribute]
private static TextParser`1<TextSpan> <Integer>k__BackingField;
    [CompilerGeneratedAttribute]
private static TextParser`1<int> <IntegerInt32>k__BackingField;
    [CompilerGeneratedAttribute]
private static TextParser`1<long> <IntegerInt64>k__BackingField;
    [CompilerGeneratedAttribute]
private static TextParser`1<TextSpan> <Decimal>k__BackingField;
    [CompilerGeneratedAttribute]
private static TextParser`1<decimal> <DecimalDecimal>k__BackingField;
    [CompilerGeneratedAttribute]
private static TextParser`1<double> <DecimalDouble>k__BackingField;
    [CompilerGeneratedAttribute]
private static TextParser`1<TextSpan> <HexDigits>k__BackingField;
    [CompilerGeneratedAttribute]
private static TextParser`1<UInt32> <HexDigitsUInt32>k__BackingField;
    [CompilerGeneratedAttribute]
private static TextParser`1<ulong> <HexDigitsUInt64>k__BackingField;
    public static TextParser`1<TextSpan> Natural { get; }
    public static TextParser`1<UInt32> NaturalUInt32 { get; }
    public static TextParser`1<ulong> NaturalUInt64 { get; }
    public static TextParser`1<TextSpan> Integer { get; }
    public static TextParser`1<int> IntegerInt32 { get; }
    public static TextParser`1<long> IntegerInt64 { get; }
    public static TextParser`1<TextSpan> Decimal { get; }
    public static TextParser`1<decimal> DecimalDecimal { get; }
    public static TextParser`1<double> DecimalDouble { get; }
    public static TextParser`1<TextSpan> HexDigits { get; }
    public static TextParser`1<UInt32> HexDigitsUInt32 { get; }
    public static TextParser`1<ulong> HexDigitsUInt64 { get; }
    private static Numerics();
    [CompilerGeneratedAttribute]
public static TextParser`1<TextSpan> get_Natural();
    [CompilerGeneratedAttribute]
public static TextParser`1<UInt32> get_NaturalUInt32();
    [CompilerGeneratedAttribute]
public static TextParser`1<ulong> get_NaturalUInt64();
    [CompilerGeneratedAttribute]
public static TextParser`1<TextSpan> get_Integer();
    [CompilerGeneratedAttribute]
public static TextParser`1<int> get_IntegerInt32();
    [CompilerGeneratedAttribute]
public static TextParser`1<long> get_IntegerInt64();
    [CompilerGeneratedAttribute]
public static TextParser`1<TextSpan> get_Decimal();
    [CompilerGeneratedAttribute]
public static TextParser`1<decimal> get_DecimalDecimal();
    [CompilerGeneratedAttribute]
public static TextParser`1<double> get_DecimalDouble();
    [CompilerGeneratedAttribute]
public static TextParser`1<TextSpan> get_HexDigits();
    [CompilerGeneratedAttribute]
public static TextParser`1<UInt32> get_HexDigitsUInt32();
    [CompilerGeneratedAttribute]
public static TextParser`1<ulong> get_HexDigitsUInt64();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public static class Superpower.Parsers.QuotedString : object {
    private static TextParser`1<char> SqlStringContentChar;
    private static TextParser`1<char> CStringContentChar;
    [CompilerGeneratedAttribute]
private static TextParser`1<string> <SqlStyle>k__BackingField;
    [CompilerGeneratedAttribute]
private static TextParser`1<string> <CStyle>k__BackingField;
    public static TextParser`1<string> SqlStyle { get; }
    public static TextParser`1<string> CStyle { get; }
    private static QuotedString();
    [CompilerGeneratedAttribute]
public static TextParser`1<string> get_SqlStyle();
    [CompilerGeneratedAttribute]
public static TextParser`1<string> get_CStyle();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public static class Superpower.Parsers.Span : object {
    [CompilerGeneratedAttribute]
private static TextParser`1<TextSpan> <WhiteSpace>k__BackingField;
    [CompilerGeneratedAttribute]
private static TextParser`1<TextSpan> <NonWhiteSpace>k__BackingField;
    public static TextParser`1<TextSpan> WhiteSpace { get; }
    public static TextParser`1<TextSpan> NonWhiteSpace { get; }
    private static Span();
    public static TextParser`1<TextSpan> Length(int length);
    public static TextParser`1<TextSpan> EqualTo(string text);
    public static TextParser`1<TextSpan> EqualToIgnoreCase(string text);
    public static TextParser`1<TextSpan> EqualTo(char ch);
    public static TextParser`1<TextSpan> EqualToIgnoreCase(char ch);
    public static TextParser`1<TextSpan> WithoutAny(Func`2<char, bool> predicate);
    public static TextParser`1<TextSpan> WithAll(Func`2<char, bool> predicate);
    [CompilerGeneratedAttribute]
public static TextParser`1<TextSpan> get_WhiteSpace();
    [CompilerGeneratedAttribute]
public static TextParser`1<TextSpan> get_NonWhiteSpace();
    public static TextParser`1<TextSpan> Regex(string regex, RegexOptions options);
    public static TextParser`1<TextSpan> MatchedBy(TextParser`1<T> parser);
    public static TextParser`1<TextSpan> Except(string text);
    public static TextParser`1<TextSpan> ExceptIgnoreCase(string text);
    private static TextParser`1<TextSpan> Except(string text, StringComparison comparison);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public static class Superpower.Parsers.Token : object {
    public static TokenListParser`2<TKind, Token`1<TKind>> EqualTo(TKind kind);
    public static TokenListParser`2<TKind, Token`1[]> Sequence(TKind[] kinds);
    public static TokenListParser`2<TKind, Token`1<TKind>> EqualToValue(TKind kind, string value);
    public static TokenListParser`2<TKind, Token`1<TKind>> EqualToValueIgnoreCase(TKind kind, string value);
    public static TokenListParser`2<TKind, Token`1<TKind>> Matching(Func`2<TKind, bool> predicate, string name);
    private static TokenListParser`2<TKind, Token`1<TKind>> Matching(Func`2<TKind, bool> predicate, String[] expectations);
}
public class Superpower.TextParser`1 : MulticastDelegate {
    public TextParser`1(object object, IntPtr method);
    public virtual Result`1<T> Invoke(TextSpan input);
    public virtual IAsyncResult BeginInvoke(TextSpan input, AsyncCallback callback, object object);
    public virtual Result`1<T> EndInvoke(IAsyncResult result);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public abstract class Superpower.Tokenizer`1 : object {
    public TokenList`1<TKind> Tokenize(string source);
    public Result`1<TokenList`1<TKind>> TryTokenize(string source);
    protected virtual IEnumerable`1<Result`1<TKind>> Tokenize(TextSpan span);
    protected virtual IEnumerable`1<Result`1<TKind>> Tokenize(TextSpan span, TokenizationState`1<TKind> state);
    [NullableContextAttribute("0")]
protected static Result`1<char> SkipWhiteSpace(TextSpan span);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class Superpower.Tokenizers.TokenizerBuilder`1 : object {
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private List`1<Recognizer<TKind>> _recognizers;
    public TokenizerBuilder`1<TKind> Match(TextParser`1<U> recognizer, TKind kind, bool requireDelimiters);
    public TokenizerBuilder`1<TKind> Ignore(TextParser`1<U> ignored);
    public Tokenizer`1<TKind> Build();
}
public class Superpower.TokenListParser`2 : MulticastDelegate {
    public TokenListParser`2(object object, IntPtr method);
    public virtual TokenListParserResult`2<TKind, T> Invoke(TokenList`1<TKind> input);
    public virtual IAsyncResult BeginInvoke(TokenList`1<TKind> input, AsyncCallback callback, object object);
    public virtual TokenListParserResult`2<TKind, T> EndInvoke(IAsyncResult result);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal static class Superpower.Util.ArrayEnumerable : object {
    public static T[] Cons(T first, T[] rest);
    public static T[] Concat(T[] first, T[] rest);
    public static T[] Append(T[] first, T last);
}
internal static class Superpower.Util.CharInfo : object {
    public static bool IsLatinDigit(char ch);
    public static bool IsHexDigit(char ch);
    public static int HexValue(char ch);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal static class Superpower.Util.Friendly : object {
    public static string Pluralize(string noun, int count);
    public static string List(IEnumerable`1<string> items);
    public static string Clip(string value, int maxLength);
}
[CompilerGeneratedAttribute]
[EmbeddedAttribute]
internal class System.Runtime.CompilerServices.IsReadOnlyAttribute : Attribute {
}
[CompilerGeneratedAttribute]
[EmbeddedAttribute]
[AttributeUsageAttribute("27524")]
internal class System.Runtime.CompilerServices.NullableAttribute : Attribute {
    public Byte[] NullableFlags;
    public NullableAttribute(byte );
    public NullableAttribute(Byte[] );
}
[CompilerGeneratedAttribute]
[EmbeddedAttribute]
[AttributeUsageAttribute("5196")]
internal class System.Runtime.CompilerServices.NullableContextAttribute : Attribute {
    public byte Flag;
    public NullableContextAttribute(byte );
}
[CompilerGeneratedAttribute]
[EmbeddedAttribute]
[AttributeUsageAttribute("2")]
internal class System.Runtime.CompilerServices.RefSafetyRulesAttribute : Attribute {
    public int Version;
    public RefSafetyRulesAttribute(int );
}
