[CompilerGeneratedAttribute]
[EmbeddedAttribute]
internal class Microsoft.CodeAnalysis.EmbeddedAttribute : Attribute {
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal static class Syncfusion.Pdf.AdobeGlyphList : object {
    private static Dictionary`2<string, char> map;
    private static AdobeGlyphList();
    private static void Initialize();
    public static bool IsSupportedPdfName(string name);
    public static char GetUnicode(string names);
    private static char ParseHex(string hex);
    private static char GetUnicodeForName(string name);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Syncfusion.Pdf.AnnotationAddedArgs : EventArgs {
    private PdfAnnotation m_annotation;
    public PdfAnnotation Annotation { get; public set; }
    public PdfAnnotation get_Annotation();
    public void set_Annotation(PdfAnnotation value);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Syncfusion.Pdf.AnnotationPropertyChangedEventArgs : EventArgs {
    internal PdfAnnotation Annotation;
    internal string PropertyName;
    internal AnnotationPropertyChangedEventArgs(PdfAnnotation annotation, string propertyName);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Syncfusion.Pdf.AnnotationRemovedArgs : EventArgs {
    private PdfAnnotation m_annotation;
    public PdfAnnotation Annotation { get; public set; }
    public PdfAnnotation get_Annotation();
    public void set_Annotation(PdfAnnotation value);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Syncfusion.Pdf.ASCII85 : object {
    private Int64[] hex_indices;
    private Int64[] base_85_indices;
    private int m_specialCases;
    private int m_returns;
    private int m_dataSize;
    private int m_outputPointer;
    public Byte[] decode(Byte[] encodedData);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class Syncfusion.Pdf.Barcode.BarcodeException : Exception {
    public BarcodeException(string message);
    public BarcodeException(string message, Exception innerException);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Syncfusion.Pdf.Barcode.BarcodeSymbolTable : object {
    private char symbol;
    private int checkDigit;
    private Byte[] bars;
    public char Symbol { get; public set; }
    public int CheckDigit { get; public set; }
    public Byte[] Bars { get; public set; }
    public BarcodeSymbolTable(char symbol, int checkDigit, Byte[] bars);
    public BarcodeSymbolTable(int checkDigit, Byte[] bars);
    public char get_Symbol();
    public void set_Symbol(char value);
    public int get_CheckDigit();
    public void set_CheckDigit(int value);
    public Byte[] get_Bars();
    public void set_Bars(Byte[] value);
}
internal enum Syncfusion.Pdf.Barcode.EncodingControl : Enum {
    public int value__;
    public static EncodingControl Auto;
    public static EncodingControl ByteOnly;
    public static EncodingControl TextAndByte;
}
internal enum Syncfusion.Pdf.Barcode.EncodingMode : Enum {
    public int value__;
    public static EncodingMode Byte;
    public static EncodingMode Text;
    public static EncodingMode Numeric;
}
public enum Syncfusion.Pdf.Barcode.InputMode : Enum {
    public int value__;
    public static InputMode NumericMode;
    public static InputMode AlphaNumericMode;
    public static InputMode BinaryMode;
    public static InputMode MixingMode;
}
internal class Syncfusion.Pdf.Barcode.ModuleValue : ValueType {
    public bool IsBlack;
    public bool IsFilled;
    public bool IsPDP;
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class Syncfusion.Pdf.Barcode.Pdf417Barcode : PdfBidimensionalBarcode {
    private Pdf417ErrorCorrectionLevel m_errorCorrectionLevel;
    private int dataRows;
    private int dataColums;
    private Byte[] inputBinaryData;
    private int inputDataLength;
    private int textDataPosition;
    private List`1<int> codeWordsList;
    private EncodingMode encodingMode;
    private TextEncodingMode textEncodingMode;
    private EncodingControl encodingControl;
    private float barWidthPixel;
    private float rowHeightPixel;
    private float quietZonePixel;
    private Boolean[0...,0...] pdf417Matrix;
    private int errorCorrectionLength;
    private Int32[] errorCorrectionCodewords;
    private int defaultDataColumns;
    private bool autoTagcheck;
    private static int SwitchToTextMode;
    private static int SwitchToByteMode;
    private static int SwitchToNumericMode;
    private static int ShiftToByteMode;
    private static int SwitchToByteModeForSix;
    private static int MaxCodeWords;
    private static int DataRowsMax;
    private static int DataColumnsMax;
    private static int CodeWordLength;
    private Boolean[] StartPattern;
    private Boolean[] StopPattern;
    public SizeF Size { get; public set; }
    internal int DataRows { get; internal set; }
    internal int DataColumns { get; internal set; }
    internal int BarcodeColumns { get; }
    internal float BarcodeWidth { get; }
    internal float BarcodeHeight { get; }
    internal float RowHeight { get; internal set; }
    internal float QuietZoneNew { get; internal set; }
    public Pdf417ErrorCorrectionLevel ErrorCorrectionLevel { get; public set; }
    public virtual SizeF get_Size();
    public virtual void set_Size(SizeF value);
    internal int get_DataRows();
    internal void set_DataRows(int value);
    internal int get_DataColumns();
    internal void set_DataColumns(int value);
    internal int get_BarcodeColumns();
    internal float get_BarcodeWidth();
    internal float get_BarcodeHeight();
    internal float get_RowHeight();
    internal void set_RowHeight(float value);
    internal float get_QuietZoneNew();
    internal void set_QuietZoneNew(float value);
    public Pdf417ErrorCorrectionLevel get_ErrorCorrectionLevel();
    public void set_ErrorCorrectionLevel(Pdf417ErrorCorrectionLevel value);
    public virtual void Draw(PdfGraphics graphics);
    public virtual void Draw(PdfGraphics graphics, PointF location);
    public void Draw(PdfGraphics graphics, PointF location, SizeF size);
    public void Draw(PdfGraphics graphics, RectangleF rectangle);
    public void Draw(PdfGraphics graphics, float x, float y, float width, float height);
    public virtual void Draw(PdfPageBase page);
    public virtual void Draw(PdfPageBase page, PointF location);
    public void Draw(PdfPageBase page, float x, float y, float width, float height);
    public void Draw(PdfPageBase page, PointF location, SizeF size);
    public void Draw(PdfPageBase page, RectangleF rectangle);
    private SizeF GetBarcodeSize();
    internal float GetQuiteZone();
    internal Boolean[0...,0...] Create417BarcodeMatrix();
    internal void CodewordToModules(int Row, int Col, int Codeword, Boolean[0...,0...] Matrix);
    internal void CalculateErrorCorrection(Int32[] Codewords);
    internal void EncodeTextData(Byte[] byteData);
    internal void DetermineCorrectionLevel();
    private int CountText();
    private int CountPunctuation(int currentTextCount);
    private int CountBytes();
    private void EncodeTextSegment(int TotalCount);
    private void EncodeByteSegment(int Count);
    private void DataEncoding();
}
public enum Syncfusion.Pdf.Barcode.Pdf417ErrorCorrectionLevel : Enum {
    public int value__;
    public static Pdf417ErrorCorrectionLevel Level0;
    public static Pdf417ErrorCorrectionLevel Level1;
    public static Pdf417ErrorCorrectionLevel Level2;
    public static Pdf417ErrorCorrectionLevel Level3;
    public static Pdf417ErrorCorrectionLevel Level4;
    public static Pdf417ErrorCorrectionLevel Level5;
    public static Pdf417ErrorCorrectionLevel Level6;
    public static Pdf417ErrorCorrectionLevel Level7;
    public static Pdf417ErrorCorrectionLevel Level8;
    public static Pdf417ErrorCorrectionLevel Auto;
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal static class Syncfusion.Pdf.Barcode.Pdf417Tables : object {
    internal static Int64[] Factorial;
    internal static Byte[] TextToUpper;
    internal static Byte[] TextToLower;
    internal static Byte[] TextToMixed;
    internal static Byte[] TextToPunctuation;
    internal static Int32[][] ErrorCorrectionTables;
    internal static Int16[0...,0...] CodewordTable;
    private static Pdf417Tables();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class Syncfusion.Pdf.Barcode.PdfBarcode : object {
    protected internal RectangleF bounds;
    private PdfColor backColor;
    private PdfColor barColor;
    private PdfColor textColor;
    private float narrowBarWidth;
    private float wideBarWidth;
    private PointF location;
    protected internal SizeF size;
    private string text;
    private PdfBarcodeQuietZones quietZones;
    private float width;
    private float height;
    protected float barHeight;
    private string extendedText;
    internal bool barHeightEnabled;
    internal bool isCustomSize;
    public PdfColor BackColor { get; public set; }
    public PdfColor BarColor { get; public set; }
    public PdfColor TextColor { get; public set; }
    public float NarrowBarWidth { get; public set; }
    public string Text { get; public set; }
    public PointF Location { get; public set; }
    public PdfBarcodeQuietZones QuietZone { get; public set; }
    public float BarHeight { get; public set; }
    public SizeF Size { get; public set; }
    public RectangleF Bounds { get; public set; }
    internal string ExtendedText { get; internal set; }
    public PdfBarcode(string text);
    public PdfColor get_BackColor();
    public void set_BackColor(PdfColor value);
    public PdfColor get_BarColor();
    public void set_BarColor(PdfColor value);
    public PdfColor get_TextColor();
    public void set_TextColor(PdfColor value);
    public float get_NarrowBarWidth();
    public void set_NarrowBarWidth(float value);
    public string get_Text();
    public void set_Text(string value);
    public PointF get_Location();
    public void set_Location(PointF value);
    public PdfBarcodeQuietZones get_QuietZone();
    public void set_QuietZone(PdfBarcodeQuietZones value);
    public float get_BarHeight();
    public void set_BarHeight(float value);
    public SizeF get_Size();
    public void set_Size(SizeF value);
    public RectangleF get_Bounds();
    public void set_Bounds(RectangleF value);
    internal string get_ExtendedText();
    internal void set_ExtendedText(string value);
    protected internal virtual bool Validate(string data);
    protected internal virtual SizeF GetSizeValue();
    private void Initialize();
}
public class Syncfusion.Pdf.Barcode.PdfBarcodeQuietZones : object {
    private static float DEF_MARGIN;
    private float right;
    private float top;
    private float left;
    private float bottom;
    public float Right { get; public set; }
    public float Top { get; public set; }
    public float Left { get; public set; }
    public float Bottom { get; public set; }
    public float All { get; public set; }
    public bool IsAll { get; }
    public float get_Right();
    public void set_Right(float value);
    public float get_Top();
    public void set_Top(float value);
    public float get_Left();
    public void set_Left(float value);
    public float get_Bottom();
    public void set_Bottom(float value);
    public float get_All();
    public void set_All(float value);
    public bool get_IsAll();
}
public enum Syncfusion.Pdf.Barcode.PdfBarcodeTextAlignment : Enum {
    public int value__;
    public static PdfBarcodeTextAlignment Left;
    public static PdfBarcodeTextAlignment Center;
    public static PdfBarcodeTextAlignment Right;
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public abstract class Syncfusion.Pdf.Barcode.PdfBidimensionalBarcode : object {
    private string text;
    private PdfColor backColor;
    private PointF location;
    private PdfBarcodeQuietZones quietZone;
    private float xDimension;
    private SizeF size;
    private PdfColor foreColor;
    public SizeF Size { get; public set; }
    public string Text { get; public set; }
    public PdfColor BackColor { get; public set; }
    public PdfBarcodeQuietZones QuietZone { get; public set; }
    public float XDimension { get; public set; }
    public PointF Location { get; public set; }
    public PdfColor ForeColor { get; public set; }
    public virtual SizeF get_Size();
    public virtual void set_Size(SizeF value);
    public string get_Text();
    public void set_Text(string value);
    public PdfColor get_BackColor();
    public void set_BackColor(PdfColor value);
    public PdfBarcodeQuietZones get_QuietZone();
    public void set_QuietZone(PdfBarcodeQuietZones value);
    public float get_XDimension();
    public void set_XDimension(float value);
    public PointF get_Location();
    public void set_Location(PointF value);
    public PdfColor get_ForeColor();
    public void set_ForeColor(PdfColor value);
    internal Byte[] GetData();
    public abstract virtual void Draw(PdfGraphics graphics);
    public abstract virtual void Draw(PdfGraphics graphics, PointF location);
    public abstract virtual void Draw(PdfPageBase page, PointF location);
    public abstract virtual void Draw(PdfPageBase page);
}
public class Syncfusion.Pdf.Barcode.PdfCodabarBarcode : PdfUnidimensionalBarcode {
    [NullableContextAttribute("1")]
public PdfCodabarBarcode(string text);
    private void Initialize();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class Syncfusion.Pdf.Barcode.PdfCode11Barcode : PdfUnidimensionalBarcode {
    public PdfCode11Barcode(string text);
    protected internal virtual Char[] CalculateCheckDigit();
    private void Initialize();
    private char GetSymbol(int checkValue);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class Syncfusion.Pdf.Barcode.PdfCode128ABarcode : PdfUnidimensionalBarcode {
    public PdfCode128ABarcode(string text);
    protected internal virtual Char[] CalculateCheckDigit();
    protected internal virtual bool Validate(string data);
    protected void Initialize();
    internal char GetSymbol(int checkValue);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class Syncfusion.Pdf.Barcode.PdfCode128Barcode : PdfUnidimensionalBarcode {
    private static bool isnumb;
    public PdfCode128Barcode(string text);
    protected internal virtual Char[] CalculateCheckDigit();
    internal virtual string GetTextToEncode();
    protected string GetDataToEncode(string originalData);
    private void Initialize();
    private char GetSymbol(int checkValue);
    internal virtual List`1<Byte[]> GetTextToEncodeList();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class Syncfusion.Pdf.Barcode.PdfCode128BBarcode : PdfUnidimensionalBarcode {
    public PdfCode128BBarcode(string text);
    protected internal virtual Char[] CalculateCheckDigit();
    private void Initialize();
    internal char GetSymbol(int checkValue);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class Syncfusion.Pdf.Barcode.PdfCode128CBarcode : PdfUnidimensionalBarcode {
    public PdfCode128CBarcode(string text);
    protected internal virtual Char[] CalculateCheckDigit();
    protected internal virtual bool Validate(string data);
    internal virtual string GetTextToEncode();
    internal virtual List`1<Byte[]> GetTextToEncodeList();
    protected string GetDataToEncode(string originalData);
    private void Initialize();
    private char GetSymbol(int checkValue);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class Syncfusion.Pdf.Barcode.PdfCode32Barcode : PdfCode39Barcode {
    private Char[] checkSumSymbols;
    private bool isTextEncoded;
    private string encodedText;
    private static int m_encodedtextLength;
    public PdfCode32Barcode(string text);
    protected internal virtual Char[] CalculateCheckDigit();
    protected string ObtainBarcodeSymbols();
    protected string GetDataToEncode(string originalData);
    internal virtual string GetTextToEncode();
    private void InitializeCode32();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class Syncfusion.Pdf.Barcode.PdfCode39Barcode : PdfUnidimensionalBarcode {
    public PdfCode39Barcode(string text);
    internal void Initialize();
    protected internal virtual Char[] CalculateCheckDigit();
    private char GetSymbol(int checkValue);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class Syncfusion.Pdf.Barcode.PdfCode39ExtendedBarcode : PdfCode39Barcode {
    private Dictionary`2<char, Char[]> extendedCodes;
    public PdfCode39ExtendedBarcode(string text);
    protected internal virtual Char[] CalculateCheckDigit();
    private void InitializeCode39Extended();
    private char GetSymbol(int checkValue);
    protected internal virtual void GetExtendedTextValue();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class Syncfusion.Pdf.Barcode.PdfCode93Barcode : PdfUnidimensionalBarcode {
    public PdfCode93Barcode(string text);
    internal void Initialize();
    protected internal virtual Char[] CalculateCheckDigit();
    protected internal Char[] GetCheckSumSymbols();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class Syncfusion.Pdf.Barcode.PdfCode93ExtendedBarcode : PdfCode93Barcode {
    private Dictionary`2<char, Char[]> extendedCodes;
    public PdfCode93ExtendedBarcode(string text);
    protected internal virtual Char[] CalculateCheckDigit();
    protected internal Char[] GetCheckSumSymbols();
    private void InitializeCode93Extended();
    private void GetExtendedText();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class Syncfusion.Pdf.Barcode.PdfCodeUpcBarcode : PdfUnidimensionalBarcode {
    public PdfCodeUpcBarcode(string text);
    protected internal virtual Char[] CalculateCheckDigit();
    private void Initialize();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class Syncfusion.Pdf.Barcode.PdfDataMatrixBarcode : PdfBidimensionalBarcode {
    private PdfDataMatrixEncoding dataMatrixEncoding;
    private PdfDataMatrixSize size;
    internal Byte[0...,0...] dataMatrixArray;
    private PdfDataMatrixSymbolAttribute[] symbolAttributes;
    private PdfDataMatrixSymbolAttribute symbolAttribute;
    private Int32[] log;
    private Int32[] aLog;
    private Byte[] polynomial;
    private int blockLength;
    private static int dpi;
    private int m_quiteZoneLeft;
    private int m_quiteZoneRight;
    private int m_quiteZoneTop;
    private int m_quiteZoneBottom;
    private bool autoTagcheck;
    public PdfDataMatrixEncoding Encoding { get; public set; }
    public PdfDataMatrixSize Size { get; public set; }
    internal int ActualRows { get; }
    internal int ActualColumns { get; }
    public PdfDataMatrixBarcode(string text);
    public PdfDataMatrixEncoding get_Encoding();
    public void set_Encoding(PdfDataMatrixEncoding value);
    public PdfDataMatrixSize get_Size();
    public void set_Size(PdfDataMatrixSize value);
    internal int get_ActualRows();
    internal int get_ActualColumns();
    private void Initialize();
    private void CreateLogArrays();
    private void CreatePolynomial(int step);
    private void CreateMatrix(Int32[] codeword);
    private void ErrorCorrectingCode200Placement(Int32[] array, int numRow, int numColumn);
    private void ErrorCorrectingCode200PlacementCornerA(Int32[] array, int numRow, int numColumn, int place);
    private void ErrorCorrectingCode200PlacementCornerB(Int32[] array, int numRow, int numColumn, int place);
    private void ErrorCorrectingCode200PlacementCornerC(Int32[] array, int numRow, int numColumn, int place);
    private void ErrorCorrectingCode200PlacementCornerD(Int32[] array, int numRow, int numColumn, int place);
    private void ErrorCorrectingCode200PlacementBlock(Int32[] array, int numRow, int numColumn, int row, int column, int place);
    private void ErrorCorrectingCode200PlacementBit(Int32[] array, int numRow, int numColumn, int row, int column, int place, char character);
    internal void BuildDataMatrix();
    private Int32[] PrepareCodeword(Byte[] dataCodeword);
    private Byte[] DataMatrixBaseEncoder(Byte[] dataCodeword);
    private byte ComputeBase256Codeword(int codeWordValue, int index);
    private Byte[] DataMatrixASCIINumericEncoder(Byte[] dataCodeword);
    private Byte[] DataMatrixASCIIEncoder(Byte[] dataCodeword);
    private Int32[] ComputeErrorCorrection(Byte[]& codeword);
    private byte ErrorCorrectionCodeDoublify(byte i, int j);
    private byte ErrorCorrectionCodeProduct(byte i, int j);
    private static byte ErrorCorrectionCodeSum(byte i, byte j);
    private void PadCodewords(int dataCodeWordLength, Byte[] temp, Byte[]& codeword);
    private Byte[] PrepareDataCodeword(Byte[] dataCodeword);
    private void AddQuiteZone(Byte[0...,0...] dataMatrix);
    private int GetQuiteZone();
    private PdfDataMatrixSize FindDataMatrixSize(int width, int height);
    public virtual void Draw(PdfGraphics graphics);
    public virtual void Draw(PdfGraphics graphics, PointF location);
    public void Draw(PdfGraphics graphics, PointF location, SizeF Size);
    public void Draw(PdfGraphics graphics, RectangleF Rectangle);
    public void Draw(PdfGraphics graphics, float x, float y, float Width, float Height);
    public virtual void Draw(PdfPageBase page, PointF location);
    public void Draw(PdfPageBase page, PointF location, SizeF size);
    public void Draw(PdfPageBase page, RectangleF rectangle);
    public void Draw(PdfPageBase page, float x, float y, float width, float height);
    public virtual void Draw(PdfPageBase page);
}
public enum Syncfusion.Pdf.Barcode.PdfDataMatrixEncoding : Enum {
    public int value__;
    public static PdfDataMatrixEncoding Auto;
    public static PdfDataMatrixEncoding ASCII;
    public static PdfDataMatrixEncoding ASCIINumeric;
    public static PdfDataMatrixEncoding Base256;
}
public enum Syncfusion.Pdf.Barcode.PdfDataMatrixSize : Enum {
    public int value__;
    public static PdfDataMatrixSize Auto;
    public static PdfDataMatrixSize Size10x10;
    public static PdfDataMatrixSize Size12x12;
    public static PdfDataMatrixSize Size14x14;
    public static PdfDataMatrixSize Size16x16;
    public static PdfDataMatrixSize Size18x18;
    public static PdfDataMatrixSize Size20x20;
    public static PdfDataMatrixSize Size22x22;
    public static PdfDataMatrixSize Size24x24;
    public static PdfDataMatrixSize Size26x26;
    public static PdfDataMatrixSize Size32x32;
    public static PdfDataMatrixSize Size36x36;
    public static PdfDataMatrixSize Size40x40;
    public static PdfDataMatrixSize Size44x44;
    public static PdfDataMatrixSize Size48x48;
    public static PdfDataMatrixSize Size52x52;
    public static PdfDataMatrixSize Size64x64;
    public static PdfDataMatrixSize Size72x72;
    public static PdfDataMatrixSize Size80x80;
    public static PdfDataMatrixSize Size88x88;
    public static PdfDataMatrixSize Size96x96;
    public static PdfDataMatrixSize Size104x104;
    public static PdfDataMatrixSize Size120x120;
    public static PdfDataMatrixSize Size132x132;
    public static PdfDataMatrixSize Size144x144;
    public static PdfDataMatrixSize Size8x18;
    public static PdfDataMatrixSize Size8x32;
    public static PdfDataMatrixSize Size12x26;
    public static PdfDataMatrixSize Size12x36;
    public static PdfDataMatrixSize Size16x36;
    public static PdfDataMatrixSize Size16x48;
}
internal class Syncfusion.Pdf.Barcode.PdfDataMatrixSymbolAttribute : ValueType {
    internal int SymbolRow;
    internal int SymbolColumn;
    internal int HoriDataRegion;
    internal int VertDataRegion;
    internal int DataCodewords;
    internal int CorrectionCodewords;
    internal int InterleavedBlock;
    internal int InterleavedDataBlock;
    internal PdfDataMatrixSymbolAttribute(int m_SymbolRow, int m_SymbolColumn, int m_horiDataRegions, int m_vertDataRegions, int m_dataCodewords, int m_correctionCodewords, int m_interleavedBlock, int m_interleavedDataBlock);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class Syncfusion.Pdf.Barcode.PdfEan13Barcode : PdfUnidimensionalBarcode {
    private float minimumAllowableScale;
    private float maximumAllowableScale;
    private float fWidth;
    private float fHeight;
    private float fontSize;
    private float scale;
    private int quietZonePixel;
    private String[] OddLeft;
    private String[] EvenLeft;
    private String[] Right;
    private string QuiteZone;
    private string LeadTail;
    private string Separator;
    private string countryCode;
    private string manufacturerCode;
    private string productCode;
    private string checksumDigit;
    internal int QuietZoneNew { get; internal set; }
    internal float MinimumAllowableScale { get; }
    internal float MaximumAllowableScale { get; }
    internal float Width { get; }
    internal float Height { get; }
    internal float FontSize { get; }
    internal float Scale { get; internal set; }
    internal string CountryCode { get; internal set; }
    internal string ManufacturerCode { get; internal set; }
    internal string ProductCode { get; internal set; }
    internal string ChecksumDigit { get; internal set; }
    public PdfEan13Barcode(string text);
    internal int get_QuietZoneNew();
    internal void set_QuietZoneNew(int value);
    internal float get_MinimumAllowableScale();
    internal float get_MaximumAllowableScale();
    internal float get_Width();
    internal float get_Height();
    internal float get_FontSize();
    internal float get_Scale();
    internal void set_Scale(float value);
    internal string get_CountryCode();
    internal void set_CountryCode(string value);
    internal string get_ManufacturerCode();
    internal void set_ManufacturerCode(string value);
    internal string get_ProductCode();
    internal void set_ProductCode(string value);
    internal string get_ChecksumDigit();
    internal void set_ChecksumDigit(string value);
    public virtual void Draw(PdfGraphics graphics);
    public virtual void Draw(PdfGraphics graphics, PointF location);
    public void Draw(PdfGraphics graphics, PointF location, SizeF size);
    public void Draw(PdfGraphics graphics, RectangleF rectangle);
    public void Draw(PdfGraphics graphics, float x, float y, float width, float height);
    public void Draw(PdfPageBase page, float x, float y, float width, float height);
    public void Draw(PdfPageBase page, PointF location, SizeF size);
    public void Draw(PdfPageBase page, RectangleF rectangle);
    public virtual void Draw(PdfPageBase page);
    public virtual void Draw(PdfPageBase page, PointF location);
    internal int GetQuiteZone();
    private string ConvertLeftPattern(string sLeft);
    private string CountryCode0(string sLeft);
    private string CountryCode1(string sLeft);
    private string CountryCode2(string sLeft);
    private string CountryCode3(string sLeft);
    private string CountryCode4(string sLeft);
    private string CountryCode5(string sLeft);
    private string CountryCode6(string sLeft);
    private string CountryCode7(string sLeft);
    private string CountryCode8(string sLeft);
    private string CountryCode9(string sLeft);
    private string ConvertToDigitPatterns(string inputNumber, String[] patterns);
    internal void CalculateChecksumDigit();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class Syncfusion.Pdf.Barcode.PdfEan8Barcode : PdfUnidimensionalBarcode {
    private String[] codesA;
    private String[] codesC;
    private string data;
    private string encodedData;
    private float fontSize;
    private int quietZonePixel;
    internal int QuietZoneNew { get; internal set; }
    public PdfEan8Barcode(string text);
    internal int get_QuietZoneNew();
    internal void set_QuietZoneNew(int value);
    public virtual void Draw(PdfGraphics graphics);
    public virtual void Draw(PdfGraphics graphics, PointF location);
    public void Draw(PdfGraphics graphics, PointF location, SizeF size);
    public void Draw(PdfGraphics graphics, RectangleF rectangle);
    public void Draw(PdfGraphics graphics, float x, float y, float width, float height);
    public void Draw(PdfPageBase page, float x, float y, float width, float height);
    public void Draw(PdfPageBase page, PointF location, SizeF size);
    public void Draw(PdfPageBase page, RectangleF rectangle);
    public virtual void Draw(PdfPageBase page);
    public virtual void Draw(PdfPageBase page, PointF location);
    internal int GetQuiteZone();
    protected bool CheckNumericOnly(string data);
    internal string GetEncoding();
    private string CheckDigit(string data);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Syncfusion.Pdf.Barcode.PdfErrorCorrectionCodewords : object {
    private int length;
    private int eccw;
    private int databits;
    private String[] dataCodeWord;
    private Int32[] gx;
    private Int32[] alpha;
    private Int32[] decimalValue;
    private PdfQRBarcodeValues qrBarcodeValues;
    internal String[] DC { get; internal set; }
    internal int DataBits { get; internal set; }
    internal int ECCW { get; internal set; }
    public PdfErrorCorrectionCodewords(QRCodeVersion version, PdfErrorCorrectionLevel correctionLevel);
    internal void set_DC(String[] value);
    internal String[] get_DC();
    internal void set_DataBits(int value);
    internal int get_DataBits();
    internal void set_ECCW(int value);
    internal int get_ECCW();
    internal String[] GetERCW();
    private void BinaryToDecimal(String[] inString);
    private String[] ConvertDecimalToBinary(Int32[] decimalRepresentation);
    private Int32[] CalculatePolynomialDivision();
    private Dictionary`2<int, int> XORPolynoms(Dictionary`2<int, int> messagePolynom, Dictionary`2<int, int> resPolynom);
    private Dictionary`2<int, int> MultiplyGeneratorPolynomByLeadterm(Dictionary`2<int, int> genPolynom, int leadTermCoefficient, int lowerExponentBy);
    private Dictionary`2<int, int> ConvertToDecimalNotation(Dictionary`2<int, int> poly);
    private Dictionary`2<int, int> ConvertToAlphaNotation(Dictionary`2<int, int> polynom);
    private int FindLargestExponent(Dictionary`2<int, int> polynom);
    private int GetIntValFromAlphaExp(int element, Int32[] alpha);
    private int FindElement(int element, Int32[] alpha);
    private Int32[] GetElement(Int32[] element, Int32[] alpha);
}
public enum Syncfusion.Pdf.Barcode.PdfErrorCorrectionLevel : Enum {
    public int value__;
    public static PdfErrorCorrectionLevel Low;
    public static PdfErrorCorrectionLevel Medium;
    public static PdfErrorCorrectionLevel Quartile;
    public static PdfErrorCorrectionLevel High;
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class Syncfusion.Pdf.Barcode.PdfGS1Code128Barcode : PdfUnidimensionalBarcode {
    public PdfGS1Code128Barcode(string text);
    protected internal virtual Char[] CalculateCheckDigit();
    internal virtual string GetTextToEncode();
    protected string GetDataToEncode(string originalData);
    private void Initialize();
    private char GetSymbol(int checkValue);
    internal virtual List`1<Byte[]> GetTextToEncodeList();
    private int GetAILength(string ai);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class Syncfusion.Pdf.Barcode.PdfQRBarcode : PdfBidimensionalBarcode {
    private QRCodeVersion version;
    internal int noOfModules;
    internal ModuleValue[0...,0...] moduleValue;
    internal ModuleValue[0...,0...] dataAllocationValues;
    private bool isMixMode;
    private bool mixVersionERC;
    private string mixExecutablePart;
    private string mixRemainingPart;
    private int totalBits;
    private int mixDataCount;
    private List`1<string> text;
    private bool autoTagcheck;
    private List`1<InputMode> mode;
    internal bool isXdimension;
    private InputMode inputMode;
    private PdfErrorCorrectionLevel errorCorrectionLevel;
    private QRCodeLogo logo;
    private int dataBits;
    private Int32[] blocks;
    private bool isUserMentionedMode;
    private bool isUserMentionedVersion;
    private bool isUserMentionedErrorCorrectionLevel;
    private bool isEci;
    private int eciAssignmentNumber;
    private PdfQRBarcodeValues qrBarcodeValues;
    private static int dpi;
    private int defaultQuiteZone;
    private bool chooseDefaultMode;
    public QRCodeVersion Version { get; public set; }
    public PdfErrorCorrectionLevel ErrorCorrectionLevel { get; public set; }
    public InputMode InputMode { get; public set; }
    public SizeF Size { get; public set; }
    internal QRCodeLogo Logo { get; public set; }
    public QRCodeVersion get_Version();
    public void set_Version(QRCodeVersion value);
    public PdfErrorCorrectionLevel get_ErrorCorrectionLevel();
    public void set_ErrorCorrectionLevel(PdfErrorCorrectionLevel value);
    public InputMode get_InputMode();
    public void set_InputMode(InputMode value);
    public virtual SizeF get_Size();
    public virtual void set_Size(SizeF value);
    internal QRCodeLogo get_Logo();
    public void set_Logo(QRCodeLogo value);
    public virtual void Draw(PdfGraphics graphics);
    public virtual void Draw(PdfGraphics graphics, PointF location);
    public void Draw(PdfGraphics graphics, PointF location, SizeF size);
    public void Draw(PdfGraphics graphics, RectangleF rectangle);
    public void Draw(PdfGraphics graphics, float a, float b, float width, float height);
    public virtual void Draw(PdfPageBase page, PointF location);
    public void Draw(PdfPageBase page, PointF location, SizeF size);
    public void Draw(PdfPageBase page, RectangleF rectangle);
    public void Draw(PdfPageBase page, float x, float y, float width, float height);
    public virtual void Draw(PdfPageBase page);
    internal void GenerateValues();
    private void AddQuietZone();
    private void DrawPDP(int x, int y);
    private void DrawTimingPattern();
    private void DrawAlignmentPattern(int x, int y);
    private Boolean[] EncodeData();
    private void DataAllocationAndMasking(Boolean[] data);
    private void DrawFormatInformation();
    private SizeF GetBarcodeSize();
    private void Initialize();
    private String[] SplitCodeWord(String[0...,0...] encodeData, int block, int count);
    private String[0...,0...] CreateBlocks(List`1<bool> encodeData, int noOfBlocks);
    private Boolean[] IntToBoolArray(int number, int noOfBits);
    private Boolean[] StringToBoolArray(string numberInString, int noOfBits);
    private Int32[] GetAlignmentPatternCoOrdinates();
    private void AllocateFormatAndVersionInformation();
    internal int GetQuiteZone();
    private bool IsCP437Character(char inputChar);
    private bool IsISO8859_2Character(char inputChar);
    private bool IsISO8859_3Character(char inputChar);
    private bool IsISO8859_4Character(char inputChar);
    private bool IsISO8859_5Character(char inputChar);
    private bool IsISO8859_6Character(char inputChar);
    private bool IsISO8859_7Character(char inputChar);
    private bool IsISO8859_8Character(char inputChar);
    private bool IsISO8859_11Character(char inputChar);
    private bool IsWindows1250Character(char inputChar);
    private bool IsWindows1251Character(char inputChar);
    private bool IsWindows1252Character(char inputChar);
    private bool IsWindows1256Character(char inputChar);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Syncfusion.Pdf.Barcode.PdfQRBarcodeValues : object {
    private QRCodeVersion version;
    private PdfErrorCorrectionLevel errorCorrectionLevel;
    private int numberOfDataCodeWord;
    private int numberOfErrorCorrectionCodeWords;
    private Int32[] _numberOfErrorCorrectionBlocks;
    private int end;
    private int dataCapacity;
    private Byte[] _formatInformation;
    private Byte[] _versionInformation;
    private static Int32[] numberOfErrorCorrectingCodeWords;
    private String[] CP437CharSet;
    private String[] iSO8859_2CharSet;
    private String[] iSO8859_3CharSet;
    private String[] iSO8859_4CharSet;
    private String[] windows1250CharSet;
    private String[] windows1251CharSet;
    private String[] windows1252CharSet;
    private String[] windows1256CharSet;
    private Int32[] CP437ReplaceNumber;
    private Int32[] iSO8859_2ReplaceNumber;
    private Int32[] iSO8859_3ReplaceNumber;
    private Int32[] iSO8859_4ReplaceNumber;
    private Int32[] windows1250ReplaceNumber;
    private Int32[] windows1251ReplaceNumber;
    private Int32[] windows1252ReplaceNumber;
    private Int32[] windows1256ReplaceNumber;
    private static Int32[] endValues;
    private static Int32[] dataCapacityValues;
    internal static Int32[] numericDataCapacityLow;
    internal static Int32[] numericDataCapacityMedium;
    internal static Int32[] numericDataCapacityQuartile;
    internal static Int32[] numericDataCapacityHigh;
    internal static Int32[] alphanumericDataCapacityLow;
    internal static Int32[] alphanumericDataCapacityMedium;
    internal static Int32[] alphanumericDataCapacityQuartile;
    internal static Int32[] alphanumericDataCapacityHigh;
    internal static Int32[] binaryDataCapacityLow;
    internal static Int32[] binaryDataCapacityMedium;
    internal static Int32[] binaryDataCapacityQuartile;
    internal static Int32[] binaryDataCapacityHigh;
    internal static Int32[] mixedDataCapacityLow;
    internal static Int32[] mixedDataCapacityMedium;
    internal static Int32[] mixedDataCapacityQuartile;
    internal static Int32[] mixedDataCapacityHigh;
    internal int NumberOfDataCodeWord { get; private set; }
    internal int NumberOfErrorCorrectingCodeWords { get; private set; }
    internal Int32[] NumberOfErrorCorrectionBlocks { get; private set; }
    internal int End { get; private set; }
    internal int DataCapacity { get; private set; }
    internal Byte[] FormatInformation { get; private set; }
    internal Byte[] VersionInformation { get; private set; }
    public PdfQRBarcodeValues(QRCodeVersion version, PdfErrorCorrectionLevel errorCorrectionLevel);
    private static PdfQRBarcodeValues();
    internal int get_NumberOfDataCodeWord();
    private void set_NumberOfDataCodeWord(int value);
    internal int get_NumberOfErrorCorrectingCodeWords();
    private void set_NumberOfErrorCorrectingCodeWords(int value);
    internal Int32[] get_NumberOfErrorCorrectionBlocks();
    private void set_NumberOfErrorCorrectionBlocks(Int32[] value);
    internal int get_End();
    private void set_End(int value);
    internal int get_DataCapacity();
    private void set_DataCapacity(int value);
    internal Byte[] get_FormatInformation();
    private void set_FormatInformation(Byte[] value);
    internal Byte[] get_VersionInformation();
    private void set_VersionInformation(Byte[] value);
    internal int GetAlphanumericvalues(char Value);
    private int ObtainNumberOfDataCodeWord();
    private int ObtainNumberOfErrorCorrectionCodeWords();
    private Int32[] ObtainNumberOfErrorCorrectionBlocks();
    private int ObtainEnd();
    private int ObtainDataCapacity();
    private Byte[] ObtainFormatInformation();
    private Byte[] ObtainVersionInformation();
    internal int GetNumberInEci(char inputChar);
    internal static int GetNumericDataCapacity(QRCodeVersion version, PdfErrorCorrectionLevel errorCorrectionLevel);
    internal static int GetAlphanumericDataCapacity(QRCodeVersion version, PdfErrorCorrectionLevel errorCorrectionLevel);
    internal static int GetBinaryDataCapacity(QRCodeVersion version, PdfErrorCorrectionLevel errorCorrectionLevel);
    internal static int GetMixedDataCapacity(QRCodeVersion version, PdfErrorCorrectionLevel errorCorrectionLevel);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public abstract class Syncfusion.Pdf.Barcode.PdfUnidimensionalBarcode : PdfBarcode {
    private static float UpcBarWidth;
    internal int barcodeSpaceCount;
    internal bool isCheckDigitAdded;
    internal bool continuous;
    protected bool check;
    private bool autoTagcheck;
    private Dictionary`2<char, BarcodeSymbolTable> barcodeSymbols;
    private Dictionary`2<string, BarcodeSymbolTable> barcodeSymbolsString;
    internal TextLocation textDisplayLocation;
    private PdfFont _font;
    internal char startSymbol;
    internal char stopSymbol;
    private string validatorExpression;
    private Regex codeValidator;
    private bool showCheckDigit;
    private bool enableCheckDigit;
    internal float interCharacterGap;
    internal float barcodeToTextGapHeight;
    private string barcodeEncodeText;
    private PdfBarcodeTextAlignment textAlignment;
    private bool _encodeStartStopSymbols;
    internal bool isFontModified;
    private static int dpi;
    private bool isContainsSmallSize;
    public PdfFont Font { get; public set; }
    public TextLocation TextDisplayLocation { get; public set; }
    public bool ShowCheckDigit { get; public set; }
    public bool EnableCheckDigit { get; public set; }
    public float BarcodeToTextGapHeight { get; public set; }
    public PdfBarcodeTextAlignment TextAlignment { get; public set; }
    public bool EncodeStartStopSymbols { get; public set; }
    internal Dictionary`2<char, BarcodeSymbolTable> BarcodeSymbols { get; internal set; }
    internal Dictionary`2<string, BarcodeSymbolTable> BarcodeSymbolsString { get; internal set; }
    internal char StartSymbol { get; internal set; }
    internal char StopSymbol { get; internal set; }
    internal string ValidatorExpression { get; internal set; }
    internal float IntercharacterGap { get; internal set; }
    public PdfFont get_Font();
    public void set_Font(PdfFont value);
    public TextLocation get_TextDisplayLocation();
    public void set_TextDisplayLocation(TextLocation value);
    public bool get_ShowCheckDigit();
    public void set_ShowCheckDigit(bool value);
    public bool get_EnableCheckDigit();
    public void set_EnableCheckDigit(bool value);
    public float get_BarcodeToTextGapHeight();
    public void set_BarcodeToTextGapHeight(float value);
    public PdfBarcodeTextAlignment get_TextAlignment();
    public void set_TextAlignment(PdfBarcodeTextAlignment value);
    public bool get_EncodeStartStopSymbols();
    public void set_EncodeStartStopSymbols(bool value);
    internal Dictionary`2<char, BarcodeSymbolTable> get_BarcodeSymbols();
    internal void set_BarcodeSymbols(Dictionary`2<char, BarcodeSymbolTable> value);
    internal Dictionary`2<string, BarcodeSymbolTable> get_BarcodeSymbolsString();
    internal void set_BarcodeSymbolsString(Dictionary`2<string, BarcodeSymbolTable> value);
    internal char get_StartSymbol();
    internal void set_StartSymbol(char value);
    internal char get_StopSymbol();
    internal void set_StopSymbol(char value);
    internal string get_ValidatorExpression();
    internal void set_ValidatorExpression(string value);
    internal float get_IntercharacterGap();
    internal void set_IntercharacterGap(float value);
    public virtual void Draw(PdfGraphics graphics);
    public void Draw(PdfGraphics graphics, PointF location);
    public void Draw(PdfGraphics graphics, PointF location, SizeF size);
    public void Draw(PdfGraphics graphics, RectangleF rectangle);
    public void Draw(PdfGraphics graphics, float x, float y, float width, float height);
    public virtual void Draw(PdfPageBase page, PointF location);
    public void Draw(PdfPageBase page, PointF location, SizeF size);
    public void Draw(PdfPageBase page, RectangleF rectangle);
    public void Draw(PdfPageBase page, float x, float y, float width, float height);
    public virtual void Draw(PdfPageBase page);
    internal void DrawRevamped(PdfGraphics graphics, PointF location);
    internal void DrawRevamped(PdfPageBase page, PointF location);
    internal void DrawRevamped(PdfGraphics graphics, float x, float y, float width, float height);
    internal void DrawRevamped(PdfPageBase page, float x, float y, float width, float height);
    internal float PaintToImage(PdfGraphics g, RectangleF barRect);
    internal float GetCharBarsCount(char character);
    protected internal virtual bool Validate(string data);
    protected internal virtual SizeF GetSizeValue();
    internal float BarcodeWidth();
    protected internal virtual void GetExtendedTextValue();
    protected internal virtual Char[] CalculateCheckDigit();
    internal float GetCharWidth(char character);
    internal virtual string GetTextToEncode();
    internal virtual List`1<Byte[]> GetTextToEncodeList();
    protected virtual float PaintRectangle(PdfPageBase page, RectangleF barRect);
    protected virtual float PaintRectangle(PdfGraphics graphics, RectangleF barRect);
    protected virtual float PaintRectangleTag(PdfTemplate template, RectangleF barRect);
    private float GetHeight();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class Syncfusion.Pdf.Barcode.QRCodeLogo : object {
    private PdfImage image;
    internal PdfImage Image { get; public set; }
    public QRCodeLogo(PdfImage logoImage);
    public QRCodeLogo(Stream logoImageStream);
    internal PdfImage get_Image();
    public void set_Image(PdfImage value);
}
public enum Syncfusion.Pdf.Barcode.QRCodeVersion : Enum {
    public int value__;
    public static QRCodeVersion Auto;
    public static QRCodeVersion Version01;
    public static QRCodeVersion Version02;
    public static QRCodeVersion Version03;
    public static QRCodeVersion Version04;
    public static QRCodeVersion Version05;
    public static QRCodeVersion Version06;
    public static QRCodeVersion Version07;
    public static QRCodeVersion Version08;
    public static QRCodeVersion Version09;
    public static QRCodeVersion Version10;
    public static QRCodeVersion Version11;
    public static QRCodeVersion Version12;
    public static QRCodeVersion Version13;
    public static QRCodeVersion Version14;
    public static QRCodeVersion Version15;
    public static QRCodeVersion Version16;
    public static QRCodeVersion Version17;
    public static QRCodeVersion Version18;
    public static QRCodeVersion Version19;
    public static QRCodeVersion Version20;
    public static QRCodeVersion Version21;
    public static QRCodeVersion Version22;
    public static QRCodeVersion Version23;
    public static QRCodeVersion Version24;
    public static QRCodeVersion Version25;
    public static QRCodeVersion Version26;
    public static QRCodeVersion Version27;
    public static QRCodeVersion Version28;
    public static QRCodeVersion Version29;
    public static QRCodeVersion Version30;
    public static QRCodeVersion Version31;
    public static QRCodeVersion Version32;
    public static QRCodeVersion Version33;
    public static QRCodeVersion Version34;
    public static QRCodeVersion Version35;
    public static QRCodeVersion Version36;
    public static QRCodeVersion Version37;
    public static QRCodeVersion Version38;
    public static QRCodeVersion Version39;
    public static QRCodeVersion Version40;
}
internal enum Syncfusion.Pdf.Barcode.TextEncodingMode : Enum {
    public int value__;
    public static TextEncodingMode Upper;
    public static TextEncodingMode Lower;
    public static TextEncodingMode Mixed;
    public static TextEncodingMode Punctuation;
    public static TextEncodingMode ShiftUpper;
    public static TextEncodingMode ShiftPunctuation;
}
public enum Syncfusion.Pdf.Barcode.TextLocation : Enum {
    public int value__;
    public static TextLocation None;
    public static TextLocation Top;
    public static TextLocation Bottom;
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Syncfusion.Pdf.CffGlyphs : object {
    private Dictionary`2<string, Byte[]> m_glyphs;
    private Double[] m_fontMatrix;
    private Dictionary`2<int, string> m_differenceEncoding;
    private Dictionary`2<string, object> m_renderedPath;
    private int m_globalBias;
    private String[] m_diffTable;
    internal Dictionary`2<string, Byte[]> Glyphs { get; internal set; }
    public int GlobalBias { get; public set; }
    internal Double[] FontMatrix { get; internal set; }
    internal Dictionary`2<int, string> DifferenceEncoding { get; internal set; }
    internal Dictionary`2<string, object> RenderedPath { get; internal set; }
    internal String[] DiffTable { get; internal set; }
    internal Dictionary`2<string, Byte[]> get_Glyphs();
    internal void set_Glyphs(Dictionary`2<string, Byte[]> value);
    public int get_GlobalBias();
    public void set_GlobalBias(int value);
    internal Double[] get_FontMatrix();
    internal void set_FontMatrix(Double[] value);
    internal Dictionary`2<int, string> get_DifferenceEncoding();
    internal void set_DifferenceEncoding(Dictionary`2<int, string> value);
    internal Dictionary`2<string, object> get_RenderedPath();
    internal void set_RenderedPath(Dictionary`2<string, object> value);
    internal String[] get_DiffTable();
    internal void set_DiffTable(String[] value);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Syncfusion.Pdf.Cmap0 : CmapTables {
    private ushort m_firstcode;
    public Byte[] glyphIdArray;
    public ushort FirstCode { get; }
    public virtual ushort get_FirstCode();
    public virtual ushort GetGlyphId(ushort charCode);
    public virtual void Read(ReadFontArray reader);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Syncfusion.Pdf.Cmap4 : CmapTables {
    private Segments[] segments;
    private ushort m_firstCode;
    public ushort FirstCode { get; }
    public virtual ushort get_FirstCode();
    public virtual ushort GetGlyphId(ushort charCode);
    public virtual void Read(ReadFontArray reader);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Syncfusion.Pdf.Cmap6 : CmapTables {
    private ushort firstCode;
    private UInt16[] glyphIdArray;
    public ushort FirstCode { get; }
    public virtual ushort get_FirstCode();
    public virtual ushort GetGlyphId(ushort charCode);
    public virtual void Read(ReadFontArray reader);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal abstract class Syncfusion.Pdf.CmapTables : object {
    private ushort m_firstcode;
    public ushort FirstCode { get; }
    public abstract virtual ushort get_FirstCode();
    public static CmapTables ReadCmapTable(ReadFontArray reader);
    public abstract virtual ushort GetGlyphId(ushort charCode);
    public abstract virtual void Read(ReadFontArray reader);
}
internal class Syncfusion.Pdf.ColorSpace.NamespaceDoc : object {
}
public class Syncfusion.Pdf.ColorSpace.PdfCalGrayColor : PdfExtendedColor {
    private double m_gray;
    public double Gray { get; public set; }
    [NullableContextAttribute("1")]
public PdfCalGrayColor(PdfColorSpaces colorspace);
    public double get_Gray();
    public void set_Gray(double value);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class Syncfusion.Pdf.ColorSpace.PdfCalGrayColorSpace : PdfColorSpaces {
    private Double[] m_whitePoint;
    private double m_gama;
    private Double[] m_blackPoint;
    public Double[] BlackPoint { get; public set; }
    public double Gamma { get; public set; }
    public Double[] WhitePoint { get; public set; }
    public Double[] get_BlackPoint();
    public void set_BlackPoint(Double[] value);
    public double get_Gamma();
    public void set_Gamma(double value);
    public Double[] get_WhitePoint();
    public void set_WhitePoint(Double[] value);
    private void Initialize();
    private PdfArray CreateInternals();
}
public class Syncfusion.Pdf.ColorSpace.PdfCalRGBColor : PdfExtendedColor {
    private double m_red;
    private double m_green;
    private double m_blue;
    public double Blue { get; public set; }
    public double Green { get; public set; }
    public double Red { get; public set; }
    [NullableContextAttribute("1")]
public PdfCalRGBColor(PdfColorSpaces colorspace);
    public double get_Blue();
    public void set_Blue(double value);
    public double get_Green();
    public void set_Green(double value);
    public double get_Red();
    public void set_Red(double value);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class Syncfusion.Pdf.ColorSpace.PdfCalRGBColorSpace : PdfColorSpaces {
    private Double[] m_whitePoint;
    private Double[] m_blackPoint;
    private Double[] m_gama;
    private Double[] m_matrix;
    public Double[] BlackPoint { get; public set; }
    public Double[] Gamma { get; public set; }
    public Double[] Matrix { get; public set; }
    public Double[] WhitePoint { get; public set; }
    public Double[] get_BlackPoint();
    public void set_BlackPoint(Double[] value);
    public Double[] get_Gamma();
    public void set_Gamma(Double[] value);
    public Double[] get_Matrix();
    public void set_Matrix(Double[] value);
    public Double[] get_WhitePoint();
    public void set_WhitePoint(Double[] value);
    private void Initialize();
    private PdfArray CreateInternals();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public abstract class Syncfusion.Pdf.ColorSpace.PdfColorSpaces : object {
    internal PdfResources resources;
    protected static object s_syncObject;
    private IPdfPrimitive m_colorInternals;
    private PdfDictionary m_dictionary;
    private PdfArray colorspace;
    private IPdfPrimitive Syncfusion.Pdf.IPdfWrapper.Element { get; }
    private static PdfColorSpaces();
    private sealed virtual override IPdfPrimitive Syncfusion.Pdf.IPdfWrapper.get_Element();
    private sealed virtual override bool Syncfusion.Pdf.IPdfCache.EqualsTo(IPdfCache obj);
    private sealed virtual override IPdfPrimitive Syncfusion.Pdf.IPdfCache.GetInternals();
    private sealed virtual override void Syncfusion.Pdf.IPdfCache.SetInternals(IPdfPrimitive internals);
}
public class Syncfusion.Pdf.ColorSpace.PdfDeviceColorSpace : PdfColorSpaces {
    private PdfColorSpace mDeviceColorSpaceType;
    public PdfColorSpace DeviceColorSpaceType { get; public set; }
    public PdfDeviceColorSpace(PdfColorSpace colorspace);
    public PdfColorSpace get_DeviceColorSpaceType();
    public void set_DeviceColorSpaceType(PdfColorSpace value);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public abstract class Syncfusion.Pdf.ColorSpace.PdfExtendedColor : object {
    protected PdfColorSpaces m_colorspace;
    public PdfColorSpaces ColorSpace { get; }
    public PdfExtendedColor(PdfColorSpaces colorspace);
    public PdfColorSpaces get_ColorSpace();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class Syncfusion.Pdf.ColorSpace.PdfICCColor : PdfExtendedColor {
    private Double[] m_components;
    private PdfICCColorSpace m_colorspaces;
    public Double[] ColorComponents { get; public set; }
    internal PdfICCColorSpace ColorSpaces { get; }
    public PdfICCColor(PdfColorSpaces colorspace);
    public Double[] get_ColorComponents();
    public void set_ColorComponents(Double[] value);
    internal PdfICCColorSpace get_ColorSpaces();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Syncfusion.Pdf.ColorSpace.PdfICCColorProfile : object {
    private PdfStream m_stream;
    public IPdfPrimitive Element { get; }
    protected void Save();
    private void Stream_BeginSave(object sender, SavePdfPrimitiveEventArgs ars);
    public Byte[] GetProfileData();
    public sealed virtual IPdfPrimitive get_Element();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class Syncfusion.Pdf.ColorSpace.PdfICCColorSpace : PdfColorSpaces {
    private PdfColorSpaces m_alterantecolorspaces;
    private byte m_colorcomponents;
    private Byte[] m_profileData;
    private Double[] m_range;
    private PdfStream m_stream;
    private static string m_cmykProfile;
    public PdfColorSpaces AlternateColorSpace { get; public set; }
    public byte ColorComponents { get; public set; }
    public Byte[] ProfileData { get; public set; }
    public Double[] Range { get; public set; }
    public PdfColorSpaces get_AlternateColorSpace();
    public void set_AlternateColorSpace(PdfColorSpaces value);
    public byte get_ColorComponents();
    public void set_ColorComponents(byte value);
    public Byte[] get_ProfileData();
    public void set_ProfileData(Byte[] value);
    public Double[] get_Range();
    public void set_Range(Double[] value);
    public Byte[] GetProfileData();
    protected void Save();
    private void Initialize();
    private PdfArray CreateInternals();
    private void Stream_BeginSave(object sender, SavePdfPrimitiveEventArgs ars);
    private Byte[] GetCmykProfileData();
}
public class Syncfusion.Pdf.ColorSpace.PdfIndexedColor : PdfExtendedColor {
    private int m_colorIndex;
    public int SelectColorIndex { get; public set; }
    [NullableContextAttribute("1")]
public PdfIndexedColor(PdfIndexedColorSpace colorspace);
    public int get_SelectColorIndex();
    public void set_SelectColorIndex(int value);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class Syncfusion.Pdf.ColorSpace.PdfIndexedColorSpace : PdfColorSpaces {
    private PdfColorSpaces m_basecolorspace;
    private int m_maxColorIndex;
    private Byte[] m_indexedColorTable;
    private PdfStream m_stream;
    public PdfColorSpaces BaseColorSpace { get; public set; }
    public int MaxColorIndex { get; public set; }
    public Byte[] IndexedColorTable { get; public set; }
    public PdfColorSpaces get_BaseColorSpace();
    public void set_BaseColorSpace(PdfColorSpaces value);
    public int get_MaxColorIndex();
    public void set_MaxColorIndex(int value);
    public Byte[] get_IndexedColorTable();
    public void set_IndexedColorTable(Byte[] value);
    public Byte[] GetProfileData();
    protected void Save();
    private void Initialize();
    private PdfArray CreateInternals();
    private void Stream_BeginSave(object sender, SavePdfPrimitiveEventArgs ars);
}
public class Syncfusion.Pdf.ColorSpace.PdfLabColor : PdfExtendedColor {
    private double m_a;
    private double m_b;
    private double m_l;
    public double A { get; public set; }
    public double B { get; public set; }
    public double L { get; public set; }
    [NullableContextAttribute("1")]
public PdfLabColor(PdfColorSpaces colorspace);
    public double get_A();
    public void set_A(double value);
    public double get_B();
    public void set_B(double value);
    public double get_L();
    public void set_L(double value);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class Syncfusion.Pdf.ColorSpace.PdfLabColorSpace : PdfColorSpaces {
    private Double[] m_whitePoint;
    private Double[] m_blackPoint;
    private Double[] m_range;
    public Double[] BlackPoint { get; public set; }
    public Double[] Range { get; public set; }
    public Double[] WhitePoint { get; public set; }
    public Double[] get_BlackPoint();
    public void set_BlackPoint(Double[] value);
    public Double[] get_Range();
    public void set_Range(Double[] value);
    public Double[] get_WhitePoint();
    public void set_WhitePoint(Double[] value);
    private void Initialize();
    private PdfArray CreateInternals();
}
public class Syncfusion.Pdf.ColorSpace.PdfSeparationColor : PdfExtendedColor {
    private double m_tint;
    public double Tint { get; public set; }
    [NullableContextAttribute("1")]
public PdfSeparationColor(PdfColorSpaces colorspace);
    public double get_Tint();
    public void set_Tint(double value);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class Syncfusion.Pdf.ColorSpace.PdfSeparationColorSpace : PdfColorSpaces {
    private string m_colorant;
    private PdfFunction m_function;
    private PdfStream m_stream;
    private PdfColorSpaces m_alterantecolorspaces;
    public PdfColorSpaces AlternateColorSpaces { get; public set; }
    public string Colorant { get; public set; }
    public PdfFunction TintTransform { get; public set; }
    public PdfColorSpaces get_AlternateColorSpaces();
    public void set_AlternateColorSpaces(PdfColorSpaces value);
    public string get_Colorant();
    public void set_Colorant(string value);
    public PdfFunction get_TintTransform();
    public void set_TintTransform(PdfFunction value);
    public Byte[] GetProfileData();
    protected void Save();
    private void Initialize();
    private PdfArray CreateInternals();
    private void Stream_BeginSave(object sender, SavePdfPrimitiveEventArgs ars);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Syncfusion.Pdf.CompositeGlyph : TrueTypeGlyphs {
    private List`1<OutlinePoint[]> contours;
    internal List`1<OutlinePoint[]> Contours { get; }
    public CompositeGlyph(FontFile2 fontFile, ushort glyphIndex);
    internal List`1<OutlinePoint[]> get_Contours();
    private static OutlinePoint GetTransformedPoint(GlyphDescription compostite, OutlinePoint point);
    private void AddGlyph(GlyphDescription gd);
    public virtual void Read(ReadFontArray reader);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Syncfusion.Pdf.Compression.DefaultCompressor : object {
    public string Name { get; }
    public CompressionType Type { get; }
    public sealed virtual string get_Name();
    public sealed virtual CompressionType get_Type();
    public sealed virtual Byte[] Compress(Byte[] data);
    public sealed virtual Stream Compress(Stream inputStream);
    public sealed virtual Byte[] Compress(string data);
    public sealed virtual Byte[] Decompress(string value);
    public sealed virtual Byte[] Decompress(Byte[] value);
    public sealed virtual Stream Decompress(Stream inputStream);
}
[NullableContextAttribute("1")]
internal interface Syncfusion.Pdf.Compression.IPdfCompressor {
    public CompressionType Type { get; }
    public string Name { get; }
    public abstract virtual CompressionType get_Type();
    public abstract virtual string get_Name();
    public abstract virtual Byte[] Compress(Byte[] data);
    public abstract virtual Byte[] Compress(string data);
    public abstract virtual Stream Compress(Stream inputStream);
    public abstract virtual Byte[] Decompress(string value);
    public abstract virtual Byte[] Decompress(Byte[] value);
    public abstract virtual Stream Decompress(Stream inputStream);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Syncfusion.Pdf.Compression.PdfASCII85Compressor : object {
    private static int m_asciiOffset;
    private Byte[] m_encodedBlock;
    private Byte[] m_decodedBlock;
    private UInt32 m_tuple;
    private UInt32[] m_codeTable;
    public CompressionType Type { get; }
    public string Name { get; }
    public sealed virtual CompressionType get_Type();
    public void Decompress(Byte[] inputData, Stream outputData);
    public sealed virtual string get_Name();
    public sealed virtual Byte[] Compress(Byte[] data);
    public sealed virtual Byte[] Compress(string data);
    public sealed virtual Stream Compress(Stream inputStream);
    public sealed virtual Byte[] Decompress(string value);
    public sealed virtual Byte[] Decompress(Byte[] value);
    public sealed virtual Stream Decompress(Stream inputStream);
    private void DecodeBlock();
    private void DecodeBlock(int bytes);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Syncfusion.Pdf.Compression.PdfCcittEncoder : object {
    private static int c_G3code_Eol;
    private static int c_G3code_Invalid;
    private static int c_G3code_Eof;
    private static int c_G3code_Incomp;
    private static int c_Length;
    private static int c_Code;
    private static int c_Runlen;
    private static int c_Eol;
    private static Byte[] s_tableZeroSpan;
    private static Byte[] s_tableOneSpan;
    private static Int32[][] s_terminatingWhiteCodes;
    private static Int32[][] s_terminatingBlackCodes;
    private static Int32[] s_horizontalTabel;
    private static Int32[] s_passcode;
    private static Int32[] s_maskTabel;
    private static Int32[][] s_verticalTable;
    private int m_rowbytes;
    private int m_rowPixels;
    private int m_countBit;
    private int m_data;
    private Byte[] m_refline;
    private List`1<byte> m_outBuf;
    private Byte[] m_imageData;
    private int m_offsetData;
    private static PdfCcittEncoder();
    public Byte[] EncodeData(Byte[] data, int width, int height);
    private static void CreateVerticalTable();
    private static void CreteTableZeroSpan();
    private static void CreteTableOneSpan();
    private static void CreateTerminatingWhiteCodes();
    private static void CreateTerminatingBlackCodes();
    private void Putcode(Int32[] table);
    private void PutSpan(int span, Int32[][] tab);
    private void PutBits(int bits, int length);
    private void Fax3Encode();
    private void Fax4Encode();
    private int Pixel(Byte[] data, int offset, int bit);
    private int FindFirstSpan(Byte[] bp, int offset, int bs, int be);
    private int FindZeroSpan(Byte[] bp, int offset, int bs, int be);
    private int Finddiff(Byte[] bp, int offset, int bs, int be, int color);
    private int Finddiff2(Byte[] bp, int offset, int bs, int be, int color);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Syncfusion.Pdf.Compression.PdfLzwCompressor : object {
    private static int c_eod;
    private static int c_clearTable;
    private static int c_startCode;
    private static int c_10BitsCode;
    private static int c_11BitsCode;
    private static int c_12BitsCode;
    private Byte[][] m_codeTable;
    private Byte[] m_inputData;
    private Stream m_outputData;
    private int m_tableIndex;
    private int m_bitsToGet;
    private int m_byteRead;
    private int m_nextData;
    private int m_nextBits;
    private Int32[] m_sizeTable;
    private bool m_isEarlyChanged;
    public CompressionType Type { get; }
    public string Name { get; }
    public sealed virtual CompressionType get_Type();
    public void Decompress(Byte[] inputData, Stream outputData);
    public sealed virtual string get_Name();
    public sealed virtual Byte[] Compress(Byte[] data);
    public sealed virtual Byte[] Compress(string data);
    public sealed virtual Stream Compress(Stream inputStream);
    public sealed virtual Byte[] Decompress(string value);
    public Byte[] Decompress(Byte[] value, bool isearlychange);
    public sealed virtual Byte[] Decompress(Byte[] value);
    public sealed virtual Stream Decompress(Stream inputStream);
    private void InitializeDataTable();
    private void WriteCode(Byte[] code);
    private void AddCodeToTable(Byte[] oldBytes, byte newByte);
    private void AddCodeToTable(Byte[] data);
    private Byte[] UniteBytes(Byte[] oldData, byte newData);
    private int NewCode();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Syncfusion.Pdf.Compression.PdfPngFilter : object {
    private static RowFilter s_subFilter;
    private static RowFilter s_upFilter;
    private static RowFilter s_averageFilter;
    private static RowFilter s_paethFilter;
    private static RowFilter s_decompressFilter;
    private static byte m_zero;
    private static PdfPngFilter();
    public static Byte[] Compress(Byte[] data, int bpr, Type type);
    public static Byte[] Decompress(Byte[] data, int bpr);
    private static Byte[] Modify(Byte[] data, int bpr, RowFilter filter, bool pack);
    private static void CompressSub(Byte[] data, long inIndex, int inBPR, Byte[] result, long resIndex, int resBPR);
    private static void CompressUp(Byte[] data, long inIndex, int inBPR, Byte[] result, long resIndex, int resBPR);
    private static void CompressAverage(Byte[] data, long inIndex, int inBPR, Byte[] result, long resIndex, int resBPR);
    private static void CompressPaeth(Byte[] data, long inIndex, int inBPR, Byte[] result, long resIndex, int resBPR);
    private static void Decompress(Byte[] data, long inIndex, int inBPR, Byte[] result, long resIndex, int resBPR);
    private static void DecompressNone(Byte[] data, long inIndex, int inBPR, Byte[] result, long resIndex, int resBPR);
    private static void DeompressSub(Byte[] data, long inIndex, int inBPR, Byte[] result, long resIndex, int resBPR);
    private static Byte[] DecompressUp(Byte[] data, long inIndex, int inBPR, Byte[] result, long resIndex, int resBPR);
    private static void DecompressAverage(Byte[] data, long inIndex, int inBPR, Byte[] result, long resIndex, int resBPR);
    private static void DecompressPaeth(Byte[] data, long inIndex, int inBPR, Byte[] result, long resIndex, int resBPR);
    private static byte PaethPredictor(int a, int b, int c);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Syncfusion.Pdf.Compression.PdfZlibCompressor : object {
    private static int DefaultBufferSize;
    private static string DefaultName;
    private PdfCompressionLevel m_level;
    public string Name { get; }
    public CompressionType Type { get; }
    public Encoding Encoding { get; }
    public PdfCompressionLevel Level { get; public set; }
    public PdfZlibCompressor(PdfCompressionLevel level);
    private static PdfZlibCompressor();
    public sealed virtual string get_Name();
    public sealed virtual CompressionType get_Type();
    public Encoding get_Encoding();
    public PdfCompressionLevel get_Level();
    public void set_Level(PdfCompressionLevel value);
    public sealed virtual Byte[] Compress(Byte[] data);
    public sealed virtual Stream Compress(Stream inputStream);
    public sealed virtual Byte[] Compress(string data);
    public sealed virtual Byte[] Decompress(string data);
    public sealed virtual Byte[] Decompress(Byte[] data);
    public sealed virtual Stream Decompress(Stream inputStream);
}
internal enum Syncfusion.Pdf.CompressionType : Enum {
    public int value__;
    public static CompressionType None;
    public static CompressionType Zlib;
    public static CompressionType LZW;
    public static CompressionType ASCII85;
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Syncfusion.Pdf.ContentLexer : object {
    private StringBuilder m_operatorParams;
    private TokenType m_tType;
    private char m_currentChar;
    private bool m_isArtifactContentEnds;
    internal bool IsContainsArtifacts;
    private char m_nextChar;
    private Byte[] m_contentStream;
    private int m_charPointer;
    private static String[] m_textShowers;
    private bool m_isContentEnded;
    internal TokenType Token { get; }
    internal StringBuilder OperatorParams { get; }
    public ContentLexer(Byte[] contentStream);
    private static ContentLexer();
    internal TokenType get_Token();
    internal StringBuilder get_OperatorParams();
    public TokenType GetNextToken();
    private void ResetToken();
    private char MoveToNextChar();
    internal void ResetContentPointer(int count);
    internal char GetNextChar();
    internal char GetNextInlineChar();
    internal char GetNextCharforInlineStream();
    internal char GetNextChar(bool value);
    private TokenType GetComment();
    private TokenType GetName();
    private TokenType GetNumber();
    private TokenType GetLiteralString();
    private string GetLiterals(char ch);
    private TokenType GetHexadecimalString();
    private TokenType GetOperator();
    private bool IsOperator(char ch);
    private char ConsumeValue();
    private bool IsWhiteSpace(char ch);
    private bool IsDelimiter(char ch);
    private bool CheckForTextOperator();
    internal void Dispose();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Syncfusion.Pdf.ContentParser : object {
    private ContentLexer m_lexer;
    private StringBuilder m_operatorParams;
    private PdfRecordCollection m_recordCollection;
    private List`1<string> m_operands;
    private List`1<byte> m_inlineImageBytes;
    private bool m_isByteOperands;
    internal bool IsTextExtractionProcess;
    internal bool ConformanceEnabled;
    internal List`1<string> fontkeys;
    private static String[] operators;
    public ContentParser(Byte[] contentStream);
    private static ContentParser();
    internal void Dispose();
    public PdfRecordCollection ReadContent();
    private void ParseObject(TokenType stop);
    private TokenType GetNextToken();
    private void ConsumeValue();
    private void CreateRecord();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[DefaultMemberAttribute("Item")]
public class Syncfusion.Pdf.CustomMetadata : object {
    private PdfDictionary m_dictionary;
    private XmpMetadata m_xmp;
    private Dictionary`2<string, string> m_customMetaDataDictionary;
    public string Item { get; public set; }
    public int Count { get; }
    internal PdfDictionary Dictionary { get; internal set; }
    internal XmpMetadata Xmp { get; internal set; }
    public string get_Item(string key);
    public void set_Item(string key, string value);
    public void Remove(string key);
    public bool ContainsKey(string key);
    public int get_Count();
    public void Add(string key, string value);
    public sealed virtual IEnumerator GetEnumerator();
    internal PdfDictionary get_Dictionary();
    internal void set_Dictionary(PdfDictionary value);
    internal XmpMetadata get_Xmp();
    internal void set_Xmp(XmpMetadata value);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Syncfusion.Pdf.DocumentSavedEventArgs : EventArgs {
    private PdfWriter m_writer;
    internal PdfWriter Writer { get; }
    internal DocumentSavedEventArgs(PdfWriter writer);
    internal PdfWriter get_Writer();
}
public enum Syncfusion.Pdf.DuplexMode : Enum {
    public int value__;
    public static DuplexMode Simplex;
    public static DuplexMode DuplexFlipShortEdge;
    public static DuplexMode DuplexFlipLongEdge;
    public static DuplexMode None;
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Syncfusion.Pdf.EmbeddedFile : object {
    private string m_fileName;
    private string m_filePath;
    private string m_mimeType;
    private Byte[] m_data;
    private EmbeddedFileParams m_params;
    private PdfStream m_stream;
    public string FileName { get; public set; }
    internal string FilePath { get; internal set; }
    public Byte[] Data { get; public set; }
    public string MimeType { get; public set; }
    internal EmbeddedFileParams Params { get; }
    public IPdfPrimitive Element { get; }
    internal EmbeddedFile(string fileName);
    public EmbeddedFile(string fileName, Byte[] data);
    public EmbeddedFile(string fileName, Stream stream);
    public string get_FileName();
    public void set_FileName(string value);
    internal string get_FilePath();
    internal void set_FilePath(string value);
    public Byte[] get_Data();
    public void set_Data(Byte[] value);
    public string get_MimeType();
    public void set_MimeType(string value);
    internal EmbeddedFileParams get_Params();
    protected void Initialize();
    protected void Save();
    private void Stream_BeginSave(object sender, SavePdfPrimitiveEventArgs ars);
    private string GetFileName(string attachmentName);
    public sealed virtual IPdfPrimitive get_Element();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Syncfusion.Pdf.EmbeddedFileParams : object {
    private DateTime m_creationDate;
    private DateTime m_modificationDate;
    private int m_size;
    private PdfDictionary m_dictionary;
    public DateTime CreationDate { get; public set; }
    public DateTime ModificationDate { get; public set; }
    internal int Size { get; internal set; }
    public IPdfPrimitive Element { get; }
    public DateTime get_CreationDate();
    public void set_CreationDate(DateTime value);
    public DateTime get_ModificationDate();
    public void set_ModificationDate(DateTime value);
    internal int get_Size();
    internal void set_Size(int value);
    public sealed virtual IPdfPrimitive get_Element();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Syncfusion.Pdf.Exporting.PdfTextExtractor : object {
    private static int m_numberOfChars;
    private static Dictionary`2<string, List`1<string>> m_differenceArray;
    private static List`1<string> m_decodedChar;
    private static PdfTextExtractor();
    public static string ExtractTextFromBytes(Byte[] data);
    internal static string ExtractTextFromBytes(Byte[] data, bool type);
    public static string ExtractTextFromBytes(Byte[] data, PdfPageBase lpage, List`1<PdfName> fontname, List`1<IPdfPrimitive> fontref);
    internal static string ExtractTextFromBytesTrueTypeFonts(Byte[] data, List`1<IPdfPrimitive> fontref, List`1<PdfName> fontname, PdfCrossTable crosstable);
    internal static string ExtractTextFromBytesEmbedFonts(Byte[] data, PdfPageBase lpage, List`1<PdfName> m_font, List`1<IPdfPrimitive> m_fref);
    internal static string ExtractTextFrom_Type0Fonts(Byte[] data, List`1<IPdfPrimitive> fontref, List`1<PdfName> fontname, PdfCrossTable crosstable);
    private static bool CheckToken(String[] tokens, Char[] recent);
    internal static string GetLatinCharacter(string decodedCharacter);
    internal static string GetSpecialCharacter(string decodedCharacter);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Syncfusion.Pdf.ExtendColorspace : object {
    private IPdfPrimitive m_colorValueArray;
    public IPdfPrimitive ColorSpaceValueArray { get; public set; }
    public ExtendColorspace(IPdfPrimitive refHolderColorspace);
    public IPdfPrimitive get_ColorSpaceValueArray();
    public void set_ColorSpaceValueArray(IPdfPrimitive value);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Syncfusion.Pdf.FontDecode : object {
    internal MemoryStream m_fontStream;
    internal FontHeader m_fontHeader;
    internal int m_tableCount;
    private int tagOffset;
    private int offset;
    private int previousLength;
    internal MemoryStream CreateFontStream(List`1<TableEntry> entries);
    private void WriteHeader(FontHeader head);
    private void WriteEntry(TableEntry entry);
    private void WriteShort(short value);
    private void WriteInt(int value);
    private void WriteString(string value);
    public void WriteBytes(Byte[] buffer);
    private int GetSearchRange(int noOfTables);
    private int GetEntrySelector(int noOfTables);
    private int GetRangeShift(int noOfTables, int searchRange);
}
internal class Syncfusion.Pdf.FontEncoding : object {
    private ushort m_platformId;
    private ushort m_encodingId;
    private UInt32 m_offset;
    public UInt32 Offset { get; public set; }
    public ushort PlatformId { get; public set; }
    public ushort EncodingId { get; public set; }
    public UInt32 get_Offset();
    public void set_Offset(UInt32 value);
    public ushort get_PlatformId();
    public void set_PlatformId(ushort value);
    public ushort get_EncodingId();
    public void set_EncodingId(ushort value);
    [NullableContextAttribute("1")]
public void ReadEncodingDeatils(ReadFontArray reader);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Syncfusion.Pdf.FontFile2 : object {
    private static long serialVersionUID;
    private RectangularArrays m_rectangularArrays;
    public static int HEAD;
    public static int MAXP;
    public static int CMAP;
    public static int LOCA;
    public static int GLYF;
    public static int HHEA;
    public static int HMTX;
    public static int NAME;
    public static int POST;
    public static int CVT;
    public static int FPGM;
    public static int HDMX;
    public static int KERN;
    public static int OS2;
    public static int PREP;
    public static int DSIG;
    public static int CFF;
    public static int GSUB;
    public static int BASE;
    public static int EBDT;
    public static int EBLC;
    public static int GASP;
    public static int VHEA;
    public static int VMTX;
    public static int GDEF;
    public static int JSTF;
    public static int LTSH;
    public static int PCLT;
    public static int VDMX;
    public static int BSLN;
    public static int MORT;
    public static int FDSC;
    public static int FFTM;
    public static int GPOS;
    public static int FEAT;
    public static int JUST;
    public static int PROP;
    protected internal int tableCount;
    protected internal Int32[][] checksums;
    protected internal Int32[][] tables;
    protected internal Int32[][] tableLength;
    protected internal Int32[][] offsets;
    public Byte[] fontDataAsArray;
    private int m_offset;
    private int id;
    private int m_firstCode;
    private UInt16[] encodevalue;
    private UInt16[] startcodevalue;
    private Int16[] idDeltavalue;
    private UInt16[] array4;
    private List`1<UInt16[]> notable;
    private UInt16[] glyphsIdValue;
    private ushort numgl;
    private MemoryStream cmapStream;
    private int numglyphs;
    private UInt32[] locaoffset;
    private Maxp m_maxp;
    private Head m_head;
    private IndexLocation m_loca;
    private TrueTypeCmap m_cmap;
    private ReadFontArray m_reader;
    private TrueTypeGlyphs m_trueTypeGlypf;
    private Dictionary`2<ushort, TrueTypeGlyphs> pathtable;
    private bool m_isfontfile2;
    private bool useArray;
    protected internal List`1<string> tableList;
    internal List`1<TableEntry> tableEntries;
    internal Dictionary`2<int, TableEntry> table;
    internal int pointer;
    public static int OPENTYPE;
    public static int TRUETYPE;
    public static int TTC;
    protected internal int type;
    public int currentFontID;
    internal int fontCount;
    public int segment;
    protected internal int numTables;
    protected internal int searchRange;
    protected internal int entrySelector;
    protected internal int rangeShift;
    public List`1<OutlinePoint[]> contours;
    private ushort noofSubtable;
    public bool IsFontFile2 { get; public set; }
    public ReadFontArray FontArrayReader { get; }
    public Byte[] FontFileArrayData { get; }
    public Maxp MaximumProfile { get; }
    public IndexLocation Loca { get; }
    public TrueTypeCmap Cmap { get; }
    public Head Header { get; }
    public TrueTypeCmap CmapTable { get; }
    internal List`1<UInt16[]> Segments { get; internal set; }
    public TrueTypeGlyphs TrueTypeFontGlyf { get; }
    public int FirstCode { get; public set; }
    public int NumGlyphs { get; }
    public int OffsetVal { get; public set; }
    public FontFile2(Byte[] data);
    public bool get_IsFontFile2();
    public void set_IsFontFile2(bool value);
    public ReadFontArray get_FontArrayReader();
    public Byte[] get_FontFileArrayData();
    public Maxp get_MaximumProfile();
    public IndexLocation get_Loca();
    public TrueTypeCmap get_Cmap();
    public Head get_Header();
    public TrueTypeCmap get_CmapTable();
    internal List`1<UInt16[]> get_Segments();
    internal void set_Segments(List`1<UInt16[]> value);
    public TrueTypeGlyphs get_TrueTypeFontGlyf();
    public int get_FirstCode();
    public void set_FirstCode(int value);
    public int get_NumGlyphs();
    public int get_OffsetVal();
    public void set_OffsetVal(int value);
    private void readHeader();
    private void readTablesForFont();
    public void ReadTable(TableBase tabb);
    public string GetWinencodeCharactername(byte val, string Winansi);
    public ushort GetChatid(byte b);
    private bool TryAppendByte(byte b, UInt16& res);
    public int GetInt(Byte[] val);
    public Byte[] GetByte(int val);
    public void GetFirstCode(CmapTables unicode);
    protected internal int getTableID(string tag);
    public TrueTypeGlyphs readGlyphdata(ushort value);
    private PointF GetMidPoint(PointF a, PointF b);
    public PointF ConvertFunittoPoint(PointF units, float fontSize);
    private static bool XIsByte(Byte[] flags, int index);
    private static bool YIsByte(Byte[] flags, int index);
    private static bool XIsSame(Byte[] flags, int index);
    private static bool YIsSame(Byte[] flags, int index);
    private static bool Repeat(Byte[] flags, int index);
    internal static bool GetBit(int n, byte bit);
    public int getOffsets(int tableID);
    public MemoryStream Getcmapstream();
    private void WriteByte(byte value);
    private void WriteuShort(short value);
    private void WriteShort(ushort value);
    private void WriteLong(ulong value);
    private void Write4();
    public void Write6();
    public byte getnextbyte();
    public int getnextUint32();
    public int getnextUint64();
    public string getnextUint32AsTag();
    public int getnextUint16();
    public ushort getnextUshort();
    public ulong getnextULong();
    public UInt32 getULong();
    public short getnextshort();
    public Byte[] getTableBytes(int tableID);
    internal Byte[] getTableBytes(int tableID, bool isTrueType);
    internal void Dispose();
}
internal abstract class Syncfusion.Pdf.FontFile2Base : object {
}
internal class Syncfusion.Pdf.FontHeader : ValueType {
    public int scalarType;
    public short noOfTables;
    public short searchRange;
    public short entrySelector;
    public short rangeShift;
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Syncfusion.Pdf.FontStructure : object {
    private string m_fontName;
    private FontStyle m_fontStyle;
    private PdfDictionary m_fontDictionary;
    private Dictionary`2<double, string> m_characterMapTable;
    private Dictionary`2<string, double> m_reverseMapTable;
    private Dictionary`2<double, string> m_cidToGidTable;
    private Dictionary`2<string, string> m_differencesDictionary;
    private static string m_replacementCharacter;
    private bool hasStemH;
    private float m_fontSize;
    private string m_fontEncoding;
    private bool isGetFontCalled;
    private Dictionary`2<int, int> m_fontGlyphWidth;
    private bool m_containsCmap;
    private bool m_fontFileContainsCmap;
    private Dictionary`2<double, string> tempMapTable;
    private bool m_isSameFont;
    private Dictionary`2<int, int> m_octDecMapTable;
    private Dictionary`2<int, int> m_cidToGidReverseMapTable;
    internal bool IsMappingDone;
    public bool IsSystemFontExist;
    private Dictionary`2<int, int> m_fontGlyphWidthMapping;
    private float m_type1GlyphHeight;
    internal Dictionary`2<string, Byte[]> m_type1FontGlyphs;
    internal bool IsType1Font;
    internal bool Is1C;
    private bool m_isCID;
    internal Dictionary`2<int, string> differenceTable;
    internal Dictionary`2<int, string> differenceEncoding;
    internal static Dictionary`2<int, string> unicodeCharMapTable;
    private Dictionary`2<int, string> m_macEncodeTable;
    public Byte[] fontfilebytess;
    private FontFile2 m_fontfile2;
    internal bool m_isContainFontfile;
    internal bool IsContainFontfile2;
    internal bool IsContainFontfile3;
    internal bool m_isEmbedded;
    internal Dictionary`2<string, int> ReverseDictMapping;
    private string m_zapfPostScript;
    private string m_fontRefNumber;
    private string m_baseFontEncoding;
    internal PdfPageResources Type3FontGlyphImages;
    internal Dictionary`2<string, PdfStream> Type3FontCharProcsDict;
    private Dictionary`2<int, string> m_adobeJapanCidMapTable;
    private byte m_Flag;
    internal List`1<string> tempStringList;
    private bool m_isTextExtraction;
    private String[] m_differenceDictionaryValues;
    private Dictionary`2<int, char> m_cidByte2Unicode;
    private bool m_skipEscapeSequence;
    private bool m_mapOctalText;
    internal bool m_mapstringFromRender;
    private static object m_locker;
    internal bool isDecodingConformance;
    internal bool m_isImageExtraction;
    internal bool m_isRedactText;
    internal bool m_isExtractTag;
    private Int32[] m_charCodeTable;
    public MemoryStream FontStream;
    internal float DefaultGlyphWidth;
    internal Dictionary`2<int, string> m_macRomanMapTable;
    internal Dictionary`2<int, string> m_winansiMapTable;
    private PdfDictionary m_cidSystemInfoDictionary;
    internal bool IsAdobeJapanFont;
    internal bool IsAdobeIdentity;
    private string m_subType;
    public PdfName fontType;
    internal bool IsOpenTypeFont;
    public bool IsEmbedded { get; public set; }
    internal bool IsTextExtraction { get; internal set; }
    public PdfDictionary FontDictionary { get; public set; }
    public string ZapfPostScript { get; public set; }
    public bool Issymbol { get; }
    public bool IsNonSymbol { get; }
    public PdfNumber Flags { get; }
    internal bool IsCID { get; internal set; }
    internal FontFile2 GlyphFontFile2 { get; internal set; }
    internal string FontRefNumber { get; internal set; }
    internal Dictionary`2<int, string> MacEncodeTable { get; internal set; }
    internal Dictionary`2<int, string> UnicodeCharMapTable { get; internal set; }
    public Dictionary`2<string, double> ReverseMapTable { get; public set; }
    public Dictionary`2<double, string> CharacterMapTable { get; public set; }
    internal String[] DifferencesDictionaryValues { get; internal set; }
    public Dictionary`2<string, string> DifferencesDictionary { get; public set; }
    internal Dictionary`2<int, int> OctDecMapTable { get; internal set; }
    internal Dictionary`2<int, int> CidToGidReverseMapTable { get; internal set; }
    internal Dictionary`2<int, string> AdobeJapanCidMapTable { get; }
    internal bool IsHexaDecimalString { get; internal set; }
    internal Dictionary`2<int, char> CIDByte2Unicode { get; internal set; }
    public Matrix FontMatrix { get; }
    public RectangleF FontBBox { get; }
    public string FontName { get; }
    public FontStyle FontStyle { get; }
    public bool IsSameFont { get; public set; }
    internal Dictionary`2<double, string> CidToGidMap { get; }
    public Dictionary`2<int, int> FontGlyphWidths { get; public set; }
    internal float Type1GlyphHeight { get; }
    public float FontSize { get; public set; }
    public string FontEncoding { get; }
    public string BaseFontEncoding { get; }
    internal bool ContainsCmap { get; }
    public FontStructure(IPdfPrimitive fontDictionary);
    public FontStructure(IPdfPrimitive fontDictionary, string fontRefNum);
    private static FontStructure();
    public bool get_IsEmbedded();
    public void set_IsEmbedded(bool value);
    internal bool get_IsTextExtraction();
    internal void set_IsTextExtraction(bool value);
    public PdfDictionary get_FontDictionary();
    public void set_FontDictionary(PdfDictionary value);
    public string get_ZapfPostScript();
    public void set_ZapfPostScript(string value);
    public bool get_Issymbol();
    public bool get_IsNonSymbol();
    public PdfNumber get_Flags();
    internal bool get_IsCID();
    internal void set_IsCID(bool value);
    internal FontFile2 get_GlyphFontFile2();
    internal void set_GlyphFontFile2(FontFile2 value);
    internal string get_FontRefNumber();
    internal void set_FontRefNumber(string value);
    internal Dictionary`2<int, string> get_MacEncodeTable();
    internal void set_MacEncodeTable(Dictionary`2<int, string> value);
    internal Dictionary`2<int, string> get_UnicodeCharMapTable();
    internal void set_UnicodeCharMapTable(Dictionary`2<int, string> value);
    public Dictionary`2<string, double> get_ReverseMapTable();
    public void set_ReverseMapTable(Dictionary`2<string, double> value);
    public Dictionary`2<double, string> get_CharacterMapTable();
    public void set_CharacterMapTable(Dictionary`2<double, string> value);
    internal String[] get_DifferencesDictionaryValues();
    internal void set_DifferencesDictionaryValues(String[] value);
    public Dictionary`2<string, string> get_DifferencesDictionary();
    public void set_DifferencesDictionary(Dictionary`2<string, string> value);
    internal Dictionary`2<int, int> get_OctDecMapTable();
    internal void set_OctDecMapTable(Dictionary`2<int, int> value);
    internal Dictionary`2<int, int> get_CidToGidReverseMapTable();
    internal void set_CidToGidReverseMapTable(Dictionary`2<int, int> value);
    internal Dictionary`2<int, string> get_AdobeJapanCidMapTable();
    internal bool get_IsHexaDecimalString();
    internal void set_IsHexaDecimalString(bool value);
    internal Dictionary`2<int, char> get_CIDByte2Unicode();
    internal void set_CIDByte2Unicode(Dictionary`2<int, char> value);
    protected virtual override void Finalize();
    internal PdfPageResources GetImageResources(PdfDictionary resourceDictionary);
    public Matrix get_FontMatrix();
    public RectangleF get_FontBBox();
    public string get_FontName();
    public FontStyle get_FontStyle();
    public bool get_IsSameFont();
    public void set_IsSameFont(bool value);
    internal Dictionary`2<double, string> get_CidToGidMap();
    public Dictionary`2<int, int> get_FontGlyphWidths();
    public void set_FontGlyphWidths(Dictionary`2<int, int> value);
    internal float get_Type1GlyphHeight();
    public float get_FontSize();
    public void set_FontSize(float value);
    public string get_FontEncoding();
    public string get_BaseFontEncoding();
    internal bool get_ContainsCmap();
    public RenderedString Decode(string textToDecode, bool isSameFont);
    internal string ToGetEncodedText(string textElement, bool isSameFont);
    public string DecodeType3FontData(string textToDecode);
    public List`1<RenderedString> DecodeTextTJ(string textToDecode, bool isSameFont);
    private int ByteArrayToInt(Byte[] data, int dataLen);
    internal List`1<string> DecodeTextExtractionTJ(string textToDecode, bool isSameFont);
    private bool HasEscapeCharacter(string text);
    public string DecodeTextExtraction(string textToDecode, bool isSameFont);
    internal string GetLiteralString(string encodedText);
    internal string GetHexaDecimalString(string hexEncodedText);
    internal string MapIdentityCharacters(string hexChar);
    internal string GetRawString(string decodedText);
    internal string MapHebrewCharacters(string hexChar);
    private string GetFontName();
    private string DecodeHexFontName(string fontName);
    private FontStyle GetFontStyle();
    private string GetFontEncoding();
    internal bool GetType1Font();
    private bool IsFontEmbedded();
    private Dictionary`2<int, string> AdobeJapanCidMap(StreamReader reader);
    internal string AdobeJapanCidMapTableGlyphParser(string mapChar);
    private string AdobeJapanCidMapReference(string mapValue);
    private void GetGlyphWidthsType1();
    private void GetGlyphWidthsNonIdH();
    private bool isMpdfaaFonts();
    private void GetGlyphWidths();
    private String[] GetFontFilter(PdfDictionary streamDictionary);
    private Dictionary`2<double, string> GetCidToGidTable(Byte[] cidTOGidmap);
    private Dictionary`2<string, double> GetReverseMapTable();
    private Dictionary`2<double, string> GetCharacterMapTable();
    private Dictionary`2<string, string> GetDifferencesDictionary();
    internal static string GetLatinCharacter(string decodedCharacter);
    internal static string GetSpecialCharacter(string decodedCharacter);
    internal string MapCharactersFromTable(string decodedText);
    internal string MapCharactersFromTable(string decodedText, RenderedString renderedString);
    internal string MapCidToGid(string decodedText);
    internal string MapDifferences(string encodedText);
    internal string DecodeToUnicode(string textDecoded);
    private string MapDifferenceOfWingDings(string decodedText);
    internal string SkipEscapeSequence(string text);
    private string EscapeSymbols(string text);
    internal static List`1<string> GetHexCode(string hexCode);
    internal static string GetCharCode(string decodedCharacter);
    private int CalculateCheckSum(Byte[] bytes);
    internal bool IsCancel(string mappingString);
    private bool IsNonPrintableCharacter(char character);
    internal static string CheckFontName(string fontName);
    internal string MapZapf(string encodedText);
    internal Dictionary`2<int, string> GetUnicodeCharMapTable();
    internal bool IsCIDFontType();
    private bool IsEmbbedFont();
    private string CheckContainInvalidChar(string charvalue);
    public static bool GetBit(int n, byte bit);
    private bool GetFlag(byte bit);
    private String[] getMapDifference();
    private PdfNumber GetFlagValue();
    private void GetMacEncodeTable();
    private void GetCIDByte2Unicode();
    internal void Dispose();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Syncfusion.Pdf.FormFieldsAddedArgs : EventArgs {
    private PdfField m_FormField;
    private PdfListFieldItem m_Item;
    private PdfRadioButtonListItem m_Items;
    private int m_index;
    private string m_methodName;
    internal PdfField Field { get; internal set; }
    internal string MethodName { get; internal set; }
    internal int Index { get; internal set; }
    internal PdfListFieldItem Item { get; internal set; }
    internal PdfRadioButtonListItem Items { get; internal set; }
    internal FormFieldsAddedArgs(PdfField form);
    internal PdfField get_Field();
    internal void set_Field(PdfField value);
    internal string get_MethodName();
    internal void set_MethodName(string value);
    internal int get_Index();
    internal void set_Index(int value);
    internal PdfListFieldItem get_Item();
    internal void set_Item(PdfListFieldItem value);
    internal PdfRadioButtonListItem get_Items();
    internal void set_Items(PdfRadioButtonListItem value);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Syncfusion.Pdf.FormFieldsRemovedArgs : EventArgs {
    private PdfField m_FormField;
    private PdfListFieldItem m_Item;
    private PdfRadioButtonListItem m_Items;
    private string m_methodName;
    private int m_index;
    internal PdfField Field { get; internal set; }
    internal string MethodName { get; internal set; }
    internal int Index { get; internal set; }
    internal PdfListFieldItem Item { get; internal set; }
    internal PdfRadioButtonListItem Items { get; internal set; }
    internal FormFieldsRemovedArgs(PdfField form);
    internal PdfField get_Field();
    internal void set_Field(PdfField value);
    internal string get_MethodName();
    internal void set_MethodName(string value);
    internal int get_Index();
    internal void set_Index(int value);
    internal PdfListFieldItem get_Item();
    internal void set_Item(PdfListFieldItem value);
    internal PdfRadioButtonListItem get_Items();
    internal void set_Items(PdfRadioButtonListItem value);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Syncfusion.Pdf.FormPropertyChangedEventArgs : EventArgs {
    private string m_propertyName;
    private PdfField m_FormField;
    private int m_index;
    internal PdfField Field { get; internal set; }
    internal string PropertyName { get; internal set; }
    internal int Index { get; internal set; }
    internal FormPropertyChangedEventArgs(PdfField form);
    internal PdfField get_Field();
    internal void set_Field(PdfField value);
    internal string get_PropertyName();
    internal void set_PropertyName(string value);
    internal int get_Index();
    internal void set_Index(int value);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class Syncfusion.Pdf.Functions.PdfExponentialInterpolationFunction : PdfFunction {
    protected Single[] m_c0;
    protected Single[] m_c1;
    private float m_interpolationExp;
    public Single[] C0 { get; public set; }
    public Single[] C1 { get; public set; }
    public float Exponent { get; public set; }
    public PdfExponentialInterpolationFunction(bool Init);
    public Single[] get_C0();
    public void set_C0(Single[] value);
    public Single[] get_C1();
    public void set_C1(Single[] value);
    public float get_Exponent();
    public void set_Exponent(float value);
    internal Single[] InterpolationExponent(Single[] singleArray1);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public abstract class Syncfusion.Pdf.Functions.PdfFunction : object {
    private PdfDictionary m_dictionary;
    internal PdfArray Domain { get; internal set; }
    internal PdfArray Range { get; internal set; }
    internal PdfDictionary Dictionary { get; }
    private IPdfPrimitive Syncfusion.Pdf.IPdfWrapper.Element { get; }
    internal PdfFunction(PdfDictionary dic);
    internal PdfArray get_Domain();
    internal void set_Domain(PdfArray value);
    internal PdfArray get_Range();
    internal void set_Range(PdfArray value);
    internal PdfDictionary get_Dictionary();
    private sealed virtual override IPdfPrimitive Syncfusion.Pdf.IPdfWrapper.get_Element();
}
internal class Syncfusion.Pdf.Functions.PdfPostScriptCalculatorFunction : PdfFunction {
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Syncfusion.Pdf.Functions.PdfSampledFunction : PdfFunction {
    internal PdfSampledFunction(Single[] domain, Single[] range, Int32[] sizes, Byte[] samples);
    internal PdfSampledFunction(Single[] domain, Single[] range, Int32[] sizes, Int32[] samples);
    internal PdfSampledFunction(Single[] domain, Single[] range, Int32[] sizes, Single[] samples, int bps);
    private void CheckParams(Single[] domain, Single[] range, Int32[] sizes, Array samples);
    private void SetDomainAndRange(Single[] domain, Single[] range);
    private void SetSizeAndValues(Int32[] sizes, Byte[] samples);
    private void SetSizeAndValues(Int32[] sizes, Int32[] samples);
}
internal class Syncfusion.Pdf.Functions.PdfStitchingFunction : PdfFunction {
}
internal class Syncfusion.Pdf.GlyphDescription : object {
    internal static int ARG_1_AND_2_ARE_WORDS;
    internal static int ARGS_ARE_XY_VALUES;
    internal static int ROUND_XY_TO_GRID;
    internal static int WE_HAVE_A_SCALE;
    internal static int MORE_COMPONENTS;
    internal static int WE_HAVE_AN_X_AND_Y_SCALE;
    internal static int WE_HAVE_A_TWO_BY_TWO;
    internal static int WE_HAVE_INSTRUCTIONS;
    internal static int USE_MY_METRICS;
    internal static int OVERLAP_COMPOUND;
    private ushort m_flags;
    private ushort m_glyphIndex;
    private Matrix m_transform;
    public ushort Flags { get; private set; }
    public ushort GlyphIndex { get; private set; }
    public Matrix Transform { get; private set; }
    public ushort get_Flags();
    private void set_Flags(ushort value);
    public ushort get_GlyphIndex();
    private void set_GlyphIndex(ushort value);
    public Matrix get_Transform();
    private void set_Transform(Matrix value);
    internal bool CheckFlag(byte bit);
    public bool GetBit(int n, byte bit);
    public PointF Transformpoint(PointF point);
    [NullableContextAttribute("1")]
public void Read(ReadFontArray reader);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class Syncfusion.Pdf.Graphics.BeginPageLayoutEventArgs : PdfCancelEventArgs {
    private RectangleF m_bounds;
    private PdfPage m_page;
    public RectangleF Bounds { get; public set; }
    public PdfPage Page { get; }
    public BeginPageLayoutEventArgs(RectangleF bounds, PdfPage page);
    public RectangleF get_Bounds();
    public void set_Bounds(RectangleF value);
    public PdfPage get_Page();
}
public class Syncfusion.Pdf.Graphics.BeginPageLayoutEventHandler : MulticastDelegate {
    public BeginPageLayoutEventHandler(object object, IntPtr method);
    [NullableContextAttribute("1")]
public virtual void Invoke(object sender, BeginPageLayoutEventArgs e);
    public virtual IAsyncResult BeginInvoke(object sender, BeginPageLayoutEventArgs e, AsyncCallback callback, object object);
    public virtual void EndInvoke(IAsyncResult result);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Syncfusion.Pdf.Graphics.CatalogedReader : CatalogedReaderBase {
    private static int m_defaultSegmentLength;
    private Stream m_stream;
    private int m_length;
    private List`1<Byte[]> m_segments;
    private bool m_isStreamFinished;
    private int m_streamLength;
    internal long Length { get; }
    internal CatalogedReader(Stream stream);
    internal CatalogedReader(Stream stream, bool isBigEndian);
    internal virtual long get_Length();
    internal virtual bool IsValidIndex(int index, int bytesRequested);
    internal virtual int ToUnshiftedOffset(int offset);
    internal virtual byte ReadByte(int index);
    internal virtual Byte[] GetBytes(int index, int count);
    internal virtual CatalogedReaderBase WithShiftedBaseOffset(int shift);
    internal virtual CatalogedReaderBase WithByteOrder(bool isBigEndian);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal abstract class Syncfusion.Pdf.Graphics.CatalogedReaderBase : object {
    private bool m_isBigEndian;
    internal bool IsBigEndian { get; internal set; }
    internal long Length { get; }
    internal CatalogedReaderBase(bool isBigEndian);
    internal bool get_IsBigEndian();
    internal void set_IsBigEndian(bool value);
    internal abstract virtual CatalogedReaderBase WithByteOrder(bool isBigEndian);
    internal abstract virtual CatalogedReaderBase WithShiftedBaseOffset(int shift);
    internal abstract virtual int ToUnshiftedOffset(int offset);
    internal abstract virtual byte ReadByte(int index);
    internal abstract virtual Byte[] GetBytes(int index, int count);
    internal abstract virtual bool IsValidIndex(int index, int length);
    internal abstract virtual long get_Length();
    internal sbyte ReadSignedByte(int index);
    internal ushort ReadUInt16(int index);
    internal short ReadInt16(int index);
    internal int ReadInt24(int index);
    internal UInt32 ReadUInt32(int index);
    internal int ReadInt32(int index);
    internal long ReadInt64(int index);
    internal float ReadFloat32(int index);
    internal double ReadDouble64(int index);
    internal string ReadString(int index, int length, Encoding encoding);
    internal string ReadNullTerminatedString(int index, int length, Encoding encoding);
    internal string ReadNullTerminatedStringValue(int index, int length, Encoding encoding);
    internal Byte[] ReadNullTerminatedBytes(int index, int maxLength);
}
internal class Syncfusion.Pdf.Graphics.CHARFORMAT : ValueType {
    public int cbSize;
    public UInt32 dwMask;
    public UInt32 dwEffects;
    public int yHeight;
    public int yOffset;
    public int crTextColor;
    public byte bCharSet;
    public byte bPitchAndFamily;
    [NullableAttribute("1")]
public Char[] szFaceName;
    public short wWeight;
    public short sSpacing;
    public int crBackColor;
    public UInt32 lcid;
    public UInt32 dwReserved;
    public short sStyle;
    public short wKerning;
    public byte bUnderlineType;
    public byte bAnimation;
    public byte bRevAuthor;
    public byte bReserved1;
}
internal enum Syncfusion.Pdf.Graphics.ColorIntent : Enum {
    public int value__;
    public static ColorIntent AbsoluteColorimetric;
    public static ColorIntent RelativeColorimetric;
    public static ColorIntent Saturation;
    public static ColorIntent Perceptual;
}
internal enum Syncfusion.Pdf.Graphics.CompositeFontType : Enum {
    public int value__;
    public static CompositeFontType Type0;
    public static CompositeFontType TrueType;
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Syncfusion.Pdf.Graphics.DataType : object {
    internal static DataType Int8Unsigned;
    internal static DataType String;
    internal static DataType Int16Unsigned;
    internal static DataType Int32Unsigned;
    internal static DataType RationalUnsigned;
    internal static DataType Int8Signed;
    internal static DataType Undefined;
    internal static DataType Int16Signed;
    internal static DataType Int32Signed;
    internal static DataType RationalSigned;
    internal static DataType Single;
    internal static DataType Double;
    private string m_name;
    private int m_size;
    private DataTypeID m_type;
    internal string Name { get; }
    internal int Size { get; }
    internal DataTypeID Type { get; }
    private DataType(string name, DataTypeID type, int size);
    private static DataType();
    internal static DataType FromTiffFormatCode(DataTypeID type);
    internal string get_Name();
    internal int get_Size();
    internal DataTypeID get_Type();
    public virtual string ToString();
}
internal enum Syncfusion.Pdf.Graphics.DataTypeID : Enum {
    public ushort value__;
    public static DataTypeID Int8Unsigned;
    public static DataTypeID String;
    public static DataTypeID Int16Unsigned;
    public static DataTypeID Int32Unsigned;
    public static DataTypeID RationalUnsigned;
    public static DataTypeID Int8Signed;
    public static DataTypeID Undefined;
    public static DataTypeID Int16Signed;
    public static DataTypeID Int32Signed;
    public static DataTypeID RationalSigned;
    public static DataTypeID Single;
    public static DataTypeID Double;
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal abstract class Syncfusion.Pdf.Graphics.ElementLayouter : object {
    private PdfLayoutElement m_element;
    protected bool m_isImagePath;
    public PdfLayoutElement Element { get; }
    internal bool IsImagePath { get; internal set; }
    public ElementLayouter(PdfLayoutElement element);
    public PdfLayoutElement get_Element();
    internal bool get_IsImagePath();
    internal void set_IsImagePath(bool value);
    public PdfLayoutResult Layout(PdfLayoutParams param);
    protected virtual PdfLayoutResult LayoutInternal(HtmlToPdfParams param);
    internal PdfLayoutResult Layout(HtmlToPdfParams param);
    public PdfLayoutResult Layout(HtmlToPdfLayoutParams param);
    public PdfPage GetNextPage(PdfPage currentPage);
    protected abstract virtual PdfLayoutResult LayoutInternal(PdfLayoutParams param);
    protected virtual PdfLayoutResult LayoutInternal(HtmlToPdfLayoutParams param);
    protected RectangleF GetPaginateBounds(PdfLayoutParams param);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class Syncfusion.Pdf.Graphics.EndPageLayoutEventArgs : PdfCancelEventArgs {
    private PdfLayoutResult m_result;
    private PdfPage m_nextPage;
    public PdfLayoutResult Result { get; }
    public PdfPage NextPage { get; public set; }
    public EndPageLayoutEventArgs(PdfLayoutResult result);
    public PdfLayoutResult get_Result();
    public PdfPage get_NextPage();
    public void set_NextPage(PdfPage value);
}
public class Syncfusion.Pdf.Graphics.EndPageLayoutEventHandler : MulticastDelegate {
    public EndPageLayoutEventHandler(object object, IntPtr method);
    [NullableContextAttribute("1")]
public virtual void Invoke(object sender, EndPageLayoutEventArgs e);
    public virtual IAsyncResult BeginInvoke(object sender, EndPageLayoutEventArgs e, AsyncCallback callback, object object);
    public virtual void EndInvoke(IAsyncResult result);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class Syncfusion.Pdf.Graphics.EndTextPageLayoutEventArgs : EndPageLayoutEventArgs {
    public PdfTextLayoutResult Result { get; }
    public EndTextPageLayoutEventArgs(PdfTextLayoutResult result);
    public PdfTextLayoutResult get_Result();
}
public class Syncfusion.Pdf.Graphics.EndTextPageLayoutEventHandler : MulticastDelegate {
    public EndTextPageLayoutEventHandler(object object, IntPtr method);
    [NullableContextAttribute("1")]
public virtual void Invoke(object sender, EndTextPageLayoutEventArgs e);
    public virtual IAsyncResult BeginInvoke(object sender, EndTextPageLayoutEventArgs e, AsyncCallback callback, object object);
    public virtual void EndInvoke(IAsyncResult result);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Syncfusion.Pdf.Graphics.FieldPainter : object {
    private static PdfBrush s_whiteBrush;
    private static PdfBrush s_blackBrush;
    private static PdfBrush s_silverBrush;
    private static PdfBrush s_grayBrush;
    private static Dictionary`2<string, PdfPen> s_pens;
    internal static bool isAutoFontSize;
    private static PdfStringFormat s_checkFieldFormat;
    private static PdfBrush WhiteBrush { get; }
    private static PdfBrush BlackBrush { get; }
    private static PdfBrush GrayBrush { get; }
    private static PdfBrush SilverBrush { get; }
    private static PdfStringFormat CheckFieldFormat { get; }
    private static FieldPainter();
    private static PdfBrush get_WhiteBrush();
    private static PdfBrush get_BlackBrush();
    private static PdfBrush get_GrayBrush();
    private static PdfBrush get_SilverBrush();
    private static PdfStringFormat get_CheckFieldFormat();
    public static void DrawButton(PdfGraphics g, PaintParams paintParams, string text, PdfFont font, PdfStringFormat format);
    public static void DrawPressedButton(PdfGraphics g, PaintParams paintParams, string text, PdfFont font, PdfStringFormat format);
    internal static void DrawTextBox(PdfGraphics g, PaintParams paintParams, string text, PdfFont font, PdfStringFormat format, bool multiLine, bool Scroll, int maxLength);
    private static void DrawInsertSpace(PdfGraphics g, PaintParams paintParams, string text, PdfFont font, PdfStringFormat format, bool multiLine, bool scroll, int maxLength);
    public static void DrawInsertSpaceTextBox(PdfGraphics g, PaintParams paintParams, string text, PdfFont font, PdfStringFormat format, bool multiLine, bool scroll);
    public static void DrawTextBox(PdfGraphics g, PaintParams paintParams, string text, PdfFont font, PdfStringFormat format, bool multiLine, bool scroll);
    public static void DrawListBox(PdfGraphics g, PaintParams paintParams, PdfListFieldItemCollection items, Int32[] selectedItem, PdfFont font, PdfStringFormat stringFormat);
    public static void DrawCheckBox(PdfGraphics g, PaintParams paintParams, string checkSymbol, PdfCheckFieldState state);
    public static void DrawCheckBox(PdfGraphics g, PaintParams paintParams, string checkSymbol, PdfCheckFieldState state, PdfFont font);
    public static void DrawComboBox(PdfGraphics g, PaintParams paintParams);
    public static void DrawComboBox(PdfGraphics g, PaintParams paintParams, string text, PdfFont font, PdfStringFormat format);
    public static void DrawRadioButton(PdfGraphics g, PaintParams paintParams, string checkSymbol, PdfCheckFieldState state);
    public static void DrawSignature(PdfGraphics g, PaintParams paintParams);
    public static void DrawEllipseAnnotation(PdfGraphics g, PaintParams paintParams, float x, float y, float width, float height);
    public static void DrawRectangleAnnotation(PdfGraphics g, PaintParams paintParams, float x, float y, float width, float height);
    internal static void DrawPolygonCloud(PdfGraphics g, PdfPen borderPen, PdfBrush backBrush, float intensity, PointF[] points, float borderWidth);
    internal static void DrawRectanglecloud(PdfGraphics g, PaintParams paintparams, RectangleF rectangle, float intensity, float borderWidth);
    private static void DrawCloudStyle(PdfGraphics g, PdfBrush brush, PdfPen pen, float radius, float overlap, PointF[] points, bool isAppearance);
    private static bool IsClockWise(PointF[] points);
    private static PointF GetIntersectionDegrees(PointF point1, PointF point2, float radius);
    public static void DrawFreeTextAnnotation(PdfGraphics g, PaintParams paintParams, string text, PdfFont font, RectangleF rect, bool isSkipDrawRectangle, PdfTextAlignment alignment, bool isRotation);
    private static void DrawBorder(PdfGraphics g, RectangleF bounds, PdfPen borderPen, PdfBorderStyle style, float borderWidth);
    private static void DrawRoundBorder(PdfGraphics g, RectangleF bounds, PdfPen borderPen, float borderWidth);
    private static void DrawRectangularControl(PdfGraphics g, PaintParams paintParams);
    private static void DrawLeftTopShadow(PdfGraphics g, RectangleF bounds, float width, PdfBrush brush);
    private static void DrawRightBottomShadow(PdfGraphics g, RectangleF bounds, float width, PdfBrush brush);
    private static void DrawRoundShadow(PdfGraphics g, PaintParams paintParams, PdfCheckFieldState state);
    private static PdfPen GetPen(PdfColor color, float width);
}
internal enum Syncfusion.Pdf.Graphics.FontDescriptorFlags : Enum {
    public int value__;
    public static FontDescriptorFlags FixedPitch;
    public static FontDescriptorFlags Serif;
    public static FontDescriptorFlags Symbolic;
    public static FontDescriptorFlags Script;
    public static FontDescriptorFlags Nonsymbolic;
    public static FontDescriptorFlags Italic;
    public static FontDescriptorFlags ForceBold;
}
internal enum Syncfusion.Pdf.Graphics.FontEncoding : Enum {
    public int value__;
    public static FontEncoding Unknown;
    public static FontEncoding StandardEncoding;
    public static FontEncoding MacRomanEncoding;
    public static FontEncoding MacExpertEncoding;
    public static FontEncoding WinAnsiEncoding;
    public static FontEncoding PDFDocEncoding;
    public static FontEncoding IdentityH;
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Syncfusion.Pdf.Graphics.Fonts.ArabicReshapeRenderer : object {
    private Regex _vowelMarks;
    internal LetterForms LettersForm;
    internal Regex LigaturesRegex;
    internal ConfigurationManager ConfigurationManager;
    internal LigatureForms LigatureForms;
    private Dictionary`2<string, List`1<string>> _lettersCollection;
    private Dictionary`2<int, Tuple`4<string, string, string, string>> _ligatureMappings;
    public string ReShape(string text);
    private Regex GetMatchCollection();
    public sealed virtual void Dispose();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Syncfusion.Pdf.Graphics.Fonts.ArabicShapeRenderer : object {
    private Char[][] ArabicCharTable;
    private static char Alef;
    private static char AlefHamza;
    private static char AlefHamzaBelow;
    private static char AlefMadda;
    private static char Lam;
    private static char Hamza;
    private static char ZeroWidthJoiner;
    private static char HamzaAbove;
    private static char HamzaBelow;
    private static char WawHamza;
    private static char YehHamza;
    private static char Waw;
    private static char AlefMaksura;
    private static char Yeh;
    private static char FarsiYeh;
    private static char Shadda;
    private static char Madda;
    private static char Lwa;
    private static char Lwawh;
    private static char Lwawhb;
    private static char Lwawm;
    private static char Bwhb;
    private static char Fathatan;
    private static char SuperScriptAlef;
    private static int ConstVowel;
    private Dictionary`2<char, Char[]> m_arabicMapTable;
    internal Dictionary`2<char, Char[]> ArabicMapTable { get; }
    internal Dictionary`2<char, Char[]> get_ArabicMapTable();
    private char GetCharacterShape(char input, int index);
    internal string Shape(Char[] text, int level);
    private string DoShape(Char[] input, int level);
    private void Append(StringBuilder builder, ArabicShape shape, int level);
    private int Ligature(char value, ArabicShape shape);
    private int GetShapeCount(char shape);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal abstract class Syncfusion.Pdf.Graphics.Fonts.BaseTable : object {
    private OtfTable m_otfontTable;
    private int m_lookupID;
    internal OtfTable OTFontTable { get; }
    internal int LookupID { get; }
    internal BaseTable(OtfTable openReader, int lookupFlag);
    internal OtfTable get_OTFontTable();
    internal int get_LookupID();
    internal virtual SubsetTable GetTable(OtfGlyphInfoList glyphList);
    internal virtual int Match(OtfGlyphInfoList glyphList, SubsetTable subsetTable);
    internal abstract virtual IList`1<SubsetTable> GetSubsetTables(int index);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Syncfusion.Pdf.Graphics.Fonts.Bidi : object {
    private Int32[] m_indexes;
    private Byte[] m_indexLevels;
    private Dictionary`2<int, int> m_mirroringShapeCharacters;
    private Dictionary`2<int, List`1<int>> m_ranges;
    internal bool m_isVisualOrder;
    internal Int32[] Indexes { get; internal set; }
    internal Byte[] IndexLevels { get; internal set; }
    internal Int32[] get_Indexes();
    internal void set_Indexes(Int32[] value);
    internal Byte[] get_IndexLevels();
    internal void set_IndexLevels(Byte[] value);
    private string DoMirrorShaping(string text);
    private OtfGlyphInfo[] DoMirrorShaping(OtfGlyphInfo[] text, TtfReader ttfReader);
    internal string GetLogicalToVisualString(string inputText, bool isRTL);
    private void DoBidiOrder(int sIndex, int eIndex);
    internal OtfGlyphInfo[] GetLogicalToVisualGlyphs(List`1<OtfGlyphInfo> inputText, bool isRTL, TtfReader ttfReader, Byte[] bidi);
    private void UpdatePlacementLineGlyphs(Int32[] reorder, Int32[] inverseReorder, List`1<OtfGlyphInfo> reorderedLine);
    private void SetDefaultIndexLevel();
    private void DoOrder(int sIndex, int eIndex);
    private void ReArrange(int i, int j);
    private void Update();
    internal static bool HasAnyRTL(string text);
    internal static bool IsRTLChar(char c);
    internal string DoBidiReverseOrder(string inputText, Byte[] bidi, int trimCount);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Syncfusion.Pdf.Graphics.Fonts.CDEFTable : object {
    internal Dictionary`2<int, int> m_records;
    internal Dictionary`2<int, int> Records { get; internal set; }
    internal Dictionary`2<int, int> get_Records();
    internal void set_Records(Dictionary`2<int, int> value);
    internal int GetValue(int glyph);
    internal bool IsMark(int glyph);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[DefaultMemberAttribute("Item")]
internal class Syncfusion.Pdf.Graphics.Fonts.CjkDifferentWidth : CjkWidth {
    private int m_from;
    private Int32[] m_width;
    internal int From { get; }
    internal int To { get; }
    internal int Item { get; }
    public CjkDifferentWidth(int from, Int32[] widths);
    internal virtual int get_From();
    internal virtual int get_To();
    internal virtual int get_Item(int index);
    internal virtual void AppendToArray(PdfArray arr);
    public virtual CjkWidth Clone();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[DefaultMemberAttribute("Item")]
internal class Syncfusion.Pdf.Graphics.Fonts.CjkSameWidth : CjkWidth {
    private int m_from;
    private int m_to;
    private int m_width;
    internal int From { get; }
    internal int To { get; }
    internal int Item { get; }
    public CjkSameWidth(int from, int to, int width);
    internal virtual int get_From();
    internal virtual int get_To();
    internal virtual int get_Item(int index);
    internal virtual void AppendToArray(PdfArray arr);
    public virtual CjkWidth Clone();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[DefaultMemberAttribute("Item")]
internal abstract class Syncfusion.Pdf.Graphics.Fonts.CjkWidth : object {
    internal int From { get; }
    internal int To { get; }
    internal int Item { get; }
    internal abstract virtual int get_From();
    internal abstract virtual int get_To();
    internal abstract virtual int get_Item(int index);
    internal abstract virtual void AppendToArray(PdfArray arr);
    private sealed virtual override object Syncfusion.Pdf.ICloneable.Clone();
    public abstract virtual CjkWidth Clone();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[DefaultMemberAttribute("Item")]
internal class Syncfusion.Pdf.Graphics.Fonts.CjkWidthTable : WidthTable {
    private List`1<CjkWidth> m_width;
    private int m_defaultWidth;
    public int DefaultWidth { get; }
    public float Item { get; }
    public CjkWidthTable(int defaultWidth);
    public int get_DefaultWidth();
    public virtual float get_Item(int index);
    public void Add(CjkWidth widths);
    public virtual WidthTable Clone();
    internal virtual PdfArray ToArray();
}
internal class Syncfusion.Pdf.Graphics.Fonts.ConfigurationManager : object {
    internal bool DeleteVowelMarks;
    internal bool ShiftVowelMarkPosition;
    internal bool DeleteArabicExtension;
    internal bool SupportArabicTextConnection;
    internal bool UseUnshapedForms;
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Syncfusion.Pdf.Graphics.Fonts.FeatureRecord : ValueType {
    private string m_tag;
    private Int32[] m_indexes;
    internal string Tag { get; internal set; }
    internal Int32[] Indexes { get; internal set; }
    internal string get_Tag();
    internal void set_Tag(string value);
    internal Int32[] get_Indexes();
    internal void set_Indexes(Int32[] value);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Syncfusion.Pdf.Graphics.Fonts.FeatureRecordReader : object {
    private IList`1<FeatureRecord> m_records;
    internal IList`1<FeatureRecord> Records { get; internal set; }
    internal FeatureRecordReader(OtfTable table, int offset);
    internal IList`1<FeatureRecord> get_Records();
    internal void set_Records(IList`1<FeatureRecord> value);
}
internal class Syncfusion.Pdf.Graphics.Fonts.FeatureTag : ValueType {
    [NullableAttribute("1")]
internal string TagName;
    internal int Offset;
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Syncfusion.Pdf.Graphics.Fonts.FeatureTags : object {
    internal static string AccessAllAlternates;
    internal static string AboveBaseForms;
    internal static string AboveBaseMarkPositioning;
    internal static string AboveBaseSubstitutions;
    internal static string AlternativeFractions;
    internal static string Akhands;
    internal static string BelowBaseForms;
    internal static string BelowBaseMarkPositioning;
    internal static string BelowBaseSubstitutions;
    internal static string PetiteCapitalsFromCapitals;
    internal static string SmallCapitalsFromCapitals;
    internal static string ContextualAlternates;
    internal static string CaseSensitiveForms;
    internal static string GlyphCompositionDecomposition;
    internal static string Conjunctformafterro;
    internal static string ContextualLigatures;
    internal static string Conjuncts;
    internal static string CapitalSpacing;
    internal static string ContextualSwash;
    internal static string CursivePositioning;
    internal static string DefaultProcessing;
    internal static string Distances;
    internal static string DiscretionaryLigatures;
    internal static string Denominators;
    internal static string Diphthongs;
    internal static string ExpertForms;
    internal static string FinalglyphAlternates;
    internal static string TerminalForms;
    internal static string TerminalForms2;
    internal static string TerminalForms3;
    internal static string Fractions;
    internal static string FullWidth;
    internal static string HalfForms;
    internal static string HalantForms;
    internal static string AlternateHalfWidth;
    internal static string HistoricalForms;
    internal static string HorizontalKanaAlternates;
    internal static string HistoricalLigatures;
    internal static string Hangul;
    internal static string HalfWidth;
    internal static string HojoKanjiForms;
    internal static string InitialForms;
    internal static string IsolatedForms;
    internal static string Italics;
    internal static string JapaneseForms;
    internal static string JustificationAlternatives;
    internal static string JIS04Forms;
    internal static string JIS78Forms;
    internal static string JIS83Forms;
    internal static string JIS90Forms;
    internal static string Kerning;
    internal static string LeftBounds;
    internal static string StandardLigatures;
    internal static string LeadingJamoForms;
    internal static string LiningFigures;
    internal static string LocalizedForms;
    internal static string MarkPositioning;
    internal static string MedialForms;
    internal static string MedialForms2;
    internal static string MathematicalGreek;
    internal static string MarktoMarkPositioning;
    internal static string MarkPositioningviaSubstitution;
    internal static string AlternateAnnotationForms;
    internal static string NLCKanjiForms;
    internal static string NuktaForms;
    internal static string Numerators;
    internal static string OldStyleFigures;
    internal static string OpticalBounds;
    internal static string Ordinals;
    internal static string Ornaments;
    internal static string ProportionalAlternateWidth;
    internal static string PetiteCapitals;
    internal static string ProportionalFigures;
    internal static string PrebaseForms;
    internal static string PrebaseSubstitutions;
    internal static string PostbaseForms;
    internal static string PostbaseSubstitutions;
    internal static string ProportionalWidths;
    internal static string QuarterWidths;
    internal static string Randomize;
    internal static string RakarForms;
    internal static string RequiredLigatures;
    internal static string RephForm;
    internal static string RightBounds;
    internal static string RightToLeftAlternates;
    internal static string RubyNotationForms;
    internal static string StylisticAlternates;
    internal static string ScientificInferiors;
    internal static string OpticalSize;
    internal static string SmallCapitals;
    internal static string SimplifiedForms;
    internal static string StylisticSet1;
    internal static string StylisticSet2;
    internal static string StylisticSet3;
    internal static string StylisticSet4;
    internal static string StylisticSet5;
    internal static string StylisticSet6;
    internal static string StylisticSet7;
    internal static string StylisticSet8;
    internal static string StylisticSet9;
    internal static string StylisticSet10;
    internal static string StylisticSet11;
    internal static string StylisticSet12;
    internal static string StylisticSet13;
    internal static string StylisticSet14;
    internal static string StylisticSet15;
    internal static string StylisticSet16;
    internal static string StylisticSet17;
    internal static string StylisticSet18;
    internal static string StylisticSet19;
    internal static string StylisticSet20;
    internal static string Subscript;
    internal static string Superscript;
    internal static string Swash;
    internal static string Titling;
    internal static string TrailingJamoForms;
    internal static string TraditionalNameForms;
    internal static string TabularFigures;
    internal static string TraditionalForms;
    internal static string ThirdWidths;
    internal static string Unicase;
    internal static string AlternateVerticalMetrics;
    internal static string VattuVariants;
    internal static string VerticalWriting;
    internal static string AlternateVerticalHalfMetrics;
    internal static string VowelJamoForms;
    internal static string VerticalKanaAlternates;
    internal static string VerticalKerning;
    internal static string ProportionalAlternateVerticalMetrics;
    internal static string VerticalRotation;
    internal static string SlashedZero;
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Syncfusion.Pdf.Graphics.Fonts.GDEFTable : object {
    private CDEFTable m_glyphCdefTable;
    private CDEFTable m_markAttachmentCdefTable;
    internal CDEFTable GlyphCdefTable { get; internal set; }
    internal CDEFTable MarkAttachmentCdefTable { get; internal set; }
    internal GDEFTable(BigEndianReader reader, TtfTableInfo tableInfo);
    internal CDEFTable get_GlyphCdefTable();
    internal void set_GlyphCdefTable(CDEFTable value);
    internal CDEFTable get_MarkAttachmentCdefTable();
    internal void set_MarkAttachmentCdefTable(CDEFTable value);
    private CDEFTable GetTable(BigEndianReader reader, int offset);
    internal bool IsSkip(int glyph, int flag);
}
internal class Syncfusion.Pdf.Graphics.Fonts.GlyphComparer : object {
    [NullableContextAttribute("1")]
public sealed virtual int Compare(OtfGlyphInfo otg1, OtfGlyphInfo otg2);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Syncfusion.Pdf.Graphics.Fonts.GlyphInfoIndex : object {
    private OtfGlyphInfoList m_glyphInfoList;
    private OtfGlyphInfo m_glyphInfo;
    private int m_index;
    internal OtfGlyphInfoList GlyphInfoList { get; internal set; }
    internal OtfGlyphInfo GlyphInfo { get; internal set; }
    internal int Index { get; internal set; }
    internal OtfGlyphInfoList get_GlyphInfoList();
    internal void set_GlyphInfoList(OtfGlyphInfoList value);
    internal OtfGlyphInfo get_GlyphInfo();
    internal void set_GlyphInfo(OtfGlyphInfo value);
    internal int get_Index();
    internal void set_Index(int value);
    internal virtual void MoveNext(OtfTable table, int flag);
    internal virtual void MovePrevious(OtfTable table, int flag);
}
internal class Syncfusion.Pdf.Graphics.Fonts.GPOSRecord : object {
    internal int Index;
    [NullableAttribute("1")]
internal GPOSValueRecord Record;
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Syncfusion.Pdf.Graphics.Fonts.GPOSRecordsCollection : object {
    internal IDictionary`2<int, GPOSRecord> Records;
    internal IDictionary`2<int, GPOSValueRecord[]> Collection;
    internal IDictionary`2<int, IList`1<GPOSValueRecord[]>> Ligatures;
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Syncfusion.Pdf.Graphics.Fonts.GPOSTable : OtfTable {
    internal GPOSTable(BigEndianReader reader, int offset, GDEFTable gdef, TtfReader ttfReader);
    internal virtual LookupTable ReadLookupTable(int type, int flag, Int32[] offsets);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Syncfusion.Pdf.Graphics.Fonts.GPOSTableFormat : LookupTable {
    private Dictionary`2<int, Dictionary`2<int, GPOSTableFormatRecord>> m_records;
    private CDEFTable m_cdefTable1;
    private CDEFTable m_cdefTable2;
    private IList`1<int> m_coverageTable;
    private IDictionary`2<int, GPOSTableFormatRecord[]> m_gposTableFormatRecord;
    private GPOSTableType m_format;
    internal GPOSTableFormat(OtfTable table, int flag, int offset, GPOSTableType format);
    internal virtual bool ReplaceGlyph(OtfGlyphInfoList glyphList);
    private bool ReplaceFormat1Glyphs(OtfGlyphInfoList glyphList);
    private bool ReplaceFormat2Glyphs(OtfGlyphInfoList line);
    internal virtual void ReadSubTable(int offset);
    private void Initialize(int offset);
    private void ReadFormat1(int offset);
    private void ReadFormat2(int offset);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Syncfusion.Pdf.Graphics.Fonts.GPOSTableFormatRecord : object {
    internal GPOSValueRecord Record1;
    internal GPOSValueRecord Record2;
}
internal enum Syncfusion.Pdf.Graphics.Fonts.GPOSTableType : Enum {
    public int value__;
    public static GPOSTableType Format1;
    public static GPOSTableType Format2;
}
internal class Syncfusion.Pdf.Graphics.Fonts.GPOSValueRecord : object {
    internal int XPlacement;
    internal int YPlacement;
    internal int XAdvance;
    internal int YAdvance;
    internal int XPlaDevice;
    internal int YPlaDevice;
    internal int XAdvDevice;
    internal int YAdvDevice;
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Syncfusion.Pdf.Graphics.Fonts.GSUBTable : OtfTable {
    internal GSUBTable(BigEndianReader reader, int gsubTableLocation, GDEFTable gdef, TtfReader ttfReader);
    internal virtual LookupTable ReadLookupTable(int type, int flag, Int32[] offset);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Syncfusion.Pdf.Graphics.Fonts.IndicCharacterClassifier : object {
    private Int32[] m_indicCharClasses;
    private static int Devanagari;
    private static int Bengali;
    private static int Gujarati;
    private static int Gurmukhi;
    private static int Kannada;
    private static int Malayalam;
    private static int Oriya;
    private static int Tamil;
    private static int Telugu;
    private static int Sinhala;
    private static int Khmer;
    private Dictionary`2<int, char> m_characters;
    private string m_pattern;
    internal string Pattern { get; }
    internal string get_Pattern();
    internal string GetClustersPattern(OtfGlyphInfoList glyphList);
    private string BuildPattern();
    internal int GetClass(int index);
    internal int GetPosition(int unicode, int side);
}
internal class Syncfusion.Pdf.Graphics.Fonts.IndicFlags : object {
    internal static long Medial;
    internal static long Consonant;
    internal static long Joiner;
    internal static long Halant;
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Syncfusion.Pdf.Graphics.Fonts.IndicGlyphInfo : OtfGlyphInfo {
    private static Int32[] m_initialChars;
    private int m_group;
    private int m_position;
    private int m_mask;
    private bool m_substitute;
    private bool m_ligate;
    internal int Group { get; internal set; }
    internal int Position { get; internal set; }
    internal int Mask { get; internal set; }
    internal bool Substitute { get; internal set; }
    internal bool Ligate { get; internal set; }
    internal IndicGlyphInfo(OtfGlyphInfo glyph);
    internal IndicGlyphInfo(OtfGlyphInfo glyph, int category, int indicPos, int mask);
    internal IndicGlyphInfo(OtfGlyphInfo glyph, int category, int position, int mask, bool substitute, bool ligate);
    private static IndicGlyphInfo();
    internal int get_Group();
    internal void set_Group(int value);
    internal int get_Position();
    internal void set_Position(int value);
    internal int get_Mask();
    internal void set_Mask(int value);
    internal virtual bool get_Substitute();
    internal virtual void set_Substitute(bool value);
    internal virtual bool get_Ligate();
    internal virtual void set_Ligate(bool value);
    public virtual bool Equals(object obj);
    internal void Update();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[DefaultMemberAttribute("Item")]
internal class Syncfusion.Pdf.Graphics.Fonts.IndicGlyphInfoList : OtfGlyphInfoList {
    private int m_glyphInfoStart;
    private int m_glyphInfoEnd;
    internal int GlyphInfoStart { get; internal set; }
    internal int GlyphInfoEnd { get; internal set; }
    internal IndicGlyphInfo Item { get; }
    internal IndicGlyphInfoList(OtfGlyphInfoList glyphInfoList, int start, int end, string text);
    internal int get_GlyphInfoStart();
    internal void set_GlyphInfoStart(int value);
    internal int get_GlyphInfoEnd();
    internal void set_GlyphInfoEnd(int value);
    internal IndicGlyphInfo get_Item(int index);
    internal void DoOrder();
    private void Order(List`1<T> glyphList, int l, int r);
    private void Order(List`1<T> glyphList, int l, int m, int r, IComparer`1<T> comparer);
    internal virtual string GetText();
    internal virtual void CombineAlternateGlyphs(OtfTable table, int flag, int length, int glyphIndex);
    internal virtual void CombineAlternateGlyphs(OtfTable table, int glyphIndex);
    internal virtual void CombineAlternateGlyphs(OtfTable table, Int32[] glyphIndexes);
    internal OtfGlyphInfoList SubSet(int start, int end);
    internal virtual void Rearrange(int d, int s, int count);
    public virtual bool Equals(object obj);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Syncfusion.Pdf.Graphics.Fonts.IndicGlyphItem : object {
    private IndicGlyphInfoList m_glyphList;
    private int m_position;
    internal IndicGlyphInfoList GlyphList { get; internal set; }
    internal int Position { get; internal set; }
    internal int Length { get; }
    internal IndicGlyphItem(IndicGlyphInfoList glyphInfoList, int position);
    internal IndicGlyphInfoList get_GlyphList();
    internal void set_GlyphList(IndicGlyphInfoList value);
    internal int get_Position();
    internal void set_Position(int value);
    internal virtual int get_Length();
    public virtual bool Equals(object obj);
}
internal class Syncfusion.Pdf.Graphics.Fonts.IndicScript : ValueType {
    internal bool OldVersion;
    internal int InitialChar;
    internal int Position;
    internal int RephPosition;
    internal int RephMode;
    internal int BlwfMode;
    internal int Length;
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Syncfusion.Pdf.Graphics.Fonts.IndicScriptLayouter : object {
    private Dictionary`2<int, Int32[]> m_defaultGlyphs;
    internal void ReplaceDefaultGlyphs(UnicodeTrueTypeFont font, OtfGlyphInfoList glyphList);
    internal void SetPosition(UnicodeTrueTypeFont font, IndicGlyphInfoList indicGlyphList, IndicScript iScript, IList`1<LookupTable> belowBaseForm, IList`1<LookupTable> postBaseForm, IList`1<LookupTable> preBaseForm);
    internal void Reorder(IndicGlyphInfoList glyphInfoList, IndicScript indicScript, IList`1<LookupTable> rephForm, IList`1<LookupTable> prebaseForm, bool oldScript, ScriptTags scriptTag);
    internal bool IsCombined(int group);
    internal bool IsConsonant(int group);
    internal bool IsHalant(int group);
    internal bool IsPresent(int group, long flag);
    internal void Reorder(IndicGlyphInfoList glyphInfoList, IndicScript iScript, ScriptTags scriptTag);
    private Int32[] GetIndicMask();
    private bool Replace(IList`1<LookupTable> featureTables, IList`1<OtfGlyphInfo> glyphInfo, int glyphLength);
    private OtfGlyphInfo GetGlyph(UnicodeTrueTypeFont font, IndicScript indicScript);
    private int GetPosition(OtfGlyphInfo glyphInfo, OtfGlyphInfo advancedGlyphInfo, IndicScript iScript, IList`1<LookupTable> belowBaseForm, IList`1<LookupTable> postBaseForm, IList`1<LookupTable> preBaseForm);
    private void Replace(OtfGlyphInfoList glyphList, int index, UnicodeTrueTypeFont font, Int32[] charCodes);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Syncfusion.Pdf.Graphics.Fonts.LanguageRecord : object {
    private string m_tag;
    private Int32[] m_records;
    internal string LanguageTag { get; internal set; }
    internal Int32[] Records { get; internal set; }
    internal string get_LanguageTag();
    internal void set_LanguageTag(string value);
    internal Int32[] get_Records();
    internal void set_Records(Int32[] value);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Syncfusion.Pdf.Graphics.Fonts.LanguageScriptTags : object {
    internal static string Arabic;
    internal static string Armenian;
    internal static string Balinese;
    internal static string Bengali;
    internal static string Bengali_v2;
    internal static string Bopomofo;
    internal static string Braille;
    internal static string Buginese;
    internal static string Buhid;
    internal static string ByzantineMusic;
    internal static string CanadianSyllabics;
    internal static string Cherokee;
    internal static string CJKIdeographic;
    internal static string Coptic;
    internal static string CypriotSyllabary;
    internal static string Cyrillic;
    internal static string Default;
    internal static string Deseret;
    internal static string Devanagari;
    internal static string Devanagari_v2;
    internal static string Ethiopic;
    internal static string Georgian;
    internal static string Glagolitic;
    internal static string Gothic;
    internal static string Greek;
    internal static string Gujarati;
    internal static string Gujarati_v2;
    internal static string Gurmukhi;
    internal static string Gurmukhi_v2;
    internal static string HangulJamo;
    internal static string Hangul;
    internal static string Hanunoo;
    internal static string Hebrew;
    internal static string Hiragana;
    internal static string Javanese;
    internal static string Kannada;
    internal static string Kannada_v2;
    internal static string Katakana;
    internal static string Kharosthi;
    internal static string Khmer;
    internal static string Lao;
    internal static string Latin;
    internal static string Limbu;
    internal static string LinearB;
    internal static string Malayalam;
    internal static string Malayalam_v2;
    internal static string MathematicalAlphanumericSymbols;
    internal static string Mongolian;
    internal static string MusicalSymbols;
    internal static string Myanmar;
    internal static string Nko;
    internal static string Ogham;
    internal static string OldItalic;
    internal static string OldPersianCuneiform;
    internal static string Oriya;
    internal static string Oriya_v2;
    internal static string Osmanya;
    internal static string Phagspa;
    internal static string Phoenician;
    internal static string Runic;
    internal static string Shavian;
    internal static string Sinhala;
    internal static string SumeroAkkadianCuneiform;
    internal static string SylotiNagri;
    internal static string Syriac;
    internal static string Tagalog;
    internal static string Tagbanwa;
    internal static string TaiLe;
    internal static string NewTaiLue;
    internal static string Tamil;
    internal static string Tamil_v2;
    internal static string Telugu;
    internal static string Telugu_v2;
    internal static string Thaana;
    internal static string Thai;
    internal static string Tibetan;
    internal static string Tifinagh;
    internal static string UgariticCuneiform;
    internal static string Yi;
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Syncfusion.Pdf.Graphics.Fonts.LanguageUtil : object {
    internal Dictionary`2<int, UnicodeLanguageInfo> languageTags;
    private static Int32[] dicardCharacters;
    private Int32[] tagStart;
    private int max_code;
    private ScriptTags[] unicodeTags;
    private static LanguageUtil();
    internal ScriptTags GetLanguage(char c);
    private T GetScriptTag(string languageName);
    internal int FindIndex(Int32[] array, char key);
    internal ScriptTags GetGlyphTag(int code);
    private bool IsValidCode(int code);
    private void UpdateLanguages();
    internal static bool IsDiscardGlyph(int charCode);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Syncfusion.Pdf.Graphics.Fonts.LetterForms : object {
    internal static int Unshaped;
    internal static int Isolated;
    internal static int Initial;
    internal static int Medial;
    internal static int Final;
    internal static string ArabicExtension;
    internal static string ArabicTextConnection;
    internal Dictionary`2<string, List`1<string>> LettersCollection;
    private static LetterForms();
    internal bool ConnectsWithLetterBefore(string letter, Dictionary`2<string, List`1<string>> letters);
    internal bool ConnectsWithLetterAfter(string letter, Dictionary`2<string, List`1<string>> letters);
    internal bool ConnectsWithLettersBeforeAndAfter(string letter, Dictionary`2<string, List`1<string>> letters);
}
internal class Syncfusion.Pdf.Graphics.Fonts.LigatureForms : object {
    [NullableContextAttribute("1")]
internal List`1<Tuple`2<string, Tuple`2<string, Tuple`4<string, string, string, string>>>> GetLigatures();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal abstract class Syncfusion.Pdf.Graphics.Fonts.LookupSubTable : BaseTable {
    internal LookupSubTable(OtfTable table, int flag);
    internal virtual SubsetTable GetTable(OtfGlyphInfoList glyphList);
    internal bool Lookup(OtfGlyphInfoList glyphList, SubsetTable subsetTable, int index);
    internal bool BackTrack(OtfGlyphInfoList glyphList, SubsetTable subsetTable);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Syncfusion.Pdf.Graphics.Fonts.LookupSubTable1 : LookupTable {
    private Dictionary`2<int, int> m_records;
    internal LookupSubTable1(OtfTable table, int flag, Int32[] offsets);
    internal virtual bool ReplaceGlyph(OtfGlyphInfoList glyphList);
    internal virtual void ReadSubTable(int offset);
    internal virtual bool IsSubstitute(int index);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Syncfusion.Pdf.Graphics.Fonts.LookupSubTable2 : LookupTable {
    private IDictionary`2<int, Int32[]> m_records;
    internal LookupSubTable2(OtfTable table, int flag, Int32[] offsets);
    internal virtual bool ReplaceGlyph(OtfGlyphInfoList glyphList);
    internal virtual void ReadSubTable(int offset);
    internal virtual bool IsSubstitute(int index);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Syncfusion.Pdf.Graphics.Fonts.LookupSubTable3 : LookupTable {
    private IDictionary`2<int, Int32[]> m_records;
    internal LookupSubTable3(OtfTable table, int flag, Int32[] offsets);
    internal virtual bool ReplaceGlyph(OtfGlyphInfoList glyphList);
    internal virtual void ReadSubTable(int offset);
    internal virtual bool IsSubstitute(int index);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Syncfusion.Pdf.Graphics.Fonts.LookupSubTable4 : LookupTable {
    private IDictionary`2<int, IList`1<Int32[]>> m_records;
    internal LookupSubTable4(OtfTable table, int flag, Int32[] offsets);
    internal virtual bool ReplaceGlyph(OtfGlyphInfoList glyphList);
    internal virtual void ReadSubTable(int offset);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Syncfusion.Pdf.Graphics.Fonts.LookupSubTable5 : LookupTable {
    protected internal IList`1<BaseTable> m_records;
    protected internal LookupSubTable5(OtfTable table, int flag, Int32[] offsets);
    internal virtual bool ReplaceGlyph(OtfGlyphInfoList glyphList);
    internal virtual void ReadSubTable(int offset);
    internal virtual void ReadSubTableFormat1(int offset);
    internal virtual void ReadSubTableFormat2(int offset);
    internal virtual void ReadSubTableFormat3(int offset);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Syncfusion.Pdf.Graphics.Fonts.LookupSubTable5Format : BaseTable {
    private IDictionary`2<int, IList`1<SubsetTable>> m_records;
    private ICollection`1<int> m_glyphIds;
    private IList`1<IList`1<SubsetTable>> m_subsetTables;
    private SubsetTable m_subSetTable;
    private CDEFTable m_cdefTable;
    private LookupSubTableFormat m_format;
    internal CDEFTable CDEFTable { get; internal set; }
    internal IList`1<IList`1<SubsetTable>> SubsetTables { get; internal set; }
    internal LookupSubTable5Format(OtfTable table, int flag, IDictionary`2<int, IList`1<SubsetTable>> records, LookupSubTableFormat format);
    internal LookupSubTable5Format(OtfTable table, int flag, ICollection`1<int> glyphIds, CDEFTable ctable, LookupSubTableFormat format);
    internal LookupSubTable5Format(OtfTable table, int flag, SubsetTableFormat subsetTable, LookupSubTableFormat format);
    internal CDEFTable get_CDEFTable();
    internal void set_CDEFTable(CDEFTable value);
    internal IList`1<IList`1<SubsetTable>> get_SubsetTables();
    internal void set_SubsetTables(IList`1<IList`1<SubsetTable>> value);
    internal virtual IList`1<SubsetTable> GetSubsetTables(int index);
}
internal class Syncfusion.Pdf.Graphics.Fonts.LookupSubTable6 : LookupSubTable5 {
    [NullableContextAttribute("1")]
internal LookupSubTable6(OtfTable table, int flag, Int32[] offsets);
    internal virtual void ReadSubTableFormat1(int offset);
    internal virtual void ReadSubTableFormat2(int offset);
    internal virtual void ReadSubTableFormat3(int offset);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Syncfusion.Pdf.Graphics.Fonts.LookupSubTable6Format : LookupSubTable {
    private IDictionary`2<int, IList`1<SubsetTable>> m_records;
    private LookupSubTableFormat m_format;
    private ICollection`1<int> m_glyphs;
    private IList`1<IList`1<SubsetTable>> m_subSetTables;
    private CDEFTable m_btCdefTable;
    private CDEFTable m_cdefTable;
    private CDEFTable m_lookupCdefTable;
    private SubsetTable m_subsetTable;
    internal IList`1<IList`1<SubsetTable>> SubSetTables { get; internal set; }
    internal CDEFTable CDEFTable { get; internal set; }
    internal CDEFTable BtCDEFTable { get; internal set; }
    internal CDEFTable LookupCDEFTable { get; internal set; }
    internal LookupSubTable6Format(OtfTable table, int flag, IDictionary`2<int, IList`1<SubsetTable>> substMap, LookupSubTableFormat format);
    internal LookupSubTable6Format(OtfTable table, int flag, ICollection`1<int> glyphs, CDEFTable btcdef, CDEFTable cdef, CDEFTable lookupcdef, LookupSubTableFormat format);
    internal LookupSubTable6Format(OtfTable table, int flag, SubsetTableFormat subsetFormat, LookupSubTableFormat format);
    internal IList`1<IList`1<SubsetTable>> get_SubSetTables();
    internal void set_SubSetTables(IList`1<IList`1<SubsetTable>> value);
    internal CDEFTable get_CDEFTable();
    internal void set_CDEFTable(CDEFTable value);
    internal CDEFTable get_BtCDEFTable();
    internal void set_BtCDEFTable(CDEFTable value);
    internal CDEFTable get_LookupCDEFTable();
    internal void set_LookupCDEFTable(CDEFTable value);
    internal virtual IList`1<SubsetTable> GetSubsetTables(int index);
}
internal enum Syncfusion.Pdf.Graphics.Fonts.LookupSubTableFormat : Enum {
    public int value__;
    public static LookupSubTableFormat Format1;
    public static LookupSubTableFormat Format2;
    public static LookupSubTableFormat Format3;
}
internal class Syncfusion.Pdf.Graphics.Fonts.LookupSubTableRecord : ValueType {
    internal int Index;
    internal int LookupIndex;
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal abstract class Syncfusion.Pdf.Graphics.Fonts.LookupTable : object {
    private int m_flag;
    private Int32[] m_offsets;
    private OtfTable m_opentypeFontTable;
    internal int Flag { get; internal set; }
    internal Int32[] Offsets { get; internal set; }
    internal OtfTable OpenTypeFontTable { get; internal set; }
    internal LookupTable(OtfTable otFontTable, int flag, Int32[] offsets);
    internal int get_Flag();
    internal void set_Flag(int value);
    internal Int32[] get_Offsets();
    internal void set_Offsets(Int32[] value);
    internal OtfTable get_OpenTypeFontTable();
    internal void set_OpenTypeFontTable(OtfTable value);
    internal GPOSValueRecord ReadGposValueRecord(OtfTable table, int foramt);
    internal IList`1<GPOSRecord> ReadMark(OtfTable table, int location);
    internal GPOSValueRecord ReadGposValueRecords(OtfTable table, int location);
    internal IList`1<GPOSValueRecord[]> ReadBaseArray(OtfTable table, int classCount, int location);
    internal GPOSValueRecord[] ReadAnchorArray(OtfTable tableReader, Int32[] locations, int left, int right);
    internal IList`1<IList`1<GPOSValueRecord[]>> ReadLigatureArray(OtfTable tableReader, int classCount, int location);
    internal CDEFTable GetTable(BigEndianReader reader, int offset);
    internal abstract virtual bool ReplaceGlyph(OtfGlyphInfoList glyphList);
    internal abstract virtual void ReadSubTable(int offset);
    internal virtual bool ReplaceGlyphs(OtfGlyphInfoList glyphInfoList);
    internal virtual bool IsSubstitute(int index);
    internal virtual void ReadSubTables();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Syncfusion.Pdf.Graphics.Fonts.LookupTable1 : LookupTable {
    private Dictionary`2<int, GPOSValueRecord> m_records;
    internal LookupTable1(OtfTable table, int flag, Int32[] offsets);
    internal virtual bool ReplaceGlyph(OtfGlyphInfoList glyphList);
    internal virtual void ReadSubTable(int offset);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Syncfusion.Pdf.Graphics.Fonts.LookupTable2 : LookupTable {
    private IList`1<LookupTable> m_records;
    internal LookupTable2(OtfTable table, int flag, Int32[] offsets);
    internal virtual bool ReplaceGlyph(OtfGlyphInfoList glyphList);
    internal virtual void ReadSubTable(int offset);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Syncfusion.Pdf.Graphics.Fonts.LookupTable4 : LookupTable {
    private IList`1<GPOSRecordsCollection> m_recordCollection;
    internal LookupTable4(OtfTable table, int flag, Int32[] offset);
    internal virtual bool ReplaceGlyph(OtfGlyphInfoList glyphList);
    internal virtual void ReadSubTable(int offset);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Syncfusion.Pdf.Graphics.Fonts.LookupTable5 : LookupTable {
    private IList`1<GPOSRecordsCollection> m_records;
    internal LookupTable5(OtfTable table, int flag, Int32[] offsets);
    internal virtual bool ReplaceGlyph(OtfGlyphInfoList glyphList);
    internal virtual void ReadSubTable(int offset);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Syncfusion.Pdf.Graphics.Fonts.LookupTable6 : LookupTable {
    private IList`1<GPOSRecordsCollection> m_records;
    internal LookupTable6(OtfTable table, int flag, Int32[] offsets);
    internal virtual bool ReplaceGlyph(OtfGlyphInfoList glyphList);
    internal virtual void ReadSubTable(int offset);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Syncfusion.Pdf.Graphics.Fonts.OtfGlyphInfo : object {
    private int m_index;
    private int m_charCode;
    private Char[] m_chars;
    private float m_width;
    internal int leadingX;
    internal int leadingY;
    internal int xAdvance;
    internal int yAdvance;
    internal int m_placment;
    internal bool unsupportedGlyph;
    internal int Index { get; internal set; }
    internal int CharCode { get; internal set; }
    internal Char[] Characters { get; internal set; }
    internal float Width { get; internal set; }
    internal OtfGlyphInfo(int charCode, int index, float width);
    internal OtfGlyphInfo(OtfGlyphInfo glyph, int x, int y);
    internal OtfGlyphInfo(OtfGlyphInfo glyph);
    internal OtfGlyphInfo(OtfGlyphInfo glyph, int xPlacement, int yPlacement, int xAdvance, int yAdvance, int m_placment);
    internal int get_Index();
    internal void set_Index(int value);
    internal int get_CharCode();
    internal void set_CharCode(int value);
    internal Char[] get_Characters();
    internal void set_Characters(Char[] value);
    internal float get_Width();
    internal void set_Width(float value);
    internal bool HasOffset();
    internal bool HasPlacement();
    internal bool HasAdvance();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Syncfusion.Pdf.Graphics.Fonts.OtfGlyphInfoList : object {
    private List`1<OtfGlyphInfo> m_glyphs;
    private int m_start;
    private int m_end;
    private int m_index;
    private List`1<string> m_text;
    private bool m_isThaiShape;
    internal List`1<string> Text { get; internal set; }
    internal List`1<OtfGlyphInfo> Glyphs { get; internal set; }
    internal int Start { get; internal set; }
    internal int End { get; internal set; }
    internal int Index { get; internal set; }
    internal bool IsThaiShaping { get; internal set; }
    internal OtfGlyphInfoList(List`1<OtfGlyphInfo> glyphs, int start, int end);
    internal OtfGlyphInfoList(OtfGlyphInfo[] glyphs, int start, int end);
    internal OtfGlyphInfoList(List`1<OtfGlyphInfo> glyphs);
    internal OtfGlyphInfoList(OtfGlyphInfoList glyphList, int start, int end);
    internal List`1<string> get_Text();
    internal void set_Text(List`1<string> value);
    internal List`1<OtfGlyphInfo> get_Glyphs();
    internal void set_Glyphs(List`1<OtfGlyphInfo> value);
    internal int get_Start();
    internal void set_Start(int value);
    internal int get_End();
    internal void set_End(int value);
    internal int get_Index();
    internal void set_Index(int value);
    internal bool get_IsThaiShaping();
    internal void set_IsThaiShaping(bool value);
    internal bool HasYPlacement();
    internal void SetGlyphs(List`1<OtfGlyphInfo> glyphs);
    internal virtual void CombineAlternateGlyphs(OtfTable table, Int32[] glyphs);
    internal virtual void CombineAlternateGlyphs(OtfTable table, int flag, int length, int glyphIndex);
    private void RemoveGlyph(int index);
    internal virtual void CombineAlternateGlyphs(OtfTable table, int glyphIndex);
    internal virtual OtfGlyphInfo Set(int index, OtfGlyphInfo glyph);
    internal virtual OtfGlyphInfoList SubSet(int start, int end);
    internal virtual void ReplaceContent(OtfGlyphInfoList glyphList);
    internal virtual void SetText(int start, int end, string text);
    private void InsertGlyphs(int index, IList`1<OtfGlyphInfo> glyphs);
    private void MoveGlyph(int end, int start, int count);
    private bool ThaiToneMark(int charcode);
    private bool ThaiGlyphRanges(int charcode, int lowest1, int heighest1, int lowest2, int heighest2, int lowest3, int heighest3);
    private bool ThaiGlyphRange(int charcode, int low, int high);
    internal bool HasOffSet();
    private bool HasAdvance();
    private bool HasPlacement();
    internal bool HasArabicScript();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Syncfusion.Pdf.Graphics.Fonts.OtfGlyphTokenizer : object {
    internal OtfGlyphInfoList m_glyphInfoList;
    internal int m_position;
    internal OtfGlyphTokenizer(OtfGlyphInfoList glyphInfoList);
    internal OtfGlyphInfo[] ReadWord(String& text);
    internal OtfGlyphInfo[][] SplitGlyphs(List`1<OtfGlyphInfo> glyphs);
    internal float GetLineWidth(OtfGlyphInfo[] glyphs, PdfTrueTypeFont font, PdfStringFormat format);
    internal float GetLineWidth(OtfGlyphInfo[] glyphs, PdfTrueTypeFont font, PdfStringFormat format, string text, Single& outWordSpace, Single& outCharSpace);
    internal float GetLineWidth(OtfGlyphInfo glyphs, PdfTrueTypeFont font, PdfStringFormat format);
    protected float ApplyFormatSettings(OtfGlyphInfo[] glyphs, PdfStringFormat format, float width, string text, Single& outWordSpace, Single& outCharSpace);
    protected float ApplyFormatSettings(OtfGlyphInfo[] glyphs, PdfStringFormat format, float width);
    protected int GetCharsCount(OtfGlyphInfo[] glyphs);
    internal OtfGlyphInfoList TrimEndSpaces(OtfGlyphInfoList glyphList);
    internal OtfGlyphInfoList TrimStartSpaces(OtfGlyphInfoList glyphList);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal abstract class Syncfusion.Pdf.Graphics.Fonts.OtfTable : object {
    private BigEndianReader m_reader;
    private int m_offset;
    private GDEFTable m_gdefTable;
    private IList`1<LookupTable> m_lookupList;
    private ScriptRecordReader m_otScript;
    private FeatureRecordReader m_otFeature;
    internal TtfReader m_ttfReader;
    internal FeatureRecordReader OTFeature { get; internal set; }
    internal IList`1<LookupTable> LookupList { get; internal set; }
    internal BigEndianReader Reader { get; internal set; }
    internal int Offset { get; internal set; }
    internal GDEFTable GDEFTable { get; internal set; }
    protected internal OtfTable(BigEndianReader reader, int offset, GDEFTable gdef, TtfReader ttfReader);
    internal abstract virtual LookupTable ReadLookupTable(int lookupType, int lookupFlag, Int32[] subTableLocations);
    internal FeatureRecordReader get_OTFeature();
    internal void set_OTFeature(FeatureRecordReader value);
    internal IList`1<LookupTable> get_LookupList();
    internal void set_LookupList(IList`1<LookupTable> value);
    internal BigEndianReader get_Reader();
    internal void set_Reader(BigEndianReader value);
    internal int get_Offset();
    internal void set_Offset(int value);
    internal GDEFTable get_GDEFTable();
    internal void set_GDEFTable(GDEFTable value);
    internal virtual OtfGlyphInfo GetGlyph(int index);
    internal virtual IList`1<LookupTable> GetLookups(FeatureRecord[] features);
    internal virtual LanguageRecord LanguageRecord(string tag);
    internal Int32[] ReadUInt16(int size, int location);
    internal Int32[] ReadUInt32(int size);
    internal virtual void ReadFormatGlyphIds(Int32[] offsets, IList`1<ICollection`1<int>> formatGlyphs);
    internal IList`1<int> ReadFormat(int offset);
    private void ReadRecord(BigEndianReader reader, IList`1<int> glyphIds);
    internal virtual LookupSubTableRecord[] ReadSubstLookupRecords(int substCount);
    internal virtual FeatureTag[] ReadFeatureTag(int offset);
    internal void Initialize();
    private void ReadLookupTables(int offset);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Syncfusion.Pdf.Graphics.Fonts.PdfCidFont : PdfDictionary {
    public PdfCidFont(PdfCjkFontFamily fontFamily, PdfFontStyle fontStyle, PdfFontMetrics fontMetrics);
    private PdfDictionary GetSystemInfo(PdfCjkFontFamily fontFamily);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Syncfusion.Pdf.Graphics.Fonts.PdfCjkFontDescryptorFactory : object {
    internal static PdfDictionary GetFontDescryptor(PdfCjkFontFamily fontFamily, PdfFontStyle fontStyle, PdfFontMetrics fontMetrics);
    private static void FillMonotypeSungLight(PdfDictionary fontDescryptor, PdfCjkFontFamily fontFamily, PdfFontMetrics fontMetrics);
    private static void FillHeiseiKakuGothicW5(PdfDictionary fontDescryptor, PdfFontStyle fontStyle, PdfCjkFontFamily fontFamily, PdfFontMetrics fontMetrics);
    private static void FillHanyangSystemsShinMyeongJoMedium(PdfDictionary fontDescryptor, PdfCjkFontFamily fontFamily, PdfFontMetrics fontMetrics);
    private static void FillHeiseiMinchoW3(PdfDictionary fontDescryptor, PdfCjkFontFamily fontFamily, PdfFontMetrics fontMetrics);
    private static void FillSinoTypeSongLight(PdfDictionary fontDescryptor, PdfCjkFontFamily fontFamily, PdfFontMetrics fontMetrics);
    private static void FillMonotypeHeiMedium(PdfDictionary fontDescryptor, PdfCjkFontFamily fontFamily, PdfFontMetrics fontMetrics);
    private static void FillHanyangSystemsGothicMedium(PdfDictionary fontDescryptor, PdfCjkFontFamily fontFamily, PdfFontMetrics fontMetrics);
    private static void FillKnownInfo(PdfDictionary fontDescryptor, PdfCjkFontFamily fontFamily, PdfFontMetrics fontMetrics);
    private static void FillFlags(PdfDictionary fontDescryptor, PdfCjkFontFamily fontFamily);
    private static void FillFontBBox(PdfDictionary fontDescryptor, Rectangle fontBBox);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Syncfusion.Pdf.Graphics.Fonts.PdfCjkStandardFontMetricsFactory : object {
    private static float c_subSuperScriptFactor;
    public static PdfFontMetrics GetMetrics(PdfCjkFontFamily fontFamily, PdfFontStyle fontStyle, float size);
    private static PdfFontMetrics GetHanyangSystemsGothicMediumMetrix(PdfCjkFontFamily fontFamily, PdfFontStyle fontStyle, float size);
    private static PdfFontMetrics GetMonotypeHeiMedium(PdfCjkFontFamily fontFamily, PdfFontStyle fontStyle, float size);
    private static PdfFontMetrics GetMonotypeSungLightMetrix(PdfCjkFontFamily fontFamily, PdfFontStyle fontStyle, float size);
    private static PdfFontMetrics GetSinoTypeSongLight(PdfCjkFontFamily fontFamily, PdfFontStyle fontStyle, float size);
    private static PdfFontMetrics GetHeiseiMinchoW3(PdfCjkFontFamily fontFamily, PdfFontStyle fontStyle, float size);
    private static PdfFontMetrics GetHeiseiKakuGothicW5Metrix(PdfCjkFontFamily fontFamily, PdfFontStyle fontStyle, float size);
    private static PdfFontMetrics GetHanyangSystemsShinMyeongJoMediumMetrix(PdfCjkFontFamily fontFamily, PdfFontStyle fontStyle, float size);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Syncfusion.Pdf.Graphics.Fonts.PdfFontMetrics : object {
    public float Ascent;
    public float Descent;
    public string Name;
    public string PostScriptName;
    public float Size;
    public float Height;
    public int FirstChar;
    public int LastChar;
    public int LineGap;
    public float SubScriptSizeFactor;
    public float SuperscriptSizeFactor;
    private WidthTable m_widthTable;
    internal bool isUnicodeFont;
    internal bool IsBold;
    public WidthTable WidthTable { get; public set; }
    public float GetAscent(PdfStringFormat format);
    public float GetDescent(PdfStringFormat format);
    public float GetLineGap(PdfStringFormat format);
    public float GetHeight(PdfStringFormat format);
    public float GetSize(PdfStringFormat format);
    public sealed virtual object Clone();
    public WidthTable get_WidthTable();
    public void set_WidthTable(WidthTable value);
}
public class Syncfusion.Pdf.Graphics.Fonts.PdfFontSettings : object {
    private float m_size;
    private PdfFontStyle m_style;
    private bool m_embed;
    private bool m_subset;
    private bool m_useFloatingFactorForMeasure;
    internal float Size { get; }
    internal bool Subset { get; }
    internal bool Embed { get; }
    internal PdfFontStyle Style { get; }
    internal bool UseFloatingFactorForMeasure { get; }
    public PdfFontSettings(float fontSize, PdfFontStyle style, bool embed, bool subset, bool useFloatingFactorForMeasure);
    internal float get_Size();
    internal bool get_Subset();
    internal bool get_Embed();
    internal PdfFontStyle get_Style();
    internal bool get_UseFloatingFactorForMeasure();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Syncfusion.Pdf.Graphics.Fonts.PdfStandardFontMetricsFactory : object {
    private static float c_subSuperScriptFactor;
    private static float c_HelveticaAscent;
    private static float c_HelveticaDescent;
    private static string c_HelveticaName;
    private static float c_HelveticaBoldAscent;
    private static float c_HelveticaBoldDescent;
    private static string c_HelveticaBoldName;
    private static float c_HelveticaItalicAscent;
    private static float c_HelveticaItalicDescent;
    private static string c_HelveticaItalicName;
    private static float c_HelveticaBoldItalicAscent;
    private static float c_HelveticaBoldItalicDescent;
    private static string c_HelveticaBoldItalicName;
    private static float c_CourierAscent;
    private static float c_CourierDescent;
    private static string c_CourierName;
    private static float c_CourierBoldAscent;
    private static float c_CourierBoldDescent;
    private static string c_CourierBoldName;
    private static float c_CourierItalicAscent;
    private static float c_CourierItalicDescent;
    private static string c_CourierItalicName;
    private static float c_CourierBoldItalicAscent;
    private static float c_CourierBoldItalicDescent;
    private static string c_CourierBoldItalicName;
    private static float c_TimesAscent;
    private static float c_TimesDescent;
    private static string c_TimesName;
    private static float c_TimesBoldAscent;
    private static float c_TimesBoldDescent;
    private static string c_TimesBoldName;
    private static float c_TimesItalicAscent;
    private static float c_TimesItalicDescent;
    private static string c_TimesItalicName;
    private static float c_TimesBoldItalicAscent;
    private static float c_TimesBoldItalicDescent;
    private static string c_TimesBoldItalicName;
    private static float c_symbolAscent;
    private static float c_symbolDescent;
    private static string c_symbolName;
    private static float c_zapfDingbatsAscent;
    private static float c_zapfDingbatsDescent;
    private static string c_zapfDingbatsName;
    private static Single[] c_arialWidth;
    private static Single[] c_arialBoldWidth;
    private static Single[] c_fixedWidth;
    private static Single[] c_timesRomanWidth;
    private static Single[] c_timesRomanBoldWidth;
    private static Single[] c_timesRomanItalicWidth;
    public static Single[] c_timesRomanBoldItalicWidth;
    private static Single[] c_symbolWidth;
    private static Single[] c_zapfDingbatsWidth;
    private static PdfStandardFontMetricsFactory();
    public static PdfFontMetrics GetMetrics(PdfFontFamily fontFamily, PdfFontStyle fontStyle, float size);
    private static PdfFontMetrics GetHelveticaMetrics(PdfFontFamily fontFamily, PdfFontStyle fontStyle, float size);
    private static PdfFontMetrics GetCourierMetrics(PdfFontFamily fontFamily, PdfFontStyle fontStyle, float size);
    private static PdfFontMetrics GetTimesMetrics(PdfFontFamily fontFamily, PdfFontStyle fontStyle, float size);
    private static PdfFontMetrics GetSymbolMetrics(PdfFontFamily fontFamily, PdfFontStyle fontStyle, float size);
    private static PdfFontMetrics GetZapfDingbatsMetrics(PdfFontFamily fontFamily, PdfFontStyle fontStyle, float size);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Syncfusion.Pdf.Graphics.Fonts.RTLCharacters : object {
    private SByte[] m_types;
    private sbyte m_textOrder;
    private int m_length;
    private SByte[] m_result;
    private SByte[] m_levels;
    private SByte[] m_rtlCharacterTypes;
    private static sbyte L;
    private static sbyte LRE;
    private static sbyte LRO;
    private static sbyte R;
    private static sbyte AL;
    private static sbyte RLE;
    private static sbyte RLO;
    private static sbyte PDF;
    private static sbyte EN;
    private static sbyte ES;
    private static sbyte ET;
    private static sbyte AN;
    private static sbyte CS;
    private static sbyte NSM;
    private static sbyte BN;
    private static sbyte B;
    private static sbyte S;
    private static sbyte WS;
    private static sbyte ON;
    private Char[] CharTypes;
    internal SByte[] Types { get; }
    internal SByte[] get_Types();
    internal Byte[] GetVisualOrder(OtfGlyphInfo[] inputText, bool isRTL);
    internal Byte[] GetVisualOrder(string inputText, bool isRTL);
    private SByte[] GetCharacterCode(string text);
    private SByte[] GetCharacterCode(OtfGlyphInfo[] text);
    private void SetDefaultLevels();
    private void SetLevels();
    private void UpdateLevels(int index, sbyte level, int length);
    private void DoVisualOrder();
    private int GetEmbeddedCharactersLength();
    private void CheckEmbeddedCharacters(int length);
    private void CheckNSM(int index, int length, sbyte level, sbyte startType, sbyte endType);
    private void CheckEuropeanDigits(int index, int length, sbyte level, sbyte startType, sbyte endType);
    private void CheckArabicCharacters(int index, int length, sbyte level, sbyte startType, sbyte endType);
    private void CheckEuropeanNumberSeparator(int index, int length, sbyte level, sbyte startType, sbyte endType);
    private void CheckEuropeanNumberTerminator(int index, int length, sbyte level, sbyte startType, sbyte endType);
    private void CheckOtherNeutrals(int index, int length, sbyte level, sbyte startType, sbyte endType);
    private void CheckOtherCharacters(int index, int length, sbyte level, sbyte startType, sbyte endType);
    private int GetLength(int index, int length, SByte[] validSet);
    private void CheckCommanCharacters(int index, int length, sbyte level, sbyte startType, sbyte endType);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Syncfusion.Pdf.Graphics.Fonts.RtlRenderer : object {
    private static char c_openBracket;
    private static char c_closeBracket;
    public static String[] Layout(LineInfo line, PdfTrueTypeFont font, bool rtl, bool wordSpace, PdfStringFormat format);
    internal static String[] SplitLayout(string line, PdfTrueTypeFont font, bool rtl, bool wordSpace, PdfStringFormat format);
    private static bool IsEnglish(string word);
    private static void KeepOrder(String[] words, int startIndex, int count, String[] result, int resultIndex);
    internal static bool GetGlyphIndices(string line, PdfTrueTypeFont font, bool rtl, UInt16[]& glyphs, bool custom);
    private static String[] CustomLayout(LineInfo line, PdfTrueTypeFont font, bool rtl, bool wordSpace, PdfStringFormat format);
    internal static string TrimLRM(string text);
    internal static bool InvisibleCharacter(int character);
    private static string CustomLayout(string line, bool rtl, PdfStringFormat format);
    private static String[] ReverseWords(String[] words);
    private static string AddChars(PdfTrueTypeFont font, UInt16[] glyphs, PdfStringFormat format);
    private static string AddChars(PdfTrueTypeFont font, string line, PdfStringFormat format);
    private static String[] CustomSplitLayout(string line, PdfTrueTypeFont font, bool rtl, bool wordSpace, PdfStringFormat format);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Syncfusion.Pdf.Graphics.Fonts.ScriptFeature : object {
    private string m_name;
    private bool m_isComplete;
    private int m_mask;
    internal string Name { get; internal set; }
    internal bool IsComplete { get; internal set; }
    internal int Mask { get; internal set; }
    internal ScriptFeature(string name, bool complete, int mask);
    internal string get_Name();
    internal void set_Name(string value);
    internal bool get_IsComplete();
    internal void set_IsComplete(bool value);
    internal int get_Mask();
    internal void set_Mask(int value);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Syncfusion.Pdf.Graphics.Fonts.ScriptLayouter : object {
    private Dictionary`2<ScriptTags, String[]> m_opentTypeScriptTags;
    private Int32[] arabicIsolatedCode;
    private IList`1<IndicGlyphInfoList> GetIndicCharacterGroup(OtfGlyphInfoList glyphList);
    internal bool DoLayout(UnicodeTrueTypeFont font, OtfGlyphInfoList glyphInfoList, ScriptTags script);
    private bool DoThaiScriptShape(UnicodeTrueTypeFont font, OtfGlyphInfoList glyphList, GSUBTable gsubTable, string otfScriptTag, LanguageRecord languageRecord);
    private bool DoArabicScriptShape(UnicodeTrueTypeFont font, OtfGlyphInfoList glyphList, GSUBTable gsubTable, string otfScriptTag, LanguageRecord languageRecord);
    private IList`1<LookupTable> GetLookupTable(IDictionary`2<string, IList`1<LookupTable>> lookupTables, string tag);
    private ScriptFeature[] GetScriptFeatures(int type);
    private bool DoIndicScriptShape(UnicodeTrueTypeFont font, OtfGlyphInfoList glyphList, ScriptTags script, GSUBTable gsubTable, string otfScriptTag, LanguageRecord gsubLanguageRecord);
    private void ApplyScriptFeatures(ScriptFeature[] scriptFeatures, IndicGlyphInfoList indicGlyphInfo, IDictionary`2<string, IList`1<LookupTable>> lookupTables);
    private IDictionary`2<string, IList`1<LookupTable>> GetLookupTables(UnicodeTrueTypeFont font, GSUBTable gsubTable, string otfScriptTag, LanguageRecord languageRecord);
    private void NormalizeGlyphList(UnicodeTrueTypeFont font, OtfGlyphInfoList glyphList);
    private bool ReplaceGlyphs(IList`1<LookupTable> lookupTables, OtfGlyphInfoList glyphList);
    private bool ReplaceGlyphsOne(IList`1<LookupTable> lookupTables, OtfGlyphInfoList glyphList);
    private bool ReplaceGlyphs(IList`1<LookupTable> lookupTables, ScriptFeature scriptFeature, IndicGlyphInfoList glyphInfoList);
    private IndicGlyphInfoList ApplyScriptFeatures(IndicGlyphInfoList indicGlyphInfoList, ScriptFeature[] scriptFeatures, IDictionary`2<string, IList`1<LookupTable>> lookupTables);
    private IndicScript GetIndicScript(ScriptTags script);
    private IList`1<int> BreakArabicLineIntoWords(OtfGlyphInfoList glyphList, IList`1<LookupTable> initial, IList`1<LookupTable> medial, IList`1<LookupTable> terminal, GDEFTable gDEFTable);
    private bool IsMedialLetter(string word);
    private bool DoInitMediFinaShaping(OtfGlyphInfoList glyphLine, IList`1<LookupTable> initial, IList`1<LookupTable> medial, IList`1<LookupTable> final, GDEFTable gDEFTable, IList`1<int> words);
    private bool DoLigatureFeature(OtfGlyphInfoList glyphLine, IList`1<LookupTable> ligature);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Syncfusion.Pdf.Graphics.Fonts.ScriptRecord : ValueType {
    private string m_scriptTag;
    private LanguageRecord m_language;
    private LanguageRecord[] m_LanguageRecord;
    internal string ScriptTag { get; internal set; }
    internal LanguageRecord Language { get; internal set; }
    internal LanguageRecord[] LanguageRecord { get; internal set; }
    internal string get_ScriptTag();
    internal void set_ScriptTag(string value);
    internal LanguageRecord get_Language();
    internal void set_Language(LanguageRecord value);
    internal LanguageRecord[] get_LanguageRecord();
    internal void set_LanguageRecord(LanguageRecord[] value);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Syncfusion.Pdf.Graphics.Fonts.ScriptRecordReader : object {
    private OtfTable m_table;
    private IList`1<ScriptRecord> m_records;
    internal IList`1<ScriptRecord> Records { get; internal set; }
    internal ScriptRecordReader(OtfTable table, int offset);
    internal IList`1<ScriptRecord> get_Records();
    internal void set_Records(IList`1<ScriptRecord> value);
    private void ReadScriptRecord(FeatureTag featureTag);
    private LanguageRecord ReadLanguageRecord(FeatureTag featureTag);
}
internal enum Syncfusion.Pdf.Graphics.Fonts.ScriptTags : Enum {
    public int value__;
    public static ScriptTags Arabic;
    public static ScriptTags Armenian;
    public static ScriptTags Balinese;
    public static ScriptTags Bengali;
    public static ScriptTags Bengali_v2;
    public static ScriptTags Bopomofo;
    public static ScriptTags Braille;
    public static ScriptTags Buginese;
    public static ScriptTags Buhid;
    public static ScriptTags ByzantineMusic;
    public static ScriptTags CanadianSyllabics;
    public static ScriptTags Cherokee;
    public static ScriptTags CJKIdeographic;
    public static ScriptTags Coptic;
    public static ScriptTags CypriotSyllabary;
    public static ScriptTags Cyrillic;
    public static ScriptTags Default;
    public static ScriptTags Deseret;
    public static ScriptTags Devanagari;
    public static ScriptTags Devanagari_v2;
    public static ScriptTags Ethiopic;
    public static ScriptTags Georgian;
    public static ScriptTags Glagolitic;
    public static ScriptTags Gothic;
    public static ScriptTags Greek;
    public static ScriptTags Gujarati;
    public static ScriptTags Gujarati_v2;
    public static ScriptTags Gurmukhi;
    public static ScriptTags Gurmukhi_v2;
    public static ScriptTags Hangul;
    public static ScriptTags HangulJamo;
    public static ScriptTags Hanunoo;
    public static ScriptTags Hebrew;
    public static ScriptTags Hiragana;
    public static ScriptTags Javanese;
    public static ScriptTags Kannada;
    public static ScriptTags Kannada_v2;
    public static ScriptTags Katakana;
    public static ScriptTags Kharosthi;
    public static ScriptTags Khmer;
    public static ScriptTags Lao;
    public static ScriptTags Latin;
    public static ScriptTags Limbu;
    public static ScriptTags LinearB;
    public static ScriptTags Malayalam;
    public static ScriptTags Malayalam_v2;
    public static ScriptTags MathematicalAlphanumericSymbols;
    public static ScriptTags Mongolian;
    public static ScriptTags MusicalSymbols;
    public static ScriptTags Myanmar;
    public static ScriptTags NewTaiLue;
    public static ScriptTags Nko;
    public static ScriptTags Ogham;
    public static ScriptTags OldItalic;
    public static ScriptTags OldPersianCuneiform;
    public static ScriptTags Oriya;
    public static ScriptTags Oriya_v2;
    public static ScriptTags Osmanya;
    public static ScriptTags Phagspa;
    public static ScriptTags Phoenician;
    public static ScriptTags Runic;
    public static ScriptTags Shavian;
    public static ScriptTags Sinhala;
    public static ScriptTags SumeroAkkadianCuneiform;
    public static ScriptTags SylotiNagri;
    public static ScriptTags Syriac;
    public static ScriptTags Tagalog;
    public static ScriptTags Tagbanwa;
    public static ScriptTags TaiLe;
    public static ScriptTags Tamil;
    public static ScriptTags Tamil_v2;
    public static ScriptTags Telugu;
    public static ScriptTags Telugu_v2;
    public static ScriptTags Thaana;
    public static ScriptTags Thai;
    public static ScriptTags Tibetan;
    public static ScriptTags Tifinagh;
    public static ScriptTags UgariticCuneiform;
    public static ScriptTags Yi;
    public static ScriptTags Common;
    public static ScriptTags Unknown;
    public static ScriptTags Inherited;
    public static ScriptTags Han;
    public static ScriptTags Miao;
    public static ScriptTags Samaritan;
    public static ScriptTags Mandaic;
    public static ScriptTags Canadian_Aboriginal;
    public static ScriptTags Tai_Tham;
    public static ScriptTags Sundanese;
    public static ScriptTags Lepcha;
    public static ScriptTags Ol_Chiki;
    public static ScriptTags Vai;
    public static ScriptTags Saurashtra;
    public static ScriptTags Batak;
    public static ScriptTags Lisu;
    public static ScriptTags Bamum;
    public static ScriptTags Kayah_Li;
    public static ScriptTags Rejang;
    public static ScriptTags Cham;
    public static ScriptTags Tai_Viet;
    public static ScriptTags Meetei_Mayek;
    public static ScriptTags Lycian;
    public static ScriptTags Carian;
    public static ScriptTags Lydian;
    public static ScriptTags Imperial_Aramaic;
    public static ScriptTags Old_South_Arabian;
    public static ScriptTags Inscriptional_Parthian;
    public static ScriptTags Inscriptional_Pahlavi;
    public static ScriptTags Old_Turkic;
    public static ScriptTags Kaithi;
    public static ScriptTags Brahmi;
    public static ScriptTags Meroitic_Hieroglyphs;
    public static ScriptTags Meroitic_Cursive;
    public static ScriptTags Avestan;
    public static ScriptTags Sora_Sompeng;
    public static ScriptTags Chakma;
    public static ScriptTags Sharada;
    public static ScriptTags Takri;
    public static ScriptTags Cuneiform;
    public static ScriptTags Egyptian_Hieroglyphs;
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[DefaultMemberAttribute("Item")]
internal class Syncfusion.Pdf.Graphics.Fonts.StandardWidthTable : WidthTable {
    private Single[] m_widths;
    public float Item { get; }
    public int Length { get; }
    internal StandardWidthTable(Single[] widths);
    public virtual float get_Item(int index);
    public int get_Length();
    public virtual WidthTable Clone();
    internal virtual PdfArray ToArray();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal abstract class Syncfusion.Pdf.Graphics.Fonts.SubsetTable : object {
    internal int Length { get; }
    internal LookupSubTableRecord[] LookupRecord { get; }
    internal int LookupLength { get; }
    internal int BTCLength { get; }
    internal abstract virtual int get_Length();
    internal abstract virtual LookupSubTableRecord[] get_LookupRecord();
    internal virtual int get_LookupLength();
    internal virtual int get_BTCLength();
    internal abstract virtual bool Match(int id, int index);
    internal virtual bool IsLookup(int glyphId, int index);
    internal virtual bool IsBackTrack(int glyphId, int index);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Syncfusion.Pdf.Graphics.Fonts.SubsetTableFormat : SubsetTable {
    private Int32[] m_glyphs;
    private Int32[] m_btGlyphs;
    private Int32[] m_lookupGlyphs;
    private CDEFTable m_cdefTable;
    private LookupSubTableRecord[] m_records;
    private IList`1<ICollection`1<int>> m_coverages;
    private IList`1<ICollection`1<int>> m_btCoverages;
    private IList`1<ICollection`1<int>> m_lookupCoverages;
    private LookupSubTable6Format subTable;
    private bool m_isLookup;
    private bool m_isBackTrack;
    private bool m_isConverage;
    private bool m_cdefMatch;
    private bool m_isFormat2;
    private bool m_isFormat3;
    internal IList`1<ICollection`1<int>> Coverages { get; internal set; }
    internal int Length { get; }
    internal int LookupLength { get; }
    internal int BTCLength { get; }
    internal LookupSubTableRecord[] LookupRecord { get; }
    internal SubsetTableFormat(Int32[] glyphs, LookupSubTableRecord[] records);
    internal SubsetTableFormat(Int32[] btGlyphs, Int32[] glyphs, Int32[] lookupGlyphs, LookupSubTableRecord[] records);
    internal SubsetTableFormat(LookupSubTable5Format subtable5, Int32[] glyphs, LookupSubTableRecord[] records);
    internal SubsetTableFormat(IList`1<ICollection`1<int>> coverages, LookupSubTableRecord[] records);
    internal SubsetTableFormat(LookupSubTable6Format subTable, Int32[] backtrackClassIds, Int32[] inputClassIds, Int32[] lookAheadClassIds, LookupSubTableRecord[] substLookupRecords);
    internal SubsetTableFormat(IList`1<ICollection`1<int>> bkCoverages, IList`1<ICollection`1<int>> coverages, IList`1<ICollection`1<int>> lookupCoverages, LookupSubTableRecord[] records);
    internal IList`1<ICollection`1<int>> get_Coverages();
    internal void set_Coverages(IList`1<ICollection`1<int>> value);
    internal virtual int get_Length();
    internal virtual int get_LookupLength();
    internal virtual int get_BTCLength();
    internal virtual LookupSubTableRecord[] get_LookupRecord();
    internal virtual bool Match(int id, int index);
    internal virtual bool IsLookup(int glyphId, int index);
    internal virtual bool IsBackTrack(int glyphId, int index);
}
internal class Syncfusion.Pdf.Graphics.Fonts.TtfAppleCmapSubTable : ValueType {
    public ushort Format;
    public ushort Length;
    public ushort Version;
}
internal class Syncfusion.Pdf.Graphics.Fonts.TtfCmapSubTable : ValueType {
    public ushort PlatformID;
    public ushort EncodingID;
    public UInt32 Offset;
}
internal class Syncfusion.Pdf.Graphics.Fonts.TtfCmapTable : ValueType {
    public ushort Version;
    public ushort TablesCount;
}
internal class Syncfusion.Pdf.Graphics.Fonts.TtfGlyphHeader : ValueType {
    public short numberOfContours;
    public short XMin;
    public short YMin;
    public short XMax;
    public short YMax;
}
internal class Syncfusion.Pdf.Graphics.Fonts.TtfGlyphInfo : ValueType {
    public int Index;
    public float Width;
    public int CharCode;
    public bool Empty { get; }
    public bool get_Empty();
    [NullableContextAttribute("1")]
public sealed virtual int CompareTo(object obj);
}
internal class Syncfusion.Pdf.Graphics.Fonts.TtfHeadTable : ValueType {
    public long Modified;
    public long Created;
    public UInt32 MagicNumber;
    public UInt32 CheckSumAdjustment;
    public float FontRevision;
    public float Version;
    public short XMin;
    public short YMin;
    public ushort UnitsPerEm;
    public short YMax;
    public short XMax;
    public ushort MacStyle;
    public ushort Flags;
    public ushort LowestRecPPEM;
    public short FontDirectionHint;
    public short IndexToLocFormat;
    public short GlyphDataFormat;
}
internal class Syncfusion.Pdf.Graphics.Fonts.TtfHorizontalHeaderTable : ValueType {
    public float Version;
    public short Ascender;
    public ushort AdvanceWidthMax;
    public short Descender;
    public ushort NumberOfHMetrics;
    public short LineGap;
    public short MinLeftSideBearing;
    public short MinRightSideBearing;
    public short XMaxExtent;
    public short CaretSlopeRise;
    public short CaretSlopeRun;
    public short MetricDataFormat;
}
internal class Syncfusion.Pdf.Graphics.Fonts.TtfLocaTable : ValueType {
    [NullableAttribute("1")]
public UInt32[] Offsets;
}
internal class Syncfusion.Pdf.Graphics.Fonts.TtfLongHorMertric : ValueType {
    public ushort AdvanceWidth;
    public short Lsb;
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Syncfusion.Pdf.Graphics.Fonts.TtfMetrics : ValueType {
    public int LineGap;
    public bool ContainsCFF;
    public bool IsSymbol;
    public RECT FontBox;
    public bool IsFixedPitch;
    public float ItalicAngle;
    public string PostScriptName;
    public string FontFamily;
    public float CapHeight;
    public float Leading;
    public float MacAscent;
    public float MacDescent;
    public float WinDescent;
    public float WinAscent;
    public float StemV;
    public Single[] WidthTable;
    public int MacStyle;
    public float SubScriptSizeFactor;
    public float SuperscriptSizeFactor;
    public bool IsItalic { get; }
    public bool IsBold { get; }
    public bool get_IsItalic();
    public bool get_IsBold();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Syncfusion.Pdf.Graphics.Fonts.TtfMicrosoftCmapSubTable : ValueType {
    public ushort Format;
    public ushort Length;
    public ushort Version;
    public ushort SegCountX2;
    public ushort SearchRange;
    public ushort EntrySelector;
    public ushort RangeShift;
    public UInt16[] EndCount;
    public ushort ReservedPad;
    public UInt16[] StartCount;
    public UInt16[] IdDelta;
    public UInt16[] IdRangeOffset;
    public UInt16[] GlyphID;
}
internal class Syncfusion.Pdf.Graphics.Fonts.TtfNameRecord : ValueType {
    public ushort PlatformID;
    public ushort EncodingID;
    public ushort LanguageID;
    public ushort NameID;
    public ushort Length;
    public ushort Offset;
    [NullableAttribute("1")]
public string Name;
}
internal class Syncfusion.Pdf.Graphics.Fonts.TtfNameTable : ValueType {
    public ushort FormatSelector;
    public ushort RecordsCount;
    public ushort Offset;
    [NullableAttribute("1")]
public TtfNameRecord[] NameRecords;
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Syncfusion.Pdf.Graphics.Fonts.TtfOS2Table : ValueType {
    public ushort Version;
    public short XAvgCharWidth;
    public ushort UsWeightClass;
    public ushort UsWidthClass;
    public short FsType;
    public short YSubscriptXSize;
    public short YSubscriptYSize;
    public short YSubscriptXOffset;
    public short YSubscriptYOffset;
    public short ySuperscriptXSize;
    public short YSuperscriptYSize;
    public short YSuperscriptXOffset;
    public short YSuperscriptYOffset;
    public short YStrikeoutSize;
    public short YStrikeoutPosition;
    public short SFamilyClass;
    public Byte[] Panose;
    public UInt32 UlUnicodeRange1;
    public UInt32 UlUnicodeRange2;
    public UInt32 UlUnicodeRange3;
    public UInt32 UlUnicodeRange4;
    public Byte[] AchVendID;
    public ushort FsSelection;
    public ushort UsFirstCharIndex;
    public ushort UsLastCharIndex;
    public short STypoAscender;
    public short STypoDescender;
    public short STypoLineGap;
    public ushort UsWinAscent;
    public ushort UsWinDescent;
    public UInt32 UlCodePageRange1;
    public UInt32 UlCodePageRange2;
    public short SxHeight;
    public short SCapHeight;
    public ushort UsDefaultChar;
    public ushort UsBreakChar;
    public ushort UsMaxContext;
}
internal class Syncfusion.Pdf.Graphics.Fonts.TtfPostTable : ValueType {
    public float FormatType;
    public float ItalicAngle;
    public short UnderlinePosition;
    public short UnderlineThickness;
    public UInt32 IsFixedPitch;
    public UInt32 MinMemType42;
    public UInt32 MaxMemType42;
    public UInt32 MinMemType1;
    public UInt32 MaxMemType1;
}
internal class Syncfusion.Pdf.Graphics.Fonts.TtfTableInfo : ValueType {
    public int Offset;
    public int Length;
    public int Checksum;
    public bool Empty { get; }
    public bool get_Empty();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Syncfusion.Pdf.Graphics.Fonts.TtfTableNames : ValueType {
    public static string cmap;
    public static string glyf;
    public static string head;
    public static string hhea;
    public static string hmtx;
    public static string loca;
    public static string maxp;
    public static string name;
    public static string post;
    public static string OS2;
    public static string CFF;
    public static string cvt;
    public static string fpgm;
    public static string prep;
}
internal class Syncfusion.Pdf.Graphics.Fonts.TtfTrimmedCmapSubTable : ValueType {
    public ushort Format;
    public ushort Length;
    public ushort Version;
    public ushort FirstCode;
    public ushort EntryCount;
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Syncfusion.Pdf.Graphics.Fonts.UnicodeLanguageInfo : object {
    internal string LanguageName;
    internal int startAt;
    internal int endAt;
    internal UnicodeLanguageInfo(string name, int s, int e);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Syncfusion.Pdf.Graphics.Fonts.UnicodeTrueTypeFont : object {
    private static string c_driverName;
    private static string c_nameString;
    private static string c_cmapPrefix;
    private static string c_cmapEndCodespaceRange;
    private static string c_cmapSuffix;
    private static string c_cmapBeginRange;
    private static string c_cmapEndRange;
    private static int c_cmapNextRangeValue;
    private static string c_registry;
    private static int c_defWidthIndex;
    private static int c_cidStreamLength;
    private static object s_syncLock;
    private Stream m_fontStream;
    internal bool is_filePath;
    private string m_filePath;
    private float m_size;
    private PdfFontMetrics m_metrics;
    private PdfDictionary m_fontDictionary;
    private PdfDictionary m_descendantFont;
    private PdfDictionary m_fontDescriptor;
    private PdfStream m_fontProgram;
    private PdfStream m_cmap;
    private PdfStream m_CidStream;
    private TtfReader m_ttfReader;
    private Dictionary`2<int, OtfGlyphInfo> m_openTypeGlyphs;
    private List`1<TtfGlyphInfo> glyphInfo;
    internal bool m_isIncreasedUsedChar;
    internal Dictionary`2<char, char> m_usedChars;
    private string m_subsetName;
    internal TtfMetrics m_ttfMetrics;
    private CompositeFontType m_type;
    private string metricsName;
    private bool m_isEmbedFont;
    private bool m_isAzureCompatible;
    private bool m_isFontFilePath;
    private bool m_isCompress;
    private bool m_isSkipFontEmbed;
    internal bool conformanceEnabled;
    internal bool m_isXPSFontStream;
    private bool m_fullEmbed;
    private bool m_useFloatingFactorForMeasure;
    internal bool m_isClearUsedChars;
    public float Size { get; }
    internal bool IsEmbed { get; internal set; }
    public PdfFontMetrics Metrics { get; }
    internal TtfReader TtfReader { get; }
    internal string FontFile { get; }
    internal Stream FontStream { get; }
    internal TtfMetrics TtfMetrics { get; }
    internal CompositeFontType FontType { get; internal set; }
    internal bool SkipFontEmbed { get; internal set; }
    internal bool ForceFullFontEmbed { get; internal set; }
    internal UnicodeTrueTypeFont(Stream font, float size, CompositeFontType type, string name);
    public UnicodeTrueTypeFont(Stream font, float size, CompositeFontType type, bool isFloatingPoint);
    public UnicodeTrueTypeFont(UnicodeTrueTypeFont prototype);
    internal UnicodeTrueTypeFont(string filePath, float size, CompositeFontType type);
    private static UnicodeTrueTypeFont();
    public sealed virtual float get_Size();
    internal bool get_IsEmbed();
    internal void set_IsEmbed(bool value);
    public sealed virtual PdfFontMetrics get_Metrics();
    internal TtfReader get_TtfReader();
    internal string get_FontFile();
    internal Stream get_FontStream();
    internal TtfMetrics get_TtfMetrics();
    internal CompositeFontType get_FontType();
    internal void set_FontType(CompositeFontType value);
    internal bool get_SkipFontEmbed();
    internal void set_SkipFontEmbed(bool value);
    internal bool get_ForceFullFontEmbed();
    internal void set_ForceFullFontEmbed(bool value);
    public void SetSymbols(string text);
    public void SetSymbols(UInt16[] glyphs);
    internal void SetSymbols(string text, bool opentype);
    internal void SetSymbols(UInt16[] glyphs, bool openType);
    internal void SetSymbols(OtfGlyphInfoList line);
    public sealed virtual IPdfPrimitive GetInternals();
    public sealed virtual bool EqualsToFont(PdfFont font);
    private bool IsEqualFontStream(Stream currentFont, Stream previousFont);
    public sealed virtual void CreateInternals();
    public sealed virtual float GetCharWidth(char charCode);
    public sealed virtual float GetLineWidth(string line);
    public sealed virtual void Close();
    private void Initialize(Stream font);
    private void InitializeMetrics();
    private void CreateFontProgram();
    private void GenerateFontProgram();
    private void CreateFontDictionary();
    private void CreateDescendantFont();
    internal int GetUsedCharsCount();
    internal void SetGlyphInfo(List`1<TtfGlyphInfo> collection);
    private void CreateCmap();
    private void CreateCidSet();
    private void GenerateCmap();
    private void GenerateOpenTypeCmap();
    private IPdfPrimitive CreateSystemInfo();
    private PdfDictionary CreateFontDescriptor();
    private string FormatName(string fontName);
    private string GetFontName();
    public PdfArray GetDescendantWidth();
    internal List`1<TtfGlyphInfo> GetGlyphInfo();
    private PdfArray GetOpenTypeDecendantWidth();
    private void UpdateOpenTypeGlyphs();
    private string ToHexString(int n);
    private int GetDescriptorFlags();
    private RectangleF GetBoundBox();
    private void Initialize();
    private BinaryReader GetFontData();
    private void FontDictionaryBeginSave(object sender, SavePdfPrimitiveEventArgs ars);
    private void FontDescriptorBeginSave(object sender, SavePdfPrimitiveEventArgs ars);
    private void FontProgramBeginSave(object sender, SavePdfPrimitiveEventArgs ars);
    private void CmapBeginSave(object sender, SavePdfPrimitiveEventArgs ars);
    private void CidBeginSave(object sender, SavePdfPrimitiveEventArgs ars);
    private void DescendantFontBeginSave(object sender, SavePdfPrimitiveEventArgs ars);
    private void GenerateCidSet();
    private void GenerateOpenTypeCidSet(Byte[] dummyBits);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[DefaultMemberAttribute("Item")]
internal abstract class Syncfusion.Pdf.Graphics.Fonts.WidthTable : object {
    public float Item { get; }
    public abstract virtual float get_Item(int index);
    public abstract virtual WidthTable Clone();
    private sealed virtual override object Syncfusion.Pdf.ICloneable.Clone();
    internal abstract virtual PdfArray ToArray();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Syncfusion.Pdf.Graphics.GifMetadataParser : object {
    private MemoryStream m_stream;
    private BinaryReader m_reader;
    internal MemoryStream Stream { get; }
    internal GifMetadataParser(Stream stream);
    internal MemoryStream get_Stream();
    public sealed virtual MemoryStream GetMetadata();
    private void SkipBlocks();
    private void ReadApplicationExtensionBlock(byte length);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Syncfusion.Pdf.Graphics.Htmltext : object {
    internal XNode mtag;
    internal string minnerText;
    internal PdfFont mfont;
    internal Color mbrushcolor;
    internal bool mbaseBrushColor;
}
[NullableContextAttribute("1")]
internal interface Syncfusion.Pdf.Graphics.IImageMetadataParser {
    public abstract virtual MemoryStream GetMetadata();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Syncfusion.Pdf.Graphics.ImageMetadataParser : object {
    private Stream m_stream;
    internal ImageMetadataParser(Stream stream, string type);
    internal ImageMetadataParser(Stream stream);
    internal XmpMetadata TryGetMetadata();
}
public enum Syncfusion.Pdf.Graphics.Images.Decoder.BitmapColorSpace : Enum {
    public int value__;
    public static BitmapColorSpace CalibratedRGB;
    public static BitmapColorSpace SRGB;
    public static BitmapColorSpace CMYK;
}
public enum Syncfusion.Pdf.Graphics.Images.Decoder.BitmapCompression : Enum {
    public int value__;
    public static BitmapCompression RGB;
    public static BitmapCompression RunlengthEncoding8;
    public static BitmapCompression RunlengthEncoding4;
    public static BitmapCompression Bitfield;
}
public class Syncfusion.Pdf.Graphics.Images.Decoder.BitmapFileHeader : ValueType {
    public long FileSize;
    public long OffSet;
}
internal class Syncfusion.Pdf.Graphics.Images.Decoder.BitmapInfoHeader : ValueType {
    public int Size;
    public int Width;
    public int Height;
    public short Planes;
    public short BitsPerPixel;
    public BitmapCompression Compression;
    public int SizeImage;
    public int XPelsPerMeter;
    public int YPelsPerMeter;
    public int ClrUsed;
    public int ClrImportant;
}
public enum Syncfusion.Pdf.Graphics.Images.Decoder.BitmapType : Enum {
    public int value__;
    public static BitmapType Version2_1Bit;
    public static BitmapType Version2_4Bit;
    public static BitmapType Version2_8Bit;
    public static BitmapType Version2_24Bit;
    public static BitmapType Version3_1Bit;
    public static BitmapType Version3_4Bit;
    public static BitmapType Version3_8Bit;
    public static BitmapType Version3_16Bit;
    public static BitmapType Version3_24Bit;
    public static BitmapType Version3_32Bit;
    public static BitmapType Version4_1Bit;
    public static BitmapType Version4_4Bit;
    public static BitmapType Version4_8Bit;
    public static BitmapType Version4_16Bit;
    public static BitmapType Version4_24Bit;
    public static BitmapType Version4_32Bit;
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Syncfusion.Pdf.Graphics.Images.Decoder.BmpDecoder : ImageDecoder {
    private static int c_fileHeaderSize;
    private static int c_BitmapHeaderSize;
    private static int c_rMask;
    private static int c_gMask;
    private static int c_bMask;
    private Byte[] m_BmpHeader;
    private PdfStream m_imageStream;
    private BitmapFileHeader m_fileHeader;
    private BitmapInfoHeader m_infoHeader;
    private Byte[] m_palette;
    private Byte[] m_csPalette;
    public BmpDecoder(Stream stream);
    public static Single[] GetImageResolution(Stream stream);
    protected virtual void Initialize();
    private void ReadImage();
    internal virtual PdfStream GetImageDictionary();
    private void ReadFileHeader();
    private void ReadInfoHeader();
    private void ReadImageData();
    private void DecodeRGBImage();
    private bool CheckIfValidBmp();
    private PdfArray GetColorSpace();
    private void Decode1BitRGB();
    private void Decode4BitRGB();
    private void Decode8bitRGB();
    private void Decode16BitRGB();
    private void Decode24BitRGB();
    private void Decode32BitRGB();
    private int Invert(int y, int height);
    private Byte[] GetImageArray(int width, int height, int bytes, Int32& alignment);
    private void SetColorSpacePalette(int bpc);
    private void UpdateImageResolution(Single[] resolution);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal abstract class Syncfusion.Pdf.Graphics.Images.Decoder.ImageDecoder : object {
    private Stream m_internalStream;
    private int m_width;
    private int m_height;
    private Byte[] m_imageData;
    private int m_bitsPerComponent;
    private ImageType m_format;
    private float m_horizontalResolution;
    private float m_verticalResolution;
    private float m_jpegDecoderOrientationAngle;
    private MemoryStream m_metadataStream;
    public Stream InternalStream { get; public set; }
    public int Width { get; public set; }
    public int Height { get; public set; }
    public Byte[] ImageData { get; public set; }
    public int BitsPerComponent { get; public set; }
    public ImageType Format { get; public set; }
    public float HorizontalResolution { get; public set; }
    public float VerticalResolution { get; public set; }
    internal float JpegDecoderOrientationAngle { get; internal set; }
    internal MemoryStream MetadataStream { get; internal set; }
    public Size Size { get; }
    public Stream get_InternalStream();
    public void set_InternalStream(Stream value);
    public int get_Width();
    public void set_Width(int value);
    public int get_Height();
    public void set_Height(int value);
    public Byte[] get_ImageData();
    public void set_ImageData(Byte[] value);
    public int get_BitsPerComponent();
    public void set_BitsPerComponent(int value);
    public ImageType get_Format();
    public void set_Format(ImageType value);
    public float get_HorizontalResolution();
    public void set_HorizontalResolution(float value);
    public float get_VerticalResolution();
    public void set_VerticalResolution(float value);
    internal float get_JpegDecoderOrientationAngle();
    internal void set_JpegDecoderOrientationAngle(float value);
    internal MemoryStream get_MetadataStream();
    internal void set_MetadataStream(MemoryStream value);
    public Size get_Size();
    public static bool TryGetDecoder(Stream stream, bool enableMetadata, ImageDecoder& decoder);
    protected abstract virtual void Initialize();
    internal abstract virtual PdfStream GetImageDictionary();
}
internal enum Syncfusion.Pdf.Graphics.Images.Decoder.ImageType : Enum {
    public int value__;
    public static ImageType Png;
    public static ImageType Jpeg;
    public static ImageType Gif;
    public static ImageType Bmp;
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Syncfusion.Pdf.Graphics.Images.Decoder.JpegDecoder : ImageDecoder {
    private static ushort c_SoiMarker;
    private static ushort c_JfifMarker;
    private static ushort c_SosMarker;
    private static ushort c_EoiMarker;
    private static ushort c_Sof0Marker;
    private static ushort c_Sof1Marker;
    private static ushort c_Sof2Marker;
    private static ushort c_Sof3Marker;
    private static ushort c_Sof5Marker;
    private static ushort c_Sof6Marker;
    private static ushort c_Sof7Marker;
    private static ushort c_Sof9Marker;
    private static ushort c_Sof10Marker;
    private static ushort c_Sof11Marker;
    private static ushort c_Sof13Marker;
    private static ushort c_Sof14Marker;
    private static ushort c_Sof15Marker;
    private Byte[] m_jpegHeader;
    private PdfStream m_imageStream;
    private bool m_isContainsLittleEndian;
    private Byte[] m_jpegSegmentPreambleBytes;
    private bool m_enableMetadata;
    private int m_noOfComponents;
    public JpegDecoder(Stream stream);
    public JpegDecoder(Stream stream, bool enableMetadata);
    public static Single[] GetImageResolution(Stream stream);
    private static float GetExifResolution(Stream jpegStream, Byte[] byteData, bool _isLittleEndian, BinaryReader jpegReader);
    protected virtual void Initialize();
    private void ReaderHeader();
    private void ReadXmpSegment(Byte[] bytes);
    private bool IsXmpSegment(Byte[] bytes);
    internal virtual PdfStream GetImageDictionary();
    private bool CheckForExifData(Int32& ImageOrientation);
    internal static bool CheckForExifDataTiff(Stream jpegStream, Int32& ImageOrientation);
    private static Byte[] ReverseBytes(Byte[] bytes);
    private Byte[] ReadJpegBytes(int byteCount, BinaryReader reader);
    private ushort ConvertToUShort(Byte[] data);
    private UInt32 ConvertToUint(Byte[] data);
    private string GetColorSpace();
    private void ReadExceededJPGImage(Stream stream);
    private ushort GetMarker(Stream stream);
    private void SkipStream(Stream stream);
    private int ReadNextTwoBytes(Stream stream);
    private PdfDictionary GetDecodeParams();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Syncfusion.Pdf.Graphics.Images.Decoder.PngDecoder : ImageDecoder {
    private static Single[] m_decode;
    private int m_currentChunkLength;
    private static int m_currentChunkSize;
    private PngHeader m_header;
    private bool m_bDecodeIdat;
    private bool m_issRGB;
    private int m_bitsPerPixel;
    private long m_idatLength;
    private int m_colors;
    private int m_inputBands;
    private int m_bytesPerPixel;
    private Stream m_iDatStream;
    internal PdfArray m_colorSpace;
    internal bool m_isDecode;
    private Byte[] m_maskData;
    private Byte[] m_alpha;
    private bool m_shades;
    private Stream m_dataStream;
    private bool m_ideateDecode;
    private bool m_enableMetadata;
    private int transparentPixel;
    private int transparentPixelId;
    private int redMask;
    private int greenMask;
    private int blueMask;
    public PngDecoder(Stream stream);
    public PngDecoder(Stream stream, bool enableMetadata);
    private static PngDecoder();
    public static Single[] GetImageResolution(Stream stream);
    private static bool ReadNextchunk(PngChunkTypes& header, Stream stream);
    private static void IgnoreChunk(Stream stream);
    protected virtual void Initialize();
    private void ReadZTextMetadata(Byte[] chunkBytes);
    internal Byte[] ReadNullTerminatedBytes(int maxLength, BinaryReader reader);
    internal void DecodeImageData();
    private Stream GetDeflatedData(Stream iDatStream);
    private void ReadDecodeData();
    private void DecodeData(int xOffset, int yOffset, int xStep, int yStep, int width, int height);
    private void ProcessPixels(Byte[] data, int x, int step, int y, int width);
    private Int32[] GetPixel(Byte[] data);
    private void SetPixel(Byte[] imageData, Int32[] data, int offset, int size, int x, int y, int bitDepth, int bpr);
    private void Read(Stream stream, Byte[] data, int offset, int count);
    private void DecompressSub(Byte[] data, int count, int bpp);
    private void DecompressUp(Byte[] data, Byte[] pData, int count);
    private void DecompressAverage(Byte[] data, Byte[] pData, int count, int bpp);
    private int PaethPredictor(int a, int b, int c);
    private void DecompressPaeth(Byte[] data, Byte[] pData, int count, int bpp);
    private void ReadPLTE();
    private void ReadTRNS();
    private IPdfPrimitive GetPngColorSpace();
    private void ReadImageData();
    internal void InitializeBase();
    internal virtual PdfStream GetImageDictionary();
    private void SetMask(PdfStream imageStream);
    private PdfDictionary GetDecodeParams();
    internal void Dispose();
    private bool ReadNextchunk(PngChunkTypes& header);
    private void ReadHeader();
    private void SetBitsPerPixel();
    private void IgnoreChunk();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ExtensionAttribute]
public static class Syncfusion.Pdf.Graphics.Images.Decoder.StreamExtensions : object {
    private static Byte[] m_jpegSignature;
    private static Byte[] m_pngSignature;
    private static Byte[] m_bmpSignature;
    private static Byte[] m_mp3Signature;
    private static Byte[] m_movSignature;
    private static Byte[] m_mp4Signature;
    private static Byte[] m_3gpSignature;
    private static Byte[] m_m4vSignature;
    private static Byte[] m_tiffSignature;
    private static Byte[] m_gifSignature;
    private static Byte[] m_tiffSignature2;
    private static StreamExtensions();
    [ExtensionAttribute]
public static int ReadUInt32(Stream stream);
    [ExtensionAttribute]
public static int ReadInt32(Stream stream);
    [ExtensionAttribute]
public static int ReadUInt16(Stream stream);
    [ExtensionAttribute]
public static int ReadInt16(Stream stream);
    [ExtensionAttribute]
public static int ReadWord(Stream stream);
    [ExtensionAttribute]
public static int ReadShortLE(Stream stream);
    [ExtensionAttribute]
public static string ReadString(Stream stream, int len);
    [ExtensionAttribute]
public static void Reset(Stream stream);
    [ExtensionAttribute]
public static void Skip(Stream stream, int noOfBytes);
    [ExtensionAttribute]
public static int ReadByte(Stream stream);
    [ExtensionAttribute]
internal static Byte[] ReadByte(Stream stream, int len);
    [ExtensionAttribute]
public static bool IsJpeg(Stream stream);
    [ExtensionAttribute]
public static bool IsBmp(Stream stream);
    [ExtensionAttribute]
public static bool IsPng(Stream stream);
    [ExtensionAttribute]
internal static bool IsTiff(Stream stream);
    [ExtensionAttribute]
internal static bool IsGif(Stream stream);
    [ExtensionAttribute]
internal static bool IsMP3(Stream stream);
    [ExtensionAttribute]
internal static bool IsMov(Stream stream);
    [ExtensionAttribute]
internal static bool IsM4v(Stream stream);
    [ExtensionAttribute]
internal static bool Is3Gp(Stream stream);
    [ExtensionAttribute]
internal static bool IsMP4(Stream stream);
}
internal enum Syncfusion.Pdf.Graphics.Images.Metafiles.BrushType : Enum {
    public int value__;
    public static BrushType SolidBrush;
    public static BrushType HatchBrush;
    public static BrushType TextureBrush;
    public static BrushType PathGradientBrush;
    public static BrushType LienarGradientBrush;
}
[FlagsAttribute]
internal enum Syncfusion.Pdf.Graphics.Images.Metafiles.GradientBrushFlags : Enum {
    public int value__;
    public static GradientBrushFlags Default;
    public static GradientBrushFlags Matrix;
    public static GradientBrushFlags ColorBlend;
    public static GradientBrushFlags Blend;
    public static GradientBrushFlags FocusScales;
    public static GradientBrushFlags GammaCorrection;
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Syncfusion.Pdf.Graphics.Images.Metafiles.ImageRegion : object {
    private float m_y;
    private float m_height;
    public float Y { get; public set; }
    public float Height { get; public set; }
    public ImageRegion(float y, float height);
    public float get_Y();
    public void set_Y(float value);
    public float get_Height();
    public void set_Height(float value);
    public static ImageRegion Union(ImageRegion region1, ImageRegion region2);
    public bool IntersectsWith(ImageRegion region);
    internal bool IntersectsWith(RectangleF sourceRect, RectangleF rect);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Syncfusion.Pdf.Graphics.Images.Metafiles.ImageRegionManager : object {
    private List`1<ImageRegion> m_regions;
    public void Add(ImageRegion region);
    public float GetTopCoordinate(float y);
    public float GetCoordinate(float y);
    public void Clear();
    private ImageRegion[] Intersect(ImageRegion region);
    private void Remove(ImageRegion region);
    private void Remove(ImageRegion[] regions);
    private ImageRegion Union(ImageRegion[] regions, ImageRegion region);
}
internal enum Syncfusion.Pdf.Graphics.Images.Metafiles.ObjectImageFormat : Enum {
    public int value__;
    public static ObjectImageFormat Unknown;
    public static ObjectImageFormat Bitmap;
    public static ObjectImageFormat Metafile;
}
internal enum Syncfusion.Pdf.Graphics.Images.Metafiles.ObjectRegionInitState : Enum {
    public int value__;
    public static ObjectRegionInitState Rectangle;
    public static ObjectRegionInitState GraphpicsPath;
    public static ObjectRegionInitState Empty;
    public static ObjectRegionInitState Infinity;
}
internal enum Syncfusion.Pdf.Graphics.Images.Metafiles.ObjectType : Enum {
    public int value__;
    public static ObjectType Invalid;
    public static ObjectType Brush;
    public static ObjectType Pen;
    public static ObjectType Path;
    public static ObjectType Region;
    public static ObjectType Image;
    public static ObjectType Font;
    public static ObjectType StringFormat;
    public static ObjectType ImageAttributes;
    public static ObjectType CustomLineCap;
}
[FlagsAttribute]
internal enum Syncfusion.Pdf.Graphics.Images.Metafiles.PenFlags : Enum {
    public int value__;
    public static PenFlags Default;
    public static PenFlags Transform;
    public static PenFlags StartCap;
    public static PenFlags EndCap;
    public static PenFlags LineJoin;
    public static PenFlags MiterLimit;
    public static PenFlags DashStyle;
    public static PenFlags DashCap;
    public static PenFlags DashOffset;
    public static PenFlags DashPattern;
    public static PenFlags Alignment;
    public static PenFlags CompoundArray;
    public static PenFlags CustomStartCap;
    public static PenFlags CustomEndCap;
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Syncfusion.Pdf.Graphics.Images.Metafiles.TextRegion : object {
    private float m_y;
    private float m_height;
    public float Y { get; public set; }
    public float Height { get; public set; }
    public TextRegion(float y, float height);
    public float get_Y();
    public void set_Y(float value);
    public float get_Height();
    public void set_Height(float value);
    public static TextRegion Union(TextRegion region1, TextRegion region2);
    public bool IntersectsWith(TextRegion region);
    internal bool IntersectsWith(RectangleF sourceRect, RectangleF rect);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Syncfusion.Pdf.Graphics.Images.Metafiles.TextRegionManager : object {
    private List`1<TextRegion> m_regions;
    internal int Count { get; }
    internal int get_Count();
    public void Add(TextRegion region);
    public float GetTopCoordinate(float y);
    public float GetCoordinate(float y);
    public void Clear();
    private TextRegion[] Intersect(TextRegion region);
    private void Remove(TextRegion region);
    private void Remove(TextRegion[] regions);
    private TextRegion Union(TextRegion[] regions, TextRegion region);
}
[NullableContextAttribute("1")]
internal interface Syncfusion.Pdf.Graphics.ITrueTypeFont {
    public float Size { get; }
    public PdfFontMetrics Metrics { get; }
    public abstract virtual float get_Size();
    public abstract virtual PdfFontMetrics get_Metrics();
    public abstract virtual IPdfPrimitive GetInternals();
    public abstract virtual bool EqualsToFont(PdfFont font);
    public abstract virtual void CreateInternals();
    public abstract virtual float GetCharWidth(char charCode);
    public abstract virtual float GetLineWidth(string line);
    public abstract virtual void Close();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class Syncfusion.Pdf.Graphics.LineInfo : object {
    internal string m_text;
    internal float m_width;
    internal LineType m_lineType;
    internal OtfGlyphInfoList OpenTypeGlyphList;
    private Byte[] m_bidiLevls;
    private int m_trimCount;
    public LineType LineType { get; internal set; }
    public string Text { get; internal set; }
    public float Width { get; internal set; }
    internal Byte[] BidiLevels { get; internal set; }
    internal int TrimCount { get; internal set; }
    public LineType get_LineType();
    internal void set_LineType(LineType value);
    public string get_Text();
    internal void set_Text(string value);
    public float get_Width();
    internal void set_Width(float value);
    internal Byte[] get_BidiLevels();
    internal void set_BidiLevels(Byte[] value);
    internal int get_TrimCount();
    internal void set_TrimCount(int value);
}
[FlagsAttribute]
public enum Syncfusion.Pdf.Graphics.LineType : Enum {
    public int value__;
    public static LineType None;
    public static LineType NewLineBreak;
    public static LineType LayoutBreak;
    public static LineType FirstParagraphLine;
    public static LineType LastParagraphLine;
}
internal class Syncfusion.Pdf.Graphics.NamespaceDoc : object {
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Syncfusion.Pdf.Graphics.PaintParams : object {
    private PdfBrush m_backBrush;
    private PdfBrush m_foreBrush;
    private float m_borderWidth;
    private PdfPen m_borderPen;
    private PdfBorderStyle m_borderStyle;
    private RectangleF m_bounds;
    private PdfBrush m_shadowBrush;
    private int m_rotationAngle;
    private bool m_insertSpace;
    private PdfPageRotateAngle m_pageRotationAngle;
    private bool m_isFlatten;
    internal bool m_complexScript;
    internal PdfTextDirection m_textDirection;
    internal float m_lineSpacing;
    private bool m_isRequiredField;
    public PdfBrush BackBrush { get; public set; }
    public PdfBrush ForeBrush { get; public set; }
    public PdfPen BorderPen { get; public set; }
    public PdfBorderStyle BorderStyle { get; public set; }
    public float BorderWidth { get; public set; }
    public RectangleF Bounds { get; public set; }
    public PdfBrush ShadowBrush { get; public set; }
    public int RotationAngle { get; public set; }
    internal bool InsertSpace { get; internal set; }
    internal PdfPageRotateAngle PageRotationAngle { get; internal set; }
    internal bool isFlatten { get; internal set; }
    internal bool IsRequired { get; internal set; }
    public PaintParams(RectangleF bounds, PdfBrush backBrush, PdfBrush foreBrush, PdfPen borderPen, PdfBorderStyle style, float borderWidth, PdfBrush shadowBrush, int rotationAngle);
    public PdfBrush get_BackBrush();
    public void set_BackBrush(PdfBrush value);
    public PdfBrush get_ForeBrush();
    public void set_ForeBrush(PdfBrush value);
    public PdfPen get_BorderPen();
    public void set_BorderPen(PdfPen value);
    public PdfBorderStyle get_BorderStyle();
    public void set_BorderStyle(PdfBorderStyle value);
    public float get_BorderWidth();
    public void set_BorderWidth(float value);
    public RectangleF get_Bounds();
    public void set_Bounds(RectangleF value);
    public PdfBrush get_ShadowBrush();
    public void set_ShadowBrush(PdfBrush value);
    public int get_RotationAngle();
    public void set_RotationAngle(int value);
    internal bool get_InsertSpace();
    internal void set_InsertSpace(bool value);
    internal PdfPageRotateAngle get_PageRotationAngle();
    internal void set_PageRotationAngle(PdfPageRotateAngle value);
    internal bool get_isFlatten();
    internal void set_isFlatten(bool value);
    internal bool get_IsRequired();
    internal void set_IsRequired(bool value);
}
internal class Syncfusion.Pdf.Graphics.PARAFORMAT : ValueType {
    public int cbSize;
    public UInt32 dwMask;
    public short wNumbering;
    public short wReserved;
    public int dxStartIndent;
    public int dxRightIndent;
    public int dxOffset;
    public short wAlignment;
    public short cTabCount;
    [NullableAttribute("1")]
public Int32[] rgxTabs;
    public int dySpaceBefore;
    public int dySpaceAfter;
    public int dyLineSpacing;
    public short sStyle;
    public byte bLineSpacingRule;
    public byte bOutlineLevel;
    public short wShadingWeight;
    public short wShadingStyle;
    public short wNumberingStart;
    public short wNumberingStyle;
    public short wNumberingTab;
    public short wBorderSpace;
    public short wBorderWidth;
    public short wBorders;
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class Syncfusion.Pdf.Graphics.PdfArc : PdfEllipsePart {
    public PdfArc(float width, float height, float startAngle, float sweepAngle);
    public PdfArc(PdfPen pen, float width, float height, float startAngle, float sweepAngle);
    public PdfArc(float x, float y, float width, float height, float startAngle, float sweepAngle);
    public PdfArc(RectangleF rectangle, float startAngle, float sweepAngle);
    public PdfArc(PdfPen pen, float x, float y, float width, float height, float startAngle, float sweepAngle);
    public PdfArc(PdfPen pen, RectangleF rectangle, float startAngle, float sweepAngle);
    protected virtual void DrawInternal(PdfGraphics graphics);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class Syncfusion.Pdf.Graphics.PdfBezierCurve : PdfDrawElement {
    private PointF m_startPoint;
    private PointF m_firstControlPoint;
    private PointF m_secondControlPoint;
    private PointF m_endPoint;
    public PointF StartPoint { get; public set; }
    public PointF FirstControlPoint { get; public set; }
    public PointF SecondControlPoint { get; public set; }
    public PointF EndPoint { get; public set; }
    public PdfBezierCurve(PointF startPoint, PointF firstControlPoint, PointF secondControlPoint, PointF endPoint);
    public PdfBezierCurve(float startPointX, float startPointY, float firstControlPointX, float firstControlPointY, float secondControlPointX, float secondControlPointY, float endPointX, float endPointY);
    public PdfBezierCurve(PdfPen pen, PointF startPoint, PointF firstControlPoint, PointF secondControlPoint, PointF endPoint);
    public PdfBezierCurve(PdfPen pen, float startPointX, float startPointY, float firstControlPointX, float firstControlPointY, float secondControlPointX, float secondControlPointY, float endPointX, float endPointY);
    public PointF get_StartPoint();
    public void set_StartPoint(PointF value);
    public PointF get_FirstControlPoint();
    public void set_FirstControlPoint(PointF value);
    public PointF get_SecondControlPoint();
    public void set_SecondControlPoint(PointF value);
    public PointF get_EndPoint();
    public void set_EndPoint(PointF value);
    protected virtual RectangleF GetBoundsInternal();
    protected virtual void DrawInternal(PdfGraphics graphics);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class Syncfusion.Pdf.Graphics.PdfBitmap : PdfImage {
    private bool m_bDisposed;
    [CompilerGeneratedAttribute]
private ImageDecoder <Decoder>k__BackingField;
    [CompilerGeneratedAttribute]
private PdfMask <Mask>k__BackingField;
    [CompilerGeneratedAttribute]
private PdfColorSpace <ColorSpace>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <ImageMask>k__BackingField;
    [CompilerGeneratedAttribute]
private int <CheckImageType>k__BackingField;
    [CompilerGeneratedAttribute]
private int <BitsPerComponent>k__BackingField;
    private bool imageStatus;
    internal ImageDecoder Decoder { get; internal set; }
    internal PdfMask Mask { get; internal set; }
    internal PdfColorSpace ColorSpace { get; internal set; }
    internal bool ImageMask { get; internal set; }
    internal int CheckImageType { get; internal set; }
    internal int BitsPerComponent { get; internal set; }
    public PdfBitmap(Stream stream);
    public PdfBitmap(Stream stream, bool enableMetadata);
    [CompilerGeneratedAttribute]
internal ImageDecoder get_Decoder();
    [CompilerGeneratedAttribute]
internal void set_Decoder(ImageDecoder value);
    [CompilerGeneratedAttribute]
internal PdfMask get_Mask();
    [CompilerGeneratedAttribute]
internal void set_Mask(PdfMask value);
    [CompilerGeneratedAttribute]
internal PdfColorSpace get_ColorSpace();
    [CompilerGeneratedAttribute]
internal void set_ColorSpace(PdfColorSpace value);
    [CompilerGeneratedAttribute]
internal bool get_ImageMask();
    [CompilerGeneratedAttribute]
internal void set_ImageMask(bool value);
    [CompilerGeneratedAttribute]
internal int get_CheckImageType();
    [CompilerGeneratedAttribute]
internal void set_CheckImageType(int value);
    [CompilerGeneratedAttribute]
internal int get_BitsPerComponent();
    [CompilerGeneratedAttribute]
internal void set_BitsPerComponent(int value);
    protected virtual override void Finalize();
    public sealed virtual void Dispose();
    internal void Close();
    private void Dispose(bool disposing);
    private void Initialize(Stream stream);
    internal virtual void Save();
    internal virtual XmpMetadata GetMetadata();
    private void SaveAsJpg();
    private void SaveRequiredItems();
    private void SaveImage(PdfArray filters);
    private void SetColorSpace();
    private void SaveAddtionalItems();
    internal virtual PdfImage Clone();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class Syncfusion.Pdf.Graphics.PdfBlend : PdfBlendBase {
    private Single[] m_factors;
    public Single[] Factors { get; public set; }
    public PdfBlend(int count);
    public Single[] get_Factors();
    public void set_Factors(Single[] value);
    internal PdfColorBlend GenerateColorBlend(PdfColor[] colours, PdfColorSpace colorSpace);
    internal PdfBlend ClonePdfBlend();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public abstract class Syncfusion.Pdf.Graphics.PdfBlendBase : object {
    private static float Precision;
    private int m_count;
    private Single[] m_positions;
    public Single[] Positions { get; public set; }
    protected int Count { get; }
    protected PdfBlendBase(int count);
    public Single[] get_Positions();
    public void set_Positions(Single[] value);
    protected int get_Count();
    protected static float Gcd(Single[] values);
    protected static float Gcd(float u, float v);
    protected static int Gcd(int u, int v);
    private static bool IsEven(int u, int v);
    private static bool IsEven(int u);
    internal static PdfColor Interpolate(double t, PdfColor color1, PdfColor color2, PdfColorSpace colorSpace);
    internal static double Interpolate(double t, double v1, double v2);
    protected Array SetArray(Array array);
}
public enum Syncfusion.Pdf.Graphics.PdfBlendMode : Enum {
    public int value__;
    public static PdfBlendMode Normal;
    public static PdfBlendMode Multiply;
    public static PdfBlendMode Screen;
    public static PdfBlendMode Overlay;
    public static PdfBlendMode Darken;
    public static PdfBlendMode Lighten;
    public static PdfBlendMode ColorDodge;
    public static PdfBlendMode ColorBurn;
    public static PdfBlendMode HardLight;
    public static PdfBlendMode SoftLight;
    public static PdfBlendMode Difference;
    public static PdfBlendMode Exclusion;
    public static PdfBlendMode Hue;
    public static PdfBlendMode Saturation;
    public static PdfBlendMode Color;
    public static PdfBlendMode Luminosity;
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public abstract class Syncfusion.Pdf.Graphics.PdfBrush : object {
    internal abstract virtual bool MonitorChanges(PdfBrush brush, PdfStreamWriter streamWriter, GetResources getResources, bool saveChanges, PdfColorSpace currentColorSpace);
    internal abstract virtual bool MonitorChanges(PdfBrush brush, PdfStreamWriter streamWriter, GetResources getResources, bool saveChanges, PdfColorSpace currentColorSpace, bool check, bool iccbased, bool indexed);
    internal abstract virtual bool MonitorChanges(PdfBrush brush, PdfStreamWriter streamWriter, GetResources getResources, bool saveChanges, PdfColorSpace currentColorSpace, bool check);
    internal abstract virtual bool MonitorChanges(PdfBrush brush, PdfStreamWriter streamWriter, GetResources getResources, bool saveChanges, PdfColorSpace currentColorSpace, bool check, bool iccbased);
    internal abstract virtual void ResetChanges(PdfStreamWriter streamWriter);
    private sealed virtual override object Syncfusion.Pdf.ICloneable.Clone();
    public abstract virtual PdfBrush Clone();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class Syncfusion.Pdf.Graphics.PdfBrushes : object {
    private static Dictionary`2<object, object> s_brushes;
    public static PdfBrush AliceBlue { get; }
    public static PdfBrush AntiqueWhite { get; }
    public static PdfBrush Aqua { get; }
    public static PdfBrush Aquamarine { get; }
    public static PdfBrush Azure { get; }
    public static PdfBrush Beige { get; }
    public static PdfBrush Bisque { get; }
    public static PdfBrush Black { get; }
    public static PdfBrush BlanchedAlmond { get; }
    public static PdfBrush Blue { get; }
    public static PdfBrush BlueViolet { get; }
    public static PdfBrush Brown { get; }
    public static PdfBrush BurlyWood { get; }
    public static PdfBrush CadetBlue { get; }
    public static PdfBrush Chartreuse { get; }
    public static PdfBrush Chocolate { get; }
    public static PdfBrush Coral { get; }
    public static PdfBrush CornflowerBlue { get; }
    public static PdfBrush Cornsilk { get; }
    public static PdfBrush Crimson { get; }
    public static PdfBrush Cyan { get; }
    public static PdfBrush DarkBlue { get; }
    public static PdfBrush DarkCyan { get; }
    public static PdfBrush DarkGoldenrod { get; }
    public static PdfBrush DarkGray { get; }
    public static PdfBrush DarkGreen { get; }
    public static PdfBrush DarkKhaki { get; }
    public static PdfBrush DarkMagenta { get; }
    public static PdfBrush DarkOliveGreen { get; }
    public static PdfBrush DarkOrange { get; }
    public static PdfBrush DarkOrchid { get; }
    public static PdfBrush DarkRed { get; }
    public static PdfBrush DarkSalmon { get; }
    public static PdfBrush DarkSeaGreen { get; }
    public static PdfBrush DarkSlateBlue { get; }
    public static PdfBrush DarkSlateGray { get; }
    public static PdfBrush DarkTurquoise { get; }
    public static PdfBrush DarkViolet { get; }
    public static PdfBrush DeepPink { get; }
    public static PdfBrush DeepSkyBlue { get; }
    public static PdfBrush DimGray { get; }
    public static PdfBrush DodgerBlue { get; }
    public static PdfBrush Firebrick { get; }
    public static PdfBrush FloralWhite { get; }
    public static PdfBrush ForestGreen { get; }
    public static PdfBrush Fuchsia { get; }
    public static PdfBrush Gainsboro { get; }
    public static PdfBrush GhostWhite { get; }
    public static PdfBrush Gold { get; }
    public static PdfBrush Goldenrod { get; }
    public static PdfBrush Gray { get; }
    public static PdfBrush Green { get; }
    public static PdfBrush GreenYellow { get; }
    public static PdfBrush Honeydew { get; }
    public static PdfBrush HotPink { get; }
    public static PdfBrush IndianRed { get; }
    public static PdfBrush Indigo { get; }
    public static PdfBrush Ivory { get; }
    public static PdfBrush Khaki { get; }
    public static PdfBrush Lavender { get; }
    public static PdfBrush LavenderBlush { get; }
    public static PdfBrush LawnGreen { get; }
    public static PdfBrush LemonChiffon { get; }
    public static PdfBrush LightBlue { get; }
    public static PdfBrush LightCoral { get; }
    public static PdfBrush LightCyan { get; }
    public static PdfBrush LightGoldenrodYellow { get; }
    public static PdfBrush LightGray { get; }
    public static PdfBrush LightGreen { get; }
    public static PdfBrush LightPink { get; }
    public static PdfBrush LightSalmon { get; }
    public static PdfBrush LightSeaGreen { get; }
    public static PdfBrush LightSkyBlue { get; }
    public static PdfBrush LightSlateGray { get; }
    public static PdfBrush LightSteelBlue { get; }
    public static PdfBrush LightYellow { get; }
    public static PdfBrush Lime { get; }
    public static PdfBrush LimeGreen { get; }
    public static PdfBrush Linen { get; }
    public static PdfBrush Magenta { get; }
    public static PdfBrush Maroon { get; }
    public static PdfBrush MediumAquamarine { get; }
    public static PdfBrush MediumBlue { get; }
    public static PdfBrush MediumOrchid { get; }
    public static PdfBrush MediumPurple { get; }
    public static PdfBrush MediumSeaGreen { get; }
    public static PdfBrush MediumSlateBlue { get; }
    public static PdfBrush MediumSpringGreen { get; }
    public static PdfBrush MediumTurquoise { get; }
    public static PdfBrush MediumVioletRed { get; }
    public static PdfBrush MidnightBlue { get; }
    public static PdfBrush MintCream { get; }
    public static PdfBrush MistyRose { get; }
    public static PdfBrush Moccasin { get; }
    public static PdfBrush NavajoWhite { get; }
    public static PdfBrush Navy { get; }
    public static PdfBrush OldLace { get; }
    public static PdfBrush Olive { get; }
    public static PdfBrush OliveDrab { get; }
    public static PdfBrush Orange { get; }
    public static PdfBrush OrangeRed { get; }
    public static PdfBrush Orchid { get; }
    public static PdfBrush PaleGoldenrod { get; }
    public static PdfBrush PaleGreen { get; }
    public static PdfBrush PaleTurquoise { get; }
    public static PdfBrush PaleVioletRed { get; }
    public static PdfBrush PapayaWhip { get; }
    public static PdfBrush PeachPuff { get; }
    public static PdfBrush Peru { get; }
    public static PdfBrush Pink { get; }
    public static PdfBrush Plum { get; }
    public static PdfBrush PowderBlue { get; }
    public static PdfBrush Purple { get; }
    public static PdfBrush Red { get; }
    public static PdfBrush RosyBrown { get; }
    public static PdfBrush RoyalBlue { get; }
    public static PdfBrush SaddleBrown { get; }
    public static PdfBrush Salmon { get; }
    public static PdfBrush SandyBrown { get; }
    public static PdfBrush SeaGreen { get; }
    public static PdfBrush SeaShell { get; }
    public static PdfBrush Sienna { get; }
    public static PdfBrush Silver { get; }
    public static PdfBrush SkyBlue { get; }
    public static PdfBrush SlateBlue { get; }
    public static PdfBrush SlateGray { get; }
    public static PdfBrush Snow { get; }
    public static PdfBrush SpringGreen { get; }
    public static PdfBrush SteelBlue { get; }
    public static PdfBrush Tan { get; }
    public static PdfBrush Teal { get; }
    public static PdfBrush Thistle { get; }
    public static PdfBrush Tomato { get; }
    public static PdfBrush Transparent { get; }
    public static PdfBrush Turquoise { get; }
    public static PdfBrush Violet { get; }
    public static PdfBrush Wheat { get; }
    public static PdfBrush White { get; }
    public static PdfBrush WhiteSmoke { get; }
    public static PdfBrush Yellow { get; }
    public static PdfBrush YellowGreen { get; }
    private static PdfBrushes();
    public static PdfBrush get_AliceBlue();
    public static PdfBrush get_AntiqueWhite();
    public static PdfBrush get_Aqua();
    public static PdfBrush get_Aquamarine();
    public static PdfBrush get_Azure();
    public static PdfBrush get_Beige();
    public static PdfBrush get_Bisque();
    public static PdfBrush get_Black();
    public static PdfBrush get_BlanchedAlmond();
    public static PdfBrush get_Blue();
    public static PdfBrush get_BlueViolet();
    public static PdfBrush get_Brown();
    public static PdfBrush get_BurlyWood();
    public static PdfBrush get_CadetBlue();
    public static PdfBrush get_Chartreuse();
    public static PdfBrush get_Chocolate();
    public static PdfBrush get_Coral();
    public static PdfBrush get_CornflowerBlue();
    public static PdfBrush get_Cornsilk();
    public static PdfBrush get_Crimson();
    public static PdfBrush get_Cyan();
    public static PdfBrush get_DarkBlue();
    public static PdfBrush get_DarkCyan();
    public static PdfBrush get_DarkGoldenrod();
    public static PdfBrush get_DarkGray();
    public static PdfBrush get_DarkGreen();
    public static PdfBrush get_DarkKhaki();
    public static PdfBrush get_DarkMagenta();
    public static PdfBrush get_DarkOliveGreen();
    public static PdfBrush get_DarkOrange();
    public static PdfBrush get_DarkOrchid();
    public static PdfBrush get_DarkRed();
    public static PdfBrush get_DarkSalmon();
    public static PdfBrush get_DarkSeaGreen();
    public static PdfBrush get_DarkSlateBlue();
    public static PdfBrush get_DarkSlateGray();
    public static PdfBrush get_DarkTurquoise();
    public static PdfBrush get_DarkViolet();
    public static PdfBrush get_DeepPink();
    public static PdfBrush get_DeepSkyBlue();
    public static PdfBrush get_DimGray();
    public static PdfBrush get_DodgerBlue();
    public static PdfBrush get_Firebrick();
    public static PdfBrush get_FloralWhite();
    public static PdfBrush get_ForestGreen();
    public static PdfBrush get_Fuchsia();
    public static PdfBrush get_Gainsboro();
    public static PdfBrush get_GhostWhite();
    public static PdfBrush get_Gold();
    public static PdfBrush get_Goldenrod();
    public static PdfBrush get_Gray();
    public static PdfBrush get_Green();
    public static PdfBrush get_GreenYellow();
    public static PdfBrush get_Honeydew();
    public static PdfBrush get_HotPink();
    public static PdfBrush get_IndianRed();
    public static PdfBrush get_Indigo();
    public static PdfBrush get_Ivory();
    public static PdfBrush get_Khaki();
    public static PdfBrush get_Lavender();
    public static PdfBrush get_LavenderBlush();
    public static PdfBrush get_LawnGreen();
    public static PdfBrush get_LemonChiffon();
    public static PdfBrush get_LightBlue();
    public static PdfBrush get_LightCoral();
    public static PdfBrush get_LightCyan();
    public static PdfBrush get_LightGoldenrodYellow();
    public static PdfBrush get_LightGray();
    public static PdfBrush get_LightGreen();
    public static PdfBrush get_LightPink();
    public static PdfBrush get_LightSalmon();
    public static PdfBrush get_LightSeaGreen();
    public static PdfBrush get_LightSkyBlue();
    public static PdfBrush get_LightSlateGray();
    public static PdfBrush get_LightSteelBlue();
    public static PdfBrush get_LightYellow();
    public static PdfBrush get_Lime();
    public static PdfBrush get_LimeGreen();
    public static PdfBrush get_Linen();
    public static PdfBrush get_Magenta();
    public static PdfBrush get_Maroon();
    public static PdfBrush get_MediumAquamarine();
    public static PdfBrush get_MediumBlue();
    public static PdfBrush get_MediumOrchid();
    public static PdfBrush get_MediumPurple();
    public static PdfBrush get_MediumSeaGreen();
    public static PdfBrush get_MediumSlateBlue();
    public static PdfBrush get_MediumSpringGreen();
    public static PdfBrush get_MediumTurquoise();
    public static PdfBrush get_MediumVioletRed();
    public static PdfBrush get_MidnightBlue();
    public static PdfBrush get_MintCream();
    public static PdfBrush get_MistyRose();
    public static PdfBrush get_Moccasin();
    public static PdfBrush get_NavajoWhite();
    public static PdfBrush get_Navy();
    public static PdfBrush get_OldLace();
    public static PdfBrush get_Olive();
    public static PdfBrush get_OliveDrab();
    public static PdfBrush get_Orange();
    public static PdfBrush get_OrangeRed();
    public static PdfBrush get_Orchid();
    public static PdfBrush get_PaleGoldenrod();
    public static PdfBrush get_PaleGreen();
    public static PdfBrush get_PaleTurquoise();
    public static PdfBrush get_PaleVioletRed();
    public static PdfBrush get_PapayaWhip();
    public static PdfBrush get_PeachPuff();
    public static PdfBrush get_Peru();
    public static PdfBrush get_Pink();
    public static PdfBrush get_Plum();
    public static PdfBrush get_PowderBlue();
    public static PdfBrush get_Purple();
    public static PdfBrush get_Red();
    public static PdfBrush get_RosyBrown();
    public static PdfBrush get_RoyalBlue();
    public static PdfBrush get_SaddleBrown();
    public static PdfBrush get_Salmon();
    public static PdfBrush get_SandyBrown();
    public static PdfBrush get_SeaGreen();
    public static PdfBrush get_SeaShell();
    public static PdfBrush get_Sienna();
    public static PdfBrush get_Silver();
    public static PdfBrush get_SkyBlue();
    public static PdfBrush get_SlateBlue();
    public static PdfBrush get_SlateGray();
    public static PdfBrush get_Snow();
    public static PdfBrush get_SpringGreen();
    public static PdfBrush get_SteelBlue();
    public static PdfBrush get_Tan();
    public static PdfBrush get_Teal();
    public static PdfBrush get_Thistle();
    public static PdfBrush get_Tomato();
    public static PdfBrush get_Transparent();
    public static PdfBrush get_Turquoise();
    public static PdfBrush get_Violet();
    public static PdfBrush get_Wheat();
    public static PdfBrush get_White();
    public static PdfBrush get_WhiteSmoke();
    public static PdfBrush get_Yellow();
    public static PdfBrush get_YellowGreen();
    private static PdfBrush GetBrush(KnownColor colorName);
}
public class Syncfusion.Pdf.Graphics.PdfCancelEventArgs : EventArgs {
    private bool m_cancel;
    public bool Cancel { get; public set; }
    public bool get_Cancel();
    public void set_Cancel(bool value);
}
public enum Syncfusion.Pdf.Graphics.PdfCjkFontFamily : Enum {
    public int value__;
    public static PdfCjkFontFamily HanyangSystemsGothicMedium;
    public static PdfCjkFontFamily HanyangSystemsShinMyeongJoMedium;
    public static PdfCjkFontFamily HeiseiKakuGothicW5;
    public static PdfCjkFontFamily HeiseiMinchoW3;
    public static PdfCjkFontFamily MonotypeHeiMedium;
    public static PdfCjkFontFamily MonotypeSungLight;
    public static PdfCjkFontFamily SinoTypeSongLight;
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class Syncfusion.Pdf.Graphics.PdfCjkStandardFont : PdfFont {
    private static int c_charOffset;
    private PdfCjkFontFamily m_fontFamily;
    public PdfCjkFontFamily FontFamily { get; }
    public PdfCjkStandardFont(PdfCjkFontFamily fontFamily, float size, PdfFontStyle style);
    public PdfCjkStandardFont(PdfCjkFontFamily fontFamily, float size);
    public PdfCjkStandardFont(PdfCjkStandardFont prototype, float size);
    public PdfCjkStandardFont(PdfCjkStandardFont prototype, float size, PdfFontStyle style);
    public PdfCjkFontFamily get_FontFamily();
    protected virtual bool EqualsToFont(PdfFont font);
    protected internal virtual float GetCharWidth(char charCode, PdfStringFormat format);
    protected internal virtual float GetLineWidth(string line, PdfStringFormat format);
    private void InitializeInternals();
    private PdfDictionary CreateInternals();
    private PdfArray GetDescendantFont();
    private static PdfName GetEncoding(PdfCjkFontFamily fontFamily);
    private void CheckStyle();
    private float GetCharWidthInternal(char charCode, PdfStringFormat format);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class Syncfusion.Pdf.Graphics.PdfColor : ValueType {
    private static Dictionary`2<int, object> s_rgbStrings;
    private static Dictionary`2<float, object> s_grayStringsSroke;
    private static Dictionary`2<float, object> s_grayStringsFill;
    private static PdfColor s_emptyColor;
    private static float MaxColourChannelValue;
    private byte m_red;
    private float m_cyan;
    private byte m_green;
    private float m_magenta;
    private byte m_blue;
    private float m_yellow;
    private float m_black;
    private float m_gray;
    private byte m_alpha;
    private bool m_isFilled;
    public static PdfColor Empty { get; }
    public bool IsEmpty { get; }
    public byte B { get; public set; }
    public float Blue { get; }
    public float C { get; public set; }
    public byte G { get; public set; }
    public float Green { get; }
    public float Gray { get; public set; }
    public float K { get; public set; }
    public float M { get; public set; }
    public byte R { get; public set; }
    public float Red { get; }
    public float Y { get; public set; }
    internal byte A { get; internal set; }
    public PdfColor(PdfColor color);
    public PdfColor(Color color);
    public PdfColor(float gray);
    public PdfColor(byte red, byte green, byte blue);
    internal PdfColor(float red, float green, float blue);
    internal PdfColor(byte a, byte red, byte green, byte blue);
    public PdfColor(float cyan, float magenta, float yellow, float black);
    private static PdfColor();
    public static PdfColor get_Empty();
    public bool get_IsEmpty();
    public byte get_B();
    public void set_B(byte value);
    public float get_Blue();
    public float get_C();
    public void set_C(float value);
    public byte get_G();
    public void set_G(byte value);
    public float get_Green();
    public float get_Gray();
    public void set_Gray(float value);
    public float get_K();
    public void set_K(float value);
    public float get_M();
    public void set_M(float value);
    public byte get_R();
    public void set_R(byte value);
    public float get_Red();
    public float get_Y();
    public void set_Y(float value);
    internal byte get_A();
    internal void set_A(byte value);
    public int ToArgb();
    private static Color FromRGBColor(int r, int g, int b);
    public static PdfColor op_Implicit(Color color);
    public static Color op_Implicit(PdfColor color);
    public static bool op_Equality(PdfColor colour1, PdfColor colour2);
    public static bool op_Inequality(PdfColor colour1, PdfColor colour2);
    public virtual bool Equals(object obj);
    public bool Equals(PdfColor colour);
    public virtual int GetHashCode();
    private string RGBToString(bool ifStroking);
    private string CalRGBToString(bool ifStroking);
    private string CalLabToString(bool ifStroking);
    private string CalGrayscaleToString(bool ifStroking);
    private string IccRGBToString(bool ifStroking);
    private string CalCMYKToString(bool ifStroking);
    private string IccLabToString(bool ifStroking);
    private string IccGrayscaleToString(bool ifStroking);
    internal string IndexedToString(bool ifStroking);
    private string GrayscaleToString(bool ifStroking);
    private string CMYKToString(bool ifStroking);
    private void RGBToStringBuilder(StringBuilder sb, bool stroke);
    private void CMYKToStringBuilder(StringBuilder sb, bool stroke);
    private void GrayscaleToStringBuilder(StringBuilder sb, bool stroke);
    internal string ToString(PdfColorSpace colorSpace, bool stroke);
    internal string CalToString(PdfColorSpace colorSpace, bool stroke);
    internal string IccColorToString(PdfColorSpace colorSpace, bool stroke);
    internal void WriteToStringBuilder(StringBuilder sb, PdfColorSpace colorSpace, bool stroke);
    private void AssignCMYK(byte r, byte g, byte b);
    private void AssignRGB(float cyan, float magenta, float yellow, float black);
    private static bool CompareColours(Color color1, Color color2);
    internal PdfArray ToArray();
    internal PdfArray ToArray(PdfColorSpace colorSpace);
    internal static void Clear();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class Syncfusion.Pdf.Graphics.PdfColorBlend : PdfBlendBase {
    private PdfColor[] m_colors;
    private PdfBrush m_brush;
    public PdfColor[] Colors { get; public set; }
    public PdfColorBlend(int count);
    internal PdfColorBlend(PdfBrush brush);
    public PdfColor[] get_Colors();
    public void set_Colors(PdfColor[] value);
    internal PdfFunction GetFunction(PdfColorSpace colorSpace);
    internal PdfColorBlend CloneColorBlend();
    private static Single[] SetRange(int colourComponents, float maxValue);
    private static int GetColorComponentsCount(PdfColorSpace colorSpace);
    private Byte[] GetSamplesValues(PdfColorSpace colorSpace, int sampleCount, int maxComponentValue, float step);
    private Byte[] GetGrayscaleSamples(int sampleCount, int maxComponentValue, float step);
    private Byte[] GetCmykSamples(int sampleCount, int maxComponentValue, float step);
    private Byte[] GetRgbSamples(int sampleCount, int maxComponentValue, float step);
    private PdfColor GetNextColor(int index, float step, PdfColorSpace colorSpace);
    private void GetIndices(float position, Int32& indexLow, Int32& indexHi);
    private int GetMaxComponentValue(PdfColorSpace colorSpace);
    private Single[] GetIntervals(Single[] positions);
}
public class Syncfusion.Pdf.Graphics.PdfColorMask : PdfMask {
    private PdfColor m_startColor;
    private PdfColor m_endColor;
    public PdfColor StartColor { get; public set; }
    public PdfColor EndColor { get; public set; }
    public PdfColorMask(PdfColor startColor, PdfColor endColor);
    public PdfColor get_StartColor();
    public void set_StartColor(PdfColor value);
    public PdfColor get_EndColor();
    public void set_EndColor(PdfColor value);
}
public enum Syncfusion.Pdf.Graphics.PdfColorSpace : Enum {
    public int value__;
    public static PdfColorSpace RGB;
    public static PdfColorSpace CMYK;
    public static PdfColorSpace GrayScale;
    public static PdfColorSpace Indexed;
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Syncfusion.Pdf.Graphics.PdfCustomLineCap : object {
    private PdfPath m_fillPath;
    private PdfPath m_strokePath;
    private PdfLineCap m_baseCap;
    private PdfLineJoin m_strokeJoin;
    private float m_widthScale;
    private PdfLineCap m_startCap;
    private PdfLineCap m_endCap;
    private float m_baseInset;
    public PdfLineCap BaseCap { get; public set; }
    public float BaseInset { get; public set; }
    public PdfLineJoin StrokeJoin { get; public set; }
    public float WidthScale { get; public set; }
    public PdfCustomLineCap(PdfPath fillPath, PdfPath strokePath);
    public PdfCustomLineCap(PdfPath fillPath, PdfPath strokePath, PdfLineCap baseCap);
    public PdfCustomLineCap(PdfPath fillPath, PdfPath strokePath, PdfLineCap baseCap, float baseInset);
    internal PdfCustomLineCap(PdfPath pdfPath, PdfLineCap baseCap, float baseInset, bool isFillPath);
    public PdfLineCap get_BaseCap();
    public void set_BaseCap(PdfLineCap value);
    public float get_BaseInset();
    public void set_BaseInset(float value);
    public PdfLineJoin get_StrokeJoin();
    public void set_StrokeJoin(PdfLineJoin value);
    public float get_WidthScale();
    public void set_WidthScale(float value);
    public void SetStrokeCaps(PdfLineCap startCap, PdfLineCap endCap);
    internal void DrawCustomCap(PdfGraphics graphics, PointF[] points, PdfPen pen, bool isStartCap);
}
public enum Syncfusion.Pdf.Graphics.PdfDashStyle : Enum {
    public int value__;
    public static PdfDashStyle Solid;
    public static PdfDashStyle Dash;
    public static PdfDashStyle Dot;
    public static PdfDashStyle DashDot;
    public static PdfDashStyle DashDotDot;
    public static PdfDashStyle Custom;
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public abstract class Syncfusion.Pdf.Graphics.PdfDrawElement : PdfShapeElement {
    private PdfPen m_pen;
    public PdfPen Pen { get; public set; }
    protected PdfDrawElement(PdfPen pen);
    public PdfPen get_Pen();
    public void set_Pen(PdfPen value);
    protected virtual PdfPen ObtainPen();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class Syncfusion.Pdf.Graphics.PdfEllipse : PdfRectangleArea {
    public float RadiusX { get; }
    public float RadiusY { get; }
    public PointF Center { get; }
    public PdfEllipse(float width, float height);
    public PdfEllipse(PdfPen pen, float width, float height);
    public PdfEllipse(PdfBrush brush, float width, float height);
    public PdfEllipse(PdfPen pen, PdfBrush brush, float width, float height);
    public PdfEllipse(float x, float y, float width, float height);
    public PdfEllipse(RectangleF rectangle);
    public PdfEllipse(PdfPen pen, float x, float y, float width, float height);
    public PdfEllipse(PdfPen pen, RectangleF rectangle);
    public PdfEllipse(PdfBrush brush, float x, float y, float width, float height);
    public PdfEllipse(PdfBrush brush, RectangleF rectangle);
    public PdfEllipse(PdfPen pen, PdfBrush brush, float x, float y, float width, float height);
    public PdfEllipse(PdfPen pen, PdfBrush brush, RectangleF rectangle);
    public float get_RadiusX();
    public float get_RadiusY();
    public PointF get_Center();
    protected virtual void DrawInternal(PdfGraphics graphics);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public abstract class Syncfusion.Pdf.Graphics.PdfEllipsePart : PdfRectangleArea {
    private float m_startAngle;
    private float m_sweepAngle;
    public float StartAngle { get; public set; }
    public float SweepAngle { get; public set; }
    protected PdfEllipsePart(float x, float y, float width, float height, float startAngle, float sweepAngle);
    protected PdfEllipsePart(RectangleF rectangle, float startAngle, float sweepAngle);
    protected PdfEllipsePart(PdfPen pen, PdfBrush brush, float x, float y, float width, float height, float startAngle, float sweepAngle);
    protected PdfEllipsePart(PdfPen pen, PdfBrush brush, RectangleF rectangle, float startAngle, float sweepAngle);
    public float get_StartAngle();
    public void set_StartAngle(float value);
    public float get_SweepAngle();
    public void set_SweepAngle(float value);
}
[FlagsAttribute]
public enum Syncfusion.Pdf.Graphics.PdfExtend : Enum {
    public int value__;
    public static PdfExtend None;
    public static PdfExtend Start;
    public static PdfExtend End;
    public static PdfExtend Both;
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Syncfusion.Pdf.Graphics.PdfExternalGraphicsState : object {
    private PdfDictionary m_stateDictionary;
    public IPdfPrimitive Element { get; }
    public sealed virtual IPdfPrimitive get_Element();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public abstract class Syncfusion.Pdf.Graphics.PdfFillElement : PdfDrawElement {
    private PdfBrush m_brush;
    public PdfBrush Brush { get; public set; }
    protected PdfFillElement(PdfPen pen);
    protected PdfFillElement(PdfBrush brush);
    protected PdfFillElement(PdfPen pen, PdfBrush brush);
    public PdfBrush get_Brush();
    public void set_Brush(PdfBrush value);
    protected virtual PdfPen ObtainPen();
}
public enum Syncfusion.Pdf.Graphics.PdfFillMode : Enum {
    public int value__;
    public static PdfFillMode Winding;
    public static PdfFillMode Alternate;
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public abstract class Syncfusion.Pdf.Graphics.PdfFont : object {
    internal static float CharSizeMultiplier;
    protected static object s_syncObject;
    private float m_size;
    private PdfFontStyle m_style;
    private PdfFontMetrics m_fontMetrics;
    private IPdfPrimitive m_fontInternals;
    private string m_internalFontName;
    private float m_ascentValue;
    public string Name { get; }
    public float Size { get; internal set; }
    public float Height { get; }
    public PdfFontStyle Style { get; internal set; }
    public bool Bold { get; }
    public bool Italic { get; }
    public bool Strikeout { get; }
    public bool Underline { get; }
    internal PdfFontMetrics Metrics { get; internal set; }
    internal string InternalFontName { get; internal set; }
    internal IPdfPrimitive FontInternal { get; internal set; }
    internal float Ascent { get; internal set; }
    private IPdfPrimitive Syncfusion.Pdf.IPdfWrapper.Element { get; }
    protected PdfFont(float size);
    protected PdfFont(float size, PdfFontStyle style);
    private static PdfFont();
    public string get_Name();
    public float get_Size();
    internal void set_Size(float value);
    public float get_Height();
    public PdfFontStyle get_Style();
    internal void set_Style(PdfFontStyle value);
    public bool get_Bold();
    public bool get_Italic();
    public bool get_Strikeout();
    public bool get_Underline();
    internal PdfFontMetrics get_Metrics();
    internal void set_Metrics(PdfFontMetrics value);
    internal string get_InternalFontName();
    internal void set_InternalFontName(string value);
    internal IPdfPrimitive get_FontInternal();
    internal void set_FontInternal(IPdfPrimitive value);
    internal float get_Ascent();
    internal void set_Ascent(float value);
    public SizeF MeasureString(string text);
    public SizeF MeasureString(string text, PdfStringFormat format);
    public SizeF MeasureString(string text, PdfStringFormat format, Int32& charactersFitted, Int32& linesFilled);
    public SizeF MeasureString(string text, float width);
    public SizeF MeasureString(string text, float width, PdfStringFormat format);
    public SizeF MeasureString(string text, float width, PdfStringFormat format, Int32& charactersFitted, Int32& linesFilled);
    public SizeF MeasureString(string text, SizeF layoutArea);
    public SizeF MeasureString(string text, SizeF layoutArea, PdfStringFormat format);
    public SizeF MeasureString(string text, SizeF layoutArea, PdfStringFormat format, Int32& charactersFitted, Int32& linesFilled);
    internal SizeF MeasureString(string text, SizeF layoutArea, PdfStringFormat format, PdfStringLayoutResult& result);
    private sealed virtual override IPdfPrimitive Syncfusion.Pdf.IPdfWrapper.get_Element();
    private sealed virtual override bool Syncfusion.Pdf.IPdfCache.EqualsTo(IPdfCache obj);
    private sealed virtual override IPdfPrimitive Syncfusion.Pdf.IPdfCache.GetInternals();
    private sealed virtual override void Syncfusion.Pdf.IPdfCache.SetInternals(IPdfPrimitive internals);
    protected abstract virtual bool EqualsToFont(PdfFont font);
    protected internal abstract virtual float GetCharWidth(char charCode, PdfStringFormat format);
    protected internal abstract virtual float GetLineWidth(string line, PdfStringFormat format);
    protected void SetStyle(PdfFontStyle style);
    protected float ApplyFormatSettings(string line, PdfStringFormat format, float width);
}
public enum Syncfusion.Pdf.Graphics.PdfFontFamily : Enum {
    public int value__;
    public static PdfFontFamily Helvetica;
    public static PdfFontFamily Courier;
    public static PdfFontFamily TimesRoman;
    public static PdfFontFamily Symbol;
    public static PdfFontFamily ZapfDingbats;
}
[FlagsAttribute]
public enum Syncfusion.Pdf.Graphics.PdfFontStyle : Enum {
    public int value__;
    public static PdfFontStyle Regular;
    public static PdfFontStyle Bold;
    public static PdfFontStyle Italic;
    public static PdfFontStyle Underline;
    public static PdfFontStyle Strikeout;
}
public enum Syncfusion.Pdf.Graphics.PdfFontType : Enum {
    public int value__;
    public static PdfFontType Standard;
    public static PdfFontType TrueType;
    public static PdfFontType TrueTypeEmbedded;
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public abstract class Syncfusion.Pdf.Graphics.PdfGradientBrush : PdfBrush {
    private PdfColor m_background;
    private bool m_bStroking;
    private PdfDictionary m_patternDictionary;
    private PdfDictionary m_shading;
    private PdfTransformationMatrix m_matrix;
    private PdfExternalGraphicsState m_externalState;
    private PdfColorSpace m_colorSpace;
    private PdfFunction m_function;
    public PdfColor Background { get; public set; }
    public bool AntiAlias { get; public set; }
    internal PdfFunction Function { get; internal set; }
    internal PdfArray BBox { get; internal set; }
    internal PdfColorSpace ColorSpace { get; internal set; }
    internal bool Stroking { get; internal set; }
    internal PdfDictionary PatternDictionary { get; }
    internal PdfDictionary Shading { get; internal set; }
    internal PdfTransformationMatrix Matrix { get; internal set; }
    internal PdfExternalGraphicsState ExternalState { get; internal set; }
    private IPdfPrimitive Syncfusion.Pdf.IPdfWrapper.Element { get; }
    internal PdfGradientBrush(PdfDictionary shading);
    public PdfColor get_Background();
    public void set_Background(PdfColor value);
    public bool get_AntiAlias();
    public void set_AntiAlias(bool value);
    internal PdfFunction get_Function();
    internal void set_Function(PdfFunction value);
    internal PdfArray get_BBox();
    internal void set_BBox(PdfArray value);
    internal PdfColorSpace get_ColorSpace();
    internal void set_ColorSpace(PdfColorSpace value);
    internal bool get_Stroking();
    internal void set_Stroking(bool value);
    internal PdfDictionary get_PatternDictionary();
    internal PdfDictionary get_Shading();
    internal void set_Shading(PdfDictionary value);
    internal PdfTransformationMatrix get_Matrix();
    internal void set_Matrix(PdfTransformationMatrix value);
    internal PdfExternalGraphicsState get_ExternalState();
    internal void set_ExternalState(PdfExternalGraphicsState value);
    internal virtual bool MonitorChanges(PdfBrush brush, PdfStreamWriter streamWriter, GetResources getResources, bool saveChanges, PdfColorSpace currentColorSpace);
    internal virtual bool MonitorChanges(PdfBrush brush, PdfStreamWriter streamWriter, GetResources getResources, bool saveChanges, PdfColorSpace currentColorSpace, bool check);
    internal virtual bool MonitorChanges(PdfBrush brush, PdfStreamWriter streamWriter, GetResources getResources, bool saveChanges, PdfColorSpace currentColorSpace, bool check, bool iccbased);
    internal virtual bool MonitorChanges(PdfBrush brush, PdfStreamWriter streamWriter, GetResources getResources, bool saveChanges, PdfColorSpace currentColorSpace, bool check, bool iccbased, bool indexed);
    internal virtual void ResetChanges(PdfStreamWriter streamWriter);
    internal static string ColorSpaceToDeviceName(PdfColorSpace colorSpace);
    internal void ResetPatternDictionary(PdfDictionary dictionary);
    internal abstract virtual void ResetFunction();
    protected void CloneAntiAliasingValue(PdfGradientBrush brush);
    protected void CloneBackgroundValue(PdfGradientBrush brush);
    private sealed virtual override IPdfPrimitive Syncfusion.Pdf.IPdfWrapper.get_Element();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class Syncfusion.Pdf.Graphics.PdfGraphics : object {
    private static int PathTypesValuesMask;
    internal bool m_isEMF;
    internal bool m_isEMFPlus;
    internal bool m_isUseFontSize;
    internal bool m_isBaselineFormat;
    internal float m_DpiY;
    private PdfStreamWriter m_streamWriter;
    private GetResources m_getResources;
    private SizeF m_canvasSize;
    internal RectangleF m_clipBounds;
    internal bool m_bStateSaved;
    private PdfPen m_currentPen;
    private PdfBrush m_currentBrush;
    private PdfFont m_currentFont;
    private PdfColorSpace m_currentColorSpace;
    private bool m_istransparencySet;
    private bool m_bCSInitialized;
    private bool m_CIEColors;
    private bool m_isItalic;
    private bool m_isSkewed;
    private bool m_isRestoreGraphics;
    internal float m_cellBorderMaxHeight;
    private PdfGraphicsState gState;
    private Stack`1<PdfGraphicsState> m_graphicsState;
    private PdfTransformationMatrix m_matrix;
    private TextRenderingMode m_previousTextRenderingMode;
    private float m_previousCharacterSpacing;
    private float m_previousWordSpacing;
    private float m_previousTextScaling;
    private Dictionary`2<TransparencyData, PdfTransparency> m_trasparencies;
    private PdfStringFormat m_currentStringFormat;
    private PdfPageLayer m_layer;
    private PdfLayer m_documentLayer;
    private PdfAutomaticFieldInfoCollection m_automaticFields;
    private PdfStringLayoutResult m_stringLayoutResult;
    private float m_split;
    private bool m_isTransparentBrush;
    private static bool m_transparencyObject;
    private static object s_transparencyLock;
    private static object s_syncLockTemplate;
    private static object s_rtlRenderLock;
    internal SizeF m_emfScalingFactor;
    internal bool m_isEmfTextScaled;
    internal bool isImageOptimized;
    internal bool isStandardUnicode;
    internal PdfDocument m_pdfdocument;
    private float m_mediaBoxUpperRightBound;
    internal PdfArray m_cropBox;
    internal bool m_isWatermarkMediabox;
    internal bool m_isNormalRender;
    private PdfColorSpace lastDocumentCS;
    private PdfColorSpace lastGraphicsCS;
    private bool colorSpaceChanged;
    private TextRenderingMode m_textRenderingMode;
    private bool m_isTextRenderingSet;
    private PdfTag m_tag;
    internal bool isBoldFontWeight;
    private bool m_isTaggedPdf;
    [CompilerGeneratedAttribute]
private StructElementEventHandler StructElementChanged;
    private string m_currentTagType;
    private bool isTemplateGraphics;
    internal bool isEmptyLayer;
    private PdfStringLayoutResult m_layoutResult;
    private PdfDictionary m_tableSpan;
    internal bool customTag;
    private Matrix m_transformMatrix;
    private float m_pageScale;
    private GraphicsUnit m_graphicsUnit;
    private Dictionary`2<int, PdfGraphicsState> m_graphicsStates;
    private int m_GraphicsStateCount;
    private SizeF m_pageUnitScaleSize;
    private RectangleF RealClip;
    private bool m_stateChanged;
    private bool m_bFirstTransform;
    private bool m_stateRestored;
    private bool m_bFirstCall;
    private Matrix m_multiplyTransform;
    private RectangleF m_textClip;
    private bool m_clipPath;
    private bool m_isTranslate;
    private SizeF m_translateTransform;
    private RectangleF m_clipBoundsDirectPDF;
    private RectangleF m_DocIOPageBounds;
    private bool m_isDirectPDF;
    private bool m_optimizeIdenticalImages;
    private bool m_isXPStoken;
    private Dictionary`2<string, string> m_replaceCharacter;
    private bool m_artifactBMCAdded;
    internal PdfArray mBox;
    internal bool bScaleTranform;
    public SizeF Size { get; }
    internal float MediaBoxUpperRightBound { get; internal set; }
    public SizeF ClientSize { get; }
    public PdfColorSpace ColorSpace { get; public set; }
    internal PdfStreamWriter StreamWriter { get; internal set; }
    internal PdfTransformationMatrix Matrix { get; }
    internal PdfPageLayer Layer { get; }
    internal PdfPageBase Page { get; }
    internal PdfAutomaticFieldInfoCollection AutomaticFields { get; }
    internal PdfStringLayoutResult StringLayoutResult { get; }
    internal float Split { get; internal set; }
    internal static bool TransparencyObject { get; internal set; }
    internal PdfTag Tag { get; internal set; }
    internal bool IsTaggedPdf { get; }
    internal string CurrentTagType { get; internal set; }
    internal bool IsTemplateGraphics { get; internal set; }
    internal PdfStringLayoutResult LayoutResult { get; internal set; }
    internal Matrix Transform { get; internal set; }
    private float PageScale { get; private set; }
    internal GraphicsUnit PageUnit { get; internal set; }
    internal RectangleF ClipBounds { get; internal set; }
    internal RectangleF DocIOPageBounds { get; internal set; }
    internal bool IsDirectPDF { get; internal set; }
    internal bool OptimizeIdenticalImages { get; internal set; }
    internal bool XPSToken { get; internal set; }
    internal Dictionary`2<string, string> XPSReplaceCharacter { get; }
    internal PdfDictionary TableSpan { get; internal set; }
    internal PdfGraphics(SizeF size, GetResources resources, PdfStreamWriter writer);
    internal PdfGraphics(SizeF size, GetResources resources, PdfStream stream);
    private static PdfGraphics();
    [CompilerGeneratedAttribute]
internal void add_StructElementChanged(StructElementEventHandler value);
    [CompilerGeneratedAttribute]
internal void remove_StructElementChanged(StructElementEventHandler value);
    public SizeF get_Size();
    internal float get_MediaBoxUpperRightBound();
    internal void set_MediaBoxUpperRightBound(float value);
    public SizeF get_ClientSize();
    public PdfColorSpace get_ColorSpace();
    public void set_ColorSpace(PdfColorSpace value);
    internal PdfStreamWriter get_StreamWriter();
    internal void set_StreamWriter(PdfStreamWriter value);
    internal PdfTransformationMatrix get_Matrix();
    internal PdfPageLayer get_Layer();
    internal PdfPageBase get_Page();
    internal PdfAutomaticFieldInfoCollection get_AutomaticFields();
    internal PdfStringLayoutResult get_StringLayoutResult();
    internal float get_Split();
    internal void set_Split(float value);
    internal static bool get_TransparencyObject();
    internal static void set_TransparencyObject(bool value);
    internal PdfTag get_Tag();
    internal void set_Tag(PdfTag value);
    internal bool get_IsTaggedPdf();
    internal string get_CurrentTagType();
    internal void set_CurrentTagType(string value);
    internal bool get_IsTemplateGraphics();
    internal void set_IsTemplateGraphics(bool value);
    internal PdfStringLayoutResult get_LayoutResult();
    internal void set_LayoutResult(PdfStringLayoutResult value);
    internal Matrix get_Transform();
    internal void set_Transform(Matrix value);
    private float get_PageScale();
    private void set_PageScale(float value);
    internal GraphicsUnit get_PageUnit();
    internal void set_PageUnit(GraphicsUnit value);
    internal RectangleF get_ClipBounds();
    internal void set_ClipBounds(RectangleF value);
    internal RectangleF get_DocIOPageBounds();
    internal void set_DocIOPageBounds(RectangleF value);
    internal bool get_IsDirectPDF();
    internal void set_IsDirectPDF(bool value);
    internal bool get_OptimizeIdenticalImages();
    internal void set_OptimizeIdenticalImages(bool value);
    internal bool get_XPSToken();
    internal void set_XPSToken(bool value);
    internal Dictionary`2<string, string> get_XPSReplaceCharacter();
    internal PdfDictionary get_TableSpan();
    internal void set_TableSpan(PdfDictionary value);
    public void DrawLine(PdfPen pen, PointF point1, PointF point2);
    public void DrawLine(PdfPen pen, float x1, float y1, float x2, float y2);
    public void DrawRectangle(PdfPen pen, RectangleF rectangle);
    public void DrawRectangle(PdfPen pen, float x, float y, float width, float height);
    public void DrawRectangle(PdfBrush brush, RectangleF rectangle);
    public void DrawRectangle(PdfBrush brush, float x, float y, float width, float height);
    public void DrawRectangle(PdfPen pen, PdfBrush brush, RectangleF rectangle);
    public void DrawRectangle(PdfPen pen, PdfBrush brush, float x, float y, float width, float height);
    internal void DrawRoundedRectangle(RectangleF bounds, int radius, PdfPen pen, PdfBrush brush);
    internal void DrawRoundedRectangle(float x, float y, float width, float height, int radius, PdfPen pen, PdfBrush brush);
    public void DrawEllipse(PdfPen pen, RectangleF rectangle);
    public void DrawEllipse(PdfPen pen, float x, float y, float width, float height);
    public void DrawEllipse(PdfBrush brush, RectangleF rectangle);
    public void DrawEllipse(PdfBrush brush, float x, float y, float width, float height);
    public void DrawEllipse(PdfPen pen, PdfBrush brush, RectangleF rectangle);
    public void DrawEllipse(PdfPen pen, PdfBrush brush, float x, float y, float width, float height);
    public void DrawArc(PdfPen pen, RectangleF rectangle, float startAngle, float sweepAngle);
    public void DrawArc(PdfPen pen, float x, float y, float width, float height, float startAngle, float sweepAngle);
    public void DrawPie(PdfPen pen, RectangleF rectangle, float startAngle, float sweepAngle);
    public void DrawPie(PdfPen pen, float x, float y, float width, float height, float startAngle, float sweepAngle);
    public void DrawPie(PdfBrush brush, RectangleF rectangle, float startAngle, float sweepAngle);
    public void DrawPie(PdfBrush brush, float x, float y, float width, float height, float startAngle, float sweepAngle);
    public void DrawPie(PdfPen pen, PdfBrush brush, RectangleF rectangle, float startAngle, float sweepAngle);
    public void DrawPie(PdfPen pen, PdfBrush brush, float x, float y, float width, float height, float startAngle, float sweepAngle);
    public void DrawPolygon(PdfPen pen, PointF[] points);
    public void DrawPolygon(PdfBrush brush, PointF[] points);
    public void DrawPolygon(PdfPen pen, PdfBrush brush, PointF[] points);
    public void DrawBezier(PdfPen pen, PointF startPoint, PointF firstControlPoint, PointF secondControlPoint, PointF endPoint);
    public void DrawBezier(PdfPen pen, float startPointX, float startPointY, float firstControlPointX, float firstControlPointY, float secondControlPointX, float secondControlPointY, float endPointX, float endPointY);
    public void DrawPath(PdfPen pen, PdfPath path);
    public void DrawPath(PdfBrush brush, PdfPath path);
    public void DrawPath(PdfPen pen, PdfBrush brush, PdfPath path);
    public void DrawImage(PdfImage image, PointF point);
    public void DrawImage(PdfImage image, float x, float y);
    public void DrawImage(PdfImage image, RectangleF rectangle);
    public void DrawImage(PdfImage image, PointF point, SizeF size);
    public void DrawImage(PdfImage image, float x, float y, float width, float height);
    internal void SetTransparencyGroup(PdfPageBase page);
    public void DrawString(string s, PdfFont font, PdfBrush brush, PointF point);
    public void DrawString(string s, PdfFont font, PdfBrush brush, PointF point, PdfStringFormat format);
    public void DrawString(string s, PdfFont font, PdfBrush brush, float x, float y);
    public void DrawString(string s, PdfFont font, PdfBrush brush, float x, float y, PdfStringFormat format);
    public void DrawString(string s, PdfFont font, PdfPen pen, PointF point);
    public void DrawString(string s, PdfFont font, PdfPen pen, PointF point, PdfStringFormat format);
    public void DrawString(string s, PdfFont font, PdfPen pen, float x, float y);
    public void DrawString(string s, PdfFont font, PdfPen pen, float x, float y, PdfStringFormat format);
    public void DrawString(string s, PdfFont font, PdfPen pen, PdfBrush brush, PointF point);
    public void DrawString(string s, PdfFont font, PdfPen pen, PdfBrush brush, PointF point, PdfStringFormat format);
    public void DrawString(string s, PdfFont font, PdfPen pen, PdfBrush brush, float x, float y, PdfStringFormat format);
    public void DrawString(string s, PdfFont font, PdfPen pen, PdfBrush brush, float x, float y);
    public void DrawString(string s, PdfFont font, PdfBrush brush, RectangleF layoutRectangle);
    public void DrawString(string s, PdfFont font, PdfBrush brush, RectangleF layoutRectangle, PdfStringFormat format);
    internal void DrawString(string s, PdfFont font, PdfBrush brush, RectangleF layoutRectangle, PdfStringFormat format, double maxRowFontSize, PdfFont maxPdfFont, PdfStringFormat maxPdfFormat);
    public void DrawString(string s, PdfFont font, PdfPen pen, RectangleF layoutRectangle);
    public void DrawString(string s, PdfFont font, PdfPen pen, RectangleF layoutRectangle, PdfStringFormat format);
    public void DrawString(string s, PdfFont font, PdfPen pen, PdfBrush brush, RectangleF layoutRectangle, PdfStringFormat format);
    internal void DrawString(string s, PdfFont font, PdfPen pen, PdfBrush brush, RectangleF layoutRectangle, PdfStringFormat format, double maxRowFontSize, PdfFont maxPdfFont, PdfStringFormat maxPdfFormat);
    internal bool IsRTLChar(char input);
    public void TranslateTransform(float offsetX, float offsetY);
    public void ScaleTransform(float scaleX, float scaleY);
    public void RotateTransform(float angle);
    public void SkewTransform(float angleX, float angleY);
    internal void MultiplyTransform(PdfTransformationMatrix matrix);
    public void DrawPdfTemplate(PdfTemplate template, PointF location);
    public void DrawPdfTemplate(PdfTemplate template, PointF location, SizeF size);
    public void Flush();
    public PdfGraphicsState Save();
    public void Restore();
    public void Restore(PdfGraphicsState state);
    public void SetClip(RectangleF rectangle);
    public void SetClip(RectangleF rectangle, PdfFillMode mode);
    public void SetClip(PdfPath path);
    public void SetClip(PdfPath path, PdfFillMode mode);
    public void SetTransparency(float alpha);
    public void SetTransparency(float alphaPen, float alphaBrush);
    public void SetTransparency(float alphaPen, float alphaBrush, PdfBlendMode blendMode);
    internal void SetTextRenderingMode(TextRenderingMode mode);
    internal static string NormalizeText(PdfFont font, string text);
    internal void TranslateTransform(float offsetX, float offsetY, bool value);
    private void Initialize();
    internal void SetLayer(PdfPageLayer layer);
    internal void SetLayer(PdfLayer layer);
    internal void EndMarkContent();
    private void BeginMarkContent();
    private void PageSave(object sender, EventArgs e);
    internal static float UpdateY(float y);
    internal void PutComment(string comment);
    internal void Reset(SizeF size);
    private PdfGraphicsState DoRestoreState();
    private void StateControl(PdfPen pen, PdfBrush brush, PdfFont font);
    private void StateControl(PdfPen pen, PdfBrush brush, PdfFont font, PdfStringFormat format);
    private void FontControl(PdfFont font, PdfStringFormat format, bool saveState);
    private void ColorSpaceControl(PdfColorSpaces colorspace);
    private void BrushControl(PdfBrush brush, bool saveState);
    private void InitCurrentColorSpace();
    private void InitCurrentColorSpace(PdfColorSpace colorspace);
    private void PenControl(PdfPen pen, bool saveState);
    private void CapControl(PdfPen pen, float x2, float y2, float x1, float y1);
    private void DrawPath(PdfPen pen, PdfBrush brush, bool needClosing);
    private void DrawPath(PdfPen pen, PdfBrush brush, PdfFillMode fillMode, bool needClosing);
    internal static List`1<Single[]> GetBezierArcPoints(float x1, float y1, float x2, float y2, float startAng, float extent);
    private void ConstructArcPath(float x1, float y1, float x2, float y2, float startAng, float sweepAngle);
    private void BuildUpPath(PdfPath path);
    private void GetBezierPoints(PointF[] points, Byte[] types, Int32& i, PointF& p2, PointF& p3);
    private void BuildUpPath(PointF[] points, Byte[] types);
    private void CheckFlags(byte type);
    private TextRenderingMode GetTextRenderingMode(PdfPen pen, PdfBrush brush, PdfStringFormat format);
    internal void ClipTranslateMargins(float x, float y, float left, float top, float right, float bottom);
    internal void ClipTranslateMargins(RectangleF clipBounds);
    internal void InitializeCoordinates();
    internal void InitializeCoordinates(PdfPageBase page);
    private void FlipHorizontal();
    private void FlipVertical();
    private PdfTransformationMatrix GetTranslateTransform(float x, float y, PdfTransformationMatrix input);
    private PdfTransformationMatrix GetScaleTransform(float x, float y, PdfTransformationMatrix input);
    private PdfTransformationMatrix GetRotateTransform(float angle, PdfTransformationMatrix input);
    private PdfTransformationMatrix GetSkewTransform(float angleX, float angleY, PdfTransformationMatrix input);
    private void DrawCjkString(LineInfo lineInfo, RectangleF layoutRectangle, PdfFont font, PdfStringFormat format);
    private Byte[] GetCjkString(string line);
    private void DrawAsciiLine(LineInfo lineInfo, RectangleF layoutRectangle, PdfFont font, PdfStringFormat format);
    private PdfString GetAsciiString(string token);
    private Byte[] GetMacRomanEncodedByte(string token);
    private string CheckFontEncoding(PdfDictionary fontDictionary);
    private void DrawUnicodeLine(LineInfo lineInfo, RectangleF layoutRectangle, PdfFont font, PdfStringFormat format);
    private void DrawOpenTypeString(OtfGlyphInfoList glyphInfoList, PdfTrueTypeFont ttfFont);
    private void DrawOpenTypeString(OtfGlyphInfo[] glyphs, PdfTrueTypeFont ttfFont, PdfStringFormat format, float spaceWidth, Boolean& skipNextLine);
    private void DrawOpenTypeStringUnicodeBlocks(OtfGlyphInfoList glyphInfoList, PdfTrueTypeFont ttfFont, PdfStringFormat format, float spaceWidth);
    private float GetSubrangeYDelta(List`1<OtfGlyphInfo> glyphInfos, int from, int to, PdfTrueTypeFont font);
    private float GetSubrangeWidth(int from, int to, PdfStringFormat stringFormat, PdfTrueTypeFont font, List`1<OtfGlyphInfo> glyphInfos);
    private float GetWordSpacingAddition(OtfGlyphInfo glyph, PdfTrueTypeFont typeFont, PdfStringFormat stringFormat);
    private void DrawOpenTypeStringBlocks(OtfGlyphInfoList glyphInfoList, PdfTrueTypeFont ttfFont, PdfStringFormat format, float spaceWidth);
    private void DrawOpenTypeStringBlocks(OtfGlyphInfo[][] blocks, PdfTrueTypeFont ttfFont, PdfStringFormat format, float wordSpacing, OtfGlyphTokenizer tokenizer);
    private PdfString GetUnicodeString(string token);
    private String[] BreakUnicodeLine(string line, PdfTrueTypeFont ttfFont, String[]& words, PdfStringFormat format);
    private string ConvertToUnicode(string text, PdfTrueTypeFont ttfFont, PdfStringFormat format);
    private void DrawUnicodeBlocks(String[] blocks, String[] words, PdfFont font, PdfStringFormat format, float wordSpacing);
    private String[] GetTextLines(string text);
    private void ApplyStringSettings(PdfFont font, PdfPen pen, PdfBrush brush, PdfStringFormat format, RectangleF bounds);
    private float GetHorizontalAlignShift(float lineWidth, float boundsWidth, PdfStringFormat format);
    internal float GetTextVerticalAlignShift(float textHeight, float boundsHeight, PdfStringFormat format);
    private float JustifyLine(LineInfo lineInfo, float boundsWidth, PdfStringFormat format);
    private bool ShouldJustify(LineInfo lineInfo, float boundsWidth, PdfStringFormat format);
    private bool CheckCorrectLayoutRectangle(RectangleF& layoutRectangle);
    internal RectangleF CheckCorrectLayoutRectangle(SizeF textSize, float x, float y, PdfStringFormat format);
    private void UnderlineStrikeoutText(PdfPen pen, PdfBrush brush, PdfStringLayoutResult result, PdfFont font, RectangleF layoutRectangle, PdfStringFormat format);
    private PdfPen CreateUnderlineStikeoutPen(PdfPen pen, PdfBrush brush, PdfFont font, PdfStringFormat format);
    private void DrawLayoutResult(PdfStringLayoutResult result, PdfFont font, PdfStringFormat format, RectangleF layoutRectangle);
    private void DrawAsciiLine(LineInfo lineInfo, RectangleF layoutRectangle, PdfFont font, PdfStringFormat format, bool embed);
    internal void DrawStringLayoutResult(PdfStringLayoutResult result, PdfFont font, PdfPen pen, PdfBrush brush, RectangleF layoutRectangle, PdfStringFormat format, double maxRowFontSize, PdfFont maxPdfFont, PdfStringFormat maxPdfFormat);
    internal void DrawStringLayoutResult(PdfStringLayoutResult result, PdfFont font, PdfPen pen, PdfBrush brush, RectangleF layoutRectangle, PdfStringFormat format);
    private bool HasOtfGlyphList(PdfStringLayoutResult result);
    private float GetAscent(PdfFont pdfFont);
    private float GetLineIndent(LineInfo lineInfo, PdfStringFormat format, RectangleF layoutBounds, bool firstLine);
    private bool RightToLeft(PdfStringFormat format);
    internal RectangleF GetLineBounds(int lineIndex, PdfStringLayoutResult result, PdfFont font, RectangleF layoutRectangle, PdfStringFormat format);
    internal void SetBBox(RectangleF bounds);
    private string SetArtifact(PdfArtifact artifact);
    private string GetEdges(PdfAttached attached);
    protected void OnStructElementChanged(PdfTag tag);
    internal void ApplyTag(PdfTag tag);
    internal void DrawString(string text, PdfFont font, PdfBrush brush, RectangleF rect, PdfStringFormat format, bool directConversion);
    private bool IsContainFont(PdfTrueTypeFont font, string text, PdfStringFormat format);
    private bool IsOpenTypeFont(PdfStringFormat format, PdfTrueTypeFont font);
    private ScriptTags[] ObtainTags(string line);
    private float ScaleText(string text, PdfFont pdfFont, RectangleF rect, SizeF& textSize, PdfStringFormat format);
    internal void ResetClip();
    private PdfTransformationMatrix PrepareMatrix(Matrix matrix, float pageScale);
    internal void SetClip(RectangleF rect, CombineMode mode);
    private void OnDrawPrimitive();
    internal PdfStringFormat ConvertFormat(StringFormat format);
    internal PdfStringFormat ConvertFormat(StringFormat format, bool isComplexScript);
    private PdfVerticalAlignment ConvertLineAlignment(StringAlignment stringAlignment);
    private PdfWordWrapType GetWrapType(StringFormatFlags stringFormatFlags);
    private PdfTextAlignment ConvertAlingnmet(StringAlignment stringAlignment);
    private void TranslateTransform(float dx, float dy, MatrixOrder order);
    internal void RotateTransform(float angle, MatrixOrder order);
    private PdfGraphicsUnit GraphicsToPrintUnits(GraphicsUnit gUnits);
    private void InternalResetClip();
    private void SetTransform();
    internal void ResetTransform();
    private void SetClip();
    private void SetPdfClipPath();
    private void InternalResetTransformation();
    internal int DirectPDFSave();
    internal void Restore(int gState);
    internal void Clear(PdfColor color);
    internal void Clear();
    internal void SetTag(PdfTag element);
    internal void ReSetTag();
    internal PdfImage GetImage(Stream stream, PdfDocument document);
    internal int ObtainGraphicsRotation(PdfArray matrix);
    private PointF ModifyLocation(PdfArray matrix, SizeF size, PointF location);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public abstract class Syncfusion.Pdf.Graphics.PdfGraphicsElement : object {
    public void Draw(PdfGraphics graphics);
    public void Draw(PdfGraphics graphics, PointF location);
    public virtual void Draw(PdfGraphics graphics, float x, float y);
    protected abstract virtual void DrawInternal(PdfGraphics graphics);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class Syncfusion.Pdf.Graphics.PdfGraphicsState : object {
    private PdfGraphics m_graphics;
    private PdfTransformationMatrix m_matrix;
    private TextRenderingMode m_textRenderingMode;
    private float m_characterSpacing;
    private float m_wordSpacing;
    private float m_textScaling;
    private PdfPen m_pen;
    private PdfBrush m_brush;
    private PdfFont m_font;
    private PdfColorSpace m_colorSpace;
    internal PdfGraphics Graphics { get; }
    internal PdfTransformationMatrix Matrix { get; }
    internal float CharacterSpacing { get; internal set; }
    internal float WordSpacing { get; internal set; }
    internal float TextScaling { get; internal set; }
    internal PdfPen Pen { get; internal set; }
    internal PdfBrush Brush { get; internal set; }
    internal PdfFont Font { get; internal set; }
    internal PdfColorSpace ColorSpace { get; internal set; }
    internal TextRenderingMode TextRenderingMode { get; internal set; }
    internal PdfGraphicsState(PdfGraphics graphics, PdfTransformationMatrix matrix);
    internal PdfGraphics get_Graphics();
    internal PdfTransformationMatrix get_Matrix();
    internal float get_CharacterSpacing();
    internal void set_CharacterSpacing(float value);
    internal float get_WordSpacing();
    internal void set_WordSpacing(float value);
    internal float get_TextScaling();
    internal void set_TextScaling(float value);
    internal PdfPen get_Pen();
    internal void set_Pen(PdfPen value);
    internal PdfBrush get_Brush();
    internal void set_Brush(PdfBrush value);
    internal PdfFont get_Font();
    internal void set_Font(PdfFont value);
    internal PdfColorSpace get_ColorSpace();
    internal void set_ColorSpace(PdfColorSpace value);
    internal TextRenderingMode get_TextRenderingMode();
    internal void set_TextRenderingMode(TextRenderingMode value);
}
public enum Syncfusion.Pdf.Graphics.PdfGraphicsUnit : Enum {
    public int value__;
    public static PdfGraphicsUnit Centimeter;
    public static PdfGraphicsUnit Pica;
    public static PdfGraphicsUnit Pixel;
    public static PdfGraphicsUnit Point;
    public static PdfGraphicsUnit Inch;
    public static PdfGraphicsUnit Document;
    public static PdfGraphicsUnit Millimeter;
}
public enum Syncfusion.Pdf.Graphics.PdfGridImagePosition : Enum {
    public int value__;
    public static PdfGridImagePosition Fit;
    public static PdfGridImagePosition Center;
    public static PdfGridImagePosition Stretch;
    public static PdfGridImagePosition Tile;
}
internal enum Syncfusion.Pdf.Graphics.PdfGridStretchOption : Enum {
    public int value__;
    public static PdfGridStretchOption Fill;
    public static PdfGridStretchOption Uniform;
    public static PdfGridStretchOption UniformToFill;
    public static PdfGridStretchOption None;
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Syncfusion.Pdf.Graphics.PdfHatchBrush : PdfTilingBrush {
    private PdfHatchStyle m_hatchStyle;
    private PdfColor m_foreColor;
    private PdfColor m_backColor;
    internal PdfColor BackColor { get; }
    public PdfHatchBrush(PdfHatchStyle hatchstyle, PdfColor foreColor);
    public PdfHatchBrush(PdfHatchStyle hatchstyle, PdfColor foreColor, PdfColor backColor);
    internal PdfColor get_BackColor();
    private void CreateHatchBrush();
    private static void DrawCross(PdfGraphics graphics, PdfPen pen, SizeF brushSize);
    private static void DrawBackwardDiagonal(PdfGraphics graphics, PdfPen pen, SizeF brushSize);
    private static void DrawForwardDiagonal(PdfGraphics graphics, PdfPen pen, SizeF brushSize);
    private static void DrawHorizontal(PdfGraphics graphics, PdfPen pen, SizeF brushSize);
    private static void DrawVertical(PdfGraphics graphics, PdfPen pen, SizeF brushSize);
    private static void DrawDownwardDiagonal(PdfGraphics graphics, PdfPen pen, SizeF brushSize);
    private void DrawWeave(PdfGraphics g, PdfPen pen, SizeF brushSize);
    private static void DrawUpwardDiagonal(PdfGraphics graphics, PdfPen pen, SizeF brushSize);
    private static void DrawBrickTails(PdfGraphics graphics, PdfPen pen, SizeF brushSize);
    private static void DrawHorizontalBrick(PdfGraphics graphics, PdfPen pen, SizeF brushSize);
    private static void DrawCheckerBoard(PdfGraphics graphics, PdfPen pen, SizeF brushSize, int cellSize);
}
internal enum Syncfusion.Pdf.Graphics.PdfHatchStyle : Enum {
    public int value__;
    public static PdfHatchStyle Horizontal;
    public static PdfHatchStyle Min;
    public static PdfHatchStyle Vertical;
    public static PdfHatchStyle ForwardDiagonal;
    public static PdfHatchStyle BackwardDiagonal;
    public static PdfHatchStyle Cross;
    public static PdfHatchStyle LargeGrid;
    public static PdfHatchStyle Max;
    public static PdfHatchStyle DiagonalCross;
    public static PdfHatchStyle Percent05;
    public static PdfHatchStyle Percent10;
    public static PdfHatchStyle Percent20;
    public static PdfHatchStyle Percent25;
    public static PdfHatchStyle Percent30;
    public static PdfHatchStyle Percent40;
    public static PdfHatchStyle Percent50;
    public static PdfHatchStyle Percent60;
    public static PdfHatchStyle Percent70;
    public static PdfHatchStyle Percent75;
    public static PdfHatchStyle Percent80;
    public static PdfHatchStyle Percent90;
    public static PdfHatchStyle LightDownwardDiagonal;
    public static PdfHatchStyle LightUpwardDiagonal;
    public static PdfHatchStyle DarkDownwardDiagonal;
    public static PdfHatchStyle DarkUpwardDiagonal;
    public static PdfHatchStyle WideDownwardDiagonal;
    public static PdfHatchStyle WideUpwardDiagonal;
    public static PdfHatchStyle LightVertical;
    public static PdfHatchStyle LightHorizontal;
    public static PdfHatchStyle NarrowVertical;
    public static PdfHatchStyle NarrowHorizontal;
    public static PdfHatchStyle DarkVertical;
    public static PdfHatchStyle DarkHorizontal;
    public static PdfHatchStyle DashedDownwardDiagonal;
    public static PdfHatchStyle DashedUpwardDiagonal;
    public static PdfHatchStyle DashedHorizontal;
    public static PdfHatchStyle DashedVertical;
    public static PdfHatchStyle SmallConfetti;
    public static PdfHatchStyle LargeConfetti;
    public static PdfHatchStyle ZigZag;
    public static PdfHatchStyle Wave;
    public static PdfHatchStyle DiagonalBrick;
    public static PdfHatchStyle HorizontalBrick;
    public static PdfHatchStyle Weave;
    public static PdfHatchStyle Plaid;
    public static PdfHatchStyle Divot;
    public static PdfHatchStyle DottedGrid;
    public static PdfHatchStyle DottedDiamond;
    public static PdfHatchStyle Shingle;
    public static PdfHatchStyle Trellis;
    public static PdfHatchStyle Sphere;
    public static PdfHatchStyle SmallGrid;
    public static PdfHatchStyle SmallCheckerBoard;
    public static PdfHatchStyle LargeCheckerBoard;
    public static PdfHatchStyle OutlinedDiamond;
    public static PdfHatchStyle SolidDiamond;
}
public enum Syncfusion.Pdf.Graphics.PdfHorizontalAlignment : Enum {
    public int value__;
    public static PdfHorizontalAlignment Left;
    public static PdfHorizontalAlignment Center;
    public static PdfHorizontalAlignment Right;
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class Syncfusion.Pdf.Graphics.PdfHTMLTextElement : object {
    private PdfFont m_font;
    private PdfBrush m_brush;
    private string m_htmlText;
    private TextAlign m_textAlign;
    internal bool m_nativeRendering;
    internal bool m_isPdfGrid;
    internal RectangleF shapeBounds;
    internal float m_bottomCellpadding;
    private float m_height;
    private int m_htmlElementFont;
    private Color m_Color;
    private float m_htmlFontHeight;
    private float m_htmlFontElementHeight;
    private string m_stringFontName;
    private PdfFont m_currentFont;
    internal List`1<Htmltext> m_htmllist;
    private float xPosition;
    private float yPosition;
    private PdfBrush m_Htmlbrush;
    private PdfFontStyle m_style;
    private PdfFontStyle m_style1;
    private PdfFontFamily m_fontFace;
    private float m_initalXvalue;
    private float m_maxHeight;
    private bool m_fontAttribute;
    private float m_paginateHeight;
    [CompilerGeneratedAttribute]
private EndPageLayoutEventHandler EndPageLayout;
    [CompilerGeneratedAttribute]
private BeginPageLayoutEventHandler BeginPageLayout;
    public PdfFont Font { get; public set; }
    public PdfBrush Brush { get; public set; }
    internal float Height { get; }
    public string HTMLText { get; public set; }
    public TextAlign TextAlign { get; public set; }
    internal bool RaiseEndPageLayout { get; }
    internal bool RaiseBeginPageLayout { get; }
    public PdfHTMLTextElement(string htmlText, PdfFont font, PdfBrush brush);
    public PdfFont get_Font();
    public void set_Font(PdfFont value);
    public PdfBrush get_Brush();
    public void set_Brush(PdfBrush value);
    internal float get_Height();
    public string get_HTMLText();
    public void set_HTMLText(string value);
    public TextAlign get_TextAlign();
    public void set_TextAlign(TextAlign value);
    public void Draw(PdfGraphics graphics, RectangleF layoutRectangle);
    public void Draw(PdfGraphics graphics, PointF location, float width, float height);
    public PdfLayoutResult Draw(PdfPage page, PointF location, float width, float height, PdfLayoutFormat format);
    public PdfLayoutResult Draw(PdfPage page, PointF location, float width, PdfLayoutFormat format);
    public PdfLayoutResult Draw(PdfPage page, RectangleF layoutRectangle, PdfLayoutFormat format);
    internal void ParseHtml(string text);
    private void ParseElements(XElement parent);
    private void Pickstyle(string chos);
    private int GetColorRgb(Color color);
    private int GetCOLORREF(int r, int g, int b);
    private void img_EndPageLayout(object sender, EndPageLayoutEventArgs e);
    private void img_BeginPageLayout(object sender, BeginPageLayoutEventArgs e);
    internal bool get_RaiseEndPageLayout();
    internal bool get_RaiseBeginPageLayout();
    [CompilerGeneratedAttribute]
public void add_EndPageLayout(EndPageLayoutEventHandler value);
    [CompilerGeneratedAttribute]
public void remove_EndPageLayout(EndPageLayoutEventHandler value);
    [CompilerGeneratedAttribute]
public void add_BeginPageLayout(BeginPageLayoutEventHandler value);
    [CompilerGeneratedAttribute]
public void remove_BeginPageLayout(BeginPageLayoutEventHandler value);
    internal void OnEndPageLayout(EndPageLayoutEventArgs e);
    internal void OnBeginPageLayout(BeginPageLayoutEventArgs e);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public abstract class Syncfusion.Pdf.Graphics.PdfImage : PdfShapeElement {
    [CompilerGeneratedAttribute]
private int <Height>k__BackingField;
    [CompilerGeneratedAttribute]
private int <Width>k__BackingField;
    [CompilerGeneratedAttribute]
private float <HorizontalResolution>k__BackingField;
    [CompilerGeneratedAttribute]
private float <VerticalResolution>k__BackingField;
    [CompilerGeneratedAttribute]
private float <JpegOrientationAngle>k__BackingField;
    [CompilerGeneratedAttribute]
private PdfStream <ImageStream>k__BackingField;
    private float m_scrollBarWidth;
    private float m_scrollBarHeight;
    private XmpMetadata m_imageMetadata;
    private bool m_enableMetadata;
    public int Height { get; internal set; }
    public int Width { get; internal set; }
    public float HorizontalResolution { get; internal set; }
    public float VerticalResolution { get; internal set; }
    public SizeF PhysicalDimension { get; }
    internal float JpegOrientationAngle { get; internal set; }
    internal PdfStream ImageStream { get; internal set; }
    internal bool EnableMetada { get; internal set; }
    internal float ScrollBarWidth { get; internal set; }
    internal float ScrollBarHeight { get; internal set; }
    private IPdfPrimitive Syncfusion.Pdf.IPdfWrapper.Element { get; }
    public XmpMetadata Metadata { get; public set; }
    [CompilerGeneratedAttribute]
public virtual int get_Height();
    [CompilerGeneratedAttribute]
internal virtual void set_Height(int value);
    [CompilerGeneratedAttribute]
public virtual int get_Width();
    [CompilerGeneratedAttribute]
internal virtual void set_Width(int value);
    [CompilerGeneratedAttribute]
public virtual float get_HorizontalResolution();
    [CompilerGeneratedAttribute]
internal virtual void set_HorizontalResolution(float value);
    [CompilerGeneratedAttribute]
public virtual float get_VerticalResolution();
    [CompilerGeneratedAttribute]
internal virtual void set_VerticalResolution(float value);
    public virtual SizeF get_PhysicalDimension();
    [CompilerGeneratedAttribute]
internal float get_JpegOrientationAngle();
    [CompilerGeneratedAttribute]
internal void set_JpegOrientationAngle(float value);
    [CompilerGeneratedAttribute]
internal PdfStream get_ImageStream();
    [CompilerGeneratedAttribute]
internal void set_ImageStream(PdfStream value);
    internal bool get_EnableMetada();
    internal void set_EnableMetada(bool value);
    internal float get_ScrollBarWidth();
    internal void set_ScrollBarWidth(float value);
    internal float get_ScrollBarHeight();
    internal void set_ScrollBarHeight(float value);
    public static PdfImage FromStream(Stream stream);
    private sealed virtual override IPdfPrimitive Syncfusion.Pdf.IPdfWrapper.get_Element();
    public XmpMetadata get_Metadata();
    public void set_Metadata(XmpMetadata value);
    internal abstract virtual XmpMetadata GetMetadata();
    internal void AddMetadata();
    internal static Stream CheckStreamExistance(Stream stream);
    protected static SizeF GetPixelSize(float width, float height);
    internal abstract virtual void Save();
    internal void SetContent(IPdfPrimitive content);
    protected virtual void DrawInternal(PdfGraphics graphics);
    protected virtual RectangleF GetBoundsInternal();
    protected internal SizeF GetPointSize(float width, float height);
    protected internal SizeF GetPointSize(float width, float height, float horizontalResolution, float verticalResolution);
    protected void SetResolution(float horizontalResolution, float verticalResolution);
    internal abstract virtual PdfImage Clone();
}
public enum Syncfusion.Pdf.Graphics.PdfImageType : Enum {
    public int value__;
    public static PdfImageType Bitmap;
    public static PdfImageType Metafile;
}
public enum Syncfusion.Pdf.Graphics.PdfLayoutBreakType : Enum {
    public int value__;
    public static PdfLayoutBreakType FitPage;
    public static PdfLayoutBreakType FitElement;
    public static PdfLayoutBreakType FitColumnsToPage;
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public abstract class Syncfusion.Pdf.Graphics.PdfLayoutElement : PdfGraphicsElement {
    private bool m_bEmbedFonts;
    private PdfTag m_tag;
    [CompilerGeneratedAttribute]
private EndPageLayoutEventHandler EndPageLayout;
    [CompilerGeneratedAttribute]
private BeginPageLayoutEventHandler BeginPageLayout;
    internal bool RaiseEndPageLayout { get; }
    internal bool RaiseBeginPageLayout { get; }
    internal bool EmbedFontResource { get; }
    public PdfTag PdfTag { get; public set; }
    [CompilerGeneratedAttribute]
public void add_EndPageLayout(EndPageLayoutEventHandler value);
    [CompilerGeneratedAttribute]
public void remove_EndPageLayout(EndPageLayoutEventHandler value);
    [CompilerGeneratedAttribute]
public void add_BeginPageLayout(BeginPageLayoutEventHandler value);
    [CompilerGeneratedAttribute]
public void remove_BeginPageLayout(BeginPageLayoutEventHandler value);
    internal bool get_RaiseEndPageLayout();
    internal bool get_RaiseBeginPageLayout();
    internal bool get_EmbedFontResource();
    public PdfTag get_PdfTag();
    public void set_PdfTag(PdfTag value);
    public PdfLayoutResult Draw(PdfPage page, PointF location);
    public PdfLayoutResult Draw(PdfPage page, float x, float y);
    public PdfLayoutResult Draw(PdfPage page, RectangleF layoutRectangle);
    internal PdfLayoutResult Draw(PdfPage page, RectangleF layoutRectangle, bool embedFonts);
    public PdfLayoutResult Draw(PdfPage page, PointF location, PdfLayoutFormat format);
    public PdfLayoutResult Draw(PdfPage page, float x, float y, PdfLayoutFormat format);
    public PdfLayoutResult Draw(PdfPage page, RectangleF layoutRectangle, PdfLayoutFormat format);
    internal virtual PdfLayoutResult Layout(HtmlToPdfParams param);
    internal PdfLayoutResult Draw(PdfPage page, HtmlToPdfFormat format, RectangleF layoutRectangle);
    internal PdfLayoutResult Draw(PdfPage page, RectangleF bounds, Single[] pageOffsets, PdfLayoutFormat format);
    protected abstract virtual PdfLayoutResult Layout(PdfLayoutParams param);
    protected virtual PdfLayoutResult Layout(HtmlToPdfLayoutParams param);
    internal void OnEndPageLayout(EndPageLayoutEventArgs e);
    internal void OnBeginPageLayout(BeginPageLayoutEventArgs e);
}
public class Syncfusion.Pdf.Graphics.PdfLayoutFormat : object {
    private bool m_boundsSet;
    private RectangleF m_paginateBounds;
    private PdfLayoutType m_layout;
    private PdfLayoutBreakType m_break;
    public PdfLayoutType Layout { get; public set; }
    public PdfLayoutBreakType Break { get; public set; }
    public RectangleF PaginateBounds { get; public set; }
    internal bool UsePaginateBounds { get; }
    [NullableContextAttribute("1")]
public PdfLayoutFormat(PdfLayoutFormat baseFormat);
    public PdfLayoutType get_Layout();
    public void set_Layout(PdfLayoutType value);
    public PdfLayoutBreakType get_Break();
    public void set_Break(PdfLayoutBreakType value);
    public RectangleF get_PaginateBounds();
    public void set_PaginateBounds(RectangleF value);
    internal bool get_UsePaginateBounds();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class Syncfusion.Pdf.Graphics.PdfLayoutParams : object {
    private PdfPage m_page;
    private RectangleF m_bounds;
    private PdfLayoutFormat m_format;
    internal PdfGraphics m_graphics;
    public PdfPage Page { get; public set; }
    public RectangleF Bounds { get; public set; }
    public PdfLayoutFormat Format { get; public set; }
    public PdfPage get_Page();
    public void set_Page(PdfPage value);
    public RectangleF get_Bounds();
    public void set_Bounds(RectangleF value);
    public PdfLayoutFormat get_Format();
    public void set_Format(PdfLayoutFormat value);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class Syncfusion.Pdf.Graphics.PdfLayoutResult : object {
    private PdfPage m_page;
    private RectangleF m_bounds;
    private double m_totalPageSize;
    public PdfPage Page { get; }
    public RectangleF Bounds { get; }
    internal double TotalPageSize { get; internal set; }
    public PdfLayoutResult(PdfPage page, RectangleF bounds);
    public PdfPage get_Page();
    public RectangleF get_Bounds();
    internal double get_TotalPageSize();
    internal void set_TotalPageSize(double value);
}
public enum Syncfusion.Pdf.Graphics.PdfLayoutType : Enum {
    public int value__;
    public static PdfLayoutType Paginate;
    public static PdfLayoutType OnePage;
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class Syncfusion.Pdf.Graphics.PdfLine : PdfDrawElement {
    private float m_x1;
    private float m_y1;
    private float m_x2;
    private float m_y2;
    public float X1 { get; public set; }
    public float Y1 { get; public set; }
    public float X2 { get; public set; }
    public float Y2 { get; public set; }
    public PdfLine(float x1, float y1, float x2, float y2);
    public PdfLine(PointF point1, PointF point2);
    public PdfLine(PdfPen pen, float x1, float y1, float x2, float y2);
    public PdfLine(PdfPen pen, PointF point1, PointF point2);
    public float get_X1();
    public void set_X1(float value);
    public float get_Y1();
    public void set_Y1(float value);
    public float get_X2();
    public void set_X2(float value);
    public float get_Y2();
    public void set_Y2(float value);
    protected virtual RectangleF GetBoundsInternal();
    protected virtual void DrawInternal(PdfGraphics graphics);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class Syncfusion.Pdf.Graphics.PdfLinearGradientBrush : PdfGradientBrush {
    private PointF m_pointStart;
    private PointF m_pointEnd;
    private PdfColor[] m_colours;
    private PdfColorBlend m_colourBlend;
    private PdfBlend m_blend;
    private RectangleF m_boundaries;
    public PdfBlend Blend { get; public set; }
    public PdfColorBlend InterpolationColors { get; public set; }
    public PdfColor[] LinearColors { get; public set; }
    public RectangleF Rectangle { get; }
    public PdfExtend Extend { get; public set; }
    public PdfLinearGradientBrush(PointF point1, PointF point2, PdfColor color1, PdfColor color2);
    public PdfLinearGradientBrush(RectangleF rect, PdfColor color1, PdfColor color2, PdfLinearGradientMode mode);
    public PdfLinearGradientBrush(RectangleF rect, PdfColor color1, PdfColor color2, float angle);
    private PdfLinearGradientBrush(PdfColor color1, PdfColor color2);
    public PdfBlend get_Blend();
    public void set_Blend(PdfBlend value);
    public PdfColorBlend get_InterpolationColors();
    public void set_InterpolationColors(PdfColorBlend value);
    public PdfColor[] get_LinearColors();
    public void set_LinearColors(PdfColor[] value);
    public RectangleF get_Rectangle();
    public PdfExtend get_Extend();
    public void set_Extend(PdfExtend value);
    private static PointF AddPoints(PointF point1, PointF point2);
    private static PointF SubPoints(PointF point1, PointF point2);
    private static float MulPoints(PointF point1, PointF point2);
    private static PointF MulPoint(PointF point, float value);
    private PointF ChoosePoint(float angle);
    private void SetPoints(PointF point1, PointF point2);
    private void InitShading();
    public virtual PdfBrush Clone();
    internal virtual void ResetFunction();
}
public enum Syncfusion.Pdf.Graphics.PdfLinearGradientMode : Enum {
    public int value__;
    public static PdfLinearGradientMode BackwardDiagonal;
    public static PdfLinearGradientMode ForwardDiagonal;
    public static PdfLinearGradientMode Horizontal;
    public static PdfLinearGradientMode Vertical;
}
public enum Syncfusion.Pdf.Graphics.PdfLineCap : Enum {
    public int value__;
    public static PdfLineCap Flat;
    public static PdfLineCap Round;
    public static PdfLineCap Square;
}
public enum Syncfusion.Pdf.Graphics.PdfLineJoin : Enum {
    public int value__;
    public static PdfLineJoin Miter;
    public static PdfLineJoin Round;
    public static PdfLineJoin Bevel;
}
public class Syncfusion.Pdf.Graphics.PdfMargins : object {
    private static float PageMargin;
    private float m_left;
    private float m_top;
    private float m_right;
    private float m_bottom;
    public float Left { get; public set; }
    public float Top { get; public set; }
    public float Right { get; public set; }
    public float Bottom { get; public set; }
    unknown float All {public set; }
    public float get_Left();
    public void set_Left(float value);
    public float get_Top();
    public void set_Top(float value);
    public float get_Right();
    public void set_Right(float value);
    public float get_Bottom();
    public void set_Bottom(float value);
    public void set_All(float value);
    internal void SetMargins(float margin);
    internal void SetMargins(float leftRight, float topBottom);
    internal void SetMargins(float left, float top, float right, float bottom);
    [NullableContextAttribute("1")]
public sealed virtual object Clone();
}
public abstract class Syncfusion.Pdf.Graphics.PdfMask : object {
}
internal class Syncfusion.Pdf.Graphics.PdfMetafileLayoutFormat : PdfLayoutFormat {
    private bool m_splitLines;
    private bool m_useImageResolution;
    private bool m_splitImages;
    private bool m_htmlPageBreak;
    internal bool m_enableDirectLayout;
    public bool SplitTextLines { get; public set; }
    public bool UseImageResolution { get; public set; }
    public bool SplitImages { get; public set; }
    public bool IsHTMLPageBreak { get; public set; }
    public bool get_SplitTextLines();
    public void set_SplitTextLines(bool value);
    public bool get_UseImageResolution();
    public void set_UseImageResolution(bool value);
    public bool get_SplitImages();
    public void set_SplitImages(bool value);
    public bool get_IsHTMLPageBreak();
    public void set_IsHTMLPageBreak(bool value);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class Syncfusion.Pdf.Graphics.PdfPath : PdfFillElement {
    private List`1<PointF> m_points;
    private List`1<byte> m_pathTypes;
    private bool m_bStartFigure;
    private PdfFillMode m_fillMode;
    private bool isBeziers3;
    internal bool isXps;
    public PdfFillMode FillMode { get; public set; }
    public PointF[] PathPoints { get; }
    public Byte[] PathTypes { get; }
    public int PointCount { get; }
    public PointF LastPoint { get; }
    internal List`1<PointF> Points { get; }
    internal List`1<byte> Types { get; }
    public PdfPath(PointF[] points, Byte[] pathTypes);
    public PdfPath(PdfPen pen);
    public PdfPath(PdfBrush brush);
    public PdfPath(PdfBrush brush, PdfFillMode fillMode);
    public PdfPath(PdfPen pen, PointF[] points, Byte[] pathTypes);
    public PdfPath(PdfBrush brush, PdfFillMode fillMode, PointF[] points, Byte[] pathTypes);
    public PdfPath(PdfPen pen, PdfBrush brush, PdfFillMode fillMode);
    internal PdfPath(PdfFillMode fillMode);
    public PdfFillMode get_FillMode();
    public void set_FillMode(PdfFillMode value);
    public PointF[] get_PathPoints();
    public Byte[] get_PathTypes();
    public int get_PointCount();
    public PointF get_LastPoint();
    internal List`1<PointF> get_Points();
    internal List`1<byte> get_Types();
    public void AddArc(RectangleF rectangle, float startAngle, float sweepAngle);
    public void AddArc(float x, float y, float width, float height, float startAngle, float sweepAngle);
    public void AddBezier(PointF startPoint, PointF firstControlPoint, PointF secondControlPoint, PointF endPoint);
    public void AddBezier(float startPointX, float startPointY, float firstControlPointX, float firstControlPointY, float secondControlPointX, float secondControlPointY, float endPointX, float endPointY);
    internal void AddBeziers(List`1<PointF> points);
    public void AddEllipse(RectangleF rectangle);
    public void AddEllipse(float x, float y, float width, float height);
    public void AddLine(PointF point1, PointF point2);
    public void AddLine(float x1, float y1, float x2, float y2);
    public void AddPath(PdfPath path);
    public void AddPath(PointF[] pathPoints, Byte[] pathTypes);
    public void AddPie(RectangleF rectangle, float startAngle, float sweepAngle);
    public void AddPie(float x, float y, float width, float height, float startAngle, float sweepAngle);
    public void AddPolygon(PointF[] points);
    public void AddRectangle(RectangleF rectangle);
    public void AddRectangle(float x, float y, float width, float height);
    public void StartFigure();
    public void CloseFigure();
    public void CloseAllFigures();
    public PointF GetLastPoint();
    internal void AddLines(PointF[] linePoints);
    internal void Scale(float scaleX, float scaleY);
    internal void AddBeziers(PointF[] points);
    protected virtual RectangleF GetBoundsInternal();
    protected virtual void DrawInternal(PdfGraphics graphics);
    private void AddPoints(List`1<float> points, PathPointType pointType);
    private void AddPoints(List`1<float> points, PathPointType pointType, int startIndex, int endIndex);
    private void AddPoint(PointF point, PathPointType pointType);
    private void CloseFigure(int index);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class Syncfusion.Pdf.Graphics.PdfPen : object {
    private PdfColor m_color;
    private float m_dashOffset;
    private Single[] m_dashPattern;
    private PdfDashStyle m_dashStyle;
    private PdfLineCap m_lineCap;
    private PdfLineJoin m_lineJoin;
    private float m_width;
    private PdfBrush m_brush;
    private float m_miterLimit;
    private PdfColorSpace m_colorSpace;
    private PdfExtendedColor m_colorspaces;
    private bool m_bImmutable;
    private Single[] m_comoundArray;
    private PdfLineCap m_StartCap;
    private PdfLineCap m_EndCap;
    internal bool isSkipPatternWidth;
    internal PdfExtendedColor Colorspaces { get; internal set; }
    public PdfBrush Brush { get; public set; }
    public PdfColor Color { get; public set; }
    public float DashOffset { get; public set; }
    public Single[] DashPattern { get; public set; }
    public PdfDashStyle DashStyle { get; public set; }
    public PdfLineCap LineCap { get; public set; }
    public PdfLineJoin LineJoin { get; public set; }
    public float Width { get; public set; }
    public float MiterLimit { get; public set; }
    internal bool IsImmutable { get; }
    internal Single[] CompoundArray { get; internal set; }
    internal PdfLineCap StartCap { get; internal set; }
    internal PdfLineCap EndCap { get; internal set; }
    public PdfPen(PdfColor color);
    public PdfPen(Color color);
    public PdfPen(PdfColor color, float width);
    public PdfPen(Color color, float width);
    public PdfPen(PdfBrush brush);
    public PdfPen(PdfBrush brush, float width);
    internal PdfPen(PdfColor color, bool immutable);
    public PdfPen(PdfExtendedColor color);
    internal PdfExtendedColor get_Colorspaces();
    internal void set_Colorspaces(PdfExtendedColor value);
    public PdfBrush get_Brush();
    public void set_Brush(PdfBrush value);
    public PdfColor get_Color();
    public void set_Color(PdfColor value);
    public float get_DashOffset();
    public void set_DashOffset(float value);
    public Single[] get_DashPattern();
    public void set_DashPattern(Single[] value);
    public PdfDashStyle get_DashStyle();
    public void set_DashStyle(PdfDashStyle value);
    public PdfLineCap get_LineCap();
    public void set_LineCap(PdfLineCap value);
    public PdfLineJoin get_LineJoin();
    public void set_LineJoin(PdfLineJoin value);
    public float get_Width();
    public void set_Width(float value);
    public float get_MiterLimit();
    public void set_MiterLimit(float value);
    internal bool get_IsImmutable();
    internal Single[] get_CompoundArray();
    internal void set_CompoundArray(Single[] value);
    internal PdfLineCap get_StartCap();
    internal void set_StartCap(PdfLineCap value);
    internal PdfLineCap get_EndCap();
    internal void set_EndCap(PdfLineCap value);
    private sealed virtual override object Syncfusion.Pdf.ICloneable.Clone();
    public PdfPen Clone();
    private void AssignBrush(PdfBrush brush);
    private void SetStrokingToBrush(PdfBrush brush);
    private void ResetStroking(PdfBrush brush);
    internal bool MonitorChanges(PdfPen currentPen, PdfStreamWriter streamWriter, GetResources getResources, bool saveState, PdfColorSpace currentColorSpace, PdfTransformationMatrix matrix);
    internal bool MonitorChanges(PdfPen currentPen, PdfStreamWriter streamWriter, GetResources getResources, bool saveState, PdfColorSpace currentColorSpace, PdfTransformationMatrix matrix, bool iccBased);
    internal Single[] GetPattern();
    private bool DashControl(PdfPen pen, bool saveState, PdfStreamWriter streamWriter);
    private void CheckImmutability(string propertyName);
    private void CreateCompoundPen();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class Syncfusion.Pdf.Graphics.PdfPens : object {
    private static Dictionary`2<object, object> s_pens;
    public static PdfPen AliceBlue { get; }
    public static PdfPen AntiqueWhite { get; }
    public static PdfPen Aqua { get; }
    public static PdfPen Aquamarine { get; }
    public static PdfPen Azure { get; }
    public static PdfPen Beige { get; }
    public static PdfPen Bisque { get; }
    public static PdfPen Black { get; }
    public static PdfPen BlanchedAlmond { get; }
    public static PdfPen Blue { get; }
    public static PdfPen BlueViolet { get; }
    public static PdfPen Brown { get; }
    public static PdfPen BurlyWood { get; }
    public static PdfPen CadetBlue { get; }
    public static PdfPen Chartreuse { get; }
    public static PdfPen Chocolate { get; }
    public static PdfPen Coral { get; }
    public static PdfPen CornflowerBlue { get; }
    public static PdfPen Cornsilk { get; }
    public static PdfPen Crimson { get; }
    public static PdfPen Cyan { get; }
    public static PdfPen DarkBlue { get; }
    public static PdfPen DarkCyan { get; }
    public static PdfPen DarkGoldenrod { get; }
    public static PdfPen DarkGray { get; }
    public static PdfPen DarkGreen { get; }
    public static PdfPen DarkKhaki { get; }
    public static PdfPen DarkMagenta { get; }
    public static PdfPen DarkOliveGreen { get; }
    public static PdfPen DarkOrange { get; }
    public static PdfPen DarkOrchid { get; }
    public static PdfPen DarkRed { get; }
    public static PdfPen DarkSalmon { get; }
    public static PdfPen DarkSeaGreen { get; }
    public static PdfPen DarkSlateBlue { get; }
    public static PdfPen DarkSlateGray { get; }
    public static PdfPen DarkTurquoise { get; }
    public static PdfPen DarkViolet { get; }
    public static PdfPen DeepPink { get; }
    public static PdfPen DeepSkyBlue { get; }
    public static PdfPen DimGray { get; }
    public static PdfPen DodgerBlue { get; }
    public static PdfPen Firebrick { get; }
    public static PdfPen FloralWhite { get; }
    public static PdfPen ForestGreen { get; }
    public static PdfPen Fuchsia { get; }
    public static PdfPen Gainsboro { get; }
    public static PdfPen GhostWhite { get; }
    public static PdfPen Gold { get; }
    public static PdfPen Goldenrod { get; }
    public static PdfPen Gray { get; }
    public static PdfPen Green { get; }
    public static PdfPen GreenYellow { get; }
    public static PdfPen Honeydew { get; }
    public static PdfPen HotPink { get; }
    public static PdfPen IndianRed { get; }
    public static PdfPen Indigo { get; }
    public static PdfPen Ivory { get; }
    public static PdfPen Khaki { get; }
    public static PdfPen Lavender { get; }
    public static PdfPen LavenderBlush { get; }
    public static PdfPen LawnGreen { get; }
    public static PdfPen LemonChiffon { get; }
    public static PdfPen LightBlue { get; }
    public static PdfPen LightCoral { get; }
    public static PdfPen LightCyan { get; }
    public static PdfPen LightGoldenrodYellow { get; }
    public static PdfPen LightGray { get; }
    public static PdfPen LightGreen { get; }
    public static PdfPen LightPink { get; }
    public static PdfPen LightSalmon { get; }
    public static PdfPen LightSeaGreen { get; }
    public static PdfPen LightSkyBlue { get; }
    public static PdfPen LightSlateGray { get; }
    public static PdfPen LightSteelBlue { get; }
    public static PdfPen LightYellow { get; }
    public static PdfPen Lime { get; }
    public static PdfPen LimeGreen { get; }
    public static PdfPen Linen { get; }
    public static PdfPen Magenta { get; }
    public static PdfPen Maroon { get; }
    public static PdfPen MediumAquamarine { get; }
    public static PdfPen MediumBlue { get; }
    public static PdfPen MediumOrchid { get; }
    public static PdfPen MediumPurple { get; }
    public static PdfPen MediumSeaGreen { get; }
    public static PdfPen MediumSlateBlue { get; }
    public static PdfPen MediumSpringGreen { get; }
    public static PdfPen MediumTurquoise { get; }
    public static PdfPen MediumVioletRed { get; }
    public static PdfPen MidnightBlue { get; }
    public static PdfPen MintCream { get; }
    public static PdfPen MistyRose { get; }
    public static PdfPen Moccasin { get; }
    public static PdfPen NavajoWhite { get; }
    public static PdfPen Navy { get; }
    public static PdfPen OldLace { get; }
    public static PdfPen Olive { get; }
    public static PdfPen OliveDrab { get; }
    public static PdfPen Orange { get; }
    public static PdfPen OrangeRed { get; }
    public static PdfPen Orchid { get; }
    public static PdfPen PaleGoldenrod { get; }
    public static PdfPen PaleGreen { get; }
    public static PdfPen PaleTurquoise { get; }
    public static PdfPen PaleVioletRed { get; }
    public static PdfPen PapayaWhip { get; }
    public static PdfPen PeachPuff { get; }
    public static PdfPen Peru { get; }
    public static PdfPen Pink { get; }
    public static PdfPen Plum { get; }
    public static PdfPen PowderBlue { get; }
    public static PdfPen Purple { get; }
    public static PdfPen Red { get; }
    public static PdfPen RosyBrown { get; }
    public static PdfPen RoyalBlue { get; }
    public static PdfPen SaddleBrown { get; }
    public static PdfPen Salmon { get; }
    public static PdfPen SandyBrown { get; }
    public static PdfPen SeaGreen { get; }
    public static PdfPen SeaShell { get; }
    public static PdfPen Sienna { get; }
    public static PdfPen Silver { get; }
    public static PdfPen SkyBlue { get; }
    public static PdfPen SlateBlue { get; }
    public static PdfPen SlateGray { get; }
    public static PdfPen Snow { get; }
    public static PdfPen SpringGreen { get; }
    public static PdfPen SteelBlue { get; }
    public static PdfPen Tan { get; }
    public static PdfPen Teal { get; }
    public static PdfPen Thistle { get; }
    public static PdfPen Tomato { get; }
    public static PdfPen Transparent { get; }
    public static PdfPen Turquoise { get; }
    public static PdfPen Violet { get; }
    public static PdfPen Wheat { get; }
    public static PdfPen White { get; }
    public static PdfPen WhiteSmoke { get; }
    public static PdfPen Yellow { get; }
    public static PdfPen YellowGreen { get; }
    private static PdfPens();
    public static PdfPen get_AliceBlue();
    public static PdfPen get_AntiqueWhite();
    public static PdfPen get_Aqua();
    public static PdfPen get_Aquamarine();
    public static PdfPen get_Azure();
    public static PdfPen get_Beige();
    public static PdfPen get_Bisque();
    public static PdfPen get_Black();
    public static PdfPen get_BlanchedAlmond();
    public static PdfPen get_Blue();
    public static PdfPen get_BlueViolet();
    public static PdfPen get_Brown();
    public static PdfPen get_BurlyWood();
    public static PdfPen get_CadetBlue();
    public static PdfPen get_Chartreuse();
    public static PdfPen get_Chocolate();
    public static PdfPen get_Coral();
    public static PdfPen get_CornflowerBlue();
    public static PdfPen get_Cornsilk();
    public static PdfPen get_Crimson();
    public static PdfPen get_Cyan();
    public static PdfPen get_DarkBlue();
    public static PdfPen get_DarkCyan();
    public static PdfPen get_DarkGoldenrod();
    public static PdfPen get_DarkGray();
    public static PdfPen get_DarkGreen();
    public static PdfPen get_DarkKhaki();
    public static PdfPen get_DarkMagenta();
    public static PdfPen get_DarkOliveGreen();
    public static PdfPen get_DarkOrange();
    public static PdfPen get_DarkOrchid();
    public static PdfPen get_DarkRed();
    public static PdfPen get_DarkSalmon();
    public static PdfPen get_DarkSeaGreen();
    public static PdfPen get_DarkSlateBlue();
    public static PdfPen get_DarkSlateGray();
    public static PdfPen get_DarkTurquoise();
    public static PdfPen get_DarkViolet();
    public static PdfPen get_DeepPink();
    public static PdfPen get_DeepSkyBlue();
    public static PdfPen get_DimGray();
    public static PdfPen get_DodgerBlue();
    public static PdfPen get_Firebrick();
    public static PdfPen get_FloralWhite();
    public static PdfPen get_ForestGreen();
    public static PdfPen get_Fuchsia();
    public static PdfPen get_Gainsboro();
    public static PdfPen get_GhostWhite();
    public static PdfPen get_Gold();
    public static PdfPen get_Goldenrod();
    public static PdfPen get_Gray();
    public static PdfPen get_Green();
    public static PdfPen get_GreenYellow();
    public static PdfPen get_Honeydew();
    public static PdfPen get_HotPink();
    public static PdfPen get_IndianRed();
    public static PdfPen get_Indigo();
    public static PdfPen get_Ivory();
    public static PdfPen get_Khaki();
    public static PdfPen get_Lavender();
    public static PdfPen get_LavenderBlush();
    public static PdfPen get_LawnGreen();
    public static PdfPen get_LemonChiffon();
    public static PdfPen get_LightBlue();
    public static PdfPen get_LightCoral();
    public static PdfPen get_LightCyan();
    public static PdfPen get_LightGoldenrodYellow();
    public static PdfPen get_LightGray();
    public static PdfPen get_LightGreen();
    public static PdfPen get_LightPink();
    public static PdfPen get_LightSalmon();
    public static PdfPen get_LightSeaGreen();
    public static PdfPen get_LightSkyBlue();
    public static PdfPen get_LightSlateGray();
    public static PdfPen get_LightSteelBlue();
    public static PdfPen get_LightYellow();
    public static PdfPen get_Lime();
    public static PdfPen get_LimeGreen();
    public static PdfPen get_Linen();
    public static PdfPen get_Magenta();
    public static PdfPen get_Maroon();
    public static PdfPen get_MediumAquamarine();
    public static PdfPen get_MediumBlue();
    public static PdfPen get_MediumOrchid();
    public static PdfPen get_MediumPurple();
    public static PdfPen get_MediumSeaGreen();
    public static PdfPen get_MediumSlateBlue();
    public static PdfPen get_MediumSpringGreen();
    public static PdfPen get_MediumTurquoise();
    public static PdfPen get_MediumVioletRed();
    public static PdfPen get_MidnightBlue();
    public static PdfPen get_MintCream();
    public static PdfPen get_MistyRose();
    public static PdfPen get_Moccasin();
    public static PdfPen get_NavajoWhite();
    public static PdfPen get_Navy();
    public static PdfPen get_OldLace();
    public static PdfPen get_Olive();
    public static PdfPen get_OliveDrab();
    public static PdfPen get_Orange();
    public static PdfPen get_OrangeRed();
    public static PdfPen get_Orchid();
    public static PdfPen get_PaleGoldenrod();
    public static PdfPen get_PaleGreen();
    public static PdfPen get_PaleTurquoise();
    public static PdfPen get_PaleVioletRed();
    public static PdfPen get_PapayaWhip();
    public static PdfPen get_PeachPuff();
    public static PdfPen get_Peru();
    public static PdfPen get_Pink();
    public static PdfPen get_Plum();
    public static PdfPen get_PowderBlue();
    public static PdfPen get_Purple();
    public static PdfPen get_Red();
    public static PdfPen get_RosyBrown();
    public static PdfPen get_RoyalBlue();
    public static PdfPen get_SaddleBrown();
    public static PdfPen get_Salmon();
    public static PdfPen get_SandyBrown();
    public static PdfPen get_SeaGreen();
    public static PdfPen get_SeaShell();
    public static PdfPen get_Sienna();
    public static PdfPen get_Silver();
    public static PdfPen get_SkyBlue();
    public static PdfPen get_SlateBlue();
    public static PdfPen get_SlateGray();
    public static PdfPen get_Snow();
    public static PdfPen get_SpringGreen();
    public static PdfPen get_SteelBlue();
    public static PdfPen get_Tan();
    public static PdfPen get_Teal();
    public static PdfPen get_Thistle();
    public static PdfPen get_Tomato();
    public static PdfPen get_Transparent();
    public static PdfPen get_Turquoise();
    public static PdfPen get_Violet();
    public static PdfPen get_Wheat();
    public static PdfPen get_White();
    public static PdfPen get_WhiteSmoke();
    public static PdfPen get_Yellow();
    public static PdfPen get_YellowGreen();
    private static PdfPen GetPen(KnownColor colorName);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class Syncfusion.Pdf.Graphics.PdfPie : PdfEllipsePart {
    public PdfPie(float width, float height, float startAngle, float sweepAngle);
    public PdfPie(PdfPen pen, float width, float height, float startAngle, float sweepAngle);
    public PdfPie(PdfBrush brush, float width, float height, float startAngle, float sweepAngle);
    public PdfPie(PdfPen pen, PdfBrush brush, float width, float height, float startAngle, float sweepAngle);
    public PdfPie(float x, float y, float width, float height, float startAngle, float sweepAngle);
    public PdfPie(RectangleF rectangle, float startAngle, float sweepAngle);
    public PdfPie(PdfPen pen, float x, float y, float width, float height, float startAngle, float sweepAngle);
    public PdfPie(PdfPen pen, RectangleF rectangle, float startAngle, float sweepAngle);
    public PdfPie(PdfBrush brush, float x, float y, float width, float height, float startAngle, float sweepAngle);
    public PdfPie(PdfBrush brush, RectangleF rectangle, float startAngle, float sweepAngle);
    public PdfPie(PdfPen pen, PdfBrush brush, float x, float y, float width, float height, float startAngle, float sweepAngle);
    public PdfPie(PdfPen pen, PdfBrush brush, RectangleF rectangle, float startAngle, float sweepAngle);
    protected virtual void DrawInternal(PdfGraphics graphics);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class Syncfusion.Pdf.Graphics.PdfPolygon : PdfFillElement {
    private List`1<PointF> m_points;
    public PointF[] Points { get; public set; }
    public int Count { get; }
    public PdfPolygon(PointF[] points);
    public PdfPolygon(PdfPen pen, PointF[] points);
    public PdfPolygon(PdfBrush brush, PointF[] points);
    public PdfPolygon(PdfPen pen, PdfBrush brush, PointF[] points);
    public PointF[] get_Points();
    public void set_Points(PointF[] value);
    public int get_Count();
    public void AddPoint(PointF point);
    protected virtual RectangleF GetBoundsInternal();
    protected virtual void DrawInternal(PdfGraphics graphics);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class Syncfusion.Pdf.Graphics.PdfRadialGradientBrush : PdfGradientBrush {
    private PointF m_pointStart;
    private float m_radiusStart;
    private PointF m_pointEnd;
    private float m_radiusEnd;
    private PdfColor[] m_colours;
    private PdfColorBlend m_colourBlend;
    private PdfBlend m_blend;
    private RectangleF m_boundaries;
    public PdfBlend Blend { get; public set; }
    public PdfColorBlend InterpolationColors { get; public set; }
    public PdfColor[] LinearColors { get; public set; }
    public RectangleF Rectangle { get; public set; }
    public PdfExtend Extend { get; public set; }
    public PdfRadialGradientBrush(PointF centreStart, float radiusStart, PointF centreEnd, float radiusEnd, PdfColor colorStart, PdfColor colorEnd);
    private PdfRadialGradientBrush(PdfColor color1, PdfColor color2);
    public PdfBlend get_Blend();
    public void set_Blend(PdfBlend value);
    public PdfColorBlend get_InterpolationColors();
    public void set_InterpolationColors(PdfColorBlend value);
    public PdfColor[] get_LinearColors();
    public void set_LinearColors(PdfColor[] value);
    public RectangleF get_Rectangle();
    public void set_Rectangle(RectangleF value);
    public PdfExtend get_Extend();
    public void set_Extend(PdfExtend value);
    private void SetPoints(PointF pointStart, PointF pointEnd, float radiusStart, float radiusEnd);
    private void InitShading();
    public virtual PdfBrush Clone();
    internal virtual void ResetFunction();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class Syncfusion.Pdf.Graphics.PdfRectangle : PdfRectangleArea {
    public PdfRectangle(float width, float height);
    public PdfRectangle(PdfPen pen, float width, float height);
    public PdfRectangle(PdfBrush brush, float width, float height);
    public PdfRectangle(PdfPen pen, PdfBrush brush, float width, float height);
    public PdfRectangle(float x, float y, float width, float height);
    public PdfRectangle(RectangleF rectangle);
    public PdfRectangle(PdfPen pen, float x, float y, float width, float height);
    public PdfRectangle(PdfPen pen, RectangleF rectangle);
    public PdfRectangle(PdfBrush brush, float x, float y, float width, float height);
    public PdfRectangle(PdfBrush brush, RectangleF rectangle);
    public PdfRectangle(PdfPen pen, PdfBrush brush, float x, float y, float width, float height);
    public PdfRectangle(PdfPen pen, PdfBrush brush, RectangleF rectangle);
    protected virtual void DrawInternal(PdfGraphics graphics);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public abstract class Syncfusion.Pdf.Graphics.PdfRectangleArea : PdfFillElement {
    private RectangleF m_rect;
    public float X { get; public set; }
    public float Y { get; public set; }
    public float Width { get; public set; }
    public float Height { get; public set; }
    public SizeF Size { get; public set; }
    public RectangleF Bounds { get; public set; }
    protected PdfRectangleArea(float x, float y, float width, float height);
    protected PdfRectangleArea(RectangleF rectangle);
    protected PdfRectangleArea(PdfPen pen, PdfBrush brush, float x, float y, float width, float height);
    protected PdfRectangleArea(PdfPen pen, PdfBrush brush, RectangleF rectangle);
    public float get_X();
    public void set_X(float value);
    public float get_Y();
    public void set_Y(float value);
    public float get_Width();
    public void set_Width(float value);
    public float get_Height();
    public void set_Height(float value);
    public SizeF get_Size();
    public void set_Size(SizeF value);
    public RectangleF get_Bounds();
    public void set_Bounds(RectangleF value);
    protected virtual RectangleF GetBoundsInternal();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public abstract class Syncfusion.Pdf.Graphics.PdfShapeElement : PdfLayoutElement {
    public RectangleF GetBounds();
    protected abstract virtual RectangleF GetBoundsInternal();
    protected virtual PdfLayoutResult Layout(PdfLayoutParams param);
    internal virtual PdfLayoutResult Layout(HtmlToPdfParams param);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class Syncfusion.Pdf.Graphics.PdfSolidBrush : PdfBrush {
    private PdfColor m_color;
    private PdfColorSpace m_colorSpace;
    private bool m_bImmutable;
    private PdfExtendedColor m_colorspaces;
    public PdfColor Color { get; public set; }
    internal PdfExtendedColor Colorspaces { get; internal set; }
    public PdfSolidBrush(PdfColor color);
    public PdfSolidBrush(PdfExtendedColor color);
    internal PdfSolidBrush(PdfColor color, bool immutable);
    public PdfColor get_Color();
    public void set_Color(PdfColor value);
    internal PdfExtendedColor get_Colorspaces();
    internal void set_Colorspaces(PdfExtendedColor value);
    internal virtual bool MonitorChanges(PdfBrush brush, PdfStreamWriter streamWriter, GetResources getResources, bool saveChanges, PdfColorSpace currentColorSpace);
    internal virtual bool MonitorChanges(PdfBrush brush, PdfStreamWriter streamWriter, GetResources getResources, bool saveChanges, PdfColorSpace currentColorSpace, bool check);
    internal virtual bool MonitorChanges(PdfBrush brush, PdfStreamWriter streamWriter, GetResources getResources, bool saveChanges, PdfColorSpace currentColorSpace, bool check, bool iccbased);
    internal virtual bool MonitorChanges(PdfBrush brush, PdfStreamWriter streamWriter, GetResources getResources, bool saveChanges, PdfColorSpace currentColorSpace, bool check, bool iccbased, bool indexed);
    internal virtual void ResetChanges(PdfStreamWriter streamWriter);
    public virtual PdfBrush Clone();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class Syncfusion.Pdf.Graphics.PdfStandardFont : PdfFont {
    private static int c_charOffset;
    private PdfFontFamily m_fontFamily;
    internal Dictionary`2<char, float> charWidthDictionary;
    private static List`1<int> usedChars;
    private PdfDictionary dictionary;
    internal Encoding fontEncoding;
    private Dictionary`2<int, string> unicodeToNames;
    private Dictionary`2<string, int> widthTableUpdate;
    private Int32[] charcode;
    private string unicodeNames;
    private string characterNames;
    private Int32[] hevetica;
    private Int32[] heveticaBold;
    private Int32[] courier;
    private Int32[] symbol;
    private Int32[] zapfDingbat;
    private Int32[] timeRoman;
    private Int32[] timesBold;
    private Int32[] timesItaic;
    private Int32[] timesBoldItalic;
    public PdfFontFamily FontFamily { get; }
    private Dictionary`2<int, string> CharacterMapTable { get; }
    private Dictionary`2<string, int> FindWidth { get; }
    public PdfStandardFont(PdfFontFamily fontFamily, float size);
    public PdfStandardFont(PdfFontFamily fontFamily, float size, PdfFontStyle style);
    internal PdfStandardFont(PdfFontFamily fontFamily, float size, PdfFontStyle style, bool isLicense);
    public PdfStandardFont(PdfStandardFont prototype, float size);
    public PdfStandardFont(PdfStandardFont prototype, float size, PdfFontStyle style);
    private static PdfStandardFont();
    protected virtual override void Finalize();
    public PdfFontFamily get_FontFamily();
    public void SetTextEncoding(Encoding textEncoding);
    protected internal virtual float GetCharWidth(char charCode, PdfStringFormat format);
    protected internal virtual float GetLineWidth(string line, PdfStringFormat format);
    protected virtual bool EqualsToFont(PdfFont font);
    private void InitializeInternals();
    private void InitializeInternals(bool isLicense);
    private PdfDictionary CreateInternals();
    private Dictionary`2<int, string> get_CharacterMapTable();
    private Dictionary`2<string, int> get_FindWidth();
    private Int32[] FindStandardWidth();
    private void FontBeginSave(object sender, SavePdfPrimitiveEventArgs ars);
    private void CheckStyle();
    private float GetCharWidthInternal(char charCode, PdfStringFormat format);
    internal static string Convert(string text);
    internal static string Convert(string text, Encoding encoding);
    private void UpdateWidthTable();
}
public class Syncfusion.Pdf.Graphics.PdfStringFormat : object {
    private PdfTextAlignment m_alignment;
    private PdfVerticalAlignment m_lineAlignment;
    private bool m_rightToLeft;
    private PdfTextDirection m_textDirection;
    private float m_characterSpacing;
    private float m_wordSpacing;
    private float m_leading;
    private bool m_clip;
    private PdfSubSuperScript m_subSuperScript;
    private float m_scalingFactor;
    private float m_firstLineIndent;
    internal float m_paragraphIndent;
    private bool m_lineLimit;
    private bool m_measureTrailingSpaces;
    private bool m_noClip;
    private PdfWordWrapType m_wrapType;
    internal bool isCustomRendering;
    private bool m_complexScript;
    private bool m_baseLine;
    internal bool m_isList;
    private bool m_enableNewLineIndent;
    private bool m_measureTiltingSpace;
    private float m_tiltingSpace;
    public PdfTextDirection TextDirection { get; public set; }
    public bool ComplexScript { get; public set; }
    public PdfTextAlignment Alignment { get; public set; }
    public PdfVerticalAlignment LineAlignment { get; public set; }
    public bool EnableBaseline { get; public set; }
    internal bool RightToLeft { get; internal set; }
    public float CharacterSpacing { get; public set; }
    public float WordSpacing { get; public set; }
    public float LineSpacing { get; public set; }
    public bool ClipPath { get; public set; }
    public PdfSubSuperScript SubSuperScript { get; public set; }
    public float ParagraphIndent { get; public set; }
    public bool LineLimit { get; public set; }
    public bool MeasureTrailingSpaces { get; public set; }
    public bool NoClip { get; public set; }
    public PdfWordWrapType WordWrap { get; public set; }
    internal float HorizontalScalingFactor { get; internal set; }
    internal float FirstLineIndent { get; internal set; }
    public bool EnableNewLineIndent { get; public set; }
    public bool MeasureTiltingSpace { get; public set; }
    internal float TiltingSpace { get; internal set; }
    public PdfStringFormat(PdfTextAlignment alignment);
    [NullableContextAttribute("1")]
public PdfStringFormat(string columnFormat);
    public PdfStringFormat(PdfTextAlignment alignment, PdfVerticalAlignment lineAlignment);
    public PdfTextDirection get_TextDirection();
    public void set_TextDirection(PdfTextDirection value);
    public bool get_ComplexScript();
    public void set_ComplexScript(bool value);
    public PdfTextAlignment get_Alignment();
    public void set_Alignment(PdfTextAlignment value);
    public PdfVerticalAlignment get_LineAlignment();
    public void set_LineAlignment(PdfVerticalAlignment value);
    public bool get_EnableBaseline();
    public void set_EnableBaseline(bool value);
    internal bool get_RightToLeft();
    internal void set_RightToLeft(bool value);
    public float get_CharacterSpacing();
    public void set_CharacterSpacing(float value);
    public float get_WordSpacing();
    public void set_WordSpacing(float value);
    public float get_LineSpacing();
    public void set_LineSpacing(float value);
    public bool get_ClipPath();
    public void set_ClipPath(bool value);
    public PdfSubSuperScript get_SubSuperScript();
    public void set_SubSuperScript(PdfSubSuperScript value);
    public float get_ParagraphIndent();
    public void set_ParagraphIndent(float value);
    public bool get_LineLimit();
    public void set_LineLimit(bool value);
    public bool get_MeasureTrailingSpaces();
    public void set_MeasureTrailingSpaces(bool value);
    public bool get_NoClip();
    public void set_NoClip(bool value);
    public PdfWordWrapType get_WordWrap();
    public void set_WordWrap(PdfWordWrapType value);
    internal float get_HorizontalScalingFactor();
    internal void set_HorizontalScalingFactor(float value);
    internal float get_FirstLineIndent();
    internal void set_FirstLineIndent(float value);
    public bool get_EnableNewLineIndent();
    public void set_EnableNewLineIndent(bool value);
    public bool get_MeasureTiltingSpace();
    public void set_MeasureTiltingSpace(bool value);
    internal float get_TiltingSpace();
    internal void set_TiltingSpace(float value);
    [NullableContextAttribute("1")]
public sealed virtual object Clone();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class Syncfusion.Pdf.Graphics.PdfStringLayouter : object {
    private string m_text;
    private PdfFont m_font;
    private PdfStringFormat m_format;
    private SizeF m_size;
    private RectangleF m_rect;
    private float m_pageHeight;
    private StringTokenizer m_reader;
    private bool m_isTabReplaced;
    private int m_tabOccuranceCount;
    internal PdfStringLayoutResult Layout(string text, PdfFont font, PdfStringFormat format, RectangleF rect, float pageHeight);
    public PdfStringLayoutResult Layout(string text, PdfFont font, PdfStringFormat format, SizeF size);
    private void Initialize(string text, PdfFont font, PdfStringFormat format, RectangleF rect, float pageHeight);
    private void Initialize(string text, PdfFont font, PdfStringFormat format, SizeF size);
    private PdfStringLayoutResult DoLayout();
    private bool CopyToResult(PdfStringLayoutResult result, PdfStringLayoutResult lineResult, List`1<LineInfo> lines, Int32& numInserted);
    private void FinalizeResult(PdfStringLayoutResult result, List`1<LineInfo> lines);
    private void Clear();
    private float GetLineHeight();
    private PdfStringLayoutResult LayoutLine(string line, float lineIndent, ScriptTags[] tags);
    private void LayoutLine(string line, float lineIndent, PdfStringLayoutResult lineResult, float maxWidth, LineType lineType, List`1<LineInfo> lines, ScriptTags[] tags);
    private void LayoutLine(string line, float lineWidth, float lineIndent, PdfStringLayoutResult lineResult, float maxWidth, LineType lineType, bool readWord, List`1<LineInfo> lines);
    private bool BrokeHyphenContent(float maxWidth, float lineWidth, float curIndent, StringTokenizer reader);
    private void ReadNearHyphen(string ln, float maxWidth, float curIndent, Int32& nextHyphen);
    private int GetLastHyphenIndex(string text);
    private int GetFirstHyphenIndex(string text);
    private void ReadHyphenLocation(string ln, float maxWidth, float curIndent, Int32& posHyphen);
    private PdfStringLayoutResult LayoutLine(string line, float lineIndent);
    private void AddToLineResult(PdfStringLayoutResult lineResult, List`1<LineInfo> lines, string line, float lineWidth, LineType breakType, OtfGlyphInfoList glyphList);
    private LineInfo TrimLine(LineInfo info, bool firstLine);
    private float GetLineWidth(string line);
    private float GetLineWidth(string line, OtfGlyphInfoList& glyphList, ScriptTags[] tags);
    private float GetLineIndent(bool firstLine);
    private PdfWordWrapType GetWrapType();
    private void UpdateLineInfoBidiLevels(string line, List`1<LineInfo> lines);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class Syncfusion.Pdf.Graphics.PdfStringLayoutResult : object {
    internal LineInfo[] m_lines;
    internal string m_remainder;
    internal SizeF m_actualSize;
    internal float m_lineHeight;
    public string Remainder { get; }
    public SizeF ActualSize { get; }
    public LineInfo[] Lines { get; }
    public float LineHeight { get; }
    internal bool Empty { get; }
    internal int LineCount { get; }
    public string get_Remainder();
    public SizeF get_ActualSize();
    public LineInfo[] get_Lines();
    public float get_LineHeight();
    internal bool get_Empty();
    internal int get_LineCount();
}
public enum Syncfusion.Pdf.Graphics.PdfSubSuperScript : Enum {
    public int value__;
    public static PdfSubSuperScript None;
    public static PdfSubSuperScript SuperScript;
    public static PdfSubSuperScript SubScript;
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class Syncfusion.Pdf.Graphics.PdfTemplate : PdfShapeElement {
    private PdfGraphics m_graphics;
    internal PdfStream m_content;
    internal PdfResources m_resources;
    private SizeF m_size;
    private bool m_bIsReadonly;
    internal bool m_writeTransformation;
    internal bool isLoadedPageTemplate;
    internal bool isCustomStamp;
    internal bool isContainPageRotation;
    private string m_customPdfTemplateName;
    private bool m_isSignatureAppearanceValidation;
    private bool m_isAnnotationTemplate;
    private bool m_isScaleAnnotation;
    internal PointF m_origin;
    internal bool isCropBox;
    internal bool m_isSignatureAppearance;
    private SizeF m_originalSize;
    public PdfGraphics Graphics { get; }
    public SizeF Size { get; }
    public float Width { get; }
    public float Height { get; }
    public bool ReadOnly { get; }
    internal string CustomPdfTemplateName { get; internal set; }
    internal bool IsSignatureAppearanceValidation { get; internal set; }
    internal SizeF OriginalSize { get; }
    private IPdfPrimitive Syncfusion.Pdf.IPdfWrapper.Element { get; }
    internal bool IsAnnotationTemplate { get; internal set; }
    internal bool NeedScaling { get; internal set; }
    public PdfTemplate(SizeF size);
    public PdfTemplate(RectangleF rect);
    internal PdfTemplate(SizeF size, bool writeTransformation);
    public PdfTemplate(float width, float height);
    public PdfTemplate(float x, float y, float width, float height);
    internal PdfTemplate(PointF origin, SizeF size, MemoryStream stream, PdfDictionary resources, bool isLoadedPage, PdfPageBase page);
    internal PdfTemplate(SizeF size, MemoryStream stream, PdfDictionary resources);
    internal PdfTemplate(PdfStream template);
    internal PdfTemplate(PdfStream template, bool isTransformBBox);
    public PdfGraphics get_Graphics();
    public SizeF get_Size();
    public float get_Width();
    public float get_Height();
    public bool get_ReadOnly();
    internal void set_CustomPdfTemplateName(string value);
    internal string get_CustomPdfTemplateName();
    internal bool get_IsSignatureAppearanceValidation();
    internal void set_IsSignatureAppearanceValidation(bool value);
    internal SizeF get_OriginalSize();
    public void Reset(SizeF size);
    public void Reset();
    internal static PdfTemplate FromJson(string jsonData);
    private sealed virtual override IPdfPrimitive Syncfusion.Pdf.IPdfWrapper.get_Element();
    protected virtual RectangleF GetBoundsInternal();
    protected virtual void DrawInternal(PdfGraphics graphics);
    private void Initialize();
    private PdfResources GetResources();
    private void AddType();
    private void AddSubType();
    private void SetSize(SizeF size);
    private void SetBounds(RectangleF bounds);
    private void SetSize(PointF origin, SizeF size);
    internal void CloneResources(PdfCrossTable crossTable);
    internal void Clear(string Data);
    private RectangleF TransformBBoxByMatrix(RectangleF bBoxValue, Single[] matrix);
    private float MaxValue(Single[] value);
    private float MinValue(Single[] value);
    private PointF TransformPoint(float x, float y, Single[] matrix);
    internal string GetAppearanceAsJson();
    internal void UpdateSize(SizeF size);
    internal bool get_IsAnnotationTemplate();
    internal void set_IsAnnotationTemplate(bool value);
    internal bool get_NeedScaling();
    internal void set_NeedScaling(bool value);
}
public enum Syncfusion.Pdf.Graphics.PdfTextAlignment : Enum {
    public int value__;
    public static PdfTextAlignment Left;
    public static PdfTextAlignment Center;
    public static PdfTextAlignment Right;
    public static PdfTextAlignment Justify;
}
public enum Syncfusion.Pdf.Graphics.PdfTextDirection : Enum {
    public int value__;
    public static PdfTextDirection None;
    public static PdfTextDirection LeftToRight;
    public static PdfTextDirection RightToLeft;
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class Syncfusion.Pdf.Graphics.PdfTextElement : PdfLayoutElement {
    private string m_text;
    private string m_value;
    private PdfPen m_pen;
    private PdfBrush m_brush;
    private PdfFont m_font;
    private PdfStringFormat m_format;
    internal bool ispdfTextElement;
    internal bool m_pdfHtmlTextElement;
    internal bool m_isPdfGrid;
    public string Text { get; public set; }
    internal string Value { get; }
    public PdfPen Pen { get; public set; }
    public PdfBrush Brush { get; public set; }
    public PdfFont Font { get; public set; }
    public PdfStringFormat StringFormat { get; public set; }
    public PdfTextElement(string text);
    public PdfTextElement(string text, PdfFont font);
    public PdfTextElement(string text, PdfFont font, PdfPen pen);
    public PdfTextElement(string text, PdfFont font, PdfBrush brush);
    public PdfTextElement(string text, PdfFont font, PdfPen pen, PdfBrush brush, PdfStringFormat format);
    public string get_Text();
    public void set_Text(string value);
    internal string get_Value();
    public PdfPen get_Pen();
    public void set_Pen(PdfPen value);
    public PdfBrush get_Brush();
    public void set_Brush(PdfBrush value);
    public PdfFont get_Font();
    public void set_Font(PdfFont value);
    public PdfStringFormat get_StringFormat();
    public void set_StringFormat(PdfStringFormat value);
    public PdfTextLayoutResult Draw(PdfPage page, PointF location, PdfLayoutFormat format);
    public PdfTextLayoutResult Draw(PdfPage page, PointF location, float width, PdfLayoutFormat format);
    public PdfTextLayoutResult Draw(PdfPage page, RectangleF layoutRectangle, PdfLayoutFormat format);
    internal PdfBrush ObtainBrush();
    protected virtual void DrawInternal(PdfGraphics graphics);
    protected virtual PdfLayoutResult Layout(PdfLayoutParams param);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class Syncfusion.Pdf.Graphics.PdfTextLayoutResult : PdfLayoutResult {
    private string m_remainder;
    private RectangleF m_lastLineBounds;
    public string Remainder { get; }
    public RectangleF LastLineBounds { get; }
    internal PdfTextLayoutResult(PdfPage page, RectangleF bounds, string remainder, RectangleF lastLineBounds);
    public string get_Remainder();
    public RectangleF get_LastLineBounds();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Syncfusion.Pdf.Graphics.PdfTextureBrush : PdfTilingBrush {
    private PdfImage m_textureImage;
    private RectangleF mImageBounds;
    public PdfTextureBrush(PdfImage image, RectangleF dstRect, float transparency);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class Syncfusion.Pdf.Graphics.PdfTilingBrush : PdfBrush {
    private RectangleF m_box;
    private PdfGraphics m_graphics;
    private PdfStream m_brushStream;
    private PdfResources m_resources;
    private bool m_bStroking;
    private PdfPage m_page;
    private PointF m_location;
    private PdfTransformationMatrix m_transformationMatrix;
    internal bool isXPSBrush;
    private float m_outerSize;
    internal PointF Location { get; internal set; }
    internal PdfTransformationMatrix TransformationMatrix { get; internal set; }
    public RectangleF Rectangle { get; }
    public SizeF Size { get; }
    public PdfGraphics Graphics { get; }
    internal PdfResources Resources { get; }
    internal bool Stroking { get; internal set; }
    private IPdfPrimitive Syncfusion.Pdf.IPdfWrapper.Element { get; }
    public PdfTilingBrush(RectangleF rectangle);
    public PdfTilingBrush(SizeF size, float outerSize);
    public PdfTilingBrush(RectangleF rectangle, float outerSize);
    public PdfTilingBrush(RectangleF rectangle, PdfPage page);
    public PdfTilingBrush(SizeF size);
    public PdfTilingBrush(SizeF size, PdfPage page);
    internal PdfTilingBrush(RectangleF rectangle, float outerSize, PdfPage page, PointF location, PdfTransformationMatrix matrix);
    internal PointF get_Location();
    internal void set_Location(PointF value);
    internal PdfTransformationMatrix get_TransformationMatrix();
    internal void set_TransformationMatrix(PdfTransformationMatrix value);
    private void SetObligatoryFields();
    private void SetBox(RectangleF box);
    public RectangleF get_Rectangle();
    public SizeF get_Size();
    public PdfGraphics get_Graphics();
    internal PdfResources get_Resources();
    internal bool get_Stroking();
    internal void set_Stroking(bool value);
    private PdfResources ObtainResources();
    public virtual PdfBrush Clone();
    internal virtual bool MonitorChanges(PdfBrush brush, PdfStreamWriter streamWriter, GetResources getResources, bool saveChanges, PdfColorSpace currentColorSpace);
    internal virtual bool MonitorChanges(PdfBrush brush, PdfStreamWriter streamWriter, GetResources getResources, bool saveChanges, PdfColorSpace currentColorSpace, bool check);
    internal virtual bool MonitorChanges(PdfBrush brush, PdfStreamWriter streamWriter, GetResources getResources, bool saveChanges, PdfColorSpace currentColorSpace, bool check, bool iccbased);
    internal virtual bool MonitorChanges(PdfBrush brush, PdfStreamWriter streamWriter, GetResources getResources, bool saveChanges, PdfColorSpace currentColorSpace, bool check, bool iccbased, bool indexed);
    internal virtual void ResetChanges(PdfStreamWriter streamWriter);
    private sealed virtual override IPdfPrimitive Syncfusion.Pdf.IPdfWrapper.get_Element();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Syncfusion.Pdf.Graphics.PdfTransformationMatrix : object {
    private static double DegRadFactor;
    private static double RadDegFactor;
    private Matrix m_matrix;
    public float OffsetX { get; }
    public float OffsetY { get; }
    protected internal Matrix Matrix { get; protected internal set; }
    internal PdfTransformationMatrix(bool value);
    public float get_OffsetX();
    public float get_OffsetY();
    protected internal Matrix get_Matrix();
    protected internal void set_Matrix(Matrix value);
    public void Translate(SizeF offsets);
    public void Translate(float offsetX, float offsetY);
    public void Scale(SizeF scales);
    public void Scale(float scaleX, float scaleY);
    public void Rotate(float angle);
    public void Skew(SizeF angles);
    public void Skew(float angleX, float angleY);
    public void Shear(float shearX, float shearY);
    public void RotateAt(float angle, PointF point);
    public virtual string ToString();
    internal Matrix Multiply(Single[] Elements, Matrix matrix);
    protected internal void Multiply(PdfTransformationMatrix matrix);
    public static double DegressToRadians(float degreesX);
    public static double RadiansToDegress(float radians);
    public PdfTransformationMatrix Clone();
    private sealed virtual override object Syncfusion.Pdf.ICloneable.Clone();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Syncfusion.Pdf.Graphics.PdfTransparency : object {
    private PdfDictionary m_dictionary;
    public float Stroke { get; }
    public float Fill { get; }
    public PdfBlendMode Mode { get; }
    private IPdfPrimitive Syncfusion.Pdf.IPdfWrapper.Element { get; }
    public PdfTransparency(float stroke, float fill, PdfBlendMode mode);
    public float get_Stroke();
    public float get_Fill();
    public PdfBlendMode get_Mode();
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    private float GetNumber(string keyName);
    private string GetName(string keyName);
    private sealed virtual override IPdfPrimitive Syncfusion.Pdf.IPdfWrapper.get_Element();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class Syncfusion.Pdf.Graphics.PdfTrueTypeFont : PdfFont {
    internal static Encoding Encoding;
    private static int c_codePage;
    protected static object s_rtlRenderLock;
    private bool m_embed;
    private bool m_unicode;
    internal ITrueTypeFont m_fontInternal;
    private bool m_bUseTrueType;
    private bool m_isContainsFont;
    private PdfFontStyle m_style;
    private string metricsName;
    private bool m_isEmbedFont;
    private TtfReader m_ttfReader;
    private bool m_isXPSFontStream;
    private bool m_isEMFFontStream;
    private bool m_conformanceEnabled;
    private bool m_isSkipFontEmbed;
    private bool is_filePath;
    private bool m_fullEmbed;
    internal bool m_isStyleBold;
    private bool m_useFloatingFactorForMeasure;
    public bool Unicode { get; }
    internal bool Embed { get; }
    internal ITrueTypeFont InternalFont { get; }
    internal bool IsContainsFont { get; }
    internal string FontFile { get; }
    internal TtfReader TtfReader { get; }
    internal bool IsEmbedFont { get; }
    public PdfTrueTypeFont(Stream fontStream, float size);
    public PdfTrueTypeFont(string fontFile, float size);
    public PdfTrueTypeFont(string fontFile, float size, PdfFontStyle style);
    public PdfTrueTypeFont(string fontFile, bool embed, PdfFontStyle style, float size);
    internal PdfTrueTypeFont(Stream fontStream, float size, bool isTrueType);
    public PdfTrueTypeFont(Stream fontStream, float size, PdfFontStyle style);
    public PdfTrueTypeFont(Stream fontStream, bool embed, PdfFontStyle style, float size);
    internal PdfTrueTypeFont(Stream fontStream, float size, PdfFontStyle style, bool useTrueType);
    public PdfTrueTypeFont(Stream fontStream, float size, bool embed, bool subset);
    internal PdfTrueTypeFont(Stream fontStream, float size, string metricsName, bool isEnableEmbedding);
    internal PdfTrueTypeFont(Stream fontStream, float size, string metricsName, bool isEnableEmbedding, PdfFontStyle fontStyle);
    internal PdfTrueTypeFont(Stream fontStream, PdfFontStyle fontStyle, float size, string metricsName, bool useTrueType, bool isEnableEmbedding);
    internal PdfTrueTypeFont(Stream fontStream, PdfFontStyle fontStyle, float size, string metricsName, bool useTrueType, bool isEnableEmbedding, bool isConformanceEnabled);
    internal PdfTrueTypeFont(Stream fontStream, float size, bool isUnicode, string metricsName, PdfFontStyle fontStyle);
    internal PdfTrueTypeFont(Stream fontStream, float size, bool isEnableEmbedding, PdfFontStyle fontStyle);
    public PdfTrueTypeFont(PdfTrueTypeFont prototype, float size);
    internal PdfTrueTypeFont(PdfTrueTypeFont prototype, bool isEnableEmbedding, float size);
    internal PdfTrueTypeFont(PdfTrueTypeFont prototype, float size, bool isXpsFontstream);
    public PdfTrueTypeFont(Stream fontStream, PdfFontSettings fontSettings);
    private static PdfTrueTypeFont();
    protected virtual override void Finalize();
    public bool get_Unicode();
    internal bool get_Embed();
    internal ITrueTypeFont get_InternalFont();
    internal bool get_IsContainsFont();
    internal string get_FontFile();
    internal TtfReader get_TtfReader();
    internal bool get_IsEmbedFont();
    public sealed virtual void Dispose();
    protected internal virtual float GetCharWidth(char charCode, PdfStringFormat format);
    private void CreateXpsFontInternal(PdfTrueTypeFont prototype);
    protected internal virtual float GetLineWidth(string line, PdfStringFormat format);
    internal float GetLineWidth(string line, PdfStringFormat format, OtfGlyphInfoList& glyphList, ScriptTags[] tags);
    protected virtual bool EqualsToFont(PdfFont font);
    internal void SetSymbols(string text);
    internal void SetSymbols(UInt16[] glyphs);
    private void CreateFontInternal(PdfTrueTypeFont prototype);
    private void CreateFontInternal(Stream fontStream, PdfFontStyle style);
    private void InitializeInternals();
    private void CalculateStyle(PdfFontStyle style);
    private float GetSymbolSize(char ch, PdfStringFormat format);
    private bool GetUnicodeLineWidth(string line, Single& width, PdfStringFormat format);
    private float GetWidth(UnicodeTrueTypeFont unicodeFont, string line);
    private void CreateFontInternal(string fontFile, PdfFontStyle style);
}
public class Syncfusion.Pdf.Graphics.PdfUnitConverter : object {
    internal static float HorizontalResolution;
    internal static float VerticalResolution;
    internal static float HorizontalSize;
    internal static float VerticalSize;
    internal static float PxHorizontalResolution;
    internal static float PxVerticalResolution;
    [NullableAttribute("1")]
private Double[] m_proportions;
    private static PdfUnitConverter();
    public PdfUnitConverter(float dpi);
    public float ConvertUnits(float value, PdfGraphicsUnit from, PdfGraphicsUnit to);
    public float ConvertToPixels(float value, PdfGraphicsUnit from);
    public RectangleF ConvertToPixels(RectangleF rect, PdfGraphicsUnit from);
    public PointF ConvertToPixels(PointF point, PdfGraphicsUnit from);
    public SizeF ConvertToPixels(SizeF size, PdfGraphicsUnit from);
    public float ConvertFromPixels(float value, PdfGraphicsUnit to);
    public RectangleF ConvertFromPixels(RectangleF rect, PdfGraphicsUnit to);
    public PointF ConvertFromPixels(PointF point, PdfGraphicsUnit to);
    public SizeF ConvertFromPixels(SizeF size, PdfGraphicsUnit to);
    private void UpdateProportions(float pixelPerInch);
}
[ObsoleteAttribute("Please use PdfUnitConverter instead")]
public class Syncfusion.Pdf.Graphics.PdfUnitConvertor : object {
    internal static float HorizontalResolution;
    internal static float VerticalResolution;
    internal static float HorizontalSize;
    internal static float VerticalSize;
    internal static float PxHorizontalResolution;
    internal static float PxVerticalResolution;
    [NullableAttribute("1")]
private Double[] m_proportions;
    private static PdfUnitConvertor();
    public PdfUnitConvertor(float dpi);
    public float ConvertUnits(float value, PdfGraphicsUnit from, PdfGraphicsUnit to);
    public float ConvertToPixels(float value, PdfGraphicsUnit from);
    public RectangleF ConvertToPixels(RectangleF rect, PdfGraphicsUnit from);
    public PointF ConvertToPixels(PointF point, PdfGraphicsUnit from);
    public SizeF ConvertToPixels(SizeF size, PdfGraphicsUnit from);
    public float ConvertFromPixels(float value, PdfGraphicsUnit to);
    public RectangleF ConvertFromPixels(RectangleF rect, PdfGraphicsUnit to);
    public PointF ConvertFromPixels(PointF point, PdfGraphicsUnit to);
    public SizeF ConvertFromPixels(SizeF size, PdfGraphicsUnit to);
    private void UpdateProportions(float pixelPerInch);
}
public enum Syncfusion.Pdf.Graphics.PdfVerticalAlignment : Enum {
    public int value__;
    public static PdfVerticalAlignment Top;
    public static PdfVerticalAlignment Middle;
    public static PdfVerticalAlignment Bottom;
}
public enum Syncfusion.Pdf.Graphics.PdfWordWrapType : Enum {
    public int value__;
    public static PdfWordWrapType None;
    public static PdfWordWrapType Word;
    public static PdfWordWrapType WordOnly;
    public static PdfWordWrapType Character;
    public static PdfWordWrapType DiscretionaryHyphen;
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Syncfusion.Pdf.Graphics.ProcedureSets : object {
    public static string PDF;
    public static string Text;
    public static string ImageB;
    public static string ImageC;
    public static string ImageI;
}
internal enum Syncfusion.Pdf.Graphics.ShadingType : Enum {
    public int value__;
    public static ShadingType Function;
    public static ShadingType Axial;
    public static ShadingType Radial;
    public static ShadingType FreeForm;
    public static ShadingType LatticeForm;
    public static ShadingType Coons;
    public static ShadingType Tensor;
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Syncfusion.Pdf.Graphics.ShapeLayouter : ElementLayouter {
    internal int olderPdfForm;
    [ThreadStaticAttribute]
private static int index;
    [ThreadStaticAttribute]
private static float splitDiff;
    [ThreadStaticAttribute]
private static bool last;
    private static int borderWidth;
    internal bool m_isPdfGrid;
    internal RectangleF shapeBounds;
    internal float m_bottomCellPadding;
    private double TotalPageSize;
    private TextRegionManager m_textRegions;
    private ImageRegionManager m_imageRegions;
    private ImageRegionManager m_formRegions;
    public PdfShapeElement Element { get; }
    private TextRegionManager TextRegions { get; private set; }
    private ImageRegionManager ImageRegions { get; private set; }
    private ImageRegionManager FormRegions { get; private set; }
    public ShapeLayouter(PdfShapeElement element);
    public PdfShapeElement get_Element();
    private TextRegionManager get_TextRegions();
    private void set_TextRegions(TextRegionManager value);
    private ImageRegionManager get_ImageRegions();
    private void set_ImageRegions(ImageRegionManager value);
    private ImageRegionManager get_FormRegions();
    private void set_FormRegions(ImageRegionManager value);
    protected virtual PdfLayoutResult LayoutInternal(PdfLayoutParams param);
    protected RectangleF GetPaginateBounds(HtmlToPdfParams param);
    protected virtual PdfLayoutResult LayoutInternal(HtmlToPdfParams param);
    protected virtual PdfLayoutResult LayoutInternal(HtmlToPdfLayoutParams param);
    protected virtual RectangleF CheckCorrectCurrentBounds(PdfPage currentPage, RectangleF currentBounds, RectangleF shapeLayoutBounds, PdfLayoutParams param);
    private PdfLayoutResult GetLayoutResult(ShapeLayoutResult pageResult);
    protected virtual RectangleF CheckCorrectCurrentBounds(PdfPage currentPage, RectangleF currentBounds, RectangleF shapeLayoutBounds, HtmlToPdfParams param);
    internal RectangleF GetPdfLayoutBounds(PdfPage currentPage, RectangleF currentBounds, RectangleF shapeLayoutBounds, HtmlToPdfParams param);
    internal void RepositionLinks(List`1<HtmlHyperLink> list, float height, HtmlToPdfFormat format);
    private ShapeLayoutResult LayoutOnPage(PdfPage currentPage, RectangleF currentBounds, RectangleF shapeLayoutBounds, HtmlToPdfParams param);
    private ShapeLayoutResult LayoutOnPage(PdfPage currentPage, RectangleF currentBounds, RectangleF shapeLayoutBounds, PdfLayoutParams param);
    private RectangleF GetNextShapeBounds(RectangleF shapeLayoutBounds, ShapeLayoutResult pageResult);
    private bool FitsToBounds(RectangleF currentBounds, RectangleF shapeLayoutBounds);
    private RectangleF GetDrawBounds(RectangleF currentBounds, RectangleF shapeLayoutBounds);
    private RectangleF GetPageResultBounds(RectangleF currentBounds, RectangleF shapeLayoutBounds);
    private void DrawShape(PdfGraphics g, RectangleF currentBounds, RectangleF drawRectangle);
    private EndPageLayoutEventArgs RaiseEndPageLayout(ShapeLayoutResult pageResult);
    private bool RaiseBeforePageLayout(PdfPage currentPage, RectangleF& currentBounds);
    protected virtual float ToCorrectBounds(RectangleF currentBounds, RectangleF shapeLayoutBounds, PdfPage currentPage);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Syncfusion.Pdf.Graphics.ShiftedIndexedCapturingReader : CatalogedReaderBase {
    private CatalogedReader m_baseReader;
    private int m_baseOffset;
    internal long Length { get; }
    internal ShiftedIndexedCapturingReader(CatalogedReader baseReader, int baseOffset, bool isBigEndian);
    internal virtual CatalogedReaderBase WithByteOrder(bool isBigEndian);
    internal virtual CatalogedReaderBase WithShiftedBaseOffset(int shift);
    internal virtual int ToUnshiftedOffset(int localOffset);
    internal virtual byte ReadByte(int index);
    internal virtual Byte[] GetBytes(int index, int count);
    internal virtual bool IsValidIndex(int index, int length);
    internal virtual long get_Length();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Syncfusion.Pdf.Graphics.StringTokenizer : object {
    public static char WhiteSpace;
    public static char Tab;
    public static Char[] Spaces;
    private static RegexOptions c_regexOptions;
    private static string c_whiteSpacePatterm;
    private static Regex s_whiteSpaceRegex;
    private string m_text;
    private int m_position;
    public bool EOF { get; }
    public int Length { get; }
    public int Position { get; public set; }
    public StringTokenizer(string text);
    private static StringTokenizer();
    public bool get_EOF();
    public int get_Length();
    public int get_Position();
    public void set_Position(int value);
    public static int GetCharsCount(string text, char symbol);
    public static int GetCharsCount(string text, Char[] symbols);
    public string ReadLine();
    public string PeekLine();
    public string ReadWord();
    public string PeekWord();
    public char Read();
    public string Read(int count);
    public string ReadToSymbol(char symbol, bool readSymbol);
    public char Peek();
    public void Close();
    public string ReadToEnd();
    internal static bool IsWhitespace(string token);
    internal static bool IsSpace(char token);
    internal static bool IsTab(char token);
    internal static int GetWhitespaceCount(string line, bool start);
    private static bool Contains(Char[] array, char symbol);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Syncfusion.Pdf.Graphics.TagDirectory : object {
    private string m_name;
    private TagDirectory m_parent;
    internal string Name { get; }
    internal TagDirectory Parent { get; internal set; }
    internal TagDirectory(string name);
    internal string get_Name();
    internal TagDirectory get_Parent();
    internal void set_Parent(TagDirectory value);
}
public enum Syncfusion.Pdf.Graphics.TextAlign : Enum {
    public int value__;
    public static TextAlign Left;
    public static TextAlign Right;
    public static TextAlign Center;
    public static TextAlign Justify;
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Syncfusion.Pdf.Graphics.TextLayouter : ElementLayouter {
    private PdfStringFormat m_format;
    private float m_maxValue;
    public PdfTextElement Element { get; }
    public TextLayouter(PdfTextElement element);
    public PdfTextElement get_Element();
    protected virtual PdfLayoutResult LayoutInternal(PdfLayoutParams param);
    private PdfTextLayoutResult GetLayoutResult(TextPageLayoutResult pageResult);
    private TextPageLayoutResult LayoutOnPage(string text, PdfPage currentPage, RectangleF currentBounds, PdfLayoutParams param);
    private RectangleF CheckCorrectBounds(PdfPage currentPage, RectangleF currentBounds);
    private RectangleF GetTextPageBounds(PdfPage currentPage, RectangleF currentBounds, PdfStringLayoutResult stringResult);
    private EndTextPageLayoutEventArgs RaisePageLayouted(TextPageLayoutResult pageResult);
    private bool RaiseBeforePageLayout(PdfPage currentPage, RectangleF& currentBounds);
    private void CheckCorectStringFormat(LineInfo lineInfo);
}
[FlagsAttribute]
internal enum Syncfusion.Pdf.Graphics.TextRenderingMode : Enum {
    public int value__;
    public static TextRenderingMode Fill;
    public static TextRenderingMode Stroke;
    public static TextRenderingMode FillStroke;
    public static TextRenderingMode None;
    public static TextRenderingMode ClipFlag;
    public static TextRenderingMode ClipFill;
    public static TextRenderingMode ClipStroke;
    public static TextRenderingMode ClipFillStroke;
    public static TextRenderingMode Clip;
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Syncfusion.Pdf.Graphics.TiffMetadataParser : object {
    private CatalogedReaderBase m_reader;
    internal TiffMetadataParser(Stream stream);
    public sealed virtual MemoryStream GetMetadata();
    internal static void ProcessImageFileDirectory(TiffTag tag, CatalogedReaderBase reader, ICollection`1<int> processedOffsets, int offset);
    private static int CalculateTagOffset(int offset, int entry);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Syncfusion.Pdf.Graphics.TiffTag : object {
    private Stack`1<TagDirectory> m_dictionary;
    private TagDirectory m_currentTag;
    private List`1<TagDirectory> m_directories;
    private MemoryStream m_stream;
    internal MemoryStream Data { get; }
    internal MemoryStream get_Data();
    internal void PushDirectory(TagDirectory tag);
    internal void SetTiffMarker(int marker);
    internal bool TryCustomProcessFormat(int tagId, DataTypeID formatCode, UInt32 componentCount, Int64& byteCount);
    internal bool TryEnterSubDirectory(int tagId);
    private bool HandlePrintIM(TagDirectory directory, int tagId);
    internal void CustomProcessTag(int tagOffset, ICollection`1<int> processedIfdOffsets, CatalogedReaderBase reader, int tagId, int byteCount);
}
internal enum Syncfusion.Pdf.Graphics.TtfCmapEncoding : Enum {
    public int value__;
    public static TtfCmapEncoding Unknown;
    public static TtfCmapEncoding Symbol;
    public static TtfCmapEncoding Unicode;
    public static TtfCmapEncoding Macintosh;
    public static TtfCmapEncoding UnicodeUCS4;
}
internal enum Syncfusion.Pdf.Graphics.TtfCmapFormat : Enum {
    public int value__;
    public static TtfCmapFormat Apple;
    public static TtfCmapFormat Microsoft;
    public static TtfCmapFormat Trimmed;
    public static TtfCmapFormat MicrosoftExt;
}
[FlagsAttribute]
internal enum Syncfusion.Pdf.Graphics.TtfCompositeGlyphFlags : Enum {
    public ushort value__;
    public static TtfCompositeGlyphFlags ARG_1_AND_2_ARE_WORDS;
    public static TtfCompositeGlyphFlags ARGS_ARE_XY_VALUES;
    public static TtfCompositeGlyphFlags ROUND_XY_TO_GRID;
    public static TtfCompositeGlyphFlags WE_HAVE_A_SCALE;
    public static TtfCompositeGlyphFlags RESERVED;
    public static TtfCompositeGlyphFlags MORE_COMPONENTS;
    public static TtfCompositeGlyphFlags WE_HAVE_AN_X_AND_Y_SCALE;
    public static TtfCompositeGlyphFlags WE_HAVE_A_TWO_BY_TWO;
    public static TtfCompositeGlyphFlags WE_HAVE_INSTRUCTIONS;
    public static TtfCompositeGlyphFlags USE_MY_METRICS;
}
internal enum Syncfusion.Pdf.Graphics.TtfMacintoshEncodingID : Enum {
    public int value__;
    public static TtfMacintoshEncodingID Roman;
    public static TtfMacintoshEncodingID Japanese;
    public static TtfMacintoshEncodingID Chinese;
}
internal enum Syncfusion.Pdf.Graphics.TtfMicrosoftEncodingID : Enum {
    public int value__;
    public static TtfMicrosoftEncodingID Undefined;
    public static TtfMicrosoftEncodingID Unicode;
    public static TtfMicrosoftEncodingID UnicodeUCS4;
}
internal enum Syncfusion.Pdf.Graphics.TtfNameID : Enum {
    public int value__;
    public static TtfNameID Copyright;
    public static TtfNameID FontFamily;
    public static TtfNameID FontSubFamily;
    public static TtfNameID FontIdentifier;
    public static TtfNameID FontName;
    public static TtfNameID Version;
    public static TtfNameID PostScriptName;
    public static TtfNameID Trademark;
}
internal enum Syncfusion.Pdf.Graphics.TtfPlatformID : Enum {
    public int value__;
    public static TtfPlatformID AppleUnicode;
    public static TtfPlatformID Macintosh;
    public static TtfPlatformID Iso;
    public static TtfPlatformID Microsoft;
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Syncfusion.Pdf.Graphics.TtfReader : object {
    internal static Encoding Encoding;
    internal static int WidthMultiplier;
    private static int c_ttfVersion1;
    private static int c_ttfVersion2;
    private static int c_macTtfVersion;
    private static int c_fp;
    private static String[] s_tableNames;
    private static String[] m_tableNames;
    private static Int16[] s_entrySelectors;
    private BigEndianReader m_reader;
    private Dictionary`2<string, TtfTableInfo> m_tableDirectory;
    private TtfMetrics m_metrics;
    private Single[] m_width;
    private Dictionary`2<int, TtfGlyphInfo> m_macintosh;
    private Dictionary`2<int, TtfGlyphInfo> m_microsoft;
    private Dictionary`2<int, TtfGlyphInfo> m_macintoshGlyphs;
    private Dictionary`2<int, TtfGlyphInfo> m_microsoftGlyphs;
    internal bool m_bIsLocaShort;
    private bool m_subset;
    private char m_surrogateHigh;
    private long m_lowestPosition;
    private int m_maxMacIndex;
    private bool m_isFontPresent;
    internal int m_missedGlyphs;
    private string metricsName;
    private bool m_isTtcFont;
    private bool m_isMacTTF;
    private string m_fontName;
    private bool m_isAzureCompatible;
    private Dictionary`2<int, TtfGlyphInfo> m_completeGlyph;
    internal int unitsPerEM;
    internal List`1<ScriptTags> supportedScriptTags;
    private Dictionary`2<int, TtfGlyphInfo> m_unicodeUCS4Glyph;
    private GSUBTable m_gsub;
    private GDEFTable m_gdef;
    private GPOSTable m_gpos;
    internal bool isOpenTypeFont;
    internal bool m_AnsiEncode;
    internal bool conformanceEnabled;
    internal int m_missedGlyphCount;
    internal int m_EmHeight;
    internal int m_CellAscent;
    internal int m_fsSelection;
    internal int m_stypoAscent;
    private long m_startOffset;
    private bool m_useFloatingFactorForMeasure;
    private static HashSet`1<string> glyphFonts;
    public BinaryReader Reader { get; public set; }
    internal bool IsFontPresent { get; }
    public BigEndianReader InternalReader { get; }
    public TtfMetrics Metrics { get; }
    internal Dictionary`2<string, TtfTableInfo> TableDirectory { get; }
    private Dictionary`2<int, TtfGlyphInfo> Macintosh { get; }
    private Dictionary`2<int, TtfGlyphInfo> Microsoft { get; }
    private Dictionary`2<int, TtfGlyphInfo> MacintoshGlyphs { get; }
    private Dictionary`2<int, TtfGlyphInfo> MicrosoftGlyphs { get; }
    internal GSUBTable GSUB { get; }
    internal GDEFTable GDEF { get; }
    internal GPOSTable GPOS { get; }
    internal Dictionary`2<int, TtfGlyphInfo> UnicodeUCS4Glyph { get; internal set; }
    internal Dictionary`2<int, TtfGlyphInfo> CompleteGlyph { get; }
    private String[] TableNames { get; }
    internal bool UseFloatingFactorForMeasure { get; }
    private static TtfReader();
    internal TtfReader(BinaryReader reader, string name);
    public TtfReader(BinaryReader reader);
    internal TtfReader(BinaryReader reader, bool isFloatingPointer);
    public BinaryReader get_Reader();
    public void set_Reader(BinaryReader value);
    internal bool get_IsFontPresent();
    public BigEndianReader get_InternalReader();
    public TtfMetrics get_Metrics();
    internal Dictionary`2<string, TtfTableInfo> get_TableDirectory();
    private Dictionary`2<int, TtfGlyphInfo> get_Macintosh();
    private Dictionary`2<int, TtfGlyphInfo> get_Microsoft();
    private Dictionary`2<int, TtfGlyphInfo> get_MacintoshGlyphs();
    private Dictionary`2<int, TtfGlyphInfo> get_MicrosoftGlyphs();
    internal GSUBTable get_GSUB();
    internal GDEFTable get_GDEF();
    internal GPOSTable get_GPOS();
    internal Dictionary`2<int, TtfGlyphInfo> get_UnicodeUCS4Glyph();
    internal void set_UnicodeUCS4Glyph(Dictionary`2<int, TtfGlyphInfo> value);
    internal Dictionary`2<int, TtfGlyphInfo> get_CompleteGlyph();
    private String[] get_TableNames();
    internal bool get_UseFloatingFactorForMeasure();
    public void Close();
    public TtfGlyphInfo GetGlyph(char charCode);
    public TtfGlyphInfo GetGlyph(int glyphIndex);
    internal bool IsFontContainsChar(int code);
    internal Stream ReadCffTable();
    internal List`1<TtfGlyphInfo> GetAllGlyphs();
    public void CreateInternals();
    public Byte[] ReadFontProgram(Dictionary`2<char, char> chars);
    internal Byte[] ReadOpenTypeFontProgram(Dictionary`2<int, OtfGlyphInfo> otGlyphs);
    public string ConvertString(string text);
    internal bool IsFontContainsString(string text);
    public float GetCharWidth(char code);
    internal Dictionary`2<int, int> GetGlyphChars(Dictionary`2<char, char> chars);
    private void Initialize();
    private void AddSupportedTags();
    private void ReadFontDirectory();
    private void FixOffsets();
    private void ReadMetrics();
    internal bool isOTFFont();
    private void InitializeMetrics(TtfNameTable nameTable, TtfHeadTable headTable, TtfHorizontalHeaderTable horizontalHeadTable, TtfOS2Table os2Table, TtfPostTable postTable, TtfCmapSubTable[] cmapTables);
    private TtfNameTable ReadNameTable();
    private TtfHeadTable ReadHeadTable();
    private TtfHorizontalHeaderTable ReadHorizontalHeaderTable();
    internal TtfGlyphInfo ReadGlyph(int index, bool isOpenType);
    private TtfOS2Table ReadOS2Table();
    private TtfPostTable ReadPostTable();
    private Single[] ReadWidthTable(int glyphCount, int unitsPerEm);
    private Single[] ReadWidthTable(int glyphCount, int gCount, int unitsPerEm);
    private TtfCmapSubTable[] ReadCmapTable();
    private void ReadCmapSubTable(TtfCmapSubTable subTable);
    private void ReadUCS4CmapTable(TtfCmapSubTable subTable, TtfCmapEncoding encoding);
    private void ReadAppleCmapTable(TtfCmapSubTable subTable, TtfCmapEncoding encoding);
    private void ReadMicrosoftCmapTable(TtfCmapSubTable subTable, TtfCmapEncoding encoding);
    private void ReadTrimmedCmapTable(TtfCmapSubTable subTable, TtfCmapEncoding encoding);
    private TtfLocaTable ReadLocaTable(bool bShort);
    private UInt16[] ReadUshortArray(int len);
    private UInt32[] ReadUintArray(int len);
    private void AddGlyph(TtfGlyphInfo glyph, TtfCmapEncoding encoding);
    private void AddGlyph(TtfGlyphInfo glyph, TtfCmapEncoding encoding, bool reverse);
    private float GetWidth(int glyphCode);
    private Single[] UpdateWidth();
    private void CheckPreambula();
    private TtfCmapEncoding GetCmapEncoding(int platformID, int encodingID);
    private TtfTableInfo GetTable(string name);
    private void UpdateGlyphChars(Dictionary`2<int, int> glyphChars, TtfLocaTable locaTable);
    private void ProcessCompositeGlyph(Dictionary`2<int, int> glyphChars, int glyph, TtfLocaTable locaTable);
    private UInt32 GenerateGlyphTable(Dictionary`2<int, int> glyphChars, TtfLocaTable locaTable, Int32[]& newLocaTable, Byte[]& newGlyphTable);
    private int UpdateLocaTable(Int32[] newLocaTable, bool bLocaIsShort, Byte[]& newLocaTableOut);
    private Byte[] GetFontProgram(Byte[] newLocaTableOut, Byte[] newGlyphTable, UInt32 glyphTableSize, UInt32 locaTableSize);
    private int GetFontProgramLength(Byte[] newLocaTableOut, Byte[] newGlyphTable, Int16& numTables);
    private int CalculateCheckSum(Byte[] bytes);
    private void WriteCheckSums(BigEndianWriter writer, short numTables, Byte[] newLocaTableOut, Byte[] newGlyphTable, UInt32 glyphTableSize, UInt32 locaTableSize);
    private void WriteGlyphs(BigEndianWriter writer, Byte[] newLocaTableOut, Byte[] newGlyphTable);
    private void InitializeFontName(TtfNameTable nameTable);
    private UInt32 Align(UInt32 value);
    private TtfGlyphInfo GetDefaultGlyph();
    private bool CompareArrays(Byte[] buff1, Byte[] buff2);
    private UInt32 FormatTableName(string name);
    internal Byte[] GetType0FontProgram();
    internal Dictionary`2<int, int> GetAllGlyphChars();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public abstract class Syncfusion.Pdf.Grid.GridCellLayoutEventArgs : EventArgs {
    private int m_rowIndex;
    private int m_cellIndex;
    private string m_value;
    private RectangleF m_bounds;
    private PdfGraphics m_graphics;
    private bool m_isHeaderRow;
    public int RowIndex { get; }
    public int CellIndex { get; }
    public string Value { get; }
    public RectangleF Bounds { get; }
    public PdfGraphics Graphics { get; }
    public bool IsHeaderRow { get; }
    internal GridCellLayoutEventArgs(PdfGraphics graphics, int rowIndex, int cellIndex, RectangleF bounds, string value, bool isHeaderRow);
    public int get_RowIndex();
    public int get_CellIndex();
    public string get_Value();
    public RectangleF get_Bounds();
    public PdfGraphics get_Graphics();
    public bool get_IsHeaderRow();
}
internal class Syncfusion.Pdf.Grid.NamespaceDoc : object {
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class Syncfusion.Pdf.Grid.PdfGrid : PdfLayoutElement {
    private PdfGridHeaderCollection m_headers;
    private PdfGridRowCollection m_rows;
    private object m_dataSource;
    private string m_dataMember;
    private PdfDataSource m_dsParser;
    private PdfGridStyle m_style;
    private PdfGridColumnCollection m_columns;
    private bool m_bRepeatHeader;
    private SizeF m_size;
    private bool m_breakRow;
    private bool m_isChildGrid;
    private PdfGridCell m_parentCell;
    private float m_initialWidth;
    private PdfLayoutFormat m_layoutFormat;
    internal bool isComplete;
    internal bool isWidthSet;
    internal int parentCellIndex;
    internal bool isDrawn;
    internal float m_rowLayoutBoundswidth;
    internal List`1<int> m_listOfNavigatePages;
    internal bool m_isRearranged;
    private bool m_headerRow;
    private bool m_bandedRow;
    private bool m_bandedColumn;
    private bool m_totalRow;
    private bool m_firstColumn;
    private bool m_lastColumn;
    internal RectangleF m_gridLocation;
    private bool m_isPageWidth;
    internal bool isBuiltinStyle;
    internal PdfGridBuiltinStyle m_gridBuiltinStyle;
    internal bool isSignleGrid;
    internal bool m_hasColumnSpan;
    internal bool m_hasRowSpanSpan;
    internal bool m_hasHTMLText;
    internal float parentGridWidth;
    [CompilerGeneratedAttribute]
private PdfGridBeginCellLayoutEventHandler BeginCellLayout;
    [CompilerGeneratedAttribute]
private PdfGridEndCellLayoutEventHandler EndCellLayout;
    public PdfGridHeaderCollection Headers { get; }
    public PdfGridRowCollection Rows { get; }
    public object DataSource { get; public set; }
    public string DataMember { get; public set; }
    public PdfGridStyle Style { get; public set; }
    internal PdfGridRow LastRow { get; }
    public PdfGridColumnCollection Columns { get; }
    public bool RepeatHeader { get; public set; }
    internal SizeF Size { get; }
    public bool AllowRowBreakAcrossPages { get; public set; }
    internal bool IsChildGrid { get; internal set; }
    internal PdfGridCell ParentCell { get; internal set; }
    internal PdfLayoutFormat LayoutFormat { get; internal set; }
    internal bool RaiseBeginCellLayout { get; }
    internal bool RaiseEndCellLayout { get; }
    internal bool IsPageWidth { get; internal set; }
    internal float InitialWidth { get; internal set; }
    public PdfGridHeaderCollection get_Headers();
    public PdfGridRowCollection get_Rows();
    public object get_DataSource();
    public void set_DataSource(object value);
    public string get_DataMember();
    public void set_DataMember(string value);
    public PdfGridStyle get_Style();
    public void set_Style(PdfGridStyle value);
    internal PdfGridRow get_LastRow();
    public PdfGridColumnCollection get_Columns();
    public bool get_RepeatHeader();
    public void set_RepeatHeader(bool value);
    internal SizeF get_Size();
    public bool get_AllowRowBreakAcrossPages();
    public void set_AllowRowBreakAcrossPages(bool value);
    internal bool get_IsChildGrid();
    internal void set_IsChildGrid(bool value);
    internal PdfGridCell get_ParentCell();
    internal void set_ParentCell(PdfGridCell value);
    internal PdfLayoutFormat get_LayoutFormat();
    internal void set_LayoutFormat(PdfLayoutFormat value);
    internal bool get_RaiseBeginCellLayout();
    internal bool get_RaiseEndCellLayout();
    internal bool get_IsPageWidth();
    internal void set_IsPageWidth(bool value);
    internal float get_InitialWidth();
    internal void set_InitialWidth(float value);
    [CompilerGeneratedAttribute]
public void add_BeginCellLayout(PdfGridBeginCellLayoutEventHandler value);
    [CompilerGeneratedAttribute]
public void remove_BeginCellLayout(PdfGridBeginCellLayoutEventHandler value);
    [CompilerGeneratedAttribute]
public void add_EndCellLayout(PdfGridEndCellLayoutEventHandler value);
    [CompilerGeneratedAttribute]
public void remove_EndCellLayout(PdfGridEndCellLayoutEventHandler value);
    public void Draw(PdfGraphics graphics, PointF location, float width);
    public void Draw(PdfGraphics graphics, float x, float y, float width);
    internal PdfGrid Clone(PdfGrid grid);
    public void Draw(PdfGraphics graphics, RectangleF bounds);
    public PdfGridLayoutResult Draw(PdfPage page, PointF location);
    public PdfGridLayoutResult Draw(PdfPage page, PointF location, PdfGridLayoutFormat format);
    public PdfGridLayoutResult Draw(PdfPage page, RectangleF bounds);
    public PdfGridLayoutResult Draw(PdfPage page, RectangleF bounds, PdfGridLayoutFormat format);
    public PdfGridLayoutResult Draw(PdfPage page, float x, float y);
    public PdfGridLayoutResult Draw(PdfPage page, float x, float y, PdfGridLayoutFormat format);
    public PdfGridLayoutResult Draw(PdfPage page, float x, float y, float width);
    public PdfGridLayoutResult Draw(PdfPage page, float x, float y, float width, PdfGridLayoutFormat format);
    protected virtual PdfLayoutResult Layout(PdfLayoutParams param);
    protected virtual void DrawInternal(PdfGraphics graphics);
    internal void SetSpan();
    private SizeF Measure();
    internal void OnBeginCellLayout(PdfGridBeginCellLayoutEventArgs args);
    internal void OnEndCellLayout(PdfGridEndCellLayoutEventArgs args);
    private void Dispose();
    public void ApplyBuiltinStyle(PdfGridBuiltinStyle gridStyle);
    internal void ApplyBuiltinStyles(PdfGridBuiltinStyle gridStyle);
    public void ApplyBuiltinStyle(PdfGridBuiltinStyle gridStyle, PdfGridBuiltinStyleSettings gridStyleSetting);
    private PdfFont CreateBoldFont(PdfFont font);
    private PdfFont CreateRegularFont(PdfFont font);
    private PdfFont CreateItalicFont(PdfFont font);
    private PdfFont ChangeFontStyle(PdfFont font);
    private PdfBrush ApplyBandedColStyle(bool firstColumn, Color backColor, int cellIndex);
    private PdfBrush ApplyBandedRowStyle(bool headerRow, Color backColor, int rowIndex);
    private void ApplyTableGridLight(Color borderColor);
    private void ApplyPlainTable1(Color borderColor, Color backColor);
    private void ApplyPlainTable2(Color borderColor);
    private void ApplyPlainTable3(Color borderColor, Color backColor);
    private void ApplyPlainTable4(Color backColor);
    private void ApplyPlainTable5(Color borderColor, Color backColor);
    private void ApplyGridTable1Light(Color borderColor, Color headerBottomColor);
    private void ApplyGridTable2(Color borderColor, Color backColor);
    private void ApplyGridTable3(Color borderColor, Color backColor);
    private void ApplyGridTable4(Color borderColor, Color backColor, Color headerBackColor);
    private void ApplyGridTable5Dark(Color headerBackColor, Color oddRowBackColor, Color evenRowBackColor);
    private void ApplyGridTable6Colorful(Color borderColor, Color backColor, Color textColor);
    private void ApplyGridTable7Colorful(Color borderColor, Color backColor, Color textColor);
    private void ApplyListTable1Light(Color borderColor, Color backColor);
    private void ApplyListTable2(Color borderColor, Color backColor);
    private void ApplyListTable3(Color backColor);
    private void ApplyListTable4(Color borderColor, Color headerBackColor, Color bandRowColor);
    private void ApplyListTable5Dark(Color backColor);
    private void ApplyListTable6Colorful(Color borderColor, Color backColor, Color textColor);
    private void ApplyListTable7Colorful(Color borderColor, Color backColor, Color textColor);
    private void SetDataSource();
    private void PopulateDataGrid();
    private void PopulateIEnumerableGrid();
    private void PopulateGrid();
    private void PopulateHeader();
    internal void MeasureColumnsWidth();
    internal void MeasureColumnsWidth(RectangleF bounds);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class Syncfusion.Pdf.Grid.PdfGridBeginCellLayoutEventArgs : GridCellLayoutEventArgs {
    private bool m_bSkip;
    private PdfGridCellStyle m_style;
    public bool Skip { get; public set; }
    public PdfGridCellStyle Style { get; public set; }
    internal PdfGridBeginCellLayoutEventArgs(PdfGraphics graphics, int rowIndex, int cellInder, RectangleF bounds, string value, PdfGridCellStyle style, bool isHeaderRow);
    public bool get_Skip();
    public void set_Skip(bool value);
    public PdfGridCellStyle get_Style();
    public void set_Style(PdfGridCellStyle value);
}
public class Syncfusion.Pdf.Grid.PdfGridBeginCellLayoutEventHandler : MulticastDelegate {
    public PdfGridBeginCellLayoutEventHandler(object object, IntPtr method);
    [NullableContextAttribute("1")]
public virtual void Invoke(object sender, PdfGridBeginCellLayoutEventArgs args);
    public virtual IAsyncResult BeginInvoke(object sender, PdfGridBeginCellLayoutEventArgs args, AsyncCallback callback, object object);
    public virtual void EndInvoke(IAsyncResult result);
}
public class Syncfusion.Pdf.Grid.PdfGridBeginPageLayoutEventArgs : BeginPageLayoutEventArgs {
    private int m_startRow;
    public int StartRowIndex { get; }
    [NullableContextAttribute("1")]
internal PdfGridBeginPageLayoutEventArgs(RectangleF bounds, PdfPage page, int startRow);
    public int get_StartRowIndex();
}
public class Syncfusion.Pdf.Grid.PdfGridBuiltinStyleSettings : object {
    private bool m_bandedColumns;
    private bool m_bandedRows;
    private bool m_firstColumn;
    private bool m_lastColumn;
    private bool m_headerRow;
    private bool m_lastRow;
    public bool ApplyStyleForBandedColumns { get; public set; }
    public bool ApplyStyleForBandedRows { get; public set; }
    public bool ApplyStyleForFirstColumn { get; public set; }
    public bool ApplyStyleForHeaderRow { get; public set; }
    public bool ApplyStyleForLastColumn { get; public set; }
    public bool ApplyStyleForLastRow { get; public set; }
    public bool get_ApplyStyleForBandedColumns();
    public void set_ApplyStyleForBandedColumns(bool value);
    public bool get_ApplyStyleForBandedRows();
    public void set_ApplyStyleForBandedRows(bool value);
    public bool get_ApplyStyleForFirstColumn();
    public void set_ApplyStyleForFirstColumn(bool value);
    public bool get_ApplyStyleForHeaderRow();
    public void set_ApplyStyleForHeaderRow(bool value);
    public bool get_ApplyStyleForLastColumn();
    public void set_ApplyStyleForLastColumn(bool value);
    public bool get_ApplyStyleForLastRow();
    public void set_ApplyStyleForLastRow(bool value);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class Syncfusion.Pdf.Grid.PdfGridCell : object {
    private float m_width;
    private float m_height;
    private int m_rowSpan;
    private int m_colSpan;
    private PdfGridRow m_row;
    private PdfGridCellStyle m_style;
    private object m_value;
    private PdfStringFormat m_format;
    private bool m_bIsCellMergeStart;
    private bool m_bIsCellMergeContinue;
    private bool m_bIsRowMergeStart;
    private bool m_bIsRowMergeContinue;
    private bool m_finsh;
    private string m_remainingString;
    internal bool present;
    private PdfGridCell m_parent;
    private float rowSpanRemainingHeight;
    private bool isHtmlText;
    internal int m_pageCount;
    private bool m_isImageDrawn;
    private float m_outerCellWidth;
    private PdfGridImagePosition m_imagePosition;
    private PdfGridStretchOption m_pdfGridStretchOption;
    internal float m_rowSpanRemainingHeight;
    internal RectangleF layoutBounds;
    internal PdfLayoutResult layoutResult;
    internal float tempHeight;
    private PdfTag m_tag;
    internal bool cellBorderCuttOffX;
    internal bool cellBorderCuttOffY;
    internal RectangleF parentLayoutBounds;
    internal bool m_isCellHeightSet;
    internal PdfGridLayouter pdfGridLayouter;
    private float gridWidth;
    public float Width { get; internal set; }
    public float Height { get; internal set; }
    public int RowSpan { get; public set; }
    public int ColumnSpan { get; public set; }
    public PdfGridCellStyle Style { get; public set; }
    public bool IsHtmlText { get; public set; }
    public object Value { get; public set; }
    public PdfStringFormat StringFormat { get; public set; }
    internal PdfGridRow Row { get; internal set; }
    internal bool IsCellMergeContinue { get; internal set; }
    internal bool IsCellMergeStart { get; internal set; }
    internal bool IsRowMergeStart { get; internal set; }
    internal bool IsRowMergeContinue { get; internal set; }
    internal PdfGridCell NextCell { get; }
    internal string RemainingString { get; internal set; }
    internal bool FinishedDrawingCell { get; internal set; }
    public PdfGridImagePosition ImagePosition { get; public set; }
    internal PdfGridStretchOption StretchOption { get; internal set; }
    public PdfTag PdfTag { get; public set; }
    public PdfGridCell(PdfGridRow row);
    public float get_Width();
    internal void set_Width(float value);
    public float get_Height();
    internal void set_Height(float value);
    public int get_RowSpan();
    public void set_RowSpan(int value);
    public int get_ColumnSpan();
    public void set_ColumnSpan(int value);
    public PdfGridCellStyle get_Style();
    public void set_Style(PdfGridCellStyle value);
    public bool get_IsHtmlText();
    public void set_IsHtmlText(bool value);
    public object get_Value();
    public void set_Value(object value);
    public PdfStringFormat get_StringFormat();
    public void set_StringFormat(PdfStringFormat value);
    internal PdfGridRow get_Row();
    internal void set_Row(PdfGridRow value);
    internal bool get_IsCellMergeContinue();
    internal void set_IsCellMergeContinue(bool value);
    internal bool get_IsCellMergeStart();
    internal void set_IsCellMergeStart(bool value);
    internal bool get_IsRowMergeStart();
    internal void set_IsRowMergeStart(bool value);
    internal bool get_IsRowMergeContinue();
    internal void set_IsRowMergeContinue(bool value);
    internal PdfGridCell get_NextCell();
    internal string get_RemainingString();
    internal void set_RemainingString(string value);
    internal bool get_FinishedDrawingCell();
    internal void set_FinishedDrawingCell(bool value);
    public PdfGridImagePosition get_ImagePosition();
    public void set_ImagePosition(PdfGridImagePosition value);
    internal PdfGridStretchOption get_StretchOption();
    internal void set_StretchOption(PdfGridStretchOption value);
    public PdfTag get_PdfTag();
    public void set_PdfTag(PdfTag value);
    internal PdfStringLayoutResult Draw(PdfGraphics graphics, RectangleF bounds, bool cancelSubsequentSpans);
    private void DrawParentCells(PdfGraphics graphics, RectangleF bounds, bool b);
    internal PdfGridCell Clone(PdfGridCell gridcell);
    private float MeasureWidth();
    internal float MeasureHeight();
    private RectangleF AdjustOuterLayoutArea(RectangleF bounds, PdfGraphics g);
    private RectangleF AdjustContentLayoutArea(RectangleF bounds);
    private bool CheckLastCell(int spanCount);
    internal void DrawCellBorders(PdfGraphics& graphics, RectangleF bounds);
    private void SetTransparency(PdfGraphics& graphics, PdfPen pen);
    private PdfGridCell ObtainNextCell();
    internal void DrawCellBackground(PdfGraphics& graphics, RectangleF bounds);
    private PdfStringFormat ObtainStringFormat();
    private PdfFont GetTextFont();
    private PdfBrush GetTextBrush();
    private PdfPen GetTextPen();
    private PdfBrush GetBackgroundBrush();
    private float CalculateWidth();
    private float GetColumnWidth();
    private float FindInitialWidthFromParentGrid(PdfGridRow row);
    private float FindGridColumnWidth(PdfGridCell pdfGridCell);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[DefaultMemberAttribute("Item")]
public class Syncfusion.Pdf.Grid.PdfGridCellCollection : object {
    private PdfGridRow m_row;
    private List`1<PdfGridCell> m_cells;
    public PdfGridCell Item { get; }
    public int Count { get; }
    internal PdfGridCellCollection(PdfGridRow row);
    public PdfGridCell get_Item(int index);
    public int get_Count();
    internal PdfGridCell Add();
    internal void Add(PdfGridCell cell);
    public int IndexOf(PdfGridCell cell);
    public sealed virtual IEnumerator GetEnumerator();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class Syncfusion.Pdf.Grid.PdfGridCellStyle : PdfGridRowStyle {
    private PdfBorders m_borders;
    private PdfPaddings m_cellPadding;
    private PdfEdges m_edges;
    private PdfStringFormat m_format;
    private PdfImage m_backgroundImage;
    public PdfStringFormat StringFormat { get; public set; }
    public PdfBorders Borders { get; public set; }
    public PdfImage BackgroundImage { get; public set; }
    internal PdfEdges Edges { get; internal set; }
    public PdfPaddings CellPadding { get; public set; }
    public PdfStringFormat get_StringFormat();
    public void set_StringFormat(PdfStringFormat value);
    public PdfBorders get_Borders();
    public void set_Borders(PdfBorders value);
    public PdfImage get_BackgroundImage();
    public void set_BackgroundImage(PdfImage value);
    internal PdfEdges get_Edges();
    internal void set_Edges(PdfEdges value);
    public PdfPaddings get_CellPadding();
    public void set_CellPadding(PdfPaddings value);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class Syncfusion.Pdf.Grid.PdfGridColumn : object {
    private PdfGrid m_grid;
    internal float m_width;
    internal bool isCustomWidth;
    private PdfStringFormat m_format;
    public float Width { get; public set; }
    public PdfStringFormat Format { get; public set; }
    public PdfGrid Grid { get; }
    public PdfGridColumn(PdfGrid grid);
    public float get_Width();
    public void set_Width(float value);
    public PdfStringFormat get_Format();
    public void set_Format(PdfStringFormat value);
    public PdfGrid get_Grid();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[DefaultMemberAttribute("Item")]
public class Syncfusion.Pdf.Grid.PdfGridColumnCollection : object {
    private PdfGrid m_grid;
    private List`1<PdfGridColumn> _mColumns;
    private float m_width;
    private float m_previousCellsCount;
    public PdfGridColumn Item { get; }
    public int Count { get; }
    internal float Width { get; }
    public PdfGridColumnCollection(PdfGrid grid);
    public PdfGridColumn get_Item(int index);
    public int get_Count();
    internal float get_Width();
    internal void Clear();
    public PdfGridColumn Add();
    public void Add(int count);
    public void Add(PdfGridColumn column);
    internal void AddColumns(int count);
    internal float MeasureColumnsWidth();
    internal Single[] GetDefaultWidths(float totalWidth);
    public sealed virtual IEnumerator GetEnumerator();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class Syncfusion.Pdf.Grid.PdfGridEndCellLayoutEventArgs : GridCellLayoutEventArgs {
    private PdfGridCellStyle m_style;
    public PdfGridCellStyle Style { get; }
    internal PdfGridEndCellLayoutEventArgs(PdfGraphics graphics, int rowIndex, int cellInder, RectangleF bounds, string value, PdfGridCellStyle style, bool isHeaderRow);
    public PdfGridCellStyle get_Style();
}
public class Syncfusion.Pdf.Grid.PdfGridEndCellLayoutEventHandler : MulticastDelegate {
    public PdfGridEndCellLayoutEventHandler(object object, IntPtr method);
    [NullableContextAttribute("1")]
public virtual void Invoke(object sender, PdfGridEndCellLayoutEventArgs args);
    public virtual IAsyncResult BeginInvoke(object sender, PdfGridEndCellLayoutEventArgs args, AsyncCallback callback, object object);
    public virtual void EndInvoke(IAsyncResult result);
}
public class Syncfusion.Pdf.Grid.PdfGridEndPageLayoutEventArgs : EndPageLayoutEventArgs {
    [NullableContextAttribute("1")]
internal PdfGridEndPageLayoutEventArgs(PdfLayoutResult result);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[DefaultMemberAttribute("Item")]
public class Syncfusion.Pdf.Grid.PdfGridHeaderCollection : object {
    internal PdfGrid m_grid;
    private List`1<PdfGridRow> _mRows;
    public PdfGridRow Item { get; }
    public int Count { get; }
    public PdfGridHeaderCollection(PdfGrid grid);
    public PdfGridRow get_Item(int index);
    public int get_Count();
    internal void Add(PdfGridRow row);
    public PdfGridRow[] Add(int count);
    public void Clear();
    public void ApplyStyle(PdfGridStyleBase style);
    internal int IndexOf(PdfGridRow row);
    public sealed virtual IEnumerator GetEnumerator();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Syncfusion.Pdf.Grid.PdfGridLayouter : ElementLayouter {
    private PdfGraphics m_currentGraphics;
    private PdfPage m_currentPage;
    private SizeF m_currentPageBounds;
    private RectangleF m_currentBounds;
    private List`1<Int32[]> m_columnRanges;
    private int m_cellStartIndex;
    private int m_cellEndIndex;
    private int m_currentRowIndex;
    private PointF m_startLocation;
    private float m_newheight;
    internal static int m_repeatRowIndex;
    private bool isChanged;
    private PointF m_currentLocation;
    private PdfHorizontalOverflowType m_hType;
    private bool flag;
    private float m_childHeight;
    private List`1<int> m_parentCellIndexList;
    private bool isChildGrid;
    private int m_rowBreakPageHeightCellIndex;
    private bool m_isHeader;
    private bool isPaginate;
    private float userHeight;
    private RectangleF m_cellEventBounds;
    private bool m_GridPaginated;
    private PdfStringLayoutResult slr;
    private string remainderText;
    internal bool paginateWithRowBreak;
    internal bool paginateWithoutRowBreak;
    internal bool drawFinalRow;
    internal float endPageHeight;
    internal float currentRowHeight;
    internal int previousPageIndex;
    internal string remainingStringValue;
    private bool drawPaginateHeader;
    internal bool cellInnerGrid;
    private float m_initialHeight;
    internal PdfTextLayoutResult currentHtmlLayoutResult;
    internal PdfLayoutParams pdfLayoutParams;
    internal PdfGrid Grid { get; }
    internal PdfGridLayouter(PdfGrid grid);
    private static PdfGridLayouter();
    internal PdfGrid get_Grid();
    public void Layout(PdfGraphics graphics, PointF location);
    public void Layout(PdfGraphics graphics, RectangleF bounds);
    protected virtual PdfLayoutResult LayoutInternal(PdfLayoutParams param);
    private PdfGridLayoutResult LayoutOnPage(PdfLayoutParams param);
    private bool DrawParentGridRow(PdfGrid grid);
    private void ReArrangePages(Dictionary`2<PdfPage, Int32[]> layoutedPages);
    private RowLayoutResult DrawRow(PdfGridRow row);
    private bool IsRowHasBackgorundImage(PdfGridRow row);
    private void DrawRowWithBreak(RowLayoutResult& result, PdfGridRow row, float height);
    private void DrawRow(RowLayoutResult& result, PdfGridRow row, float height);
    private float ReCalculateHeight(PdfGridRow row, float height);
    private bool RaiseBeforePageLayout(PdfPage currentPage, RectangleF& currentBounds, Int32& currentRow);
    private PdfGridEndPageLayoutEventArgs RaisePageLayouted(PdfLayoutResult result);
    private PdfGridBeginCellLayoutEventArgs RaiseBeforeCellLayout(PdfGraphics graphics, int rowIndex, int cellIndex, RectangleF bounds, string value, PdfGridCellStyle& style, bool isHeaderRow);
    private void RaiseAfterCellLayout(PdfGraphics graphics, int rowIndex, int cellIndex, RectangleF bounds, string value, PdfGridCellStyle cellstyle, bool isHeaderRow);
    private bool CheckIfDefaultFormat(PdfStringFormat format);
    private void DetermineColumnDrawRanges();
    private void ReArrangePages(PdfPage page);
    public PdfPage GetNextPage(PdfLayoutFormat format);
    private PdfGridLayoutFormat GetFormat(PdfLayoutFormat format);
    private PdfGridLayoutResult GetLayoutResult();
    private bool IsFitToCell(float currentHeight, PdfGrid grid, PdfGridRow gridRow);
}
public class Syncfusion.Pdf.Grid.PdfGridLayoutFormat : PdfLayoutFormat {
    [NullableContextAttribute("1")]
public PdfGridLayoutFormat(PdfLayoutFormat baseFormat);
}
public class Syncfusion.Pdf.Grid.PdfGridLayoutResult : PdfLayoutResult {
    [NullableContextAttribute("1")]
public PdfGridLayoutResult(PdfPage page, RectangleF bounds);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class Syncfusion.Pdf.Grid.PdfGridRow : object {
    private PdfGridCellCollection m_cells;
    private PdfGrid m_grid;
    private PdfGridRowStyle m_style;
    private float m_height;
    private float m_width;
    private bool m_bRowSpanExists;
    private bool m_bColumnSpanExists;
    private float m_rowBreakHeight;
    private int m_rowOverflowIndex;
    private PdfLayoutResult m_gridResult;
    internal bool isRowBreaksNextPage;
    internal float rowBreakHeight;
    internal bool isrowFinish;
    internal bool isComplete;
    private bool m_rowMergeComplete;
    internal int m_noOfPageCount;
    internal bool m_isRowHeightSet;
    private PdfTag m_tag;
    internal int maximumRowSpan;
    internal bool isPageBreakRowSpanApplied;
    internal bool m_isRowSpanRowHeightSet;
    internal float m_rowSpanRemainingHeight;
    internal bool m_isHeaderRow;
    internal bool m_drawCellBroders;
    internal float m_borderReminingHeight;
    internal bool m_paginatedGridRow;
    public PdfGridCellCollection Cells { get; }
    internal PdfGrid Grid { get; internal set; }
    internal bool IsHeaderRow { get; internal set; }
    public PdfGridRowStyle Style { get; public set; }
    public float Height { get; public set; }
    internal float Width { get; }
    internal bool RowSpanExists { get; internal set; }
    internal bool ColumnSpanExists { get; internal set; }
    internal float RowBreakHeight { get; internal set; }
    internal int RowOverflowIndex { get; internal set; }
    internal PdfLayoutResult NestedGridLayoutResult { get; internal set; }
    internal int RowIndex { get; }
    internal bool RowMergeComplete { get; internal set; }
    public PdfTag PdfTag { get; public set; }
    public PdfGridRow(PdfGrid grid);
    public PdfGridCellCollection get_Cells();
    internal PdfGrid get_Grid();
    internal void set_Grid(PdfGrid value);
    internal bool get_IsHeaderRow();
    internal void set_IsHeaderRow(bool value);
    public PdfGridRowStyle get_Style();
    public void set_Style(PdfGridRowStyle value);
    public float get_Height();
    public void set_Height(float value);
    internal float get_Width();
    internal bool get_RowSpanExists();
    internal void set_RowSpanExists(bool value);
    internal bool get_ColumnSpanExists();
    internal void set_ColumnSpanExists(bool value);
    internal float get_RowBreakHeight();
    internal void set_RowBreakHeight(float value);
    internal int get_RowOverflowIndex();
    internal void set_RowOverflowIndex(int value);
    internal PdfLayoutResult get_NestedGridLayoutResult();
    internal void set_NestedGridLayoutResult(PdfLayoutResult value);
    internal int get_RowIndex();
    internal bool get_RowMergeComplete();
    internal void set_RowMergeComplete(bool value);
    public PdfTag get_PdfTag();
    public void set_PdfTag(PdfTag value);
    private float MeasureHeight();
    private float MeasureWidth();
    public void ApplyStyle(PdfGridCellStyle cellStyle);
    internal PdfGridRow CloneGridRow();
}
[NullableContextAttribute("1")]
[NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public class Syncfusion.Pdf.Grid.PdfGridRowCollection : List`1<PdfGridRow> {
    private PdfGrid m_grid;
    internal PdfGridRowCollection(PdfGrid grid);
    public PdfGridRow Add();
    public void Add(PdfGridRow row);
    public void SetSpan(int rowIndex, int cellIndex, int rowSpan, int colSpan);
    public void ApplyStyle(PdfGridStyleBase style);
}
public class Syncfusion.Pdf.Grid.PdfGridRowStyle : PdfGridStyleBase {
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class Syncfusion.Pdf.Grid.PdfGridStyle : PdfGridStyleBase {
    private float m_cellSpacing;
    private PdfPaddings m_cellPadding;
    private PdfBorderOverlapStyle m_borderOverlapStyle;
    private bool m_bAllowHorizontalOverflow;
    private PdfHorizontalOverflowType m_HorizontalOverflowType;
    public float CellSpacing { get; public set; }
    public PdfPaddings CellPadding { get; public set; }
    public PdfBorderOverlapStyle BorderOverlapStyle { get; public set; }
    public bool AllowHorizontalOverflow { get; public set; }
    public PdfHorizontalOverflowType HorizontalOverflowType { get; public set; }
    public float get_CellSpacing();
    public void set_CellSpacing(float value);
    public PdfPaddings get_CellPadding();
    public void set_CellPadding(PdfPaddings value);
    public PdfBorderOverlapStyle get_BorderOverlapStyle();
    public void set_BorderOverlapStyle(PdfBorderOverlapStyle value);
    public bool get_AllowHorizontalOverflow();
    public void set_AllowHorizontalOverflow(bool value);
    public PdfHorizontalOverflowType get_HorizontalOverflowType();
    public void set_HorizontalOverflowType(PdfHorizontalOverflowType value);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public abstract class Syncfusion.Pdf.Grid.PdfGridStyleBase : object {
    private PdfBrush m_backgroundBrush;
    private PdfBrush m_textBrush;
    private PdfPen m_textPen;
    private PdfFont m_font;
    private PdfPaddings m_gridCellpadding;
    public PdfBrush BackgroundBrush { get; public set; }
    public PdfBrush TextBrush { get; public set; }
    public PdfPen TextPen { get; public set; }
    public PdfFont Font { get; public set; }
    internal PdfPaddings GridCellPadding { get; internal set; }
    public PdfBrush get_BackgroundBrush();
    public void set_BackgroundBrush(PdfBrush value);
    public PdfBrush get_TextBrush();
    public void set_TextBrush(PdfBrush value);
    public PdfPen get_TextPen();
    public void set_TextPen(PdfPen value);
    public PdfFont get_Font();
    public void set_Font(PdfFont value);
    internal PdfPaddings get_GridCellPadding();
    internal void set_GridCellPadding(PdfPaddings value);
    public sealed virtual object Clone();
}
public enum Syncfusion.Pdf.Grid.PdfHorizontalOverflowType : Enum {
    public int value__;
    public static PdfHorizontalOverflowType NextPage;
    public static PdfHorizontalOverflowType LastPage;
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Syncfusion.Pdf.Head : TableBase {
    private ushort macStyle;
    private ushort m_flags;
    private short m_glyphDataFormat;
    private ushort m_unitsPerEm;
    private int m_id;
    private RectangleF m_bbox;
    private short m_indexFormat;
    internal int Id { get; }
    public ushort Flags { get; private set; }
    public short GlyphDataFormat { get; private set; }
    public ushort UnitsPerEm { get; private set; }
    public RectangleF BBox { get; private set; }
    public short IndexToLocFormat { get; private set; }
    public bool IsBold { get; }
    public bool IsItalic { get; }
    public Head(FontFile2 fontFile);
    internal virtual int get_Id();
    public ushort get_Flags();
    private void set_Flags(ushort value);
    public short get_GlyphDataFormat();
    private void set_GlyphDataFormat(short value);
    public ushort get_UnitsPerEm();
    private void set_UnitsPerEm(ushort value);
    public RectangleF get_BBox();
    private void set_BBox(RectangleF value);
    public short get_IndexToLocFormat();
    private void set_IndexToLocFormat(short value);
    public bool get_IsBold();
    public bool get_IsItalic();
    private bool CheckMacStyle(byte bit);
    public virtual void Read(ReadFontArray reader);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Syncfusion.Pdf.HtmlToPdf.HtmlHyperLink : object {
    private RectangleF m_bounds;
    private string m_href;
    private string m_name;
    private string m_hash;
    public RectangleF Bounds { get; public set; }
    internal string Hash { get; internal set; }
    internal string Name { get; internal set; }
    public string Href { get; public set; }
    public HtmlHyperLink(RectangleF Bounds, string Href);
    public RectangleF get_Bounds();
    public void set_Bounds(RectangleF value);
    internal string get_Hash();
    internal void set_Hash(string value);
    internal string get_Name();
    internal void set_Name(string value);
    public string get_Href();
    public void set_Href(string value);
    internal void ConvertBoundsToPoint();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Syncfusion.Pdf.HtmlToPdf.HtmlInternalLink : object {
    private string m_href;
    private string m_sourcePageNumber;
    private RectangleF m_bounds;
    private string m_headerTagLevel;
    private string m_id;
    private string m_headerContent;
    private int m_destinationPageNumber;
    private PointF m_destination;
    private PdfPageBase m_destinationPage;
    private float m_tocXcoordinate;
    private float m_tocRectangleHeight;
    private int m_tocPagecount;
    private float m_bottomMargin;
    private static int maxHeaderLevel;
    internal string Href { get; internal set; }
    internal string SourcePageNumber { get; internal set; }
    internal RectangleF Bounds { get; internal set; }
    internal string HeaderTagLevel { get; internal set; }
    internal string ID { get; internal set; }
    internal string HeaderContent { get; internal set; }
    internal int DestinationPageNumber { get; internal set; }
    internal PdfPageBase DestinationPage { get; internal set; }
    internal PointF Destination { get; internal set; }
    internal float TocXcoordinate { get; internal set; }
    internal float TocRectHeight { get; internal set; }
    internal int TocPageCount { get; internal set; }
    internal string get_Href();
    internal void set_Href(string value);
    internal string get_SourcePageNumber();
    internal void set_SourcePageNumber(string value);
    internal RectangleF get_Bounds();
    internal void set_Bounds(RectangleF value);
    internal string get_HeaderTagLevel();
    internal void set_HeaderTagLevel(string value);
    internal string get_ID();
    internal void set_ID(string value);
    internal string get_HeaderContent();
    internal void set_HeaderContent(string value);
    internal int get_DestinationPageNumber();
    internal void set_DestinationPageNumber(int value);
    internal PdfPageBase get_DestinationPage();
    internal void set_DestinationPage(PdfPageBase value);
    internal PointF get_Destination();
    internal void set_Destination(PointF value);
    internal float get_TocXcoordinate();
    internal void set_TocXcoordinate(float value);
    internal float get_TocRectHeight();
    internal void set_TocRectHeight(float value);
    internal int get_TocPageCount();
    internal void set_TocPageCount(int value);
    internal void AddBookmark(PdfPage page, PdfDocument lDoc, List`1<HtmlInternalLink> internalLinkCollection);
    private void AddChildBookmark(int index, PdfDocument lDoc, PdfBookmark[] bookmarkCollection, int prevIndex, List`1<HtmlInternalLink> internalLinkCollection);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Syncfusion.Pdf.HtmlToPdf.HtmlToPdfAutoCreateForms : object {
    private string m_elementId;
    private string m_elementValue;
    private bool m_isReadOnly;
    private bool m_isSelected;
    private string m_elementType;
    private int m_elementPageNo;
    private RectangleF m_elementBounds;
    private string m_optionValue;
    internal string OptionValue { get; internal set; }
    internal string ElementId { get; internal set; }
    internal string ElementValue { get; internal set; }
    internal bool IsReadOnly { get; internal set; }
    internal bool IsSelected { get; internal set; }
    internal string ElementType { get; internal set; }
    internal int ElementPageNo { get; internal set; }
    internal RectangleF ElementBounds { get; internal set; }
    internal HtmlToPdfAutoCreateForms(string id, string value, bool isReadonly, bool selected, string type, int pageNo, RectangleF bounds, string optionValue);
    internal string get_OptionValue();
    internal void set_OptionValue(string value);
    internal string get_ElementId();
    internal void set_ElementId(string value);
    internal string get_ElementValue();
    internal void set_ElementValue(string value);
    internal bool get_IsReadOnly();
    internal void set_IsReadOnly(bool value);
    internal bool get_IsSelected();
    internal void set_IsSelected(bool value);
    internal string get_ElementType();
    internal void set_ElementType(string value);
    internal int get_ElementPageNo();
    internal void set_ElementPageNo(int value);
    internal RectangleF get_ElementBounds();
    internal void set_ElementBounds(RectangleF value);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Syncfusion.Pdf.HtmlToPdf.HtmlToPdfFormat : object {
    private bool m_boundsSet;
    private RectangleF m_paginateBounds;
    private PdfLayoutType m_layout;
    private PdfLayoutBreakType m_break;
    private bool m_splitTextLines;
    private bool m_splitImages;
    internal float TotalPageLayoutSize;
    internal int PageCount;
    internal int PageNumber;
    internal double TotalPageSize;
    private ImageRegionManager m_imageRegionManager;
    private TextRegionManager m_textRegionManager;
    private ImageRegionManager m_formRegionManager;
    private List`1<HtmlHyperLink> m_htmlHyperlinksCollection;
    private List`1<HtmlInternalLink> m_htmlInternalLinksCollection;
    public bool SplitTextLines { get; public set; }
    public bool SplitImages { get; public set; }
    public PdfLayoutType Layout { get; public set; }
    public PdfLayoutBreakType Break { get; public set; }
    public RectangleF PaginateBounds { get; public set; }
    internal TextRegionManager TextRegionManager { get; internal set; }
    internal List`1<HtmlHyperLink> HtmlHyperlinksCollection { get; internal set; }
    internal List`1<HtmlInternalLink> HtmlInternalLinksCollection { get; internal set; }
    internal ImageRegionManager ImageRegionManager { get; internal set; }
    internal ImageRegionManager FormRegionManager { get; internal set; }
    internal bool UsePaginateBounds { get; }
    public bool get_SplitTextLines();
    public void set_SplitTextLines(bool value);
    public bool get_SplitImages();
    public void set_SplitImages(bool value);
    public PdfLayoutType get_Layout();
    public void set_Layout(PdfLayoutType value);
    public PdfLayoutBreakType get_Break();
    public void set_Break(PdfLayoutBreakType value);
    public RectangleF get_PaginateBounds();
    public void set_PaginateBounds(RectangleF value);
    internal TextRegionManager get_TextRegionManager();
    internal void set_TextRegionManager(TextRegionManager value);
    internal List`1<HtmlHyperLink> get_HtmlHyperlinksCollection();
    internal void set_HtmlHyperlinksCollection(List`1<HtmlHyperLink> value);
    internal List`1<HtmlInternalLink> get_HtmlInternalLinksCollection();
    internal void set_HtmlInternalLinksCollection(List`1<HtmlInternalLink> value);
    internal ImageRegionManager get_ImageRegionManager();
    internal void set_ImageRegionManager(ImageRegionManager value);
    internal ImageRegionManager get_FormRegionManager();
    internal void set_FormRegionManager(ImageRegionManager value);
    internal bool get_UsePaginateBounds();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class Syncfusion.Pdf.HtmlToPdf.HtmlToPdfLayoutParams : PdfLayoutParams {
    private PdfPage m_page;
    private Single[] m_verticalOffsets;
    private RectangleF m_bounds;
    private PdfLayoutFormat m_format;
    public PdfPage Page { get; public set; }
    public RectangleF Bounds { get; public set; }
    public Single[] VerticalOffsets { get; public set; }
    public PdfLayoutFormat Format { get; public set; }
    public PdfPage get_Page();
    public void set_Page(PdfPage value);
    public RectangleF get_Bounds();
    public void set_Bounds(RectangleF value);
    public Single[] get_VerticalOffsets();
    public void set_VerticalOffsets(Single[] value);
    public PdfLayoutFormat get_Format();
    public void set_Format(PdfLayoutFormat value);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Syncfusion.Pdf.HtmlToPdf.HtmlToPdfParams : object {
    private PdfPage m_page;
    private RectangleF m_bounds;
    private HtmlToPdfFormat m_format;
    private bool isSinglePageLayout;
    public PdfPage Page { get; public set; }
    public RectangleF Bounds { get; public set; }
    public HtmlToPdfFormat Format { get; public set; }
    internal bool SinglePageLayout { get; internal set; }
    public PdfPage get_Page();
    public void set_Page(PdfPage value);
    public RectangleF get_Bounds();
    public void set_Bounds(RectangleF value);
    public HtmlToPdfFormat get_Format();
    public void set_Format(HtmlToPdfFormat value);
    internal bool get_SinglePageLayout();
    internal void set_SinglePageLayout(bool value);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Syncfusion.Pdf.HtmlToPdf.HtmlToPdfResult : object {
    private HtmlToPdfToc m_toc;
    private bool m_enableBookmark;
    private bool m_enableToc;
    private SinglePageLayout m_singlePageLayout;
    private bool m_isTempDir;
    private bool m_disableIEWarning;
    private bool m_disableWebKitWarning;
    private List`1<HtmlHyperLink> m_WebKitHyperlinkCollection;
    private List`1<HtmlInternalLink> m_WebKitInternalLinkCollection;
    private List`1<HtmlInternalLink> m_internalLinkDestination;
    private List`1<HtmlToPdfAutoCreateForms> m_webkitAutoCreateForms;
    private Image[] m_images;
    private PointF m_location;
    private float m_metafileTransparency;
    private long m_quality;
    private Stream m_docStream;
    private bool m_Completed;
    private bool m_enableForm;
    private float m_height;
    private float m_remHeight;
    private PdfLayoutResult m_layoutResult;
    private bool m_isImagePath;
    private static int m_splitOffset;
    internal string WebKitFilePath;
    internal string RenderEngine;
    internal string baseURL;
    internal bool m_enableDirectLayout;
    private PdfLayoutResult[] layoutDetails;
    private static string TEXTBOX;
    private static string INPUT;
    private static string TEXTAREA;
    private static string SUBMIT;
    private static string BUTTON;
    private static string CHECKBOX;
    private static string RADIOBUTTON;
    private static string SELECTBOX;
    private static string READONLY;
    private static string CHECKED;
    private static string SELECTED;
    private static string PASSWORD;
    private static string NUMBER;
    private static string TEL;
    private static string EMAIL;
    private static string FORMBEGIN;
    private static string FORMEND;
    private PdfDocument singlePdfDoc;
    internal bool EnableBookmark { get; internal set; }
    internal bool EnableToc { get; internal set; }
    internal HtmlToPdfToc Toc { get; internal set; }
    internal bool IsImagePath { get; internal set; }
    internal bool DisableIEWarning { get; internal set; }
    internal bool DisableWebKitWarning { get; internal set; }
    internal bool Completed { get; }
    internal bool EnableForms { get; internal set; }
    internal float Height { get; }
    public Image RenderedImage { get; }
    public Image[] Images { get; }
    unknown long Quality {public set; }
    public PointF Location { get; public set; }
    public float MetafileTransparency { get; public set; }
    internal PdfLayoutResult LayoutResult { get; }
    internal SinglePageLayout SinglePageLayout { get; internal set; }
    internal bool IsTempDirectory { get; internal set; }
    internal bool get_EnableBookmark();
    internal void set_EnableBookmark(bool value);
    internal bool get_EnableToc();
    internal void set_EnableToc(bool value);
    internal HtmlToPdfToc get_Toc();
    internal void set_Toc(HtmlToPdfToc value);
    internal bool get_IsImagePath();
    internal void set_IsImagePath(bool value);
    internal bool get_DisableIEWarning();
    internal void set_DisableIEWarning(bool value);
    internal bool get_DisableWebKitWarning();
    internal void set_DisableWebKitWarning(bool value);
    internal bool get_Completed();
    internal bool get_EnableForms();
    internal void set_EnableForms(bool value);
    internal float get_Height();
    public Image get_RenderedImage();
    public Image[] get_Images();
    public void set_Quality(long value);
    public PointF get_Location();
    public void set_Location(PointF value);
    public float get_MetafileTransparency();
    public void set_MetafileTransparency(float value);
    internal PdfLayoutResult get_LayoutResult();
    internal SinglePageLayout get_SinglePageLayout();
    internal void set_SinglePageLayout(SinglePageLayout value);
    internal bool get_IsTempDirectory();
    internal void set_IsTempDirectory(bool value);
    private void DeleteFile(string filePath);
    public void Render(PdfDocument document);
    internal PdfDocument Render(PdfDocument document, PdfMetafileLayoutFormat metafileFormat);
    public void Render(PdfPageBase page, PdfLayoutFormat format);
    public void Render(PdfPageBase page, PdfLayoutFormat format, PdfLayoutResult& result);
    private void AddWebKitWarningWatermark(PdfPage page);
    private void AddIEWarningWatermark(PdfPage page);
    private PdfLayoutResult RenderWebKit(PdfPageBase page, PdfLayoutFormat format);
    internal void UpdateFormBounds(SizeF size);
    internal void updateInternalLink();
    internal void createPdfForms(PdfDocument lDoc);
    private sealed virtual override void System.IDisposable.Dispose();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class Syncfusion.Pdf.HtmlToPdf.HtmlToPdfToc : object {
    private string m_title;
    private PdfTextAlignment m_titleAlignment;
    private HtmlToPdfTocStyle m_titleStyle;
    private HtmlToPdfTocStyle m_headerStyle;
    private TabLeaderStyle m_tabLeader;
    private int m_tocPageCount;
    private bool m_isBlinkRenderingEngine;
    private char m_dotStyle;
    private char m_tabLeaderChar;
    private int m_maximumHeaderLevel;
    private int m_startingPageNumber;
    private bool isNextPage;
    private bool isFirstPage;
    private bool isTabLeaderChar;
    private PdfLayoutResult m_pageLayoutResult;
    private float m_pageLayoutBottom;
    private PdfTemplate m_template;
    private PdfPage m_pageTemplate;
    private List`1<HtmlToPdfTocStyle> m_headerStyleCollection;
    private static int beginRect;
    private static int beginTitle;
    private static int leftRectPadding;
    private static int rightRectPadding;
    private static int rectLineSpacing;
    private static int maxHeaderLevel;
    private float m_headerHeight;
    private float m_footerHeight;
    public string Title { get; public set; }
    public PdfTextAlignment TitleAlignment { get; public set; }
    public HtmlToPdfTocStyle TitleStyle { get; public set; }
    public TabLeaderStyle TabLeader { get; public set; }
    public char TabLeaderChar { get; public set; }
    public int MaximumHeaderLevel { get; public set; }
    public int StartingPageNumber { get; public set; }
    internal HtmlToPdfTocStyle HeaderStyle { get; internal set; }
    internal int TocPageCount { get; internal set; }
    internal bool IsBlinkRenderingEngine { get; internal set; }
    internal float HeaderHeight { get; internal set; }
    internal float FooterHeight { get; internal set; }
    public string get_Title();
    public void set_Title(string value);
    public PdfTextAlignment get_TitleAlignment();
    public void set_TitleAlignment(PdfTextAlignment value);
    public HtmlToPdfTocStyle get_TitleStyle();
    public void set_TitleStyle(HtmlToPdfTocStyle value);
    public TabLeaderStyle get_TabLeader();
    public void set_TabLeader(TabLeaderStyle value);
    public char get_TabLeaderChar();
    public void set_TabLeaderChar(char value);
    public int get_MaximumHeaderLevel();
    public void set_MaximumHeaderLevel(int value);
    public int get_StartingPageNumber();
    public void set_StartingPageNumber(int value);
    internal HtmlToPdfTocStyle get_HeaderStyle();
    internal void set_HeaderStyle(HtmlToPdfTocStyle value);
    internal int get_TocPageCount();
    internal void set_TocPageCount(int value);
    internal bool get_IsBlinkRenderingEngine();
    internal void set_IsBlinkRenderingEngine(bool value);
    internal float get_HeaderHeight();
    internal void set_HeaderHeight(float value);
    internal float get_FooterHeight();
    internal void set_FooterHeight(float value);
    internal int GetRectangleHeightAndTocPageCount(PdfPageBase page, List`1<HtmlInternalLink> internalLinkCollection);
    private float GetRectangleHeight(HtmlInternalLink htmlToc, float rectWidth, int currentHeaderLevel);
    internal void DrawTable(PdfDocument lDoc, PdfPage page, List`1<HtmlInternalLink> internalLinkCollection);
    private void DrawHeaderContent(RectangleF rectBounds, PdfGraphics graphics, HtmlInternalLink htmlToc);
    private void DrawTabLeader(RectangleF rectBounds, PdfGraphics graphics, SizeF contentSize, float pageNumberWidth, string HeaderContent);
    private void AddDocumentLinkAnnotation(RectangleF rectBounds, PdfDocument lDoc, PdfPage page, HtmlInternalLink htmltoc);
    public void SetItemStyle(int headingStyle, HtmlToPdfTocStyle tocStyle);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class Syncfusion.Pdf.HtmlToPdf.HtmlToPdfTocStyle : object {
    private PdfBrush m_backgroundColor;
    private PdfFont m_font;
    private PdfBrush m_foreColor;
    private PdfPaddings m_Padding;
    public PdfBrush BackgroundColor { get; public set; }
    public PdfFont Font { get; public set; }
    public PdfBrush ForeColor { get; public set; }
    public PdfPaddings Padding { get; public set; }
    public PdfBrush get_BackgroundColor();
    public void set_BackgroundColor(PdfBrush value);
    public PdfFont get_Font();
    public void set_Font(PdfFont value);
    public PdfBrush get_ForeColor();
    public void set_ForeColor(PdfBrush value);
    public PdfPaddings get_Padding();
    public void set_Padding(PdfPaddings value);
}
internal class Syncfusion.Pdf.HtmlToPdf.NamespaceDoc : object {
}
public enum Syncfusion.Pdf.HtmlToPdf.SinglePageLayout : Enum {
    public int value__;
    public static SinglePageLayout None;
    public static SinglePageLayout FitWidth;
    public static SinglePageLayout FitHeight;
}
public enum Syncfusion.Pdf.HttpReadType : Enum {
    public int value__;
    public static HttpReadType Open;
    public static HttpReadType Save;
}
[NullableContextAttribute("1")]
public interface Syncfusion.Pdf.ICloneable {
    public abstract virtual object Clone();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Syncfusion.Pdf.IndexLocation : TableBase {
    private int m_id;
    private UInt32[] m_offset;
    private int p;
    internal int Id { get; }
    public UInt32[] Offset { get; public set; }
    public IndexLocation(FontFile2 fontsource);
    internal virtual int get_Id();
    public UInt32[] get_Offset();
    public void set_Offset(UInt32[] value);
    public long GetOffset(ushort index);
    public virtual void Read(ReadFontArray reader);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Syncfusion.Pdf.Interactive.CloudBorderEffect : object {
    private static double Angle180;
    private static double Angle34;
    private static double Angle12;
    private PdfStreamWriter _writer;
    private RectangleF _cloudRectangle;
    private double _intensity;
    private double _borderWidth;
    private RectangleF _updatedRectangle;
    private bool _isWriter;
    private double _boundingBoxMinX;
    private double _boundingBoxMinY;
    private double _boundingBoxMaxX;
    private double _boundingBoxMaxY;
    public CloudBorderEffect(PdfStreamWriter stream, double intensity, double borderWidth, RectangleF rect);
    public void CreateCloudBorder(RectangleF rd);
    public RectangleF GetBoundingBox();
    public RectangleF GetRectangleBounds();
    public PdfTransformationMatrix GetTranslateInstance(float minXbBox, float minYbBox);
    public RectangleF GetAdjustedRectangle();
    private static double GetCosineValue(double baseLengthX, double totalLength);
    private static double GetSineValue(double baseLengthY, double totalLength);
    private void DrawCornerCurve(double previousAngle, double curveAngle, double radius, double centerX, double centerY, double rotationAngle, double previousRotationAngle, bool addMoveTo);
    private RectangleF UpdateRectangle(RectangleF rd, float minimum);
    private void CalculateArc(double startAngle, double endAngle, double radiusX, double radiusY, double centerX, double centerY, List`1<PointF> pointList, bool isMoveTo);
    private void CalculateArcSegment(double startAngle, double endAngle, double centerX, double centerY, double radiusX, double radiusY, List`1<PointF> pointList, bool isMoveTo);
    private PointF[] FlattenEllipsePoints(double left, double bottom, double right, double top);
    private void DrawCloudBorderStyle(double leftOrig, double bottomOrig, double rightOrig, double topOrig);
    private double CalculateEllipseParameters(PointF point, PointF pointNext, double radius, double curlAdvance);
    private float ObtainDistance(PointF point1, PointF point2);
    private void DrawEllipseAnnotation(double left, double bottom, double right, double top);
    private void StartWriter(double x, double y);
    private void UpdateBoundingBox(double x, double y);
    private void MoveTo(double x, double y);
    private void CurveTo(double pointAx, double pointAy, double pointBx, double pointBy, double pointCx, double pointCy);
    private void Close();
    private double CalculateCloudRadius();
    public List`1<PointF> AddEllipse(float left, float bottom, float width, float height);
}
internal class Syncfusion.Pdf.Interactive.CloudStyleArc : object {
    internal PointF point;
    internal float endAngle;
    internal float startAngle;
}
[FlagsAttribute]
internal enum Syncfusion.Pdf.Interactive.FieldFlags : Enum {
    public int value__;
    public static FieldFlags Default;
    public static FieldFlags ReadOnly;
    public static FieldFlags Required;
    public static FieldFlags NoExport;
    public static FieldFlags Multiline;
    public static FieldFlags Password;
    public static FieldFlags FileSelect;
    public static FieldFlags DoNotSpellCheck;
    public static FieldFlags DoNotScroll;
    public static FieldFlags Comb;
    public static FieldFlags RichText;
    public static FieldFlags NoToggleToOff;
    public static FieldFlags Radio;
    public static FieldFlags PushButton;
    public static FieldFlags RadiosInUnison;
    public static FieldFlags Combo;
    public static FieldFlags Edit;
    public static FieldFlags Sort;
    public static FieldFlags MultiSelect;
    public static FieldFlags CommitOnSelChange;
}
public enum Syncfusion.Pdf.Interactive.HttpMethod : Enum {
    public int value__;
    public static HttpMethod Get;
    public static HttpMethod Post;
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class Syncfusion.Pdf.Interactive.LineBorder : object {
    private float m_borderLineWidth;
    private int m_borderWidth;
    private int m_dashArray;
    private PdfBorderStyle m_borderStyle;
    private PdfDictionary m_dictionary;
    public int BorderWidth { get; public set; }
    internal float BorderLineWidth { get; internal set; }
    public PdfBorderStyle BorderStyle { get; public set; }
    public int DashArray { get; public set; }
    private IPdfPrimitive Syncfusion.Pdf.IPdfWrapper.Element { get; }
    public int get_BorderWidth();
    public void set_BorderWidth(int value);
    internal float get_BorderLineWidth();
    internal void set_BorderLineWidth(float value);
    public PdfBorderStyle get_BorderStyle();
    public void set_BorderStyle(PdfBorderStyle value);
    public int get_DashArray();
    public void set_DashArray(int value);
    private string StyleToString(PdfBorderStyle style);
    private sealed virtual override IPdfPrimitive Syncfusion.Pdf.IPdfWrapper.get_Element();
}
internal class Syncfusion.Pdf.Interactive.NamespaceDoc : object {
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class Syncfusion.Pdf.Interactive.Pdf3DActivation : object {
    private Pdf3DActivationMode m_activationMode;
    private Pdf3DActivationState m_activationState;
    private Pdf3DDeactivationMode m_deactivationMode;
    private Pdf3DDeactivationState m_deactivationState;
    private bool m_showToolbar;
    private bool m_showUI;
    private PdfDictionary m_dictionary;
    public Pdf3DActivationMode ActivationMode { get; public set; }
    public Pdf3DDeactivationMode DeactivationMode { get; public set; }
    public Pdf3DActivationState ActivationState { get; public set; }
    public Pdf3DDeactivationState DeactivationState { get; public set; }
    public bool ShowToolbar { get; public set; }
    public bool ShowUI { get; public set; }
    internal PdfDictionary Dictionary { get; }
    private IPdfPrimitive Syncfusion.Pdf.IPdfWrapper.Element { get; }
    public Pdf3DActivationMode get_ActivationMode();
    public void set_ActivationMode(Pdf3DActivationMode value);
    public Pdf3DDeactivationMode get_DeactivationMode();
    public void set_DeactivationMode(Pdf3DDeactivationMode value);
    public Pdf3DActivationState get_ActivationState();
    public void set_ActivationState(Pdf3DActivationState value);
    public Pdf3DDeactivationState get_DeactivationState();
    public void set_DeactivationState(Pdf3DDeactivationState value);
    public bool get_ShowToolbar();
    public void set_ShowToolbar(bool value);
    public bool get_ShowUI();
    public void set_ShowUI(bool value);
    internal PdfDictionary get_Dictionary();
    protected virtual void Initialize();
    private void Dictionary_BeginSave(object sender, SavePdfPrimitiveEventArgs ars);
    protected virtual void Save();
    private sealed virtual override IPdfPrimitive Syncfusion.Pdf.IPdfWrapper.get_Element();
}
public enum Syncfusion.Pdf.Interactive.Pdf3DActivationMode : Enum {
    public int value__;
    public static Pdf3DActivationMode PageOpen;
    public static Pdf3DActivationMode PageVisible;
    public static Pdf3DActivationMode ExplicitActivation;
}
public enum Syncfusion.Pdf.Interactive.Pdf3DActivationState : Enum {
    public int value__;
    public static Pdf3DActivationState Instantiated;
    public static Pdf3DActivationState Live;
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class Syncfusion.Pdf.Interactive.Pdf3DAnimation : object {
    private PDF3DAnimationType m_type;
    private int m_playCount;
    private float m_timeMultiplier;
    private PdfDictionary m_dictionary;
    public PDF3DAnimationType Type { get; public set; }
    public int PlayCount { get; public set; }
    public float TimeMultiplier { get; public set; }
    internal PdfDictionary Dictionary { get; }
    private IPdfPrimitive Syncfusion.Pdf.IPdfWrapper.Element { get; }
    public Pdf3DAnimation(PDF3DAnimationType type);
    public PDF3DAnimationType get_Type();
    public void set_Type(PDF3DAnimationType value);
    public int get_PlayCount();
    public void set_PlayCount(int value);
    public float get_TimeMultiplier();
    public void set_TimeMultiplier(float value);
    internal PdfDictionary get_Dictionary();
    protected virtual void Initialize();
    private void Dictionary_BeginSave(object sender, SavePdfPrimitiveEventArgs ars);
    protected virtual void Save();
    private sealed virtual override IPdfPrimitive Syncfusion.Pdf.IPdfWrapper.get_Element();
}
public enum Syncfusion.Pdf.Interactive.PDF3DAnimationType : Enum {
    public int value__;
    public static PDF3DAnimationType None;
    public static PDF3DAnimationType Linear;
    public static PDF3DAnimationType Oscillating;
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class Syncfusion.Pdf.Interactive.Pdf3DAnnotation : PdfFileAnnotation {
    private Pdf3DActivation m_activation;
    private Pdf3DBase m_u3d;
    private PdfTemplate m_apperance;
    public Pdf3DViewCollection Views { get; }
    public int DefaultView { get; public set; }
    public Pdf3DAnnotationType Type { get; public set; }
    public string OnInstantiate { get; public set; }
    public Pdf3DActivation Activation { get; public set; }
    public string FileName { get; public set; }
    public Pdf3DAnimation Animation { get; public set; }
    public Pdf3DAnnotation(RectangleF rectangle);
    public Pdf3DAnnotation(RectangleF rectangle, Stream data);
    public Pdf3DViewCollection get_Views();
    public int get_DefaultView();
    public void set_DefaultView(int value);
    public Pdf3DAnnotationType get_Type();
    public void set_Type(Pdf3DAnnotationType value);
    public string get_OnInstantiate();
    public void set_OnInstantiate(string value);
    public Pdf3DActivation get_Activation();
    public void set_Activation(Pdf3DActivation value);
    public virtual string get_FileName();
    public virtual void set_FileName(string value);
    public Pdf3DAnimation get_Animation();
    public void set_Animation(Pdf3DAnimation value);
    protected virtual void Initialize();
    protected virtual void Save();
}
public enum Syncfusion.Pdf.Interactive.Pdf3DAnnotationType : Enum {
    public int value__;
    public static Pdf3DAnnotationType U3D;
    public static Pdf3DAnnotationType PRC;
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class Syncfusion.Pdf.Interactive.Pdf3DBackground : object {
    private static float MaxColourChannelValue;
    private PdfColor m_backgroundColor;
    private bool m_applyEntire;
    private PdfDictionary m_dictionary;
    public PdfColor Color { get; public set; }
    public bool ApplyToEntireAnnotation { get; public set; }
    internal PdfDictionary Dictionary { get; }
    private IPdfPrimitive Syncfusion.Pdf.IPdfWrapper.Element { get; }
    public Pdf3DBackground(PdfColor color);
    public PdfColor get_Color();
    public void set_Color(PdfColor value);
    public bool get_ApplyToEntireAnnotation();
    public void set_ApplyToEntireAnnotation(bool value);
    internal PdfDictionary get_Dictionary();
    protected virtual void Initialize();
    private void Dictionary_BeginSave(object sender, SavePdfPrimitiveEventArgs ars);
    protected virtual void Save();
    private sealed virtual override IPdfPrimitive Syncfusion.Pdf.IPdfWrapper.get_Element();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Syncfusion.Pdf.Interactive.Pdf3DBase : object {
    private string m_fileName;
    private Pdf3DStream m_stream;
    private Stream m_data;
    public Pdf3DStream Stream { get; public set; }
    public string FileName { get; public set; }
    public IPdfPrimitive Element { get; }
    public Pdf3DBase(Stream data);
    public Pdf3DStream get_Stream();
    public void set_Stream(Pdf3DStream value);
    public string get_FileName();
    public void set_FileName(string value);
    private void Stream_BeginSave(object sender, SavePdfPrimitiveEventArgs ars);
    protected void Save();
    public sealed virtual IPdfPrimitive get_Element();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class Syncfusion.Pdf.Interactive.Pdf3DCrossSection : object {
    private Single[] m_center;
    private PdfColor m_color;
    private PdfColor m_intersectionColor;
    private bool m_intersectionIsVisible;
    private Object[] m_orientation;
    private float m_opacity;
    private PdfDictionary m_dictionary;
    public Single[] Center { get; public set; }
    public PdfColor Color { get; public set; }
    public PdfColor IntersectionColor { get; public set; }
    public bool IntersectionIsVisible { get; public set; }
    public float Opacity { get; public set; }
    public Object[] Orientation { get; public set; }
    internal PdfDictionary Dictionary { get; }
    private IPdfPrimitive Syncfusion.Pdf.IPdfWrapper.Element { get; }
    public Single[] get_Center();
    public void set_Center(Single[] value);
    public PdfColor get_Color();
    public void set_Color(PdfColor value);
    public PdfColor get_IntersectionColor();
    public void set_IntersectionColor(PdfColor value);
    public bool get_IntersectionIsVisible();
    public void set_IntersectionIsVisible(bool value);
    public float get_Opacity();
    public void set_Opacity(float value);
    public Object[] get_Orientation();
    public void set_Orientation(Object[] value);
    internal PdfDictionary get_Dictionary();
    protected virtual void Initialize();
    private void Dictionary_BeginSave(object sender, SavePdfPrimitiveEventArgs ars);
    protected virtual void Save();
    private sealed virtual override IPdfPrimitive Syncfusion.Pdf.IPdfWrapper.get_Element();
}
[NullableContextAttribute("1")]
[NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[DefaultMemberAttribute("Item")]
public class Syncfusion.Pdf.Interactive.Pdf3DCrossSectionCollection : List`1<Pdf3DCrossSection> {
    public Pdf3DCrossSection Item { get; public set; }
    public int Add(Pdf3DCrossSection value);
    public bool Contains(Pdf3DCrossSection value);
    public int IndexOf(Pdf3DCrossSection value);
    public void Insert(int index, Pdf3DCrossSection value);
    public void Remove(Pdf3DCrossSection value);
    public Pdf3DCrossSection get_Item(int index);
    public void set_Item(int index, Pdf3DCrossSection value);
}
public enum Syncfusion.Pdf.Interactive.Pdf3DDeactivationMode : Enum {
    public int value__;
    public static Pdf3DDeactivationMode PageClose;
    public static Pdf3DDeactivationMode PageInvisible;
    public static Pdf3DDeactivationMode ExplicitDeactivation;
}
public enum Syncfusion.Pdf.Interactive.Pdf3DDeactivationState : Enum {
    public int value__;
    public static Pdf3DDeactivationState Uninstantiated;
    public static Pdf3DDeactivationState Instantiated;
    public static Pdf3DDeactivationState Live;
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class Syncfusion.Pdf.Interactive.Pdf3DLighting : object {
    private Pdf3DLightingStyle m_lightingStyle;
    private PdfDictionary m_dictionary;
    public Pdf3DLightingStyle Style { get; public set; }
    internal PdfDictionary Dictionary { get; }
    private IPdfPrimitive Syncfusion.Pdf.IPdfWrapper.Element { get; }
    public Pdf3DLighting(Pdf3DLightingStyle style);
    public Pdf3DLightingStyle get_Style();
    public void set_Style(Pdf3DLightingStyle value);
    internal PdfDictionary get_Dictionary();
    protected virtual void Initialize();
    private void Dictionary_BeginSave(object sender, SavePdfPrimitiveEventArgs ars);
    protected virtual void Save();
    private sealed virtual override IPdfPrimitive Syncfusion.Pdf.IPdfWrapper.get_Element();
}
public enum Syncfusion.Pdf.Interactive.Pdf3DLightingStyle : Enum {
    public int value__;
    public static Pdf3DLightingStyle Artwork;
    public static Pdf3DLightingStyle None;
    public static Pdf3DLightingStyle White;
    public static Pdf3DLightingStyle Day;
    public static Pdf3DLightingStyle Night;
    public static Pdf3DLightingStyle Hard;
    public static Pdf3DLightingStyle Primary;
    public static Pdf3DLightingStyle Blue;
    public static Pdf3DLightingStyle Red;
    public static Pdf3DLightingStyle Cube;
    public static Pdf3DLightingStyle CAD;
    public static Pdf3DLightingStyle Headlamp;
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class Syncfusion.Pdf.Interactive.Pdf3DNode : object {
    private bool m_visible;
    private string m_name;
    private float m_opacity;
    private Single[] m_matrix;
    private PdfDictionary m_dictionary;
    public bool Visible { get; public set; }
    public string Name { get; public set; }
    public float Opacity { get; public set; }
    public Single[] Matrix { get; public set; }
    internal PdfDictionary Dictionary { get; }
    private IPdfPrimitive Syncfusion.Pdf.IPdfWrapper.Element { get; }
    public bool get_Visible();
    public void set_Visible(bool value);
    public string get_Name();
    public void set_Name(string value);
    public float get_Opacity();
    public void set_Opacity(float value);
    public Single[] get_Matrix();
    public void set_Matrix(Single[] value);
    internal PdfDictionary get_Dictionary();
    protected virtual void Initialize();
    private void Dictionary_BeginSave(object sender, SavePdfPrimitiveEventArgs ars);
    protected virtual void Save();
    private sealed virtual override IPdfPrimitive Syncfusion.Pdf.IPdfWrapper.get_Element();
}
[NullableContextAttribute("1")]
[NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[DefaultMemberAttribute("Item")]
public class Syncfusion.Pdf.Interactive.Pdf3DNodeCollection : List`1<Pdf3DNode> {
    public Pdf3DNode Item { get; public set; }
    public int Add(Pdf3DNode value);
    public bool Contains(Pdf3DNode value);
    public int IndexOf(Pdf3DNode value);
    public void Insert(int index, Pdf3DNode value);
    public void Remove(Pdf3DNode value);
    public Pdf3DNode get_Item(int index);
    public void set_Item(int index, Pdf3DNode value);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class Syncfusion.Pdf.Interactive.Pdf3DProjection : object {
    private Pdf3DProjectionType m_Type;
    private Pdf3DProjectionClipStyle m_ClipStyle;
    private Pdf3DProjectionOrthoScaleMode m_OrthoScalemode;
    private float m_farClipDistance;
    private float m_fieldOfView;
    private float m_nearClipDistance;
    private float m_scaling;
    private PdfDictionary m_dictionary;
    public Pdf3DProjectionType ProjectionType { get; public set; }
    public Pdf3DProjectionClipStyle ClipStyle { get; public set; }
    public Pdf3DProjectionOrthoScaleMode OrthoScaleMode { get; public set; }
    public float FarClipDistance { get; public set; }
    public float FieldOfView { get; public set; }
    public float NearClipDistance { get; public set; }
    public float Scaling { get; public set; }
    internal PdfDictionary Dictionary { get; }
    private IPdfPrimitive Syncfusion.Pdf.IPdfWrapper.Element { get; }
    public Pdf3DProjection(Pdf3DProjectionType type);
    public Pdf3DProjectionType get_ProjectionType();
    public void set_ProjectionType(Pdf3DProjectionType value);
    public Pdf3DProjectionClipStyle get_ClipStyle();
    public void set_ClipStyle(Pdf3DProjectionClipStyle value);
    public Pdf3DProjectionOrthoScaleMode get_OrthoScaleMode();
    public void set_OrthoScaleMode(Pdf3DProjectionOrthoScaleMode value);
    public float get_FarClipDistance();
    public void set_FarClipDistance(float value);
    public float get_FieldOfView();
    public void set_FieldOfView(float value);
    public float get_NearClipDistance();
    public void set_NearClipDistance(float value);
    public float get_Scaling();
    public void set_Scaling(float value);
    internal PdfDictionary get_Dictionary();
    protected virtual void Initialize();
    private void Dictionary_BeginSave(object sender, SavePdfPrimitiveEventArgs ars);
    protected virtual void Save();
    private sealed virtual override IPdfPrimitive Syncfusion.Pdf.IPdfWrapper.get_Element();
}
public enum Syncfusion.Pdf.Interactive.Pdf3DProjectionClipStyle : Enum {
    public int value__;
    public static Pdf3DProjectionClipStyle ExplicitNearFar;
    public static Pdf3DProjectionClipStyle AutomaticNearFar;
}
public enum Syncfusion.Pdf.Interactive.Pdf3DProjectionOrthoScaleMode : Enum {
    public int value__;
    public static Pdf3DProjectionOrthoScaleMode Width;
    public static Pdf3DProjectionOrthoScaleMode Height;
    public static Pdf3DProjectionOrthoScaleMode Min;
    public static Pdf3DProjectionOrthoScaleMode Max;
    public static Pdf3DProjectionOrthoScaleMode Absolute;
}
public enum Syncfusion.Pdf.Interactive.Pdf3DProjectionType : Enum {
    public int value__;
    public static Pdf3DProjectionType Orthographic;
    public static Pdf3DProjectionType Perspective;
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class Syncfusion.Pdf.Interactive.Pdf3DRendermode : object {
    private Pdf3DRenderStyle m_style;
    private PdfColor m_faceColor;
    private PdfColor m_auxilaryColor;
    private float m_opacity;
    private float m_creaseValue;
    private PdfDictionary m_dictionary;
    public Pdf3DRenderStyle Style { get; public set; }
    public PdfColor AuxilaryColor { get; public set; }
    public PdfColor FaceColor { get; public set; }
    public float CreaseValue { get; public set; }
    public float Opacity { get; public set; }
    internal PdfDictionary Dictionary { get; }
    private IPdfPrimitive Syncfusion.Pdf.IPdfWrapper.Element { get; }
    public Pdf3DRendermode(Pdf3DRenderStyle style);
    public Pdf3DRenderStyle get_Style();
    public void set_Style(Pdf3DRenderStyle value);
    public PdfColor get_AuxilaryColor();
    public void set_AuxilaryColor(PdfColor value);
    public PdfColor get_FaceColor();
    public void set_FaceColor(PdfColor value);
    public float get_CreaseValue();
    public void set_CreaseValue(float value);
    public float get_Opacity();
    public void set_Opacity(float value);
    internal PdfDictionary get_Dictionary();
    protected virtual void Initialize();
    private void Dictionary_BeginSave(object sender, SavePdfPrimitiveEventArgs ars);
    protected virtual void Save();
    private sealed virtual override IPdfPrimitive Syncfusion.Pdf.IPdfWrapper.get_Element();
}
public enum Syncfusion.Pdf.Interactive.Pdf3DRenderStyle : Enum {
    public int value__;
    public static Pdf3DRenderStyle Solid;
    public static Pdf3DRenderStyle SolidWireframe;
    public static Pdf3DRenderStyle Transparent;
    public static Pdf3DRenderStyle TransparentWireframe;
    public static Pdf3DRenderStyle BoundingBox;
    public static Pdf3DRenderStyle TransparentBoundingBox;
    public static Pdf3DRenderStyle TransparentBoundingBoxOutline;
    public static Pdf3DRenderStyle Wireframe;
    public static Pdf3DRenderStyle ShadedWireframe;
    public static Pdf3DRenderStyle HiddenWireframe;
    public static Pdf3DRenderStyle Vertices;
    public static Pdf3DRenderStyle ShadedVertices;
    public static Pdf3DRenderStyle Illustration;
    public static Pdf3DRenderStyle SolidOutline;
    public static Pdf3DRenderStyle ShadedIllustration;
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class Syncfusion.Pdf.Interactive.Pdf3DView : object {
    private Pdf3DBackground m_3dBackground;
    private Pdf3DCrossSectionCollection m_3dCrossSectionCollection;
    private Single[] m_centretoWorldMatrix;
    private Pdf3DLighting m_3dLighting;
    private Pdf3DNodeCollection m_3dNodeCollection;
    private Pdf3DProjection m_3dProjection;
    private Pdf3DRendermode m_3dRendermode;
    private bool m_resetNodesState;
    private float m_centreOfOrbit;
    private string m_externalName;
    private string m_internalName;
    private string m_viewNodeName;
    private PdfDictionary m_dictionary;
    public Pdf3DBackground Background { get; public set; }
    public Single[] CameraToWorldMatrix { get; public set; }
    public float CenterOfOrbit { get; public set; }
    public Pdf3DCrossSectionCollection CrossSections { get; }
    public string ExternalName { get; public set; }
    public string InternalName { get; public set; }
    public Pdf3DLighting LightingScheme { get; public set; }
    public Pdf3DNodeCollection Nodes { get; }
    public Pdf3DProjection Projection { get; public set; }
    public Pdf3DRendermode RenderMode { get; public set; }
    public bool ResetNodesState { get; public set; }
    public string ViewNodeName { get; public set; }
    internal PdfDictionary Dictionary { get; }
    private IPdfPrimitive Syncfusion.Pdf.IPdfWrapper.Element { get; }
    public Pdf3DBackground get_Background();
    public void set_Background(Pdf3DBackground value);
    public Single[] get_CameraToWorldMatrix();
    public void set_CameraToWorldMatrix(Single[] value);
    public float get_CenterOfOrbit();
    public void set_CenterOfOrbit(float value);
    public Pdf3DCrossSectionCollection get_CrossSections();
    public string get_ExternalName();
    public void set_ExternalName(string value);
    public string get_InternalName();
    public void set_InternalName(string value);
    public Pdf3DLighting get_LightingScheme();
    public void set_LightingScheme(Pdf3DLighting value);
    public Pdf3DNodeCollection get_Nodes();
    public Pdf3DProjection get_Projection();
    public void set_Projection(Pdf3DProjection value);
    public Pdf3DRendermode get_RenderMode();
    public void set_RenderMode(Pdf3DRendermode value);
    public bool get_ResetNodesState();
    public void set_ResetNodesState(bool value);
    public string get_ViewNodeName();
    public void set_ViewNodeName(string value);
    internal PdfDictionary get_Dictionary();
    protected virtual void Initialize();
    private void Dictionary_BeginSave(object sender, SavePdfPrimitiveEventArgs ars);
    protected virtual void Save();
    private sealed virtual override IPdfPrimitive Syncfusion.Pdf.IPdfWrapper.get_Element();
}
[NullableContextAttribute("1")]
[NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[DefaultMemberAttribute("Item")]
public class Syncfusion.Pdf.Interactive.Pdf3DViewCollection : List`1<Pdf3DView> {
    public Pdf3DView Item { get; public set; }
    public int Add(Pdf3DView value);
    public bool Contains(Pdf3DView value);
    public int IndexOf(Pdf3DView value);
    public void Insert(int index, Pdf3DView value);
    public void Remove(Pdf3DView value);
    public Pdf3DView get_Item(int index);
    public void set_Item(int index, Pdf3DView value);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public abstract class Syncfusion.Pdf.Interactive.PdfAction : object {
    private PdfAction _mAction;
    private PdfDictionary _mDictionary;
    public PdfAction Next { get; public set; }
    internal PdfDictionary Dictionary { get; }
    private IPdfPrimitive Syncfusion.Pdf.IPdfWrapper.Element { get; }
    public PdfAction get_Next();
    public void set_Next(PdfAction value);
    internal PdfDictionary get_Dictionary();
    protected virtual void Initialize();
    private sealed virtual override IPdfPrimitive Syncfusion.Pdf.IPdfWrapper.get_Element();
}
public class Syncfusion.Pdf.Interactive.PdfActionAnnotation : PdfActionLinkAnnotation {
    [NullableContextAttribute("1")]
public PdfActionAnnotation(RectangleF rectangle, PdfAction action);
    protected virtual void Save();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[DefaultMemberAttribute("Item")]
public class Syncfusion.Pdf.Interactive.PdfActionCollection : PdfCollection {
    private PdfArray m_actions;
    private PdfAction Item { get; }
    private PdfAction get_Item(int index);
    public int Add(PdfAction action);
    public void Insert(int index, PdfAction action);
    public int IndexOf(PdfAction action);
    public bool Contains(PdfAction action);
    public void Clear();
    public void Remove(PdfAction action);
    public void RemoveAt(int index);
    private int DoAdd(PdfAction action);
    private void DoInsert(int index, PdfAction action);
    private void DoClear();
    private void DoRemove(PdfAction action);
    private void DoRemoveAt(int index);
}
public enum Syncfusion.Pdf.Interactive.PdfActionDestination : Enum {
    public int value__;
    public static PdfActionDestination FirstPage;
    public static PdfActionDestination LastPage;
    public static PdfActionDestination NextPage;
    public static PdfActionDestination PrevPage;
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public abstract class Syncfusion.Pdf.Interactive.PdfActionLinkAnnotation : PdfLinkAnnotation {
    private PdfAction _mAction;
    public PdfAction Action { get; public set; }
    public PdfActionLinkAnnotation(RectangleF rectangle);
    public PdfActionLinkAnnotation(RectangleF rectangle, PdfAction action);
    public virtual PdfAction get_Action();
    public virtual void set_Action(PdfAction value);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public abstract class Syncfusion.Pdf.Interactive.PdfAnnotation : object {
    private PdfColor _mColor;
    private PdfAnnotationBorder m_border;
    private RectangleF _mRectangle;
    private PdfPage _mPage;
    internal PdfLoadedPage m_loadedPage;
    internal string _mText;
    private string _mAuthor;
    private string _mSubject;
    private DateTime _mModifiedDate;
    private PdfAnnotationFlags m_annotationFlags;
    private PdfDictionary _mDictionary;
    private PdfColor _mInnerColor;
    private float _mOpacity;
    private bool _mFlatten;
    private bool _mFlattenPopUps;
    private PdfTag _mTag;
    internal PdfAppearance m_appearance;
    private bool _mSetAppearanceDictionary;
    internal bool isAuthorExplicitSet;
    private PdfPopupAnnotation m_popup;
    private PdfLayer layer;
    private PdfAnnotationRotateAngle _mAngle;
    internal bool RotationModified;
    private PdfMargins _mMargins;
    internal PdfPopupAnnotationCollection m_reviewHistory;
    internal PdfPopupAnnotationCollection m_comments;
    internal static string TopCaption;
    private List`1<PdfAnnotation> m_popupAnnotations;
    private string _mName;
    private float _mBorderWidth;
    internal bool m_isStandardAppearance;
    private float rotateAngle;
    private bool m_locationDisplaced;
    internal bool m_addingOldAnnotation;
    internal bool unSupportedAnnotation;
    internal bool isPropertyChanged;
    internal bool isAnnotationCreation;
    private PdfConformanceLevel existingConformanceLevel;
    private int m_flagBit;
    private bool beginSaveEventTriggered;
    [CompilerGeneratedAttribute]
private PropertyChangedEventHandler PropertyChanged;
    internal static string r_Comment;
    internal static string r_Comment_Secondhalf;
    internal static string n_Comment;
    internal static string n_Comment_Secondhalf;
    internal static string r_Note;
    internal static string n_Note;
    internal static string r_Help;
    internal static string r_Help_Secondhalf;
    internal static string n_Help;
    internal static string n_Help_Secondhalf;
    internal static string r_Insert;
    internal static string n_Insert;
    internal static string r_Key;
    internal static string r_Key_Secondhalf;
    internal static string n_Key;
    internal static string n_Key_Secondhalf;
    internal static string r_NewParagraph;
    internal static string r_NewParagraph_Secondhalf;
    internal static string n_NewParagraph;
    internal static string n_NewParagraph_Secondhalf;
    internal static string r_Paragraph;
    internal static string r_Paragraph_Secondhalf;
    internal static string n_Paragraph;
    internal static string n_Paragraph_Secondhalf;
    internal static string r_CheckMark;
    internal static string n_CheckMark;
    internal static string r_Check;
    internal static string n_Check;
    internal static string r_Circle;
    internal static string r_CircleSecondHalf;
    internal static string n_Circle;
    internal static string n_CircleSecondHalf;
    internal static string r_Cross;
    internal static string n_Cross;
    internal static string r_CheckHairs;
    internal static string r_CheckHairsSecondHalf;
    internal static string n_CheckHairs;
    internal static string n_CheckHairsSecondHalf;
    internal static string r_RightArrow;
    internal static string r_RightArrowSecondHalf;
    internal static string n_RightArrow;
    internal static string n_RightArrowSecondHalf;
    internal static string r_RightPointer;
    internal static string n_RightPointer;
    internal static string r_Star;
    internal static string n_Star;
    internal static string r_UpArrow;
    internal static string n_UpArrow;
    internal static string r_UpLeftArrow;
    internal static string n_UpLeftArrow;
    public PdfColor Color { get; public set; }
    public float Opacity { get; public set; }
    public PdfColor InnerColor { get; public set; }
    public PdfAnnotationBorder Border { get; public set; }
    public RectangleF Bounds { get; public set; }
    public PointF Location { get; public set; }
    public SizeF Size { get; public set; }
    public PdfPage Page { get; }
    internal PdfLoadedPage LoadedPage { get; }
    public string Text { get; public set; }
    public string Author { get; public set; }
    public string Subject { get; public set; }
    public DateTime ModifiedDate { get; public set; }
    public PdfAnnotationFlags AnnotationFlags { get; public set; }
    internal PdfDictionary Dictionary { get; internal set; }
    public bool Flatten { get; public set; }
    public bool FlattenPopUps { get; public set; }
    public PdfTag PdfTag { get; public set; }
    internal PdfAppearance Appearance { get; internal set; }
    internal bool SetAppearanceDictionary { get; internal set; }
    internal PdfPopupAnnotation Popup { get; internal set; }
    public PdfLayer Layer { get; public set; }
    public PdfAnnotationRotateAngle Rotate { get; public set; }
    public string Name { get; public set; }
    internal float RotateAngle { get; internal set; }
    private IPdfPrimitive Syncfusion.Pdf.IPdfWrapper.Element { get; }
    protected PdfAnnotation(PdfPageBase page, string text);
    protected PdfAnnotation(RectangleF bounds);
    internal PdfAnnotation(PdfDictionary dictionary, PdfCrossTable crossTable, RectangleF bounds);
    [CompilerGeneratedAttribute]
public sealed virtual void add_PropertyChanged(PropertyChangedEventHandler value);
    [CompilerGeneratedAttribute]
public sealed virtual void remove_PropertyChanged(PropertyChangedEventHandler value);
    internal void NotifyPropertyChanged(string propertyName);
    public virtual PdfColor get_Color();
    public virtual void set_Color(PdfColor value);
    public virtual float get_Opacity();
    public virtual void set_Opacity(float value);
    public virtual PdfColor get_InnerColor();
    public virtual void set_InnerColor(PdfColor value);
    public virtual PdfAnnotationBorder get_Border();
    public virtual void set_Border(PdfAnnotationBorder value);
    public virtual RectangleF get_Bounds();
    public virtual void set_Bounds(RectangleF value);
    public virtual PointF get_Location();
    public virtual void set_Location(PointF value);
    public virtual SizeF get_Size();
    public virtual void set_Size(SizeF value);
    public PdfPage get_Page();
    internal PdfLoadedPage get_LoadedPage();
    public virtual string get_Text();
    public virtual void set_Text(string value);
    public virtual string get_Author();
    public virtual void set_Author(string value);
    public virtual string get_Subject();
    public virtual void set_Subject(string value);
    public virtual DateTime get_ModifiedDate();
    public virtual void set_ModifiedDate(DateTime value);
    public virtual PdfAnnotationFlags get_AnnotationFlags();
    public virtual void set_AnnotationFlags(PdfAnnotationFlags value);
    internal PdfDictionary get_Dictionary();
    internal void set_Dictionary(PdfDictionary value);
    public bool get_Flatten();
    public void set_Flatten(bool value);
    public bool get_FlattenPopUps();
    public void set_FlattenPopUps(bool value);
    public PdfTag get_PdfTag();
    public void set_PdfTag(PdfTag value);
    internal PdfAppearance get_Appearance();
    internal void set_Appearance(PdfAppearance value);
    internal bool get_SetAppearanceDictionary();
    internal void set_SetAppearanceDictionary(bool value);
    public void SetAppearance(bool appearance);
    internal PdfPopupAnnotation get_Popup();
    internal void set_Popup(PdfPopupAnnotation value);
    public PdfLayer get_Layer();
    public void set_Layer(PdfLayer value);
    public PdfAnnotationRotateAngle get_Rotate();
    public void set_Rotate(PdfAnnotationRotateAngle value);
    public string get_Name();
    public void set_Name(string value);
    internal float get_RotateAngle();
    internal void set_RotateAngle(float value);
    internal void SetPage(PdfPageBase page);
    internal PdfGraphicsUnit GetEqualPdfGraphicsUnit(PdfMeasurementUnit measurementUnit, String& m_unitString);
    internal PdfDictionary CreateMeasureDictioanry(string m_unitString);
    internal PdfTemplate CreateNormalAppearance(string overlayText, PdfFont font, bool repeat, PdfColor TextColor, PdfTextAlignment alignment, LineBorder Border);
    internal PdfTemplate CreateBorderAppearance(PdfColor BorderColor, LineBorder Border);
    internal string FindOperator(int token);
    internal string ColorToHex(Color c);
    internal void RemoveAnnoationFromPage(PdfPageBase page, PdfAnnotation annot);
    internal void AssignLocation(PointF location);
    internal virtual void ApplyText(string text);
    internal void AssignSize(SizeF size);
    protected virtual void Initialize();
    internal virtual void Dictionary_BeginSave(object sender, SavePdfPrimitiveEventArgs ars);
    internal virtual void InstanceSave();
    internal virtual void FlattenAnnot(bool flattenPopUps);
    protected virtual void Save();
    protected RectangleF CalculateBounds(RectangleF Bounds, PdfPage page, PdfLoadedPage loadedpage);
    internal void DrawAuthor(string author, string subject, RectangleF bounds, PdfBrush backBrush, PdfBrush aBrush, PdfPageBase page, Single& trackingHeight, PdfAnnotationBorder border);
    internal void DrawSubject(string subject, RectangleF bounds, PdfPageBase page);
    internal void FlattenPopup();
    internal void FlattenPopup(PdfPageBase page, PdfColor color, RectangleF annotBounds, PdfAnnotationBorder border, string author, string subject, string text);
    internal void SaveGraphics(PdfPageBase page, PdfBlendMode blendMode);
    internal PdfColor GetForeColor(PdfColor c);
    public void SetValues(string key, string value);
    protected PointF CalculateTemplateBounds(RectangleF Bounds, PdfPageBase page, PdfTemplate template);
    private PdfLayer GetDocumentLayer();
    private void IsMatched(PdfDocumentLayerCollection layerCollection, IPdfPrimitive expectedObject, PdfLoadedPage page);
    internal float GetRotationAngle();
    internal RectangleF GetRotatedBounds(RectangleF bounds, float rotateangle);
    internal static RectangleF CalculateBoundingBox(PointF[] imageCoordinates);
    internal PdfTransformationMatrix GetRotatedTransformMatrix(PdfArray bbox, float angle);
    internal PdfTransformationMatrix GetRotatedTransformMatrixAngle(PdfArray bbox, float angle, RectangleF rectangle);
    private float GetCenterX(float angle, PdfArray bbox, float x);
    private float GetCenterY(float angle, PdfArray bbox, float y);
    private RectangleF TransformBBoxByMatrix(RectangleF bounds, Single[] mMatrix);
    private float MaxValue(Single[] value);
    private float MinValue(Single[] value);
    private PointF TransformPoint(float x, float y, Single[] matrix);
    private void TriggerAnnotationSaveEvent(PdfPageBase page);
    internal PdfPopupIcon GetIconName(string name);
    private sealed virtual override IPdfPrimitive Syncfusion.Pdf.IPdfWrapper.get_Element();
    private PdfAnnotationRotateAngle GetRotateAngle();
    internal bool ValidateTemplateMatrix(PdfDictionary dictionary);
    internal int ObtainGraphicsRotation(PdfTransformationMatrix matrix);
    protected RectangleF CalculateTemplateBounds(RectangleF bounds, PdfPageBase page, PdfTemplate template, bool isNormalMatrix, PdfGraphics graphics);
    protected RectangleF CalculateTemplateBounds(RectangleF bounds, PdfPageBase page, PdfTemplate template, bool isNormalMatrix);
    internal void SetMatrix(PdfDictionary template);
    internal RectangleF ObtainNativeRectangle();
    private bool IsContainsAnnotation();
    internal PdfArray GetCropOrMediaBox(PdfPageBase page, PdfArray cropOrMediaBox);
    internal PdfMargins ObtainMargin();
    protected void CheckFlatten();
    internal double GetAngle(float x1, float y1, float x2, float y2);
    internal RectangleF CalculateLineBounds(Single[] linePoints, int m_leaderLineExt, int m_leaderLine, int leaderOffset, PdfArray lineStyle, double borderLength);
    internal PdfGraphics GetLayerGraphics();
    internal Single[] GetAxisValue(Single[] value, double angle, double length);
    internal void SetLineEndingStyles(Single[] startingPoint, Single[] endingPoint, PdfGraphics graphics, double angle, PdfPen m_borderPen, PdfBrush m_backBrush, PdfArray lineStyle, double borderLength);
    private void AddPopUpAnnotation();
    internal string GetXmlFormattedString(string value);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ObsoleteAttribute("Please use PdfAnnotation instead")]
public abstract class Syncfusion.Pdf.Interactive.PdfAnnotation1 : object {
    private PdfColor m_color;
    private PdfAnnotationBorder m_border;
    private RectangleF m_rectangle;
    private PdfPage m_page;
    private string m_text;
    private PdfAnnotationFlags m_annotationFlags;
    private PdfDictionary m_dictionary;
    private PdfAnnotationCollection m_annotations;
    public PdfColor Color { get; public set; }
    public PdfAnnotationBorder Border { get; public set; }
    public RectangleF Bounds { get; public set; }
    public PointF Location { get; public set; }
    public SizeF Size { get; public set; }
    public PdfPage Page { get; }
    public string Text { get; public set; }
    public PdfAnnotationFlags AnnotationFlags { get; public set; }
    internal PdfDictionary Dictionary { get; }
    private IPdfPrimitive Syncfusion.Pdf.IPdfWrapper.Element { get; }
    protected PdfAnnotation1(RectangleF bounds);
    public PdfColor get_Color();
    public void set_Color(PdfColor value);
    public PdfAnnotationBorder get_Border();
    public void set_Border(PdfAnnotationBorder value);
    public RectangleF get_Bounds();
    public void set_Bounds(RectangleF value);
    public PointF get_Location();
    public void set_Location(PointF value);
    public SizeF get_Size();
    public void set_Size(SizeF value);
    public PdfPage get_Page();
    public string get_Text();
    public void set_Text(string value);
    public PdfAnnotationFlags get_AnnotationFlags();
    public void set_AnnotationFlags(PdfAnnotationFlags value);
    internal PdfDictionary get_Dictionary();
    internal void SetPage(PdfPage page);
    internal void AssignLocation(PointF location);
    internal void AssignSize(SizeF size);
    protected virtual void Initialize();
    private void Dictionary_BeginSave(object sender, SavePdfPrimitiveEventArgs ars);
    protected virtual void Save();
    private sealed virtual override IPdfPrimitive Syncfusion.Pdf.IPdfWrapper.get_Element();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class Syncfusion.Pdf.Interactive.PdfAnnotationActions : object {
    private PdfAction m_mouseEnter;
    private PdfAction m_mouseLeave;
    private PdfAction m_mouseDown;
    private PdfAction m_mouseUp;
    private PdfAction m_gotFocus;
    private PdfAction m_lostFocus;
    private PdfDictionary m_dictionary;
    public PdfAction MouseEnter { get; public set; }
    public PdfAction MouseLeave { get; public set; }
    public PdfAction MouseDown { get; public set; }
    public PdfAction MouseUp { get; public set; }
    public PdfAction GotFocus { get; public set; }
    public PdfAction LostFocus { get; public set; }
    private IPdfPrimitive Syncfusion.Pdf.IPdfWrapper.Element { get; }
    public PdfAction get_MouseEnter();
    public void set_MouseEnter(PdfAction value);
    public PdfAction get_MouseLeave();
    public void set_MouseLeave(PdfAction value);
    public PdfAction get_MouseDown();
    public void set_MouseDown(PdfAction value);
    public PdfAction get_MouseUp();
    public void set_MouseUp(PdfAction value);
    public PdfAction get_GotFocus();
    public void set_GotFocus(PdfAction value);
    public PdfAction get_LostFocus();
    public void set_LostFocus(PdfAction value);
    private sealed virtual override IPdfPrimitive Syncfusion.Pdf.IPdfWrapper.get_Element();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[DefaultMemberAttribute("Item")]
internal class Syncfusion.Pdf.Interactive.PdfAnnotationBase : PdfAnnotation {
    private PdfDictionary m_dictionary;
    private PdfCrossTable m_crossTable;
    private List`1<PdfAnnotation> m_list;
    public PdfAnnotation Item { get; }
    internal List`1<PdfAnnotation> List { get; }
    internal PdfDictionary Dictionary { get; }
    internal PdfCrossTable CrossTable { get; }
    internal PdfAnnotationBase(PdfDictionary dictionary, PdfCrossTable crossTable);
    public PdfAnnotation get_Item(int index);
    internal virtual List`1<PdfAnnotation> get_List();
    internal PdfDictionary get_Dictionary();
    internal PdfCrossTable get_CrossTable();
    public PdfAnnotation Add(string title);
    private void UpdateFields();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class Syncfusion.Pdf.Interactive.PdfAnnotationBorder : object {
    private float m_horizontalRadius;
    private float m_verticalRadius;
    private float m_borderWidth;
    private PdfArray m_array;
    public float HorizontalRadius { get; public set; }
    public float VerticalRadius { get; public set; }
    public float Width { get; public set; }
    private IPdfPrimitive Syncfusion.Pdf.IPdfWrapper.Element { get; }
    public PdfAnnotationBorder(float borderWidth);
    public PdfAnnotationBorder(float borderWidth, float horizontalRadius, float verticalRadius);
    public float get_HorizontalRadius();
    public void set_HorizontalRadius(float value);
    public float get_VerticalRadius();
    public void set_VerticalRadius(float value);
    public float get_Width();
    public void set_Width(float value);
    private void Initialize(float borderWidth, float horizontalRadius, float verticalRadius);
    private void SetNumber(int index, float value);
    private sealed virtual override IPdfPrimitive Syncfusion.Pdf.IPdfWrapper.get_Element();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[DefaultMemberAttribute("Item")]
public class Syncfusion.Pdf.Interactive.PdfAnnotationCollection : PdfCollection {
    private string AlreadyExistsAnnotationError;
    private string MissingAnnotationException;
    private PdfPage _mPage;
    private PdfArray _mAnnotations;
    private Dictionary`2<PdfDictionary, PdfAnnotation> m_popupCollection;
    internal bool _mSavePopup;
    public PdfAnnotation Item { get; }
    internal PdfArray Annotations { get; internal set; }
    private IPdfPrimitive Syncfusion.Pdf.IPdfWrapper.Element { get; }
    public PdfAnnotationCollection(PdfPage page);
    public virtual PdfAnnotation get_Item(int index);
    internal PdfArray get_Annotations();
    internal void set_Annotations(PdfArray value);
    public virtual int Add(PdfAnnotation annotation);
    private PdfPopupAnnotationCollection GetCommentsOrReview(PdfAnnotation annotation, bool isReview);
    private void DoAddComments(PdfAnnotation annotation);
    private void DoAddReviewHistory(PdfAnnotation annotation);
    public void Clear();
    public bool Contains(PdfAnnotation annotation);
    public int IndexOf(PdfAnnotation annotation);
    public void Insert(int index, PdfAnnotation annotation);
    public void RemoveAt(int index);
    public void Remove(PdfAnnotation annot);
    public void SetPrint(PdfAnnotation annot);
    private int AddAnnotation(PdfAnnotation annotation);
    private void InsertAnnotation(int index, PdfAnnotation annotation);
    private void RemoveAnnotation(PdfAnnotation annotation);
    private void RemoveAnnotationAt(int index);
    protected virtual int DoAdd(PdfAnnotation annot);
    internal bool LoadedAnnotation(PdfAnnotation annot);
    private PdfPageBase GetPage(PdfAnnotation annotation);
    private void DoAddState(PdfAnnotation popupAnnoataion);
    protected virtual void DoInsert(int index, PdfAnnotation annot);
    protected virtual void DoClear();
    protected virtual void DoRemoveAt(int index);
    private void RemovePopupAnnotation(PdfAnnotation annot);
    protected virtual void DoRemove(PdfAnnotation annot);
    internal void AnnotationRemovedEvent(PdfAnnotation annot);
    private void ParsingPopUpAnnotation(PdfAnnotation annot);
    private sealed virtual override IPdfPrimitive Syncfusion.Pdf.IPdfWrapper.get_Element();
}
[FlagsAttribute]
public enum Syncfusion.Pdf.Interactive.PdfAnnotationFlags : Enum {
    public int value__;
    public static PdfAnnotationFlags Default;
    public static PdfAnnotationFlags Invisible;
    public static PdfAnnotationFlags Hidden;
    public static PdfAnnotationFlags Print;
    public static PdfAnnotationFlags NoZoom;
    public static PdfAnnotationFlags NoRotate;
    public static PdfAnnotationFlags NoView;
    public static PdfAnnotationFlags ReadOnly;
    public static PdfAnnotationFlags Locked;
    public static PdfAnnotationFlags ToggleNoView;
}
public enum Syncfusion.Pdf.Interactive.PdfAnnotationIntent : Enum {
    public int value__;
    public static PdfAnnotationIntent FreeTextCallout;
    public static PdfAnnotationIntent FreeTextTypeWriter;
    public static PdfAnnotationIntent None;
}
public enum Syncfusion.Pdf.Interactive.PdfAnnotationRotateAngle : Enum {
    public int value__;
    public static PdfAnnotationRotateAngle RotateAngle0;
    public static PdfAnnotationRotateAngle RotateAngle90;
    public static PdfAnnotationRotateAngle RotateAngle180;
    public static PdfAnnotationRotateAngle RotateAngle270;
}
public enum Syncfusion.Pdf.Interactive.PdfAnnotationState : Enum {
    public int value__;
    public static PdfAnnotationState None;
    public static PdfAnnotationState Accepted;
    public static PdfAnnotationState Rejected;
    public static PdfAnnotationState Cancelled;
    public static PdfAnnotationState Completed;
    public static PdfAnnotationState Marked;
    public static PdfAnnotationState Unmarked;
    public static PdfAnnotationState Unknown;
}
public enum Syncfusion.Pdf.Interactive.PdfAnnotationStateModel : Enum {
    public int value__;
    public static PdfAnnotationStateModel None;
    public static PdfAnnotationStateModel Marked;
    public static PdfAnnotationStateModel Review;
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class Syncfusion.Pdf.Interactive.PdfAppearance : object {
    private PdfTemplate m_templateNormal;
    private PdfTemplate m_templateMouseHover;
    private PdfTemplate m_templatePressed;
    private PdfAnnotation m_annotation;
    private PdfDictionary m_dictionary;
    private PdfTemplate m_appearanceLayer;
    internal bool IsCompletedValidationAppearance;
    public PdfTemplate Normal { get; public set; }
    public PdfTemplate MouseHover { get; public set; }
    public PdfTemplate Pressed { get; public set; }
    internal PdfTemplate AppearanceLayer { get; }
    private IPdfPrimitive Syncfusion.Pdf.IPdfWrapper.Element { get; }
    public PdfAppearance(PdfAnnotation annotation);
    public PdfTemplate get_Normal();
    public void set_Normal(PdfTemplate value);
    public PdfTemplate get_MouseHover();
    public void set_MouseHover(PdfTemplate value);
    public PdfTemplate get_Pressed();
    public void set_Pressed(PdfTemplate value);
    internal PdfTemplate get_AppearanceLayer();
    internal PdfTemplate GetNormalTemplate();
    internal PdfTemplate GetPressedTemplate();
    private sealed virtual override IPdfPrimitive Syncfusion.Pdf.IPdfWrapper.get_Element();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public abstract class Syncfusion.Pdf.Interactive.PdfAppearanceField : PdfStyledField {
    public PdfAppearance Appearance { get; }
    protected PdfAppearanceField(PdfPageBase page, string name);
    public PdfAppearance get_Appearance();
    internal virtual void Save();
    internal virtual void Draw();
    protected virtual void DrawAppearance(PdfTemplate template);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class Syncfusion.Pdf.Interactive.PdfAppearanceState : object {
    private PdfTemplate m_on;
    private PdfTemplate m_off;
    private PdfDictionary m_dictionary;
    private string m_onMappingName;
    private string m_offMappingName;
    public PdfTemplate On { get; public set; }
    public PdfTemplate Off { get; public set; }
    public string OnMappingName { get; public set; }
    public string OffMappingName { get; public set; }
    private IPdfPrimitive Syncfusion.Pdf.IPdfWrapper.Element { get; }
    public PdfTemplate get_On();
    public void set_On(PdfTemplate value);
    public PdfTemplate get_Off();
    public void set_Off(PdfTemplate value);
    public string get_OnMappingName();
    public void set_OnMappingName(string value);
    public string get_OffMappingName();
    public void set_OffMappingName(string value);
    private void Dictionary_BeginSave(object sender, SavePdfPrimitiveEventArgs ars);
    private sealed virtual override IPdfPrimitive Syncfusion.Pdf.IPdfWrapper.get_Element();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class Syncfusion.Pdf.Interactive.PdfAttachment : PdfEmbeddedFileSpecification {
    internal PdfAttachment(string fileName);
    public PdfAttachment(string fileName, Byte[] data);
    public PdfAttachment(string fileName, Stream stream);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class Syncfusion.Pdf.Interactive.PdfAttachmentAnnotation : PdfFileAnnotation {
    private PdfAttachmentIcon m_attachmentIcon;
    private PdfEmbeddedFileSpecification m_fileSpecification;
    public PdfAttachmentIcon Icon { get; public set; }
    public string FileName { get; public set; }
    public PdfPopupAnnotationCollection ReviewHistory { get; }
    public PdfPopupAnnotationCollection Comments { get; }
    public PdfAttachmentAnnotation(RectangleF rectangle, string fileName, Byte[] data);
    public PdfAttachmentAnnotation(RectangleF rectangle, string fileName, Stream stream);
    public PdfAttachmentIcon get_Icon();
    public void set_Icon(PdfAttachmentIcon value);
    public virtual string get_FileName();
    public virtual void set_FileName(string value);
    public PdfPopupAnnotationCollection get_ReviewHistory();
    public PdfPopupAnnotationCollection get_Comments();
    protected virtual void Initialize();
    protected virtual void Save();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[DefaultMemberAttribute("Item")]
public class Syncfusion.Pdf.Interactive.PdfAttachmentCollection : PdfCollection {
    private PdfArray m_array;
    private PdfDictionary m_dictionary;
    private Dictionary`2<string, PdfReferenceHolder> dic;
    private List`1<string> orderList;
    private int count;
    internal PdfCrossTable m_CrossTable;
    private PdfMainObjectCollection m_objectCollection;
    private PdfDictionary attachmentDictionay;
    public PdfAttachment Item { get; }
    internal PdfArray ArrayList { get; }
    private IPdfPrimitive Syncfusion.Pdf.IPdfWrapper.Element { get; }
    internal PdfAttachmentCollection(PdfDictionary attachmentDictionary, PdfCrossTable table);
    private void attachmentInformation(PdfArray m_array);
    public PdfAttachment get_Item(int index);
    internal PdfArray get_ArrayList();
    public int Add(PdfAttachment attachment);
    public void Insert(int index, PdfAttachment attachment);
    public void Remove(PdfAttachment attachment);
    public void RemoveAt(int index);
    public int IndexOf(PdfAttachment attachment);
    public bool Contains(PdfAttachment attachment);
    public void Clear();
    private int DoAdd(PdfAttachment attachment);
    private void DoInsert(int index, PdfAttachment attachment);
    private void DoRemove(PdfAttachment attachment);
    private void DoRemoveAt(int index);
    private void DoClear();
    private void RemoveAttachementObjects(PdfDictionary attachmentDictionary);
    private PdfAttachmentRelationship ObtainRelationShip(string relation);
    private sealed virtual override IPdfPrimitive Syncfusion.Pdf.IPdfWrapper.get_Element();
}
public enum Syncfusion.Pdf.Interactive.PdfAttachmentIcon : Enum {
    public int value__;
    public static PdfAttachmentIcon PushPin;
    public static PdfAttachmentIcon Tag;
    public static PdfAttachmentIcon Graph;
    public static PdfAttachmentIcon Paperclip;
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class Syncfusion.Pdf.Interactive.PdfBookmark : PdfBookmarkBase {
    private PdfDestination m_destination;
    private PdfNamedDestination m_namedDestination;
    private PdfColor m_color;
    private PdfTextStyle m_textStyle;
    private PdfBookmark m_previous;
    private PdfBookmark m_next;
    private PdfBookmarkBase m_parent;
    private PdfAction m_action;
    public PdfDestination Destination { get; public set; }
    public PdfNamedDestination NamedDestination { get; public set; }
    public string Title { get; public set; }
    public PdfColor Color { get; public set; }
    public PdfTextStyle TextStyle { get; public set; }
    public PdfAction Action { get; public set; }
    public bool IsExpanded { get; public set; }
    internal PdfBookmark Previous { get; internal set; }
    internal PdfBookmarkBase Parent { get; }
    internal PdfBookmark Next { get; internal set; }
    internal PdfBookmark(string title, PdfBookmarkBase parent, PdfBookmark previous, PdfBookmark next);
    internal PdfBookmark(string title, PdfBookmarkBase parent, PdfBookmark previous, PdfBookmark next, PdfDestination dest);
    internal PdfBookmark(PdfDictionary dictionary, PdfCrossTable crossTable);
    public virtual PdfDestination get_Destination();
    public virtual void set_Destination(PdfDestination value);
    public virtual PdfNamedDestination get_NamedDestination();
    public virtual void set_NamedDestination(PdfNamedDestination value);
    public virtual string get_Title();
    public virtual void set_Title(string value);
    public virtual PdfColor get_Color();
    public virtual void set_Color(PdfColor value);
    public virtual PdfTextStyle get_TextStyle();
    public virtual void set_TextStyle(PdfTextStyle value);
    public PdfAction get_Action();
    public void set_Action(PdfAction value);
    public bool get_IsExpanded();
    public void set_IsExpanded(bool value);
    internal virtual PdfBookmark get_Previous();
    internal virtual void set_Previous(PdfBookmark value);
    internal virtual PdfBookmarkBase get_Parent();
    internal virtual PdfBookmark get_Next();
    internal virtual void set_Next(PdfBookmark value);
    internal void SetParent(PdfBookmarkBase parent);
    private void UpdateColor();
    private void UpdateTextStyle();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[DefaultMemberAttribute("Item")]
public class Syncfusion.Pdf.Interactive.PdfBookmarkBase : object {
    private List`1<PdfBookmarkBase> m_list;
    private PdfDictionary m_dictionary;
    private PdfCrossTable m_crossTable;
    private List`1<PdfBookmark> bookmark;
    private List`1<PdfBookmarkBase> m_booklist;
    private bool m_isExpanded;
    private int parentIndex;
    internal List`1<long> m_bookmarkReference;
    public int Count { get; }
    public PdfBookmark Item { get; }
    internal List`1<PdfBookmarkBase> List { get; }
    internal PdfDictionary Dictionary { get; }
    internal PdfCrossTable CrossTable { get; }
    internal bool IsExpanded { get; internal set; }
    private IPdfPrimitive Syncfusion.Pdf.IPdfWrapper.Element { get; }
    internal PdfBookmarkBase(PdfDictionary dictionary, PdfCrossTable crossTable);
    public int get_Count();
    public PdfBookmark get_Item(int index);
    internal virtual List`1<PdfBookmarkBase> get_List();
    internal PdfDictionary get_Dictionary();
    internal PdfCrossTable get_CrossTable();
    internal bool get_IsExpanded();
    internal void set_IsExpanded(bool value);
    public PdfBookmark Add(string title);
    public bool Contains(PdfBookmark outline);
    public void Remove(string title);
    private void ChildBookmark(List`1<PdfBookmarkBase> pdfBookmarkList);
    public void RemoveAt(int index);
    public void Clear();
    public PdfBookmark Insert(int index, string title);
    private void GetBookmarkCollection(List`1<PdfBookmark> pageBookmarks, List`1<PdfBookmark> bookmarks);
    internal void Dispose();
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
    internal void ReproduceTree();
    private void UpdateFields();
    private PdfLoadedBookmark GetFirstBookMark(PdfBookmarkBase bookmark);
    private sealed virtual override IPdfPrimitive Syncfusion.Pdf.IPdfWrapper.get_Element();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class Syncfusion.Pdf.Interactive.PdfBorderEffect : object {
    private PdfDictionary m_dictionary;
    private PdfBorderEffectStyle m_style;
    private float m_intensity;
    public PdfBorderEffectStyle Style { get; public set; }
    public float Intensity { get; public set; }
    internal PdfDictionary Dictionary { get; }
    private IPdfPrimitive Syncfusion.Pdf.IPdfWrapper.Element { get; }
    internal PdfBorderEffect(PdfDictionary dictionary);
    public PdfBorderEffectStyle get_Style();
    public void set_Style(PdfBorderEffectStyle value);
    public float get_Intensity();
    public void set_Intensity(float value);
    internal PdfDictionary get_Dictionary();
    protected void Initialize();
    private void Dictionary_BeginSave(object sender, SavePdfPrimitiveEventArgs ars);
    private string StyleToEffect(PdfBorderEffectStyle effect);
    private PdfBorderEffectStyle GetBorderEffect(string beffect);
    private sealed virtual override IPdfPrimitive Syncfusion.Pdf.IPdfWrapper.get_Element();
}
public enum Syncfusion.Pdf.Interactive.PdfBorderEffectStyle : Enum {
    public int value__;
    public static PdfBorderEffectStyle Solid;
    public static PdfBorderEffectStyle Cloudy;
}
public enum Syncfusion.Pdf.Interactive.PdfBorderStyle : Enum {
    public int value__;
    public static PdfBorderStyle Solid;
    public static PdfBorderStyle Dashed;
    public static PdfBorderStyle Beveled;
    public static PdfBorderStyle Inset;
    public static PdfBorderStyle Underline;
    public static PdfBorderStyle Dot;
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class Syncfusion.Pdf.Interactive.PdfButtonField : PdfAppearanceField {
    private string m_text;
    public bool ComplexScript { get; public set; }
    public string Text { get; public set; }
    public PdfButtonField(PdfPageBase page, string name);
    public bool get_ComplexScript();
    public void set_ComplexScript(bool value);
    public string get_Text();
    public void set_Text(string value);
    public void AddPrintAction();
    internal virtual void Draw();
    internal virtual void Save();
    protected virtual void Initialize();
    protected virtual void DrawAppearance(PdfTemplate template);
    protected void DrawPressedAppearance(PdfTemplate template);
}
public class Syncfusion.Pdf.Interactive.PdfCheckBoxField : PdfCheckFieldBase {
    private bool m_checked;
    public bool Checked { get; public set; }
    [NullableContextAttribute("1")]
public PdfCheckBoxField(PdfPageBase page, string name);
    public bool get_Checked();
    public void set_Checked(bool value);
    internal virtual void Save();
    internal virtual void Draw();
    protected virtual void DrawAppearance();
}
public enum Syncfusion.Pdf.Interactive.PdfCheckBoxStyle : Enum {
    public int value__;
    public static PdfCheckBoxStyle Check;
    public static PdfCheckBoxStyle Circle;
    public static PdfCheckBoxStyle Cross;
    public static PdfCheckBoxStyle Diamond;
    public static PdfCheckBoxStyle Square;
    public static PdfCheckBoxStyle Star;
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class Syncfusion.Pdf.Interactive.PdfCheckFieldBase : PdfStyledField {
    private PdfCheckBoxStyle m_style;
    private PdfTemplate m_checkedTemplate;
    private PdfTemplate m_uncheckedTemplate;
    private PdfTemplate m_pressedCheckedTemplate;
    private PdfTemplate m_pressedUncheckedTemplate;
    public PdfCheckBoxStyle Style { get; public set; }
    internal PdfTemplate CheckedTemplate { get; internal set; }
    internal PdfTemplate UncheckedTemplate { get; internal set; }
    internal PdfTemplate PressedCheckedTemplate { get; internal set; }
    internal PdfTemplate PressedUncheckedTemplate { get; internal set; }
    public PdfCheckFieldBase(PdfPageBase page, string name);
    public PdfCheckBoxStyle get_Style();
    public void set_Style(PdfCheckBoxStyle value);
    internal PdfTemplate get_CheckedTemplate();
    internal void set_CheckedTemplate(PdfTemplate value);
    internal PdfTemplate get_UncheckedTemplate();
    internal void set_UncheckedTemplate(PdfTemplate value);
    internal PdfTemplate get_PressedCheckedTemplate();
    internal void set_PressedCheckedTemplate(PdfTemplate value);
    internal PdfTemplate get_PressedUncheckedTemplate();
    internal void set_PressedUncheckedTemplate(PdfTemplate value);
    protected string StyleToString(PdfCheckBoxStyle style);
    protected virtual void Initialize();
    internal virtual void Save();
    protected virtual void DrawAppearance();
    private void CreateTemplate(PdfTemplate& template);
    private void ReleaseTemplate(PdfTemplate template);
    internal virtual void Draw();
}
internal enum Syncfusion.Pdf.Interactive.PdfCheckFieldState : Enum {
    public int value__;
    public static PdfCheckFieldState Unchecked;
    public static PdfCheckFieldState Checked;
    public static PdfCheckFieldState PressedUnchecked;
    public static PdfCheckFieldState PressedChecked;
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class Syncfusion.Pdf.Interactive.PdfCircleAnnotation : PdfAnnotation {
    private LineBorder m_border;
    private float m_borderWidth;
    private PdfBorderEffect _mBorderEffect;
    public PdfPopupAnnotationCollection ReviewHistory { get; }
    public PdfPopupAnnotationCollection Comments { get; }
    public LineBorder Border { get; public set; }
    public PdfBorderEffect BorderEffect { get; public set; }
    public PdfCircleAnnotation(RectangleF rectangle, string text);
    public PdfCircleAnnotation(RectangleF rectangle);
    public PdfPopupAnnotationCollection get_ReviewHistory();
    public PdfPopupAnnotationCollection get_Comments();
    public LineBorder get_Border();
    public void set_Border(LineBorder value);
    public PdfBorderEffect get_BorderEffect();
    public void set_BorderEffect(PdfBorderEffect value);
    protected virtual void Initialize();
    internal virtual void FlattenAnnot(bool flattenPopUps);
    private void SaveAndFlatten(bool isExternalFlatten, bool isExternalFlattenPopUps);
    protected virtual void Save();
    private void FlattenAnnotation(PdfPageBase page, PdfTemplate appearance);
    private PdfTemplate CreateAppearance();
    private void UpdateBorderEffects();
    private PdfArray GetMatrix(PdfTransformationMatrix translatedMatrix);
    private PdfTemplate CreateCloudyAppearance();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class Syncfusion.Pdf.Interactive.PdfCircleMeasurementAnnotation : PdfAnnotation {
    private LineBorder m_border;
    private PdfMeasurementUnit m_measurementUnit;
    private PdfCircleMeasurementType m_type;
    private PdfFont m_font;
    private string m_unitString;
    private float m_borderWidth;
    public LineBorder Border { get; public set; }
    public PdfMeasurementUnit Unit { get; public set; }
    public PdfCircleMeasurementType MeasurementType { get; public set; }
    public PdfFont Font { get; public set; }
    public PdfPopupAnnotationCollection Comments { get; }
    public PdfPopupAnnotationCollection ReviewHistory { get; }
    public PdfCircleMeasurementAnnotation(RectangleF rectangle);
    public LineBorder get_Border();
    public void set_Border(LineBorder value);
    public PdfMeasurementUnit get_Unit();
    public void set_Unit(PdfMeasurementUnit value);
    public PdfCircleMeasurementType get_MeasurementType();
    public void set_MeasurementType(PdfCircleMeasurementType value);
    public PdfFont get_Font();
    public void set_Font(PdfFont value);
    public PdfPopupAnnotationCollection get_Comments();
    public PdfPopupAnnotationCollection get_ReviewHistory();
    protected virtual void Initialize();
    private float ConvertToUnit();
    protected virtual void Save();
}
public enum Syncfusion.Pdf.Interactive.PdfCircleMeasurementType : Enum {
    public int value__;
    public static PdfCircleMeasurementType Diameter;
    public static PdfCircleMeasurementType Radius;
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class Syncfusion.Pdf.Interactive.PdfComboBoxField : PdfListField {
    private bool m_editable;
    public bool ComplexScript { get; public set; }
    public bool Editable { get; public set; }
    public PdfComboBoxField(PdfPageBase page, string name);
    public bool get_ComplexScript();
    public void set_ComplexScript(bool value);
    public bool get_Editable();
    public void set_Editable(bool value);
    internal virtual void Draw();
    protected virtual void Initialize();
    protected virtual void DrawAppearance(PdfTemplate template);
    internal float GetFontHeight(PdfFontFamily family);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Syncfusion.Pdf.Interactive.PdfDefaultAppearance : object {
    private PdfColor m_foreColor;
    private string m_fontName;
    private float m_fontSize;
    public string FontName { get; public set; }
    public float FontSize { get; public set; }
    public PdfColor ForeColor { get; public set; }
    public string get_FontName();
    public void set_FontName(string value);
    public float get_FontSize();
    public void set_FontSize(float value);
    public PdfColor get_ForeColor();
    public void set_ForeColor(PdfColor value);
    public virtual string ToString();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class Syncfusion.Pdf.Interactive.PdfDestination : object {
    private PdfDestinationMode m_destinationMode;
    private float m_zoom;
    private PointF m_location;
    private RectangleF m_bounds;
    private PdfPageBase m_page;
    private int m_index;
    private PdfArray m_array;
    private bool m_isValid;
    internal bool isModified;
    public float Zoom { get; public set; }
    public PdfPageBase Page { get; public set; }
    public int PageIndex { get; internal set; }
    public PdfDestinationMode Mode { get; public set; }
    public PointF Location { get; public set; }
    internal RectangleF Bounds { get; internal set; }
    public bool IsValid { get; }
    private IPdfPrimitive Syncfusion.Pdf.IPdfWrapper.Element { get; }
    public PdfDestination(PdfPageBase page);
    public PdfDestination(PdfPageBase page, PointF location);
    internal PdfDestination(PdfPageBase page, RectangleF rect);
    public float get_Zoom();
    public void set_Zoom(float value);
    public PdfPageBase get_Page();
    public void set_Page(PdfPageBase value);
    public int get_PageIndex();
    internal void set_PageIndex(int value);
    public PdfDestinationMode get_Mode();
    public void set_Mode(PdfDestinationMode value);
    public PointF get_Location();
    public void set_Location(PointF value);
    internal RectangleF get_Bounds();
    internal void set_Bounds(RectangleF value);
    public bool get_IsValid();
    internal void SetValidation(bool valid);
    private PointF PointToNativePdf(PdfPage page, PointF point);
    private void InitializePrimitive();
    private void Initialize();
    private sealed virtual override IPdfPrimitive Syncfusion.Pdf.IPdfWrapper.get_Element();
}
public enum Syncfusion.Pdf.Interactive.PdfDestinationMode : Enum {
    public int value__;
    public static PdfDestinationMode Location;
    public static PdfDestinationMode FitToPage;
    public static PdfDestinationMode FitR;
    public static PdfDestinationMode FitH;
    public static PdfDestinationMode FitV;
    public static PdfDestinationMode FitB;
    public static PdfDestinationMode FitBH;
    public static PdfDestinationMode FitBV;
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class Syncfusion.Pdf.Interactive.PdfDocumentActions : object {
    private PdfDictionary m_dictionary;
    private PdfAction m_afterOpen;
    private PdfAction m_beforeClose;
    private PdfJavaScriptAction m_beforeSave;
    private PdfJavaScriptAction m_afterSave;
    private PdfJavaScriptAction m_beforePrint;
    private PdfJavaScriptAction m_afterPrint;
    private PdfCatalog m_catalog;
    public PdfAction AfterOpen { get; public set; }
    public PdfJavaScriptAction BeforeClose { get; public set; }
    public PdfJavaScriptAction BeforeSave { get; public set; }
    public PdfJavaScriptAction AfterSave { get; public set; }
    public PdfJavaScriptAction BeforePrint { get; public set; }
    public PdfJavaScriptAction AfterPrint { get; public set; }
    private IPdfPrimitive Syncfusion.Pdf.IPdfWrapper.Element { get; }
    internal PdfDocumentActions(PdfCatalog catalog);
    public PdfAction get_AfterOpen();
    public void set_AfterOpen(PdfAction value);
    private PdfJavaScriptAction GetAfterOpenDictionary();
    private void RemoveJavaScriptAction();
    public PdfJavaScriptAction get_BeforeClose();
    public void set_BeforeClose(PdfJavaScriptAction value);
    private PdfJavaScriptAction GetBeforeCloseDictionary();
    public PdfJavaScriptAction get_BeforeSave();
    public void set_BeforeSave(PdfJavaScriptAction value);
    private PdfJavaScriptAction GetBeforeSaveDictionary();
    public PdfJavaScriptAction get_AfterSave();
    public void set_AfterSave(PdfJavaScriptAction value);
    private PdfJavaScriptAction GetAfterSaveDictionary();
    public PdfJavaScriptAction get_BeforePrint();
    public void set_BeforePrint(PdfJavaScriptAction value);
    private PdfJavaScriptAction GetBeforePrintDictionary();
    public PdfJavaScriptAction get_AfterPrint();
    public void set_AfterPrint(PdfJavaScriptAction value);
    private PdfJavaScriptAction GetAfterPrintDictionary();
    private sealed virtual override IPdfPrimitive Syncfusion.Pdf.IPdfWrapper.get_Element();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class Syncfusion.Pdf.Interactive.PdfDocumentLinkAnnotation : PdfLinkAnnotation {
    private PdfDestination m_destination;
    public PdfDestination Destination { get; public set; }
    public PdfDocumentLinkAnnotation(RectangleF rectangle);
    public PdfDocumentLinkAnnotation(RectangleF rectangle, PdfDestination destination);
    public PdfDestination get_Destination();
    public void set_Destination(PdfDestination value);
    protected virtual void Save();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class Syncfusion.Pdf.Interactive.PdfEllipseAnnotation : PdfCircleAnnotation {
    public PdfPopupAnnotationCollection ReviewHistory { get; }
    public PdfPopupAnnotationCollection Comments { get; }
    public PdfEllipseAnnotation(RectangleF rectangle, string text);
    public PdfPopupAnnotationCollection get_ReviewHistory();
    public PdfPopupAnnotationCollection get_Comments();
    protected virtual void Initialize();
    internal virtual void FlattenAnnot(bool flattenPopUps);
    protected virtual void Save();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class Syncfusion.Pdf.Interactive.PdfEmbeddedFileSpecification : PdfFileSpecificationBase {
    private string m_description;
    private EmbeddedFile m_embeddedFile;
    private PdfDictionary m_dictionary;
    private PdfPortfolioAttributes m_portfolioAttributes;
    private PdfAttachmentRelationship m_relationShip;
    public string FileName { get; public set; }
    public Byte[] Data { get; public set; }
    public string Description { get; public set; }
    public string MimeType { get; public set; }
    public DateTime CreationDate { get; public set; }
    public DateTime ModificationDate { get; public set; }
    public PdfPortfolioAttributes PortfolioAttributes { get; public set; }
    internal EmbeddedFile EmbeddedFile { get; }
    public PdfAttachmentRelationship Relationship { get; public set; }
    public PdfEmbeddedFileSpecification(string fileName);
    public PdfEmbeddedFileSpecification(string fileName, Byte[] data);
    public PdfEmbeddedFileSpecification(string fileName, Stream stream);
    public virtual string get_FileName();
    public virtual void set_FileName(string value);
    public Byte[] get_Data();
    public void set_Data(Byte[] value);
    public string get_Description();
    public void set_Description(string value);
    public string get_MimeType();
    public void set_MimeType(string value);
    public DateTime get_CreationDate();
    public void set_CreationDate(DateTime value);
    public DateTime get_ModificationDate();
    public void set_ModificationDate(DateTime value);
    public PdfPortfolioAttributes get_PortfolioAttributes();
    public void set_PortfolioAttributes(PdfPortfolioAttributes value);
    internal EmbeddedFile get_EmbeddedFile();
    public PdfAttachmentRelationship get_Relationship();
    public void set_Relationship(PdfAttachmentRelationship value);
    protected virtual void Initialize();
    protected virtual void Save();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class Syncfusion.Pdf.Interactive.PdfExtendedAppearance : object {
    private PdfAppearanceState m_normal;
    private PdfAppearanceState m_pressed;
    private PdfAppearanceState m_mouseHover;
    private PdfDictionary m_dictionary;
    public PdfAppearanceState Normal { get; }
    public PdfAppearanceState MouseHover { get; }
    public PdfAppearanceState Pressed { get; }
    private IPdfPrimitive Syncfusion.Pdf.IPdfWrapper.Element { get; }
    public PdfAppearanceState get_Normal();
    public PdfAppearanceState get_MouseHover();
    public PdfAppearanceState get_Pressed();
    private sealed virtual override IPdfPrimitive Syncfusion.Pdf.IPdfWrapper.get_Element();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public abstract class Syncfusion.Pdf.Interactive.PdfField : object {
    private string m_name;
    private PdfPageBase m_page;
    private FieldFlags m_flags;
    private PdfForm m_form;
    private string m_mappingName;
    private bool m_export;
    private bool m_readOnly;
    private bool m_required;
    private string m_toolTip;
    private PdfDictionary m_dictionary;
    private bool m_flatten;
    private bool m_disableAutoFormat;
    private int m_rotationAngle;
    internal bool isXfa;
    private PdfTag m_tag;
    private int m_tabIndex;
    private int m_annotationIndex;
    private bool m_complexScript;
    private PdfLayer layer;
    internal PdfLoadedStyledField m_loadedStyleField;
    [CompilerGeneratedAttribute]
private PropertyChangedEventHandler PropertyChanged;
    public string Name { get; }
    public PdfForm Form { get; }
    public string MappingName { get; public set; }
    public bool Export { get; public set; }
    public bool ReadOnly { get; public set; }
    public bool Required { get; public set; }
    public string ToolTip { get; public set; }
    public PdfPageBase Page { get; internal set; }
    internal bool ComplexScript { get; internal set; }
    public bool Flatten { get; public set; }
    internal FieldFlags Flags { get; internal set; }
    internal PdfDictionary Dictionary { get; internal set; }
    internal int RotationAngle { get; internal set; }
    public bool DisableAutoFormat { get; public set; }
    public PdfTag PdfTag { get; public set; }
    public int TabIndex { get; public set; }
    internal int AnnotationIndex { get; internal set; }
    public PdfLayer Layer { get; public set; }
    private IPdfPrimitive Syncfusion.Pdf.IPdfWrapper.Element { get; }
    public PdfField(PdfPageBase page, string name);
    [CompilerGeneratedAttribute]
public sealed virtual void add_PropertyChanged(PropertyChangedEventHandler value);
    [CompilerGeneratedAttribute]
public sealed virtual void remove_PropertyChanged(PropertyChangedEventHandler value);
    internal void NotifyPropertyChanged(string propertyName, int m_index);
    internal void NotifyPropertyChanged(string propertyName);
    public virtual string get_Name();
    public virtual PdfForm get_Form();
    public virtual string get_MappingName();
    public virtual void set_MappingName(string value);
    public virtual bool get_Export();
    public virtual void set_Export(bool value);
    public virtual bool get_ReadOnly();
    public virtual void set_ReadOnly(bool value);
    public virtual bool get_Required();
    public virtual void set_Required(bool value);
    public virtual string get_ToolTip();
    public virtual void set_ToolTip(string value);
    public virtual PdfPageBase get_Page();
    internal virtual void set_Page(PdfPageBase value);
    internal bool get_ComplexScript();
    internal void set_ComplexScript(bool value);
    public bool get_Flatten();
    public void set_Flatten(bool value);
    internal virtual FieldFlags get_Flags();
    internal virtual void set_Flags(FieldFlags value);
    internal PdfDictionary get_Dictionary();
    internal void set_Dictionary(PdfDictionary value);
    internal int get_RotationAngle();
    internal void set_RotationAngle(int value);
    public bool get_DisableAutoFormat();
    public void set_DisableAutoFormat(bool value);
    public PdfTag get_PdfTag();
    public void set_PdfTag(PdfTag value);
    public int get_TabIndex();
    public void set_TabIndex(int value);
    internal int get_AnnotationIndex();
    internal void set_AnnotationIndex(int value);
    public PdfLayer get_Layer();
    public void set_Layer(PdfLayer value);
    public string GetValue(string key);
    public void SetValue(string key, string value);
    internal void SetForm(PdfForm form);
    internal virtual void Save();
    internal abstract virtual void Draw();
    internal virtual void ApplyName(string name);
    internal virtual PdfField Clone(PdfPageBase page);
    protected virtual void DefineDefaultAppearance();
    protected virtual void Initialize();
    private void Dictionary_BeginSave(object sender, SavePdfPrimitiveEventArgs ars);
    private PdfLayer GetDocumentLayer();
    private void IsMatched(PdfDocumentLayerCollection layerCollection, IPdfPrimitive expectedObject, PdfLoadedPage page);
    internal PdfArray GetCropOrMediaBox(PdfPageBase page, PdfArray cropOrMediaBox);
    private sealed virtual override IPdfPrimitive Syncfusion.Pdf.IPdfWrapper.get_Element();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class Syncfusion.Pdf.Interactive.PdfFieldActions : object {
    private PdfAnnotationActions m_annotationActions;
    private PdfDictionary m_dictionary;
    private PdfJavaScriptAction m_keyPressed;
    private PdfJavaScriptAction m_format;
    private PdfJavaScriptAction m_validate;
    private PdfJavaScriptAction m_calculate;
    public PdfJavaScriptAction KeyPressed { get; public set; }
    public PdfJavaScriptAction Format { get; public set; }
    public PdfJavaScriptAction Validate { get; public set; }
    public PdfJavaScriptAction Calculate { get; public set; }
    public PdfAction MouseEnter { get; public set; }
    public PdfAction MouseLeave { get; public set; }
    public PdfAction MouseUp { get; public set; }
    public PdfAction MouseDown { get; public set; }
    public PdfAction GotFocus { get; public set; }
    public PdfAction LostFocus { get; public set; }
    private IPdfPrimitive Syncfusion.Pdf.IPdfWrapper.Element { get; }
    public PdfFieldActions(PdfAnnotationActions annotationActions);
    public PdfJavaScriptAction get_KeyPressed();
    public void set_KeyPressed(PdfJavaScriptAction value);
    public PdfJavaScriptAction get_Format();
    public void set_Format(PdfJavaScriptAction value);
    public PdfJavaScriptAction get_Validate();
    public void set_Validate(PdfJavaScriptAction value);
    public PdfJavaScriptAction get_Calculate();
    public void set_Calculate(PdfJavaScriptAction value);
    public PdfAction get_MouseEnter();
    public void set_MouseEnter(PdfAction value);
    public PdfAction get_MouseLeave();
    public void set_MouseLeave(PdfAction value);
    public PdfAction get_MouseUp();
    public void set_MouseUp(PdfAction value);
    public PdfAction get_MouseDown();
    public void set_MouseDown(PdfAction value);
    public PdfAction get_GotFocus();
    public void set_GotFocus(PdfAction value);
    public PdfAction get_LostFocus();
    public void set_LostFocus(PdfAction value);
    private sealed virtual override IPdfPrimitive Syncfusion.Pdf.IPdfWrapper.get_Element();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[DefaultMemberAttribute("Item")]
public class Syncfusion.Pdf.Interactive.PdfFieldCollection : PdfCollection {
    internal string c_exisingFieldException;
    private PdfArray m_array;
    private Dictionary`2<string, int> m_fieldNames;
    public PdfField Item { get; }
    public PdfField Item { get; }
    internal PdfArray Items { get; }
    private IPdfPrimitive Syncfusion.Pdf.IPdfWrapper.Element { get; }
    public virtual PdfField get_Item(int index);
    public PdfField get_Item(string name);
    internal PdfArray get_Items();
    public int Add(PdfField field);
    internal void Add(PdfXfaForm collection, string subformName);
    public void Insert(int index, PdfField field);
    public bool Contains(PdfField field);
    public int IndexOf(PdfField field);
    public void Remove(PdfField field);
    public void RemoveAt(int index);
    public void Clear();
    internal int Add(PdfField field, PdfPageBase newPage);
    protected virtual void DoAdd(PdfXfaForm form, string subformName);
    protected virtual int DoAdd(PdfField field);
    protected virtual void DoInsert(int index, PdfField field);
    protected virtual void DoRemove(PdfField field);
    protected virtual void DoRemoveAt(int index);
    protected virtual void DoClear();
    internal bool RemoveContainingFieldItems(PdfDictionary fieldDictionary, PdfReferenceHolder pageReferenceHolder, Boolean& removeField);
    private PdfField InsertLoadedField(PdfLoadedField field, PdfPageBase newPage);
    private void UpdateReferences(PdfArray kidsArray, PdfArray array, PdfArray newArray, PdfField field);
    private int GetFieldIndex(string name);
    private sealed virtual override IPdfPrimitive Syncfusion.Pdf.IPdfWrapper.get_Element();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public abstract class Syncfusion.Pdf.Interactive.PdfFileAnnotation : PdfAnnotation {
    private PdfAppearance m_appearance;
    public string FileName { get; public set; }
    public PdfAppearance Appearance { get; public set; }
    protected PdfFileAnnotation(RectangleF rectangle);
    public abstract virtual string get_FileName();
    public abstract virtual void set_FileName(string value);
    public PdfAppearance get_Appearance();
    public void set_Appearance(PdfAppearance value);
    protected virtual void Save();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class Syncfusion.Pdf.Interactive.PdfFileLinkAnnotation : PdfActionLinkAnnotation {
    private PdfLaunchAction m_action;
    public string FileName { get; public set; }
    public PdfAction Action { get; public set; }
    public PdfFileLinkAnnotation(RectangleF rectangle, string fileName);
    public string get_FileName();
    public void set_FileName(string value);
    public virtual PdfAction get_Action();
    public virtual void set_Action(PdfAction value);
    protected virtual void Save();
}
public enum Syncfusion.Pdf.Interactive.PdfFilePathType : Enum {
    public int value__;
    public static PdfFilePathType Relative;
    public static PdfFilePathType Absolute;
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public abstract class Syncfusion.Pdf.Interactive.PdfFileSpecificationBase : object {
    private PdfDictionary m_dictionary;
    public string FileName { get; public set; }
    internal PdfDictionary Dictionary { get; }
    private IPdfPrimitive Syncfusion.Pdf.IPdfWrapper.Element { get; }
    public PdfFileSpecificationBase(string fileName);
    public abstract virtual string get_FileName();
    public abstract virtual void set_FileName(string value);
    internal PdfDictionary get_Dictionary();
    protected virtual void Initialize();
    protected abstract virtual void Save();
    protected string FormatFileName(string fileName, bool flag);
    private void Dictionary_BeginSave(object sender, SavePdfPrimitiveEventArgs ars);
    private sealed virtual override IPdfPrimitive Syncfusion.Pdf.IPdfWrapper.get_Element();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class Syncfusion.Pdf.Interactive.PdfForm : object {
    private PdfFormFieldCollection m_fields;
    private PdfResources m_resources;
    private bool m_readOnly;
    private SignatureFlags m_signatureFlags;
    private PdfDictionary m_dictionary;
    private bool m_needAppearances;
    private bool m_flatten;
    private bool m_changeName;
    private List`1<string> m_fieldName;
    private List`1<string> m_fieldNames;
    private bool m_isXFA;
    private bool m_disableAutoFormat;
    internal Dictionary`2<PdfDictionary, PdfPageBase> m_pageMap;
    private bool m_setAppearanceDictionary;
    private bool m_isDefaultEncoding;
    private bool m_isDefaultAppearance;
    internal bool isXfaForm;
    private bool m_complexScript;
    internal bool m_enableXfaFormfill;
    private PdfXfaDocument m_xfa;
    [CompilerGeneratedAttribute]
private EventHandler`1<FormPropertyChangedEventArgs> FormFieldPropertyChanged;
    [CompilerGeneratedAttribute]
private EventHandler`1<FormFieldsAddedArgs> FormFieldAdded;
    [CompilerGeneratedAttribute]
private EventHandler`1<FormFieldsRemovedArgs> FormFieldRemoved;
    internal PdfXfaDocument Xfa { get; internal set; }
    internal bool IsDefaultAppearance { get; internal set; }
    public bool ComplexScript { get; public set; }
    public bool IsDefaultEncoding { get; public set; }
    internal List`1<string> FieldNames { get; }
    internal bool IsXFA { get; internal set; }
    public PdfFormFieldCollection Fields { get; }
    public bool Flatten { get; public set; }
    public bool ReadOnly { get; public set; }
    public bool FieldAutoNaming { get; public set; }
    internal bool NeedAppearances { get; internal set; }
    internal SignatureFlags SignatureFlags { get; internal set; }
    internal PdfResources Resources { get; internal set; }
    internal PdfDictionary Dictionary { get; internal set; }
    public bool DisableAutoFormat { get; public set; }
    internal bool SetAppearanceDictionary { get; internal set; }
    private IPdfPrimitive Syncfusion.Pdf.IPdfWrapper.Element { get; }
    [CompilerGeneratedAttribute]
internal void add_FormFieldPropertyChanged(EventHandler`1<FormPropertyChangedEventArgs> value);
    [CompilerGeneratedAttribute]
internal void remove_FormFieldPropertyChanged(EventHandler`1<FormPropertyChangedEventArgs> value);
    [CompilerGeneratedAttribute]
internal void add_FormFieldAdded(EventHandler`1<FormFieldsAddedArgs> value);
    [CompilerGeneratedAttribute]
internal void remove_FormFieldAdded(EventHandler`1<FormFieldsAddedArgs> value);
    [CompilerGeneratedAttribute]
internal void add_FormFieldRemoved(EventHandler`1<FormFieldsRemovedArgs> value);
    [CompilerGeneratedAttribute]
internal void remove_FormFieldRemoved(EventHandler`1<FormFieldsRemovedArgs> value);
    internal void OnFormFieldAdded(FormFieldsAddedArgs e);
    internal void OnFormFieldRemoved(FormFieldsRemovedArgs e);
    internal void OnFormPropertyChanged(FormPropertyChangedEventArgs e);
    internal PdfXfaDocument get_Xfa();
    internal void set_Xfa(PdfXfaDocument value);
    internal bool get_IsDefaultAppearance();
    internal void set_IsDefaultAppearance(bool value);
    public bool get_ComplexScript();
    public void set_ComplexScript(bool value);
    public bool get_IsDefaultEncoding();
    public void set_IsDefaultEncoding(bool value);
    internal List`1<string> get_FieldNames();
    internal bool get_IsXFA();
    internal void set_IsXFA(bool value);
    public PdfFormFieldCollection get_Fields();
    public bool get_Flatten();
    public void set_Flatten(bool value);
    public virtual bool get_ReadOnly();
    public virtual void set_ReadOnly(bool value);
    public bool get_FieldAutoNaming();
    public void set_FieldAutoNaming(bool value);
    internal virtual bool get_NeedAppearances();
    internal virtual void set_NeedAppearances(bool value);
    internal virtual SignatureFlags get_SignatureFlags();
    internal virtual void set_SignatureFlags(SignatureFlags value);
    internal virtual PdfResources get_Resources();
    internal virtual void set_Resources(PdfResources value);
    internal virtual PdfDictionary get_Dictionary();
    internal virtual void set_Dictionary(PdfDictionary value);
    public bool get_DisableAutoFormat();
    public void set_DisableAutoFormat(bool value);
    internal bool get_SetAppearanceDictionary();
    internal void set_SetAppearanceDictionary(bool value);
    private sealed virtual override IPdfPrimitive Syncfusion.Pdf.IPdfWrapper.get_Element();
    internal virtual void Dictionary_BeginSave(object sender, SavePdfPrimitiveEventArgs ars);
    internal virtual void Clear();
    private void CheckFlatten();
    private void AddFieldResourcesToPage(PdfField field);
    internal void DeleteFromPages(PdfField field);
    internal void DeleteAnnotation(PdfField field);
    internal virtual string GetCorrectName(string name);
    public void SetDefaultAppearance(bool applyDefault);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class Syncfusion.Pdf.Interactive.PdfFormAction : PdfAction {
    private bool m_include;
    private PdfFieldCollection m_fields;
    public bool Include { get; public set; }
    public PdfFieldCollection Fields { get; }
    public virtual bool get_Include();
    public virtual void set_Include(bool value);
    public PdfFieldCollection get_Fields();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class Syncfusion.Pdf.Interactive.PdfFormFieldCollection : PdfFieldCollection {
    private PdfForm m_form;
    internal PdfForm Form { get; internal set; }
    internal PdfForm get_Form();
    internal void set_Form(PdfForm value);
    protected virtual int DoAdd(PdfField field);
    protected virtual void DoInsert(int index, PdfField field);
    protected virtual void DoRemove(PdfField field);
    protected virtual void DoRemoveAt(int index);
    protected virtual void DoClear();
    private bool IsValidName(string name);
}
public enum Syncfusion.Pdf.Interactive.PdfFormFieldVisibility : Enum {
    public int value__;
    public static PdfFormFieldVisibility Visible;
    public static PdfFormFieldVisibility Hidden;
    public static PdfFormFieldVisibility VisibleNotPrintable;
    public static PdfFormFieldVisibility HiddenPrintable;
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class Syncfusion.Pdf.Interactive.PdfFreeTextAnnotation : PdfAnnotation {
    private static string c_annotationType;
    private PdfLineEndingStyle m_lineEndingStyle;
    private PdfAnnotationIntent m_annotationIntent;
    private string m_markUpText;
    private PdfFont m_font;
    private PointF[] m_calloutLines;
    private PdfColor m_textMarkupColor;
    private WidgetAnnotation m_widgetAnnotation;
    private PdfColor m_borderColor;
    private PdfMargins m_margins;
    private bool m_complexScript;
    private PdfTextAlignment alignment;
    private PdfTextDirection m_textDirection;
    private float m_lineSpacing;
    private bool isAllRotation;
    private float m_cropBoxValueX;
    private float m_cropBoxValueY;
    private PdfPaddings m_paddings;
    public float LineSpacing { get; public set; }
    public PdfLineEndingStyle LineEndingStyle { get; public set; }
    public PdfAnnotationIntent AnnotationIntent { get; public set; }
    public string MarkupText { get; public set; }
    public PdfFont Font { get; public set; }
    public PointF[] CalloutLines { get; public set; }
    public PdfColor TextMarkupColor { get; public set; }
    public PdfColor BorderColor { get; public set; }
    public PdfPopupAnnotationCollection ReviewHistory { get; }
    public PdfPopupAnnotationCollection Comments { get; }
    public bool ComplexScript { get; public set; }
    public PdfTextAlignment TextAlignment { get; public set; }
    public PdfTextDirection TextDirection { get; public set; }
    public PdfFreeTextAnnotation(RectangleF rectangle);
    public float get_LineSpacing();
    public void set_LineSpacing(float value);
    public PdfLineEndingStyle get_LineEndingStyle();
    public void set_LineEndingStyle(PdfLineEndingStyle value);
    public PdfAnnotationIntent get_AnnotationIntent();
    public void set_AnnotationIntent(PdfAnnotationIntent value);
    public string get_MarkupText();
    public void set_MarkupText(string value);
    public PdfFont get_Font();
    public void set_Font(PdfFont value);
    public PointF[] get_CalloutLines();
    public void set_CalloutLines(PointF[] value);
    public PdfColor get_TextMarkupColor();
    public void set_TextMarkupColor(PdfColor value);
    public PdfColor get_BorderColor();
    public void set_BorderColor(PdfColor value);
    public PdfPopupAnnotationCollection get_ReviewHistory();
    public PdfPopupAnnotationCollection get_Comments();
    public bool get_ComplexScript();
    public void set_ComplexScript(bool value);
    public PdfTextAlignment get_TextAlignment();
    public void set_TextAlignment(PdfTextAlignment value);
    public PdfTextDirection get_TextDirection();
    public void set_TextDirection(PdfTextDirection value);
    protected virtual void Initialize();
    internal virtual void FlattenAnnot(bool flattenPopUps);
    private void SaveAndFlatten(bool isExternalFlatten, bool isExternalFlattenPopUps);
    protected virtual void Save();
    private void FlattenAnnotation(PdfPageBase page, PdfTemplate appearance);
    private void SaveFreeTextDictionary();
    private void UpdateCropBoxValues();
    private Single[] ObtainLinePoints();
    private RectangleF ObtainAppearanceBounds();
    private void ExpandAppearanceForEndLineStyle(PointF[] pointArray);
    private PdfTemplate CreateAppearance();
    private void DrawArrow(PaintParams paintParams, PdfGraphics graphics, PdfPen mBorderPen);
    private void DrawCallOuts(PdfGraphics graphics, PdfPen mBorderPen);
    private PointF[] CalculateArrowPoints(PointF startingPoint, PointF endPoint);
    private void DrawFreeTextRectangle(PdfGraphics graphics, PaintParams paintParams, RectangleF rect);
    private void DrawFreeMarkUpText(PdfGraphics graphics, PaintParams paintParams, RectangleF rect);
    private void SetRectangleDifferance(RectangleF innerRectangle);
    internal void SetPaddings(PdfPaddings paddings);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class Syncfusion.Pdf.Interactive.PdfGoToAction : PdfAction {
    private PdfDestination m_destination;
    public PdfDestination Destination { get; public set; }
    public PdfGoToAction(PdfDestination destination);
    public PdfGoToAction(PdfPage page);
    public PdfDestination get_Destination();
    public void set_Destination(PdfDestination value);
    protected virtual void Initialize();
    private void Dictionary_BeginSave(object sender, SavePdfPrimitiveEventArgs ars);
}
public enum Syncfusion.Pdf.Interactive.PdfHighlightMode : Enum {
    public int value__;
    public static PdfHighlightMode NoHighlighting;
    public static PdfHighlightMode Invert;
    public static PdfHighlightMode Outline;
    public static PdfHighlightMode Push;
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class Syncfusion.Pdf.Interactive.PdfInkAnnotation : PdfAnnotation {
    private List`1<float> m_inkList;
    private bool m_isListAdded;
    private List`1<List`1<float>> m_inkPointsCollection;
    private Int32[] m_dashArray;
    private int m_borderWidth;
    private float m_borderLineWidth;
    private PdfDictionary m_borderDic;
    private PdfLineBorderStyle m_borderStyle;
    internal bool EnableControlPoints;
    private bool isContainsCropOrMediaBox;
    public List`1<float> InkList { get; public set; }
    public List`1<List`1<float>> InkPointsCollection { get; public set; }
    public int BorderWidth { get; public set; }
    internal float BorderLineWidth { get; internal set; }
    public PdfLineBorderStyle BorderStyle { get; public set; }
    public Int32[] DashArray { get; public set; }
    public PdfPopupAnnotationCollection ReviewHistory { get; }
    public PdfPopupAnnotationCollection Comments { get; }
    public PdfInkAnnotation(RectangleF rectangle, List`1<float> linePoints);
    public List`1<float> get_InkList();
    public void set_InkList(List`1<float> value);
    public List`1<List`1<float>> get_InkPointsCollection();
    public void set_InkPointsCollection(List`1<List`1<float>> value);
    public int get_BorderWidth();
    public void set_BorderWidth(int value);
    internal float get_BorderLineWidth();
    internal void set_BorderLineWidth(float value);
    public PdfLineBorderStyle get_BorderStyle();
    public void set_BorderStyle(PdfLineBorderStyle value);
    public Int32[] get_DashArray();
    public void set_DashArray(Int32[] value);
    public PdfPopupAnnotationCollection get_ReviewHistory();
    public PdfPopupAnnotationCollection get_Comments();
    protected virtual void Initialize();
    private void GetBoundsValue();
    private void GetControlPoints(PointF[] pointCollection, PointF[]& controlPointOne, PointF[]& controlPointTwo);
    private Double[] GetSingleControlPoint(Double[] rightVector);
    internal virtual void FlattenAnnot(bool flattenPopUps);
    private void SaveAndFlatten(bool isExternalFlatten, bool isExternalFlattenPopUps);
    protected virtual void Save();
    private void FlattenAnnotation(PdfPageBase page, PdfTemplate appearance);
    internal PdfTemplate CreateAppearance();
    internal void AddInkPoints();
    internal void AddInkPointCollection();
    private void SaveInkDictionary();
    private void CalculateInkBounds(PointF[] pointCollection, bool isTwoPoints);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class Syncfusion.Pdf.Interactive.PdfJavaScriptAction : PdfAction {
    private string m_javaScript;
    public string JavaScript { get; public set; }
    public PdfJavaScriptAction(string javaScript);
    public string get_JavaScript();
    public void set_JavaScript(string value);
    protected virtual void Initialize();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class Syncfusion.Pdf.Interactive.PdfLaunchAction : PdfAction {
    private ReferenceFileSpecification m_fileSpecification;
    private PdfFilePathType m_pathType;
    public string FileName { get; public set; }
    public PdfLaunchAction(string fileName);
    public PdfLaunchAction(string fileName, PdfFilePathType path);
    internal PdfLaunchAction(string fileName, bool loaded);
    public string get_FileName();
    public void set_FileName(string value);
    protected virtual void Initialize();
    private void Dictionary_BeginSave(object sender, SavePdfPrimitiveEventArgs ars);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class Syncfusion.Pdf.Interactive.PdfLineAnnotation : PdfAnnotation {
    private PdfLineEndingStyle m_beginLine;
    private PdfLineEndingStyle m_endLine;
    private LineBorder m_lineBorder;
    internal PdfArray m_linePoints;
    internal PdfArray m_lineStyle;
    private int m_leaderLineExt;
    private int m_leaderLine;
    private bool m_lineCaption;
    private PdfLineIntent m_lineIntent;
    public PdfLineCaptionType m_captionType;
    private Int32[] m_points;
    private Single[] m_point;
    private float m_borderWidth;
    private bool m_isLineIntent;
    public bool LineCaption { get; public set; }
    public int LeaderLine { get; public set; }
    public int LeaderLineExt { get; public set; }
    public LineBorder lineBorder { get; public set; }
    public PdfLineEndingStyle BeginLineStyle { get; public set; }
    public PdfLineEndingStyle EndLineStyle { get; public set; }
    public PdfLineCaptionType CaptionType { get; public set; }
    public PdfLineIntent LineIntent { get; public set; }
    public PdfColor InnerLineColor { get; public set; }
    public PdfColor BackColor { get; public set; }
    public Int32[] LinePoints { get; public set; }
    internal Single[] LinePoint { get; internal set; }
    public PdfPopupAnnotationCollection ReviewHistory { get; }
    public PdfPopupAnnotationCollection Comments { get; }
    public PdfLineAnnotation(Int32[] linePoints);
    public PdfLineAnnotation(Int32[] linePoints, string text);
    internal PdfLineAnnotation(Single[] linePoints, string text);
    public PdfLineAnnotation(RectangleF rectangle);
    public bool get_LineCaption();
    public void set_LineCaption(bool value);
    public int get_LeaderLine();
    public void set_LeaderLine(int value);
    public int get_LeaderLineExt();
    public void set_LeaderLineExt(int value);
    public LineBorder get_lineBorder();
    public void set_lineBorder(LineBorder value);
    public PdfLineEndingStyle get_BeginLineStyle();
    public void set_BeginLineStyle(PdfLineEndingStyle value);
    public PdfLineEndingStyle get_EndLineStyle();
    public void set_EndLineStyle(PdfLineEndingStyle value);
    public PdfLineCaptionType get_CaptionType();
    public void set_CaptionType(PdfLineCaptionType value);
    public PdfLineIntent get_LineIntent();
    public void set_LineIntent(PdfLineIntent value);
    public PdfColor get_InnerLineColor();
    public void set_InnerLineColor(PdfColor value);
    public PdfColor get_BackColor();
    public void set_BackColor(PdfColor value);
    public Int32[] get_LinePoints();
    public void set_LinePoints(Int32[] value);
    internal Single[] get_LinePoint();
    internal void set_LinePoint(Single[] value);
    public PdfPopupAnnotationCollection get_ReviewHistory();
    public PdfPopupAnnotationCollection get_Comments();
    protected virtual void Initialize();
    private Single[] ObtainLinePoints();
    internal virtual void FlattenAnnot(bool flattenPopUps);
    private void SaveAndFlatten(bool isExternalFlatten, bool isExternalFlattenPopUps);
    protected virtual void Save();
    private RectangleF ObtainLineBounds();
    private void SavePdfLineDictionary();
    private PdfTemplate CreateAppearance();
    private void FlattenAnnotation(PdfPageBase page, PdfTemplate appearance);
}
public enum Syncfusion.Pdf.Interactive.PdfLineBorderStyle : Enum {
    public int value__;
    public static PdfLineBorderStyle Solid;
    public static PdfLineBorderStyle Dashed;
    public static PdfLineBorderStyle Beveled;
    public static PdfLineBorderStyle Inset;
    public static PdfLineBorderStyle Underline;
}
public enum Syncfusion.Pdf.Interactive.PdfLineCaptionType : Enum {
    public int value__;
    public static PdfLineCaptionType Inline;
    public static PdfLineCaptionType Top;
}
public enum Syncfusion.Pdf.Interactive.PdfLineEndingStyle : Enum {
    public int value__;
    public static PdfLineEndingStyle None;
    public static PdfLineEndingStyle OpenArrow;
    public static PdfLineEndingStyle ClosedArrow;
    public static PdfLineEndingStyle ROpenArrow;
    public static PdfLineEndingStyle RClosedArrow;
    public static PdfLineEndingStyle Butt;
    public static PdfLineEndingStyle Diamond;
    public static PdfLineEndingStyle Circle;
    public static PdfLineEndingStyle Square;
    public static PdfLineEndingStyle Slash;
}
public enum Syncfusion.Pdf.Interactive.PdfLineIntent : Enum {
    public int value__;
    public static PdfLineIntent LineArrow;
    public static PdfLineIntent LineDimension;
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class Syncfusion.Pdf.Interactive.PdfLineMeasurementAnnotation : PdfAnnotation {
    private LineBorder m_lineBorder;
    internal PdfArray m_linePoints;
    private int m_leaderLineExt;
    private int m_leaderLine;
    private bool m_lineCaption;
    private PdfLineIntent m_lineIntent;
    public PdfLineCaptionType m_captionType;
    private PdfMeasurementUnit m_measurementUnit;
    private PdfFont m_font;
    private Int32[] m_points;
    private string m_unitString;
    internal PdfArray m_lineStyle;
    private int m_leaderOffset;
    private PdfLineEndingStyle m_beginLine;
    private PdfLineEndingStyle m_endLine;
    private float m_borderWidth;
    public bool LineCaption { get; public set; }
    public int LeaderLine { get; public set; }
    public int LeaderLineExt { get; public set; }
    public LineBorder lineBorder { get; public set; }
    public PdfLineCaptionType CaptionType { get; public set; }
    public PdfLineIntent LineIntent { get; public set; }
    public PdfColor InnerLineColor { get; public set; }
    public PdfFont Font { get; public set; }
    public PdfColor BackColor { get; public set; }
    public Int32[] LinePoints { get; public set; }
    public PdfMeasurementUnit Unit { get; public set; }
    public int LeaderOffset { get; public set; }
    public PdfLineEndingStyle BeginLineStyle { get; public set; }
    public PdfLineEndingStyle EndLineStyle { get; public set; }
    public PdfPopupAnnotationCollection Comments { get; }
    public PdfPopupAnnotationCollection ReviewHistory { get; }
    public PdfLineMeasurementAnnotation(Int32[] linePoints);
    public bool get_LineCaption();
    public void set_LineCaption(bool value);
    public int get_LeaderLine();
    public void set_LeaderLine(int value);
    public int get_LeaderLineExt();
    public void set_LeaderLineExt(int value);
    public LineBorder get_lineBorder();
    public void set_lineBorder(LineBorder value);
    public PdfLineCaptionType get_CaptionType();
    public void set_CaptionType(PdfLineCaptionType value);
    public PdfLineIntent get_LineIntent();
    public void set_LineIntent(PdfLineIntent value);
    public PdfColor get_InnerLineColor();
    public void set_InnerLineColor(PdfColor value);
    public PdfFont get_Font();
    public void set_Font(PdfFont value);
    public PdfColor get_BackColor();
    public void set_BackColor(PdfColor value);
    public Int32[] get_LinePoints();
    public void set_LinePoints(Int32[] value);
    public PdfMeasurementUnit get_Unit();
    public void set_Unit(PdfMeasurementUnit value);
    public int get_LeaderOffset();
    public void set_LeaderOffset(int value);
    public PdfLineEndingStyle get_BeginLineStyle();
    public void set_BeginLineStyle(PdfLineEndingStyle value);
    public PdfLineEndingStyle get_EndLineStyle();
    public void set_EndLineStyle(PdfLineEndingStyle value);
    public PdfPopupAnnotationCollection get_Comments();
    public PdfPopupAnnotationCollection get_ReviewHistory();
    protected virtual void Initialize();
    private Single[] ObtainLinePoints();
    private float ConvertToUnit();
    private RectangleF ObtainLineBounds();
    protected virtual void Save();
    private float CalculateAngle(PointF startPoint, PointF endPoint);
}
public abstract class Syncfusion.Pdf.Interactive.PdfLinkAnnotation : PdfAnnotation {
    private PdfHighlightMode m_highlightMode;
    public PdfHighlightMode HighlightMode { get; public set; }
    public PdfLinkAnnotation(RectangleF rectangle);
    public PdfHighlightMode get_HighlightMode();
    public void set_HighlightMode(PdfHighlightMode value);
    protected virtual void Initialize();
    [NullableContextAttribute("1")]
private string GetHighlightMode(PdfHighlightMode mode);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class Syncfusion.Pdf.Interactive.PdfListBoxField : PdfListField {
    private bool m_multiselect;
    public bool ComplexScript { get; public set; }
    public bool MultiSelect { get; public set; }
    public PdfListBoxField(PdfPageBase page, string name);
    public bool get_ComplexScript();
    public void set_ComplexScript(bool value);
    public bool get_MultiSelect();
    public void set_MultiSelect(bool value);
    internal virtual void Draw();
    protected virtual void Initialize();
    protected virtual void DrawAppearance(PdfTemplate template);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public abstract class Syncfusion.Pdf.Interactive.PdfListField : PdfAppearanceField {
    private PdfListFieldItemCollection m_items;
    private int m_selectedIndex;
    private Int32[] m_selectedIndexes;
    public PdfListFieldItemCollection Items { get; }
    public int SelectedIndex { get; public set; }
    public string SelectedValue { get; public set; }
    public PdfListFieldItem SelectedItem { get; }
    internal Int32[] SelectedIndexes { get; internal set; }
    public PdfListField(PdfPageBase page, string name);
    public PdfListFieldItemCollection get_Items();
    public int get_SelectedIndex();
    public void set_SelectedIndex(int value);
    public string get_SelectedValue();
    public void set_SelectedValue(string value);
    public PdfListFieldItem get_SelectedItem();
    internal Int32[] get_SelectedIndexes();
    internal void set_SelectedIndexes(Int32[] value);
    internal virtual void Draw();
    protected virtual void Initialize();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class Syncfusion.Pdf.Interactive.PdfListFieldItem : object {
    private int c_textIndex;
    private int c_valueIndex;
    private string m_text;
    internal PdfField m_field;
    internal int m_index;
    private string m_value;
    private PdfArray m_array;
    public string Text { get; public set; }
    public string Value { get; public set; }
    private IPdfPrimitive Syncfusion.Pdf.IPdfWrapper.Element { get; }
    public PdfListFieldItem(string text, string value);
    public string get_Text();
    public void set_Text(string value);
    public string get_Value();
    public void set_Value(string value);
    private void Initialize(string text, string value);
    private sealed virtual override IPdfPrimitive Syncfusion.Pdf.IPdfWrapper.get_Element();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[DefaultMemberAttribute("Item")]
public class Syncfusion.Pdf.Interactive.PdfListFieldItemCollection : PdfCollection {
    private PdfArray m_items;
    private PdfField m_field;
    [CompilerGeneratedAttribute]
private EventHandler`1<FormFieldsAddedArgs> ItemsAdded;
    [CompilerGeneratedAttribute]
private EventHandler`1<FormFieldsRemovedArgs> ItemsRemoved;
    public PdfListFieldItem Item { get; }
    private IPdfPrimitive Syncfusion.Pdf.IPdfWrapper.Element { get; }
    internal PdfListFieldItemCollection(PdfField field);
    [CompilerGeneratedAttribute]
internal void add_ItemsAdded(EventHandler`1<FormFieldsAddedArgs> value);
    [CompilerGeneratedAttribute]
internal void remove_ItemsAdded(EventHandler`1<FormFieldsAddedArgs> value);
    [CompilerGeneratedAttribute]
internal void add_ItemsRemoved(EventHandler`1<FormFieldsRemovedArgs> value);
    [CompilerGeneratedAttribute]
internal void remove_ItemsRemoved(EventHandler`1<FormFieldsRemovedArgs> value);
    internal void OnItemAdded(FormFieldsAddedArgs e);
    internal void OnItemRemoved(FormFieldsRemovedArgs e);
    public PdfListFieldItem get_Item(int index);
    public int Add(PdfListFieldItem item);
    public void Insert(int index, PdfListFieldItem item);
    public void Remove(PdfListFieldItem item);
    public void RemoveAt(int index);
    public bool Contains(PdfListFieldItem item);
    public int IndexOf(PdfListFieldItem item);
    public void Clear();
    private int DoAdd(PdfListFieldItem item);
    private void DoInsert(int index, PdfListFieldItem item);
    private void DoRemoveAt(int index);
    private void DoRemove(PdfListFieldItem item);
    private sealed virtual override IPdfPrimitive Syncfusion.Pdf.IPdfWrapper.get_Element();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public abstract class Syncfusion.Pdf.Interactive.PdfLoadedAnnotation : PdfAnnotation {
    [CompilerGeneratedAttribute]
private BeforeNameChangesEventHandler BeforeNameChanges;
    public int ObjectID;
    private PdfCrossTable m_crossTable;
    private bool m_Changed;
    private int m_defaultIndex;
    private string m_fileName;
    internal PdfLoadedPage m_loadedpage;
    private string m_annotationID;
    private PdfAnnotation m_loadedPopup;
    internal PdfLoadedAnnotationType m_type;
    private bool m_isCreationDateObtained;
    private DateTime m_creationDate;
    public DateTime CreationDate { get; }
    public PdfLoadedAnnotationType Type { get; internal set; }
    internal bool Changed { get; internal set; }
    internal PdfCrossTable CrossTable { get; internal set; }
    internal PdfAnnotation Popup { get; internal set; }
    public PdfLoadedPage Page { get; public set; }
    internal bool IsPopup { get; }
    internal PdfLoadedAnnotation(PdfDictionary dictionary, PdfCrossTable crossTable);
    [CompilerGeneratedAttribute]
internal void add_BeforeNameChanges(BeforeNameChangesEventHandler value);
    [CompilerGeneratedAttribute]
internal void remove_BeforeNameChanges(BeforeNameChangesEventHandler value);
    public DateTime get_CreationDate();
    public PdfLoadedAnnotationType get_Type();
    internal void set_Type(PdfLoadedAnnotationType value);
    internal bool get_Changed();
    internal void set_Changed(bool value);
    internal PdfCrossTable get_CrossTable();
    internal void set_CrossTable(PdfCrossTable value);
    internal virtual PdfAnnotation get_Popup();
    internal virtual void set_Popup(PdfAnnotation value);
    public PdfLoadedPage get_Page();
    public void set_Page(PdfLoadedPage value);
    public void SetText(string text);
    public List`1<string> GetValues(string name);
    public void SetValues(string key, string value);
    internal static IPdfPrimitive SearchInParents(PdfDictionary dictionary, PdfCrossTable crossTable, string value);
    internal static IPdfPrimitive GetValue(PdfDictionary dictionary, PdfCrossTable crossTable, string value, bool inheritable);
    internal PdfDictionary GetWidgetAnnotation(PdfDictionary dictionary, PdfCrossTable crossTable);
    private DateTime ObtainCreationDate();
    internal virtual void ApplyText(string text);
    internal virtual void BeginSave();
    internal void ExportText(Stream stream, Int32& objectid);
    internal static bool validateString(string text1);
    internal List`1<string> ExportAnnotation(PdfWriter& writer, Int32& currentID, List`1<string> annotID, int pageIndex, bool hasAppearance);
    private void GetEntriesInDictionary(Dictionary`2& dictionaries, List`1& streamReferences, Int32& currentID, PdfDictionary dictionary, PdfWriter writer, bool hasAppearance);
    private void AppendStream(PdfStream stream, PdfWriter writer);
    private void AppendElement(IPdfPrimitive element, PdfWriter writer, Int32& currentID, bool isStream, Dictionary`2& dictionaries, List`1& streamReferences);
    private void AppendArrayElements(PdfArray array, PdfWriter writer, Int32& currentID, bool isStream, Dictionary`2& dictionaries, List`1& streamReferences);
    private string GetFormattedString(string value);
    internal bool get_IsPopup();
    internal bool ValidPopup(PdfDictionary dictionary, bool isSupportedPopup);
}
public enum Syncfusion.Pdf.Interactive.PdfLoadedAnnotationType : Enum {
    public int value__;
    public static PdfLoadedAnnotationType Highlight;
    public static PdfLoadedAnnotationType Underline;
    public static PdfLoadedAnnotationType StrikeOut;
    public static PdfLoadedAnnotationType Squiggly;
    public static PdfLoadedAnnotationType RedactionAnnotation;
    public static PdfLoadedAnnotationType TextAnnotation;
    public static PdfLoadedAnnotationType LinkAnnotation;
    public static PdfLoadedAnnotationType DocumentLinkAnnotation;
    public static PdfLoadedAnnotationType FileLinkAnnotation;
    public static PdfLoadedAnnotationType FreeTextAnnotation;
    public static PdfLoadedAnnotationType LineAnnotation;
    public static PdfLoadedAnnotationType CircleAnnotation;
    public static PdfLoadedAnnotationType EllipseAnnotation;
    public static PdfLoadedAnnotationType SquareAnnotation;
    public static PdfLoadedAnnotationType RectangleAnnotation;
    public static PdfLoadedAnnotationType PolygonAnnotation;
    public static PdfLoadedAnnotationType PolyLineAnnotation;
    public static PdfLoadedAnnotationType TextMarkupAnnotation;
    public static PdfLoadedAnnotationType CaretAnnotation;
    public static PdfLoadedAnnotationType RubberStampAnnotation;
    public static PdfLoadedAnnotationType PopupAnnotation;
    public static PdfLoadedAnnotationType FileAttachmentAnnotation;
    public static PdfLoadedAnnotationType SoundAnnotation;
    public static PdfLoadedAnnotationType MovieAnnotation;
    public static PdfLoadedAnnotationType ScreenAnnotation;
    public static PdfLoadedAnnotationType WidgetAnnotation;
    public static PdfLoadedAnnotationType PrinterMarkAnnotation;
    public static PdfLoadedAnnotationType TrapNetworkAnnotation;
    public static PdfLoadedAnnotationType WatermarkAnnotation;
    public static PdfLoadedAnnotationType TextWebLinkAnnotation;
    public static PdfLoadedAnnotationType InkAnnotation;
    public static PdfLoadedAnnotationType RichMediaAnnotation;
    public static PdfLoadedAnnotationType Null;
}
[ObsoleteAttribute("Please use PdfLoadedAnnotationType instead")]
public enum Syncfusion.Pdf.Interactive.PdfLoadedAnnotationTypes : Enum {
    public int value__;
    public static PdfLoadedAnnotationTypes Highlight;
    public static PdfLoadedAnnotationTypes Underline;
    public static PdfLoadedAnnotationTypes RedactionAnnotation;
    public static PdfLoadedAnnotationTypes StrikeOut;
    public static PdfLoadedAnnotationTypes Squiggly;
    public static PdfLoadedAnnotationTypes AnnotationStates;
    public static PdfLoadedAnnotationTypes TextAnnotation;
    public static PdfLoadedAnnotationTypes LinkAnnotation;
    public static PdfLoadedAnnotationTypes DocumentLinkAnnotation;
    public static PdfLoadedAnnotationTypes FileLinkAnnotation;
    public static PdfLoadedAnnotationTypes FreeTextAnnotation;
    public static PdfLoadedAnnotationTypes LineAnnotation;
    public static PdfLoadedAnnotationTypes CircleAnnotation;
    public static PdfLoadedAnnotationTypes EllipseAnnotation;
    public static PdfLoadedAnnotationTypes SquareAnnotation;
    public static PdfLoadedAnnotationTypes RectangleAnnotation;
    public static PdfLoadedAnnotationTypes PolygonAnnotation;
    public static PdfLoadedAnnotationTypes PolyLineAnnotation;
    public static PdfLoadedAnnotationTypes SquareandCircleAnnotation;
    public static PdfLoadedAnnotationTypes PolygonandPolylineAnnotation;
    public static PdfLoadedAnnotationTypes TextMarkupAnnotation;
    public static PdfLoadedAnnotationTypes CaretAnnotation;
    public static PdfLoadedAnnotationTypes RubberStampAnnotation;
    public static PdfLoadedAnnotationTypes LnkAnnotation;
    public static PdfLoadedAnnotationTypes PopupAnnotation;
    public static PdfLoadedAnnotationTypes FileAttachmentAnnotation;
    public static PdfLoadedAnnotationTypes SoundAnnotation;
    public static PdfLoadedAnnotationTypes MovieAnnotation;
    public static PdfLoadedAnnotationTypes ScreenAnnotation;
    public static PdfLoadedAnnotationTypes WidgetAnnotation;
    public static PdfLoadedAnnotationTypes PrinterMarkAnnotation;
    public static PdfLoadedAnnotationTypes TrapNetworkAnnotation;
    public static PdfLoadedAnnotationTypes WatermarkAnnotation;
    public static PdfLoadedAnnotationTypes TextWebLinkAnnotation;
    public static PdfLoadedAnnotationTypes InkAnnotation;
    public static PdfLoadedAnnotationTypes Null;
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class Syncfusion.Pdf.Interactive.PdfLoadedAttachmentAnnotation : PdfLoadedStyledAnnotation {
    private PdfCrossTable m_crossTable;
    private PdfAttachmentIcon m_icon;
    public PdfLoadedPopupAnnotationCollection ReviewHistory { get; }
    public PdfLoadedPopupAnnotationCollection Comments { get; }
    public PdfAttachmentIcon Icon { get; public set; }
    public string FileName { get; }
    public Byte[] Data { get; }
    internal PdfLoadedAttachmentAnnotation(PdfDictionary dictionary, PdfCrossTable crossTable, RectangleF rectangle, string text);
    public PdfLoadedPopupAnnotationCollection get_ReviewHistory();
    public PdfLoadedPopupAnnotationCollection get_Comments();
    public PdfAttachmentIcon get_Icon();
    public void set_Icon(PdfAttachmentIcon value);
    public string get_FileName();
    public Byte[] get_Data();
    private PdfAttachmentIcon ObtainIcon();
    internal virtual void FlattenAnnot(bool flattenPopUps);
    private void SaveAndFlatten(bool isExternalFlatten, bool isExternalFlattenPopUps);
    protected virtual void Save();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class Syncfusion.Pdf.Interactive.PdfLoadedBookmark : PdfBookmark {
    private PdfNamedDestination m_namedDestination;
    private Regex regex;
    private Char[] pdfEncodingByteToChar;
    public PdfDestination Destination { get; public set; }
    public PdfNamedDestination NamedDestination { get; public set; }
    public string Title { get; public set; }
    public PdfColor Color { get; public set; }
    public PdfTextStyle TextStyle { get; public set; }
    internal PdfBookmark Next { get; internal set; }
    internal PdfBookmark Previous { get; internal set; }
    internal PdfBookmarkBase Parent { get; }
    internal List`1<PdfBookmarkBase> List { get; }
    internal PdfLoadedBookmark(PdfDictionary dictionary, PdfCrossTable crossTable);
    public virtual PdfDestination get_Destination();
    public virtual void set_Destination(PdfDestination value);
    public virtual PdfNamedDestination get_NamedDestination();
    public virtual void set_NamedDestination(PdfNamedDestination value);
    private PdfLoadedNamedDestination ObtainNamedDestination();
    public virtual string get_Title();
    public virtual void set_Title(string value);
    public virtual PdfColor get_Color();
    public virtual void set_Color(PdfColor value);
    public virtual PdfTextStyle get_TextStyle();
    public virtual void set_TextStyle(PdfTextStyle value);
    internal virtual PdfBookmark get_Next();
    internal virtual void set_Next(PdfBookmark value);
    internal virtual PdfBookmark get_Previous();
    internal virtual void set_Previous(PdfBookmark value);
    internal virtual PdfBookmarkBase get_Parent();
    internal virtual List`1<PdfBookmarkBase> get_List();
    private string ObtainTitle();
    private string ConvertUnicodeToString(string text);
    private PdfColor ObtainColor();
    private PdfTextStyle ObtainTextStyle();
    private PdfBookmark ObtainNext();
    private PdfBookmark ObtainPrevious();
    private void AssignColor(PdfColor color);
    private void AssignTextStyle(PdfTextStyle value);
    private PdfDestination ObtainDestination();
    private float CheckRotation(PdfPageBase page, PdfNumber top, PdfNumber left);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class Syncfusion.Pdf.Interactive.PdfLoadedCircleAnnotation : PdfLoadedStyledAnnotation {
    private PdfCrossTable m_crossTable;
    private LineBorder m_border;
    private PdfArray m_DashedArray;
    private bool m_isDashArrayReset;
    private float m_borderWidth;
    private PdfBorderEffect _mBorderEffect;
    public LineBorder Border { get; public set; }
    public PdfLoadedPopupAnnotationCollection ReviewHistory { get; }
    public PdfLoadedPopupAnnotationCollection Comments { get; }
    public PdfBorderEffect BorderEffect { get; public set; }
    internal PdfLoadedCircleAnnotation(PdfDictionary dictionary, PdfCrossTable crossTable, RectangleF rectangle, string text);
    public LineBorder get_Border();
    public void set_Border(LineBorder value);
    public PdfLoadedPopupAnnotationCollection get_ReviewHistory();
    public PdfLoadedPopupAnnotationCollection get_Comments();
    public PdfBorderEffect get_BorderEffect();
    public void set_BorderEffect(PdfBorderEffect value);
    private LineBorder GetLineBorder();
    private PdfBorderStyle GetBorderStyle(string bstyle);
    internal virtual void FlattenAnnot(bool flattenPopUps);
    private void SaveAndFlatten(bool isExternalFlatten, bool isExternalFlattenPopUps);
    protected virtual void Save();
    private void FlattenAnnotation(PdfPageBase page, PdfTemplate appearance);
    private PdfTemplate CreateAppearance();
    private void DrawAppearance(RectangleF rectangle, float borderWidth, PdfGraphics graphics, PaintParams paintParams);
    private RectangleF ObtainStyle(PdfPen mBorderPen, RectangleF rectangle, float borderWidth);
    private void CreateBezier(PointF ctrl1, PointF ctrl2, PointF ctrl3, List`1<PointF> bezierPoints);
    private void PopulateBezierPoints(PointF ctrl1, PointF ctrl2, PointF ctrl3, int currentIteration, List`1<PointF> bezierPoints);
    private PointF MidPoint(PointF controlPoint1, PointF controlPoint2);
    private void UpdateBorderEffects();
    private PdfArray GetMatrix(PdfTransformationMatrix translatedMatrix);
    private PdfTemplate CreateCloudyAppearance();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class Syncfusion.Pdf.Interactive.PdfLoadedDocumentLinkAnnotation : PdfLoadedStyledAnnotation {
    private PdfCrossTable m_crossTable;
    private PdfDestination pdfDestination;
    public PdfDestination Destination { get; public set; }
    internal PdfLoadedDocumentLinkAnnotation(PdfDictionary dictionary, PdfCrossTable crossTable, RectangleF rectangle);
    public PdfDestination get_Destination();
    public void set_Destination(PdfDestination value);
    private PdfDestination ObtainDestination();
    internal virtual void FlattenAnnot(bool flattenPopUps);
    private void SaveAndFlatten(bool isExternalFlatten, bool isExternalFlattenPopUps);
    protected virtual void Save();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class Syncfusion.Pdf.Interactive.PdfLoadedEllipseAnnotation : PdfLoadedStyledAnnotation {
    private PdfCrossTable m_crossTable;
    private LineBorder m_border;
    private PdfArray m_dashedArray;
    private bool m_isDashArrayReset;
    private float m_borderWidth;
    private PdfBorderEffect _mBorderEffect;
    public PdfLoadedPopupAnnotationCollection ReviewHistory { get; }
    public PdfLoadedPopupAnnotationCollection Comments { get; }
    public LineBorder Border { get; public set; }
    public PdfBorderEffect BorderEffect { get; public set; }
    internal PdfLoadedEllipseAnnotation(PdfDictionary dictionary, PdfCrossTable crossTable, RectangleF rectangle, string text);
    public PdfLoadedPopupAnnotationCollection get_ReviewHistory();
    public PdfLoadedPopupAnnotationCollection get_Comments();
    public LineBorder get_Border();
    public void set_Border(LineBorder value);
    public PdfBorderEffect get_BorderEffect();
    public void set_BorderEffect(PdfBorderEffect value);
    private LineBorder ObtainBorder();
    private PdfBorderStyle GetBorderStyle(string bstyle);
    internal virtual void FlattenAnnot(bool flattenPopUps);
    private void SaveAndFlatten(bool isExternalFlatten, bool isExternalFlattenPopUps);
    protected virtual void Save();
    private void FlattenAnnotation(PdfPageBase page, PdfTemplate appearance);
    private PdfTemplate CreateAppearance();
    private void DrawAppearance(RectangleF rectangle, float borderWidth, PdfGraphics graphics, PaintParams paintParams);
    private RectangleF ObtainStyle(PdfPen mBorderPen, RectangleF rectangle, float borderWidth);
    private void CreateBezier(PointF ctrl1, PointF ctrl2, PointF ctrl3, List`1<PointF> bezierPoints);
    private void PopulateBezierPoints(PointF ctrl1, PointF ctrl2, PointF ctrl3, int currentIteration, List`1<PointF> bezierPoints);
    private PointF MidPoint(PointF controlPoint1, PointF controlPoint2);
    private void UpdateBorderEffects();
    private PdfArray GetMatrix(PdfTransformationMatrix translatedMatrix);
    private PdfTemplate CreateCloudyAppearance();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class Syncfusion.Pdf.Interactive.PdfLoadedFileLinkAnnotation : PdfLoadedStyledAnnotation {
    private Int32[] destinationArray;
    private PdfCrossTable m_crossTable;
    private PdfLaunchAction m_action;
    private PdfArray m_destination;
    public string FileName { get; public set; }
    private PdfArray Destination { get; private set; }
    public Int32[] DestinationArray { get; public set; }
    internal PdfLoadedFileLinkAnnotation(PdfDictionary dictionary, PdfCrossTable crossTable, RectangleF rectangle, string filename);
    internal PdfLoadedFileLinkAnnotation(PdfDictionary dictionary, PdfCrossTable crossTable, PdfArray destination, RectangleF rectangle, string filename);
    public string get_FileName();
    public void set_FileName(string value);
    private PdfArray get_Destination();
    private void set_Destination(PdfArray value);
    public Int32[] get_DestinationArray();
    public void set_DestinationArray(Int32[] value);
    private string ObtainFileName();
    private Int32[] ObtainDestination();
    internal virtual void FlattenAnnot(bool flattenPopUps);
    private void SaveAndFlatten(bool isExternalFlatten, bool isExternalFlattenPopUps);
    protected virtual void Save();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class Syncfusion.Pdf.Interactive.PdfLoadedFreeTextAnnotation : PdfLoadedStyledAnnotation {
    private PdfLineEndingStyle m_lineEndingStyle;
    private PdfFont m_font;
    private PdfColor m_textMarkupColor;
    private PdfAnnotationIntent m_annotationIntent;
    private PointF[] m_calloutLines;
    private PdfColor m_borderColor;
    private PdfCrossTable m_crossTable;
    private string m_markUpText;
    private bool m_istextMarkupcolor;
    private PointF[] m_calloutsClone;
    private bool m_isfontAPStream;
    private bool m_markupTextFromStream;
    private MemoryStream freeTextStream;
    private PdfRecordCollection readTextCollection;
    private ContentParser parser;
    private bool m_complexScript;
    private PdfTextAlignment alignment;
    private PdfTextDirection m_textDirection;
    private float m_lineSpacing;
    private bool isAllRotation;
    public float LineSpacing { get; public set; }
    public PdfLoadedPopupAnnotationCollection ReviewHistory { get; }
    public PdfLoadedPopupAnnotationCollection Comments { get; }
    public PdfLineEndingStyle LineEndingStyle { get; public set; }
    public string MarkUpText { get; public set; }
    internal bool MarkUpTextFromStream { get; internal set; }
    public PdfAnnotationIntent AnnotationIntent { get; public set; }
    public PdfFont Font { get; public set; }
    public PdfColor TextMarkupColor { get; public set; }
    public PointF[] CalloutLines { get; public set; }
    public PdfColor BorderColor { get; public set; }
    public bool ComplexScript { get; public set; }
    public PdfTextAlignment TextAlignment { get; public set; }
    public PdfTextDirection TextDirection { get; public set; }
    internal PdfLoadedFreeTextAnnotation(PdfDictionary dictionary, PdfCrossTable crossTable, RectangleF rect, string text);
    public float get_LineSpacing();
    public void set_LineSpacing(float value);
    public PdfLoadedPopupAnnotationCollection get_ReviewHistory();
    public PdfLoadedPopupAnnotationCollection get_Comments();
    public PdfLineEndingStyle get_LineEndingStyle();
    public void set_LineEndingStyle(PdfLineEndingStyle value);
    public string get_MarkUpText();
    public void set_MarkUpText(string value);
    internal bool get_MarkUpTextFromStream();
    internal void set_MarkUpTextFromStream(bool value);
    public PdfAnnotationIntent get_AnnotationIntent();
    public void set_AnnotationIntent(PdfAnnotationIntent value);
    public PdfFont get_Font();
    public void set_Font(PdfFont value);
    public PdfColor get_TextMarkupColor();
    public void set_TextMarkupColor(PdfColor value);
    public PointF[] get_CalloutLines();
    public void set_CalloutLines(PointF[] value);
    public PdfColor get_BorderColor();
    public void set_BorderColor(PdfColor value);
    public bool get_ComplexScript();
    public void set_ComplexScript(bool value);
    public PdfTextAlignment get_TextAlignment();
    public void set_TextAlignment(PdfTextAlignment value);
    public PdfTextDirection get_TextDirection();
    public void set_TextDirection(PdfTextDirection value);
    private PdfColor ObtainColor();
    private PointF[] GetcalloutLinepoints();
    private PdfColor GetTextMarkUpColor();
    private void UpdateTextMarkupColor();
    private string ObtainText();
    private PdfLineEndingStyle ObtainLineEndingStyle();
    private PdfAnnotationIntent ObtainAnnotationIntent();
    private PdfFont ObtainFont();
    private PdfFont GetFontFromEvent(string fontName, float fontSize, PdfFontStyle fontStyle, PdfLoadedDocument ldoc);
    private string ObtainTextFromAPStream(bool isfontStream);
    private void ObtainFromAPStream(bool isfontStream);
    private int GetTextOperatorIndex(PdfRecordCollection records);
    internal virtual void FlattenAnnot(bool flattenPopUps);
    private void SaveAndFlatten(bool isExternalFlatten, bool isExternalFlattenPopUps);
    protected virtual void Save();
    private void FlattenAnnotation(PdfPageBase page, PdfTemplate appearance);
    private PdfTemplate CreateAppearance();
    private void DrawArrow(PaintParams paintParams, PdfGraphics graphics, PdfPen mBorderPen);
    private void DrawAppearance(RectangleF rectangle, PdfGraphics graphics, PaintParams paintParams);
    private RectangleF ObtainStyle(PdfPen mBorderPen, RectangleF rectangle, float borderWidth, PaintParams paintParams);
    private PointF[] CalculateArrowPoints(PointF startingPoint, PointF endPoint);
    private Single[] ObtainLinePoints();
    private RectangleF ObtainAppearanceBounds();
    private void ExpandAppearanceForEndLineStyle(PointF[] pointArray);
    private void DrawFreeTextRectangle(PdfGraphics graphics, PaintParams paintParams, RectangleF rect);
    private void DrawFreeMarkUpText(PdfGraphics graphics, PaintParams paintParams, RectangleF rect, string text);
    private void SetRectangleDifferance(RectangleF innerRectangle);
    private void DrawCallOuts(PdfGraphics graphics, PdfPen mBorderPen);
    private void ObtainCallOutsNative();
    private PdfTextAlignment ObtainTextAlignment();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class Syncfusion.Pdf.Interactive.PdfLoadedInkAnnotation : PdfLoadedStyledAnnotation {
    private PdfCrossTable m_crossTable;
    private List`1<float> m_inkList;
    private List`1<List`1<float>> m_inkListcollection;
    private Int32[] m_dashArray;
    private int m_borderWidth;
    private float m_borderLineWidth;
    private PdfDictionary m_borderDic;
    private PdfLineBorderStyle m_borderStyle;
    private bool m_isConatainsCropOrMediaBoxValue;
    public PdfLoadedPopupAnnotationCollection ReviewHistory { get; }
    public PdfLoadedPopupAnnotationCollection Comments { get; }
    public List`1<float> InkList { get; public set; }
    public List`1<List`1<float>> InkPointsCollection { get; public set; }
    public int BorderWidth { get; public set; }
    internal float BorderLineWidth { get; internal set; }
    public PdfLineBorderStyle BorderStyle { get; public set; }
    public Int32[] DashArray { get; public set; }
    internal PdfLoadedInkAnnotation(PdfDictionary dictionary, PdfCrossTable crossTable, RectangleF rectangle);
    public PdfLoadedPopupAnnotationCollection get_ReviewHistory();
    public PdfLoadedPopupAnnotationCollection get_Comments();
    public List`1<float> get_InkList();
    public void set_InkList(List`1<float> value);
    public List`1<List`1<float>> get_InkPointsCollection();
    public void set_InkPointsCollection(List`1<List`1<float>> value);
    public int get_BorderWidth();
    public void set_BorderWidth(int value);
    internal float get_BorderLineWidth();
    internal void set_BorderLineWidth(float value);
    public PdfLineBorderStyle get_BorderStyle();
    public void set_BorderStyle(PdfLineBorderStyle value);
    public Int32[] get_DashArray();
    public void set_DashArray(Int32[] value);
    private List`1<float> ObtainInkList();
    private List`1<List`1<float>> ObtainInkListCollection();
    private float ObtainBorderWidth();
    private Int32[] ObtainDashArray();
    private void GetBoundsValue();
    internal virtual void FlattenAnnot(bool flattenPopUps);
    private void SaveAndFlatten(bool isExternalFlatten, bool isExternalFlattenPopUps);
    protected virtual void Save();
    private PdfTemplate CreateAppearance();
    private void FlattenAnnotation(PdfPageBase page, PdfTemplate appearance);
    private void AddInkPoints();
    private void GetControlPoints(PointF[] pointCollection, PointF[]& controlPointOne, PointF[]& controlPointTwo);
    private Double[] GetSingleControlPoint(Double[] rightVector);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class Syncfusion.Pdf.Interactive.PdfLoadedLineAnnotation : PdfLoadedStyledAnnotation {
    private PdfCrossTable m_crossTable;
    private PdfColor m_backcolor;
    private LineBorder m_lineborder;
    private PdfArray m_linePoints;
    private Int32[] m_points;
    private Single[] m_point;
    internal PdfFont m_font;
    private PdfRecordCollection readTextCollection;
    private ContentParser parser;
    private bool m_isfontAPStream;
    private MemoryStream freeTextStream;
    private float m_borderWidth;
    public PdfLoadedPopupAnnotationCollection ReviewHistory { get; }
    public PdfLoadedPopupAnnotationCollection Comments { get; }
    public PdfColor BackColor { get; public set; }
    public PdfLineEndingStyle BeginLineStyle { get; public set; }
    public PdfLineCaptionType CaptionType { get; public set; }
    public PdfLineEndingStyle EndLineStyle { get; public set; }
    public PdfColor InnerLineColor { get; public set; }
    public int LeaderLine { get; public set; }
    public int LeaderExt { get; public set; }
    public int LeaderOffset { get; public set; }
    public LineBorder LineBorder { get; public set; }
    public Int32[] LinePoints { get; public set; }
    internal Single[] LinePoint { get; internal set; }
    public bool LineCaption { get; public set; }
    public PdfLineIntent LineIntent { get; public set; }
    internal PdfLoadedLineAnnotation(PdfDictionary dictionary, PdfCrossTable crossTable, RectangleF rectangle, string text);
    public PdfLoadedPopupAnnotationCollection get_ReviewHistory();
    public PdfLoadedPopupAnnotationCollection get_Comments();
    public PdfColor get_BackColor();
    public void set_BackColor(PdfColor value);
    public PdfLineEndingStyle get_BeginLineStyle();
    public void set_BeginLineStyle(PdfLineEndingStyle value);
    public PdfLineCaptionType get_CaptionType();
    public void set_CaptionType(PdfLineCaptionType value);
    public PdfLineEndingStyle get_EndLineStyle();
    public void set_EndLineStyle(PdfLineEndingStyle value);
    public PdfColor get_InnerLineColor();
    public void set_InnerLineColor(PdfColor value);
    public int get_LeaderLine();
    public void set_LeaderLine(int value);
    public int get_LeaderExt();
    public void set_LeaderExt(int value);
    public int get_LeaderOffset();
    public void set_LeaderOffset(int value);
    public LineBorder get_LineBorder();
    public void set_LineBorder(LineBorder value);
    public Int32[] get_LinePoints();
    public void set_LinePoints(Int32[] value);
    internal Single[] get_LinePoint();
    internal void set_LinePoint(Single[] value);
    public bool get_LineCaption();
    public void set_LineCaption(bool value);
    public PdfLineIntent get_LineIntent();
    public void set_LineIntent(PdfLineIntent value);
    private PdfLineIntent ObtainLineIntent();
    private PdfArray GetLineStyle();
    private PdfLineEndingStyle GetLineStyle(int Ch);
    private PdfLineEndingStyle GetLineStyle(string style);
    private PdfColor ObtainInnerLineColor();
    private PdfColor ObtainBackColor();
    private PdfLineCaptionType ObtainCaptionType();
    private PdfLineCaptionType GetCaptionType(string cType);
    private bool ObtainLineCaption();
    private int ObtainLeaderLine();
    private int ObtainLeaderExt();
    private int ObtainLeaderOffset();
    private LineBorder ObtainLineBorder();
    private Int32[] ObtainLinePoints();
    private Single[] ObtainLinePoint();
    private PdfBorderStyle GetBorderStyle(string bstyle);
    private PdfLineIntent GetLineIntentText(string lintent);
    internal virtual void FlattenAnnot(bool flattenPopUps);
    private void SaveAndFlatten(bool isExternalFlatten, bool isExternalFlattenPopUps);
    protected virtual void Save();
    private void FlattenAnnotation(PdfPageBase page, PdfTemplate appearance);
    private RectangleF ObtainLineBounds();
    private PdfTemplate CreateAppearance();
    private PdfFont ObtainFont();
    private void ObtainFromAPStream(bool isfontStream);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class Syncfusion.Pdf.Interactive.PdfLoadedNamedDestination : PdfNamedDestination {
    public PdfDestination Destination { get; public set; }
    public string Title { get; public set; }
    internal PdfLoadedNamedDestination(PdfDictionary dictionary, PdfCrossTable crossTable);
    public virtual PdfDestination get_Destination();
    public virtual void set_Destination(PdfDestination value);
    public virtual string get_Title();
    public virtual void set_Title(string value);
    private PdfDestination ObtainDestination();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class Syncfusion.Pdf.Interactive.PdfLoadedPolygonAnnotation : PdfLoadedStyledAnnotation {
    private PdfCrossTable m_crossTable;
    private LineBorder m_border;
    private Single[] m_dashPattern;
    private PdfBorderEffect m_borderEffect;
    private float m_borderWidth;
    private Int32[] m_points;
    private Single[] m_point;
    public PdfLoadedPopupAnnotationCollection ReviewHistory { get; }
    public PdfBorderEffect BorderEffect { get; public set; }
    public PdfLoadedPopupAnnotationCollection Comments { get; }
    public LineBorder Border { get; public set; }
    public Int32[] PolygonPoints { get; internal set; }
    internal Single[] PolygonPoint { get; }
    internal PdfLoadedPolygonAnnotation(PdfDictionary dictionary, PdfCrossTable crossTable, RectangleF rectangle, string text);
    public PdfLoadedPopupAnnotationCollection get_ReviewHistory();
    public PdfBorderEffect get_BorderEffect();
    public void set_BorderEffect(PdfBorderEffect value);
    public PdfLoadedPopupAnnotationCollection get_Comments();
    public LineBorder get_Border();
    public void set_Border(LineBorder value);
    public Int32[] get_PolygonPoints();
    internal void set_PolygonPoints(Int32[] value);
    internal Single[] get_PolygonPoint();
    private LineBorder GetLineBorder();
    private PdfBorderStyle GetBorderStyle(string bstyle);
    private PointF[] GetLinePoints();
    private void GetBoundsValue();
    internal virtual void FlattenAnnot(bool flattenPopUps);
    private void SaveAndFlatten(bool isExternalFlattenPopUps);
    protected virtual void Save();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class Syncfusion.Pdf.Interactive.PdfLoadedPolyLineAnnotation : PdfLoadedStyledAnnotation {
    private PdfCrossTable m_crossTable;
    private LineBorder m_lineborder;
    private Int32[] m_points;
    private Single[] m_point;
    public PdfLoadedPopupAnnotationCollection ReviewHistory { get; }
    public PdfLoadedPopupAnnotationCollection Comments { get; }
    internal Int32[] PolylinePoints { get; internal set; }
    internal Single[] PolylinePoint { get; }
    public LineBorder LineBorder { get; public set; }
    public PdfLineEndingStyle BeginLineStyle { get; public set; }
    public PdfLineEndingStyle EndLineStyle { get; public set; }
    internal PdfLoadedPolyLineAnnotation(PdfDictionary dictionary, PdfCrossTable crossTable, RectangleF rectangle, string text);
    public PdfLoadedPopupAnnotationCollection get_ReviewHistory();
    public PdfLoadedPopupAnnotationCollection get_Comments();
    internal Int32[] get_PolylinePoints();
    internal void set_PolylinePoints(Int32[] value);
    internal Single[] get_PolylinePoint();
    public LineBorder get_LineBorder();
    public void set_LineBorder(LineBorder value);
    public PdfLineEndingStyle get_BeginLineStyle();
    public void set_BeginLineStyle(PdfLineEndingStyle value);
    public PdfLineEndingStyle get_EndLineStyle();
    public void set_EndLineStyle(PdfLineEndingStyle value);
    private PdfLineEndingStyle GetLineStyle(int Ch);
    private PdfLineEndingStyle GetLineStyle(string style);
    private PdfArray GetLineStyle();
    private PointF[] GetLinePoints();
    private void GetBoundsValue();
    private PdfColor GetBackColor();
    private LineBorder AssignLineBorder();
    private PdfBorderStyle GetBorderStyle(string bstyle);
    internal virtual void FlattenAnnot(bool flattenPopUps);
    private void SaveAndFlatten(bool isExternalFlattenPopUps);
    protected virtual void Save();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class Syncfusion.Pdf.Interactive.PdfLoadedPopupAnnotation : PdfLoadedStyledAnnotation {
    private PdfCrossTable m_crossTable;
    private bool m_open;
    private PdfPopupIcon m_name;
    private PdfAnnotationState m_state;
    private PdfAnnotationStateModel m_statemodel;
    private string m_iconName;
    private bool m_isCustomIconEnabled;
    public PdfLoadedPopupAnnotationCollection ReviewHistory { get; }
    public PdfLoadedPopupAnnotationCollection Comments { get; }
    public PdfAnnotationState State { get; public set; }
    public PdfAnnotationStateModel StateModel { get; public set; }
    public bool Open { get; public set; }
    public PdfPopupIcon Icon { get; public set; }
    public string IconName { get; public set; }
    internal PdfLoadedPopupAnnotation(PdfDictionary dictionary, PdfCrossTable crossTable, RectangleF rectangle, string text);
    public PdfLoadedPopupAnnotationCollection get_ReviewHistory();
    public PdfLoadedPopupAnnotationCollection get_Comments();
    public PdfAnnotationState get_State();
    public void set_State(PdfAnnotationState value);
    public PdfAnnotationStateModel get_StateModel();
    public void set_StateModel(PdfAnnotationStateModel value);
    public bool get_Open();
    public void set_Open(bool value);
    public PdfPopupIcon get_Icon();
    public void set_Icon(PdfPopupIcon value);
    public string get_IconName();
    public void set_IconName(string value);
    internal string ObtainIconName();
    private bool ObtainOpen();
    private PdfPopupIcon ObtainIcon();
    internal virtual void FlattenAnnot(bool flattenPopUps);
    private void SaveAndFlatten(bool isExternalFlatten, bool isExternalFlattenPopUps);
    protected virtual void Save();
    internal void ChangeBounds(RectangleF bounds);
    protected void CreateApperance();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class Syncfusion.Pdf.Interactive.PdfLoadedRectangleAnnotation : PdfLoadedStyledAnnotation {
    private PdfCrossTable m_crossTable;
    private LineBorder m_lineborder;
    private PdfArray m_dashedArray;
    private bool m_isDashArrayReset;
    private PdfBorderEffect _mBorderEffect;
    private float mBorderWidth;
    private bool ismodified;
    internal bool IsModified { get; internal set; }
    public PdfLoadedPopupAnnotationCollection ReviewHistory { get; }
    public PdfLoadedPopupAnnotationCollection Comments { get; }
    public LineBorder LineBorder { get; public set; }
    public PdfBorderEffect BorderEffect { get; public set; }
    internal PdfLoadedRectangleAnnotation(PdfDictionary dictionary, PdfCrossTable crossTable, RectangleF rectangle, string text);
    internal bool get_IsModified();
    internal void set_IsModified(bool value);
    public PdfLoadedPopupAnnotationCollection get_ReviewHistory();
    public PdfLoadedPopupAnnotationCollection get_Comments();
    public LineBorder get_LineBorder();
    public void set_LineBorder(LineBorder value);
    public PdfBorderEffect get_BorderEffect();
    public void set_BorderEffect(PdfBorderEffect value);
    private LineBorder ObtainLineBorder();
    private PdfBorderStyle GetBorderStyle(string bstyle);
    internal virtual void FlattenAnnot(bool flattenPopUps);
    private void SaveAndFlatten(bool isExternalFlatten, bool isExternalFlattenPopUps);
    protected virtual void Save();
    private void FlattenAnnotation(PdfPageBase page, PdfTemplate appearance);
    private PdfTemplate CreateAppearance();
    private void DrawAppearance(RectangleF rectangle, float borderWidth, PdfGraphics graphics, PaintParams paintParams);
    private RectangleF ObtainStyle(PdfPen mBorderPen, RectangleF rectangle, float borderWidth);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class Syncfusion.Pdf.Interactive.PdfLoadedRedactionAnnotation : PdfLoadedStyledAnnotation {
    private PdfColor borderColor;
    private LineBorder border;
    private string overlayText;
    private PdfColor textColor;
    private bool repeat;
    private PdfFont font;
    private PdfTextAlignment alignment;
    private PdfCrossTable crossTable;
    private bool isfontAPStream;
    private bool flatten;
    private MemoryStream redactTextStream;
    private PdfRecordCollection readTextCollection;
    private ContentParser parser;
    private PdfDictionary dictionary;
    internal bool AppearanceEnabled;
    public PdfColor TextColor { get; public set; }
    public PdfTextAlignment TextAlignment { get; public set; }
    public LineBorder Border { get; public set; }
    public string OverlayText { get; public set; }
    public PdfFont Font { get; public set; }
    public PdfColor BorderColor { get; public set; }
    public bool RepeatText { get; public set; }
    public bool Flatten { get; public set; }
    internal PdfLoadedRedactionAnnotation(PdfDictionary dictionary, PdfCrossTable crossTable);
    public PdfColor get_TextColor();
    public void set_TextColor(PdfColor value);
    public PdfTextAlignment get_TextAlignment();
    public void set_TextAlignment(PdfTextAlignment value);
    public LineBorder get_Border();
    public void set_Border(LineBorder value);
    public string get_OverlayText();
    public void set_OverlayText(string value);
    public PdfFont get_Font();
    public void set_Font(PdfFont value);
    public PdfColor get_BorderColor();
    public void set_BorderColor(PdfColor value);
    public bool get_RepeatText();
    public void set_RepeatText(bool value);
    public bool get_Flatten();
    public void set_Flatten(bool value);
    internal virtual void FlattenAnnot(bool flattenPopUps);
    protected virtual void Save();
    private void ApplyRedaction();
    private string ObtainOverlayText();
    private bool ObtainTextRepeat();
    private PdfColor ObtainBorderColor();
    private PdfColor ObtainTextColor();
    private PdfColor GetColorFromArray(PdfArray colours);
    private PdfTextAlignment ObtainTextAlignment();
    private PdfFont ObtainFont();
    private void ObtainFromAPStream(bool isfontStream);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class Syncfusion.Pdf.Interactive.PdfLoadedRichMediaAnnotation : PdfLoadedStyledAnnotation {
    internal PdfRichMediaContent m_content;
    private PdfRichMediaPresentationStyle m_presentationStyle;
    private PdfRichMediaActivationMode m_activationMode;
    private PdfCrossTable m_crossTable;
    private PdfDictionary m_contentDictionary;
    private PdfDictionary m_settingsDictionary;
    private PdfDictionary m_activationDictionary;
    private PdfDictionary m_configurations;
    private PdfArray m_configurationsArray;
    private PdfArray m_instancesArray;
    private PdfDictionary m_instances;
    private PdfDictionary m_assets;
    private PdfDictionary ContentDictionary { get; }
    private PdfArray ConfigurationsArray { get; }
    private PdfDictionary Configurations { get; }
    private PdfArray InstancesArray { get; }
    private PdfDictionary Instances { get; }
    private PdfDictionary Asset { get; }
    private PdfDictionary SettingsDictionary { get; }
    private PdfDictionary ActivationDictionary { get; }
    public PdfRichMediaActivationMode ActivationMode { get; public set; }
    public PdfRichMediaContent Content { get; }
    internal Byte[] Data { get; }
    internal string FileName { get; }
    public PdfRichMediaPresentationStyle PresentationStyle { get; public set; }
    internal PdfLoadedRichMediaAnnotation(PdfDictionary dictionary, PdfCrossTable crossTable, RectangleF rectangle);
    private PdfDictionary get_ContentDictionary();
    private PdfArray get_ConfigurationsArray();
    private PdfDictionary get_Configurations();
    private PdfArray get_InstancesArray();
    private PdfDictionary get_Instances();
    private PdfDictionary get_Asset();
    private PdfDictionary get_SettingsDictionary();
    private PdfDictionary get_ActivationDictionary();
    public PdfRichMediaActivationMode get_ActivationMode();
    public void set_ActivationMode(PdfRichMediaActivationMode value);
    public PdfRichMediaContent get_Content();
    internal Byte[] get_Data();
    internal string get_FileName();
    public PdfRichMediaPresentationStyle get_PresentationStyle();
    public void set_PresentationStyle(PdfRichMediaPresentationStyle value);
    private PdfRichMediaActivationMode ObtainActivateMode();
    private string ActivateMode(PdfRichMediaActivationMode mode);
    private string Type(PdfRichMediaContentType mode);
    private PdfRichMediaPresentationStyle ObtainPresentationStyle();
    private string GetStyle(PdfRichMediaPresentationStyle pstyle);
    protected virtual void Save();
    internal virtual void FlattenAnnot(bool flattenPopUps);
    private void SaveAndFlatten(bool isExternalFlatten, bool isExternalFlattenPopUps);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class Syncfusion.Pdf.Interactive.PdfLoadedRubberStampAnnotation : PdfLoadedStyledAnnotation {
    private PdfCrossTable m_crossTable;
    private PdfRubberStampAnnotationIcon m_name;
    private string m_icon;
    private PdfNumber rotation;
    private float m_stampWidth;
    private bool isStampAppearance;
    private RectangleF innerTemplateBounds;
    private float rotateAngle;
    private SizeF m_size;
    private PointF m_location;
    public PdfLoadedPopupAnnotationCollection ReviewHistory { get; }
    public PdfLoadedPopupAnnotationCollection Comments { get; }
    public PdfRubberStampAnnotationIcon Icon { get; public set; }
    internal RectangleF InnerTemplateBounds { get; }
    private PdfColor BackGroundColor { get; }
    private PdfColor BorderColor { get; }
    internal PdfLoadedRubberStampAnnotation(PdfDictionary dictionary, PdfCrossTable crossTable, RectangleF rectangle, string text);
    public PdfLoadedPopupAnnotationCollection get_ReviewHistory();
    public PdfLoadedPopupAnnotationCollection get_Comments();
    public PdfRubberStampAnnotationIcon get_Icon();
    public void set_Icon(PdfRubberStampAnnotationIcon value);
    internal RectangleF get_InnerTemplateBounds();
    private PdfColor get_BackGroundColor();
    private PdfColor get_BorderColor();
    private RectangleF ObtainInnerBounds();
    private PdfRubberStampAnnotationIcon ObtainIcon();
    private PdfRubberStampAnnotationIcon GetIconName(string name);
    private PdfColor ObtainBackGroundColor();
    private PdfColor ObtainBorderColor();
    internal virtual void FlattenAnnot(bool flattenPopUps);
    private void SaveAndFlatten(bool isExternalFlatten, bool isExternalFlattenPopUps);
    protected virtual void Save();
    private void FlattenAnnotation(PdfPageBase page, PdfTemplate appearance);
    private void FlattenAnnotationTemplate(PdfTemplate appearance, bool isNormalMatrix);
    private PdfTemplate CreateAppearance();
    internal PdfTemplate CreateTemplate();
    private PdfTemplate CreateStampAppearance();
    private void DrawRubberStamp(PdfGraphics graphics, PdfPath path, PdfPen mBorderPen, PdfBrush mBackBrush);
    private void DrawRubberStamp(PdfGraphics graphics, PdfPen mBorderPen, PdfBrush mBackBrush, PdfFont font, PdfStringFormat stringFormat);
    protected void ModifyTemplateAppearance(RectangleF bounds);
    private void SetMatrix(PdfDictionary template);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class Syncfusion.Pdf.Interactive.PdfLoadedSoundAnnotation : PdfLoadedStyledAnnotation {
    private PdfCrossTable m_crossTable;
    private PdfSound m_sound;
    private PdfDictionary m_dictionary;
    private PdfSoundIcon m_icon;
    private PdfAppearance m_appearance;
    public PdfLoadedPopupAnnotationCollection ReviewHistory { get; }
    public PdfLoadedPopupAnnotationCollection Comments { get; }
    public PdfSound Sound { get; public set; }
    public string FileName { get; }
    public PdfSoundIcon Icon { get; public set; }
    internal PdfLoadedSoundAnnotation(PdfDictionary dictionary, PdfCrossTable crossTable, RectangleF rectangle);
    public PdfLoadedPopupAnnotationCollection get_ReviewHistory();
    public PdfLoadedPopupAnnotationCollection get_Comments();
    public PdfSound get_Sound();
    public void set_Sound(PdfSound value);
    public string get_FileName();
    public PdfSoundIcon get_Icon();
    public void set_Icon(PdfSoundIcon value);
    private string ObtainFileName();
    private PdfSoundIcon ObtainIcon();
    private PdfSoundIcon GetIconName(string iType);
    private PdfSound ObtainSound();
    private PdfSoundEncoding GetEncodigType(string eType);
    internal virtual void FlattenAnnot(bool flattenPopUps);
    private void SaveAndFlatten(bool isExternalFlatten, bool isExternalFlattenPopUps);
    protected virtual void Save();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class Syncfusion.Pdf.Interactive.PdfLoadedSquareAnnotation : PdfLoadedStyledAnnotation {
    private PdfCrossTable m_crossTable;
    private LineBorder m_border;
    private PdfArray m_dashedArray;
    private bool m_isDashArrayReset;
    private PdfBorderEffect mBorderEffect;
    private float m_borderWidth;
    public PdfLoadedPopupAnnotationCollection ReviewHistory { get; }
    public PdfBorderEffect BorderEffect { get; public set; }
    public PdfLoadedPopupAnnotationCollection Comments { get; }
    public LineBorder Border { get; public set; }
    internal PdfLoadedSquareAnnotation(PdfDictionary dictionary, PdfCrossTable crossTable, RectangleF rectangle, string text);
    public PdfLoadedPopupAnnotationCollection get_ReviewHistory();
    public PdfBorderEffect get_BorderEffect();
    public void set_BorderEffect(PdfBorderEffect value);
    public PdfLoadedPopupAnnotationCollection get_Comments();
    public LineBorder get_Border();
    public void set_Border(LineBorder value);
    private LineBorder ObtainBorder();
    private PdfBorderStyle GetBorderStyle(string bstyle);
    internal virtual void FlattenAnnot(bool flattenPopUps);
    private void SaveAndFlatten(bool isExternalFlatten, bool isExternalFlattenPopUps);
    protected virtual void Save();
    private void FlattenAnnotation(PdfPageBase page, PdfTemplate appearance);
    private PdfTemplate CreateAppearance();
    private void DrawAppearance(RectangleF rectangle, float borderWidth, PdfGraphics graphics, PaintParams paintParams);
    private RectangleF ObtainStyle(PdfPen mBorderPen, RectangleF rectangle, float borderWidth);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class Syncfusion.Pdf.Interactive.PdfLoadedStyledAnnotation : PdfLoadedAnnotation {
    private PdfDictionary m_dictionary;
    private PdfCrossTable m_crossTable;
    private PdfColor m_color;
    private string m_text;
    private string m_name;
    private string m_author;
    private string m_subject;
    private DateTime m_modifiedDate;
    private PdfColor m_innerColor;
    private float m_opacity;
    internal bool isBounds;
    private PdfAnnotationBorder m_border;
    internal bool isOpacity;
    private bool m_isContainBorder;
    internal bool isContentUpdated;
    internal PdfLoadedPopupAnnotationCollection m_reviewHistory;
    internal PdfLoadedPopupAnnotationCollection m_comments;
    internal string m_rctext;
    internal bool hasRichTextFont;
    internal bool hasRichTextAlignment;
    public PdfColor Color { get; public set; }
    public float Opacity { get; public set; }
    public PdfColor InnerColor { get; public set; }
    public string Text { get; public set; }
    public string Author { get; public set; }
    public string Subject { get; public set; }
    public DateTime ModifiedDate { get; public set; }
    public string Name { get; public set; }
    public RectangleF Bounds { get; public set; }
    public PdfAnnotationBorder Border { get; public set; }
    public PointF Location { get; public set; }
    public SizeF Size { get; public set; }
    public PdfAnnotationFlags AnnotationFlags { get; public set; }
    internal bool IsContainBorder { get; }
    internal PdfLoadedStyledAnnotation(PdfDictionary dictionary, PdfCrossTable crossTable);
    public virtual PdfColor get_Color();
    public virtual void set_Color(PdfColor value);
    public virtual float get_Opacity();
    public virtual void set_Opacity(float value);
    public virtual PdfColor get_InnerColor();
    public virtual void set_InnerColor(PdfColor value);
    public virtual string get_Text();
    public virtual void set_Text(string value);
    public virtual string get_Author();
    public virtual void set_Author(string value);
    public virtual string get_Subject();
    public virtual void set_Subject(string value);
    public virtual DateTime get_ModifiedDate();
    public virtual void set_ModifiedDate(DateTime value);
    public string get_Name();
    public void set_Name(string value);
    public virtual RectangleF get_Bounds();
    public virtual void set_Bounds(RectangleF value);
    public virtual PdfAnnotationBorder get_Border();
    public virtual void set_Border(PdfAnnotationBorder value);
    public virtual PointF get_Location();
    public virtual void set_Location(PointF value);
    public virtual SizeF get_Size();
    public virtual void set_Size(SizeF value);
    public virtual PdfAnnotationFlags get_AnnotationFlags();
    public virtual void set_AnnotationFlags(PdfAnnotationFlags value);
    internal bool get_IsContainBorder();
    internal PdfAnnotationState ObtainState();
    internal PdfAnnotationStateModel ObtainStateModel();
    private string ObtainText();
    private string ObtainAuthor();
    private string ObtainSubject();
    private DateTime ObtainModifiedDate();
    internal RectangleF GetBounds(PdfDictionary dictionary, PdfCrossTable crossTable);
    private PdfAnnotationBorder ObtainBorder();
    private PdfColor ObtainColor();
    private float ObtainOpacity();
    private float GetNumber(string keyName);
    private PdfColor ObtainInnerColor();
    private PdfAnnotationFlags ObtainAnnotationFlags();
    private bool IsClockWise(PointF[] points);
    private PointF GetIntersectionDegrees(PointF point1, PointF point2, float radius);
    internal void DrawCloudStyle(PdfGraphics graphics, PdfBrush brush, PdfPen pen, float radius, float overlap, PointF[] points, bool isAppearance);
    protected void CheckFlatten();
    protected void FlattenAnnotationTemplate(PdfTemplate appearance, bool isNormalMatrix);
    internal PdfGraphics ObtainlayerGraphics();
    internal bool IsValidTemplateMatrix(PdfDictionary dictionary, PointF bounds, PdfTemplate template);
    internal PdfLineBorderStyle GetLineBorder();
    internal PdfLineBorderStyle GetBorderStyle(string bstyle);
    internal RectangleF ObtainBounds();
    internal void FlattenLoadedPopup();
    private RectangleF CalculateBounds(RectangleF bounds, PdfPageBase Page);
    private bool IsRotatedTemplate(PdfDictionary dictionary);
    internal List`1<object> ParseXMLData();
    internal Color FromHtml(string colorString);
    private Color FromHex(string hex);
    private RectangleF GetBoundsValue();
    private void RemoveAnnoation(PdfPageBase page, PdfAnnotation annot);
    internal void SaveAnnotationBorder(float borderWidth);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class Syncfusion.Pdf.Interactive.PdfLoadedTextMarkupAnnotation : PdfLoadedStyledAnnotation {
    private PdfCrossTable m_crossTable;
    private PdfDictionary m_dictionary;
    private PdfTextMarkupAnnotationType m_TextMarkupAnnotationType;
    private PdfColor m_color;
    private List`1<RectangleF> m_boundscollection;
    private PdfDictionary m_borderDic;
    private PdfLineBorderStyle m_borderStyle;
    public PdfLoadedPopupAnnotationCollection ReviewHistory { get; }
    public PdfLoadedPopupAnnotationCollection Comments { get; }
    public PdfTextMarkupAnnotationType TextMarkupAnnotationType { get; public set; }
    public PdfColor TextMarkupColor { get; public set; }
    public List`1<RectangleF> BoundsCollection { get; public set; }
    internal PdfLineBorderStyle BorderStyle { get; internal set; }
    internal PdfLoadedTextMarkupAnnotation(PdfDictionary dictionary, PdfCrossTable crossTable, RectangleF rectagle);
    public PdfLoadedPopupAnnotationCollection get_ReviewHistory();
    public PdfLoadedPopupAnnotationCollection get_Comments();
    public PdfTextMarkupAnnotationType get_TextMarkupAnnotationType();
    public void set_TextMarkupAnnotationType(PdfTextMarkupAnnotationType value);
    public PdfColor get_TextMarkupColor();
    public void set_TextMarkupColor(PdfColor value);
    public List`1<RectangleF> get_BoundsCollection();
    public void set_BoundsCollection(List`1<RectangleF> value);
    internal PdfLineBorderStyle get_BorderStyle();
    internal void set_BorderStyle(PdfLineBorderStyle value);
    public void SetTitleText(string text);
    private List`1<RectangleF> ObtainBoundsValue();
    private void SetQuadPoints(SizeF pageSize);
    private PdfTextMarkupAnnotationType ObtainTextMarkupAnnotationType();
    private PdfTextMarkupAnnotationType GetTextMarkupAnnotation(string aType);
    private PdfColor ObtainTextMarkupColor();
    internal virtual void FlattenAnnot(bool flattenPopUps);
    private void SaveAndFlatten(bool isExternalFlatten, bool isExternalFlattenPopUps);
    protected virtual void Save();
    private void FlattenAnnotation(PdfPageBase page, PdfTemplate appearance);
    private PdfTemplate CreateAppearance();
    private PdfPath DrawSquiggly(float width, float height);
    internal void FlattenNonSupportAnnotation();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class Syncfusion.Pdf.Interactive.PdfLoadedTextWebLinkAnnotation : PdfLoadedStyledAnnotation {
    private PdfCrossTable m_crossTable;
    private string m_url;
    public string Url { get; public set; }
    internal PdfLoadedTextWebLinkAnnotation(PdfDictionary dictionary, PdfCrossTable crossTable, string text);
    public string get_Url();
    public void set_Url(string value);
    private string ObtainUrl();
    internal virtual void FlattenAnnot(bool flattenPopUps);
    private void SaveAndFlatten(bool isExternalFlatten, bool isExternalFlattenPopUps);
    protected virtual void Save();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class Syncfusion.Pdf.Interactive.PdfLoadedUriAnnotation : PdfLoadedStyledAnnotation {
    private PdfCrossTable m_crossTable;
    private string m_uri;
    public string Uri { get; public set; }
    internal PdfLoadedUriAnnotation(PdfDictionary dictionary, PdfCrossTable crossTable, RectangleF rectangle, string text);
    public string get_Uri();
    public void set_Uri(string value);
    private string GetUriText();
    internal virtual void FlattenAnnot(bool flattenPopUps);
    private void SaveAndFlatten(bool isExternalFlatten, bool isExternalFlattenPopUps);
    protected virtual void Save();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class Syncfusion.Pdf.Interactive.PdfLoadedWatermarkAnnotation : PdfLoadedStyledAnnotation {
    private PdfCrossTable m_crossTable;
    private float m_opacity;
    private PdfTemplate m_template;
    private bool opacityChanged;
    private PdfAppearance m_appearance;
    private float rotateAngle;
    private SizeF m_size;
    private PointF m_location;
    internal PdfLoadedWatermarkAnnotation(PdfDictionary dictionary, PdfCrossTable crossTable, RectangleF rectangle);
    internal PdfTemplate CreateAppearance();
    protected virtual void Save();
    internal virtual void FlattenAnnot(bool flattenPopUps);
    private void SaveAndFlatten(bool isExternalFlatten, bool isExternalFlattenPopUps);
    private void FlattenAnnotation(PdfPageBase page, PdfTemplate appearance);
    private void FlattenAnnotationTemplate(PdfTemplate appearance, bool isNormalMatrix);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class Syncfusion.Pdf.Interactive.PdfLoadedWebLinkAnnotation : PdfLoadedUriAnnotation {
    private PdfCrossTable m_crossTable;
    internal PdfLoadedWebLinkAnnotation(PdfDictionary dictionary, PdfCrossTable crossTable, RectangleF rectangle, string text);
    internal virtual void FlattenAnnot(bool flattenPopUps);
    private void SaveAndFlatten(bool isExternalFlatten, bool isExternalFlattenPopUps);
    protected virtual void Save();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class Syncfusion.Pdf.Interactive.PdfLoadedWidgetAnnotation : PdfLoadedStyledAnnotation {
    private PdfCrossTable m_crossTable;
    private PdfAnnotationFlags m_flags;
    private PdfExtendedAppearance m_extendedAppearance;
    private WidgetBorder m_border;
    private WidgetAppearance m_widgetAppearance;
    private PdfHighlightMode m_highlightMode;
    private PdfDefaultAppearance m_defaultAppearance;
    private PdfAnnotationActions m_actions;
    private PdfAppearance m_appearance;
    private PdfTextAlignment m_alignment;
    private string m_appearanceState;
    internal PdfFont m_font;
    private PdfRecordCollection readTextCollection;
    private ContentParser parser;
    private bool m_isfontAPStream;
    private MemoryStream freeTextStream;
    public PdfExtendedAppearance ExtendedAppearance { get; public set; }
    public PdfHighlightMode HighlightMode { get; public set; }
    public PdfTextAlignment TextAlignment { get; public set; }
    public PdfAnnotationActions Actions { get; }
    public PdfAppearance Appearance { get; public set; }
    internal PdfFont Font { get; internal set; }
    internal PdfColor ForeColor { get; internal set; }
    internal string AppearanceState { get; internal set; }
    internal PdfLoadedWidgetAnnotation(PdfDictionary dictionary, PdfCrossTable crossTable, RectangleF rectangle);
    public PdfExtendedAppearance get_ExtendedAppearance();
    public void set_ExtendedAppearance(PdfExtendedAppearance value);
    public PdfHighlightMode get_HighlightMode();
    public void set_HighlightMode(PdfHighlightMode value);
    public PdfTextAlignment get_TextAlignment();
    public void set_TextAlignment(PdfTextAlignment value);
    public PdfAnnotationActions get_Actions();
    public PdfAppearance get_Appearance();
    public void set_Appearance(PdfAppearance value);
    internal PdfFont get_Font();
    internal void set_Font(PdfFont value);
    internal PdfColor get_ForeColor();
    internal void set_ForeColor(PdfColor value);
    internal string get_AppearanceState();
    internal void set_AppearanceState(string value);
    private string HighlightModeToString(PdfHighlightMode m_highlightingMode);
    internal PdfColor GetForeColour(string defaultAppearance);
    private float ParseFloatColour(string text);
    internal string FontName(string fontString, Single& height);
    private PdfFont ObtainFont();
    private void ObtainFromAPStream(bool isfontStream);
    internal virtual void FlattenAnnot(bool flattenPopUps);
    private void SaveAndFlatten(bool isExternalFlatten, bool isExternalFlattenPopUps);
    protected virtual void Save();
}
public enum Syncfusion.Pdf.Interactive.PdfMeasurementUnit : Enum {
    public int value__;
    public static PdfMeasurementUnit Inch;
    public static PdfMeasurementUnit Pica;
    public static PdfMeasurementUnit Point;
    public static PdfMeasurementUnit Centimeter;
    public static PdfMeasurementUnit Millimeter;
}
public class Syncfusion.Pdf.Interactive.PdfNamedAction : PdfAction {
    private PdfActionDestination m_destination;
    public PdfActionDestination Destination { get; public set; }
    public PdfNamedAction(PdfActionDestination destination);
    public PdfActionDestination get_Destination();
    public void set_Destination(PdfActionDestination value);
    protected virtual void Initialize();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class Syncfusion.Pdf.Interactive.PdfNamedDestination : object {
    private PdfDestination m_destination;
    private PdfDictionary m_dictionary;
    private PdfCrossTable m_crossTable;
    public PdfDestination Destination { get; public set; }
    public string Title { get; public set; }
    internal PdfDictionary Dictionary { get; }
    internal PdfCrossTable CrossTable { get; }
    private IPdfPrimitive Syncfusion.Pdf.IPdfWrapper.Element { get; }
    public PdfNamedDestination(string title);
    internal PdfNamedDestination(PdfDictionary dictionary, PdfCrossTable crossTable);
    public virtual PdfDestination get_Destination();
    public virtual void set_Destination(PdfDestination value);
    public virtual string get_Title();
    public virtual void set_Title(string value);
    internal PdfDictionary get_Dictionary();
    internal PdfCrossTable get_CrossTable();
    internal void Initialize();
    private void Dictionary_BeginSave(object sender, SavePdfPrimitiveEventArgs ars);
    private sealed virtual override IPdfPrimitive Syncfusion.Pdf.IPdfWrapper.get_Element();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[DefaultMemberAttribute("Item")]
public class Syncfusion.Pdf.Interactive.PdfNamedDestinationCollection : object {
    private List`1<PdfNamedDestination> namedCollections;
    private PdfDictionary m_dictionary;
    private PdfCrossTable m_crossTable;
    internal int count;
    private PdfArray m_namedDestination;
    private Dictionary`2<string, PdfNamedDestination> m_destCollection;
    public int Count { get; }
    public PdfNamedDestination Item { get; }
    internal PdfDictionary Dictionary { get; }
    internal PdfCrossTable CrossTable { get; }
    private IPdfPrimitive Syncfusion.Pdf.IPdfWrapper.Element { get; }
    internal PdfNamedDestinationCollection(PdfDictionary dictionary, PdfCrossTable crossTable);
    public int get_Count();
    public PdfNamedDestination get_Item(int index);
    internal PdfDictionary get_Dictionary();
    internal PdfCrossTable get_CrossTable();
    public void Add(PdfNamedDestination namedDestination);
    public bool Contains(PdfNamedDestination namedDestination);
    public void Remove(string title);
    public void RemoveAt(int index);
    public void Clear();
    public void Insert(int index, PdfNamedDestination namedDestination);
    internal void Initialize();
    private void Dictionary_BeginSave(object sender, SavePdfPrimitiveEventArgs ars);
    private void ReviseNamedDestinationOrder();
    private void FindDestination(PdfDictionary destination);
    private void AddCollection(PdfDictionary namedDictionary);
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
    private sealed virtual override IPdfPrimitive Syncfusion.Pdf.IPdfWrapper.get_Element();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class Syncfusion.Pdf.Interactive.PdfPageTemplate : object {
    private string m_pageTemplateName;
    private bool m_isVisible;
    private PdfPageBase m_pageBase;
    public string Name { get; public set; }
    public bool IsVisible { get; public set; }
    internal PdfPageBase PdfPageBase { get; internal set; }
    public PdfPageTemplate(PdfPageBase page, string name, bool isVisible);
    public PdfPageTemplate(PdfPageBase page);
    public string get_Name();
    public void set_Name(string value);
    public bool get_IsVisible();
    public void set_IsVisible(bool value);
    internal PdfPageBase get_PdfPageBase();
    internal void set_PdfPageBase(PdfPageBase value);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[DefaultMemberAttribute("Item")]
public class Syncfusion.Pdf.Interactive.PdfPageTemplateCollection : object {
    private List`1<PdfPageTemplate> m_pageTemplatesCollection;
    private PdfDictionary m_dictionary;
    private PdfCrossTable m_crossTable;
    private Dictionary`2<PdfPageBase, string> m_pages;
    private Dictionary`2<PdfPageBase, string> m_templates;
    private PdfArray m_namedPages;
    private PdfArray m_namedTempates;
    internal PdfDictionary Dictionary { get; }
    internal PdfCrossTable CrossTable { get; }
    public int Count { get; }
    public PdfPageTemplate Item { get; }
    private IPdfPrimitive Syncfusion.Pdf.IPdfWrapper.Element { get; }
    internal PdfPageTemplateCollection(PdfDictionary dictionary, PdfCrossTable crossTable);
    internal void Initialize();
    internal PdfDictionary get_Dictionary();
    internal PdfCrossTable get_CrossTable();
    public int get_Count();
    public PdfPageTemplate get_Item(int index);
    public void Add(PdfPageTemplate pdfPageTemplate);
    public bool Contains(PdfPageTemplate pdfPageTemplate);
    public void RemoveAt(int index);
    public void Remove(PdfPageTemplate pdfPageTemplate);
    public void Clear();
    private void Dictionary_BeginSave(object sender, SavePdfPrimitiveEventArgs ars);
    private void ParsingExistingPageTemplates(PdfLoadedPageCollection pageCollection, PdfArray pageTemplates, bool isVisible);
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
    private sealed virtual override IPdfPrimitive Syncfusion.Pdf.IPdfWrapper.get_Element();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class Syncfusion.Pdf.Interactive.PdfPolygonAnnotation : PdfAnnotation {
    private LineBorder m_border;
    internal PdfArray m_linePoints;
    private int m_lineExtension;
    private PdfBorderEffect m_borderEffect;
    private float m_borderWidth;
    private Int32[] m_points;
    private Single[] m_point;
    public PdfPopupAnnotationCollection ReviewHistory { get; }
    public PdfPopupAnnotationCollection Comments { get; }
    public PdfBorderEffect BorderEffect { get; public set; }
    public LineBorder Border { get; public set; }
    public int LineExtension { get; public set; }
    internal Int32[] PolygonPoints { get; internal set; }
    internal Single[] PolygonPoint { get; internal set; }
    public PdfPolygonAnnotation(Int32[] points, string text);
    internal PdfPolygonAnnotation(Single[] linePoints, string text);
    public PdfPopupAnnotationCollection get_ReviewHistory();
    public PdfPopupAnnotationCollection get_Comments();
    public PdfBorderEffect get_BorderEffect();
    public void set_BorderEffect(PdfBorderEffect value);
    public LineBorder get_Border();
    public void set_Border(LineBorder value);
    public int get_LineExtension();
    public void set_LineExtension(int value);
    internal Int32[] get_PolygonPoints();
    internal void set_PolygonPoints(Int32[] value);
    internal Single[] get_PolygonPoint();
    internal void set_PolygonPoint(Single[] value);
    protected virtual void Initialize();
    private PointF[] GetLinePoints();
    private void GetBoundsValue();
    internal virtual void FlattenAnnot(bool flattenPopUps);
    private void SaveAndFlatten(bool isExternalFlatten, bool isExternalFlattenPopUps);
    protected virtual void Save();
    private void FlattenAnnotation(PdfPageBase page, PdfTemplate appearance);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class Syncfusion.Pdf.Interactive.PdfPolyLineAnnotation : PdfAnnotation {
    private LineBorder m_border;
    internal PdfArray m_linePoints;
    private int m_lineExtension;
    internal PdfArray m_lineStyle;
    private PdfLineEndingStyle m_beginLine;
    private PdfLineEndingStyle m_endLine;
    private float m_borderWidth;
    private Int32[] m_points;
    private Single[] m_point;
    public PdfPopupAnnotationCollection ReviewHistory { get; }
    public PdfPopupAnnotationCollection Comments { get; }
    public LineBorder Border { get; public set; }
    public int LineExtension { get; public set; }
    public PdfLineEndingStyle BeginLineStyle { get; public set; }
    public PdfLineEndingStyle EndLineStyle { get; public set; }
    internal Int32[] PolylinePoints { get; internal set; }
    internal Single[] PolylinePoint { get; internal set; }
    public PdfPolyLineAnnotation(Int32[] points, string text);
    internal PdfPolyLineAnnotation(Single[] points, string text);
    public PdfPopupAnnotationCollection get_ReviewHistory();
    public PdfPopupAnnotationCollection get_Comments();
    public LineBorder get_Border();
    public void set_Border(LineBorder value);
    public int get_LineExtension();
    public void set_LineExtension(int value);
    public PdfLineEndingStyle get_BeginLineStyle();
    public void set_BeginLineStyle(PdfLineEndingStyle value);
    public PdfLineEndingStyle get_EndLineStyle();
    public void set_EndLineStyle(PdfLineEndingStyle value);
    internal Int32[] get_PolylinePoints();
    internal void set_PolylinePoints(Int32[] value);
    internal Single[] get_PolylinePoint();
    internal void set_PolylinePoint(Single[] value);
    protected virtual void Initialize();
    private PointF[] GetLinePoints();
    private void GetBoundsValue();
    internal virtual void FlattenAnnot(bool flattenPopUps);
    private void SaveAndFlatten(bool isExternalFlatten, bool isExternalFlattenPopUps);
    protected virtual void Save();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class Syncfusion.Pdf.Interactive.PdfPopupAnnotation : PdfAnnotation {
    private bool m_open;
    private PdfPopupIcon m_icon;
    private PdfAppearance m_appearance;
    private PdfAnnotationState m_state;
    private PdfAnnotationStateModel m_statemodel;
    private bool m_isCustomIconEnabled;
    private string m_iconName;
    public PdfPopupIcon Icon { get; public set; }
    public bool Open { get; public set; }
    public PdfAppearance Appearance { get; public set; }
    public PdfAnnotationState State { get; public set; }
    public PdfAnnotationStateModel StateModel { get; public set; }
    public PdfPopupAnnotationCollection ReviewHistory { get; }
    public PdfPopupAnnotationCollection Comments { get; }
    public string IconName { get; public set; }
    public PdfPopupAnnotation(RectangleF rectangle);
    public PdfPopupAnnotation(RectangleF rectangle, string text);
    internal PdfPopupAnnotation(RectangleF bounds, bool isPopup);
    public PdfPopupIcon get_Icon();
    public void set_Icon(PdfPopupIcon value);
    public bool get_Open();
    public void set_Open(bool value);
    public PdfAppearance get_Appearance();
    public void set_Appearance(PdfAppearance value);
    public PdfAnnotationState get_State();
    public void set_State(PdfAnnotationState value);
    public PdfAnnotationStateModel get_StateModel();
    public void set_StateModel(PdfAnnotationStateModel value);
    public PdfPopupAnnotationCollection get_ReviewHistory();
    public PdfPopupAnnotationCollection get_Comments();
    public string get_IconName();
    public void set_IconName(string value);
    protected virtual void Initialize();
    internal virtual void FlattenAnnot(bool flattenPopUps);
    private void SaveAndFlatten(bool isExternalFlattenPopUps);
    protected virtual void Save();
    private void CreateApearance();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[DefaultMemberAttribute("Item")]
public class Syncfusion.Pdf.Interactive.PdfPopupAnnotationCollection : PdfCollection {
    internal PdfDictionary annotDictionary;
    private bool isReview;
    internal PdfPageBase page;
    private int ReviewFlag;
    private int CommentFlag;
    public PdfPopupAnnotation Item { get; }
    internal PdfPopupAnnotationCollection(PdfAnnotation pdfAnnotation, bool isReview);
    public PdfPopupAnnotation get_Item(int index);
    public void Add(PdfPopupAnnotation popupAnnotation);
    private void DoAddPage(PdfDictionary annotDictionary, PdfPopupAnnotation annotation);
    private void AddInnerCommentOrReview(PdfPageBase page, PdfPopupAnnotation popupAnnotation);
    private PdfPopupAnnotationCollection GetCommentsOrReview(PdfAnnotation annotation, bool isReview);
    private void DoAddComments(PdfAnnotation annotation);
    private void DoAddReviewHistory(PdfAnnotation annotation);
    public void Remove(PdfPopupAnnotation popupAnnotation);
    public void RemoveAt(int index);
    private void DoRemovePage(PdfDictionary annotDictionary, PdfAnnotation annotation);
    private void DoRemoveChildAnnots(PdfPageBase lPage, PdfAnnotation annot);
    private bool IsReviewAnnot();
}
public enum Syncfusion.Pdf.Interactive.PdfPopupIcon : Enum {
    public int value__;
    public static PdfPopupIcon Note;
    public static PdfPopupIcon Comment;
    public static PdfPopupIcon Help;
    public static PdfPopupIcon Insert;
    public static PdfPopupIcon Key;
    public static PdfPopupIcon NewParagraph;
    public static PdfPopupIcon Paragraph;
    public static PdfPopupIcon Check;
    public static PdfPopupIcon Circle;
    public static PdfPopupIcon Cross;
    public static PdfPopupIcon CrossHairs;
    public static PdfPopupIcon RightArrow;
    public static PdfPopupIcon RightPointer;
    public static PdfPopupIcon Star;
    public static PdfPopupIcon UpArrow;
    public static PdfPopupIcon UpLeftArrow;
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[DefaultMemberAttribute("Item")]
public class Syncfusion.Pdf.Interactive.PdfRadioButtonItemCollection : PdfCollection {
    private PdfArray m_array;
    private PdfRadioButtonListField m_field;
    [CompilerGeneratedAttribute]
private EventHandler`1<FormFieldsAddedArgs> ItemsAdded;
    [CompilerGeneratedAttribute]
private EventHandler`1<FormFieldsRemovedArgs> ItemsRemoved;
    public PdfRadioButtonListItem Item { get; }
    private IPdfPrimitive Syncfusion.Pdf.IPdfWrapper.Element { get; }
    public PdfRadioButtonItemCollection(PdfRadioButtonListField field);
    [CompilerGeneratedAttribute]
internal void add_ItemsAdded(EventHandler`1<FormFieldsAddedArgs> value);
    [CompilerGeneratedAttribute]
internal void remove_ItemsAdded(EventHandler`1<FormFieldsAddedArgs> value);
    [CompilerGeneratedAttribute]
internal void add_ItemsRemoved(EventHandler`1<FormFieldsRemovedArgs> value);
    [CompilerGeneratedAttribute]
internal void remove_ItemsRemoved(EventHandler`1<FormFieldsRemovedArgs> value);
    internal void OnItemAdded(FormFieldsAddedArgs e);
    internal void OnItemRemoved(FormFieldsRemovedArgs e);
    public int Add(PdfRadioButtonListItem item);
    public void Insert(int index, PdfRadioButtonListItem item);
    public void Remove(PdfRadioButtonListItem item);
    public void RemoveAt(int index);
    public int IndexOf(PdfRadioButtonListItem item);
    public bool Contains(PdfRadioButtonListItem item);
    public void Clear();
    public PdfRadioButtonListItem get_Item(int index);
    private int DoAdd(PdfRadioButtonListItem item);
    private void DoInsert(int index, PdfRadioButtonListItem item);
    private void DoRemove(PdfRadioButtonListItem item);
    private void DoClear();
    private sealed virtual override IPdfPrimitive Syncfusion.Pdf.IPdfWrapper.get_Element();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class Syncfusion.Pdf.Interactive.PdfRadioButtonListField : PdfField {
    private PdfRadioButtonItemCollection m_items;
    private int m_selectedIndex;
    public int SelectedIndex { get; public set; }
    public string SelectedValue { get; public set; }
    public PdfRadioButtonListItem SelectedItem { get; }
    public PdfRadioButtonItemCollection Items { get; }
    public PdfRadioButtonListField(PdfPageBase page, string name);
    public int get_SelectedIndex();
    public void set_SelectedIndex(int value);
    public string get_SelectedValue();
    public void set_SelectedValue(string value);
    public PdfRadioButtonListItem get_SelectedItem();
    public PdfRadioButtonItemCollection get_Items();
    internal virtual void Draw();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class Syncfusion.Pdf.Interactive.PdfRadioButtonListItem : PdfCheckFieldBase {
    internal PdfRadioButtonListField m_field;
    private string m_value;
    public PdfForm Form { get; }
    public RectangleF Bounds { get; public set; }
    public string Value { get; public set; }
    private IPdfPrimitive Syncfusion.Pdf.IPdfWrapper.Element { get; }
    public PdfRadioButtonListItem(string value);
    public virtual PdfForm get_Form();
    public virtual RectangleF get_Bounds();
    public virtual void set_Bounds(RectangleF value);
    public string get_Value();
    public void set_Value(string value);
    protected virtual void Initialize();
    internal void SetField(PdfRadioButtonListField field);
    private void Widget_Save(object sender, EventArgs e);
    internal virtual void Save();
    protected virtual void DrawAppearance();
    private string ObtainValue();
    internal virtual void Draw();
    private sealed virtual override IPdfPrimitive Syncfusion.Pdf.IPdfWrapper.get_Element();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class Syncfusion.Pdf.Interactive.PdfRectangleAnnotation : PdfSquareAnnotation {
    public PdfPopupAnnotationCollection ReviewHistory { get; }
    public PdfPopupAnnotationCollection Comments { get; }
    public PdfRectangleAnnotation(RectangleF rectangle, string text);
    public PdfPopupAnnotationCollection get_ReviewHistory();
    public PdfPopupAnnotationCollection get_Comments();
    protected virtual void Initialize();
    internal virtual void FlattenAnnot(bool flattenPopUps);
    protected virtual void Save();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class Syncfusion.Pdf.Interactive.PdfRedactionAnnotation : PdfAnnotation {
    private PdfColor borderColor;
    private PdfColor textColor;
    private PdfFont font;
    private PdfTextAlignment alignment;
    private LineBorder border;
    private string overlayText;
    private bool repeat;
    private bool flatten;
    private float m_borderWidth;
    public PdfColor TextColor { get; public set; }
    public PdfTextAlignment TextAlignment { get; public set; }
    public string OverlayText { get; public set; }
    public PdfFont Font { get; public set; }
    public PdfColor BorderColor { get; public set; }
    public LineBorder Border { get; public set; }
    public bool RepeatText { get; public set; }
    public bool Flatten { get; public set; }
    public PdfColor get_TextColor();
    public void set_TextColor(PdfColor value);
    public PdfTextAlignment get_TextAlignment();
    public void set_TextAlignment(PdfTextAlignment value);
    public string get_OverlayText();
    public void set_OverlayText(string value);
    public PdfFont get_Font();
    public void set_Font(PdfFont value);
    public PdfColor get_BorderColor();
    public void set_BorderColor(PdfColor value);
    public LineBorder get_Border();
    public void set_Border(LineBorder value);
    public bool get_RepeatText();
    public void set_RepeatText(bool value);
    public bool get_Flatten();
    public void set_Flatten(bool value);
    protected virtual void Initialize();
    internal virtual void FlattenAnnot(bool flattenPopUps);
    private void SaveAndFlatten(bool isExternalFlattenPopUps);
    protected virtual void Save();
    internal void ApplyRedaction(PdfLoadedPage page);
}
public class Syncfusion.Pdf.Interactive.PdfRemoteDestination : PdfDestination {
    private int m_pageNumber;
    public int RemotePageNumber { get; public set; }
    public int get_RemotePageNumber();
    public void set_RemotePageNumber(int value);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class Syncfusion.Pdf.Interactive.PdfRemoteGoToAction : PdfAction {
    private string m_filePath;
    private PdfRemoteDestination m_remoteDestination;
    private bool m_isNewWindow;
    private PdfArray m_array;
    private PdfDestinationMode m_destinationMode;
    private float m_zoom;
    private PointF m_location;
    private RectangleF m_bounds;
    public string FilePath { get; public set; }
    public bool IsNewWindow { get; public set; }
    public PdfRemoteDestination PdfRemoteDestination { get; public set; }
    public PdfRemoteGoToAction(string filePath, PdfRemoteDestination remoteDestination);
    public string get_FilePath();
    public void set_FilePath(string value);
    public bool get_IsNewWindow();
    public void set_IsNewWindow(bool value);
    public PdfRemoteDestination get_PdfRemoteDestination();
    public void set_PdfRemoteDestination(PdfRemoteDestination value);
    protected virtual void Initialize();
    private void Dictionary_BeginSave(object sender, SavePdfPrimitiveEventArgs ars);
    private PdfArray Save();
}
public class Syncfusion.Pdf.Interactive.PdfResetAction : PdfFormAction {
    public bool Include { get; public set; }
    public virtual bool get_Include();
    public virtual void set_Include(bool value);
    protected virtual void Initialize();
}
public enum Syncfusion.Pdf.Interactive.PdfRichMediaActivationMode : Enum {
    public int value__;
    public static PdfRichMediaActivationMode PageOpen;
    public static PdfRichMediaActivationMode PageVisible;
    public static PdfRichMediaActivationMode Click;
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class Syncfusion.Pdf.Interactive.PdfRichMediaAnnotation : PdfAnnotation {
    internal PdfRichMediaContent content;
    internal PdfRichMediaPresentationStyle m_presentationStyle;
    internal PdfRichMediaActivationMode m_activationMode;
    private bool m_saved;
    private PdfAppearance m_appearance;
    public PdfAppearance Appearance { get; }
    public PdfRichMediaActivationMode ActivationMode { get; public set; }
    public PdfRichMediaContent Content { get; public set; }
    public PdfRichMediaPresentationStyle PresentationStyle { get; public set; }
    public PdfRichMediaAnnotation(RectangleF bounds);
    public PdfAppearance get_Appearance();
    public PdfRichMediaActivationMode get_ActivationMode();
    public void set_ActivationMode(PdfRichMediaActivationMode value);
    public PdfRichMediaContent get_Content();
    public void set_Content(PdfRichMediaContent value);
    public PdfRichMediaPresentationStyle get_PresentationStyle();
    public void set_PresentationStyle(PdfRichMediaPresentationStyle value);
    protected virtual void Initialize();
    protected virtual void Save();
    private void SaveRichMediaDictionary();
    private string GetActiveMode(PdfRichMediaActivationMode mode);
    private PdfTemplate CreateAppearance();
    private void SetMatrix(PdfDictionary template);
    internal virtual void FlattenAnnot(bool flattenPopUps);
    private PdfTemplate CustomAppearance(PdfTemplate template);
    private void FlattenAnnotation(PdfPageBase page, PdfTemplate appearance);
    private void SaveAndFlatten(bool isExternalFlatten, bool isExternalFlattenPopUps);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class Syncfusion.Pdf.Interactive.PdfRichMediaContent : object {
    private Stream m_data;
    private PdfRichMediaContentType m_type;
    internal PdfEmbeddedFileSpecification m_fileSpecification;
    internal bool isInternalLoad;
    private string mName;
    private string m_stringType;
    private string mFileExtension;
    public Stream Data { get; }
    public PdfRichMediaContentType ContentType { get; public set; }
    public string FileExtension { get; public set; }
    public string FileName { get; public set; }
    public PdfRichMediaContent(string name, Stream mediaFileStream, string fileExtension);
    public PdfRichMediaContent(string name, Stream mediaFileStream, string fileExtension, PdfRichMediaContentType type);
    internal PdfRichMediaContent(string mediaFile, Stream file, bool isInternal);
    public Stream get_Data();
    public PdfRichMediaContentType get_ContentType();
    public void set_ContentType(PdfRichMediaContentType value);
    public string get_FileExtension();
    public void set_FileExtension(string value);
    public string get_FileName();
    public void set_FileName(string value);
    private PdfRichMediaContentType GetRichMediaContentType(Stream mediaFile);
    private string ValidateFileExtension(string fileExtension);
    private string TrimFileExtension(string fileName);
    private string GetFileExtension(string fileName);
}
public enum Syncfusion.Pdf.Interactive.PdfRichMediaContentType : Enum {
    public int value__;
    public static PdfRichMediaContentType Video;
    public static PdfRichMediaContentType Sound;
}
public enum Syncfusion.Pdf.Interactive.PdfRichMediaPresentationStyle : Enum {
    public int value__;
    public static PdfRichMediaPresentationStyle Embedded;
    public static PdfRichMediaPresentationStyle Windowed;
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class Syncfusion.Pdf.Interactive.PdfRubberStampAnnotation : PdfAnnotation {
    private PdfRubberStampAnnotationIcon m_rubberStampAnnotaionIcon;
    private PdfAppearance m_appearance;
    private string m_icon;
    private float m_stampWidth;
    private bool m_standardStampAppearance;
    private float rotateAngle;
    private SizeF m_size;
    private PointF m_location;
    private bool m_saved;
    private bool m_resetAppearance;
    private bool m_alterRotateBounds;
    public PdfRubberStampAnnotationIcon Icon { get; public set; }
    public PdfAppearance Appearance { get; public set; }
    public PdfPopupAnnotationCollection ReviewHistory { get; }
    public PdfPopupAnnotationCollection Comments { get; }
    private string IconName { get; }
    private PdfColor BackGroundColor { get; }
    private PdfColor BorderColor { get; }
    public PdfRubberStampAnnotation(RectangleF rectangle);
    public PdfRubberStampAnnotation(RectangleF rectangle, string text);
    internal PdfRubberStampAnnotation(RectangleF rectangle, bool alterRotateBounds);
    public PdfRubberStampAnnotationIcon get_Icon();
    public void set_Icon(PdfRubberStampAnnotationIcon value);
    public PdfAppearance get_Appearance();
    public void set_Appearance(PdfAppearance value);
    public PdfPopupAnnotationCollection get_ReviewHistory();
    public PdfPopupAnnotationCollection get_Comments();
    private string get_IconName();
    private PdfColor get_BackGroundColor();
    private PdfColor get_BorderColor();
    protected virtual void Initialize();
    private string ObtainIconName(PdfRubberStampAnnotationIcon icon);
    private PdfColor ObtainBackGroundColor();
    private PdfColor ObtainBorderColor();
    internal virtual void FlattenAnnot(bool flattenPopUps);
    private void SaveAndFlatten(bool isExternalFlatten, bool isExternalFlattenPopUps);
    protected virtual void Save();
    private void FlattenAnnotation(PdfPageBase page, PdfTemplate appearance);
    internal PdfTemplate CreateAppearance();
    private PdfTemplate CreateStampAppearance(PdfTemplate template);
    private void SetDefaultIcon();
    private PdfTemplate CustomAppearance(PdfTemplate template);
    private void DrawRubberStamp(PdfGraphics graphics, PdfPath path, PdfPen mBorderPen, PdfBrush mBackBrush);
    private void DrawRubberStamp(PdfGraphics graphics, PdfPen mBorderPen, PdfBrush mBackBrush, PdfFont font, PdfStringFormat stringFormat);
    private void SetMatrix(PdfDictionary template);
    private void SetCustomStampIcon();
}
public enum Syncfusion.Pdf.Interactive.PdfRubberStampAnnotationIcon : Enum {
    public int value__;
    public static PdfRubberStampAnnotationIcon Approved;
    public static PdfRubberStampAnnotationIcon AsIs;
    public static PdfRubberStampAnnotationIcon Confidential;
    public static PdfRubberStampAnnotationIcon Departmental;
    public static PdfRubberStampAnnotationIcon Draft;
    public static PdfRubberStampAnnotationIcon Experimental;
    public static PdfRubberStampAnnotationIcon Expired;
    public static PdfRubberStampAnnotationIcon Final;
    public static PdfRubberStampAnnotationIcon ForComment;
    public static PdfRubberStampAnnotationIcon ForPublicRelease;
    public static PdfRubberStampAnnotationIcon NotApproved;
    public static PdfRubberStampAnnotationIcon NotForPublicRelease;
    public static PdfRubberStampAnnotationIcon Sold;
    public static PdfRubberStampAnnotationIcon TopSecret;
    public static PdfRubberStampAnnotationIcon Completed;
    public static PdfRubberStampAnnotationIcon Void;
    public static PdfRubberStampAnnotationIcon InformationOnly;
    public static PdfRubberStampAnnotationIcon PreliminaryResults;
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public abstract class Syncfusion.Pdf.Interactive.PdfSignatureAppearanceField : PdfSignatureStyledField {
    public PdfAppearance Appearance { get; }
    protected PdfSignatureAppearanceField(PdfPageBase page, string name);
    public PdfAppearance get_Appearance();
    internal virtual void Save();
    internal virtual void Draw();
    protected virtual void DrawAppearance(PdfTemplate template);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class Syncfusion.Pdf.Interactive.PdfSignatureField : PdfSignatureAppearanceField {
    private PdfSignature m_signature;
    internal bool m_fieldAutoNaming;
    internal bool m_SkipKidsCertificate;
    public PdfAppearance Appearance { get; }
    public PdfSignature Signature { get; public set; }
    public PdfSignatureField(PdfPageBase page, string name);
    public PdfAppearance get_Appearance();
    public PdfSignature get_Signature();
    public void set_Signature(PdfSignature value);
    protected virtual void Initialize();
    internal virtual void Save();
    private void Catalog_BeginSave(object sender, SavePdfPrimitiveEventArgs ars);
    private void Dictionary_BeginSave(object sender, SavePdfPrimitiveEventArgs ars);
    internal virtual void Draw();
    protected virtual void DrawAppearance(PdfTemplate template);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public abstract class Syncfusion.Pdf.Interactive.PdfSignatureStyledField : PdfField {
    private static byte ShadowShift;
    internal int m_angle;
    private WidgetAnnotation m_widget;
    private PdfFieldActions m_actions;
    private PdfTemplate m_appearanceTemplate;
    private PdfBrush m_backBrush;
    private PdfPen m_borderPen;
    private PdfBrush m_shadowBrush;
    private bool m_visible;
    private string m_name;
    internal bool m_containsBW;
    internal bool m_containsBG;
    public RectangleF Bounds { get; public set; }
    public int RotationAngle { get; public set; }
    public PointF Location { get; public set; }
    public SizeF Size { get; public set; }
    public PdfColor BorderColor { get; public set; }
    public PdfColor BackColor { get; public set; }
    public float BorderWidth { get; public set; }
    public PdfHighlightMode HighlightMode { get; public set; }
    public PdfFieldActions Actions { get; }
    public PdfBorderStyle BorderStyle { get; public set; }
    public bool Visible { get; public set; }
    internal PdfBrush ShadowBrush { get; }
    internal WidgetAnnotation Widget { get; }
    internal PdfTemplate AppearanceTemplate { get; }
    internal PdfBrush BackBrush { get; }
    internal PdfPen BorderPen { get; }
    public PdfSignatureStyledField(PdfPageBase page, string name);
    public virtual RectangleF get_Bounds();
    public virtual void set_Bounds(RectangleF value);
    public int get_RotationAngle();
    public void set_RotationAngle(int value);
    public PointF get_Location();
    public void set_Location(PointF value);
    public SizeF get_Size();
    public void set_Size(SizeF value);
    public PdfColor get_BorderColor();
    public void set_BorderColor(PdfColor value);
    public PdfColor get_BackColor();
    public void set_BackColor(PdfColor value);
    public float get_BorderWidth();
    public void set_BorderWidth(float value);
    public PdfHighlightMode get_HighlightMode();
    public void set_HighlightMode(PdfHighlightMode value);
    public PdfFieldActions get_Actions();
    public PdfBorderStyle get_BorderStyle();
    public void set_BorderStyle(PdfBorderStyle value);
    public bool get_Visible();
    public void set_Visible(bool value);
    internal PdfBrush get_ShadowBrush();
    internal WidgetAnnotation get_Widget();
    internal PdfTemplate get_AppearanceTemplate();
    internal PdfBrush get_BackBrush();
    internal PdfPen get_BorderPen();
    internal virtual void Draw();
    internal void RemoveAnnoationFromPage(PdfPageBase page, PdfAnnotation widget);
    internal void AddAnnotationToPage(PdfPageBase page, PdfAnnotation widget);
    protected virtual void Initialize();
    private void CreateBorderPen();
    private void CreateBackBrush();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class Syncfusion.Pdf.Interactive.PdfSound : object {
    private int m_rate;
    private PdfSoundEncoding m_encoding;
    private PdfSoundChannels m_channels;
    private int m_bits;
    private string m_fileName;
    private PdfStream m_stream;
    private Stream m_data;
    public int Rate { get; public set; }
    public int Bits { get; public set; }
    public PdfSoundEncoding Encoding { get; public set; }
    public PdfSoundChannels Channels { get; public set; }
    public string FileName { get; public set; }
    private IPdfPrimitive Syncfusion.Pdf.IPdfWrapper.Element { get; }
    internal PdfSound(string fileName);
    public PdfSound(Stream data);
    internal PdfSound(string fileName, bool test);
    public int get_Rate();
    public void set_Rate(int value);
    public int get_Bits();
    public void set_Bits(int value);
    public PdfSoundEncoding get_Encoding();
    public void set_Encoding(PdfSoundEncoding value);
    public PdfSoundChannels get_Channels();
    public void set_Channels(PdfSoundChannels value);
    public string get_FileName();
    public void set_FileName(string value);
    private void Stream_BeginSave(object sender, SavePdfPrimitiveEventArgs ars);
    protected void Save();
    private sealed virtual override IPdfPrimitive Syncfusion.Pdf.IPdfWrapper.get_Element();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class Syncfusion.Pdf.Interactive.PdfSoundAction : PdfAction {
    private float m_volume;
    private PdfSound m_sound;
    private bool m_synchronous;
    private bool m_repeat;
    private bool m_mix;
    public float Volume { get; public set; }
    public string FileName { get; public set; }
    public PdfSound Sound { get; public set; }
    public bool Synchronous { get; public set; }
    public bool Repeat { get; public set; }
    public bool Mix { get; public set; }
    public PdfSoundAction(Stream data);
    public float get_Volume();
    public void set_Volume(float value);
    public string get_FileName();
    public void set_FileName(string value);
    public PdfSound get_Sound();
    public void set_Sound(PdfSound value);
    public bool get_Synchronous();
    public void set_Synchronous(bool value);
    public bool get_Repeat();
    public void set_Repeat(bool value);
    public bool get_Mix();
    public void set_Mix(bool value);
    protected virtual void Initialize();
    private void Dictionary_BeginSave(object sender, SavePdfPrimitiveEventArgs ars);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class Syncfusion.Pdf.Interactive.PdfSoundAnnotation : PdfFileAnnotation {
    private PdfSoundIcon m_icon;
    private PdfSound m_sound;
    public PdfSoundIcon Icon { get; public set; }
    public PdfSound Sound { get; public set; }
    public PdfPopupAnnotationCollection ReviewHistory { get; }
    public PdfPopupAnnotationCollection Comments { get; }
    public string FileName { get; public set; }
    public PdfSoundAnnotation(RectangleF rectangle, Stream data);
    public PdfSoundIcon get_Icon();
    public void set_Icon(PdfSoundIcon value);
    public PdfSound get_Sound();
    public void set_Sound(PdfSound value);
    public PdfPopupAnnotationCollection get_ReviewHistory();
    public PdfPopupAnnotationCollection get_Comments();
    public virtual string get_FileName();
    public virtual void set_FileName(string value);
    protected virtual void Initialize();
    protected virtual void Save();
}
public enum Syncfusion.Pdf.Interactive.PdfSoundChannels : Enum {
    public int value__;
    public static PdfSoundChannels Mono;
    public static PdfSoundChannels Stereo;
}
public enum Syncfusion.Pdf.Interactive.PdfSoundEncoding : Enum {
    public int value__;
    public static PdfSoundEncoding Raw;
    public static PdfSoundEncoding Signed;
    public static PdfSoundEncoding MuLaw;
    public static PdfSoundEncoding ALaw;
}
public enum Syncfusion.Pdf.Interactive.PdfSoundIcon : Enum {
    public int value__;
    public static PdfSoundIcon Speaker;
    public static PdfSoundIcon Mic;
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class Syncfusion.Pdf.Interactive.PdfSquareAnnotation : PdfAnnotation {
    private LineBorder m_border;
    private PdfBorderEffect m_borderEffect;
    private float m_borderWidth;
    public PdfPopupAnnotationCollection ReviewHistory { get; }
    public PdfPopupAnnotationCollection Comments { get; }
    public PdfBorderEffect BorderEffect { get; public set; }
    public LineBorder Border { get; public set; }
    public PdfSquareAnnotation(RectangleF rectangle, string text);
    public PdfSquareAnnotation(RectangleF rectangle);
    public PdfPopupAnnotationCollection get_ReviewHistory();
    public PdfPopupAnnotationCollection get_Comments();
    public PdfBorderEffect get_BorderEffect();
    public void set_BorderEffect(PdfBorderEffect value);
    public LineBorder get_Border();
    public void set_Border(LineBorder value);
    protected virtual void Initialize();
    internal virtual void FlattenAnnot(bool flattenPopUps);
    private void SaveAndFlatten(bool isExternalFlatten, bool isExternalFlattenPopUps);
    protected virtual void Save();
    private void FlattenAnnotation(PdfPageBase page, PdfTemplate appearance);
    private PdfTemplate CreateAppearance();
    private RectangleF ObtainStyle(RectangleF rectangle);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class Syncfusion.Pdf.Interactive.PdfSquareMeasurementAnnotation : PdfAnnotation {
    private LineBorder m_border;
    private string m_unitString;
    private PdfMeasurementUnit m_measurementUnit;
    private PdfFont m_font;
    private float m_borderWidth;
    public PdfMeasurementUnit Unit { get; public set; }
    public LineBorder Border { get; public set; }
    public PdfFont Font { get; public set; }
    public PdfPopupAnnotationCollection Comments { get; }
    public PdfPopupAnnotationCollection ReviewHistory { get; }
    public PdfSquareMeasurementAnnotation(RectangleF rectangle);
    public PdfMeasurementUnit get_Unit();
    public void set_Unit(PdfMeasurementUnit value);
    public LineBorder get_Border();
    public void set_Border(LineBorder value);
    public PdfFont get_Font();
    public void set_Font(PdfFont value);
    public PdfPopupAnnotationCollection get_Comments();
    public PdfPopupAnnotationCollection get_ReviewHistory();
    protected virtual void Initialize();
    private float CalculateAreaOfSquare();
    protected virtual void Save();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public abstract class Syncfusion.Pdf.Interactive.PdfStyledField : PdfField {
    private static byte ShadowShift;
    internal int m_angle;
    internal WidgetAnnotation m_widget;
    private PdfFont m_font;
    private PdfFieldActions m_actions;
    private PdfTemplate m_appearanceTemplate;
    private PdfBrush m_backBrush;
    private PdfColor m_backRectColor;
    private PdfBrush m_foreBrush;
    private PdfPen m_borderPen;
    private PdfStringFormat m_stringFormat;
    private PdfBrush m_shadowBrush;
    private bool m_visible;
    private PdfFormFieldVisibility m_visibility;
    internal PdfArray m_array;
    internal List`1<PdfField> fieldItems;
    internal bool m_isBCSet;
    public RectangleF Bounds { get; public set; }
    public PdfFormFieldVisibility Visibility { get; public set; }
    public PointF Location { get; public set; }
    public int RotationAngle { get; public set; }
    public SizeF Size { get; public set; }
    public PdfColor BorderColor { get; public set; }
    public PdfColor BackColor { get; public set; }
    internal PdfColor BackRectColor { get; internal set; }
    public PdfColor ForeColor { get; public set; }
    public float BorderWidth { get; public set; }
    public PdfHighlightMode HighlightMode { get; public set; }
    public PdfFont Font { get; public set; }
    public PdfTextAlignment TextAlignment { get; public set; }
    public PdfFieldActions Actions { get; }
    public PdfBorderStyle BorderStyle { get; public set; }
    public bool Visible { get; public set; }
    internal PdfBrush ShadowBrush { get; }
    internal WidgetAnnotation Widget { get; }
    internal PdfTemplate AppearanceTemplate { get; }
    internal PdfBrush BackBrush { get; }
    internal PdfPen BorderPen { get; }
    internal PdfBrush ForeBrush { get; }
    internal PdfStringFormat StringFormat { get; }
    public PdfStyledField(PdfPageBase page, string name);
    public virtual RectangleF get_Bounds();
    public virtual void set_Bounds(RectangleF value);
    public PdfFormFieldVisibility get_Visibility();
    public void set_Visibility(PdfFormFieldVisibility value);
    public PointF get_Location();
    public void set_Location(PointF value);
    public int get_RotationAngle();
    public void set_RotationAngle(int value);
    public SizeF get_Size();
    public void set_Size(SizeF value);
    public PdfColor get_BorderColor();
    public void set_BorderColor(PdfColor value);
    public PdfColor get_BackColor();
    public void set_BackColor(PdfColor value);
    internal PdfColor get_BackRectColor();
    internal void set_BackRectColor(PdfColor value);
    public PdfColor get_ForeColor();
    public void set_ForeColor(PdfColor value);
    public float get_BorderWidth();
    public void set_BorderWidth(float value);
    public PdfHighlightMode get_HighlightMode();
    public void set_HighlightMode(PdfHighlightMode value);
    public PdfFont get_Font();
    public void set_Font(PdfFont value);
    public PdfTextAlignment get_TextAlignment();
    public void set_TextAlignment(PdfTextAlignment value);
    public PdfFieldActions get_Actions();
    public PdfBorderStyle get_BorderStyle();
    public void set_BorderStyle(PdfBorderStyle value);
    public bool get_Visible();
    public void set_Visible(bool value);
    internal PdfBrush get_ShadowBrush();
    internal WidgetAnnotation get_Widget();
    internal PdfTemplate get_AppearanceTemplate();
    internal PdfBrush get_BackBrush();
    internal PdfPen get_BorderPen();
    internal PdfBrush get_ForeBrush();
    internal PdfStringFormat get_StringFormat();
    private void SetVisibility();
    internal virtual void Draw();
    internal void RemoveAnnoationFromPage(PdfPageBase page, PdfAnnotation widget);
    internal void AddAnnotationToPage(PdfPageBase page, PdfAnnotation widget);
    protected PdfFont ObtainFont();
    protected virtual void Initialize();
    protected virtual void DefineDefaultAppearance();
    private void CreateBorderPen();
    private void CreateBackBrush();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class Syncfusion.Pdf.Interactive.PdfSubmitAction : PdfFormAction {
    private string _mFileName;
    private PdfSubmitFormFlags m_flags;
    private HttpMethod m_httpMethod;
    private bool m_canonicalDateTimeFormat;
    private bool m_submitCoordinates;
    private bool m_includeNoValueFields;
    private bool m_includeIncrementalUpdates;
    private bool m_includeAnnotations;
    private bool m_excludeNonUserAnnotations;
    private bool m_embedForm;
    private SubmitDataFormat m_dataFormat;
    public string Url { get; }
    public HttpMethod HttpMethod { get; public set; }
    public bool CanonicalDateTimeFormat { get; public set; }
    public bool SubmitCoordinates { get; public set; }
    public bool IncludeNoValueFields { get; public set; }
    public bool IncludeIncrementalUpdates { get; public set; }
    public bool IncludeAnnotations { get; public set; }
    public bool ExcludeNonUserAnnotations { get; public set; }
    public bool EmbedForm { get; public set; }
    public SubmitDataFormat DataFormat { get; public set; }
    public bool Include { get; public set; }
    public PdfSubmitAction(string url);
    public string get_Url();
    public HttpMethod get_HttpMethod();
    public void set_HttpMethod(HttpMethod value);
    public bool get_CanonicalDateTimeFormat();
    public void set_CanonicalDateTimeFormat(bool value);
    public bool get_SubmitCoordinates();
    public void set_SubmitCoordinates(bool value);
    public bool get_IncludeNoValueFields();
    public void set_IncludeNoValueFields(bool value);
    public bool get_IncludeIncrementalUpdates();
    public void set_IncludeIncrementalUpdates(bool value);
    public bool get_IncludeAnnotations();
    public void set_IncludeAnnotations(bool value);
    public bool get_ExcludeNonUserAnnotations();
    public void set_ExcludeNonUserAnnotations(bool value);
    public bool get_EmbedForm();
    public void set_EmbedForm(bool value);
    public SubmitDataFormat get_DataFormat();
    public void set_DataFormat(SubmitDataFormat value);
    public virtual bool get_Include();
    public virtual void set_Include(bool value);
    protected virtual void Initialize();
    private void Dictionary_BeginSave(object sender, SavePdfPrimitiveEventArgs ars);
}
[FlagsAttribute]
public enum Syncfusion.Pdf.Interactive.PdfSubmitFormFlags : Enum {
    public int value__;
    public static PdfSubmitFormFlags IncludeExclude;
    public static PdfSubmitFormFlags IncludeNoValueFields;
    public static PdfSubmitFormFlags ExportFormat;
    public static PdfSubmitFormFlags GetMethod;
    public static PdfSubmitFormFlags SubmitCoordinates;
    public static PdfSubmitFormFlags Xfdf;
    public static PdfSubmitFormFlags IncludeAppendSaves;
    public static PdfSubmitFormFlags IncludeAnnotations;
    public static PdfSubmitFormFlags SubmitPdf;
    public static PdfSubmitFormFlags CanonicalFormat;
    public static PdfSubmitFormFlags ExclNonUserAnnots;
    public static PdfSubmitFormFlags ExclFKey;
    public static PdfSubmitFormFlags EmbedForm;
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class Syncfusion.Pdf.Interactive.PdfTextBoxField : PdfAppearanceField {
    private static string m_passwordValue;
    private string m_text;
    private string m_defaultValue;
    private bool m_spellCheck;
    private bool m_insertSpaces;
    private bool m_multiline;
    private bool m_password;
    private bool m_scrollable;
    private int m_maxLength;
    private bool m_autoResizeText;
    public bool ComplexScript { get; public set; }
    public string Text { get; public set; }
    public string DefaultValue { get; public set; }
    public bool SpellCheck { get; public set; }
    public bool InsertSpaces { get; public set; }
    public bool Multiline { get; public set; }
    public bool Password { get; public set; }
    public bool Scrollable { get; public set; }
    public int MaxLength { get; public set; }
    public bool AutoResizeText { get; public set; }
    public PdfTextBoxField(PdfPageBase page, string name);
    public bool get_ComplexScript();
    public void set_ComplexScript(bool value);
    public string get_Text();
    public void set_Text(string value);
    public string get_DefaultValue();
    public void set_DefaultValue(string value);
    public bool get_SpellCheck();
    public void set_SpellCheck(bool value);
    public bool get_InsertSpaces();
    public void set_InsertSpaces(bool value);
    public bool get_Multiline();
    public void set_Multiline(bool value);
    public bool get_Password();
    public void set_Password(bool value);
    public bool get_Scrollable();
    public void set_Scrollable(bool value);
    public int get_MaxLength();
    public void set_MaxLength(int value);
    public bool get_AutoResizeText();
    public void set_AutoResizeText(bool value);
    internal virtual void Draw();
    protected virtual void Initialize();
    protected virtual void DrawAppearance(PdfTemplate template);
    private void SetFittingFontSize(PaintParams prms, string text);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class Syncfusion.Pdf.Interactive.PdfTextMarkupAnnotation : PdfAnnotation {
    private PdfTextMarkupAnnotationType m_textMarkupAnnotationType;
    private Int32[] m_quadPoints;
    private PdfArray m_points;
    private PdfColor m_textMarkupColor;
    private string m_text;
    internal SizeF m_textSize;
    private PointF m_textPoint;
    internal PdfFont m_font;
    private List`1<RectangleF> m_boundscollection;
    internal PdfDictionary m_borderDic;
    private PdfLineBorderStyle m_borderStyle;
    public PdfTextMarkupAnnotationType TextMarkupAnnotationType { get; public set; }
    public PdfColor TextMarkupColor { get; public set; }
    internal PdfLineBorderStyle BorderStyle { get; internal set; }
    public List`1<RectangleF> BoundsCollection { get; public set; }
    public PdfPopupAnnotationCollection ReviewHistory { get; }
    public PdfPopupAnnotationCollection Comments { get; }
    public PdfTextMarkupAnnotation(string markupTitle, string text, string markupText, PointF point, PdfFont pdfFont);
    public PdfTextMarkupAnnotation(RectangleF rectangle);
    public PdfTextMarkupAnnotationType get_TextMarkupAnnotationType();
    public void set_TextMarkupAnnotationType(PdfTextMarkupAnnotationType value);
    public PdfColor get_TextMarkupColor();
    public void set_TextMarkupColor(PdfColor value);
    internal PdfLineBorderStyle get_BorderStyle();
    internal void set_BorderStyle(PdfLineBorderStyle value);
    public List`1<RectangleF> get_BoundsCollection();
    public void set_BoundsCollection(List`1<RectangleF> value);
    public PdfPopupAnnotationCollection get_ReviewHistory();
    public PdfPopupAnnotationCollection get_Comments();
    protected virtual void Initialize();
    internal virtual void FlattenAnnot(bool flattenPopUps);
    private void SaveAndFlatten(bool isExternalFlatten, bool isExternalFlattenPopUps);
    protected virtual void Save();
    private void SaveTextMarkUpDictionary();
    private void FlattenAnnotation(PdfPageBase page, PdfTemplate appearance);
    private PdfPath DrawSquiggly(float width, float height);
    private PdfTemplate CreateAppearance();
    internal void SetQuadPoints(SizeF pageSize);
}
public enum Syncfusion.Pdf.Interactive.PdfTextMarkupAnnotationType : Enum {
    public int value__;
    public static PdfTextMarkupAnnotationType Highlight;
    public static PdfTextMarkupAnnotationType Underline;
    public static PdfTextMarkupAnnotationType Squiggly;
    public static PdfTextMarkupAnnotationType StrikeOut;
}
[FlagsAttribute]
public enum Syncfusion.Pdf.Interactive.PdfTextStyle : Enum {
    public int value__;
    public static PdfTextStyle Regular;
    public static PdfTextStyle Italic;
    public static PdfTextStyle Bold;
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class Syncfusion.Pdf.Interactive.PdfTextWebLink : PdfTextElement {
    private string m_url;
    private PdfUriAnnotation m_uriAnnotation;
    public string Url { get; public set; }
    public string get_Url();
    public void set_Url(string value);
    public PdfLayoutResult DrawTextWebLink(PdfPage page, PointF location);
    public void DrawTextWebLink(PdfGraphics graphics, PointF location);
    private RectangleF CalculateBounds(PointF location, SizeF size);
    internal void AnnotationRotateAndTransform(PdfGraphics graphics);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class Syncfusion.Pdf.Interactive.PdfUriAction : PdfAction {
    private string _mUri;
    public string Uri { get; public set; }
    public PdfUriAction(string uri);
    public string get_Uri();
    public void set_Uri(string value);
    protected virtual void Initialize();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class Syncfusion.Pdf.Interactive.PdfUriAnnotation : PdfActionLinkAnnotation {
    private PdfUriAction m_uriAction;
    public string Uri { get; public set; }
    public PdfAction Action { get; public set; }
    public PdfUriAnnotation(RectangleF rectangle);
    public PdfUriAnnotation(RectangleF rectangle, string uri);
    public string get_Uri();
    public void set_Uri(string value);
    public virtual PdfAction get_Action();
    public virtual void set_Action(PdfAction value);
    protected virtual void Initialize();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class Syncfusion.Pdf.Interactive.PdfWatermarkAnnotation : PdfAnnotation {
    private PdfAppearance m_appearance;
    private float m_opacity;
    private float rotateAngle;
    private SizeF m_size;
    private PointF m_location;
    private bool m_saved;
    public PdfAppearance Appearance { get; }
    public float Opacity { get; public set; }
    public PdfWatermarkAnnotation(RectangleF rectangle);
    public PdfAppearance get_Appearance();
    public virtual float get_Opacity();
    public virtual void set_Opacity(float value);
    protected virtual void Initialize();
    private void SetMatrix(PdfDictionary template);
    protected virtual void Save();
    internal virtual void FlattenAnnot(bool flattenPopUps);
    private PdfTemplate CustomAppearance(PdfTemplate template);
    private PdfTemplate CreateAppearance();
    private void SaveAndFlatten(bool isExternalFlatten, bool isExternalFlattenPopUps);
    private void FlattenAnnotation(PdfPageBase page, PdfTemplate appearance);
}
public enum Syncfusion.Pdf.Interactive.SubmitDataFormat : Enum {
    public int value__;
    public static SubmitDataFormat Html;
    public static SubmitDataFormat Pdf;
    public static SubmitDataFormat Fdf;
    public static SubmitDataFormat Xfdf;
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Syncfusion.Pdf.Interactive.WidgetAnnotation : PdfAnnotation {
    private PdfField m_parent;
    private PdfExtendedAppearance m_extendedAppearance;
    private WidgetBorder m_border;
    private WidgetAppearance m_widgetAppearance;
    private PdfHighlightMode m_highlightMode;
    private PdfDefaultAppearance m_defaultAppearance;
    private PdfTextAlignment m_alignment;
    private PdfAnnotationActions m_actions;
    private PdfAppearance m_appearance;
    private string m_appearanceState;
    internal bool isAutoResize;
    internal PdfSignatureField m_signatureField;
    [CompilerGeneratedAttribute]
private EventHandler BeginSave;
    public PdfField Parent { get; public set; }
    public PdfExtendedAppearance ExtendedAppearance { get; public set; }
    public PdfDefaultAppearance DefaultAppearance { get; }
    public WidgetBorder WidgetBorder { get; }
    public WidgetAppearance WidgetAppearance { get; }
    public PdfHighlightMode HighlightMode { get; public set; }
    public PdfTextAlignment TextAlignment { get; public set; }
    public PdfAnnotationActions Actions { get; }
    public PdfAppearance Appearance { get; public set; }
    internal string AppearanceState { get; internal set; }
    public PdfField get_Parent();
    public void set_Parent(PdfField value);
    public PdfExtendedAppearance get_ExtendedAppearance();
    public void set_ExtendedAppearance(PdfExtendedAppearance value);
    public PdfDefaultAppearance get_DefaultAppearance();
    public WidgetBorder get_WidgetBorder();
    public WidgetAppearance get_WidgetAppearance();
    public PdfHighlightMode get_HighlightMode();
    public void set_HighlightMode(PdfHighlightMode value);
    public PdfTextAlignment get_TextAlignment();
    public void set_TextAlignment(PdfTextAlignment value);
    public PdfAnnotationActions get_Actions();
    public PdfAppearance get_Appearance();
    public void set_Appearance(PdfAppearance value);
    internal string get_AppearanceState();
    internal void set_AppearanceState(string value);
    [CompilerGeneratedAttribute]
internal void add_BeginSave(EventHandler value);
    [CompilerGeneratedAttribute]
internal void remove_BeginSave(EventHandler value);
    protected virtual void Initialize();
    protected virtual void OnBeginSave(EventArgs args);
    protected virtual void Save();
    private string HighlightModeToString(PdfHighlightMode m_highlightingMode);
    internal PdfAppearance ObtainAppearance();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[DefaultMemberAttribute("Item")]
internal class Syncfusion.Pdf.Interactive.WidgetAnnotationCollection : PdfCollection {
    private PdfArray m_array;
    public WidgetAnnotation Item { get; }
    public IPdfPrimitive Element { get; }
    public WidgetAnnotation get_Item(int index);
    public int Add(WidgetAnnotation annotation);
    public void Insert(int index, WidgetAnnotation annotation);
    public void Remove(WidgetAnnotation annotation);
    public void RemoveAt(int index);
    public int IndexOf(WidgetAnnotation annotation);
    public bool Contains(WidgetAnnotation annotation);
    public void Clear();
    private int DoAdd(WidgetAnnotation annotation);
    private void DoInsert(int index, WidgetAnnotation annotation);
    private void DoRemove(WidgetAnnotation annotation);
    private void DoRemoveAt(int index);
    private void DoClear();
    public sealed virtual IPdfPrimitive get_Element();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Syncfusion.Pdf.Interactive.WidgetAppearance : object {
    private PdfColor m_borderColor;
    private PdfColor m_backColor;
    private string m_normalCaption;
    private PdfDictionary m_dictionary;
    private int m_rotationAngle;
    internal int RotationAngle { get; internal set; }
    public PdfColor BorderColor { get; public set; }
    public PdfColor BackColor { get; public set; }
    public string NormalCaption { get; public set; }
    public IPdfPrimitive Element { get; }
    internal int get_RotationAngle();
    internal void set_RotationAngle(int value);
    public PdfColor get_BorderColor();
    public void set_BorderColor(PdfColor value);
    public PdfColor get_BackColor();
    public void set_BackColor(PdfColor value);
    public string get_NormalCaption();
    public void set_NormalCaption(string value);
    public sealed virtual IPdfPrimitive get_Element();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Syncfusion.Pdf.Interactive.WidgetBorder : object {
    private float m_width;
    private PdfBorderStyle m_style;
    private PdfDictionary m_dictionary;
    public float Width { get; public set; }
    public PdfBorderStyle Style { get; public set; }
    public IPdfPrimitive Element { get; }
    public float get_Width();
    public void set_Width(float value);
    public PdfBorderStyle get_Style();
    public void set_Style(PdfBorderStyle value);
    private string StyleToString(PdfBorderStyle style);
    public sealed virtual IPdfPrimitive get_Element();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Syncfusion.Pdf.IO.ArchiveInformation : object {
    private long m_archiveNumber;
    private long m_index;
    private PdfStream m_archive;
    private GetArchive m_getArchive;
    public PdfStream Archive { get; }
    public long Index { get; }
    internal long ArchiveNumber { get; }
    public ArchiveInformation(long arcNum, long index, GetArchive getArchive);
    public PdfStream get_Archive();
    public long get_Index();
    internal long get_ArchiveNumber();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Syncfusion.Pdf.IO.BigEndianReader : object {
    internal static int Int32Size;
    internal static int Int16Size;
    internal static int Int64Size;
    private Encoding c_encoding;
    private static float c_fraction;
    private BinaryReader m_reader;
    public BinaryReader Reader { get; public set; }
    public Stream BaseStream { get; }
    public BigEndianReader(BinaryReader reader);
    public BinaryReader get_Reader();
    public void set_Reader(BinaryReader value);
    public Stream get_BaseStream();
    public void Close();
    public void Seek(long position);
    public void Skip(long numBytes);
    public Byte[] Reverse(Byte[] buffer);
    public long ReadInt64();
    public ulong ReadUInt64();
    public int ReadInt32();
    public UInt32 ReadUInt32();
    public short ReadInt16();
    public ushort ReadUInt16();
    public byte ReadByte();
    public float ReadFixed();
    public Byte[] ReadBytes(int count);
    public string ReadString(int len);
    public string ReadString(int len, bool unicode);
    public string ReadUtf8String(int len);
    public int Read(Byte[] buffer, int index, int count);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Syncfusion.Pdf.IO.BigEndianWriter : object {
    internal static int Int32Size;
    internal static int Int16Size;
    internal static int Int64Size;
    private Encoding c_encoding;
    private static float c_fraction;
    private Byte[] m_buffer;
    private int m_position;
    public Byte[] Data { get; }
    public int Position { get; }
    public BigEndianWriter(int capacity);
    public Byte[] get_Data();
    public int get_Position();
    public void Write(short value);
    public void Write(ushort value);
    public void Write(int value);
    public void Write(UInt32 value);
    public void Write(string value);
    public void Write(Byte[] value);
    private void Flush(Byte[] buff);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[DefaultMemberAttribute("Item")]
internal class Syncfusion.Pdf.IO.CrossTable : object {
    private Stream m_stream;
    private PdfReader m_reader;
    private PdfParser m_parser;
    internal Dictionary`2<long, ObjectInformation> m_objects;
    private PdfDictionary m_trailer;
    private PdfReferenceHolder m_documentCatalog;
    private long m_startXRef;
    private Dictionary`2<PdfStream, PdfParser> m_readersTable;
    private Dictionary`2<long, PdfStream> m_archives;
    private PdfEncryptor m_encryptor;
    private PdfCrossTable m_crossTable;
    internal long m_initialNumberOfSubsection;
    internal long m_initialSubsectionCount;
    internal long m_totalNumberOfSubsection;
    private bool m_isStructureAltered;
    private static int m_generationNumber;
    internal bool m_isOpenAndRepair;
    private long m_whiteSpace;
    internal bool validateSyntax;
    private Dictionary`2<long, List`1<ObjectInformation>> m_allTables;
    internal Dictionary`2<PdfStream, Int64[]> archiveIndices;
    private bool m_repair;
    internal long m_trailerPosition;
    internal bool m_invalidXrefStart;
    internal bool m_closeCompletely;
    private List`1<long> m_prevOffset;
    private List`1<long> m_eofOffset;
    internal ObjectInformation Item { get; }
    internal Dictionary`2<long, List`1<ObjectInformation>> AllTables { get; }
    public long Count { get; }
    public PdfReferenceHolder DocumentCatalog { get; }
    internal Stream Stream { get; }
    internal long XRefOffset { get; }
    public PdfReader Reader { get; }
    public PdfParser Parser { get; }
    internal PdfDictionary Trailer { get; }
    internal bool IsStructureAltered { get; }
    internal PdfEncryptor Encryptor { get; internal set; }
    internal List`1<long> PrevOffset { get; }
    internal List`1<long> EofOffset { get; internal set; }
    public CrossTable(Stream docStream, PdfCrossTable crossTable);
    internal CrossTable(Stream docStream, PdfCrossTable crossTable, bool isFdf);
    internal ObjectInformation get_Item(long index);
    internal Dictionary`2<long, List`1<ObjectInformation>> get_AllTables();
    public long get_Count();
    public PdfReferenceHolder get_DocumentCatalog();
    internal Stream get_Stream();
    internal long get_XRefOffset();
    public PdfReader get_Reader();
    public PdfParser get_Parser();
    internal PdfDictionary get_Trailer();
    internal bool get_IsStructureAltered();
    internal PdfEncryptor get_Encryptor();
    internal void set_Encryptor(PdfEncryptor value);
    internal List`1<long> get_PrevOffset();
    internal List`1<long> get_EofOffset();
    internal void set_EofOffset(List`1<long> value);
    private void ReadAllObjects(Dictionary`2<long, ObjectInformation> objects, PdfParser parser);
    private void CheckStartxref();
    public IPdfPrimitive GetObject(IPdfPrimitive pointer);
    public Byte[] GetStream(IPdfPrimitive streamRef);
    internal void ParseNewTable(PdfStream stream, Dictionary`2<long, ObjectInformation> hashTable);
    internal void ParseSubsection(PdfParser parser, Dictionary`2<long, ObjectInformation> table);
    private void AddTables(long objectOffset, ObjectInformation oi);
    internal PdfParser RetrieveParser(ArchiveInformation archive);
    private PdfStream RetrieveArchive(long archiveNumber);
    private List`1<SubSection> GetSections(PdfStream stream);
    private int ParseSubsection(PdfStream stream, SubSection subsection, Dictionary`2<long, ObjectInformation> table, int startIndex);
    private IPdfPrimitive GetObject(PdfParser parser, long position);
    private int CheckJunk();
    internal void Dispose();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Syncfusion.Pdf.IO.DictionaryProperties : object {
    internal static string App;
    internal static string RV;
    internal static string Prop_Build;
    public static string ModifyDate;
    public static string dc;
    internal static string Calibrate;
    internal static string CustomData;
    public static string pdfx;
    public static string Size;
    public static string First;
    public static string N;
    public static string W;
    public static string Count;
    public static string Length;
    public static string Length1;
    public static string Length2;
    public static string Length3;
    public static string Names;
    public static string Index;
    public static string Type;
    internal static string IDTree;
    public static string Lang;
    public static string ViewerPreferences;
    public static string Filter;
    public static string Prev;
    public static string Kids;
    public static string DecodeParms;
    public static string ID;
    public static string Encrypt;
    public static string Root;
    public static string Pages;
    internal static string Page;
    internal static string Tabs;
    internal static string BE;
    public static string Columns;
    public static string Rows;
    public static string BitsPerComponent;
    public static string Matte;
    public static string Parent;
    public static string Metadata;
    public static string XML;
    public static string Pg;
    public static string ParentTree;
    public static string ParentTreeNextKey;
    internal static string ClassMap;
    public static string MediaBox;
    public static string CropBox;
    public static string BleedBox;
    public static string TrimBox;
    public static string ArtBox;
    internal static string ActualText;
    public static string Resources;
    public static string ExtGState;
    public static string ColorSpace;
    public static string Pattern;
    public static string Shading;
    public static string XObject;
    public static string Group;
    internal static string StructParent;
    public static string Font;
    public static string Type1;
    public static string Type0;
    public static string DescendantFonts;
    public static string CIDFontType2;
    public static string CIDFontType0;
    public static string CIDToGIDMap;
    public static string CIDSystemInfo;
    public static string Registry;
    internal static string OCSPs;
    internal static string CRLs;
    internal static string VRI;
    internal static string DSS;
    internal static string OCSP;
    internal static string CRL;
    internal static string Certs;
    internal static string Order;
    internal static string AFRelationship;
    internal static string AF;
    internal static string Alternative;
    internal static string Source;
    internal static string Unspecified;
    internal static string SlopeType;
    internal static string NumberFormat;
    internal static string FD;
    internal static string SS;
    internal static string Measure;
    internal static string RT;
    internal static string RL;
    internal static string MeasurementTypes;
    internal static string TargetUnitConversion;
    internal static string PolyLineAngle;
    internal static string CharSet;
    internal static string FontStretch;
    public static string Ordering;
    public static string Supplement;
    public static string DW;
    public static string Identity;
    public static string IdentityH;
    public static string ToUnicode;
    public static string FirstChar;
    public static string LastChar;
    public static string Widths;
    public static string FontDescriptor;
    public static string TrueType;
    public static string BaseFont;
    public static string Encoding;
    public static string BaseEncoding;
    public static string FontName;
    public static string Flags;
    public static string FontBBox;
    public static string MissingWidth;
    public static string StemV;
    public static string StemH;
    public static string ItalicAngle;
    public static string CapHeight;
    public static string XHeight;
    public static string Ascent;
    public static string Descent;
    public static string Leading;
    public static string MaxWidth;
    public static string AvgWidth;
    public static string FontFile;
    public static string FontFile2;
    public static string FontFile3;
    public static string WinAnsiEncoding;
    internal static string CIDFontType0C;
    public static string ProcSet;
    public static string Properties;
    public static string Contents;
    public static string Form;
    public static string Subtype;
    public static string BBox;
    public static string Rotate;
    public static string Rotation;
    public static string UserUnit;
    public static string XFA;
    public static string Thumb;
    public static string PatternType;
    public static string PaintType;
    public static string TilingType;
    public static string XStep;
    public static string YStep;
    public static string Matrix;
    public static string AntiAlias;
    public static string Background;
    public static string Domain;
    public static string Range;
    public static string Function;
    public static string FunctionType;
    public static string BitsPerSample;
    public static string Extend;
    public static string Coords;
    public static string ShadingType;
    public static string PieceInfo;
    public static string Rect;
    public static string Annots;
    public static string Annot;
    public static string F;
    public static string Name;
    public static string Open;
    public static string Sound;
    internal static string Movie;
    internal static string Screen;
    internal static string PrinterMark;
    internal static string TrapNet;
    internal static string Watermark;
    public static string R;
    public static string B;
    public static string C;
    public static string CF;
    public static string CFM;
    public static string StdCF;
    public static string Popup;
    internal static string StmF;
    internal static string StrF;
    public static string NewWindow;
    public static string E;
    public static string Border;
    public static string A;
    public static string S;
    public static string URI;
    public static string FS;
    public static string EF;
    public static string Dest;
    public static string D;
    public static string AP;
    public static string APN;
    public static string RD;
    public static string RC;
    public static string Image;
    public static string Decode;
    public static string Width;
    public static string Height;
    internal static string Interpolate;
    public static string Predictor;
    public static string Colors;
    public static string EarlyChange;
    public static string Mask;
    public static string SMask;
    public static string SMaskInData;
    public static string ImageMask;
    public static string K;
    public static string BlackIs1;
    public static string EndOfBlock;
    public static string EncodedByteAlign;
    public static string DeviceRGB;
    public static string DeviceCMYK;
    public static string DeviceGray;
    public static string Indexed;
    public static string FlateDecode;
    public static string FlateDecodeShort;
    public static string LZWDecode;
    public static string LZWDecodeShort;
    public static string DCTDecode;
    public static string DCTDecodeShort;
    public static string ASCIIHexDecode;
    public static string ASCIIHexDecodeShort;
    public static string ASCII85Decode;
    public static string ASCII85DecodeShort;
    public static string Crypt;
    public static string JPXDecode;
    public static string JBIG2Decode;
    public static string JBIG2Globals;
    public static string CCITTFaxDecode;
    public static string CCITTFaxDecodeShort;
    public static string RunLengthDecode;
    public static string RunLenghtDecodeShort;
    public static string Info;
    public static string CenterWindow;
    public static string DisplayDocTitle;
    public static string FitWindow;
    public static string HideMenubar;
    public static string HideToolbar;
    public static string HideWindowUI;
    public static string PageMode;
    public static string PageLayout;
    public static string Launch;
    public static string Link;
    public static string XYZ;
    public static string Fit;
    public static string FitR;
    internal static string FitH;
    internal static string FitBH;
    internal static string FitV;
    internal static string FitB;
    internal static string FitBV;
    public static string Text;
    public static string FileAttachment;
    public static string EmbeddedFile;
    public static string Filespec;
    public static string Author;
    public static string Title;
    public static string Subject;
    internal static string Subj;
    public static string Keywords;
    public static string Creator;
    public static string Producer;
    public static string CreationDate;
    public static string ModificationDate;
    public static string Last;
    public static string Outlines;
    public static string Next;
    public static string Action;
    public static string GoTo;
    public static string GoToR;
    public static string OpenAction;
    public static string Volume;
    public static string Synchronous;
    public static string Repeat;
    public static string Mix;
    public static string Named;
    public static string JavaScript;
    public static string JS;
    public static string URL;
    public static string SubmitForm;
    public static string ResetForm;
    public static string EmbeddedFiles;
    public static string Description;
    public static string Params;
    public static string UF;
    public static string CA;
    public static string ca;
    public static string BM;
    public static string OPM;
    public static string HT;
    internal static string TR;
    public static string St;
    public static string r;
    public static string a;
    public static string P;
    public static string U;
    public static string O;
    public static string OE;
    public static string UE;
    public static string PageLabels;
    public static string Nums;
    public static string Standard;
    public static string AcroForm;
    public static string Fields;
    public static string T;
    public static string FT;
    public static string Btn;
    public static string Tx;
    public static string Ch;
    public static string Sig;
    public static string FieldFlags;
    public static string Widget;
    public static string BS;
    public static string MK;
    public static string H;
    public static string NeedAppearances;
    public static string On;
    public static string Off;
    public static string V;
    public static string BC;
    public static string BG;
    public static string DA;
    public static string DR;
    public static string AA;
    public static string TM;
    public static string TU;
    public static string MaxLen;
    public static string Yes;
    public static string Opt;
    public static string I;
    internal static string NM;
    public static string Perms;
    public static string UR3;
    public static string TransformParams;
    public static string FieldMDP;
    public static string DigestValue;
    public static string DigestLocation;
    public static string DigestMethod;
    public static string MD5;
    public static string SigRef;
    public static string Data;
    public static string Include;
    public static string Reference;
    public static string PPKMS;
    public static string DocMDP;
    public static string Location;
    public static string ContactInfo;
    public static string Reason;
    public static string M;
    public static string SubFilter;
    public static string ByteRange;
    public static string TransformMethod;
    public static string SigFlags;
    public static string WC;
    public static string WS;
    public static string DS;
    public static string WP;
    public static string DP;
    public static string Q;
    public static string X;
    public static string Fo;
    public static string Bl;
    public static string PageDuration;
    public static string Transition;
    public static string Scale;
    public static string Style;
    public static string Duration;
    public static string Dimension;
    public static string Motion;
    public static string Direction;
    public static string AS;
    public static string Dests;
    public static string Limits;
    public static string OnInstantiate;
    public static string _3D;
    public static string _3DD;
    public static string _3DA;
    public static string U3D;
    internal static string PRC;
    public static string _3DB;
    public static string _3DV;
    public static string DV;
    public static string C2W;
    public static string IN;
    public static string MS;
    public static string XN;
    public static string AN;
    public static string PROJECTION;
    public static string CLIPPINGSTYLE;
    public static string XNF;
    public static string ANF;
    public static string FOV;
    public static string PS;
    public static string OS;
    public static string OB;
    public static string VA;
    public static string _3DLightingScheme;
    public static string _3DBG;
    public static string SC;
    public static string CS;
    public static string EA;
    public static string _3DRenderMode;
    public static string AC;
    public static string FC;
    public static string CV;
    public static string _3DAnimationStyle;
    public static string PC;
    public static string PO;
    public static string PV;
    public static string XA;
    public static string AIS;
    public static string L;
    public static string PI;
    public static string XD;
    public static string DIS;
    public static string TB;
    public static string NP;
    public static string _3DCrossSection;
    public static string IV;
    public static string IC;
    public static string _3DView;
    public static string U3DPath;
    public static string CO;
    public static string RM;
    public static string LS;
    public static string SA;
    public static string NA;
    public static string NR;
    public static string _3DNode;
    public static string FormType;
    public static string Stamp;
    internal static string Caret;
    public static string Line;
    public static string LE;
    public static string LLE;
    public static string LL;
    public static string Cap;
    public static string IT;
    public static string CP;
    public static string Inline;
    public static string Top;
    public static string LineHeight;
    public static string Square;
    public static string Circle;
    public static string FreeText;
    public static string Highlight;
    public static string Underline;
    public static string StrikeOut;
    internal static string Squiggly;
    public static string Polygon;
    public static string Vertices;
    public static string PolyLine;
    public static string QuadPoints;
    public static string PrintScaling;
    public static string GTS_PDFX;
    public static string OutputConditionIdentifier;
    public static string OutputIntent;
    public static string OutputIntents;
    public static string RegistryName;
    public static string OutputCondition;
    public static string GTS_PDFXConformance;
    public static string Trapped;
    public static string GTS_PDFXVersion;
    public static string EncryptMetadata;
    public static string CalGray;
    public static string CalRGB;
    public static string Lab;
    public static string ICCBased;
    public static string WhitePoint;
    public static string BlackPoint;
    public static string Gamma;
    public static string Alternate;
    public static string Alt;
    public static string C0;
    public static string C1;
    public static string CidSet;
    public static string Differences;
    public static string Print;
    public static string XFdf;
    public static string Field;
    public static string Value;
    public static string Ids;
    public static string MarkInfo;
    public static string Marked;
    public static string OCProperties;
    public static string Ocg;
    public static string Defaultview;
    public static string OCGName;
    public static string OCGOrder;
    public static string OCGON;
    public static string OCGOFF;
    public static string OCGVisible;
    public static string OCGLayerID;
    public static string PrintState;
    public static string Usage;
    public static string Event;
    public static string Category;
    public static string OC;
    internal static string OCGLock;
    internal static string OCGViewState;
    public static string InkList;
    public static string Ink;
    public static string StructTreeRoot;
    public static string StructParents;
    internal static string CL;
    public static string Collection;
    public static string CollectionSchema;
    public static string CollectionField;
    public static string Schema;
    public static string CollectionItem;
    public static string CI;
    public static string View;
    public static string Xref;
    public static string Obj;
    public static string Catalog;
    public static string PageScaling;
    internal static string Duplex;
    internal static string Timestamp;
    internal static string RfcFilter;
    internal static string Approved;
    internal static string AsIs;
    internal static string Confidential;
    internal static string Departmental;
    internal static string Draft;
    internal static string Experimental;
    internal static string Expired;
    internal static string Final;
    internal static string ForComment;
    internal static string ForPublicRelease;
    internal static string NotApproved;
    internal static string NotForPublicRelease;
    internal static string Sold;
    internal static string TopSecret;
    internal static string Completed;
    internal static string Void;
    internal static string InformationOnly;
    internal static string PreliminaryResults;
    internal static string n0;
    internal static string n1;
    internal static string n2;
    internal static string n3;
    internal static string n4;
    internal static string FRM;
    internal static string State;
    internal static string StateModel;
    internal static string IRT;
    internal static string Accepted;
    internal static string Cancelled;
    internal static string Complete;
    internal static string Rejected;
    internal static string Unmarked;
    internal static string Review;
    internal static string None;
    internal static string Version;
    internal static string AuthEvent;
    internal static string DL;
    internal static string LLO;
    internal static string TextColor;
    internal static string OverlayText;
    internal static string Redact;
    internal static string Templates;
    internal static string XRefStm;
    internal static string Base;
    internal static string RichMedia;
    internal static string RichMediaContent;
    internal static string RichMediaSettings;
    internal static string Assets;
    internal static string Configurations;
    internal static string Instances;
    internal static string Activation;
    internal static string Deactivation;
    internal static string Condition;
    internal static string Asset;
    internal static string Presentation;
    internal static string PassContextClick;
    internal static string Transparent;
    internal static string NavigationPane;
    internal static string Toolbar;
    internal static string Styles;
    internal static string Lock;
    internal static string SigFieldLock;
    internal static string All;
    internal static string ICC2;
    internal static string Scope;
    internal static string Ja;
    internal static string GS11;
    internal static string RI;
    internal static string RelativeColor;
    internal static string Encode;
    internal static string Functions;
    internal static string OPI;
}
internal class Syncfusion.Pdf.IO.GetArchive : MulticastDelegate {
    public GetArchive(object object, IntPtr method);
    [NullableContextAttribute("1")]
public virtual PdfStream Invoke(long archiveNumber);
    public virtual IAsyncResult BeginInvoke(long archiveNumber, AsyncCallback callback, object object);
    public virtual PdfStream EndInvoke(IAsyncResult result);
}
[NullableContextAttribute("1")]
internal interface Syncfusion.Pdf.IO.IPdfWriter {
    public long Position { get; public set; }
    public long Length { get; }
    public PdfDocumentBase Document { get; public set; }
    public abstract virtual long get_Position();
    public abstract virtual void set_Position(long value);
    public abstract virtual long get_Length();
    public abstract virtual PdfDocumentBase get_Document();
    public abstract virtual void set_Document(PdfDocumentBase value);
    public abstract virtual void Write(IPdfPrimitive pdfObject);
    public abstract virtual void Write(long number);
    public abstract virtual void Write(float number);
    public abstract virtual void Write(string text);
    public abstract virtual void Write(Char[] text);
    public abstract virtual void Write(Byte[] data);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Syncfusion.Pdf.IO.ObjectInfo : object {
    private bool m_bModified;
    private IPdfPrimitive m_object;
    private PdfReference m_reference;
    internal bool Modified { get; }
    internal PdfReference Reference { get; }
    internal IPdfPrimitive Object { get; internal set; }
    internal ObjectInfo(IPdfPrimitive obj);
    internal ObjectInfo(IPdfPrimitive obj, PdfReference reference);
    internal bool get_Modified();
    internal PdfReference get_Reference();
    internal IPdfPrimitive get_Object();
    internal void set_Object(IPdfPrimitive value);
    public void SetModified();
    internal void SetReference(PdfReference reference);
    public virtual string ToString();
    public static bool op_Equality(ObjectInfo oi, object obj);
    public static bool op_Inequality(ObjectInfo oi, object obj);
    public virtual bool Equals(object obj);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Syncfusion.Pdf.IO.ObjectInformation : object {
    private ObjectType m_type;
    private ArchiveInformation m_archive;
    private PdfParser m_parser;
    private long m_offset;
    private CrossTable m_crossTable;
    public IPdfPrimitive Obj;
    public ObjectType Type { get; }
    public PdfParser Parser { get; }
    public long Offset { get; }
    public ArchiveInformation Archive { get; }
    public ObjectInformation(ObjectType type, long offset, ArchiveInformation arciveInfo, CrossTable crossTable);
    public ObjectType get_Type();
    public PdfParser get_Parser();
    public long get_Offset();
    public ArchiveInformation get_Archive();
    public static long op_Implicit(ObjectInformation oi);
}
internal enum Syncfusion.Pdf.IO.ObjectStatus : Enum {
    public int value__;
    public static ObjectStatus None;
    public static ObjectStatus Registered;
}
internal enum Syncfusion.Pdf.IO.ObjectType : Enum {
    public int value__;
    public static ObjectType Free;
    public static ObjectType Normal;
    public static ObjectType Packed;
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Syncfusion.Pdf.IO.Operators : object {
    public static string obj;
    public static string endobj;
    public static string R;
    public static string WhiteSpace;
    public static string Slash;
    public static string LessThan;
    public static string GreaterThan;
    public static string NewLine;
    public static string RegexNewLine;
    public static string stream;
    public static string endstream;
    public static string xref;
    public static string f;
    public static string n;
    public static string trailer;
    public static string startxref;
    public static string EOF;
    public static string header;
    public static string BeginText;
    public static string EndText;
    public static string BeginPath;
    public static string AppendLineSegment;
    public static string Stroke;
    public static string Fill;
    public static string Fill_EvenOdd;
    public static string FillStroke;
    public static string FillStroke_EvenOdd;
    public static string AppendBezierCurve;
    public static string AppendRectangle;
    public static string SaveState;
    public static string RestoreState;
    public static string PaintXObject;
    public static string ModifyCTM;
    public static string ModifyTM;
    public static string SetLineWidth;
    public static string SetLineCapStyle;
    public static string SetLineJoinStyle;
    public static string SetDashPattern;
    public static string SetFlatnessTolerance;
    public static string ClosePath;
    public static string CloseStrokePath;
    public static string CloseFillStrokePath;
    public static string SetCharacterSpace;
    public static string SetWordSpace;
    public static string SetHorizontalScaling;
    public static string SetTextLeading;
    public static string SetFont;
    public static string SetRenderingMode;
    public static string SetTextRise;
    public static string SetTextScaling;
    public static string SetCoords;
    public static string SetCoordsAndLeading;
    public static string GoToNextLine;
    public static string SetText;
    public static string SetTextWithFormatting;
    public static string SetTextOnNewLine;
    public static string SetTextOnNewLineWithSpacings;
    public static string SelectColorSpaceForStroking;
    public static string SelectColorSpaceForNonStroking;
    public static string SetRGBColorForStroking;
    public static string SetRGBColorForNonStroking;
    public static string SetCMYKColorForStroking;
    public static string SetCMYKColorForNonstroking;
    public static string SetGrayColorForStroking;
    public static string SetGrayColorForNonstroking;
    public static string Pattern;
    public static string SetColorAndPattern;
    public static string SetColorAndPatternStroking;
    public static string ClipPath;
    public static string ClipPath_EvenOdd;
    public static string EndPath;
    public static string SetGraphicsState;
    public static string Comment;
    public static string AnyRegexSymbol;
    public static string BeginMarkedSequence;
    public static string EndMarkedSequence;
    public static string EvenOdd;
    public static string AppendBezierCurve2;
    public static string AppendBezierCurve1;
    public static string SetMiterLimit;
    public static string SetColorRenderingIntent;
    public static string SetColorStroking;
    public static string SetColorNonStroking;
    public static string Para;
    public static string Mcid;
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Syncfusion.Pdf.IO.Pair : ValueType {
    public static Pair Empty;
    public PdfName Name;
    public IPdfPrimitive Value;
    public Pair(PdfName name, IPdfPrimitive value);
    private static Pair();
    public static bool op_Equality(Pair pair, object obj);
    public static bool op_Inequality(Pair pair, object obj);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Syncfusion.Pdf.IO.PdfArchiveStream : PdfStream {
    private SortedListEx m_indices;
    private MemoryStream m_objects;
    private StreamWriter m_writer;
    private IPdfWriter m_objectWriter;
    private PdfDocumentBase m_document;
    internal int ObjCount { get; }
    internal PdfArchiveStream(PdfDocumentBase document);
    internal int get_ObjCount();
    public void SaveObject(IPdfPrimitive obj, PdfReference reference);
    public int GetIndex(long objNum);
    public virtual void Save(IPdfWriter writer);
    internal void Clear();
    private void SaveObjects();
    private void SaveIndices();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Syncfusion.Pdf.IO.PdfCrossTable : object {
    private CrossTable m_crossTable;
    private PdfDictionary m_documentCatalog;
    private Stream m_stream;
    private Dictionary`2<long, RegisteredObject> m_objects;
    private int m_count;
    private bool m_bDisposed;
    private IPdfPrimitive m_trailer;
    private PdfDocumentBase m_document;
    private bool m_bForceNew;
    private Stack`1<PdfReference> m_objNumbers;
    private long m_maxGenNumIndex;
    private PdfArchiveStream m_archive;
    private Dictionary`2<PdfReference, PdfReference> m_mappedReferences;
    private int m_storedCount;
    private List`1<ArchiveInfo> m_archives;
    private PdfDictionary m_encryptorDictionary;
    private PdfMainObjectCollection m_items;
    private bool m_bEncrypt;
    private Dictionary`2<IPdfPrimitive, object> m_pageCorrespondance;
    private List`1<PdfReference> m_preReference;
    private bool m_isMerging;
    private bool m_isColorSpace;
    private bool m_isOutlineOrDest;
    internal bool isOpenAndRepair;
    internal bool isRepair;
    private bool isIndexGreaterthanTotalObjectCount;
    internal bool isCompletely;
    internal bool isDisposed;
    internal PdfLoadedDocument loadedPdfDocument;
    internal PdfDictionary m_pdfDocumentEncoding;
    internal bool m_closeCompletely;
    internal List`1<long> m_pdfObjects;
    private bool m_isPDFAppend;
    private bool m_isTagged;
    private Dictionary`2<long, long> m_preReferenceTable;
    internal bool isTemplateMerging;
    internal bool Encrypted { get; internal set; }
    internal bool IsTagged { get; internal set; }
    public PdfDictionary DocumentCatalog { get; }
    internal Stream Stream { get; }
    internal int NextObjNumber { get; }
    internal CrossTable CrossTable { get; }
    internal int Count { get; internal set; }
    internal PdfDocumentBase Document { get; internal set; }
    internal PdfMainObjectCollection PdfObjects { get; }
    internal PdfDictionary Trailer { get; }
    internal bool IsMerging { get; internal set; }
    internal PdfEncryptor Encryptor { get; internal set; }
    private PdfMainObjectCollection ObjectCollection { get; }
    internal PdfDictionary EncryptorDictionary { get; }
    internal Dictionary`2<IPdfPrimitive, object> PageCorrespondance { get; internal set; }
    internal List`1<PdfReference> PrevReference { get; internal set; }
    internal Dictionary`2<long, long> PrevCloneReference { get; internal set; }
    internal bool StructureAltered { get; }
    internal bool IsPDFAppend { get; internal set; }
    public PdfCrossTable(Stream docStream);
    public PdfCrossTable(Stream docStream, bool openAndRepair);
    internal PdfCrossTable(Stream docStream, bool openAndRepair, bool repair);
    internal PdfCrossTable(int count, PdfDictionary encryptionDictionary, PdfDictionary documentCatalog);
    internal PdfCrossTable(int count, PdfDictionary encryptionDictionary, PdfDictionary documentCatalog, CrossTable cTable);
    internal PdfCrossTable(bool isFdf, Stream docStream);
    internal PdfCrossTable(Stream docStream, PdfLoadedDocument ldoc);
    internal bool get_Encrypted();
    internal void set_Encrypted(bool value);
    internal bool get_IsTagged();
    internal void set_IsTagged(bool value);
    public PdfDictionary get_DocumentCatalog();
    internal Stream get_Stream();
    internal int get_NextObjNumber();
    internal CrossTable get_CrossTable();
    internal int get_Count();
    internal void set_Count(int value);
    internal PdfDocumentBase get_Document();
    internal void set_Document(PdfDocumentBase value);
    internal PdfMainObjectCollection get_PdfObjects();
    internal PdfDictionary get_Trailer();
    internal bool get_IsMerging();
    internal void set_IsMerging(bool value);
    internal PdfEncryptor get_Encryptor();
    internal void set_Encryptor(PdfEncryptor value);
    private PdfMainObjectCollection get_ObjectCollection();
    internal PdfDictionary get_EncryptorDictionary();
    internal Dictionary`2<IPdfPrimitive, object> get_PageCorrespondance();
    internal void set_PageCorrespondance(Dictionary`2<IPdfPrimitive, object> value);
    internal List`1<PdfReference> get_PrevReference();
    internal void set_PrevReference(List`1<PdfReference> value);
    internal Dictionary`2<long, long> get_PrevCloneReference();
    internal void set_PrevCloneReference(Dictionary`2<long, long> value);
    internal bool get_StructureAltered();
    internal bool get_IsPDFAppend();
    internal void set_IsPDFAppend(bool value);
    protected virtual override void Finalize();
    public static IPdfPrimitive Dereference(IPdfPrimitive obj);
    public IPdfPrimitive GetObject(IPdfPrimitive pointer);
    private void Decrypt(IPdfDecryptable obj);
    private void Decrypt(IPdfPrimitive obj);
    private bool CheckForOutlinesAndDestination(PdfDictionary dictionary);
    public Byte[] GetStream(IPdfPrimitive streamRef);
    public void RegisterObject(long offset, PdfReference reference);
    public void RegisterObject(PdfArchiveStream archive, PdfReference reference);
    public void RegisterObject(long offset, PdfReference reference, bool free);
    public void Save(PdfWriter writer);
    internal PdfReference GetReference(IPdfPrimitive obj);
    internal PdfReference GetReference(IPdfPrimitive obj, Boolean& bNew);
    internal void ForceNew();
    private void ObjectDecyptionProcess(IPdfPrimitive result);
    private void DecryptionPrimitives(IPdfDecryptable encryptedObj, IPdfPrimitive result);
    private void MarkTrailerReferences();
    private IPdfPrimitive PageProceed(IPdfPrimitive obj);
    private PdfStream PrepareXRefStream(long prevXRef, long position, PdfReference& reference);
    private int GetSize(ulong number);
    private void SaveSubsection(BinaryWriter xRefStream, long objectNum, long count, Int32[] format);
    private void SaveLong(BinaryWriter xRefStream, long number, int count);
    private void SetSecurity();
    private PdfArray GetFileID();
    private void SaveObjects(PdfWriter writer);
    private void SavePrimitive(IPdfPrimitive obj, PdfWriter writer);
    private void StructureRootElements(PdfStructTreeRoot treeRoot);
    private void SaveArchives(PdfWriter writer);
    private PdfReference GetMappedReference(PdfReference reference);
    private PdfReference FindArchiveReference(PdfArchiveStream archive);
    internal void SaveIndirectObject(IPdfPrimitive obj, PdfWriter writer);
    private void DoArchiveObject(IPdfPrimitive obj, PdfReference reference, PdfWriter writer);
    private void SaveArchive(PdfWriter writer);
    private void DoSaveObject(IPdfPrimitive obj, PdfReference reference, PdfWriter writer);
    private PdfDictionary GeneratePagesRoot();
    private void SaveSections(PdfWriter writer);
    private long PrepareSubsection(Int64& objectNum);
    private void SaveSubsection(PdfWriter writer, long objectNum, long count);
    internal static string GetItem(long offset, long genNumber, bool isFree);
    private void SaveTrailer(PdfWriter writer, long count, long prevXRef);
    private void ForceIDHex(PdfDictionary trailer);
    private void SaveTheEndess(PdfWriter writer, long xrefPos);
    private void SaveHead(PdfWriter writer);
    private bool IsEndWithNewLine(PdfWriter writer);
    private string GenerateFileVersion(PdfDocumentBase document);
    private bool IsCrossReferenceStream(PdfDocumentBase document);
    public sealed virtual void Dispose();
    internal void Close(bool completely);
    public void Dispose(bool completely);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Syncfusion.Pdf.IO.PdfLexer : object {
    private static int YY_BUFFER_SIZE;
    private static int YY_F;
    private static int YY_NO_STATE;
    private static int YY_NOT_ACCEPT;
    private static int YY_START;
    private static int YY_END;
    private static int YY_NO_ANCHOR;
    private static int YY_BOL;
    private static int YY_EOF;
    private static string Prefix;
    private StringBuilder m_string;
    private int m_paren;
    private bool m_bSkip;
    internal bool isArray;
    internal string objectName;
    internal bool m_checkEof;
    private TextReader m_yyReader;
    private int m_yyBufferIndex;
    private int m_yyBufferRead;
    private int m_yyBufferStart;
    private int m_yyBufferEnd;
    private Char[] m_yyBuffer;
    private int m_yyLine;
    private bool TType;
    private bool m_yyAtBol;
    private State m_yyLexicalState;
    internal bool fdfImport;
    private static Int32[] m_yyStateDtrans;
    private bool m_yyLastWasCr;
    private String[] m_yyErrorString;
    private Int32[] m_yyAccept;
    private Int32[] m_yyCmap;
    private Int32[] m_yyRmap;
    private Int32[][] m_yyNext;
    internal string Text { get; }
    internal int Line { get; }
    internal StringBuilder StringText { get; }
    internal long Position { get; }
    internal bool Skip { get; internal set; }
    internal PdfLexer(TextReader reader);
    internal PdfLexer(Stream inStream);
    private static PdfLexer();
    internal string get_Text();
    internal int get_Line();
    internal StringBuilder get_StringText();
    internal long get_Position();
    internal bool get_Skip();
    internal void set_Skip(bool value);
    internal void Reset();
    internal Byte[] Read(int count);
    internal void SkipNewLine();
    internal void SkipToken();
    internal void MoveBack();
    public TokenType GetNextToken();
    private void YyBegin(State state);
    private int YyAdvance();
    private int YyRead();
    private void YyMoveEnd();
    private void YyMarkStart();
    private void YyMarkEnd();
    private void YyToMark();
    private string YyText();
    private int YyLength();
    private Char[] YyDouble(Char[] buffer);
    private void YyError(YYError code, bool fatal);
    private static Int32[][] UnpackFromString(int size1, int size2, string st);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[DefaultMemberAttribute("Item")]
internal class Syncfusion.Pdf.IO.PdfMainObjectCollection : object {
    private List`1<ObjectInfo> m_objectCollection;
    internal Dictionary`2<long, ObjectInfo> mainObjectCollection;
    private Dictionary`2<IPdfPrimitive, long> m_primitiveObjectCollection;
    private HashSet`1<IPdfPrimitive> m_primitiveObjects;
    private int m_index;
    internal int m_maximumReferenceObjNumber;
    protected static object s_syncObject;
    internal ObjectInfo Item { get; }
    internal int Count { get; }
    private static PdfMainObjectCollection();
    internal ObjectInfo get_Item(int index);
    internal int get_Count();
    internal void Add(IPdfPrimitive element);
    internal void Add(IPdfPrimitive obj, PdfReference reference);
    internal void Remove(int index);
    internal bool Contains(IPdfPrimitive element);
    internal bool ContainsReference(PdfReference reference);
    internal PdfReference GetReference(int index);
    internal PdfReference GetReference(IPdfPrimitive obj, Boolean& isNew);
    internal IPdfPrimitive GetObject(int index);
    internal IPdfPrimitive GetObject(PdfReference reference);
    internal int GetObjectIndex(PdfReference reference);
    internal bool TrySetReference(IPdfPrimitive obj, PdfReference reference, Boolean& found);
    internal int IndexOf(IPdfPrimitive element);
    internal void ReregisterReference(int oldObjIndex, IPdfPrimitive newObj);
    internal void ReregisterReference(IPdfPrimitive oldObj, IPdfPrimitive newObj);
    private int LookFor(IPdfPrimitive obj);
    private int GetObjectIndex(IPdfPrimitive obj);
    private int LookForReference(PdfReference reference);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Syncfusion.Pdf.IO.PdfMatrix : object {
    private PdfReader m_contentStream;
    private string m_key;
    private float m_width;
    private float m_height;
    private float m_x;
    private float m_y;
    private Single[] m_translationMatrix;
    private Single[] m_scaleMatrix;
    private SizeF m_pageSize;
    internal List`1<string> m_token;
    private string m_marginToken;
    private string m_rectToken;
    private string m_prevRectToken;
    private float m_leftMargin;
    private float m_topMargin;
    internal RectangleF m_scaledBounds;
    public float GetScaleX { get; }
    public float GetScaleY { get; }
    public float GetHeight { get; }
    public float GetWidth { get; }
    public float LeftMargin { get; }
    public float TopMargin { get; }
    public PdfMatrix(PdfReader ContentStream, string key, SizeF pageSize);
    public float get_GetScaleX();
    public float get_GetScaleY();
    public float get_GetHeight();
    public float get_GetWidth();
    public float get_LeftMargin();
    public float get_TopMargin();
    private List`1<string> MatrixCalculation();
    private void SetScaleMatrix(SizeF pageSize);
    private void SetTranslationMatrix();
    private void ConvertToArray(List`1<string> matrixString);
}
internal class Syncfusion.Pdf.IO.PdfMessages : object {
    [NullableAttribute("1")]
public static string InvalidFormat;
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Syncfusion.Pdf.IO.PdfParser : object {
    private CrossTable m_cTable;
    private PdfReader m_reader;
    private PdfLexer m_lexer;
    private TokenType m_next;
    private Queue`1<int> m_integerQueue;
    private PdfCrossTable m_crossTable;
    private bool m_bEncrypt;
    private bool m_colorSpace;
    private bool m_isPassword;
    private bool m_certString;
    private bool m_forceRebuild;
    private bool m_isRGB;
    internal bool fdfImport;
    internal bool Encrypted { get; internal set; }
    internal PdfLexer Lexer { get; }
    internal bool ForceRebuild { get; internal set; }
    internal long Position { get; }
    public PdfParser(CrossTable cTable, PdfReader reader, PdfCrossTable crossTable);
    private PdfParser(Byte[] data);
    internal bool get_Encrypted();
    internal void set_Encrypted(bool value);
    internal PdfLexer get_Lexer();
    internal bool get_ForceRebuild();
    internal void set_ForceRebuild(bool value);
    internal long get_Position();
    public IPdfPrimitive Parse(long offset);
    internal void SeekOffset(long offset);
    public IPdfPrimitive Parse();
    public IPdfPrimitive Trailer(long offset);
    public IPdfPrimitive Trailer();
    public long StartXRef();
    public void SetOffset(long offset);
    public IPdfPrimitive ParseXRefTable(Dictionary`2<long, ObjectInformation> objects, CrossTable cTable);
    public void RebuildXrefTable(Dictionary`2<long, ObjectInformation> newObjects, CrossTable crosstable);
    private Int64[] CheckObjectStart(Byte[] line, long pos);
    internal Dictionary`2<long, ObjectInformation> FindFirstObject(Dictionary`2<long, ObjectInformation> newObjects, CrossTable crosstable);
    internal IPdfPrimitive Simple();
    internal char GetObjectFlag();
    internal void StartFrom(long offset);
    internal FdfObject ParseObject();
    private void ParseOldXRef(CrossTable cTable, Dictionary`2<long, ObjectInformation> objects);
    private bool IsSubsection();
    private void Error(ErrorType error, string additional);
    private void Match(TokenType token, TokenType match);
    internal void Advance();
    internal TokenType GetNext();
    private IPdfPrimitive ReadName();
    private IPdfPrimitive ReadBoolean();
    private IPdfPrimitive ReadUnicodeString();
    private string ProcessUnicodeEscapes(string text);
    private IPdfPrimitive ReadString();
    private bool CheckForPreamble(string text);
    private bool CheckEscapeSequence(string text);
    private bool CheckForExtraSequence(string text);
    private bool CheckUnicodePeramble(string text);
    private string ProcessEscapes(string text, bool isComplete);
    private char ProcessOctal(string text, Int32& i);
    private string ProcessEncryptEscapes(string text);
    private char ProcessEncryptOctal(string text, Int32& i);
    private IPdfPrimitive HexString();
    private IPdfPrimitive Number();
    private PdfNumber ParseInteger();
    private IPdfPrimitive Real();
    private IPdfPrimitive Array();
    internal IPdfPrimitive Dictionary();
    private IPdfPrimitive ReadStream(PdfDictionary dic);
    private bool CheckStreamLength(long lexPosition, int value);
    private Pair ReadPair();
    private void ProcessUnicodeWithPreamble(String& text);
    private bool CheckForControlSequence(string text);
    private void DecodeEscapeProcess(String& text, Boolean& unicode);
    private bool CheckEndByteOrderMark(string text);
    private void ProcessUnicodeWithPreamble(String& text, Boolean& unicode);
    private string ProcessBigIndianEscapes(string text);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Syncfusion.Pdf.IO.PdfReader : TextReader {
    private Stream m_stream;
    private string m_delimiters;
    private string m_jsonDelimiters;
    private int m_peekedByte;
    private bool m_bBytePeeked;
    internal bool m_importFormData;
    internal PdfCrossTable crossTable;
    public long Position { get; public set; }
    public Stream Stream { get; }
    public PdfReader(Stream stream);
    public long get_Position();
    public void set_Position(long value);
    public Stream get_Stream();
    protected virtual void Dispose(bool disposing);
    public virtual string ReadLine();
    internal void ReadLine(Byte[] data, bool skipWhiteSpace);
    internal string ReadContent();
    private bool IsWhitespaceCharcater(int character, bool isWhitespace);
    public virtual int Read();
    public virtual int Peek();
    public virtual int Read(Char[] buffer, int index, int count);
    public virtual int ReadBlock(Char[] buffer, int index, int count);
    public virtual string ReadToEnd();
    internal string ReadStream();
    public bool IsEol(char character);
    public bool IsSeparator(char character);
    internal bool IsJsonSeparator(char character);
    public bool IsDelimiter(char character);
    internal bool IsJsonDelimiter(char character);
    public long SearchBack(string token);
    public long SearchForward(string token);
    public string ReadBack(int length);
    public void SkipWSBack();
    public void SkipWS();
    public string GetNextToken();
    internal string GetNextJsonToken();
    public long Seek(long offset, SeekOrigin origin);
    private int AppendChar(String& line);
    private bool GetPeeked(Int32& byteValue);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Syncfusion.Pdf.IO.PdfStreamWriter : object {
    private PdfStream m_stream;
    public long Position { get; public set; }
    public long Length { get; }
    public PdfDocumentBase Document { get; public set; }
    public PdfStreamWriter(PdfStream stream);
    public void ModifyTM(PdfTransformationMatrix matrix);
    public void SetFont(PdfFont font, string name, float size);
    public void SetFont(PdfFont font, PdfName name, float size);
    public void SetColorSpace(PdfColorSpaces colorspace, PdfName name);
    public void SetCharacterSpacing(float charSpacing);
    public void SetWordSpacing(float wordSpacing);
    public void SetHorizontalScaling(float scalingFactor);
    public void SetLeading(float leading);
    public void SetTextRenderingMode(TextRenderingMode renderingMode);
    public void SetTextRise(float rise);
    internal void SetTextScaling(float textScaling);
    public void StartNextLine();
    public void StartNextLine(PointF point);
    public void StartNextLine(float x, float y);
    public void StartLineAndSetLeading(PointF point);
    public void StartLineAndSetLeading(float x, float y);
    public void ShowText(Byte[] text, bool hex);
    public void ShowText(string text, bool hex);
    public void ShowText(PdfString text);
    public void ShowText(PdfArray formattedText);
    internal void ShowFormatedText(string text);
    public void ShowNextLineText(Byte[] text, bool hex);
    public void ShowNextLineText(string text, bool hex);
    public void ShowNextLineText(PdfString text);
    public void ShowNextLineTextWithSpacings(float wordSpacing, float charSpacing, Byte[] text, bool hex);
    public void ShowNextLineTextWithSpacings(float wordSpacing, float charSpacing, string text, bool hex);
    public void ShowNextLineTextWithSpacings(float wordSpacing, float charSpacing, PdfString text);
    public void ShowText(IList formatting);
    public void BeginText();
    internal void WriteTag(string tag);
    public void EndText();
    public void BeginMarkupSequence(string name);
    public void BeginMarkupSequence(PdfName name);
    public void EndMarkupSequence();
    public void WriteComment(string comment);
    public void BeginPath(PointF startPoint);
    public void BeginPath(float x, float y);
    public void AppendBezierSegment(PointF p1, PointF p2, PointF p3);
    public void AppendBezierSegment(float x1, float y1, float x2, float y2, float x3, float y3);
    public void AppendBezierSegment(PointF p2, PointF p3, bool useFirstPoint);
    public void AppendBezierSegment(float x2, float y2, float x3, float y3, bool useFirstPoint);
    public void AppendLineSegment(PointF point);
    public void AppendLineSegment(float x, float y);
    public void AppendRectangle(RectangleF rect);
    public void AppendRectangle(float x, float y, float width, float height);
    public void ClosePath();
    public void CloseSubPath();
    public void FillPath(bool useEvenOddRule);
    public void StrokePath();
    public void FillStrokePath(bool useEvenOddRule);
    public void CloseStrokePath();
    public void CloseFillStrokePath(bool useEvenOddRule);
    public void CloseFillPath(bool useEvenOddRule);
    public void ClipPath(bool useEvenOddRule);
    public void EndPath();
    public void SaveGraphicsState();
    public void RestoreGraphicsState();
    public void ModifyCTM(PdfTransformationMatrix matrix);
    public void SetLineWidth(float width);
    public void SetLineCap(PdfLineCap lineCapStyle);
    public void SetLineJoin(PdfLineJoin lineJoinStyle);
    public void SetMiterLimit(float miterLimit);
    public void SetLineDashPattern(Single[] pattern, float patternOffset);
    private void SetLineDashPattern(PdfArray pattern, PdfNumber patternOffset);
    public void SetColorRenderingIntent(ColorIntent intent);
    public void SetFlatnessTolerance(int tolerance);
    public void SetGraphicsState(PdfName dictionaryName);
    public void SetGraphicsState(string dictionaryName);
    public void SetColorSpace(string name, bool forStroking);
    public void SetColorSpace(PdfName name, bool forStroking);
    public void SetColorAndSpace(PdfColor color, PdfColorSpace colorSpace, bool forStroking);
    public void SetColorAndSpace(PdfColor color, PdfColorSpace colorSpace, bool forStroking, bool check);
    public void SetColorAndSpace(PdfColor color, PdfColorSpace colorSpace, bool forStroking, bool check, bool iccbased);
    public void SetColorAndSpace(PdfColor color, PdfColorSpace colorSpace, bool forStroking, bool check, bool iccbased, bool indexed);
    public void SetColor(PdfColor color, PdfColorSpace currentSpace, bool forStroking);
    public void SetColourWithPattern(IList colours, PdfName patternName, bool forStroking);
    public void ExecuteObject(string name);
    public void ExecuteObject(PdfName name);
    internal PdfStream GetStream();
    internal void Clear();
    private void WritePoint(PointF point);
    private void WritePoint(float x, float y);
    private void WriteText(object text);
    private void WriteText(Byte[] text, bool hex);
    private void WriteText(string text, bool hex);
    private void WriteText(PdfString text);
    private void WriteOperator(string opcode);
    private void CheckTextParam(Byte[] text);
    private void CheckTextParam(string text);
    private void CheckTextParam(PdfString text);
    public sealed virtual long get_Position();
    public sealed virtual void set_Position(long value);
    public sealed virtual long get_Length();
    public sealed virtual PdfDocumentBase get_Document();
    public sealed virtual void set_Document(PdfDocumentBase value);
    public sealed virtual void Write(IPdfPrimitive pdfObject);
    public sealed virtual void Write(long number);
    public sealed virtual void Write(float number);
    public sealed virtual void Write(string text);
    public sealed virtual void Write(Char[] text);
    public sealed virtual void Write(Byte[] data);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Syncfusion.Pdf.IO.PdfStructTreeRoot : PdfDictionary {
    private PdfArray m_childSTR;
    private PdfPageBase m_pdfPage;
    [ThreadStaticAttribute]
private static int m_id;
    private RectangleF m_BBoxBounds;
    private PdfArray m_nodeTree;
    private static object s_syncObject;
    [ThreadStaticAttribute]
private static int m_pageStructId;
    private PdfArray m_structTreeChild;
    private List`1<int> m_orderList;
    private Dictionary`2<string, IPdfPrimitive> m_ParentTagCollection;
    private PdfDictionary m_currentTreeRootChild;
    private List`1<PdfDictionary> m_structParentHierarchy;
    private PdfArray m_treeRootNode;
    private Dictionary`2<string, IPdfPrimitive> m_structChildCollection;
    private List`1<string> m_structElementTags;
    private PdfArray m_treeRootChilds;
    private PdfDictionary m_currentParent;
    internal bool isNewRow;
    internal bool m_SplitTable;
    private PdfDictionary m_structElementParent;
    internal bool isNewTable;
    private bool m_isNewListItem;
    private bool m_isNewList;
    internal bool m_isSubList;
    private PdfDictionary m_subListData;
    private PdfArray m_subListCollection;
    private bool m_isOrderAdded;
    internal bool m_isNestedGridRendered;
    private PdfArray m_prevRootNode;
    internal bool m_isChildGrid;
    private int m_orderIndex;
    private bool m_hasOrder;
    private PdfArray m_prevStructParent;
    internal bool m_isImage;
    private bool m_autoTag;
    internal bool m_WordtoPDFTaggedObject;
    private List`1<PdfStructureElement> structureElementsCollection;
    private PdfStructureElement m_currentStructureElement;
    private PdfDictionary m_currentElementDictionay;
    internal List`1<int> OrderList { get; internal set; }
    internal PdfArray TreeRootNode { get; internal set; }
    internal bool IsNewList { get; internal set; }
    internal bool IsNewListItem { get; internal set; }
    internal bool HasOrder { get; internal set; }
    private static PdfStructTreeRoot();
    internal List`1<int> get_OrderList();
    internal void set_OrderList(List`1<int> value);
    internal PdfArray get_TreeRootNode();
    internal void set_TreeRootNode(PdfArray value);
    internal bool get_IsNewList();
    internal void set_IsNewList(bool value);
    internal bool get_IsNewListItem();
    internal void set_IsNewListItem(bool value);
    internal bool get_HasOrder();
    internal void set_HasOrder(bool value);
    internal int Add(string structType, string altText, PdfPageBase page, RectangleF bounds);
    internal int Add(string structType, string altText, RectangleF bounds);
    internal void Add(PdfStructureElement structElement, PdfPageBase page, PdfDictionary annotDictionary);
    internal int Add(PdfStructureElement structElement, PdfPageBase page, RectangleF bounds);
    private void GroupMapping(PdfDictionary pdfStructElement);
    private void MappingGroupKids(PdfDictionary currentElement, PdfDictionary pdfStructElement);
    private bool IncludeIdenticalParent(PdfDictionary currentElement);
    private bool IncludeParentForGroupElements(List`1<PdfStructureElement> elements);
    private bool AddEntriesForStructElement(List`1<PdfStructureElement> elements);
    private bool CheckTableChild(List`1<PdfStructureElement> elements);
    private bool IncludeParentForStructElement(PdfStructureElement structElement, List`1<PdfStructureElement> elements, Boolean& hasStructElement);
    private bool CheckSubList(List`1<PdfStructureElement> elements);
    private void SetSubEntries(List`1<PdfStructureElement> structElements, PdfDictionary currentParent);
    private string AddTags(List`1<PdfStructureElement> elements);
    private bool IsIdenticalStructureElement(string tag);
    private void SetParentForStructHierarchy(List`1<PdfStructureElement> structElements, PdfDictionary structElementParent, int index);
    private void SetTreeRootNodes(List`1<PdfDictionary> treeRootItems);
    private void SetChildForStructElement(List`1<PdfDictionary> treeRootItems, PdfArray m_childs);
    internal void Dispose();
    private List`1<PdfStructureElement> FindRootParent(PdfStructureElement structElement);
    private void AddOrderFromStructure(PdfStructureElement structElement);
    internal string ConvertToEquivalentTag(PdfTagType tag);
    internal void ReOrderList(int maxLimit, List`1<int> orderList);
    private int FindLowest(List`1<int> orderList, int maxLimit);
    internal void ReArrange(PdfArray childElements, List`1<int> orderList);
    private List`1<int> ArrangeChildWithOrder(int elementCount);
    internal void GetChildElements(PdfArray treeRootChild);
}
internal enum Syncfusion.Pdf.IO.PDFType : Enum {
    public int value__;
    public static PDFType Unknown;
    public static PDFType String;
    public static PDFType Array;
    public static PDFType Name;
    public static PDFType Boolean;
    public static PDFType Integer;
    public static PDFType Real;
    public static PDFType Reference;
    public static PDFType Dictionary;
    public static PDFType Stream;
    public static PDFType Comment;
    public static PDFType Null;
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Syncfusion.Pdf.IO.PdfWriter : object {
    internal Stream m_stream;
    private PdfDocumentBase m_document;
    private bool m_cannotSeek;
    private long m_position;
    private long m_length;
    internal bool isCompress;
    private Stream Stream { get; }
    public PdfDocumentBase Document { get; public set; }
    public long Position { get; public set; }
    public long Length { get; }
    internal PdfWriter(Stream stream);
    private Stream get_Stream();
    public sealed virtual void Dispose();
    internal void Close();
    public sealed virtual PdfDocumentBase get_Document();
    public sealed virtual void set_Document(PdfDocumentBase value);
    public sealed virtual long get_Position();
    public sealed virtual void set_Position(long value);
    public sealed virtual long get_Length();
    public sealed virtual void Write(IPdfPrimitive pdfObject);
    public sealed virtual void Write(long number);
    public sealed virtual void Write(float number);
    public sealed virtual void Write(string text);
    public sealed virtual void Write(Char[] text);
    public sealed virtual void Write(Byte[] data);
    internal void Write(Byte[] data, int end);
    internal Stream ObtainStream();
}
internal enum Syncfusion.Pdf.IO.TokenType : Enum {
    public int value__;
    public static TokenType Unknown;
    public static TokenType DictionaryStart;
    public static TokenType DictionaryEnd;
    public static TokenType StreamStart;
    public static TokenType StreamEnd;
    public static TokenType HexStringStart;
    public static TokenType HexStringEnd;
    public static TokenType String;
    public static TokenType UnicodeString;
    public static TokenType Number;
    public static TokenType Real;
    public static TokenType Name;
    public static TokenType ArrayStart;
    public static TokenType ArrayEnd;
    public static TokenType Reference;
    public static TokenType ObjectStart;
    public static TokenType ObjectEnd;
    public static TokenType Boolean;
    public static TokenType HexDigit;
    public static TokenType Eof;
    public static TokenType Trailer;
    public static TokenType StartXRef;
    public static TokenType XRef;
    public static TokenType Null;
    public static TokenType ObjectType;
    public static TokenType HexStringWeird;
    public static TokenType HexStringWeirdEscape;
    public static TokenType WhiteSpace;
}
[NullableContextAttribute("1")]
internal interface Syncfusion.Pdf.IPdfCache {
    public abstract virtual bool EqualsTo(IPdfCache obj);
    public abstract virtual IPdfPrimitive GetInternals();
    public abstract virtual void SetInternals(IPdfPrimitive internals);
}
[NullableContextAttribute("1")]
internal interface Syncfusion.Pdf.IPdfChangable {
    public bool Changed { get; }
    public abstract virtual bool get_Changed();
    public abstract virtual void FreezeChanges(object freezer);
}
[NullableContextAttribute("1")]
internal interface Syncfusion.Pdf.IPdfWrapper {
    public IPdfPrimitive Element { get; }
    public abstract virtual IPdfPrimitive get_Element();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class Syncfusion.Pdf.Lists.BeginItemLayoutEventArgs : object {
    private PdfListItem m_item;
    private PdfPage m_page;
    public PdfListItem Item { get; }
    public PdfPage Page { get; }
    internal BeginItemLayoutEventArgs(PdfListItem item, PdfPage page);
    public PdfListItem get_Item();
    public PdfPage get_Page();
}
public class Syncfusion.Pdf.Lists.BeginItemLayoutEventHandler : MulticastDelegate {
    public BeginItemLayoutEventHandler(object object, IntPtr method);
    [NullableContextAttribute("1")]
public virtual void Invoke(object sender, BeginItemLayoutEventArgs args);
    public virtual IAsyncResult BeginInvoke(object sender, BeginItemLayoutEventArgs args, AsyncCallback callback, object object);
    public virtual void EndInvoke(IAsyncResult result);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class Syncfusion.Pdf.Lists.EndItemLayoutEventArgs : object {
    private PdfListItem m_item;
    private PdfPage m_page;
    public PdfListItem Item { get; }
    public PdfPage Page { get; }
    internal EndItemLayoutEventArgs(PdfListItem item, PdfPage page);
    public PdfListItem get_Item();
    public PdfPage get_Page();
}
public class Syncfusion.Pdf.Lists.EndItemLayoutEventHandler : MulticastDelegate {
    public EndItemLayoutEventHandler(object object, IntPtr method);
    [NullableContextAttribute("1")]
public virtual void Invoke(object sender, EndItemLayoutEventArgs args);
    public virtual IAsyncResult BeginInvoke(object sender, EndItemLayoutEventArgs args, AsyncCallback callback, object object);
    public virtual void EndInvoke(IAsyncResult result);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class Syncfusion.Pdf.Lists.ListBeginPageLayoutEventArgs : BeginPageLayoutEventArgs {
    private PdfList m_list;
    public PdfList List { get; }
    internal ListBeginPageLayoutEventArgs(RectangleF bounds, PdfPage page, PdfList list);
    public PdfList get_List();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class Syncfusion.Pdf.Lists.ListEndPageLayoutEventArgs : EndPageLayoutEventArgs {
    private PdfList m_list;
    public PdfList List { get; }
    internal ListEndPageLayoutEventArgs(PdfLayoutResult layoutResult, PdfList list);
    public PdfList get_List();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Syncfusion.Pdf.Lists.ListInfo : object {
    private int m_index;
    private PdfList m_list;
    private string m_number;
    private PdfBrush m_brush;
    private PdfPen m_pen;
    private PdfFont m_font;
    private PdfStringFormat m_format;
    internal float MarkerWidth;
    internal int Index { get; internal set; }
    internal PdfList List { get; internal set; }
    internal string Number { get; internal set; }
    internal PdfBrush Brush { get; internal set; }
    internal PdfPen Pen { get; internal set; }
    internal PdfFont Font { get; internal set; }
    internal PdfStringFormat Format { get; internal set; }
    internal ListInfo(PdfList list, int index, string number);
    internal ListInfo(PdfList list, int index);
    internal int get_Index();
    internal void set_Index(int value);
    internal PdfList get_List();
    internal void set_List(PdfList value);
    internal string get_Number();
    internal void set_Number(string value);
    internal PdfBrush get_Brush();
    internal void set_Brush(PdfBrush value);
    internal PdfPen get_Pen();
    internal void set_Pen(PdfPen value);
    internal PdfFont get_Font();
    internal void set_Font(PdfFont value);
    internal PdfStringFormat get_Format();
    internal void set_Format(PdfStringFormat value);
}
internal class Syncfusion.Pdf.Lists.NamespaceDoc : object {
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Syncfusion.Pdf.Lists.PageLayoutResult : object {
    public bool Broken;
    public float Y;
    public string ItemText;
    public string MarkerText;
    public bool MarkerWrote;
    public float MarkerWidth;
    public float MarkerX;
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public abstract class Syncfusion.Pdf.Lists.PdfList : PdfLayoutElement {
    protected static Char[] c_splitChars;
    private PdfListItemCollection m_items;
    private float m_indent;
    private float m_textIndent;
    private PdfFont m_font;
    private PdfPen m_pen;
    private PdfBrush m_brush;
    private PdfStringFormat m_format;
    [CompilerGeneratedAttribute]
private BeginItemLayoutEventHandler BeginItemLayout;
    [CompilerGeneratedAttribute]
private EndItemLayoutEventHandler EndItemLayout;
    public PdfListItemCollection Items { get; }
    public float Indent { get; public set; }
    public float TextIndent { get; public set; }
    public PdfFont Font { get; public set; }
    public PdfBrush Brush { get; public set; }
    public PdfPen Pen { get; public set; }
    public PdfStringFormat StringFormat { get; public set; }
    internal bool RiseBeginItemLayout { get; }
    internal bool RiseEndItemLayout { get; }
    internal PdfList(PdfListItemCollection items);
    internal PdfList(PdfFont font);
    private static PdfList();
    protected static PdfListItemCollection CreateItems(string text);
    public PdfListItemCollection get_Items();
    public float get_Indent();
    public void set_Indent(float value);
    public float get_TextIndent();
    public void set_TextIndent(float value);
    public PdfFont get_Font();
    public void set_Font(PdfFont value);
    public PdfBrush get_Brush();
    public void set_Brush(PdfBrush value);
    public PdfPen get_Pen();
    public void set_Pen(PdfPen value);
    public PdfStringFormat get_StringFormat();
    public void set_StringFormat(PdfStringFormat value);
    internal bool get_RiseBeginItemLayout();
    internal bool get_RiseEndItemLayout();
    [CompilerGeneratedAttribute]
public void add_BeginItemLayout(BeginItemLayoutEventHandler value);
    [CompilerGeneratedAttribute]
public void remove_BeginItemLayout(BeginItemLayoutEventHandler value);
    [CompilerGeneratedAttribute]
public void add_EndItemLayout(EndItemLayoutEventHandler value);
    [CompilerGeneratedAttribute]
public void remove_EndItemLayout(EndItemLayoutEventHandler value);
    public virtual void Draw(PdfGraphics graphics, float x, float y);
    protected virtual void DrawInternal(PdfGraphics graphics);
    protected virtual PdfLayoutResult Layout(PdfLayoutParams param);
    internal void OnBeginItemLayout(BeginItemLayoutEventArgs args);
    internal void OnEndItemLayout(EndItemLayoutEventArgs args);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class Syncfusion.Pdf.Lists.PdfListItem : object {
    private PdfFont m_font;
    private string m_text;
    private PdfStringFormat m_format;
    private PdfPen m_pen;
    private PdfBrush m_brush;
    private PdfList m_list;
    private float m_textIndent;
    private PdfTag m_tag;
    public PdfFont Font { get; public set; }
    public string Text { get; public set; }
    public PdfStringFormat StringFormat { get; public set; }
    public PdfPen Pen { get; public set; }
    public PdfBrush Brush { get; public set; }
    public PdfList SubList { get; public set; }
    public float TextIndent { get; public set; }
    public PdfTag PdfTag { get; public set; }
    public PdfListItem(string text);
    public PdfListItem(string text, PdfFont font);
    public PdfListItem(string text, PdfFont font, PdfStringFormat format);
    public PdfListItem(string text, PdfFont font, PdfStringFormat format, PdfPen pen, PdfBrush brush);
    public PdfFont get_Font();
    public void set_Font(PdfFont value);
    public string get_Text();
    public void set_Text(string value);
    public PdfStringFormat get_StringFormat();
    public void set_StringFormat(PdfStringFormat value);
    public PdfPen get_Pen();
    public void set_Pen(PdfPen value);
    public PdfBrush get_Brush();
    public void set_Brush(PdfBrush value);
    public PdfList get_SubList();
    public void set_SubList(PdfList value);
    public float get_TextIndent();
    public void set_TextIndent(float value);
    public PdfTag get_PdfTag();
    public void set_PdfTag(PdfTag value);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[DefaultMemberAttribute("Item")]
public class Syncfusion.Pdf.Lists.PdfListItemCollection : PdfCollection {
    public PdfListItem Item { get; }
    public PdfListItemCollection(String[] items);
    public PdfListItem get_Item(int index);
    public int Add(PdfListItem item);
    public int Add(PdfListItem item, float itemIndent);
    public PdfListItem Add(string text);
    public PdfListItem Add(string text, float itemIndent);
    public PdfListItem Add(string text, PdfFont font);
    public PdfListItem Add(string text, PdfFont font, float itemIndent);
    public void Insert(int index, PdfListItem item);
    public void Insert(int index, PdfListItem item, float itemIndent);
    public void Remove(PdfListItem item);
    public void RemoveAt(int index);
    public int IndexOf(PdfListItem item);
    public void Clear();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Syncfusion.Pdf.Lists.PdfListLayouter : ElementLayouter {
    private PdfGraphics m_graphics;
    private bool m_finish;
    private PdfList m_curList;
    private Stack`1<ListInfo> m_info;
    private int m_index;
    private float m_indent;
    private float m_resultHeight;
    private RectangleF m_bounds;
    private PdfPage currentPage;
    private SizeF size;
    private bool usePaginateBounds;
    private PdfBrush currentBrush;
    private PdfPen currentPen;
    private PdfFont currentFont;
    private PdfStringFormat currentFormat;
    private float markerMaxWidth;
    public PdfList Element { get; }
    public PdfListLayouter(PdfList element);
    public PdfList get_Element();
    public void Layout(PdfGraphics graphics, float x, float y);
    public void Layout(PdfGraphics graphics, PointF point);
    public void Layout(PdfGraphics graphics, RectangleF boundaries);
    protected virtual PdfLayoutResult LayoutInternal(PdfLayoutParams param);
    private float GetMarkerMaxWidth(PdfOrderedList list, Stack`1<ListInfo> info);
    private void SetCurrentParameters(PdfList list);
    private void SetCurrentParameters(PdfListItem item);
    private PageLayoutResult LayoutOnPage(PageLayoutResult pageResult);
    private void DrawItem(PageLayoutResult& pageResult, float x, PdfList curList, int index, float indent, Stack`1<ListInfo> info, PdfListItem item, Single& height, Single& y);
    private static bool IsNullOrEmpty(string text);
    private void AfterItemLayouted(PdfListItem item, PdfPage page);
    private void BeforeItemLayout(PdfListItem item, PdfPage page);
    private ListEndPageLayoutEventArgs AfterPageLayouted(RectangleF currentBounds, PdfPage currentPage, PdfList list);
    private bool BeforePageLayout(RectangleF currentBounds, PdfPage currentPage, PdfList list);
    private PdfStringLayoutResult CreateMarkerResult(int index, PdfList curList, Stack`1<ListInfo> info, PdfListItem item);
    private PdfStringLayoutResult CreateUnorderedMarkerResult(PdfList curList, PdfListItem item, SizeF& markerSize);
    private PdfStringLayoutResult CreateOrderedMarkerResult(PdfList list, PdfListItem item, int index, Stack`1<ListInfo> info, bool findMaxWidth);
    private PdfStringFormat SetMarkerStringFormat(PdfOrderedMarker marker, PdfStringFormat markerFormat);
    private bool DrawMarker(PdfList curList, PdfListItem item, PdfStringLayoutResult markerResult, float posY, float posX);
    private PdfStringLayoutResult DrawUnorderedMarker(PdfList curList, PdfStringLayoutResult markerResult, PdfListItem item, float posX, float posY);
    private PdfStringLayoutResult DrawOrderedMarker(PdfList curList, PdfStringLayoutResult markerResult, PdfListItem item, float posX, float posY);
    private PdfFont GetMarkerFont(PdfMarker marker, PdfListItem item);
    private PdfStringFormat GetMarkerFormat(PdfMarker marker, PdfListItem item);
    private PdfPen GetMarkerPen(PdfMarker marker, PdfListItem item);
    private PdfBrush GetMarkerBrush(PdfMarker marker, PdfListItem item);
}
public enum Syncfusion.Pdf.Lists.PdfListMarkerAlignment : Enum {
    public int value__;
    public static PdfListMarkerAlignment Left;
    public static PdfListMarkerAlignment Right;
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public abstract class Syncfusion.Pdf.Lists.PdfMarker : object {
    private PdfFont m_font;
    private PdfBrush m_brush;
    private PdfPen m_pen;
    private PdfStringFormat m_format;
    private PdfListMarkerAlignment m_alignment;
    public PdfFont Font { get; public set; }
    public PdfBrush Brush { get; public set; }
    public PdfPen Pen { get; public set; }
    public PdfStringFormat StringFormat { get; public set; }
    public PdfListMarkerAlignment Alignment { get; public set; }
    internal bool RightToLeft { get; }
    public PdfFont get_Font();
    public void set_Font(PdfFont value);
    public PdfBrush get_Brush();
    public void set_Brush(PdfBrush value);
    public PdfPen get_Pen();
    public void set_Pen(PdfPen value);
    public PdfStringFormat get_StringFormat();
    public void set_StringFormat(PdfStringFormat value);
    public PdfListMarkerAlignment get_Alignment();
    public void set_Alignment(PdfListMarkerAlignment value);
    internal bool get_RightToLeft();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class Syncfusion.Pdf.Lists.PdfOrderedList : PdfList {
    private PdfOrderedMarker m_marker;
    private bool m_useHierarchy;
    public PdfOrderedMarker Marker { get; public set; }
    public bool MarkerHierarchy { get; public set; }
    public PdfOrderedList(PdfFont font);
    public PdfOrderedList(PdfNumberStyle style);
    public PdfOrderedList(PdfListItemCollection items);
    public PdfOrderedList(PdfOrderedMarker marker);
    public PdfOrderedList(PdfListItemCollection items, PdfOrderedMarker marker);
    public PdfOrderedList(string text);
    public PdfOrderedList(string text, PdfOrderedMarker marker);
    public PdfOrderedMarker get_Marker();
    public void set_Marker(PdfOrderedMarker value);
    public bool get_MarkerHierarchy();
    public void set_MarkerHierarchy(bool value);
    private static PdfOrderedMarker CreateMarker(PdfNumberStyle style);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class Syncfusion.Pdf.Lists.PdfOrderedMarker : PdfMarker {
    private PdfNumberStyle m_style;
    private int m_startNumber;
    private string m_delimiter;
    private string m_suffix;
    private int m_currentIndex;
    public PdfNumberStyle Style { get; public set; }
    public int StartNumber { get; public set; }
    public string Delimiter { get; public set; }
    public string Suffix { get; public set; }
    internal int CurrentIndex { get; internal set; }
    public PdfOrderedMarker(PdfNumberStyle style, string delimiter, string suffix, PdfFont font);
    public PdfOrderedMarker(PdfNumberStyle style, string suffix, PdfFont font);
    public PdfOrderedMarker(PdfNumberStyle style, PdfFont font);
    public PdfNumberStyle get_Style();
    public void set_Style(PdfNumberStyle value);
    public int get_StartNumber();
    public void set_StartNumber(int value);
    public string get_Delimiter();
    public void set_Delimiter(string value);
    public string get_Suffix();
    public void set_Suffix(string value);
    internal int get_CurrentIndex();
    internal void set_CurrentIndex(int value);
    internal void Draw(PdfGraphics graphics, PointF point);
    internal void Draw(PdfPage page, PointF point);
    internal string GetNumber();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class Syncfusion.Pdf.Lists.PdfUnorderedList : PdfList {
    private PdfUnorderedMarker m_marker;
    public PdfUnorderedMarker Marker { get; public set; }
    public PdfUnorderedList(PdfListItemCollection items);
    public PdfUnorderedList(PdfFont font);
    public PdfUnorderedList(PdfUnorderedMarker marker);
    public PdfUnorderedList(PdfListItemCollection items, PdfUnorderedMarker marker);
    public PdfUnorderedList(string text);
    public PdfUnorderedList(string text, PdfUnorderedMarker marker);
    public PdfUnorderedMarker get_Marker();
    public void set_Marker(PdfUnorderedMarker value);
    private static PdfUnorderedMarker CreateMarker(PdfUnorderedMarkerStyle style);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class Syncfusion.Pdf.Lists.PdfUnorderedMarker : PdfMarker {
    private string m_text;
    private PdfUnorderedMarkerStyle m_style;
    private PdfImage m_image;
    private PdfTemplate m_template;
    private SizeF m_size;
    private PdfFont m_unicodeFont;
    public PdfTemplate Template { get; public set; }
    public PdfImage Image { get; public set; }
    public string Text { get; public set; }
    public PdfUnorderedMarkerStyle Style { get; public set; }
    internal SizeF Size { get; internal set; }
    internal PdfFont UnicodeFont { get; internal set; }
    public PdfUnorderedMarker(string text, PdfFont font);
    public PdfUnorderedMarker(PdfUnorderedMarkerStyle style);
    public PdfUnorderedMarker(PdfImage image);
    public PdfUnorderedMarker(PdfTemplate template);
    public PdfTemplate get_Template();
    public void set_Template(PdfTemplate value);
    public PdfImage get_Image();
    public void set_Image(PdfImage value);
    public string get_Text();
    public void set_Text(string value);
    public PdfUnorderedMarkerStyle get_Style();
    public void set_Style(PdfUnorderedMarkerStyle value);
    internal SizeF get_Size();
    internal void set_Size(SizeF value);
    internal PdfFont get_UnicodeFont();
    internal void set_UnicodeFont(PdfFont value);
    internal void Draw(PdfGraphics graphics, PointF point, PdfBrush brush, PdfPen pen);
    internal void Draw(PdfPage page, PointF point, PdfBrush brush, PdfPen pen);
    internal string GetStyledText();
}
public enum Syncfusion.Pdf.Lists.PdfUnorderedMarkerStyle : Enum {
    public int value__;
    public static PdfUnorderedMarkerStyle None;
    public static PdfUnorderedMarkerStyle Disk;
    public static PdfUnorderedMarkerStyle Square;
    public static PdfUnorderedMarkerStyle Asterisk;
    public static PdfUnorderedMarkerStyle Circle;
    public static PdfUnorderedMarkerStyle CustomString;
    public static PdfUnorderedMarkerStyle CustomImage;
    public static PdfUnorderedMarkerStyle CustomTemplate;
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Syncfusion.Pdf.Maxp : TableBase {
    private int m_id;
    private float m_version;
    private ushort m_numGlyphs;
    internal int Id { get; }
    public float Version { get; private set; }
    public ushort NumGlyphs { get; private set; }
    public Maxp(FontFile2 fontsource);
    internal virtual int get_Id();
    public float get_Version();
    private void set_Version(float value);
    public ushort get_NumGlyphs();
    private void set_NumGlyphs(ushort value);
    public virtual void Read(ReadFontArray reader);
}
internal class Syncfusion.Pdf.NamespaceDoc : object {
}
internal class Syncfusion.Pdf.Native.ABC : ValueType {
    public int abcA;
    public int abcB;
    public int abcC;
}
internal enum Syncfusion.Pdf.Native.AD_ANGLEDIRECTION : Enum {
    public int value__;
    public static AD_ANGLEDIRECTION AD_COUNTERCLOCKWISE;
    public static AD_ANGLEDIRECTION AD_CLOCKWISE;
}
internal enum Syncfusion.Pdf.Native.BACKGROUNDMODE : Enum {
    public int value__;
    public static BACKGROUNDMODE TRANSPARENT;
    public static BACKGROUNDMODE OPAQUE;
}
internal class Syncfusion.Pdf.Native.BITMAP : ValueType {
    public int bmType;
    public int bmWidth;
    public int bmHeight;
    public int bmWidthBytes;
    public int bmPlanes;
    public int bmBitsPixel;
    [NullableAttribute("1")]
public Byte[] bmBits;
}
internal class Syncfusion.Pdf.Native.BITMAPINFO : ValueType {
    public BITMAPINFOHEADER bmiHeader;
    public IntPtr bmiColors;
}
internal class Syncfusion.Pdf.Native.BITMAPINFOHEADER : ValueType {
    public int biSize;
    public int biWidth;
    public int biHeight;
    public short biPlanes;
    public short biBitCount;
    public DIB_COMPRESSION biCompression;
    public UInt32 biSizeImage;
    public int biXPelsPerMeter;
    public int biYPelsPerMeter;
    public int biClrUsed;
    public int biClrImportant;
}
internal enum Syncfusion.Pdf.Native.BS_BRUSH_HATCH_STYLE : Enum {
    public int value__;
    public static BS_BRUSH_HATCH_STYLE HS_HORIZONTAL;
    public static BS_BRUSH_HATCH_STYLE HS_VERTICAL;
    public static BS_BRUSH_HATCH_STYLE HS_FDIAGONAL;
    public static BS_BRUSH_HATCH_STYLE HS_BDIAGONAL;
    public static BS_BRUSH_HATCH_STYLE HS_CROSS;
    public static BS_BRUSH_HATCH_STYLE HS_DIAGCROSS;
}
internal enum Syncfusion.Pdf.Native.BS_BRUSH_STYLE : Enum {
    public int value__;
    public static BS_BRUSH_STYLE BS_SOLID;
    public static BS_BRUSH_STYLE BS_NULL;
    public static BS_BRUSH_STYLE BS_HOLLOW;
    public static BS_BRUSH_STYLE BS_HATCHED;
    public static BS_BRUSH_STYLE BS_PATTERN;
    public static BS_BRUSH_STYLE BS_INDEXED;
    public static BS_BRUSH_STYLE BS_DIBPATTERN;
    public static BS_BRUSH_STYLE BS_DIBPATTERNPT;
    public static BS_BRUSH_STYLE BS_PATTERN8X8;
    public static BS_BRUSH_STYLE BS_DIBPATTERN8X8;
    public static BS_BRUSH_STYLE BS_MONOPATTERN;
}
internal class Syncfusion.Pdf.Native.CERT_PUBLIC_KEY_INFO : ValueType {
    public CRYPT_ALGORITHM_IDENTIFIER Algorithm;
    public CryptographicApiStore PublicKey;
}
internal class Syncfusion.Pdf.Native.CertificateContext : ValueType {
    public int CertEncodingType;
    public IntPtr EncodedCertificate;
    public int EncodedCertificateSize;
    public IntPtr CertificateInformation;
    public IntPtr CertificateStore;
}
internal class Syncfusion.Pdf.Native.CertificateNameInformation : ValueType {
    public int Length;
    public IntPtr Pointers;
}
internal class Syncfusion.Pdf.Native.CertificateRDNAttribute : ValueType {
    [NullableAttribute("1")]
public string ID;
    public int ValueType;
    public CryptographicApiStore Value;
}
internal class Syncfusion.Pdf.Native.CertificateRelativeDistinguishedName : ValueType {
    public int Length;
    public IntPtr Attribute;
}
internal class Syncfusion.Pdf.Native.CertInformation : ValueType {
    public int Version;
    public CryptographicApiStore SerialNumber;
    public CRYPT_ALGORITHM_IDENTIFIER SignatureAlgorithm;
    public CryptographicApiStore Issuer;
    public FileTime NotBefore;
    public FileTime NotAfter;
    public CryptographicApiStore Subject;
    public CERT_PUBLIC_KEY_INFO SubjectPublicKeyInfo;
    public CryptographicApiStore IssuerUniqueId;
    public CryptographicApiStore SubjectUniqueId;
    public int ExtensionCount;
    public PCERT_EXTENSION Extension;
}
internal class Syncfusion.Pdf.Native.CHARRANGE : ValueType {
    public int cpMin;
    public int cpMax;
}
internal class Syncfusion.Pdf.Native.ColorData : ValueType {
    public byte Blue;
    public byte Green;
    public byte Red;
}
internal class Syncfusion.Pdf.Native.ColorData16 : ValueType {
    public short Blue;
    public short Green;
    public short Red;
}
internal class Syncfusion.Pdf.Native.ColorDataEx : ValueType {
    public byte Blue;
    public byte Green;
    public byte Red;
    public byte Alpha;
}
internal enum Syncfusion.Pdf.Native.COMBINE_RGN : Enum {
    public int value__;
    public static COMBINE_RGN RGN_AND;
    public static COMBINE_RGN RGN_OR;
    public static COMBINE_RGN RGN_XOR;
    public static COMBINE_RGN RGN_DIFF;
    public static COMBINE_RGN RGN_COPY;
    public static COMBINE_RGN RGN_MIN;
    public static COMBINE_RGN RGN_MAX;
}
internal class Syncfusion.Pdf.Native.CRYPT_ALGORITHM_IDENTIFIER : ValueType {
    [NullableAttribute("1")]
public string pszObjId;
    public CryptographicApiStore Parameters;
}
internal class Syncfusion.Pdf.Native.CryptographicApiStore : ValueType {
    public int Length;
    public IntPtr Data;
}
internal class Syncfusion.Pdf.Native.CryptographicDataStore : ValueType {
    public int BinaryContentLength;
    public IntPtr BinaryContentData;
}
internal class Syncfusion.Pdf.Native.CryptoSignMessageParamerter : ValueType {
    public UInt32 SizeInBytes;
    public UInt32 EncodingType;
    public IntPtr SigningCertPointer;
    public CRYPT_ALGORITHM_IDENTIFIER HashAlgorithm;
    public IntPtr HashAuxInfo;
    public UInt32 MessageCertificateCount;
    public IntPtr MessageCertificate;
    public UInt32 MessageCrlCount;
    public IntPtr MessageCrl;
    public UInt32 AuthenticatedAttributeCount;
    public IntPtr AuthenticatedAttribute;
    public UInt32 UnauthenticatedAttributeCount;
    public IntPtr UnauthenticatedAttribute;
    public UInt32 CrytographicSilentFlag;
    public UInt32 InnerContentType;
    public CRYPT_ALGORITHM_IDENTIFIER HashEncryptionAlgorithm;
    public IntPtr HashEncryptionAux;
}
internal enum Syncfusion.Pdf.Native.DIB_COMPRESSION : Enum {
    public int value__;
    public static DIB_COMPRESSION BI_RGB;
    public static DIB_COMPRESSION BI_RLE8;
    public static DIB_COMPRESSION BI_RLE4;
    public static DIB_COMPRESSION BI_BITFIELDS;
    public static DIB_COMPRESSION BI_JPEG;
    public static DIB_COMPRESSION BI_PNG;
}
internal class Syncfusion.Pdf.Native.EMR_ALPHABLEND : ValueType {
    public RECT rclBounds;
    public int xDest;
    public int yDest;
    public int cxDest;
    public int cyDest;
    public int dwRop;
    public int xSrc;
    public int ySrc;
    public XFORM xformSrc;
    public int crBkColorSrc;
    public int iUsageSrc;
    public int offBmiSrc;
    public int cbBmiSrc;
    public int offBitsSrc;
    public UInt32 cbBitsSrc;
    public int cxSrc;
    public int cySrc;
}
internal class Syncfusion.Pdf.Native.EMR_ANGLEARC : ValueType {
    public POINT ptlCenter;
    public int nRadius;
    public float eStartAngle;
    public float eSweepAngle;
}
internal class Syncfusion.Pdf.Native.EMR_ARC : ValueType {
    public RECT rclBox;
    public POINT ptlStart;
    public POINT ptlEnd;
}
internal class Syncfusion.Pdf.Native.EMR_BITBLT : ValueType {
    public RECT rclBounds;
    public int xDest;
    public int yDest;
    public int cxDest;
    public int cyDest;
    public RASTER_CODE dwRop;
    public int xSrc;
    public int ySrc;
    public XFORM xformSrc;
    public int crBkColorSrc;
    public int iUsageSrc;
    public int offBmiSrc;
    public int cbBmiSrc;
    public int offBitsSrc;
    public UInt32 cbBitsSrc;
}
internal class Syncfusion.Pdf.Native.EMR_CREATEBRUSHINDIRECT : ValueType {
    public int ihBrush;
    public LOGBRUSH32 lb;
}
internal class Syncfusion.Pdf.Native.EMR_CREATEDIBPATTERNBRUSHPT : ValueType {
    public int ihBrush;
    public int iUsage;
    public int offBmi;
    public int cbBmi;
    public int offBits;
    public UInt32 cbBits;
}
internal class Syncfusion.Pdf.Native.EMR_CREATEPEN : ValueType {
    public int ihPen;
    public LOGPEN lopn;
}
internal class Syncfusion.Pdf.Native.EMR_EmfSetROP2 : ValueType {
    public RasterOperation rasterOpertation;
}
internal class Syncfusion.Pdf.Native.EMR_EXCLUDECLIPRECT : ValueType {
    public RECT rclClip;
}
internal class Syncfusion.Pdf.Native.EMR_EXTCREATEFONTINDIRECTW : ValueType {
    public int ihFonts;
    [NullableAttribute("1")]
public LOGFONT elfw;
}
internal class Syncfusion.Pdf.Native.EMR_EXTCREATEPEN : ValueType {
    public int ihPen;
    public int offBmi;
    public int cbBmi;
    public int offBits;
    public int cbBits;
    public int elpPenStyle;
    public int elpWidth;
    public UInt32 elpBrushStyle;
    public int elpColor;
    public IntPtr elpHatch;
    public int elpNumEntries;
    [NullableAttribute("1")]
public Int32[] elpStyleEntry;
}
internal class Syncfusion.Pdf.Native.EMR_EXTSELECTCLIPRGN : ValueType {
    public int cbRgnData;
    public int iMode;
    public RGNDATA RgnData;
}
internal class Syncfusion.Pdf.Native.EMR_EXTTEXTOUTA : ValueType {
    public RECT rclBounds;
    public int iGraphicsMode;
    public float exScale;
    public float eyScale;
    public EMR_TEXT emrtext;
}
internal class Syncfusion.Pdf.Native.EMR_FILLPATH : ValueType {
    public RECT rclBounds;
}
internal class Syncfusion.Pdf.Native.EMR_FILLRGN : ValueType {
    public RECT rclBounds;
    public int cbRgnData;
    public int ihBrush;
    public RGNDATA RgnData;
}
internal class Syncfusion.Pdf.Native.EMR_INVERTRGN : ValueType {
    public RECT rclBounds;
    public int cbRgnData;
    public RGNDATA RgnData;
}
internal class Syncfusion.Pdf.Native.EMR_LINETO : ValueType {
    public POINT ptl;
}
internal class Syncfusion.Pdf.Native.EMR_MASKBLT : ValueType {
    public RECT rclBounds;
    public int xDest;
    public int yDest;
    public int cxDest;
    public int cyDest;
    public RASTER_CODE dwRop;
    public int xSrc;
    public int ySrc;
    public XFORM xformSrc;
    public int crBkColorSrc;
    public int iUsageSrc;
    public int offBmiSrc;
    public int cbBmiSrc;
    public int offBitsSrc;
    public UInt32 cbBitsSrc;
    public int xMask;
    public int yMask;
    public int iUsageMask;
    public int offBmiMask;
    public int cbBmiMask;
    public int offBitsMask;
    public UInt32 cbBitsMask;
}
internal class Syncfusion.Pdf.Native.EMR_MODIFYWORLDTRANSFORM : ValueType {
    public XFORM xform;
    public MWT_DATA iMode;
}
internal class Syncfusion.Pdf.Native.EMR_OFFSETCLIPRGN : ValueType {
    public POINT ptlOffset;
}
internal class Syncfusion.Pdf.Native.EMR_POLYLINE : ValueType {
    public RECT rclBounds;
    public UInt32 cpts;
    [NullableAttribute("1")]
public POINT[] apts;
}
internal class Syncfusion.Pdf.Native.EMR_POLYLINE16 : ValueType {
    public RECT rclBounds;
    public UInt32 cpts;
    [NullableAttribute("1")]
public POINTS[] apts;
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Syncfusion.Pdf.Native.EMR_POLYPOLYLINE : ValueType {
    public RECT rclBounds;
    public UInt32 nPolys;
    public UInt32 cpts;
    public UInt32[] aPolyCounts;
    public POINT[] apts;
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Syncfusion.Pdf.Native.EMR_POLYPOLYLINE16 : ValueType {
    public RECT rclBounds;
    public UInt32 nPolys;
    public UInt32 cpts;
    public UInt32[] aPolyCounts;
    public POINTS[] apts;
}
internal class Syncfusion.Pdf.Native.EMR_RECTANGLE : ValueType {
    public RECT rclBox;
}
internal class Syncfusion.Pdf.Native.EMR_ROUNDRECT : ValueType {
    public RECT rclBox;
    public SIZE szlCorner;
}
internal class Syncfusion.Pdf.Native.EMR_SCALEVIEWPORTEXTEX : ValueType {
    public int xNum;
    public int xDenom;
    public int yNum;
    public int yDenom;
}
internal class Syncfusion.Pdf.Native.EMR_SELECTCLIPPATH : ValueType {
    public int iMode;
}
internal class Syncfusion.Pdf.Native.EMR_SELECTPALETTE : ValueType {
    public UInt32 ihPal;
}
internal class Syncfusion.Pdf.Native.EMR_SETARCDIRECTION : ValueType {
    public int iArcDirection;
}
internal class Syncfusion.Pdf.Native.EMR_SETMITERLIMIT : ValueType {
    public int eMiterLimit;
}
internal class Syncfusion.Pdf.Native.EMR_SETPIXELV : ValueType {
    public POINT ptlPixel;
    public int crColor;
}
internal class Syncfusion.Pdf.Native.EMR_SETTEXTCOLOR : ValueType {
    public int crColor;
}
internal class Syncfusion.Pdf.Native.EMR_SETVIEWPORTEXTEX : ValueType {
    public SIZE szlExtent;
}
internal class Syncfusion.Pdf.Native.EMR_SETVIEWPORTORGEX : ValueType {
    public POINT ptlOrigin;
}
internal class Syncfusion.Pdf.Native.EMR_SETWORLDTRANSFORM : ValueType {
    public XFORM xform;
}
internal class Syncfusion.Pdf.Native.EMR_STRETCHBLT : ValueType {
    public RECT rclBounds;
    public int xDest;
    public int yDest;
    public int cxDest;
    public int cyDest;
    public RASTER_CODE dwRop;
    public int xSrc;
    public int ySrc;
    public XFORM xformSrc;
    public int crBkColorSrc;
    public int iUsageSrc;
    public int offBmiSrc;
    public int cbBmiSrc;
    public int offBitsSrc;
    public UInt32 cbBitsSrc;
    public int cxSrc;
    public int cySrc;
}
internal class Syncfusion.Pdf.Native.EMR_STRETCHDIBITS : ValueType {
    public RECT rclBounds;
    public int xDest;
    public int yDest;
    public int xSrc;
    public int ySrc;
    public int cxSrc;
    public int cySrc;
    public int offBmiSrc;
    public int cbBmiSrc;
    public int offBitsSrc;
    public UInt32 cbBitsSrc;
    public int iUsageSrc;
    public UInt32 dwRop;
    public int cxDest;
    public int cyDest;
}
internal class Syncfusion.Pdf.Native.EMR_TEXT : ValueType {
    public POINT ptlReference;
    public int nChars;
    public int offString;
    public int fOptions;
    public RECT rcl;
    public int offDx;
}
internal class Syncfusion.Pdf.Native.EMR_TRANSPARENTBLT : ValueType {
    public RECT rclBounds;
    public int xDest;
    public int yDest;
    public int cxDest;
    public int cyDest;
    public int color;
    public int xSrc;
    public int ySrc;
    public XFORM xformSrc;
    public int crBkColorSrc;
    public int iUsageSrc;
    public int offBmiSrc;
    public int cbBmiSrc;
    public int offBitsSrc;
    public UInt32 cbBitsSrc;
    public int cxSrc;
    public int cySrc;
}
[FlagsAttribute]
internal enum Syncfusion.Pdf.Native.ETO : Enum {
    public int value__;
    public static ETO OPAQUE;
    public static ETO CLIPPED;
    public static ETO GLYPH_INDEX;
    public static ETO NUMERICSLATIN;
    public static ETO NUMERICSLOCAL;
    public static ETO RTLREADING;
    public static ETO IGNORELANGUAGE;
    public static ETO PDY;
}
internal class Syncfusion.Pdf.Native.EXTLOGPEN : ValueType {
    public int elpPenStyle;
    public int elpWidth;
    public UInt32 elpBrushStyle;
    public int elpColor;
    public IntPtr elpHatch;
    public int elpNumEntries;
    [NullableAttribute("1")]
public Int32[] elpStyleEntry;
}
internal class Syncfusion.Pdf.Native.FileTime : ValueType {
    public int HighDateTime;
    public int LowDateTime;
}
[FlagsAttribute]
internal enum Syncfusion.Pdf.Native.FormatMessageFlags : Enum {
    public int value__;
    public static FormatMessageFlags AllocateBuffer;
    public static FormatMessageFlags IgnoreInserts;
    public static FormatMessageFlags FromString;
    public static FormatMessageFlags FromHmodule;
    public static FormatMessageFlags FromSystem;
    public static FormatMessageFlags ArgumentArray;
}
internal class Syncfusion.Pdf.Native.FORMATRANGE : object {
    public IntPtr hdc;
    public IntPtr hdcTarget;
    public RECT rc;
    public RECT rcPage;
    public CHARRANGE chrg;
}
internal enum Syncfusion.Pdf.Native.FW_FONT_WEIGHT : Enum {
    public int value__;
    public static FW_FONT_WEIGHT FW_DONTCARE;
    public static FW_FONT_WEIGHT FW_THIN;
    public static FW_FONT_WEIGHT FW_EXTRALIGHT;
    public static FW_FONT_WEIGHT FW_LIGHT;
    public static FW_FONT_WEIGHT FW_NORMAL;
    public static FW_FONT_WEIGHT FW_MEDIUM;
    public static FW_FONT_WEIGHT FW_SEMIBOLD;
    public static FW_FONT_WEIGHT FW_BOLD;
    public static FW_FONT_WEIGHT FW_EXTRABOLD;
    public static FW_FONT_WEIGHT FW_HEAVY;
}
internal enum Syncfusion.Pdf.Native.GDI_CHARSET : Enum {
    public int value__;
    public static GDI_CHARSET ANSI_CHARSET;
    public static GDI_CHARSET DEFAULT_CHARSET;
    public static GDI_CHARSET SYMBOL_CHARSET;
    public static GDI_CHARSET SHIFTJIS_CHARSET;
    public static GDI_CHARSET EASTEUROPE_CHARSET;
    public static GDI_CHARSET RUSSIAN_CHARSET;
    public static GDI_CHARSET MAC_CHARSET;
}
internal enum Syncfusion.Pdf.Native.GDI_PITCH_AND_FAMILY : Enum {
    public int value__;
    public static GDI_PITCH_AND_FAMILY TMPF_FIXED_PITCH;
    public static GDI_PITCH_AND_FAMILY TMPF_VECTOR;
    public static GDI_PITCH_AND_FAMILY TMPF_TRUETYPE;
    public static GDI_PITCH_AND_FAMILY TMPF_DEVICE;
    public static GDI_PITCH_AND_FAMILY FF_DONTCARE;
    public static GDI_PITCH_AND_FAMILY FF_ROMAN;
    public static GDI_PITCH_AND_FAMILY FF_SWISS;
    public static GDI_PITCH_AND_FAMILY FF_MODERN;
    public static GDI_PITCH_AND_FAMILY FF_SCRIPT;
    public static GDI_PITCH_AND_FAMILY FF_DECORATIVE;
}
internal enum Syncfusion.Pdf.Native.GM_GraphicsMode : Enum {
    public int value__;
    public static GM_GraphicsMode GM_COMPATIBLE;
    public static GM_GraphicsMode GM_ADVANCED;
}
internal enum Syncfusion.Pdf.Native.GradientFillEnum : Enum {
    public int value__;
    public static GradientFillEnum GRADIENT_FILL_RECT_H;
    public static GradientFillEnum GRADIENT_FILL_RECT_V;
    public static GradientFillEnum GRADIENT_FILL_TRIANGLE;
}
internal class Syncfusion.Pdf.Native.GRADIENTTRIANGLE : ValueType {
    public int vertex1;
    public int vertex2;
    public int vertex3;
}
internal enum Syncfusion.Pdf.Native.ICM_MODE : Enum {
    public int value__;
    public static ICM_MODE ICM_OFF;
    public static ICM_MODE ICM_ON;
    public static ICM_MODE ICM_QUERY;
    public static ICM_MODE ICM_DONE_OUTSIDEDC;
}
internal class Syncfusion.Pdf.Native.LOGBRUSH32 : ValueType {
    public BS_BRUSH_STYLE lbStyle;
    public int lbColor;
    public UInt32 lbHatch;
}
internal class Syncfusion.Pdf.Native.LOGFONT : object {
    public int lfHeight;
    public int lfWidth;
    public int lfEscapement;
    public int lfOrientation;
    public FW_FONT_WEIGHT lfWeight;
    public bool lfItalic;
    public bool lfUnderline;
    public bool lfStrikeOut;
    public byte lfCharSet;
    public byte lfOutPrecision;
    public byte lfClipPrecision;
    public byte lfQuality;
    public byte lfPitchAndFamily;
    [NullableAttribute("1")]
public string lfFaceName;
}
internal class Syncfusion.Pdf.Native.LOGPEN : ValueType {
    public UInt32 lopnStyle;
    public POINT lopnWidth;
    public int lopnColor;
}
internal enum Syncfusion.Pdf.Native.MAPPING_MODE : Enum {
    public int value__;
    public static MAPPING_MODE MM_TEXT;
    public static MAPPING_MODE MM_LOMETRIC;
    public static MAPPING_MODE MM_HIMETRIC;
    public static MAPPING_MODE MM_LOENGLISH;
    public static MAPPING_MODE MM_HIENGLISH;
    public static MAPPING_MODE MM_TWIPS;
    public static MAPPING_MODE MM_ISOTROPIC;
    public static MAPPING_MODE MM_ANISOTROPIC;
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Syncfusion.Pdf.Native.Md5_Ctx : ValueType {
    public UInt32[] i;
    public UInt32[] buf;
    public Byte[] input;
    public Byte[] digest;
}
internal class Syncfusion.Pdf.Native.METAFILEPICT : ValueType {
    public int mm;
    public int xExt;
    public int yExt;
    public IntPtr hMF;
}
internal enum Syncfusion.Pdf.Native.MWT_DATA : Enum {
    public int value__;
    public static MWT_DATA MWT_IDENTITY;
    public static MWT_DATA MWT_LEFTMULTIPLY;
    public static MWT_DATA MWT_RIGHTMULTIPLY;
}
internal class Syncfusion.Pdf.Native.OUTLINETEXTMETRIC : ValueType {
    public UInt32 otmSize;
    public TEXTMETRIC otmTextMetrics;
    public byte otmFiller;
    public PANOSE otmPanoseNumber;
    public UInt32 otmfsSelection;
    public UInt32 otmfsType;
    public int otmsCharSlopeRise;
    public int otmsCharSlopeRun;
    public int otmItalicAngle;
    public UInt32 otmEMSquare;
    public int otmAscent;
    public int otmDescent;
    public UInt32 otmLineGap;
    public UInt32 otmsCapEmHeight;
    public UInt32 otmsXHeight;
    public RECT otmrcFontBox;
    public int otmMacAscent;
    public int otmMacDescent;
    public UInt32 otmMacLineGap;
    public UInt32 otmusMinimumPPEM;
    public POINT otmptSubscriptSize;
    public POINT otmptSubscriptOffset;
    public POINT otmptSuperscriptSize;
    public POINT otmptSuperscriptOffset;
    public UInt32 otmsStrikeoutSize;
    public int otmsStrikeoutPosition;
    public int otmsUnderscoreSize;
    public int otmsUnderscorePosition;
    public IntPtr otmpFamilyName;
    public IntPtr otmpFaceName;
    public IntPtr otmpStyleName;
    public IntPtr otmpFullName;
}
internal class Syncfusion.Pdf.Native.PANOSE : ValueType {
    public byte bFamilyType;
    public byte bSerifStyle;
    public byte bWeight;
    public byte bProportion;
    public byte bContrast;
    public byte bStrokeVariation;
    public byte bArmStyle;
    public byte bLetterform;
    public byte bMidline;
    public byte bXHeight;
}
internal class Syncfusion.Pdf.Native.PCERT_EXTENSION : ValueType {
    public IntPtr pszObjId;
    public bool fCritical;
    public CryptographicApiStore Value;
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Syncfusion.Pdf.Native.PdfPrimitiveId : ValueType {
    internal Byte[] Null { get; }
    internal Byte[] Integer { get; }
    internal Byte[] Real { get; }
    internal Byte[] Boolean { get; }
    internal Byte[] Name { get; }
    internal Byte[] String { get; }
    internal Byte[] Dictionary { get; }
    internal Byte[] Array { get; }
    internal Byte[] Stream { get; }
    internal Byte[] True { get; }
    internal Byte[] False { get; }
    internal Byte[] Visited { get; }
    internal Byte[] get_Null();
    internal Byte[] get_Integer();
    internal Byte[] get_Real();
    internal Byte[] get_Boolean();
    internal Byte[] get_Name();
    internal Byte[] get_String();
    internal Byte[] get_Dictionary();
    internal Byte[] get_Array();
    internal Byte[] get_Stream();
    internal Byte[] get_True();
    internal Byte[] get_False();
    internal Byte[] get_Visited();
}
internal class Syncfusion.Pdf.Native.POINT : ValueType {
    public int x;
    public int y;
    public POINT(int X, int Y);
    public POINT(int lParam);
    public static Point op_Implicit(POINT p);
    public static PointF op_Implicit(POINT p);
    public static POINT op_Implicit(Point p);
}
internal class Syncfusion.Pdf.Native.POINTS : ValueType {
    public short x;
    public short y;
    public POINTS(short X, short Y);
    public static Point op_Implicit(POINTS p);
    public static PointF op_Implicit(POINTS p);
    public static POINTS op_Implicit(Point p);
    public static POINTS op_Implicit(PointF p);
}
internal enum Syncfusion.Pdf.Native.PS_PEN_CAP_STYLE : Enum {
    public int value__;
    public static PS_PEN_CAP_STYLE PS_ENDCAP_ROUND;
    public static PS_PEN_CAP_STYLE PS_ENDCAP_SQUARE;
    public static PS_PEN_CAP_STYLE PS_ENDCAP_FLAT;
}
internal enum Syncfusion.Pdf.Native.PS_PEN_JOIN_STYLE : Enum {
    public int value__;
    public static PS_PEN_JOIN_STYLE PS_JOIN_ROUND;
    public static PS_PEN_JOIN_STYLE PS_JOIN_BEVEL;
    public static PS_PEN_JOIN_STYLE PS_JOIN_MITER;
}
internal enum Syncfusion.Pdf.Native.PS_PEN_STYLE : Enum {
    public int value__;
    public static PS_PEN_STYLE PS_SOLID;
    public static PS_PEN_STYLE PS_DASH;
    public static PS_PEN_STYLE PS_DOT;
    public static PS_PEN_STYLE PS_DASHDOT;
    public static PS_PEN_STYLE PS_DASHDOTDOT;
    public static PS_PEN_STYLE PS_NULL;
    public static PS_PEN_STYLE PS_INSIDEFRAME;
    public static PS_PEN_STYLE PS_USERSTYLE;
    public static PS_PEN_STYLE PS_ALTERNATE;
}
internal enum Syncfusion.Pdf.Native.PS_PEN_TYPE : Enum {
    public int value__;
    public static PS_PEN_TYPE PS_COSMETIC;
    public static PS_PEN_TYPE PS_GEOMETRIC;
}
[FlagsAttribute]
internal enum Syncfusion.Pdf.Native.PT_POINT_TYPE : Enum {
    public byte value__;
    public static PT_POINT_TYPE PT_CLOSEFIGURE;
    public static PT_POINT_TYPE PT_LINETO;
    public static PT_POINT_TYPE PT_BEZIERTO;
    public static PT_POINT_TYPE PT_MOVETO;
}
[FlagsAttribute]
internal enum Syncfusion.Pdf.Native.RASTER_CODE : Enum {
    public UInt32 value__;
    public static RASTER_CODE SRCCOPY;
    public static RASTER_CODE SRCPAINT;
    public static RASTER_CODE SRCAND;
    public static RASTER_CODE SRCINVERT;
    public static RASTER_CODE SRCERASE;
    public static RASTER_CODE NOTSRCCOPY;
    public static RASTER_CODE NOTSRCERASE;
    public static RASTER_CODE MERGECOPY;
    public static RASTER_CODE MERGEPAINT;
    public static RASTER_CODE PATCOPY;
    public static RASTER_CODE PATPAINT;
    public static RASTER_CODE PATINVERT;
    public static RASTER_CODE DSTINVERT;
    public static RASTER_CODE BLACKNESS;
    public static RASTER_CODE WHITENESS;
    public static RASTER_CODE SRCANDDST;
    public static RASTER_CODE PSDPXAX;
}
public enum Syncfusion.Pdf.Native.RasterOperation : Enum {
    public int value__;
    public static RasterOperation R2_BLACK;
    public static RasterOperation R2_NOTMERGEPEN;
    public static RasterOperation R2_MASKNOTPEN;
    public static RasterOperation R2_NOTCOPYPEN;
    public static RasterOperation R2_MASKPENNOT;
    public static RasterOperation R2_NOT;
    public static RasterOperation R2_XORPEN;
    public static RasterOperation R2_NOTMASKPEN;
    public static RasterOperation R2_MASKPEN;
    public static RasterOperation R2_NOTXORPEN;
    public static RasterOperation R2_NOP;
    public static RasterOperation R2_MERGENOTPEN;
    public static RasterOperation R2_COPYPEN;
    public static RasterOperation R2_MERGEPENNOT;
    public static RasterOperation R2_MERGEPEN;
    public static RasterOperation R2_WHITE;
}
internal class Syncfusion.Pdf.Native.RECT : ValueType {
    public int left;
    public int top;
    public int right;
    public int bottom;
    public int Width { get; }
    public int Height { get; }
    public Point TopLeft { get; }
    public Size Size { get; }
    public RECT(int x1, int y1, int x2, int y2);
    public int get_Width();
    public int get_Height();
    public Point get_TopLeft();
    public Size get_Size();
    [NullableContextAttribute("1")]
public virtual string ToString();
    public static Rectangle op_Implicit(RECT rect);
    public static RectangleF op_Implicit(RECT rect);
    public static Size op_Implicit(RECT rect);
    public static RECT op_Explicit(Rectangle rect);
}
internal class Syncfusion.Pdf.Native.RGBQUAD : ValueType {
    public byte rgbBlue;
    public byte rgbGreen;
    public byte rgbRed;
    public byte rgbReserved;
}
internal class Syncfusion.Pdf.Native.RGNDATA : ValueType {
    public RGNDATAHEADER rdh;
}
internal class Syncfusion.Pdf.Native.RGNDATAHEADER : ValueType {
    public int dwSize;
    public int iType;
    public int nCount;
    public int nRgnSize;
    public RECT rcBound;
}
internal class Syncfusion.Pdf.Native.SIZE : ValueType {
    public int cx;
    public int cy;
    public static SizeF op_Implicit(SIZE rect);
}
internal enum Syncfusion.Pdf.Native.STOCK : Enum {
    public int value__;
    public static STOCK WHITE_BRUSH;
    public static STOCK LTGRAY_BRUSH;
    public static STOCK GRAY_BRUSH;
    public static STOCK DKGRAY_BRUSH;
    public static STOCK BLACK_BRUSH;
    public static STOCK NULL_BRUSH;
    public static STOCK HOLLOW_BRUSH;
    public static STOCK WHITE_PEN;
    public static STOCK BLACK_PEN;
    public static STOCK NULL_PEN;
    public static STOCK OEM_FIXED_FONT;
    public static STOCK ANSI_FIXED_FONT;
    public static STOCK ANSI_VAR_FONT;
    public static STOCK SYSTEM_FONT;
    public static STOCK DEVICE_DEFAULT_FONT;
    public static STOCK DEFAULT_PALETTE;
    public static STOCK SYSTEM_FIXED_FONT;
    public static STOCK DEFAULT_GUI_FONT;
    public static STOCK DC_BRUSH;
    public static STOCK DC_PEN;
}
internal enum Syncfusion.Pdf.Native.StringInfoCtype1 : Enum {
    public ushort value__;
    public static StringInfoCtype1 C1_UPPER;
    public static StringInfoCtype1 C1_LOWER;
    public static StringInfoCtype1 C1_DIGIT;
    public static StringInfoCtype1 C1_SPACE;
    public static StringInfoCtype1 C1_PUNCT;
    public static StringInfoCtype1 C1_CNTRL;
    public static StringInfoCtype1 C1_BLANK;
    public static StringInfoCtype1 C1_XDIGIT;
    public static StringInfoCtype1 C1_ALPHA;
}
internal enum Syncfusion.Pdf.Native.StringInfoCtype2 : Enum {
    public ushort value__;
    public static StringInfoCtype2 C2_LEFTTORIGHT;
    public static StringInfoCtype2 C2_RIGHTTOLEFT;
    public static StringInfoCtype2 C2_EUROPENUMBER;
    public static StringInfoCtype2 C2_EUROPESEPARATOR;
    public static StringInfoCtype2 C2_EUROPETERMINATOR;
    public static StringInfoCtype2 C2_ARABICNUMBER;
    public static StringInfoCtype2 C2_COMMONSEPARATOR;
    public static StringInfoCtype2 C2_BLOCKSEPARATOR;
    public static StringInfoCtype2 C2_SEGMENTSEPARATOR;
    public static StringInfoCtype2 C2_WHITESPACE;
    public static StringInfoCtype2 C2_OTHERNEUTRAL;
    public static StringInfoCtype2 C2_NOTAPPLICABLE;
}
internal enum Syncfusion.Pdf.Native.StringInfoCtype3 : Enum {
    public ushort value__;
    public static StringInfoCtype3 C3_DIACRITIC;
    public static StringInfoCtype3 C3_VOWELMARK;
    public static StringInfoCtype3 C3_SYMBOL;
    public static StringInfoCtype3 C3_KATAKANA;
    public static StringInfoCtype3 C3_HIRAGANA;
    public static StringInfoCtype3 C3_HALFWIDTH;
    public static StringInfoCtype3 C3_FULLWIDTH;
    public static StringInfoCtype3 C3_IDEOGRAPH;
    public static StringInfoCtype3 C3_KASHIDA;
    public static StringInfoCtype3 C3_LEXICAL;
    public static StringInfoCtype3 C3_ALPHA;
    public static StringInfoCtype3 C3_NOTAPPLICABLE;
}
internal enum Syncfusion.Pdf.Native.StringInfoType : Enum {
    public UInt32 value__;
    public static StringInfoType CT_TYPE1;
    public static StringInfoType CT_TYPE2;
    public static StringInfoType CT_TYPE3;
}
internal class Syncfusion.Pdf.Native.SystemTime : ValueType {
    public ushort Year;
    public ushort Month;
    public ushort DayOfWeek;
    public ushort Day;
    public ushort Hour;
    public ushort Minute;
    public ushort Second;
    public ushort Milliseconds;
}
[FlagsAttribute]
internal enum Syncfusion.Pdf.Native.TA_TEXT_ALIGN : Enum {
    public int value__;
    public static TA_TEXT_ALIGN TA_NOUPDATECP;
    public static TA_TEXT_ALIGN TA_UPDATECP;
    public static TA_TEXT_ALIGN TA_LEFT;
    public static TA_TEXT_ALIGN TA_RIGHT;
    public static TA_TEXT_ALIGN TA_CENTER;
    public static TA_TEXT_ALIGN TA_TOP;
    public static TA_TEXT_ALIGN TA_BOTTOM;
    public static TA_TEXT_ALIGN TA_BASELINE;
    public static TA_TEXT_ALIGN TA_RTLREADING;
}
internal class Syncfusion.Pdf.Native.TEXTMETRIC : ValueType {
    public int tmHeight;
    public int tmAscent;
    public int tmDescent;
    public int tmInternalLeading;
    public int tmExternalLeading;
    public int tmAveCharWidth;
    public int tmMaxCharWidth;
    public int tmWeight;
    public int tmOverhang;
    public int tmDigitizedAspectX;
    public int tmDigitizedAspectY;
    public byte tmFirstChar;
    public byte tmLastChar;
    public byte tmDefaultChar;
    public byte tmBreakChar;
    public byte tmItalic;
    public byte tmUnderlined;
    public byte tmStruckOut;
    public byte tmPitchAndFamily;
    public byte tmCharSet;
}
internal class Syncfusion.Pdf.Native.Trivertex : ValueType {
    internal int x;
    internal int y;
    internal ushort red;
    internal ushort green;
    internal ushort blue;
    internal ushort alpha;
}
internal class Syncfusion.Pdf.Native.WinGdiConst : object {
    public static int PS_STYLE_MASK;
    public static int PS_ENDCAP_MASK;
    public static int PS_JOIN_MASK;
    public static int PS_TYPE_MASK;
    public static int DIB_RGB_COLORS;
    public static int DIB_PAL_COLORS;
    public static int LF_FULLFACESIZE;
    public static int LF_FACESIZE;
    public static int ELF_VENDOR_SIZE;
    public static int LOGPIXELSX;
    public static int LOGPIXELSY;
    public static int CBM_INIT;
    public static UInt32 GDI_ERROR;
}
internal class Syncfusion.Pdf.Native.XFORM : ValueType {
    public float eM11;
    public float eM12;
    public float eM21;
    public float eM22;
    public float eDx;
    public float eDy;
    [NullableContextAttribute("1")]
public virtual string ToString();
}
internal class Syncfusion.Pdf.OutlinePoint : object {
    private PointF m_point;
    private byte m_flags;
    public PointF Point { get; public set; }
    public byte Flags { get; public set; }
    public bool IsOnCurve { get; }
    public OutlinePoint(double x, double y, byte flags);
    public OutlinePoint(byte flags);
    public PointF get_Point();
    public void set_Point(PointF value);
    public byte get_Flags();
    public void set_Flags(byte value);
    public bool get_IsOnCurve();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class Syncfusion.Pdf.PageAddedEventArgs : EventArgs {
    private PdfPage m_page;
    public PdfPage Page { get; }
    public PageAddedEventArgs(PdfPage page);
    public PdfPage get_Page();
}
public class Syncfusion.Pdf.PageAddedEventHandler : MulticastDelegate {
    public PageAddedEventHandler(object object, IntPtr method);
    [NullableContextAttribute("1")]
public virtual void Invoke(object sender, PageAddedEventArgs args);
    public virtual IAsyncResult BeginInvoke(object sender, PageAddedEventArgs args, AsyncCallback callback, object object);
    public virtual void EndInvoke(IAsyncResult result);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Syncfusion.Pdf.PageResourceLoader : object {
    private static PageResourceLoader s_instance;
    private static object s_lock;
    private bool m_isExtractImages;
    internal Dictionary`2<string, PdfMatrix> m_commonMatrix;
    private object m_resourceLock;
    private bool m_hasImages;
    internal string m_colorSpaceText;
    public static PageResourceLoader Instance { get; }
    internal bool HasImages { get; internal set; }
    private static PageResourceLoader();
    public static PageResourceLoader get_Instance();
    internal bool get_HasImages();
    internal void set_HasImages(bool value);
    public PdfPageResources GetPageResources(PdfPageBase page);
    internal Dictionary`2<string, object> GetExtendedGraphicResources(PdfDictionary resourceDictionary);
    internal Dictionary`2<string, object> GetColorSpaceResource(PdfDictionary resourceDic);
    internal Dictionary`2<string, object> GetShadingResource(PdfDictionary resourceDictionary);
    internal Dictionary`2<string, object> GetPatternResource(PdfDictionary resourceDictionary);
    internal Dictionary`2<string, object> GetFontResources(PdfDictionary resourceDictionary);
    internal Dictionary`2<string, object> GetFontResources(PdfDictionary resourceDictionary, PdfPageBase page);
    internal Dictionary`2<string, object> GetImageResources(PdfDictionary resourceDictionary, PdfPageBase page, Dictionary`2& commonMatrix);
    internal PdfPageResources UpdatePageResources(PdfPageResources pageResources, Dictionary`2<string, object> objects);
}
public enum Syncfusion.Pdf.PageScalingMode : Enum {
    public int value__;
    public static PageScalingMode AppDefault;
    public static PageScalingMode None;
}
[NullableContextAttribute("1")]
public interface Syncfusion.Pdf.Parsing.AnalyzerResult {
    public List`1<PdfException> Errors { get; }
    public abstract virtual List`1<PdfException> get_Errors();
}
public enum Syncfusion.Pdf.Parsing.AnnotationDataFormat : Enum {
    public int value__;
    public static AnnotationDataFormat Fdf;
    public static AnnotationDataFormat XFdf;
    public static AnnotationDataFormat Json;
}
public enum Syncfusion.Pdf.Parsing.DataFormat : Enum {
    public int value__;
    public static DataFormat Xml;
    public static DataFormat Fdf;
    public static DataFormat XFdf;
    public static DataFormat Json;
}
[NullableContextAttribute("1")]
[NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal class Syncfusion.Pdf.Parsing.EnumerableSorter`2 : SystemFontEnumerableSorter`1<TElement> {
    internal Func`2<TElement, TKey> keySelector;
    internal IComparer`1<TKey> comparer;
    internal bool descending;
    internal SystemFontEnumerableSorter`1<TElement> next;
    internal TKey[] keys;
    internal EnumerableSorter`2(Func`2<TElement, TKey> keySelector, IComparer`1<TKey> comparer, bool descending, SystemFontEnumerableSorter`1<TElement> next);
    internal virtual int CompareKeys(int index1, int index2);
    internal virtual void ComputeKeys(TElement[] elements, int count);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class Syncfusion.Pdf.Parsing.ExportFormSettings : object {
    private DataFormat dataFormat;
    internal bool AsPerSpecification;
    private string formName;
    public DataFormat DataFormat { get; public set; }
    public string FormName { get; public set; }
    public DataFormat get_DataFormat();
    public void set_DataFormat(DataFormat value);
    public string get_FormName();
    public void set_FormName(string value);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Syncfusion.Pdf.Parsing.FdfObject : object {
    private int m_objNumber;
    private int m_genNumber;
    private IPdfPrimitive m_object;
    private IPdfPrimitive m_trailer;
    internal int ObjectNumber { get; }
    internal int GenerationNumber { get; }
    internal IPdfPrimitive Object { get; }
    internal IPdfPrimitive Trailer { get; }
    internal FdfObject(PdfNumber objNum, PdfNumber genNum, IPdfPrimitive obj);
    internal FdfObject(IPdfPrimitive obj);
    internal int get_ObjectNumber();
    internal int get_GenerationNumber();
    internal IPdfPrimitive get_Object();
    internal IPdfPrimitive get_Trailer();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Syncfusion.Pdf.Parsing.FdfObjectCollection : object {
    private Dictionary`2<string, IPdfPrimitive> m_objects;
    internal Dictionary`2<string, IPdfPrimitive> Objects { get; internal set; }
    internal Dictionary`2<string, IPdfPrimitive> get_Objects();
    internal void set_Objects(Dictionary`2<string, IPdfPrimitive> value);
    internal void Add(string key, IPdfPrimitive value);
    internal void Dispose();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Syncfusion.Pdf.Parsing.FdfParser : object {
    private PdfReader m_reader;
    private PdfParser m_parser;
    private Stream m_stream;
    private FdfObjectCollection m_objects;
    private Dictionary`2<string, PdfReferenceHolder> m_annotationObjects;
    private Dictionary`2<string, string> m_groupObjects;
    internal bool hasTrailer;
    internal bool fdfImport;
    internal PdfReader Reader { get; }
    internal PdfParser Parser { get; }
    internal FdfObjectCollection FdfObjects { get; }
    internal Dictionary`2<string, string> GroupedObjects { get; }
    internal FdfParser(Stream stream);
    internal PdfReader get_Reader();
    internal PdfParser get_Parser();
    internal FdfObjectCollection get_FdfObjects();
    internal Dictionary`2<string, string> get_GroupedObjects();
    internal void ImportAnnotations(PdfLoadedDocument document);
    private bool GroupAnnotations();
    internal void ParseObjectData();
    internal void ParseAnnotationData();
    internal void Dispose();
    private long CheckFdf();
    private void ParseObject(FdfObjectCollection objects);
    private void ParseDictionary(PdfDictionary dictionary, PdfName key);
    private void ParseDictionary(PdfDictionary dictionary);
    private void ParseArray(PdfArray array);
    private Dictionary`2<string, PdfReferenceHolder> GetAnnotationObjects();
    private PdfName[] GetKeys(PdfDictionary dictionary);
    internal void ParseObjectTrailer();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Syncfusion.Pdf.Parsing.Glyph : object {
    [CompilerGeneratedAttribute]
private ushort <GlyphId>k__BackingField;
    [CompilerGeneratedAttribute]
private GlyphOutlinesCollection <Outlines>k__BackingField;
    [CompilerGeneratedAttribute]
private double <AdvancedWidth>k__BackingField;
    [CompilerGeneratedAttribute]
private Point <HorizontalKerning>k__BackingField;
    [CompilerGeneratedAttribute]
private Point <VerticalKerning>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Name>k__BackingField;
    internal ushort GlyphId { get; internal set; }
    public GlyphOutlinesCollection Outlines { get; public set; }
    public double AdvancedWidth { get; public set; }
    public Point HorizontalKerning { get; public set; }
    public Point VerticalKerning { get; public set; }
    public string Name { get; public set; }
    [CompilerGeneratedAttribute]
internal ushort get_GlyphId();
    [CompilerGeneratedAttribute]
internal void set_GlyphId(ushort value);
    [CompilerGeneratedAttribute]
public GlyphOutlinesCollection get_Outlines();
    [CompilerGeneratedAttribute]
public void set_Outlines(GlyphOutlinesCollection value);
    [CompilerGeneratedAttribute]
public double get_AdvancedWidth();
    [CompilerGeneratedAttribute]
public void set_AdvancedWidth(double value);
    [CompilerGeneratedAttribute]
public Point get_HorizontalKerning();
    [CompilerGeneratedAttribute]
public void set_HorizontalKerning(Point value);
    [CompilerGeneratedAttribute]
public Point get_VerticalKerning();
    [CompilerGeneratedAttribute]
public void set_VerticalKerning(Point value);
    [CompilerGeneratedAttribute]
public string get_Name();
    [CompilerGeneratedAttribute]
public void set_Name(string value);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class Syncfusion.Pdf.Parsing.ImportFormSettings : object {
    private DataFormat dataFormat;
    internal bool AsPerSpecification;
    private string formName;
    private bool ignoreErrors;
    public DataFormat DataFormat { get; public set; }
    public string FormName { get; public set; }
    public bool IgnoreErrors { get; public set; }
    public DataFormat get_DataFormat();
    public void set_DataFormat(DataFormat value);
    public string get_FormName();
    public void set_FormName(string value);
    public bool get_IgnoreErrors();
    public void set_IgnoreErrors(bool value);
}
[NullableContextAttribute("1")]
internal interface Syncfusion.Pdf.Parsing.ISystemFontBuildCharHolder {
    public abstract virtual Byte[] GetSubr(int index);
    public abstract virtual Byte[] GetGlobalSubr(int index);
    public abstract virtual SystemFontType1GlyphData GetGlyphData(string glyphName);
}
[NullableContextAttribute("1")]
internal interface Syncfusion.Pdf.Parsing.ISystemFontConverter {
    public abstract virtual object Convert(Type resultType, object value);
}
[NullableContextAttribute("1")]
internal interface Syncfusion.Pdf.Parsing.ISystemFontEncoding {
    public abstract virtual string GetGlyphName(SystemFontCFFFontFile file, ushort index);
}
internal interface Syncfusion.Pdf.Parsing.ISystemFontOrderedEnumerable`1 {
    [NullableContextAttribute("1")]
public abstract virtual ISystemFontOrderedEnumerable`1<TElement> CreateOrderedEnumerable(Func`2<TElement, TKey> keySelector, IComparer`1<TKey> comparer, bool descending);
}
[NullableContextAttribute("1")]
internal interface Syncfusion.Pdf.Parsing.ISystemFontProperty {
    public SystemFontPropertyDescriptor Descriptor { get; }
    public abstract virtual SystemFontPropertyDescriptor get_Descriptor();
    public abstract virtual bool SetValue(object value);
}
[NullableContextAttribute("1")]
internal interface Syncfusion.Pdf.Parsing.ISystemFontType1BuildCharHolder {
    public abstract virtual Byte[] GetSubr(int index);
    public abstract virtual Byte[] GetGlobalSubr(int index);
    public abstract virtual SystemFontGlyphData GetGlyphData(string glyphName);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Syncfusion.Pdf.Parsing.JsonDocument : object {
    private string pdfFilePath;
    private PdfLoadedDocument m_document;
    private bool m_skipBorderStyle;
    private Dictionary`2<string, string> table;
    private PdfExportAnnotationCollection m_annotationCollection;
    private int count;
    private bool flag;
    private string jsonData;
    private bool m_exportAppearance;
    internal PdfExportAnnotationCollection AnnotationCollection { get; internal set; }
    internal bool ExportAppearance { get; internal set; }
    internal JsonDocument(string filename);
    internal PdfExportAnnotationCollection get_AnnotationCollection();
    internal void set_AnnotationCollection(PdfExportAnnotationCollection value);
    internal bool get_ExportAppearance();
    internal void set_ExportAppearance(bool value);
    internal void ExportAnnotations(Stream stream, PdfLoadedDocument document);
    private void ExportAnnotationData(Stream stream, PdfLoadedAnnotation annotation, int index, int count);
    private void ExportAnnotationData(PdfLoadedDocument document, int pageCount, Stream stream);
    private void ExportAnnotationData(PdfLoadedAnnotation annotation, int pageIndex, PdfDictionary dictionary);
    private void WriteDictionary(PdfLoadedAnnotation annotation, int pageIndex, PdfDictionary dictionary, bool hasAppearance);
    private string GetAnnotationType(PdfDictionary dictionary);
    private void WriteAttribute(string key, IPdfPrimitive primitive, int p, PdfDictionary dictionary);
    private string GetValue(IPdfPrimitive primitive);
    private string GetValidString(string value);
    private string GetColor(IPdfPrimitive primitive);
    private string convertToJson(Dictionary`2<string, string> value);
    private string convertToJsonArray(PdfArray[] value);
    private void ExportMeasureDictionary(PdfDictionary dictionary);
    private void ExportMeasureFormatDetails(string key, PdfDictionary measurementDetails);
    private MemoryStream GetAppearanceString(IPdfPrimitive primitive);
    private void WriteAppearanceDictionary(Dictionary`2<string, string> textWriter, PdfDictionary dictionary);
    private void WriteObject(Dictionary`2<string, string> textWriter, string key, IPdfPrimitive primitive, List`1<Dictionary`2<string, string>> arrayWriter);
    private void WriteArray(List`1<Dictionary`2<string, string>> textWriter, PdfArray array);
    private string convertListToJson(List`1<Dictionary`2<string, string>> value);
    internal string GetJsonAppearanceString(IPdfPrimitive primitive);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Syncfusion.Pdf.Parsing.JsonParser : object {
    private PdfLoadedDocument m_document;
    private string annotation;
    private string beginLineStyle;
    private string endLineStyle;
    private string values;
    private bool isBasicStyle;
    private string style;
    private Dictionary`2<string, string> dataStream;
    private Dictionary`2<string, string> fields;
    private List`1<PdfDictionary> m_groupHolders;
    private Dictionary`2<string, PdfReferenceHolder> m_groupReferences;
    private bool m_isNormalAppearanceAdded;
    internal JsonParser(Stream stream, PdfLoadedDocument document);
    internal void ImportAnnotationData(Stream stream);
    private void parseAnnotationData(Dictionary`2<string, string> annotData);
    private PdfDictionary GetAnnotationData(string type, int pageindex, Dictionary`2<string, string> key_Value);
    private void AddAnnotationData(PdfDictionary annotDictionary, Dictionary`2<string, string> key_Value, int index);
    private string TrimEscapeCharacters(string value);
    private void AddStreamData(Dictionary`2<string, string> dataValues, PdfDictionary annotDictionary, string values);
    private void AddInt(PdfDictionary dictionary, string key, string value);
    private PdfLineEndingStyle MapLineEndingStyle(string style);
    private Single[] ObtainFloatPoints(string value);
    private PdfAnnotationFlags MapAnnotationFlags(string flag);
    private void AddFloatPoints(PdfDictionary dictionary, Single[] points, string key);
    private void AddFloatPoints(List`1<float> collection, string value);
    private void AddFloat(PdfDictionary dictionary, string key, string value);
    private void AddString(PdfDictionary dictionary, string key, string value);
    private void AddLinePoints(List`1<float> linePoints, string value);
    private Byte[] GetBytes(string hex);
    private void AddArrayElement(PdfArray array, IPdfPrimitive primitive);
    private string GetColor(IPdfPrimitive primitive);
    private PdfArray GetColorArray(string value);
    private void AddBorderStyle(string key, string value, PdfDictionary borderEffectDictionary, PdfDictionary borderStyleDictionary);
    private void AddReferenceToGroup(PdfReferenceHolder holder, PdfDictionary dictionary);
    private string getJsonObject(string token, string key, PdfReader reader);
    private void AddMeasureDictionary(PdfDictionary annotDictionary, Dictionary`2<string, string> element);
    private void AddElements(Dictionary`2<string, string> element, PdfDictionary dictionary);
    public Dictionary`2<string, string> AddDictionaryData(Dictionary`2<string, string> data, string value);
    private void AddAppearanceData(PdfDictionary dictionary, string value);
    internal IPdfPrimitive GetAppearanceStreamFromJson(string value);
    private IPdfPrimitive GetAppearanceData(Dictionary`2<string, object> dict);
    private object SplitJSONAppearance(string value);
    private Dictionary`2<string, object> SplitDictionaryItems(string json);
    private List`1<object> SplitArrayItems(string json);
    private string SplitSubStringJson(string json);
    private int GetIntFromJson(string json);
    private double GetFloatFromJson(string value);
    private List`1<string> ConvertToDictionaryItems(string value);
    private int AddChunkValues(bool escapeString, int index, string value, StringBuilder chunkBuilder);
    private IPdfPrimitive ParseDictionaryItems(object elementValue, IPdfPrimitive pdfPrimitive);
    private Byte[] GetStreamData(Dictionary`2<string, object> element);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class Syncfusion.Pdf.Parsing.MatchedItem : object {
    private string m_text;
    private int m_pageNumber;
    private RectangleF m_boundingBox;
    private Color m_textColor;
    public string Text { get; public set; }
    internal Color TextColor { get; internal set; }
    internal int PageNumber { get; internal set; }
    public RectangleF Bounds { get; public set; }
    public string get_Text();
    public void set_Text(string value);
    internal Color get_TextColor();
    internal void set_TextColor(Color value);
    internal int get_PageNumber();
    internal void set_PageNumber(int value);
    public RectangleF get_Bounds();
    public void set_Bounds(RectangleF value);
}
[NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public class Syncfusion.Pdf.Parsing.MatchedItemCollection : List`1<MatchedItem> {
}
internal class Syncfusion.Pdf.Parsing.NamespaceDoc : object {
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class Syncfusion.Pdf.Parsing.OnPdfPasswordEventArgs : object {
    private string m_userpassword;
    public string UserPassword { get; public set; }
    public string get_UserPassword();
    public void set_UserPassword(string value);
}
[NullableContextAttribute("1")]
[NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal class Syncfusion.Pdf.Parsing.OrderedEnumerable`2 : SystemFontOrderedEnumerable`1<TElement> {
    internal SystemFontOrderedEnumerable`1<TElement> parent;
    internal Func`2<TElement, TKey> keySelector;
    internal IComparer`1<TKey> comparer;
    internal bool descending;
    internal OrderedEnumerable`2(IEnumerable`1<TElement> source, Func`2<TElement, TKey> keySelector, IComparer`1<TKey> comparer, bool descending);
    internal virtual SystemFontEnumerableSorter`1<TElement> GetEnumerableSorter(SystemFontEnumerableSorter`1<TElement> next);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Syncfusion.Pdf.Parsing.Page : object {
    private static int c_ShadowWidth;
    private static int c_ShadowHeight;
    internal List`1<RectangleF> matchTextPositions;
    private PdfUnitConvertor m_unitConverter;
    private PdfPageResources m_resources;
    private PdfRecordCollection m_recordCollection;
    private PdfPageBase m_page;
    private int m_actualWidth;
    private int m_actualHeight;
    private RectangleF m_bounds;
    private double m_rotation;
    private string errorText;
    private bool _isRotationInitialized;
    private bool _isCropboxInitialized;
    private bool _isMediaboxInitialized;
    private RectangleF _cropboxRectangle;
    private RectangleF _mediaboxRectangle;
    public int CurrentLeftLocation;
    public int ActualWidth { get; }
    public int ActualHeight { get; }
    public RectangleF Bounds { get; public set; }
    public float Width { get; public set; }
    public float Height { get; public set; }
    internal double Rotation { get; }
    internal PdfPageResources Resources { get; }
    internal PdfRecordCollection RecordCollection { get; }
    internal RectangleF CropBox { get; }
    internal RectangleF MediaBox { get; }
    private static Page();
    public Page(PdfPageBase page);
    public int get_ActualWidth();
    public int get_ActualHeight();
    public RectangleF get_Bounds();
    public void set_Bounds(RectangleF value);
    public float get_Width();
    public void set_Width(float value);
    public float get_Height();
    public void set_Height(float value);
    internal double get_Rotation();
    internal PdfPageResources get_Resources();
    internal PdfRecordCollection get_RecordCollection();
    internal RectangleF get_CropBox();
    internal RectangleF get_MediaBox();
    internal void Initialize(PdfPageBase page, bool needParsing);
}
public class Syncfusion.Pdf.Parsing.PdfAConversionProgressEventArgs : object {
    internal float m_progressValue;
    public float ProgressValue { get; }
    public float get_ProgressValue();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class Syncfusion.Pdf.Parsing.PdfAnnotationExportSettings : object {
    private AnnotationDataFormat dataFormat;
    private bool exportAppearance;
    private PdfLoadedAnnotationType[] annotationType;
    public AnnotationDataFormat DataFormat { get; public set; }
    public bool ExportAppearance { get; public set; }
    internal PdfLoadedAnnotationType[] AnnotationTypes { get; public set; }
    public AnnotationDataFormat get_DataFormat();
    public void set_DataFormat(AnnotationDataFormat value);
    public bool get_ExportAppearance();
    public void set_ExportAppearance(bool value);
    internal PdfLoadedAnnotationType[] get_AnnotationTypes();
    public void set_AnnotationTypes(PdfLoadedAnnotationType[] value);
}
public enum Syncfusion.Pdf.Parsing.PdfCertificateField : Enum {
    public int value__;
    public static PdfCertificateField Subject;
    public static PdfCertificateField Issuer;
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class Syncfusion.Pdf.Parsing.PdfDocumentAnalyzer : object {
    private Stream m_stream;
    private string m_password;
    private List`1<PdfException> result;
    private List`1<long> parsedObjNum;
    public PdfDocumentAnalyzer(Stream stream);
    public PdfDocumentAnalyzer(Stream stream, string password);
    public SyntaxAnalyzerResult AnalyzeSyntax();
    private void ParseDictionary(PdfDictionary dictionary);
    private void ParseReferenceHolder(PdfReferenceHolder holder);
    private void ParseArray(PdfArray array);
    public void Close();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class Syncfusion.Pdf.Parsing.PdfDocumentSplitEventArgs : EventArgs {
    private Stream m_stream;
    public Stream PdfDocumentData { get; public set; }
    internal PdfDocumentSplitEventArgs(Stream doc);
    public Stream get_PdfDocumentData();
    public void set_PdfDocumentData(Stream value);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Syncfusion.Pdf.Parsing.PdfEncoding : object {
    private Regex regex;
    private Char[] pdfEncodingByteToChar;
    internal string ConvertUnicodeToString(string text);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[DefaultMemberAttribute("Item")]
public class Syncfusion.Pdf.Parsing.PdfExportAnnotationCollection : PdfCollection {
    public PdfLoadedAnnotation Item { get; }
    public PdfLoadedAnnotation get_Item(int index);
    public void Add(PdfLoadedAnnotation annotation);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Syncfusion.Pdf.Parsing.PdfFeatures : object {
    internal float m_zoomFactor;
    private PdfUnitConvertor m_unitConvertor;
    private DeviceCMYK m_cmyk;
    private MatchedItemCollection m_searchObjects;
    private Dictionary`2<int, string> m_pageTexts;
    private object m_lock;
    private int m_pageCount;
    private PdfLoadedDocument m_loadedDocument;
    internal string searchstring;
    private static double CHAR_SIZE_MULTIPLIER;
    private ArabicReshapeRenderer m_arabicReshapeRenderer;
    private bool m_wholeWords;
    internal bool continueOnError;
    private static int c_gapBetweenPages;
    private List`1<Page> pagesForTextSearch;
    private void LoadPagesForTextSearch(PdfLoadedDocument loadedDocument);
    internal bool FindText(PdfLoadedDocument loadedDocument, List`1<string> searchItems, int pageIndex, TextSearchOptions textSearchOption, List`1& searchResults);
    internal bool FindText(PdfLoadedDocument loadedDocument, List`1<string> listOfTerms, TextSearchOptions textSearchOption, TextSearchResultCollection& searchResult, bool isMultiThread);
    private bool GetSearchResults(TextSearchResultCollection& searchResult);
    private bool GetSearchResults(List`1& searchResult);
    internal bool FindText(PdfLoadedDocument loadedDocument, List`1<TextSearchItem> searchItems, int pageIndex, List`1& searchResults);
    internal bool FindText(PdfLoadedDocument loadedDocument, List`1<TextSearchItem> listOfTerms, TextSearchResultCollection& searchResult, bool isMultiThread);
    private void InvokeInParallel(Action[] actions);
    private bool CheckOverlapOrLarger(RectangleF thisRectangle, int thisPageNumber, List`1<MatchedItem> capturedTermList);
    private bool CheckOverlapOrLarger(RectangleF thisRectangle, int thisPageNumber, MatchedItemCollection capturedTermList);
    private void SearchInBackground(PdfLoadedDocument LoadedDocument, List`1<string> listOfTerms, TextSearchOptions textSearchOption, int startIndex, int endIndex);
    private void SearchInBackground(PdfLoadedDocument LoadedDocument, List`1<TextSearchItem> listOfTerms, int startIndex, int endIndex);
    internal bool SearchText(Page page, PdfLoadedDocument loadedDocument, int pageIndex, string searchText, List`1& texts);
    internal bool FindTextMatches(PdfLoadedDocument loadedDocument, string text, TextSearchOptions textSearchOption, int pageIndex, Dictionary`2& matchRect);
    private bool CheckGlyphBoundsArea(int targetTextIndex, List`1<Glyph> txtMatchs, TextSearchOptions textSearchOption, string text, int index);
    internal bool FindTextMatches(int pageIndex, PdfLoadedDocument loadedDocument, string text, TextSearchOptions textSearchoptions, List`1& matchRectangles);
    private List`1<string> GetMatchedTexts(string pageText, string text);
    private List`1<string> GetMatchedTexts(string pageText, List`1<string> searchText);
    private List`1<string> GetAllMatchedArabicText(List`1<Char[]> mapTable, int i, string renderedTerm, string pageText, List`1<string> searchTexts);
    internal bool FindTextMatches(PdfLoadedDocument loadedDocument, string text, Dictionary`2& matchTextPositionsDict);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class Syncfusion.Pdf.Parsing.PdfFontEventArgs : object {
    private Stream m_fontStream;
    internal string m_fontName;
    internal PdfFontStyle m_fontStyle;
    public Stream FontStream { get; public set; }
    public string FontName { get; }
    public PdfFontStyle FontStyle { get; }
    public Stream get_FontStream();
    public void set_FontStream(Stream value);
    public string get_FontName();
    public PdfFontStyle get_FontStyle();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[DefaultMemberAttribute("Item")]
public class Syncfusion.Pdf.Parsing.PdfLoadedAnnotationCollection : PdfAnnotationCollection {
    private PdfLoadedPage m_page;
    private bool m_flatten;
    public PdfAnnotation Item { get; }
    public PdfAnnotation Item { get; }
    public PdfLoadedPage Page { get; public set; }
    public bool Flatten { get; public set; }
    internal PdfLoadedAnnotationCollection(PdfLoadedPage page);
    public virtual PdfAnnotation get_Item(int index);
    public PdfAnnotation get_Item(string text);
    public PdfLoadedPage get_Page();
    public void set_Page(PdfLoadedPage value);
    public bool get_Flatten();
    public void set_Flatten(bool value);
    private void ldAnnotation_NameChanded(string name);
    public virtual int Add(PdfAnnotation annotation);
    private PdfPopupAnnotationCollection GetCommentsOrReview(PdfAnnotation annotation, bool isReview);
    private void DoAddComments(PdfAnnotation annotation);
    private void DoAddReviewHistory(PdfAnnotation annotation);
    private void DoAddState(PdfAnnotation popupAnnoataion);
    protected virtual int DoAdd(PdfAnnotation annot);
    internal bool LoadedAnnotation(PdfAnnotation annot);
    internal string GetCorrectName(string name);
    internal bool IsValidName(string name);
    private int GetAnnotationIndex(string text);
    private PdfAnnotation GetAnnotation(int index);
    private void SetAnnotationType(PdfAnnotation annotation, PdfLoadedAnnotationType type);
    internal PdfLoadedAnnotationType GetAnnotationType(PdfName name, PdfDictionary dictionary, PdfCrossTable crossTable);
    private PdfAnnotation CreateFileRemoteGoToLinkAnnotation(PdfDictionary dictionary, PdfCrossTable crossTable, PdfString fileName, PdfArray destination, RectangleF rect);
    private PdfAnnotation CreateTextWebLinkAnnotation(PdfDictionary dictionary, PdfCrossTable crossTable, string text);
    private PdfAnnotation CreateDocumentLinkAnnotation(PdfDictionary dictionary, PdfCrossTable crossTable, RectangleF rect);
    private PdfAnnotation CreateFileLinkAnnotation(PdfDictionary dictionary, PdfCrossTable crossTable, RectangleF rect, string filename);
    private PdfAnnotation CreateWidgetAnnotation(PdfDictionary dictionary, PdfCrossTable crossTable, RectangleF rect);
    private PdfAnnotation CreateInkAnnotation(PdfDictionary dictionary, PdfCrossTable crossTable, RectangleF rect);
    private PdfAnnotation CreateWatermarkAnnotation(PdfDictionary dictionary, PdfCrossTable crossTable, RectangleF rect);
    private PdfAnnotation CreateRichMediaAnnotation(PdfDictionary dictionary, PdfCrossTable crossTable, RectangleF rect);
    private PdfAnnotation CreateTrapNetworkAnnotation(PdfDictionary dictionary, PdfCrossTable crossTable, RectangleF rect);
    private PdfAnnotation CreateTextMarkupAnnotation(PdfDictionary dictionary, PdfCrossTable crossTable);
    private PdfAnnotation CreateTextAnnotation(PdfDictionary dictionary, PdfCrossTable crossTable);
    private PdfAnnotation CreateSoundAnnotation(PdfDictionary dictionary, PdfCrossTable crossTable, RectangleF rect);
    private PdfAnnotation CreateScreenAnnotation(PdfDictionary dictionary, PdfCrossTable crossTable, RectangleF rect);
    private PdfAnnotation CreateRubberStampAnnotation(PdfDictionary dictionary, PdfCrossTable crossTable, RectangleF rect, string text);
    private PdfAnnotation CreatePrinterMarkAnnotation(PdfDictionary dictionary, PdfCrossTable crossTable, RectangleF rect);
    private PdfAnnotation CreatePopupAnnotation(PdfDictionary dictionary, PdfCrossTable crossTable, RectangleF rect, string text);
    private PdfAnnotation CreateMovieAnnotation(PdfDictionary dictionary, PdfCrossTable crossTable, RectangleF rect);
    private PdfAnnotation CreateMarkupAnnotation(PdfDictionary dictionary, PdfCrossTable crossTable, RectangleF rect);
    private PdfAnnotation CreateLinkAnnotation(PdfDictionary dictionary, PdfCrossTable crossTable, RectangleF rect, string text);
    private PdfAnnotation CreateLineAnnotation(PdfDictionary dictionary, PdfCrossTable crossTable, RectangleF rect, string text);
    private PdfAnnotation CreateCircleAnnotation(PdfDictionary dictionary, PdfCrossTable crossTable, RectangleF rect, string text);
    private PdfAnnotation CreateEllipseAnnotation(PdfDictionary dictionary, PdfCrossTable crossTable, RectangleF rectangle, string text);
    private PdfAnnotation CreateSquareAnnotation(PdfDictionary dictionary, PdfCrossTable crossTable, RectangleF rectangle, string text);
    private PdfAnnotation CreateRectangleAnnotation(PdfDictionary dictionary, PdfCrossTable crossTable, RectangleF rectangle, string text);
    private PdfAnnotation CreatePolygonAnnotation(PdfDictionary dictionary, PdfCrossTable crossTable, RectangleF rectangle, string text);
    private PdfAnnotation CreatePolyLineAnnotation(PdfDictionary dictionary, PdfCrossTable crossTable, RectangleF rectangle, string text);
    private PdfAnnotation CreateFreeTextAnnotation(PdfDictionary dictionary, PdfCrossTable crossTable, RectangleF rect, string text);
    private PdfAnnotation CreateRedactionAnnotation(PdfDictionary dictionary, PdfCrossTable crossTable);
    private PdfAnnotation CreateFileAttachmentAnnotation(PdfDictionary dictionary, PdfCrossTable crossTable, RectangleF rect, string filename);
    private PdfAnnotation CreateCaretAnnotation(PdfDictionary dictionary, PdfCrossTable crossTable, RectangleF rect);
    protected virtual void DoInsert(int index, PdfAnnotation annot);
    protected virtual void DoClear();
    protected virtual void DoRemoveAt(int index);
    protected virtual void DoRemove(PdfAnnotation annot);
    internal bool FindAnnotation(PdfArray arr);
    internal PdfArray Rearrange(PdfReference reference, int tabIndex, int index);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class Syncfusion.Pdf.Parsing.PdfLoadedButtonField : PdfLoadedStyledField {
    private PdfLoadedButtonItemCollection m_items;
    public bool ComplexScript { get; public set; }
    public string Text { get; public set; }
    public PdfLoadedButtonItemCollection Items { get; internal set; }
    internal PdfLoadedButtonField(PdfDictionary dictionary, PdfCrossTable crossTable);
    public bool get_ComplexScript();
    public void set_ComplexScript(bool value);
    public string get_Text();
    public void set_Text(string value);
    public PdfLoadedButtonItemCollection get_Items();
    internal void set_Items(PdfLoadedButtonItemCollection value);
    private string ObtainText();
    private void AssignText(string value);
    internal virtual void Draw();
    internal virtual void BeginSave();
    internal PdfField Clone(PdfDictionary dictionary, PdfPage page);
    internal PdfLoadedStyledField Clone();
    internal virtual PdfLoadedFieldItem CreateLoadedItem(PdfDictionary dictionary);
    private void ApplyAppearance(PdfDictionary widget, PdfLoadedFieldItem item);
    private void DrawButton(PdfGraphics graphics, PdfLoadedFieldItem item);
    internal virtual float GetFontHeight(PdfFontFamily family);
    public void AddPrintAction();
    public void RemoveAt(int index);
    public void Remove(PdfLoadedButtonItem item);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class Syncfusion.Pdf.Parsing.PdfLoadedButtonItem : PdfLoadedFieldItem {
    internal PdfLoadedButtonItem(PdfLoadedStyledField field, int index, PdfDictionary dictionary);
    internal PdfLoadedButtonItem Clone();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[DefaultMemberAttribute("Item")]
public class Syncfusion.Pdf.Parsing.PdfLoadedButtonItemCollection : PdfCollection {
    public PdfLoadedButtonItem Item { get; }
    public PdfLoadedButtonItem get_Item(int index);
    internal void Add(PdfLoadedButtonItem item);
    internal int Remove(PdfLoadedButtonItem item);
    internal PdfLoadedButtonItemCollection Clone();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class Syncfusion.Pdf.Parsing.PdfLoadedCheckBoxField : PdfLoadedStateField {
    private static string CHECK_SYMBOL;
    public bool Checked { get; public set; }
    public PdfColor BackColor { get; public set; }
    public PdfColor ForeColor { get; public set; }
    public PdfCheckBoxStyle Style { get; public set; }
    public PdfLoadedCheckBoxItemCollection Items { get; internal set; }
    internal PdfLoadedCheckBoxField(PdfDictionary dictionary, PdfCrossTable crossTable);
    public bool get_Checked();
    public void set_Checked(bool value);
    public PdfColor get_BackColor();
    public void set_BackColor(PdfColor value);
    public PdfColor get_ForeColor();
    public void set_ForeColor(PdfColor value);
    public PdfCheckBoxStyle get_Style();
    public void set_Style(PdfCheckBoxStyle value);
    public PdfLoadedCheckBoxItemCollection get_Items();
    internal void set_Items(PdfLoadedCheckBoxItemCollection value);
    internal virtual PdfLoadedStateItem GetItem(int index, PdfDictionary itemDictionary);
    internal virtual void Draw();
    internal virtual void BeginSave();
    internal PdfField Clone(PdfDictionary dictionary, PdfPage page);
    internal PdfLoadedStyledField Clone();
    internal virtual PdfLoadedFieldItem CreateLoadedItem(PdfDictionary dictionary);
    public void RemoveAt(int index);
    public void Remove(PdfLoadedCheckBoxItem item);
    public bool TryGetFieldItem(string exportValue, PdfLoadedCheckBoxItem& field);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class Syncfusion.Pdf.Parsing.PdfLoadedCheckBoxItem : PdfLoadedStateItem {
    private string exportValue;
    public PdfCheckBoxStyle Style { get; public set; }
    public string ExportValue { get; }
    internal PdfLoadedCheckBoxItem(PdfLoadedStyledField field, int index, PdfDictionary dictionary);
    public PdfCheckBoxStyle get_Style();
    public void set_Style(PdfCheckBoxStyle value);
    public string get_ExportValue();
    private void SetCheckedStatus(bool value);
    internal PdfLoadedCheckBoxItem Clone();
    private string TryGetExportValue();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[DefaultMemberAttribute("Item")]
public class Syncfusion.Pdf.Parsing.PdfLoadedCheckBoxItemCollection : PdfLoadedStateItemCollection {
    public PdfLoadedCheckBoxItem Item { get; }
    public PdfLoadedCheckBoxItem get_Item(int index);
    internal int IndexOf(PdfLoadedCheckBoxItem item);
    internal void Add(PdfLoadedCheckBoxItem item);
    internal int Remove(PdfLoadedCheckBoxItem item);
    internal PdfLoadedCheckBoxItemCollection Clone();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class Syncfusion.Pdf.Parsing.PdfLoadedChoiceField : PdfLoadedStyledField {
    public PdfLoadedListItemCollection Values { get; }
    public Int32[] SelectedIndex { get; public set; }
    public String[] SelectedValue { get; public set; }
    public PdfLoadedListItemCollection SelectedItem { get; }
    public PdfColor BackColor { get; public set; }
    public PdfColor ForeColor { get; public set; }
    internal PdfLoadedChoiceField(PdfDictionary dictionary, PdfCrossTable crossTable);
    public PdfLoadedListItemCollection get_Values();
    public Int32[] get_SelectedIndex();
    public void set_SelectedIndex(Int32[] value);
    public String[] get_SelectedValue();
    public void set_SelectedValue(String[] value);
    public PdfLoadedListItemCollection get_SelectedItem();
    public PdfColor get_BackColor();
    public void set_BackColor(PdfColor value);
    public PdfColor get_ForeColor();
    public void set_ForeColor(PdfColor value);
    protected Int32[] ObtainSelectedIndex();
    protected void AssignSelectedIndex(Int32[] value);
    protected String[] ObtainSelectedValue();
    protected void AssignSelectedValue(String[] values);
    internal PdfLoadedListItemCollection GetListItemCollection();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class Syncfusion.Pdf.Parsing.PdfLoadedComboBoxField : PdfLoadedChoiceField {
    private PdfLoadedComboBoxItemCollection m_items;
    public bool ComplexScript { get; public set; }
    internal bool IsAutoFontSize { get; }
    public bool Editable { get; public set; }
    public PdfLoadedComboBoxItemCollection Items { get; internal set; }
    public int SelectedIndex { get; public set; }
    public string SelectedValue { get; public set; }
    internal PdfLoadedComboBoxField(PdfDictionary dictionary, PdfCrossTable crossTable);
    public bool get_ComplexScript();
    public void set_ComplexScript(bool value);
    internal bool get_IsAutoFontSize();
    public bool get_Editable();
    public void set_Editable(bool value);
    public PdfLoadedComboBoxItemCollection get_Items();
    internal void set_Items(PdfLoadedComboBoxItemCollection value);
    public int get_SelectedIndex();
    public void set_SelectedIndex(int value);
    public string get_SelectedValue();
    public void set_SelectedValue(string value);
    internal virtual void Draw();
    internal virtual void BeginSave();
    internal PdfField Clone(PdfDictionary dictionary, PdfPage page);
    internal PdfLoadedStyledField Clone();
    internal virtual PdfLoadedFieldItem CreateLoadedItem(PdfDictionary dictionary);
    private void ApplyAppearance(PdfDictionary widget, PdfLoadedFieldItem item);
    private void DrawComboBox(PdfGraphics graphics, PdfLoadedFieldItem item);
    private void DrawComboBox(PdfGraphics graphics, PdfLoadedFieldItem item, string text);
    private void SetFittingFontSize(GraphicsProperties& gp, PaintParams prms, string text);
    internal virtual float GetFontHeight(PdfFontFamily family);
    public void RemoveAt(int index);
    public void Remove(PdfLoadedComboBoxItem item);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class Syncfusion.Pdf.Parsing.PdfLoadedComboBoxItem : PdfLoadedFieldItem {
    internal PdfLoadedComboBoxItem(PdfLoadedStyledField field, int index, PdfDictionary dictionary);
    internal PdfLoadedComboBoxItem Clone();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[DefaultMemberAttribute("Item")]
public class Syncfusion.Pdf.Parsing.PdfLoadedComboBoxItemCollection : PdfCollection {
    public PdfLoadedComboBoxItem Item { get; }
    public PdfLoadedComboBoxItem get_Item(int index);
    internal void Add(PdfLoadedComboBoxItem item);
    internal int Remove(PdfLoadedComboBoxItem item);
    internal PdfLoadedComboBoxItemCollection Clone();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class Syncfusion.Pdf.Parsing.PdfLoadedDocument : PdfDocumentBase {
    internal bool m_duplicatePage;
    internal int m_duplicatePageIndex;
    internal bool m_duplicateAcroform;
    internal string m_password;
    internal Stream m_stream;
    private bool m_bWasEncrypted;
    private bool m_isPdfViewerDocumentDisable;
    private PdfLoadedForm m_form;
    private PdfLoadedPageCollection m_pages;
    private PdfBookmarkBase m_bookmark;
    private PdfNamedDestinationCollection m_namedDestinations;
    private bool m_bCloseStream;
    private bool m_isDisposed;
    internal PdfDocumentInformation m_documentInfo;
    private MemoryStream m_internalStream;
    private PdfColorSpace m_colorSpace;
    private PdfAttachmentCollection m_attachments;
    private string password;
    private PdfPageLabel m_pageLabel;
    private PdfLoadedPageLabelCollection m_pageLabelCollection;
    private bool isPageLabel;
    private bool m_isXFAForm;
    private bool m_isExtendedFeatureEnabled;
    internal string m_fileName;
    private PdfConformanceLevel m_conformance;
    private bool isLinearized;
    private bool isPortfolio;
    private List`1<long> unRepeatedReferenceCollections;
    internal bool m_isXfaDocument;
    private PdfPortfolioInformation m_portfolio;
    private static Stream m_openStream;
    internal List`1<PdfLoadedAnnotationType> annotationsTypeToBeIgnored;
    private bool isDispose;
    private bool isParsedForm;
    internal bool isOpenAndRepair;
    private int acroformFieldscount;
    private bool m_isOpenAndRepair;
    internal bool m_isNamedDestinationCall;
    internal bool IsSkipSaving;
    private bool isAttachmentOnlyEncryption;
    internal bool isCompressPdf;
    private PdfPageTemplateCollection m_pageTemplatesCollection;
    private bool m_enableInitialLoadingOptimization;
    internal Dictionary`2<string, string> currentFont;
    internal Dictionary`2<long, PdfFont> font;
    private DublinCoreSchema m_dublinschema;
    private Dictionary`2<PdfPageBase, object> m_bookmarkHashtable;
    internal bool IsOcredDocument;
    internal bool ConformanceEnabled;
    internal PdfConformanceLevel m_previousConformance;
    internal List`1<PdfLoadedPage> m_redactionPages;
    internal List`1<PdfException> pdfException;
    internal bool validateSyntax;
    private bool m_isOptimizeIdentical;
    private PdfDocumentBase m_destinationDocument;
    private bool m_isExtendMargin;
    private bool isRedacted;
    private bool isConformanceApplied;
    internal List`1<PdfAnnotation> m_redactAnnotationCollection;
    private PdfAnnotationExportSettings annotationExportSettings;
    private bool m_isAllFontsEmbedded;
    internal PdfConformanceLevel existingConformanceLevel;
    private bool importCustomData;
    private PdfStructureElement m_structTreeRoot;
    private int m_elementOrder;
    private List`1<PdfRevision> m_revisions;
    private bool m_splitPDF;
    private bool m_mergePDF;
    private bool m_removeUnusedResourceSplit;
    private PdfDocumentSecureStore m_documentSecureStore;
    internal bool m_isPageMerging;
    [CompilerGeneratedAttribute]
private OnPdfPasswordEventHandler OnPdfPassword;
    [CompilerGeneratedAttribute]
private RedactionProgressEventHandler RedactionProgress;
    [CompilerGeneratedAttribute]
private PdfAConversionProgressEventHandler PdfAConversionProgress;
    [CompilerGeneratedAttribute]
private PdfFontEventHandler SubstituteFont;
    [CompilerGeneratedAttribute]
private PdfDocumentSplitEventHandler DocumentSplitEvent;
    private PdfFeatures feature;
    private PdfDocumentActions m_actions;
    internal bool IsXFAForm { get; internal set; }
    internal bool IsPDFSplit { get; internal set; }
    internal bool IsUnusedResourceSplit { get; internal set; }
    internal bool IsPDFMerge { get; internal set; }
    public bool IsExtendedFeatureEnabled { get; }
    internal bool EnableInitialLoadingOptimization { get; internal set; }
    internal DublinCoreSchema DublinSchema { get; internal set; }
    public PdfPageLabel LoadedPageLabel { get; public set; }
    internal string Password { get; internal set; }
    public PdfDocumentActions Actions { get; }
    public PdfAttachmentCollection Attachments { get; }
    public PdfPortfolioInformation PortfolioInformation { get; public set; }
    public PdfColorSpace ColorSpace { get; public set; }
    public PdfLoadedForm Form { get; }
    public PdfLoadedPageCollection Pages { get; }
    public PdfBookmarkBase Bookmarks { get; }
    public PdfNamedDestinationCollection NamedDestinationCollection { get; }
    public PdfPageTemplateCollection PdfPageTemplates { get; }
    public int PageCount { get; }
    public PdfConformanceLevel Conformance { get; public set; }
    public bool IsLinearized { get; }
    public bool IsPortfolio { get; }
    internal bool IsOptimizeIdentical { get; internal set; }
    internal PdfDocumentBase DestinationDocument { get; internal set; }
    internal bool IsExtendMargin { get; internal set; }
    internal bool ImportCustomData { get; internal set; }
    public PdfStructureElement StructureElement { get; }
    public PdfRevision[] Revisions { get; }
    public PdfDocumentSecureStore DocumentSecureStore { get; }
    internal bool RaiseUserPassword { get; }
    internal bool RaiseTrackRedactionProgress { get; }
    internal bool RaiseTrackPdfAConversionProgress { get; }
    internal bool RaisePdfFont { get; }
    public PdfDocumentInformation DocumentInformation { get; }
    internal bool IsPdfViewerDocumentDisable { get; internal set; }
    internal bool WasEncrypted { get; }
    public bool IsEncrypted { get; }
    public PdfLoadedDocument(Byte[] file);
    public PdfLoadedDocument(Byte[] file, bool openAndRepair);
    public PdfLoadedDocument(Byte[] file, string password);
    public PdfLoadedDocument(Byte[] file, string password, bool openAndRepair);
    public PdfLoadedDocument(Stream file);
    public PdfLoadedDocument(Stream file, bool openAndRepair);
    internal PdfLoadedDocument(Stream file, bool openAndRepair, bool isXfaDocument);
    public PdfLoadedDocument(Stream file, string password);
    public PdfLoadedDocument(Stream file, string password, bool openAndRepair);
    internal PdfLoadedDocument(Stream file, string password, bool openAndRepair, bool isXfaDocument);
    internal PdfLoadedDocument(Stream file, string password, List`1& exceptions);
    internal bool get_IsXFAForm();
    internal void set_IsXFAForm(bool value);
    internal bool get_IsPDFSplit();
    internal void set_IsPDFSplit(bool value);
    internal bool get_IsUnusedResourceSplit();
    internal void set_IsUnusedResourceSplit(bool value);
    internal bool get_IsPDFMerge();
    internal void set_IsPDFMerge(bool value);
    public bool get_IsExtendedFeatureEnabled();
    internal bool get_EnableInitialLoadingOptimization();
    internal void set_EnableInitialLoadingOptimization(bool value);
    internal DublinCoreSchema get_DublinSchema();
    internal void set_DublinSchema(DublinCoreSchema value);
    public PdfPageLabel get_LoadedPageLabel();
    public void set_LoadedPageLabel(PdfPageLabel value);
    internal string get_Password();
    internal void set_Password(string value);
    public PdfDocumentActions get_Actions();
    public PdfAttachmentCollection get_Attachments();
    public void set_PortfolioInformation(PdfPortfolioInformation value);
    public PdfPortfolioInformation get_PortfolioInformation();
    public PdfColorSpace get_ColorSpace();
    public void set_ColorSpace(PdfColorSpace value);
    public PdfLoadedForm get_Form();
    public PdfLoadedPageCollection get_Pages();
    public virtual PdfBookmarkBase get_Bookmarks();
    public PdfNamedDestinationCollection get_NamedDestinationCollection();
    public PdfPageTemplateCollection get_PdfPageTemplates();
    public virtual int get_PageCount();
    public PdfConformanceLevel get_Conformance();
    public void set_Conformance(PdfConformanceLevel value);
    public bool get_IsLinearized();
    public bool get_IsPortfolio();
    public void RemoveConformance();
    internal bool get_IsOptimizeIdentical();
    internal void set_IsOptimizeIdentical(bool value);
    internal PdfDocumentBase get_DestinationDocument();
    internal void set_DestinationDocument(PdfDocumentBase value);
    internal bool get_IsExtendMargin();
    internal void set_IsExtendMargin(bool value);
    internal bool get_ImportCustomData();
    internal void set_ImportCustomData(bool value);
    public PdfStructureElement get_StructureElement();
    public PdfRevision[] get_Revisions();
    public PdfDocumentSecureStore get_DocumentSecureStore();
    protected virtual override void Finalize();
    [CompilerGeneratedAttribute]
public void add_OnPdfPassword(OnPdfPasswordEventHandler value);
    [CompilerGeneratedAttribute]
public void remove_OnPdfPassword(OnPdfPasswordEventHandler value);
    internal bool get_RaiseUserPassword();
    internal void PdfUserPassword(OnPdfPasswordEventArgs args);
    [CompilerGeneratedAttribute]
public void add_RedactionProgress(RedactionProgressEventHandler value);
    [CompilerGeneratedAttribute]
public void remove_RedactionProgress(RedactionProgressEventHandler value);
    internal bool get_RaiseTrackRedactionProgress();
    internal void OnTrackProgress(RedactionProgressEventArgs arguments);
    [CompilerGeneratedAttribute]
public void add_PdfAConversionProgress(PdfAConversionProgressEventHandler value);
    [CompilerGeneratedAttribute]
public void remove_PdfAConversionProgress(PdfAConversionProgressEventHandler value);
    internal bool get_RaiseTrackPdfAConversionProgress();
    internal void OnPdfAConversionTrackProgress(PdfAConversionProgressEventArgs arguments);
    [CompilerGeneratedAttribute]
public void add_SubstituteFont(PdfFontEventHandler value);
    [CompilerGeneratedAttribute]
public void remove_SubstituteFont(PdfFontEventHandler value);
    internal bool get_RaisePdfFont();
    internal void PdfFontStream(PdfFontEventArgs args);
    [CompilerGeneratedAttribute]
public void add_DocumentSplitEvent(PdfDocumentSplitEventHandler value);
    [CompilerGeneratedAttribute]
public void remove_DocumentSplitEvent(PdfDocumentSplitEventHandler value);
    private static Stream CreateStream(Byte[] file);
    public bool FindText(string text, int index, List`1& matchRect);
    internal bool FindText(string text, int index, TextSearchOptions textSearchOption, List`1& matchRect);
    public bool FindText(string text, Dictionary`2& matchRect);
    public bool FindText(List`1<string> searchItems, TextSearchResultCollection& searchResult);
    public bool FindText(List`1<string> searchItems, int pageIndex, List`1& searchResults);
    public bool FindText(List`1<TextSearchItem> searchItems, TextSearchResultCollection& searchResult);
    public bool FindText(List`1<TextSearchItem> searchItems, int pageIndex, List`1& searchResults);
    public bool FindText(List`1<string> searchItems, TextSearchOptions textSearchOption, TextSearchResultCollection& searchResult);
    public bool FindText(List`1<string> searchItems, int pageIndex, TextSearchOptions textSearchOption, List`1& searchResults);
    public bool FindText(List`1<string> searchItems, TextSearchResultCollection& searchResult, bool enableMultiThreading);
    public bool FindText(List`1<TextSearchItem> searchItems, TextSearchResultCollection& searchResult, bool enableMultiThreading);
    public bool FindText(List`1<string> searchItems, TextSearchOptions textSearchOption, TextSearchResultCollection& searchResult, bool enableMultiThreading);
    public void SplitByFixedNumber(int numberToSplit);
    public void SplitByFixedNumber(int numberToSplit, PdfSplitOptions splitOptions);
    public void SplitByRanges(Int32[0...,0...] ranges);
    public void SplitByRanges(Int32[0...,0...] ranges, PdfSplitOptions splitOptions);
    internal void ImportDocumentPages(int startIndex, int endIndex, string destFilePattern, int docNum);
    public void CreateForm();
    public PdfAttachmentCollection CreateAttachment();
    public PdfBookmarkBase CreateBookmarkRoot();
    private PdfNamedDestinationCollection CreateNamedDestinations();
    private PdfPageTemplateCollection CreatePageTemplates();
    private void RemovePDFConformanceInfo();
    private string CheckLicense();
    public virtual void Save(Stream stream);
    private void AddWatermark();
    internal virtual void AddFields(PdfLoadedDocument ldDoc, PdfPageBase newPage, List`1<PdfField> fields);
    internal virtual PdfPageBase ClonePage(PdfLoadedDocument ldDoc, PdfPageBase page, List`1<PdfArray> destinations);
    public virtual PdfDocumentInformation get_DocumentInformation();
    internal virtual PdfForm ObtainForm();
    public sealed virtual void Dispose();
    private void Dispose(bool dispose);
    public virtual void Close(bool completely);
    public object Clone();
    internal PdfConformanceLevel GetDocumentConformance(PdfConformanceLevel m_conformance);
    private PdfConformanceLevel GetConformanceLevel(string conformanceValue, Boolean& found);
    internal void PageLabel();
    internal void UpdateFormFields();
    internal virtual bool get_IsPdfViewerDocumentDisable();
    internal virtual void set_IsPdfViewerDocumentDisable(bool value);
    internal virtual bool get_WasEncrypted();
    public bool get_IsEncrypted();
    internal Dictionary`2<PdfPageBase, object> CreateBookmarkDestinationDictionary();
    internal PdfArray GetNamedDestination(PdfName name);
    internal PdfArray GetNamedDestination(PdfString name);
    private static PdfArray ExtractDestination(IPdfPrimitive obj);
    private void LoadDocument(Stream file);
    private void CheckIfTagged();
    private void ReadFileVersion();
    private void SetFileVersion(string token);
    private PdfCatalog GetCatalogValue();
    private void CheckNeedAppearence(PdfDictionary dictionary);
    internal void ReadDocumentInfo();
    internal bool CheckEncryption(bool isAttachEncryption);
    private PdfDictionary GetFormDictionary();
    private PdfDictionary GetAttachmentDictionary();
    private PdfDictionary GetPortfolioDictionary();
    private void AppendDocument(PdfWriter writer);
    private void CopyOldStream(PdfWriter writer);
    private Stream CheckIfValid(Stream file);
    private bool CheckLinearization();
    public void FlattenAnnotations();
    public void FlattenAnnotations(bool flattenPopups);
    internal void FlattenAnnotations(List`1<PdfLoadedAnnotationType> annotsTypeToBeIgnored);
    public bool ExportAnnotations(Stream stream, AnnotationDataFormat format);
    public bool ExportAnnotations(Stream stream, PdfAnnotationExportSettings settings);
    public bool ExportAnnotations(Stream stream, AnnotationDataFormat format, string targetFilePath);
    public bool ExportAnnotations(Stream stream, AnnotationDataFormat format, PdfExportAnnotationCollection collection);
    public bool ExportAnnotations(Stream stream, AnnotationDataFormat format, string targetFilePath, PdfExportAnnotationCollection collection);
    private void ExportAnnotationsXFDF(Stream stream, string fileName);
    private void ExportAnnotationsJSON(Stream stream, string fileName);
    private void ExportAnnotationsJSON(Stream stream, string fileName, PdfExportAnnotationCollection collection);
    private void ExportAnnotationsXFDF(Stream stream, string fileName, PdfExportAnnotationCollection collection);
    private bool ExportAnnotationsFDF(PdfWriter writer, string fileName, PdfExportAnnotationCollection collection);
    public void ImportAnnotations(Stream stream, AnnotationDataFormat format);
    internal void ImportAnnotations(Stream stream, AnnotationDataFormat format, bool importCustomData);
    private void DecryptDocumentInfo(PdfDictionary info, PdfReference infoReference);
    private PdfStructureElement GetStructTreeRoot();
    internal PdfStructureElement GetStructTreeRoot(PdfDictionary root);
    private bool IsSingleRootElement(PdfDictionary structureDictionary);
    private PdfStructureElement GetStructureElement(PdfDictionary structureDictionary, PdfStructureElement parent);
    private void GetRevisions();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[DefaultMemberAttribute("Item")]
public class Syncfusion.Pdf.Parsing.PdfLoadeddStateItemCollection : PdfCollection {
    public PdfLoadedStateItem Item { get; }
    public PdfLoadedStateItem get_Item(int index);
    internal int IndexOf(PdfLoadedStateItem item);
    internal void Add(PdfLoadedStateItem item);
    internal int Remove(PdfLoadedStateItem item);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public abstract class Syncfusion.Pdf.Parsing.PdfLoadedField : PdfField {
    public int ObjectID;
    private PdfCrossTable m_crossTable;
    private bool m_Changed;
    private bool m_fieldChanged;
    internal int m_defaultIndex;
    private string m_name;
    private PdfPageBase m_page;
    private PdfLoadedForm m_form;
    internal bool ExportEmptyField;
    internal PdfReferenceHolder m_requiredReference;
    internal bool isAcrobat;
    private List`1<string> selectedList;
    [CompilerGeneratedAttribute]
private BeforeNameChangesEventHandler BeforeNameChanges;
    public string Name { get; }
    public string MappingName { get; public set; }
    public string ToolTip { get; public set; }
    public PdfPageBase Page { get; internal set; }
    public bool ReadOnly { get; public set; }
    public bool Required { get; public set; }
    public bool Export { get; public set; }
    internal FieldFlags Flags { get; internal set; }
    internal string ActualFieldName { get; }
    public PdfForm Form { get; }
    internal PdfCrossTable CrossTable { get; internal set; }
    internal PdfDictionary Parent { get; }
    internal bool Changed { get; internal set; }
    internal bool FieldChanged { get; internal set; }
    internal int DefaultIndex { get; internal set; }
    internal PdfLoadedField(PdfDictionary dictionary, PdfCrossTable crossTable);
    [CompilerGeneratedAttribute]
internal void add_BeforeNameChanges(BeforeNameChangesEventHandler value);
    [CompilerGeneratedAttribute]
internal void remove_BeforeNameChanges(BeforeNameChangesEventHandler value);
    public virtual string get_Name();
    public virtual string get_MappingName();
    public virtual void set_MappingName(string value);
    public virtual string get_ToolTip();
    public virtual void set_ToolTip(string value);
    public virtual PdfPageBase get_Page();
    internal virtual void set_Page(PdfPageBase value);
    public virtual bool get_ReadOnly();
    public virtual void set_ReadOnly(bool value);
    public virtual bool get_Required();
    public virtual void set_Required(bool value);
    public virtual bool get_Export();
    public virtual void set_Export(bool value);
    internal virtual FieldFlags get_Flags();
    internal virtual void set_Flags(FieldFlags value);
    internal string get_ActualFieldName();
    public PdfForm get_Form();
    internal PdfCrossTable get_CrossTable();
    internal void set_CrossTable(PdfCrossTable value);
    internal PdfDictionary get_Parent();
    internal bool get_Changed();
    internal void set_Changed(bool value);
    internal bool get_FieldChanged();
    internal void set_FieldChanged(bool value);
    internal int get_DefaultIndex();
    internal void set_DefaultIndex(int value);
    public void SetName(string name);
    internal static IPdfPrimitive SearchInParents(PdfDictionary dictionary, PdfCrossTable crossTable, string value);
    internal static IPdfPrimitive GetValue(PdfDictionary dictionary, PdfCrossTable crossTable, string value, bool inheritable);
    internal PdfDictionary GetWidgetAnnotation(PdfDictionary dictionary, PdfCrossTable crossTable);
    private PdfArray ObtainKids();
    private PdfArray ObtainKids(PdfDictionary dictionary);
    private PdfArray RecursiveCall(PdfArray kids);
    internal List`1<PdfDictionary> GetWidgetAnnotations(PdfDictionary dictionary, PdfCrossTable crossTable);
    internal PdfHighlightMode GetHighLight(PdfDictionary dictionary, PdfCrossTable crossTable);
    internal abstract virtual void Draw();
    internal abstract virtual PdfLoadedFieldItem CreateLoadedItem(PdfDictionary dictionary);
    internal virtual void ApplyName(string name);
    internal virtual void BeginSave();
    private PdfPageBase GetLoadedPage();
    private PdfPageBase FindWidgetPageReference(PdfDictionary widget, PdfLoadedDocument doc);
    internal void ExportField(XmlWriter textWriter);
    internal void ExportField(XmlWriter textWriter, Dictionary`2<object, object> table, string uniquekey);
    private string HexToString(string text);
    private string ReplaceCRtoLF(string value);
    private string ReverseLFtoCR(string value);
    internal string GetExportValue(PdfLoadedField field, IPdfPrimitive buttonFieldPrimitive);
    private object GetMultipleSelectedItems(PdfLoadedField field, IPdfPrimitive buttonFieldPrimitive);
    internal string GetAppearanceStateValue(PdfLoadedField field);
    internal void ExportField(Stream stream, Int32& objectid);
    private void ExportSelectedFDFField(Stream stream, string strValue1, PdfArray kids, bool flag, Int32& objectid);
    internal void ExportField(Dictionary`2<string, object> table);
    internal void SetFields(object fieldName, object Fieldvalue, Dictionary`2<object, object> table);
    internal void SetFields(string fieldName, object Fieldvalue, Dictionary`2<string, object> table);
    internal void ImportFieldValue(object FieldValue);
    private bool ContainsExportValue(string value, PdfDictionary dictionary);
    internal static bool validateString(string text1);
    internal string GetFieldName();
    internal string ReplaceNotUsedCharacters(string input, Dictionary`2<string, string> encodingDifference, FontStructure fontStructure);
    internal string UpdateEncodedValue(string value, PdfDictionary font);
    internal void GetEncodedFontDictionary(PdfDictionary fieldDictionary, PdfDictionary& font);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class Syncfusion.Pdf.Parsing.PdfLoadedFieldImportError : object {
    private PdfLoadedField loadedFieldName;
    private Exception exceptionDetails;
    public Exception Exception { get; }
    public PdfLoadedField Field { get; }
    internal PdfLoadedFieldImportError(PdfLoadedField field, Exception exception);
    public Exception get_Exception();
    public PdfLoadedField get_Field();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class Syncfusion.Pdf.Parsing.PdfLoadedFieldItem : object {
    internal PdfLoadedStyledField m_field;
    internal int m_collectionIndex;
    private PdfDictionary m_dictionary;
    private PdfPageBase m_page;
    protected PdfLoadedStyledField Field { get; }
    internal PdfLoadedStyledField Parent { get; }
    internal PdfCrossTable CrossTable { get; }
    internal PdfDictionary Dictionary { get; }
    public RectangleF Bounds { get; public set; }
    public PointF Location { get; public set; }
    public SizeF Size { get; public set; }
    internal PdfPen BorderPen { get; }
    internal PdfBorderStyle BorderStyle { get; }
    internal Single[] DashPatern { get; }
    internal float BorderWidth { get; }
    internal PdfStringFormat StringFormat { get; }
    internal PdfBrush BackBrush { get; }
    internal PdfBrush ForeBrush { get; }
    internal PdfBrush ShadowBrush { get; }
    internal PdfFont Font { get; }
    public PdfPageBase Page { get; internal set; }
    internal int PageIndex { get; }
    internal PdfLoadedFieldItem(PdfLoadedStyledField field, int index, PdfDictionary dictionary);
    protected PdfLoadedStyledField get_Field();
    internal PdfLoadedStyledField get_Parent();
    internal PdfCrossTable get_CrossTable();
    internal PdfDictionary get_Dictionary();
    public RectangleF get_Bounds();
    public void set_Bounds(RectangleF value);
    public PointF get_Location();
    public void set_Location(PointF value);
    public SizeF get_Size();
    public void set_Size(SizeF value);
    internal PdfPen get_BorderPen();
    internal PdfBorderStyle get_BorderStyle();
    internal Single[] get_DashPatern();
    internal float get_BorderWidth();
    internal PdfStringFormat get_StringFormat();
    internal PdfBrush get_BackBrush();
    internal PdfBrush get_ForeBrush();
    internal PdfBrush get_ShadowBrush();
    internal PdfFont get_Font();
    public PdfPageBase get_Page();
    internal void set_Page(PdfPageBase value);
    internal int get_PageIndex();
}
internal enum Syncfusion.Pdf.Parsing.PdfLoadedFieldTypes : Enum {
    public int value__;
    public static PdfLoadedFieldTypes PushButton;
    public static PdfLoadedFieldTypes CheckBox;
    public static PdfLoadedFieldTypes RadioButton;
    public static PdfLoadedFieldTypes TextField;
    public static PdfLoadedFieldTypes ListBox;
    public static PdfLoadedFieldTypes ComboBox;
    public static PdfLoadedFieldTypes SignatureField;
    public static PdfLoadedFieldTypes Null;
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class Syncfusion.Pdf.Parsing.PdfLoadedForm : PdfForm {
    private PdfLoadedFormFieldCollection m_fields;
    private ExportFormSettings m_formSettings;
    private ImportFormSettings m_settings;
    private PdfFormFieldsTabOrder pdfFormFieldsTabOrder;
    private PdfCrossTable m_crossTable;
    private List`1<PdfDictionary> m_terminalFields;
    private bool m_isModified;
    private bool m_isXFAForm;
    private bool m_hasFieldFontRetrieved;
    internal bool isUR3;
    private PdfLoadedXfaForm m_loadedXfa;
    internal Dictionary`2<string, List`1<PdfDictionary>> m_widgetDictionary;
    private bool m_formHasKids;
    private bool m_exportEmptyFields;
    private Dictionary`2<string, PdfDictionary> m_fdfFields;
    private Dictionary`2<string, List`1<string>> m_xmlFields;
    private Dictionary`2<string, List`1<string>> m_xdfdFields;
    private string uniquekey;
    private Dictionary`2<string, string> fdfRichTextTable;
    private Dictionary`2<string, string> m_xfdfRichText;
    internal List`1<string> m_terminalAddedFieldsNames;
    private bool isJsonFormat;
    private string m_jsonDelimiters;
    internal bool isEmpty;
    private bool isSignature;
    private List`1<string> selectedList;
    private string CurrentFieldName;
    private string PreviousFieldName;
    internal PdfLoadedXfaForm LoadedXfa { get; internal set; }
    public PdfLoadedFormFieldCollection Fields { get; }
    public bool EnableXfaFormFill { get; public set; }
    public bool ExportEmptyFields { get; public set; }
    public bool ReadOnly { get; public set; }
    internal SignatureFlags SignatureFlags { get; internal set; }
    internal bool NeedAppearances { get; internal set; }
    internal PdfResources Resources { get; internal set; }
    internal bool IsModified { get; internal set; }
    internal PdfCrossTable CrossTable { get; }
    internal List`1<PdfDictionary> TerminalFields { get; internal set; }
    internal bool IsXFAForm { get; internal set; }
    internal bool IsFormContainsKids { get; internal set; }
    internal PdfLoadedForm(PdfDictionary formDictionary, PdfCrossTable crossTable);
    internal PdfLoadedForm(PdfCrossTable crossTable);
    internal PdfLoadedXfaForm get_LoadedXfa();
    internal void set_LoadedXfa(PdfLoadedXfaForm value);
    public PdfLoadedFormFieldCollection get_Fields();
    public bool get_EnableXfaFormFill();
    public void set_EnableXfaFormFill(bool value);
    public bool get_ExportEmptyFields();
    public void set_ExportEmptyFields(bool value);
    public virtual bool get_ReadOnly();
    public virtual void set_ReadOnly(bool value);
    internal virtual SignatureFlags get_SignatureFlags();
    internal virtual void set_SignatureFlags(SignatureFlags value);
    internal virtual bool get_NeedAppearances();
    internal virtual void set_NeedAppearances(bool value);
    internal virtual PdfResources get_Resources();
    internal virtual void set_Resources(PdfResources value);
    internal bool get_IsModified();
    internal void set_IsModified(bool value);
    internal PdfCrossTable get_CrossTable();
    internal List`1<PdfDictionary> get_TerminalFields();
    internal void set_TerminalFields(List`1<PdfDictionary> value);
    internal bool get_IsXFAForm();
    internal void set_IsXFAForm(bool value);
    internal bool get_IsFormContainsKids();
    internal void set_IsFormContainsKids(bool value);
    internal PdfField GetField(string nodeName);
    private void CheckPerms(PdfCatalog catalog);
    private void Initialize(PdfDictionary formDictionary, PdfCrossTable crossTable);
    private void CreateFields();
    private bool IsNode(PdfArray kids);
    public void ExportData(Stream stream, DataFormat dataFormat, string formName);
    public void ExportData(Stream stream, ExportFormSettings settings);
    public void FlattenFields();
    private void ExportDataXFDF(Stream stream, string formName);
    private string HexToString(string text);
    internal PdfLoadedXfaField GetXfaField(string fieldName);
    private void ExportDataFDF(Stream stream, string formName);
    private void AppendArrayElements(PdfArray array, PdfWriter writer);
    private void AppendElement(IPdfPrimitive element, PdfWriter writer);
    private void GetEntriesInDictionary(PdfDictionary dictionary, PdfWriter writer);
    private bool NonAsciiCheck(string value);
    internal Byte[] EscapeSymbols(Byte[] data);
    private string GetFormattedString(string value);
    private PdfArray GroupFieldNames(Dictionary`2<string, object> map);
    internal Dictionary`2<string, object> GetElements(Dictionary`2<string, object> table);
    internal void ExportDataXML(Stream stream);
    private void WriteFieldName(Dictionary`2<object, object> value, XmlWriter textWriter);
    private bool HasEscapeCharacter(string text);
    internal Dictionary`2<object, object> GetElements(Dictionary`2<object, object> table);
    private void fieldname(Dictionary`2<object, object> value, XmlWriter textWriter);
    internal void ExportDataJSON(Stream stream);
    internal bool IsJsonDelimiter(string str);
    private object GetExportValue(IPdfPrimitive fieldPrimitive);
    internal void OnValidate(string nodeName);
    internal virtual void Dictionary_BeginSave(object sender, SavePdfPrimitiveEventArgs ars);
    private void FlttenFormFields();
    internal virtual void Clear();
    internal void RemoveFromDictionaries(PdfField field);
    internal void DeleteFromPages(PdfField field);
    internal void DeleteAnnottation(PdfField field);
    internal void CreateFormFields(PdfLoadedPage page, List`1<long> widgetReferences);
    internal virtual string GetCorrectName(string name);
    private PdfLoadedFieldImportError[] ImportData(Stream fileName, DataFormat dataFormat, bool continueImportOnError);
    public PdfLoadedFieldImportError[] ImportDataXML(Stream stream, bool continueImportOnError);
    public void ImportDataXML(Byte[] array);
    public void ImportDataXML(Stream stream);
    private void ImportXMLData(IEnumerable`1<XElement> xmlnode, bool continueImportOnError, List`1<PdfLoadedFieldImportError> list);
    public void ImportDataXFDF(Byte[] array);
    public void ImportDataXFDF(Stream stream);
    private void ImportXFDFNodes(IEnumerable`1<XElement> fieldElements, XNamespace ns);
    private PdfLoadedFieldImportError[] ImportDataXFDF(Stream stream, bool continueImportOnError);
    public void ImportDataJson(Byte[] array);
    public void ImportDataJson(Stream stream);
    public void ImportDataFDF(Stream stream);
    public void ImportDataFDF(Byte[] array);
    public PdfLoadedFieldImportError[] ImportDataFDF(Stream stream, bool continueImportOnError);
    private void ReadFDFFields(PdfDictionary kidNodes, string name);
    private string GetFieldName(PdfReader reader, String& token);
    private void GetFieldValue(PdfReader reader, string token, string fieldName, Dictionary`2<string, String[]> table);
    private string GetFieldValue(PdfReader reader, string token, bool isMultiSelect, Dictionary`2<string, String[]> table, string fieldName, List`1<string> fieldValues);
    public void HighlightFields(bool highlight);
    public bool OnlyHexInString(string test);
    public void ImportData(Stream stream, ImportFormSettings settings);
    internal bool HasAnyFlattenedField();
    private int CompareKidsElement(PdfReferenceHolder referenceHolder1, PdfReferenceHolder referenceHolder2);
    private void SortFieldItems(PdfField field);
    private int CompareFieldItem(object item1, object item2);
    private int CompareField(object formField1, object formField2);
    internal PdfLoadedFormFieldCollection OrderFormFields(PdfFormFieldsTabOrder formFieldsTabOrder);
    private bool OrderIPdfPrimitives(PdfLoadedFormFieldCollection formFieldCollection, bool setTabOrder, PdfFormFieldsTabOrder formFieldsTabOrder);
    private void SetTabOrderToKids(PdfField field, PdfFormFieldsTabOrder formFieldsTabOrder);
    internal PdfLoadedFormFieldCollection OrderFormFields();
    internal PdfLoadedFormFieldCollection OrderFormFields(Dictionary`2<int, PdfFormFieldsTabOrder> tabCollection);
    private RectangleF GetBounds(PdfField lField);
    private PdfPageBase SortItemPageIndex(PdfField lField, bool pageTabOrder);
    private PdfArray GetItemRectangle(PdfDictionary rectangle, PdfLoadedField lField);
    private PdfArray GetRectangle(PdfDictionary rectangle);
    [CompilerGeneratedAttribute]
private int <SortFieldItems>b__127_0(object item1, object item2);
    [CompilerGeneratedAttribute]
private int <SortFieldItems>b__127_1(object item1, object item2);
    [CompilerGeneratedAttribute]
private int <SortFieldItems>b__127_2(object item1, object item2);
    [CompilerGeneratedAttribute]
private int <SortFieldItems>b__127_3(object item1, object item2);
    [CompilerGeneratedAttribute]
private int <OrderFormFields>b__130_0(object pdfField1, object pdfField2);
    [CompilerGeneratedAttribute]
private int <OrderFormFields>b__134_0(PdfField pdfField1, PdfField pdfField2);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[DefaultMemberAttribute("Item")]
public class Syncfusion.Pdf.Parsing.PdfLoadedFormFieldCollection : PdfFieldCollection {
    private PdfLoadedForm m_form;
    private List`1<string> m_fieldNames;
    private List`1<string> m_indexedFieldNames;
    private List`1<string> m_actualFieldNames;
    private List`1<string> m_indexedActualFieldNames;
    internal List`1<string> m_addedFieldNames;
    private bool m_isCreateNewFormField;
    internal bool m_isImported;
    public PdfField Item { get; }
    public PdfField Item { get; }
    public PdfLoadedForm Form { get; public set; }
    public PdfLoadedFormFieldCollection(PdfLoadedForm form);
    public virtual PdfField get_Item(int index);
    public PdfField get_Item(string name);
    public PdfLoadedForm get_Form();
    public void set_Form(PdfLoadedForm value);
    public bool ValidateSignatures(List`1& results);
    public bool ValidateSignatures(PdfSignatureValidationOptions options, List`1& results);
    public bool ValidateSignatures(X509Certificate2Collection rootCertificates, List`1& results);
    public bool ValidateSignatures(X509Certificate2Collection rootCertificates, PdfSignatureValidationOptions options, List`1& results);
    private PdfField GetField(int index);
    private PdfField GetField(PdfDictionary dictionary);
    private PdfField CreateSignatureField(PdfDictionary dictionary, PdfCrossTable crossTable);
    private PdfField CreateListBox(PdfDictionary dictionary, PdfCrossTable crossTable);
    private PdfField CreateComboBox(PdfDictionary dictionary, PdfCrossTable crossTable);
    private PdfField CreateTextField(PdfDictionary dictionary, PdfCrossTable crossTable);
    private PdfField CreateRadioButton(PdfDictionary dictionary, PdfCrossTable crossTable);
    internal void CreateFormFieldsFromWidgets(int startFormFieldIndex);
    private PdfField CreateCheckBox(PdfDictionary dictionary, PdfCrossTable crossTable);
    private PdfField CreatePushButton(PdfDictionary dictionary, PdfCrossTable crossTable);
    internal PdfLoadedFieldTypes GetFieldType(PdfName name, PdfDictionary dictionary, PdfCrossTable crossTable);
    protected virtual int DoAdd(PdfField field);
    protected virtual void DoInsert(int index, PdfField field);
    protected virtual void DoRemove(PdfField field);
    protected virtual void DoRemoveAt(int index);
    internal void RemoveContainingField(PdfReferenceHolder pageReferenceHolder);
    protected virtual void DoClear();
    internal bool IsValidName(string name);
    internal string GetCorrectName(string name);
    internal void AddFieldDictionary(PdfDictionary field);
    private void ldField_NameChanded(string name);
    private int GetFieldIndex(string name);
    internal void ResetFieldNames();
    private PdfField GetNamedField(string name);
    public bool TryGetField(string fieldName, PdfLoadedField& field);
    public bool TryGetValue(string fieldName, String& fieldValue);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class Syncfusion.Pdf.Parsing.PdfLoadedListBoxField : PdfLoadedChoiceField {
    private PdfLoadedListFieldItemCollection m_items;
    public bool ComplexScript { get; public set; }
    public bool MultiSelect { get; public set; }
    public PdfLoadedListFieldItemCollection Items { get; internal set; }
    internal PdfLoadedListBoxField(PdfDictionary dictionary, PdfCrossTable crossTable);
    public bool get_ComplexScript();
    public void set_ComplexScript(bool value);
    public bool get_MultiSelect();
    public void set_MultiSelect(bool value);
    public PdfLoadedListFieldItemCollection get_Items();
    internal void set_Items(PdfLoadedListFieldItemCollection value);
    internal virtual void Draw();
    internal virtual void BeginSave();
    internal PdfField Clone(PdfDictionary dictionary, PdfPage page);
    internal PdfLoadedStyledField Clone();
    internal virtual PdfLoadedFieldItem CreateLoadedItem(PdfDictionary dictionary);
    private void ApplyAppearance(PdfDictionary widget, PdfLoadedFieldItem item);
    private void DrawListBox(PdfGraphics graphics, PdfLoadedFieldItem item);
    private PdfListFieldItemCollection ConvertToListItems(PdfLoadedListItemCollection items);
    internal virtual float GetFontHeight(PdfFontFamily family);
    public void RemoveAt(int index);
    public void Remove(PdfLoadedListFieldItem item);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class Syncfusion.Pdf.Parsing.PdfLoadedListFieldItem : PdfLoadedFieldItem {
    internal PdfLoadedListFieldItem(PdfLoadedStyledField field, int index, PdfDictionary dictionary);
    internal PdfLoadedListFieldItem Clone();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[DefaultMemberAttribute("Item")]
public class Syncfusion.Pdf.Parsing.PdfLoadedListFieldItemCollection : PdfCollection {
    public PdfLoadedListFieldItem Item { get; }
    public PdfLoadedListFieldItem get_Item(int index);
    internal void Add(PdfLoadedListFieldItem item);
    internal int Remove(PdfLoadedListFieldItem item);
    internal PdfLoadedListFieldItemCollection Clone();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class Syncfusion.Pdf.Parsing.PdfLoadedListItem : object {
    private string m_text;
    private string m_value;
    private PdfLoadedChoiceField m_field;
    private PdfCrossTable m_crossTable;
    public string Text { get; public set; }
    public string Value { get; public set; }
    internal PdfLoadedListItem(string text, string value, PdfLoadedChoiceField field, PdfCrossTable cTable);
    public PdfLoadedListItem(string text, string value);
    public string get_Text();
    public void set_Text(string value);
    public string get_Value();
    public void set_Value(string value);
    private void AssignText(string value);
    private void AssignValue(string value);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[DefaultMemberAttribute("Item")]
public class Syncfusion.Pdf.Parsing.PdfLoadedListItemCollection : PdfCollection {
    private PdfLoadedChoiceField m_field;
    public PdfLoadedListItem Item { get; }
    internal PdfLoadedListItemCollection(PdfLoadedChoiceField field);
    public PdfLoadedListItem get_Item(int index);
    public int Add(PdfLoadedListItem item);
    internal int AddItem(PdfLoadedListItem item);
    public void Insert(int index, PdfLoadedListItem item);
    public void RemoveAt(int index);
    public void Clear();
    private PdfArray GetItems();
    private PdfArray GetArray(PdfLoadedListItem item);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[DefaultMemberAttribute("Item")]
public class Syncfusion.Pdf.Parsing.PdfLoadedPageCollection : object {
    private PdfDocumentBase m_document;
    private PdfCrossTable m_crossTable;
    private Dictionary`2<PdfDictionary, PdfPageBase> m_pagesCash;
    private PdfLoadedDocument m_loadedDocument;
    private int m_pageDuplicaton;
    internal static int m_repeatIndex;
    internal static int m_parentKidsCount;
    internal static int m_parentKidsCounttemp;
    internal static int m_nestedPages;
    private int m_sectionCount;
    private PdfLoadedDocument m_destDocument;
    private IPdfPrimitive m_pageCatalogObj;
    private PdfDictionary m_pageNodeDictionary;
    private int m_pageNodeCount;
    private PdfArray m_nodeKids;
    private int m_lastPageIndex;
    private int m_lastKidIndex;
    private PdfCrossTable m_lastCrossTable;
    private int m_pageIndex;
    internal Dictionary`2<PdfDictionary, int> m_pageIndexCollection;
    private bool m_invalidPageNode;
    internal bool m_closeCompletely;
    private bool m_parseInvalidPages;
    private List`1<long> objectReference;
    private bool m_groupFormFields;
    private List`1<PdfArray> annotArrays;
    public int SectionCount { get; }
    private PdfLoadedDocument LoadedDocument { get; }
    public PdfPageBase Item { get; }
    public int Count { get; }
    private Dictionary`2<PdfDictionary, PdfPageBase> PageCache { get; }
    internal PdfLoadedPageCollection(PdfDocumentBase document, PdfCrossTable crossTable);
    public int get_SectionCount();
    private PdfLoadedDocument get_LoadedDocument();
    public PdfPageBase get_Item(int index);
    public int get_Count();
    private Dictionary`2<PdfDictionary, PdfPageBase> get_PageCache();
    public PdfPageBase Add();
    public PdfPageBase Add(SizeF size);
    public PdfPageBase Add(SizeF size, PdfMargins margins);
    public PdfPageBase Add(SizeF size, PdfMargins margins, PdfPageRotateAngle rotation);
    internal PdfPageBase Add(SizeF size, PdfMargins margins, PdfPageRotateAngle rotation, int location);
    internal PdfPageBase Add(PdfLoadedDocument ldDoc, PdfPageBase page, List`1<PdfArray> destinations);
    internal PdfPageBase Add(PdfLoadedDocument ldDoc, PdfPageBase page);
    public PdfPageBase Insert(int index);
    public PdfPageBase Insert(int index, SizeF size);
    public PdfPageBase Insert(int index, SizeF size, PdfMargins margins);
    public PdfPageBase Insert(int index, SizeF size, PdfMargins margins, PdfPageRotateAngle rotation);
    public void RemoveAt(int index);
    public void Remove(PdfPageBase page);
    internal void RemoveFormFields(PdfReferenceHolder pageHolder);
    private void RemovePdfPageTemplates(PdfLoadedDocument loadedDocument, PdfPageBase pdfPageBase);
    private PdfArray GetUpdatedPdfPagetemplates(PdfArray namedCollection, PdfLoadedDocument loadedDocument, PdfPageBase pdfPageBase);
    public void ReArrange(Int32[] orderArray);
    private int GetInnerKids(PdfReferenceHolder pdfReference, PdfArray kids, List`1<long> kidsReference, int klen, int kidsLength1);
    private void UpdateCountDecrement(PdfDictionary parent);
    public PdfPageBase Insert(int index, SizeF size, PdfMargins margins, PdfPageRotateAngle rotation, PdfPageOrientation orientation);
    internal void Insert(int index, PdfPageBase loadedPage, bool isGrouping, List`1<PdfArray> array);
    public void Insert(int index, PdfPageBase loadedPage);
    private void DuplicatePage(PdfPageBase page, int index, bool sameDocument);
    private void SaveAnnotations(PdfPageBase page);
    private PdfDictionary MapAcroFromFields(PdfDictionary acroFormData, PdfDictionary destinationForm);
    internal PdfPageBase GetPage(PdfDictionary dic);
    internal void UpdateCount(PdfDictionary parent);
    internal int IndexOf(PdfPageBase page);
    internal int GetIndex(PdfPageBase page);
    private void ParsePageNodes(PdfPageBase page);
    private void FindKids(PdfDictionary pages);
    private void FindPageNodes(PdfDictionary pageNode);
    private void ResetPageCollection();
    private PdfPageBase GetPage(int index);
    private bool IsNodeLeaf(PdfDictionary node);
    private PdfArray GetNodeKids(PdfDictionary node);
    private int GetNodeCount(PdfDictionary node);
    private PdfDictionary GetParent(int index, Int32& localIndex, bool zeroValid);
    private PdfDictionary GetParent(int index, Int32& localIndex, bool zeroValid, bool enableFastFetching);
    private void GetParentNode(int kidStartIndex, PdfArray kids, int lowIndex, int pageIndex, PdfDictionary& node, Int32& localIndex, Boolean& isParentFetched);
    internal void Clear(bool isCompletely);
    public sealed virtual IEnumerator GetEnumerator();
    private void RemoveInvalidPageNodes();
    private void ParseKids(PdfDictionary pages);
    private void ParsePageNodes(PdfDictionary pageNode, Boolean& invalid);
    private void RemovePageNode(PdfArray kids, int i, PdfDictionary node);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class Syncfusion.Pdf.Parsing.PdfLoadedPageEnumerator : object {
    private PdfLoadedPageCollection m_collection;
    private int m_index;
    public object Current { get; }
    public PdfLoadedPageEnumerator(PdfLoadedPageCollection collection);
    public sealed virtual object get_Current();
    public sealed virtual bool MoveNext();
    public sealed virtual void Reset();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[DefaultMemberAttribute("Item")]
public class Syncfusion.Pdf.Parsing.PdfLoadedPopupAnnotationCollection : PdfCollection {
    internal PdfDictionary m_annotDictionary;
    private bool m_isReview;
    private PdfLoadedPage m_loadedPage;
    private static int ReviewFlag;
    private static int CommentFlag;
    public PdfLoadedPopupAnnotation Item { get; }
    internal PdfLoadedPopupAnnotationCollection(PdfLoadedPage page, PdfDictionary annotDictionary, bool isReview);
    public PdfLoadedPopupAnnotation get_Item(int index);
    private void GetReviewHistory(PdfLoadedPage page, PdfDictionary annotDictionary);
    private void GetComments(PdfLoadedPage page, PdfDictionary annotDictionary);
    private bool IsReviewAnnot(PdfDictionary annotDictionary);
    public void Add(PdfPopupAnnotation popupAnnotation);
    private void AddInnerCommentOrReview(PdfLoadedPage page, PdfPopupAnnotation popupAnnotation);
    private void DoAddPage(PdfDictionary annotDictionary, PdfPopupAnnotation annotation);
    public void Remove(PdfAnnotation popupAnnotation);
    public void RemoveAt(int index);
    private void DoRemovePage(PdfDictionary annotDictionary, PdfAnnotation annotation);
    private void DoRemoveChildAnnots(PdfLoadedPage lPage, PdfAnnotation annot);
    private bool IsReviewAnnot();
    private void DoAddComments(PdfAnnotation annotation);
    private void DoAddReviewHistory(PdfAnnotation annotation);
    private PdfPopupAnnotationCollection GetCommentsOrReview(PdfAnnotation annotation, bool isReview);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class Syncfusion.Pdf.Parsing.PdfLoadedRadioButtonItem : PdfLoadedStateItem {
    private string m_optionValue;
    public string Value { get; public set; }
    public string OptionValue { get; internal set; }
    public bool Selected { get; public set; }
    internal PdfLoadedRadioButtonListField Parent { get; }
    internal PdfLoadedRadioButtonItem(PdfLoadedStyledField field, int index, PdfDictionary dictionary);
    public string get_Value();
    public void set_Value(string value);
    public string get_OptionValue();
    internal void set_OptionValue(string value);
    public bool get_Selected();
    public void set_Selected(bool value);
    internal PdfLoadedRadioButtonListField get_Parent();
    private string GetItemValue();
    private void SetItemValue(string value);
    internal PdfLoadedRadioButtonItem Clone();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[DefaultMemberAttribute("Item")]
public class Syncfusion.Pdf.Parsing.PdfLoadedRadioButtonItemCollection : PdfLoadedStateItemCollection {
    public PdfLoadedRadioButtonItem Item { get; }
    public PdfLoadedRadioButtonItem get_Item(int index);
    internal int IndexOf(PdfLoadedRadioButtonItem item);
    internal void Add(PdfLoadedRadioButtonItem item);
    internal int Remove(PdfLoadedRadioButtonItem item);
    internal PdfLoadedRadioButtonItemCollection Clone();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class Syncfusion.Pdf.Parsing.PdfLoadedRadioButtonListField : PdfLoadedStateField {
    private static string CHECK_SYMBOL;
    public PdfLoadedRadioButtonItemCollection Items { get; internal set; }
    public int SelectedIndex { get; public set; }
    public string SelectedValue { get; public set; }
    public PdfLoadedRadioButtonItem SelectedItem { get; }
    public string Value { get; public set; }
    internal PdfLoadedRadioButtonListField(PdfDictionary dictionary, PdfCrossTable crossTable);
    public PdfLoadedRadioButtonItemCollection get_Items();
    internal void set_Items(PdfLoadedRadioButtonItemCollection value);
    public int get_SelectedIndex();
    public void set_SelectedIndex(int value);
    public string get_SelectedValue();
    public void set_SelectedValue(string value);
    public PdfLoadedRadioButtonItem get_SelectedItem();
    public string get_Value();
    public void set_Value(string value);
    internal PdfLoadedRadioButtonItem GetItem(string value);
    internal virtual PdfLoadedStateItem GetItem(int index, PdfDictionary itemDictionary);
    private int ObtainSelectedIndex();
    private void AssignSelectedIndex(int value);
    private void AssignSelectedValue(string value);
    internal virtual void Draw();
    internal virtual void BeginSave();
    internal PdfField Clone(PdfDictionary dictionary, PdfPage page);
    internal PdfLoadedStyledField Clone();
    internal virtual PdfLoadedFieldItem CreateLoadedItem(PdfDictionary dictionary);
    private void RetrieveOptionValue();
    public void RemoveAt(int index);
    public void Remove(PdfLoadedRadioButtonItem item);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class Syncfusion.Pdf.Parsing.PdfLoadedSignatureField : PdfLoadedStyledField {
    private PdfSignature m_signature;
    private PdfCmsSigner m_pdfCmsSigner;
    private bool m_isSigned;
    private string m_message;
    private List`1<long> m_skipedObjects;
    private PdfLoadedSignatureItemCollection m_items;
    private PdfSignatureValidationResult result;
    private PdfSignatureValidationOptions signatureOptions;
    private bool m_isVerified;
    private int m_revision;
    private bool m_isAcroFormDic;
    private bool isComment;
    public bool IsSigned { get; }
    public PdfLoadedSignatureItemCollection Items { get; internal set; }
    internal PdfCmsSigner CmsSigner { get; }
    public PdfSignature Signature { get; public set; }
    internal PdfAppearance Appearance { get; }
    public int Revision { get; }
    internal PdfLoadedSignatureField(PdfDictionary dictionary, PdfCrossTable crossTable);
    public bool get_IsSigned();
    public PdfLoadedSignatureItemCollection get_Items();
    internal void set_Items(PdfLoadedSignatureItemCollection value);
    internal PdfCmsSigner get_CmsSigner();
    public PdfSignature get_Signature();
    public void set_Signature(PdfSignature value);
    internal PdfAppearance get_Appearance();
    public int get_Revision();
    private void CheckSigned();
    private void SetLock(IPdfPrimitive primitive);
    private void SetSignature(IPdfPrimitive signature);
    private X509Certificate2 FindEndChainCertificate(List`1<X509Certificate2> chainElements);
    private void InitializeSigner();
    internal virtual void BeginSave();
    internal PdfField Clone(PdfDictionary dictionary, PdfPage page);
    internal virtual PdfLoadedFieldItem CreateLoadedItem(PdfDictionary dictionary);
    internal virtual void Draw();
    private RectangleF CalculateTemplateBounds(RectangleF bounds, PdfPageBase page, PdfTemplate template, PdfGraphics graphics);
    internal int ObtainGraphicsRotation(PdfTransformationMatrix matrix);
    private bool CheckCertificateValidity(DateTime date, DateTime validFrom, DateTime validTo);
    public PdfSignatureValidationResult ValidateSignature();
    public PdfSignatureValidationResult ValidateSignature(PdfSignatureValidationOptions options);
    private List`1<Byte[]> GetByteCollection(PdfArray array);
    private PdfSignatureValidationResult Validate(PdfSignatureValidationOptions options);
    public PdfSignatureValidationResult ValidateSignature(X509CertificateCollection rootCertificates);
    public PdfSignatureValidationResult ValidateSignature(X509CertificateCollection rootCertificates, PdfSignatureValidationOptions options);
    private X509Certificate2Collection GetCertficates();
    private bool VerifyChecksum();
    private bool CheckIncrementUpdate();
    private bool VerifyPageisModify(PdfDictionary dictionary, List`1<ObjectInformation> entry);
    private PdfDictionary ReadDictionary(ObjectInformation objInfo);
    private bool CheckFormFieldRemoved(PdfArray oldAnnots, PdfArray newAnnots);
    private bool CheckSubType(PdfDictionary dictionary);
    private bool CheckSubType(PdfDictionary newer, PdfDictionary older);
    private bool CompareObjects(PdfDictionary dictionaryObj, List`1<long> skipObjects, long key, PdfDictionary dictionary);
    private bool ReadFormReferences(PdfDictionary dictionaryObj, PdfDictionary dictionary);
    private void ReadAllReferences(PdfDictionary formDictionary);
    private void ReadAllSubReferences(IPdfPrimitive primitive);
    private bool IsAnnotation(string subType);
    private bool AreEqual(PdfDictionary older, PdfDictionary newer, bool ignoreAnnotation);
    private bool IsEqual(IPdfPrimitive older, IPdfPrimitive newer);
    private RevocationResult ValidateRevocation(PdfSignatureValidationResult result);
    private TimeStampInformation VerifyTimeStamp();
    private void UpdateByteRange(PdfCmsSigner pkcs7, PdfArray byteRange);
    private void FlattenSignatureApperance();
    private PdfTemplate GetItemTemplate(PdfDictionary Dictionary);
    private void FlattenSignature(PdfDictionary Dictionary, PdfPageBase Page, PdfTemplate signatureTemplate, RectangleF Bounds);
    private void FindAllReferences(PdfDictionary formDictionary);
    private void FindAllSubReferences(IPdfPrimitive primitive);
    internal int SignedRevision();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class Syncfusion.Pdf.Parsing.PdfLoadedSignatureItem : PdfLoadedFieldItem {
    internal PdfLoadedSignatureItem(PdfLoadedStyledField field, int index, PdfDictionary dictionary);
    internal PdfLoadedSignatureItem Clone();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[DefaultMemberAttribute("Item")]
public class Syncfusion.Pdf.Parsing.PdfLoadedSignatureItemCollection : PdfCollection {
    public PdfLoadedSignatureItem Item { get; }
    public PdfLoadedSignatureItem get_Item(int index);
    internal void Add(PdfLoadedSignatureItem item);
    internal int Remove(PdfLoadedSignatureItem item);
    internal PdfLoadedSignatureItemCollection Clone();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public abstract class Syncfusion.Pdf.Parsing.PdfLoadedStateField : PdfLoadedStyledField {
    private PdfLoadedStateItemCollection m_items;
    private bool m_bUnchecking;
    public PdfLoadedStateItemCollection Items { get; internal set; }
    internal PdfLoadedStateField(PdfDictionary dictionary, PdfCrossTable crossTable, PdfLoadedStateItemCollection items);
    public PdfLoadedStateItemCollection get_Items();
    internal void set_Items(PdfLoadedStateItemCollection value);
    internal abstract virtual PdfLoadedStateItem GetItem(int index, PdfDictionary itemDictionary);
    private PdfTemplate GetStateTemplate(PdfCheckFieldState state, PdfLoadedStateItem item);
    protected void SetCheckedStatus(bool value);
    internal static string GetItemValue(PdfDictionary dictionary, PdfCrossTable crossTable);
    internal void UncheckOthers(PdfLoadedStateItem child, string value, bool check);
    internal void ApplyAppearance(PdfDictionary widget, PdfLoadedStateItem item);
    internal void DrawStateItem(PdfGraphics graphics, PdfCheckFieldState state, PdfLoadedStateItem item);
    public void RemoveAt(int index);
    public void Remove(PdfLoadedStateItem item);
    internal RectangleF RotateField(RectangleF rect, SizeF size, PdfPageRotateAngle angle);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class Syncfusion.Pdf.Parsing.PdfLoadedStateItem : PdfLoadedFieldItem {
    public bool Checked { get; public set; }
    public PdfColor BackColor { get; public set; }
    public PdfColor ForeColor { get; public set; }
    public PdfColor BorderColor { get; public set; }
    internal PdfLoadedStateItem(PdfLoadedStyledField field, int index, PdfDictionary dictionary);
    public bool get_Checked();
    public void set_Checked(bool value);
    public PdfColor get_BackColor();
    public void set_BackColor(PdfColor value);
    public PdfColor get_ForeColor();
    public void set_ForeColor(PdfColor value);
    public PdfColor get_BorderColor();
    public void set_BorderColor(PdfColor value);
    private void SetCheckedStatus(bool value);
    internal PdfColor GetBackColor();
    private PdfColor CreateColor(PdfArray array);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[DefaultMemberAttribute("Item")]
public class Syncfusion.Pdf.Parsing.PdfLoadedStateItemCollection : PdfCollection {
    public PdfLoadedStateItem Item { get; }
    public PdfLoadedStateItem get_Item(int index);
    internal int IndexOf(PdfLoadedStateItem item);
    internal void Add(PdfLoadedStateItem item);
    internal int Remove(PdfLoadedStateItem item);
    internal PdfLoadedStateItemCollection Clone();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class Syncfusion.Pdf.Parsing.PdfLoadedStyledField : PdfLoadedField {
    private static byte ShadowShift;
    private PdfFieldActions m_actions;
    private WidgetAnnotation m_widget;
    private PdfAction m_mouseEnter;
    private PdfAction m_mouseLeave;
    private PdfAction m_mouseDown;
    private PdfAction m_mouseUp;
    private PdfAction m_gotFocus;
    private PdfAction m_lostFocus;
    private PdfPen m_borderPen;
    internal PdfFont m_font;
    private PdfFormFieldVisibility m_visibility;
    internal PdfArray m_array;
    internal bool m_isTextChanged;
    internal bool m_isCustomFontSize;
    internal bool m_isFieldPropertyChanged;
    internal int m_angle;
    internal bool isRotationModified;
    internal bool m_isTextModified;
    internal bool m_isFontModified;
    internal bool m_isCropBox;
    private Dictionary`2<int, PdfFont> m_fontCollection;
    private bool m_mouseUpAction;
    internal bool m_isImportFields;
    public PdfAction MouseEnter { get; public set; }
    public PdfAction MouseUp { get; public set; }
    public PdfAction MouseDown { get; public set; }
    public PdfAction MouseLeave { get; public set; }
    public PdfAction GotFocus { get; public set; }
    internal PdfColor ForeColor { get; internal set; }
    public PdfAction LostFocus { get; public set; }
    internal WidgetAnnotation Widget { get; }
    public RectangleF Bounds { get; public set; }
    public PointF Location { get; public set; }
    public SizeF Size { get; public set; }
    internal PdfPen BorderPen { get; }
    public PdfBorderStyle BorderStyle { get; public set; }
    public PdfColor BorderColor { get; public set; }
    internal Single[] DashPatern { get; }
    public float BorderWidth { get; public set; }
    internal PdfStringFormat StringFormat { get; }
    internal PdfBrush BackBrush { get; internal set; }
    internal PdfBrush ForeBrush { get; }
    internal PdfBrush ShadowBrush { get; }
    public PdfFont Font { get; public set; }
    public int DefaultIndex { get; public set; }
    internal PdfArray Kids { get; }
    public bool Visible { get; }
    public PdfFormFieldVisibility Visibility { get; public set; }
    public int RotationAngle { get; public set; }
    internal PdfCheckBoxStyle Style { get; internal set; }
    internal PdfLoadedStyledField(PdfDictionary dictionary, PdfCrossTable crossTable);
    public PdfAction get_MouseEnter();
    public void set_MouseEnter(PdfAction value);
    public PdfAction get_MouseUp();
    public void set_MouseUp(PdfAction value);
    public PdfAction get_MouseDown();
    public void set_MouseDown(PdfAction value);
    public PdfAction get_MouseLeave();
    public void set_MouseLeave(PdfAction value);
    public PdfAction get_GotFocus();
    public void set_GotFocus(PdfAction value);
    internal PdfColor get_ForeColor();
    internal void set_ForeColor(PdfColor value);
    public PdfAction get_LostFocus();
    public void set_LostFocus(PdfAction value);
    internal WidgetAnnotation get_Widget();
    public RectangleF get_Bounds();
    public void set_Bounds(RectangleF value);
    public PointF get_Location();
    public void set_Location(PointF value);
    public SizeF get_Size();
    public void set_Size(SizeF value);
    internal PdfPen get_BorderPen();
    public PdfBorderStyle get_BorderStyle();
    public void set_BorderStyle(PdfBorderStyle value);
    public PdfColor get_BorderColor();
    public void set_BorderColor(PdfColor value);
    internal Single[] get_DashPatern();
    public float get_BorderWidth();
    public void set_BorderWidth(float value);
    internal PdfStringFormat get_StringFormat();
    internal PdfBrush get_BackBrush();
    internal void set_BackBrush(PdfBrush value);
    internal PdfBrush get_ForeBrush();
    internal PdfBrush get_ShadowBrush();
    public PdfFont get_Font();
    public void set_Font(PdfFont value);
    public int get_DefaultIndex();
    public void set_DefaultIndex(int value);
    internal PdfArray get_Kids();
    public bool get_Visible();
    public PdfFormFieldVisibility get_Visibility();
    public void set_Visibility(PdfFormFieldVisibility value);
    public int get_RotationAngle();
    public void set_RotationAngle(int value);
    internal PdfCheckBoxStyle get_Style();
    internal void set_Style(PdfCheckBoxStyle value);
    private PdfFormFieldVisibility ObtainVisibility();
    private PdfAnnotationFlags ObtainAnnotationFlags(PdfNumber flagNumber);
    private PdfFormFieldVisibility ObtainKidsVisibility(PdfDictionary dictionary);
    private void SetVisibility();
    private void SetVisiblityToWidget(PdfDictionary widget, bool kids);
    protected void GetGraphicsProperties(GraphicsProperties& graphicsProperties, PdfLoadedFieldItem item);
    private PdfBorderStyle CreateBorderStyle(PdfDictionary bs);
    private void AssignBorderStyle(PdfBorderStyle borderStyle);
    internal PdfPen AssignBorderColor(PdfColor borderColor);
    internal void AssignBackColor(PdfColor value);
    private RectangleF GetBounds(PdfDictionary dictionary, PdfCrossTable crossTable);
    private string GetHighLightString(PdfHighlightMode mode);
    private PdfColor CreateColor(PdfArray array);
    internal PdfColor GetForeColour(string defaultAppearance);
    private float ParseFloatColour(string text);
    internal string FontName(string fontString, Single& height);
    internal bool CheckFieldFlagValue(IPdfPrimitive kid);
    private PdfFontMetrics CreateFont(PdfDictionary fontDictionary, float height, PdfName baseFont);
    private PdfFont GetFontByName(string name, float height);
    private bool CheckFontStyle(string fontFamilyString, PdfFontStyle& style);
    private PdfFontStyle GetFontStyle(string fontFamilyString);
    internal string GetFontName(string fontFamilyString);
    private PdfFontFamily GetFontFamily(string fontFamilyString, String& standardName);
    internal PdfColor GetBackColor();
    private PdfBorderStyle ObtainBorderStyle();
    private Single[] ObtainDashPatern();
    private float ObtainBorderWidth();
    private void AssignBorderWidth(float width);
    private PdfStringFormat AssignStringFormat();
    private PdfBrush ObtainBackBrush();
    private void AssignBackBrush(PdfBrush brush);
    private PdfFont UpdateFontEncoding(PdfFont font, PdfDictionary fontDictionary);
    private PdfBrush ObtainForeBrush();
    private PdfBrush ObtainShadowBrush();
    internal virtual void Draw();
    internal virtual PdfLoadedFieldItem CreateLoadedItem(PdfDictionary dictionary);
    internal virtual void BeginSave();
    internal virtual float GetFontHeight(PdfFontFamily family);
    internal PdfPen ObtainBorderPen();
    private PdfArray ObtainKids();
    private PdfArray ObtainKids(PdfDictionary dictionary);
    private PdfArray RecursiveCall(PdfArray kids);
    private bool ObtainVisible();
    private void CreateBorderPen();
    protected virtual void DefineDefaultAppearance();
    private int ObtainRotationAngle();
    internal void SetRotationAngle(int angle);
    internal PdfField Clone(PdfDictionary dictionary, PdfPage page);
    internal PdfCheckBoxStyle ObtainStyle();
    private PdfCheckBoxStyle CreateStyle(PdfDictionary bs);
    internal void AssignStyle(PdfCheckBoxStyle checkStyle);
    protected string StyleToString(PdfCheckBoxStyle style);
    internal PdfLoadedStyledField Clone();
    private PdfFont GetFont(string fontString, Boolean& isCorrectFont, String& name);
    private string FindFontName(PdfDictionary fontDictionary, string name, PdfFontStyle& textFontStyle);
    private PdfFont CreateFontFromFontStream(PdfFont font, PdfDictionary fontDictionary, bool isUnicode, float height, PdfFontStyle fontStyle);
    private PdfDestination ObtainDestination(PdfDictionary actionDictionary);
    private PdfRemoteDestination ObtainRemoteDestination(PdfDictionary actionDictionary);
    private PdfAction GetPdfAction(string key);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class Syncfusion.Pdf.Parsing.PdfLoadedTexBoxItem : PdfLoadedFieldItem {
    internal PdfLoadedTexBoxItem(PdfLoadedStyledField field, int index, PdfDictionary dictionary);
    internal PdfLoadedTexBoxItem Clone();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class Syncfusion.Pdf.Parsing.PdfLoadedTextBoxField : PdfLoadedStyledField {
    private static string m_passwordValue;
    private PdfLoadedTextBoxItemCollection m_items;
    private PdfColor m_foreColor;
    private bool m_autoSize;
    private bool m_applyAppearence;
    public bool ComplexScript { get; public set; }
    public PdfColor BackColor { get; public set; }
    public PdfColor ForeColor { get; public set; }
    public PdfTextAlignment TextAlignment { get; public set; }
    public PdfHighlightMode HighlightMode { get; public set; }
    public string Text { get; public set; }
    public string DefaultValue { get; public set; }
    public bool SpellCheck { get; public set; }
    public bool InsertSpaces { get; public set; }
    public bool Multiline { get; public set; }
    public bool Password { get; public set; }
    public bool Scrollable { get; public set; }
    public int MaxLength { get; public set; }
    public bool IsAutoFontSize { get; }
    public bool AutoResizeText { get; public set; }
    public PdfLoadedTextBoxItemCollection Items { get; internal set; }
    internal PdfLoadedTextBoxField(PdfDictionary dictionary, PdfCrossTable crossTable);
    public bool get_ComplexScript();
    public void set_ComplexScript(bool value);
    public PdfColor get_BackColor();
    public void set_BackColor(PdfColor value);
    public virtual PdfColor get_ForeColor();
    public virtual void set_ForeColor(PdfColor value);
    public PdfTextAlignment get_TextAlignment();
    public void set_TextAlignment(PdfTextAlignment value);
    public PdfHighlightMode get_HighlightMode();
    public void set_HighlightMode(PdfHighlightMode value);
    public string get_Text();
    public void set_Text(string value);
    public string get_DefaultValue();
    public void set_DefaultValue(string value);
    public bool get_SpellCheck();
    public void set_SpellCheck(bool value);
    public bool get_InsertSpaces();
    public void set_InsertSpaces(bool value);
    public bool get_Multiline();
    public void set_Multiline(bool value);
    public bool get_Password();
    public void set_Password(bool value);
    public bool get_Scrollable();
    public void set_Scrollable(bool value);
    public int get_MaxLength();
    public void set_MaxLength(int value);
    public bool get_IsAutoFontSize();
    public bool get_AutoResizeText();
    public void set_AutoResizeText(bool value);
    public PdfLoadedTextBoxItemCollection get_Items();
    internal void set_Items(PdfLoadedTextBoxItemCollection value);
    private void UpdateXfaFieldData(PdfLoadedXfaField field);
    internal virtual void Dictionary_BeginSave(object sender, SavePdfPrimitiveEventArgs ars);
    private string HighlightModeToString(PdfHighlightMode m_highlightingMode);
    private PdfHighlightMode GetHighlightModeFromString(PdfName hightlightMode);
    internal virtual void BeginSave();
    internal PdfField Clone(PdfDictionary dictionary, PdfPage page);
    internal PdfLoadedStyledField Clone();
    internal virtual PdfLoadedFieldItem CreateLoadedItem(PdfDictionary dictionary);
    private void ApplyAppearance(PdfDictionary widget, PdfLoadedFieldItem item);
    internal virtual void Draw();
    private void DrawTextBox(PdfGraphics graphics, PdfLoadedFieldItem item);
    internal bool IsRTLChar(char input);
    private void SetFittingFontSize(GraphicsProperties& gp, PaintParams prms, string text);
    private void SetMultiLineFontSize(GraphicsProperties& gp, string text);
    private bool isRTL(string text);
    private bool IsRTLText(UInt16[] characterCodes);
    internal virtual float GetFontHeight(PdfFontFamily family);
    private bool IsUnicodeStandardFont();
    private static bool IsChineseString(string text);
    private bool FindAppearanceDrawFromStream(PdfStream apperenceStream);
    private float FindAppearanceFontSizeFromStream(PdfStream apperenceStream);
    private string FindOperator(int token);
    public void RemoveAt(int index);
    public void Remove(PdfLoadedTexBoxItem item);
    private void MapNumberFormat(string text, bool updateDictionary, String& finalText, Boolean& replace);
    private void ConvertUnicodeToCurrency(Char[] chars, bool preAppend, String[] splitted, Boolean& space, String& currencyText);
    private void UpdateNegativeTextWithCurrency(bool negativeText, int negativeNumberStyle, bool preAppend, string currencyText, string number, bool space, String& finalText);
    private void UpdateNumberFormatTextAlone(int separatorStyle, string number, String[] splitted, bool negativeText, String& finalText, Boolean& replace);
    private string UpdateTextFromSeparatorStyle(int separatorStyle, string number, String[] splitted, int decimalSpace, string text);
    private string UpdateTextWithDecimalBreak(string number, string decimalProcess, string text, int separatorStyle, string symbol);
    private string UpdateDecimalRoundOffText(string number, decimal parsedNumber, int decimalSpace, int separatorStyle, string symbol);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[DefaultMemberAttribute("Item")]
public class Syncfusion.Pdf.Parsing.PdfLoadedTextBoxItemCollection : PdfCollection {
    public PdfLoadedTexBoxItem Item { get; }
    public PdfLoadedTexBoxItem get_Item(int index);
    internal void Add(PdfLoadedTexBoxItem item);
    internal int Remove(PdfLoadedTexBoxItem item);
    internal PdfLoadedTextBoxItemCollection Clone();
}
public class Syncfusion.Pdf.Parsing.PdfRevision : object {
    private long startPosition;
    public long StartPosition { get; internal set; }
    public long get_StartPosition();
    internal void set_StartPosition(long value);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class Syncfusion.Pdf.Parsing.PdfSignatureValidationOptions : object {
    private bool m_revocation;
    private RevocationValidationType m_revocationValidationType;
    private List`1<Byte[]> ocspExternalData;
    private List`1<Byte[]> crlExternalData;
    public bool ValidateRevocationStatus { get; public set; }
    public RevocationValidationType RevocationValidationType { get; public set; }
    internal List`1<Byte[]> OCSPResponseData { get; internal set; }
    internal List`1<Byte[]> CRLResponseData { get; internal set; }
    public bool get_ValidateRevocationStatus();
    public void set_ValidateRevocationStatus(bool value);
    public RevocationValidationType get_RevocationValidationType();
    public void set_RevocationValidationType(RevocationValidationType value);
    internal List`1<Byte[]> get_OCSPResponseData();
    internal void set_OCSPResponseData(List`1<Byte[]> value);
    internal List`1<Byte[]> get_CRLResponseData();
    internal void set_CRLResponseData(List`1<Byte[]> value);
}
public class Syncfusion.Pdf.Parsing.RedactionProgressEventArgs : object {
    internal float m_progress;
    public float Progress { get; }
    public float get_Progress();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class Syncfusion.Pdf.Parsing.SyntaxAnalyzerResult : object {
    private List`1<PdfException> m_errors;
    private bool m_isCorrupted;
    public List`1<PdfException> Errors { get; internal set; }
    public bool IsCorrupted { get; internal set; }
    public sealed virtual List`1<PdfException> get_Errors();
    internal void set_Errors(List`1<PdfException> value);
    public bool get_IsCorrupted();
    internal void set_IsCorrupted(bool value);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal static class Syncfusion.Pdf.Parsing.SystemFontAdobeGlyphList : object {
    internal static Dictionary`2<string, char> map;
    private static SystemFontAdobeGlyphList();
    internal static void Initialize();
    public static bool IsSupportedPdfName(string name);
    public static char GetUnicode(string names);
    private static char ParseHex(string hex);
    private static char GetUnicodeForName(string name);
}
internal class Syncfusion.Pdf.Parsing.SystemFontBezierSegment : SystemFontPathSegment {
    [CompilerGeneratedAttribute]
private Point <Point1>k__BackingField;
    [CompilerGeneratedAttribute]
private Point <Point2>k__BackingField;
    [CompilerGeneratedAttribute]
private Point <Point3>k__BackingField;
    public Point Point1 { get; public set; }
    public Point Point2 { get; public set; }
    public Point Point3 { get; public set; }
    [CompilerGeneratedAttribute]
public Point get_Point1();
    [CompilerGeneratedAttribute]
public void set_Point1(Point value);
    [CompilerGeneratedAttribute]
public Point get_Point2();
    [CompilerGeneratedAttribute]
public void set_Point2(Point value);
    [CompilerGeneratedAttribute]
public Point get_Point3();
    [CompilerGeneratedAttribute]
public void set_Point3(Point value);
    [NullableContextAttribute("1")]
public virtual SystemFontPathSegment Clone();
    public virtual void Transform(SystemFontMatrix transformMatrix);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal static class Syncfusion.Pdf.Parsing.SystemFontBitsHelper : object {
    internal static bool GetBit(int n, byte bit);
    internal static Byte[] GetBits(byte bt);
    internal static byte ToByte(Byte[] bits, int offset, int count);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Syncfusion.Pdf.Parsing.SystemFontBuffer`1 : ValueType {
    internal TElement[] items;
    internal int count;
    internal SystemFontBuffer`1(IEnumerable`1<TElement> source);
    internal TElement[] ToArray();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Syncfusion.Pdf.Parsing.SystemFontBuildChar : object {
    private static Dictionary`2<SystemFontOperatorDescriptor, SystemFontOperator> operators;
    private static SystemFontOperatorDescriptor endChar;
    private static SystemFontHintOperator vStem;
    private ISystemFontBuildCharHolder buildCharHolder;
    private SystemFontOperandsCollection postScriptStack;
    private SystemFontOperandsCollection operands;
    [CompilerGeneratedAttribute]
private SystemFontPathFigure <CurrentPathFigure>k__BackingField;
    [CompilerGeneratedAttribute]
private SystemFontGlyphOutlinesCollection <GlyphOutlines>k__BackingField;
    [CompilerGeneratedAttribute]
private Point <CurrentPoint>k__BackingField;
    [CompilerGeneratedAttribute]
private Point <BottomLeft>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<int> <Width>k__BackingField;
    [CompilerGeneratedAttribute]
private int <Hints>k__BackingField;
    internal SystemFontOperandsCollection Operands { get; }
    internal SystemFontOperandsCollection PostScriptStack { get; }
    internal SystemFontPathFigure CurrentPathFigure { get; internal set; }
    internal SystemFontGlyphOutlinesCollection GlyphOutlines { get; private set; }
    internal Point CurrentPoint { get; internal set; }
    internal Point BottomLeft { get; internal set; }
    internal Nullable`1<int> Width { get; internal set; }
    internal int Hints { get; internal set; }
    private static SystemFontBuildChar();
    public SystemFontBuildChar(ISystemFontBuildCharHolder subrsHodler);
    internal SystemFontOperandsCollection get_Operands();
    internal SystemFontOperandsCollection get_PostScriptStack();
    [CompilerGeneratedAttribute]
internal SystemFontPathFigure get_CurrentPathFigure();
    [CompilerGeneratedAttribute]
internal void set_CurrentPathFigure(SystemFontPathFigure value);
    [CompilerGeneratedAttribute]
internal SystemFontGlyphOutlinesCollection get_GlyphOutlines();
    [CompilerGeneratedAttribute]
private void set_GlyphOutlines(SystemFontGlyphOutlinesCollection value);
    [CompilerGeneratedAttribute]
internal Point get_CurrentPoint();
    [CompilerGeneratedAttribute]
internal void set_CurrentPoint(Point value);
    [CompilerGeneratedAttribute]
internal Point get_BottomLeft();
    [CompilerGeneratedAttribute]
internal void set_BottomLeft(Point value);
    [CompilerGeneratedAttribute]
internal Nullable`1<int> get_Width();
    [CompilerGeneratedAttribute]
internal void set_Width(Nullable`1<int> value);
    [CompilerGeneratedAttribute]
internal int get_Hints();
    [CompilerGeneratedAttribute]
internal void set_Hints(int value);
    internal static Point CalculatePoint(SystemFontBuildChar interpreter, int dx, int dy);
    private static void InitializePathConstructionOperators();
    private static bool IsOperator(byte b);
    private static bool IsTwoByteOperator(byte b);
    public void ExecuteSubr(int index);
    public void ExecuteGlobalSubr(int index);
    public void CombineChars(string accentedChar, string baseChar, int dx, int dy);
    public void Execute(Byte[] data);
    private void ExecuteInternal(Byte[] data);
    private int GetMaskSize();
    private void ExecuteOperator(SystemFontOperatorDescriptor descr, SystemFontEncodedDataReader reader);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal abstract class Syncfusion.Pdf.Parsing.SystemFontByteEncoding : object {
    private SystemFontRange range;
    [CompilerGeneratedAttribute]
private static SystemFontByteEncodingCollection <DictByteEncodings>k__BackingField;
    [CompilerGeneratedAttribute]
private static SystemFontByteEncodingCollection <CharStringByteEncodings>k__BackingField;
    public static SystemFontByteEncodingCollection DictByteEncodings { get; private set; }
    public static SystemFontByteEncodingCollection CharStringByteEncodings { get; private set; }
    private static SystemFontByteEncoding();
    public SystemFontByteEncoding(byte start, byte end);
    [CompilerGeneratedAttribute]
public static SystemFontByteEncodingCollection get_DictByteEncodings();
    [CompilerGeneratedAttribute]
private static void set_DictByteEncodings(SystemFontByteEncodingCollection value);
    [CompilerGeneratedAttribute]
public static SystemFontByteEncodingCollection get_CharStringByteEncodings();
    [CompilerGeneratedAttribute]
private static void set_CharStringByteEncodings(SystemFontByteEncodingCollection value);
    private static void InitializeDictByteEncodings();
    private static void InitializeCharStringByteEncodings();
    public abstract virtual object Read(SystemFontEncodedDataReader reader);
    public bool IsInRange(byte b0);
}
[NullableContextAttribute("1")]
[NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal class Syncfusion.Pdf.Parsing.SystemFontByteEncodingCollection : List`1<SystemFontByteEncoding> {
    public SystemFontByteEncoding FindEncoding(byte b0);
}
internal class Syncfusion.Pdf.Parsing.SystemFontCallGSubr : SystemFontOperator {
    [NullableContextAttribute("1")]
public virtual void Execute(SystemFontBuildChar interpreter);
}
internal class Syncfusion.Pdf.Parsing.SystemFontCallOtherSubr : SystemFontOperator {
    [NullableContextAttribute("1")]
public virtual void Execute(SystemFontBuildChar interpreter);
}
internal class Syncfusion.Pdf.Parsing.SystemFontCallSubr : SystemFontOperator {
    [NullableContextAttribute("1")]
public virtual void Execute(SystemFontBuildChar interpreter);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Syncfusion.Pdf.Parsing.SystemFontCFFFontFile : object {
    private SystemFontCFFFontReader reader;
    private SystemFontCFFFontSource fontSource;
    [CompilerGeneratedAttribute]
private SystemFontHeader <Header>k__BackingField;
    [CompilerGeneratedAttribute]
private SystemFontNameIndex <Name>k__BackingField;
    [CompilerGeneratedAttribute]
private SystemFontTopIndex <TopIndex>k__BackingField;
    [CompilerGeneratedAttribute]
private SystemFontStringIndex <StringIndex>k__BackingField;
    [CompilerGeneratedAttribute]
private SystemFontSubrsIndex <GlobalSubrs>k__BackingField;
    public SystemFontCFFFontSource FontSource { get; }
    public SystemFontHeader Header { get; private set; }
    public SystemFontNameIndex Name { get; private set; }
    public SystemFontTopIndex TopIndex { get; private set; }
    public SystemFontStringIndex StringIndex { get; private set; }
    public SystemFontSubrsIndex GlobalSubrs { get; private set; }
    public SystemFontCFFFontReader Reader { get; }
    public SystemFontCFFFontFile(Byte[] data);
    public SystemFontCFFFontSource get_FontSource();
    [CompilerGeneratedAttribute]
public SystemFontHeader get_Header();
    [CompilerGeneratedAttribute]
private void set_Header(SystemFontHeader value);
    [CompilerGeneratedAttribute]
public SystemFontNameIndex get_Name();
    [CompilerGeneratedAttribute]
private void set_Name(SystemFontNameIndex value);
    [CompilerGeneratedAttribute]
public SystemFontTopIndex get_TopIndex();
    [CompilerGeneratedAttribute]
private void set_TopIndex(SystemFontTopIndex value);
    [CompilerGeneratedAttribute]
public SystemFontStringIndex get_StringIndex();
    [CompilerGeneratedAttribute]
private void set_StringIndex(SystemFontStringIndex value);
    [CompilerGeneratedAttribute]
public SystemFontSubrsIndex get_GlobalSubrs();
    [CompilerGeneratedAttribute]
private void set_GlobalSubrs(SystemFontSubrsIndex value);
    public SystemFontCFFFontReader get_Reader();
    public string ReadString(ushort sid);
    internal void ReadTable(SystemFontCFFTable table);
    private void Initialize();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Syncfusion.Pdf.Parsing.SystemFontCFFFontReader : SystemFontReaderBase {
    public SystemFontCFFFontReader(Byte[] data);
    public byte ReadCard8();
    public ushort ReadCard16();
    public UInt32 ReadCard24();
    public UInt32 ReadCard32();
    public UInt32 ReadOffset(byte offsetSize);
    public byte ReadOffSize();
    public ushort ReadSID();
    public string ReadString(int length);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Syncfusion.Pdf.Parsing.SystemFontCFFFontSource : SystemFontFontSource {
    private SystemFontCFFFontFile file;
    private SystemFontTop top;
    internal SystemFontCFFFontFile File { get; }
    internal SystemFontCFFFontReader Reader { get; }
    public string FontFamily { get; }
    public bool IsBold { get; }
    public bool IsItalic { get; }
    public short Ascender { get; }
    public short Descender { get; }
    public bool UsesCIDFontOperators { get; }
    public SystemFontCFFFontSource(SystemFontCFFFontFile file, SystemFontTop top);
    internal SystemFontCFFFontFile get_File();
    internal SystemFontCFFFontReader get_Reader();
    public virtual string get_FontFamily();
    public virtual bool get_IsBold();
    public virtual bool get_IsItalic();
    public virtual short get_Ascender();
    public virtual short get_Descender();
    public bool get_UsesCIDFontOperators();
    public ushort GetGlyphId(string name);
    public ushort GetGlyphId(ushort cid);
    public string GetGlyphName(ushort cid);
    public virtual void GetAdvancedWidth(SystemFontGlyph glyph);
    public virtual void GetGlyphOutlines(SystemFontGlyph glyph, double fontSize);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Syncfusion.Pdf.Parsing.SystemFontCFFPredefinedEncoding : object {
    private UInt16[] sids;
    [CompilerGeneratedAttribute]
private static SystemFontCFFPredefinedEncoding <StandardEncoding>k__BackingField;
    [CompilerGeneratedAttribute]
private static SystemFontCFFPredefinedEncoding <ExpertEncoding>k__BackingField;
    public static SystemFontCFFPredefinedEncoding StandardEncoding { get; private set; }
    public static SystemFontCFFPredefinedEncoding ExpertEncoding { get; private set; }
    private static SystemFontCFFPredefinedEncoding();
    [CompilerGeneratedAttribute]
public static SystemFontCFFPredefinedEncoding get_StandardEncoding();
    [CompilerGeneratedAttribute]
private static void set_StandardEncoding(SystemFontCFFPredefinedEncoding value);
    [CompilerGeneratedAttribute]
public static SystemFontCFFPredefinedEncoding get_ExpertEncoding();
    [CompilerGeneratedAttribute]
private static void set_ExpertEncoding(SystemFontCFFPredefinedEncoding value);
    public static SystemFontCFFPredefinedEncoding GetPredefinedEncoding(int b);
    public static bool IsPredefinedEncoding(int b);
    private static void InitializeExpertEncoding();
    private static void InitializeStandardEncoding();
    public SystemFontPostScriptArray ToArray();
    public sealed virtual string GetGlyphName(SystemFontCFFFontFile fontFile, ushort index);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal abstract class Syncfusion.Pdf.Parsing.SystemFontCFFTable : object {
    private SystemFontCFFFontFile file;
    private long offset;
    protected SystemFontCFFFontReader Reader { get; }
    internal SystemFontCFFFontFile File { get; }
    public long Offset { get; }
    public SystemFontCFFTable(SystemFontCFFFontFile file, long offset);
    protected SystemFontCFFFontReader get_Reader();
    internal SystemFontCFFFontFile get_File();
    public long get_Offset();
    public abstract virtual void Read(SystemFontCFFFontReader reader);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[DefaultMemberAttribute("Item")]
internal class Syncfusion.Pdf.Parsing.SystemFontCharset : SystemFontCFFTable {
    internal static ushort NotDefIndex;
    private int count;
    private Dictionary`2<string, ushort> indices;
    private String[] names;
    public ushort Item { get; }
    public string Item { get; }
    public SystemFontCharset(SystemFontCFFFontFile file, long offset, int count);
    public SystemFontCharset(SystemFontCFFFontFile file, UInt16[] glyphs);
    public ushort get_Item(string name);
    public string get_Item(ushort index);
    private List`1<ushort> ReadFormat0(SystemFontCFFFontReader reader);
    private List`1<ushort> ReadFormat1(SystemFontCFFFontReader reader);
    private List`1<ushort> ReadFormat2(SystemFontCFFFontReader reader);
    private void Initialize(UInt16[] glyphs);
    public virtual void Read(SystemFontCFFFontReader reader);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[DefaultMemberAttribute("Item")]
internal class Syncfusion.Pdf.Parsing.SystemFontCharString : SystemFontIndex {
    private SystemFontType1GlyphData[] glyphOutlines;
    private SystemFontTop top;
    public SystemFontType1GlyphData Item { get; }
    public SystemFontCharString(SystemFontTop top, long offset);
    public SystemFontType1GlyphData get_Item(ushort index);
    public int GetAdvancedWidth(ushort glyphId, int defaultWidth, int nominalWidth);
    public void GetGlyphOutlines(SystemFontGlyph glyph, double fontSize);
    private SystemFontType1GlyphData ReadGlyphData(SystemFontCFFFontReader reader, UInt32 offset, int length);
    public virtual void Read(SystemFontCFFFontReader reader);
}
internal class Syncfusion.Pdf.Parsing.SystemFontClosePath : SystemFontOperator {
    [NullableContextAttribute("1")]
public virtual void Execute(SystemFontBuildChar buildChar);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Syncfusion.Pdf.Parsing.SystemFontCMap : SystemFontTrueTypeTableBase {
    private static ushort UNICODE_PLATFORM_ID;
    private static ushort WINDOWS_PLATFORM_ID;
    private static ushort DEFAULT_SEMANTIC_ID;
    private static ushort SYMBOL_ENCODING_ID;
    private static ushort UNICODE_ENCODING_ID;
    internal static ushort MISSING_GLYPH_ID;
    private SystemFontEncodingRecord[] encodings;
    private Dictionary`2<SystemFontEncodingRecord, SystemFontCMapTable> tables;
    private bool isInitialized;
    private SystemFontCMapTable encoding;
    internal UInt32 Tag { get; }
    public SystemFontCMap(SystemFontOpenTypeFontSourceBase fontFile);
    internal virtual UInt32 get_Tag();
    private void Initialize();
    private SystemFontCMapTable GetCMapTable(SystemFontOpenTypeFontReader reader, SystemFontEncodingRecord record);
    public SystemFontCMapTable GetCMapTable(ushort platformId, ushort encodingId);
    public ushort GetGlyphId(ushort unicode);
    public virtual void Read(SystemFontOpenTypeFontReader reader);
    internal virtual void Write(SystemFontFontWriter writer);
    internal virtual void Import(SystemFontOpenTypeFontReader reader);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Syncfusion.Pdf.Parsing.SystemFontCMapFormat0Table : SystemFontCMapTable {
    private static int GLYPH_IDS;
    private Byte[] glyphIdArray;
    public ushort FirstCode { get; }
    public virtual ushort get_FirstCode();
    public virtual ushort GetGlyphId(ushort charCode);
    public virtual void Read(SystemFontOpenTypeFontReader reader);
    public virtual void Write(SystemFontFontWriter writer);
    public virtual void Import(SystemFontOpenTypeFontReader reader);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Syncfusion.Pdf.Parsing.SystemFontCMapFormat4Table : SystemFontCMapTable {
    private SystemFontSegment[] segments;
    private ushort firstCode;
    public ushort FirstCode { get; }
    public virtual ushort get_FirstCode();
    public virtual ushort GetGlyphId(ushort charCode);
    public virtual void Read(SystemFontOpenTypeFontReader reader);
    public virtual void Write(SystemFontFontWriter writer);
    public virtual void Import(SystemFontOpenTypeFontReader reader);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Syncfusion.Pdf.Parsing.SystemFontCMapFormat6Table : SystemFontCMapTable {
    private ushort firstCode;
    private UInt16[] glyphIdArray;
    public ushort FirstCode { get; }
    public virtual ushort get_FirstCode();
    public virtual ushort GetGlyphId(ushort charCode);
    public virtual void Read(SystemFontOpenTypeFontReader reader);
    public virtual void Write(SystemFontFontWriter writer);
    public virtual void Import(SystemFontOpenTypeFontReader reader);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal abstract class Syncfusion.Pdf.Parsing.SystemFontCMapTable : object {
    public ushort FirstCode { get; }
    public abstract virtual ushort get_FirstCode();
    internal static SystemFontCMapTable ReadCMapTable(SystemFontOpenTypeFontReader reader);
    internal static SystemFontCMapTable ImportCMapTable(SystemFontOpenTypeFontReader reader);
    public abstract virtual ushort GetGlyphId(ushort charCode);
    public abstract virtual void Read(SystemFontOpenTypeFontReader reader);
    public abstract virtual void Write(SystemFontFontWriter writer);
    public abstract virtual void Import(SystemFontOpenTypeFontReader reader);
}
internal class Syncfusion.Pdf.Parsing.SystemFontCompareDelegate`2 : MulticastDelegate {
    public SystemFontCompareDelegate`2(object object, IntPtr method);
    [NullableContextAttribute("1")]
public virtual int Invoke(T1 left, T2 right);
    public virtual IAsyncResult BeginInvoke(T1 left, T2 right, AsyncCallback callback, object object);
    public virtual int EndInvoke(IAsyncResult result);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Syncfusion.Pdf.Parsing.SystemFontCompositeGlyph : SystemFontGlyphData {
    private List`1<SystemFontOutlinePoint[]> contours;
    internal IEnumerable`1<SystemFontOutlinePoint[]> Contours { get; }
    public SystemFontCompositeGlyph(SystemFontOpenTypeFontSourceBase fontFile, ushort glyphIndex);
    internal virtual IEnumerable`1<SystemFontOutlinePoint[]> get_Contours();
    private static SystemFontOutlinePoint GetTransformedPoint(SystemFontMatrix matrix, SystemFontOutlinePoint point);
    private void AddGlyph(SystemFontGlyphDescription gd);
    public virtual void Read(SystemFontOpenTypeFontReader reader);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal abstract class Syncfusion.Pdf.Parsing.SystemFontCoverage : SystemFontTableBase {
    public SystemFontCoverage(SystemFontOpenTypeFontSourceBase fontFile);
    private static SystemFontCoverage CreateCoverageTable(SystemFontOpenTypeFontSourceBase fontSource, SystemFontOpenTypeFontReader reader);
    internal static SystemFontCoverage ReadCoverageTable(SystemFontOpenTypeFontSourceBase fontSource, SystemFontOpenTypeFontReader reader);
    internal static SystemFontCoverage ImportCoverageTable(SystemFontOpenTypeFontSourceBase fontSource, SystemFontOpenTypeFontReader reader);
    internal virtual void Import(SystemFontOpenTypeFontReader reader);
    public abstract virtual int GetCoverageIndex(ushort glyphIndex);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Syncfusion.Pdf.Parsing.SystemFontCoverageFormat1 : SystemFontCoverage {
    public SystemFontCoverageFormat1(SystemFontOpenTypeFontSourceBase fontFile);
    public virtual void Read(SystemFontOpenTypeFontReader reader);
    public virtual int GetCoverageIndex(ushort glyphIndex);
    internal virtual void Write(SystemFontFontWriter writer);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Syncfusion.Pdf.Parsing.SystemFontCoverageFormat2 : SystemFontCoverage {
    private SystemFontRangeRecord[] rangeRecords;
    public SystemFontCoverageFormat2(SystemFontOpenTypeFontSourceBase fontFile);
    public virtual void Read(SystemFontOpenTypeFontReader reader);
    internal virtual void Write(SystemFontFontWriter writer);
    public virtual int GetCoverageIndex(ushort glyphIndex);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Syncfusion.Pdf.Parsing.SystemFontDict : SystemFontCFFTable {
    private int length;
    [CompilerGeneratedAttribute]
private Dictionary`2<SystemFontOperatorDescriptor, SystemFontOperandsCollection> <Data>k__BackingField;
    protected Dictionary`2<SystemFontOperatorDescriptor, SystemFontOperandsCollection> Data { get; private set; }
    public long SkipOffset { get; }
    public SystemFontDict(SystemFontCFFFontFile file, long offset, int length);
    [CompilerGeneratedAttribute]
protected Dictionary`2<SystemFontOperatorDescriptor, SystemFontOperandsCollection> get_Data();
    [CompilerGeneratedAttribute]
private void set_Data(Dictionary`2<SystemFontOperatorDescriptor, SystemFontOperandsCollection> value);
    public long get_SkipOffset();
    private static bool IsOperator(byte b);
    private static bool IsTwoByteOperator(byte b);
    protected int GetInt(SystemFontOperatorDescriptor op);
    protected SystemFontOperandsCollection GetOperands(SystemFontOperatorDescriptor op);
    protected double GetNumber(SystemFontOperatorDescriptor op);
    protected SystemFontPostScriptArray GetArray(SystemFontOperatorDescriptor op);
    public virtual void Read(SystemFontCFFFontReader reader);
}
internal class Syncfusion.Pdf.Parsing.SystemFontDiv : SystemFontOperator {
    [NullableContextAttribute("1")]
public virtual void Execute(SystemFontBuildChar buildChar);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal static class Syncfusion.Pdf.Parsing.SystemFontDocumentsHelper : object {
    public static char SpaceSymbol;
    public static char TabSymbol;
    public static char NewLine;
    public static char ZeroWidthSymbol;
    public static char LineHeightMeasureSymbol;
    public static Uri GetResourceUri(string resource);
    public static Stream GetResourceStream(string resource);
    public static bool IsLineBreak(char ch);
    public static bool IsTab(char ch);
    public static bool IsWhiteSpace(char ch);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Syncfusion.Pdf.Parsing.SystemFontEmptyEnumerable`1 : object {
    private static TElement[] instance;
    public static IEnumerable`1<TElement> Instance { get; }
    public static IEnumerable`1<TElement> get_Instance();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Syncfusion.Pdf.Parsing.SystemFontEncodedDataReader : SystemFontReaderBase {
    private SystemFontByteEncodingCollection encodings;
    public SystemFontEncodedDataReader(Byte[] data, SystemFontByteEncodingCollection encodings);
    public object ReadOperand();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Syncfusion.Pdf.Parsing.SystemFontEncoding : SystemFontCFFTable {
    private SystemFontCharset charset;
    private List`1<ushort> gids;
    [CompilerGeneratedAttribute]
private SystemFontSupplementalEncoding <SupplementalEncoding>k__BackingField;
    public SystemFontSupplementalEncoding SupplementalEncoding { get; private set; }
    public SystemFontEncoding(SystemFontCFFFontFile file, SystemFontCharset charset, long offset);
    [CompilerGeneratedAttribute]
public SystemFontSupplementalEncoding get_SupplementalEncoding();
    [CompilerGeneratedAttribute]
private void set_SupplementalEncoding(SystemFontSupplementalEncoding value);
    private void ReadFormat0(SystemFontCFFFontReader reader);
    private void ReadFormat1(SystemFontCFFFontReader reader);
    public virtual void Read(SystemFontCFFFontReader reader);
    public sealed virtual string GetGlyphName(SystemFontCFFFontFile fontFile, ushort index);
}
internal class Syncfusion.Pdf.Parsing.SystemFontEncodingRecord : object {
    [CompilerGeneratedAttribute]
private ushort <PlatformId>k__BackingField;
    [CompilerGeneratedAttribute]
private ushort <EncodingId>k__BackingField;
    [CompilerGeneratedAttribute]
private UInt32 <Offset>k__BackingField;
    public ushort PlatformId { get; public set; }
    public ushort EncodingId { get; public set; }
    public UInt32 Offset { get; public set; }
    [CompilerGeneratedAttribute]
public ushort get_PlatformId();
    [CompilerGeneratedAttribute]
public void set_PlatformId(ushort value);
    [CompilerGeneratedAttribute]
public ushort get_EncodingId();
    [CompilerGeneratedAttribute]
public void set_EncodingId(ushort value);
    [CompilerGeneratedAttribute]
public UInt32 get_Offset();
    [CompilerGeneratedAttribute]
public void set_Offset(UInt32 value);
    [NullableContextAttribute("1")]
public void Read(SystemFontOpenTypeFontReader reader);
}
internal class Syncfusion.Pdf.Parsing.SystemFontEndChar : SystemFontOperator {
    [NullableContextAttribute("1")]
public virtual void Execute(SystemFontBuildChar buildChar);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal static class Syncfusion.Pdf.Parsing.SystemFontEnumerable : object {
    public static int Count(IEnumerable`1<TSource> source);
    public static bool Any(IEnumerable`1<TSource> source);
    public static bool All(IEnumerable`1<TSource> source, Func`2<TSource, bool> predicate);
    public static bool Any(IEnumerable`1<TSource> source, Func`2<TSource, bool> predicate);
    public static IEnumerable`1<TResult> OfType(IEnumerable source);
    [IteratorStateMachineAttribute("Syncfusion.Pdf.Parsing.SystemFontEnumerable/<OfTypeIterator>d__5`1")]
private static IEnumerable`1<TResult> OfTypeIterator(IEnumerable source);
    public static TSource FirstOrDefault(IEnumerable`1<TSource> source);
    public static TSource FirstOrDefault(IEnumerable`1<TSource> source, Func`2<TSource, bool> predicate);
    public static TSource First(IEnumerable`1<TSource> source);
    public static TSource First(IEnumerable`1<TSource> source, Func`2<TSource, bool> selector);
    public static bool Contains(IEnumerable`1<TSource> source, TSource value);
    public static bool Contains(IEnumerable`1<TSource> source, TSource value, IEqualityComparer`1<TSource> comparer);
    public static TSource[] ToArray(IEnumerable`1<TSource> source);
    public static List`1<TSource> ToList(IEnumerable`1<TSource> source);
    public static IEnumerable`1<TResult> Empty();
    public static byte Max(IEnumerable`1<byte> source);
    public static byte Max(IEnumerable`1<TSource> source, Func`2<TSource, byte> selector);
    public static double Sum(IEnumerable`1<double> source);
    public static int Sum(IEnumerable`1<int> source);
    public static int Sum(IEnumerable`1<TSource> source, Func`2<TSource, int> selector);
    [IteratorStateMachineAttribute("Syncfusion.Pdf.Parsing.SystemFontEnumerable/<Skip>d__20`1")]
public static IEnumerable`1<TSource> Skip(IEnumerable`1<TSource> source, int count);
    [IteratorStateMachineAttribute("Syncfusion.Pdf.Parsing.SystemFontEnumerable/<Select>d__21`2")]
public static IEnumerable`1<TResult> Select(IEnumerable`1<TSource> source, Func`2<TSource, TResult> selector);
    [IteratorStateMachineAttribute("Syncfusion.Pdf.Parsing.SystemFontEnumerable/<Where>d__22`1")]
public static IEnumerable`1<TSource> Where(IEnumerable`1<TSource> source, Func`2<TSource, bool> predicate);
    public static IEnumerable`1<TSource> Take(IEnumerable`1<TSource> source, int count);
    [IteratorStateMachineAttribute("Syncfusion.Pdf.Parsing.SystemFontEnumerable/<TakeIterator>d__24`1")]
private static IEnumerable`1<TSource> TakeIterator(IEnumerable`1<TSource> source, int count);
    public static IEnumerable`1<TSource> Concat(IEnumerable`1<TSource> first, IEnumerable`1<TSource> second);
    [IteratorStateMachineAttribute("Syncfusion.Pdf.Parsing.SystemFontEnumerable/<ConcatIterator>d__26`1")]
private static IEnumerable`1<TSource> ConcatIterator(IEnumerable`1<TSource> first, IEnumerable`1<TSource> second);
    public static TSource Last(IEnumerable`1<TSource> source);
    public static ISystemFontOrderedEnumerable`1<TSource> OrderBy(IEnumerable`1<TSource> source, Func`2<TSource, TKey> keySelector);
    public static ISystemFontOrderedEnumerable`1<TSource> OrderBy(IEnumerable`1<TSource> source, Func`2<TSource, TKey> keySelector, IComparer`1<TKey> comparer);
    public static TSource ElementAt(IEnumerable`1<TSource> source, int index);
    public static TSource LastOrDefault(IEnumerable`1<TSource> source);
    public static TSource LastOrDefault(IEnumerable`1<TSource> source, Func`2<TSource, bool> predicate);
    public static TSource SingleOrDefault(IEnumerable`1<TSource> source);
    public static TSource SingleOrDefault(IEnumerable`1<TSource> source, Func`2<TSource, bool> predicate);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal abstract class Syncfusion.Pdf.Parsing.SystemFontEnumerableSorter`1 : object {
    internal abstract virtual int CompareKeys(int index1, int index2);
    internal abstract virtual void ComputeKeys(TElement[] elements, int count);
    private void QuickSort(Int32[] map, int left, int right);
    internal Int32[] Sort(TElement[] elements, int count);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal static class Syncfusion.Pdf.Parsing.SystemFontExtensions : object {
    private static int BUFFER_SIZE;
    public static T1 FindElement(IEnumerable`1<T1> collection, T2 index, SystemFontCompareDelegate`2<T1, T2> comparer);
    internal static Byte[] ReadAllBytes(Stream reader);
    private static T1 FindElement(IEnumerable`1<T1> collection, int lo, int hi, T2 element, SystemFontCompareDelegate`2<T1, T2> comparer);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Syncfusion.Pdf.Parsing.SystemFontFallbackRange : object {
    private static List`1<SystemFontFallbackRange> fallbackRanges;
    [CompilerGeneratedAttribute]
private SystemFontRange[] <Ranges>k__BackingField;
    [CompilerGeneratedAttribute]
private String[] <FallbackFontFamilies>k__BackingField;
    public SystemFontRange[] Ranges { get; private set; }
    public String[] FallbackFontFamilies { get; private set; }
    private static SystemFontFallbackRange();
    public SystemFontFallbackRange(SystemFontRange[] ranges, String[] fallbackFontFamilies);
    [CompilerGeneratedAttribute]
public SystemFontRange[] get_Ranges();
    [CompilerGeneratedAttribute]
private void set_Ranges(SystemFontRange[] value);
    [CompilerGeneratedAttribute]
public String[] get_FallbackFontFamilies();
    [CompilerGeneratedAttribute]
private void set_FallbackFontFamilies(String[] value);
    private static void InitializeFallbackRanges();
    internal static SystemFontFallbackRange GetFallbackRange(char unicode);
    public bool FallsInRange(char unicode);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Syncfusion.Pdf.Parsing.SystemFontFeature : SystemFontTableBase {
    private UInt16[] lookupListIndices;
    [CompilerGeneratedAttribute]
private SystemFontFeatureInfo <FeatureInfo>k__BackingField;
    public SystemFontFeatureInfo FeatureInfo { get; private set; }
    public UInt16[] LookupsListIndices { get; }
    public SystemFontFeature(SystemFontOpenTypeFontSourceBase fontFile, SystemFontFeatureInfo featureInfo);
    [CompilerGeneratedAttribute]
public SystemFontFeatureInfo get_FeatureInfo();
    [CompilerGeneratedAttribute]
private void set_FeatureInfo(SystemFontFeatureInfo value);
    public UInt16[] get_LookupsListIndices();
    public virtual void Read(SystemFontOpenTypeFontReader reader);
    internal virtual void Write(SystemFontFontWriter writer);
    internal virtual void Import(SystemFontOpenTypeFontReader reader);
    public virtual string ToString();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal abstract class Syncfusion.Pdf.Parsing.SystemFontFeatureInfo : object {
    public UInt32 Tag { get; }
    public FeatureType Type { get; }
    public abstract virtual UInt32 get_Tag();
    public abstract virtual FeatureType get_Type();
    internal static SystemFontFeatureInfo CreateFeatureInfo(UInt32 featureTag);
    private static SystemFontGlyphsSequence ApplyMultipleSubstitutionLookup(SystemFontLookup lookup, SystemFontGlyphsSequence glyphIDs);
    public abstract virtual bool ShouldApply(SystemFontGlyphInfo glyphIndex);
    public SystemFontGlyphsSequence ApplyLookup(SystemFontLookup lookup, SystemFontGlyphsSequence glyphIDs);
    private SystemFontGlyphsSequence ApplySingleGlyphSubstitutionLookup(SystemFontLookup lookup, SystemFontGlyphsSequence glyphIDs);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Syncfusion.Pdf.Parsing.SystemFontFeatureList : SystemFontTableBase {
    private SystemFontFeatureRecord[] featureRecords;
    private SystemFontFeature[] features;
    public SystemFontFeatureList(SystemFontOpenTypeFontSourceBase fontFile);
    private SystemFontFeature ReadFeature(SystemFontOpenTypeFontReader reader, SystemFontFeatureRecord record);
    public SystemFontFeature GetFeature(int index);
    public virtual void Read(SystemFontOpenTypeFontReader reader);
    internal virtual void Write(SystemFontFontWriter writer);
    internal virtual void Import(SystemFontOpenTypeFontReader reader);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Syncfusion.Pdf.Parsing.SystemFontFeatureRecord : object {
    [CompilerGeneratedAttribute]
private UInt32 <FeatureTag>k__BackingField;
    [CompilerGeneratedAttribute]
private ushort <FeatureOffset>k__BackingField;
    public UInt32 FeatureTag { get; private set; }
    public ushort FeatureOffset { get; private set; }
    [CompilerGeneratedAttribute]
public UInt32 get_FeatureTag();
    [CompilerGeneratedAttribute]
private void set_FeatureTag(UInt32 value);
    [CompilerGeneratedAttribute]
public ushort get_FeatureOffset();
    [CompilerGeneratedAttribute]
private void set_FeatureOffset(ushort value);
    public void Read(SystemFontOpenTypeFontReader reader);
    public virtual string ToString();
}
internal enum Syncfusion.Pdf.Parsing.SystemFontFillRule : Enum {
    public int value__;
    public static SystemFontFillRule EvenOdd;
    public static SystemFontFillRule Nonzero;
}
internal class Syncfusion.Pdf.Parsing.SystemFontFinalFeatureInfo : SystemFontFeatureInfo {
    public UInt32 Tag { get; }
    public FeatureType Type { get; }
    public virtual UInt32 get_Tag();
    public virtual FeatureType get_Type();
    [NullableContextAttribute("1")]
public virtual bool ShouldApply(SystemFontGlyphInfo glyphInfo);
}
internal class Syncfusion.Pdf.Parsing.SystemFontFiveByteFixedEncoding : SystemFontByteEncoding {
    [NullableContextAttribute("1")]
public virtual object Read(SystemFontEncodedDataReader reader);
}
internal class Syncfusion.Pdf.Parsing.SystemFontFiveByteIntegerEncoding : SystemFontByteEncoding {
    [NullableContextAttribute("1")]
public virtual object Read(SystemFontEncodedDataReader reader);
}
internal class Syncfusion.Pdf.Parsing.SystemFontFlex : SystemFontOperator {
    [NullableContextAttribute("1")]
public virtual void Execute(SystemFontBuildChar buildChar);
}
internal class Syncfusion.Pdf.Parsing.SystemFontFlex1 : SystemFontOperator {
    [NullableContextAttribute("1")]
public virtual void Execute(SystemFontBuildChar buildChar);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Syncfusion.Pdf.Parsing.SystemFontFontDescriptor : object {
    private string fontFamily;
    private FontStyle fontStyle;
    public string FontFamily { get; }
    public FontStyle FontStyle { get; }
    public SystemFontFontDescriptor(string fontFamily);
    public SystemFontFontDescriptor(string fontFamily, FontStyle fontStyle);
    public string get_FontFamily();
    public FontStyle get_FontStyle();
    public static bool op_Equality(SystemFontFontDescriptor left, SystemFontFontDescriptor right);
    public static bool op_Inequality(SystemFontFontDescriptor left, SystemFontFontDescriptor right);
    private static FontStyle GetFontStyle(string styles, FontStyle baseStyle);
    public virtual int GetHashCode();
    public virtual bool Equals(object obj);
    public virtual string ToString();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Syncfusion.Pdf.Parsing.SystemFontFontsManager : object {
    private static string RegistryFontPath;
    private Dictionary`2<SystemFontFontDescriptor, SystemFontOpenTypeFontSourceBase> fonts;
    internal SystemFontOpenTypeFontSourceBase GetFontSource(SystemFontFontDescriptor descr);
    internal SystemFontOpenTypeFontSource GetOpenTypeFontSource(string fontName, FontStyle style);
    internal string FontFallback(string fontFamily);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal abstract class Syncfusion.Pdf.Parsing.SystemFontFontSource : object {
    public string FontFamily { get; }
    public bool IsBold { get; }
    public bool IsItalic { get; }
    public short Ascender { get; }
    public short Descender { get; }
    public abstract virtual string get_FontFamily();
    public abstract virtual bool get_IsBold();
    public abstract virtual bool get_IsItalic();
    public abstract virtual short get_Ascender();
    public abstract virtual short get_Descender();
    internal static SystemFontFontType GetFontType(SystemFontOpenTypeFontReader reader);
    public virtual void GetAdvancedWidth(SystemFontGlyph glyph);
    public virtual void GetGlyphOutlines(SystemFontGlyph glyph, double fontSize);
}
internal enum Syncfusion.Pdf.Parsing.SystemFontFontType : Enum {
    public int value__;
    public static SystemFontFontType Unknown;
    public static SystemFontFontType TrueType;
    public static SystemFontFontType TrueTypeCollection;
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Syncfusion.Pdf.Parsing.SystemFontFontWriter : object {
    private BinaryWriter writer;
    private Stream stream;
    private void WriteBE(Byte[] buffer, int count);
    public void Write(byte b);
    public void WriteChar(sbyte ch);
    public void WriteUShort(ushort us);
    public void WriteShort(short s);
    public void WriteULong(UInt32 ul);
    public void WriteLong(int l);
    public void WriteString(string str);
    public Byte[] GetBytes();
    public sealed virtual void Dispose();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Syncfusion.Pdf.Parsing.SystemFontFormat0KerningSubTable : SystemFontKerningSubTable {
    private Dictionary`2<ushort, Dictionary`2<ushort, short>> values;
    public SystemFontFormat0KerningSubTable(SystemFontOpenTypeFontSourceBase fontSource);
    public virtual short GetValue(ushort leftGlyphIndex, ushort rightGlyphIndex);
    public virtual void Read(SystemFontOpenTypeFontReader reader);
    internal virtual void Write(SystemFontFontWriter writer);
    internal virtual void Import(SystemFontOpenTypeFontReader reader);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Syncfusion.Pdf.Parsing.SystemFontGlyph : object {
    [CompilerGeneratedAttribute]
private ushort <GlyphId>k__BackingField;
    [CompilerGeneratedAttribute]
private CharCode <CharId>k__BackingField;
    [CompilerGeneratedAttribute]
private SystemFontGlyphOutlinesCollection <Outlines>k__BackingField;
    [CompilerGeneratedAttribute]
private double <AdvancedWidth>k__BackingField;
    [CompilerGeneratedAttribute]
private Point <HorizontalKerning>k__BackingField;
    [CompilerGeneratedAttribute]
private Point <VerticalKerning>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Name>k__BackingField;
    private double descent;
    [CompilerGeneratedAttribute]
private int <FontId>k__BackingField;
    [CompilerGeneratedAttribute]
private string <ToUnicode>k__BackingField;
    [CompilerGeneratedAttribute]
private string <FontFamily>k__BackingField;
    [CompilerGeneratedAttribute]
private FontStyle <FontStyle>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsBold>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsItalic>k__BackingField;
    [CompilerGeneratedAttribute]
private double <FontSize>k__BackingField;
    [CompilerGeneratedAttribute]
private double <Rise>k__BackingField;
    [CompilerGeneratedAttribute]
private double <CharSpacing>k__BackingField;
    [CompilerGeneratedAttribute]
private double <WordSpacing>k__BackingField;
    [CompilerGeneratedAttribute]
private double <HorizontalScaling>k__BackingField;
    [CompilerGeneratedAttribute]
private double <Width>k__BackingField;
    [CompilerGeneratedAttribute]
private double <Ascent>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsFilled>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsStroked>k__BackingField;
    [CompilerGeneratedAttribute]
private SystemFontMatrix <TransformMatrix>k__BackingField;
    [CompilerGeneratedAttribute]
private Size <Size>k__BackingField;
    [CompilerGeneratedAttribute]
private Rect <BoundingRect>k__BackingField;
    [CompilerGeneratedAttribute]
private int <ZIndex>k__BackingField;
    [CompilerGeneratedAttribute]
private SystemFontPathGeometry <Clip>k__BackingField;
    [CompilerGeneratedAttribute]
private double <StrokeThickness>k__BackingField;
    internal ushort GlyphId { get; internal set; }
    public CharCode CharId { get; public set; }
    public SystemFontGlyphOutlinesCollection Outlines { get; public set; }
    public double AdvancedWidth { get; public set; }
    public Point HorizontalKerning { get; public set; }
    public Point VerticalKerning { get; public set; }
    public string Name { get; public set; }
    public int FontId { get; public set; }
    public string ToUnicode { get; public set; }
    public string FontFamily { get; public set; }
    public FontStyle FontStyle { get; public set; }
    public bool IsBold { get; public set; }
    public bool IsItalic { get; public set; }
    public double FontSize { get; public set; }
    public double Rise { get; public set; }
    public double CharSpacing { get; public set; }
    public double WordSpacing { get; public set; }
    public double HorizontalScaling { get; public set; }
    public double Width { get; public set; }
    public double Ascent { get; public set; }
    public double Descent { get; public set; }
    public bool IsFilled { get; public set; }
    public bool IsStroked { get; public set; }
    public SystemFontMatrix TransformMatrix { get; public set; }
    public Size Size { get; public set; }
    public Rect BoundingRect { get; public set; }
    public int ZIndex { get; public set; }
    public SystemFontPathGeometry Clip { get; public set; }
    public bool HasChildren { get; }
    public double StrokeThickness { get; public set; }
    [CompilerGeneratedAttribute]
internal ushort get_GlyphId();
    [CompilerGeneratedAttribute]
internal void set_GlyphId(ushort value);
    [CompilerGeneratedAttribute]
public CharCode get_CharId();
    [CompilerGeneratedAttribute]
public void set_CharId(CharCode value);
    [CompilerGeneratedAttribute]
public SystemFontGlyphOutlinesCollection get_Outlines();
    [CompilerGeneratedAttribute]
public void set_Outlines(SystemFontGlyphOutlinesCollection value);
    [CompilerGeneratedAttribute]
public double get_AdvancedWidth();
    [CompilerGeneratedAttribute]
public void set_AdvancedWidth(double value);
    [CompilerGeneratedAttribute]
public Point get_HorizontalKerning();
    [CompilerGeneratedAttribute]
public void set_HorizontalKerning(Point value);
    [CompilerGeneratedAttribute]
public Point get_VerticalKerning();
    [CompilerGeneratedAttribute]
public void set_VerticalKerning(Point value);
    [CompilerGeneratedAttribute]
public string get_Name();
    [CompilerGeneratedAttribute]
public void set_Name(string value);
    [CompilerGeneratedAttribute]
public int get_FontId();
    [CompilerGeneratedAttribute]
public void set_FontId(int value);
    [CompilerGeneratedAttribute]
public string get_ToUnicode();
    [CompilerGeneratedAttribute]
public void set_ToUnicode(string value);
    [CompilerGeneratedAttribute]
public string get_FontFamily();
    [CompilerGeneratedAttribute]
public void set_FontFamily(string value);
    [CompilerGeneratedAttribute]
public FontStyle get_FontStyle();
    [CompilerGeneratedAttribute]
public void set_FontStyle(FontStyle value);
    [CompilerGeneratedAttribute]
public bool get_IsBold();
    [CompilerGeneratedAttribute]
public void set_IsBold(bool value);
    [CompilerGeneratedAttribute]
public bool get_IsItalic();
    [CompilerGeneratedAttribute]
public void set_IsItalic(bool value);
    [CompilerGeneratedAttribute]
public double get_FontSize();
    [CompilerGeneratedAttribute]
public void set_FontSize(double value);
    [CompilerGeneratedAttribute]
public double get_Rise();
    [CompilerGeneratedAttribute]
public void set_Rise(double value);
    [CompilerGeneratedAttribute]
public double get_CharSpacing();
    [CompilerGeneratedAttribute]
public void set_CharSpacing(double value);
    [CompilerGeneratedAttribute]
public double get_WordSpacing();
    [CompilerGeneratedAttribute]
public void set_WordSpacing(double value);
    [CompilerGeneratedAttribute]
public double get_HorizontalScaling();
    [CompilerGeneratedAttribute]
public void set_HorizontalScaling(double value);
    [CompilerGeneratedAttribute]
public double get_Width();
    [CompilerGeneratedAttribute]
public void set_Width(double value);
    [CompilerGeneratedAttribute]
public double get_Ascent();
    [CompilerGeneratedAttribute]
public void set_Ascent(double value);
    public double get_Descent();
    public void set_Descent(double value);
    [CompilerGeneratedAttribute]
public bool get_IsFilled();
    [CompilerGeneratedAttribute]
public void set_IsFilled(bool value);
    [CompilerGeneratedAttribute]
public bool get_IsStroked();
    [CompilerGeneratedAttribute]
public void set_IsStroked(bool value);
    [CompilerGeneratedAttribute]
public SystemFontMatrix get_TransformMatrix();
    [CompilerGeneratedAttribute]
public void set_TransformMatrix(SystemFontMatrix value);
    [CompilerGeneratedAttribute]
public Size get_Size();
    [CompilerGeneratedAttribute]
public void set_Size(Size value);
    [CompilerGeneratedAttribute]
public Rect get_BoundingRect();
    [CompilerGeneratedAttribute]
public void set_BoundingRect(Rect value);
    [CompilerGeneratedAttribute]
public int get_ZIndex();
    [CompilerGeneratedAttribute]
public void set_ZIndex(int value);
    [CompilerGeneratedAttribute]
public SystemFontPathGeometry get_Clip();
    [CompilerGeneratedAttribute]
public void set_Clip(SystemFontPathGeometry value);
    public bool get_HasChildren();
    [CompilerGeneratedAttribute]
public double get_StrokeThickness();
    [CompilerGeneratedAttribute]
public void set_StrokeThickness(double value);
    public virtual string ToString();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Syncfusion.Pdf.Parsing.SystemFontGlyphData : SystemFontTrueTypeTableBase {
    private ushort glyphIndex;
    [CompilerGeneratedAttribute]
private short <NumberOfContours>k__BackingField;
    [CompilerGeneratedAttribute]
private Rectangle <BoundingRect>k__BackingField;
    internal IEnumerable`1<SystemFontOutlinePoint[]> Contours { get; }
    internal UInt32 Tag { get; }
    internal short NumberOfContours { get; internal set; }
    public ushort GlyphIndex { get; }
    public Rectangle BoundingRect { get; public set; }
    public SystemFontGlyphData(SystemFontOpenTypeFontSourceBase fontFile, ushort glyphIndex);
    internal virtual IEnumerable`1<SystemFontOutlinePoint[]> get_Contours();
    internal virtual UInt32 get_Tag();
    [CompilerGeneratedAttribute]
internal short get_NumberOfContours();
    [CompilerGeneratedAttribute]
internal void set_NumberOfContours(short value);
    public ushort get_GlyphIndex();
    [CompilerGeneratedAttribute]
public Rectangle get_BoundingRect();
    [CompilerGeneratedAttribute]
public void set_BoundingRect(Rectangle value);
    public static SystemFontGlyphData ReadGlyf(SystemFontOpenTypeFontSourceBase fontFile, ushort glyphIndex);
    public virtual void Read(SystemFontOpenTypeFontReader reader);
}
internal class Syncfusion.Pdf.Parsing.SystemFontGlyphDescription : object {
    internal static int ARG_1_AND_2_ARE_WORDS;
    internal static int ARGS_ARE_XY_VALUES;
    internal static int ROUND_XY_TO_GRID;
    internal static int WE_HAVE_A_SCALE;
    internal static int MORE_COMPONENTS;
    internal static int WE_HAVE_AN_X_AND_Y_SCALE;
    internal static int WE_HAVE_A_TWO_BY_TWO;
    internal static int WE_HAVE_INSTRUCTIONS;
    internal static int USE_MY_METRICS;
    internal static int OVERLAP_COMPOUND;
    [CompilerGeneratedAttribute]
private ushort <Flags>k__BackingField;
    [CompilerGeneratedAttribute]
private ushort <GlyphIndex>k__BackingField;
    [CompilerGeneratedAttribute]
private SystemFontMatrix <Transform>k__BackingField;
    public ushort Flags { get; private set; }
    public ushort GlyphIndex { get; private set; }
    public SystemFontMatrix Transform { get; private set; }
    [CompilerGeneratedAttribute]
public ushort get_Flags();
    [CompilerGeneratedAttribute]
private void set_Flags(ushort value);
    [CompilerGeneratedAttribute]
public ushort get_GlyphIndex();
    [CompilerGeneratedAttribute]
private void set_GlyphIndex(ushort value);
    [CompilerGeneratedAttribute]
public SystemFontMatrix get_Transform();
    [CompilerGeneratedAttribute]
private void set_Transform(SystemFontMatrix value);
    internal bool CheckFlag(byte bit);
    [NullableContextAttribute("1")]
public void Read(SystemFontOpenTypeFontReader reader);
}
internal enum Syncfusion.Pdf.Parsing.SystemFontGlyphForm : Enum {
    public int value__;
    public static SystemFontGlyphForm Undefined;
    public static SystemFontGlyphForm Initial;
    public static SystemFontGlyphForm Medial;
    public static SystemFontGlyphForm Isolated;
    public static SystemFontGlyphForm Final;
}
internal class Syncfusion.Pdf.Parsing.SystemFontGlyphInfo : object {
    [CompilerGeneratedAttribute]
private ushort <GlyphId>k__BackingField;
    [CompilerGeneratedAttribute]
private SystemFontGlyphForm <Form>k__BackingField;
    public ushort GlyphId { get; private set; }
    public SystemFontGlyphForm Form { get; private set; }
    public SystemFontGlyphInfo(ushort glyphId);
    public SystemFontGlyphInfo(ushort glyphID, SystemFontGlyphForm form);
    [CompilerGeneratedAttribute]
public ushort get_GlyphId();
    [CompilerGeneratedAttribute]
private void set_GlyphId(ushort value);
    [CompilerGeneratedAttribute]
public SystemFontGlyphForm get_Form();
    [CompilerGeneratedAttribute]
private void set_Form(SystemFontGlyphForm value);
    [NullableContextAttribute("1")]
public virtual string ToString();
}
[NullableContextAttribute("1")]
[NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal class Syncfusion.Pdf.Parsing.SystemFontGlyphOutlinesCollection : List`1<SystemFontPathFigure> {
    public SystemFontGlyphOutlinesCollection Clone();
    public void Transform(SystemFontMatrix transformMatrix);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[DefaultMemberAttribute("Item")]
internal class Syncfusion.Pdf.Parsing.SystemFontGlyphsSequence : object {
    private List`1<SystemFontGlyphInfo> store;
    public SystemFontGlyphInfo Item { get; }
    public int Count { get; }
    public SystemFontGlyphsSequence(int capacity);
    public SystemFontGlyphInfo get_Item(int index);
    public int get_Count();
    public void Add(SystemFontGlyphInfo glyphInfo);
    public void Add(ushort glyphID, SystemFontGlyphForm form);
    public void Add(ushort glyphId);
    public void AddRange(IEnumerable`1<ushort> glyphIDs);
    public void AddRange(IEnumerable`1<SystemFontGlyphInfo> glyphIDs);
    public SystemFontGlyphForm GetGlyphForm(int index);
    public sealed virtual IEnumerator`1<SystemFontGlyphInfo> GetEnumerator();
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
    public virtual string ToString();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Syncfusion.Pdf.Parsing.SystemFontGlyphSubstitution : SystemFontTrueTypeTableBase {
    private ushort scriptListOffset;
    private ushort featureListOffset;
    private ushort lookupListOffset;
    private SystemFontScriptList scriptList;
    private SystemFontLookupList lookupList;
    private SystemFontFeatureList featureList;
    internal UInt32 Tag { get; }
    public SystemFontGlyphSubstitution(SystemFontOpenTypeFontSourceBase fontFile);
    internal virtual UInt32 get_Tag();
    private void ReadTable(T table, ushort offset);
    private void ReadScriptList();
    private void ReadFeatureList();
    private void ReadLookupList();
    public SystemFontScript GetScript(UInt32 tag);
    public SystemFontFeature GetFeature(ushort index);
    public SystemFontLookup GetLookup(ushort index);
    public virtual void Read(SystemFontOpenTypeFontReader reader);
    internal virtual void Write(SystemFontFontWriter writer);
    internal virtual void Import(SystemFontOpenTypeFontReader reader);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Syncfusion.Pdf.Parsing.SystemFontHead : SystemFontTrueTypeTableBase {
    private ushort macStyle;
    [CompilerGeneratedAttribute]
private ushort <Flags>k__BackingField;
    [CompilerGeneratedAttribute]
private short <GlyphDataFormat>k__BackingField;
    [CompilerGeneratedAttribute]
private ushort <UnitsPerEm>k__BackingField;
    [CompilerGeneratedAttribute]
private Rect <BBox>k__BackingField;
    [CompilerGeneratedAttribute]
private short <IndexToLocFormat>k__BackingField;
    internal UInt32 Tag { get; }
    public ushort Flags { get; private set; }
    public short GlyphDataFormat { get; private set; }
    public ushort UnitsPerEm { get; private set; }
    public Rect BBox { get; private set; }
    public short IndexToLocFormat { get; private set; }
    public bool IsBold { get; }
    public bool IsItalic { get; }
    public SystemFontHead(SystemFontOpenTypeFontSourceBase fontFile);
    internal virtual UInt32 get_Tag();
    [CompilerGeneratedAttribute]
public ushort get_Flags();
    [CompilerGeneratedAttribute]
private void set_Flags(ushort value);
    [CompilerGeneratedAttribute]
public short get_GlyphDataFormat();
    [CompilerGeneratedAttribute]
private void set_GlyphDataFormat(short value);
    [CompilerGeneratedAttribute]
public ushort get_UnitsPerEm();
    [CompilerGeneratedAttribute]
private void set_UnitsPerEm(ushort value);
    [CompilerGeneratedAttribute]
public Rect get_BBox();
    [CompilerGeneratedAttribute]
private void set_BBox(Rect value);
    [CompilerGeneratedAttribute]
public short get_IndexToLocFormat();
    [CompilerGeneratedAttribute]
private void set_IndexToLocFormat(short value);
    public bool get_IsBold();
    public bool get_IsItalic();
    private bool CheckMacStyle(byte bit);
    public virtual void Read(SystemFontOpenTypeFontReader reader);
    internal virtual void Write(SystemFontFontWriter writer);
    internal virtual void Import(SystemFontOpenTypeFontReader reader);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Syncfusion.Pdf.Parsing.SystemFontHeader : SystemFontCFFTable {
    [CompilerGeneratedAttribute]
private byte <HeaderSize>k__BackingField;
    [CompilerGeneratedAttribute]
private byte <OffSize>k__BackingField;
    public byte HeaderSize { get; public set; }
    public byte OffSize { get; public set; }
    public SystemFontHeader(SystemFontCFFFontFile file);
    [CompilerGeneratedAttribute]
public byte get_HeaderSize();
    [CompilerGeneratedAttribute]
public void set_HeaderSize(byte value);
    [CompilerGeneratedAttribute]
public byte get_OffSize();
    [CompilerGeneratedAttribute]
public void set_OffSize(byte value);
    public virtual void Read(SystemFontCFFFontReader reader);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal static class Syncfusion.Pdf.Parsing.SystemFontHelper : object {
    public static bool UnboxInteger(object number, Int32& res);
    public static bool UnboxReal(object number, Double& res);
    public static Byte[] CreateByteArray(Byte[] bytes);
}
internal class Syncfusion.Pdf.Parsing.SystemFontHFlex : SystemFontOperator {
    [NullableContextAttribute("1")]
public virtual void Execute(SystemFontBuildChar buildChar);
}
internal class Syncfusion.Pdf.Parsing.SystemFontHFlex1 : SystemFontOperator {
    [NullableContextAttribute("1")]
public virtual void Execute(SystemFontBuildChar buildChar);
}
internal class Syncfusion.Pdf.Parsing.SystemFontHHCurveTo : SystemFontOperator {
    [NullableContextAttribute("1")]
public virtual void Execute(SystemFontBuildChar interpreter);
}
internal class Syncfusion.Pdf.Parsing.SystemFontHintMaskOperator : SystemFontHintOperator {
    [NullableContextAttribute("1")]
public void Execute(SystemFontBuildChar interpreter, Byte[] mask);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Syncfusion.Pdf.Parsing.SystemFontHintOperator : SystemFontOperator {
    private static void ReadWidth(SystemFontBuildChar interpreter);
    public virtual void Execute(SystemFontBuildChar interpreter);
    internal void Execute(SystemFontBuildChar interpreter, Int32& count);
}
internal class Syncfusion.Pdf.Parsing.SystemFontHLineTo : SystemFontOperator {
    [NullableContextAttribute("1")]
public virtual void Execute(SystemFontBuildChar interpreter);
}
internal class Syncfusion.Pdf.Parsing.SystemFontHMoveTo : SystemFontOperator {
    [NullableContextAttribute("1")]
public virtual void Execute(SystemFontBuildChar interpreter);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Syncfusion.Pdf.Parsing.SystemFontHorizontalHeader : SystemFontTrueTypeTableBase {
    [CompilerGeneratedAttribute]
private short <Ascender>k__BackingField;
    [CompilerGeneratedAttribute]
private short <Descender>k__BackingField;
    [CompilerGeneratedAttribute]
private short <LineGap>k__BackingField;
    [CompilerGeneratedAttribute]
private ushort <NumberOfHMetrics>k__BackingField;
    internal UInt32 Tag { get; }
    public short Ascender { get; private set; }
    public short Descender { get; private set; }
    public short LineGap { get; private set; }
    public ushort NumberOfHMetrics { get; private set; }
    public SystemFontHorizontalHeader(SystemFontOpenTypeFontSourceBase fontFile);
    internal virtual UInt32 get_Tag();
    [CompilerGeneratedAttribute]
public short get_Ascender();
    [CompilerGeneratedAttribute]
private void set_Ascender(short value);
    [CompilerGeneratedAttribute]
public short get_Descender();
    [CompilerGeneratedAttribute]
private void set_Descender(short value);
    [CompilerGeneratedAttribute]
public short get_LineGap();
    [CompilerGeneratedAttribute]
private void set_LineGap(short value);
    [CompilerGeneratedAttribute]
public ushort get_NumberOfHMetrics();
    [CompilerGeneratedAttribute]
private void set_NumberOfHMetrics(ushort value);
    public virtual void Read(SystemFontOpenTypeFontReader reader);
    internal virtual void Write(SystemFontFontWriter writer);
    internal virtual void Import(SystemFontOpenTypeFontReader reader);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Syncfusion.Pdf.Parsing.SystemFontHorizontalMetrics : SystemFontTrueTypeTableBase {
    private SystemFontLongHorMetric[] hMetrics;
    private Int16[] leftSideBearing;
    internal UInt32 Tag { get; }
    public SystemFontHorizontalMetrics(SystemFontOpenTypeFontSourceBase fontFile);
    internal virtual UInt32 get_Tag();
    public ushort GetAdvancedWidth(int glyphID);
    public short GetLeftSideBearing(int glyphID);
    public virtual void Read(SystemFontOpenTypeFontReader reader);
    internal virtual void Write(SystemFontFontWriter writer);
    internal virtual void Import(SystemFontOpenTypeFontReader reader);
}
internal class Syncfusion.Pdf.Parsing.SystemFontHsbw : SystemFontOperator {
    [NullableContextAttribute("1")]
public virtual void Execute(SystemFontBuildChar buildChar);
}
internal class Syncfusion.Pdf.Parsing.SystemFontHVCurveTo : SystemFontOperator {
    [NullableContextAttribute("1")]
public virtual void Execute(SystemFontBuildChar interpreter);
}
internal static class Syncfusion.Pdf.Parsing.SystemFontIDs : object {
    internal static ushort FONT_FAMILY_ID;
    internal static ushort MANUFACTURER_NAME_ID;
    internal static ushort DESIGNER_ID;
    internal static ushort SAMPLE_TEXT_ID;
    internal static ushort WINDOWS_PLATFORM_ID;
    internal static ushort WINDOWS_SYMBOL_ENCODING_ID;
    internal static ushort WINDOWS_UNICODE_BMP_ENCODING_ID;
    internal static ushort ENGLISH_US_ID;
    [NullableContextAttribute("1")]
internal static Encoding GetEncodingFromEncodingID(ushort encodingId);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Syncfusion.Pdf.Parsing.SystemFontIndex : SystemFontCFFTable {
    [CompilerGeneratedAttribute]
private ushort <Count>k__BackingField;
    [CompilerGeneratedAttribute]
private UInt32[] <Offsets>k__BackingField;
    [CompilerGeneratedAttribute]
private long <DataOffset>k__BackingField;
    public long SkipOffset { get; }
    public ushort Count { get; private set; }
    protected UInt32[] Offsets { get; private set; }
    protected long DataOffset { get; private set; }
    public SystemFontIndex(SystemFontCFFFontFile file, long offset);
    public long get_SkipOffset();
    [CompilerGeneratedAttribute]
public ushort get_Count();
    [CompilerGeneratedAttribute]
private void set_Count(ushort value);
    [CompilerGeneratedAttribute]
protected UInt32[] get_Offsets();
    [CompilerGeneratedAttribute]
private void set_Offsets(UInt32[] value);
    [CompilerGeneratedAttribute]
protected long get_DataOffset();
    [CompilerGeneratedAttribute]
private void set_DataOffset(long value);
    protected int GetDataLength(int index);
    public virtual void Read(SystemFontCFFFontReader reader);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Syncfusion.Pdf.Parsing.SystemFontIndexToLocation : SystemFontTrueTypeTableBase {
    private UInt32[] offsets;
    internal UInt32 Tag { get; }
    public SystemFontIndexToLocation(SystemFontOpenTypeFontSource fontFile);
    internal virtual UInt32 get_Tag();
    public long GetOffset(ushort index);
    public virtual void Read(SystemFontOpenTypeFontReader reader);
}
internal class Syncfusion.Pdf.Parsing.SystemFontInitFeatureInfo : SystemFontFeatureInfo {
    public UInt32 Tag { get; }
    public FeatureType Type { get; }
    public virtual UInt32 get_Tag();
    public virtual FeatureType get_Type();
    [NullableContextAttribute("1")]
public virtual bool ShouldApply(SystemFontGlyphInfo glyphInfo);
}
internal class Syncfusion.Pdf.Parsing.SystemFontIsolatedFeatureInfo : SystemFontFeatureInfo {
    public UInt32 Tag { get; }
    public FeatureType Type { get; }
    public virtual UInt32 get_Tag();
    public virtual FeatureType get_Type();
    [NullableContextAttribute("1")]
public virtual bool ShouldApply(SystemFontGlyphInfo glyphInfo);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Syncfusion.Pdf.Parsing.SystemFontKerning : SystemFontTrueTypeTableBase {
    private List`1<SystemFontKerningSubTable> subTables;
    internal UInt32 Tag { get; }
    public SystemFontKerning(SystemFontOpenTypeFontSourceBase fontFile);
    internal virtual UInt32 get_Tag();
    public SystemFontKerningInfo GetKerning(ushort leftGlyphIndex, ushort rightGlyphIndex);
    public virtual void Read(SystemFontOpenTypeFontReader reader);
    internal virtual void Write(SystemFontFontWriter writer);
    internal virtual void Import(SystemFontOpenTypeFontReader reader);
}
internal class Syncfusion.Pdf.Parsing.SystemFontKerningInfo : object {
    [CompilerGeneratedAttribute]
private Point <HorizontalKerning>k__BackingField;
    [CompilerGeneratedAttribute]
private Point <VerticalKerning>k__BackingField;
    public Point HorizontalKerning { get; public set; }
    public Point VerticalKerning { get; public set; }
    [CompilerGeneratedAttribute]
public Point get_HorizontalKerning();
    [CompilerGeneratedAttribute]
public void set_HorizontalKerning(Point value);
    [CompilerGeneratedAttribute]
public Point get_VerticalKerning();
    [CompilerGeneratedAttribute]
public void set_VerticalKerning(Point value);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal abstract class Syncfusion.Pdf.Parsing.SystemFontKerningSubTable : SystemFontTableBase {
    [CompilerGeneratedAttribute]
private ushort <Coverage>k__BackingField;
    public ushort Coverage { get; private set; }
    public bool IsHorizontal { get; }
    public bool HasMinimumValues { get; }
    public bool IsCrossStream { get; }
    public bool Override { get; }
    public SystemFontKerningSubTable(SystemFontOpenTypeFontSourceBase fontSource);
    [CompilerGeneratedAttribute]
public ushort get_Coverage();
    [CompilerGeneratedAttribute]
private void set_Coverage(ushort value);
    public bool get_IsHorizontal();
    public bool get_HasMinimumValues();
    public bool get_IsCrossStream();
    public bool get_Override();
    internal static SystemFontKerningSubTable ReadSubTable(SystemFontOpenTypeFontSourceBase fontSource, SystemFontOpenTypeFontReader reader);
    internal static SystemFontKerningSubTable ImportSubTable(SystemFontOpenTypeFontSourceBase fontSource, SystemFontOpenTypeFontReader reader);
    private bool GetBit(byte bit);
    public abstract virtual short GetValue(ushort leftGlyphIndex, ushort rightGlyphIndex);
    internal virtual void Write(SystemFontFontWriter writer);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Syncfusion.Pdf.Parsing.SystemFontLangSys : SystemFontTableBase {
    private ushort reqFeatureIndex;
    private UInt16[] featureIndices;
    private List`1<Tuple`2<SystemFontFeatureInfo, SystemFontLookup>> lookups;
    private IEnumerable`1<Tuple`2<SystemFontFeatureInfo, SystemFontLookup>> Lookups { get; }
    public SystemFontLangSys(SystemFontOpenTypeFontSourceBase fontFile);
    private IEnumerable`1<Tuple`2<SystemFontFeatureInfo, SystemFontLookup>> get_Lookups();
    private int Compare(Tuple`2<SystemFontFeatureInfo, ushort> left, Tuple`2<SystemFontFeatureInfo, ushort> right);
    private IEnumerable`1<SystemFontFeature> GetFeatures();
    private IEnumerable`1<Tuple`2<SystemFontFeatureInfo, ushort>> GetLookupIndices();
    public SystemFontGlyphsSequence Apply(SystemFontGlyphsSequence glyphIDs);
    public virtual void Read(SystemFontOpenTypeFontReader reader);
    internal virtual void Write(SystemFontFontWriter writer);
    internal virtual void Import(SystemFontOpenTypeFontReader reader);
}
internal class Syncfusion.Pdf.Parsing.SystemFontLangSysRecord : object {
    [CompilerGeneratedAttribute]
private UInt32 <LangSysTag>k__BackingField;
    [CompilerGeneratedAttribute]
private UInt32 <LangSys>k__BackingField;
    public UInt32 LangSysTag { get; private set; }
    public UInt32 LangSys { get; private set; }
    [CompilerGeneratedAttribute]
public UInt32 get_LangSysTag();
    [CompilerGeneratedAttribute]
private void set_LangSysTag(UInt32 value);
    [CompilerGeneratedAttribute]
public UInt32 get_LangSys();
    [CompilerGeneratedAttribute]
private void set_LangSys(UInt32 value);
    [NullableContextAttribute("1")]
public void Read(SystemFontOpenTypeFontReader reader);
}
internal class Syncfusion.Pdf.Parsing.SystemFontLigaFeatureInfo : SystemFontFeatureInfo {
    public UInt32 Tag { get; }
    public FeatureType Type { get; }
    public virtual UInt32 get_Tag();
    public virtual FeatureType get_Type();
    [NullableContextAttribute("1")]
public virtual bool ShouldApply(SystemFontGlyphInfo glyphInfo);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Syncfusion.Pdf.Parsing.SystemFontLigature : SystemFontTableBase {
    private UInt16[] componentGlyphIds;
    [CompilerGeneratedAttribute]
private ushort <LigatureGlyphId>k__BackingField;
    public ushort LigatureGlyphId { get; private set; }
    public int Length { get; }
    public SystemFontLigature(SystemFontOpenTypeFontSourceBase fontFile);
    [CompilerGeneratedAttribute]
public ushort get_LigatureGlyphId();
    [CompilerGeneratedAttribute]
private void set_LigatureGlyphId(ushort value);
    public int get_Length();
    public bool IsMatch(SystemFontGlyphsSequence glyphIDs, int startIndex);
    public virtual void Read(SystemFontOpenTypeFontReader reader);
    internal virtual void Write(SystemFontFontWriter writer);
    internal virtual void Import(SystemFontOpenTypeFontReader reader);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Syncfusion.Pdf.Parsing.SystemFontLigatureSet : SystemFontTableBase {
    private UInt16[] ligatureOffsets;
    private SystemFontLigature[] ligatures;
    public SystemFontLigature[] Ligatures { get; }
    public SystemFontLigatureSet(SystemFontOpenTypeFontSourceBase fontFile);
    public SystemFontLigature[] get_Ligatures();
    private SystemFontLigature ReadLigature(SystemFontOpenTypeFontReader reader, ushort offset);
    public SystemFontLigature FindLigature(SystemFontGlyphsSequence glyphIDs, int startIndex);
    public virtual void Read(SystemFontOpenTypeFontReader reader);
    internal virtual void Write(SystemFontFontWriter writer);
    internal virtual void Import(SystemFontOpenTypeFontReader reader);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Syncfusion.Pdf.Parsing.SystemFontLigatureSubstitution : SystemFontSubTable {
    private ushort coverageOffset;
    private UInt16[] ligatureSetOffsets;
    private SystemFontLigatureSet[] ligatureSets;
    private SystemFontCoverage coverage;
    public SystemFontCoverage Coverage { get; }
    public SystemFontLigatureSet[] LigatureSets { get; }
    public SystemFontLigatureSubstitution(SystemFontOpenTypeFontSourceBase fontFile);
    public SystemFontCoverage get_Coverage();
    public SystemFontLigatureSet[] get_LigatureSets();
    private SystemFontLigatureSet ReadLigatureSet(SystemFontOpenTypeFontReader reader, ushort offset);
    public virtual SystemFontGlyphsSequence Apply(SystemFontGlyphsSequence glyphIDs);
    public virtual void Read(SystemFontOpenTypeFontReader reader);
    internal virtual void Write(SystemFontFontWriter writer);
    internal virtual void Import(SystemFontOpenTypeFontReader reader);
}
internal class Syncfusion.Pdf.Parsing.SystemFontLineSegment : SystemFontPathSegment {
    [CompilerGeneratedAttribute]
private Point <Point>k__BackingField;
    public Point Point { get; public set; }
    [CompilerGeneratedAttribute]
public Point get_Point();
    [CompilerGeneratedAttribute]
public void set_Point(Point value);
    [NullableContextAttribute("1")]
public virtual SystemFontPathSegment Clone();
    public virtual void Transform(SystemFontMatrix transformMatrix);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Syncfusion.Pdf.Parsing.SystemFontLongHorMetric : object {
    [CompilerGeneratedAttribute]
private ushort <AdvanceWidth>k__BackingField;
    [CompilerGeneratedAttribute]
private short <LSB>k__BackingField;
    public ushort AdvanceWidth { get; private set; }
    public short LSB { get; private set; }
    [CompilerGeneratedAttribute]
public ushort get_AdvanceWidth();
    [CompilerGeneratedAttribute]
private void set_AdvanceWidth(ushort value);
    [CompilerGeneratedAttribute]
public short get_LSB();
    [CompilerGeneratedAttribute]
private void set_LSB(short value);
    public void Read(SystemFontOpenTypeFontReader reader);
    public void Write(SystemFontFontWriter writer);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Syncfusion.Pdf.Parsing.SystemFontLookup : SystemFontTableBase {
    private UInt16[] subTableOffsets;
    private SystemFontSubTable[] subTables;
    [CompilerGeneratedAttribute]
private ushort <Type>k__BackingField;
    [CompilerGeneratedAttribute]
private ushort <Flags>k__BackingField;
    public ushort Type { get; private set; }
    public ushort Flags { get; private set; }
    public IEnumerable`1<SystemFontSubTable> SubTables { get; }
    public SystemFontLookup(SystemFontOpenTypeFontSourceBase fontFile, ushort type);
    [CompilerGeneratedAttribute]
public ushort get_Type();
    [CompilerGeneratedAttribute]
private void set_Type(ushort value);
    [CompilerGeneratedAttribute]
public ushort get_Flags();
    [CompilerGeneratedAttribute]
private void set_Flags(ushort value);
    public IEnumerable`1<SystemFontSubTable> get_SubTables();
    internal static bool IsSupported(ushort type);
    private SystemFontSubTable ReadSubtable(SystemFontOpenTypeFontReader reader, ushort offset);
    public SystemFontGlyphsSequence Apply(SystemFontGlyphsSequence glyphIDs);
    public virtual void Read(SystemFontOpenTypeFontReader reader);
    internal virtual void Write(SystemFontFontWriter writer);
    internal virtual void Import(SystemFontOpenTypeFontReader reader);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Syncfusion.Pdf.Parsing.SystemFontLookupList : SystemFontTableBase {
    private UInt16[] lookupOffsets;
    private SystemFontLookup[] lookups;
    public SystemFontLookupList(SystemFontOpenTypeFontSourceBase fontFile);
    private SystemFontLookup ReadLookup(SystemFontOpenTypeFontReader reader, ushort offset);
    public SystemFontLookup GetLookup(ushort index);
    public virtual void Read(SystemFontOpenTypeFontReader reader);
    internal virtual void Write(SystemFontFontWriter writer);
    internal virtual void Import(SystemFontOpenTypeFontReader reader);
}
internal enum Syncfusion.Pdf.Parsing.SystemFontLookupType : Enum {
    public int value__;
    public static SystemFontLookupType Single;
    public static SystemFontLookupType Multiple;
    public static SystemFontLookupType Alternate;
    public static SystemFontLookupType Ligature;
    public static SystemFontLookupType Context;
    public static SystemFontLookupType ChainingContext;
    public static SystemFontLookupType ExtensionSubstitution;
    public static SystemFontLookupType ReverseChainingContextSingle;
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Syncfusion.Pdf.Parsing.SystemFontMatrix : ValueType {
    private SystemFontMatrixTypes type;
    [CompilerGeneratedAttribute]
private double <M11>k__BackingField;
    [CompilerGeneratedAttribute]
private double <M12>k__BackingField;
    [CompilerGeneratedAttribute]
private double <M21>k__BackingField;
    [CompilerGeneratedAttribute]
private double <M22>k__BackingField;
    [CompilerGeneratedAttribute]
private double <OffsetX>k__BackingField;
    [CompilerGeneratedAttribute]
private double <OffsetY>k__BackingField;
    public static SystemFontMatrix Identity { get; }
    public double Determinant { get; }
    public double M11 { get; public set; }
    public double M12 { get; public set; }
    public double M21 { get; public set; }
    public double M22 { get; public set; }
    public double OffsetX { get; public set; }
    public double OffsetY { get; public set; }
    public SystemFontMatrix(double m11, double m12, double m21, double m22, double offsetX, double offsetY);
    public static SystemFontMatrix get_Identity();
    public double get_Determinant();
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public double get_M11();
    [CompilerGeneratedAttribute]
public void set_M11(double value);
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public double get_M12();
    [CompilerGeneratedAttribute]
public void set_M12(double value);
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public double get_M21();
    [CompilerGeneratedAttribute]
public void set_M21(double value);
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public double get_M22();
    [CompilerGeneratedAttribute]
public void set_M22(double value);
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public double get_OffsetX();
    [CompilerGeneratedAttribute]
public void set_OffsetX(double value);
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public double get_OffsetY();
    [CompilerGeneratedAttribute]
public void set_OffsetY(double value);
    public static SystemFontMatrix op_Multiply(SystemFontMatrix matrix1, SystemFontMatrix matrix2);
    public static bool op_Equality(SystemFontMatrix a, SystemFontMatrix b);
    public static bool op_Inequality(SystemFontMatrix a, SystemFontMatrix b);
    public bool IsIdentity();
    public SystemFontMatrix Translate(double offsetX, double offsetY);
    public SystemFontMatrix Scale(double scaleX, double scaleY, double centerX, double centerY);
    public SystemFontMatrix ScaleAppend(double scaleX, double scaleY, double centerX, double centerY);
    public SystemFontMatrix Rotate(double angle, double centerX, double centerY);
    public bool Equals(SystemFontMatrix value);
    public double Transform(double d);
    public Point Transform(Point point);
    public virtual int GetHashCode();
    public virtual bool Equals(object obj);
    public virtual string ToString();
    private void CheckMatrixType();
    private void SetMatrix(double m11, double m12, double m21, double m22, double offsetX, double offsetY, SystemFontMatrixTypes type);
}
[FlagsAttribute]
internal enum Syncfusion.Pdf.Parsing.SystemFontMatrixTypes : Enum {
    public int value__;
    public static SystemFontMatrixTypes Identity;
    public static SystemFontMatrixTypes Scaling;
    public static SystemFontMatrixTypes Translation;
    public static SystemFontMatrixTypes Unknown;
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Syncfusion.Pdf.Parsing.SystemFontMaxProfile : SystemFontTrueTypeTableBase {
    [CompilerGeneratedAttribute]
private float <Version>k__BackingField;
    [CompilerGeneratedAttribute]
private ushort <NumGlyphs>k__BackingField;
    internal UInt32 Tag { get; }
    public float Version { get; private set; }
    public ushort NumGlyphs { get; private set; }
    public SystemFontMaxProfile(SystemFontOpenTypeFontSourceBase fontFile);
    internal virtual UInt32 get_Tag();
    [CompilerGeneratedAttribute]
public float get_Version();
    [CompilerGeneratedAttribute]
private void set_Version(float value);
    [CompilerGeneratedAttribute]
public ushort get_NumGlyphs();
    [CompilerGeneratedAttribute]
private void set_NumGlyphs(ushort value);
    public virtual void Read(SystemFontOpenTypeFontReader reader);
}
internal class Syncfusion.Pdf.Parsing.SystemFontMedialFeatureInfo : SystemFontFeatureInfo {
    public UInt32 Tag { get; }
    public FeatureType Type { get; }
    public virtual UInt32 get_Tag();
    public virtual FeatureType get_Type();
    [NullableContextAttribute("1")]
public virtual bool ShouldApply(SystemFontGlyphInfo glyphInfo);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Syncfusion.Pdf.Parsing.SystemFontMultipleSubstitution : SystemFontSubTable {
    private ushort coverageOffset;
    private UInt16[] sequenceOffsets;
    private SystemFontCoverage coverage;
    private SystemFontSequence[] sequences;
    protected SystemFontCoverage Coverage { get; }
    protected SystemFontSequence[] Sequences { get; }
    public SystemFontMultipleSubstitution(SystemFontOpenTypeFontSourceBase fontFile);
    protected SystemFontCoverage get_Coverage();
    protected SystemFontSequence[] get_Sequences();
    private SystemFontSequence ReadSequence(SystemFontOpenTypeFontReader reader, ushort offset);
    public virtual SystemFontGlyphsSequence Apply(SystemFontGlyphsSequence glyphIDs);
    public virtual void Read(SystemFontOpenTypeFontReader reader);
    internal virtual void Write(SystemFontFontWriter writer);
    internal virtual void Import(SystemFontOpenTypeFontReader reader);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Syncfusion.Pdf.Parsing.SystemFontNameFormat0 : SystemFontSystemFontName {
    private ushort stringOffset;
    private SystemFontNameRecord[] nameRecords;
    private Dictionary`2<SystemFontNameRecord, string> strings;
    private string fontFamily;
    public string FontFamily { get; }
    public SystemFontNameFormat0(SystemFontOpenTypeFontSourceBase fontSource);
    public virtual string get_FontFamily();
    private string ReadString(SystemFontOpenTypeFontReader reader, ushort languageId, ushort nameId);
    private string ReadString(SystemFontOpenTypeFontReader reader, SystemFontNameRecord record, Encoding encoding);
    private IEnumerable`1<SystemFontNameRecord> FindNameRecords(int platformId, ushort languageId, ushort nameId);
    internal virtual string ReadName(ushort languageID, ushort nameID);
    public virtual void Read(SystemFontOpenTypeFontReader reader);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Syncfusion.Pdf.Parsing.SystemFontNameFormat1 : SystemFontSystemFontName {
    public string FontFamily { get; }
    public SystemFontNameFormat1(SystemFontOpenTypeFontSourceBase fontSource);
    public virtual string get_FontFamily();
    internal virtual string ReadName(ushort languageID, ushort nameID);
    public virtual void Read(SystemFontOpenTypeFontReader reader);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[DefaultMemberAttribute("Item")]
internal class Syncfusion.Pdf.Parsing.SystemFontNameIndex : SystemFontIndex {
    private String[] names;
    public string Item { get; }
    public SystemFontNameIndex(SystemFontCFFFontFile file, long offset);
    public string get_Item(ushort sid);
    private string ReadString(SystemFontCFFFontReader reader, UInt32 offset, int length);
    private string GetString(int index);
    public virtual void Read(SystemFontCFFFontReader reader);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Syncfusion.Pdf.Parsing.SystemFontNameRecord : object {
    [CompilerGeneratedAttribute]
private ushort <PlatformID>k__BackingField;
    [CompilerGeneratedAttribute]
private ushort <EncodingID>k__BackingField;
    [CompilerGeneratedAttribute]
private ushort <LanguageID>k__BackingField;
    [CompilerGeneratedAttribute]
private ushort <NameID>k__BackingField;
    [CompilerGeneratedAttribute]
private ushort <Length>k__BackingField;
    [CompilerGeneratedAttribute]
private ushort <Offset>k__BackingField;
    public ushort PlatformID { get; private set; }
    public ushort EncodingID { get; private set; }
    public ushort LanguageID { get; private set; }
    public ushort NameID { get; private set; }
    public ushort Length { get; private set; }
    public ushort Offset { get; private set; }
    [CompilerGeneratedAttribute]
public ushort get_PlatformID();
    [CompilerGeneratedAttribute]
private void set_PlatformID(ushort value);
    [CompilerGeneratedAttribute]
public ushort get_EncodingID();
    [CompilerGeneratedAttribute]
private void set_EncodingID(ushort value);
    [CompilerGeneratedAttribute]
public ushort get_LanguageID();
    [CompilerGeneratedAttribute]
private void set_LanguageID(ushort value);
    [CompilerGeneratedAttribute]
public ushort get_NameID();
    [CompilerGeneratedAttribute]
private void set_NameID(ushort value);
    [CompilerGeneratedAttribute]
public ushort get_Length();
    [CompilerGeneratedAttribute]
private void set_Length(ushort value);
    [CompilerGeneratedAttribute]
public ushort get_Offset();
    [CompilerGeneratedAttribute]
private void set_Offset(ushort value);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    public void Read(SystemFontOpenTypeFontReader reader);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Syncfusion.Pdf.Parsing.SystemFontNibble : object {
    private byte value;
    public SystemFontNibble(byte value);
    public static SystemFontNibble[] GetNibbles(byte b);
    public static bool op_Equality(SystemFontNibble left, SystemFontNibble right);
    public static bool op_Inequality(SystemFontNibble left, SystemFontNibble right);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    public virtual string ToString();
}
internal class Syncfusion.Pdf.Parsing.SystemFontOffsetTable : object {
    [CompilerGeneratedAttribute]
private ushort <NumTables>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <HasOpenTypeOutlines>k__BackingField;
    public ushort NumTables { get; private set; }
    public bool HasOpenTypeOutlines { get; private set; }
    [CompilerGeneratedAttribute]
public ushort get_NumTables();
    [CompilerGeneratedAttribute]
private void set_NumTables(ushort value);
    [CompilerGeneratedAttribute]
public bool get_HasOpenTypeOutlines();
    [CompilerGeneratedAttribute]
private void set_HasOpenTypeOutlines(bool value);
    [NullableContextAttribute("1")]
public void Read(SystemFontOpenTypeFontReader reader);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Syncfusion.Pdf.Parsing.SystemFontOpenTypeFontReader : SystemFontReaderBase {
    public SystemFontOpenTypeFontReader(Byte[] data);
    public sbyte ReadChar();
    public ushort ReadUShort();
    public short ReadShort();
    public UInt32 ReadULong();
    public int ReadLong();
    public long ReadLongDateTime();
    public float ReadFixed();
    public float Read2Dot14();
    public string ReadString();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Syncfusion.Pdf.Parsing.SystemFontOpenTypeFontSource : SystemFontOpenTypeFontSourceBase {
    private Dictionary`2<ushort, SystemFontGlyphData> glyphsData;
    private SystemFontCMap cmap;
    private SystemFontHorizontalMetrics hmtx;
    private SystemFontKerning kern;
    private SystemFontGlyphSubstitution gsub;
    private Dictionary`2<UInt32, SystemFontTableRecord> tables;
    private SystemFontIndexToLocation loca;
    private SystemFontMaxProfile maxp;
    private SystemFontHead head;
    private SystemFontHorizontalHeader hhea;
    private SystemFontSystemFontName name;
    private SystemFontPost post;
    private SystemFontCFFFontSource ccf;
    [CompilerGeneratedAttribute]
private SystemFontOffsetTable <OffsetTable>k__BackingField;
    [CompilerGeneratedAttribute]
private long <Offset>k__BackingField;
    internal SystemFontOutlines Outlines { get; }
    internal SystemFontCMap CMap { get; }
    internal SystemFontHorizontalMetrics HMtx { get; }
    internal SystemFontKerning Kern { get; }
    internal SystemFontGlyphSubstitution GSub { get; }
    internal SystemFontHead Head { get; }
    internal SystemFontHorizontalHeader HHea { get; }
    internal SystemFontPost Post { get; }
    internal SystemFontSystemFontName Name { get; }
    internal SystemFontIndexToLocation Loca { get; }
    internal SystemFontMaxProfile MaxP { get; }
    internal Dictionary`2<UInt32, SystemFontTableRecord> Tables { get; }
    internal SystemFontOffsetTable OffsetTable { get; private set; }
    internal ushort GlyphCount { get; }
    internal long Offset { get; internal set; }
    public string FontFamily { get; }
    public bool IsBold { get; }
    public bool IsItalic { get; }
    internal SystemFontCFFFontSource CFF { get; }
    public SystemFontOpenTypeFontSource(SystemFontOpenTypeFontReader reader);
    internal virtual SystemFontOutlines get_Outlines();
    internal virtual SystemFontCMap get_CMap();
    internal virtual SystemFontHorizontalMetrics get_HMtx();
    internal virtual SystemFontKerning get_Kern();
    internal virtual SystemFontGlyphSubstitution get_GSub();
    internal virtual SystemFontHead get_Head();
    internal virtual SystemFontHorizontalHeader get_HHea();
    internal SystemFontPost get_Post();
    internal SystemFontSystemFontName get_Name();
    internal SystemFontIndexToLocation get_Loca();
    internal SystemFontMaxProfile get_MaxP();
    internal Dictionary`2<UInt32, SystemFontTableRecord> get_Tables();
    [CompilerGeneratedAttribute]
internal SystemFontOffsetTable get_OffsetTable();
    [CompilerGeneratedAttribute]
private void set_OffsetTable(SystemFontOffsetTable value);
    internal virtual ushort get_GlyphCount();
    [CompilerGeneratedAttribute]
internal long get_Offset();
    [CompilerGeneratedAttribute]
internal void set_Offset(long value);
    public virtual string get_FontFamily();
    public virtual bool get_IsBold();
    public virtual bool get_IsItalic();
    internal virtual SystemFontCFFFontSource get_CFF();
    private void ReadTableData(T table);
    private T ReadTableData(UInt32 tag, SystemFontReadTableFormatDelegate`1<T> readTableDelegate);
    private int GetTableLength(UInt32 tag);
    private SystemFontCFFFontSource ReadCFFTable();
    private void ReadTableRecords();
    private void Initialize();
    internal virtual SystemFontGlyphData GetGlyphData(ushort glyphIndex);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal abstract class Syncfusion.Pdf.Parsing.SystemFontOpenTypeFontSourceBase : SystemFontFontSource {
    private SystemFontOpenTypeGlyphScaler scaler;
    private SystemFontOpenTypeFontReader reader;
    internal SystemFontOutlines Outlines { get; }
    internal SystemFontOpenTypeFontReader Reader { get; }
    internal SystemFontCFFFontSource CFF { get; }
    internal SystemFontCMap CMap { get; }
    internal SystemFontHead Head { get; }
    internal SystemFontHorizontalHeader HHea { get; }
    internal SystemFontHorizontalMetrics HMtx { get; }
    internal SystemFontKerning Kern { get; }
    internal SystemFontGlyphSubstitution GSub { get; }
    internal ushort GlyphCount { get; }
    internal ushort NumberOfHorizontalMetrics { get; }
    internal SystemFontOpenTypeGlyphScaler Scaler { get; }
    public short Ascender { get; }
    public short Descender { get; }
    public SystemFontOpenTypeFontSourceBase(SystemFontOpenTypeFontReader reader);
    internal abstract virtual SystemFontOutlines get_Outlines();
    internal SystemFontOpenTypeFontReader get_Reader();
    internal abstract virtual SystemFontCFFFontSource get_CFF();
    internal abstract virtual SystemFontCMap get_CMap();
    internal abstract virtual SystemFontHead get_Head();
    internal abstract virtual SystemFontHorizontalHeader get_HHea();
    internal abstract virtual SystemFontHorizontalMetrics get_HMtx();
    internal abstract virtual SystemFontKerning get_Kern();
    internal abstract virtual SystemFontGlyphSubstitution get_GSub();
    internal abstract virtual ushort get_GlyphCount();
    internal ushort get_NumberOfHorizontalMetrics();
    internal SystemFontOpenTypeGlyphScaler get_Scaler();
    public virtual short get_Ascender();
    public virtual short get_Descender();
    public SystemFontGlyph GetGlyphMetrics(ushort glyphId, ushort previousGlyphId, double fontSize);
    public SystemFontGlyph GetGlyphMetrics(ushort glyphId, double fontSize);
    public virtual void GetAdvancedWidth(SystemFontGlyph glyph);
    internal SystemFontScript GetScript(UInt32 tag);
    internal SystemFontFeature GetFeature(ushort index);
    internal SystemFontLookup GetLookup(ushort index);
    internal abstract virtual SystemFontGlyphData GetGlyphData(ushort glyphID);
    public ushort GetGlyphId(ushort ch);
    public double GetLineHeight(double fontSize);
    public double GetBaselineOffset(double fontSize);
    public virtual void GetGlyphOutlines(SystemFontGlyph glyph, double fontSize);
    internal void Write(SystemFontFontWriter writer);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Syncfusion.Pdf.Parsing.SystemFontOpenTypeGlyphScaler : object {
    internal static double Dpi;
    private static double Ppi;
    private SystemFontOpenTypeFontSourceBase fontFile;
    public SystemFontOpenTypeGlyphScaler(SystemFontOpenTypeFontSourceBase fontFile);
    public void ScaleGlyphMetrics(SystemFontGlyph glyph, double fontSize);
    public double FUnitsToPixels(int units, double fontSize);
    public double FUnitsToPixels(double units, double fontSize);
    public PointF FUnitsOutlinePointToPixels(Point unitPoint, double fontSize);
    public Point FUnitsPointToPixels(Point unitPoint, double fontSize);
    public void GetScaleGlyphOutlines(SystemFontGlyph glyph, double fontSize);
    private static Point GetMidPoint(Point a, Point b);
    private static SystemFontLineSegment CreateLineSegment(PointF point);
    private static SystemFontQuadraticBezierSegment CreateBezierSegment(PointF control, PointF end);
    private SystemFontPathFigure CreatePathFigureFromContour(SystemFontOutlinePoint[] points, double fontSize);
    private void CreateOpenTypeOutlines(SystemFontGlyph glyph, double fontSize);
    private void CreateTrueTypeOutlines(SystemFontGlyph glyph, double fontSize);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Syncfusion.Pdf.Parsing.SystemFontOperandsCollection : object {
    private LinkedList`1<object> store;
    public int Count { get; }
    public object First { get; }
    public object Last { get; }
    public int get_Count();
    public object get_First();
    public object get_Last();
    public object GetElementAt(SystemFontOrigin origin, int index);
    public void AddLast(object obj);
    public void AddFirst(object obj);
    public object GetLast();
    public T GetLastAs();
    public int GetLastAsInt();
    public double GetLastAsReal();
    public object GetFirst();
    public T GetFirstAs();
    public int GetFirstAsInt();
    public double GetFirstAsReal();
    public void Clear();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal abstract class Syncfusion.Pdf.Parsing.SystemFontOperator : object {
    internal static Point CalculatePoint(SystemFontBuildChar interpreter, int dx, int dy);
    internal static void HLineTo(SystemFontBuildChar interpreter, int dx);
    internal static void VLineTo(SystemFontBuildChar interpreter, int dy);
    internal static void LineTo(SystemFontBuildChar interpreter, int dx, int dy);
    internal static void CurveTo(SystemFontBuildChar interpreter, int dxa, int dya, int dxb, int dyb, int dxc, int dyc);
    internal static void MoveTo(SystemFontBuildChar interpreter, int dx, int dy);
    internal static void ReadWidth(SystemFontBuildChar interpreter, int operands);
    public abstract virtual void Execute(SystemFontBuildChar buildChar);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Syncfusion.Pdf.Parsing.SystemFontOperatorDescriptor : object {
    internal static byte TwoByteOperatorFirstByte;
    private Byte[] value;
    private object defaultValue;
    private int hashCode;
    public object DefaultValue { get; }
    public SystemFontOperatorDescriptor(byte b0);
    public SystemFontOperatorDescriptor(Byte[] bytes);
    public SystemFontOperatorDescriptor(byte b0, object defaultValue);
    public SystemFontOperatorDescriptor(Byte[] bytes, object defaultValue);
    public object get_DefaultValue();
    private void CalculateHashCode();
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    public virtual string ToString();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal abstract class Syncfusion.Pdf.Parsing.SystemFontOrderedEnumerable`1 : object {
    internal IEnumerable`1<TElement> source;
    internal abstract virtual SystemFontEnumerableSorter`1<TElement> GetEnumerableSorter(SystemFontEnumerableSorter`1<TElement> next);
    [IteratorStateMachineAttribute("Syncfusion.Pdf.Parsing.SystemFontOrderedEnumerable`1/<GetEnumerator>d__2")]
public sealed virtual IEnumerator`1<TElement> GetEnumerator();
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
    private sealed virtual override ISystemFontOrderedEnumerable`1<TElement> Syncfusion.Pdf.Parsing.ISystemFontOrderedEnumerable<TElement>.CreateOrderedEnumerable(Func`2<TElement, TKey> keySelector, IComparer`1<TKey> comparer, bool descending);
}
internal enum Syncfusion.Pdf.Parsing.SystemFontOrigin : Enum {
    public int value__;
    public static SystemFontOrigin Begin;
    public static SystemFontOrigin End;
}
internal class Syncfusion.Pdf.Parsing.SystemFontOutlinePoint : object {
    [CompilerGeneratedAttribute]
private Point <Point>k__BackingField;
    [CompilerGeneratedAttribute]
private byte <Flags>k__BackingField;
    [CompilerGeneratedAttribute]
private byte <Instruction>k__BackingField;
    public Point Point { get; public set; }
    public byte Flags { get; public set; }
    public byte Instruction { get; public set; }
    public bool IsOnCurve { get; }
    public SystemFontOutlinePoint(byte flags);
    public SystemFontOutlinePoint(double x, double y, byte flags);
    [CompilerGeneratedAttribute]
public Point get_Point();
    [CompilerGeneratedAttribute]
public void set_Point(Point value);
    [CompilerGeneratedAttribute]
public byte get_Flags();
    [CompilerGeneratedAttribute]
public void set_Flags(byte value);
    [CompilerGeneratedAttribute]
public byte get_Instruction();
    [CompilerGeneratedAttribute]
public void set_Instruction(byte value);
    public bool get_IsOnCurve();
}
internal enum Syncfusion.Pdf.Parsing.SystemFontOutlines : Enum {
    public int value__;
    public static SystemFontOutlines TrueType;
    public static SystemFontOutlines OpenType;
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Syncfusion.Pdf.Parsing.SystemFontPathFigure : object {
    [CompilerGeneratedAttribute]
private List`1<SystemFontPathSegment> <Segments>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsClosed>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsFilled>k__BackingField;
    [CompilerGeneratedAttribute]
private Point <StartPoint>k__BackingField;
    public List`1<SystemFontPathSegment> Segments { get; public set; }
    public bool IsClosed { get; public set; }
    public bool IsFilled { get; public set; }
    public Point StartPoint { get; public set; }
    [CompilerGeneratedAttribute]
public List`1<SystemFontPathSegment> get_Segments();
    [CompilerGeneratedAttribute]
public void set_Segments(List`1<SystemFontPathSegment> value);
    [CompilerGeneratedAttribute]
public bool get_IsClosed();
    [CompilerGeneratedAttribute]
public void set_IsClosed(bool value);
    [CompilerGeneratedAttribute]
public bool get_IsFilled();
    [CompilerGeneratedAttribute]
public void set_IsFilled(bool value);
    [CompilerGeneratedAttribute]
public Point get_StartPoint();
    [CompilerGeneratedAttribute]
public void set_StartPoint(Point value);
    public SystemFontPathFigure Clone();
    internal void Transform(SystemFontMatrix transformMatrix);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Syncfusion.Pdf.Parsing.SystemFontPathGeometry : object {
    [CompilerGeneratedAttribute]
private List`1<SystemFontPathFigure> <Figures>k__BackingField;
    [CompilerGeneratedAttribute]
private SystemFontFillRule <FillRule>k__BackingField;
    [CompilerGeneratedAttribute]
private SystemFontMatrix <TransformMatrix>k__BackingField;
    public List`1<SystemFontPathFigure> Figures { get; public set; }
    public SystemFontFillRule FillRule { get; public set; }
    public SystemFontMatrix TransformMatrix { get; public set; }
    public bool IsEmpty { get; }
    [CompilerGeneratedAttribute]
public List`1<SystemFontPathFigure> get_Figures();
    [CompilerGeneratedAttribute]
public void set_Figures(List`1<SystemFontPathFigure> value);
    [CompilerGeneratedAttribute]
public SystemFontFillRule get_FillRule();
    [CompilerGeneratedAttribute]
public void set_FillRule(SystemFontFillRule value);
    [CompilerGeneratedAttribute]
public SystemFontMatrix get_TransformMatrix();
    [CompilerGeneratedAttribute]
public void set_TransformMatrix(SystemFontMatrix value);
    public bool get_IsEmpty();
    internal static SystemFontPathGeometry CreateRectangle(Rect rect);
    private static void Compare(Point point, Double& minX, Double& maxX, Double& minY, Double& maxY);
    public SystemFontPathGeometry Clone();
    public Rect GetBoundingRect();
}
internal abstract class Syncfusion.Pdf.Parsing.SystemFontPathSegment : object {
    [NullableContextAttribute("1")]
public abstract virtual SystemFontPathSegment Clone();
    public abstract virtual void Transform(SystemFontMatrix transformMatrix);
}
internal enum Syncfusion.Pdf.Parsing.SystemFontPenLineCap : Enum {
    public int value__;
    public static SystemFontPenLineCap Flat;
    public static SystemFontPenLineCap Round;
    public static SystemFontPenLineCap Square;
}
internal enum Syncfusion.Pdf.Parsing.SystemFontPenLineJoin : Enum {
    public int value__;
    public static SystemFontPenLineJoin Bevel;
    public static SystemFontPenLineJoin Miter;
    public static SystemFontPenLineJoin Round;
}
internal class Syncfusion.Pdf.Parsing.SystemFontPop : SystemFontOperator {
    [NullableContextAttribute("1")]
public virtual void Execute(SystemFontBuildChar buildChar);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal abstract class Syncfusion.Pdf.Parsing.SystemFontPost : SystemFontTrueTypeTableBase {
    protected static Dictionary`2<string, ushort> macintoshStandardOrderGlyphIds;
    protected static String[] macintoshStandardOrderNames;
    internal UInt32 Tag { get; }
    private static SystemFontPost();
    public SystemFontPost(SystemFontOpenTypeFontSourceBase fontSource);
    internal virtual UInt32 get_Tag();
    private static void Initialize();
    public static SystemFontPost ReadPostTable(SystemFontOpenTypeFontSourceBase fontSource, SystemFontOpenTypeFontReader reader);
    public abstract virtual ushort GetGlyphId(string name);
    public virtual void Read(SystemFontOpenTypeFontReader reader);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Syncfusion.Pdf.Parsing.SystemFontPostFormat1 : SystemFontPost {
    public SystemFontPostFormat1(SystemFontOpenTypeFontSourceBase fontSource);
    public virtual ushort GetGlyphId(string name);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Syncfusion.Pdf.Parsing.SystemFontPostFormat2 : SystemFontPost {
    private Dictionary`2<string, ushort> glyphNames;
    public SystemFontPostFormat2(SystemFontOpenTypeFontSourceBase fontSource);
    private void CreateGlyphNamesMapping(UInt16[] glyphNameIndex, String[] names);
    public virtual ushort GetGlyphId(string name);
    public virtual void Read(SystemFontOpenTypeFontReader reader);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Syncfusion.Pdf.Parsing.SystemFontPostFormat3 : SystemFontPost {
    public SystemFontPostFormat3(SystemFontOpenTypeFontSourceBase fontSource);
    public virtual ushort GetGlyphId(string name);
    public virtual void Read(SystemFontOpenTypeFontReader reader);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[DefaultMemberAttribute("Item")]
internal class Syncfusion.Pdf.Parsing.SystemFontPostScriptArray : SystemFontPostScriptObject {
    private List`1<object> store;
    public static SystemFontPostScriptArray MatrixIdentity { get; }
    public object Item { get; public set; }
    public int Count { get; }
    public bool IsReadOnly { get; }
    public SystemFontPostScriptArray(int capacity);
    public SystemFontPostScriptArray(Object[] initialValue);
    public static SystemFontPostScriptArray get_MatrixIdentity();
    public sealed virtual object get_Item(int index);
    public sealed virtual void set_Item(int index, object value);
    public sealed virtual int get_Count();
    public sealed virtual bool get_IsReadOnly();
    public SystemFontMatrix ToMatrix();
    public sealed virtual int IndexOf(object item);
    public sealed virtual void Insert(int index, object item);
    public sealed virtual void RemoveAt(int index);
    public sealed virtual void Add(object item);
    public sealed virtual void Clear();
    public sealed virtual bool Contains(object item);
    public sealed virtual void CopyTo(Object[] array, int arrayIndex);
    public sealed virtual bool Remove(object item);
    public sealed virtual IEnumerator`1<object> GetEnumerator();
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
    public void Load(Object[] content);
    public T GetElementAs(int index);
    public virtual string ToString();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[DefaultMemberAttribute("Item")]
internal class Syncfusion.Pdf.Parsing.SystemFontPostScriptDictionary : SystemFontPostScriptObject {
    private Dictionary`2<string, object> store;
    public ICollection`1<string> Keys { get; }
    public ICollection`1<object> Values { get; }
    public object Item { get; public set; }
    public int Count { get; }
    public bool IsReadOnly { get; }
    public SystemFontPostScriptDictionary(int capacity);
    public sealed virtual ICollection`1<string> get_Keys();
    public sealed virtual ICollection`1<object> get_Values();
    public sealed virtual object get_Item(string key);
    public sealed virtual void set_Item(string key, object value);
    public sealed virtual int get_Count();
    public sealed virtual bool get_IsReadOnly();
    public sealed virtual void Add(string key, object value);
    public sealed virtual bool ContainsKey(string key);
    public sealed virtual bool Remove(string key);
    public sealed virtual bool TryGetValue(string key, Object& value);
    public sealed virtual void Add(KeyValuePair`2<string, object> item);
    public sealed virtual void Clear();
    public sealed virtual bool Contains(KeyValuePair`2<string, object> item);
    public sealed virtual void CopyTo(KeyValuePair`2[] array, int arrayIndex);
    public sealed virtual bool Remove(KeyValuePair`2<string, object> item);
    public sealed virtual IEnumerator`1<KeyValuePair`2<string, object>> GetEnumerator();
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
    public T GetElementAs(string key);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal abstract class Syncfusion.Pdf.Parsing.SystemFontPostScriptObject : object {
    private Dictionary`2<string, ISystemFontProperty> properties;
    public void Load(SystemFontPostScriptDictionary fromDict);
    protected SystemFontProperty`1<T> CreateProperty(SystemFontPropertyDescriptor descriptor);
    protected SystemFontProperty`1<T> CreateProperty(SystemFontPropertyDescriptor descriptor, ISystemFontConverter converter);
    protected SystemFontProperty`1<T> CreateProperty(SystemFontPropertyDescriptor descriptor, T defaultValue);
    protected SystemFontProperty`1<T> CreateProperty(SystemFontPropertyDescriptor descriptor, ISystemFontConverter converter, T defaultValue);
    private void RegisterProperty(SystemFontPropertyDescriptor descriptor, ISystemFontProperty property);
    private void RegisterProperty(ISystemFontProperty property);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Syncfusion.Pdf.Parsing.SystemFontPredefinedCharset : object {
    public static SystemFontPredefinedCharset ISOAdobeCharset;
    public static SystemFontPredefinedCharset ExpertCharset;
    public static SystemFontPredefinedCharset ExpertSubsetCharset;
    private UInt16[] codes;
    private static SystemFontPredefinedCharset();
    public static UInt16[] GetPredefinedCodes(int b);
    public static bool IsPredefinedCharset(int b);
    private static void InitializeExpertSubsetCharset();
    private static void InitializeExpertCharset();
    private static void InitializeISOAdobeCharset();
    private UInt16[] GetCodes();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Syncfusion.Pdf.Parsing.SystemFontPredefinedEncoding : object {
    private String[] names;
    private Dictionary`2<string, byte> mapping;
    [CompilerGeneratedAttribute]
private static SystemFontPredefinedEncoding <PdfDocEncoding>k__BackingField;
    [CompilerGeneratedAttribute]
private static SystemFontPredefinedEncoding <WinAnsiEncoding>k__BackingField;
    [CompilerGeneratedAttribute]
private static SystemFontPredefinedEncoding <MacRomanEncoding>k__BackingField;
    [CompilerGeneratedAttribute]
private static SystemFontPredefinedEncoding <StandardMacRomanEncoding>k__BackingField;
    [CompilerGeneratedAttribute]
private static SystemFontPredefinedEncoding <StandardEncoding>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Name>k__BackingField;
    public static SystemFontPredefinedEncoding PdfDocEncoding { get; private set; }
    public static SystemFontPredefinedEncoding WinAnsiEncoding { get; private set; }
    public static SystemFontPredefinedEncoding MacRomanEncoding { get; private set; }
    public static SystemFontPredefinedEncoding StandardMacRomanEncoding { get; private set; }
    public static SystemFontPredefinedEncoding StandardEncoding { get; private set; }
    public string Name { get; private set; }
    private static SystemFontPredefinedEncoding();
    [CompilerGeneratedAttribute]
public static SystemFontPredefinedEncoding get_PdfDocEncoding();
    [CompilerGeneratedAttribute]
private static void set_PdfDocEncoding(SystemFontPredefinedEncoding value);
    [CompilerGeneratedAttribute]
public static SystemFontPredefinedEncoding get_WinAnsiEncoding();
    [CompilerGeneratedAttribute]
private static void set_WinAnsiEncoding(SystemFontPredefinedEncoding value);
    [CompilerGeneratedAttribute]
public static SystemFontPredefinedEncoding get_MacRomanEncoding();
    [CompilerGeneratedAttribute]
private static void set_MacRomanEncoding(SystemFontPredefinedEncoding value);
    [CompilerGeneratedAttribute]
public static SystemFontPredefinedEncoding get_StandardMacRomanEncoding();
    [CompilerGeneratedAttribute]
private static void set_StandardMacRomanEncoding(SystemFontPredefinedEncoding value);
    [CompilerGeneratedAttribute]
public static SystemFontPredefinedEncoding get_StandardEncoding();
    [CompilerGeneratedAttribute]
private static void set_StandardEncoding(SystemFontPredefinedEncoding value);
    [CompilerGeneratedAttribute]
public string get_Name();
    [CompilerGeneratedAttribute]
private void set_Name(string value);
    private static void InitializePdfEncoding();
    private static void InitializeWinAnsiEncoding();
    private static void InitializeMacEncoding();
    private static void InitializeStandardMacEncoding();
    private static void InitializeStandardEncoding();
    public static SystemFontPredefinedEncoding GetPredefinedEncoding(string encoding);
    private void Init();
    private void InitMapping();
    public String[] GetNames();
    public byte GetCharId(string name);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal static class Syncfusion.Pdf.Parsing.SystemFontPredefinedEncodings : object {
    [CompilerGeneratedAttribute]
private static String[] <StandardEncoding>k__BackingField;
    public static String[] StandardEncoding { get; private set; }
    private static SystemFontPredefinedEncodings();
    [CompilerGeneratedAttribute]
public static String[] get_StandardEncoding();
    [CompilerGeneratedAttribute]
private static void set_StandardEncoding(String[] value);
    private static void InitializeStandardEncoding();
    public static SystemFontPostScriptArray CreateEncoding(string predefinedEncoding);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Syncfusion.Pdf.Parsing.SystemFontPrivate : SystemFontDict {
    private SystemFontTop top;
    private SystemFontSubrsIndex subrs;
    [CompilerGeneratedAttribute]
private static SystemFontOperatorDescriptor <SubrsOperator>k__BackingField;
    public static SystemFontOperatorDescriptor SubrsOperator { get; private set; }
    public SystemFontSubrsIndex Subrs { get; }
    private static SystemFontPrivate();
    public SystemFontPrivate(SystemFontTop top, long offset, int length);
    [CompilerGeneratedAttribute]
public static SystemFontOperatorDescriptor get_SubrsOperator();
    [CompilerGeneratedAttribute]
private static void set_SubrsOperator(SystemFontOperatorDescriptor value);
    public SystemFontSubrsIndex get_Subrs();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Syncfusion.Pdf.Parsing.SystemFontProperty`1 : object {
    private ISystemFontConverter converter;
    private T value;
    [CompilerGeneratedAttribute]
private SystemFontPropertyDescriptor <Descriptor>k__BackingField;
    public SystemFontPropertyDescriptor Descriptor { get; public set; }
    public SystemFontProperty`1(SystemFontPropertyDescriptor descriptor);
    public SystemFontProperty`1(SystemFontPropertyDescriptor descriptor, ISystemFontConverter converter);
    public SystemFontProperty`1(SystemFontPropertyDescriptor descriptor, T defaultValue);
    public SystemFontProperty`1(SystemFontPropertyDescriptor descriptor, ISystemFontConverter converter, T defaultValue);
    [CompilerGeneratedAttribute]
public sealed virtual SystemFontPropertyDescriptor get_Descriptor();
    [CompilerGeneratedAttribute]
public void set_Descriptor(SystemFontPropertyDescriptor value);
    public T GetValue();
    public sealed virtual bool SetValue(object value);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Syncfusion.Pdf.Parsing.SystemFontPropertyDescriptor : object {
    [CompilerGeneratedAttribute]
private string <Name>k__BackingField;
    public string Name { get; public set; }
    [CompilerGeneratedAttribute]
public string get_Name();
    [CompilerGeneratedAttribute]
public void set_Name(string value);
}
internal class Syncfusion.Pdf.Parsing.SystemFontQuadraticBezierSegment : SystemFontPathSegment {
    [CompilerGeneratedAttribute]
private Point <Point1>k__BackingField;
    [CompilerGeneratedAttribute]
private Point <Point2>k__BackingField;
    public Point Point1 { get; public set; }
    public Point Point2 { get; public set; }
    [CompilerGeneratedAttribute]
public Point get_Point1();
    [CompilerGeneratedAttribute]
public void set_Point1(Point value);
    [CompilerGeneratedAttribute]
public Point get_Point2();
    [CompilerGeneratedAttribute]
public void set_Point2(Point value);
    [NullableContextAttribute("1")]
public virtual SystemFontPathSegment Clone();
    public virtual void Transform(SystemFontMatrix transformMatrix);
}
internal class Syncfusion.Pdf.Parsing.SystemFontRange : object {
    [CompilerGeneratedAttribute]
private int <RangeStart>k__BackingField;
    [CompilerGeneratedAttribute]
private int <RangeEnd>k__BackingField;
    public int RangeStart { get; private set; }
    public int RangeEnd { get; private set; }
    public SystemFontRange(int start, int end);
    [CompilerGeneratedAttribute]
public int get_RangeStart();
    [CompilerGeneratedAttribute]
private void set_RangeStart(int value);
    [CompilerGeneratedAttribute]
public int get_RangeEnd();
    [CompilerGeneratedAttribute]
private void set_RangeEnd(int value);
    public bool IsInRange(int value);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Syncfusion.Pdf.Parsing.SystemFontRangeRecord : object {
    [CompilerGeneratedAttribute]
private ushort <Start>k__BackingField;
    [CompilerGeneratedAttribute]
private ushort <End>k__BackingField;
    [CompilerGeneratedAttribute]
private ushort <StartCoverageIndex>k__BackingField;
    public ushort Start { get; private set; }
    public ushort End { get; private set; }
    public ushort StartCoverageIndex { get; private set; }
    [CompilerGeneratedAttribute]
public ushort get_Start();
    [CompilerGeneratedAttribute]
private void set_Start(ushort value);
    [CompilerGeneratedAttribute]
public ushort get_End();
    [CompilerGeneratedAttribute]
private void set_End(ushort value);
    [CompilerGeneratedAttribute]
public ushort get_StartCoverageIndex();
    [CompilerGeneratedAttribute]
private void set_StartCoverageIndex(ushort value);
    public int GetCoverageIndex(ushort glyphIndex);
    public void Read(SystemFontOpenTypeFontReader reader);
    internal void Write(SystemFontFontWriter writer);
}
internal class Syncfusion.Pdf.Parsing.SystemFontRCurveLine : SystemFontOperator {
    [NullableContextAttribute("1")]
public virtual void Execute(SystemFontBuildChar interpreter);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal abstract class Syncfusion.Pdf.Parsing.SystemFontReaderBase : object {
    private Byte[] data;
    private Stack`1<long> beginReadingPositions;
    private long position;
    public bool EndOfFile { get; }
    public int Length { get; }
    public long Position { get; public set; }
    public SystemFontReaderBase(Byte[] data);
    public bool get_EndOfFile();
    public int get_Length();
    public virtual long get_Position();
    public virtual void set_Position(long value);
    public virtual void BeginReadingBlock();
    public virtual void EndReadingBlock();
    public virtual byte Read();
    public virtual byte Peek(int skip);
    public int Read(Byte[] buffer, int count);
    public int ReadBE(Byte[] buffer, int count);
    public virtual void Seek(long offset, SeekOrigin origin);
}
internal class Syncfusion.Pdf.Parsing.SystemFontReadTableFormatDelegate`1 : MulticastDelegate {
    public SystemFontReadTableFormatDelegate`1(object object, IntPtr method);
    [NullableContextAttribute("1")]
public virtual T Invoke(SystemFontOpenTypeFontSourceBase fontSource, SystemFontOpenTypeFontReader reader);
    public virtual IAsyncResult BeginInvoke(SystemFontOpenTypeFontSourceBase fontSource, SystemFontOpenTypeFontReader reader, AsyncCallback callback, object object);
    public virtual T EndInvoke(IAsyncResult result);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Syncfusion.Pdf.Parsing.SystemFontRealByteEncoding : SystemFontByteEncoding {
    private static Dictionary`2<SystemFontNibble, string> nibbleMapping;
    private static SystemFontNibble endOfNumber;
    private static SystemFontRealByteEncoding();
    public virtual object Read(SystemFontEncodedDataReader reader);
}
internal class Syncfusion.Pdf.Parsing.SystemFontReturn : SystemFontOperator {
    [NullableContextAttribute("1")]
public virtual void Execute(SystemFontBuildChar interpreter);
}
internal class Syncfusion.Pdf.Parsing.SystemFontRLigFeatureInfo : SystemFontFeatureInfo {
    public UInt32 Tag { get; }
    public FeatureType Type { get; }
    public virtual UInt32 get_Tag();
    public virtual FeatureType get_Type();
    [NullableContextAttribute("1")]
public virtual bool ShouldApply(SystemFontGlyphInfo glyphInfo);
}
internal class Syncfusion.Pdf.Parsing.SystemFontRLineCurve : SystemFontOperator {
    [NullableContextAttribute("1")]
public virtual void Execute(SystemFontBuildChar interpreter);
}
internal class Syncfusion.Pdf.Parsing.SystemFontRLineTo : SystemFontOperator {
    [NullableContextAttribute("1")]
public virtual void Execute(SystemFontBuildChar interpreter);
}
internal class Syncfusion.Pdf.Parsing.SystemFontRMoveTo : SystemFontOperator {
    [NullableContextAttribute("1")]
public virtual void Execute(SystemFontBuildChar interpreter);
}
internal class Syncfusion.Pdf.Parsing.SystemFontRRCurveTo : SystemFontOperator {
    [NullableContextAttribute("1")]
public virtual void Execute(SystemFontBuildChar interpreter);
}
internal class Syncfusion.Pdf.Parsing.SystemFontSbw : SystemFontOperator {
    [NullableContextAttribute("1")]
public virtual void Execute(SystemFontBuildChar buildChar);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Syncfusion.Pdf.Parsing.SystemFontScript : SystemFontTableBase {
    private ushort defaultLangSysOffset;
    private SystemFontLangSys defaultLangSys;
    [CompilerGeneratedAttribute]
private UInt32 <ScriptTag>k__BackingField;
    public UInt32 ScriptTag { get; private set; }
    public SystemFontLangSys DefaultLangSys { get; }
    public SystemFontScript(SystemFontOpenTypeFontSourceBase fontFile, UInt32 scriptTag);
    [CompilerGeneratedAttribute]
public UInt32 get_ScriptTag();
    [CompilerGeneratedAttribute]
private void set_ScriptTag(UInt32 value);
    public SystemFontLangSys get_DefaultLangSys();
    private SystemFontLangSys ReadLangSys(SystemFontOpenTypeFontReader reader, ushort offset);
    public virtual void Read(SystemFontOpenTypeFontReader reader);
    internal virtual void Write(SystemFontFontWriter writer);
    internal virtual void Import(SystemFontOpenTypeFontReader reader);
    public virtual string ToString();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Syncfusion.Pdf.Parsing.SystemFontScriptList : SystemFontTableBase {
    private Dictionary`2<UInt32, SystemFontScriptRecord> scriptRecords;
    private Dictionary`2<UInt32, SystemFontScript> scripts;
    public SystemFontScriptList(SystemFontOpenTypeFontSourceBase fontFile);
    private SystemFontScript ReadScript(SystemFontOpenTypeFontReader reader, SystemFontScriptRecord record);
    public SystemFontScript GetScript(UInt32 tag);
    public virtual void Read(SystemFontOpenTypeFontReader reader);
    internal virtual void Write(SystemFontFontWriter writer);
    internal virtual void Import(SystemFontOpenTypeFontReader reader);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Syncfusion.Pdf.Parsing.SystemFontScriptRecord : object {
    [CompilerGeneratedAttribute]
private UInt32 <ScriptTag>k__BackingField;
    [CompilerGeneratedAttribute]
private ushort <ScriptOffset>k__BackingField;
    public UInt32 ScriptTag { get; private set; }
    public ushort ScriptOffset { get; private set; }
    [CompilerGeneratedAttribute]
public UInt32 get_ScriptTag();
    [CompilerGeneratedAttribute]
private void set_ScriptTag(UInt32 value);
    [CompilerGeneratedAttribute]
public ushort get_ScriptOffset();
    [CompilerGeneratedAttribute]
private void set_ScriptOffset(ushort value);
    public void Read(SystemFontOpenTypeFontReader reader);
    public virtual string ToString();
}
internal class Syncfusion.Pdf.Parsing.SystemFontSeac : SystemFontOperator {
    [NullableContextAttribute("1")]
public virtual void Execute(SystemFontBuildChar buildChar);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Syncfusion.Pdf.Parsing.SystemFontSegment : object {
    private ushort startCode;
    private ushort endCode;
    private short idDelta;
    private UInt16[] map;
    public SystemFontSegment(ushort startCode, ushort endCode, short idDelta);
    public SystemFontSegment(ushort startCode, ushort endCode, short idDelta, UInt16[] map);
    public bool IsInside(ushort charCode);
    public ushort GetGlyphId(ushort charCode);
    public void Write(SystemFontFontWriter writer);
    public void Import(SystemFontOpenTypeFontReader reader);
    public virtual int GetHashCode();
    public virtual bool Equals(object obj);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Syncfusion.Pdf.Parsing.SystemFontSequence : object {
    [CompilerGeneratedAttribute]
private UInt16[] <Subsitutes>k__BackingField;
    public UInt16[] Subsitutes { get; private set; }
    [CompilerGeneratedAttribute]
public UInt16[] get_Subsitutes();
    [CompilerGeneratedAttribute]
private void set_Subsitutes(UInt16[] value);
    public void Read(SystemFontOpenTypeFontReader reader);
    internal void Write(SystemFontFontWriter writer);
    internal void Import(SystemFontOpenTypeFontReader reader);
}
internal class Syncfusion.Pdf.Parsing.SystemFontSetCurrentPoint : SystemFontOperator {
    [NullableContextAttribute("1")]
public virtual void Execute(SystemFontBuildChar buildChar);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Syncfusion.Pdf.Parsing.SystemFontSimpleGlyph : SystemFontGlyphData {
    private List`1<SystemFontOutlinePoint[]> contours;
    internal IEnumerable`1<SystemFontOutlinePoint[]> Contours { get; }
    public SystemFontSimpleGlyph(SystemFontOpenTypeFontSourceBase fontFile, ushort glyphIndex);
    internal virtual IEnumerable`1<SystemFontOutlinePoint[]> get_Contours();
    private static bool XIsByte(Byte[] flags, int index);
    private static bool YIsByte(Byte[] flags, int index);
    private static bool Repeat(Byte[] flags, int index);
    private static bool XIsSame(Byte[] flags, int index);
    private static bool YIsSame(Byte[] flags, int index);
    public virtual void Read(SystemFontOpenTypeFontReader reader);
}
internal class Syncfusion.Pdf.Parsing.SystemFontSingleByteIntegerEncoding : SystemFontByteEncoding {
    [NullableContextAttribute("1")]
public virtual object Read(SystemFontEncodedDataReader reader);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal abstract class Syncfusion.Pdf.Parsing.SystemFontSingleSubstitution : SystemFontSubTable {
    private ushort coverageOffset;
    private SystemFontCoverage coverage;
    protected SystemFontCoverage Coverage { get; }
    public SystemFontSingleSubstitution(SystemFontOpenTypeFontSourceBase fontFile);
    protected SystemFontCoverage get_Coverage();
    internal static SystemFontSingleSubstitution CreateSingleSubstitutionTable(SystemFontOpenTypeFontSourceBase fontFile, ushort format);
    public virtual void Read(SystemFontOpenTypeFontReader reader);
    internal virtual void Write(SystemFontFontWriter writer);
    internal virtual void Import(SystemFontOpenTypeFontReader reader);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Syncfusion.Pdf.Parsing.SystemFontSingleSubstitutionFormat1 : SystemFontSingleSubstitution {
    private ushort deltaGlyphId;
    public SystemFontSingleSubstitutionFormat1(SystemFontOpenTypeFontSourceBase fontFile);
    public virtual SystemFontGlyphsSequence Apply(SystemFontGlyphsSequence glyphIDs);
    public virtual void Read(SystemFontOpenTypeFontReader reader);
    internal virtual void Write(SystemFontFontWriter writer);
    internal virtual void Import(SystemFontOpenTypeFontReader reader);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Syncfusion.Pdf.Parsing.SystemFontSingleSubstitutionFormat2 : SystemFontSingleSubstitution {
    private UInt16[] substitutes;
    public SystemFontSingleSubstitutionFormat2(SystemFontOpenTypeFontSourceBase fontFile);
    public virtual SystemFontGlyphsSequence Apply(SystemFontGlyphsSequence glyphIDs);
    public virtual void Read(SystemFontOpenTypeFontReader reader);
    internal virtual void Write(SystemFontFontWriter writer);
    internal virtual void Import(SystemFontOpenTypeFontReader reader);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Syncfusion.Pdf.Parsing.SystemFontsManager : object {
    private static HashSet`1<string> fontsWithKerning;
    private static HashSet`1<string> monospacedFonts;
    private static List`1<string> systemFonts;
    private static SystemFontsManager();
    public static IEnumerable`1<string> GetAvailableFonts();
    public static bool HasKerning(string fontName);
    public static bool IsMonospaced(string fontFamily);
    private static string SanitizeFontFileName(string fileName);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal static class Syncfusion.Pdf.Parsing.SystemFontsTags : object {
    internal static UInt32 DEFAULT_TABLE_SCRIPT_TAG;
    internal static UInt32 CFF_TABLE;
    internal static UInt32 CMAP_TABLE;
    internal static UInt32 GLYF_TABLE;
    internal static UInt32 MAXP_TABLE;
    internal static UInt32 LOCA_TABLE;
    internal static UInt32 HEAD_TABLE;
    internal static UInt32 HHEA_TABLE;
    internal static UInt32 HMTX_TABLE;
    internal static UInt32 KERN_TABLE;
    internal static UInt32 GSUB_TABLE;
    internal static UInt32 NAME_TABLE;
    internal static UInt32 OS_2_TABLE;
    internal static UInt32 POST_TABLE;
    internal static UInt32 OTTO_TAG;
    internal static UInt32 NULL_TAG;
    internal static ushort NULL_TYPE;
    internal static UInt32 TRUE_TYPE_COLLECTION;
    internal static UInt32 FEATURE_ACCESS_ALL_ALTERNATES;
    internal static UInt32 FEATURE_ABOVE_BASE_FORMS;
    internal static UInt32 FEATURE_ABOVE_BASE_MARK_POSITIONING;
    internal static UInt32 FEATURE_ABOVE_BASE_SUBSTITUTIONS;
    internal static UInt32 FEATURE_ALTERNATIVE_FRACTIONS;
    internal static UInt32 FEATURE_AKHANDS;
    internal static UInt32 FEATURE_BELOW_BASE_FORMS;
    internal static UInt32 FEATURE_BELOW_BASE_MARK_POSITIONING;
    internal static UInt32 FEATURE_BELOW_BASE_SUBSTITUTIONS;
    internal static UInt32 FEATURE_CONTEXTUAL_ALTERNATES;
    internal static UInt32 FEATURE_CASE_SENSITIVE_FORMS;
    internal static UInt32 FEATURE_GLYPH_COMPOSITION_DECOMPOSITION;
    internal static UInt32 FEATURE_CONJUNCT_FORM_AFTER_RO;
    internal static UInt32 FEATURE_CONJUNCT_FORMS;
    internal static UInt32 FEATURE_CONTEXTUAL_LIGATURES;
    internal static UInt32 FEATURE_CENTERED_CJK_PUNCTUATION;
    internal static UInt32 FEATURE_CAPITAL_SPACING;
    internal static UInt32 FEATURE_CONTEXTUAL_SWASH;
    internal static UInt32 FEATURE_CURSIVE_POSITIONING;
    internal static UInt32 FEATURE_PETITE_CAPITALS_FROM_CAPITALS;
    internal static UInt32 FEATURE_SMALL_CAPITALS_FROM_CAPITALS;
    internal static UInt32 FEATURE_DISTANCES;
    internal static UInt32 FEATURE_DISCRETIONARY_LIGATURES;
    internal static UInt32 FEATURE_DENOMINATORS;
    internal static UInt32 FEATURE_EXPERT_FORMS;
    internal static UInt32 FEATURE_FINAL_GLYPH_ON_LINE_ALTERNATES;
    internal static UInt32 FEATURE_TERMINAL_FORMS_2;
    internal static UInt32 FEATURE_TERMINAL_FORMS_3;
    internal static UInt32 FEATURE_TERMINAL_FORMS;
    internal static UInt32 FEATURE_FRACTIONS;
    internal static UInt32 FEATURE_FULL_WIDTHS;
    internal static UInt32 FEATURE_HALF_FORMS;
    internal static UInt32 FEATURE_HALANT_FORMS;
    internal static UInt32 FEATURE_ALTERNATE_HALF_WIDTHS;
    internal static UInt32 FEATURE_HISTORICAL_FORMS;
    internal static UInt32 FEATURE_HORIZONTAL_KANA_ALTERNATES;
    internal static UInt32 FEATURE_HISTORICAL_LIGATURES;
    internal static UInt32 FEATURE_HANGUL;
    internal static UInt32 FEATURE_HOJO_KANJI_FORMS;
    internal static UInt32 FEATURE_HALF_WIDTHS;
    internal static UInt32 FEATURE_INITIAL_FORMS;
    internal static UInt32 FEATURE_ISOLATED_FORMS;
    internal static UInt32 FEATURE_ITALICS;
    internal static UInt32 FEATURE_JUSTIFICATION_ALTERNATES;
    internal static UInt32 FEATURE_JIS78_FORMS;
    internal static UInt32 FEATURE_JIS83_FORMS;
    internal static UInt32 FEATURE_JIS90_FORMS;
    internal static UInt32 FEATURE_JIS2004_FORMS;
    internal static UInt32 FEATURE_KERNING;
    internal static UInt32 FEATURE_LEFT_BOUNDS;
    internal static UInt32 FEATURE_STANDARD_LIGATURES;
    internal static UInt32 FEATURE_LEADING_JAMO_FORMS;
    internal static UInt32 FEATURE_LINING_FIGURES;
    internal static UInt32 FEATURE_LOCALIZED_FORMS;
    internal static UInt32 FEATURE_LEFT_TO_RIGHT_ALTERNATES;
    internal static UInt32 FEATURE_LEFT_TO_RIGHT_MIRRORED_FORMS;
    internal static UInt32 FEATURE_MARK_POSITIONING;
    internal static UInt32 FEATURE_MEDIAL_FORMS_2;
    internal static UInt32 FEATURE_MEDIAL_FORMS;
    internal static UInt32 FEATURE_MATHEMATICAL_GREEK;
    internal static UInt32 FEATURE_MARK_TO_MARK_POSITIONING;
    internal static UInt32 FEATURE_MARK_POSITIONING_VIA_SUBSTITUTION;
    internal static UInt32 FEATURE_ALTERNATE_ANNOTATION_FORMS;
    internal static UInt32 FEATURE_NLC_KANJI_FORMS;
    internal static UInt32 FEATURE_NUKTA_FORMS;
    internal static UInt32 FEATURE_NUMERATORS;
    internal static UInt32 FEATURE_OLDSTYLE_FIGURES;
    internal static UInt32 FEATURE_OPTICAL_BOUNDS;
    internal static UInt32 FEATURE_ORDINALS;
    internal static UInt32 FEATURE_ORNAMENTS;
    internal static UInt32 FEATURE_PROPORTIONAL_ALTERNATE_WIDTHS;
    internal static UInt32 FEATURE_PETITE_CAPITALS;
    internal static UInt32 FEATURE_PROPORTIONAL_KANA;
    internal static UInt32 FEATURE_PROPORTIONAL_FIGURES;
    internal static UInt32 FEATURE_PRE_BASE_FORMS;
    internal static UInt32 FEATURE_PRE_BASE_SUBSTITUTIONS;
    internal static UInt32 FEATURE_POST_BASE_FORMS;
    internal static UInt32 FEATURE_POST_BASE_SUBSTITUTIONS;
    internal static UInt32 FEATURE_PROPORTIONAL_WIDTHS;
    internal static UInt32 FEATURE_QUARTER_WIDTHS;
    internal static UInt32 FEATURE_RANDOMIZE;
    internal static UInt32 FEATURE_RAKAR_FORMS;
    internal static UInt32 FEATURE_REQUIRED_LIGATURES;
    internal static UInt32 FEATURE_REPH_FORMS;
    internal static UInt32 FEATURE_RIGHT_BOUNDS;
    internal static UInt32 FEATURE_RIGHT_TO_LEFT_ALTERNATES;
    internal static UInt32 FEATURE_RIGHT_TO_LEFT_MIRRORED_FORMS;
    internal static UInt32 FEATURE_RUBY_NOTATION_FORMS;
    internal static UInt32 FEATURE_STYLISTIC_ALTERNATES;
    internal static UInt32 FEATURE_SCIENTIFIC_INFERIORS;
    internal static UInt32 FEATURE_OPTICAL_SIZE;
    internal static UInt32 FEATURE_SMALL_CAPITALS;
    internal static UInt32 FEATURE_SIMPLIFIED_FORMS;
    internal static UInt32 FEATURE_STYLISTIC_SET_1;
    internal static UInt32 FEATURE_STYLISTIC_SET_2;
    internal static UInt32 FEATURE_STYLISTIC_SET_3;
    internal static UInt32 FEATURE_STYLISTIC_SET_4;
    internal static UInt32 FEATURE_STYLISTIC_SET_5;
    internal static UInt32 FEATURE_STYLISTIC_SET_6;
    internal static UInt32 FEATURE_STYLISTIC_SET_7;
    internal static UInt32 FEATURE_STYLISTIC_SET_8;
    internal static UInt32 FEATURE_STYLISTIC_SET_9;
    internal static UInt32 FEATURE_STYLISTIC_SET_10;
    internal static UInt32 FEATURE_STYLISTIC_SET_11;
    internal static UInt32 FEATURE_STYLISTIC_SET_12;
    internal static UInt32 FEATURE_STYLISTIC_SET_13;
    internal static UInt32 FEATURE_STYLISTIC_SET_14;
    internal static UInt32 FEATURE_STYLISTIC_SET_15;
    internal static UInt32 FEATURE_STYLISTIC_SET_16;
    internal static UInt32 FEATURE_STYLISTIC_SET_17;
    internal static UInt32 FEATURE_STYLISTIC_SET_18;
    internal static UInt32 FEATURE_STYLISTIC_SET_19;
    internal static UInt32 FEATURE_STYLISTIC_SET_20;
    internal static UInt32 FEATURE_SUBSCRIPT;
    internal static UInt32 FEATURE_SUPERSCRIPT;
    internal static UInt32 FEATURE_SWASH;
    internal static UInt32 FEATURE_TITLING;
    internal static UInt32 FEATURE_TRAILING_JAMO_FORMS;
    internal static UInt32 FEATURE_TRADITIONAL_NAME_FORMS;
    internal static UInt32 FEATURE_TABULAR_FIGURES;
    internal static UInt32 FEATURE_TRADITIONAL_FORMS;
    internal static UInt32 FEATURE_THIRD_WIDTHS;
    internal static UInt32 FEATURE_UNICASE;
    internal static UInt32 FEATURE_ALTERNATE_VERTICAL_METRICS;
    internal static UInt32 FEATURE_VATTU_VARIANTS;
    internal static UInt32 FEATURE_VERTICAL_WRITING;
    internal static UInt32 FEATURE_ALTERNATE_VERTICAL_HALF_METRICS;
    internal static UInt32 FEATURE_VOWEL_JAMO_FORMS;
    internal static UInt32 FEATURE_VERTICAL_KANA_ALTERNATES;
    internal static UInt32 FEATURE_VERTICAL_KERNING;
    internal static UInt32 FEATURE_PROPORTIONAL_ALTERNATE_VERTICAL_METRICS;
    internal static UInt32 FEATURE_VERTICAL_ALTERNATES_AND_ROTATION;
    internal static UInt32 FEATURE_SLASHED_ZERO;
    private static SystemFontsTags();
    internal static string GetStringFromTag(UInt32 tag);
    internal static UInt32 GetTagFromString(string str);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal static class Syncfusion.Pdf.Parsing.SystemFontStandardStrings : object {
    private static String[] standardStrings;
    public static int StandardStringsCount { get; }
    private static SystemFontStandardStrings();
    public static int get_StandardStringsCount();
    public static bool IsStandardString(ushort sid);
    public static string GetStandardString(ushort sid);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[DefaultMemberAttribute("Item")]
internal class Syncfusion.Pdf.Parsing.SystemFontStringIndex : SystemFontIndex {
    private String[] strings;
    public string Item { get; }
    public SystemFontStringIndex(SystemFontCFFFontFile file, long offset);
    public string get_Item(ushort sid);
    private string ReadString(SystemFontCFFFontReader reader, UInt32 offset, int length);
    private string GetString(int index);
    public virtual void Read(SystemFontCFFFontReader reader);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[DefaultMemberAttribute("Item")]
internal class Syncfusion.Pdf.Parsing.SystemFontSubrsIndex : SystemFontIndex {
    private int charstringType;
    private Byte[][] subrs;
    private ushort bias;
    public Byte[] Item { get; }
    public SystemFontSubrsIndex(SystemFontCFFFontFile fontFile, int charstringType, long offset);
    public Byte[] get_Item(int index);
    private Byte[] ReadSubr(SystemFontCFFFontReader reader, UInt32 offset, int length);
    private Byte[] GetSubr(int index);
    public virtual void Read(SystemFontCFFFontReader reader);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Syncfusion.Pdf.Parsing.SystemFontSubRule : SystemFontTableBase {
    private UInt16[] input;
    private SystemFontSubstLookupRecord[] substitutions;
    public SystemFontSubRule(SystemFontOpenTypeFontSourceBase fontFile);
    public bool IsMatch(SystemFontGlyphsSequence glyphIDs, int startIndex);
    public virtual void Read(SystemFontOpenTypeFontReader reader);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Syncfusion.Pdf.Parsing.SystemFontSubRuleSet : SystemFontTableBase {
    private UInt16[] subRuleOffsets;
    private SystemFontSubRule[] subRules;
    public SystemFontSubRule[] SubRules { get; }
    public SystemFontSubRuleSet(SystemFontOpenTypeFontSourceBase fontFile);
    public SystemFontSubRule[] get_SubRules();
    private SystemFontSubRule ReadSubRule(SystemFontOpenTypeFontReader reader, ushort offset);
    public virtual void Read(SystemFontOpenTypeFontReader reader);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Syncfusion.Pdf.Parsing.SystemFontSubstLookupRecord : SystemFontTableBase {
    private ushort lookupIndex;
    private SystemFontLookup lookup;
    [CompilerGeneratedAttribute]
private ushort <SequenceIndex>k__BackingField;
    public ushort SequenceIndex { get; private set; }
    public SystemFontLookup Lookup { get; }
    public SystemFontSubstLookupRecord(SystemFontOpenTypeFontSourceBase fontFile);
    [CompilerGeneratedAttribute]
public ushort get_SequenceIndex();
    [CompilerGeneratedAttribute]
private void set_SequenceIndex(ushort value);
    public SystemFontLookup get_Lookup();
    public virtual void Read(SystemFontOpenTypeFontReader reader);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal abstract class Syncfusion.Pdf.Parsing.SystemFontSubTable : SystemFontTableBase {
    public SystemFontSubTable(SystemFontOpenTypeFontSourceBase fontFile);
    private static SystemFontSubTable CreateSubTable(SystemFontOpenTypeFontSourceBase fontSource, ushort type, SystemFontOpenTypeFontReader reader);
    internal static SystemFontSubTable ReadSubTable(SystemFontOpenTypeFontSourceBase fontSource, SystemFontOpenTypeFontReader reader, ushort type);
    internal static SystemFontSubTable ImportSubTable(SystemFontOpenTypeFontSourceBase fontSource, SystemFontOpenTypeFontReader reader, ushort type);
    protected SystemFontCoverage ReadCoverage(SystemFontOpenTypeFontReader reader, ushort offset);
    public abstract virtual SystemFontGlyphsSequence Apply(SystemFontGlyphsSequence glyphIndices);
}
internal class Syncfusion.Pdf.Parsing.SystemFontSupplement : object {
    [NullableContextAttribute("1")]
public void Read(SystemFontCFFFontReader reader);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Syncfusion.Pdf.Parsing.SystemFontSupplementalEncoding : object {
    private SystemFontSupplement[] supplements;
    public void Read(SystemFontCFFFontReader reader);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal abstract class Syncfusion.Pdf.Parsing.SystemFontSystemFontName : SystemFontTrueTypeTableBase {
    internal UInt32 Tag { get; }
    public string FontFamily { get; }
    public SystemFontSystemFontName(SystemFontOpenTypeFontSourceBase fontSource);
    internal virtual UInt32 get_Tag();
    public abstract virtual string get_FontFamily();
    internal static SystemFontSystemFontName ReadNameTable(SystemFontOpenTypeFontSourceBase fontSource, SystemFontOpenTypeFontReader reader);
    internal abstract virtual string ReadName(ushort languageID, ushort nameID);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal abstract class Syncfusion.Pdf.Parsing.SystemFontTableBase : object {
    private SystemFontOpenTypeFontSourceBase fontSource;
    [CompilerGeneratedAttribute]
private long <Offset>k__BackingField;
    internal long Offset { get; internal set; }
    protected SystemFontOpenTypeFontReader Reader { get; }
    protected SystemFontOpenTypeFontSourceBase FontSource { get; }
    public SystemFontTableBase(SystemFontOpenTypeFontSourceBase fontSource);
    [CompilerGeneratedAttribute]
internal long get_Offset();
    [CompilerGeneratedAttribute]
internal void set_Offset(long value);
    protected SystemFontOpenTypeFontReader get_Reader();
    protected SystemFontOpenTypeFontSourceBase get_FontSource();
    public abstract virtual void Read(SystemFontOpenTypeFontReader reader);
    internal virtual void Write(SystemFontFontWriter writer);
    internal virtual void Import(SystemFontOpenTypeFontReader reader);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Syncfusion.Pdf.Parsing.SystemFontTableRecord : object {
    [CompilerGeneratedAttribute]
private UInt32 <Tag>k__BackingField;
    [CompilerGeneratedAttribute]
private UInt32 <CheckSum>k__BackingField;
    [CompilerGeneratedAttribute]
private UInt32 <Offset>k__BackingField;
    [CompilerGeneratedAttribute]
private UInt32 <Length>k__BackingField;
    public UInt32 Tag { get; public set; }
    public UInt32 CheckSum { get; public set; }
    public UInt32 Offset { get; public set; }
    public UInt32 Length { get; public set; }
    [CompilerGeneratedAttribute]
public UInt32 get_Tag();
    [CompilerGeneratedAttribute]
public void set_Tag(UInt32 value);
    [CompilerGeneratedAttribute]
public UInt32 get_CheckSum();
    [CompilerGeneratedAttribute]
public void set_CheckSum(UInt32 value);
    [CompilerGeneratedAttribute]
public UInt32 get_Offset();
    [CompilerGeneratedAttribute]
public void set_Offset(UInt32 value);
    [CompilerGeneratedAttribute]
public UInt32 get_Length();
    [CompilerGeneratedAttribute]
public void set_Length(UInt32 value);
    public void Read(SystemFontOpenTypeFontReader reader);
    public virtual string ToString();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal static class Syncfusion.Pdf.Parsing.SystemFontTags : object {
    internal static UInt32 DEFAULT_TABLE_SCRIPT_TAG;
    internal static UInt32 CFF_TABLE;
    internal static UInt32 CMAP_TABLE;
    internal static UInt32 GLYF_TABLE;
    internal static UInt32 MAXP_TABLE;
    internal static UInt32 LOCA_TABLE;
    internal static UInt32 HEAD_TABLE;
    internal static UInt32 HHEA_TABLE;
    internal static UInt32 HMTX_TABLE;
    internal static UInt32 KERN_TABLE;
    internal static UInt32 GSUB_TABLE;
    internal static UInt32 NAME_TABLE;
    internal static UInt32 OS_2_TABLE;
    internal static UInt32 POST_TABLE;
    internal static UInt32 OTTO_TAG;
    internal static UInt32 NULL_TAG;
    internal static ushort NULL_TYPE;
    internal static UInt32 TRUE_TYPE_COLLECTION;
    internal static UInt32 FEATURE_ACCESS_ALL_ALTERNATES;
    internal static UInt32 FEATURE_ABOVE_BASE_FORMS;
    internal static UInt32 FEATURE_ABOVE_BASE_MARK_POSITIONING;
    internal static UInt32 FEATURE_ABOVE_BASE_SUBSTITUTIONS;
    internal static UInt32 FEATURE_ALTERNATIVE_FRACTIONS;
    internal static UInt32 FEATURE_AKHANDS;
    internal static UInt32 FEATURE_BELOW_BASE_FORMS;
    internal static UInt32 FEATURE_BELOW_BASE_MARK_POSITIONING;
    internal static UInt32 FEATURE_BELOW_BASE_SUBSTITUTIONS;
    internal static UInt32 FEATURE_CONTEXTUAL_ALTERNATES;
    internal static UInt32 FEATURE_CASE_SENSITIVE_FORMS;
    internal static UInt32 FEATURE_GLYPH_COMPOSITION_DECOMPOSITION;
    internal static UInt32 FEATURE_CONJUNCT_FORM_AFTER_RO;
    internal static UInt32 FEATURE_CONJUNCT_FORMS;
    internal static UInt32 FEATURE_CONTEXTUAL_LIGATURES;
    internal static UInt32 FEATURE_CENTERED_CJK_PUNCTUATION;
    internal static UInt32 FEATURE_CAPITAL_SPACING;
    internal static UInt32 FEATURE_CONTEXTUAL_SWASH;
    internal static UInt32 FEATURE_CURSIVE_POSITIONING;
    internal static UInt32 FEATURE_PETITE_CAPITALS_FROM_CAPITALS;
    internal static UInt32 FEATURE_SMALL_CAPITALS_FROM_CAPITALS;
    internal static UInt32 FEATURE_DISTANCES;
    internal static UInt32 FEATURE_DISCRETIONARY_LIGATURES;
    internal static UInt32 FEATURE_DENOMINATORS;
    internal static UInt32 FEATURE_EXPERT_FORMS;
    internal static UInt32 FEATURE_FINAL_GLYPH_ON_LINE_ALTERNATES;
    internal static UInt32 FEATURE_TERMINAL_FORMS_2;
    internal static UInt32 FEATURE_TERMINAL_FORMS_3;
    internal static UInt32 FEATURE_TERMINAL_FORMS;
    internal static UInt32 FEATURE_FRACTIONS;
    internal static UInt32 FEATURE_FULL_WIDTHS;
    internal static UInt32 FEATURE_HALF_FORMS;
    internal static UInt32 FEATURE_HALANT_FORMS;
    internal static UInt32 FEATURE_ALTERNATE_HALF_WIDTHS;
    internal static UInt32 FEATURE_HISTORICAL_FORMS;
    internal static UInt32 FEATURE_HORIZONTAL_KANA_ALTERNATES;
    internal static UInt32 FEATURE_HISTORICAL_LIGATURES;
    internal static UInt32 FEATURE_HANGUL;
    internal static UInt32 FEATURE_HOJO_KANJI_FORMS;
    internal static UInt32 FEATURE_HALF_WIDTHS;
    internal static UInt32 FEATURE_INITIAL_FORMS;
    internal static UInt32 FEATURE_ISOLATED_FORMS;
    internal static UInt32 FEATURE_ITALICS;
    internal static UInt32 FEATURE_JUSTIFICATION_ALTERNATES;
    internal static UInt32 FEATURE_JIS78_FORMS;
    internal static UInt32 FEATURE_JIS83_FORMS;
    internal static UInt32 FEATURE_JIS90_FORMS;
    internal static UInt32 FEATURE_JIS2004_FORMS;
    internal static UInt32 FEATURE_KERNING;
    internal static UInt32 FEATURE_LEFT_BOUNDS;
    internal static UInt32 FEATURE_STANDARD_LIGATURES;
    internal static UInt32 FEATURE_LEADING_JAMO_FORMS;
    internal static UInt32 FEATURE_LINING_FIGURES;
    internal static UInt32 FEATURE_LOCALIZED_FORMS;
    internal static UInt32 FEATURE_LEFT_TO_RIGHT_ALTERNATES;
    internal static UInt32 FEATURE_LEFT_TO_RIGHT_MIRRORED_FORMS;
    internal static UInt32 FEATURE_MARK_POSITIONING;
    internal static UInt32 FEATURE_MEDIAL_FORMS_2;
    internal static UInt32 FEATURE_MEDIAL_FORMS;
    internal static UInt32 FEATURE_MATHEMATICAL_GREEK;
    internal static UInt32 FEATURE_MARK_TO_MARK_POSITIONING;
    internal static UInt32 FEATURE_MARK_POSITIONING_VIA_SUBSTITUTION;
    internal static UInt32 FEATURE_ALTERNATE_ANNOTATION_FORMS;
    internal static UInt32 FEATURE_NLC_KANJI_FORMS;
    internal static UInt32 FEATURE_NUKTA_FORMS;
    internal static UInt32 FEATURE_NUMERATORS;
    internal static UInt32 FEATURE_OLDSTYLE_FIGURES;
    internal static UInt32 FEATURE_OPTICAL_BOUNDS;
    internal static UInt32 FEATURE_ORDINALS;
    internal static UInt32 FEATURE_ORNAMENTS;
    internal static UInt32 FEATURE_PROPORTIONAL_ALTERNATE_WIDTHS;
    internal static UInt32 FEATURE_PETITE_CAPITALS;
    internal static UInt32 FEATURE_PROPORTIONAL_KANA;
    internal static UInt32 FEATURE_PROPORTIONAL_FIGURES;
    internal static UInt32 FEATURE_PRE_BASE_FORMS;
    internal static UInt32 FEATURE_PRE_BASE_SUBSTITUTIONS;
    internal static UInt32 FEATURE_POST_BASE_FORMS;
    internal static UInt32 FEATURE_POST_BASE_SUBSTITUTIONS;
    internal static UInt32 FEATURE_PROPORTIONAL_WIDTHS;
    internal static UInt32 FEATURE_QUARTER_WIDTHS;
    internal static UInt32 FEATURE_RANDOMIZE;
    internal static UInt32 FEATURE_RAKAR_FORMS;
    internal static UInt32 FEATURE_REQUIRED_LIGATURES;
    internal static UInt32 FEATURE_REPH_FORMS;
    internal static UInt32 FEATURE_RIGHT_BOUNDS;
    internal static UInt32 FEATURE_RIGHT_TO_LEFT_ALTERNATES;
    internal static UInt32 FEATURE_RIGHT_TO_LEFT_MIRRORED_FORMS;
    internal static UInt32 FEATURE_RUBY_NOTATION_FORMS;
    internal static UInt32 FEATURE_STYLISTIC_ALTERNATES;
    internal static UInt32 FEATURE_SCIENTIFIC_INFERIORS;
    internal static UInt32 FEATURE_OPTICAL_SIZE;
    internal static UInt32 FEATURE_SMALL_CAPITALS;
    internal static UInt32 FEATURE_SIMPLIFIED_FORMS;
    internal static UInt32 FEATURE_STYLISTIC_SET_1;
    internal static UInt32 FEATURE_STYLISTIC_SET_2;
    internal static UInt32 FEATURE_STYLISTIC_SET_3;
    internal static UInt32 FEATURE_STYLISTIC_SET_4;
    internal static UInt32 FEATURE_STYLISTIC_SET_5;
    internal static UInt32 FEATURE_STYLISTIC_SET_6;
    internal static UInt32 FEATURE_STYLISTIC_SET_7;
    internal static UInt32 FEATURE_STYLISTIC_SET_8;
    internal static UInt32 FEATURE_STYLISTIC_SET_9;
    internal static UInt32 FEATURE_STYLISTIC_SET_10;
    internal static UInt32 FEATURE_STYLISTIC_SET_11;
    internal static UInt32 FEATURE_STYLISTIC_SET_12;
    internal static UInt32 FEATURE_STYLISTIC_SET_13;
    internal static UInt32 FEATURE_STYLISTIC_SET_14;
    internal static UInt32 FEATURE_STYLISTIC_SET_15;
    internal static UInt32 FEATURE_STYLISTIC_SET_16;
    internal static UInt32 FEATURE_STYLISTIC_SET_17;
    internal static UInt32 FEATURE_STYLISTIC_SET_18;
    internal static UInt32 FEATURE_STYLISTIC_SET_19;
    internal static UInt32 FEATURE_STYLISTIC_SET_20;
    internal static UInt32 FEATURE_SUBSCRIPT;
    internal static UInt32 FEATURE_SUPERSCRIPT;
    internal static UInt32 FEATURE_SWASH;
    internal static UInt32 FEATURE_TITLING;
    internal static UInt32 FEATURE_TRAILING_JAMO_FORMS;
    internal static UInt32 FEATURE_TRADITIONAL_NAME_FORMS;
    internal static UInt32 FEATURE_TABULAR_FIGURES;
    internal static UInt32 FEATURE_TRADITIONAL_FORMS;
    internal static UInt32 FEATURE_THIRD_WIDTHS;
    internal static UInt32 FEATURE_UNICASE;
    internal static UInt32 FEATURE_ALTERNATE_VERTICAL_METRICS;
    internal static UInt32 FEATURE_VATTU_VARIANTS;
    internal static UInt32 FEATURE_VERTICAL_WRITING;
    internal static UInt32 FEATURE_ALTERNATE_VERTICAL_HALF_METRICS;
    internal static UInt32 FEATURE_VOWEL_JAMO_FORMS;
    internal static UInt32 FEATURE_VERTICAL_KANA_ALTERNATES;
    internal static UInt32 FEATURE_VERTICAL_KERNING;
    internal static UInt32 FEATURE_PROPORTIONAL_ALTERNATE_VERTICAL_METRICS;
    internal static UInt32 FEATURE_VERTICAL_ALTERNATES_AND_ROTATION;
    internal static UInt32 FEATURE_SLASHED_ZERO;
    private static SystemFontTags();
    internal static string GetStringFromTag(UInt32 tag);
    internal static UInt32 GetTagFromString(string str);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Syncfusion.Pdf.Parsing.SystemFontTCCHeader : object {
    private SystemFontTrueTypeCollection collection;
    private UInt32[] offsetTable;
    private SystemFontOpenTypeFontSourceBase[] fonts;
    protected SystemFontOpenTypeFontReader Reader { get; }
    public SystemFontOpenTypeFontSourceBase[] Fonts { get; }
    public SystemFontTCCHeader(SystemFontTrueTypeCollection collection);
    protected SystemFontOpenTypeFontReader get_Reader();
    public SystemFontOpenTypeFontSourceBase[] get_Fonts();
    private static SystemFontOpenTypeFontSource ReadTrueTypeFontFile(SystemFontOpenTypeFontReader reader, UInt32 offset);
    public void Read(SystemFontOpenTypeFontReader reader);
}
internal class Syncfusion.Pdf.Parsing.SystemFontThreeByteIntegerEncoding : SystemFontByteEncoding {
    [NullableContextAttribute("1")]
public virtual object Read(SystemFontEncodedDataReader reader);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Syncfusion.Pdf.Parsing.SystemFontTop : SystemFontDict {
    private ISystemFontEncoding encoding;
    private SystemFontCharString charString;
    private SystemFontCharset charset;
    private string familyName;
    private Nullable`1<SystemFontMatrix> fontMatrix;
    private SystemFontPrivate priv;
    private Nullable`1<int> charstringType;
    private Nullable`1<int> defaultWidthX;
    private Nullable`1<int> nominalWidthX;
    private Nullable`1<bool> usesCIDFontOperators;
    [CompilerGeneratedAttribute]
private static SystemFontOperatorDescriptor <FamilyNameOperator>k__BackingField;
    [CompilerGeneratedAttribute]
private static SystemFontOperatorDescriptor <WeightOperator>k__BackingField;
    [CompilerGeneratedAttribute]
private static SystemFontOperatorDescriptor <EncodingOperator>k__BackingField;
    [CompilerGeneratedAttribute]
private static SystemFontOperatorDescriptor <CharStringsOperator>k__BackingField;
    [CompilerGeneratedAttribute]
private static SystemFontOperatorDescriptor <ItalicAngleOperator>k__BackingField;
    [CompilerGeneratedAttribute]
private static SystemFontOperatorDescriptor <CharstringTypeOperator>k__BackingField;
    [CompilerGeneratedAttribute]
private static SystemFontOperatorDescriptor <CharsetOperator>k__BackingField;
    [CompilerGeneratedAttribute]
private static SystemFontOperatorDescriptor <FontMatrixOperator>k__BackingField;
    [CompilerGeneratedAttribute]
private static SystemFontOperatorDescriptor <PrivateOperator>k__BackingField;
    [CompilerGeneratedAttribute]
private static SystemFontOperatorDescriptor <DefaultWidthXOperator>k__BackingField;
    [CompilerGeneratedAttribute]
private static SystemFontOperatorDescriptor <NominalWidthXOperator>k__BackingField;
    [CompilerGeneratedAttribute]
private static SystemFontOperatorDescriptor <ROSOperator>k__BackingField;
    [CompilerGeneratedAttribute]
private static SystemFontOperatorDescriptor <FDArrayOperator>k__BackingField;
    [CompilerGeneratedAttribute]
private static SystemFontOperatorDescriptor <FDSelectOperator>k__BackingField;
    public static SystemFontOperatorDescriptor FamilyNameOperator { get; private set; }
    public static SystemFontOperatorDescriptor WeightOperator { get; private set; }
    public static SystemFontOperatorDescriptor EncodingOperator { get; private set; }
    public static SystemFontOperatorDescriptor CharStringsOperator { get; private set; }
    public static SystemFontOperatorDescriptor ItalicAngleOperator { get; private set; }
    public static SystemFontOperatorDescriptor CharstringTypeOperator { get; private set; }
    public static SystemFontOperatorDescriptor CharsetOperator { get; private set; }
    public static SystemFontOperatorDescriptor FontMatrixOperator { get; private set; }
    public static SystemFontOperatorDescriptor PrivateOperator { get; private set; }
    public static SystemFontOperatorDescriptor DefaultWidthXOperator { get; private set; }
    public static SystemFontOperatorDescriptor NominalWidthXOperator { get; private set; }
    public static SystemFontOperatorDescriptor ROSOperator { get; private set; }
    public static SystemFontOperatorDescriptor FDArrayOperator { get; private set; }
    public static SystemFontOperatorDescriptor FDSelectOperator { get; private set; }
    public int CharstringType { get; }
    public ISystemFontEncoding Encoding { get; }
    public SystemFontCharset Charset { get; }
    public SystemFontCharString CharString { get; }
    public string FamilyName { get; }
    public SystemFontMatrix FontMatrix { get; }
    public SystemFontPrivate Private { get; }
    public int DefaultWidthX { get; }
    public int NominalWidthX { get; }
    public bool UsesCIDFontOperators { get; }
    private static SystemFontTop();
    public SystemFontTop(SystemFontCFFFontFile file, long offset, int length);
    [CompilerGeneratedAttribute]
public static SystemFontOperatorDescriptor get_FamilyNameOperator();
    [CompilerGeneratedAttribute]
private static void set_FamilyNameOperator(SystemFontOperatorDescriptor value);
    [CompilerGeneratedAttribute]
public static SystemFontOperatorDescriptor get_WeightOperator();
    [CompilerGeneratedAttribute]
private static void set_WeightOperator(SystemFontOperatorDescriptor value);
    [CompilerGeneratedAttribute]
public static SystemFontOperatorDescriptor get_EncodingOperator();
    [CompilerGeneratedAttribute]
private static void set_EncodingOperator(SystemFontOperatorDescriptor value);
    [CompilerGeneratedAttribute]
public static SystemFontOperatorDescriptor get_CharStringsOperator();
    [CompilerGeneratedAttribute]
private static void set_CharStringsOperator(SystemFontOperatorDescriptor value);
    [CompilerGeneratedAttribute]
public static SystemFontOperatorDescriptor get_ItalicAngleOperator();
    [CompilerGeneratedAttribute]
private static void set_ItalicAngleOperator(SystemFontOperatorDescriptor value);
    [CompilerGeneratedAttribute]
public static SystemFontOperatorDescriptor get_CharstringTypeOperator();
    [CompilerGeneratedAttribute]
private static void set_CharstringTypeOperator(SystemFontOperatorDescriptor value);
    [CompilerGeneratedAttribute]
public static SystemFontOperatorDescriptor get_CharsetOperator();
    [CompilerGeneratedAttribute]
private static void set_CharsetOperator(SystemFontOperatorDescriptor value);
    [CompilerGeneratedAttribute]
public static SystemFontOperatorDescriptor get_FontMatrixOperator();
    [CompilerGeneratedAttribute]
private static void set_FontMatrixOperator(SystemFontOperatorDescriptor value);
    [CompilerGeneratedAttribute]
public static SystemFontOperatorDescriptor get_PrivateOperator();
    [CompilerGeneratedAttribute]
private static void set_PrivateOperator(SystemFontOperatorDescriptor value);
    [CompilerGeneratedAttribute]
public static SystemFontOperatorDescriptor get_DefaultWidthXOperator();
    [CompilerGeneratedAttribute]
private static void set_DefaultWidthXOperator(SystemFontOperatorDescriptor value);
    [CompilerGeneratedAttribute]
public static SystemFontOperatorDescriptor get_NominalWidthXOperator();
    [CompilerGeneratedAttribute]
private static void set_NominalWidthXOperator(SystemFontOperatorDescriptor value);
    [CompilerGeneratedAttribute]
public static SystemFontOperatorDescriptor get_ROSOperator();
    [CompilerGeneratedAttribute]
private static void set_ROSOperator(SystemFontOperatorDescriptor value);
    [CompilerGeneratedAttribute]
public static SystemFontOperatorDescriptor get_FDArrayOperator();
    [CompilerGeneratedAttribute]
private static void set_FDArrayOperator(SystemFontOperatorDescriptor value);
    [CompilerGeneratedAttribute]
public static SystemFontOperatorDescriptor get_FDSelectOperator();
    [CompilerGeneratedAttribute]
private static void set_FDSelectOperator(SystemFontOperatorDescriptor value);
    public int get_CharstringType();
    public ISystemFontEncoding get_Encoding();
    public SystemFontCharset get_Charset();
    public SystemFontCharString get_CharString();
    public string get_FamilyName();
    public SystemFontMatrix get_FontMatrix();
    public SystemFontPrivate get_Private();
    public int get_DefaultWidthX();
    public int get_NominalWidthX();
    public bool get_UsesCIDFontOperators();
    public sealed virtual Byte[] GetSubr(int index);
    public sealed virtual Byte[] GetGlobalSubr(int index);
    public sealed virtual SystemFontType1GlyphData GetGlyphData(string name);
    public ushort GetGlyphId(string name);
    public ushort GetGlyphId(ushort cid);
    internal string GetGlyphName(ushort cid);
    public ushort GetAdvancedWidth(ushort glyphId);
    public void GetGlyphOutlines(SystemFontGlyph glyph, double fontSize);
    private void ReadEncoding();
    private void ReadPrivate();
    private void ReadCharset();
    private void ReadCharString();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[DefaultMemberAttribute("Item")]
internal class Syncfusion.Pdf.Parsing.SystemFontTopIndex : SystemFontIndex {
    private SystemFontTop[] tops;
    public SystemFontTop Item { get; }
    public SystemFontTopIndex(SystemFontCFFFontFile file, long offset);
    public SystemFontTop get_Item(int index);
    private SystemFontTop ReadTop(SystemFontCFFFontReader reader, UInt32 offset, int length);
    private SystemFontTop GetTop(int index);
    public virtual void Read(SystemFontCFFFontReader reader);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Syncfusion.Pdf.Parsing.SystemFontTrueTypeCollection : object {
    private SystemFontOpenTypeFontReader reader;
    private SystemFontTCCHeader header;
    internal SystemFontOpenTypeFontReader Reader { get; }
    public IEnumerable`1<SystemFontOpenTypeFontSourceBase> Fonts { get; }
    public SystemFontTrueTypeCollection(SystemFontOpenTypeFontReader reader);
    internal SystemFontOpenTypeFontReader get_Reader();
    public IEnumerable`1<SystemFontOpenTypeFontSourceBase> get_Fonts();
    public void Initialzie();
}
internal abstract class Syncfusion.Pdf.Parsing.SystemFontTrueTypeTableBase : SystemFontTableBase {
    internal UInt32 Tag { get; }
    [NullableContextAttribute("1")]
public SystemFontTrueTypeTableBase(SystemFontOpenTypeFontSourceBase fontSource);
    internal abstract virtual UInt32 get_Tag();
}
internal class Syncfusion.Pdf.Parsing.SystemFontTwoByteIntegerEncodingType1 : SystemFontByteEncoding {
    [NullableContextAttribute("1")]
public virtual object Read(SystemFontEncodedDataReader reader);
}
internal class Syncfusion.Pdf.Parsing.SystemFontTwoByteIntegerEncodingType2 : SystemFontByteEncoding {
    [NullableContextAttribute("1")]
public virtual object Read(SystemFontEncodedDataReader reader);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Syncfusion.Pdf.Parsing.SystemFontType1GlyphData : object {
    [CompilerGeneratedAttribute]
private SystemFontGlyphOutlinesCollection <Oultlines>k__BackingField;
    [CompilerGeneratedAttribute]
private ushort <AdvancedWidth>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <HasWidth>k__BackingField;
    public SystemFontGlyphOutlinesCollection Oultlines { get; private set; }
    public ushort AdvancedWidth { get; private set; }
    public bool HasWidth { get; private set; }
    public SystemFontType1GlyphData(SystemFontGlyphOutlinesCollection outlines, Nullable`1<ushort> width);
    [CompilerGeneratedAttribute]
public SystemFontGlyphOutlinesCollection get_Oultlines();
    [CompilerGeneratedAttribute]
private void set_Oultlines(SystemFontGlyphOutlinesCollection value);
    [CompilerGeneratedAttribute]
public ushort get_AdvancedWidth();
    [CompilerGeneratedAttribute]
private void set_AdvancedWidth(ushort value);
    [CompilerGeneratedAttribute]
public bool get_HasWidth();
    [CompilerGeneratedAttribute]
private void set_HasWidth(bool value);
}
internal class Syncfusion.Pdf.Parsing.SystemFontVHCurveTo : SystemFontOperator {
    [NullableContextAttribute("1")]
public virtual void Execute(SystemFontBuildChar interpreter);
}
internal class Syncfusion.Pdf.Parsing.SystemFontVLineTo : SystemFontOperator {
    [NullableContextAttribute("1")]
public virtual void Execute(SystemFontBuildChar interpreter);
}
internal class Syncfusion.Pdf.Parsing.SystemFontVMoveTo : SystemFontOperator {
    [NullableContextAttribute("1")]
public virtual void Execute(SystemFontBuildChar interpreter);
}
internal class Syncfusion.Pdf.Parsing.SystemFontVVCurveTo : SystemFontOperator {
    [NullableContextAttribute("1")]
public virtual void Execute(SystemFontBuildChar interpreter);
}
[NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public class Syncfusion.Pdf.Parsing.TextSearchResultCollection : Dictionary`2<int, MatchedItemCollection> {
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Syncfusion.Pdf.Parsing.XFdfDocument : object {
    private Dictionary`2<object, object> table;
    private string pdfFilePath;
    private bool isAnnotationExport;
    private PdfLoadedDocument m_document;
    private PdfExportAnnotationCollection m_annotationCollection;
    private Dictionary`2<string, object> annotationObjects;
    private bool m_skipBorderStyle;
    private List`1<string> m_annotationAttributes;
    private string isContainsRV;
    internal IPdfPrimitive trailerId;
    internal bool ExportAppearance;
    internal bool isExportAppearance;
    internal PdfLoadedAnnotationType[] AnnotationTypes;
    private bool stampHasImageAppearance;
    private bool isStampAnnotation;
    internal bool IsExportAnnotations { get; internal set; }
    internal PdfExportAnnotationCollection AnnotationCollection { get; internal set; }
    public XFdfDocument(string filename);
    internal bool get_IsExportAnnotations();
    internal void set_IsExportAnnotations(bool value);
    internal PdfExportAnnotationCollection get_AnnotationCollection();
    internal void set_AnnotationCollection(PdfExportAnnotationCollection value);
    internal void SetFields(object fieldName, object Fieldvalue);
    internal void SetFields(object fieldName, object Fieldvalue, string uniqueKey);
    internal void Save(Stream stream);
    internal void Save(Stream stream, bool isacrobat);
    internal Dictionary`2<object, object> GetElements(Dictionary`2<object, object> table);
    private void WriteFieldName(Dictionary`2<object, object> value, XmlWriter textWriter);
    internal void ExportAnnotations(Stream stream, PdfLoadedDocument document);
    private void WriteFormData(XmlWriter textWriter);
    private void ExportAnnotationData(PdfLoadedAnnotation annotation, int index, XmlWriter textWriter);
    private void WriteAnnotationData(PdfLoadedAnnotation annotation, int pageIndex, XmlWriter textWriter, PdfDictionary dictionary);
    private void WriteDictionary(PdfDictionary dictionary, int pageIndex, XmlWriter textWriter, bool hasAppearance);
    private MemoryStream GetAppearanceString(IPdfPrimitive primitive);
    private void WriteAppearanceDictionary(XmlWriter textWriter, PdfDictionary dictionary);
    private void WriteObject(XmlWriter textWriter, string key, IPdfPrimitive primitive);
    private void WriteArray(XmlWriter textWriter, PdfArray array);
    private void WriteArrayElement(XmlWriter textWriter, IPdfPrimitive element);
    private void WriteAttribute(XmlWriter textWriter, string key, IPdfPrimitive primitive);
    private void WriteRawData(XmlWriter textWriter, string name, string value);
    private string GetColor(IPdfPrimitive primitive);
    private string GetValue(IPdfPrimitive primitive);
    private string GetAnnotationType(PdfDictionary dictionary);
    private string GetFormatedString(string value);
    private void ExportMeasureDictionary(PdfDictionary dictionary, XmlWriter textWriter);
    private void ExportMeasureFormatDetails(PdfDictionary measurementDetails, XmlWriter textWriter);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Syncfusion.Pdf.Parsing.XfdfParser : object {
    private PdfLoadedDocument m_document;
    private Stream m_stream;
    private XDocument m_xmlDocument;
    private string m_richTextPrefix;
    private Dictionary`2<string, PdfReferenceHolder> m_groupReferences;
    private List`1<PdfDictionary> m_groupHolders;
    internal XfdfParser(Stream stream, PdfLoadedDocument document);
    internal void ParseAndImportAnnotationData();
    private void ParseAnnotationData(XElement chileElement);
    private PdfStream GetStream(XElement element);
    private PdfDictionary GetDictionary(XElement element);
    private PdfArray GetArray(XElement element);
    private PdfNumber GetFixed(XElement element);
    private PdfNumber GetInt(XElement element);
    private PdfString GetString(XElement element);
    private PdfName GetName(XElement element);
    private PdfBoolean GetBoolean(XElement element);
    private Byte[] GetData(XElement element);
    private PdfDictionary GetAppearance(PdfDictionary appearance, XElement element);
    private void AddBorderStyle(PdfDictionary annotDictionary, XElement element);
    private void AddMeasureDictionary(PdfDictionary annotDictionary, XElement element);
    private void ParseInnerElements(PdfDictionary annotDictionary, XElement element, int pageIndex);
    private void AddNumber(PdfDictionary dictionary, XElement element, string attributeName, string key);
    private void AddString(PdfDictionary dictionary, XElement element, string attributeName, string key);
    private void AddKey(IPdfPrimitive primitive, PdfDictionary dictionary, XElement element);
    private PdfArray GetColorArray(string value);
    private void AddReferenceToGroup(PdfReferenceHolder holder, PdfDictionary dictionary);
    private void AddLineEndStyle(XElement element, PdfDictionary annotDictionary);
    private void AddAnnotationData(PdfDictionary annotDictionary, XElement element, int pageIndex);
    private void AddLinePoints(List`1<float> linePoints, string value);
    private Single[] ObtainFloatPoints(string value);
    private string GetFormatedString(string value);
    private void HandlePopUp(PdfArray annots, PdfReferenceHolder holder, PdfDictionary annotDictionary);
    private void CheckXfdf(XElement element);
    private void AddArrayElements(PdfArray array, XElement element);
    private void ApplyAttributeValues(PdfDictionary annotDictionary, IEnumerable`1<XAttribute> collection);
    private PdfDictionary GetAnnotationData(XElement element, int pageIndex);
    private void AddImageToAppearance(PdfDictionary annotDictionary, string value);
    private void SetMatrix(PdfDictionary template, PdfDictionary annotDictionary);
    private PdfLineEndingStyle MapLineEndingStyle(string style);
    private PdfAnnotationFlags MapAnnotationFlags(string flag);
    private void AddFloatPoints(PdfDictionary dictionary, Single[] points, string key);
    private void AddFloatPoints(List`1<float> collection, string value);
    private void AddFloat(PdfDictionary dictionary, string key, string value);
    private void AddInt(PdfDictionary dictionary, string key, string value);
    private void AddString(PdfDictionary dictionary, string key, string value);
    private Byte[] GetBytes(string hex);
    private void AddArrayElement(PdfArray array, IPdfPrimitive primitive);
    private void AddElements(XElement element, PdfDictionary dictionary);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Syncfusion.Pdf.Parsing.XfdfProperties : object {
    internal static string Dict;
    internal static string Key;
    internal static string Stream;
    internal static string Define;
    internal static string Data;
    internal static string Mode;
    internal static string Raw;
    internal static string Hex;
    internal static string Filtered;
    internal static string Ascii;
    internal static string Bool;
    internal static string Val;
    internal static string Name;
    internal static string String;
    internal static string Int;
    internal static string Fixed;
    internal static string Null;
    internal static string Array;
}
public enum Syncfusion.Pdf.PdfAlignmentStyle : Enum {
    public int value__;
    public static PdfAlignmentStyle None;
    public static PdfAlignmentStyle TopLeft;
    public static PdfAlignmentStyle TopCenter;
    public static PdfAlignmentStyle TopRight;
    public static PdfAlignmentStyle MiddleLeft;
    public static PdfAlignmentStyle MiddleCenter;
    public static PdfAlignmentStyle MiddleRight;
    public static PdfAlignmentStyle BottomLeft;
    public static PdfAlignmentStyle BottomCenter;
    public static PdfAlignmentStyle BottomRight;
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class Syncfusion.Pdf.PdfAnnotationException : PdfDocumentException {
    private static string ErrorMessage;
    public PdfAnnotationException(Exception innerException);
    public PdfAnnotationException(string message);
    public PdfAnnotationException(string message, Exception innerException);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class Syncfusion.Pdf.PdfArtifact : PdfTag {
    private RectangleF m_boundingBox;
    private PdfArtifactType m_artifactType;
    private PdfArtifactSubType m_subType;
    private PdfAttached m_attached;
    public RectangleF BoundingBox { get; public set; }
    public PdfArtifactType ArtifactType { get; public set; }
    public PdfArtifactSubType SubType { get; public set; }
    public PdfAttached Attached { get; public set; }
    public PdfArtifact(PdfArtifactType type);
    public PdfArtifact(PdfArtifactType type, PdfAttached attached);
    public PdfArtifact(PdfArtifactType type, PdfAttached attached, PdfArtifactSubType subType);
    public PdfArtifact(PdfArtifactType type, RectangleF bBox, PdfAttached attached, PdfArtifactSubType subType);
    public RectangleF get_BoundingBox();
    public void set_BoundingBox(RectangleF value);
    public PdfArtifactType get_ArtifactType();
    public void set_ArtifactType(PdfArtifactType value);
    public PdfArtifactSubType get_SubType();
    public void set_SubType(PdfArtifactSubType value);
    public PdfAttached get_Attached();
    public void set_Attached(PdfAttached value);
}
public enum Syncfusion.Pdf.PdfArtifactSubType : Enum {
    public int value__;
    public static PdfArtifactSubType Header;
    public static PdfArtifactSubType Footer;
    public static PdfArtifactSubType Watermark;
    public static PdfArtifactSubType None;
}
public enum Syncfusion.Pdf.PdfArtifactType : Enum {
    public int value__;
    public static PdfArtifactType Pagination;
    public static PdfArtifactType Layout;
    public static PdfArtifactType Page;
    public static PdfArtifactType Background;
    public static PdfArtifactType None;
}
public class Syncfusion.Pdf.PdfAttached : object {
    private bool m_top;
    private bool m_left;
    private bool m_bottom;
    private bool m_right;
    internal bool Top { get; }
    internal bool Left { get; }
    internal bool Bottom { get; }
    internal bool Right { get; }
    public PdfAttached(PdfEdge pageEdge);
    public PdfAttached(PdfEdge edge1, PdfEdge edge2);
    public PdfAttached(PdfEdge edge1, PdfEdge edge2, PdfEdge edge3, PdfEdge edge4);
    internal bool get_Top();
    internal bool get_Left();
    internal bool get_Bottom();
    internal bool get_Right();
    [NullableContextAttribute("1")]
public void SetEdge(PdfEdge[] edges);
}
public enum Syncfusion.Pdf.PdfAttachmentRelationship : Enum {
    public int value__;
    public static PdfAttachmentRelationship Source;
    public static PdfAttachmentRelationship Data;
    public static PdfAttachmentRelationship Alternative;
    public static PdfAttachmentRelationship Supplement;
    public static PdfAttachmentRelationship Unspecified;
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public abstract class Syncfusion.Pdf.PdfAutomaticField : PdfGraphicsElement {
    private RectangleF m_bounds;
    private PdfFont m_font;
    private PdfBrush m_brush;
    private PdfPen m_pen;
    private PdfStringFormat m_stringFormat;
    private SizeF m_templateSize;
    public RectangleF Bounds { get; public set; }
    public SizeF Size { get; public set; }
    public PointF Location { get; public set; }
    public PdfFont Font { get; public set; }
    public PdfBrush Brush { get; public set; }
    public PdfPen Pen { get; public set; }
    public PdfStringFormat StringFormat { get; public set; }
    protected PdfAutomaticField(PdfFont font);
    protected PdfAutomaticField(PdfFont font, PdfBrush brush);
    protected PdfAutomaticField(PdfFont font, RectangleF bounds);
    public RectangleF get_Bounds();
    public void set_Bounds(RectangleF value);
    public SizeF get_Size();
    public void set_Size(SizeF value);
    public PointF get_Location();
    public void set_Location(PointF value);
    public PdfFont get_Font();
    public void set_Font(PdfFont value);
    public PdfBrush get_Brush();
    public void set_Brush(PdfBrush value);
    public PdfPen get_Pen();
    public void set_Pen(PdfPen value);
    public PdfStringFormat get_StringFormat();
    public void set_StringFormat(PdfStringFormat value);
    public virtual void Draw(PdfGraphics graphics, float x, float y);
    protected internal abstract virtual string GetValue(PdfGraphics graphics);
    protected internal virtual void PerformDraw(PdfGraphics graphics, PointF location, float scalingX, float scalingY);
    protected SizeF ObtainSize();
    protected virtual void DrawInternal(PdfGraphics graphics);
    protected PdfBrush ObtainBrush();
    protected PdfFont ObtainFont();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Syncfusion.Pdf.PdfAutomaticFieldInfo : object {
    private PointF m_location;
    private PdfAutomaticField m_field;
    private float m_scalingX;
    private float m_scalingY;
    public PointF Location { get; public set; }
    public PdfAutomaticField Field { get; public set; }
    public float ScalingX { get; public set; }
    public float ScalingY { get; public set; }
    public PdfAutomaticFieldInfo(PdfAutomaticField field, PointF location);
    public PdfAutomaticFieldInfo(PdfAutomaticField field, PointF location, float scalingX, float scalingY);
    public PdfAutomaticFieldInfo(PdfAutomaticFieldInfo fieldInfo);
    public PointF get_Location();
    public void set_Location(PointF value);
    public PdfAutomaticField get_Field();
    public void set_Field(PdfAutomaticField value);
    public float get_ScalingX();
    public void set_ScalingX(float value);
    public float get_ScalingY();
    public void set_ScalingY(float value);
}
internal class Syncfusion.Pdf.PdfAutomaticFieldInfoCollection : PdfCollection {
    [NullableContextAttribute("1")]
public int Add(PdfAutomaticFieldInfo fieldInfo);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class Syncfusion.Pdf.PdfBookletCreator : object {
    public static PdfDocument CreateBooklet(PdfLoadedDocument loadedDocument, SizeF pageSize);
    public static PdfDocument CreateBooklet(PdfLoadedDocument loadedDocument, SizeF pageSize, bool twoSide);
    public static PdfDocument CreateBooklet(PdfLoadedDocument loadedDocument, SizeF pageSize, bool twoSide, PdfMargins margin);
    private static Int32[] GetNextPair(int index, int count, bool twoSide);
}
public enum Syncfusion.Pdf.PdfBorderOverlapStyle : Enum {
    public int value__;
    public static PdfBorderOverlapStyle Overlap;
    public static PdfBorderOverlapStyle Inside;
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class Syncfusion.Pdf.PdfBorders : object {
    private PdfPen m_left;
    private PdfPen m_right;
    private PdfPen m_top;
    private PdfPen m_bottom;
    public PdfPen Left { get; public set; }
    public PdfPen Right { get; public set; }
    public PdfPen Top { get; public set; }
    public PdfPen Bottom { get; public set; }
    unknown PdfPen All {public set; }
    internal bool IsAll { get; }
    public static PdfBorders Default { get; }
    public PdfPen get_Left();
    public void set_Left(PdfPen value);
    public PdfPen get_Right();
    public void set_Right(PdfPen value);
    public PdfPen get_Top();
    public void set_Top(PdfPen value);
    public PdfPen get_Bottom();
    public void set_Bottom(PdfPen value);
    public void set_All(PdfPen value);
    internal bool get_IsAll();
    public static PdfBorders get_Default();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[DefaultMemberAttribute("Item")]
internal class Syncfusion.Pdf.PdfCacheCollection : object {
    private List`1<List`1<object>> m_referenceObjects;
    private List`1<PdfFont> m_fontCollection;
    private List`1<object> Item { get; }
    internal List`1<PdfFont> FontCollection { get; internal set; }
    internal List`1<List`1<object>> ReferenceObjects { get; }
    private List`1<object> get_Item(int index);
    internal List`1<PdfFont> get_FontCollection();
    internal void set_FontCollection(List`1<PdfFont> value);
    internal List`1<List`1<object>> get_ReferenceObjects();
    public IPdfCache Search(IPdfCache obj);
    public bool Contains(IPdfCache obj);
    public IPdfCache ContainsFont(IPdfCache obj);
    public void AddFont(PdfFont obj);
    public int GroupCount(IPdfCache obj);
    public void Remove(IPdfCache obj);
    public void Clear();
    private List`1<object> CreateNewGroup();
    private List`1<object> GetGroup(IPdfCache result);
    private void RemoveGroup(List`1<object> group);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Syncfusion.Pdf.PdfCatalog : PdfDictionary {
    private PdfSectionCollection m_sections;
    private PdfAttachmentCollection m_attachment;
    private PdfViewerPreferences m_viewerPreferences;
    private PdfCatalogNames m_names;
    private XmpMetadata m_metadata;
    private PdfForm m_form;
    private PdfLoadedForm m_loadedForm;
    private PdfLoadedDocument m_loadedDocument;
    private PdfDictionary m_dictionary;
    private PdfPortfolioInformation m_pdfPortfolio;
    private bool m_noNames;
    [ThreadStaticAttribute]
internal static PdfStructTreeRoot m_structTreeRoot;
    public PdfViewerPreferences ViewerPreferences { get; public set; }
    internal PdfPortfolioInformation PdfPortfolio { get; internal set; }
    public static PdfStructTreeRoot StructTreeRoot { get; }
    public PdfForm Form { get; public set; }
    public PdfCatalogNames Names { get; }
    internal PdfDictionary Destinations { get; }
    internal PdfLoadedForm LoadedForm { get; internal set; }
    internal PdfLoadedDocument LoadedDocument { get; }
    internal PdfSectionCollection Pages { get; internal set; }
    internal PdfAttachmentCollection Attachments { get; internal set; }
    internal XmpMetadata Metadata { get; internal set; }
    internal PdfCatalog(PdfLoadedDocument document, PdfDictionary catalog);
    public PdfViewerPreferences get_ViewerPreferences();
    public void set_ViewerPreferences(PdfViewerPreferences value);
    internal PdfPortfolioInformation get_PdfPortfolio();
    internal void set_PdfPortfolio(PdfPortfolioInformation value);
    public static PdfStructTreeRoot get_StructTreeRoot();
    public PdfForm get_Form();
    public void set_Form(PdfForm value);
    public PdfCatalogNames get_Names();
    internal PdfDictionary get_Destinations();
    internal PdfLoadedForm get_LoadedForm();
    internal void set_LoadedForm(PdfLoadedForm value);
    internal PdfLoadedDocument get_LoadedDocument();
    internal PdfSectionCollection get_Pages();
    internal void set_Pages(PdfSectionCollection value);
    internal PdfAttachmentCollection get_Attachments();
    internal void set_Attachments(PdfAttachmentCollection value);
    internal XmpMetadata get_Metadata();
    internal void set_Metadata(XmpMetadata value);
    internal void CreateNamesIfNone();
    internal void InitializeStructTreeRoot();
    private void ReadMetadata();
    internal void ApplyPdfXConformance();
    internal void Clear();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Syncfusion.Pdf.PdfCatalogNames : object {
    private PdfAttachmentCollection m_attachments;
    internal PdfDictionary m_dictionary;
    public PdfAttachmentCollection EmbeddedFiles { get; public set; }
    internal PdfDictionary Destinations { get; }
    public IPdfPrimitive Element { get; }
    public PdfCatalogNames(PdfDictionary root);
    public PdfAttachmentCollection get_EmbeddedFiles();
    public void set_EmbeddedFiles(PdfAttachmentCollection value);
    internal PdfDictionary get_Destinations();
    internal IPdfPrimitive GetNamedObjectFromTree(PdfDictionary root, PdfString name);
    private IPdfPrimitive FindName(PdfDictionary current, PdfString name);
    private PdfDictionary GetProperKid(PdfDictionary current, PdfString name);
    private bool CheckLimits(PdfDictionary kid, PdfString name);
    public sealed virtual IPdfPrimitive get_Element();
    internal void MergeEmbedded(PdfCatalogNames names, PdfCrossTable crossTable);
    private void AppendEmbedded(List`1<IPdfPrimitive> embedded, PdfCrossTable crossTable);
    private string GetNodeRightLimit(PdfDictionary node);
    private void AppendObjects(string baseName, PdfDictionary node, List`1<IPdfPrimitive> embedded, bool updateLimits, PdfCrossTable crossTable);
    private void SortAttachmentNames(PdfArray loadedAttachmentNames, PdfDictionary catalogNames);
    private string GetUniqueName(string attachmentName, Dictionary`2<string, IPdfPrimitive> attachmentCollection);
    private List`1<IPdfPrimitive> GetEmbedded();
    private void CollectObjects(PdfDictionary leafNode, List`1<IPdfPrimitive> array);
    internal void Clear();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class Syncfusion.Pdf.PdfCollection : object {
    private List`1<object> m_list;
    public int Count { get; }
    protected List`1<object> List { get; }
    internal List`1<object> InternalList { get; }
    public int get_Count();
    protected List`1<object> get_List();
    internal List`1<object> get_InternalList();
    internal void CopyTo(IPdfWrapper[] array, int index);
    public sealed virtual IEnumerator GetEnumerator();
    internal void DoClear();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class Syncfusion.Pdf.PdfCompositeField : PdfMultipleValueField {
    private PdfAutomaticField[] m_automaticFields;
    private string m_text;
    public string Text { get; public set; }
    public PdfAutomaticField[] AutomaticFields { get; public set; }
    public PdfCompositeField(PdfFont font);
    public PdfCompositeField(PdfFont font, PdfBrush brush);
    public PdfCompositeField(PdfFont font, string text);
    public PdfCompositeField(PdfFont font, PdfBrush brush, string text);
    public PdfCompositeField(string text, PdfAutomaticField[] list);
    public PdfCompositeField(PdfFont font, string text, PdfAutomaticField[] list);
    public PdfCompositeField(PdfFont font, PdfBrush brush, string text, PdfAutomaticField[] list);
    public string get_Text();
    public void set_Text(string value);
    public PdfAutomaticField[] get_AutomaticFields();
    public void set_AutomaticFields(PdfAutomaticField[] value);
    protected internal virtual string GetValue(PdfGraphics graphics);
}
public enum Syncfusion.Pdf.PdfCompressionLevel : Enum {
    public int value__;
    public static PdfCompressionLevel None;
    public static PdfCompressionLevel BestSpeed;
    public static PdfCompressionLevel BelowNormal;
    public static PdfCompressionLevel Normal;
    public static PdfCompressionLevel AboveNormal;
    public static PdfCompressionLevel Best;
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class Syncfusion.Pdf.PdfConformanceException : PdfDocumentException {
    private static string ErrorMessage;
    public PdfConformanceException(Exception innerException);
    public PdfConformanceException(string message);
    public PdfConformanceException(string message, Exception innerException);
}
public enum Syncfusion.Pdf.PdfConformanceLevel : Enum {
    public int value__;
    public static PdfConformanceLevel None;
    public static PdfConformanceLevel Pdf_A1B;
    public static PdfConformanceLevel Pdf_X1A2001;
    public static PdfConformanceLevel Pdf_A2B;
    public static PdfConformanceLevel Pdf_A3B;
    public static PdfConformanceLevel Pdf_A1A;
    public static PdfConformanceLevel Pdf_A2A;
    public static PdfConformanceLevel Pdf_A2U;
    public static PdfConformanceLevel Pdf_A3A;
    public static PdfConformanceLevel Pdf_A3U;
    public static PdfConformanceLevel Pdf_A4;
    public static PdfConformanceLevel Pdf_A4E;
    public static PdfConformanceLevel Pdf_A4F;
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class Syncfusion.Pdf.PdfCreationDateField : PdfSingleValueField {
    private string m_formatString;
    public string DateFormatString { get; public set; }
    public PdfCreationDateField(PdfFont font);
    public PdfCreationDateField(PdfFont font, PdfBrush brush);
    public PdfCreationDateField(PdfFont font, RectangleF bounds);
    public string get_DateFormatString();
    public void set_DateFormatString(string value);
    protected internal virtual string GetValue(PdfGraphics graphics);
}
public enum Syncfusion.Pdf.PdfCrossReferenceType : Enum {
    public int value__;
    public static PdfCrossReferenceType CrossReferenceTable;
    public static PdfCrossReferenceType CrossReferenceStream;
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class Syncfusion.Pdf.PdfDateTimeField : PdfStaticField {
    private DateTime m_date;
    private string m_formatString;
    public string DateFormatString { get; public set; }
    public PdfDateTimeField(PdfFont font);
    public PdfDateTimeField(PdfFont font, PdfBrush brush);
    public PdfDateTimeField(PdfFont font, RectangleF bounds);
    public string get_DateFormatString();
    public void set_DateFormatString(string value);
    protected internal virtual string GetValue(PdfGraphics graphics);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class Syncfusion.Pdf.PdfDestinationPageNumberField : PdfPageNumberField {
    private PdfPage m_page;
    private PdfLoadedPage m_loadedPage;
    public PdfLoadedPage LoadedPage { get; public set; }
    public PdfPage Page { get; public set; }
    public PdfDestinationPageNumberField(PdfFont font);
    public PdfDestinationPageNumberField(PdfFont font, PdfBrush brush);
    public PdfDestinationPageNumberField(PdfFont font, RectangleF bounds);
    public PdfLoadedPage get_LoadedPage();
    public void set_LoadedPage(PdfLoadedPage value);
    public PdfPage get_Page();
    public void set_Page(PdfPage value);
    protected internal virtual string GetValue(PdfGraphics graphics);
}
public enum Syncfusion.Pdf.PdfDockStyle : Enum {
    public int value__;
    public static PdfDockStyle None;
    public static PdfDockStyle Bottom;
    public static PdfDockStyle Top;
    public static PdfDockStyle Left;
    public static PdfDockStyle Right;
    public static PdfDockStyle Fill;
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class Syncfusion.Pdf.PdfDocument : PdfDocumentBase {
    internal static float DefaultMargin;
    private static PdfFont s_defaultFont;
    [ThreadStaticAttribute]
private static PdfCacheCollection s_cache;
    private static object s_cacheLock;
    private PdfDocumentTemplate m_pageTemplate;
    private PdfAttachmentCollection m_attachments;
    private PdfDocumentPageCollection m_pages;
    private PdfNamedDestinationCollection m_namedDestinations;
    private bool m_isPdfViewerDocumentDisable;
    private PdfSectionCollection m_sections;
    private PdfPageSettings m_settings;
    private PdfBookmarkBase m_outlines;
    private bool m_bPageLabels;
    private bool m_bWasEncrypted;
    private PdfDocumentActions m_actions;
    private PdfColorSpace m_colorSpace;
    [ThreadStaticAttribute]
internal static PdfConformanceLevel ConformanceLevel;
    private static bool m_enableCache;
    [ThreadStaticAttribute]
private static bool m_enableUniqueResourceNaming;
    private static bool m_enableThreadSafe;
    private bool m_isDisposed;
    private bool m_isTaggedPdf;
    private PdfStructTreeRoot m_treeRoot;
    private bool m_isMergeDocHasSection;
    private ZugferdConformanceLevel m_zugferdConformanceLevel;
    private ZugferdVersion m_zugferdConformanceVersion;
    internal Dictionary`2<string, PdfImage> m_imageCollection;
    internal Dictionary`2<string, PdfDictionary> m_parnetTagDicitionaryCollection;
    private bool m_split;
    internal bool m_WordtoPDFTagged;
    internal static bool FontEmbeddingEnabled;
    internal bool SeparateTable { get; internal set; }
    public ZugferdConformanceLevel ZugferdConformanceLevel { get; public set; }
    public ZugferdVersion ZugferdVersion { get; public set; }
    public PdfDocumentTemplate Template { get; public set; }
    internal bool IsPdfViewerDocumentDisable { get; internal set; }
    public PdfDocumentActions Actions { get; }
    public bool AutoTag { get; public set; }
    public PdfDocumentPageCollection Pages { get; }
    public PdfNamedDestinationCollection NamedDestinationCollection { get; }
    public PdfSectionCollection Sections { get; }
    internal bool IsMergeDocHasSections { get; internal set; }
    public PdfPageSettings PageSettings { get; public set; }
    public PdfBookmarkBase Bookmarks { get; }
    public PdfAttachmentCollection Attachments { get; }
    public PdfForm Form { get; }
    public PdfColorSpace ColorSpace { get; public set; }
    internal static PdfCacheCollection Cache { get; internal set; }
    internal static PdfFont DefaultFont { get; }
    internal bool WasEncrypted { get; }
    internal Dictionary`2<string, PdfImage> ImageCollection { get; }
    public int PageCount { get; }
    internal PdfConformanceLevel Conformance { get; }
    public static bool EnableCache { get; public set; }
    public static bool EnableUniqueResourceNaming { get; public set; }
    public static bool EnableThreadSafe { get; public set; }
    private static PdfDocument();
    internal PdfDocument(bool isMerging);
    public PdfDocument(PdfConformanceLevel conformance);
    internal bool get_SeparateTable();
    internal void set_SeparateTable(bool value);
    public ZugferdConformanceLevel get_ZugferdConformanceLevel();
    public void set_ZugferdConformanceLevel(ZugferdConformanceLevel value);
    public ZugferdVersion get_ZugferdVersion();
    public void set_ZugferdVersion(ZugferdVersion value);
    public PdfDocumentTemplate get_Template();
    public void set_Template(PdfDocumentTemplate value);
    internal virtual bool get_IsPdfViewerDocumentDisable();
    internal virtual void set_IsPdfViewerDocumentDisable(bool value);
    public PdfDocumentActions get_Actions();
    public bool get_AutoTag();
    public void set_AutoTag(bool value);
    public PdfDocumentPageCollection get_Pages();
    public PdfNamedDestinationCollection get_NamedDestinationCollection();
    public PdfSectionCollection get_Sections();
    internal bool get_IsMergeDocHasSections();
    internal void set_IsMergeDocHasSections(bool value);
    public PdfPageSettings get_PageSettings();
    public void set_PageSettings(PdfPageSettings value);
    public virtual PdfBookmarkBase get_Bookmarks();
    public PdfAttachmentCollection get_Attachments();
    public PdfForm get_Form();
    public PdfColorSpace get_ColorSpace();
    public void set_ColorSpace(PdfColorSpace value);
    internal static PdfCacheCollection get_Cache();
    internal static void set_Cache(PdfCacheCollection value);
    internal static PdfFont get_DefaultFont();
    internal virtual bool get_WasEncrypted();
    internal Dictionary`2<string, PdfImage> get_ImageCollection();
    public virtual int get_PageCount();
    internal PdfConformanceLevel get_Conformance();
    private string CheckLicense();
    public virtual void Save(Stream stream);
    private void AddWatermark();
    public virtual void Close(bool completely);
    public sealed virtual void Dispose();
    public object Clone();
    public static void ClearFontCache();
    private void AutoTagRequiredElements();
    internal void PageLabelsSet();
    private void CheckPagesPresence();
    public static bool get_EnableCache();
    public static void set_EnableCache(bool value);
    public static bool get_EnableUniqueResourceNaming();
    public static void set_EnableUniqueResourceNaming(bool value);
    public static bool get_EnableThreadSafe();
    public static void set_EnableThreadSafe(bool value);
    private void ProcessPageLabels();
    private void SetDocumentColorProfile();
    internal string GetImageHash(Byte[] imageData);
    internal virtual PdfForm ObtainForm();
    internal virtual void AddFields(PdfLoadedDocument ldDoc, PdfPageBase newPage, List`1<PdfField> fields);
    internal virtual PdfPageBase ClonePage(PdfLoadedDocument ldDoc, PdfPageBase page, List`1<PdfArray> destinations);
    private void CloneAcroFormFontResources(PdfLoadedDocument ldDoc);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class Syncfusion.Pdf.PdfDocumentAuthorField : PdfSingleValueField {
    public PdfDocumentAuthorField(PdfFont font);
    public PdfDocumentAuthorField(PdfFont font, PdfBrush brush);
    public PdfDocumentAuthorField(PdfFont font, RectangleF bounds);
    protected internal virtual string GetValue(PdfGraphics graphics);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public abstract class Syncfusion.Pdf.PdfDocumentBase : object {
    private PdfMainObjectCollection m_objects;
    internal PdfArray m_lock;
    internal static object s_licenseLock;
    internal string m_licenseURI;
    private int m_progressPageIndex;
    private List`1<PdfNamedDestination> m_namedDetinations;
    private List`1<PdfImage> m_imageCollection;
    private PdfSecurity m_security;
    private PdfReference m_currentSavingObj;
    private PdfCatalog m_catalog;
    private PdfCrossTable m_crossTable;
    private PdfDocumentInformation m_documentInfo;
    private string m_password;
    private PdfCompressionLevel m_compression;
    private PdfFileStructure m_fileStructure;
    private List`1<IDisposable> m_disposeObjects;
    private bool m_enableMemoryOptimization;
    private bool m_wcagPDF;
    private PdfPortfolioInformation m_portfolio;
    internal PdfArray primitive;
    internal int m_positon;
    internal int m_orderposition;
    internal int m_onpositon;
    internal int m_offpositon;
    internal PdfArray m_order;
    internal PdfArray m_on;
    internal PdfArray m_off;
    internal PdfArray m_sublayer;
    internal int m_sublayerposition;
    internal PdfArray m_printLayer;
    internal bool m_isStreamCopied;
    internal bool m_isImported;
    private int m_annotCount;
    private bool m_isKidsPage;
    internal bool isCompressed;
    private bool m_isMerging;
    private PdfDocumentLayerCollection m_layers;
    internal ProgressEventHandler progressDelegate;
    private int m_pageProcessed;
    private int m_pageCount;
    internal int m_changedPages;
    private Dictionary`2<string, PdfField> m_fieldKids;
    private List`1<string> m_addedField;
    internal Dictionary`2<string, IPdfPrimitive> m_resourceCollection;
    internal Dictionary`2<PdfReferenceHolder, PdfDictionary> documentLayerCollection;
    private string m_baseUri;
    internal bool m_licensingAdded;
    private Dictionary`2<string, IPdfPrimitive> m_annotationCollection;
    private Dictionary`2<string, IPdfPrimitive> m_contentCollection;
    private Dictionary`2<string, IPdfPrimitive> m_extGstateCollection;
    private Dictionary`2<string, IPdfPrimitive> m_widgetAnnotationCollection;
    private Dictionary`2<string, IPdfPrimitive> m_fontCollection;
    private Dictionary`2<string, IPdfPrimitive> m_annotationReferenceCollection;
    internal bool m_isMergingdocument;
    internal PdfDictionary m_structElemnt;
    internal bool m_isFirstDocument;
    private List`1<PdfArray> annotArrays;
    [CompilerGeneratedAttribute]
private AnnotationPropertyChangedEventHandler AnnotationPropertyChanged;
    [CompilerGeneratedAttribute]
private DocumentSavedEventHandler DocumentSaved;
    [CompilerGeneratedAttribute]
private EventHandler`1<AnnotationAddedArgs> AnnotationAdded;
    [CompilerGeneratedAttribute]
private EventHandler`1<AnnotationRemovedArgs> AnnotationRemoved;
    internal List`1<PdfImage> ImageCollection { get; }
    public PdfSecurity Security { get; }
    internal static bool IsSecurityGranted { get; }
    public PdfDocumentInformation DocumentInformation { get; }
    public PdfViewerPreferences ViewerPreferences { get; public set; }
    public PdfCompressionLevel Compression { get; public set; }
    public PdfFileStructure FileStructure { get; public set; }
    public PdfPortfolioInformation PortfolioInformation { get; public set; }
    public PdfBookmarkBase Bookmarks { get; }
    internal bool WasEncrypted { get; }
    internal bool IsPdfViewerDocumentDisable { get; internal set; }
    internal PdfMainObjectCollection PdfObjects { get; }
    internal PdfReference CurrentSavingObj { get; internal set; }
    internal PdfCrossTable CrossTable { get; }
    internal PdfCatalog Catalog { get; }
    internal List`1<IDisposable> DisposeObjects { get; }
    public int PageCount { get; }
    public bool EnableMemoryOptimization { get; public set; }
    public PdfDocumentLayerCollection Layers { get; }
    internal Dictionary`2<string, IPdfPrimitive> ResourceCollection { get; }
    internal Dictionary`2<string, IPdfPrimitive> AnnotationCollection { get; }
    internal Dictionary`2<string, IPdfPrimitive> AnnotationReferenceCollection { get; }
    internal Dictionary`2<string, IPdfPrimitive> ContentCollection { get; }
    internal Dictionary`2<string, IPdfPrimitive> ExtGstateCollection { get; }
    internal Dictionary`2<string, IPdfPrimitive> WidgetAnnotationCollection { get; }
    internal Dictionary`2<string, IPdfPrimitive> FontCollection { get; }
    public string BaseUri { get; public set; }
    internal bool IsWCAGCloned { get; }
    private static PdfDocumentBase();
    [CompilerGeneratedAttribute]
internal void add_AnnotationPropertyChanged(AnnotationPropertyChangedEventHandler value);
    [CompilerGeneratedAttribute]
internal void remove_AnnotationPropertyChanged(AnnotationPropertyChangedEventHandler value);
    [CompilerGeneratedAttribute]
internal void add_DocumentSaved(DocumentSavedEventHandler value);
    [CompilerGeneratedAttribute]
internal void remove_DocumentSaved(DocumentSavedEventHandler value);
    public void add_SaveProgress(ProgressEventHandler value);
    public void remove_SaveProgress(ProgressEventHandler value);
    [CompilerGeneratedAttribute]
internal void add_AnnotationAdded(EventHandler`1<AnnotationAddedArgs> value);
    [CompilerGeneratedAttribute]
internal void remove_AnnotationAdded(EventHandler`1<AnnotationAddedArgs> value);
    [CompilerGeneratedAttribute]
internal void add_AnnotationRemoved(EventHandler`1<AnnotationRemovedArgs> value);
    [CompilerGeneratedAttribute]
internal void remove_AnnotationRemoved(EventHandler`1<AnnotationRemovedArgs> value);
    internal virtual void OnAnnotationAdded(AnnotationAddedArgs e);
    internal virtual void OnAnnotationRemoved(AnnotationRemovedArgs e);
    internal void OnAnnotationPropertyChanged(PdfAnnotation annotation, string propertyName);
    internal List`1<PdfImage> get_ImageCollection();
    public PdfSecurity get_Security();
    internal static bool get_IsSecurityGranted();
    public virtual PdfDocumentInformation get_DocumentInformation();
    public PdfViewerPreferences get_ViewerPreferences();
    public void set_ViewerPreferences(PdfViewerPreferences value);
    public PdfCompressionLevel get_Compression();
    public void set_Compression(PdfCompressionLevel value);
    public PdfFileStructure get_FileStructure();
    public void set_FileStructure(PdfFileStructure value);
    public PdfPortfolioInformation get_PortfolioInformation();
    public void set_PortfolioInformation(PdfPortfolioInformation value);
    private void m_fileStructure_TaggedPdfChanged(object sender, EventArgs e);
    public abstract virtual PdfBookmarkBase get_Bookmarks();
    internal abstract virtual bool get_WasEncrypted();
    internal abstract virtual bool get_IsPdfViewerDocumentDisable();
    internal abstract virtual void set_IsPdfViewerDocumentDisable(bool value);
    internal PdfMainObjectCollection get_PdfObjects();
    internal PdfReference get_CurrentSavingObj();
    internal void set_CurrentSavingObj(PdfReference value);
    internal PdfCrossTable get_CrossTable();
    internal PdfCatalog get_Catalog();
    internal List`1<IDisposable> get_DisposeObjects();
    public abstract virtual int get_PageCount();
    public bool get_EnableMemoryOptimization();
    public void set_EnableMemoryOptimization(bool value);
    public PdfDocumentLayerCollection get_Layers();
    internal Dictionary`2<string, IPdfPrimitive> get_ResourceCollection();
    internal Dictionary`2<string, IPdfPrimitive> get_AnnotationCollection();
    internal Dictionary`2<string, IPdfPrimitive> get_AnnotationReferenceCollection();
    internal Dictionary`2<string, IPdfPrimitive> get_ContentCollection();
    internal Dictionary`2<string, IPdfPrimitive> get_ExtGstateCollection();
    internal Dictionary`2<string, IPdfPrimitive> get_WidgetAnnotationCollection();
    internal Dictionary`2<string, IPdfPrimitive> get_FontCollection();
    public string get_BaseUri();
    public void set_BaseUri(string value);
    internal bool get_IsWCAGCloned();
    public static PdfDocumentBase Merge(PdfDocumentBase dest, PdfMergeOptions options, Object[] sourceDocuments);
    public static PdfDocumentBase Merge(PdfDocumentBase dest, Object[] sourceDocuments);
    public static PdfDocumentBase Merge(PdfDocumentBase dest, PdfLoadedDocument src);
    public void DisposeOnClose(IDisposable obj);
    public void Close();
    public virtual void Close(bool completely);
    public abstract virtual void Save(Stream stream);
    public PdfPageBase ImportPage(PdfLoadedDocument ldDoc, PdfPageBase page);
    internal void ImportPage(PdfLoadedDocument ldDoc, PdfPageBase page, PdfImportOptions options);
    public PdfPageBase ImportPage(PdfLoadedDocument ldDoc, int pageIndex);
    internal void ImportPage(PdfLoadedDocument ldDoc, int pageIndex, PdfImportOptions options);
    public PdfPageBase ImportPageRange(PdfLoadedDocument ldDoc, int startIndex, int endIndex);
    internal void ImportPageRange(PdfLoadedDocument ldDoc, int startIndex, int endIndex, PdfImportOptions options);
    public PdfPageBase ImportPageRange(PdfLoadedDocument ldDoc, int startIndex, int endIndex, bool importBookmarks);
    internal void GroupAcroFormFields(PdfDictionary acroForm, PdfArray annots);
    private PdfDictionary GetFirstKid(PdfDictionary fieldGroup);
    private void ApplyAppearanceField(PdfDictionary fieldDictionary, string text, PdfLoadedFieldTypes loadedFieldTypes, PdfDictionary expectedMK, PdfDictionary groupFields);
    private void RadioFieldAppearance(PdfDictionary fieldDictionary, string text, PdfLoadedFieldTypes loadedFieldTypes, PdfDictionary expectedMk);
    private void TextBoxFieldAppearance(PdfDictionary fieldDictionary, string text, PdfLoadedFieldTypes loadedFieldTypes, PdfDictionary expectedMk);
    private void SignatureFieldAppearance(PdfDictionary fieldDictionary, string text, PdfLoadedFieldTypes loadedFieldTypes, PdfDictionary expectedMk);
    private void CheckBoxFieldAppearance(PdfDictionary fieldDictionary, string text, PdfLoadedFieldTypes loadedFieldTypes, PdfDictionary expectedMk);
    protected string StyleToString(PdfCheckBoxStyle style);
    internal PdfCheckBoxStyle ObtainStyle(PdfDictionary fieldDictionary);
    private PdfCheckBoxStyle CreateStyle(PdfDictionary bs);
    private void ButtonFieldAppearance(PdfDictionary fieldDictionary, string text, PdfLoadedFieldTypes loadedFieldTypes, PdfDictionary expectedMk);
    private void ListBoxFieldAppearance(PdfDictionary fieldDictionary, string text, PdfLoadedFieldTypes loadedFieldTypes, PdfDictionary expectedMk, PdfArray options, PdfArray selectedValues);
    private Int32[] ObtainSelectedIndex(PdfArray selectvalue);
    private PdfListFieldItemCollection GetListItemCollection(PdfArray options);
    private void ComboBoxFieldAppearance(PdfDictionary fieldDictionary, string text, PdfLoadedFieldTypes loadedFieldTypes, PdfDictionary expectedMk);
    private PdfBrush ObtainShadowBrush(PdfDictionary fieldDictionary);
    private PdfBorderStyle ObtainBorderStyle(PdfDictionary fieldDictionary);
    private PdfBorderStyle CreateBorderStyle(PdfDictionary bs);
    internal PdfPen ObtainBorderPen(PdfDictionary fieldDictionary);
    private Single[] ObtainDashPatern(PdfDictionary fieldDictionary);
    private PdfBrush ObtainForeBrush(PdfDictionary fieldDictionary);
    private float ObtainBorderWidth(PdfDictionary fieldDictionary);
    internal PdfColor GetForeColour(string defaultAppearance);
    private float ParseFloatColour(string text);
    private PdfBrush ObtainBackBrush(PdfDictionary dictionary);
    private PdfColor CreateColor(PdfArray array);
    private PdfLoadedFieldTypes GetFieldType(int fieldFlags, string fieldType);
    private string GetFieldName(PdfDictionary acroField);
    private void GroupField(PdfDictionary fieldDictionary, PdfDictionary fieldGroup, PdfDictionary acroForm, PdfArray acroFormFields, PdfDictionary annot, PdfString fieldNameValue);
    private PdfArray GetFieldArray(PdfDictionary acroField);
    private void ImportLayers(PdfDictionary ocPropertiesDictionary, PdfArray ocgArray, PdfDictionary optimalContentViewDictionary);
    private PdfDictionary ParsePdfLayers(PdfDictionary lDocLayers);
    public void Append(PdfLoadedDocument ldDoc);
    private void MergeLayer(PdfLoadedDocument ldDoc);
    internal void AddLicenseWatermark(PdfPageBase page, bool isFirstIndex, bool isLastIndex);
    private PdfStringLayoutResult GetLineResult(string text, PdfFont font, PdfStringFormat format, SizeF size);
    internal void DrawWatermarkOnPage(PdfPageBase page, PdfFont font, PdfGraphics graphics, bool lastPage, PdfPageRotateAngle rotationAngle);
    private PdfMargins GetMargin(PdfPageBase page);
    private RectangleF GetBoundsWidthoutMargin(RectangleF bounds, PdfMargins margin, PdfPage newPage);
    private void DrawStringWithRotation(PdfGraphics graphics, string text, RectangleF bounds, PdfPageRotateAngle angle, PdfFont font, PdfBrush brush, PdfStringFormat format);
    internal void OnPageSave(PdfPageBase page);
    internal void OnSaveProgress(ProgressEventArgs arguments);
    internal void SetWaterMarkResources(PdfResources templateResources, PdfResources pageResources);
    internal abstract virtual PdfForm ObtainForm();
    internal void SetMainObjectCollection(PdfMainObjectCollection moc);
    internal void SetSecurity(PdfSecurity security);
    internal void SetCrossTable(PdfCrossTable cTable);
    internal void SetCatalog(PdfCatalog catalog);
    internal void OnDocumentSaved(DocumentSavedEventArgs args);
    internal abstract virtual void AddFields(PdfLoadedDocument ldDoc, PdfPageBase newPage, List`1<PdfField> fields);
    internal abstract virtual PdfPageBase ClonePage(PdfLoadedDocument ldDoc, PdfPageBase page, List`1<PdfArray> destinations);
    protected virtual void CheckFields(PdfLoadedDocument ldDoc, PdfPageBase page, List`1<PdfField> fields, PdfPageBase importedPage);
    private void MergeAttachments(PdfLoadedDocument ldDoc);
    private PdfNamedDestination GetNamedDestination(PdfNamedDestination nDest, PdfPageBase page);
    private PdfDestination GetDestination(PdfPageBase page, PdfDestination dest);
    private void ExportBookmarks(PdfLoadedDocument ldDoc, List`1<PdfBookmarkBase> bookmarks, int pageCount, Dictionary`2<PdfPageBase, object> bookmarkshash);
    private void ExportNamedDestination(PdfLoadedDocument doc);
    private void MarkBookmarks(List`1<object> pageBookmarks, List`1<PdfBookmarkBase> bookmarks);
    private void MarkBookmarks(PdfBookmarkBase bookmarkBase, List`1<PdfBookmarkBase> bookmarks);
    private void FixDestinations(Dictionary`2<IPdfPrimitive, object> pageCorrespondance, List`1<PdfArray> destinations);
    private void ResetProgress();
    private void SetProgress();
    internal string CreateHashFromStream(Byte[] streamBytes);
    private string ObtainBaseURI();
    private void SetBaseURI(string baseURIString);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class Syncfusion.Pdf.PdfDocumentException : PdfException {
    private static string ErrorMessage;
    public PdfDocumentException(Exception innerException);
    public PdfDocumentException(string message);
    public PdfDocumentException(string message, Exception innerException);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class Syncfusion.Pdf.PdfDocumentInformation : object {
    private XmpMetadata m_xmp;
    private PdfCatalog m_catalog;
    private string m_author;
    private string m_title;
    private string m_subject;
    private string m_keywords;
    private string m_creator;
    private string m_producer;
    internal DateTime m_creationDate;
    internal DateTime m_modificationDate;
    internal PdfDictionary m_dictionary;
    internal bool ConformanceEnabled;
    private string m_arrayString;
    private string m_customValue;
    internal bool isRemoveModifyDate;
    internal bool isRemoveCreationDate;
    private CustomMetadata m_customMetadata;
    private ZugferdConformanceLevel m_zugferdConformanceLevel;
    private ZugferdVersion m_zugferdVersion;
    private string m_language;
    internal bool isConformanceCheck;
    private string m_label;
    internal bool m_autoTag;
    public DateTime CreationDate { get; public set; }
    public DateTime ModificationDate { get; public set; }
    public string Title { get; public set; }
    public string Author { get; public set; }
    public string Subject { get; public set; }
    public string Keywords { get; public set; }
    public string Creator { get; public set; }
    public string Producer { get; public set; }
    public XmpMetadata XmpMetadata { get; }
    public CustomMetadata CustomMetadata { get; public set; }
    internal PdfDictionary Dictionary { get; }
    internal ZugferdConformanceLevel ZugferdConformanceLevel { get; internal set; }
    internal ZugferdVersion ZugferdVersion { get; internal set; }
    public string Language { get; public set; }
    internal string Label { get; internal set; }
    internal PdfCatalog Catalog { get; }
    private IPdfPrimitive Syncfusion.Pdf.IPdfWrapper.Element { get; }
    internal PdfDocumentInformation(PdfCatalog catalog);
    internal PdfDocumentInformation(PdfDictionary dictionary, PdfCatalog catalog);
    public DateTime get_CreationDate();
    public void set_CreationDate(DateTime value);
    public DateTime get_ModificationDate();
    public void set_ModificationDate(DateTime value);
    public string get_Title();
    public void set_Title(string value);
    public string get_Author();
    public void set_Author(string value);
    public string get_Subject();
    public void set_Subject(string value);
    public string get_Keywords();
    public void set_Keywords(string value);
    public string get_Creator();
    public void set_Creator(string value);
    public string get_Producer();
    public void set_Producer(string value);
    public XmpMetadata get_XmpMetadata();
    public CustomMetadata get_CustomMetadata();
    public void set_CustomMetadata(CustomMetadata value);
    private void SetCustomDictionary(CustomMetadata value);
    internal void AddCustomMetaDataInfo(string metaDataName, string metaDataValue);
    internal PdfDictionary get_Dictionary();
    internal ZugferdConformanceLevel get_ZugferdConformanceLevel();
    internal void set_ZugferdConformanceLevel(ZugferdConformanceLevel value);
    internal ZugferdVersion get_ZugferdVersion();
    internal void set_ZugferdVersion(ZugferdVersion value);
    public string get_Language();
    public void set_Language(string value);
    internal string get_Label();
    internal void set_Label(string value);
    internal PdfCatalog get_Catalog();
    internal void ApplyPdfXConformance();
    public bool Remove(string key);
    public void RemoveModificationDate();
    private void UpdateMetadata();
    internal void ResetXmp();
    private sealed virtual override IPdfPrimitive Syncfusion.Pdf.IPdfWrapper.get_Element();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[DefaultMemberAttribute("Item")]
public class Syncfusion.Pdf.PdfDocumentLayerCollection : PdfCollection {
    internal bool m_sublayer;
    internal PdfDictionary m_OptionalContent;
    private bool m_isLayerContainsResource;
    private static object s_syncLockLayer;
    private PdfDocumentBase document;
    private PdfLayer m_parent;
    private Dictionary`2<PdfReferenceHolder, PdfLayer> layerDictionary;
    private int m_bdcCount;
    public PdfLayer Item { get; public set; }
    private bool IsSkip { get; }
    internal PdfDocumentLayerCollection(PdfDocumentBase document, PdfLayer layer);
    internal PdfDocumentLayerCollection(PdfDocumentBase document);
    private static PdfDocumentLayerCollection();
    public PdfLayer get_Item(int index);
    public void set_Item(int index, PdfLayer value);
    private bool get_IsSkip();
    public PdfLayer Add(string name, bool visible);
    public PdfLayer Add(string name);
    private int Add(PdfLayer layer);
    private int AddNestedLayer(PdfLayer layer);
    internal void CreateLayer(PdfLayer layer);
    private PdfDictionary setPrintOption(PdfLayer layer);
    internal void CreateLayerLoadedDocument(PdfLayer layer);
    public void Move(int index, PdfLayer layer);
    private IPdfPrimitive CreateOptionalContentDictionary(PdfLayer layer);
    private IPdfPrimitive CreateOptionalContentDictionary(PdfLayer layer, bool isLoadedDocument);
    private void CreateSublayer(PdfDictionary ocProperties, PdfReferenceHolder reference, PdfLayer layer);
    private IPdfPrimitive CreateOptionalContentViews(PdfLayer layer);
    private IPdfPrimitive CreateOptionalContentViews(PdfLayer layer, bool isLoadedDocument);
    public void Remove(PdfLayer layer);
    public void Remove(PdfLayer layer, bool removeGraphicalContent);
    public void Remove(string name);
    public void Remove(string name, bool removeGraphicalContent);
    public void RemoveAt(int index);
    public void RemoveAt(int index, bool removeGraphicalContent);
    public bool Contains(PdfLayer layer);
    public bool Contains(string name);
    public int IndexOf(PdfLayer layer);
    public void Clear();
    private void RemoveLayer(PdfLayer layer, bool isRemoveContent);
    private void InsertLayer(int index, PdfLayer layer);
    private void CheckLayerVisible(PdfDictionary ocProperties);
    private void CheckLayerLock(PdfDictionary ocProperties);
    private void RemoveOCG(PdfLayer layer, PdfArray ocGroup);
    private void RemoveUsage(PdfLayer layer, PdfArray m_usage);
    private void RemoveOrder(PdfLayer layer, PdfArray order, List`1<PdfArray> arrayList);
    private void RemoveVisible(PdfLayer layer, PdfArray on, PdfArray off);
    private void RemoveLocked(PdfLayer layer, PdfArray locked);
    private void RemoveLayerContent(PdfLayer layer);
    private void CheckParentLayer(PdfDictionary ocProperties);
    private void ParsingLayerOrder(PdfLayer parent, PdfArray array, Dictionary`2<PdfReferenceHolder, PdfLayer> layerDictionary);
    private string FindOperator(int token);
    private void StreamWrite(String[] operands, string mOperator, bool skip, PdfStream data);
    private void ProcessBeginMarkContent(PdfLayer parser, string m_operator, String[] operands, PdfStream data);
    private void CreateLayerHierarchical(PdfDictionary ocProperties);
    private void AddChildlayer(PdfLayer pdflayer);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[DefaultMemberAttribute("Item")]
public class Syncfusion.Pdf.PdfDocumentPageCollection : object {
    private PdfDocument m_document;
    private Dictionary`2<PdfPage, int> m_pageCollectionIndex;
    internal int count;
    [CompilerGeneratedAttribute]
private PageAddedEventHandler PageAdded;
    public int Count { get; }
    public PdfPage Item { get; }
    internal Dictionary`2<PdfPage, int> PageCollectionIndex { get; }
    internal PdfDocumentPageCollection(PdfDocument document);
    public int get_Count();
    public PdfPage get_Item(int index);
    internal Dictionary`2<PdfPage, int> get_PageCollectionIndex();
    [CompilerGeneratedAttribute]
public void add_PageAdded(PageAddedEventHandler value);
    [CompilerGeneratedAttribute]
public void remove_PageAdded(PageAddedEventHandler value);
    public PdfPage Add();
    internal void Add(PdfPage page);
    public void Insert(int index, PdfPage page);
    public void Insert(int index, PdfPageBase loadedPage);
    public int IndexOf(PdfPage page);
    internal PdfSection Remove(PdfPage page);
    private void RemoveAndClearAllPages();
    internal void Clear();
    private int CountPages();
    private PdfPage GetPageByIndex(int index);
    private void Add(PdfLoadedPage page);
    private PdfSection GetLastSection();
    internal void OnPageAdded(PageAddedEventArgs args);
    internal PdfPageBase Add(PdfLoadedDocument ldDoc, PdfPageBase page, List`1<PdfArray> destinations);
    private bool CanPageFitLastSection(PdfPageBase page);
    public sealed virtual IEnumerator GetEnumerator();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class Syncfusion.Pdf.PdfDocumentTemplate : object {
    private PdfPageTemplateElement m_left;
    private PdfPageTemplateElement m_top;
    private PdfPageTemplateElement m_right;
    private PdfPageTemplateElement m_bottom;
    private PdfPageTemplateElement m_evenLeft;
    private PdfPageTemplateElement m_evenTop;
    private PdfPageTemplateElement m_evenRight;
    private PdfPageTemplateElement m_evenBottom;
    private PdfPageTemplateElement m_oddLeft;
    private PdfPageTemplateElement m_oddTop;
    private PdfPageTemplateElement m_oddRight;
    private PdfPageTemplateElement m_oddBottom;
    private PdfStampCollection m_stamps;
    internal PdfMargins blinkMargin;
    public PdfPageTemplateElement Left { get; public set; }
    public PdfPageTemplateElement Top { get; public set; }
    public PdfPageTemplateElement Right { get; public set; }
    public PdfPageTemplateElement Bottom { get; public set; }
    public PdfPageTemplateElement EvenLeft { get; public set; }
    public PdfPageTemplateElement EvenTop { get; public set; }
    public PdfPageTemplateElement EvenRight { get; public set; }
    public PdfPageTemplateElement EvenBottom { get; public set; }
    public PdfPageTemplateElement OddLeft { get; public set; }
    public PdfPageTemplateElement OddTop { get; public set; }
    public PdfPageTemplateElement OddRight { get; public set; }
    public PdfPageTemplateElement OddBottom { get; public set; }
    public PdfStampCollection Stamps { get; }
    public PdfPageTemplateElement get_Left();
    public void set_Left(PdfPageTemplateElement value);
    public PdfPageTemplateElement get_Top();
    public void set_Top(PdfPageTemplateElement value);
    public PdfPageTemplateElement get_Right();
    public void set_Right(PdfPageTemplateElement value);
    public PdfPageTemplateElement get_Bottom();
    public void set_Bottom(PdfPageTemplateElement value);
    public PdfPageTemplateElement get_EvenLeft();
    public void set_EvenLeft(PdfPageTemplateElement value);
    public PdfPageTemplateElement get_EvenTop();
    public void set_EvenTop(PdfPageTemplateElement value);
    public PdfPageTemplateElement get_EvenRight();
    public void set_EvenRight(PdfPageTemplateElement value);
    public PdfPageTemplateElement get_EvenBottom();
    public void set_EvenBottom(PdfPageTemplateElement value);
    public PdfPageTemplateElement get_OddLeft();
    public void set_OddLeft(PdfPageTemplateElement value);
    public PdfPageTemplateElement get_OddTop();
    public void set_OddTop(PdfPageTemplateElement value);
    public PdfPageTemplateElement get_OddRight();
    public void set_OddRight(PdfPageTemplateElement value);
    public PdfPageTemplateElement get_OddBottom();
    public void set_OddBottom(PdfPageTemplateElement value);
    public PdfStampCollection get_Stamps();
    internal PdfPageTemplateElement GetLeft(PdfPage page);
    internal PdfPageTemplateElement GetTop(PdfPage page);
    internal PdfPageTemplateElement GetRight(PdfPage page);
    internal PdfPageTemplateElement GetBottom(PdfPage page);
    private bool IsEven(PdfPage page);
    private PdfPageTemplateElement CheckElement(PdfPageTemplateElement templateElement, TemplateType type);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public abstract class Syncfusion.Pdf.PdfDynamicField : PdfAutomaticField {
    public PdfDynamicField(PdfFont font);
    public PdfDynamicField(PdfFont font, PdfBrush brush);
    public PdfDynamicField(PdfFont font, RectangleF bounds);
    internal static PdfPage GetPageFromGraphics(PdfGraphics graphics);
    internal static PdfLoadedPage GetLoadedPageFromGraphics(PdfGraphics graphics);
}
public enum Syncfusion.Pdf.PdfEdge : Enum {
    public int value__;
    public static PdfEdge Top;
    public static PdfEdge Bottom;
    public static PdfEdge Left;
    public static PdfEdge Right;
}
public class Syncfusion.Pdf.PdfEdges : object {
    private int m_left;
    private int m_right;
    private int m_top;
    private int m_bottom;
    public int Left { get; public set; }
    public int Right { get; public set; }
    public int Top { get; public set; }
    public int Bottom { get; public set; }
    unknown int All {public set; }
    internal bool IsAll { get; }
    public PdfEdges(int left, int right, int top, int bottom);
    public int get_Left();
    public void set_Left(int value);
    public int get_Right();
    public void set_Right(int value);
    public int get_Top();
    public void set_Top(int value);
    public int get_Bottom();
    public void set_Bottom(int value);
    public void set_All(int value);
    internal bool get_IsAll();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class Syncfusion.Pdf.PdfException : Exception {
    public PdfException(string message);
    public PdfException(string message, Exception innerException);
}
internal enum Syncfusion.Pdf.PdfFileFormat : Enum {
    public int value__;
    public static PdfFileFormat Plain;
    public static PdfFileFormat Linearized;
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class Syncfusion.Pdf.PdfFileStructure : object {
    private PdfVersion m_version;
    private PdfCrossReferenceType m_crossReferenceType;
    private PdfFileFormat m_fileformat;
    private bool m_incrementalUpdate;
    private bool m_taggedPdf;
    [CompilerGeneratedAttribute]
private EventHandler TaggedPdfChanged;
    internal bool m_fileID;
    public PdfVersion Version { get; public set; }
    public bool IncrementalUpdate { get; public set; }
    public bool EnableTrailerId { get; public set; }
    public PdfCrossReferenceType CrossReferenceType { get; public set; }
    internal PdfFileFormat FileFormat { get; internal set; }
    public bool TaggedPdf { get; internal set; }
    [CompilerGeneratedAttribute]
internal void add_TaggedPdfChanged(EventHandler value);
    [CompilerGeneratedAttribute]
internal void remove_TaggedPdfChanged(EventHandler value);
    public PdfVersion get_Version();
    public void set_Version(PdfVersion value);
    public bool get_IncrementalUpdate();
    public void set_IncrementalUpdate(bool value);
    public bool get_EnableTrailerId();
    public void set_EnableTrailerId(bool value);
    public PdfCrossReferenceType get_CrossReferenceType();
    public void set_CrossReferenceType(PdfCrossReferenceType value);
    internal PdfFileFormat get_FileFormat();
    internal void set_FileFormat(PdfFileFormat value);
    public bool get_TaggedPdf();
    internal void set_TaggedPdf(bool value);
    protected void OnTaggedPdfChanged(EventArgs e);
}
public enum Syncfusion.Pdf.PdfFormFieldsTabOrder : Enum {
    public int value__;
    public static PdfFormFieldsTabOrder None;
    public static PdfFormFieldsTabOrder Row;
    public static PdfFormFieldsTabOrder Column;
    public static PdfFormFieldsTabOrder Structure;
    public static PdfFormFieldsTabOrder Manual;
    public static PdfFormFieldsTabOrder Widget;
}
public enum Syncfusion.Pdf.PdfGridBuiltinStyle : Enum {
    public int value__;
    public static PdfGridBuiltinStyle PlainTable1;
    public static PdfGridBuiltinStyle PlainTable2;
    public static PdfGridBuiltinStyle PlainTable3;
    public static PdfGridBuiltinStyle PlainTable4;
    public static PdfGridBuiltinStyle PlainTable5;
    public static PdfGridBuiltinStyle GridTable1Light;
    public static PdfGridBuiltinStyle GridTable1LightAccent1;
    public static PdfGridBuiltinStyle GridTable1LightAccent2;
    public static PdfGridBuiltinStyle GridTable1LightAccent3;
    public static PdfGridBuiltinStyle GridTable1LightAccent4;
    public static PdfGridBuiltinStyle GridTable1LightAccent5;
    public static PdfGridBuiltinStyle GridTable1LightAccent6;
    public static PdfGridBuiltinStyle GridTable2;
    public static PdfGridBuiltinStyle GridTable2Accent1;
    public static PdfGridBuiltinStyle GridTable2Accent2;
    public static PdfGridBuiltinStyle GridTable2Accent3;
    public static PdfGridBuiltinStyle GridTable2Accent4;
    public static PdfGridBuiltinStyle GridTable2Accent5;
    public static PdfGridBuiltinStyle GridTable2Accent6;
    public static PdfGridBuiltinStyle GridTable3;
    public static PdfGridBuiltinStyle GridTable3Accent1;
    public static PdfGridBuiltinStyle GridTable3Accent2;
    public static PdfGridBuiltinStyle GridTable3Accent3;
    public static PdfGridBuiltinStyle GridTable3Accent4;
    public static PdfGridBuiltinStyle GridTable3Accent5;
    public static PdfGridBuiltinStyle GridTable3Accent6;
    public static PdfGridBuiltinStyle GridTable4;
    public static PdfGridBuiltinStyle GridTable4Accent1;
    public static PdfGridBuiltinStyle GridTable4Accent2;
    public static PdfGridBuiltinStyle GridTable4Accent3;
    public static PdfGridBuiltinStyle GridTable4Accent4;
    public static PdfGridBuiltinStyle GridTable4Accent5;
    public static PdfGridBuiltinStyle GridTable4Accent6;
    public static PdfGridBuiltinStyle GridTable5Dark;
    public static PdfGridBuiltinStyle GridTable5DarkAccent1;
    public static PdfGridBuiltinStyle GridTable5DarkAccent2;
    public static PdfGridBuiltinStyle GridTable5DarkAccent3;
    public static PdfGridBuiltinStyle GridTable5DarkAccent4;
    public static PdfGridBuiltinStyle GridTable5DarkAccent5;
    public static PdfGridBuiltinStyle GridTable5DarkAccent6;
    public static PdfGridBuiltinStyle GridTable6Colorful;
    public static PdfGridBuiltinStyle GridTable6ColorfulAccent1;
    public static PdfGridBuiltinStyle GridTable6ColorfulAccent2;
    public static PdfGridBuiltinStyle GridTable6ColorfulAccent3;
    public static PdfGridBuiltinStyle GridTable6ColorfulAccent4;
    public static PdfGridBuiltinStyle GridTable6ColorfulAccent5;
    public static PdfGridBuiltinStyle GridTable6ColorfulAccent6;
    public static PdfGridBuiltinStyle GridTable7Colorful;
    public static PdfGridBuiltinStyle GridTable7ColorfulAccent1;
    public static PdfGridBuiltinStyle GridTable7ColorfulAccent2;
    public static PdfGridBuiltinStyle GridTable7ColorfulAccent3;
    public static PdfGridBuiltinStyle GridTable7ColorfulAccent4;
    public static PdfGridBuiltinStyle GridTable7ColorfulAccent5;
    public static PdfGridBuiltinStyle GridTable7ColorfulAccent6;
    public static PdfGridBuiltinStyle ListTable1Light;
    public static PdfGridBuiltinStyle ListTable1LightAccent1;
    public static PdfGridBuiltinStyle ListTable1LightAccent2;
    public static PdfGridBuiltinStyle ListTable1LightAccent3;
    public static PdfGridBuiltinStyle ListTable1LightAccent4;
    public static PdfGridBuiltinStyle ListTable1LightAccent5;
    public static PdfGridBuiltinStyle ListTable1LightAccent6;
    public static PdfGridBuiltinStyle ListTable2;
    public static PdfGridBuiltinStyle ListTable2Accent1;
    public static PdfGridBuiltinStyle ListTable2Accent2;
    public static PdfGridBuiltinStyle ListTable2Accent3;
    public static PdfGridBuiltinStyle ListTable2Accent4;
    public static PdfGridBuiltinStyle ListTable2Accent5;
    public static PdfGridBuiltinStyle ListTable2Accent6;
    public static PdfGridBuiltinStyle ListTable3;
    public static PdfGridBuiltinStyle ListTable3Accent1;
    public static PdfGridBuiltinStyle ListTable3Accent2;
    public static PdfGridBuiltinStyle ListTable3Accent3;
    public static PdfGridBuiltinStyle ListTable3Accent4;
    public static PdfGridBuiltinStyle ListTable3Accent5;
    public static PdfGridBuiltinStyle ListTable3Accent6;
    public static PdfGridBuiltinStyle ListTable4;
    public static PdfGridBuiltinStyle ListTable4Accent1;
    public static PdfGridBuiltinStyle ListTable4Accent2;
    public static PdfGridBuiltinStyle ListTable4Accent3;
    public static PdfGridBuiltinStyle ListTable4Accent4;
    public static PdfGridBuiltinStyle ListTable4Accent5;
    public static PdfGridBuiltinStyle ListTable4Accent6;
    public static PdfGridBuiltinStyle ListTable5Dark;
    public static PdfGridBuiltinStyle ListTable5DarkAccent1;
    public static PdfGridBuiltinStyle ListTable5DarkAccent2;
    public static PdfGridBuiltinStyle ListTable5DarkAccent3;
    public static PdfGridBuiltinStyle ListTable5DarkAccent4;
    public static PdfGridBuiltinStyle ListTable5DarkAccent5;
    public static PdfGridBuiltinStyle ListTable5DarkAccent6;
    public static PdfGridBuiltinStyle ListTable6Colorful;
    public static PdfGridBuiltinStyle ListTable6ColorfulAccent1;
    public static PdfGridBuiltinStyle ListTable6ColorfulAccent2;
    public static PdfGridBuiltinStyle ListTable6ColorfulAccent3;
    public static PdfGridBuiltinStyle ListTable6ColorfulAccent4;
    public static PdfGridBuiltinStyle ListTable6ColorfulAccent5;
    public static PdfGridBuiltinStyle ListTable6ColorfulAccent6;
    public static PdfGridBuiltinStyle ListTable7Colorful;
    public static PdfGridBuiltinStyle ListTable7ColorfulAccent1;
    public static PdfGridBuiltinStyle ListTable7ColorfulAccent2;
    public static PdfGridBuiltinStyle ListTable7ColorfulAccent3;
    public static PdfGridBuiltinStyle ListTable7ColorfulAccent4;
    public static PdfGridBuiltinStyle ListTable7ColorfulAccent5;
    public static PdfGridBuiltinStyle ListTable7ColorfulAccent6;
    public static PdfGridBuiltinStyle TableGridLight;
    public static PdfGridBuiltinStyle TableGrid;
}
public enum Syncfusion.Pdf.PdfImagePosition : Enum {
    public int value__;
    public static PdfImagePosition BottomLeftCornerOfPage;
    public static PdfImagePosition BottomRightCornerOfPage;
    public static PdfImagePosition CenteredOnPage;
    public static PdfImagePosition CropPage;
    public static PdfImagePosition FitToPage;
    public static PdfImagePosition FitToPageAndMaintainAspectRatio;
    public static PdfImagePosition TopLeftCornerOfPage;
    public static PdfImagePosition TopRightCornerOfPage;
}
internal class Syncfusion.Pdf.PdfImportOptions : object {
    private int _targetPageIndex;
    private bool _groupFormFields;
    private bool _bookmark;
    internal int TargetPageIndex { get; internal set; }
    internal bool GroupFormFields { get; internal set; }
    internal bool Bookmark { get; internal set; }
    internal int get_TargetPageIndex();
    internal void set_TargetPageIndex(int value);
    internal bool get_GroupFormFields();
    internal void set_GroupFormFields(bool value);
    internal bool get_Bookmark();
    internal void set_Bookmark(bool value);
}
public class Syncfusion.Pdf.PdfInvalidPasswordException : PdfException {
    [NullableContextAttribute("1")]
internal PdfInvalidPasswordException(string message);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class Syncfusion.Pdf.PdfLayer : object {
    private PdfPageBase m_page;
    private PdfGraphics m_graphics;
    internal PdfStream m_content;
    private PdfGraphicsState m_graphicsState;
    private bool m_clipPageTemplates;
    private bool m_bSaved;
    private PdfColorSpace m_colorspace;
    private string m_layerid;
    private string m_name;
    internal bool m_visible;
    internal PdfDictionary m_printOption;
    internal PdfDictionary m_usage;
    private PdfPrintState printState;
    internal bool m_isEndState;
    private PdfDictionary m_dictionary;
    private PdfReferenceHolder m_refholder;
    private PdfLayer layer;
    private PdfDocumentBase document;
    internal List`1<PdfPageBase> pages;
    private PdfDocumentLayerCollection m_layer;
    private bool m_sublayer;
    internal int m_sublayerposition;
    internal PdfArray sublayer;
    internal bool m_locked;
    internal PdfArray m_lock;
    internal List`1<PdfLayer> m_parentLayer;
    internal List`1<PdfLayer> m_child;
    internal PdfLayer parent;
    private Dictionary`2<PdfGraphics, PdfGraphics> graphics;
    private Dictionary`2<PdfPageBase, PdfGraphics> pageGraphics;
    private bool m_pagePasrsed;
    private bool m_contentParsed;
    internal List`1<string> xobject;
    internal PdfReferenceHolder ReferenceHolder { get; internal set; }
    internal PdfDictionary Dictionary { get; internal set; }
    internal PdfColorSpace Colorspace { get; internal set; }
    internal PdfPageBase Page { get; internal set; }
    internal PdfDocumentBase Document { get; internal set; }
    internal string LayerId { get; internal set; }
    internal PdfLayer Layer { get; internal set; }
    public string Name { get; public set; }
    public bool Visible { get; public set; }
    private PdfGraphics Graphics { get; }
    public PdfPrintState PrintState { get; public set; }
    public PdfDocumentLayerCollection Layers { get; }
    public bool Locked { get; public set; }
    internal PdfStream ContentStream { get; }
    private IPdfPrimitive Syncfusion.Pdf.IPdfWrapper.Element { get; }
    internal PdfReferenceHolder get_ReferenceHolder();
    internal void set_ReferenceHolder(PdfReferenceHolder value);
    internal PdfDictionary get_Dictionary();
    internal void set_Dictionary(PdfDictionary value);
    internal PdfColorSpace get_Colorspace();
    internal void set_Colorspace(PdfColorSpace value);
    internal PdfPageBase get_Page();
    internal void set_Page(PdfPageBase value);
    internal PdfDocumentBase get_Document();
    internal void set_Document(PdfDocumentBase value);
    internal string get_LayerId();
    internal void set_LayerId(string value);
    internal PdfLayer get_Layer();
    internal void set_Layer(PdfLayer value);
    public string get_Name();
    public void set_Name(string value);
    public bool get_Visible();
    public void set_Visible(bool value);
    private PdfGraphics get_Graphics();
    public PdfPrintState get_PrintState();
    public void set_PrintState(PdfPrintState value);
    public PdfDocumentLayerCollection get_Layers();
    public bool get_Locked();
    public void set_Locked(bool value);
    internal PdfStream get_ContentStream();
    public PdfGraphics CreateGraphics(PdfPageBase page);
    internal void Clear();
    private void SetVisibility(bool value);
    private void SetLock(bool isSetLock);
    private void SetPrintState();
    private sealed virtual override IPdfPrimitive Syncfusion.Pdf.IPdfWrapper.get_Element();
    private void BeginSaveContent(object sender, SavePdfPrimitiveEventArgs e);
    internal void BeginLayer(PdfGraphics currentGraphics);
    private void GraphicsContent(PdfPageBase page);
    private void ParseContent();
    private void ParsingLayerPage();
    private bool ParsingDictionary(PdfDictionary dictionary, PdfReferenceHolder reference, PdfPageBase pagebase, PdfName layerID);
    private bool SetLayerPage(PdfReferenceHolder reference, PdfPageBase pagebase, PdfName layerID);
}
public enum Syncfusion.Pdf.PdfLightTableBuiltinStyle : Enum {
    public int value__;
    public static PdfLightTableBuiltinStyle PlainTable1;
    public static PdfLightTableBuiltinStyle PlainTable2;
    public static PdfLightTableBuiltinStyle PlainTable3;
    public static PdfLightTableBuiltinStyle PlainTable4;
    public static PdfLightTableBuiltinStyle PlainTable5;
    public static PdfLightTableBuiltinStyle GridTable1Light;
    public static PdfLightTableBuiltinStyle GridTable1LightAccent1;
    public static PdfLightTableBuiltinStyle GridTable1LightAccent2;
    public static PdfLightTableBuiltinStyle GridTable1LightAccent3;
    public static PdfLightTableBuiltinStyle GridTable1LightAccent4;
    public static PdfLightTableBuiltinStyle GridTable1LightAccent5;
    public static PdfLightTableBuiltinStyle GridTable1LightAccent6;
    public static PdfLightTableBuiltinStyle GridTable2;
    public static PdfLightTableBuiltinStyle GridTable2Accent1;
    public static PdfLightTableBuiltinStyle GridTable2Accent2;
    public static PdfLightTableBuiltinStyle GridTable2Accent3;
    public static PdfLightTableBuiltinStyle GridTable2Accent4;
    public static PdfLightTableBuiltinStyle GridTable2Accent5;
    public static PdfLightTableBuiltinStyle GridTable2Accent6;
    public static PdfLightTableBuiltinStyle GridTable3;
    public static PdfLightTableBuiltinStyle GridTable3Accent1;
    public static PdfLightTableBuiltinStyle GridTable3Accent2;
    public static PdfLightTableBuiltinStyle GridTable3Accent3;
    public static PdfLightTableBuiltinStyle GridTable3Accent4;
    public static PdfLightTableBuiltinStyle GridTable3Accent5;
    public static PdfLightTableBuiltinStyle GridTable3Accent6;
    public static PdfLightTableBuiltinStyle GridTable4;
    public static PdfLightTableBuiltinStyle GridTable4Accent1;
    public static PdfLightTableBuiltinStyle GridTable4Accent2;
    public static PdfLightTableBuiltinStyle GridTable4Accent3;
    public static PdfLightTableBuiltinStyle GridTable4Accent4;
    public static PdfLightTableBuiltinStyle GridTable4Accent5;
    public static PdfLightTableBuiltinStyle GridTable4Accent6;
    public static PdfLightTableBuiltinStyle GridTable5Dark;
    public static PdfLightTableBuiltinStyle GridTable5DarkAccent1;
    public static PdfLightTableBuiltinStyle GridTable5DarkAccent2;
    public static PdfLightTableBuiltinStyle GridTable5DarkAccent3;
    public static PdfLightTableBuiltinStyle GridTable5DarkAccent4;
    public static PdfLightTableBuiltinStyle GridTable5DarkAccent5;
    public static PdfLightTableBuiltinStyle GridTable5DarkAccent6;
    public static PdfLightTableBuiltinStyle GridTable6Colorful;
    public static PdfLightTableBuiltinStyle GridTable6ColorfulAccent1;
    public static PdfLightTableBuiltinStyle GridTable6ColorfulAccent2;
    public static PdfLightTableBuiltinStyle GridTable6ColorfulAccent3;
    public static PdfLightTableBuiltinStyle GridTable6ColorfulAccent4;
    public static PdfLightTableBuiltinStyle GridTable6ColorfulAccent5;
    public static PdfLightTableBuiltinStyle GridTable6ColorfulAccent6;
    public static PdfLightTableBuiltinStyle GridTable7Colorful;
    public static PdfLightTableBuiltinStyle GridTable7ColorfulAccent1;
    public static PdfLightTableBuiltinStyle GridTable7ColorfulAccent2;
    public static PdfLightTableBuiltinStyle GridTable7ColorfulAccent3;
    public static PdfLightTableBuiltinStyle GridTable7ColorfulAccent4;
    public static PdfLightTableBuiltinStyle GridTable7ColorfulAccent5;
    public static PdfLightTableBuiltinStyle GridTable7ColorfulAccent6;
    public static PdfLightTableBuiltinStyle ListTable1Light;
    public static PdfLightTableBuiltinStyle ListTable1LightAccent1;
    public static PdfLightTableBuiltinStyle ListTable1LightAccent2;
    public static PdfLightTableBuiltinStyle ListTable1LightAccent3;
    public static PdfLightTableBuiltinStyle ListTable1LightAccent4;
    public static PdfLightTableBuiltinStyle ListTable1LightAccent5;
    public static PdfLightTableBuiltinStyle ListTable1LightAccent6;
    public static PdfLightTableBuiltinStyle ListTable2;
    public static PdfLightTableBuiltinStyle ListTable2Accent1;
    public static PdfLightTableBuiltinStyle ListTable2Accent2;
    public static PdfLightTableBuiltinStyle ListTable2Accent3;
    public static PdfLightTableBuiltinStyle ListTable2Accent4;
    public static PdfLightTableBuiltinStyle ListTable2Accent5;
    public static PdfLightTableBuiltinStyle ListTable2Accent6;
    public static PdfLightTableBuiltinStyle ListTable3;
    public static PdfLightTableBuiltinStyle ListTable3Accent1;
    public static PdfLightTableBuiltinStyle ListTable3Accent2;
    public static PdfLightTableBuiltinStyle ListTable3Accent3;
    public static PdfLightTableBuiltinStyle ListTable3Accent4;
    public static PdfLightTableBuiltinStyle ListTable3Accent5;
    public static PdfLightTableBuiltinStyle ListTable3Accent6;
    public static PdfLightTableBuiltinStyle ListTable4;
    public static PdfLightTableBuiltinStyle ListTable4Accent1;
    public static PdfLightTableBuiltinStyle ListTable4Accent2;
    public static PdfLightTableBuiltinStyle ListTable4Accent3;
    public static PdfLightTableBuiltinStyle ListTable4Accent4;
    public static PdfLightTableBuiltinStyle ListTable4Accent5;
    public static PdfLightTableBuiltinStyle ListTable4Accent6;
    public static PdfLightTableBuiltinStyle ListTable5Dark;
    public static PdfLightTableBuiltinStyle ListTable5DarkAccent1;
    public static PdfLightTableBuiltinStyle ListTable5DarkAccent2;
    public static PdfLightTableBuiltinStyle ListTable5DarkAccent3;
    public static PdfLightTableBuiltinStyle ListTable5DarkAccent4;
    public static PdfLightTableBuiltinStyle ListTable5DarkAccent5;
    public static PdfLightTableBuiltinStyle ListTable5DarkAccent6;
    public static PdfLightTableBuiltinStyle ListTable6Colorful;
    public static PdfLightTableBuiltinStyle ListTable6ColorfulAccent1;
    public static PdfLightTableBuiltinStyle ListTable6ColorfulAccent2;
    public static PdfLightTableBuiltinStyle ListTable6ColorfulAccent3;
    public static PdfLightTableBuiltinStyle ListTable6ColorfulAccent4;
    public static PdfLightTableBuiltinStyle ListTable6ColorfulAccent5;
    public static PdfLightTableBuiltinStyle ListTable6ColorfulAccent6;
    public static PdfLightTableBuiltinStyle ListTable7Colorful;
    public static PdfLightTableBuiltinStyle ListTable7ColorfulAccent1;
    public static PdfLightTableBuiltinStyle ListTable7ColorfulAccent2;
    public static PdfLightTableBuiltinStyle ListTable7ColorfulAccent3;
    public static PdfLightTableBuiltinStyle ListTable7ColorfulAccent4;
    public static PdfLightTableBuiltinStyle ListTable7ColorfulAccent5;
    public static PdfLightTableBuiltinStyle ListTable7ColorfulAccent6;
    public static PdfLightTableBuiltinStyle TableGridLight;
    public static PdfLightTableBuiltinStyle TableGrid;
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class Syncfusion.Pdf.PdfLoadedPage : PdfPageBase {
    private PdfCrossTable m_crossTable;
    private bool m_bCheckResources;
    private PdfDocumentBase m_document;
    internal List`1<PdfAnnotation> m_unsupportedAnnotation;
    private List`1<PdfDictionary> m_terminalannots;
    private PdfLoadedAnnotationCollection m_annots;
    private List`1<long> m_widgetReferences;
    private RectangleF m_mediaBox;
    private SizeF m_size;
    private RectangleF m_cropBox;
    private RectangleF m_bleedBox;
    private RectangleF m_trimBox;
    private RectangleF m_artBox;
    private PdfResources m_resources;
    private PointF m_origin;
    private PdfArray m_annotsReference;
    internal bool importAnnotation;
    private List`1<PdfStructureElement> m_pageElements;
    internal List`1<PdfLoadedPopupAnnotation> RemoveList;
    [CompilerGeneratedAttribute]
private EventHandler BeginSave;
    public PdfLoadedAnnotationCollection Annotations { get; public set; }
    public RectangleF MediaBox { get; }
    public SizeF Size { get; }
    public RectangleF CropBox { get; }
    public RectangleF BleedBox { get; }
    public RectangleF TrimBox { get; }
    public RectangleF ArtBox { get; }
    public PdfDocumentBase Document { get; }
    internal PdfCrossTable CrossTable { get; }
    internal List`1<PdfDictionary> TerminalAnnotation { get; internal set; }
    internal PointF Origin { get; }
    internal PdfArray AnnotsReference { get; internal set; }
    public PdfStructureElement[] StructureElements { get; }
    internal PdfLoadedPage(PdfDocumentBase document, PdfCrossTable cTable, PdfDictionary dictionary);
    public PdfLoadedAnnotationCollection get_Annotations();
    public void set_Annotations(PdfLoadedAnnotationCollection value);
    public RectangleF get_MediaBox();
    public virtual SizeF get_Size();
    public RectangleF get_CropBox();
    public RectangleF get_BleedBox();
    public RectangleF get_TrimBox();
    public RectangleF get_ArtBox();
    public PdfDocumentBase get_Document();
    internal PdfCrossTable get_CrossTable();
    internal virtual PdfResources GetResources();
    private int CalculateHash(Byte[] b);
    private void ParseXobjectImages(Byte[] pageContent, PdfDictionary xObject, PdfDictionary xobjects);
    internal List`1<PdfDictionary> get_TerminalAnnotation();
    internal void set_TerminalAnnotation(List`1<PdfDictionary> value);
    internal virtual PointF get_Origin();
    internal PdfArray get_AnnotsReference();
    internal void set_AnnotsReference(PdfArray value);
    public PdfStructureElement[] get_StructureElements();
    private void GetElements(PdfStructureElement element);
    [CompilerGeneratedAttribute]
public void add_BeginSave(EventHandler value);
    [CompilerGeneratedAttribute]
public void remove_BeginSave(EventHandler value);
    private bool CheckFormField(IPdfPrimitive iPdfPrimitive);
    internal void RemoveFromDictionaries(PdfAnnotation annot);
    private void RemoveLoadedReviewHistory(PdfLoadedPopupAnnotationCollection reviewHistory, PdfArray array);
    private PdfLoadedPopupAnnotationCollection GetAnnotationReviewHistory(PdfLoadedAnnotation annotation);
    private PdfLoadedPopupAnnotationCollection GetAnnotationComment(PdfLoadedAnnotation annotation);
    private void RemoveAllReference(IPdfPrimitive obj);
    private PdfDictionary GetObject(IPdfPrimitive primitive);
    internal List`1<long> GetWidgetReferences();
    private void ParseInnerKids(PdfArray kidsArray, PdfDictionary widget);
    internal void CreateAnnotations(List`1<long> widgetReferences);
    protected virtual void OnBeginSave(EventArgs e);
    private void PageBeginSave(object sender, SavePdfPrimitiveEventArgs args);
    private void PageEndSave(object sender, SavePdfPrimitiveEventArgs args);
    internal virtual void Clear();
    private float GetContentHeight(string key, bool signedPDF);
    private float GetContentHeight(string key, MemoryStream data);
    private PdfFontMetrics CreateFont(PdfDictionary fontDictionary, float height, PdfName baseFont);
    private PdfFontStyle GetFontStyle(string fontFamilyString);
    private PdfFontFamily GetFontFamily(string fontFamilyString);
    private string GetKey(PdfName fontName, string keyValue);
    private RectangleF CalculateBounds(float x, float y, float width, float height);
    internal RectangleF GetCropBox();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[DefaultMemberAttribute("Item")]
public class Syncfusion.Pdf.PdfLoadedPageLabelCollection : object {
    private int m_count;
    private List`1<PdfPageLabel> m_pageLabel;
    private List`1<PdfReferenceHolder> m_pageLabelCollection;
    public int Count { get; }
    public PdfPageLabel Item { get; }
    private IPdfPrimitive Syncfusion.Pdf.IPdfWrapper.Element { get; }
    public int get_Count();
    public PdfPageLabel get_Item(int index);
    public void Add(PdfPageLabel pageLabel);
    private sealed virtual override IPdfPrimitive Syncfusion.Pdf.IPdfWrapper.get_Element();
}
public class Syncfusion.Pdf.PdfMergeOptions : object {
    private bool m_optimizeResources;
    private bool m_extendMargin;
    private bool m_mergeAccessibilityTags;
    public bool OptimizeResources { get; public set; }
    public bool ExtendMargin { get; public set; }
    public bool MergeAccessibilityTags { get; public set; }
    public bool get_OptimizeResources();
    public void set_OptimizeResources(bool value);
    public bool get_ExtendMargin();
    public void set_ExtendMargin(bool value);
    public bool get_MergeAccessibilityTags();
    public void set_MergeAccessibilityTags(bool value);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public abstract class Syncfusion.Pdf.PdfMultipleNumberValueField : PdfMultipleValueField {
    private PdfNumberStyle m_numberStyle;
    public PdfNumberStyle NumberStyle { get; public set; }
    public PdfMultipleNumberValueField(PdfFont font);
    public PdfMultipleNumberValueField(PdfFont font, PdfBrush brush);
    public PdfMultipleNumberValueField(PdfFont font, RectangleF bounds);
    public PdfNumberStyle get_NumberStyle();
    public void set_NumberStyle(PdfNumberStyle value);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public abstract class Syncfusion.Pdf.PdfMultipleValueField : PdfDynamicField {
    private Dictionary`2<PdfGraphics, PdfTemplateValuePair> m_list;
    private PdfTag m_tag;
    public PdfTag PdfTag { get; public set; }
    public PdfMultipleValueField(PdfFont font);
    public PdfMultipleValueField(PdfFont font, PdfBrush brush);
    public PdfMultipleValueField(PdfFont font, RectangleF bounds);
    public PdfTag get_PdfTag();
    public void set_PdfTag(PdfTag value);
    protected internal virtual void PerformDraw(PdfGraphics graphics, PointF location, float scalingX, float scalingY);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Syncfusion.Pdf.PdfNumbersConvertor : object {
    private static float LetterLimit;
    private static int AcsiiStartIndex;
    public static string Convert(int intArabic, PdfNumberStyle numberStyle);
    private static string ArabicToRoman(int intArabic);
    private static string ArabicToLetter(int arabic);
    private static string GenerateNumber(Int32& value, int magnitude, string letter);
    private static Stack`1<int> ConvertToLetter(float arabic);
    private static void AppendChar(StringBuilder builder, int number);
}
public enum Syncfusion.Pdf.PdfNumberStyle : Enum {
    public int value__;
    public static PdfNumberStyle None;
    public static PdfNumberStyle Numeric;
    public static PdfNumberStyle LowerLatin;
    public static PdfNumberStyle LowerRoman;
    public static PdfNumberStyle UpperLatin;
    public static PdfNumberStyle UpperRoman;
}
public class Syncfusion.Pdf.PdfPaddings : object {
    private float m_left;
    private float m_right;
    private float m_top;
    private float m_bottom;
    public float Left { get; public set; }
    public float Right { get; public set; }
    public float Top { get; public set; }
    public float Bottom { get; public set; }
    unknown float All {public set; }
    public PdfPaddings(float left, float right, float top, float bottom);
    public float get_Left();
    public void set_Left(float value);
    public float get_Right();
    public void set_Right(float value);
    public float get_Top();
    public void set_Top(float value);
    public float get_Bottom();
    public void set_Bottom(float value);
    public void set_All(float value);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class Syncfusion.Pdf.PdfPage : PdfPageBase {
    internal PdfSection m_section;
    private PdfAnnotationCollection m_annotations;
    internal bool IsNewPage;
    internal bool isMergingPage;
    [CompilerGeneratedAttribute]
private EventHandler BeginSave;
    public PdfSection Section { get; internal set; }
    public SizeF Size { get; }
    internal PointF Origin { get; }
    public PdfAnnotationCollection Annotations { get; }
    internal PdfDocument Document { get; }
    internal PdfCrossTable CrossTable { get; }
    public PdfSection get_Section();
    internal void set_Section(PdfSection value);
    public virtual SizeF get_Size();
    internal virtual PointF get_Origin();
    public PdfAnnotationCollection get_Annotations();
    internal PdfDocument get_Document();
    internal PdfCrossTable get_CrossTable();
    [CompilerGeneratedAttribute]
public void add_BeginSave(EventHandler value);
    [CompilerGeneratedAttribute]
public void remove_BeginSave(EventHandler value);
    public SizeF GetClientSize();
    protected virtual void OnBeginSave(EventArgs e);
    internal virtual void Clear();
    internal void AssignSection(PdfSection section);
    private void Initialize();
    private void DrawPageTemplates(PdfDocument document);
    private void RemoveTemplateLayers(PdfDocument document);
    private void PageBeginSave(object sender, SavePdfPrimitiveEventArgs args);
    private void PageEndSave(object sender, SavePdfPrimitiveEventArgs args);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public abstract class Syncfusion.Pdf.PdfPageBase : object {
    private Color TextColor;
    internal bool isFlatten;
    private PdfDictionary m_pageDictionary;
    internal List`1<string> pageWords;
    private bool isExtractWithFormat;
    private List`1<IPdfPrimitive> pdfPrimitivesCollection;
    private PdfResources m_resources;
    private PdfPageLayerCollection m_layers;
    private PdfLoadedAnnotationCollection m_annotations;
    private int m_defLayerIndex;
    private bool m_initializeGraphics;
    internal bool m_parseLayerGraphics;
    internal bool m_isRedactionPage;
    private List`1<PdfName> m_fontNames;
    internal List`1<IPdfPrimitive> m_fontReference;
    private Dictionary`2<PdfName, IPdfPrimitive> m_fontcollect;
    private PdfTemplate m_contentTemplate;
    private int m_annotCount;
    private int m_layersCount;
    private long m_pageContentLength;
    private bool m_imported;
    private static object s_syncLockTemplate;
    private int m_fieldCount;
    internal List`1<PdfStream> m_xObjectContentStream;
    private PdfFormFieldsTabOrder m_formFieldsTabOrder;
    private PdfPageRotateAngle m_LoadedrotateAngle;
    internal bool m_isProgressOn;
    internal bool m_removedPage;
    internal bool isExtractImages;
    internal bool isFlateCompress;
    private bool m_isTagged;
    private Dictionary`2<long, PdfDictionary> annotMapReference;
    private List`1<IPdfPrimitive> m_mcrContentType;
    private List`1<IPdfPrimitive> m_mcrObjType;
    private bool m_modified;
    private Dictionary`2<int, string> m_imageLengthDict;
    private bool m_isContainsImage;
    private int m_nonBreakingSpaceCharValue;
    private long resourceNumber;
    internal List`1<RectangleF> m_RedactionBounds;
    internal bool is_Contains_Redaction;
    private float pt;
    internal PdfArray m_childSTR;
    private PdfDocumentBase m_documentBase;
    internal bool templateResource;
    internal List`1<PdfReference> m_xobjectReferenceCollection;
    internal int m_id;
    private Dictionary`2<int, string> m_abbreviationCollection;
    private Dictionary`2<int, List`1<TextElement>> m_mcidAndTextElements;
    private Dictionary`2<int, Dictionary`2<RectangleF, bool>> m_mcidAndFigureBounds;
    private Bidi m_bidiInstance;
    internal bool m_visualOrder;
    private bool m_hasRTL;
    internal List`1<PdfReference> repeatedReferenceCollection;
    internal int importPageEndIndex;
    internal int importPageStartIndex;
    internal bool m_isBooklet;
    internal bool isSkipColorSpace;
    internal List`1<string> m_h1Tags;
    internal List`1<string> m_hChildTags;
    private string resultantText;
    private float m_wordSpacing;
    private float TextHorizontalScaling;
    private float m_fontSize;
    private float m_previousFontSize;
    private Matrix m_previousTextMatrix;
    private Matrix m_textLineMatrix;
    private Matrix m_currentTextMatrix;
    internal Matrix Ctm;
    internal int m_rise;
    private int m_horizontalScaling;
    private int m_charID;
    private FontStructure m_structure;
    internal Dictionary`2<int, int> FontGlyphWidths;
    private double m_advancedWidth;
    private float m_charSizeMultiplier;
    private double m_characterWidth;
    private Matrix m_textMatrix;
    private PdfUnitConvertor m_unitConvertor;
    private TransformationStack m_transformations;
    private bool m_isTextMatrix;
    private PointF m_currentLocation;
    private bool m_isRotated;
    private RectangleF m_boundingRect;
    private RectangleF m_tempBoundingRectangle;
    private float m_textLeading;
    private string m_strBackup;
    private bool m_hasNoSpacing;
    private bool m_hasLeading;
    private bool m_hasTj;
    private bool m_hasTm;
    private bool m_hasET;
    private bool m_hasBDC;
    private bool hasSpace;
    private PageResourceLoader m_resourceLoader;
    private PdfRecordCollection m_recordCollection;
    private Stack`1<PdfPageResources> m_parentResources;
    private PdfPageResources m_pageResources;
    private Char[] m_symbolChars;
    private string m_currentFont;
    private float m_characterSpacing;
    private bool m_isLayoutTextExtraction;
    private bool spaceBetweenWord;
    private bool contentOptimize;
    private bool annotArrayModified;
    private bool annotOptimize;
    private Dictionary`2<PdfDictionary, PdfArray> colorSpaceList;
    public PdfGraphics Graphics { get; }
    internal bool Imported { get; internal set; }
    public PdfPageLayerCollection Layers { get; }
    public PdfLoadedAnnotationCollection Annotations { get; }
    public PdfFormFieldsTabOrder FormFieldsTabOrder { get; public set; }
    public int DefaultLayerIndex { get; public set; }
    public PdfPageLayer DefaultLayer { get; }
    public SizeF Size { get; }
    internal PointF Origin { get; }
    internal PdfArray Contents { get; }
    internal PdfDictionary Dictionary { get; }
    public PdfPageRotateAngle Rotation { get; public set; }
    internal PdfPageOrientation Orientation { get; }
    internal PdfTemplate ContentTemplate { get; }
    internal int FieldsCount { get; }
    internal PdfDocumentBase DestinationDocument { get; internal set; }
    internal bool IsTagged { get; internal set; }
    internal Dictionary`2<long, PdfDictionary> ImportedAnnotationReference { get; }
    internal List`1<IPdfPrimitive> McrContentCollection { get; internal set; }
    internal List`1<IPdfPrimitive> McrObjectCollection { get; internal set; }
    private PointF CurrentLocation { get; private set; }
    internal PdfUnitConvertor UnitConvertor { get; }
    public bool IsBlank { get; }
    private IPdfPrimitive Syncfusion.Pdf.IPdfWrapper.Element { get; }
    internal PdfPageBase(PdfDictionary dic);
    private static PdfPageBase();
    public PdfGraphics get_Graphics();
    internal bool get_Imported();
    internal void set_Imported(bool value);
    public PdfPageLayerCollection get_Layers();
    public PdfLoadedAnnotationCollection get_Annotations();
    public PdfFormFieldsTabOrder get_FormFieldsTabOrder();
    public void set_FormFieldsTabOrder(PdfFormFieldsTabOrder value);
    public int get_DefaultLayerIndex();
    public void set_DefaultLayerIndex(int value);
    public PdfPageLayer get_DefaultLayer();
    public abstract virtual SizeF get_Size();
    internal abstract virtual PointF get_Origin();
    internal PdfArray get_Contents();
    internal PdfDictionary get_Dictionary();
    public PdfPageRotateAngle get_Rotation();
    public void set_Rotation(PdfPageRotateAngle value);
    internal PdfPageOrientation get_Orientation();
    internal PdfTemplate get_ContentTemplate();
    internal int get_FieldsCount();
    internal PdfDocumentBase get_DestinationDocument();
    internal void set_DestinationDocument(PdfDocumentBase value);
    internal bool get_IsTagged();
    internal void set_IsTagged(bool value);
    internal Dictionary`2<long, PdfDictionary> get_ImportedAnnotationReference();
    internal List`1<IPdfPrimitive> get_McrContentCollection();
    internal void set_McrContentCollection(List`1<IPdfPrimitive> value);
    internal List`1<IPdfPrimitive> get_McrObjectCollection();
    internal void set_McrObjectCollection(List`1<IPdfPrimitive> value);
    public PdfTemplate CreateTemplate();
    private PointF get_CurrentLocation();
    private void set_CurrentLocation(PointF value);
    internal PdfUnitConvertor get_UnitConvertor();
    public bool get_IsBlank();
    private int GetContentLength();
    public string ExtractText(TextLineCollection& textLineCollection);
    private SplitWord[] SplitRenderedText(string text, List`1<Glyph> glyphs, int index, bool isRTL);
    private double GetRotationAngle(double m11, double m12, double m21, double m22);
    private bool IsNotInSameLine(double pageRotation, double currentYPosition, double currentBottomPosition, double currentXPosition, double previousYPosition, double previousBottomPosition, double previousXPosition, int extractTextElementIndex);
    private void AddLine(TextWord textwords, ImageRenderer renderer, TextElement textElements, TextLine textLine, int glyphIndex, double x, double y, double width, double height);
    private void AddLineCollection(TextLine textLine, TextLineCollection lineCollection, ImageRenderer renderer, int lineStartIndex, int glyphIndex);
    private string ExtractTextWithLayout();
    public string ExtractText();
    public string ExtractText(bool IsLayout);
    private void RenderText(PdfRecordCollection recordCollection, PdfPageResources m_pageResources);
    private void GetCharacterSpacing(String[] element);
    private void GetWordSpacing(String[] element);
    private string RenderTextElementTJ(String[] textElements, string token, PdfPageResources m_pageResources, Matrix m_textLineMatrix);
    private string RenderTextFromLeading(string decodedText, Matrix m_textLineMatrix);
    private string RenderTextFromTJ(List`1<string> decodedList, Matrix m_textLineMatrix);
    private Matrix GetTransformationMatrix(Matrix transform);
    private void UpdateTextMatrix();
    private Matrix CalculateTextMatrix(Matrix m);
    private double GetCharacterWidth(char character);
    private void UpdateTextMatrix(double tj);
    private Matrix GetTextRenderingMatrix();
    private void RenderTextAsLayout(PdfRecordCollection recordCollection, PdfPageResources m_pageResources);
    private void MoveToNextLine(float tx, float ty);
    private void SetTextLeading(float txtLeading);
    private void GetScalingFactor(String[] scaling);
    private void GetXObject(String[] xobjectElement, PdfPageResources m_pageResources);
    private PdfPageResources UpdateFontResources(PdfPageResources pageResources);
    private string RenderTextElement(String[] textElements, string tokenType, PdfPageResources m_pageResources);
    private void RenderFont(String[] fontElements);
    private string SkipEscapeSequence(string text);
    private PdfDictionary GetPDFFontDictionary(PdfDictionary resources);
    internal void GetFontStream();
    internal IPdfPrimitive GetXObject(PdfResources resources);
    private IPdfPrimitive GetPDFXObject(PdfDictionary resources);
    private string StripSlashes(string text);
    internal string ExtractTaggedText(List`1<int> mcids, Dictionary`2& properties);
    internal RectangleF ExtractTaggedContent(String& abbreviation, int mcid, Boolean& objectType);
    private Matrix Multiply(Matrix matrix1, Matrix matrix2);
    internal virtual PdfResources GetResources();
    internal void SetResources(PdfResources res);
    private sealed virtual override IPdfPrimitive Syncfusion.Pdf.IPdfWrapper.get_Element();
    internal void SetProgress();
    internal void ResetProgress();
    internal PdfTemplate GetContent();
    private void SetMatrix(PdfTemplate template);
    private void SetTemplateMatrix(PdfDictionary template);
    internal PdfArray ReInitializeContentReference();
    internal PdfDictionary CheckTypeOfXObject(PdfDictionary xObjectDictionary);
    internal void ReInitializeFormXObject(PdfStream formXObjectData);
    internal PdfDictionary CheckOptionalContent(PdfStream xObjectData);
    internal void ReInitializeImageData(PdfStream imageData);
    internal PdfDictionary ReinitializePageResources();
    internal void CheckPageShadingReference(PdfDictionary pageShadingItems);
    internal void ReInitializePageAnnotation(PdfDictionary acroFormData);
    internal void CheckAnnotAppearanceData(PdfDictionary annotAppearanceData);
    internal void InitializeAcroformReference(PdfDictionary acroFormData);
    internal void ReInitializeThumbnail();
    internal void ReinitializeColorSpace(PdfArray colorSpaceCollection);
    internal void ReinitializeColorSpaceItem(PdfDictionary colorSpaceItems);
    internal void ReInitializePagePatterns(PdfDictionary pagePattern);
    internal void CheckFontInternalReference(PdfDictionary fontDictionary);
    internal PdfDictionary ReInitializeFontDescriptor(PdfDictionary fontDictionary);
    internal PdfDictionary ReInitializeExtGState(PdfDictionary extStateData);
    internal void ReInitializeXobjectResources(PdfDictionary xObjectData);
    private PdfPageOrientation ObtainOrientation();
    internal virtual void Clear();
    internal void ImportAnnotations(PdfLoadedDocument ldDoc, PdfPageBase page, List`1<PdfArray> destinations);
    private bool FindAcroFromFieldsCount(PdfLoadedDocument loadedDocument);
    private void AddFieldParent(PdfDictionary annot, PdfLoadedDocument loadedDocument);
    internal void ImportAnnotations(PdfLoadedDocument ldDoc, PdfPageBase page);
    private PdfArray GetDestination(PdfLoadedDocument ldDoc, PdfDictionary annotation);
    internal PdfArray ObtainAnnotations();
    private int GetAnnotationCount();
    internal PdfFormFieldsTabOrder ObtainTabOrder();
    private PdfPageRotateAngle ObtainRotation();
    private void DrawAnnotationTemplates(PdfGraphics g);
    private PointF NormalizeAnnotationLocation(PointF location, PdfGraphics graphics, PdfTemplate template);
    private PointF GetAnnotationLocation(PdfDictionary annotation);
    private SizeF GetAnnotationSize(PdfDictionary annotation);
    private SizeF GetElementSize(PdfDictionary dictionary, string propertyName);
    private PdfTemplate GetAnnotTemplate(PdfDictionary annotation);
    internal PdfArray GetCropOrMediaBox(PdfPageBase page, PdfArray cropOrMediaBox);
    internal RectangleF GetCropOrMediaBoxBounds(RectangleF bounds, float x, float y);
    private RectangleF GetBounds(double pageRotation, bool isGlyphRotated, float xValue, float yValue, float Width, float Height);
    private void ExtGStateOptimization(PdfDictionary extGDictionary, PdfPageBase newPage);
    private void PropertiseOptimization(PdfDictionary propDictionary, PdfPageBase newPage);
    internal void RemoveIdeticalContentStreams(PdfArray pageContents, PdfPage newPage);
    internal void AddContentElement(PdfStream stream, PdfReferenceHolder contentReferenceHolder, PdfPage newPage);
    internal void RemoveIdenticalAnnotations(PdfArray annotArray, PdfPage newPage);
    private void RemoveidenticalAnnotationResource(PdfResources resources, PdfPage newPage, PdfReferenceHolder annotReference, PdfArray annots);
    private void AddAnnotationResourceCollection(PdfStream stream, PdfPageBase newPage, PdfDictionary xObject, PdfDictionary xObjectDictionary, PdfName xObjectkey, PdfReferenceHolder annotReference, PdfArray annots);
    private void RemoveFromDocument(PdfDictionary dictionary);
    private void AddToDocument(PdfDictionary dictionary);
    private bool IsRepeatedEntry(IPdfPrimitive primitive);
    private bool CheckRepeatedReference(PdfReferenceHolder referenceHolder);
    internal void RemoveIdenticalResources(PdfResources resources, PdfPageBase newPage);
    private bool IsRepeatedResource(PdfReferenceHolder referenceHolder);
    private void FontOptimization(PdfDictionary fontDictionary, PdfPageBase newPage);
    private bool CompareStream(MemoryStream stream, PdfPageBase page, String& hashValue);
    internal void CompareColorSpace(PdfDictionary dictionary);
    private void AddResourceCollection(PdfStream stream, PdfPageBase newPage, PdfDictionary xObject, PdfDictionary xObjectDictionary, PdfName xObjectkey);
    private string GetHashValuse(MemoryStream stream);
    private bool ValidateXObjectDictionary(PdfDictionary existing, PdfDictionary current);
    private void OptimizeDescendantFonts(PdfDictionary xObject, PdfPageBase newPage, PdfDictionary fontDictionary, PdfName fontKey);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class Syncfusion.Pdf.PdfPageCountField : PdfSingleValueField {
    private PdfNumberStyle m_numberStyle;
    public PdfNumberStyle NumberStyle { get; public set; }
    public PdfPageCountField(PdfFont font);
    public PdfPageCountField(PdfFont font, PdfBrush brush);
    public PdfPageCountField(PdfFont font, RectangleF bounds);
    public PdfNumberStyle get_NumberStyle();
    public void set_NumberStyle(PdfNumberStyle value);
    protected internal virtual string GetValue(PdfGraphics graphics);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class Syncfusion.Pdf.PdfPageLabel : object {
    private PdfDictionary m_dictionary;
    private int m_startIndex;
    public PdfNumberStyle NumberStyle { get; public set; }
    public string Prefix { get; public set; }
    public int StartNumber { get; public set; }
    public int StartPageIndex { get; public set; }
    private IPdfPrimitive Syncfusion.Pdf.IPdfWrapper.Element { get; }
    public PdfNumberStyle get_NumberStyle();
    public void set_NumberStyle(PdfNumberStyle value);
    public string get_Prefix();
    public void set_Prefix(string value);
    public int get_StartNumber();
    public void set_StartNumber(int value);
    public int get_StartPageIndex();
    public void set_StartPageIndex(int value);
    private static string FromStyleToString(PdfNumberStyle style);
    private static PdfNumberStyle FromStringToStyle(string name);
    private sealed virtual override IPdfPrimitive Syncfusion.Pdf.IPdfWrapper.get_Element();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class Syncfusion.Pdf.PdfPageLayer : object {
    private PdfPageBase m_page;
    internal PdfGraphics m_graphics;
    internal PdfStream m_content;
    internal PdfGraphicsState m_graphicsState;
    private bool m_clipPageTemplates;
    private bool m_bSaved;
    private PdfColorSpace m_colorspace;
    private string m_layerid;
    private string m_name;
    internal bool m_visible;
    private PdfPageLayerCollection m_layer;
    internal bool m_sublayer;
    internal long m_contentLength;
    internal PdfDictionary m_printOption;
    internal PdfDictionary m_usage;
    private PdfPrintState printState;
    private bool m_isEndState;
    private PdfDictionary m_dictionary;
    private PdfReferenceHolder m_refholder;
    internal bool isResourceLayer;
    internal PdfReferenceHolder ReferenceHolder { get; internal set; }
    internal PdfDictionary Dictionary { get; internal set; }
    internal PdfColorSpace Colorspace { get; internal set; }
    public PdfPageBase Page { get; }
    internal string LayerId { get; internal set; }
    public string Name { get; public set; }
    public bool Visible { get; public set; }
    public PdfGraphics Graphics { get; }
    public PdfPrintState PrintState { get; public set; }
    public PdfPageLayerCollection Layers { get; }
    private IPdfPrimitive Syncfusion.Pdf.IPdfWrapper.Element { get; }
    public PdfPageLayer(PdfPageBase page);
    internal PdfPageLayer(PdfPageBase page, PdfStream stream);
    internal PdfPageLayer(PdfPageBase page, bool clipPageTemplates);
    internal PdfReferenceHolder get_ReferenceHolder();
    internal void set_ReferenceHolder(PdfReferenceHolder value);
    internal PdfDictionary get_Dictionary();
    internal void set_Dictionary(PdfDictionary value);
    internal PdfColorSpace get_Colorspace();
    internal void set_Colorspace(PdfColorSpace value);
    public PdfPageBase get_Page();
    internal string get_LayerId();
    internal void set_LayerId(string value);
    public string get_Name();
    public void set_Name(string value);
    public bool get_Visible();
    public void set_Visible(bool value);
    public PdfGraphics get_Graphics();
    public PdfPrintState get_PrintState();
    public void set_PrintState(PdfPrintState value);
    public PdfPageLayer Add();
    public PdfPageLayerCollection get_Layers();
    private void InitializeGraphics(PdfPageBase page);
    internal void Clear();
    private void SetVisibility(bool value);
    private sealed virtual override IPdfPrimitive Syncfusion.Pdf.IPdfWrapper.get_Element();
    private void BeginSaveContent(object sender, SavePdfPrimitiveEventArgs e);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[DefaultMemberAttribute("Item")]
public class Syncfusion.Pdf.PdfPageLayerCollection : PdfCollection {
    private PdfPageBase m_page;
    internal bool m_sublayer;
    private int parentLayerCount;
    internal PdfDictionary m_OptionalContent;
    private List`1<string> m_layerCollection;
    private bool m_isLayerContainsResource;
    private static object s_syncLockLayer;
    private bool isLayerPresent;
    private int m_bdcCount;
    private Dictionary`2<PdfReferenceHolder, PdfDictionary> documentLayers;
    private static object m_resourceLock;
    internal bool isOptimizeContent;
    private bool m_parseLayer;
    public PdfPageLayer Item { get; public set; }
    private bool IsSkip { get; }
    public PdfPageLayerCollection(PdfPageBase page);
    internal PdfPageLayerCollection(PdfPageBase page, bool initializeLayer);
    private static PdfPageLayerCollection();
    public PdfPageLayer get_Item(int index);
    public void set_Item(int index, PdfPageLayer value);
    private bool get_IsSkip();
    public PdfPageLayer Add();
    public PdfPageLayer Add(string LayerName, bool Visible);
    public PdfPageLayer Add(string LayerName);
    public int Add(PdfPageLayer layer);
    private void CreateLayer(PdfPageLayer layer);
    private PdfDictionary setPrintOption(PdfPageLayer layer);
    private void CreateLayerLoadedPage(PdfPageLayer layer);
    public void Insert(int index, PdfPageLayer layer);
    private IPdfPrimitive CreateOptionalContentDictionary(PdfPageLayer layer);
    private IPdfPrimitive CreateOptionalContentDictionary(PdfPageLayer layer, bool isLoadedPage);
    private void WriteEndMark();
    private IPdfPrimitive CreateOptionalContentViews(PdfPageLayer layer);
    private IPdfPrimitive CreateOptionalContentViews(PdfPageLayer layer, bool isLoadedPage);
    public void Remove(PdfPageLayer layer);
    public void Remove(string name);
    public void RemoveAt(int index);
    public bool Contains(PdfPageLayer layer);
    public int IndexOf(PdfPageLayer layer);
    public void Clear();
    internal void CombineContent(Stream stream);
    private void CombineProcess(PdfLoadedPage lPage, bool decompress, Stream stream, Byte[] endl);
    private void AddLayer(int index, PdfPageLayer layer);
    private void RemoveLayer(PdfPageLayer layer);
    private void RemoveLayerReference(PdfLoadedPage page, PdfPageLayer layer, bool isloaded);
    private void RemoveLayerReference(PdfPage page, PdfPageLayer layer);
    private void InsertLayer(int index, PdfPageLayer layer);
    private void ParseLayers(PdfPageBase loadedPage);
    private void AddSaveRestoreState();
    private void CheckVisible(PdfDictionary ocproperties, Dictionary`2<PdfReferenceHolder, PdfPageLayer> m_layerDictionary);
    private void SortLayerList(PdfDictionary ocPropertie, Dictionary`2<PdfReferenceHolder, PdfPageLayer> layerCollection);
    private void PageContainsLayer(PdfDictionary propertie, PdfDictionary resource, Boolean& isPropertieLayer, Boolean& isResourceLayer);
    private void AddLayer(PdfPageBase page, PdfDictionary dictionary, PdfReferenceHolder reference, string key, Dictionary`2<PdfReferenceHolder, PdfPageLayer> pageLayerCollection, bool isResourceLayer);
    private void ParseResourceLayer(PdfDictionary resource, PdfDictionary layerDictionary, PdfReferenceHolder layerReference, PdfPageBase loadedPage, Dictionary`2<PdfReferenceHolder, PdfPageLayer> pageLayerCollection, Dictionary`2<PdfReferenceHolder, PdfDictionary> documentLayers);
    private void RemoveLayerContent(PdfPageLayer layer);
    private string FindOperator(int token);
    private void StreamWrite(String[] operands, string mOperator, bool skip, PdfStream data);
    private void ProcessBeginMarkContent(PdfPageLayer parser, string mOperator, String[] operands, PdfStream data);
    private PdfStream FindLayersContent(PdfPageLayer layer, ContentParser parser, PdfStream data, bool isSkip);
}
public enum Syncfusion.Pdf.PdfPageLayout : Enum {
    public int value__;
    public static PdfPageLayout SinglePage;
    public static PdfPageLayout OneColumn;
    public static PdfPageLayout TwoColumnLeft;
    public static PdfPageLayout TwoColumnRight;
    public static PdfPageLayout TwoPageLeft;
    public static PdfPageLayout TwoPageRight;
}
public enum Syncfusion.Pdf.PdfPageMode : Enum {
    public int value__;
    public static PdfPageMode UseNone;
    public static PdfPageMode UseOutlines;
    public static PdfPageMode UseThumbs;
    public static PdfPageMode FullScreen;
    public static PdfPageMode UseOC;
    public static PdfPageMode UseAttachments;
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class Syncfusion.Pdf.PdfPageNumberField : PdfMultipleNumberValueField {
    public PdfPageNumberField(PdfFont font);
    public PdfPageNumberField(PdfFont font, PdfBrush brush);
    public PdfPageNumberField(PdfFont font, RectangleF bounds);
    protected internal virtual string GetValue(PdfGraphics graphics);
    protected string InternalGetValue(PdfPage page);
    protected string InternalLoadedGetValue(PdfLoadedPage page);
}
public enum Syncfusion.Pdf.PdfPageOrientation : Enum {
    public int value__;
    public static PdfPageOrientation Portrait;
    public static PdfPageOrientation Landscape;
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[DefaultMemberAttribute("Item")]
public class Syncfusion.Pdf.PdfPageResources : object {
    private Dictionary`2<string, object> m_resources;
    internal Dictionary`2<string, FontStructure> fontCollection;
    public Dictionary`2<string, object> Resources { get; }
    public object Item { get; public set; }
    public Dictionary`2<string, object> get_Resources();
    public object get_Item(string key);
    public void set_Item(string key, object value);
    public bool isSameFont();
    public void Add(string resourceName, object resource);
    public bool ContainsKey(string key);
    internal void Dispose();
}
public enum Syncfusion.Pdf.PdfPageRotateAngle : Enum {
    public int value__;
    public static PdfPageRotateAngle RotateAngle0;
    public static PdfPageRotateAngle RotateAngle90;
    public static PdfPageRotateAngle RotateAngle180;
    public static PdfPageRotateAngle RotateAngle270;
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class Syncfusion.Pdf.PdfPageSettings : object {
    private PdfPageOrientation m_orientation;
    private SizeF m_size;
    private PdfMargins m_margins;
    private PdfPageRotateAngle m_rotateAngle;
    private PdfGraphicsUnit m_logicalUnit;
    private PointF m_origin;
    internal bool m_isRotation;
    private bool m_isOrientation;
    private PdfPageTransition m_transition;
    public PdfPageOrientation Orientation { get; public set; }
    public SizeF Size { get; public set; }
    public float Width { get; public set; }
    public float Height { get; public set; }
    public PdfMargins Margins { get; public set; }
    public PdfPageRotateAngle Rotate { get; public set; }
    public PdfPageTransition Transition { get; public set; }
    internal PdfGraphicsUnit Unit { get; internal set; }
    internal PointF Origin { get; internal set; }
    public PdfPageSettings(SizeF size);
    public PdfPageSettings(PdfPageOrientation pageOrientation);
    public PdfPageSettings(SizeF size, PdfPageOrientation pageOrientation);
    public PdfPageSettings(float margins);
    public PdfPageSettings(float leftMargin, float topMargin, float rightMargin, float bottomMargin);
    public PdfPageSettings(SizeF size, float margins);
    public PdfPageSettings(SizeF size, float leftMargin, float topMargin, float rightMargin, float bottomMargin);
    public PdfPageSettings(SizeF size, PdfPageOrientation pageOrientation, float margins);
    public PdfPageSettings(SizeF size, PdfPageOrientation pageOrientation, float leftMargin, float topMargin, float rightMargin, float bottomMargin);
    public PdfPageOrientation get_Orientation();
    public void set_Orientation(PdfPageOrientation value);
    public SizeF get_Size();
    public void set_Size(SizeF value);
    public float get_Width();
    public void set_Width(float value);
    public float get_Height();
    public void set_Height(float value);
    public PdfMargins get_Margins();
    public void set_Margins(PdfMargins value);
    public PdfPageRotateAngle get_Rotate();
    public void set_Rotate(PdfPageRotateAngle value);
    public PdfPageTransition get_Transition();
    public void set_Transition(PdfPageTransition value);
    internal PdfGraphicsUnit get_Unit();
    internal void set_Unit(PdfGraphicsUnit value);
    internal PointF get_Origin();
    internal void set_Origin(PointF value);
    public void SetMargins(float margins);
    public void SetMargins(float leftRight, float topBottom);
    public void SetMargins(float left, float top, float right, float bottom);
    public sealed virtual object Clone();
    internal SizeF GetActualSize();
    internal PdfPageTransition AssignTransition();
    private void UpdateSize(PdfPageOrientation orientation);
    private void AssignSize(SizeF size);
    private void AssignOrientation();
}
public class Syncfusion.Pdf.PdfPageSize : object {
    public static SizeF Letter;
    public static SizeF Note;
    public static SizeF Legal;
    public static SizeF A0;
    public static SizeF A1;
    public static SizeF A2;
    public static SizeF A3;
    public static SizeF A4;
    public static SizeF A5;
    public static SizeF A6;
    public static SizeF A7;
    public static SizeF A8;
    public static SizeF A9;
    public static SizeF A10;
    public static SizeF B0;
    public static SizeF B1;
    public static SizeF B2;
    public static SizeF B3;
    public static SizeF B4;
    public static SizeF B5;
    public static SizeF ArchE;
    public static SizeF ArchD;
    public static SizeF ArchC;
    public static SizeF ArchB;
    public static SizeF ArchA;
    public static SizeF Flsa;
    public static SizeF HalfLetter;
    public static SizeF Letter11x17;
    public static SizeF Ledger;
    private static PdfPageSize();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class Syncfusion.Pdf.PdfPageTemplateElement : object {
    private bool m_foreground;
    private PdfDockStyle m_dockStyle;
    private PdfAlignmentStyle m_alignmentStyle;
    private PdfTemplate m_template;
    private TemplateType m_type;
    private PointF m_location;
    private PdfTag m_tag;
    public PdfDockStyle Dock { get; public set; }
    public PdfAlignmentStyle Alignment { get; public set; }
    public bool Foreground { get; public set; }
    public bool Background { get; public set; }
    public PointF Location { get; public set; }
    public float X { get; public set; }
    public float Y { get; public set; }
    public SizeF Size { get; public set; }
    public float Width { get; public set; }
    public float Height { get; public set; }
    public RectangleF Bounds { get; public set; }
    public PdfGraphics Graphics { get; }
    internal PdfTemplate Template { get; }
    internal TemplateType Type { get; internal set; }
    public PdfTag PdfTag { get; public set; }
    public PdfPageTemplateElement(RectangleF bounds);
    public PdfPageTemplateElement(RectangleF bounds, PdfPage page);
    public PdfPageTemplateElement(PointF location, SizeF size);
    public PdfPageTemplateElement(PointF location, SizeF size, PdfPage page);
    public PdfPageTemplateElement(SizeF size);
    public PdfPageTemplateElement(float width, float height);
    public PdfPageTemplateElement(float width, float height, PdfPage page);
    public PdfPageTemplateElement(float x, float y, float width, float height);
    public PdfPageTemplateElement(float x, float y, float width, float height, PdfPage page);
    public PdfDockStyle get_Dock();
    public void set_Dock(PdfDockStyle value);
    public PdfAlignmentStyle get_Alignment();
    public void set_Alignment(PdfAlignmentStyle value);
    public bool get_Foreground();
    public void set_Foreground(bool value);
    public bool get_Background();
    public void set_Background(bool value);
    public PointF get_Location();
    public void set_Location(PointF value);
    public float get_X();
    public void set_X(float value);
    public float get_Y();
    public void set_Y(float value);
    public SizeF get_Size();
    public void set_Size(SizeF value);
    public float get_Width();
    public void set_Width(float value);
    public float get_Height();
    public void set_Height(float value);
    public RectangleF get_Bounds();
    public void set_Bounds(RectangleF value);
    public PdfGraphics get_Graphics();
    internal PdfTemplate get_Template();
    internal TemplateType get_Type();
    internal void set_Type(TemplateType value);
    public PdfTag get_PdfTag();
    public void set_PdfTag(PdfTag value);
    internal void Draw(PdfPageLayer layer, PdfDocument document);
    private void UpdateDocking(TemplateType type);
    private void ResetAlignment();
    private void AssignAlignment(PdfAlignmentStyle alignment);
    private RectangleF CalculateBounds(PdfPage page, PdfDocument document);
    private RectangleF GetAlignmentBounds(PdfPage page, PdfDocument document);
    private RectangleF GetSimpleAlignmentBounds(PdfPage page, PdfDocument document);
    private RectangleF GetTemplateAlignmentBounds(PdfPage page, PdfDocument document);
    private RectangleF GetDockBounds(PdfPage page, PdfDocument document);
    private RectangleF GetSimpleDockBounds(PdfPage page, PdfDocument document);
    private RectangleF GetTemplateDockBounds(PdfPage page, PdfDocument document);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class Syncfusion.Pdf.PdfPageTransition : object {
    private PdfDictionary m_dictionary;
    private PdfTransitionStyle m_style;
    private float m_duration;
    private PdfTransitionDimension m_dimension;
    private PdfTransitionMotion m_motion;
    private PdfTransitionDirection m_direction;
    private float m_scale;
    private float m_pageDuration;
    public PdfTransitionStyle Style { get; public set; }
    public float Duration { get; public set; }
    public PdfTransitionDimension Dimension { get; public set; }
    public PdfTransitionMotion Motion { get; public set; }
    public PdfTransitionDirection Direction { get; public set; }
    public float Scale { get; public set; }
    public float PageDuration { get; public set; }
    private IPdfPrimitive Syncfusion.Pdf.IPdfWrapper.Element { get; }
    public PdfTransitionStyle get_Style();
    public void set_Style(PdfTransitionStyle value);
    public float get_Duration();
    public void set_Duration(float value);
    public PdfTransitionDimension get_Dimension();
    public void set_Dimension(PdfTransitionDimension value);
    public PdfTransitionMotion get_Motion();
    public void set_Motion(PdfTransitionMotion value);
    public PdfTransitionDirection get_Direction();
    public void set_Direction(PdfTransitionDirection value);
    public float get_Scale();
    public void set_Scale(float value);
    public float get_PageDuration();
    public void set_PageDuration(float value);
    private string MotionToString(PdfTransitionMotion motion);
    private string DimensionToString(PdfTransitionDimension dimension);
    private string StyleToString(PdfTransitionStyle style);
    private sealed virtual override IPdfPrimitive Syncfusion.Pdf.IPdfWrapper.get_Element();
    public sealed virtual object Clone();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class Syncfusion.Pdf.PdfPortfolioAttributes : object {
    private PdfDictionary m_dictionary;
    private String[] m_attributeKeys;
    private Dictionary`2<string, string> m_attributes;
    private PdfPortfolioSchemaCollection m_schemaAttributes;
    public String[] AttributesKey { get; }
    internal PdfPortfolioSchemaCollection SchemaAttributes { get; }
    private IPdfPrimitive Syncfusion.Pdf.IPdfWrapper.Element { get; }
    internal PdfPortfolioAttributes(PdfDictionary dictionary);
    public String[] get_AttributesKey();
    internal PdfPortfolioSchemaCollection get_SchemaAttributes();
    private void Initialize();
    public void AddAttributes(string key, string value);
    public void RemoveAttributes(string key);
    public PdfPortfolioSchemaCollection GetAttributes();
    private sealed virtual override IPdfPrimitive Syncfusion.Pdf.IPdfWrapper.get_Element();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class Syncfusion.Pdf.PdfPortfolioInformation : object {
    private PdfCatalog m_catalog;
    private PdfDictionary m_dictionary;
    private PdfPortfolioSchema m_Schema;
    private PdfPortfolioViewMode m_viewMode;
    private PdfAttachment m_startupDocument;
    public PdfPortfolioSchema Schema { get; public set; }
    public PdfPortfolioViewMode ViewMode { get; public set; }
    public PdfAttachment StartupDocument { get; public set; }
    private IPdfPrimitive Syncfusion.Pdf.IPdfWrapper.Element { get; }
    internal PdfPortfolioInformation(PdfDictionary portfolioDictionary);
    public PdfPortfolioSchema get_Schema();
    public void set_Schema(PdfPortfolioSchema value);
    public PdfPortfolioViewMode get_ViewMode();
    public void set_ViewMode(PdfPortfolioViewMode value);
    public PdfAttachment get_StartupDocument();
    public void set_StartupDocument(PdfAttachment value);
    private void Initialize();
    private sealed virtual override IPdfPrimitive Syncfusion.Pdf.IPdfWrapper.get_Element();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class Syncfusion.Pdf.PdfPortfolioSchema : object {
    private PdfDictionary m_dictionary;
    private PdfPortfolioSchemaField m_schemaField;
    private String[] fieldkeys;
    private Dictionary`2<string, PdfPortfolioSchemaField> m_fieldCollections;
    public String[] FieldKeys { get; }
    private IPdfPrimitive Syncfusion.Pdf.IPdfWrapper.Element { get; }
    internal PdfPortfolioSchema(PdfDictionary schemaDictionary);
    public String[] get_FieldKeys();
    public void AddSchemaField(PdfPortfolioSchemaField field);
    public void RemoveField(string key);
    public Dictionary`2<string, PdfPortfolioSchemaField> GetSchemaField();
    private void Initialize();
    private sealed virtual override IPdfPrimitive Syncfusion.Pdf.IPdfWrapper.get_Element();
}
[NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public class Syncfusion.Pdf.PdfPortfolioSchemaCollection : Dictionary`2<string, string> {
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class Syncfusion.Pdf.PdfPortfolioSchemaField : object {
    private bool m_editable;
    private string m_name;
    private int m_order;
    private bool m_visible;
    private PdfPortfolioSchemaFieldType m_type;
    private PdfDictionary m_dictionary;
    public bool Editable { get; public set; }
    public string Name { get; public set; }
    public int Order { get; public set; }
    public PdfPortfolioSchemaFieldType Type { get; public set; }
    public bool Visible { get; public set; }
    private IPdfPrimitive Syncfusion.Pdf.IPdfWrapper.Element { get; }
    internal PdfPortfolioSchemaField(PdfDictionary schemaField);
    public bool get_Editable();
    public void set_Editable(bool value);
    public string get_Name();
    public void set_Name(string value);
    public int get_Order();
    public void set_Order(int value);
    public PdfPortfolioSchemaFieldType get_Type();
    public void set_Type(PdfPortfolioSchemaFieldType value);
    public bool get_Visible();
    public void set_Visible(bool value);
    private void Initialize();
    private sealed virtual override IPdfPrimitive Syncfusion.Pdf.IPdfWrapper.get_Element();
}
public enum Syncfusion.Pdf.PdfPortfolioSchemaFieldType : Enum {
    public int value__;
    public static PdfPortfolioSchemaFieldType String;
    public static PdfPortfolioSchemaFieldType Date;
    public static PdfPortfolioSchemaFieldType Number;
    public static PdfPortfolioSchemaFieldType FileName;
    public static PdfPortfolioSchemaFieldType Description;
    public static PdfPortfolioSchemaFieldType ModDate;
    public static PdfPortfolioSchemaFieldType CreationDate;
    public static PdfPortfolioSchemaFieldType Size;
}
public enum Syncfusion.Pdf.PdfPortfolioViewMode : Enum {
    public int value__;
    public static PdfPortfolioViewMode Details;
    public static PdfPortfolioViewMode Tile;
    public static PdfPortfolioViewMode Hidden;
}
public enum Syncfusion.Pdf.PdfPrintState : Enum {
    public int value__;
    public static PdfPrintState PrintWhenVisible;
    public static PdfPrintState NeverPrint;
    public static PdfPrintState AlwaysPrint;
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[DebuggerDisplayAttribute("({OperatorName}, operands={Operands.Length})")]
internal class Syncfusion.Pdf.PdfRecord : object {
    private string m_operatorName;
    private String[] m_operands;
    private Byte[] m_inlineImageBytes;
    internal string OperatorName { get; internal set; }
    internal String[] Operands { get; internal set; }
    internal Byte[] InlineImageBytes { get; internal set; }
    public PdfRecord(string name, String[] operands);
    internal PdfRecord(string name, Byte[] imageData);
    internal string get_OperatorName();
    internal void set_OperatorName(string value);
    internal String[] get_Operands();
    internal void set_Operands(String[] value);
    internal Byte[] get_InlineImageBytes();
    internal void set_InlineImageBytes(Byte[] value);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Syncfusion.Pdf.PdfRecordCollection : object {
    private List`1<PdfRecord> m_recordCollection;
    internal List`1<PdfRecord> RecordCollection { get; internal set; }
    internal List`1<PdfRecord> get_RecordCollection();
    internal void set_RecordCollection(List`1<PdfRecord> value);
    public void Add(PdfRecord record);
    internal void Remove(PdfRecord record);
    public sealed virtual IEnumerator GetEnumerator();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Syncfusion.Pdf.PdfResources : PdfDictionary {
    private Dictionary`2<IPdfPrimitive, PdfName> m_names;
    private PdfDictionary m_properties;
    private string m_originalFontName;
    private PdfDocument m_document;
    private int m_imageCounter;
    private string m_imageName;
    private int m_fontCounter;
    private string m_fontName;
    private int m_colorSpaceCounter;
    private string m_colorSpaceName;
    private int m_brushCounter;
    private string m_brushName;
    private int m_templateCounter;
    private string m_templateName;
    private int m_transparencyCounter;
    private string m_transparencyName;
    private int m_dColorSpaceCounter;
    private string m_dColorSpaceName;
    private Dictionary`2<IPdfPrimitive, PdfName> Names { get; }
    internal string OriginalFontName { get; internal set; }
    internal PdfDocument Document { get; internal set; }
    internal PdfResources(PdfDictionary baseDictionary);
    private Dictionary`2<IPdfPrimitive, PdfName> get_Names();
    internal string get_OriginalFontName();
    internal void set_OriginalFontName(string value);
    internal PdfDocument get_Document();
    internal void set_Document(PdfDocument value);
    internal PdfName GetName(IPdfWrapper obj);
    internal Dictionary`2<IPdfPrimitive, PdfName> ObtainNames();
    internal void RequireProcSet(string procSetName);
    private string GenerateName();
    private string GenerateName(IPdfWrapper obj);
    private string SetResourceName(string name, PdfDictionary resourceDictionary, int counter, Int32& updatedCounter);
    private PdfDictionary FetchResourceDictionary(string DictionaryProperty);
    private void Add(IPdfWrapper obj, PdfName name);
    internal void Add(PdfFont font, PdfName name);
    internal void AddProperties(string layerid, PdfReferenceHolder reff);
    private void Add(PdfTemplate template, PdfName name);
    private void Add(PdfImage image, PdfName name);
    private void Add(PdfBrush brush, PdfName name);
    private void Add(PdfTransparency transparancy, PdfName name);
    internal void Add(PdfColorSpaces color, PdfName name);
    internal void Add(PdfDictionary color, PdfName name);
    internal void RemoveFont(string name);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[DefaultMemberAttribute("Item")]
public class Syncfusion.Pdf.PdfSection : object {
    private List`1<PdfPageBase> m_pages;
    private PdfArray m_pagesReferences;
    private PdfDictionary m_section;
    private PdfNumber m_count;
    private PdfSectionCollection m_parent;
    private PdfDictionary m_resources;
    private PdfPageSettings m_settings;
    private PdfSectionTemplate m_pageTemplate;
    private PdfPageLabel m_pageLabel;
    private bool m_isProgressOn;
    private PdfPageSettings m_initialSettings;
    private PdfPageTransition m_savedTransition;
    private bool m_isTransitionSaved;
    private PdfSectionPageCollection m_pagesCollection;
    internal PdfDocumentBase m_document;
    private bool m_isNewPageSection;
    internal bool m_importedSection;
    [CompilerGeneratedAttribute]
private PageAddedEventHandler PageAdded;
    public PdfSectionPageCollection Pages { get; }
    public PdfPageLabel PageLabel { get; public set; }
    public PdfPageSettings PageSettings { get; public set; }
    public PdfSectionTemplate Template { get; public set; }
    internal PdfPage Item { get; }
    internal int Count { get; }
    internal PdfSectionCollection Parent { get; internal set; }
    internal PdfDictionary Resources { get; }
    internal PdfDocument Document { get; }
    internal PdfDocumentBase ParentDocument { get; }
    private IPdfPrimitive Syncfusion.Pdf.IPdfWrapper.Element { get; }
    internal PdfSection(PdfDocumentBase document, PdfPageSettings pageSettings);
    internal PdfSection(PdfDocument document);
    public PdfSectionPageCollection get_Pages();
    public PdfPageLabel get_PageLabel();
    public void set_PageLabel(PdfPageLabel value);
    public PdfPageSettings get_PageSettings();
    public void set_PageSettings(PdfPageSettings value);
    public PdfSectionTemplate get_Template();
    public void set_Template(PdfSectionTemplate value);
    internal PdfPage get_Item(int index);
    internal int get_Count();
    internal PdfSectionCollection get_Parent();
    internal void set_Parent(PdfSectionCollection value);
    internal PdfDictionary get_Resources();
    internal PdfDocument get_Document();
    internal PdfDocumentBase get_ParentDocument();
    [CompilerGeneratedAttribute]
public void add_PageAdded(PageAddedEventHandler value);
    [CompilerGeneratedAttribute]
public void remove_PageAdded(PageAddedEventHandler value);
    internal PdfPage Add();
    internal void Add(PdfPage page);
    internal void Insert(int index, PdfPage page);
    internal void Insert(int index, PdfPageBase loadedPage);
    internal int IndexOf(PdfPage page);
    internal bool Contains(PdfPage page);
    internal void Remove(PdfPage page);
    internal void RemoveAt(int index);
    internal void Clear();
    public sealed virtual IEnumerator GetEnumerator();
    private sealed virtual override IPdfPrimitive Syncfusion.Pdf.IPdfWrapper.get_Element();
    internal bool ContainsTemplates(PdfDocument document, PdfPage page, bool foreground);
    internal void DrawTemplates(PdfPage page, PdfPageLayer layer, PdfDocument document, bool foreground);
    internal RectangleF GetActualBounds(PdfPage page, bool includeMargins);
    internal RectangleF GetActualBounds(PdfDocument document, PdfPage page, bool includeMargins);
    internal float GetLeftIndentWidth(PdfDocument document, PdfPage page, bool includeMargins);
    internal float GetTopIndentHeight(PdfDocument document, PdfPage page, bool includeMargins);
    internal float GetRightIndentWidth(PdfDocument document, PdfPage page, bool includeMargins);
    internal float GetBottomIndentHeight(PdfDocument document, PdfPage page, bool includeMargins);
    internal PointF PointToNativePdf(PdfPage page, PointF point);
    private void DrawTemplates(PdfPageLayer layer, PdfDocument document, PdfPageTemplateElement[] templates);
    private PdfPageTemplateElement[] GetDocumentTemplates(PdfDocument document, PdfPage page, bool headers, bool foreground);
    private PdfPageTemplateElement[] GetSectionTemplates(PdfPage page, bool headers, bool foreground);
    protected virtual void OnPageAdded(PageAddedEventArgs args);
    internal void SetProgress();
    internal void ResetProgress();
    internal void OnPageSaving(PdfPage page);
    private PdfReferenceHolder CheckPresence(PdfPage page);
    private void SetPageSettings(PdfDictionary container, PdfPageSettings parentSettings);
    private void Initialize();
    internal PdfPageTransition GetTransitionSettings();
    internal void DropCropBox();
    private void PageAddedMethod(PdfPage page);
    private void BeginSave(object sender, SavePdfPrimitiveEventArgs e);
    private void EndSave(object sender, SavePdfPrimitiveEventArgs ars);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[DefaultMemberAttribute("Item")]
public class Syncfusion.Pdf.PdfSectionCollection : object {
    internal static int RotateFactor;
    private PdfArray m_sectionCollection;
    private List`1<PdfSection> m_sections;
    private PdfDictionary m_pages;
    private PdfNumber m_count;
    private PdfDocument m_document;
    public PdfSection Item { get; }
    public int Count { get; }
    internal PdfDocument Document { get; }
    private IPdfPrimitive Syncfusion.Pdf.IPdfWrapper.Element { get; }
    internal PdfSectionCollection(PdfDocument document);
    public PdfSection get_Item(int index);
    public int get_Count();
    internal PdfDocument get_Document();
    public PdfSection Add();
    public int IndexOf(PdfSection section);
    public void Insert(int index, PdfSection section);
    public bool Contains(PdfSection section);
    public sealed virtual IEnumerator GetEnumerator();
    private sealed virtual override IPdfPrimitive Syncfusion.Pdf.IPdfWrapper.get_Element();
    internal void PageLabelsSet();
    internal void ResetProgress();
    internal void SetProgress();
    internal void OnPageSaving(PdfPage page);
    private void SetPageSettings(PdfDictionary container, PdfPageSettings pageSettings);
    private PdfReferenceHolder CheckSection(PdfSection section);
    private int CountPages();
    private int Add(PdfSection section);
    private void AddSection(PdfSection section);
    private void Initialize();
    internal void Clear();
    private void BeginSave(object sender, SavePdfPrimitiveEventArgs e);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class Syncfusion.Pdf.PdfSectionNumberField : PdfMultipleNumberValueField {
    public PdfSectionNumberField(PdfFont font);
    public PdfSectionNumberField(PdfFont font, PdfBrush brush);
    public PdfSectionNumberField(PdfFont font, RectangleF bounds);
    protected internal virtual string GetValue(PdfGraphics graphics);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[DefaultMemberAttribute("Item")]
public class Syncfusion.Pdf.PdfSectionPageCollection : object {
    private PdfSection m_section;
    public PdfPage Item { get; }
    public int Count { get; }
    internal PdfSectionPageCollection(PdfSection section);
    public PdfPage get_Item(int index);
    public int get_Count();
    public PdfPage Add();
    public void Add(PdfPage page);
    public void Insert(int index, PdfPage page);
    public int IndexOf(PdfPage page);
    public bool Contains(PdfPage page);
    public void Remove(PdfPage page);
    public void RemoveAt(int index);
    public void Clear();
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class Syncfusion.Pdf.PdfSectionPageCountField : PdfMultipleNumberValueField {
    public PdfSectionPageCountField(PdfFont font);
    public PdfSectionPageCountField(PdfFont font, PdfBrush brush);
    public PdfSectionPageCountField(PdfFont font, RectangleF bounds);
    protected internal virtual string GetValue(PdfGraphics graphics);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class Syncfusion.Pdf.PdfSectionPageNumberField : PdfMultipleNumberValueField {
    public PdfSectionPageNumberField(PdfFont font);
    public PdfSectionPageNumberField(PdfFont font, PdfBrush brush);
    public PdfSectionPageNumberField(PdfFont font, RectangleF bounds);
    protected internal virtual string GetValue(PdfGraphics graphics);
}
public class Syncfusion.Pdf.PdfSectionTemplate : PdfDocumentTemplate {
    private bool m_left;
    private bool m_top;
    private bool m_right;
    private bool m_bottom;
    private bool m_stamp;
    public bool ApplyDocumentLeftTemplate { get; public set; }
    public bool ApplyDocumentTopTemplate { get; public set; }
    public bool ApplyDocumentRightTemplate { get; public set; }
    public bool ApplyDocumentBottomTemplate { get; public set; }
    public bool ApplyDocumentStamps { get; public set; }
    public bool get_ApplyDocumentLeftTemplate();
    public void set_ApplyDocumentLeftTemplate(bool value);
    public bool get_ApplyDocumentTopTemplate();
    public void set_ApplyDocumentTopTemplate(bool value);
    public bool get_ApplyDocumentRightTemplate();
    public void set_ApplyDocumentRightTemplate(bool value);
    public bool get_ApplyDocumentBottomTemplate();
    public void set_ApplyDocumentBottomTemplate(bool value);
    public bool get_ApplyDocumentStamps();
    public void set_ApplyDocumentStamps(bool value);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public abstract class Syncfusion.Pdf.PdfSingleValueField : PdfDynamicField {
    private Dictionary`2<PdfDocumentBase, PdfTemplateValuePair> m_list;
    private List`1<PdfGraphics> m_painterGraphics;
    public PdfSingleValueField(PdfFont font);
    public PdfSingleValueField(PdfFont font, PdfBrush brush);
    public PdfSingleValueField(PdfFont font, RectangleF bounds);
    protected internal virtual void PerformDraw(PdfGraphics graphics, PointF location, float scalingX, float scalingY);
}
public class Syncfusion.Pdf.PdfSplitOptions : object {
    private bool m_splitTags;
    private bool m_removeUnusedResources;
    public bool SplitTags { get; public set; }
    public bool RemoveUnusedResources { get; public set; }
    public bool get_SplitTags();
    public void set_SplitTags(bool value);
    public bool get_RemoveUnusedResources();
    public void set_RemoveUnusedResources(bool value);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[DefaultMemberAttribute("Item")]
public class Syncfusion.Pdf.PdfStampCollection : PdfCollection {
    public PdfPageTemplateElement Item { get; }
    public PdfPageTemplateElement get_Item(int index);
    public int Add(PdfPageTemplateElement template);
    public PdfPageTemplateElement Add(float x, float y, float width, float height);
    public bool Contains(PdfPageTemplateElement template);
    public void Insert(int index, PdfPageTemplateElement template);
    public void Remove(PdfPageTemplateElement template);
    public void RemoveAt(int index);
    public void Clear();
    public IEnumerator GetEnumerator();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public abstract class Syncfusion.Pdf.PdfStaticField : PdfAutomaticField {
    private PdfTemplate m_template;
    private List`1<PdfGraphics> m_graphicsList;
    public PdfStaticField(PdfFont font);
    public PdfStaticField(PdfFont font, PdfBrush brush);
    public PdfStaticField(PdfFont font, RectangleF bounds);
    protected internal virtual void PerformDraw(PdfGraphics graphics, PointF location, float scalingX, float scalingY);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class Syncfusion.Pdf.PdfStructureElement : PdfTag {
    private PdfTagType m_tagType;
    private PdfStructureElement m_parent;
    private string m_altText;
    private string m_title;
    private string m_language;
    private string m_abbrevation;
    private string m_actualText;
    internal string m_name;
    private int m_order;
    private bool isAdded;
    private ScopeType m_scope;
    internal bool m_isActiveSetTag;
    internal List`1<PdfStructureElement> m_child;
    private PdfDictionary m_dictionary;
    private PdfDictionary m_pageDictionary;
    private PdfLoadedDocument m_document;
    private PdfPageBase m_page;
    private RectangleF m_bounds;
    private string m_text;
    internal List`1<int> m_mcids;
    private List`1<RectangleF> m_boundsCollection;
    private string m_fontName;
    private float m_fontSize;
    internal bool IsTagSplitParser;
    private PdfDictionary m_attributeDictionary;
    private FontStyle m_fontStyle;
    public string Abbrevation { get; public set; }
    public string ActualText { get; public set; }
    public string AlternateText { get; public set; }
    public string Language { get; public set; }
    public int Order { get; public set; }
    public PdfStructureElement Parent { get; public set; }
    public PdfTagType TagType { get; public set; }
    public string Title { get; public set; }
    internal bool IsAdded { get; internal set; }
    internal PdfDictionary AttributeDictionary { get; }
    public ScopeType Scope { get; public set; }
    public PdfStructureElement[] ChildElements { get; }
    public PdfPageBase Page { get; internal set; }
    public RectangleF Bounds { get; internal set; }
    public string Text { get; }
    internal string FontName { get; }
    internal float FontSize { get; }
    internal FontStyle FontStyle { get; }
    internal PdfDictionary Dictionary { get; }
    public PdfStructureElement(PdfTagType tag);
    internal PdfStructureElement(PdfLoadedDocument loadedDocument, PdfDictionary dictionary, int order, PdfStructureElement parent);
    public string get_Abbrevation();
    public void set_Abbrevation(string value);
    public string get_ActualText();
    public void set_ActualText(string value);
    public string get_AlternateText();
    public void set_AlternateText(string value);
    public string get_Language();
    public void set_Language(string value);
    public virtual int get_Order();
    public virtual void set_Order(int value);
    public PdfStructureElement get_Parent();
    public void set_Parent(PdfStructureElement value);
    public PdfTagType get_TagType();
    public void set_TagType(PdfTagType value);
    public string get_Title();
    public void set_Title(string value);
    internal bool get_IsAdded();
    internal void set_IsAdded(bool value);
    internal PdfDictionary get_AttributeDictionary();
    public ScopeType get_Scope();
    public void set_Scope(ScopeType value);
    public PdfStructureElement[] get_ChildElements();
    public PdfPageBase get_Page();
    internal void set_Page(PdfPageBase value);
    public RectangleF get_Bounds();
    internal void set_Bounds(RectangleF value);
    public string get_Text();
    internal string get_FontName();
    internal float get_FontSize();
    internal FontStyle get_FontStyle();
    internal PdfDictionary get_Dictionary();
    private PdfTagType GetTagType(string tagType);
    private ScopeType GetScopeType(string scopeType);
    private void InitializeTaggedContents();
    private RectangleF CalculateBounds(RectangleF bounds);
    private PdfPageBase GetChildPage();
    private PdfPageBase GetPageFromElement(PdfStructureElement element);
    internal void InitializePageDictionary(PdfDictionary pageDictionary);
    internal void SetAttributeDictionary(PdfDictionary dictionary);
}
public abstract class Syncfusion.Pdf.PdfTag : object {
    private int m_tagOrder;
    private RectangleF bounds;
    public int Order { get; public set; }
    internal RectangleF Bounds { get; internal set; }
    public virtual int get_Order();
    public virtual void set_Order(int value);
    internal RectangleF get_Bounds();
    internal void set_Bounds(RectangleF value);
}
public enum Syncfusion.Pdf.PdfTagType : Enum {
    public int value__;
    public static PdfTagType Annotation;
    public static PdfTagType Article;
    public static PdfTagType BibliographyEntry;
    public static PdfTagType BlockQuotation;
    public static PdfTagType Caption;
    public static PdfTagType Code;
    public static PdfTagType Division;
    public static PdfTagType Document;
    public static PdfTagType Figure;
    public static PdfTagType Form;
    public static PdfTagType Formula;
    public static PdfTagType Heading;
    public static PdfTagType HeadingLevel1;
    public static PdfTagType HeadingLevel2;
    public static PdfTagType HeadingLevel3;
    public static PdfTagType HeadingLevel4;
    public static PdfTagType HeadingLevel5;
    public static PdfTagType HeadingLevel6;
    public static PdfTagType Index;
    public static PdfTagType Label;
    public static PdfTagType Link;
    public static PdfTagType List;
    public static PdfTagType ListBody;
    public static PdfTagType ListItem;
    public static PdfTagType Note;
    public static PdfTagType Paragraph;
    public static PdfTagType Part;
    public static PdfTagType Private;
    public static PdfTagType Quotation;
    public static PdfTagType Reference;
    public static PdfTagType Ruby;
    public static PdfTagType Section;
    public static PdfTagType Span;
    public static PdfTagType Table;
    public static PdfTagType TableBodyRowGroup;
    public static PdfTagType TableDataCell;
    public static PdfTagType TableFooterRowGroup;
    public static PdfTagType TableHeader;
    public static PdfTagType TableHeaderRowGroup;
    public static PdfTagType TableOfContent;
    public static PdfTagType TableOfContentItem;
    public static PdfTagType TableRow;
    public static PdfTagType Warichu;
    public static PdfTagType None;
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Syncfusion.Pdf.PdfTemplateValuePair : object {
    private PdfTemplate m_template;
    private string m_value;
    public PdfTemplate Template { get; public set; }
    public string Value { get; public set; }
    public PdfTemplateValuePair(PdfTemplate template, string value);
    public PdfTemplate get_Template();
    public void set_Template(PdfTemplate value);
    public string get_Value();
    public void set_Value(string value);
}
public enum Syncfusion.Pdf.PdfTransitionDimension : Enum {
    public int value__;
    public static PdfTransitionDimension Horizontal;
    public static PdfTransitionDimension Vertical;
}
public enum Syncfusion.Pdf.PdfTransitionDirection : Enum {
    public int value__;
    public static PdfTransitionDirection LeftToRight;
    public static PdfTransitionDirection BottomToTop;
    public static PdfTransitionDirection RightToLeft;
    public static PdfTransitionDirection TopToBottom;
    public static PdfTransitionDirection TopLeftToBottomRight;
}
public enum Syncfusion.Pdf.PdfTransitionMotion : Enum {
    public int value__;
    public static PdfTransitionMotion Inward;
    public static PdfTransitionMotion Outward;
}
public enum Syncfusion.Pdf.PdfTransitionStyle : Enum {
    public int value__;
    public static PdfTransitionStyle Split;
    public static PdfTransitionStyle Blinds;
    public static PdfTransitionStyle Box;
    public static PdfTransitionStyle Wipe;
    public static PdfTransitionStyle Dissolve;
    public static PdfTransitionStyle Glitter;
    public static PdfTransitionStyle Replace;
    public static PdfTransitionStyle Fly;
    public static PdfTransitionStyle Push;
    public static PdfTransitionStyle Cover;
    public static PdfTransitionStyle Uncover;
    public static PdfTransitionStyle Fade;
}
public enum Syncfusion.Pdf.PdfVersion : Enum {
    public int value__;
    public static PdfVersion Version1_0;
    public static PdfVersion Version1_1;
    public static PdfVersion Version1_2;
    public static PdfVersion Version1_3;
    public static PdfVersion Version1_4;
    public static PdfVersion Version1_5;
    public static PdfVersion Version1_6;
    public static PdfVersion Version1_7;
    public static PdfVersion Version2_0;
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class Syncfusion.Pdf.PdfViewerPreferences : object {
    private bool m_centerWindow;
    private bool m_displayDocTitle;
    private bool m_fitWindow;
    private bool m_hideMenubar;
    private bool m_hideToolbar;
    private bool m_hideWindowUI;
    private PdfPageMode m_pageMode;
    private PdfPageLayout m_pageLayout;
    private PdfCatalog m_catalog;
    private PdfDictionary m_dictionary;
    private PageScalingMode m_pageScaling;
    private DuplexMode m_duplex;
    public bool CenterWindow { get; public set; }
    public bool DisplayTitle { get; public set; }
    public bool FitWindow { get; public set; }
    public bool HideMenubar { get; public set; }
    public bool HideToolbar { get; public set; }
    public bool HideWindowUI { get; public set; }
    public PdfPageMode PageMode { get; public set; }
    public PdfPageLayout PageLayout { get; public set; }
    public DuplexMode Duplex { get; public set; }
    public PageScalingMode PageScaling { get; public set; }
    private IPdfPrimitive Syncfusion.Pdf.IPdfWrapper.Element { get; }
    internal PdfViewerPreferences(PdfCatalog catalog);
    public bool get_CenterWindow();
    public void set_CenterWindow(bool value);
    public bool get_DisplayTitle();
    public void set_DisplayTitle(bool value);
    public bool get_FitWindow();
    public void set_FitWindow(bool value);
    public bool get_HideMenubar();
    public void set_HideMenubar(bool value);
    public bool get_HideToolbar();
    public void set_HideToolbar(bool value);
    public bool get_HideWindowUI();
    public void set_HideWindowUI(bool value);
    public PdfPageMode get_PageMode();
    public void set_PageMode(PdfPageMode value);
    public PdfPageLayout get_PageLayout();
    public void set_PageLayout(PdfPageLayout value);
    public DuplexMode get_Duplex();
    public void set_Duplex(DuplexMode value);
    public PageScalingMode get_PageScaling();
    public void set_PageScaling(PageScalingMode value);
    private sealed virtual override IPdfPrimitive Syncfusion.Pdf.IPdfWrapper.get_Element();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Syncfusion.Pdf.PredefinedEncoding : object {
    private String[] names;
    private string m_name;
    private static PredefinedEncoding m_pdfdocEncoding;
    private static PredefinedEncoding m_winAnsiEncoding;
    private static PredefinedEncoding m_macRomanEncoding;
    private static PredefinedEncoding m_standardMacRomanEncoding;
    private static PredefinedEncoding m_standardEncoding;
    private Dictionary`2<string, byte> mapping;
    public static PredefinedEncoding PdfDocEncoding { get; private set; }
    public static PredefinedEncoding WinAnsiEncoding { get; private set; }
    public static PredefinedEncoding MacRomanEncoding { get; private set; }
    public static PredefinedEncoding StandardMacRomanEncoding { get; private set; }
    public static PredefinedEncoding StandardEncoding { get; private set; }
    public string Name { get; private set; }
    private static PredefinedEncoding();
    public static PredefinedEncoding get_PdfDocEncoding();
    private static void set_PdfDocEncoding(PredefinedEncoding value);
    public static PredefinedEncoding get_WinAnsiEncoding();
    private static void set_WinAnsiEncoding(PredefinedEncoding value);
    public static PredefinedEncoding get_MacRomanEncoding();
    private static void set_MacRomanEncoding(PredefinedEncoding value);
    public static PredefinedEncoding get_StandardMacRomanEncoding();
    private static void set_StandardMacRomanEncoding(PredefinedEncoding value);
    public static PredefinedEncoding get_StandardEncoding();
    private static void set_StandardEncoding(PredefinedEncoding value);
    public string get_Name();
    private void set_Name(string value);
    private static void InitializePdfEncoding();
    private static void InitializeWinAnsiEncoding();
    private static void InitializeMacEncoding();
    private static void InitializeStandardMacEncoding();
    public static PredefinedEncoding GetPredefinedEncoding(string encoding);
    private void Init();
    private void InitMapping();
    public String[] GetNames();
    public byte GetCharId(string name);
}
[NullableContextAttribute("1")]
internal interface Syncfusion.Pdf.Primitives.IPdfPrimitive {
    public ObjectStatus Status { get; public set; }
    public bool IsSaving { get; public set; }
    public int ObjectCollectionIndex { get; public set; }
    public IPdfPrimitive ClonedObject { get; }
    public int Position { get; public set; }
    public abstract virtual ObjectStatus get_Status();
    public abstract virtual void set_Status(ObjectStatus value);
    public abstract virtual bool get_IsSaving();
    public abstract virtual void set_IsSaving(bool value);
    public abstract virtual int get_ObjectCollectionIndex();
    public abstract virtual void set_ObjectCollectionIndex(int value);
    public abstract virtual IPdfPrimitive get_ClonedObject();
    public abstract virtual void Save(IPdfWriter writer);
    public abstract virtual IPdfPrimitive Clone(PdfCrossTable crossTable);
    public abstract virtual int get_Position();
    public abstract virtual void set_Position(int value);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Syncfusion.Pdf.Primitives.Pdf3DStream : PdfDictionary {
    private static string Prefix;
    private static string Suffix;
    private Byte[] m_content;
    private Pdf3DAnimation m_animation;
    private int m_defaultView;
    private string m_onInstatiate;
    private Pdf3DAnnotationType m_type;
    private Pdf3DViewCollection m_pdf3dViewCollection;
    private MemoryStream m_dataStream;
    private bool m_blockEncryption;
    private bool m_bDecrypted;
    private bool m_bCompress;
    public Pdf3DAnimation Animation { get; public set; }
    public Byte[] Content { get; public set; }
    public int DefaultView { get; public set; }
    internal Pdf3DAnnotationType Type { get; internal set; }
    public string OnInstantiate { get; public set; }
    public Pdf3DViewCollection Views { get; }
    internal MemoryStream InternalStream { get; }
    internal Byte[] Data { get; internal set; }
    internal bool Compress { get; internal set; }
    public bool WasEncrypted { get; }
    public bool Decrypted { get; }
    internal Pdf3DStream(PdfDictionary dictionary, Byte[] data);
    public Pdf3DAnimation get_Animation();
    public void set_Animation(Pdf3DAnimation value);
    public Byte[] get_Content();
    public void set_Content(Byte[] value);
    public int get_DefaultView();
    public void set_DefaultView(int value);
    internal Pdf3DAnnotationType get_Type();
    internal void set_Type(Pdf3DAnnotationType value);
    public string get_OnInstantiate();
    public void set_OnInstantiate(string value);
    public Pdf3DViewCollection get_Views();
    internal MemoryStream get_InternalStream();
    internal Byte[] get_Data();
    internal void set_Data(Byte[] value);
    internal bool get_Compress();
    internal void set_Compress(bool value);
    public static Byte[] StreamToBytes(Stream stream);
    public static Byte[] StreamToBytes(Stream stream, bool writeWholeStream);
    public static Byte[] StreamToBigEndian(Stream stream);
    internal void Write(char symbol);
    internal void Write(string text);
    internal void Write(Byte[] data);
    internal void BlockEncryption();
    internal void Decompress();
    internal void Clear();
    public virtual void Save(IPdfWriter writer);
    public sealed virtual bool get_WasEncrypted();
    public sealed virtual bool get_Decrypted();
    public sealed virtual void Decrypt(PdfEncryptor encryptor, long currObjNumber);
    private Byte[] Decompress(Byte[] data, string filter);
    private IPdfCompressor DetermineCompressor(string filter);
    private Byte[] PostProcess(Byte[] data, string filter);
    private void NormalizeFilter();
    private Byte[] CompressContent(IPdfWriter writer);
    private void AddFilter(string filterName);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[DefaultMemberAttribute("Item")]
internal class Syncfusion.Pdf.Primitives.PdfArray : object {
    public static string StartMark;
    public static string EndMark;
    private List`1<IPdfPrimitive> m_elements;
    private bool m_bChanged;
    private ObjectStatus m_status;
    private bool m_isSaving;
    private int m_index;
    private int m_position;
    private PdfCrossTable m_crossTable;
    private PdfArray m_clonedObject;
    private bool isFont;
    private bool skip;
    internal IPdfPrimitive Item { get; }
    internal int Count { get; }
    public ObjectStatus Status { get; public set; }
    public bool IsSaving { get; public set; }
    public int ObjectCollectionIndex { get; public set; }
    public int Position { get; public set; }
    internal List`1<IPdfPrimitive> Elements { get; }
    internal PdfCrossTable CrossTable { get; }
    public IPdfPrimitive ClonedObject { get; }
    internal bool IsFont { get; internal set; }
    internal bool Skip { get; internal set; }
    public bool Changed { get; }
    internal PdfArray(PdfArray array);
    internal PdfArray(List`1<PdfArray> array);
    internal PdfArray(Int32[] array);
    internal PdfArray(Single[] array);
    public PdfArray(Double[] array);
    internal IPdfPrimitive get_Item(int index);
    internal int get_Count();
    public sealed virtual ObjectStatus get_Status();
    public sealed virtual void set_Status(ObjectStatus value);
    public sealed virtual bool get_IsSaving();
    public sealed virtual void set_IsSaving(bool value);
    public sealed virtual int get_ObjectCollectionIndex();
    public sealed virtual void set_ObjectCollectionIndex(int value);
    public sealed virtual int get_Position();
    public sealed virtual void set_Position(int value);
    internal List`1<IPdfPrimitive> get_Elements();
    internal PdfCrossTable get_CrossTable();
    public sealed virtual IPdfPrimitive get_ClonedObject();
    internal bool get_IsFont();
    internal void set_IsFont(bool value);
    internal bool get_Skip();
    internal void set_Skip(bool value);
    public static PdfArray FromRectangle(RectangleF rectangle);
    public static PdfArray FromRectangle(Rectangle rectangle);
    internal void Add(IPdfPrimitive element);
    internal void Add(IPdfPrimitive[] list);
    internal bool Contains(IPdfPrimitive element);
    internal void Insert(int index, IPdfPrimitive element);
    internal int IndexOf(IPdfPrimitive element);
    internal void Remove(IPdfPrimitive element);
    internal void ReArrange(Int32[] orderArray);
    internal void RemoveAt(int index);
    internal void Clear();
    public RectangleF ToRectangle();
    public virtual void Save(IPdfWriter writer);
    public sealed virtual IEnumerator GetEnumerator();
    public void MarkChanged();
    public sealed virtual bool get_Changed();
    public sealed virtual void FreezeChanges(object freezer);
    private PdfNumber GetNumber(int index);
    public sealed virtual IPdfPrimitive Clone(PdfCrossTable crossTable);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Syncfusion.Pdf.Primitives.PdfBoolean : object {
    private bool m_value;
    private ObjectStatus m_status;
    private bool m_isSaving;
    private int m_index;
    private int m_position;
    public bool Value { get; public set; }
    public ObjectStatus Status { get; public set; }
    public bool IsSaving { get; public set; }
    public int ObjectCollectionIndex { get; public set; }
    public int Position { get; public set; }
    public IPdfPrimitive ClonedObject { get; }
    internal PdfBoolean(bool value);
    public bool get_Value();
    public void set_Value(bool value);
    public sealed virtual ObjectStatus get_Status();
    public sealed virtual void set_Status(ObjectStatus value);
    public sealed virtual bool get_IsSaving();
    public sealed virtual void set_IsSaving(bool value);
    public sealed virtual int get_ObjectCollectionIndex();
    public sealed virtual void set_ObjectCollectionIndex(int value);
    public sealed virtual int get_Position();
    public sealed virtual void set_Position(int value);
    public sealed virtual IPdfPrimitive get_ClonedObject();
    private string BoolToStr(bool value);
    public sealed virtual IPdfPrimitive Clone(PdfCrossTable crossTable);
    public sealed virtual void Save(IPdfWriter writer);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[DefaultMemberAttribute("Item")]
internal class Syncfusion.Pdf.Primitives.PdfDictionary : object {
    private static string Prefix;
    private static string Suffix;
    private static object s_syncLock;
    private Dictionary`2<PdfName, IPdfPrimitive> m_items;
    private bool m_archive;
    private bool m_encrypt;
    private bool m_isDecrypted;
    private bool m_bChanged;
    private ObjectStatus m_status;
    private bool m_isSaving;
    private int m_index;
    private int m_position;
    private PdfCrossTable m_crossTable;
    internal PdfDictionary m_clonedObject;
    internal bool isXfa;
    internal bool isSkip;
    private bool isFont;
    [CompilerGeneratedAttribute]
private SavePdfPrimitiveEventHandler BeginSave;
    [CompilerGeneratedAttribute]
private SavePdfPrimitiveEventHandler EndSave;
    public IPdfPrimitive Item { get; public set; }
    public IPdfPrimitive Item { get; public set; }
    public int Count { get; }
    public ValueCollection<PdfName, IPdfPrimitive> Values { get; }
    internal bool Archive { get; internal set; }
    internal bool Encrypt { get; internal set; }
    internal bool IsDecrypted { get; internal set; }
    internal KeyCollection<PdfName, IPdfPrimitive> Keys { get; }
    internal Dictionary`2<PdfName, IPdfPrimitive> Items { get; }
    public ObjectStatus Status { get; public set; }
    public bool IsSaving { get; public set; }
    public int ObjectCollectionIndex { get; public set; }
    public int Position { get; public set; }
    internal PdfCrossTable CrossTable { get; }
    public IPdfPrimitive ClonedObject { get; }
    internal bool IsFont { get; internal set; }
    public bool Changed { get; }
    internal PdfDictionary(PdfDictionary dictionary);
    private static PdfDictionary();
    public IPdfPrimitive get_Item(PdfName key);
    public void set_Item(PdfName key, IPdfPrimitive value);
    public IPdfPrimitive get_Item(string key);
    public void set_Item(string key, IPdfPrimitive value);
    public int get_Count();
    public ValueCollection<PdfName, IPdfPrimitive> get_Values();
    internal bool get_Archive();
    internal void set_Archive(bool value);
    internal bool get_Encrypt();
    internal void set_Encrypt(bool value);
    internal bool get_IsDecrypted();
    internal void set_IsDecrypted(bool value);
    internal KeyCollection<PdfName, IPdfPrimitive> get_Keys();
    internal Dictionary`2<PdfName, IPdfPrimitive> get_Items();
    public sealed virtual ObjectStatus get_Status();
    public sealed virtual void set_Status(ObjectStatus value);
    public sealed virtual bool get_IsSaving();
    public sealed virtual void set_IsSaving(bool value);
    public sealed virtual int get_ObjectCollectionIndex();
    public sealed virtual void set_ObjectCollectionIndex(int value);
    public sealed virtual int get_Position();
    public sealed virtual void set_Position(int value);
    internal PdfCrossTable get_CrossTable();
    public virtual IPdfPrimitive get_ClonedObject();
    internal bool get_IsFont();
    internal void set_IsFont(bool value);
    [CompilerGeneratedAttribute]
internal void add_BeginSave(SavePdfPrimitiveEventHandler value);
    [CompilerGeneratedAttribute]
internal void remove_BeginSave(SavePdfPrimitiveEventHandler value);
    [CompilerGeneratedAttribute]
internal void add_EndSave(SavePdfPrimitiveEventHandler value);
    [CompilerGeneratedAttribute]
internal void remove_EndSave(SavePdfPrimitiveEventHandler value);
    public bool ContainsKey(string key);
    public bool ContainsKey(PdfName key);
    public void Remove(PdfName key);
    public void Remove(string key);
    internal void Clear();
    public virtual IPdfPrimitive Clone(PdfCrossTable crossTable);
    public IPdfPrimitive GetValue(PdfCrossTable crossTable, string key, string parentKey);
    public IPdfPrimitive GetValue(string key, string parentKey);
    internal PdfString GetString(string propertyName);
    internal int GetInt(string propertyName);
    internal virtual void SaveItems(IPdfWriter writer);
    protected internal PdfName GetName(string name);
    protected virtual void OnBeginSave(SavePdfPrimitiveEventArgs args);
    protected virtual void OnEndSave(SavePdfPrimitiveEventArgs args);
    public virtual void Save(IPdfWriter writer);
    internal void Save(IPdfWriter writer, bool bRaiseEvent);
    internal void SetProperty(string key, IPdfPrimitive primitive);
    internal void SetProperty(PdfName key, IPdfPrimitive primitive);
    internal void SetProperty(string key, IPdfWrapper wrapper);
    internal static void SetProperty(PdfDictionary dictionary, string key, IPdfWrapper wrapper);
    internal static void SetProperty(PdfDictionary dictionary, string key, IPdfPrimitive primitive);
    internal void SetBoolean(string key, bool value);
    internal void SetNumber(string key, int value);
    internal void SetNumber(string key, float value);
    internal void SetArray(string key, IPdfPrimitive[] list);
    internal void SetDateTime(string key, DateTime dateTime);
    internal DateTime GetDateTime(PdfString dateTimeStringValue);
    internal void SetString(string key, string str);
    internal static void SetName(PdfDictionary dictionary, string key, string name);
    internal void SetName(string key, string name);
    internal void SetName(string key, string name, bool processSpecialCharacters);
    public sealed virtual bool get_Changed();
    private bool CheckChanges();
    public sealed virtual void FreezeChanges(object freezer);
    internal void Modify();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Syncfusion.Pdf.Primitives.PdfName : object {
    internal static string StringStartMark;
    public static string Delimiters;
    private static Char[] m_replacements;
    private string m_value;
    private ObjectStatus m_status;
    private bool m_isSaving;
    private int m_index;
    private int m_position;
    public string Value { get; public set; }
    public ObjectStatus Status { get; public set; }
    public bool IsSaving { get; public set; }
    public int ObjectCollectionIndex { get; public set; }
    public int Position { get; public set; }
    public IPdfPrimitive ClonedObject { get; }
    public PdfName(string value);
    public PdfName(Enum value);
    private static PdfName();
    public string get_Value();
    public void set_Value(string value);
    public sealed virtual ObjectStatus get_Status();
    public sealed virtual void set_Status(ObjectStatus value);
    public sealed virtual bool get_IsSaving();
    public sealed virtual void set_IsSaving(bool value);
    public sealed virtual int get_ObjectCollectionIndex();
    public sealed virtual void set_ObjectCollectionIndex(int value);
    public sealed virtual int get_Position();
    public sealed virtual void set_Position(int value);
    public sealed virtual IPdfPrimitive get_ClonedObject();
    private static string NormalizeValue(string value);
    private static string NormalizeValue(string value, char symbol);
    public static string EscapeString(string str);
    internal static string EncodeName(string value);
    internal static string DecodeName(string name);
    private static int ConvertToHex(int hex);
    public static PdfName op_Explicit(string str);
    public virtual string ToString();
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    public static bool op_Equality(PdfName name1, object name2);
    public static bool op_Inequality(PdfName name1, object name2);
    public static bool op_Equality(PdfName name1, PdfName name2);
    public static bool op_Inequality(PdfName name1, PdfName name2);
    public sealed virtual void Save(IPdfWriter writer);
    public sealed virtual IPdfPrimitive Clone(PdfCrossTable crossTable);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Syncfusion.Pdf.Primitives.PdfNull : object {
    private ObjectStatus m_status;
    private bool m_isSaving;
    private int m_index;
    private int m_position;
    public ObjectStatus Status { get; public set; }
    public bool IsSaving { get; public set; }
    public int ObjectCollectionIndex { get; public set; }
    public int Position { get; public set; }
    public IPdfPrimitive ClonedObject { get; }
    public sealed virtual ObjectStatus get_Status();
    public sealed virtual void set_Status(ObjectStatus value);
    public sealed virtual bool get_IsSaving();
    public sealed virtual void set_IsSaving(bool value);
    public sealed virtual int get_ObjectCollectionIndex();
    public sealed virtual void set_ObjectCollectionIndex(int value);
    public sealed virtual int get_Position();
    public sealed virtual void set_Position(int value);
    public sealed virtual IPdfPrimitive get_ClonedObject();
    public sealed virtual void Save(IPdfWriter writer);
    public sealed virtual IPdfPrimitive Clone(PdfCrossTable crossTable);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Syncfusion.Pdf.Primitives.PdfNumber : object {
    private int m_intValue;
    private float m_floatValue;
    private bool m_isInteger;
    private bool m_IsLong;
    private ObjectStatus m_status;
    private bool m_isSaving;
    private int m_index;
    private int m_position;
    private long m_longValue;
    internal long LongValue { get; internal set; }
    public int IntValue { get; public set; }
    public float FloatValue { get; public set; }
    public bool IsInteger { get; public set; }
    internal bool IsLong { get; internal set; }
    public ObjectStatus Status { get; public set; }
    public bool IsSaving { get; public set; }
    public int ObjectCollectionIndex { get; public set; }
    public int Position { get; public set; }
    public IPdfPrimitive ClonedObject { get; }
    internal PdfNumber(int value);
    internal PdfNumber(long value);
    internal PdfNumber(float value);
    internal PdfNumber(double value);
    internal long get_LongValue();
    internal void set_LongValue(long value);
    public int get_IntValue();
    public void set_IntValue(int value);
    public float get_FloatValue();
    public void set_FloatValue(float value);
    public bool get_IsInteger();
    public void set_IsInteger(bool value);
    internal bool get_IsLong();
    internal void set_IsLong(bool value);
    public sealed virtual ObjectStatus get_Status();
    public sealed virtual void set_Status(ObjectStatus value);
    public sealed virtual bool get_IsSaving();
    public sealed virtual void set_IsSaving(bool value);
    public sealed virtual int get_ObjectCollectionIndex();
    public sealed virtual void set_ObjectCollectionIndex(int value);
    public sealed virtual int get_Position();
    public sealed virtual void set_Position(int value);
    public sealed virtual IPdfPrimitive get_ClonedObject();
    public static string FloatToString(float number);
    public static float Min(float x, float y, float z);
    public static float Max(float x, float y, float z);
    public sealed virtual void Save(IPdfWriter writer);
    public sealed virtual IPdfPrimitive Clone(PdfCrossTable crossTable);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Syncfusion.Pdf.Primitives.PdfPair : ValueType {
    public PdfName Key;
    public IPdfPrimitive Value;
    internal PdfPair(PdfName key, IPdfPrimitive value);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Syncfusion.Pdf.Primitives.PdfReference : object {
    public long ObjNum;
    public int GenNum;
    private ObjectStatus m_status;
    private bool m_isSaving;
    private int m_index;
    private int m_position;
    private bool m_isDisposed;
    public ObjectStatus Status { get; public set; }
    public bool IsSaving { get; public set; }
    public int ObjectCollectionIndex { get; public set; }
    public int Position { get; public set; }
    public IPdfPrimitive ClonedObject { get; }
    internal bool IsDisposed { get; internal set; }
    public PdfReference(long objNum, int genNum);
    public PdfReference(string objNum, string genNum);
    public sealed virtual ObjectStatus get_Status();
    public sealed virtual void set_Status(ObjectStatus value);
    public sealed virtual bool get_IsSaving();
    public sealed virtual void set_IsSaving(bool value);
    public sealed virtual int get_ObjectCollectionIndex();
    public sealed virtual void set_ObjectCollectionIndex(int value);
    public sealed virtual int get_Position();
    public sealed virtual void set_Position(int value);
    public sealed virtual IPdfPrimitive get_ClonedObject();
    internal bool get_IsDisposed();
    internal void set_IsDisposed(bool value);
    public virtual string ToString();
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    private sealed virtual override IPdfPrimitive Syncfusion.Pdf.Primitives.IPdfPrimitive.Clone(PdfCrossTable crossTable);
    public static bool op_Equality(PdfReference ref1, PdfReference ref2);
    public static bool op_Inequality(PdfReference ref1, PdfReference ref2);
    public sealed virtual void Save(IPdfWriter writer);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Syncfusion.Pdf.Primitives.PdfReferenceHolder : object {
    private IPdfPrimitive m_object;
    private PdfCrossTable m_crossTable;
    private PdfReference m_reference;
    private int m_objectIndex;
    private ObjectStatus m_status;
    private bool m_isSaving;
    private int m_index;
    private int m_position;
    private static object m_lock;
    internal IPdfPrimitive Object { get; }
    internal int Index { get; }
    public PdfReference Reference { get; }
    public ObjectStatus Status { get; public set; }
    public bool IsSaving { get; public set; }
    public int ObjectCollectionIndex { get; public set; }
    public int Position { get; public set; }
    public IPdfPrimitive ClonedObject { get; }
    public PdfReferenceHolder(IPdfWrapper wrapper);
    public PdfReferenceHolder(IPdfPrimitive obj);
    internal PdfReferenceHolder(PdfReference reference, PdfCrossTable crossTable);
    private static PdfReferenceHolder();
    internal IPdfPrimitive get_Object();
    internal int get_Index();
    public PdfReference get_Reference();
    public sealed virtual ObjectStatus get_Status();
    public sealed virtual void set_Status(ObjectStatus value);
    public sealed virtual bool get_IsSaving();
    public sealed virtual void set_IsSaving(bool value);
    public sealed virtual int get_ObjectCollectionIndex();
    public sealed virtual void set_ObjectCollectionIndex(int value);
    public sealed virtual int get_Position();
    public sealed virtual void set_Position(int value);
    public sealed virtual IPdfPrimitive get_ClonedObject();
    public sealed virtual void Save(IPdfWriter writer);
    public sealed virtual IPdfPrimitive Clone(PdfCrossTable crossTable);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    public static bool op_Equality(PdfReferenceHolder rh1, PdfReferenceHolder rh2);
    public static bool op_Inequality(PdfReferenceHolder rh1, PdfReferenceHolder rh2);
    private IPdfPrimitive ObtainObject();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Syncfusion.Pdf.Primitives.PdfStream : PdfDictionary {
    private static string Prefix;
    private static string Suffix;
    private MemoryStream m_dataStream;
    private bool m_blockEncryption;
    private bool m_bDecrypted;
    private bool m_bCompress;
    private bool m_bEncrypted;
    private PdfStream m_clonedObject;
    internal bool isCustomQuality;
    internal bool isImageDualFilter;
    private long m_objNumber;
    private PdfCrossTable m_pdfCrosstable;
    internal MemoryStream InternalStream { get; internal set; }
    internal Byte[] Data { get; internal set; }
    internal bool Compress { get; internal set; }
    public IPdfPrimitive ClonedObject { get; }
    internal long ObjNumber { get; internal set; }
    internal PdfCrossTable PdfCrossTable { get; internal set; }
    public bool WasEncrypted { get; }
    public bool Decrypted { get; }
    internal PdfStream(PdfDictionary dictionary, Byte[] data);
    internal MemoryStream get_InternalStream();
    internal void set_InternalStream(MemoryStream value);
    internal Byte[] get_Data();
    internal void set_Data(Byte[] value);
    internal bool get_Compress();
    internal void set_Compress(bool value);
    public virtual IPdfPrimitive get_ClonedObject();
    internal long get_ObjNumber();
    internal void set_ObjNumber(long value);
    internal PdfCrossTable get_PdfCrossTable();
    internal void set_PdfCrossTable(PdfCrossTable value);
    public static Byte[] StreamToBytes(Stream stream);
    public static Byte[] StreamToBytes(Stream stream, bool writeWholeStream);
    public static Byte[] StreamToBigEndian(Stream stream);
    internal void Write(char symbol);
    internal void Write(string text);
    internal void Write(Byte[] data);
    internal void BlockEncryption();
    internal void Decompress();
    internal Byte[] GetDecompressedData();
    private Byte[] DecodeASCII85Stream(Byte[] data);
    private byte HexToDecimalConversion(char hex);
    private Byte[] Decode(Byte[] inputData);
    private Byte[] RemoveWhiteSpace(Byte[] data);
    internal void Clear();
    internal void Dispose();
    public virtual void Save(IPdfWriter writer);
    private void RemoveFilter();
    private Byte[] CompressStream();
    public virtual IPdfPrimitive Clone(PdfCrossTable crossTable);
    public sealed virtual bool get_WasEncrypted();
    public sealed virtual bool get_Decrypted();
    public sealed virtual void Decrypt(PdfEncryptor encryptor, long currObjNumber);
    private Byte[] Decompress(Byte[] data, string filter);
    private IPdfCompressor DetermineCompressor(string filter);
    private Byte[] PostProcess(Byte[] data, string filter);
    private void NormalizeFilter();
    private Byte[] CompressContent(IPdfWriter writer);
    internal void AddFilter(string filterName);
    private Byte[] EncryptContent(Byte[] data, IPdfWriter writer);
    private string GetFilterName(PdfDictionary dictionary);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Syncfusion.Pdf.Primitives.PdfString : object {
    public static string StringMark;
    public static string HexStringMark;
    private static string HexFormatPattern;
    private bool m_bHex;
    private string m_value;
    private Byte[] m_data;
    private bool m_bConverted;
    private ForceEncoding m_bForceEncoding;
    private bool m_bDecrypted;
    private ObjectStatus m_status;
    private bool m_isSaving;
    private int m_index;
    private int m_position;
    internal bool m_isParentDecrypted;
    private PdfCrossTable m_crossTable;
    private PdfString m_clonedObject;
    private bool m_isPacked;
    internal bool IsFormField;
    internal bool IsColorSpace;
    internal bool IsRGB;
    internal bool m_isHexString;
    private Byte[] m_encodedBytes;
    private bool isSaveWriter;
    public string Value { get; public set; }
    internal bool Hex { get; }
    internal bool IsPacked { get; internal set; }
    internal bool Converted { get; internal set; }
    internal ForceEncoding Encode { get; internal set; }
    public bool Decrypted { get; }
    internal Byte[] Bytes { get; }
    public ObjectStatus Status { get; public set; }
    public bool IsSaving { get; public set; }
    public int ObjectCollectionIndex { get; public set; }
    public int Position { get; public set; }
    internal bool IsParentDecrypted { get; internal set; }
    internal PdfCrossTable CrossTable { get; }
    public IPdfPrimitive ClonedObject { get; }
    internal Byte[] EncodedBytes { get; internal set; }
    private bool Syncfusion.Pdf.Security.IPdfDecryptable.WasEncrypted { get; }
    public PdfString(string value);
    public PdfString(string value, bool encrypted);
    public PdfString(Byte[] value);
    public string get_Value();
    public void set_Value(string value);
    internal bool get_Hex();
    internal bool get_IsPacked();
    internal void set_IsPacked(bool value);
    internal bool get_Converted();
    internal void set_Converted(bool value);
    internal ForceEncoding get_Encode();
    internal void set_Encode(ForceEncoding value);
    public sealed virtual bool get_Decrypted();
    internal Byte[] get_Bytes();
    public sealed virtual ObjectStatus get_Status();
    public sealed virtual void set_Status(ObjectStatus value);
    public sealed virtual bool get_IsSaving();
    public sealed virtual void set_IsSaving(bool value);
    public sealed virtual int get_ObjectCollectionIndex();
    public sealed virtual void set_ObjectCollectionIndex(int value);
    public sealed virtual int get_Position();
    public sealed virtual void set_Position(int value);
    internal bool get_IsParentDecrypted();
    internal void set_IsParentDecrypted(bool value);
    internal PdfCrossTable get_CrossTable();
    public sealed virtual IPdfPrimitive get_ClonedObject();
    internal Byte[] get_EncodedBytes();
    internal void set_EncodedBytes(Byte[] value);
    public static string ByteToString(Byte[] data);
    internal static string ByteToString(Byte[] data, int length);
    public static bool IsUnicode(string value);
    internal static bool IsContainsNonBrakingSpace(string value);
    internal static Byte[] ToEncode(UInt16[] data);
    internal static Byte[] ToEncode(int data);
    internal static Byte[] ToEncode(Char[] chars);
    public static Byte[] ToUnicodeArray(string value, bool bAddPrefix);
    public static string FromDate(DateTime dateTime);
    internal static int ByteCompare(PdfString str1, PdfString str2);
    public static PdfString op_Explicit(string str);
    internal Byte[] PdfEncode(PdfDocumentBase document);
    private static Byte[] GetAsciiBytes(string value);
    private Byte[] GetAsciiBytes(string value, Boolean& isAsciiBytes);
    internal static string BytesToHex(Byte[] bytes);
    private Byte[] EncryptIfNeeded(Byte[] data, PdfDocumentBase document);
    internal static Byte[] EscapeSymbols(Byte[] data);
    internal static Byte[] EscapeSymbols(Byte[] data, bool isFormField);
    public Byte[] HexToBytes(string value);
    private byte ParseHex(char c);
    private Byte[] HexDigitsToNumbers(List`1<byte> hexNumbers);
    private Byte[] ObtainBytes();
    private Byte[] GetBytes(bool unicode);
    public sealed virtual void Save(IPdfWriter writer);
    internal void ToHex();
    public sealed virtual IPdfPrimitive Clone(PdfCrossTable crossTable);
    internal static Byte[] StringToByte(string data);
    private void ProcessUnicodeWithPreamble(String& text, Encoding encoding);
    private sealed virtual override bool Syncfusion.Pdf.Security.IPdfDecryptable.get_WasEncrypted();
    public sealed virtual void Decrypt(PdfEncryptor encryptor, long currObjNumber);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Syncfusion.Pdf.Primitives.SavePdfPrimitiveEventArgs : EventArgs {
    private IPdfWriter m_writer;
    public IPdfWriter Writer { get; }
    public SavePdfPrimitiveEventArgs(IPdfWriter writer);
    public IPdfWriter get_Writer();
}
internal class Syncfusion.Pdf.Primitives.SavePdfPrimitiveEventHandler : MulticastDelegate {
    public SavePdfPrimitiveEventHandler(object object, IntPtr method);
    [NullableContextAttribute("1")]
public virtual void Invoke(object sender, SavePdfPrimitiveEventArgs ars);
    public virtual IAsyncResult BeginInvoke(object sender, SavePdfPrimitiveEventArgs ars, AsyncCallback callback, object object);
    public virtual void EndInvoke(IAsyncResult result);
}
public class Syncfusion.Pdf.ProgressEventArgs : object {
    private int m_total;
    private int m_current;
    private int m_pageProcessed;
    private int m_changedPages;
    public int Total { get; }
    public int Current { get; }
    public float Progress { get; }
    internal ProgressEventArgs(int current, int total);
    internal ProgressEventArgs(int current, int total, int processed);
    internal ProgressEventArgs(int current, int total, int processed, int changed);
    public int get_Total();
    public int get_Current();
    public float get_Progress();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Syncfusion.Pdf.ReadFontArray : object {
    private Byte[] nextValue_2;
    private Byte[] nextValue_4;
    private Byte[] m_data;
    private int m_pointer;
    public int Pointer { get; public set; }
    public Byte[] Data { get; public set; }
    public ReadFontArray(Byte[] data, int pointer);
    public ReadFontArray(Byte[] data);
    public int get_Pointer();
    public void set_Pointer(int value);
    public Byte[] get_Data();
    public void set_Data(Byte[] value);
    public byte getnextbyte();
    public int getnextUint32();
    public int getnextUint64();
    public string getnextUint32AsTag();
    public int getnextUint16();
    public ushort getnextUshort();
    public ulong getnextULong();
    public sbyte ReadChar();
    public long getLongDateTime();
    public float getFixed();
    public sbyte Read();
    public UInt32 getULong();
    public short getnextshort();
    public float Get2Dot14();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Syncfusion.Pdf.RectangularArrays : object {
    internal Int32[][] ReturnRectangularIntArray(int Size1, int Size2);
    internal String[][] ReturnRectangularStringArray(int Size1, int Size2);
    internal Single[][] ReturnRectangularFloatArray(int Size1, int Size2);
    internal Int16[][] ReturnRectangularShortArray(int Size1, int Size2);
    internal Byte[][] ReturnRectangularSbyteArray(int Size1, int Size2);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Syncfusion.Pdf.ReferenceFileSpecification : PdfFileSpecificationBase {
    private string m_fileName;
    private PdfFilePathType m_path;
    public string FileName { get; public set; }
    public ReferenceFileSpecification(string fileName, PdfFilePathType path);
    internal ReferenceFileSpecification(string fileName);
    public virtual string get_FileName();
    public virtual void set_FileName(string value);
    protected virtual void Save();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Syncfusion.Pdf.RemoveUnusedResources : object {
    private HashSet`1<PdfName> m_colorSpaces;
    private HashSet`1<PdfName> m_xObject;
    private HashSet`1<PdfName> m_fonts;
    private HashSet`1<PdfName> m_patterns;
    private bool ignoreUnknownColorSpace;
    private string m_currrentFont;
    internal HashSet`1<PdfName> ColorSpaces { get; internal set; }
    internal HashSet`1<PdfName> XObjects { get; internal set; }
    internal HashSet`1<PdfName> Fonts { get; internal set; }
    internal HashSet`1<PdfName> Patterns { get; internal set; }
    internal HashSet`1<PdfName> get_ColorSpaces();
    internal void set_ColorSpaces(HashSet`1<PdfName> value);
    internal HashSet`1<PdfName> get_XObjects();
    internal void set_XObjects(HashSet`1<PdfName> value);
    internal HashSet`1<PdfName> get_Fonts();
    internal void set_Fonts(HashSet`1<PdfName> value);
    internal HashSet`1<PdfName> get_Patterns();
    internal void set_Patterns(HashSet`1<PdfName> value);
    internal PdfDictionary RemoveUnusedResource(PdfRecordCollection recordCollection, PdfDictionary resources);
    private void RenderFont(String[] fontElements);
    private string FindOperator(int token);
    internal PdfDictionary CleanUp(PdfDictionary resourceDic);
    private void CleanUpResources(PdfDictionary resourcesDict, HashSet`1<PdfName> usedResources);
    private PdfDictionary CopyResources(PdfDictionary resourcesDict);
    private PdfDictionary CopyDictionary(PdfDictionary dict);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Syncfusion.Pdf.RenderedString : object {
    private string m_text;
    private Dictionary`2<int, int> m_indexAndWidths;
    internal string Text { get; internal set; }
    internal Dictionary`2<int, int> IndexAndWidths { get; internal set; }
    internal string get_Text();
    internal void set_Text(string value);
    internal Dictionary`2<int, int> get_IndexAndWidths();
    internal void set_IndexAndWidths(Dictionary`2<int, int> value);
}
public enum Syncfusion.Pdf.ScopeType : Enum {
    public int value__;
    public static ScopeType Row;
    public static ScopeType Column;
    public static ScopeType Both;
    public static ScopeType None;
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class Syncfusion.Pdf.Security.Aes : object {
    private int Nb;
    private int Nk;
    private int Nr;
    private Byte[] key;
    private Byte[0...,0...] Sbox;
    private Byte[0...,0...] iSbox;
    private Byte[0...,0...] w;
    private Byte[0...,0...] Rcon;
    private Byte[0...,0...] State;
    private KeySize mKeySize;
    public Aes(KeySize keySize, Byte[] keyBytes);
    private void Initialize();
    public int Cipher(Byte[] input, Byte[] output, int outOff);
    public int InvCipher(Byte[] input, Byte[] output, int outOff);
    private void SetNbNkNr(KeySize keySize);
    private void BuildSbox();
    private void BuildInvSbox();
    private void BuildRcon();
    private void AddRoundKey(int round);
    private void SubBytes();
    private void InvSubBytes();
    private void ShiftRows();
    private void InvShiftRows();
    private void MixColumns();
    private void InvMixColumns();
    private static byte gfmultby01(byte b);
    private static byte gfmultby02(byte b);
    private static byte gfmultby03(byte b);
    private static byte gfmultby09(byte b);
    private static byte gfmultby0b(byte b);
    private static byte gfmultby0d(byte b);
    private static byte gfmultby0e(byte b);
    private void KeyExpansion();
    private Byte[] SubWord(Byte[] word);
    private Byte[] RotWord(Byte[] word);
    public void Dump();
    public string DumpKey();
    public string DumpTwoByTwo(Byte[0...,0...] a);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Syncfusion.Pdf.Security.AesCipher : object {
    private BufferedCipher m_bp;
    public AesCipher(bool isEncryption, Byte[] key, Byte[] iv);
    internal Byte[] Update(Byte[] inp, int inpOff, int inpLen);
    internal Byte[] DoFinal();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Syncfusion.Pdf.Security.AesCipherNoPadding : object {
    private ICipher m_cbc;
    public AesCipherNoPadding(bool isEncryption, Byte[] key);
    internal Byte[] ProcessBlock(Byte[] inp, int inpOff, int inpLen);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Syncfusion.Pdf.Security.AesEncryptor : object {
    private int c_blockSize;
    private Aes m_aes;
    private Byte[] m_cbcV;
    private Byte[] m_nextBlockV;
    private int m_ivOff;
    private Byte[] m_buf;
    private bool m_isEncryption;
    internal AesEncryptor(Byte[] key, Byte[] iv, bool isEncryption);
    internal void ProcessBytes(Byte[] input, int inOff, int length, Byte[] output, int outOff);
    internal int Finalize(Byte[] output);
    internal int GetBlockSize(int length);
    internal int CalculateOutputSize();
    private int ProcessBlock(Byte[] input, int inOff, Byte[] outBytes, int outOff);
    private static int AddPadding(Byte[] input, int inOff);
    private static int CheckPadding(Byte[] input);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Syncfusion.Pdf.Security.AesEngine : object {
    private static Byte[] S;
    private static Byte[] Sinv;
    private static Byte[] rcon;
    private static UInt32[] R0;
    private static UInt32[] R1;
    private static UInt32[] R2;
    private static UInt32[] R3;
    private static UInt32[] Rinv0;
    private static UInt32[] Rinv1;
    private static UInt32[] Rinv2;
    private static UInt32[] Rinv3;
    private static UInt32 mix1;
    private static UInt32 mix2;
    private static UInt32 mix3;
    private int m_rounds;
    private UInt32[][] m_key;
    private UInt32 C0;
    private UInt32 C1;
    private UInt32 C2;
    private UInt32 C3;
    private bool m_isEncryption;
    private static int m_blockSize;
    public string AlgorithmName { get; }
    public bool IsBlock { get; }
    public int BlockSize { get; }
    private static AesEngine();
    public sealed virtual void Initialize(bool isEncryption, ICipherParam parameters);
    private UInt32 Shift(UInt32 r, int shift);
    private UInt32 mulX(UInt32 x);
    private UInt32 Inv_Mcol(UInt32 x);
    private UInt32 SubWord(UInt32 x);
    private UInt32[][] GenerateKey(Byte[] key, bool isEncryption);
    public sealed virtual string get_AlgorithmName();
    public sealed virtual bool get_IsBlock();
    public sealed virtual int get_BlockSize();
    public sealed virtual int ProcessBlock(Byte[] input, int inOff, Byte[] output, int outOff);
    private void EncryptBlock();
    private void DecryptBlock();
    public sealed virtual void Reset();
    private void UnPackBlock(Byte[] bytes, int off);
    private void PackBlock(Byte[] bytes, int off);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Syncfusion.Pdf.Security.Algorithms : Asn1Encode {
    private Asn1Sequence m_sequence;
    private DerObjectID m_objectID;
    private Asn1Encode m_parameters;
    private bool m_parametersDefined;
    public DerObjectID ObjectID { get; }
    public Asn1Encode Parameters { get; }
    internal Algorithms(Asn1Identifier id, Asn1 asn1);
    internal Algorithms(DerObjectID objectID);
    internal Algorithms(string objectID);
    internal Algorithms(DerObjectID objectID, Asn1Encode parameters);
    internal Algorithms(Asn1Sequence sequence);
    internal static Algorithms GetAlgorithms(object obj);
    public virtual DerObjectID get_ObjectID();
    public Asn1Encode get_Parameters();
    internal Byte[] AsnEncode();
    public virtual Asn1 GetAsn1();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal abstract class Syncfusion.Pdf.Security.Asn1 : Asn1Encode {
    private Asn1UniversalTags m_tag;
    private MemoryStream m_stream;
    internal Asn1(Asn1UniversalTags tag);
    internal static Asn1 FromByteArray(Byte[] data);
    internal static Asn1 FromStream(Stream stream);
    public sealed virtual Asn1 GetAsn1();
    internal bool Asn1Equals(Asn1 obj);
    internal int GetAsn1Hash();
    internal Byte[] Asn1Encode(Byte[] bytes);
    internal Byte[] GetDerEncoded();
    internal abstract virtual void Encode(DerStream derOut);
    protected abstract virtual bool IsEquals(Asn1 asn1Object);
    public abstract virtual int GetHashCode();
    private void Write(int length);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Syncfusion.Pdf.Security.Asn1Boolean : Asn1 {
    private bool m_value;
    public Asn1Boolean(bool value);
    public Asn1Boolean(Byte[] bytes);
    private Byte[] ToArray();
    public Byte[] AsnEncode();
    protected virtual bool IsEquals(Asn1 asn1Object);
    public virtual int GetHashCode();
    internal virtual void Encode(DerStream derOut);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Syncfusion.Pdf.Security.Asn1Constants : object {
    internal static string BerSequence;
    internal static string DerSequence;
    internal static string Sequence;
    internal static string Null;
    internal static string Empty;
    internal static string Der;
    internal static string Ber;
    internal static string DesEde;
    internal static string Des;
    internal static string RC2;
    internal static string RSA;
    internal static string PKCS7;
    internal static void UInt32ToBe(UInt32 n, Byte[] bs, int off);
    internal static UInt32 BeToUInt32(Byte[] bs, int off);
    internal static Byte[] UInt64ToBe(ulong n);
    internal static void UInt32ToBe(UInt32 n, Byte[] bs);
    internal static void UInt64ToBe(ulong n, Byte[] bs);
    internal static void UInt64ToBe(ulong n, Byte[] bs, int off);
    internal static UInt32 BeToUInt32(Byte[] bs);
    internal static Byte[] UInt32ToLe(UInt32 n);
    internal static void UInt32ToLe(UInt32 n, Byte[] bs);
    internal static void UInt32ToLe(UInt32 n, Byte[] bs, int off);
    internal static Byte[] UInt32ToLe(UInt32[] ns);
    internal static void UInt32ToLe(UInt32[] ns, Byte[] bs, int off);
    internal static ushort LeToUInt16(Byte[] bs);
    internal static ushort LeToUInt16(Byte[] bs, int off);
    internal static UInt32 LeToUInt32(Byte[] bs);
    internal static UInt32 LeToUInt32(Byte[] bs, int off);
    internal static void LeToUInt32(Byte[] bs, int off, UInt32[] ns);
    internal static ulong BeToUInt64(Byte[] bs);
    internal static ulong BeToUInt64(Byte[] bs, int off);
    public static bool AreEqual(Byte[] a, Byte[] b);
    private static bool HaveSameContents(Byte[] a, Byte[] b);
    public static int GetHashCode(Byte[] data);
    public static Byte[] Clone(Byte[] data);
    public static Int32[] Clone(Int32[] data);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Syncfusion.Pdf.Security.Asn1DerStream : DerStream {
    private MemoryStream m_stream;
    public Asn1DerStream(Stream stream);
    internal Byte[] ParseTimeStamp(Asn1 encodedObject);
    internal Byte[] ParseTimeStampToken(Asn1 encodedObject);
    private void Write(Byte[] buffer);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal abstract class Syncfusion.Pdf.Security.Asn1Encode : object {
    public abstract virtual Asn1 GetAsn1();
    internal Byte[] GetEncoded();
    internal Byte[] GetEncoded(string encoding);
    public Byte[] GetDerEncoded();
    public sealed virtual int GetHashCode();
    public sealed virtual bool Equals(object obj);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[DefaultMemberAttribute("Item")]
internal class Syncfusion.Pdf.Security.Asn1EncodeCollection : object {
    private List`1<object> m_encodableObjects;
    internal Asn1Encode Item { get; }
    internal int Count { get; }
    internal Asn1EncodeCollection(Asn1Encode[] vector);
    internal Asn1Encode get_Item(int index);
    internal int get_Count();
    internal static Asn1EncodeCollection FromEnumerable(IEnumerable e);
    internal void Add(Asn1Encode[] objs);
    public sealed virtual IEnumerator GetEnumerator();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Syncfusion.Pdf.Security.Asn1Identifier : Asn1 {
    private char m_tokenSeparator;
    private string m_id;
    private Byte[] m_body;
    private MemoryStream m_stream;
    internal Byte[] Body { get; }
    public Asn1Identifier(string id);
    public Asn1Identifier(Byte[] bytes);
    public Asn1Identifier GetIdentifier(object obj);
    internal Byte[] get_Body();
    private Byte[] ToArray();
    private void AppendField(long value, Stream stream);
    private void AppendField(string value, Stream stream);
    internal Byte[] Asn1Encode();
    protected virtual bool IsEquals(Asn1 asn1Object);
    public virtual int GetHashCode();
    internal virtual void Encode(DerStream derStr);
    private string CreateIdentifier(Byte[] bytes);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Syncfusion.Pdf.Security.Asn1Integer : Asn1 {
    private long m_value;
    private Byte[] m_bytes;
    public Asn1Integer(long value);
    public Asn1Integer(Byte[] value);
    private Byte[] ToArray();
    public Byte[] AsnEncode();
    protected virtual bool IsEquals(Asn1 asn1Object);
    public virtual int GetHashCode();
    internal virtual void Encode(DerStream stream);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Syncfusion.Pdf.Security.Asn1LengthStream : BaseStream {
    private int m_byte;
    private bool m_isEndOfFile;
    internal Asn1LengthStream(Stream stream, int limit);
    internal void SetEndOfFileOnStart(bool isEOF);
    private bool CheckEndOfFile();
    public virtual int Read(Byte[] buffer, int offset, int count);
    public virtual int ReadByte();
    private int RequireByte();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal abstract class Syncfusion.Pdf.Security.Asn1Null : Asn1 {
    internal static Asn1Null GetInstance();
    private Byte[] ToArray();
    internal Byte[] AsnEncode();
    public virtual string ToString();
    internal virtual void Encode(DerStream derOut);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Syncfusion.Pdf.Security.Asn1Octet : Asn1 {
    internal Byte[] m_value;
    internal IAsn1Octet Parser { get; }
    internal Asn1Octet(Byte[] value);
    internal Asn1Octet(Asn1Encode obj);
    internal IAsn1Octet get_Parser();
    public sealed virtual Stream GetOctetStream();
    internal virtual Byte[] GetOctets();
    public virtual int GetHashCode();
    protected virtual bool IsEquals(Asn1 asn1Object);
    public virtual string ToString();
    internal Byte[] AsnEncode();
    internal virtual void Encode(DerStream stream);
    internal static Asn1Octet GetOctetString(Asn1Tag tag, bool isExplicit);
    internal static Asn1Octet GetOctetString(object obj);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Syncfusion.Pdf.Security.Asn1Parser : object {
    private Stream m_stream;
    private int m_limit;
    private Byte[][] m_buffers;
    internal Asn1Parser(Stream stream);
    public Asn1Parser(Stream stream, int limit);
    internal Asn1Parser(Byte[] encoding);
    internal IAsn1 ReadIndefinite(int tagValue);
    internal IAsn1 ReadImplicit(bool constructed, int tagNumber);
    internal Asn1 ReadTaggedObject(bool constructed, int tagNumber);
    public virtual IAsn1 ReadObject();
    private void SetEndOfFile(bool enabled);
    internal Asn1EncodeCollection ReadCollection();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[DefaultMemberAttribute("Item")]
internal class Syncfusion.Pdf.Security.Asn1Sequence : Asn1 {
    private List`1<object> m_objects;
    internal IList Objects { get; }
    internal Asn1Encode Item { get; }
    internal IAsn1Collection Parser { get; }
    internal int Count { get; }
    public Asn1Sequence(Asn1Encode[] asn1EncodableArray);
    public Asn1Sequence(List`1<Asn1> sequence);
    internal Asn1Sequence(Asn1EncodeCollection collection);
    internal Asn1Sequence(int capacity);
    internal IList get_Objects();
    internal virtual Asn1Encode get_Item(int index);
    internal virtual IAsn1Collection get_Parser();
    internal virtual int get_Count();
    internal static Asn1Sequence GetSequence(object obj);
    internal static Asn1Sequence GetSequence(Asn1Tag obj, bool explicitly);
    public virtual IEnumerator GetEnumerator();
    public virtual int GetHashCode();
    protected virtual bool IsEquals(Asn1 asn1Object);
    private Asn1Encode GetCurrentObject(IEnumerator e);
    protected internal void AddObject(Asn1Encode obj);
    public virtual string ToString();
    internal string ToString(IEnumerable e);
    private Byte[] ToArray();
    internal virtual void Encode(DerStream derOut);
    internal Byte[] AsnEncode();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Syncfusion.Pdf.Security.Asn1SequenceCollection : Asn1Encode {
    private DerObjectID m_id;
    private Asn1 m_value;
    private Asn1Set m_attributes;
    internal DerObjectID ID { get; }
    internal Asn1 Value { get; }
    internal Asn1Set Attributes { get; }
    internal Asn1SequenceCollection(Asn1Sequence sequence);
    internal DerObjectID get_ID();
    internal Asn1 get_Value();
    internal Asn1Set get_Attributes();
    public virtual Asn1 GetAsn1();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[DefaultMemberAttribute("Item")]
internal class Syncfusion.Pdf.Security.Asn1Set : Asn1 {
    private List`1<object> m_objects;
    internal object Objects { get; }
    internal Asn1Encode Item { get; }
    internal int Count { get; }
    internal IAsn1SetHelper Parser { get; }
    protected internal Asn1Set(int capacity);
    internal object get_Objects();
    internal Asn1Encode get_Item(int index);
    internal int get_Count();
    internal IAsn1SetHelper get_Parser();
    internal Asn1Encode[] ToArray();
    public virtual int GetHashCode();
    protected virtual bool IsEquals(Asn1 asn1Object);
    private Asn1Encode GetCurrentSet(IEnumerator e);
    private bool LessThanOrEqual(Byte[] a, Byte[] b);
    protected internal void AddObject(Asn1Encode obj);
    public virtual string ToString();
    internal virtual void Encode(DerStream derOut);
    public static Asn1Set GetAsn1Set(object obj);
    public static Asn1Set GetAsn1Set(Asn1Tag taggedObject, bool isExplicit);
    public virtual IEnumerator GetEnumerator();
    protected internal void SortObjects();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Syncfusion.Pdf.Security.Asn1Stream : object {
    private int m_limit;
    private Byte[][] m_buffers;
    private Stream m_stream;
    internal Asn1Stream(Stream stream);
    public Asn1Stream(Stream stream, int limit);
    public Asn1Stream(Byte[] input);
    private Asn1 BuildObject(int tag, int tagNumber, int length);
    internal Asn1EncodeCollection GetEncodableCollection();
    internal virtual Asn1EncodeCollection GetDerEncodableCollection(Asn1StreamHelper stream);
    internal virtual DerSequence CreateDerSequence(Asn1StreamHelper stream);
    internal virtual DerSet CreateDerSet(Asn1StreamHelper stream);
    internal Asn1 ReadAsn1();
    internal static int GetLimit(Stream input);
    internal static int ReadTagNumber(Stream stream, int tagNumber);
    internal static int GetLength(Stream stream, int limit);
    internal static Byte[] GetBytes(Asn1StreamHelper stream, Byte[][] buffers);
    internal static Asn1 GetPrimitiveObject(int tagNumber, Asn1StreamHelper stream, Byte[][] buffers);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Syncfusion.Pdf.Security.Asn1StreamHelper : BaseStream {
    private Byte[] m_empty;
    private int m_originalLength;
    private int m_remaining;
    internal int Remaining { get; }
    internal Asn1StreamHelper(Stream stream, int length);
    internal int get_Remaining();
    public virtual int ReadByte();
    public virtual int Read(Byte[] bytes, int offset, int length);
    internal void ReadAll(Byte[] bytes);
    internal Byte[] ToArray();
    private int Read(Stream stream, Byte[] bytes, int offset, int length);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Syncfusion.Pdf.Security.Asn1Tag : Asn1 {
    internal int m_tagNumber;
    internal bool MIsExplicit;
    internal Asn1Encode m_object;
    public int TagNumber { get; }
    internal bool IsExplicit { get; }
    internal bool IsEmpty { get; }
    protected Asn1Tag(int tagNumber, Asn1Encode asn1Encode);
    protected Asn1Tag(bool isExplicit, int tagNumber, Asn1Encode asn1Encode);
    public sealed virtual int get_TagNumber();
    internal bool get_IsExplicit();
    internal bool get_IsEmpty();
    internal static Asn1Tag GetTag(Asn1Tag tag, bool isExplicit);
    internal static Asn1Tag GetTag(object obj);
    protected virtual bool IsEquals(Asn1 asn1Object);
    public virtual int GetHashCode();
    internal Asn1 GetObject();
    public sealed virtual IAsn1 GetParser(int tagNumber, bool isExplicit);
    public virtual string ToString();
    internal virtual void Encode(DerStream stream);
}
internal class Syncfusion.Pdf.Security.Asn1Tags : object {
    public static int Boolean;
    public static int Integer;
    public static int BitString;
    public static int OctetString;
    public static int Null;
    public static int ObjectIdentifier;
    public static int External;
    public static int Enumerated;
    public static int Sequence;
    public static int SequenceOf;
    public static int Set;
    public static int SetOf;
    public static int NumericString;
    public static int PrintableString;
    public static int TeleText;
    public static int VideotexString;
    public static int AsciiString;
    public static int UtcTime;
    public static int GeneralizedTime;
    public static int GraphicString;
    public static int VisibleString;
    public static int GeneralString;
    public static int UniversalString;
    public static int BmpString;
    public static int Utf8String;
    public static int Constructed;
    public static int Application;
    public static int Tagged;
}
[FlagsAttribute]
internal enum Syncfusion.Pdf.Security.Asn1UniversalTags : Enum {
    public int value__;
    public static Asn1UniversalTags ReservedBER;
    public static Asn1UniversalTags Boolean;
    public static Asn1UniversalTags Integer;
    public static Asn1UniversalTags BitString;
    public static Asn1UniversalTags OctetString;
    public static Asn1UniversalTags Null;
    public static Asn1UniversalTags ObjectIdentifier;
    public static Asn1UniversalTags ObjectDescriptor;
    public static Asn1UniversalTags External;
    public static Asn1UniversalTags Real;
    public static Asn1UniversalTags Enumerated;
    public static Asn1UniversalTags EmbeddedPDV;
    public static Asn1UniversalTags UTF8String;
    public static Asn1UniversalTags RelativeOid;
    public static Asn1UniversalTags Sequence;
    public static Asn1UniversalTags Set;
    public static Asn1UniversalTags NumericString;
    public static Asn1UniversalTags PrintableString;
    public static Asn1UniversalTags TeletexString;
    public static Asn1UniversalTags VideotexString;
    public static Asn1UniversalTags IA5String;
    public static Asn1UniversalTags UTFTime;
    public static Asn1UniversalTags GeneralizedTime;
    public static Asn1UniversalTags GraphicsString;
    public static Asn1UniversalTags VisibleString;
    public static Asn1UniversalTags GeneralString;
    public static Asn1UniversalTags UniversalString;
    public static Asn1UniversalTags CharacterString;
    public static Asn1UniversalTags BMPString;
    public static Asn1UniversalTags Constructed;
    public static Asn1UniversalTags Application;
    public static Asn1UniversalTags Tagged;
}
internal class Syncfusion.Pdf.Security.AsyncPdfSignatureEventHandler : MulticastDelegate {
    public AsyncPdfSignatureEventHandler(object object, IntPtr method);
    [NullableContextAttribute("1")]
public virtual Task Invoke(object sender, PdfSignatureEventArgs ars);
    public virtual IAsyncResult BeginInvoke(object sender, PdfSignatureEventArgs ars, AsyncCallback callback, object object);
    public virtual Task EndInvoke(IAsyncResult result);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Syncfusion.Pdf.Security.BaseConstraints : Asn1Encode {
    private DerBoolean m_isCertificate;
    private DerInteger m_pathLength;
    internal Number PathLenConstraint { get; }
    internal bool IsCertificate { get; }
    private BaseConstraints(Asn1Sequence sequence);
    internal Number get_PathLenConstraint();
    internal bool get_IsCertificate();
    internal static BaseConstraints GetConstraints(object obj);
    public virtual Asn1 GetAsn1();
    public virtual string ToString();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal abstract class Syncfusion.Pdf.Security.BaseStream : Stream {
    protected Stream m_input;
    private int m_limit;
    private bool m_closed;
    internal int Remaining { get; }
    public bool CanRead { get; }
    public bool CanSeek { get; }
    public bool CanWrite { get; }
    public long Length { get; }
    public long Position { get; public set; }
    internal BaseStream(Stream stream, int limit);
    internal int get_Remaining();
    protected virtual void SetParentEndOfFileDetect(bool isDetect);
    public sealed virtual bool get_CanRead();
    public sealed virtual bool get_CanSeek();
    public sealed virtual bool get_CanWrite();
    public void Close();
    public sealed virtual void Flush();
    public sealed virtual long get_Length();
    public sealed virtual long get_Position();
    public sealed virtual void set_Position(long value);
    public virtual int Read(Byte[] buffer, int offset, int count);
    public sealed virtual long Seek(long offset, SeekOrigin origin);
    public sealed virtual void SetLength(long value);
    public sealed virtual void Write(Byte[] buffer, int offset, int count);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Syncfusion.Pdf.Security.BerOctet : DerOctet {
    private static int m_max;
    private IEnumerable m_octets;
    public BerOctet(Byte[] bytes);
    public BerOctet(IEnumerable octets);
    public BerOctet(Asn1 asn1);
    public BerOctet(Asn1Encode asn1);
    internal virtual Byte[] GetOctets();
    private IList GenerateOctets();
    internal virtual void Encode(DerStream stream);
    internal static BerOctet GetBerOctet(Asn1Sequence sequence);
    private static Byte[] GetBytes(IEnumerable octets);
    public sealed virtual IEnumerator GetEnumerator();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Syncfusion.Pdf.Security.BerOctetHelper : object {
    private Asn1Parser m_helper;
    internal BerOctetHelper(Asn1Parser helper);
    public sealed virtual Stream GetOctetStream();
    public sealed virtual Asn1 GetAsn1();
    internal Byte[] ReadAll(Stream stream);
    private void PipeAll(Stream input, Stream output);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Syncfusion.Pdf.Security.BerSequence : DerSequence {
    public static BerSequence Empty;
    internal BerSequence(Asn1Encode asn1);
    internal BerSequence(Asn1Encode[] collection);
    internal BerSequence(Asn1EncodeCollection collection);
    private static BerSequence();
    public static BerSequence FromCollection(Asn1EncodeCollection collection);
    internal virtual void Encode(DerStream stream);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Syncfusion.Pdf.Security.BerSequenceHelper : object {
    private Asn1Parser m_helper;
    internal BerSequenceHelper(Asn1Parser helper);
    public sealed virtual IAsn1 ReadObject();
    public sealed virtual Asn1 GetAsn1();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Syncfusion.Pdf.Security.BerTag : DerTag {
    internal BerTag(int tagNumber, Asn1Encode asn1);
    internal BerTag(bool IsExplicit, int tagNumber, Asn1Encode asn1);
    internal BerTag(int tagNumber);
    internal void Encode(DerStream stream);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Syncfusion.Pdf.Security.BerTagHelper : object {
    private bool m_isConstructed;
    private int m_tagNumber;
    private Asn1Parser m_helper;
    internal bool Constructed { get; }
    public int TagNumber { get; }
    internal BerTagHelper(bool isConstructed, int tagNumber, Asn1Parser helper);
    internal bool get_Constructed();
    public sealed virtual int get_TagNumber();
    public sealed virtual IAsn1 GetParser(int tagNumber, bool isExplicit);
    public sealed virtual Asn1 GetAsn1();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal abstract class Syncfusion.Pdf.Security.BigDigest : object {
    private int m_length;
    private Byte[] m_buf;
    private int m_bufOffset;
    private long m_byte1;
    private long m_byte2;
    private ulong m_h1;
    private ulong m_h2;
    private ulong m_h3;
    private ulong m_h4;
    private ulong m_h5;
    private ulong m_h6;
    private ulong m_h7;
    private ulong m_h8;
    private UInt64[] m_word;
    private int m_wordOffset;
    internal static UInt64[] K;
    internal ulong Header1 { get; internal set; }
    internal ulong Header2 { get; internal set; }
    internal ulong Header3 { get; internal set; }
    internal ulong Header4 { get; internal set; }
    internal ulong Header5 { get; internal set; }
    internal ulong Header6 { get; internal set; }
    internal ulong Header7 { get; internal set; }
    internal ulong Header8 { get; internal set; }
    public int ByteLength { get; }
    public string AlgorithmName { get; }
    public int MessageDigestSize { get; }
    internal BigDigest(BigDigest t);
    private static BigDigest();
    internal ulong get_Header1();
    internal void set_Header1(ulong value);
    internal ulong get_Header2();
    internal void set_Header2(ulong value);
    internal ulong get_Header3();
    internal void set_Header3(ulong value);
    internal ulong get_Header4();
    internal void set_Header4(ulong value);
    internal ulong get_Header5();
    internal void set_Header5(ulong value);
    internal ulong get_Header6();
    internal void set_Header6(ulong value);
    internal ulong get_Header7();
    internal void set_Header7(ulong value);
    internal ulong get_Header8();
    internal void set_Header8(ulong value);
    public sealed virtual void Update(byte input);
    public sealed virtual void Update(Byte[] bytes, int offset, int length);
    public sealed virtual void BlockUpdate(Byte[] bytes, int offset, int length);
    public void Finish();
    public virtual void Reset();
    internal void ProcessWord(Byte[] input, int inOff);
    private void ChangeByteCounts();
    internal void ProcessLength(long lowW, long hiW);
    internal void ProcessBlock();
    private static ulong Op1(ulong x, ulong y, ulong z);
    private static ulong Op2(ulong x, ulong y, ulong z);
    private static ulong Op3(ulong x);
    private static ulong Op4(ulong x);
    private static ulong Op5(ulong x);
    private static ulong Op6(ulong x);
    public sealed virtual int get_ByteLength();
    public abstract virtual string get_AlgorithmName();
    public abstract virtual int get_MessageDigestSize();
    public abstract virtual int DoFinal(Byte[] bytes, int offset);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Syncfusion.Pdf.Security.BufferedBlockPadding : BufferedCipher {
    private IPadding m_padding;
    internal BufferedBlockPadding(ICipher cipher, IPadding padding);
    internal BufferedBlockPadding(ICipher cipher);
    public virtual void Initialize(bool isEncryption, ICipherParam parameters);
    public virtual int GetOutputSize(int length);
    public virtual int GetUpdateOutputSize(int length);
    public virtual int ProcessByte(byte input, Byte[] output, int outOff);
    public virtual int ProcessBytes(Byte[] input, int inOffset, int length, Byte[] output, int outOffset);
    public virtual int DoFinal(Byte[] output, int outOff);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal abstract class Syncfusion.Pdf.Security.BufferedBlockPaddingBase : object {
    protected static Byte[] EmptyBuffer;
    public string AlgorithmName { get; }
    public int BlockSize { get; }
    private static BufferedBlockPaddingBase();
    public abstract virtual string get_AlgorithmName();
    public abstract virtual void Initialize(bool isEncryption, ICipherParam parameters);
    public abstract virtual int get_BlockSize();
    public abstract virtual int GetOutputSize(int inputLen);
    public abstract virtual int GetUpdateOutputSize(int inputLen);
    public abstract virtual Byte[] ProcessByte(byte input);
    public abstract virtual void Reset();
    public abstract virtual Byte[] ProcessBytes(Byte[] input, int inOff, int length);
    public abstract virtual Byte[] DoFinal();
    public abstract virtual Byte[] DoFinal(Byte[] input, int inOff, int length);
    public virtual int ProcessByte(byte input, Byte[] output, int outOff);
    public virtual Byte[] ProcessBytes(Byte[] input);
    public virtual int ProcessBytes(Byte[] input, Byte[] output, int outOff);
    public virtual int ProcessBytes(Byte[] input, int inOff, int length, Byte[] output, int outOff);
    public virtual Byte[] DoFinal(Byte[] input);
    public virtual int DoFinal(Byte[] output, int outOff);
    public virtual int DoFinal(Byte[] input, Byte[] output, int outOff);
    public virtual int DoFinal(Byte[] input, int inOff, int length, Byte[] output, int outOff);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Syncfusion.Pdf.Security.BufferedCipher : BufferedBlockPaddingBase {
    internal Byte[] m_bytes;
    internal int m_offset;
    internal bool m_isEncryption;
    internal ICipher m_cipher;
    public string AlgorithmName { get; }
    public int BlockSize { get; }
    internal BufferedCipher(ICipher cipher);
    public virtual string get_AlgorithmName();
    public virtual void Initialize(bool isEncryption, ICipherParam parameters);
    public virtual int get_BlockSize();
    public virtual int GetUpdateOutputSize(int length);
    public virtual int GetOutputSize(int length);
    public virtual int ProcessByte(byte input, Byte[] bytes, int offset);
    public virtual Byte[] ProcessByte(byte input);
    public virtual Byte[] ProcessBytes(Byte[] input, int offset, int length);
    public virtual int ProcessBytes(Byte[] input, int inOffset, int length, Byte[] output, int outOffset);
    public virtual Byte[] DoFinal();
    public virtual Byte[] DoFinal(Byte[] input, int inOffset, int inLength);
    public virtual int DoFinal(Byte[] bytes, int offset);
    public virtual void Reset();
}
internal abstract class Syncfusion.Pdf.Security.CerificateStatus : object {
    [NullableAttribute("1")]
public static CerificateStatus Good;
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Syncfusion.Pdf.Security.CertificateCollection : Asn1Encode {
    private SignedCertificateCollection m_certificates;
    private Algorithms m_id;
    private DerBitString m_signature;
    private RevocationListEntry[] m_revokedCertificates;
    internal Algorithms SignatureAlgorithm { get; }
    internal DerBitString Signature { get; }
    internal X509Time CurrentUpdate { get; }
    internal X509Time NextUpdate { get; }
    internal X509Name Issuer { get; }
    internal SignedCertificateCollection CertificateList { get; }
    internal RevocationListEntry[] RevokedCertificates { get; }
    private CertificateCollection(Asn1Sequence sequence);
    internal Algorithms get_SignatureAlgorithm();
    internal DerBitString get_Signature();
    internal X509Time get_CurrentUpdate();
    internal X509Time get_NextUpdate();
    internal X509Name get_Issuer();
    internal SignedCertificateCollection get_CertificateList();
    internal RevocationListEntry[] get_RevokedCertificates();
    internal static CertificateCollection GetCertificateList(object obj);
    internal bool IsRevoked(X509Certificate certificate);
    public virtual Asn1 GetAsn1();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Syncfusion.Pdf.Security.CertificateIdentity : object {
    internal static string Sha1;
    private CertificateIdentityHelper m_id;
    internal CertificateIdentityHelper ID { get; }
    internal CertificateIdentity(string hashAlgorithm, X509Certificate issuerCert, Number serialNumber);
    internal CertificateIdentityHelper get_ID();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Syncfusion.Pdf.Security.CertificateIdentityHelper : Asn1Encode {
    private Algorithms m_hash;
    private Asn1Octet m_issuerName;
    private Asn1Octet m_issuerKey;
    private DerInteger m_serialNumber;
    internal DerInteger SerialNumber { get; }
    internal CertificateIdentityHelper(Algorithms hashAlgorithm, Asn1Octet issuerNameHash, Asn1Octet issuerKeyHash, DerInteger serialNumber);
    private CertificateIdentityHelper(Asn1Sequence sequence);
    internal DerInteger get_SerialNumber();
    internal CertificateIdentityHelper GetCertificateIdentity(object obj);
    public virtual Asn1 GetAsn1();
}
internal enum Syncfusion.Pdf.Security.CertificateInclusion : Enum {
    public int value__;
    public static CertificateInclusion YES;
    public static CertificateInclusion NO;
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Syncfusion.Pdf.Security.CertificateInformation : Asn1Encode {
    private X509Name m_name;
    private DerInteger m_serialNumber;
    internal X509Name Name { get; }
    internal DerInteger SerialNumber { get; }
    internal CertificateInformation(Asn1Sequence sequence);
    internal static CertificateInformation GetCertificateInformation(object obj);
    internal X509Name get_Name();
    internal DerInteger get_SerialNumber();
    public virtual Asn1 GetAsn1();
}
internal enum Syncfusion.Pdf.Security.CertificateOption : Enum {
    public int value__;
    public static CertificateOption SIGNING_CERTIFICATE;
    public static CertificateOption WHOLE_CHAIN;
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Syncfusion.Pdf.Security.CertificateUtililty : object {
    internal PdfSignatureValidationResult result;
    internal string GetCrlUrl(X509Certificate certificate);
    internal string GetOcspUrl(X509Certificate certificate);
    private Asn1 GetExtensionValue(X509Certificate certificate, string id);
    private string GetStringFromGeneralName(Asn1 names);
    internal List`1<string> GetCrlUrls(X509Certificate certificate);
    private bool IsValidUrl(string url);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Syncfusion.Pdf.Security.CipherBlockChainingMode : object {
    private Byte[] m_bytes;
    private Byte[] m_cbcBytes;
    private Byte[] m_cbcNextBytes;
    private int m_size;
    private ICipher m_cipher;
    private bool m_isEncryption;
    internal ICipher Cipher { get; }
    public string AlgorithmName { get; }
    public bool IsBlock { get; }
    public int BlockSize { get; }
    internal CipherBlockChainingMode(ICipher cipher);
    internal ICipher get_Cipher();
    public sealed virtual string get_AlgorithmName();
    public sealed virtual bool get_IsBlock();
    public sealed virtual void Initialize(bool isEncryption, ICipherParam parameters);
    public sealed virtual int get_BlockSize();
    public sealed virtual int ProcessBlock(Byte[] inBytes, int inOffset, Byte[] outBytes, int outOffset);
    public sealed virtual void Reset();
    private int EncryptBlock(Byte[] inBytes, int inOffset, Byte[] outBytes, int outOffset);
    private int DecryptBlock(Byte[] inBytes, int inOffset, Byte[] outBytes, int outOffset);
}
internal abstract class Syncfusion.Pdf.Security.CipherParameter : object {
    private bool m_privateKey;
    internal bool IsPrivate { get; }
    protected CipherParameter(bool privateKey);
    internal bool get_IsPrivate();
    [NullableContextAttribute("1")]
public virtual bool Equals(object obj);
    [NullableContextAttribute("1")]
protected bool Equals(CipherParameter other);
    public virtual int GetHashCode();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Syncfusion.Pdf.Security.CipherUtils : object {
    private static Dictionary`2<string, string> m_algorithms;
    private static Dictionary`2<string, DerObjectID> m_ids;
    internal static ICollection Algorithms { get; }
    private static CipherUtils();
    internal static ICollection get_Algorithms();
    internal static IBufferedCipher GetCipher(string algorithm);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Syncfusion.Pdf.Security.CmsSignedDetails : object {
    private CryptographicMessageSyntaxBytes m_content;
    private SignedDetails m_signedCms;
    private ContentInformation m_contentInformation;
    private SignerInformationCollection m_signerInformationCollection;
    internal DerObjectID SignedContentType { get; }
    internal CryptographicMessageSyntaxBytes SignedContent { get; }
    internal CmsSignedDetails(ContentInformation sigData);
    internal DerObjectID get_SignedContentType();
    internal CryptographicMessageSyntaxBytes get_SignedContent();
    internal SignerInformationCollection GetSignerDetails();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Syncfusion.Pdf.Security.CmsSignerDetails : object {
    private SignerId m_id;
    private SignerDetails m_details;
    private Algorithms m_digestAlgorithm;
    private Algorithms m_encryptionAlgorithm;
    private Asn1Set m_signedSet;
    private Asn1Set m_unsignedSet;
    private CryptographicMessageSyntaxBytes m_bytes;
    private Byte[] m_signatureData;
    private DerObjectID m_contentType;
    private TimeStampElements m_signedTable;
    internal SignerId ID { get; }
    internal TimeStampElements SignedAttributes { get; }
    internal CmsSignerDetails(SignerDetails information, DerObjectID contentType, CryptographicMessageSyntaxBytes content);
    internal SignerId get_ID();
    internal TimeStampElements get_SignedAttributes();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Syncfusion.Pdf.Security.ContentInformation : Asn1Encode {
    private DerObjectID m_contentType;
    private Asn1Encode m_content;
    internal DerObjectID ContentType { get; }
    internal Asn1Encode Content { get; }
    private ContentInformation(Asn1Sequence sequence);
    internal static ContentInformation GetInformation(object obj);
    internal DerObjectID get_ContentType();
    internal Asn1Encode get_Content();
    public virtual Asn1 GetAsn1();
}
internal enum Syncfusion.Pdf.Security.CryptoAlgorithms : Enum {
    public int value__;
    public static CryptoAlgorithms CMS;
    public static CryptoAlgorithms CADES;
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Syncfusion.Pdf.Security.CryptographicMessageSyntaxBytes : object {
    private Byte[] m_bytes;
    internal CryptographicMessageSyntaxBytes(Byte[] bytes);
    internal virtual void Write(Stream stream);
}
public enum Syncfusion.Pdf.Security.CryptographicStandard : Enum {
    public int value__;
    public static CryptographicStandard CMS;
    public static CryptographicStandard CADES;
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal abstract class Syncfusion.Pdf.Security.CRYPTOIDs : object {
    private static string ECGOSTID;
    internal static DerObjectID IDR3410;
    internal static DerObjectID IDR3411X94;
    internal static DerObjectID IDR3410A;
    internal static DerObjectID IDR3410B;
    internal static DerObjectID IDR3410C;
    internal static DerObjectID IDR3410XA;
    internal static DerObjectID IDR3410XB;
    private static CRYPTOIDs();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Syncfusion.Pdf.Security.DataEncryption : object {
    internal static int m_blockSize;
    private static Int16[] ByteBit;
    private static Int32[] BigByte;
    private static Byte[] Pc1;
    private static Byte[] ToTrot;
    private static Byte[] Pc2;
    private static UInt32[] Sp1;
    private static UInt32[] Sp2;
    private static UInt32[] Sp3;
    private static UInt32[] Sp4;
    private static UInt32[] Sp5;
    private static UInt32[] Sp6;
    private static UInt32[] Sp7;
    private static UInt32[] Sp8;
    private Int32[] m_keys;
    internal Int32[] Keys { get; }
    public string AlgorithmName { get; }
    public bool IsBlock { get; }
    public int BlockSize { get; }
    private static DataEncryption();
    internal virtual Int32[] get_Keys();
    public virtual string get_AlgorithmName();
    public sealed virtual bool get_IsBlock();
    public virtual void Initialize(bool isEncryption, ICipherParam parameters);
    public virtual int get_BlockSize();
    public virtual int ProcessBlock(Byte[] inputBytes, int inOffset, Byte[] outputBytes, int outOffset);
    public virtual void Reset();
    protected static Int32[] GenerateWorkingKey(bool isEncrypt, Byte[] bytes);
    internal static void EncryptData(Int32[] keys, Byte[] inputBytes, int inOffset, Byte[] outBytes, int outOffset);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Syncfusion.Pdf.Security.DataEncryptionParameter : KeyParameter {
    internal static int DataEncryptionKeyLength;
    private static int DataEncryptionWeekKeysCount;
    private static Byte[] DataEncryptionWeekKeys;
    internal DataEncryptionParameter(Byte[] keys);
    internal DataEncryptionParameter(Byte[] keys, int offset, int length);
    private static DataEncryptionParameter();
    internal static bool CheckKey(Byte[] bytes, int offset);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Syncfusion.Pdf.Security.DerAsciiString : DerString {
    private string m_value;
    internal DerAsciiString(Byte[] bytes);
    internal DerAsciiString(string value);
    internal DerAsciiString(string value, bool isValid);
    public virtual string GetString();
    internal Byte[] AsnEncode();
    internal Byte[] GetOctets();
    internal virtual void Encode(DerStream stream);
    public virtual int GetHashCode();
    protected virtual bool IsEquals(Asn1 asn1);
    internal static DerAsciiString GetAsciiString(object obj);
    internal static DerAsciiString GetAsciiString(Asn1Tag tag, bool isExplicit);
    internal static bool IsAsciiString(string value);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Syncfusion.Pdf.Security.DerBitString : DerString {
    private static Char[] m_table;
    private Byte[] m_data;
    private int m_extra;
    internal int ExtraBits { get; }
    public int Value { get; }
    internal DerBitString(byte data, int pad);
    internal DerBitString(Byte[] data, int pad);
    internal DerBitString(Byte[] data);
    internal DerBitString(Asn1Encode asn1);
    private static DerBitString();
    internal int get_ExtraBits();
    public Byte[] GetBytes();
    public int get_Value();
    internal virtual void Encode(DerStream stream);
    public virtual int GetHashCode();
    protected virtual bool IsEquals(Asn1 asn1);
    public virtual string GetString();
    internal static DerBitString FromAsn1Octets(Byte[] bytes);
    internal static DerBitString GetString(object obj);
    internal static DerBitString GetString(Asn1Tag tag, bool isExplicit);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Syncfusion.Pdf.Security.DerBmpString : DerString {
    private string m_value;
    internal DerBmpString(Byte[] bytes);
    public virtual string GetString();
    protected virtual bool IsEquals(Asn1 asn1);
    internal virtual void Encode(DerStream stream);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Syncfusion.Pdf.Security.DerBoolean : Asn1 {
    private byte m_value;
    internal static DerBoolean False;
    internal static DerBoolean True;
    internal bool IsTrue { get; }
    internal DerBoolean(Byte[] bytes);
    private DerBoolean(bool value);
    private static DerBoolean();
    internal bool get_IsTrue();
    internal virtual void Encode(DerStream stream);
    protected virtual bool IsEquals(Asn1 asn1);
    public virtual int GetHashCode();
    public virtual string ToString();
    internal static DerBoolean GetBoolean(object obj);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Syncfusion.Pdf.Security.DerCatalogue : Asn1 {
    private Byte[] m_bytes;
    internal Number Value { get; }
    internal DerCatalogue(int value);
    internal DerCatalogue(Byte[] bytes);
    internal DerCatalogue GetEnumeration(object obj);
    internal Number get_Value();
    internal virtual void Encode(DerStream stream);
    protected virtual bool IsEquals(Asn1 asn1);
    public virtual int GetHashCode();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Syncfusion.Pdf.Security.DerInteger : Asn1 {
    internal Byte[] m_value;
    internal Number Value { get; }
    internal Number PositiveValue { get; }
    internal DerInteger(int value);
    internal DerInteger(Number value);
    internal DerInteger(Byte[] bytes);
    internal Number get_Value();
    internal Number get_PositiveValue();
    internal virtual void Encode(DerStream stream);
    public virtual int GetHashCode();
    protected virtual bool IsEquals(Asn1 asn1);
    public virtual string ToString();
    internal static DerInteger GetNumber(object obj);
    internal static DerInteger GetNumber(Asn1Tag tag, bool isExplicit);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Syncfusion.Pdf.Security.DerName : Asn1Encode {
    private Asn1Encode m_name;
    private int m_tagNumber;
    internal DerName(int tagNumber, Asn1Encode name);
    internal static DerName GetDerName(object name);
    internal static DerName GetDerName(Asn1Tag tag, bool isExplicit);
    public virtual string ToString();
    public virtual Asn1 GetAsn1();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Syncfusion.Pdf.Security.DerNames : Asn1Encode {
    private DerName[] m_names;
    private DerNames(Asn1Sequence sequence);
    internal static DerNames GetDerNames(object obj);
    public virtual Asn1 GetAsn1();
    public virtual string ToString();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Syncfusion.Pdf.Security.DerNull : Asn1Null {
    internal static DerNull Value;
    private Byte[] m_bytes;
    internal DerNull(int value);
    private static DerNull();
    internal virtual void Encode(DerStream stream);
    protected virtual bool IsEquals(Asn1 asn1);
    public virtual int GetHashCode();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Syncfusion.Pdf.Security.DerObjectID : Asn1 {
    private string m_id;
    private Byte[] m_bytes;
    private static DerObjectID[] m_objects;
    private static long m_limit;
    public string ID { get; }
    internal DerObjectID(string id);
    internal DerObjectID(DerObjectID id, string branchId);
    internal DerObjectID(Byte[] bytes);
    private static DerObjectID();
    public string get_ID();
    public virtual DerObjectID Branch(string id);
    private void WriteField(Stream stream, long fieldValue);
    private void WriteField(Stream stream, Number fieldValue);
    private void GetOutput(MemoryStream stream);
    internal Byte[] GetBytes();
    internal virtual void Encode(DerStream stream);
    public virtual int GetHashCode();
    protected virtual bool IsEquals(Asn1 asn1);
    public virtual string ToString();
    internal static DerObjectID GetID(object obj);
    internal static DerObjectID GetID(Asn1Tag obj, bool isExplicit);
    private static bool IsValidBranchID(string branchID, int start);
    private static bool IsValidIdentifier(string id);
    private static string GetID(Byte[] bytes);
    internal static DerObjectID FromOctetString(Byte[] bytes);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Syncfusion.Pdf.Security.DerOctet : Asn1Octet {
    internal DerOctet(Byte[] bytes);
    internal DerOctet(Asn1Encode asn1);
    internal virtual void Encode(DerStream stream);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Syncfusion.Pdf.Security.DerOctetHelper : object {
    private Asn1StreamHelper m_stream;
    internal DerOctetHelper(Asn1StreamHelper stream);
    public sealed virtual Stream GetOctetStream();
    public sealed virtual Asn1 GetAsn1();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Syncfusion.Pdf.Security.DerPrecision : Asn1Encode {
    private DerInteger m_seconds;
    private DerInteger m_milliSeconds;
    private DerInteger m_microSeconds;
    private int m_minMilliSeconds;
    private int m_maxMilliSeconds;
    private int m_minMicroSeconds;
    private int m_maxMicroSeconds;
    internal DerInteger Seconds { get; }
    internal DerInteger MilliSeconds { get; }
    internal DerInteger MicroSeconds { get; }
    internal DerPrecision(DerInteger seconds, DerInteger milliSeconds, DerInteger microSeconds);
    private DerPrecision(Asn1Sequence sequence);
    internal static DerPrecision GetDerPrecision(object obj);
    internal DerInteger get_Seconds();
    internal DerInteger get_MilliSeconds();
    internal DerInteger get_MicroSeconds();
    public virtual Asn1 GetAsn1();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Syncfusion.Pdf.Security.DerPrintableString : DerString {
    private string m_value;
    internal DerPrintableString(Byte[] bytes);
    internal DerPrintableString(string value);
    internal Byte[] Asn1Encode();
    public virtual string GetString();
    public Byte[] GetBytes();
    internal virtual void Encode(DerStream stream);
    protected virtual bool IsEquals(Asn1 asn1);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Syncfusion.Pdf.Security.DerSequence : Asn1Sequence {
    internal static DerSequence Empty;
    internal DerSequence(Asn1Encode asn1);
    internal DerSequence(Asn1Encode[] collection);
    internal DerSequence(Asn1EncodeCollection collection);
    private static DerSequence();
    internal static DerSequence FromCollection(Asn1EncodeCollection collection);
    internal virtual void Encode(DerStream outputStream);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Syncfusion.Pdf.Security.DerSequenceHelper : object {
    private Asn1Parser m_helper;
    internal DerSequenceHelper(Asn1Parser helper);
    public sealed virtual IAsn1 ReadObject();
    public sealed virtual Asn1 GetAsn1();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Syncfusion.Pdf.Security.DerSet : Asn1Set {
    internal static DerSet Empty;
    internal DerSet(Asn1Encode[] collection);
    internal DerSet(Asn1EncodeCollection collection);
    internal DerSet(Asn1EncodeCollection collection, bool isSort);
    private static DerSet();
    internal virtual void Encode(DerStream outputStream);
    internal static DerSet FromCollection(Asn1EncodeCollection collection);
    internal static DerSet FromCollection(Asn1EncodeCollection collection, bool isSort);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Syncfusion.Pdf.Security.DerSetHelper : object {
    private Asn1Parser m_helper;
    internal DerSetHelper(Asn1Parser helper);
    public sealed virtual IAsn1 ReadObject();
    public sealed virtual Asn1 GetAsn1();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Syncfusion.Pdf.Security.DerStream : object {
    internal Stream m_stream;
    internal DerStream(Stream stream);
    private void WriteLength(int length);
    internal void WriteEncoded(int tagNumber, Byte[] bytes);
    internal void WriteEncoded(int tagNumber, Byte[] bytes, int offset, int length);
    internal void WriteTag(int flag, int tagNumber);
    internal void WriteEncoded(int flag, int tagNumber, Byte[] bytes);
    public void Close();
    internal virtual void WriteObject(object obj);
}
internal abstract class Syncfusion.Pdf.Security.DerString : Asn1 {
    [NullableContextAttribute("1")]
public abstract virtual string GetString();
    [NullableContextAttribute("1")]
public virtual string ToString();
    public virtual int GetHashCode();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Syncfusion.Pdf.Security.DerTag : Asn1Tag {
    internal DerTag(int tagNumber, Asn1Encode asn1);
    internal DerTag(bool isExplicit, int tagNumber, Asn1Encode asn1);
    internal DerTag(int tagNumber);
    internal virtual void Encode(DerStream stream);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Syncfusion.Pdf.Security.DerTeleText : DerString {
    private string m_value;
    internal DerTeleText(Byte[] bytes);
    public DerTeleText(string value);
    public virtual string GetString();
    internal virtual void Encode(DerStream stream);
    public Byte[] GetBytes();
    protected virtual bool IsEquals(Asn1 asn1);
    private Byte[] ToByteArray(string value);
    internal static DerTeleText GetTeleText(object obj);
    internal static DerTeleText GetTeleText(Asn1Tag tag, bool isExplicit);
    internal static string FromByteArray(Byte[] bytes);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Syncfusion.Pdf.Security.DerUtcTime : Asn1 {
    private string m_time;
    internal string AdjustedTimeString { get; }
    internal string TimeString { get; }
    internal DerUtcTime(string time);
    internal DerUtcTime(DateTime time);
    internal DerUtcTime(Byte[] bytes);
    internal static DerUtcTime GetUtcTime(object obj);
    internal static DerUtcTime GetInstance(Asn1Tag tag, bool isExplicit);
    public DateTime ToDateTime();
    internal DateTime ToAdjustedDateTime();
    private Byte[] GetBytes();
    internal virtual void Encode(DerStream stream);
    protected virtual bool IsEquals(Asn1 asn1);
    public virtual int GetHashCode();
    public virtual string ToString();
    internal string get_AdjustedTimeString();
    internal string get_TimeString();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Syncfusion.Pdf.Security.DerUtf8String : DerString {
    private string m_value;
    internal DerUtf8String(Byte[] bytes);
    internal DerUtf8String(string value);
    internal static DerUtf8String GetUtf8String(object obj);
    internal static DerUtf8String GetUtf8String(Asn1Tag tag, bool isExplicit);
    public virtual string GetString();
    protected virtual bool IsEquals(Asn1 asn1);
    internal virtual void Encode(DerStream stream);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Syncfusion.Pdf.Security.DerVisibleString : DerString {
    private string m_value;
    internal DerVisibleString(Byte[] bytes);
    internal DerVisibleString(string str);
    internal static DerVisibleString GetDerVisibleString(object obj);
    public static DerVisibleString GetDerVisibleString(Asn1Tag obj, bool explicitly);
    public virtual string GetString();
    protected virtual bool IsEquals(Asn1 asn1Object);
    internal Byte[] GetOctets();
    internal virtual void Encode(DerStream derOut);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Syncfusion.Pdf.Security.DESedeAlgorithmParameter : DataEncryptionParameter {
    internal static int DesEdeKeyLength;
    internal DESedeAlgorithmParameter(Byte[] key);
    internal DESedeAlgorithmParameter(Byte[] key, int keyOff, int keyLen);
    private static Byte[] FixKey(Byte[] key, int keyOff, int keyLen);
    internal static bool CheckKey(Byte[] key, int offset, int length);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Syncfusion.Pdf.Security.DesEdeAlogorithm : DataEncryption {
    private Int32[] m_key1;
    private Int32[] m_Key2;
    private Int32[] m_Key3;
    private bool m_isEncryption;
    public int BlockSize { get; }
    public string AlgorithmName { get; }
    public virtual void Initialize(bool forEncryption, ICipherParam parameters);
    public virtual int ProcessBlock(Byte[] inputBytes, int inOffset, Byte[] outputBytes, int outOffset);
    public virtual void Reset();
    public virtual int get_BlockSize();
    public virtual string get_AlgorithmName();
}
public enum Syncfusion.Pdf.Security.DigestAlgorithm : Enum {
    public int value__;
    public static DigestAlgorithm SHA1;
    public static DigestAlgorithm SHA256;
    public static DigestAlgorithm SHA384;
    public static DigestAlgorithm SHA512;
    public static DigestAlgorithm RIPEMD160;
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Syncfusion.Pdf.Security.DigestAlgorithmGenerator : object {
    private static long m_count;
    private long m_stateCount;
    private long m_seedCount;
    private IMessageDigest m_digest;
    private Byte[] m_state;
    private Byte[] m_bytes;
    internal DigestAlgorithmGenerator(IMessageDigest digest);
    public sealed virtual void AddMaterial(Byte[] bytes);
    public sealed virtual void AddMaterial(long value);
    public sealed virtual void FillNextBytes(Byte[] bytes);
    public sealed virtual void FillNextBytes(Byte[] bytes, int index, int length);
    private void GenerateState();
    private void AddToCounter(long value);
    private void DigestUpdate(Byte[] bytes);
    private void DigestDoFinal(Byte[] bytes);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Syncfusion.Pdf.Security.DigestInformation : Asn1Encode {
    private Byte[] m_bytes;
    private Algorithms m_algorithms;
    internal DigestInformation(Algorithms algorithms, Byte[] bytes);
    private DigestInformation(Asn1Sequence sequence);
    internal static DigestInformation GetDigestInformation(object obj);
    public virtual Asn1 GetAsn1();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Syncfusion.Pdf.Security.DigitalIdentifiers : object {
    internal static string Pkcs7Data;
    internal static string Pkcs7SignedData;
    internal static string RSA;
    internal static string DSA;
    internal static string ECDSA;
    internal static string ContentType;
    internal static string MessageDigest;
    internal static string AaSigningCertificateV2;
    internal static string ABDERevocation;
    internal static string OcspNoCheckExtension;
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Syncfusion.Pdf.Security.DSASigner : object {
    private IMessageDigest algorithm;
    private IDSASigner signer;
    private bool isSign;
    public string AlgorithmName { get; }
    internal DSASigner(IDSASigner signer, IMessageDigest digest);
    public sealed virtual string get_AlgorithmName();
    public sealed virtual void Initialize(bool isSigning, ICipherParam parameters);
    public sealed virtual void Update(byte input);
    public sealed virtual void BlockUpdate(Byte[] input, int offset, int length);
    public sealed virtual Byte[] GenerateSignature();
    public sealed virtual bool ValidateSignature(Byte[] signature);
    public sealed virtual void Reset();
    private Byte[] DerEncode(Number number1, Number number2);
    private Number[] DerDecode(Byte[] encoding);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Syncfusion.Pdf.Security.ECBrainpoolAlgorithm : object {
    internal static Dictionary`2<DerObjectID, ECX9Params> curves;
    internal static Dictionary`2<string, DerObjectID> objectIds;
    internal static Dictionary`2<DerObjectID, string> curveNames;
    private static ECBrainpoolAlgorithm();
    private static void CreateCurve(string name, DerObjectID oid, ECX9Params id);
    public static ECX9Field GetByOid(DerObjectID oid);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Syncfusion.Pdf.Security.ECBrainpoolIDs : object {
    public static DerObjectID Algorithm;
    public static DerObjectID EllipticSign;
    public static DerObjectID EllipticSignSignWithSha1;
    public static DerObjectID EllipticSignWithRipeMD160;
    public static DerObjectID ECBrainpool;
    public static DerObjectID EllipticCurve;
    public static DerObjectID V1;
    public static DerObjectID BrainpoolP160R1;
    public static DerObjectID BrainpoolP160T1;
    public static DerObjectID BrainpoolP192R1;
    public static DerObjectID BrainpoolP192T1;
    public static DerObjectID BrainpoolP224R1;
    public static DerObjectID BrainpoolP224T1;
    public static DerObjectID BrainpoolP256R1;
    public static DerObjectID BrainpoolP256T1;
    public static DerObjectID BrainpoolP320R1;
    public static DerObjectID BrainpoolP320T1;
    public static DerObjectID BrainpoolP384R1;
    public static DerObjectID BrainpoolP384T1;
    public static DerObjectID BrainpoolP512R1;
    public static DerObjectID BrainpoolP512T1;
    private static ECBrainpoolIDs();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Syncfusion.Pdf.Security.ECCipherKeyParam : object {
    private CipherParameter m_publicKeyParameter;
    private CipherParameter m_privateKeyParameter;
    internal ECCipherKeyParam(CipherParameter publicKeyParameter, CipherParameter privateKeyParameter);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Syncfusion.Pdf.Security.ECConvertPoint : object {
    public static int GetByteLength(EllipticCurveElements field);
    public static Byte[] ConvetByte(Number numberS, int qLength);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Syncfusion.Pdf.Security.ECDSAAlgorithm : object {
    private EllipticKeyParam ecKey;
    private SecureRandomAlgorithm ecRandomNumber;
    public string AlgorithmName { get; }
    public sealed virtual string get_AlgorithmName();
    public sealed virtual void Initialize(bool isSigning, ICipherParam parameters);
    public sealed virtual Number[] GenerateSignature(Byte[] data);
    public sealed virtual bool ValidateSignature(Byte[] message, Number number3, Number number4);
    private Number CalculateMessageBit(Number number1, Byte[] data);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal abstract class Syncfusion.Pdf.Security.ECDSAOIDs : object {
    internal static string IDx962;
    public static DerObjectID X90IDx962_1;
    public static DerObjectID X90FieldID;
    public static DerObjectID X90UniqueID;
    public static DerObjectID X90RecordID;
    public static DerObjectID X90TNObjID;
    public static DerObjectID X90PPObjID;
    public static DerObjectID X90SignType;
    public static DerObjectID ECDSAwithSHA1;
    public static DerObjectID X90KeyType;
    public static DerObjectID IdECPublicKey;
    public static DerObjectID ECDSAwithSHA2;
    public static DerObjectID ECDSAwithSHA224;
    public static DerObjectID ECDSAwithSHA256;
    public static DerObjectID ECDSAwithSHA384;
    public static DerObjectID ECDSAwithSHA512;
    public static DerObjectID EllipticCurve;
    public static DerObjectID Curves;
    public static DerObjectID ECP163v1;
    public static DerObjectID ECP163v2;
    public static DerObjectID ECP163v3;
    public static DerObjectID ECP176w1;
    public static DerObjectID ECP191v1;
    public static DerObjectID ECP191v2;
    public static DerObjectID ECP191v3;
    public static DerObjectID ECP208w1;
    public static DerObjectID ECP239v1;
    public static DerObjectID ECP239v2;
    public static DerObjectID ECP239v3;
    public static DerObjectID ECP272w1;
    public static DerObjectID ECP304w1;
    public static DerObjectID ECP359v1;
    public static DerObjectID ECP368w1;
    public static DerObjectID ECP431r1;
    public static DerObjectID ECPC;
    public static DerObjectID ECPC192v1;
    public static DerObjectID ECPC192v2;
    public static DerObjectID ECPC192v3;
    public static DerObjectID ECPC239v1;
    public static DerObjectID ECPC239v2;
    public static DerObjectID ECPC239v3;
    public static DerObjectID ECPC256v1;
    private static ECDSAOIDs();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Syncfusion.Pdf.Security.ECGostAlgorithm : Asn1Encode {
    private DerObjectID m_publicKey;
    private DerObjectID m_digestParam;
    private DerObjectID m_encryptParam;
    public ECGostAlgorithm(DerObjectID m_publicKey, DerObjectID m_digestParam);
    public ECGostAlgorithm(DerObjectID m_publicKey, DerObjectID m_digestParam, DerObjectID m_encryptParam);
    public virtual Asn1 GetAsn1();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Syncfusion.Pdf.Security.ECMath : object {
    internal static EllipticPoint AddCurve(EllipticPoint PCurve, Number number, EllipticPoint QCurve, Number number1);
    private static EllipticPoint BlockFunction(EllipticPoint PCurve, Number number1, EllipticPoint QCurve, Number number2);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Syncfusion.Pdf.Security.ECNamedCurves : object {
    internal static Dictionary`2<string, DerObjectID> curvesObjIds;
    internal static Dictionary`2<DerObjectID, string> curveNames;
    private static ECNamedCurves();
    private static void CreateNamedCurves(string name, DerObjectID oid);
    public static ECX9Field GetByOid(DerObjectID oid);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal abstract class Syncfusion.Pdf.Security.ECPointBase : EllipticPoint {
    protected internal bool BasePoint { get; }
    protected internal ECPointBase(EllipticCurves curve, EllipticCurveElements pointX, EllipticCurveElements pointY, bool isCompress);
    protected internal abstract virtual bool get_BasePoint();
    internal virtual Byte[] Encoded(bool compressed);
    internal virtual EllipticPoint Multiply(Number number);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Syncfusion.Pdf.Security.ECPrivateKey : EllipticKeyParam {
    private Number number;
    public Number Key { get; }
    public ECPrivateKey(Number number, EllipticCurveParams parameters);
    public ECPrivateKey(string algorithm, Number number, EllipticCurveParams parameters);
    public ECPrivateKey(string algorithm, Number number, DerObjectID publicKeySet);
    public Number get_Key();
    public virtual bool Equals(object element);
    protected bool Equals(ECPrivateKey element);
    public virtual int GetHashCode();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Syncfusion.Pdf.Security.ECPrivateKeyParam : Asn1Encode {
    private Asn1Sequence sequence;
    public ECPrivateKeyParam(Asn1Sequence sequence);
    public Number GetKey();
    public virtual Asn1 GetAsn1();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Syncfusion.Pdf.Security.ECPublicKeyParam : EllipticKeyParam {
    private EllipticPoint pointQ;
    public EllipticPoint PointQ { get; }
    public ECPublicKeyParam(EllipticPoint pointQ, EllipticCurveParams parameters);
    public ECPublicKeyParam(string algorithm, EllipticPoint pointQ, EllipticCurveParams parameters);
    public ECPublicKeyParam(string algorithm, EllipticPoint pointQ, DerObjectID publicKeyParamSet);
    public EllipticPoint get_PointQ();
    public virtual bool Equals(object element);
    protected bool Equals(ECPublicKeyParam element);
    public virtual int GetHashCode();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal abstract class Syncfusion.Pdf.Security.ECSecIDs : object {
    public static DerObjectID EllipticCurve;
    public static DerObjectID ECSECG163k1;
    public static DerObjectID ECSECG163r1;
    public static DerObjectID ECSECG239k1;
    public static DerObjectID ECSECG113r1;
    public static DerObjectID ECSECG113r2;
    public static DerObjectID ECSECP112r1;
    public static DerObjectID ECSECP112r2;
    public static DerObjectID ECSECP160r1;
    public static DerObjectID ECSECP160k1;
    public static DerObjectID ECSECP256k1;
    public static DerObjectID ECSECG163r2;
    public static DerObjectID ECSECG283k1;
    public static DerObjectID ECSECG283r1;
    public static DerObjectID ECSECG131r1;
    public static DerObjectID ECSECG131r2;
    public static DerObjectID ECSECG193r1;
    public static DerObjectID ECSECG193r2;
    public static DerObjectID ECSECG233k1;
    public static DerObjectID ECSECG233r1;
    public static DerObjectID ECSECP128r1;
    public static DerObjectID ECSECP128r2;
    public static DerObjectID ECSECP160r2;
    public static DerObjectID ECSECP192k1;
    public static DerObjectID ECSECP224k1;
    public static DerObjectID ECSECP224r1;
    public static DerObjectID ECSECP384r1;
    public static DerObjectID ECSECP521r1;
    public static DerObjectID ECSECG409k1;
    public static DerObjectID ECSECG409r1;
    public static DerObjectID ECSECG571k1;
    public static DerObjectID ECSECG571r1;
    public static DerObjectID ECSECP192r1;
    public static DerObjectID ECSECP256r1;
    private static ECSecIDs();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Syncfusion.Pdf.Security.ECTanFunction : object {
    private static Number degOne;
    private static Number degTwo;
    private static Number degThree;
    private static Number mFour;
    public static sbyte WidthValue;
    public static sbyte Power2Width;
    public static ITanuElement[] AlphaZeo;
    public static SByte[][] AlphaZeroT;
    public static ITanuElement[] AlphaOne;
    public static SByte[][] AlphaOneT;
    private static ECTanFunction();
    public static Number Norm(sbyte byteMu, ITanuElement lambdaValue);
    public static ITanuElement Round(LargeDecimal lambda0, LargeDecimal lambda1, sbyte byteMu);
    public static LargeDecimal DivideByN(Number numberA, Number numberS, Number numberVM, sbyte a, int m, int c);
    public static Finite2MPoint GetTanU(Finite2MPoint pointP);
    public static sbyte FindMU(Field2MCurves curve);
    public static Number[] TraceLC(sbyte byteMu, int numberA, bool div);
    public static Number FindTW(sbyte byteMu, int w);
    public static Number[] FindSI(Field2MCurves curve);
    public static ITanuElement MODFun(Number numberA, int m, sbyte a, Number[] numberS, sbyte byteMu, sbyte c);
    public static Finite2MPoint MultiplyFromTnaf(Finite2MPoint pointP, SByte[] u);
    public static SByte[] GetTAdic(sbyte byteMu, ITanuElement lambdaValue, sbyte width, Number pow2w, Number tw, ITanuElement[] alpha);
    public static Finite2MPoint[] FindComp(Finite2MPoint pointP, sbyte a);
}
internal class Syncfusion.Pdf.Security.ECWMultiplier : object {
    [NullableContextAttribute("1")]
public SByte[] CheckBitValue(sbyte width, Number number);
    [NullableContextAttribute("1")]
public sealed virtual EllipticPoint Multiply(EllipticPoint pointP, Number number, EllipticComp preInfo);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Syncfusion.Pdf.Security.ECX962Curves : object {
    internal static Dictionary`2<DerObjectID, ECX9Params> m_curves;
    internal static Dictionary`2<string, DerObjectID> objectIds;
    internal static Dictionary`2<DerObjectID, string> curveNames;
    private static ECX962Curves();
    private static void CreateCurve(string name, DerObjectID oid, ECX9Params holder);
    public static ECX9Field GetByOid(DerObjectID oid);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Syncfusion.Pdf.Security.ECX962Params : Asn1Encode {
    private Asn1 m_parameters;
    public bool IsNamedCurve { get; }
    public Asn1 Parameters { get; }
    public ECX962Params(ECX9Field ecParameters);
    public ECX962Params(DerObjectID namedCurve);
    public ECX962Params(Asn1 obj);
    public bool get_IsNamedCurve();
    public Asn1 get_Parameters();
    public virtual Asn1 GetAsn1();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Syncfusion.Pdf.Security.ECx9Curve : Asn1Encode {
    private EllipticCurves m_curve;
    private Byte[] m_seed;
    private DerObjectID m_fieldID;
    public EllipticCurves Curve { get; }
    public ECx9Curve(EllipticCurves curve, Byte[] seed);
    public ECx9Curve(ECx9FieldObject fieldID, Asn1Sequence sequence);
    public EllipticCurves get_Curve();
    public Byte[] GetSeed();
    public virtual Asn1 GetAsn1();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Syncfusion.Pdf.Security.ECX9Field : Asn1Encode {
    private ECx9FieldObject m_fieldID;
    private EllipticCurves m_curve;
    private EllipticPoint m_point;
    private Number m_num1;
    private Number m_num2;
    private Byte[] m_seed;
    public EllipticCurves Curve { get; }
    public EllipticPoint PointG { get; }
    public Number NumberX { get; }
    public Number NumberY { get; }
    public ECX9Field(Asn1Sequence sequence);
    public ECX9Field(EllipticCurves curve, EllipticPoint point, Number num, Number num1);
    public ECX9Field(EllipticCurves curve, EllipticPoint point, Number num, Number num1, Byte[] seed);
    public EllipticCurves get_Curve();
    public EllipticPoint get_PointG();
    public Number get_NumberX();
    public Number get_NumberY();
    public Byte[] Seed();
    public virtual Asn1 GetAsn1();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Syncfusion.Pdf.Security.ECx9FieldObject : Asn1Encode {
    private DerObjectID m_identifier;
    private Asn1 m_param;
    public DerObjectID Identifier { get; }
    public Asn1 Parameters { get; }
    public ECx9FieldObject(Number primePNum);
    public ECx9FieldObject(int num, int num1, int num2, int num3);
    internal ECx9FieldObject(Asn1Sequence sequence);
    public DerObjectID get_Identifier();
    public Asn1 get_Parameters();
    public virtual Asn1 GetAsn1();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Syncfusion.Pdf.Security.ECx9FieldObjectID : Asn1Encode {
    private EllipticCurveElements m_field;
    public EllipticCurveElements Value { get; }
    public ECx9FieldObjectID(EllipticCurveElements field);
    public ECx9FieldObjectID(Number point, Asn1Octet sequence);
    public ECx9FieldObjectID(int num, int num1, int num2, int num3, Asn1Octet sequence);
    public EllipticCurveElements get_Value();
    public virtual Asn1 GetAsn1();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal abstract class Syncfusion.Pdf.Security.ECX9Params : object {
    private ECX9Field m_parameters;
    public ECX9Field Parameters { get; }
    public ECX9Field get_Parameters();
    protected abstract virtual ECX9Field DefineParameters();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Syncfusion.Pdf.Security.ECx9Point : Asn1Encode {
    private EllipticPoint m_point;
    public EllipticPoint Point { get; }
    public ECx9Point(EllipticPoint point);
    public ECx9Point(EllipticCurves curve, Asn1Octet sequence);
    public EllipticPoint get_Point();
    public virtual Asn1 GetAsn1();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Syncfusion.Pdf.Security.EllipicCryptoKeyGen : object {
    private string algorithm;
    private EllipticCurveParams parameters;
    private DerObjectID publicCyptoKey;
    private SecureRandomAlgorithm randomNumber;
    internal EllipicCryptoKeyGen(string algorithm);
    public sealed virtual void Init(KeyGenParam parameters);
    public sealed virtual ECCipherKeyParam GenerateKeyPair();
    internal static ECX9Field GetECCurveByObjectID(DerObjectID objectIds);
}
internal interface Syncfusion.Pdf.Security.EllipticComp {
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Syncfusion.Pdf.Security.EllipticCryptoParam : KeyGenParam {
    private EllipticCurveParams domainParameters;
    private DerObjectID publicCyptoKey;
    public EllipticCurveParams DomainParameters { get; }
    public DerObjectID PublicKeyParamSet { get; }
    public EllipticCryptoParam(EllipticCurveParams domainParameters, SecureRandomAlgorithm random);
    public EllipticCryptoParam(DerObjectID publicCyptoKey, SecureRandomAlgorithm random);
    public EllipticCurveParams get_DomainParameters();
    public DerObjectID get_PublicKeyParamSet();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal abstract class Syncfusion.Pdf.Security.EllipticCurveElements : object {
    public string ECElementName { get; }
    public int ElementSize { get; }
    public abstract virtual Number ToIntValue();
    public abstract virtual string get_ECElementName();
    public abstract virtual int get_ElementSize();
    public abstract virtual EllipticCurveElements SumValue(EllipticCurveElements value);
    public abstract virtual EllipticCurveElements Subtract(EllipticCurveElements value);
    public abstract virtual EllipticCurveElements Multiply(EllipticCurveElements value);
    public abstract virtual EllipticCurveElements Divide(EllipticCurveElements value);
    public abstract virtual EllipticCurveElements Negate();
    public abstract virtual EllipticCurveElements Square();
    public abstract virtual EllipticCurveElements Invert();
    public abstract virtual EllipticCurveElements SquareRoot();
    public virtual bool Equals(object element);
    protected bool Equals(EllipticCurveElements element);
    public virtual int GetHashCode();
    public virtual string ToString();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Syncfusion.Pdf.Security.EllipticCurveParams : object {
    internal EllipticCurves ecCurve;
    internal Byte[] data;
    internal EllipticPoint pointG;
    internal Number numberX;
    internal Number numberY;
    internal EllipticCurves Curve { get; }
    internal EllipticPoint PointG { get; }
    internal Number NumberX { get; }
    internal Number NumberY { get; }
    internal EllipticCurveParams(EllipticCurves ecCurve, EllipticPoint pointG, Number numberX);
    internal EllipticCurveParams(EllipticCurves ecCurve, EllipticPoint pointG, Number numberX, Number numberY);
    internal EllipticCurveParams(EllipticCurves ecCurve, EllipticPoint pointG, Number numberX, Number numberY, Byte[] data);
    internal EllipticCurves get_Curve();
    internal EllipticPoint get_PointG();
    internal Number get_NumberX();
    internal Number get_NumberY();
    internal Byte[] ECSeed();
    public virtual bool Equals(object element);
    protected bool Equals(EllipticCurveParams element);
    public virtual int GetHashCode();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal abstract class Syncfusion.Pdf.Security.EllipticCurves : object {
    internal EllipticCurveElements elementA;
    internal EllipticCurveElements elementB;
    public int Size { get; }
    public EllipticPoint IsInfinity { get; }
    public EllipticCurveElements ElementA { get; }
    public EllipticCurveElements ElementB { get; }
    public abstract virtual int get_Size();
    public abstract virtual EllipticCurveElements ECNumber(Number number);
    public abstract virtual EllipticPoint ECPoints(Number pointX, Number pointY, bool isCompress);
    public abstract virtual EllipticPoint get_IsInfinity();
    public EllipticCurveElements get_ElementA();
    public EllipticCurveElements get_ElementB();
    public virtual bool Equals(object element);
    protected bool Equals(EllipticCurves element);
    public virtual int GetHashCode();
    protected abstract virtual EllipticPoint GetDecompressECPoint(int point, Number number);
    public virtual EllipticPoint GetDecodedECPoint(Byte[] encodedPoints);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Syncfusion.Pdf.Security.EllipticGOSTCurves : object {
    internal static Dictionary`2<DerObjectID, EllipticCurveParams> parameters;
    internal static Dictionary`2<string, DerObjectID> curveIds;
    internal static Dictionary`2<DerObjectID, string> curveNames;
    private static EllipticGOSTCurves();
    public static EllipticCurveParams GetByOid(DerObjectID oid);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Syncfusion.Pdf.Security.EllipticKeyParam : CipherParameter {
    private static String[] algorithms;
    private string algorithm;
    private EllipticCurveParams parameters;
    private DerObjectID publicCyptoKey;
    public string AlgorithmName { get; }
    public EllipticCurveParams Parameters { get; }
    public DerObjectID PublicKeyParamSet { get; }
    protected EllipticKeyParam(string algorithm, bool isPrivate, EllipticCurveParams parameters);
    protected EllipticKeyParam(string algorithm, bool isPrivate, DerObjectID publicCyptoKey);
    private static EllipticKeyParam();
    public string get_AlgorithmName();
    public EllipticCurveParams get_Parameters();
    public DerObjectID get_PublicKeyParamSet();
    public virtual bool Equals(object element);
    protected bool Equals(EllipticKeyParam element);
    public virtual int GetHashCode();
    internal static string VerifyAlgorithmName(string algorithm);
    internal static EllipticCurveParams FindParameters(DerObjectID publicCyptoKey);
}
[NullableContextAttribute("1")]
internal interface Syncfusion.Pdf.Security.EllipticMultiplier {
    public abstract virtual EllipticPoint Multiply(EllipticPoint pointP, Number number, EllipticComp preInfo);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal abstract class Syncfusion.Pdf.Security.EllipticPoint : object {
    internal EllipticCurves curve;
    internal EllipticCurveElements pointX;
    internal EllipticCurveElements pointY;
    internal bool isCompress;
    internal EllipticMultiplier multiplier;
    internal EllipticComp preInfo;
    internal EllipticCurves Curve { get; }
    internal EllipticCurveElements PointX { get; }
    internal EllipticCurveElements PointY { get; }
    internal bool IsInfinity { get; }
    internal bool IsCompressed { get; }
    protected internal EllipticPoint(EllipticCurves curve, EllipticCurveElements pointX, EllipticCurveElements pointY, bool isCompress);
    internal EllipticCurves get_Curve();
    internal EllipticCurveElements get_PointX();
    internal EllipticCurveElements get_PointY();
    internal bool get_IsInfinity();
    internal bool get_IsCompressed();
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    internal void SetInfo(EllipticComp preInfo);
    internal virtual Byte[] Encoded();
    internal abstract virtual Byte[] Encoded(bool compressed);
    internal abstract virtual EllipticPoint SumValue(EllipticPoint value);
    internal abstract virtual EllipticPoint Subtract(EllipticPoint value);
    internal abstract virtual EllipticPoint Negate();
    internal abstract virtual EllipticPoint Twice();
    internal abstract virtual EllipticPoint Multiply(Number value);
    internal virtual void CheckMultiplier();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Syncfusion.Pdf.Security.EllipticTNMuliplier : object {
    public sealed virtual EllipticPoint Multiply(EllipticPoint pointP, Number number, EllipticComp preInfo);
    private Finite2MPoint MultiplyValue(Finite2MPoint pointP, ITanuElement lambdaValue, EllipticComp preInfo, sbyte bitA, sbyte pointMU);
    private static Finite2MPoint MultiplyTFunction(Finite2MPoint pointP, SByte[] byteU, EllipticComp preInfo);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Syncfusion.Pdf.Security.EllipticWComp : object {
    private EllipticPoint[] compBitValue;
    private EllipticPoint twicePoint;
    internal EllipticPoint[] FindComp();
    internal void SetComp(EllipticPoint[] compBitValue);
    internal EllipticPoint FindTwice();
    internal void TwicePoint(EllipticPoint twiceP);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Syncfusion.Pdf.Security.EncryptedPrivateKey : Asn1Encode {
    private Algorithms m_algorithms;
    private Asn1Octet m_octet;
    internal Algorithms EncryptionAlgorithm { get; }
    internal Byte[] EncryptedData { get; }
    private EncryptedPrivateKey(Asn1Sequence sequence);
    internal Algorithms get_EncryptionAlgorithm();
    internal Byte[] get_EncryptedData();
    internal static EncryptedPrivateKey GetEncryptedPrivateKeyInformation(object obj);
    public virtual Asn1 GetAsn1();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Syncfusion.Pdf.Security.EncryptionAlgorithms : object {
    private Dictionary`2<string, string> algorithmNames;
    internal string GetAlgorithm(string oid);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Syncfusion.Pdf.Security.EnumerableProxy : object {
    private IEnumerable m_value;
    internal EnumerableProxy(IEnumerable value);
    public sealed virtual IEnumerator GetEnumerator();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Syncfusion.Pdf.Security.Enums : object {
    internal static Enum GetEnumValue(Type enumType, string s);
    internal static Array GetEnumValues(Type enumType);
    internal static Enum GetArbitraryValue(Type enumType);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Syncfusion.Pdf.Security.Field2MCurves : EllipticCurves {
    private int pointM;
    private int elementX;
    private int elementY;
    private int elementZ;
    private Number numberX;
    private Number numberY;
    private Finite2MPoint infinityPoint;
    private sbyte mPoint;
    private Number[] collection;
    public EllipticPoint IsInfinity { get; }
    public int Size { get; }
    public bool IsKOBLITZ { get; }
    public int PointM { get; }
    public int ElementX { get; }
    public int ElementY { get; }
    public int ElementZ { get; }
    public Number NumberY { get; }
    public Field2MCurves(int pointM, int pointX, Number elementA, Number elementB, Number numberX, Number numberY);
    public Field2MCurves(int pointM, int elementX, int elementY, int elementZ, Number elementA, Number elementB);
    public Field2MCurves(int pointM, int elementX, int elementY, int elementZ, Number elementA, Number elementB, Number numberX, Number numberY);
    public virtual EllipticPoint get_IsInfinity();
    public virtual int get_Size();
    public virtual EllipticCurveElements ECNumber(Number number);
    public bool get_IsKOBLITZ();
    internal sbyte MU();
    internal Number[] SI();
    public virtual EllipticPoint ECPoints(Number numberX1, Number numberY1, bool isCompress);
    protected virtual EllipticPoint GetDecompressECPoint(int point, Number numberX1);
    private EllipticCurveElements ECEquation(EllipticCurveElements betaPoint);
    public virtual bool Equals(object element);
    protected bool Equals(Field2MCurves element);
    public virtual int GetHashCode();
    public int get_PointM();
    public int get_ElementX();
    public int get_ElementY();
    public int get_ElementZ();
    public Number get_NumberY();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Syncfusion.Pdf.Security.Finite2MFieldObject : EllipticCurveElements {
    public static int intergerX;
    public static int intergerY;
    public static int intergerZ;
    private int valueA;
    private int valueB;
    private int valueC;
    private int valueD;
    private int valueE;
    private PdfIntArray numberPX;
    private int valueF;
    public string ECElementName { get; }
    public int ElementSize { get; }
    public Finite2MFieldObject(int valueB, int valueC, int valueD, int valueE, Number numberPX);
    private Finite2MFieldObject(int valueB, int valueC, int valueD, int valueE, PdfIntArray numberPX);
    public virtual Number ToIntValue();
    public virtual string get_ECElementName();
    public virtual int get_ElementSize();
    public static void ValidateElements(EllipticCurveElements curveA, EllipticCurveElements value);
    public virtual EllipticCurveElements SumValue(EllipticCurveElements value);
    public virtual EllipticCurveElements Subtract(EllipticCurveElements value);
    public virtual EllipticCurveElements Multiply(EllipticCurveElements value);
    public virtual EllipticCurveElements Divide(EllipticCurveElements value);
    public virtual EllipticCurveElements Negate();
    public virtual EllipticCurveElements Square();
    public virtual EllipticCurveElements Invert();
    public virtual EllipticCurveElements SquareRoot();
    public virtual bool Equals(object element);
    protected bool Equals(Finite2MFieldObject element);
    public virtual int GetHashCode();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Syncfusion.Pdf.Security.Finite2MPoint : ECPointBase {
    protected internal bool BasePoint { get; }
    internal Finite2MPoint(EllipticCurves curve, EllipticCurveElements pointX, EllipticCurveElements pointY);
    internal Finite2MPoint(EllipticCurves curve, EllipticCurveElements pointX, EllipticCurveElements pointY, bool isCompress);
    protected internal virtual bool get_BasePoint();
    private static void ValidatePoints(EllipticPoint bitA, EllipticPoint value);
    internal virtual EllipticPoint SumValue(EllipticPoint value);
    internal Finite2MPoint AddSimple(Finite2MPoint value);
    internal virtual EllipticPoint Subtract(EllipticPoint value);
    internal Finite2MPoint SubtractSimple(Finite2MPoint value);
    internal virtual EllipticPoint Twice();
    internal virtual EllipticPoint Negate();
    internal virtual void CheckMultiplier();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Syncfusion.Pdf.Security.FiniteCompField : object {
    private Finite2MPoint[] compBitValue;
    internal FiniteCompField(Finite2MPoint[] compBitValue);
    internal Finite2MPoint[] FindComp();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Syncfusion.Pdf.Security.FiniteCurves : EllipticCurves {
    private Number number;
    private FinitePoint infinityPoint;
    public Number PointQ { get; }
    public EllipticPoint IsInfinity { get; }
    public int Size { get; }
    public FiniteCurves(Number number, Number elementA, Number elementB);
    public Number get_PointQ();
    public virtual EllipticPoint get_IsInfinity();
    public virtual int get_Size();
    public virtual EllipticCurveElements ECNumber(Number num);
    public virtual EllipticPoint ECPoints(Number numberX1, Number numberY1, bool isCompress);
    protected virtual EllipticPoint GetDecompressECPoint(int point, Number numberX1);
    public virtual bool Equals(object element);
    protected bool Equals(FiniteCurves element);
    public virtual int GetHashCode();
}
internal class Syncfusion.Pdf.Security.FiniteFieldMulipler : object {
    [NullableContextAttribute("1")]
public sealed virtual EllipticPoint Multiply(EllipticPoint pointP, Number number, EllipticComp preInfo);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Syncfusion.Pdf.Security.FinitePFieldObject : EllipticCurveElements {
    private Number numberPQ;
    private Number numberPX;
    public string ECElementName { get; }
    public int ElementSize { get; }
    public FinitePFieldObject(Number numberPQ, Number numberPX);
    public virtual Number ToIntValue();
    public virtual string get_ECElementName();
    public virtual int get_ElementSize();
    public virtual EllipticCurveElements SumValue(EllipticCurveElements value);
    public virtual EllipticCurveElements Subtract(EllipticCurveElements value);
    public virtual EllipticCurveElements Multiply(EllipticCurveElements value);
    public virtual EllipticCurveElements Divide(EllipticCurveElements value);
    public virtual EllipticCurveElements Negate();
    public virtual EllipticCurveElements Square();
    public virtual EllipticCurveElements Invert();
    public virtual EllipticCurveElements SquareRoot();
    private static Number[] FLSequence(Number valueP, Number numberP, Number numberQ, Number numberK1);
    public virtual bool Equals(object element);
    protected bool Equals(FinitePFieldObject element);
    public virtual int GetHashCode();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Syncfusion.Pdf.Security.FinitePoint : ECPointBase {
    protected internal bool BasePoint { get; }
    internal FinitePoint(EllipticCurves curve, EllipticCurveElements pointX, EllipticCurveElements pointY);
    internal FinitePoint(EllipticCurves curve, EllipticCurveElements pointX, EllipticCurveElements pointY, bool isCompress);
    protected internal virtual bool get_BasePoint();
    internal virtual EllipticPoint SumValue(EllipticPoint value);
    internal virtual EllipticPoint Twice();
    internal virtual EllipticPoint Subtract(EllipticPoint value);
    internal virtual EllipticPoint Negate();
    internal virtual void CheckMultiplier();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Syncfusion.Pdf.Security.GeneralizedTime : Asn1 {
    internal static string GMT;
    internal static char TZ;
    internal static string Day;
    internal static string Month;
    internal static string Year;
    internal static string Hours;
    internal static string Minutes;
    internal static string Seconds;
    private string m_time;
    internal string TimeString { get; }
    internal GeneralizedTime(Byte[] bytes);
    internal string get_TimeString();
    internal DateTime ToDateTime();
    private string FormatString(int count);
    internal virtual void Encode(DerStream dStream);
    protected virtual bool IsEquals(Asn1 asn1Object);
    public virtual int GetHashCode();
    internal static GeneralizedTime GetGeneralizedTime(object obj);
    internal static GeneralizedTime GetGeneralizedTime(Asn1Tag tag, bool isExplicit);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Syncfusion.Pdf.Security.HexStringEncoder : object {
    private static Byte[] table;
    private static Byte[] tableDecode;
    private static HexStringEncoder();
    private static Byte[] CreateDecodeTable(Byte[] value);
    public sealed virtual int Encode(Byte[] data, int offset, int length, Stream outputStream);
    private static bool Ignore(char character);
    public sealed virtual int Decode(Byte[] data, int offset, int length, Stream outputStream);
    public sealed virtual int DecodeString(string data, Stream outputStream);
}
[NullableContextAttribute("1")]
internal interface Syncfusion.Pdf.Security.IAlgorithmGenerator {
    public abstract virtual void AddMaterial(Byte[] bytes);
    public abstract virtual void AddMaterial(long value);
    public abstract virtual void FillNextBytes(Byte[] bytes);
    public abstract virtual void FillNextBytes(Byte[] bytes, int start, int length);
}
[NullableContextAttribute("1")]
internal interface Syncfusion.Pdf.Security.IAsn1 {
    public abstract virtual Asn1 GetAsn1();
}
internal interface Syncfusion.Pdf.Security.IAsn1Choice {
}
internal interface Syncfusion.Pdf.Security.IAsn1Collection {
    [NullableContextAttribute("1")]
public abstract virtual IAsn1 ReadObject();
}
internal interface Syncfusion.Pdf.Security.IAsn1Octet {
    [NullableContextAttribute("1")]
public abstract virtual Stream GetOctetStream();
}
internal interface Syncfusion.Pdf.Security.IAsn1SetHelper {
    [NullableContextAttribute("1")]
public abstract virtual IAsn1 ReadObject();
}
[NullableContextAttribute("1")]
internal interface Syncfusion.Pdf.Security.IAsn1String {
    public abstract virtual string GetString();
}
internal interface Syncfusion.Pdf.Security.IAsn1Tag {
    public int TagNumber { get; }
    public abstract virtual int get_TagNumber();
    [NullableContextAttribute("1")]
public abstract virtual IAsn1 GetParser(int tagNumber, bool isExplicit);
}
[NullableContextAttribute("1")]
internal interface Syncfusion.Pdf.Security.IBufferedCipher {
    public string AlgorithmName { get; }
    public int BlockSize { get; }
    public abstract virtual string get_AlgorithmName();
    public abstract virtual void Initialize(bool forEncryption, ICipherParam parameters);
    public abstract virtual int get_BlockSize();
    public abstract virtual int GetOutputSize(int inputLen);
    public abstract virtual int GetUpdateOutputSize(int inputLen);
    public abstract virtual Byte[] ProcessByte(byte input);
    public abstract virtual int ProcessByte(byte input, Byte[] output, int outOff);
    public abstract virtual Byte[] ProcessBytes(Byte[] input);
    public abstract virtual Byte[] ProcessBytes(Byte[] input, int inOff, int length);
    public abstract virtual int ProcessBytes(Byte[] input, Byte[] output, int outOff);
    public abstract virtual int ProcessBytes(Byte[] input, int inOff, int length, Byte[] output, int outOff);
    public abstract virtual Byte[] DoFinal();
    public abstract virtual Byte[] DoFinal(Byte[] input);
    public abstract virtual Byte[] DoFinal(Byte[] input, int inOff, int length);
    public abstract virtual int DoFinal(Byte[] output, int outOff);
    public abstract virtual int DoFinal(Byte[] input, Byte[] output, int outOff);
    public abstract virtual int DoFinal(Byte[] input, int inOff, int length, Byte[] output, int outOff);
    public abstract virtual void Reset();
}
[NullableContextAttribute("1")]
internal interface Syncfusion.Pdf.Security.ICipher {
    public string AlgorithmName { get; }
    public int BlockSize { get; }
    public bool IsBlock { get; }
    public abstract virtual string get_AlgorithmName();
    public abstract virtual void Initialize(bool isEncryption, ICipherParam parameters);
    public abstract virtual int get_BlockSize();
    public abstract virtual bool get_IsBlock();
    public abstract virtual int ProcessBlock(Byte[] inBytes, int inOffset, Byte[] outBytes, int outOffset);
    public abstract virtual void Reset();
}
[NullableContextAttribute("1")]
internal interface Syncfusion.Pdf.Security.ICipherBlock {
    public string AlgorithmName { get; }
    public int InputBlock { get; }
    public int OutputBlock { get; }
    public abstract virtual string get_AlgorithmName();
    public abstract virtual void Initialize(bool isEncryption, ICipherParam parameters);
    public abstract virtual int get_InputBlock();
    public abstract virtual int get_OutputBlock();
    public abstract virtual Byte[] ProcessBlock(Byte[] bytes, int offset, int length);
}
[NullableContextAttribute("1")]
internal interface Syncfusion.Pdf.Security.ICipherKeyGen {
    public abstract virtual void Init(KeyGenParam parameters);
    public abstract virtual ECCipherKeyParam GenerateKeyPair();
}
internal interface Syncfusion.Pdf.Security.ICipherParam {
}
[NullableContextAttribute("1")]
internal interface Syncfusion.Pdf.Security.IDSASigner {
    public string AlgorithmName { get; }
    public abstract virtual string get_AlgorithmName();
    public abstract virtual void Initialize(bool forSigning, ICipherParam parameters);
    public abstract virtual Number[] GenerateSignature(Byte[] message);
    public abstract virtual bool ValidateSignature(Byte[] message, Number r, Number s);
}
[NullableContextAttribute("1")]
internal interface Syncfusion.Pdf.Security.IHexEncoder {
    public abstract virtual int Encode(Byte[] data, int offset, int length, Stream outputStream);
    public abstract virtual int Decode(Byte[] data, int offset, int length, Stream outputStream);
    public abstract virtual int DecodeString(string data, Stream outputStream);
}
[NullableContextAttribute("1")]
internal interface Syncfusion.Pdf.Security.IMessageDigest {
    public string AlgorithmName { get; }
    public int MessageDigestSize { get; }
    public int ByteLength { get; }
    public abstract virtual string get_AlgorithmName();
    public abstract virtual int get_MessageDigestSize();
    public abstract virtual int get_ByteLength();
    public abstract virtual void Update(byte input);
    public abstract virtual void Update(Byte[] bytes, int offset, int length);
    public abstract virtual void BlockUpdate(Byte[] bytes, int offset, int length);
    public abstract virtual int DoFinal(Byte[] bytes, int offset);
    public abstract virtual void Reset();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Syncfusion.Pdf.Security.InvalidParameter : object {
    private ICipherParam m_parameters;
    private Byte[] m_bytes;
    internal Byte[] InvalidBytes { get; }
    internal ICipherParam Parameters { get; }
    internal InvalidParameter(ICipherParam parameters, Byte[] bytes);
    internal InvalidParameter(ICipherParam parameters, Byte[] bytes, int offset, int length);
    internal Byte[] get_InvalidBytes();
    internal ICipherParam get_Parameters();
}
[NullableContextAttribute("1")]
internal interface Syncfusion.Pdf.Security.IPadding {
    public string PaddingName { get; }
    public abstract virtual void Initialize(SecureRandomAlgorithm random);
    public abstract virtual string get_PaddingName();
    public abstract virtual int AddPadding(Byte[] bytes, int offset);
    public abstract virtual int Count(Byte[] bytes);
}
[NullableContextAttribute("1")]
internal interface Syncfusion.Pdf.Security.IPdfDecryptable {
    public bool WasEncrypted { get; }
    public bool Decrypted { get; }
    public abstract virtual bool get_WasEncrypted();
    public abstract virtual bool get_Decrypted();
    public abstract virtual void Decrypt(PdfEncryptor encryptor, long currObjNumber);
}
[NullableContextAttribute("1")]
public interface Syncfusion.Pdf.Security.IPdfExternalSigner {
    public string HashAlgorithm { get; }
    public abstract virtual string get_HashAlgorithm();
    public abstract virtual Byte[] Sign(Byte[] message, Byte[]& timeStampResponse);
}
internal interface Syncfusion.Pdf.Security.IRandom {
    public long Length { get; }
    public abstract virtual int Get(long position);
    [NullableContextAttribute("1")]
public abstract virtual int Get(long position, Byte[] bytes, int offset, int length);
    public abstract virtual long get_Length();
    public abstract virtual void Close();
}
[NullableContextAttribute("1")]
internal interface Syncfusion.Pdf.Security.ISigner {
    public string AlgorithmName { get; }
    public abstract virtual string get_AlgorithmName();
    public abstract virtual void Initialize(bool isSigning, ICipherParam parameters);
    public abstract virtual void Update(byte input);
    public abstract virtual void BlockUpdate(Byte[] bytes, int offset, int length);
    public abstract virtual Byte[] GenerateSignature();
    public abstract virtual bool ValidateSignature(Byte[] bytes);
    public abstract virtual void Reset();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Syncfusion.Pdf.Security.ITanuElement : object {
    public Number num1;
    public Number num2;
    public ITanuElement(Number num1, Number num2);
}
[NullableContextAttribute("1")]
internal interface Syncfusion.Pdf.Security.IX509Extension {
    public abstract virtual Asn1Octet GetExtension(DerObjectID id);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Syncfusion.Pdf.Security.KeyEntry : object {
    private CipherParameter m_key;
    private IDictionary m_attributes;
    internal CipherParameter Key { get; }
    internal KeyEntry(CipherParameter key, IDictionary attributes);
    internal CipherParameter get_Key();
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Syncfusion.Pdf.Security.KeyGenParam : object {
    private SecureRandomAlgorithm randomNumber;
    private int strength;
    internal SecureRandomAlgorithm Random { get; }
    internal int Strength { get; }
    internal KeyGenParam(SecureRandomAlgorithm randomNumber, int strength);
    internal SecureRandomAlgorithm get_Random();
    internal int get_Strength();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Syncfusion.Pdf.Security.KeyIdentifier : Asn1Encode {
    internal Asn1Octet m_keyIdentifier;
    internal DerInteger m_serialNumber;
    internal Byte[] KeyID { get; }
    protected internal KeyIdentifier(Asn1Sequence sequence);
    internal Byte[] get_KeyID();
    internal static KeyIdentifier GetKeyIdentifier(object obj);
    public virtual Asn1 GetAsn1();
    public virtual string ToString();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Syncfusion.Pdf.Security.KeyInformation : Asn1Encode {
    private Asn1 m_privateKey;
    private Algorithms m_algorithms;
    private Asn1Set m_attributes;
    internal Algorithms AlgorithmID { get; }
    internal Asn1 PrivateKey { get; }
    internal KeyInformation(Algorithms algorithms, Asn1 privateKey);
    public KeyInformation(Algorithms algorithms, Asn1 privateKey, Asn1Set attributes);
    private KeyInformation(Asn1Sequence sequence);
    internal static KeyInformation GetInformation(object obj);
    internal Algorithms get_AlgorithmID();
    internal Asn1 get_PrivateKey();
    public virtual Asn1 GetAsn1();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Syncfusion.Pdf.Security.KeyInformationCollection : object {
    internal static KeyInformation CreatePrivateKeyInfo(CipherParameter key);
    internal static KeyInformation CreatePrivateKeyInfo(Char[] passPhrase, EncryptedPrivateKey encInfo);
    internal static KeyInformation CreatePrivateKeyInfo(Char[] passPhrase, bool isPkcs12empty, EncryptedPrivateKey encInfo);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Syncfusion.Pdf.Security.KeyParameter : object {
    private Byte[] m_bytes;
    internal Byte[] Keys { get; }
    internal KeyParameter(Byte[] bytes);
    internal KeyParameter(Byte[] bytes, int offset, int length);
    internal Byte[] get_Keys();
}
public enum Syncfusion.Pdf.Security.KeyStorageFlags : Enum {
    public int value__;
    public static KeyStorageFlags DefaultKeySet;
    public static KeyStorageFlags UserKeySet;
    public static KeyStorageFlags MachineKeySet;
    public static KeyStorageFlags Exportable;
    public static KeyStorageFlags UserProtected;
    public static KeyStorageFlags PersistKeySet;
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Syncfusion.Pdf.Security.LargeDecimal : object {
    private Number m_bigDigit;
    private int m_scale;
    public int Scale { get; }
    public LargeDecimal(Number digit, int value);
    private void CheckScale(LargeDecimal value);
    public LargeDecimal AdjustScale(int newScale);
    public LargeDecimal Add(LargeDecimal value);
    public LargeDecimal Negate();
    public LargeDecimal Subtract(LargeDecimal value);
    public LargeDecimal Subtract(Number value);
    public int CompareTo(Number val);
    public Number Floor();
    public Number Round();
    public int get_Scale();
    public virtual string ToString();
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
}
public class Syncfusion.Pdf.Security.LtvVerificationInfo : object {
    private bool m_isLtvEnabled;
    private bool m_isCrlEmbedded;
    private bool m_isOcspEmbedded;
    public bool IsLtvEnabled { get; internal set; }
    public bool IsCrlEmbedded { get; internal set; }
    public bool IsOcspEmbedded { get; internal set; }
    public bool get_IsLtvEnabled();
    internal void set_IsLtvEnabled(bool value);
    public bool get_IsCrlEmbedded();
    internal void set_IsCrlEmbedded(bool value);
    public bool get_IsOcspEmbedded();
    internal void set_IsOcspEmbedded(bool value);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Syncfusion.Pdf.Security.MacInformation : Asn1Encode {
    internal DigestInformation m_digest;
    internal Byte[] m_value;
    internal Number m_count;
    private MacInformation(Asn1Sequence sequence);
    internal static MacInformation GetInformation(object obj);
    public virtual Asn1 GetAsn1();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal abstract class Syncfusion.Pdf.Security.MessageDigest : object {
    private static int c_byteLength;
    private Byte[] m_buf;
    private int m_bufOff;
    private long m_byteCount;
    public int ByteLength { get; }
    public string AlgorithmName { get; }
    public int MessageDigestSize { get; }
    internal MessageDigest(MessageDigest t);
    public sealed virtual void Update(byte input);
    public sealed virtual void Update(Byte[] bytes, int offset, int length);
    public sealed virtual void BlockUpdate(Byte[] bytes, int offset, int length);
    internal void Finish();
    public virtual void Reset();
    public sealed virtual int get_ByteLength();
    internal abstract virtual void ProcessWord(Byte[] input, int inOff);
    internal abstract virtual void ProcessLength(long bitLength);
    internal abstract virtual void ProcessBlock();
    public abstract virtual string get_AlgorithmName();
    public abstract virtual int get_MessageDigestSize();
    public abstract virtual int DoFinal(Byte[] bytes, int offset);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Syncfusion.Pdf.Security.MessageDigest5 : MessageDigest {
    private static int m_digestLength;
    private UInt32 m_a;
    private UInt32 m_b;
    private UInt32 m_c;
    private UInt32 m_d;
    private UInt32[] m_localarray;
    private int m_offset;
    private static int r11;
    private static int r12;
    private static int r13;
    private static int r14;
    private static int r21;
    private static int r22;
    private static int r23;
    private static int r24;
    private static int r31;
    private static int r32;
    private static int r33;
    private static int r34;
    private static int r41;
    private static int r42;
    private static int r43;
    private static int r44;
    public string AlgorithmName { get; }
    public int MessageDigestSize { get; }
    public MessageDigest5(MessageDigest5 md5);
    private static MessageDigest5();
    internal virtual void ProcessWord(Byte[] input, int inOff);
    internal virtual void ProcessLength(long Length);
    internal virtual void ProcessBlock();
    public virtual string get_AlgorithmName();
    public virtual int get_MessageDigestSize();
    public virtual int DoFinal(Byte[] bytes, int offset);
    private UInt32 RotateLeft(UInt32 x, int n);
    private UInt32 F1(UInt32 u, UInt32 v, UInt32 w);
    private UInt32 F2(UInt32 u, UInt32 v, UInt32 w);
    private UInt32 F3(UInt32 u, UInt32 v, UInt32 w);
    private UInt32 F4(UInt32 u, UInt32 v, UInt32 w);
    public virtual void Reset();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Syncfusion.Pdf.Security.MessageDigestAlgorithms : object {
    internal static string SHA1;
    internal static string SHA256;
    internal static string SHA384;
    internal static string SHA512;
    internal static string RIPEMD160;
    private Dictionary`2<string, string> m_names;
    private Dictionary`2<string, string> m_digests;
    private MessageDigestFinder m_finder;
    internal IMessageDigest GetMessageDigest(string hashAlgorithm);
    internal Byte[] Digest(Stream data, string hashAlgorithm);
    internal Byte[] Digest(Stream data, IMessageDigest messageDigest);
    internal string GetDigest(string id);
    internal string GetAllowedDigests(string name);
    internal Byte[] Digest(string algorithm, Byte[] bytes);
    internal Byte[] Digest(IMessageDigest digest, Byte[] bytes, int offset, int length);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Syncfusion.Pdf.Security.MessageDigestFinder : object {
    private Dictionary`2<string, string> m_algorithms;
    private Dictionary`2<string, DerObjectID> m_ids;
    internal IMessageDigest GetMessageDigest(DerObjectID id);
    internal IMessageDigest GetDigest(string algorithm);
    internal Byte[] CalculateDigest(string algorithm, Byte[] bytes);
    internal Byte[] DoFinal(IMessageDigest digest);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Syncfusion.Pdf.Security.MessageStamp : Asn1Sequence {
    internal Asn1Sequence m_sequence;
    private Algorithms m_hashAlgorithm;
    private Byte[] m_hash;
    internal string HashAlgorithm { get; }
    internal Byte[] HashedMessage { get; }
    internal MessageStamp(string id, Byte[] hash);
    private MessageStamp(Asn1Sequence sequence);
    internal static MessageStamp GetMessageStamp(object obj);
    internal string get_HashAlgorithm();
    internal Byte[] get_HashedMessage();
}
internal class Syncfusion.Pdf.Security.NamespaceDoc : object {
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Syncfusion.Pdf.Security.NISTOIDs : object {
    internal static DerObjectID NistAlgorithm;
    internal static DerObjectID HashAlgs;
    internal static DerObjectID SHA256;
    internal static DerObjectID SHA384;
    internal static DerObjectID SHA512;
    internal static DerObjectID DSAWithSHA2;
    internal static DerObjectID DSAWithSHA256;
    internal static DerObjectID DSAWithSHA384;
    internal static DerObjectID DSAWithSHA512;
    internal static DerObjectID TTTAlgorithm;
    internal static DerObjectID RipeMD160;
    internal static DerObjectID TTTRsaSignatureAlgorithm;
    internal static DerObjectID RsaSignatureWithRipeMD160;
    private static NISTOIDs();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Syncfusion.Pdf.Security.NullMessageDigest : object {
    private MemoryStream m_stream;
    public string AlgorithmName { get; }
    public int MessageDigestSize { get; }
    public int ByteLength { get; }
    public sealed virtual string get_AlgorithmName();
    public sealed virtual int get_MessageDigestSize();
    public sealed virtual int get_ByteLength();
    public int GetByteLength();
    public int GetDigestSize();
    public sealed virtual void Update(byte b);
    public sealed virtual void BlockUpdate(Byte[] inBytes, int inOff, int len);
    public sealed virtual int DoFinal(Byte[] outBytes, int outOff);
    public sealed virtual void Reset();
    public sealed virtual void Update(Byte[] bytes, int offset, int length);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Syncfusion.Pdf.Security.Number : object {
    internal static Int32[][] m_lists;
    internal static Int32[] m_products;
    private static long m_iMask;
    private static ulong m_uMask;
    private static Int32[] m_zeroMagnitude;
    private static Byte[] m_zeroEncoding;
    private static Number[] m_smallConstants;
    public static Number Zero;
    public static Number One;
    public static Number Two;
    public static Number Three;
    public static Number Ten;
    private static Byte[] m_bitLengthTable;
    private static int m_c2;
    private static int m_c8;
    private static int m_c10;
    private static int m_c16;
    private static Number m_r2;
    private static Number m_r2E;
    private static Number m_r8;
    private static Number m_r8E;
    private static Number m_r10;
    private static Number m_r10E;
    private static Number m_r16;
    private static Number m_r16E;
    private static SecureRandomAlgorithm m_rs;
    private static Int32[] m_eT;
    private static int m_bByte;
    private static int m_bInt;
    private static int m_byteInt;
    private Int32[] m_magnitude;
    private int m_sign;
    private int m_nBits;
    private int m_nBitLength;
    private int m_quote;
    internal int BitCount { get; }
    internal int BitLength { get; }
    internal int IntValue { get; }
    internal long LongValue { get; }
    internal int SignValue { get; }
    private static Number();
    private Number(int signum, Int32[] mag, bool checkMag);
    internal Number(string value);
    internal Number(string str, int radix);
    internal Number(Byte[] bytes);
    internal Number(Byte[] bytes, int offset, int length);
    internal Number(int sign, Byte[] bytes);
    internal Number(int sign, Byte[] bytes, int offset, int length);
    internal Number(int value, SecureRandomAlgorithm random);
    private static int GetByteLength(int nBits);
    private static Int32[] MakeMagnitude(Byte[] bytes, int offset, int length);
    internal Number Absolute();
    internal static Int32[] AddMagnitudes(Int32[] a, Int32[] b);
    internal Number Add(Number value);
    private Number AddToMagnitude(Int32[] magToAdd);
    internal int get_BitCount();
    internal static int BitCnt(int i);
    private static int CalcBitLength(int sign, int indx, Int32[] mag);
    internal int get_BitLength();
    private static int BitLen(int w);
    private bool QuickPow2Check();
    internal int CompareTo(object obj);
    private static int CompareTo(int xIndx, Int32[] x, int yIndx, Int32[] y);
    private static int CompareNoLeadingZeroes(int xIndx, Int32[] x, int yIndx, Int32[] y);
    internal int CompareTo(Number value);
    private Int32[] Divide(Int32[] x, Int32[] y);
    internal Number Divide(Number value);
    internal Number[] DivideAndRemainder(Number value);
    public virtual bool Equals(object obj);
    private bool IsEqualMagnitude(Number x);
    public virtual int GetHashCode();
    private Number Inc();
    internal int get_IntValue();
    internal bool IsProbablePrime(int certainty);
    private bool CheckProbablePrime(int certainty, SecureRandomAlgorithm random);
    internal bool RabinMillerTest(int certainty, SecureRandomAlgorithm random);
    internal long get_LongValue();
    internal Number Mod(Number m);
    internal Number ModInverse(Number m);
    private static int ModInverse32(int d);
    private static Number ExtEuclid(Number a, Number b, Number& u1Out);
    internal Number ModPow(Number e, Number m);
    private static Number ModPowBarrett(Number b, Number e, Number m);
    private static Number ReduceBarrett(Number x, Number m, Number mr, Number yu);
    private static Number ModPowMonty(Number b, Number e, Number m, bool convert);
    private static Int32[] GetWindowList(Int32[] mag, int extraBits);
    private static int CreateWindowEntry(int mult, int zeroes);
    private static Int32[] Square(Int32[] w, Int32[] x);
    private static Int32[] Multiply(Int32[] x, Int32[] y, Int32[] z);
    private int GetMQuote();
    private static void MontgomeryReduce(Int32[] x, Int32[] m, UInt32 mDash);
    private static void MultiplyMonty(Int32[] a, Int32[] x, Int32[] y, Int32[] m, UInt32 mDash, bool smallMontyModulus);
    private static void SquareMonty(Int32[] a, Int32[] x, Int32[] m, UInt32 mDash, bool smallMontyModulus);
    private static UInt32 MultiplyMontyNIsOne(UInt32 x, UInt32 y, UInt32 m, UInt32 mDash);
    internal Number Multiply(Number val);
    internal Number Square();
    internal Number Negate();
    internal Number Not();
    internal Number Pow(int exp);
    private int Remainder(int m);
    private static Int32[] Remainder(Int32[] x, Int32[] y);
    internal Number Remainder(Number n);
    private Int32[] LastNBits(int n);
    private Number DivideWords(int w);
    private Number RemainderWords(int w);
    private static Int32[] ShiftLeft(Int32[] mag, int n);
    internal Number ShiftLeft(int n);
    private static void ShiftRightInPlace(int start, Int32[] mag, int n);
    private static void ShiftRightOneInPlace(int start, Int32[] mag);
    internal Number ShiftRight(int n);
    internal int get_SignValue();
    private static Int32[] Subtract(int xStart, Int32[] x, int yStart, Int32[] y);
    internal Number Subtract(Number n);
    private static Int32[] doSubBigLil(Int32[] bigMag, Int32[] lilMag);
    internal Byte[] ToByteArray();
    internal Byte[] ToByteArrayUnsigned();
    private Byte[] ToByteArray(bool unsigned);
    public virtual string ToString();
    public string ToString(int radix);
    private static void AppendZeroExtendedString(StringBuilder sb, string s, int minLength);
    private static Number CreateUValueOf(ulong value);
    private static Number CreateValueOf(long value);
    public static Number ValueOf(long value);
    private int GetLowestSetBitMaskFirst(int firstWordMask);
    internal bool TestBit(int value);
    internal Number Or(Number value);
    internal Number SetBit(int value);
    private Number FlipExistingBit(int value);
    internal int GetLowestSetBit();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Syncfusion.Pdf.Security.ObjectIdentityToken : object {
    private string m_id;
    private int m_index;
    internal bool HasMoreTokens { get; }
    internal ObjectIdentityToken(string id);
    internal bool get_HasMoreTokens();
    internal string NextToken();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Syncfusion.Pdf.Security.Ocsp : object {
    private Byte[] bytes;
    private Stream m_stream;
    private ManualResetEvent allDone;
    internal PdfSignatureValidationResult result;
    internal X509RevocationResponse GetBasicOCSPResponse(X509Certificate checkCertificate, X509Certificate rootCertificate, string url);
    internal Byte[] GetEncodedOcspRspnose(X509Certificate checkCert, X509Certificate rootCert, string url);
    private OcspRequestHelper GenerateOCSPRequest(X509Certificate issuerCertificate, Number serialNumber);
    private OcspResponseHelper GetOcspResponse(X509Certificate checkCertificate, X509Certificate rootCertificate, string url);
    internal Stream GetTimeStampResponse(string url);
    private void GetRequestStreamCallback(IAsyncResult asynchronousResult);
    private void GetResponseCallback(IAsyncResult asynchronousResult);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal abstract class Syncfusion.Pdf.Security.OcspConstants : object {
    internal static string OcspId;
    public static DerObjectID Ocsp;
    public static DerObjectID OcspBasic;
    public static DerObjectID OcspNonce;
    public static DerObjectID OcspCrl;
    public static DerObjectID OcspResponse;
    public static DerObjectID OcspNocheck;
    public static DerObjectID OcspArchiveCutoff;
    public static DerObjectID OcspServiceLocator;
    private static OcspConstants();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Syncfusion.Pdf.Security.OcspHelper : Asn1Encode {
    private ResponseInformation m_responseInformation;
    private Algorithms m_algorithms;
    private DerBitString m_signature;
    private Asn1Sequence m_sequence;
    internal DerBitString Signature { get; }
    internal Algorithms Algorithm { get; }
    internal Asn1Sequence Sequence { get; }
    public ResponseInformation ResponseInformation { get; }
    private OcspHelper(Asn1Sequence sequence);
    internal DerBitString get_Signature();
    internal Algorithms get_Algorithm();
    internal Asn1Sequence get_Sequence();
    public OcspHelper GetOcspStructure(object obj);
    public ResponseInformation get_ResponseInformation();
    public virtual Asn1 GetAsn1();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Syncfusion.Pdf.Security.OcspRequestCollection : Asn1Encode {
    private static DerInteger m_integer;
    private DerInteger m_version;
    private OcspTag m_requestorName;
    private Asn1Sequence m_requestList;
    private X509Extensions m_requestExtensions;
    private bool m_versionSet;
    public OcspRequestCollection(OcspTag requestorName, Asn1Sequence requestList, X509Extensions requestExtensions);
    private static OcspRequestCollection();
    public virtual Asn1 GetAsn1();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Syncfusion.Pdf.Security.OcspRequestCreator : object {
    private IList m_list;
    private OcspTag m_requestorName;
    private X509Extensions m_requestExtensions;
    internal void AddRequest(CertificateIdentity id);
    internal void SetRequestExtensions(X509Extensions extensions);
    private OcspRequestHelper CreateRequest(DerObjectID signingAlgorithm, CipherParameter privateKey, X509Certificate[] chain, int count);
    internal OcspRequestHelper Generate();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Syncfusion.Pdf.Security.OcspRequestHelper : X509ExtensionBase {
    private RevocationListRequest m_request;
    public OcspRequestHelper(RevocationListRequest request);
    protected virtual X509Extensions GetX509Extensions();
    public Byte[] GetEncoded();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Syncfusion.Pdf.Security.OcspResponse : Asn1Encode {
    private OcspResponseStatus m_responseStatus;
    private RevocationResponseBytes m_responseBytes;
    internal OcspResponseStatus ResponseStatus { get; }
    internal RevocationResponseBytes ResponseBytes { get; }
    private OcspResponse(Asn1Sequence sequence);
    internal OcspResponse GetOcspResponse(object obj);
    internal OcspResponseStatus get_ResponseStatus();
    internal RevocationResponseBytes get_ResponseBytes();
    public virtual Asn1 GetAsn1();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Syncfusion.Pdf.Security.OcspResponseHelper : object {
    private OcspResponse m_response;
    internal PdfSignatureValidationResult result;
    internal int Status { get; }
    public OcspResponseHelper(Stream stream);
    private OcspResponseHelper(Asn1Stream stream);
    internal int get_Status();
    internal object GetResponseObject();
}
internal class Syncfusion.Pdf.Security.OcspResponseStatus : DerCatalogue {
    internal static int Successful;
    internal static int MalformedRequest;
    internal static int InternalError;
    internal static int TryLater;
    internal static int SignatureRequired;
    internal static int Unauthorized;
    [NullableContextAttribute("1")]
internal OcspResponseStatus(DerCatalogue value);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Syncfusion.Pdf.Security.OcspStatus : Asn1Encode {
    private int m_tagNumber;
    private Asn1Encode m_value;
    internal int TagNumber { get; }
    internal OcspStatus(Asn1Tag choice);
    internal OcspStatus GetStatus(object obj);
    internal int get_TagNumber();
    public virtual Asn1 GetAsn1();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Syncfusion.Pdf.Security.OcspTag : Asn1Encode {
    internal Asn1Encode m_encode;
    internal int m_tagNumber;
    internal int TagNumber { get; }
    internal OcspTag(int tag, Asn1Encode encode);
    internal OcspTag GetOcspName(object obj);
    internal int get_TagNumber();
    public virtual Asn1 GetAsn1();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Syncfusion.Pdf.Security.OcspValidator : object {
    private List`1<X509RevocationResponse> m_responseCollection;
    internal RevocationStatus RevocationStatus;
    internal bool m_ocspResposne;
    internal bool m_ocspFromDSS;
    private bool m_isOcspEmbedded;
    internal PdfSignatureValidationResult result;
    internal bool IsOcspEmbedded { get; internal set; }
    internal OcspValidator(List`1<X509RevocationResponse> responses);
    internal bool get_IsOcspEmbedded();
    internal void set_IsOcspEmbedded(bool value);
    internal RevocationStatus Validate(X509Certificate signerCertificate, X509Certificate issuerCertificate, DateTime signDate, bool isCrlEmbbed);
    private void SetStatus(RevocationStatus status);
    private RevocationStatus Validate(X509RevocationResponse response, X509Certificate signCertificate, X509Certificate issuerCertificate, DateTime signDate, bool isOcspEmbbed);
    private void CheckResponse(X509RevocationResponse ocspResp, X509Certificate issuerCert);
    private bool CheckSignatureValidity(X509RevocationResponse ocspResp, X509Certificate responderCert);
    private X509RevocationResponse GetOcspResponse(X509Certificate signCert, X509Certificate issuerCert);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Syncfusion.Pdf.Security.OctetStream : Stream {
    private Asn1Parser m_helper;
    private bool m_first;
    private Stream m_stream;
    private bool m_closed;
    public bool CanRead { get; }
    public bool CanSeek { get; }
    public bool CanWrite { get; }
    public long Length { get; }
    public long Position { get; public set; }
    internal OctetStream(Asn1Parser helper);
    public virtual int Read(Byte[] buffer, int offset, int count);
    public virtual int ReadByte();
    public sealed virtual bool get_CanRead();
    public sealed virtual bool get_CanSeek();
    public sealed virtual bool get_CanWrite();
    public void Close();
    public sealed virtual void Flush();
    public sealed virtual long get_Length();
    public sealed virtual long get_Position();
    public sealed virtual void set_Position(long value);
    public sealed virtual long Seek(long offset, SeekOrigin origin);
    public sealed virtual void SetLength(long value);
    public sealed virtual void Write(Byte[] buffer, int offset, int count);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Syncfusion.Pdf.Security.OneTimeResponse : X509ExtensionBase {
    private OneTimeResponseHelper m_helper;
    internal GeneralizedTime NextUpdate { get; }
    internal GeneralizedTime CurrentUpdate { get; }
    internal CertificateIdentityHelper CertificateID { get; }
    internal object CertificateStatus { get; }
    internal OneTimeResponse(OneTimeResponseHelper helper);
    internal GeneralizedTime get_NextUpdate();
    internal GeneralizedTime get_CurrentUpdate();
    internal CertificateIdentityHelper get_CertificateID();
    internal object get_CertificateStatus();
    protected virtual X509Extensions GetX509Extensions();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Syncfusion.Pdf.Security.OneTimeResponseHelper : Asn1Encode {
    private CertificateIdentityHelper m_id;
    private OcspStatus m_certificateStatus;
    private GeneralizedTime m_currentUpdate;
    private GeneralizedTime m_nextUpdate;
    private X509Extensions m_extensions;
    internal CertificateIdentityHelper CertificateIdentification { get; }
    internal GeneralizedTime NextUpdate { get; }
    internal GeneralizedTime CurrentUpdate { get; }
    internal OcspStatus Status { get; }
    public OneTimeResponseHelper(Asn1Sequence sequence);
    internal CertificateIdentityHelper get_CertificateIdentification();
    internal GeneralizedTime get_NextUpdate();
    internal GeneralizedTime get_CurrentUpdate();
    internal OneTimeResponseHelper GetResponse(object obj);
    internal OcspStatus get_Status();
    public virtual Asn1 GetAsn1();
}
internal enum Syncfusion.Pdf.Security.PAdESSignatureLevel : Enum {
    public int value__;
    public static PAdESSignatureLevel None;
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Syncfusion.Pdf.Security.ParamUtility : object {
    private Dictionary`2<string, string> m_algorithms;
    private void AddAlgorithm(string name, Object[] objects);
    internal KeyParameter CreateKeyParameter(string algorithm, Byte[] bytes, int offset, int length);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal abstract class Syncfusion.Pdf.Security.PasswordGenerator : object {
    protected Byte[] m_password;
    protected Byte[] m_value;
    protected int m_count;
    internal abstract virtual ICipherParam GenerateParam(string algorithm, int keySize);
    internal abstract virtual ICipherParam GenerateParam(string algorithm, int keySize, int size);
    internal abstract virtual ICipherParam GenerateParam(int keySize);
    internal virtual void Init(Byte[] password, Byte[] value, int count);
    internal static Byte[] ToBytes(Char[] password, bool isWrong);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Syncfusion.Pdf.Security.PasswordUtility : object {
    private static string m_pkcs12;
    private Dictionary`2<string, string> m_algorithms;
    private Dictionary`2<string, string> m_type;
    private Dictionary`2<string, DerObjectID> m_ids;
    internal PasswordGenerator GetEncoder(string type, IMessageDigest digest, Byte[] key, Byte[] salt, int iterationCount);
    internal bool IsPkcs12(string algorithm);
    internal ICipherParam GenerateCipherParameters(DerObjectID algorithmOid, Char[] password, bool isWrong, Asn1Encode parameters);
    internal ICipherParam GenerateCipherParameters(Algorithms algID, Char[] password, bool isWrong);
    internal ICipherParam GenerateCipherParameters(string algorithm, Char[] password, bool isWrong, Asn1Encode pbeParameters);
    internal object CreateEncoder(DerObjectID algorithmOid);
    internal object CreateEncoder(Algorithms algId);
    internal object CreateEncoder(string algorithm);
    private ICipherParam FixDataEncryptionParity(string mechanism, ICipherParam parameters);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class Syncfusion.Pdf.Security.PdfCertificate : object {
    private static UInt32 CryptographicUserKeyset;
    private static UInt32 SystemStoreCertificateCurrentUser;
    private static UInt32 CertificateStoreReadonlyFlag;
    private static UInt32 CertificateStoreOpenExistingFlag;
    private static UInt32 X509AsnEncoding;
    private static UInt32 PKCS7AsnEncoding;
    private static UInt32 EncodingType;
    private static int X509Name;
    private static string RelativeDistinguishedName;
    private CryptoSignMessageParamerter m_signParameters;
    private int m_version;
    private Byte[] m_serialNumber;
    private string m_issuerName;
    private string m_subjectName;
    private IntPtr m_certificate;
    private UInt32 m_signatureLength;
    private DateTime m_validTo;
    private DateTime m_validFrom;
    private X509Certificate2 m_x509Certificate;
    internal PdfPKCSCertificate m_pkcs7Certificate;
    internal bool isPkcs7Certificate;
    internal bool isStore;
    internal X509Certificate[] Chains;
    private Dictionary`2<string, Dictionary`2<string, string>> m_distinguishedNameCollection;
    public int Version { get; }
    public Byte[] SerialNumber { get; }
    public string IssuerName { get; }
    public string SubjectName { get; }
    public DateTime ValidTo { get; }
    public DateTime ValidFrom { get; }
    internal IntPtr SysCertificate { get; }
    internal X509Certificate2 X509Certificate { get; }
    public PdfCertificate(Stream certificate, string password);
    internal PdfCertificate(PdfCmsSigner signer);
    public PdfCertificate(Stream certificate, string password, KeyStorageFlags storageFlag);
    internal PdfCertificate(IntPtr certificate);
    public PdfCertificate(X509Certificate2 x509Certificate2);
    internal PdfCertificate(X509Certificate2 x509Certificate2, bool buildChain);
    public int get_Version();
    public Byte[] get_SerialNumber();
    public string get_IssuerName();
    public string get_SubjectName();
    public DateTime get_ValidTo();
    public DateTime get_ValidFrom();
    internal IntPtr get_SysCertificate();
    internal X509Certificate2 get_X509Certificate();
    private Byte[] StreamToByteArray(Stream stream);
    private void InitializePkcs7Certificate(Byte[] data, Char[] password);
    private void LoadDetails(X509Certificate certificate);
    private string GetDistinguishedAttributes(string name, string key);
    private void AddStringToDictionary(string name, Dictionary`2<string, string> dictionary);
    private string GetName(string name, string key);
    private void Initialize(Stream certificate, string password);
    private void Initialize(IntPtr certificate);
    internal UInt32 GetSignatureLength();
    private static bool Equals(Byte[] arr1, Byte[] arr2);
}
public enum Syncfusion.Pdf.Security.PdfCertificationFlags : Enum {
    public int value__;
    public static PdfCertificationFlags ForbidChanges;
    public static PdfCertificationFlags AllowFormFill;
    public static PdfCertificationFlags AllowComments;
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Syncfusion.Pdf.Security.PdfCmsSigner : object {
    private static string rfc_FilterType;
    private int m_version;
    private int m_signerVersion;
    private string m_digestAlgorithmOid;
    private IMessageDigest m_messageDigest;
    private Dictionary`2<string, object> m_digestOid;
    private string m_encryptionAlgorithmOid;
    private Byte[] m_signedData;
    private Byte[] m_signedRSAData;
    private ISigner m_signer;
    private Byte[] m_digest;
    private Byte[] m_rsaData;
    private List`1<X509Certificate> m_certificates;
    private X509Certificate m_signCert;
    private string m_encryptionAlgorithm;
    private bool m_isTimeStamp;
    private Byte[] m_digestAttributeData;
    private Byte[] m_sigAttribute;
    private Byte[] m_sigAttributeDer;
    private Byte[] m_timestampCertificates;
    private IMessageDigest m_encodedMessageDigest;
    private MessageDigestAlgorithms m_digestAlgorithm;
    private MessageDigestFinder m_digestFinder;
    private X509RevocationResponse m_basicOcspResponse;
    private TimeStampToken m_timeStampToken;
    private string m_ocspID;
    private string m_hashAlgorithm;
    private List`1<X509RevocationResponse> ocspResponseCollection;
    internal bool m_timeStampDocument;
    private string m_storeFilterType;
    private PdfSignature m_signature;
    private List`1<X509RevocationResponse> m_embbedOCSPs;
    private List`1<X509RevocationResponse> m_dssOCSPs;
    internal Asn1Sequence m_crlSequence;
    internal List`1<Byte[]> m_crlByteCollection;
    internal List`1<Byte[]> m_ocspByteCollection;
    internal LtvVerificationInfo m_ltvVerificationInfo;
    internal X509CertificateCollection rootCertificates;
    private List`1<string> m_foundOCSPs;
    private List`1<string> m_foundCRLs;
    private Dictionary`2<string, List`1<Dictionary`2<string, List`1<string>>>> m_revocationCertURIs;
    private List`1<string> intermediateIssueNames;
    private bool isLtvEnabled;
    private List`1<string> m_certSerialNumbers;
    private X509Certificate2 m_certificate2;
    private List`1<X509Certificate> endCertificates;
    internal List`1<X509Certificate> CertificateList { get; }
    internal X509Certificate SignerCertificate { get; }
    internal PdfSignature Signature { get; internal set; }
    internal IMessageDigest MessageDigest { get; }
    internal string HashAlgorithm { get; }
    internal string MessageDigestAlgorithm { get; }
    public string EncryptionAlgorithm { get; }
    internal PdfCmsSigner(ICipherParam privateKey, ICollection`1<X509Certificate> certChain, string hashAlgorithm, bool hasRSAdata);
    internal PdfCmsSigner(string hashAlgorithm, bool hasRSAdata);
    internal PdfCmsSigner(Byte[] contentByte, Byte[] certBytes);
    internal PdfCmsSigner(Byte[] bytes, string subFilter, PdfSignatureValidationOptions options);
    internal List`1<X509Certificate> get_CertificateList();
    internal X509Certificate get_SignerCertificate();
    internal PdfSignature get_Signature();
    internal void set_Signature(PdfSignature value);
    internal IMessageDigest get_MessageDigest();
    internal string get_HashAlgorithm();
    internal void SetSignedData(Byte[] digest, Byte[] RSAdata, string digestEncryptionAlgorithm);
    internal Byte[] Sign(Byte[] secondDigest, TimeStampServer server, Byte[] timeStampResponse, Byte[] ocsp, ICollection`1<Byte[]> crls, CryptographicStandard sigtype, string hashAlgorithm);
    internal Byte[] GetEncodedTimestamp(Byte[] secondDigest, TimeStampServer server);
    private Asn1EncodeCollection GetAttributes(Byte[] timeStampToken);
    private Asn1 GetIssuer(Byte[] data);
    internal Byte[] GetSequenceData(Byte[] secondDigest, Byte[] ocsp, ICollection`1<Byte[]> crlBytes, CryptographicStandard sigtype);
    private DerSet GetSequenceDataSet(Byte[] secondDigest, Byte[] ocsp, ICollection`1<Byte[]> crlBytes, CryptographicStandard sigtype);
    internal string get_MessageDigestAlgorithm();
    public string get_EncryptionAlgorithm();
    internal void Update(Byte[] bytes, int offset, int length);
    private List`1<X509Certificate> GetCertificateChain(X509Certificate signCert, IList`1<X509Certificate> certs);
    internal bool ValidateCertificateWithCollection(List`1<X509Certificate> collection, DateTime signDate, PdfSignatureValidationResult signatureResult);
    internal List`1<string> GetSupportedOids();
    private bool IsSupportedOid(List`1<string> oids, X509Certificate certificate);
    private bool ValidateCertificates(X509Certificate certificate, DateTime signDate);
    internal X509Certificate2Collection GetCertificates();
    internal bool ValidateChecksum();
    private X509Certificate CheckCertificateValidation(DateTime signDate, PdfSignatureValidationResult result);
    private bool ValidateAttributes(Byte[] attr);
    internal TimeStampInformation ValidateTimestamp();
    private ISigner InitializeSignature();
    private void GetOcsp(Asn1Sequence sequenceObj, bool dss);
    private X509Certificate2 TimeStampCertificates();
    internal RevocationResult CheckRevocation(DateTime signedDate, PdfSignatureValidationResult validationResult);
    private void UpdateIntermediateURIs();
    private void UpdateEmbbedOCSP(Dictionary`2<string, X509RevocationResponse> ocsps);
    private void UpdateDSSOCSP(Dictionary`2<string, X509RevocationResponse> ocsps);
    private void UpdateOCSPCollection(Dictionary`2<string, X509RevocationResponse> ocsps, X509RevocationResponse m_basicOcspResponse);
    private void UpdateFromDSS(Byte[] bytes, Dictionary`2<string, X509RevocationResponse> ocsps);
    private void UpdateEmbbedCRL(Dictionary`2<string, CertificateCollection> crls, CertificateCollection certificateList);
    private void UpdateCertificateCollection(Byte[] bytes, CertificateCollection& certificateList);
    private string GetDistinguishedAttributes(string name, string key);
    private void AddStringToDictionary(string name, Dictionary`2<string, string> dictionary);
    private Byte[] ReadPemCRL(Stream stream);
    private void Close();
    private void UpdateDSSCollection();
    private List`1<Byte[]> GetByteCollection(PdfArray array);
    internal void UpdateSignerDetails(List`1<PdfSignerCertificate> signerCertificates, PdfSignatureValidationResult validationResult);
    internal void UpdateTimeStampSignerDetails(List`1<PdfSignerCertificate> signerCertificates);
    private List`1<X509Certificate2> TimeStampChainCertificates();
    internal List`1<X509Certificate2> GetTimeStampCertificates(List`1<X509Certificate2> certificates);
    private bool IsDssContainsCertCollection();
    private void GetExtensionUrls(X509Extension extension, List`1& crlUrls);
    private void CheckRootCertficate(Boolean& rootFound);
    private void UpdateCertCollection();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class Syncfusion.Pdf.Security.PdfDocumentSecureStore : object {
    private PdfCatalog m_catalog;
    private X509Certificate2[] certificates;
    public X509Certificate2[] Certificates { get; }
    internal PdfDocumentSecureStore(PdfCatalog catalog);
    public X509Certificate2[] get_Certificates();
    private void ReadCertificates();
}
internal class Syncfusion.Pdf.Security.PdfEncryption : object {
    internal static long Sequence;
    private static PdfEncryption();
    [NullableContextAttribute("1")]
internal static Byte[] CreateDocumentId();
}
public enum Syncfusion.Pdf.Security.PdfEncryptionAlgorithm : Enum {
    public int value__;
    public static PdfEncryptionAlgorithm RC4;
    public static PdfEncryptionAlgorithm AES;
}
public enum Syncfusion.Pdf.Security.PdfEncryptionKeySize : Enum {
    public int value__;
    public static PdfEncryptionKeySize Key40Bit;
    public static PdfEncryptionKeySize Key128Bit;
    public static PdfEncryptionKeySize Key256Bit;
    public static PdfEncryptionKeySize Key256BitRevision6;
}
public enum Syncfusion.Pdf.Security.PdfEncryptionOptions : Enum {
    public int value__;
    public static PdfEncryptionOptions EncryptAllContents;
    public static PdfEncryptionOptions EncryptAllContentsExceptMetadata;
    public static PdfEncryptionOptions EncryptOnlyAttachments;
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Syncfusion.Pdf.Security.PdfEncryptor : object {
    private static int c_newKeyOffset;
    private static int c_key40;
    private static int c_key128;
    private static int c_key256;
    private static int c_40RevisionNumber;
    private static int c_128RevisionNumber;
    private static int c_bytesAmount;
    private static int c_randomBytesAmount;
    private static int c_stringLength;
    private static int c_ownerLoopNum;
    private static int c_ownerLoopNum2;
    private static byte c_flagNum;
    internal static byte c_numBits;
    private static int c_permissionSet;
    private static int c_permissionCleared;
    private static int c_permissionRevisionTwoMask;
    private bool m_hasComputedPasswordValues;
    private IMessageDigest MD5;
    private Byte[] m_customArray;
    private Byte[] m_randomBytes;
    private string m_ownerPassword;
    private string m_userPassword;
    private Byte[] m_ownerPasswordOut;
    private Byte[] m_userPasswordOut;
    private Byte[] m_encryptionKey;
    private PdfEncryptionKeySize m_keyLength;
    private PdfPermissionsFlags m_permission;
    private int m_revision;
    private bool m_bChanged;
    private static Byte[] s_paddingString;
    private static object s_lockObject;
    private bool m_encrypt;
    private int m_permissionValue;
    private static Byte[] salt;
    private PdfEncryptionAlgorithm m_encryptionAlgorithm;
    private Byte[] m_userEncryptionKeyOut;
    private Byte[] m_ownerEncryptionKeyOut;
    private Byte[] m_permissionFlag;
    private Byte[] m_fileEncryptionKey;
    private Byte[] m_userRandomBytes;
    private Byte[] m_ownerRandomBytes;
    private SecureRandomAlgorithm m_randomArray;
    private bool m_encryptMetadata;
    private int m_revisionNumberOut;
    private int m_versionNumberOut;
    private int keyLength;
    private String[] HashAlgorithms;
    private Byte[] m_documentID;
    private bool m_encryptOnlyAttachment;
    internal PdfArray FileID { get; }
    public string Filter { get; }
    public PdfEncryptionKeySize CryptographicAlgorithm { get; public set; }
    public PdfEncryptionAlgorithm EncryptionAlgorithm { get; public set; }
    internal PdfPermissionsFlags Permissions { get; internal set; }
    public int RevisionNumber { get; }
    internal string OwnerPassword { get; internal set; }
    internal string UserPassword { get; internal set; }
    protected Byte[] RandomBytes { get; }
    internal bool EncryptOnlyAttachment { get; internal set; }
    protected Byte[] CustomArray { get; protected set; }
    protected Encoding SecurityEncoding { get; }
    protected Byte[] EncryptionKey { get; protected set; }
    internal bool Encrypt { get; internal set; }
    internal Byte[] UserPasswordOut { get; }
    internal Byte[] OwnerPasswordOut { get; }
    internal bool Changed { get; }
    internal bool EncryptMetaData { get; internal set; }
    protected static Byte[] PaddingString { get; protected set; }
    private static PdfEncryptor();
    internal PdfArray get_FileID();
    public string get_Filter();
    public PdfEncryptionKeySize get_CryptographicAlgorithm();
    public void set_CryptographicAlgorithm(PdfEncryptionKeySize value);
    public PdfEncryptionAlgorithm get_EncryptionAlgorithm();
    public void set_EncryptionAlgorithm(PdfEncryptionAlgorithm value);
    internal PdfPermissionsFlags get_Permissions();
    internal void set_Permissions(PdfPermissionsFlags value);
    public int get_RevisionNumber();
    internal string get_OwnerPassword();
    internal void set_OwnerPassword(string value);
    internal string get_UserPassword();
    internal void set_UserPassword(string value);
    protected Byte[] get_RandomBytes();
    internal bool get_EncryptOnlyAttachment();
    internal void set_EncryptOnlyAttachment(bool value);
    protected Byte[] get_CustomArray();
    protected void set_CustomArray(Byte[] value);
    protected Encoding get_SecurityEncoding();
    protected Byte[] get_EncryptionKey();
    protected void set_EncryptionKey(Byte[] value);
    internal bool get_Encrypt();
    internal void set_Encrypt(bool value);
    internal Byte[] get_UserPasswordOut();
    internal Byte[] get_OwnerPasswordOut();
    internal bool get_Changed();
    internal bool get_EncryptMetaData();
    internal void set_EncryptMetaData(bool value);
    protected static Byte[] get_PaddingString();
    protected static void set_PaddingString(Byte[] value);
    internal PdfEncryptor Clone();
    internal void ReadFromDictionary(PdfDictionary dictionary);
    internal bool CheckPassword(string password, PdfString key, bool attachEncryption);
    internal Byte[] EncryptData(long currObjNumber, Byte[] data, bool isEncryption);
    internal void SaveToDictionary(PdfDictionary dictionary);
    private Byte[] PadTrancateString(string source);
    private Byte[] PadTrancateString(Byte[] sourceBytes);
    private Byte[] EncryptDataByCustom(Byte[] data, Byte[] key);
    private Byte[] EncryptDataByCustom(Byte[] data, Byte[] key, int keyLen);
    private Byte[] AESEncrypt(Byte[] data, Byte[] key);
    private Byte[] AESDecrypt(Byte[] data, Byte[] key);
    private Byte[] EncryptData256(Byte[] data);
    private Byte[] DecryptData256(Byte[] data);
    private Byte[] GenerateIV();
    private void RecreateCustomArray(Byte[] key, int keyLen);
    protected internal int GetKeyLength();
    private Byte[] CreateOwnerPassword();
    private Byte[] AcrobatXComputeHash(Byte[] input, Byte[] password, Byte[] Key);
    private Byte[] Create256BitOwnerPassword();
    private void CreateAcrobatX256BitOwnerPassword();
    private Byte[] CreateOwnerEncryptionKey();
    private Byte[] GetKeyFromOwnerPass(string password);
    private void FindFileEncryptionKey(string password);
    private void AcrobatXOwnerFileEncryptionKey(string password);
    private void AdvanceXUserFileEncryptionKey(string password);
    private Byte[] GetKeyForOwnerPassStep7(Byte[] originalKey, byte index);
    private Byte[] CreateEncryptionKey(string inputPass, Byte[] ownerPass);
    private void CreateFileEncryptionKey();
    private Byte[] CreateUserPassword();
    private Byte[] Create256BitUserPassword();
    private void CreateAcrobatX256BitUserPassword();
    private Byte[] CreateUserEncryptionKey();
    private Byte[] CreatePermissionFlag();
    private Byte[] Create40BitUserPassword();
    private Byte[] Create128BitUserPassword();
    private void InitializeData();
    private Byte[] PrepareKeyForEncryption(Byte[] originalKey);
    private bool AuthenticateUserPassword(string password);
    private bool Authenticate256BitUserPassword(string password);
    private bool AuthenticateOwnerPassword(string password);
    private bool Authenticate256BitOwnerPassword(string password);
    private string ConvertToPassword(Byte[] array);
    private bool CompareByteArrays(Byte[] array1, Byte[] array2);
    private bool CompareByteArrays(Byte[] array1, Byte[] array2, int size);
    private PdfDictionary AESDictionary();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Syncfusion.Pdf.Security.PdfHexEncoder : object {
    private static IHexEncoder encoder;
    private static PdfHexEncoder();
    public static Byte[] Decode(string data);
    public static string DecodeString(string data);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Syncfusion.Pdf.Security.PdfIntArray : object {
    private Int32[] intValues;
    public int BitLength { get; }
    public int Length { get; }
    public PdfIntArray(int length);
    private PdfIntArray(Int32[] values);
    public PdfIntArray(Number bigInterger, int minimumLength);
    public int GetLength();
    public int get_BitLength();
    private Int32[] ResizedValues(int length);
    public Number ToBigInteger();
    public void ShiftLeft();
    public PdfIntArray ShiftLeft(int number);
    public void AddShifted(PdfIntArray values, int shift);
    public int get_Length();
    public bool TestBit(int number);
    public void FlipBit(int number);
    public void SetBit(int number);
    public PdfIntArray Multiply(PdfIntArray values, int value);
    public void Reduce(int value, Int32[] redPol);
    public PdfIntArray Square(int value);
    public virtual bool Equals(object o);
    public virtual int GetHashCode();
    internal PdfIntArray Copy();
    public virtual string ToString();
}
[FlagsAttribute]
public enum Syncfusion.Pdf.Security.PdfPermissionsFlags : Enum {
    public int value__;
    public static PdfPermissionsFlags Default;
    public static PdfPermissionsFlags Print;
    public static PdfPermissionsFlags EditContent;
    public static PdfPermissionsFlags CopyContent;
    public static PdfPermissionsFlags EditAnnotations;
    public static PdfPermissionsFlags FillFields;
    public static PdfPermissionsFlags AccessibilityCopyContent;
    public static PdfPermissionsFlags AssembleDocument;
    public static PdfPermissionsFlags FullQualityPrint;
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Syncfusion.Pdf.Security.PdfPKCSCertificate : object {
    private CertificateTable m_keys;
    private CertificateTable m_certificates;
    private Dictionary`2<string, string> m_localIdentifiers;
    private Dictionary`2<CertificateIdentifier, X509Certificates> m_chainCertificates;
    private Dictionary`2<string, X509Certificates> m_keyCertificates;
    internal IEnumerable KeyEnumerable { get; }
    public PdfPKCSCertificate(Stream input, Char[] password);
    private static SubjectKeyID CreateSubjectKeyID(CipherParameter publicKey);
    private static void DecompressBytes(Byte[] encKey, int offset, Number byteBI);
    internal void LoadCertificate(Stream input, Char[] password);
    internal KeyEntry GetKey(string key);
    internal bool IsCertificate(string key);
    internal bool IsKey(string key);
    private IDictionary GetContentTable();
    internal IEnumerable get_KeyEnumerable();
    internal X509Certificates GetCertificate(string key);
    internal X509Certificates[] GetCertificateChain(string key);
    private static Byte[] GetCryptographicData(bool forEncryption, Algorithms id, Char[] password, bool isZero, Byte[] data);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class Syncfusion.Pdf.Security.PdfRevocationCertificate : object {
    private bool isEmbedded;
    private DateTime validFrom;
    private DateTime validTo;
    private X509Certificate2[] certificates;
    private bool isRevokedCRL;
    private RevokedCertificate[] revokedCertificates;
    public bool IsEmbedded { get; internal set; }
    public DateTime ValidFrom { get; internal set; }
    public DateTime ValidTo { get; internal set; }
    public X509Certificate2[] Certificates { get; internal set; }
    public bool IsRevokedCRL { get; internal set; }
    public RevokedCertificate[] RevokedCertificates { get; internal set; }
    public bool get_IsEmbedded();
    internal void set_IsEmbedded(bool value);
    public DateTime get_ValidFrom();
    internal void set_ValidFrom(DateTime value);
    public DateTime get_ValidTo();
    internal void set_ValidTo(DateTime value);
    public X509Certificate2[] get_Certificates();
    internal void set_Certificates(X509Certificate2[] value);
    public bool get_IsRevokedCRL();
    internal void set_IsRevokedCRL(bool value);
    public RevokedCertificate[] get_RevokedCertificates();
    internal void set_RevokedCertificates(RevokedCertificate[] value);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class Syncfusion.Pdf.Security.PdfSecurity : object {
    private string m_ownerPassword;
    private string m_userPassword;
    private PdfEncryptor m_encryptor;
    internal bool m_modifiedSecurity;
    internal bool m_encryptOnlyAttachment;
    internal PdfEncryptionOptions m_encryptionOption;
    public string OwnerPassword { get; public set; }
    public string UserPassword { get; public set; }
    public PdfPermissionsFlags Permissions { get; public set; }
    internal PdfEncryptor Encryptor { get; internal set; }
    public PdfEncryptionKeySize KeySize { get; public set; }
    public PdfEncryptionAlgorithm Algorithm { get; public set; }
    internal bool Enabled { get; internal set; }
    internal bool EncryptOnlyAttachment { get; internal set; }
    public PdfEncryptionOptions EncryptionOptions { get; public set; }
    public string get_OwnerPassword();
    public void set_OwnerPassword(string value);
    public string get_UserPassword();
    public void set_UserPassword(string value);
    public PdfPermissionsFlags get_Permissions();
    public void set_Permissions(PdfPermissionsFlags value);
    internal PdfEncryptor get_Encryptor();
    internal void set_Encryptor(PdfEncryptor value);
    public PdfEncryptionKeySize get_KeySize();
    public void set_KeySize(PdfEncryptionKeySize value);
    public PdfEncryptionAlgorithm get_Algorithm();
    public void set_Algorithm(PdfEncryptionAlgorithm value);
    internal bool get_Enabled();
    internal void set_Enabled(bool value);
    internal bool get_EncryptOnlyAttachment();
    internal void set_EncryptOnlyAttachment(bool value);
    public PdfEncryptionOptions get_EncryptionOptions();
    public void set_EncryptionOptions(PdfEncryptionOptions value);
    public PdfPermissionsFlags SetPermissions(PdfPermissionsFlags flags);
    public PdfPermissionsFlags ResetPermissions(PdfPermissionsFlags flags);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class Syncfusion.Pdf.Security.PdfSignature : object {
    internal PdfSignatureDictionary m_signatureDictionary;
    private PdfDictionary fieldDictionary;
    private PdfSignatureField m_field;
    private PdfLoadedSignatureField m_sigField;
    private PdfCertificate m_pdfCertificate;
    private string m_reason;
    private PdfPageBase m_page;
    private string m_location;
    private string m_contactInformation;
    private PdfArray m_byteRange;
    private bool m_certeficated;
    private PdfCertificationFlags m_documentPermission;
    private TimeStampServer m_timeStampServer;
    private bool m_hasDocumentPermission;
    internal PdfDocumentBase m_document;
    private bool m_drawSignatureAppearance;
    private bool m_enabledValiadtionAppearance;
    private SizeF size;
    internal bool isTimeStampOnly;
    private PdfDictionary m_dssDictionary;
    private bool m_enableLTV;
    internal DateTime m_signedDate;
    internal string m_signedName;
    private PdfSignatureSettings m_signatureSettings;
    private IPdfExternalSigner m_externalSigner;
    private Byte[] m_ocsp;
    private ICollection`1<Byte[]> m_crlBytes;
    private bool m_isExternalOCSP;
    private List`1<X509Certificate2> m_externalRootCert;
    private List`1<X509Certificate> m_externalChain;
    private Byte[] m_inputBytes;
    private Stream m_stream;
    private ManualResetEvent m_allDone;
    private UInt32 m_estimatedSize;
    internal bool m_lock;
    internal bool m_signed;
    private Byte[] m_signatureContentBytes;
    internal bool m_isPermissionUpdated;
    internal bool m_addCerts;
    [CompilerGeneratedAttribute]
private PdfSignatureEventHandler ComputeHash;
    [CompilerGeneratedAttribute]
private AsyncPdfSignatureEventHandler AsyncComputeHash;
    internal PdfDictionary Dictionary { get; internal set; }
    public PdfSignatureSettings Settings { get; }
    [ObsoleteAttribute("Please use Appearance instead")]
public PdfAppearance Appearence { get; }
    public PdfAppearance Appearance { get; }
    public PointF Location { get; public set; }
    public RectangleF Bounds { get; public set; }
    public string ContactInfo { get; public set; }
    internal PdfArray ByteRange { get; internal set; }
    public string Reason { get; public set; }
    public string LocationInfo { get; public set; }
    public bool Certificated { get; public set; }
    public PdfCertificationFlags DocumentPermissions { get; public set; }
    internal bool HasDocumentPermission { get; internal set; }
    public PdfCertificate Certificate { get; public set; }
    public bool EnableLtv { get; public set; }
    public bool Visible { get; }
    public TimeStampServer TimeStampServer { get; public set; }
    internal PdfField Field { get; }
    internal bool DrawFieldAppearance { get; }
    public bool EnableValidationAppearance { get; public set; }
    public DateTime SignedDate { get; }
    public string SignedName { get; public set; }
    internal bool IsLTVEnabled { get; }
    internal Byte[] OCSP { get; }
    internal ICollection`1<Byte[]> CRLBytes { get; }
    internal IPdfExternalSigner ExternalSigner { get; }
    internal List`1<X509Certificate2> ExternalCertificates { get; }
    internal UInt32 EstimatedSignatureSize { get; public set; }
    public bool IsLocked { get; public set; }
    internal Byte[] SignatureContentBytes { get; internal set; }
    public PdfSignature(PdfPage page, PdfCertificate cert, string signatureName);
    public PdfSignature(PdfPage page, string signatureName);
    public PdfSignature(PdfLoadedPage page, string signatureName);
    public PdfSignature(PdfDocumentBase document, PdfPageBase page, PdfCertificate certificate, string signatureName);
    public PdfSignature(PdfDocumentBase document, PdfPageBase page, PdfCertificate certificate, string signatureName, PdfLoadedSignatureField loadedField);
    internal PdfDictionary get_Dictionary();
    internal void set_Dictionary(PdfDictionary value);
    [CompilerGeneratedAttribute]
public void add_ComputeHash(PdfSignatureEventHandler value);
    [CompilerGeneratedAttribute]
public void remove_ComputeHash(PdfSignatureEventHandler value);
    [CompilerGeneratedAttribute]
internal void add_AsyncComputeHash(AsyncPdfSignatureEventHandler value);
    [CompilerGeneratedAttribute]
internal void remove_AsyncComputeHash(AsyncPdfSignatureEventHandler value);
    public PdfSignatureSettings get_Settings();
    public PdfAppearance get_Appearence();
    public PdfAppearance get_Appearance();
    public PointF get_Location();
    public void set_Location(PointF value);
    public RectangleF get_Bounds();
    public void set_Bounds(RectangleF value);
    public string get_ContactInfo();
    public void set_ContactInfo(string value);
    internal PdfArray get_ByteRange();
    internal void set_ByteRange(PdfArray value);
    public string get_Reason();
    public void set_Reason(string value);
    public string get_LocationInfo();
    public void set_LocationInfo(string value);
    public bool get_Certificated();
    public void set_Certificated(bool value);
    public PdfCertificationFlags get_DocumentPermissions();
    public void set_DocumentPermissions(PdfCertificationFlags value);
    internal bool get_HasDocumentPermission();
    internal void set_HasDocumentPermission(bool value);
    public PdfCertificate get_Certificate();
    public void set_Certificate(PdfCertificate value);
    public bool get_EnableLtv();
    public void set_EnableLtv(bool value);
    public bool get_Visible();
    public TimeStampServer get_TimeStampServer();
    public void set_TimeStampServer(TimeStampServer value);
    internal PdfField get_Field();
    internal bool get_DrawFieldAppearance();
    public void set_EnableValidationAppearance(bool value);
    public bool get_EnableValidationAppearance();
    private bool IsEnableValidationAppearance();
    public DateTime get_SignedDate();
    public string get_SignedName();
    public void set_SignedName(string value);
    internal bool get_IsLTVEnabled();
    internal Byte[] get_OCSP();
    internal ICollection`1<Byte[]> get_CRLBytes();
    internal IPdfExternalSigner get_ExternalSigner();
    internal List`1<X509Certificate2> get_ExternalCertificates();
    internal UInt32 get_EstimatedSignatureSize();
    public void set_EstimatedSignatureSize(UInt32 value);
    public bool get_IsLocked();
    public void set_IsLocked(bool value);
    internal Byte[] get_SignatureContentBytes();
    internal void set_SignatureContentBytes(Byte[] value);
    internal void SetValidationApperance();
    private string ReviseSignatureValidationStream(string validationStreamData);
    private void SetFittingFontSize(RectangleF rect, PdfFont font, string text);
    private void SetMatrix(PdfDictionary template);
    private Single[] findScale(float m_templateWidth, float m_templateHeight);
    private void CheckAnnotationElementsContainsSignature(PdfPageBase page, string signatureName);
    private void EnableLtvFromTimestamp();
    public void CreateLongTermValidity(List`1<X509Certificate2> certificates, bool includePublicCertificates);
    public void CreateLongTermValidity(List`1<X509Certificate2> certificates, RevocationType type, bool includePublicCertificates);
    internal void CreateLongTermValidity(List`1<X509Certificate2> certificates, List`1<Byte[]> ocspResponseData, List`1<Byte[]> crlResponseData);
    private List`1<X509Certificate> GetX509CertificateList(List`1<X509Certificate2> certificates);
    private bool GetLTVData(List`1<X509Certificate> x509CertificateList, List`1<Byte[]> ocspResponseData, List`1<Byte[]> crlResponseData);
    private bool GetLTVData(List`1<X509Certificate> x509CertificateList, List`1<Byte[]> ocspResponseData, List`1<Byte[]> crlResponseData, RevocationType revocationType);
    public void AddExternalSigner(IPdfExternalSigner signer, List`1<X509Certificate2> publicCertificates, Byte[] Ocsp);
    internal void OnComputeHash(PdfSignatureEventArgs args);
    public static void ReplaceEmptySignature(Stream inputFileStream, string pdfPassword, Stream outputFileStream, string signatureName, IPdfExternalSigner externalSigner, List`1<X509Certificate2> publicCertificates);
    public static void ReplaceEmptySignature(Stream inputFileStream, string pdfPassword, Stream outputFileStream, string signatureName, IPdfExternalSigner externalSigner, List`1<X509Certificate2> publicCertificates, bool isEncodeSignature);
    private static void TransferBytes(Stream sourceStream, long positionStart, long length, Stream destination);
    private static int FindLocation(long currentPosition, Byte[] data, int offsetPosition, int length, Stream sourceStream);
    private bool CheckCertificated();
    private bool RemoveUnusedDocMDP();
    private bool GetDSSDetails(List`1<X509Certificate> certificates, Ocsp ocsp, RevocationList crl, RevocationType revocationType, List`1<Byte[]> certCollection);
    private List`1<Byte[]> GetOCSPData(Ocsp ocsp, List`1<X509Certificate> certificates);
    private bool GetDSSDetails(List`1<X509Certificate> certificates, List`1<Byte[]> ocspCollection, RevocationList crl, List`1<Byte[]> certCollection);
    private bool GetDssDetails(List`1<Byte[]> crlCollection, List`1<Byte[]> ocspCollection, List`1<Byte[]> certCollection);
    private string GetVRIName();
    private static Byte[] BuildOCSPResponse(Byte[] BasicOCSPResponse);
    private X509Certificate GetRoot(X509Certificate cert, List`1<X509Certificate> certs);
    private Byte[] GetEncoded(X509Certificate checkCert, X509Certificate rootCert, string url);
    internal X509RevocationResponse GetBasicOCSPResponse(X509Certificate checkCert, X509Certificate rootCert, string url);
    private OcspResponseHelper GetOcspResponse(X509Certificate checkCert, X509Certificate rootCert, string url);
    [AsyncStateMachineAttribute("Syncfusion.Pdf.Security.PdfSignature/<GetTimeStampResponse>d__161")]
internal Task`1<Byte[]> GetTimeStampResponse(Byte[] request, string url);
    private static OcspRequestHelper GenerateOCSPRequest(X509Certificate issuerCert, Number serialNumber);
    private static Asn1 GetExtensionValue(X509Certificate cert, string oid);
    internal void EnableExternalLTV();
    private void LockSignature();
    private List`1<X509Certificate2> AddTimeStampCertificates(List`1<X509Certificate2> certificates);
    private List`1<X509Certificate2> TimeStampServerCertificate(List`1<X509Certificate2> certificates);
    private void Catalog_BeginSave(object sender, SavePdfPrimitiveEventArgs ars);
    private void Dictionary_BeginSave(object sender, SavePdfPrimitiveEventArgs ars);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Syncfusion.Pdf.Security.PdfSignatureDictionary : object {
    private static string c_Type;
    private static string ts_Type;
    private static string c_cmsFilterType;
    internal static string CadasFilterType;
    private static string rfc_FilterType;
    internal static string StoreFilterType;
    private static string c_DocMdp;
    private static string c_TransParam;
    private UInt32 c_EstimatedSize;
    private PdfDocumentBase m_doc;
    private PdfSignature m_sig;
    private PdfCertificate m_cert;
    private int m_firstRangeLength;
    private int m_secondRangeIndex;
    private int m_startPositionByteRange;
    private int m_docDigestPosition;
    private int m_fieldsDigestPosition;
    private PdfDictionary m_dictionary;
    private bool m_isEndCertOnly;
    private Stream m_stream;
    private Int64[] m_range;
    public bool Archive { get; public set; }
    private IPdfPrimitive Syncfusion.Pdf.IPdfWrapper.Element { get; }
    internal PdfSignatureDictionary(PdfDocumentBase doc, PdfSignature sig, PdfCertificate cert);
    internal PdfSignatureDictionary(PdfDocumentBase doc, PdfDictionary dic);
    internal PdfSignatureDictionary(PdfDocumentBase doc, PdfSignature sig);
    public bool get_Archive();
    public void set_Archive(bool value);
    private void AddRequiredItems();
    private void AddOptionalItems();
    private void AddLocation();
    private void AddContactInfo();
    private void AddType();
    private void AddSignedName();
    private void AddDate();
    private void AddReason();
    private void AddFilter();
    private void AddSubFilter();
    private void AddContents(IPdfWriter writer);
    private void AddRange(IPdfWriter writer);
    private bool AllowMDP();
    private void AddDigest(IPdfWriter writer);
    private void DocumentSaved(object sender, DocumentSavedEventArgs e);
    private string GetPortableStoreCertificate();
    private Byte[] GetPKCS7Content();
    private string GetDigestAlgorithm(DigestAlgorithm digest);
    private Byte[] GetPKCS7TimeStampContent();
    private IRandom GetUnderlyingSource();
    private int SaveRangeItem(PdfWriter writer, string str, int startPosition);
    private void AddReference();
    private int CreateAsn1TspRequest(Byte[] sha1Hash, Stream input);
    private void Dictionary_BeginSave(object sender, SavePdfPrimitiveEventArgs args);
    private sealed virtual override IPdfPrimitive Syncfusion.Pdf.IPdfWrapper.get_Element();
}
internal class Syncfusion.Pdf.Security.PdfSignatureDigest : object {
    [NullableAttribute("1")]
private List`1<object> m_objList;
    private PdfPrimitiveId m_id;
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class Syncfusion.Pdf.Security.PdfSignatureEventArgs : EventArgs {
    private Byte[] m_data;
    private Byte[] m_signedData;
    public Byte[] Data { get; }
    public Byte[] SignedData { get; public set; }
    internal PdfSignatureEventArgs(Byte[] documentData);
    public Byte[] get_Data();
    public Byte[] get_SignedData();
    public void set_SignedData(Byte[] value);
}
public class Syncfusion.Pdf.Security.PdfSignatureEventHandler : MulticastDelegate {
    public PdfSignatureEventHandler(object object, IntPtr method);
    [NullableContextAttribute("1")]
public virtual void Invoke(object sender, PdfSignatureEventArgs ars);
    public virtual IAsyncResult BeginInvoke(object sender, PdfSignatureEventArgs ars, AsyncCallback callback, object object);
    public virtual void EndInvoke(IAsyncResult result);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class Syncfusion.Pdf.Security.PdfSignatureSettings : object {
    private DigestAlgorithm m_digestAlgorithm;
    private CryptographicStandard m_cryptoStandard;
    private bool m_hasChanged;
    private PdfLoadedSignatureField m_field;
    private bool m_digestUpdated;
    internal PdfLoadedSignatureField SignatureField { get; internal set; }
    public DigestAlgorithm DigestAlgorithm { get; public set; }
    public CryptographicStandard CryptographicStandard { get; public set; }
    internal bool HasChanged { get; }
    internal PdfLoadedSignatureField get_SignatureField();
    internal void set_SignatureField(PdfLoadedSignatureField value);
    public DigestAlgorithm get_DigestAlgorithm();
    public void set_DigestAlgorithm(DigestAlgorithm value);
    public CryptographicStandard get_CryptographicStandard();
    public void set_CryptographicStandard(CryptographicStandard value);
    internal bool get_HasChanged();
    private DigestAlgorithm GetDigestAlgorithm();
}
public class Syncfusion.Pdf.Security.PdfSignatureValidationException : PdfException {
    private PdfSignatureValidationExceptionType exceptionType;
    internal PdfSignatureValidationExceptionType ExceptionType { get; internal set; }
    [NullableContextAttribute("1")]
internal PdfSignatureValidationException(string message);
    internal PdfSignatureValidationExceptionType get_ExceptionType();
    internal void set_ExceptionType(PdfSignatureValidationExceptionType value);
}
internal enum Syncfusion.Pdf.Security.PdfSignatureValidationExceptionType : Enum {
    public int value__;
    public static PdfSignatureValidationExceptionType Others;
    public static PdfSignatureValidationExceptionType CRL;
    public static PdfSignatureValidationExceptionType OCSP;
    public static PdfSignatureValidationExceptionType TimeStamp;
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class Syncfusion.Pdf.Security.PdfSignatureValidationResult : object {
    private SignatureStatus m_signatureStatus;
    private bool m_isDocumentModified;
    private bool m_isCertificated;
    private bool m_isValidAtSignedTime;
    private bool m_isValidAtCurrentTime;
    private bool m_isValidAtTimeStampTime;
    private bool m_signerIdentity;
    private RevocationResult m_revocationResult;
    private CryptographicStandard m_cryptographicStandard;
    private DigestAlgorithm m_digestAlgorithm;
    private string m_signatureAlgorithm;
    private PAdESSignatureLevel m_signatureLevel;
    private X509Certificate2Collection m_certificates;
    private TimeStampInformation m_timeStampInfo;
    private List`1<PdfSignatureValidationException> m_signatureValidationErrors;
    private string m_signatureName;
    internal bool m_isValidOCSPorCRLtimeValidation;
    internal PdfSignatureValidationOptions signatureOptions;
    private LtvVerificationInfo m_ltvVerificationInfo;
    private List`1<PdfSignerCertificate> m_signerCertificates;
    private PdfCmsSigner m_signer;
    public string SignatureName { get; internal set; }
    public SignatureStatus SignatureStatus { get; internal set; }
    public RevocationResult RevocationResult { get; internal set; }
    public bool IsDocumentModified { get; internal set; }
    public bool IsCertificated { get; internal set; }
    public bool IsValidAtSignedTime { get; internal set; }
    public bool IsValidAtCurrentTime { get; internal set; }
    public bool IsValidAtTimeStampTime { get; internal set; }
    public bool IsSignatureValid { get; internal set; }
    public CryptographicStandard CryptographicStandard { get; internal set; }
    public string SignatureAlgorithm { get; internal set; }
    public DigestAlgorithm DigestAlgorithm { get; internal set; }
    internal PAdESSignatureLevel PAdESSignatureLevel { get; internal set; }
    public X509Certificate2Collection Certificates { get; internal set; }
    public TimeStampInformation TimeStampInformation { get; internal set; }
    public List`1<PdfSignatureValidationException> SignatureValidationErrors { get; internal set; }
    public LtvVerificationInfo LtvVerificationInfo { get; internal set; }
    public PdfSignerCertificate[] SignerCertificates { get; }
    internal PdfCmsSigner Signer { get; internal set; }
    public string get_SignatureName();
    internal void set_SignatureName(string value);
    public SignatureStatus get_SignatureStatus();
    internal void set_SignatureStatus(SignatureStatus value);
    public RevocationResult get_RevocationResult();
    internal void set_RevocationResult(RevocationResult value);
    public bool get_IsDocumentModified();
    internal void set_IsDocumentModified(bool value);
    public bool get_IsCertificated();
    internal void set_IsCertificated(bool value);
    public bool get_IsValidAtSignedTime();
    internal void set_IsValidAtSignedTime(bool value);
    public bool get_IsValidAtCurrentTime();
    internal void set_IsValidAtCurrentTime(bool value);
    public bool get_IsValidAtTimeStampTime();
    internal void set_IsValidAtTimeStampTime(bool value);
    public bool get_IsSignatureValid();
    internal void set_IsSignatureValid(bool value);
    public CryptographicStandard get_CryptographicStandard();
    internal void set_CryptographicStandard(CryptographicStandard value);
    public string get_SignatureAlgorithm();
    internal void set_SignatureAlgorithm(string value);
    public DigestAlgorithm get_DigestAlgorithm();
    internal void set_DigestAlgorithm(DigestAlgorithm value);
    internal PAdESSignatureLevel get_PAdESSignatureLevel();
    internal void set_PAdESSignatureLevel(PAdESSignatureLevel value);
    public X509Certificate2Collection get_Certificates();
    internal void set_Certificates(X509Certificate2Collection value);
    public TimeStampInformation get_TimeStampInformation();
    internal void set_TimeStampInformation(TimeStampInformation value);
    public List`1<PdfSignatureValidationException> get_SignatureValidationErrors();
    internal void set_SignatureValidationErrors(List`1<PdfSignatureValidationException> value);
    public LtvVerificationInfo get_LtvVerificationInfo();
    internal void set_LtvVerificationInfo(LtvVerificationInfo value);
    public PdfSignerCertificate[] get_SignerCertificates();
    internal PdfCmsSigner get_Signer();
    internal void set_Signer(PdfCmsSigner value);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class Syncfusion.Pdf.Security.PdfSignerCertificate : object {
    private PdfRevocationCertificate ocspCertificate;
    private PdfRevocationCertificate crlCertificate;
    private X509Certificate2 certificate;
    public PdfRevocationCertificate OcspCertificate { get; internal set; }
    public PdfRevocationCertificate CrlCertificate { get; internal set; }
    public X509Certificate2 Certificate { get; internal set; }
    public PdfRevocationCertificate get_OcspCertificate();
    internal void set_OcspCertificate(PdfRevocationCertificate value);
    public PdfRevocationCertificate get_CrlCertificate();
    internal void set_CrlCertificate(PdfRevocationCertificate value);
    public X509Certificate2 get_Certificate();
    internal void set_Certificate(X509Certificate2 value);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Syncfusion.Pdf.Security.PfxData : Asn1Encode {
    private ContentInformation m_contentInformation;
    private MacInformation m_macInformation;
    internal ContentInformation ContentInformation { get; }
    internal PfxData(Asn1Sequence sequence);
    internal ContentInformation get_ContentInformation();
    public virtual Asn1 GetAsn1();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Syncfusion.Pdf.Security.PKCS12AlgorithmGenerator : PasswordGenerator {
    private static int m_keyMaterial;
    private static int m_invaidMaterial;
    private static int m_macMaterial;
    private IMessageDigest m_digest;
    private int m_size;
    private int m_length;
    internal PKCS12AlgorithmGenerator(IMessageDigest digest);
    private void Adjust(Byte[] a, int offset, Byte[] b);
    private Byte[] GenerateDerivedKey(int id, int length);
    internal virtual ICipherParam GenerateParam(string algorithm, int keySize);
    internal virtual ICipherParam GenerateParam(string algorithm, int keySize, int ivSize);
    internal virtual ICipherParam GenerateParam(int keySize);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Syncfusion.Pdf.Security.PKCS12PasswordParameter : Asn1Encode {
    private DerInteger m_iterations;
    private Asn1Octet m_octet;
    internal Number Iterations { get; }
    internal Byte[] Octets { get; }
    internal PKCS12PasswordParameter(Byte[] bytes, int iteration);
    private PKCS12PasswordParameter(Asn1Sequence sequence);
    internal static PKCS12PasswordParameter GetPBEParameter(object obj);
    internal Number get_Iterations();
    internal Byte[] get_Octets();
    public virtual Asn1 GetAsn1();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Syncfusion.Pdf.Security.Pkcs1Encoding : object {
    private static string m_enableSequrity;
    private static int m_length;
    private static Boolean[] m_securityLengthEnabled;
    private SecureRandomAlgorithm m_random;
    private ICipherBlock m_cipher;
    private bool m_isEncryption;
    private bool m_isPrivateKey;
    private bool m_useSecurityLength;
    internal bool SecurityLengthEnabled { get; internal set; }
    public string AlgorithmName { get; }
    public int InputBlock { get; }
    public int OutputBlock { get; }
    private static Pkcs1Encoding();
    internal Pkcs1Encoding(ICipherBlock cipher);
    internal bool get_SecurityLengthEnabled();
    internal void set_SecurityLengthEnabled(bool value);
    public sealed virtual string get_AlgorithmName();
    public ICipherBlock GetUnderlyingCipher();
    public sealed virtual void Initialize(bool forEncryption, ICipherParam parameters);
    public sealed virtual int get_InputBlock();
    public sealed virtual int get_OutputBlock();
    public sealed virtual Byte[] ProcessBlock(Byte[] input, int inOff, int length);
    private Byte[] EncodeBlock(Byte[] input, int inOff, int inLen);
    private Byte[] DecodeBlock(Byte[] input, int inOff, int inLen);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Syncfusion.Pdf.Security.Pkcs7Padding : object {
    public string PaddingName { get; }
    public sealed virtual void Initialize(SecureRandomAlgorithm random);
    public sealed virtual string get_PaddingName();
    public sealed virtual int AddPadding(Byte[] bytes, int offset);
    public sealed virtual int Count(Byte[] input);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal abstract class Syncfusion.Pdf.Security.PKCSOIDs : object {
    internal static string Pkcs1;
    internal static DerObjectID RsaEncryption;
    internal static DerObjectID MD2WithRsaEncryption;
    internal static DerObjectID Sha1WithRsaEncryption;
    internal static DerObjectID RsaCrlAlgorithmIdntifier;
    internal static DerObjectID Sha256WithRsaEncryption;
    internal static DerObjectID Sha384WithRsaEncryption;
    internal static DerObjectID Sha512WithRsaEncryption;
    internal static string EncryptionAlgorithm;
    internal static DerObjectID DesEde3Cbc;
    internal static DerObjectID RC2Cbc;
    internal static string DigestAlgorithm;
    internal static string Pkcs7;
    internal static DerObjectID Data;
    internal static DerObjectID SignedData;
    internal static DerObjectID EnvelopedData;
    internal static DerObjectID SignedAndEnvelopedData;
    internal static DerObjectID DigestedData;
    internal static DerObjectID EncryptedData;
    internal static string Pkcs9;
    internal static string TimeStampCert;
    internal static string TimeStampCertInformation;
    internal static string SigningCert;
    internal static DerObjectID Pkcs9AtEmailAddress;
    internal static DerObjectID Pkcs9AtUnstructuredName;
    internal static DerObjectID Pkcs9AtMessageDigest;
    internal static DerObjectID Pkcs9AtUnstructuredAddress;
    internal static DerObjectID Pkcs9AtFriendlyName;
    internal static DerObjectID Pkcs9AtLocalKeyID;
    internal static DerObjectID Pkcs9AtSigningCertV1;
    internal static DerObjectID Pkcs9AtSigningCertV2;
    internal static DerObjectID Pkcs9SignatureTimeStamp;
    internal static string Pkcs12;
    internal static string BagTypes;
    internal static DerObjectID KeyBag;
    internal static DerObjectID Pkcs8ShroudedKeyBag;
    internal static DerObjectID CertBag;
    internal static DerObjectID CrlBag;
    internal static DerObjectID SecretBag;
    internal static DerObjectID SafeContentsBag;
    internal static string Pkcs12PbeIds;
    internal static DerObjectID PbeWithShaAnd128BitRC4;
    internal static DerObjectID PbeWithShaAnd40BitRC4;
    internal static DerObjectID PbeWithShaAnd3KeyTripleDesCbc;
    internal static DerObjectID PbeWithShaAnd2KeyTripleDesCbc;
    internal static DerObjectID PbeWithShaAnd128BitRC2Cbc;
    internal static DerObjectID PbewithShaAnd40BitRC2Cbc;
    internal static DerObjectID IdAlgCms3DesWrap;
    internal static DerObjectID IdAlgCmsRC2Wrap;
    internal static string MessageDigestAlgorithm;
    internal static DerObjectID MD5;
    internal static DerObjectID DigestAlgorithmSHA256;
    internal static DerObjectID DigestAlgorithmSHA384;
    internal static DerObjectID DigestAlgorithmSHA512;
    internal static DerObjectID AdobeRevocation;
    internal static DerObjectID Tsa;
    private static PKCSOIDs();
}
[FlagsAttribute]
internal enum Syncfusion.Pdf.Security.PKIStatus : Enum {
    public int value__;
    public static PKIStatus Granted;
    public static PKIStatus GrantedWithMods;
    public static PKIStatus Rejection;
    public static PKIStatus Waiting;
    public static PKIStatus RevocationWarning;
    public static PKIStatus RevocationNotification;
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Syncfusion.Pdf.Security.PSSSigner : object {
    public static byte m_trailer;
    private IMessageDigest m_digest1;
    private IMessageDigest m_digest2;
    private IMessageDigest m_pssDigest;
    private ICipherBlock m_cipher;
    private SecureRandomAlgorithm m_random;
    private int m_hashLength;
    private int m_digestLength;
    private int m_saltLength;
    private int m_emBits;
    private Byte[] m_salt;
    private Byte[] m_Dash;
    private Byte[] m_blockCipher;
    private byte m_trailerBlock;
    public string AlgorithmName { get; }
    public PSSSigner(ICipherBlock m_cipher, IMessageDigest digest);
    public PSSSigner(ICipherBlock m_cipher, IMessageDigest digest, int saltLen);
    public PSSSigner(ICipherBlock m_cipher, IMessageDigest contentDigest, IMessageDigest m_pssDigest, int saltLen);
    public PSSSigner(ICipherBlock m_cipher, IMessageDigest digest, int saltLen, byte m_trailerBlock);
    public PSSSigner(ICipherBlock m_cipher, IMessageDigest contentDigest, IMessageDigest m_pssDigest, int saltLen, byte m_trailerBlock);
    private PSSSigner(ICipherBlock m_cipher, IMessageDigest m_digest1, IMessageDigest m_digest2, IMessageDigest m_pssDigest, int saltLen, byte m_trailerBlock);
    public static PSSSigner CreateRawSigner(ICipherBlock m_cipher, IMessageDigest digest);
    public static PSSSigner CreateRawSigner(ICipherBlock m_cipher, IMessageDigest contentDigest, IMessageDigest m_pssDigest, int saltLen, byte m_trailerBlock);
    public sealed virtual string get_AlgorithmName();
    public sealed virtual void BlockUpdate(Byte[] bytes, int offset, int length);
    public sealed virtual Byte[] GenerateSignature();
    public sealed virtual void Initialize(bool isSigning, ICipherParam parameters);
    public sealed virtual void Reset();
    public sealed virtual void Update(byte input);
    public sealed virtual bool ValidateSignature(Byte[] signature);
    private Byte[] ComputeMask(Byte[] maskD, int maskOff, int maskLen, int size);
    private void ComputeItoOSP(int m, Byte[] osp);
    private void ClearBlock(Byte[] input);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Syncfusion.Pdf.Security.PublicKeyInformation : Asn1Encode {
    private Algorithms m_algorithms;
    private DerBitString m_publicKey;
    internal Algorithms Algorithm { get; }
    internal DerBitString PublicKey { get; }
    internal PublicKeyInformation(Algorithms algorithms, Asn1Encode publicKey);
    internal PublicKeyInformation(Algorithms algorithms, Byte[] publicKey);
    private PublicKeyInformation(Asn1Sequence sequence);
    internal Algorithms get_Algorithm();
    internal DerBitString get_PublicKey();
    internal static PublicKeyInformation GetPublicKeyInformation(object obj);
    internal Asn1 GetPublicKey();
    public virtual Asn1 GetAsn1();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Syncfusion.Pdf.Security.PushStream : Stream {
    private int m_buffer;
    internal Stream m_stream;
    public bool CanRead { get; }
    public bool CanSeek { get; }
    public bool CanWrite { get; }
    public long Length { get; }
    public long Position { get; public set; }
    internal PushStream(Stream stream);
    public virtual int ReadByte();
    public virtual int Read(Byte[] buffer, int offset, int count);
    public virtual void Unread(int b);
    public virtual bool get_CanRead();
    public virtual bool get_CanSeek();
    public virtual bool get_CanWrite();
    public virtual long get_Length();
    public virtual long get_Position();
    public virtual void set_Position(long value);
    public void Close();
    public virtual void Flush();
    public virtual long Seek(long offset, SeekOrigin origin);
    public virtual void SetLength(long value);
    public virtual void Write(Byte[] buffer, int offset, int count);
    public virtual void WriteByte(byte value);
}
internal class Syncfusion.Pdf.Security.RandomArray : object {
    [NullableAttribute("1")]
private Byte[] m_array;
    public long Length { get; }
    [NullableContextAttribute("1")]
internal RandomArray(Byte[] array);
    public virtual long get_Length();
    public virtual void Close();
    public virtual int Get(long offset);
    [NullableContextAttribute("1")]
public virtual int Get(long offset, Byte[] bytes, int off, int length);
    public virtual void Dispose();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Syncfusion.Pdf.Security.RandomGroup : object {
    private SourceEntry[] m_sources;
    private SourceEntry m_cse;
    private long m_size;
    public long Length { get; }
    internal RandomGroup(ICollection`1<IRandom> sources);
    protected internal int GetStartIndex(long offset);
    private SourceEntry GetEntry(long offset);
    protected internal virtual void SourceReleased(IRandom source);
    protected internal virtual void SourceInUse(IRandom source);
    public virtual int Get(long position);
    public virtual int Get(long position, Byte[] bytes, int off, int len);
    public virtual long get_Length();
    public virtual void Close();
    public virtual void Dispose();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Syncfusion.Pdf.Security.RandomStream : Stream {
    private IRandom m_random;
    private long m_position;
    public bool CanRead { get; }
    public bool CanSeek { get; }
    public bool CanWrite { get; }
    public long Length { get; }
    public long Position { get; public set; }
    internal RandomStream(IRandom source);
    public virtual bool get_CanRead();
    public virtual bool get_CanSeek();
    public virtual bool get_CanWrite();
    public virtual void Flush();
    public virtual long get_Length();
    public virtual long get_Position();
    public virtual void set_Position(long value);
    public virtual int Read(Byte[] buffer, int offset, int length);
    public virtual int ReadByte();
    public virtual long Seek(long offset, SeekOrigin origin);
    public virtual void SetLength(long value);
    public virtual void Write(Byte[] buffer, int offset, int count);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Syncfusion.Pdf.Security.RC2Algorithm : object {
    private static Byte[] m_piTable;
    private static int m_blockSize;
    private Int32[] m_Key;
    private bool m_isEncrypt;
    public string AlgorithmName { get; }
    public bool IsBlock { get; }
    public int BlockSize { get; }
    private static RC2Algorithm();
    private Int32[] GenerateKey(Byte[] key, int bits);
    public sealed virtual void Initialize(bool forEncryption, ICipherParam parameters);
    public sealed virtual void Reset();
    public sealed virtual string get_AlgorithmName();
    public sealed virtual bool get_IsBlock();
    public sealed virtual int get_BlockSize();
    public sealed virtual int ProcessBlock(Byte[] input, int inOff, Byte[] output, int outOff);
    private int RotateWordLeft(int x, int y);
    private void EncryptBlock(Byte[] input, int inOff, Byte[] outBytes, int outOff);
    private void DecryptBlock(Byte[] input, int inOff, Byte[] outBytes, int outOff);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Syncfusion.Pdf.Security.ResponseInformation : Asn1Encode {
    private static DerInteger Version1;
    private bool m_versionPresent;
    private DerInteger m_version;
    private RevocationResponseIdentifier m_responderIdentifier;
    private GeneralizedTime m_producedTime;
    private Asn1Sequence m_sequence;
    private X509Extensions m_responseExtensions;
    internal Asn1Sequence Sequence { get; }
    private ResponseInformation(Asn1Sequence sequence);
    private static ResponseInformation();
    internal ResponseInformation GetInformation(object obj);
    internal Asn1Sequence get_Sequence();
    public virtual Asn1 GetAsn1();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Syncfusion.Pdf.Security.RevocationDistribution : Asn1Encode {
    private RevocationDistributionType m_distributionPoint;
    private RevocationName m_issuer;
    internal RevocationDistributionType DistributionPointName { get; }
    private RevocationDistribution(Asn1Sequence sequence);
    public RevocationDistribution GetCrlDistribution(object obj);
    internal RevocationDistributionType get_DistributionPointName();
    public virtual Asn1 GetAsn1();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Syncfusion.Pdf.Security.RevocationDistributionType : Asn1Encode {
    private Asn1Encode m_name;
    private int m_type;
    public static int FullName;
    public static int NameRelativeToCrlIssuer;
    internal int PointType { get; }
    internal Asn1Encode Name { get; }
    internal RevocationDistributionType(Asn1Tag tag);
    internal RevocationDistributionType GetDistributionType(Asn1Tag tag, bool isExplicit);
    internal RevocationDistributionType GetDistributionType(object obj);
    internal int get_PointType();
    internal Asn1Encode get_Name();
    public virtual Asn1 GetAsn1();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Syncfusion.Pdf.Security.RevocationList : object {
    private IList`1<string> m_urls;
    internal PdfSignatureValidationResult result;
    private Stream m_stream;
    private ManualResetEvent allDone;
    private CertificateUtililty m_utility;
    private string m_currentUrl;
    internal RevocationList(ICollection`1<X509Certificate> chain);
    internal RevocationList(X509Certificate certificate);
    private void Initialize(X509Certificate certificate);
    protected virtual void AddUrl(string url);
    internal ICollection`1<Byte[]> GetEncoded(X509Certificate certificate, string url);
    private void GetResponseCallback(IAsyncResult asynchronousResult);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Syncfusion.Pdf.Security.RevocationListEntry : Asn1Encode {
    internal Asn1Sequence m_sequence;
    internal DerInteger m_userCertificate;
    internal X509Time m_revocationDate;
    internal X509Extensions m_crlEntryExtensions;
    internal string m_serialNumber;
    internal DerInteger UserCertificate { get; }
    internal RevocationListEntry(Asn1Sequence sequence);
    internal DerInteger get_UserCertificate();
    public virtual Asn1 GetAsn1();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Syncfusion.Pdf.Security.RevocationListHelper : object {
    private CertificateCollection m_certificateList;
    private string m_algorithm;
    private Byte[] m_bytes;
    internal RevocationListHelper(CertificateCollection certificateList);
    internal bool Validate(X509Certificate signerCertificate, X509Certificate issuerCertificate, DateTime signDate);
    private bool Validate(CipherParameter publicKey);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Syncfusion.Pdf.Security.RevocationListRequest : Asn1Encode {
    private OcspRequestCollection m_requests;
    public RevocationListRequest(OcspRequestCollection requests);
    public virtual Asn1 GetAsn1();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Syncfusion.Pdf.Security.RevocationListValidator : object {
    private RevocationList m_crl;
    private RevocationResult m_result;
    internal PdfSignatureValidationResult result;
    internal RevocationListValidator(X509Certificate signerCertificate, RevocationResult result);
    internal bool Validate(X509Certificate signerCertificate, X509Certificate issuerCertificate, DateTime signDate, List`1<CertificateCollection> certificateCollections);
    internal bool OnlineValidate(X509Certificate signerCertificate, X509Certificate issuerCertificate, DateTime signDate);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Syncfusion.Pdf.Security.RevocationName : Asn1Encode {
    private OcspTag[] m_names;
    internal OcspTag[] Names { get; }
    private RevocationName(Asn1Sequence sequence);
    internal OcspTag[] get_Names();
    public RevocationName GetCrlName(object obj);
    public RevocationName GetCrlName(Asn1Tag tag, bool isExplicit);
    public virtual Asn1 GetAsn1();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Syncfusion.Pdf.Security.RevocationPointList : Asn1Encode {
    private Asn1Sequence m_sequence;
    private RevocationPointList(Asn1Sequence sequence);
    internal RevocationPointList GetCrlPointList(object obj);
    internal RevocationDistribution[] GetDistributionPoints();
    public virtual Asn1 GetAsn1();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Syncfusion.Pdf.Security.RevocationRequest : Asn1Encode {
    private CertificateIdentityHelper m_certificateID;
    private X509Extensions m_singleRequestExtensions;
    internal RevocationRequest(CertificateIdentityHelper certificateID, X509Extensions singleRequestExtensions);
    public virtual Asn1 GetAsn1();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Syncfusion.Pdf.Security.RevocationResponseBytes : Asn1Encode {
    private DerObjectID m_responseType;
    private Asn1Octet m_response;
    public DerObjectID ResponseType { get; }
    public Asn1Octet Response { get; }
    private RevocationResponseBytes(Asn1Sequence sequence);
    public RevocationResponseBytes GetResponseBytes(Asn1Tag tag, bool isExplicit);
    public RevocationResponseBytes GetResponseBytes(object obj);
    public DerObjectID get_ResponseType();
    public Asn1Octet get_Response();
    public virtual Asn1 GetAsn1();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Syncfusion.Pdf.Security.RevocationResponseIdentifier : Asn1Encode {
    private Asn1Encode m_id;
    public RevocationResponseIdentifier(Asn1Octet id);
    public RevocationResponseIdentifier(X509Name id);
    internal RevocationResponseIdentifier GetResponseID(object obj);
    public virtual Asn1 GetAsn1();
}
public class Syncfusion.Pdf.Security.RevocationResult : object {
    private bool m_isRevokedCRL;
    private RevocationStatus m_revocationStatus;
    public bool IsRevokedCRL { get; internal set; }
    public RevocationStatus OcspRevocationStatus { get; internal set; }
    public bool get_IsRevokedCRL();
    internal void set_IsRevokedCRL(bool value);
    public RevocationStatus get_OcspRevocationStatus();
    internal void set_OcspRevocationStatus(RevocationStatus value);
}
public enum Syncfusion.Pdf.Security.RevocationStatus : Enum {
    public int value__;
    public static RevocationStatus None;
    public static RevocationStatus Good;
    public static RevocationStatus Unknown;
    public static RevocationStatus Revoked;
}
public enum Syncfusion.Pdf.Security.RevocationType : Enum {
    public int value__;
    public static RevocationType Ocsp;
    public static RevocationType Crl;
    public static RevocationType OcspAndCrl;
    public static RevocationType OcspOrCrl;
}
public enum Syncfusion.Pdf.Security.RevocationValidationType : Enum {
    public int value__;
    public static RevocationValidationType Both;
    public static RevocationValidationType Crl;
    public static RevocationValidationType Ocsp;
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class Syncfusion.Pdf.Security.RevokedCertificate : object {
    private string m_serialNumber;
    private DateTime m_validTo;
    public string SerialNumber { get; internal set; }
    public DateTime ValidTo { get; internal set; }
    public string get_SerialNumber();
    internal void set_SerialNumber(string value);
    public DateTime get_ValidTo();
    internal void set_ValidTo(DateTime value);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Syncfusion.Pdf.Security.RIPEMD160MessageDigest : MessageDigest {
    private static int m_digestLength;
    private int m_h0;
    private int m_h1;
    private int m_h2;
    private int m_h3;
    private int m_h4;
    private Int32[] m_x;
    private int m_xOffset;
    public string AlgorithmName { get; }
    public int MessageDigestSize { get; }
    internal RIPEMD160MessageDigest(RIPEMD160MessageDigest t);
    public virtual string get_AlgorithmName();
    public virtual int get_MessageDigestSize();
    internal virtual void ProcessWord(Byte[] input, int inOff);
    internal virtual void ProcessLength(long bitLength);
    private void UnpackWord(int word, Byte[] output, int offset);
    public virtual int DoFinal(Byte[] bytes, int offset);
    public virtual void Reset();
    private int GetRightToLeft(int x, int n);
    private int GetBitLevelEXOR(int x, int y, int z);
    private int GetBitlevelMultiplexer(int x, int y, int z);
    private int GetBitlevelNegative(int x, int y, int z);
    private int GetBitlevelDemultiplexer(int x, int y, int z);
    private int GetBitlevelReverseNegative(int x, int y, int z);
    internal virtual void ProcessBlock();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Syncfusion.Pdf.Security.RMDSigner : object {
    private ICipherBlock m_rsaEngine;
    private Algorithms m_id;
    private IMessageDigest m_digest;
    private bool m_isSigning;
    private static Dictionary`2<string, DerObjectID> m_map;
    public string AlgorithmName { get; }
    private static RMDSigner();
    internal RMDSigner(IMessageDigest digest);
    public sealed virtual string get_AlgorithmName();
    public sealed virtual void Initialize(bool isSigning, ICipherParam parameters);
    public sealed virtual void Update(byte input);
    public sealed virtual void BlockUpdate(Byte[] input, int inOff, int length);
    public sealed virtual Byte[] GenerateSignature();
    public sealed virtual bool ValidateSignature(Byte[] signature);
    public sealed virtual void Reset();
    private Byte[] DerEncode(Byte[] hash);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Syncfusion.Pdf.Security.RSAAlgorithm : object {
    private RSACoreAlgorithm m_rsaCoreEngine;
    private RsaKeyParam m_key;
    private SecureRandomAlgorithm m_random;
    public string AlgorithmName { get; }
    public int InputBlock { get; }
    public int OutputBlock { get; }
    public sealed virtual string get_AlgorithmName();
    public sealed virtual void Initialize(bool isEncryption, ICipherParam parameter);
    public sealed virtual int get_InputBlock();
    public sealed virtual int get_OutputBlock();
    public sealed virtual Byte[] ProcessBlock(Byte[] bytes, int offset, int length);
    internal Number CreateRandomInRange(Number minimum, Number maximum, SecureRandomAlgorithm random);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Syncfusion.Pdf.Security.RSACoreAlgorithm : object {
    private RsaKeyParam m_key;
    private bool m_isEncryption;
    private int m_bitSize;
    internal int InputBlockSize { get; }
    internal int OutputBlockSize { get; }
    internal void Initialize(bool isEncryption, ICipherParam parameters);
    internal int get_InputBlockSize();
    internal int get_OutputBlockSize();
    internal Number ConvertInput(Byte[] bytes, int offset, int length);
    internal Byte[] ConvertOutput(Number result);
    internal Number ProcessBlock(Number input);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Syncfusion.Pdf.Security.RSAKey : Asn1Encode {
    private Number m_modulus;
    private Number m_publicExponent;
    private Number m_privateExponent;
    private Number m_prime1;
    private Number m_prime2;
    private Number m_exponent1;
    private Number m_exponent2;
    private Number m_coefficient;
    internal Number Modulus { get; }
    internal Number PublicExponent { get; }
    internal Number PrivateExponent { get; }
    internal Number Prime1 { get; }
    internal Number Prime2 { get; }
    internal Number Exponent1 { get; }
    internal Number Exponent2 { get; }
    internal Number Coefficient { get; }
    internal RSAKey(Number modulus, Number publicExponent, Number privateExponent, Number prime1, Number prime2, Number exponent1, Number exponent2, Number coefficient);
    public RSAKey(Asn1Sequence sequence);
    internal Number get_Modulus();
    internal Number get_PublicExponent();
    internal Number get_PrivateExponent();
    internal Number get_Prime1();
    internal Number get_Prime2();
    internal Number get_Exponent1();
    internal Number get_Exponent2();
    internal Number get_Coefficient();
    public virtual Asn1 GetAsn1();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Syncfusion.Pdf.Security.RsaKeyParam : CipherParameter {
    private Number m_modulus;
    private Number m_exponent;
    internal Number Modulus { get; }
    internal Number Exponent { get; }
    internal RsaKeyParam(bool isPrivate, Number modulus, Number exponent);
    internal Number get_Modulus();
    internal Number get_Exponent();
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Syncfusion.Pdf.Security.RsaPrivateKeyParam : RsaKeyParam {
    private Number m_publicExponent;
    private Number m_p;
    private Number m_q;
    private Number m_dP;
    private Number m_dQ;
    private Number m_inverse;
    internal Number PublicExponent { get; }
    internal Number P { get; }
    internal Number Q { get; }
    internal Number DP { get; }
    internal Number DQ { get; }
    internal Number QInv { get; }
    internal RsaPrivateKeyParam(Number modulus, Number publicExponent, Number privateExponent, Number p, Number q, Number dP, Number dQ, Number inverse);
    internal Number get_PublicExponent();
    internal Number get_P();
    internal Number get_Q();
    internal Number get_DP();
    internal Number get_DQ();
    internal Number get_QInv();
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    private static void ValidateValue(Number number);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Syncfusion.Pdf.Security.RSAPublicKey : Asn1Encode {
    private Number m_modulus;
    private Number m_publicExponent;
    internal Number Modulus { get; }
    internal Number PublicExponent { get; }
    internal RSAPublicKey(Number modulus, Number publicExponent);
    private RSAPublicKey(Asn1Sequence sequence);
    internal Number get_Modulus();
    internal Number get_PublicExponent();
    internal static RSAPublicKey GetPublicKey(object obj);
    public virtual Asn1 GetAsn1();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Syncfusion.Pdf.Security.RWAlgorithmGenerator : object {
    private IAlgorithmGenerator m_generator;
    private Byte[] m_window;
    private int m_windowCount;
    internal RWAlgorithmGenerator(IAlgorithmGenerator generator, int windowSize);
    public virtual void AddMaterial(Byte[] bytes);
    public virtual void AddMaterial(long value);
    public virtual void FillNextBytes(Byte[] bytes);
    public virtual void FillNextBytes(Byte[] bytes, int start, int length);
    private void doNextBytes(Byte[] bytes, int start, int length);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Syncfusion.Pdf.Security.SECGCurves : object {
    internal static Dictionary`2<DerObjectID, ECX9Params> curves;
    internal static Dictionary`2<string, DerObjectID> objectIds;
    internal static Dictionary`2<DerObjectID, string> curveNames;
    private static SECGCurves();
    private static Number DecodeHex(string hex);
    private static void DefineCurve(string name, DerObjectID oid, ECX9Params holder);
    public static ECX9Field GetByOid(DerObjectID oid);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Syncfusion.Pdf.Security.SecureParamNumber : object {
    private ICipherParam m_parameters;
    private SecureRandomAlgorithm m_random;
    public SecureRandomAlgorithm Random { get; }
    public ICipherParam Parameters { get; }
    public SecureParamNumber(ICipherParam parameters, SecureRandomAlgorithm random);
    public SecureParamNumber(ICipherParam parameters);
    public SecureRandomAlgorithm get_Random();
    public ICipherParam get_Parameters();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Syncfusion.Pdf.Security.SecureRandomAlgorithm : Random {
    private static IAlgorithmGenerator m_sha1Generator;
    private static IAlgorithmGenerator m_sha256Generator;
    private SecureRandomAlgorithm[] m_master;
    private double DoubleScale;
    protected IAlgorithmGenerator m_generator;
    private SecureRandomAlgorithm Algorithm { get; }
    internal SecureRandomAlgorithm(IAlgorithmGenerator generator);
    private static SecureRandomAlgorithm();
    private SecureRandomAlgorithm get_Algorithm();
    internal Byte[] GetBytes(int length);
    public virtual Byte[] GenerateBytes(int length);
    public virtual void SetBytes(Byte[] bytes);
    public virtual void SetBytes(long value);
    public virtual int Next();
    public virtual int Next(int maxValue);
    public virtual int Next(int minValue, int maxValue);
    public virtual void NextBytes(Byte[] buffer);
    public virtual void NextBytes(Byte[] buffer, int start, int length);
    public virtual double NextDouble();
    public virtual int NextInt();
    public virtual long NextLong();
}
internal enum Syncfusion.Pdf.Security.SecurityHandlers : Enum {
    public int value__;
    public static SecurityHandlers Standard;
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Syncfusion.Pdf.Security.SfBigInteger : object {
    private static int maxLength;
    private UInt32[] data;
    private int dataLength;
    internal SfBigInteger(long value);
    private SfBigInteger(SfBigInteger bi);
    private SfBigInteger(UInt32[] inData);
    internal SfBigInteger(Byte[] inData);
    private SfBigInteger(ulong value);
    private long LongValue();
    internal int IntValue();
    public static bool op_LessThan(SfBigInteger b1, SfBigInteger b2);
    public static SfBigInteger op_UnaryNegation(SfBigInteger b1);
    public static SfBigInteger op_Modulus(SfBigInteger b1, SfBigInteger b2);
    public static SfBigInteger op_Implicit(long value);
    public static SfBigInteger op_Implicit(ulong value);
    public static SfBigInteger op_Implicit(int value);
    public static SfBigInteger op_Implicit(UInt32 value);
    public static SfBigInteger op_Decrement(SfBigInteger b1);
    public static SfBigInteger op_LeftShift(SfBigInteger b1, int shiftVal);
    public static SfBigInteger op_Multiply(SfBigInteger b1, SfBigInteger b2);
    private static void MultiByteDivide(SfBigInteger b1, SfBigInteger b2, SfBigInteger outQuotient, SfBigInteger outRemainder);
    public static SfBigInteger op_Subtraction(SfBigInteger b1, SfBigInteger b2);
    public static bool op_GreaterThan(SfBigInteger b1, SfBigInteger b2);
    private static int ShiftRight(UInt32[] buffer, int shiftVal);
    private static void SingleByteDivide(SfBigInteger b1, SfBigInteger b2, SfBigInteger outQuotient, SfBigInteger outRemainder);
    private static int ShiftLeft(UInt32[] buffer, int shiftVal);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Syncfusion.Pdf.Security.SHA1MessageDigest : MessageDigest {
    private static UInt32 c_y1;
    private static UInt32 c_y2;
    private static UInt32 c_y3;
    private static UInt32 c_y4;
    private static int c_digestLength;
    private UInt32 m_h1;
    private UInt32 m_h2;
    private UInt32 m_h3;
    private UInt32 m_h4;
    private UInt32 m_h5;
    private UInt32[] m_x;
    private int m_xOff;
    public string AlgorithmName { get; }
    public int MessageDigestSize { get; }
    internal SHA1MessageDigest(SHA1MessageDigest t);
    public virtual string get_AlgorithmName();
    public virtual int get_MessageDigestSize();
    internal virtual void ProcessWord(Byte[] input, int inOff);
    internal virtual void ProcessLength(long bitLength);
    public virtual int DoFinal(Byte[] bytes, int offset);
    public virtual void Reset();
    internal virtual void ProcessBlock();
    private UInt32 F(UInt32 u, UInt32 v, UInt32 w);
    private UInt32 H(UInt32 u, UInt32 v, UInt32 w);
    private UInt32 G(UInt32 u, UInt32 v, UInt32 w);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Syncfusion.Pdf.Security.SHA256MessageDigest : MessageDigest {
    private static int c_digestLength;
    private UInt32 m_h1;
    private UInt32 m_h2;
    private UInt32 m_h3;
    private UInt32 m_h4;
    private UInt32 m_h5;
    private UInt32 m_h6;
    private UInt32 m_h7;
    private UInt32 m_h8;
    private UInt32[] m_x;
    private int m_xOff;
    private static UInt32[] K;
    public string AlgorithmName { get; }
    public int MessageDigestSize { get; }
    internal SHA256MessageDigest(SHA256MessageDigest t);
    private static SHA256MessageDigest();
    public virtual string get_AlgorithmName();
    public virtual int get_MessageDigestSize();
    internal virtual void ProcessWord(Byte[] input, int inOff);
    internal virtual void ProcessLength(long bitLength);
    public virtual int DoFinal(Byte[] bytes, int offset);
    public virtual void Reset();
    private void initHs();
    internal virtual void ProcessBlock();
    private static UInt32 Sum1Ch(UInt32 x, UInt32 y, UInt32 z);
    private static UInt32 Sum0Maj(UInt32 x, UInt32 y, UInt32 z);
    private static UInt32 Theta0(UInt32 x);
    private static UInt32 Theta1(UInt32 x);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Syncfusion.Pdf.Security.SHA384MessageDigest : BigDigest {
    private static int DigestLength;
    public string AlgorithmName { get; }
    public int MessageDigestSize { get; }
    public virtual string get_AlgorithmName();
    public virtual int get_MessageDigestSize();
    public virtual int DoFinal(Byte[] bytes, int offset);
    public virtual void Reset();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Syncfusion.Pdf.Security.SHA512MessageDigest : BigDigest {
    private static int m_digestLength;
    public string AlgorithmName { get; }
    public int MessageDigestSize { get; }
    public virtual string get_AlgorithmName();
    public virtual int get_MessageDigestSize();
    public virtual int DoFinal(Byte[] bytes, int offset);
    public virtual void Reset();
}
[FlagsAttribute]
internal enum Syncfusion.Pdf.Security.SignatureFlags : Enum {
    public int value__;
    public static SignatureFlags None;
    public static SignatureFlags SignaturesExists;
    public static SignatureFlags AppendOnly;
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Syncfusion.Pdf.Security.SignaturePrivateKey : object {
    private ICipherParam m_key;
    private string m_hashAlgorithm;
    private string m_encryptionAlgorithm;
    internal SignaturePrivateKey(ICipherParam key, string hashAlgorithm);
    internal SignaturePrivateKey(string hashAlgorithm, string encryptionAlgorithm);
    internal Byte[] Sign(Byte[] bytes);
    internal string GetHashAlgorithm();
    internal string GetEncryptionAlgorithm();
}
public enum Syncfusion.Pdf.Security.SignatureStatus : Enum {
    public int value__;
    public static SignatureStatus Unknown;
    public static SignatureStatus Valid;
    public static SignatureStatus Invalid;
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Syncfusion.Pdf.Security.SignedCertificateCollection : Asn1Encode {
    private Asn1Sequence m_sequence;
    private DerInteger m_version;
    private Algorithms m_signature;
    private X509Name m_issuerName;
    private X509Time m_currentUpdate;
    private X509Time m_nextUpdate;
    private Asn1Sequence m_revokedCertificates;
    private X509Extensions m_crls;
    internal X509Name Issuer { get; }
    internal X509Time CurrentUpdate { get; }
    internal X509Time NextUpdate { get; }
    internal Algorithms Signature { get; }
    internal SignedCertificateCollection(Asn1Sequence sequence);
    internal X509Name get_Issuer();
    internal X509Time get_CurrentUpdate();
    internal X509Time get_NextUpdate();
    internal Algorithms get_Signature();
    internal static SignedCertificateCollection GetCertificateList(object obj);
    internal RevocationListEntry[] GetRevokedCertificates();
    internal X509Extensions GetExtensions();
    public virtual Asn1 GetAsn1();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Syncfusion.Pdf.Security.SignedDetails : Asn1Encode {
    private DerInteger m_version;
    private Asn1Set m_digestAlgorithms;
    private ContentInformation m_contentInformation;
    private Asn1Set m_certificates;
    private Asn1Set m_crls;
    private Asn1Set m_signerInformation;
    private bool m_certsBer;
    private bool m_crlsBerObject;
    internal ContentInformation ContentInformation { get; }
    internal Asn1Set SignerInformation { get; }
    internal SignedDetails(Asn1Sequence seq);
    public virtual Asn1 GetAsn1();
    internal ContentInformation get_ContentInformation();
    internal Asn1Set get_SignerInformation();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Syncfusion.Pdf.Security.SignerDetails : Asn1Encode {
    private DerInteger m_version;
    private SignerIdentity m_id;
    private Algorithms m_algorithm;
    private Asn1Set m_attributes;
    private Algorithms m_encryptionAlgorithm;
    private Asn1Octet m_encryptedOctet;
    private Asn1Set m_elements;
    internal SignerIdentity ID { get; }
    internal Asn1Set Attributes { get; }
    internal Algorithms DigestAlgorithm { get; }
    internal Asn1Octet EncryptedOctet { get; }
    internal Algorithms EncryptionAlgorithm { get; }
    internal Asn1Set Elements { get; }
    internal SignerDetails(Asn1Sequence seq);
    internal static SignerDetails GetSignerDetails(object obj);
    internal SignerIdentity get_ID();
    internal Asn1Set get_Attributes();
    internal Algorithms get_DigestAlgorithm();
    internal Asn1Octet get_EncryptedOctet();
    internal Algorithms get_EncryptionAlgorithm();
    internal Asn1Set get_Elements();
    public virtual Asn1 GetAsn1();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Syncfusion.Pdf.Security.SignerId : X509CertificateHelper {
    public virtual int GetHashCode();
    public virtual bool Equals(object obj);
    private bool AreEqual(X509Name issuer1, X509Name issuer2);
    private bool AreEqual(Byte[] a, Byte[] b);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Syncfusion.Pdf.Security.SignerIdentity : Asn1Encode {
    private Asn1Encode m_id;
    internal bool IsTagged { get; }
    internal Asn1Encode ID { get; }
    internal SignerIdentity(CertificateInformation id);
    internal SignerIdentity(Asn1Octet id);
    internal SignerIdentity(Asn1 id);
    internal static SignerIdentity GetIdentity(object o);
    internal bool get_IsTagged();
    internal Asn1Encode get_ID();
    public virtual Asn1 GetAsn1();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Syncfusion.Pdf.Security.SignerInformationCollection : object {
    private ICollection all;
    private IDictionary table;
    internal SignerInformationCollection(ICollection signerInfos);
    internal ICollection GetSigners();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Syncfusion.Pdf.Security.SignerUtilities : object {
    internal Dictionary`2<string, string> m_algms;
    internal Dictionary`2<string, DerObjectID> m_oids;
    internal DerObjectID GetOID(string mechanism);
    internal ISigner GetSigner(string algorithm);
    internal string GetEncoding(DerObjectID oid);
    internal string GetAlgorithmName(DerObjectID oid);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Syncfusion.Pdf.Security.SingnedCertificate : Asn1Encode {
    internal Asn1Sequence m_sequence;
    internal DerInteger m_version;
    internal DerInteger m_serialNumber;
    internal Algorithms m_signature;
    internal X509Name m_issuer;
    internal X509Time m_startDate;
    internal X509Time m_endDate;
    internal X509Name m_subject;
    internal PublicKeyInformation m_publicKeyInformation;
    internal DerBitString m_issuerID;
    internal DerBitString m_subjectID;
    internal X509Extensions m_extensions;
    internal int Version { get; }
    internal DerInteger SerialNumber { get; }
    internal Algorithms Signature { get; }
    internal X509Name Issuer { get; }
    internal X509Time StartDate { get; }
    internal X509Time EndDate { get; }
    internal X509Name Subject { get; }
    internal PublicKeyInformation SubjectPublicKeyInfo { get; }
    internal DerBitString IssuerUniqueID { get; }
    internal DerBitString SubjectUniqueID { get; }
    internal X509Extensions Extensions { get; }
    internal SingnedCertificate(Asn1Sequence sequence);
    internal static SingnedCertificate GetCertificate(object obj);
    internal int get_Version();
    internal DerInteger get_SerialNumber();
    internal Algorithms get_Signature();
    internal X509Name get_Issuer();
    internal X509Time get_StartDate();
    internal X509Time get_EndDate();
    internal X509Name get_Subject();
    internal PublicKeyInformation get_SubjectPublicKeyInfo();
    internal DerBitString get_IssuerUniqueID();
    internal DerBitString get_SubjectUniqueID();
    internal X509Extensions get_Extensions();
    public virtual Asn1 GetAsn1();
}
public enum Syncfusion.Pdf.Security.StoreRegion : Enum {
    public int value__;
    public static StoreRegion LocalMachine;
    public static StoreRegion CurrentUser;
}
public enum Syncfusion.Pdf.Security.StoreType : Enum {
    public int value__;
    public static StoreType MY;
    public static StoreType ROOT;
    public static StoreType CA;
    public static StoreType SPC;
    public static StoreType TrustedPeople;
    public static StoreType TrustedPublisher;
    public static StoreType AuthRoot;
    public static StoreType AddressBook;
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Syncfusion.Pdf.Security.SubjectKeyID : Asn1Encode {
    private Byte[] m_bytes;
    internal SubjectKeyID(Asn1Octet keyID);
    internal SubjectKeyID(PublicKeyInformation publicKey);
    internal static SubjectKeyID GetIdentifier(object obj);
    internal Byte[] GetKeyIdentifier();
    public virtual Asn1 GetAsn1();
    internal static PublicKeyInformation CreateSubjectKeyID(CipherParameter publicKey);
    private static void DecompressBytes(Byte[] encKey, int offset, Number byteBI);
    private static Byte[] GetDigest(PublicKeyInformation publicKey);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Syncfusion.Pdf.Security.TimeStampCertificate : Asn1Encode {
    private Asn1Sequence m_certificates;
    private Asn1Sequence m_policies;
    internal TimeStampIdentifier[] Certificates { get; }
    internal TimeStampCertificate(Asn1Sequence sequence);
    internal static TimeStampCertificate GetTimeStanpCertificate(object obj);
    public virtual Asn1 GetAsn1();
    internal TimeStampIdentifier[] get_Certificates();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Syncfusion.Pdf.Security.TimeStampCertIssuerDetails : Asn1Encode {
    private DerNames m_issuerName;
    private DerInteger m_serialNumber;
    private DerBitString m_issuerId;
    private TimeStampCertIssuerDetails(Asn1Sequence sequence);
    internal static TimeStampCertIssuerDetails GetIssuerDetails(object obj);
    public virtual Asn1 GetAsn1();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Syncfusion.Pdf.Security.TimeStampData : Asn1Encode {
    private DerInteger m_version;
    private DerObjectID m_policyId;
    private MessageStamp m_messageImprint;
    private DerInteger m_serialNumber;
    private GeneralizedTime m_generalizedTime;
    private DerPrecision m_precision;
    private DerBoolean m_isOrdered;
    private DerInteger m_nonce;
    private DerName m_timeStampName;
    private X509Extensions m_extensions;
    internal DerInteger Version { get; }
    internal MessageStamp MessageImprint { get; }
    internal DerObjectID Policy { get; }
    internal DerInteger SerialNumber { get; }
    internal DerPrecision Precision { get; }
    internal GeneralizedTime GeneralizedTime { get; }
    internal DerBoolean IsOrdered { get; }
    internal DerInteger Nonce { get; }
    internal DerName TimeStampName { get; }
    internal X509Extensions Extensions { get; }
    internal TimeStampData(Asn1Sequence sequence);
    internal DerInteger get_Version();
    internal MessageStamp get_MessageImprint();
    internal DerObjectID get_Policy();
    internal DerInteger get_SerialNumber();
    internal DerPrecision get_Precision();
    internal GeneralizedTime get_GeneralizedTime();
    internal DerBoolean get_IsOrdered();
    internal DerInteger get_Nonce();
    internal DerName get_TimeStampName();
    internal X509Extensions get_Extensions();
    public virtual Asn1 GetAsn1();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Syncfusion.Pdf.Security.TimeStampElement : Asn1Encode {
    private DerObjectID m_type;
    private Asn1Set m_values;
    internal DerObjectID Type { get; }
    internal Asn1Set Values { get; }
    internal TimeStampElement(Asn1Sequence sequence);
    internal DerObjectID get_Type();
    internal Asn1Set get_Values();
    internal static TimeStampElement GetTimeStampElement(object obj);
    public virtual Asn1 GetAsn1();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[DefaultMemberAttribute("Item")]
internal class Syncfusion.Pdf.Security.TimeStampElements : object {
    private Dictionary`2<DerObjectID, List`1<TimeStampElement>> m_elements;
    internal TimeStampElement Item { get; }
    internal TimeStampElements(Asn1Set values);
    internal TimeStampElement get_Item(DerObjectID id);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Syncfusion.Pdf.Security.TimeStampIdentifier : object {
    private Asn1Octet m_hash;
    private TimeStampCertIssuerDetails m_issuerDetail;
    internal TimeStampIdentifier(Asn1Sequence sequence);
    internal static TimeStampIdentifier GetTimeStampCertID(object obj);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class Syncfusion.Pdf.Security.TimeStampInformation : object {
    private bool m_isValid;
    private X509Certificate2 m_certificate;
    private string m_messageImprintAlgorithmId;
    private string m_timeStampPolicyId;
    private DateTime m_time;
    private object m_signerInformation;
    private bool m_documentTimeStamp;
    private List`1<PdfSignerCertificate> m_signerCertificates;
    internal PdfCmsSigner m_signer;
    internal string MessageImprintAlgorithmId { get; internal set; }
    public string TimeStampPolicyId { get; internal set; }
    public DateTime Time { get; internal set; }
    internal object SignerInformation { get; internal set; }
    public bool IsValid { get; internal set; }
    public bool IsDocumentTimeStamp { get; internal set; }
    public X509Certificate2 Certificate { get; internal set; }
    public PdfSignerCertificate[] SignerCertificates { get; }
    internal string get_MessageImprintAlgorithmId();
    internal void set_MessageImprintAlgorithmId(string value);
    public string get_TimeStampPolicyId();
    internal void set_TimeStampPolicyId(string value);
    public DateTime get_Time();
    internal void set_Time(DateTime value);
    internal object get_SignerInformation();
    internal void set_SignerInformation(object value);
    public bool get_IsValid();
    internal void set_IsValid(bool value);
    public bool get_IsDocumentTimeStamp();
    internal void set_IsDocumentTimeStamp(bool value);
    public X509Certificate2 get_Certificate();
    internal void set_Certificate(X509Certificate2 value);
    public PdfSignerCertificate[] get_SignerCertificates();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Syncfusion.Pdf.Security.TimeStampRequestCreator : Asn1 {
    private static string c_IdSHA256;
    private static string c_IdTimeStampToken;
    private Asn1Integer m_version;
    private MessageStamp m_messageImprint;
    private Asn1Boolean m_certReq;
    public TimeStampRequestCreator(bool certReq);
    public Byte[] GetAsnEncodedTimestampRequest(Byte[] hash);
    protected virtual bool IsEquals(Asn1 asn1Object);
    public virtual int GetHashCode();
    internal virtual void Encode(DerStream derOut);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Syncfusion.Pdf.Security.TimeStampResponse : object {
    private Asn1 m_encodedObject;
    private Asn1Integer m_pkiStatusInfo;
    private Asn1 m_timeStampToken;
    private Asn1Identifier m_contentType;
    internal Asn1 Object { get; }
    internal TimeStampResponse(Byte[] bytes);
    internal Asn1 get_Object();
    internal Byte[] GetEncoded(Asn1 encodedObject);
    private void ReadTimeStampResponse(Asn1Stream stream);
    private Byte[] ReadTimeStampToken(Asn1 encodedObject);
    private Byte[] ReadContentInfo();
    private Byte[] ReadTimeStampContent();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class Syncfusion.Pdf.Security.TimeStampServer : object {
    private Uri m_server;
    private string m_username;
    private string m_password;
    private int m_timeOut;
    private Byte[] inputBytes;
    private Stream m_stream;
    private ManualResetEvent allDone;
    public Uri Server { get; public set; }
    public string UserName { get; public set; }
    public string Password { get; public set; }
    public int TimeOut { get; public set; }
    public bool IsValid { get; }
    public TimeStampServer(Uri server);
    public TimeStampServer(Uri server, string username, string password);
    public TimeStampServer(Uri server, string username, string password, int timeOut);
    public Uri get_Server();
    public void set_Server(Uri value);
    public string get_UserName();
    public void set_UserName(string value);
    public string get_Password();
    public void set_Password(string value);
    public int get_TimeOut();
    public void set_TimeOut(int value);
    public bool get_IsValid();
    internal bool IsValidTimeStamp();
    internal Byte[] GetTimeStampResponse(Byte[] request);
    private void GetRequestStreamCallback(IAsyncResult asynchronousResult);
    private void GetResponseCallback(IAsyncResult asynchronousResult);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Syncfusion.Pdf.Security.TimeStampToken : object {
    private CmsSignedDetails m_timeStampData;
    private CmsSignerDetails m_sigerDetails;
    private TimeStampIdentifier m_certIdentifier;
    private TimeStampTokenInformation m_timestampTokenInformation;
    internal TimeStampTokenInformation TimeStampInformation { get; }
    internal TimeStampToken(CmsSignedDetails signedData);
    internal TimeStampTokenInformation get_TimeStampInformation();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Syncfusion.Pdf.Security.TimeStampTokenInformation : object {
    private TimeStampData m_timeStampData;
    private DateTime m_generalizedTime;
    internal DateTime GeneralizedTime { get; }
    internal string Policy { get; }
    internal string MessageImprintAlgOid { get; }
    internal TimeStampData TimeStampData { get; }
    internal TimeStampTokenInformation(TimeStampData timeStampData);
    internal DateTime get_GeneralizedTime();
    internal string get_Policy();
    internal string get_MessageImprintAlgOid();
    internal TimeStampData get_TimeStampData();
}
internal class Syncfusion.Pdf.Security.TSGenerator : object {
}
internal class Syncfusion.Pdf.Security.WindowRandom : object {
    [NullableAttribute("1")]
private IRandom m_source;
    private long m_offset;
    private long m_length;
    public long Length { get; }
    [NullableContextAttribute("1")]
internal WindowRandom(IRandom source, long offset, long length);
    public virtual int Get(long position);
    [NullableContextAttribute("1")]
public virtual int Get(long position, Byte[] bytes, int off, int len);
    public virtual long get_Length();
    public virtual void Close();
    public virtual void Dispose();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Syncfusion.Pdf.Security.X509Certificate : X509ExtensionBase {
    private X509CertificateStructure m_c;
    private BaseConstraints m_basicConstraints;
    private Boolean[] m_keyUsage;
    private bool m_hashValueSet;
    private int m_hashValue;
    internal X509CertificateStructure CertificateStructure { get; }
    public bool IsValidNow { get; }
    public int Version { get; }
    public Number SerialNumber { get; }
    public X509Name IssuerDN { get; }
    public X509Name SubjectDN { get; }
    public DateTime NotBefore { get; }
    public DateTime NotAfter { get; }
    public string SigAlgName { get; }
    public string SigAlgOid { get; }
    public DerBitString IssuerUniqueID { get; }
    public DerBitString SubjectUniqueID { get; }
    internal X509Certificate(X509CertificateStructure c);
    internal virtual X509CertificateStructure get_CertificateStructure();
    public virtual bool get_IsValidNow();
    public virtual bool IsValid(DateTime time);
    public virtual void CheckValidity();
    public virtual void CheckValidity(DateTime time);
    public virtual int get_Version();
    public virtual Number get_SerialNumber();
    public virtual X509Name get_IssuerDN();
    public virtual X509Name get_SubjectDN();
    public virtual DateTime get_NotBefore();
    public virtual DateTime get_NotAfter();
    public virtual Byte[] GetTbsCertificate();
    public virtual Byte[] GetSignature();
    public virtual string get_SigAlgName();
    public virtual string get_SigAlgOid();
    public virtual Byte[] GetSigAlgParams();
    public virtual DerBitString get_IssuerUniqueID();
    public virtual DerBitString get_SubjectUniqueID();
    public virtual Boolean[] GetKeyUsage();
    public virtual IList GetExtendedKeyUsage();
    internal List`1<string> GetOids(bool critical);
    public virtual int GetBasicConstraints();
    public virtual ICollection GetSubjectAlternativeNames();
    public virtual ICollection GetIssuerAlternativeNames();
    protected virtual ICollection GetAlternativeNames(string oid);
    protected virtual X509Extensions GetX509Extensions();
    public virtual CipherParameter GetPublicKey();
    internal CipherParameter CreateKey(PublicKeyInformation keyInfo);
    public virtual Byte[] GetEncoded();
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    public virtual string ToString();
    public virtual void Verify(CipherParameter key);
    protected virtual void CheckSignature(CipherParameter publicKey, ISigner signature);
    private static bool IsAlgIDEqual(Algorithms id1, Algorithms id2);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Syncfusion.Pdf.Security.X509Certificate2Signature : object {
    private X509Certificate2 certificate;
    private string hashAlgorithm;
    private string encryptionAlgorithm;
    public X509Certificate2Signature(X509Certificate2 cert, string hashAlgorithm);
    public virtual string GetHashAlgorithm();
    public virtual string GetEncryptionAlgorithm();
    public Byte[] Sign(Byte[] message);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Syncfusion.Pdf.Security.X509CertificateHelper : object {
    private Byte[] m_id;
    private X509Name m_issuer;
    private Number m_serialNumber;
    internal Byte[] KeyIdentifier { get; internal set; }
    internal X509Name Issuer { get; internal set; }
    internal Number SerialNumber { get; internal set; }
    internal Byte[] get_KeyIdentifier();
    internal void set_KeyIdentifier(Byte[] value);
    internal X509Name get_Issuer();
    internal void set_Issuer(X509Name value);
    internal Number get_SerialNumber();
    internal void set_SerialNumber(Number value);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Syncfusion.Pdf.Security.X509CertificateParser : object {
    private Asn1Set m_sData;
    private int m_sDataObjectCount;
    private Stream m_currentStream;
    private X509Certificate ReadDerCertificate(Asn1Stream dIn);
    private X509Certificate GetCertificate();
    protected virtual X509Certificate CreateX509Certificate(X509CertificateStructure c);
    internal X509Certificate ReadCertificate(Byte[] input);
    internal ICollection ReadCertificates(Byte[] input);
    internal X509Certificate ReadCertificate(Stream inStream);
    internal ICollection ReadCertificates(Stream inStream);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Syncfusion.Pdf.Security.X509Certificates : object {
    private X509Certificate m_certificate;
    internal X509Certificate Certificate { get; }
    internal X509Certificates(X509Certificate certificates);
    internal X509Certificate get_Certificate();
    public virtual int GetHashCode();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Syncfusion.Pdf.Security.X509CertificateStructure : Asn1Encode {
    private SingnedCertificate m_tbsCert;
    private Algorithms m_sigAlgID;
    private DerBitString m_sig;
    internal SingnedCertificate TbsCertificate { get; }
    internal int Version { get; }
    internal DerInteger SerialNumber { get; }
    internal X509Name Issuer { get; }
    internal X509Time StartDate { get; }
    internal X509Time EndDate { get; }
    internal X509Name Subject { get; }
    internal PublicKeyInformation SubjectPublicKeyInfo { get; }
    internal Algorithms SignatureAlgorithm { get; }
    internal DerBitString Signature { get; }
    private X509CertificateStructure(Asn1Sequence seq);
    internal static X509CertificateStructure GetInstance(object obj);
    internal SingnedCertificate get_TbsCertificate();
    internal int get_Version();
    internal DerInteger get_SerialNumber();
    internal X509Name get_Issuer();
    internal X509Time get_StartDate();
    internal X509Time get_EndDate();
    internal X509Name get_Subject();
    internal PublicKeyInformation get_SubjectPublicKeyInfo();
    internal Algorithms get_SignatureAlgorithm();
    internal DerBitString get_Signature();
    public virtual Asn1 GetAsn1();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Syncfusion.Pdf.Security.X509Extension : object {
    internal bool m_critical;
    internal Asn1Octet m_value;
    internal bool IsCritical { get; }
    internal Asn1Octet Value { get; }
    internal X509Extension(bool critical, Asn1Octet value);
    internal bool get_IsCritical();
    internal Asn1Octet get_Value();
    internal Asn1Encode GetParsedValue();
    public virtual int GetHashCode();
    public virtual bool Equals(object obj);
    public static Asn1 ConvertValueToObject(X509Extension ext);
}
internal abstract class Syncfusion.Pdf.Security.X509ExtensionBase : object {
    [NullableContextAttribute("1")]
protected abstract virtual X509Extensions GetX509Extensions();
    [NullableContextAttribute("1")]
public virtual Asn1Octet GetExtension(DerObjectID oid);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Syncfusion.Pdf.Security.X509Extensions : Asn1Encode {
    internal static DerObjectID SubjectDirectoryAttributes;
    internal static DerObjectID SubjectKeyIdentifier;
    internal static DerObjectID KeyUsage;
    internal static DerObjectID PrivateKeyUsagePeriod;
    internal static DerObjectID SubjectAlternativeName;
    internal static DerObjectID IssuerAlternativeName;
    internal static DerObjectID BasicConstraints;
    internal static DerObjectID CrlNumber;
    internal static DerObjectID ReasonCode;
    internal static DerObjectID InstructionCode;
    internal static DerObjectID InvalidityDate;
    internal static DerObjectID DeltaCrlIndicator;
    internal static DerObjectID IssuingDistributionPoint;
    internal static DerObjectID CertificateIssuer;
    internal static DerObjectID NameConstraints;
    internal static DerObjectID CrlDistributionPoints;
    internal static DerObjectID CertificatePolicies;
    internal static DerObjectID PolicyMappings;
    internal static DerObjectID AuthorityKeyIdentifier;
    internal static DerObjectID PolicyConstraints;
    internal static DerObjectID ExtendedKeyUsage;
    internal static DerObjectID FreshestCrl;
    internal static DerObjectID InhibitAnyPolicy;
    internal static DerObjectID AuthorityInfoAccess;
    internal static DerObjectID SubjectInfoAccess;
    internal static DerObjectID LogoType;
    internal static DerObjectID BiometricInfo;
    internal static DerObjectID QCStatements;
    internal static DerObjectID AuditIdentity;
    internal static DerObjectID NoRevAvail;
    internal static DerObjectID TargetInformation;
    private Dictionary`2<DerObjectID, X509Extension> m_extensions;
    private IList m_ordering;
    internal IEnumerable ExtensionOids { get; }
    private X509Extensions(Asn1Sequence seq);
    internal X509Extensions(IDictionary extensions);
    internal X509Extensions(IList ordering, IDictionary extensions);
    private static X509Extensions();
    internal static X509Extensions GetInstance(Asn1Tag obj, bool explicitly);
    internal static X509Extensions GetInstance(object obj);
    internal IEnumerable get_ExtensionOids();
    internal X509Extension GetExtension(DerObjectID oid);
    public virtual Asn1 GetAsn1();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Syncfusion.Pdf.Security.X509Name : Asn1Encode {
    internal static DerObjectID C;
    internal static DerObjectID O;
    internal static DerObjectID OU;
    internal static DerObjectID T;
    internal static DerObjectID CN;
    internal static DerObjectID Street;
    internal static DerObjectID SerialNumber;
    internal static DerObjectID L;
    internal static DerObjectID ST;
    internal static DerObjectID Surname;
    internal static DerObjectID GivenName;
    internal static DerObjectID Initials;
    internal static DerObjectID Generation;
    internal static DerObjectID UniqueIdentifier;
    internal static DerObjectID BusinessCategory;
    internal static DerObjectID PostalCode;
    internal static DerObjectID DnQualifier;
    internal static DerObjectID Pseudonym;
    internal static DerObjectID DateOfBirth;
    internal static DerObjectID PlaceOfBirth;
    internal static DerObjectID Gender;
    internal static DerObjectID CountryOfCitizenship;
    internal static DerObjectID CountryOfResidence;
    internal static DerObjectID NameAtBirth;
    internal static DerObjectID PostalAddress;
    internal static DerObjectID DmdName;
    internal static DerObjectID TelephoneNumber;
    internal static DerObjectID Name;
    internal static DerObjectID EmailAddress;
    internal static DerObjectID UnstructuredName;
    internal static DerObjectID UnstructuredAddress;
    internal static DerObjectID E;
    internal static DerObjectID DC;
    internal static DerObjectID UID;
    private static Boolean[] defaultReverse;
    internal static Dictionary`2<DerObjectID, string> DefaultSymbols;
    internal static Dictionary`2<DerObjectID, string> RFC2253Symbols;
    internal static Dictionary`2<DerObjectID, string> RFC1779Symbols;
    internal static Dictionary`2<string, DerObjectID> DefaultLookup;
    private List`1<object> m_ordering;
    private List`1<object> m_values;
    private List`1<object> m_added;
    private Asn1Sequence m_sequence;
    internal static bool DefaultReverse { get; internal set; }
    private static X509Name();
    protected X509Name(Asn1Sequence sequence);
    internal static bool get_DefaultReverse();
    internal static void set_DefaultReverse(bool value);
    internal static X509Name GetName(Asn1Tag tag, bool isExplicit);
    internal static X509Name GetName(object obj);
    public virtual Asn1 GetAsn1();
    private void AppendValue(StringBuilder builder, IDictionary symbols, DerObjectID id, string value);
    internal string ToString(bool isReverse, IDictionary symbols);
    public virtual string ToString();
    internal bool Equivalent(X509Name other);
    private bool CheckStringEquivalent(string text, string other);
    private string RecognizeText(string text);
    private string SkipSequence(string sequence);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal abstract class Syncfusion.Pdf.Security.X509Objects : object {
    internal static string ID;
    internal static DerObjectID CommonName;
    internal static DerObjectID CountryName;
    internal static DerObjectID LocalityName;
    internal static DerObjectID StateOrProvinceName;
    internal static DerObjectID Organization;
    internal static DerObjectID OrganizationalUnitName;
    internal static DerObjectID TelephoneNumberID;
    internal static DerObjectID NameID;
    internal static DerObjectID IdSha1;
    internal static DerObjectID RipeMD160;
    internal static DerObjectID RipeMD160WithRsaEncryption;
    internal static DerObjectID IdEARsa;
    internal static DerObjectID IdPkix;
    internal static DerObjectID IdPE;
    internal static DerObjectID IdAD;
    internal static DerObjectID IdADCAIssuers;
    internal static DerObjectID IdADOcsp;
    internal static DerObjectID OcspAccessMethod;
    internal static DerObjectID CrlAccessMethod;
    private static X509Objects();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Syncfusion.Pdf.Security.X509RevocationResponse : X509ExtensionBase {
    private OcspHelper m_helper;
    private ResponseInformation m_data;
    internal Byte[] EncodedBytes { get; }
    internal OneTimeResponse[] Responses { get; }
    internal X509Certificate[] Certificates { get; }
    internal X509RevocationResponse(OcspHelper helper);
    internal Byte[] get_EncodedBytes();
    internal OneTimeResponse[] get_Responses();
    internal X509Certificate[] get_Certificates();
    protected virtual X509Extensions GetX509Extensions();
    internal bool Verify(CipherParameter publicKey);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Syncfusion.Pdf.Security.X509Time : Asn1Encode {
    internal Asn1 m_time;
    internal X509Time(Asn1 time);
    internal static X509Time GetTime(object obj);
    internal string GetTime();
    internal DateTime ToDateTime();
    public virtual Asn1 GetAsn1();
    public virtual string ToString();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Syncfusion.Pdf.Segments : object {
    private ushort startCode;
    private ushort endCode;
    private short idDelta;
    private UInt16[] map;
    public Segments(ushort startCode, ushort endCode, short idDelta);
    public Segments(ushort startCode, ushort endCode, short idDelta, UInt16[] mapval);
    public bool IsContain(ushort charCode);
    public ushort GetGlyphId(ushort charCode);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Syncfusion.Pdf.SimpleGlyf : TrueTypeGlyphs {
    private List`1<OutlinePoint[]> contours;
    internal List`1<OutlinePoint[]> Contours { get; }
    public SimpleGlyf(FontFile2 fontFile, ushort glyphIndex);
    internal List`1<OutlinePoint[]> get_Contours();
    public virtual void Read(ReadFontArray reader);
    private static bool XIsByte(Byte[] flags, int index);
    private static bool YIsByte(Byte[] flags, int index);
    private static bool XIsSame(Byte[] flags, int index);
    private static bool YIsSame(Byte[] flags, int index);
    private static bool Repeat(Byte[] flags, int index);
    internal static bool GetBit(int n, byte bit);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[DefaultMemberAttribute("Item")]
internal class Syncfusion.Pdf.SortedListEx : object {
    private static int _defaultCapacity;
    private Object[] keys;
    private Dictionary`2<object, object> values;
    private int _size;
    private int version;
    private IComparer comparer;
    private KeyList keyList;
    private ValueList valueList;
    public int Capacity { get; public set; }
    public int Count { get; }
    public ICollection Keys { get; }
    public ICollection Values { get; }
    public bool IsReadOnly { get; }
    public bool IsFixedSize { get; }
    public bool IsSynchronized { get; }
    public object SyncRoot { get; }
    public object Item { get; public set; }
    public SortedListEx(int initialCapacity);
    public SortedListEx(IComparer comparer);
    public SortedListEx(IComparer comparer, int capacity);
    public SortedListEx(IDictionary d);
    public SortedListEx(IDictionary d, IComparer comparer);
    public virtual int get_Capacity();
    public virtual void set_Capacity(int value);
    public virtual int get_Count();
    public virtual ICollection get_Keys();
    public virtual ICollection get_Values();
    public virtual bool get_IsReadOnly();
    public virtual bool get_IsFixedSize();
    public virtual bool get_IsSynchronized();
    public virtual object get_SyncRoot();
    public virtual object get_Item(object key);
    public virtual void set_Item(object key, object value);
    public static SortedListEx Synchronized(SortedListEx list);
    public virtual void Add(object key, object value);
    public virtual void Clear();
    public virtual object Clone();
    public SortedListEx CloneAll();
    public virtual bool Contains(object key);
    public virtual bool ContainsKey(object key);
    public virtual bool ContainsValue(object value);
    public virtual void CopyTo(Array array, int arrayIndex);
    public virtual object GetByIndex(int index);
    public virtual object GetKey(int index);
    public virtual IList GetKeyList();
    public virtual IList GetValueList();
    public virtual int IndexOfKey(object key);
    public virtual int IndexOfValue(object value);
    public virtual void RemoveAt(int index);
    public virtual void Remove(object key);
    public virtual void SetByIndex(int index, object value);
    public virtual void TrimToSize();
    public virtual IDictionaryEnumerator GetEnumerator();
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
    private void Insert(int index, object key, object value);
    private void EnsureCapacity(int min);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[DefaultMemberAttribute("Item")]
internal class Syncfusion.Pdf.SortedListEx`2 : object {
    private static int _defaultCapacity;
    private TKey[] m_keys;
    private Dictionary`2<TKey, TValue> m_values;
    private int m_size;
    private int m_version;
    private IComparer`1<TKey> m_comparer;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private KeyList<TKey, TValue> m_keyList;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private ValueList<TKey, TValue> m_valueList;
    public int Capacity { get; public set; }
    public int Count { get; }
    public IList`1<TKey> Keys { get; }
    private ICollection`1<TKey> System.Collections.Generic.IDictionary<TKey,TValue>.Keys { get; }
    public IList`1<TValue> Values { get; }
    private ICollection`1<TValue> System.Collections.Generic.IDictionary<TKey,TValue>.Values { get; }
    public bool IsReadOnly { get; }
    public bool IsFixedSize { get; }
    public bool IsSynchronized { get; }
    public object SyncRoot { get; }
    public TValue Item { get; public set; }
    public SortedListEx`2(int initialCapacity);
    public SortedListEx`2(IComparer`1<TKey> comparer);
    public SortedListEx`2(IComparer`1<TKey> comparer, int capacity);
    public SortedListEx`2(IDictionary`2<TKey, TValue> d);
    public SortedListEx`2(IDictionary`2<TKey, TValue> d, IComparer`1<TKey> comparer);
    public virtual int get_Capacity();
    public virtual void set_Capacity(int value);
    public virtual int get_Count();
    public virtual IList`1<TKey> get_Keys();
    private sealed virtual override ICollection`1<TKey> System.Collections.Generic.IDictionary<TKey,TValue>.get_Keys();
    public virtual IList`1<TValue> get_Values();
    private sealed virtual override ICollection`1<TValue> System.Collections.Generic.IDictionary<TKey,TValue>.get_Values();
    public virtual bool get_IsReadOnly();
    public virtual bool get_IsFixedSize();
    public virtual bool get_IsSynchronized();
    public virtual object get_SyncRoot();
    public virtual TValue get_Item(TKey key);
    public virtual void set_Item(TKey key, TValue value);
    public static SortedListEx`2<TKey, TValue> Synchronized(SortedListEx`2<TKey, TValue> list);
    public virtual void Add(TKey key, TValue value);
    public virtual void Add(KeyValuePair`2<TKey, TValue> pair);
    public virtual void Clear();
    public virtual object Clone();
    public SortedListEx`2<TKey, TValue> CloneAll();
    public virtual bool Contains(TKey key);
    public virtual bool ContainsKey(TKey key);
    public virtual bool ContainsValue(TValue value);
    public virtual bool Contains(KeyValuePair`2<TKey, TValue> pair);
    public virtual void CopyTo(KeyValuePair`2[] array, int arrayIndex);
    public virtual TValue GetByIndex(int index);
    public virtual TKey GetKey(int index);
    public virtual IList`1<TKey> GetKeyList();
    public virtual IList`1<TValue> GetValueList();
    public virtual int IndexOfKey(TKey key);
    public virtual int IndexOfValue(TValue value);
    public virtual void RemoveAt(int index);
    public virtual bool Remove(TKey key);
    public virtual bool Remove(KeyValuePair`2<TKey, TValue> pair);
    public virtual void SetByIndex(int index, TValue value);
    public virtual void TrimToSize();
    public virtual IEnumerator`1<KeyValuePair`2<TKey, TValue>> GetEnumerator();
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
    public virtual bool TryGetValue(TKey key, TValue& value);
    private void Insert(int index, TKey key, TValue value);
    private void EnsureCapacity(int min);
}
internal enum Syncfusion.Pdf.StreamFilters : Enum {
    public int value__;
    public static StreamFilters DCTDecode;
    public static StreamFilters FlateDecode;
}
internal class Syncfusion.Pdf.StringComparer : object {
    [NullableContextAttribute("1")]
public sealed virtual int Compare(object x, object y);
    [NullableContextAttribute("1")]
public sealed virtual int Compare(string x, string y);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal abstract class Syncfusion.Pdf.TableBase : object {
    private FontFile2 fontSource;
    private int m_offset;
    internal int Id { get; }
    public int Offset { get; public set; }
    protected ReadFontArray Reader { get; }
    protected FontFile2 FontSource { get; }
    public TableBase(FontFile2 fontSource);
    internal abstract virtual int get_Id();
    public int get_Offset();
    public void set_Offset(int value);
    protected ReadFontArray get_Reader();
    protected FontFile2 get_FontSource();
    public abstract virtual void Read(ReadFontArray reader);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Syncfusion.Pdf.TableEntry : object {
    public string id;
    public int checkSum;
    public int offset;
    public int length;
    public Byte[] bytes;
}
public class Syncfusion.Pdf.Tables.BeginCellLayoutEventArgs : CellLayoutEventArgs {
    private bool m_bSkip;
    public bool Skip { get; public set; }
    [NullableContextAttribute("1")]
internal BeginCellLayoutEventArgs(PdfGraphics graphics, int rowIndex, int cellInder, RectangleF bounds, string value);
    public bool get_Skip();
    public void set_Skip(bool value);
}
public class Syncfusion.Pdf.Tables.BeginCellLayoutEventHandler : MulticastDelegate {
    public BeginCellLayoutEventHandler(object object, IntPtr method);
    [NullableContextAttribute("1")]
public virtual void Invoke(object sender, BeginCellLayoutEventArgs args);
    public virtual IAsyncResult BeginInvoke(object sender, BeginCellLayoutEventArgs args, AsyncCallback callback, object object);
    public virtual void EndInvoke(IAsyncResult result);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class Syncfusion.Pdf.Tables.BeginRowLayoutEventArgs : EventArgs {
    private int m_rowIndex;
    private PdfCellStyle m_cellStyle;
    private Int32[] m_spanMap;
    private bool m_bCancel;
    private bool m_bSkip;
    private bool m_ignoreColumnFormat;
    private float m_minHeight;
    private bool m_isRowPaginated;
    internal bool isArgsPropertyModified;
    public int RowIndex { get; }
    public PdfCellStyle CellStyle { get; public set; }
    public Int32[] ColumnSpanMap { get; public set; }
    public bool Cancel { get; public set; }
    public bool Skip { get; public set; }
    public bool IgnoreColumnFormat { get; public set; }
    public float MinimalHeight { get; public set; }
    internal bool IsRowPaginated { get; internal set; }
    internal BeginRowLayoutEventArgs(int rowIndex, PdfCellStyle cellStyle);
    public int get_RowIndex();
    public PdfCellStyle get_CellStyle();
    public void set_CellStyle(PdfCellStyle value);
    public Int32[] get_ColumnSpanMap();
    public void set_ColumnSpanMap(Int32[] value);
    public bool get_Cancel();
    public void set_Cancel(bool value);
    public bool get_Skip();
    public void set_Skip(bool value);
    public bool get_IgnoreColumnFormat();
    public void set_IgnoreColumnFormat(bool value);
    public float get_MinimalHeight();
    public void set_MinimalHeight(float value);
    internal bool get_IsRowPaginated();
    internal void set_IsRowPaginated(bool value);
}
public class Syncfusion.Pdf.Tables.BeginRowLayoutEventHandler : MulticastDelegate {
    public BeginRowLayoutEventHandler(object object, IntPtr method);
    [NullableContextAttribute("1")]
public virtual void Invoke(object sender, BeginRowLayoutEventArgs args);
    public virtual IAsyncResult BeginInvoke(object sender, BeginRowLayoutEventArgs args, AsyncCallback callback, object object);
    public virtual void EndInvoke(IAsyncResult result);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public abstract class Syncfusion.Pdf.Tables.CellLayoutEventArgs : EventArgs {
    private int m_rowIndex;
    private int m_cellIndex;
    private string m_value;
    private RectangleF m_bounds;
    private PdfGraphics m_graphics;
    public int RowIndex { get; }
    public int CellIndex { get; }
    public string Value { get; }
    public RectangleF Bounds { get; }
    public PdfGraphics Graphics { get; }
    internal CellLayoutEventArgs(PdfGraphics graphics, int rowIndex, int cellInder, RectangleF bounds, string value);
    public int get_RowIndex();
    public int get_CellIndex();
    public string get_Value();
    public RectangleF get_Bounds();
    public PdfGraphics get_Graphics();
}
public class Syncfusion.Pdf.Tables.EndCellLayoutEventArgs : CellLayoutEventArgs {
    [NullableContextAttribute("1")]
internal EndCellLayoutEventArgs(PdfGraphics graphics, int rowIndex, int cellInder, RectangleF bounds, string value);
}
public class Syncfusion.Pdf.Tables.EndCellLayoutEventHandler : MulticastDelegate {
    public EndCellLayoutEventHandler(object object, IntPtr method);
    [NullableContextAttribute("1")]
public virtual void Invoke(object sender, EndCellLayoutEventArgs args);
    public virtual IAsyncResult BeginInvoke(object sender, EndCellLayoutEventArgs args, AsyncCallback callback, object object);
    public virtual void EndInvoke(IAsyncResult result);
}
public class Syncfusion.Pdf.Tables.EndRowLayoutEventArgs : EventArgs {
    private int m_rowIndex;
    private bool m_bDrawnCompletely;
    private bool m_bCancel;
    private RectangleF m_bounds;
    public int RowIndex { get; }
    public bool LayoutCompleted { get; }
    public bool Cancel { get; public set; }
    public RectangleF Bounds { get; }
    internal EndRowLayoutEventArgs(int rowIndex, bool drawnCompletely, RectangleF rowBounds);
    public int get_RowIndex();
    public bool get_LayoutCompleted();
    public bool get_Cancel();
    public void set_Cancel(bool value);
    public RectangleF get_Bounds();
}
public class Syncfusion.Pdf.Tables.EndRowLayoutEventHandler : MulticastDelegate {
    public EndRowLayoutEventHandler(object object, IntPtr method);
    [NullableContextAttribute("1")]
public virtual void Invoke(object sender, EndRowLayoutEventArgs args);
    public virtual IAsyncResult BeginInvoke(object sender, EndRowLayoutEventArgs args, AsyncCallback callback, object object);
    public virtual void EndInvoke(IAsyncResult result);
}
public class Syncfusion.Pdf.Tables.LightTableBeginPageLayoutEventArgs : BeginPageLayoutEventArgs {
    private int m_startRow;
    public int StartRowIndex { get; }
    [NullableContextAttribute("1")]
internal LightTableBeginPageLayoutEventArgs(RectangleF bounds, PdfPage page, int startRow);
    public int get_StartRowIndex();
}
public class Syncfusion.Pdf.Tables.LightTableEndPageLayoutEventArgs : EndPageLayoutEventArgs {
    private int m_startRow;
    private int m_endRow;
    public int StartRowIndex { get; }
    public int EndRowIndex { get; }
    [NullableContextAttribute("1")]
internal LightTableEndPageLayoutEventArgs(PdfLightTableLayoutResult result, int startRow, int endRow);
    public int get_StartRowIndex();
    public int get_EndRowIndex();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Syncfusion.Pdf.Tables.LightTableLayouter : ElementLayouter {
    private String[] m_row;
    private PdfStringLayoutResult[] m_latestTextResults;
    private Single[] m_cellWidths;
    private PdfPage m_currentPage;
    private SizeF m_currentPageBounds;
    private PdfGraphics m_currentGraphics;
    private RectangleF m_currentBounds;
    private float m_cellSpacing;
    private Int32[] m_spanMap;
    private int m_dropIndex;
    private int m_startColumn;
    private int m_endColumn;
    private int m_previousRowIndex;
    private int m_currentRowIndex;
    private int m_currentCellIndex;
    private int m_currentIndex;
    private bool isRemainder;
    private int currentPageIndex;
    private bool isPreviousReminderText;
    private int previousRowIndex;
    private int previousPageIndex;
    private bool remainderText;
    public PdfLightTable Table { get; }
    internal int CurrentPageIndex { get; }
    internal LightTableLayouter(PdfLightTable table);
    public PdfLightTable get_Table();
    internal int get_CurrentPageIndex();
    public void Layout(PdfGraphics graphics, PointF location);
    public void Layout(PdfGraphics graphics, RectangleF boundaries);
    protected virtual PdfLayoutResult LayoutInternal(PdfLayoutParams param);
    private PdfLightTableLayoutFormat GetFormat(PdfLayoutFormat format);
    private PdfLightTableLayoutResult GetLayoutResult(PageLayoutResult pageResult);
    private PageLayoutResult LayoutOnPage(int startRowIndex, PdfLayoutParams param, bool isPageFirst);
    private String[] CropRow(String[] row);
    private static RectangleF PreserveForBorder(RectangleF bounds, PdfPen pen, PdfBorderOverlapStyle overlapStyle);
    private PdfFont CreateBoldFont(PdfFont font);
    private PdfFont CreateRegularFont(PdfFont font);
    private PdfFont CreateItalicFont(PdfFont font);
    private bool DrawRow(PdfLayoutParams param, Int32& rowIndex, String[] row, RectangleF rowBouds, Single& rowHeight, bool isHeader, Boolean& stop);
    private void DrawBorder(RectangleF bounds, PdfGraphics graphics, PdfCellStyle style);
    private void SetTransparency(PdfGraphics& graphics, PdfPen pen);
    private void ValidateSpanMap();
    private bool IsIncomplete(PdfStringLayoutResult[] results);
    private float DetermineRowHeight(PdfLayoutParams param, int rowIndex, String[] row, RectangleF rowBouds, PdfStringLayoutResult[]& results, PdfCellStyle cs);
    private void DropToNextPage(PdfStringLayoutResult[] results, int count, String[] row);
    private float GetCellWidth(int cellIndex);
    private static float ApplyBordersToHeight(float height, float borderWidth, bool overlapped);
    private PdfStringLayoutResult DrawCell(PdfStringLayoutResult layoutResult, RectangleF bounds, int rowIndex, int cellIndex, PdfCellStyle cs, bool ignoreColumnFormat);
    private PdfCellStyle GetCellStyle(int rowIndex, bool isHeader, Boolean& hasOwnStyle);
    private Single[] GetWidths(RectangleF bounds);
    private String[] GetRow(int startRowIndex, PdfLayoutParams param);
    private float GetAlpha(PdfBrush brush);
    private bool RaiseBeforePageLayout(PdfPage currentPage, RectangleF& currentBounds, Int32& currentRow);
    private LightTableEndPageLayoutEventArgs RaisePageLayouted(PageLayoutResult pageResult);
    private BeginRowLayoutEventArgs RaiseBeforeRowLayout(int rowIndex, PdfCellStyle cellStyle);
    private bool RaiseAfterRowLayout(int rowIndex, bool isComplete, RectangleF rowBouds);
    private BeginCellLayoutEventArgs RaiseBeforeCellLayout(PdfGraphics graphics, int rowIndex, int cellIndex, RectangleF bounds, string value);
    private void RaiseAfterCellLayout(PdfGraphics graphics, int rowIndex, int cellIndex, RectangleF bounds, string value);
    private void ApplyStyle(PdfLightTableBuiltinStyle tableStyle);
    private PdfFont ChangeFontStyle(PdfFont font);
    private PdfBrush ApplyBandedColStyle(bool firstColumn, Color backColor, int cellIndex);
    private PdfBrush ApplyBandedRowStyle(bool headerRow, Color backColor, int rowIndex);
    private void ApplyTableGridLight(Color borderColor);
    private void ApplyPlainTable1(Color borderColor, Color backColor);
    private void ApplyPlainTable2(Color borderColor);
    private void ApplyPlainTable3(Color borderColor, Color backColor);
    private void ApplyPlainTable4(Color backColor);
    private void ApplyPlainTable5(Color borderColor, Color backColor);
    private void ApplyGridTable1Light(Color borderColor, Color headerBottomColor);
    private void ApplyGridTable2(Color borderColor, Color backColor);
    private void ApplyGridTable3(Color borderColor, Color backColor);
    private void ApplyGridTable4(Color borderColor, Color backColor, Color headerColor);
    private void ApplyGridTable5Dark(Color headerColor, Color oddRowColor, Color evenRowColor);
    private void ApplyGridTable6Colorful(Color borderColor, Color backColor, Color textColor);
    private void ApplyGridTable7Colorful(Color borderColor, Color backColor, Color textColor);
    private void ApplyListTable1Light(Color borderColor, Color backColor);
    private void ApplyListTable2(Color borderColor, Color backColor);
    private void ApplyListTable3(Color backColor);
    private void ApplyListTable4(Color borderColor, Color headerBackColor, Color bandedRowColor);
    private void ApplyListTable5Dark(Color backColor);
    private void ApplyListTable6Colorful(Color borderColor, Color backColor, Color textColor);
    private void ApplyListTable7Colorful(Color borderColor, Color backColor, Color textColor);
}
internal class Syncfusion.Pdf.Tables.NamespaceDoc : object {
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class Syncfusion.Pdf.Tables.PdfCellStyle : object {
    private PdfFont m_font;
    private PdfStringFormat m_stringFormat;
    private PdfPen m_textPen;
    private PdfBrush m_textBrush;
    private PdfPen m_borderPen;
    private PdfBrush m_backgroundBrush;
    private PdfBorders m_borders;
    public PdfFont Font { get; public set; }
    public PdfStringFormat StringFormat { get; public set; }
    public PdfPen TextPen { get; public set; }
    public PdfBrush TextBrush { get; public set; }
    public PdfPen BorderPen { get; public set; }
    public PdfBrush BackgroundBrush { get; public set; }
    internal PdfBorders Borders { get; internal set; }
    public PdfCellStyle(PdfFont font, PdfBrush fontBrush, PdfPen borderPen);
    public PdfFont get_Font();
    public void set_Font(PdfFont value);
    public PdfStringFormat get_StringFormat();
    public void set_StringFormat(PdfStringFormat value);
    public PdfPen get_TextPen();
    public void set_TextPen(PdfPen value);
    public PdfBrush get_TextBrush();
    public void set_TextBrush(PdfBrush value);
    public PdfPen get_BorderPen();
    public void set_BorderPen(PdfPen value);
    public PdfBrush get_BackgroundBrush();
    public void set_BackgroundBrush(PdfBrush value);
    internal PdfBorders get_Borders();
    internal void set_Borders(PdfBorders value);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class Syncfusion.Pdf.Tables.PdfColumn : object {
    private static float DefaultWidth;
    private float m_width;
    private PdfStringFormat m_stringFormat;
    private string m_columnName;
    internal bool isCustomWidth;
    internal PdfLightTableDataSourceType m_dataSourceType;
    public PdfStringFormat StringFormat { get; public set; }
    public float Width { get; public set; }
    public string ColumnName { get; public set; }
    internal PdfColumn(float width);
    public PdfColumn(string columnName);
    public PdfStringFormat get_StringFormat();
    public void set_StringFormat(PdfStringFormat value);
    public float get_Width();
    public void set_Width(float value);
    public string get_ColumnName();
    public void set_ColumnName(string value);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[DefaultMemberAttribute("Item")]
public class Syncfusion.Pdf.Tables.PdfColumnCollection : PdfCollection {
    public PdfColumn Item { get; }
    public PdfColumn get_Item(int index);
    public void Add(PdfColumn column);
    internal Single[] GetWidths(float totalWidth);
    internal Single[] GetWidths(float totalWidth, int startColumn, int endColumn, bool columnProportionalSizing);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Syncfusion.Pdf.Tables.PdfDataSource : object {
    private DataTable m_dataTable;
    private int m_rowCount;
    private int m_colCount;
    private DataColumn m_dataColumn;
    private Array m_array;
    private bool m_useSorting;
    private DataRow[] m_cachRows;
    internal bool UseSorting { get; internal set; }
    public int RowCount { get; }
    public int ColumnCount { get; }
    public String[] ColumnNames { get; }
    public String[] ColumnCaptions { get; }
    public PdfDataSource(DataTable table);
    internal PdfDataSource(IEnumerable customSource);
    public PdfDataSource(DataSet dataSet, string tableName);
    public PdfDataSource(DataView view);
    public PdfDataSource(DataColumn column);
    public PdfDataSource(Array array);
    internal bool get_UseSorting();
    internal void set_UseSorting(bool value);
    public int get_RowCount();
    public int get_ColumnCount();
    public String[] get_ColumnNames();
    public String[] get_ColumnCaptions();
    public String[] GetRow(Int32& index);
    public bool IsColumnReadOnly(int index);
    public MappingType GetColumnMappingType(int index);
    public Type GetColumnDataType(int index);
    public object GetColumnDefaultValue(int index);
    public bool AllowDBNull(int index);
    private Type GetTypeOfArray(Array array);
    private String[] GetColumnsNames();
    private String[] GetColumnsCaptions();
    private bool IsArrayValid(Array array, Int32& count);
    private void SetTable(DataTable table);
    private void dataTable_RowDeleted(object sender, DataRowChangeEventArgs e);
    private void dataTable_RowChanged(object sender, DataRowChangeEventArgs e);
    private void dataTable_ColumnChanged(object sender, DataColumnChangeEventArgs e);
    private void RefreshCache();
    private int GetVisibleColCount();
    private int GetVisibleIndex(int index);
    private String[] GetRowFromArray(Array array, Int32& index);
    private String[] GetRowFromColumn(DataColumn dataColumn, Int32& index);
    private String[] GetRowFromTable(DataTable dataTable, Int32& index);
    private static DataTable GetTableFromDataSet(DataSet dataSet, string tableName);
    private static DataTable GetTableFromDataView(DataView view);
}
public enum Syncfusion.Pdf.Tables.PdfHeaderSource : Enum {
    public int value__;
    public static PdfHeaderSource ColumnCaptions;
    public static PdfHeaderSource Rows;
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class Syncfusion.Pdf.Tables.PdfLightTable : PdfLayoutElement {
    private PdfColumnCollection m_columns;
    private PdfRowCollection m_rows;
    internal object m_dataSource;
    private string m_dataMember;
    private PdfLightTableDataSourceType m_dataSourceType;
    private PdfLightTableStyle m_properties;
    private PdfDataSource m_dsParser;
    private bool m_allowRowBreakAcrossPages;
    internal PdfLightTableBuiltinStyle m_lightTableBuiltinStyle;
    internal bool m_headerStyle;
    internal bool m_bandedRowStyle;
    internal bool m_bandedColStyle;
    internal bool m_totalRowStyle;
    internal bool m_firstColumnStyle;
    internal bool m_lastColumnStyle;
    internal bool isBuiltinStyle;
    internal bool isCustomDataSource;
    private bool isColumnProportionalSizing;
    [CompilerGeneratedAttribute]
private BeginRowLayoutEventHandler BeginRowLayout;
    [CompilerGeneratedAttribute]
private EndRowLayoutEventHandler EndRowLayout;
    [CompilerGeneratedAttribute]
private BeginCellLayoutEventHandler BeginCellLayout;
    [CompilerGeneratedAttribute]
private EndCellLayoutEventHandler EndCellLayout;
    [CompilerGeneratedAttribute]
private QueryNextRowEventHandler QueryNextRow;
    [CompilerGeneratedAttribute]
private QueryColumnCountEventHandler QueryColumnCount;
    [CompilerGeneratedAttribute]
private QueryRowCountEventHandler QueryRowCount;
    public PdfColumnCollection Columns { get; }
    public PdfRowCollection Rows { get; }
    public bool ColumnProportionalSizing { get; public set; }
    public object DataSource { get; public set; }
    public PdfLightTableDataSourceType DataSourceType { get; public set; }
    public PdfLightTableStyle Style { get; public set; }
    internal bool RaiseBeginRowLayout { get; }
    internal bool RaiseEndRowLayout { get; }
    internal bool RaiseBeginCellLayout { get; }
    internal bool RaiseEndCellLayout { get; }
    public bool AllowRowBreakAcrossPages { get; public set; }
    public PdfColumnCollection get_Columns();
    public PdfRowCollection get_Rows();
    public bool get_ColumnProportionalSizing();
    public void set_ColumnProportionalSizing(bool value);
    public object get_DataSource();
    public void set_DataSource(object value);
    public PdfLightTableDataSourceType get_DataSourceType();
    public void set_DataSourceType(PdfLightTableDataSourceType value);
    public PdfLightTableStyle get_Style();
    public void set_Style(PdfLightTableStyle value);
    public void SetDataSource();
    internal bool get_RaiseBeginRowLayout();
    internal bool get_RaiseEndRowLayout();
    internal bool get_RaiseBeginCellLayout();
    internal bool get_RaiseEndCellLayout();
    public bool get_AllowRowBreakAcrossPages();
    public void set_AllowRowBreakAcrossPages(bool value);
    [CompilerGeneratedAttribute]
public void add_BeginRowLayout(BeginRowLayoutEventHandler value);
    [CompilerGeneratedAttribute]
public void remove_BeginRowLayout(BeginRowLayoutEventHandler value);
    [CompilerGeneratedAttribute]
public void add_EndRowLayout(EndRowLayoutEventHandler value);
    [CompilerGeneratedAttribute]
public void remove_EndRowLayout(EndRowLayoutEventHandler value);
    [CompilerGeneratedAttribute]
public void add_BeginCellLayout(BeginCellLayoutEventHandler value);
    [CompilerGeneratedAttribute]
public void remove_BeginCellLayout(BeginCellLayoutEventHandler value);
    [CompilerGeneratedAttribute]
public void add_EndCellLayout(EndCellLayoutEventHandler value);
    [CompilerGeneratedAttribute]
public void remove_EndCellLayout(EndCellLayoutEventHandler value);
    [CompilerGeneratedAttribute]
public void add_QueryNextRow(QueryNextRowEventHandler value);
    [CompilerGeneratedAttribute]
public void remove_QueryNextRow(QueryNextRowEventHandler value);
    [CompilerGeneratedAttribute]
public void add_QueryColumnCount(QueryColumnCountEventHandler value);
    [CompilerGeneratedAttribute]
public void remove_QueryColumnCount(QueryColumnCountEventHandler value);
    [CompilerGeneratedAttribute]
public void add_QueryRowCount(QueryRowCountEventHandler value);
    [CompilerGeneratedAttribute]
public void remove_QueryRowCount(QueryRowCountEventHandler value);
    public void Draw(PdfGraphics graphics, PointF location, float width);
    public void Draw(PdfGraphics graphics, float x, float y, float width);
    public void Draw(PdfGraphics graphics, RectangleF bounds);
    public PdfLightTableLayoutResult Draw(PdfPage page, PointF location);
    public PdfLightTableLayoutResult Draw(PdfPage page, PointF location, PdfLightTableLayoutFormat format);
    public PdfLightTableLayoutResult Draw(PdfPage page, RectangleF bounds);
    public PdfLightTableLayoutResult Draw(PdfPage page, RectangleF bounds, PdfLightTableLayoutFormat format);
    public PdfLightTableLayoutResult Draw(PdfPage page, float x, float y);
    public PdfLightTableLayoutResult Draw(PdfPage page, float x, float y, PdfLightTableLayoutFormat format);
    public PdfLightTableLayoutResult Draw(PdfPage page, float x, float y, float width);
    public PdfLightTableLayoutResult Draw(PdfPage page, float x, float y, float width, PdfLightTableLayoutFormat format);
    public void ApplyBuiltinStyle(PdfLightTableBuiltinStyle tableStyle);
    public void ApplyBuiltinStyle(PdfLightTableBuiltinStyle lightTableStyle, PdfLightTableBuiltinStyleSettings lightTableSetting);
    public virtual void Draw(PdfGraphics graphics, float x, float y);
    protected virtual PdfLayoutResult Layout(PdfLayoutParams param);
    protected virtual void DrawInternal(PdfGraphics graphics);
    internal void OnBeginRowLayout(BeginRowLayoutEventArgs args);
    internal void OnEndRowLayout(EndRowLayoutEventArgs args);
    internal void OnBeginCellLayout(BeginCellLayoutEventArgs args);
    internal void OnEndCellLayout(EndCellLayoutEventArgs args);
    internal String[] GetNextRow(Int32& index);
    internal String[] GetColumnCaptions();
    private PdfDataSource CreateDataSourceConsumer(object value);
    private object FillData();
    private PdfColumnCollection CreateColumns();
    private PdfRowCollection CreateRows();
    private PdfColumnCollection CreateColumnCollection(PdfColumnCollection columns);
    private object FillDataValue();
    private PdfRowCollection CreateRowCollection(PdfRowCollection rows);
    private String[] GetColumnsCaption();
    private String[] OnGetNextRow(int rowIndex);
    private int OnGetColumnNumber();
    private int OnGetRowNumber();
}
public class Syncfusion.Pdf.Tables.PdfLightTableBuiltinStyleSettings : object {
    private bool m_bandedColumns;
    private bool m_bandedRows;
    private bool m_firstColumn;
    private bool m_lastColumn;
    private bool m_headerRow;
    private bool m_lastRow;
    public bool ApplyStyleForBandedColumns { get; public set; }
    public bool ApplyStyleForBandedRows { get; public set; }
    public bool ApplyStyleForFirstColumn { get; public set; }
    public bool ApplyStyleForHeaderRow { get; public set; }
    public bool ApplyStyleForLastColumn { get; public set; }
    public bool ApplyStyleForLastRow { get; public set; }
    public bool get_ApplyStyleForBandedColumns();
    public void set_ApplyStyleForBandedColumns(bool value);
    public bool get_ApplyStyleForBandedRows();
    public void set_ApplyStyleForBandedRows(bool value);
    public bool get_ApplyStyleForFirstColumn();
    public void set_ApplyStyleForFirstColumn(bool value);
    public bool get_ApplyStyleForHeaderRow();
    public void set_ApplyStyleForHeaderRow(bool value);
    public bool get_ApplyStyleForLastColumn();
    public void set_ApplyStyleForLastColumn(bool value);
    public bool get_ApplyStyleForLastRow();
    public void set_ApplyStyleForLastRow(bool value);
}
public enum Syncfusion.Pdf.Tables.PdfLightTableDataSourceType : Enum {
    public int value__;
    public static PdfLightTableDataSourceType External;
    public static PdfLightTableDataSourceType TableDirect;
}
public class Syncfusion.Pdf.Tables.PdfLightTableException : PdfException {
    [NullableContextAttribute("1")]
internal PdfLightTableException(string message);
}
public class Syncfusion.Pdf.Tables.PdfLightTableLayoutFormat : PdfLayoutFormat {
    private int m_startColumn;
    private int m_endColumn;
    public int StartColumnIndex { get; public set; }
    public int EndColumnIndex { get; public set; }
    [NullableContextAttribute("1")]
public PdfLightTableLayoutFormat(PdfLayoutFormat baseFormat);
    public int get_StartColumnIndex();
    public void set_StartColumnIndex(int value);
    public int get_EndColumnIndex();
    public void set_EndColumnIndex(int value);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class Syncfusion.Pdf.Tables.PdfLightTableLayoutResult : PdfLayoutResult {
    private PdfStringLayoutResult[] m_cellResults;
    private int m_rowIndex;
    internal PdfStringLayoutResult[] CellResults { get; }
    public int LastRowIndex { get; }
    internal PdfLightTableLayoutResult(PdfPage page, RectangleF bounds, int rowIndex, PdfStringLayoutResult[] cellResults);
    internal PdfStringLayoutResult[] get_CellResults();
    public int get_LastRowIndex();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class Syncfusion.Pdf.Tables.PdfLightTableStyle : object {
    private PdfCellStyle m_defaultStyle;
    private PdfCellStyle m_alternateStyle;
    private PdfHeaderSource m_headerSource;
    private int m_headerRowCount;
    private PdfCellStyle m_headerStyle;
    private bool m_bRepeateHeader;
    private bool m_bShowHeader;
    private float m_cellSpacing;
    private float m_cellPadding;
    private PdfBorderOverlapStyle m_overlappedBorders;
    private PdfPen m_borderPen;
    public PdfCellStyle DefaultStyle { get; public set; }
    public PdfCellStyle AlternateStyle { get; public set; }
    public PdfHeaderSource HeaderSource { get; public set; }
    public int HeaderRowCount { get; public set; }
    public PdfCellStyle HeaderStyle { get; public set; }
    public bool RepeatHeader { get; public set; }
    public bool ShowHeader { get; public set; }
    public float CellSpacing { get; public set; }
    public float CellPadding { get; public set; }
    public PdfBorderOverlapStyle BorderOverlapStyle { get; public set; }
    public PdfPen BorderPen { get; public set; }
    public PdfCellStyle get_DefaultStyle();
    public void set_DefaultStyle(PdfCellStyle value);
    public PdfCellStyle get_AlternateStyle();
    public void set_AlternateStyle(PdfCellStyle value);
    public PdfHeaderSource get_HeaderSource();
    public void set_HeaderSource(PdfHeaderSource value);
    public int get_HeaderRowCount();
    public void set_HeaderRowCount(int value);
    public PdfCellStyle get_HeaderStyle();
    public void set_HeaderStyle(PdfCellStyle value);
    public bool get_RepeatHeader();
    public void set_RepeatHeader(bool value);
    public bool get_ShowHeader();
    public void set_ShowHeader(bool value);
    public float get_CellSpacing();
    public void set_CellSpacing(float value);
    public float get_CellPadding();
    public void set_CellPadding(float value);
    public PdfBorderOverlapStyle get_BorderOverlapStyle();
    public void set_BorderOverlapStyle(PdfBorderOverlapStyle value);
    public PdfPen get_BorderPen();
    public void set_BorderPen(PdfPen value);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class Syncfusion.Pdf.Tables.PdfRow : object {
    private Object[] m_values;
    public Object[] Values { get; public set; }
    internal PdfRow(Object[] values);
    public Object[] get_Values();
    public void set_Values(Object[] value);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[DefaultMemberAttribute("Item")]
public class Syncfusion.Pdf.Tables.PdfRowCollection : PdfCollection {
    public PdfRow Item { get; }
    public PdfRow get_Item(int index);
    public void Add(PdfRow row);
    public void Add(Object[] values);
}
public class Syncfusion.Pdf.Tables.QueryColumnCountEventArgs : EventArgs {
    private int m_columnCount;
    public int ColumnCount { get; public set; }
    public int get_ColumnCount();
    public void set_ColumnCount(int value);
}
public class Syncfusion.Pdf.Tables.QueryColumnCountEventHandler : MulticastDelegate {
    public QueryColumnCountEventHandler(object object, IntPtr method);
    [NullableContextAttribute("1")]
public virtual void Invoke(object sender, QueryColumnCountEventArgs args);
    public virtual IAsyncResult BeginInvoke(object sender, QueryColumnCountEventArgs args, AsyncCallback callback, object object);
    public virtual void EndInvoke(IAsyncResult result);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class Syncfusion.Pdf.Tables.QueryNextRowEventArgs : EventArgs {
    private String[] m_rowData;
    private int m_columnCount;
    private int m_rowIndex;
    public String[] RowData { get; public set; }
    public int ColumnCount { get; }
    public int RowIndex { get; }
    internal QueryNextRowEventArgs(int columnCount, int rowIndex);
    public String[] get_RowData();
    public void set_RowData(String[] value);
    public int get_ColumnCount();
    public int get_RowIndex();
}
public class Syncfusion.Pdf.Tables.QueryNextRowEventHandler : MulticastDelegate {
    public QueryNextRowEventHandler(object object, IntPtr method);
    [NullableContextAttribute("1")]
public virtual void Invoke(object sender, QueryNextRowEventArgs args);
    public virtual IAsyncResult BeginInvoke(object sender, QueryNextRowEventArgs args, AsyncCallback callback, object object);
    public virtual void EndInvoke(IAsyncResult result);
}
public class Syncfusion.Pdf.Tables.QueryRowCountEventArgs : EventArgs {
    private int m_rowCount;
    public int RowCount { get; public set; }
    public int get_RowCount();
    public void set_RowCount(int value);
}
public class Syncfusion.Pdf.Tables.QueryRowCountEventHandler : MulticastDelegate {
    public QueryRowCountEventHandler(object object, IntPtr method);
    [NullableContextAttribute("1")]
public virtual void Invoke(object sender, QueryRowCountEventArgs args);
    public virtual IAsyncResult BeginInvoke(object sender, QueryRowCountEventArgs args, AsyncCallback callback, object object);
    public virtual void EndInvoke(IAsyncResult result);
}
internal enum Syncfusion.Pdf.TemplateType : Enum {
    public int value__;
    public static TemplateType None;
    public static TemplateType Top;
    public static TemplateType Bottom;
    public static TemplateType Left;
    public static TemplateType Right;
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class Syncfusion.Pdf.TextGlyph : object {
    private RectangleF m_glyphBounds;
    private char m_text;
    private float m_fontSize;
    private string m_fontName;
    private FontStyle m_fontStyle;
    private int m_rotateAngle;
    private Color m_textcolor;
    public char Text { get; public set; }
    internal int RotateAngle { get; internal set; }
    public RectangleF Bounds { get; internal set; }
    public Color TextColor { get; internal set; }
    public float FontSize { get; internal set; }
    public string FontName { get; internal set; }
    public FontStyle FontStyle { get; internal set; }
    public char get_Text();
    public void set_Text(char value);
    internal int get_RotateAngle();
    internal void set_RotateAngle(int value);
    public RectangleF get_Bounds();
    internal void set_Bounds(RectangleF value);
    public Color get_TextColor();
    internal void set_TextColor(Color value);
    public float get_FontSize();
    internal void set_FontSize(float value);
    public string get_FontName();
    internal void set_FontName(string value);
    public FontStyle get_FontStyle();
    internal void set_FontStyle(FontStyle value);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class Syncfusion.Pdf.TextLine : object {
    private List`1<TextWord> m_wordCollection;
    private RectangleF m_lineBounds;
    private float m_fontSize;
    private string m_fontName;
    private FontStyle m_fontStyle;
    private string m_text;
    private Color m_textcolor;
    public string Text { get; internal set; }
    public float FontSize { get; public set; }
    public string FontName { get; public set; }
    public FontStyle FontStyle { get; public set; }
    internal Color TextColor { get; internal set; }
    public List`1<TextWord> WordCollection { get; internal set; }
    public RectangleF Bounds { get; internal set; }
    public string get_Text();
    internal void set_Text(string value);
    public float get_FontSize();
    public void set_FontSize(float value);
    public string get_FontName();
    public void set_FontName(string value);
    public FontStyle get_FontStyle();
    public void set_FontStyle(FontStyle value);
    internal Color get_TextColor();
    internal void set_TextColor(Color value);
    public List`1<TextWord> get_WordCollection();
    internal void set_WordCollection(List`1<TextWord> value);
    public RectangleF get_Bounds();
    internal void set_Bounds(RectangleF value);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class Syncfusion.Pdf.TextLineCollection : object {
    private List`1<TextLine> m_textLine;
    public List`1<TextLine> TextLine { get; internal set; }
    public List`1<TextLine> get_TextLine();
    internal void set_TextLine(List`1<TextLine> value);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class Syncfusion.Pdf.TextWord : object {
    private string m_text;
    private RectangleF m_wordBounds;
    private float m_fontSize;
    private string m_fontName;
    private FontStyle m_fontStyle;
    private List`1<TextGlyph> m_glyphs;
    private Color m_textcolor;
    public string Text { get; internal set; }
    public RectangleF Bounds { get; internal set; }
    internal Color TextColor { get; internal set; }
    internal float FontSize { get; internal set; }
    internal string FontName { get; internal set; }
    internal FontStyle FontStyle { get; internal set; }
    public List`1<TextGlyph> Glyphs { get; }
    public string get_Text();
    internal void set_Text(string value);
    public RectangleF get_Bounds();
    internal void set_Bounds(RectangleF value);
    internal Color get_TextColor();
    internal void set_TextColor(Color value);
    internal float get_FontSize();
    internal void set_FontSize(float value);
    internal string get_FontName();
    internal void set_FontName(string value);
    internal FontStyle get_FontStyle();
    internal void set_FontStyle(FontStyle value);
    public List`1<TextGlyph> get_Glyphs();
}
internal enum Syncfusion.Pdf.TokenType : Enum {
    public int value__;
    public static TokenType None;
    public static TokenType Comment;
    public static TokenType Integer;
    public static TokenType Real;
    public static TokenType String;
    public static TokenType HexString;
    public static TokenType UnicodeString;
    public static TokenType UnicodeHexString;
    public static TokenType Name;
    public static TokenType Operator;
    public static TokenType BeginArray;
    public static TokenType EndArray;
    public static TokenType Eof;
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Syncfusion.Pdf.TrueTypeCmap : TableBase {
    private int m_id;
    public FontEncoding[] encodings;
    private Dictionary`2<FontEncoding, CmapTables> encodingtable;
    private ushort noofSubtable;
    private UInt32 subOffset;
    internal int Id { get; }
    public TrueTypeCmap(FontFile2 fontsource);
    internal virtual int get_Id();
    public virtual void Read(ReadFontArray reader);
    public CmapTables GetCmaptable(ushort platformid, ushort encodingid);
    public CmapTables GetCmapTable(FontEncoding encode, ReadFontArray reader);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Syncfusion.Pdf.TrueTypeGlyphs : TableBase {
    private ushort glyphIndex;
    private List`1<OutlinePoint[]> m_contours;
    private int m_id;
    private short m_numberOfContours;
    internal List`1<OutlinePoint[]> Contours { get; internal set; }
    internal int Id { get; }
    internal short NumberOfContours { get; internal set; }
    public ushort GlyphIndex { get; }
    public TrueTypeGlyphs(FontFile2 fontFile, ushort glyphIndex);
    public TrueTypeGlyphs(FontFile2 fontFile);
    internal List`1<OutlinePoint[]> get_Contours();
    internal void set_Contours(List`1<OutlinePoint[]> value);
    internal virtual int get_Id();
    internal short get_NumberOfContours();
    internal void set_NumberOfContours(short value);
    public ushort get_GlyphIndex();
    public static TrueTypeGlyphs ReadGlyf(FontFile2 fontFile, ushort glyphIndex);
    public virtual void Read(ReadFontArray reader);
}
internal abstract class Syncfusion.Pdf.TrueTypeTableBase : TableBase {
    internal UInt32 Tag { get; }
    [NullableContextAttribute("1")]
public TrueTypeTableBase(FontFile2 fontSource);
    internal abstract virtual UInt32 get_Tag();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Syncfusion.Pdf.UrlFileSpecification : PdfFileSpecificationBase {
    private string m_fileName;
    public string FileName { get; public set; }
    public UrlFileSpecification(string fileName);
    public virtual string get_FileName();
    public virtual void set_FileName(string value);
    protected virtual void Initialize();
    protected virtual void Save();
}
internal class Syncfusion.Pdf.Utils : object {
    private static int c_roundDecimals;
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Syncfusion.Pdf.WCAGCloner : object {
    private List`1<IPdfPrimitive> m_taggedObjects;
    private int structureElementCount;
    private PdfDictionary m_catalog;
    private PdfCrossTable m_crossTable;
    private Dictionary`2<IPdfPrimitive, object> pageCollection;
    private PdfDictionary m_currentPageDict;
    private PdfPageBase m_currentPage;
    private PdfDocumentBase m_document;
    private Dictionary`2<IPdfPrimitive, object> newPageCollection;
    private Dictionary`2<IPdfPrimitive, object> pageDictionaryCollection;
    private Dictionary`2<IPdfPrimitive, object> newPageDictionaryCollection;
    private PdfDictionary m_tableDictionary;
    private PdfDictionary Catalog { get; }
    private PdfDocumentBase Document { get; }
    private Dictionary`2<IPdfPrimitive, object> PageCorrespondance { get; }
    private List`1<IPdfPrimitive> TaggedPDFObjects { get; }
    private PdfCrossTable CrossTable { get; }
    private PdfPageBase CurrentPage { get; }
    private PdfDictionary CurrentPageDictionary { get; }
    internal WCAGCloner(PdfCatalog catalog, PdfDocumentBase doc);
    private PdfDictionary get_Catalog();
    private PdfDocumentBase get_Document();
    private Dictionary`2<IPdfPrimitive, object> get_PageCorrespondance();
    private List`1<IPdfPrimitive> get_TaggedPDFObjects();
    private PdfCrossTable get_CrossTable();
    private PdfPageBase get_CurrentPage();
    private PdfDictionary get_CurrentPageDictionary();
    internal void ImportingStructureElements(int startIndex, int endIndex, PdfLoadedDocument ldDoc, Dictionary`2<IPdfPrimitive, object> pageCorrespondance, Dictionary`2<int, PdfPageBase> loadedPageCollection);
    private void UpdateParentKey(PdfDictionary dictionary, PdfDictionary root);
    private PdfArray CopyArray(PdfArray original);
    private PdfDictionary BuildParentTree(PdfArray numsRoot);
    private PdfDictionary CopyPDFDictionary(PdfDictionary original);
    private void ImportWCAG(PdfStructureElement elementRoot);
    private bool IsChildPageIsNull(PdfStructureElement structureElement);
    private PdfStructureElement IsChildInnerPageIsNull(PdfStructureElement structureElement);
    private void UpdateChildStructureElemtents(PdfStructureElement structureElement, List`1<IPdfPrimitive> McrContentCollection, List`1<IPdfPrimitive> McrObjectCollection, PdfDictionary parent);
    private void RemoveElement(PdfDictionary parent, PdfDictionary elementDictionary);
    private PdfDictionary GetChildFromParent(int i, PdfDictionary parent);
    private void AddElements(PdfDictionary elementDictionary, List`1<IPdfPrimitive> McrContentCollection, List`1<IPdfPrimitive> McrObjectCollection);
    private void AddMarkedContentTypeElements(PdfDictionary elementDictionary, List`1<IPdfPrimitive> McrContentCollection);
    private void AddObjectTypeElements(PdfDictionary kDictionaryType, List`1<IPdfPrimitive> McrObjectCollection, PdfDictionary elementDictionary);
    private void StructureDictionaryCopier(PdfDictionary copyDictionary, PdfDictionary dictionary, IPdfPrimitive parent);
    private bool IsAllChildIsNull(PdfArray child);
    private void StructureObjectFinder(PdfDictionary dictionary, string key, IPdfPrimitive primitive);
    private void StructureArrayCloner(PdfArray dictionary, PdfArray array, PdfDictionary parent);
    private void AddStructureArrayElement(PdfArray array, IPdfPrimitive element, PdfDictionary parent);
    private bool IsChildIsNull(PdfArray child);
    public sealed virtual void Dispose();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Syncfusion.Pdf.Xfa.BreakAfter : object {
    private string m_afterTargetID;
    private bool m_isStartNew;
    private PdfXfaTargetType m_targetType;
    internal bool IsStartNew { get; internal set; }
    internal string AfterTargetID { get; internal set; }
    internal PdfXfaTargetType TargetType { get; internal set; }
    internal bool get_IsStartNew();
    internal void set_IsStartNew(bool value);
    internal string get_AfterTargetID();
    internal void set_AfterTargetID(string value);
    internal PdfXfaTargetType get_TargetType();
    internal void set_TargetType(PdfXfaTargetType value);
    internal void Read(XmlNode node);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Syncfusion.Pdf.Xfa.BreakBefore : object {
    private string m_beforeTargetID;
    private PdfXfaTargetType m_targetType;
    private bool m_isStartNew;
    internal PdfXfaTargetType TargetType { get; internal set; }
    internal string BeforeTargetID { get; internal set; }
    internal bool IsStartNew { get; internal set; }
    internal PdfXfaTargetType get_TargetType();
    internal void set_TargetType(PdfXfaTargetType value);
    internal string get_BeforeTargetID();
    internal void set_BeforeTargetID(string value);
    internal bool get_IsStartNew();
    internal void set_IsStartNew(bool value);
    internal void Read(XmlNode node);
}
internal class Syncfusion.Pdf.Xfa.namespaceDoc : object {
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Syncfusion.Pdf.Xfa.OverFlow : object {
    private string m_overFlowID;
    internal string OverFlowID { get; internal set; }
    internal string get_OverFlowID();
    internal void set_OverFlowID(string value);
    internal void Read(XmlNode node);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class Syncfusion.Pdf.Xfa.PdfLoadedXfaArea : PdfLoadedXfaField {
    public PdfLoadedXfaFieldCollection Fields { get; internal set; }
    public PdfLoadedXfaFieldCollection get_Fields();
    internal void set_Fields(PdfLoadedXfaFieldCollection value);
    internal void Save(PdfLoadedXfaArea area, XmlWriter dataSetWriter, XmlDocument dataSetDoc, PdfLoadedXfaForm form);
    internal void ReadArea(XmlNode subNode, PdfLoadedXfaArea area, PdfLoadedXfaForm form, List`1<string> fieldsNames, List`1<string> subFormNames, XmlDocument dataSetDoc);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Syncfusion.Pdf.Xfa.PdfLoadedXfaButtonField : PdfLoadedXfaStyledField {
    private PdfHighlightMode m_highlight;
    private string m_rolloverText;
    private string m_downText;
    private string m_content;
    public PdfHighlightMode Highlight { get; public set; }
    public string MouseRolloverText { get; public set; }
    public string MouseDownText { get; public set; }
    public string Content { get; public set; }
    public PdfHighlightMode get_Highlight();
    public void set_Highlight(PdfHighlightMode value);
    public string get_MouseRolloverText();
    public void set_MouseRolloverText(string value);
    public string get_MouseDownText();
    public void set_MouseDownText(string value);
    public string get_Content();
    public void set_Content(string value);
    internal void Read(XmlNode node);
    internal void DrawField(PdfGraphics graphics, RectangleF bounds);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class Syncfusion.Pdf.Xfa.PdfLoadedXfaCheckBoxField : PdfLoadedXfaStyledField {
    private bool m_isChecked;
    private float m_checkBoxSize;
    private PdfXfaCheckedStyle m_checkedStyle;
    private PdfXfaCheckBoxAppearance m_checkBoxAppearance;
    internal string m_innerText;
    internal bool isItemText;
    public bool IsChecked { get; public set; }
    public float CheckBoxSize { get; public set; }
    public PdfXfaCheckedStyle CheckedStyle { get; public set; }
    public PdfXfaCheckBoxAppearance CheckBoxAppearance { get; public set; }
    public bool get_IsChecked();
    public void set_IsChecked(bool value);
    public float get_CheckBoxSize();
    public void set_CheckBoxSize(float value);
    public void set_CheckedStyle(PdfXfaCheckedStyle value);
    public PdfXfaCheckedStyle get_CheckedStyle();
    public void set_CheckBoxAppearance(PdfXfaCheckBoxAppearance value);
    public PdfXfaCheckBoxAppearance get_CheckBoxAppearance();
    internal void Read(XmlNode node, XmlDocument dataSetDoc);
    internal void Save();
    internal void DrawField(PdfGraphics graphics, RectangleF bounds);
    internal void Fill(XmlWriter dataSetWriter, PdfLoadedXfaForm form);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Syncfusion.Pdf.Xfa.PdfLoadedXfaCircleField : PdfLoadedXfaStyledField {
    private int m_sweepAngle;
    private int m_startAngle;
    private PdfXfaCircleAppearance m_Appearance;
    private string m_toolTip;
    private PdfXfaRotateAngle m_rotate;
    private float m_width;
    private float m_height;
    private PdfXfaBorder m_border;
    internal PdfXfaBorder Border { get; internal set; }
    internal string ToolTip { get; internal set; }
    internal int StartAngle { get; internal set; }
    internal int SweepAngle { get; internal set; }
    internal PdfXfaCircleAppearance Appearance { get; internal set; }
    internal PdfXfaRotateAngle Rotate { get; internal set; }
    internal float Width { get; internal set; }
    internal float Height { get; internal set; }
    internal PdfXfaBorder get_Border();
    internal void set_Border(PdfXfaBorder value);
    internal string get_ToolTip();
    internal void set_ToolTip(string value);
    internal int get_StartAngle();
    internal void set_StartAngle(int value);
    internal int get_SweepAngle();
    internal void set_SweepAngle(int value);
    internal PdfXfaCircleAppearance get_Appearance();
    internal void set_Appearance(PdfXfaCircleAppearance value);
    internal PdfXfaRotateAngle get_Rotate();
    internal void set_Rotate(PdfXfaRotateAngle value);
    internal void set_Width(float value);
    internal float get_Width();
    internal void set_Height(float value);
    internal float get_Height();
    internal void ReadField(XmlNode node);
    internal void DrawCircle(PdfGraphics graphics, RectangleF bounds);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class Syncfusion.Pdf.Xfa.PdfLoadedXfaComboBoxField : PdfLoadedXfaStyledField {
    private List`1<string> m_items;
    private int m_selectedIndex;
    private string m_selectedValue;
    private List`1<string> m_hiddenItems;
    private PdfMargins m_innerMargin;
    public List`1<string> Items { get; public set; }
    public int SelectedIndex { get; public set; }
    public string SelectedValue { get; public set; }
    public List`1<string> HiddenItems { get; }
    public List`1<string> get_Items();
    public void set_Items(List`1<string> value);
    public int get_SelectedIndex();
    public void set_SelectedIndex(int value);
    public string get_SelectedValue();
    public void set_SelectedValue(string value);
    public List`1<string> get_HiddenItems();
    internal void ReadField(XmlNode node, XmlDocument dataSetDoc);
    internal void Save();
    internal void DrawField(PdfGraphics graphics, RectangleF bounds);
    private RectangleF GetBounds(RectangleF bounds1);
    internal void Fill(XmlWriter dataSetWriter, PdfLoadedXfaForm form);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class Syncfusion.Pdf.Xfa.PdfLoadedXfaDateTimeField : PdfLoadedXfaStyledField {
    internal Nullable`1<DateTime> m_value;
    internal string fieldName;
    private PdfXfaDateTimeFormat m_format;
    internal string patternString;
    internal bool m_isSet;
    private string m_pattern;
    internal string m_bindedvalue;
    private PdfMargins m_innerMargin;
    private bool isSkipDefaultMargin;
    public DateTime Value { get; public set; }
    public PdfXfaDateTimeFormat Format { get; public set; }
    public string Pattern { get; public set; }
    public DateTime get_Value();
    public void set_Value(DateTime value);
    internal void SetDate(Nullable`1<DateTime> value);
    public PdfXfaDateTimeFormat get_Format();
    public void set_Format(PdfXfaDateTimeFormat value);
    public string get_Pattern();
    public void set_Pattern(string value);
    private void GetFieldPattern();
    public void ClearValue();
    internal void Read(XmlNode node, XmlDocument dataSetDoc);
    private Nullable`1<DateTime> ParseDate(string text);
    internal void Save();
    private void setFormat(string formatText);
    private string GetDate();
    internal void DrawField(PdfGraphics graphics, RectangleF bounds);
    private RectangleF GetBounds(RectangleF bounds1);
    internal SizeF GetFieldSize();
    internal void Fill(XmlWriter dataSetWriter, PdfLoadedXfaForm form);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class Syncfusion.Pdf.Xfa.PdfLoadedXfaDocument : object {
    private PdfLoadedXfaForm m_form;
    private PdfFileStructure _mFileStructure;
    private PdfLoadedDocument m_document;
    private bool m_flatten;
    private XmlDocument m_xmlData;
    public PdfLoadedXfaForm XfaForm { get; internal set; }
    public XmlDocument XmlData { get; }
    public PdfLoadedXfaDocument(Stream file);
    public PdfLoadedXfaDocument(Stream file, string password);
    public PdfLoadedXfaForm get_XfaForm();
    internal void set_XfaForm(PdfLoadedXfaForm value);
    public XmlDocument get_XmlData();
    public void Save(Stream stream);
    public void Close();
    private void LoadXDP(Dictionary`2<string, PdfStream> xfaArray);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public abstract class Syncfusion.Pdf.Xfa.PdfLoadedXfaField : PdfXfaField {
    internal XmlNode currentNode;
    internal XmlNode dataSetNode;
    internal string nodeName;
    internal PdfLoadedXfaField parent;
    internal string bindingName;
    internal bool isRendered;
    internal List`1<string> m_fieldNames;
    internal List`1<string> m_subFormNames;
    internal List`1<string> internalFieldNames;
    internal List`1<string> internalSubFormNames;
    internal bool isUnNamedSubForm;
    internal List`1<string> m_areaNames;
    internal PdfLoadedXfaFieldCollection m_fields;
    internal PdfLoadedForm acroForm;
    internal string m_name;
    internal bool isBindingMatchNone;
    internal string GetFieldName(List`1<string> fieldNameList, string name);
    internal int GetSameNameFieldsCount(string name);
    internal void SetName(PdfLoadedXfaField field, List`1<string> subFormNamesCollection, bool isArea);
    internal float ConvertToPoint(string value);
    internal void ReadMargin(XmlNode node);
    internal void ReadMargin(XmlNode node, PdfMargins margins);
    internal string ReadBinding(XmlNode node, PdfLoadedXfaForm ff);
    internal void SetSize(XmlNode node, string attribute, float value);
    internal void ReadField(XmlNode node, PdfLoadedXfaForm form, List`1<string> fieldNames, List`1<string> subFormNames, XmlDocument dataSetDoc);
    internal void ReadStaticField(XmlNode node, PdfLoadedXfaForm form, XmlDocument dataSetDoc);
    internal string ReadField(XmlNode node, PdfLoadedXfaArea form, List`1<string> fieldNames, List`1<string> subFormNames, XmlDocument dataSetDoc);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[DefaultMemberAttribute("Item")]
public class Syncfusion.Pdf.Xfa.PdfLoadedXfaFieldCollection : object {
    private Dictionary`2<string, PdfXfaField> m_fieldCollection;
    internal PdfLoadedXfaField parent;
    private Dictionary`2<string, PdfXfaField> m_completeFields;
    internal Dictionary`2<string, PdfXfaField> CompleteFields { get; internal set; }
    public PdfLoadedXfaField Item { get; internal set; }
    internal PdfXfaField Item { get; }
    internal Dictionary`2<string, PdfXfaField> FieldCollection { get; }
    public int Count { get; }
    internal Dictionary`2<string, PdfXfaField> get_CompleteFields();
    internal void set_CompleteFields(Dictionary`2<string, PdfXfaField> value);
    internal void set_Item(string fieldName, PdfLoadedXfaField value);
    public PdfLoadedXfaField get_Item(string fieldName);
    internal PdfXfaField get_Item(int index);
    internal Dictionary`2<string, PdfXfaField> get_FieldCollection();
    public int get_Count();
    internal string Add(PdfLoadedXfaField xfaField);
    internal void Add(PdfLoadedXfaField field, string fieldName);
    private string GetName(string name);
    internal void AddStaticFields(PdfLoadedXfaField xfaField, string fieldName);
    internal void AddStaticFields(PdfLoadedXfaField xfaField);
    public void Add(PdfXfaField xfaField);
    public void Remove(PdfLoadedXfaField lField);
    public void RemoveAt(int index);
    public void Clear();
    public sealed virtual IEnumerator GetEnumerator();
}
[FlagsAttribute]
internal enum Syncfusion.Pdf.Xfa.PdfLoadedXfaFlowDirection : Enum {
    public int value__;
    public static PdfLoadedXfaFlowDirection None;
    public static PdfLoadedXfaFlowDirection LeftToRight;
    public static PdfLoadedXfaFlowDirection TopToBottom;
    public static PdfLoadedXfaFlowDirection RightToLeft;
    public static PdfLoadedXfaFlowDirection Row;
    public static PdfLoadedXfaFlowDirection Table;
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class Syncfusion.Pdf.Xfa.PdfLoadedXfaForm : PdfLoadedXfaField {
    private PdfDictionary m_catalog;
    private Dictionary`2<string, PdfStream> m_xfaArray;
    private PdfArray m_imageArray;
    private PdfLoadedDocument m_loadedDocument;
    private List`1<PdfLoadedXfaField> tryGetfields;
    private int m_fieldCount;
    internal XmlWriter dataSetWriter;
    internal XmlDocument xmlDoc;
    internal XmlDocument dataSetDoc;
    private int count;
    private int nodeCount;
    private List`1<string> m_completefieldNames;
    private float m_width;
    private float m_height;
    private PointF m_location;
    private PdfXfaVisibility m_visibility;
    private bool m_readOnly;
    internal SizeF m_size;
    private PdfLoadedXfaFlowDirection m_flowDirection;
    internal PdfDocument fDocument;
    internal bool is_modified;
    internal PointF currentPoint;
    internal float maxHeight;
    internal float maxWidth;
    internal float extraSize;
    internal List`1<float> columnWidths;
    internal bool isLocationPresent;
    internal PointF startPoint;
    internal float trackingHeight;
    private PdfXfaBorder m_border;
    private bool isXfaImport;
    internal SizeF bgSize;
    internal List`1<float> backgroundHeight;
    internal int bgHeightCounter;
    private string m_originalXFA;
    internal PdfLoadedXfaPageBreak PageBreak;
    internal PointF cStartPoint;
    internal PdfLoadedXfaFlowDirection FlowDirection { get; internal set; }
    internal PdfXfaBorder Border { get; internal set; }
    public bool ReadOnly { get; public set; }
    public PdfXfaVisibility Visibility { get; public set; }
    public float Width { get; public set; }
    public float Height { get; public set; }
    public PointF Location { get; public set; }
    public PdfLoadedXfaFieldCollection Fields { get; public set; }
    internal PdfDictionary Catalog { get; internal set; }
    internal Dictionary`2<string, PdfStream> XFAArray { get; internal set; }
    public String[] FieldNames { get; }
    public String[] SubFormNames { get; }
    public String[] CompleteFieldNames { get; }
    public String[] AreaNames { get; }
    internal PdfLoadedXfaFlowDirection get_FlowDirection();
    internal void set_FlowDirection(PdfLoadedXfaFlowDirection value);
    internal PdfXfaBorder get_Border();
    internal void set_Border(PdfXfaBorder value);
    public bool get_ReadOnly();
    public void set_ReadOnly(bool value);
    public PdfXfaVisibility get_Visibility();
    public void set_Visibility(PdfXfaVisibility value);
    public float get_Width();
    public void set_Width(float value);
    public float get_Height();
    public void set_Height(float value);
    public PointF get_Location();
    public void set_Location(PointF value);
    public PdfLoadedXfaFieldCollection get_Fields();
    public void set_Fields(PdfLoadedXfaFieldCollection value);
    internal PdfDictionary get_Catalog();
    internal void set_Catalog(PdfDictionary value);
    internal Dictionary`2<string, PdfStream> get_XFAArray();
    internal void set_XFAArray(Dictionary`2<string, PdfStream> value);
    public String[] get_FieldNames();
    public String[] get_SubFormNames();
    public String[] get_CompleteFieldNames();
    public String[] get_AreaNames();
    internal void Load(PdfCatalog catalog);
    internal void Save(PdfLoadedDocument document);
    internal void SaveForm();
    internal void SaveSubForms(PdfLoadedXfaForm form, XmlWriter dataSetWriter);
    internal List`1<PdfLoadedXfaCheckBoxField> GetSameNameFields(string name, PdfLoadedXfaForm form);
    internal void ReadForm();
    private void ReadColumnWidth(XmlNode node, PdfLoadedXfaForm subform);
    internal void ReadSubFormProperties(XmlNode node, PdfLoadedXfaForm ff, PdfLoadedXfaForm form);
    internal void ReadSubForm(XmlNode subNode, PdfLoadedXfaForm form, List`1<string> fieldsNames, List`1<string> subFormNames);
    public PdfLoadedXfaField[] TryGetFieldsByName(string name);
    public PdfLoadedXfaField TryGetFieldByCompleteName(string name);
    public void ImportXfaData(Stream stream);
    public void ExportXfaData(Stream stream);
    private string GetName(string name);
    private void SaveAttributes(PdfLoadedXfaForm lForm);
    private void GetCompeleteFieldNames(PdfLoadedXfaForm form);
    private void GetCompeleteFieldNames(PdfLoadedXfaArea form);
    private void GetFields(string name, PdfLoadedXfaForm form, bool isTryGetFlag);
    private void SaveNewXfaItems(PdfLoadedXfaForm loadedXfa, PdfXfaField field);
    private PdfLoadedXfaField[] TryGetFieldsByName(string name, bool isTryGetFlag);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Syncfusion.Pdf.Xfa.PdfLoadedXfaImage : PdfLoadedXfaStyledField {
    internal string m_base64ImageData;
    internal XfaImageAspectRadio aspectRadio;
    internal string m_imageReference;
    internal void ReadField(XmlNode node, XmlDocument dataSetDoc);
    internal void DrawImage(PdfGraphics graphics, RectangleF bounds, PdfLoadedDocument ldoc);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Syncfusion.Pdf.Xfa.PdfLoadedXfaLine : PdfLoadedXfaStyledField {
    private PdfXfaEdge edge;
    internal void ReadField(XmlNode node);
    internal void DrawLine(PdfGraphics graphics, RectangleF bounds);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class Syncfusion.Pdf.Xfa.PdfLoadedXfaListBoxField : PdfLoadedXfaStyledField {
    private List`1<string> m_items;
    private int m_selectedIndex;
    private string m_selectedValue;
    private PdfXfaSelectionMode m_selectionMode;
    private String[] m_selectedItems;
    private PdfMargins m_innerMargin;
    public String[] SelectedItems { get; public set; }
    public List`1<string> Items { get; public set; }
    public int SelectedIndex { get; public set; }
    public string SelectedValue { get; public set; }
    public PdfXfaSelectionMode SelectionMode { get; }
    public String[] get_SelectedItems();
    public void set_SelectedItems(String[] value);
    public List`1<string> get_Items();
    public void set_Items(List`1<string> value);
    public int get_SelectedIndex();
    public void set_SelectedIndex(int value);
    public string get_SelectedValue();
    public void set_SelectedValue(string value);
    public PdfXfaSelectionMode get_SelectionMode();
    internal void ReadField(XmlNode node, XmlDocument dataSetDoc);
    internal void Save();
    internal void DrawListBoxField(PdfGraphics graphics, RectangleF bounds);
    private RectangleF GetBounds(RectangleF bounds1);
    internal void Fill(XmlWriter dataSetWriter, PdfLoadedXfaForm form);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class Syncfusion.Pdf.Xfa.PdfLoadedXfaNumericField : PdfLoadedXfaStyledField {
    private double m_numericValue;
    internal string fullName;
    private PdfXfaNumericType m_fieldType;
    private int m_combLength;
    private string m_patternString;
    private PdfMargins m_innerMargin;
    private bool isSkipDefaultMargin;
    public double NumericValue { get; public set; }
    public int CombLenght { get; public set; }
    public PdfXfaNumericType FieldType { get; internal set; }
    public string PatternString { get; }
    public double get_NumericValue();
    public void set_NumericValue(double value);
    public int get_CombLenght();
    public void set_CombLenght(int value);
    public PdfXfaNumericType get_FieldType();
    internal void set_FieldType(PdfXfaNumericType value);
    public string get_PatternString();
    internal void Read(XmlNode node, XmlDocument dataSetDoc);
    internal void DrawField(PdfGraphics graphics, RectangleF bounds);
    private RectangleF GetBounds(RectangleF bounds1);
    internal SizeF GetNumericFieldSize();
    internal void Save();
    internal void Fill(XmlWriter dataSetWriter, PdfLoadedXfaForm form);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Syncfusion.Pdf.Xfa.PdfLoadedXfaPage : object {
    private PdfPage m_currentPage;
    internal PdfXfaPageSettings pageSettings;
    internal PdfLoadedXfaForm m_loadedXfaForm;
    internal PdfTemplate pageSetTemplate;
    internal string Name;
    internal string Id;
    internal PdfDocument document;
    internal bool isSet;
    private float m_headerTemplateHeight;
    internal PdfPage CurrentPage { get; }
    internal PdfPage get_CurrentPage();
    internal SizeF GetClientSize();
    internal void ReadPage(XmlNode node, PdfLoadedXfaForm lForm);
    internal void AddPdfPage();
    internal void DrawPageBackgroundTemplate(PdfPage currentPage);
    internal float ConvertToPoint(string value);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Syncfusion.Pdf.Xfa.PdfLoadedXfaPageBreak : object {
    private BreakBefore m_beforeBreak;
    private BreakAfter m_afterBreak;
    private OverFlow m_overflow;
    private string m_beforeTargetID;
    private string m_afterTargetID;
    private bool m_isStartNew;
    internal bool IsStartNew { get; internal set; }
    internal string AfterTargetID { get; internal set; }
    internal string BeforeTargetID { get; internal set; }
    internal OverFlow Overflow { get; internal set; }
    internal BreakBefore BeforeBreak { get; internal set; }
    internal BreakAfter AfterBreak { get; internal set; }
    internal bool get_IsStartNew();
    internal void set_IsStartNew(bool value);
    internal string get_AfterTargetID();
    internal void set_AfterTargetID(string value);
    internal string get_BeforeTargetID();
    internal void set_BeforeTargetID(string value);
    internal OverFlow get_Overflow();
    internal void set_Overflow(OverFlow value);
    internal BreakBefore get_BeforeBreak();
    internal void set_BeforeBreak(BreakBefore value);
    internal BreakAfter get_AfterBreak();
    internal void set_AfterBreak(BreakAfter value);
    internal void Read(XmlNode node);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class Syncfusion.Pdf.Xfa.PdfLoadedXfaRadioButtonField : PdfLoadedXfaStyledField {
    internal bool m_isChecked;
    internal string vText;
    internal string iText;
    private PdfXfaCheckedStyle m_checkedStyle;
    private PdfXfaCheckBoxAppearance m_radioButtonAppearance;
    private float m_radioButtonSize;
    public bool IsChecked { get; public set; }
    public float RadioButtonSize { get; public set; }
    public PdfXfaCheckedStyle CheckedStyle { get; public set; }
    public PdfXfaCheckBoxAppearance RadioButtonAppearance { get; public set; }
    public bool get_IsChecked();
    public void set_IsChecked(bool value);
    public float get_RadioButtonSize();
    public void set_RadioButtonSize(float value);
    public void set_CheckedStyle(PdfXfaCheckedStyle value);
    public PdfXfaCheckedStyle get_CheckedStyle();
    public void set_RadioButtonAppearance(PdfXfaCheckBoxAppearance value);
    public PdfXfaCheckBoxAppearance get_RadioButtonAppearance();
    internal void ReadField(XmlNode node);
    internal void DrawRadioButton(PdfGraphics graphics, RectangleF bounds);
    internal void Save();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class Syncfusion.Pdf.Xfa.PdfLoadedXfaRadioButtonGroup : PdfLoadedXfaField {
    private List`1<PdfLoadedXfaRadioButtonField> m_fields;
    internal int m_selectedItemIndex;
    internal string vText;
    private float m_width;
    private float m_height;
    private PointF m_location;
    private PdfXfaVisibility m_visibility;
    private bool m_readOnly;
    internal PdfLoadedXfaFlowDirection m_flowDirection;
    internal SizeF Size;
    public bool ReadOnly { get; public set; }
    public PdfXfaVisibility Visibility { get; public set; }
    public float Width { get; public set; }
    public float Height { get; public set; }
    public PointF Location { get; public set; }
    public PdfLoadedXfaRadioButtonField[] Fields { get; }
    public bool get_ReadOnly();
    public void set_ReadOnly(bool value);
    public PdfXfaVisibility get_Visibility();
    public void set_Visibility(PdfXfaVisibility value);
    public float get_Width();
    public void set_Width(float value);
    public float get_Height();
    public void set_Height(float value);
    public PointF get_Location();
    public void set_Location(PointF value);
    public PdfLoadedXfaRadioButtonField[] get_Fields();
    internal void Add(PdfLoadedXfaRadioButtonField field);
    internal void ReadField(XmlNode node, XmlDocument dataSetDoc);
    internal SizeF GetSize();
    internal void DrawRadiButtonGroup(PdfGraphics graphics, RectangleF bounds);
    internal void SetIndex();
    internal void ResetSelection();
    internal void Save();
    internal void Fill(XmlWriter dataSetWriter, PdfLoadedXfaForm form);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Syncfusion.Pdf.Xfa.PdfLoadedXfaRectangleField : PdfLoadedXfaStyledField {
    private PdfXfaCorner m_corner;
    private float m_radius;
    private PdfXfaRotateAngle m_rotate;
    private PdfXfaBorder m_border;
    private string m_toolTip;
    public PdfXfaBorder Border { get; public set; }
    public string ToolTip { get; public set; }
    public PdfXfaCorner Corner { get; public set; }
    public PdfXfaRotateAngle Rotate { get; public set; }
    public PdfXfaBorder get_Border();
    public void set_Border(PdfXfaBorder value);
    public string get_ToolTip();
    public void set_ToolTip(string value);
    public PdfXfaCorner get_Corner();
    public void set_Corner(PdfXfaCorner value);
    public PdfXfaRotateAngle get_Rotate();
    public void set_Rotate(PdfXfaRotateAngle value);
    internal void ReadField(XmlNode node);
    internal void DrawRectangle(PdfGraphics graphics, RectangleF bounds);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public abstract class Syncfusion.Pdf.Xfa.PdfLoadedXfaStyledField : PdfLoadedXfaField {
    private string m_toolTip;
    private PdfXfaCaption m_caption;
    private PdfFont m_font;
    private PdfColor m_foreColor;
    private PdfXfaBorder m_border;
    private string m_presence;
    private PdfXfaVerticalAlignment m_vAlign;
    private PdfXfaHorizontalAlignment m_hAlign;
    private string hAlign;
    private string vAlign;
    private float m_width;
    private float m_height;
    private PointF m_location;
    private bool m_readOnly;
    private PdfXfaRotateAngle m_rotate;
    private PdfXfaBorder m_completeBorder;
    internal bool m_isDefaultFont;
    internal float lineHeight;
    internal PdfXfaRotateAngle Rotate { get; internal set; }
    internal PdfXfaBorder CompleteBorder { get; internal set; }
    public bool ReadOnly { get; public set; }
    public float Width { get; public set; }
    public float Height { get; public set; }
    public PointF Location { get; public set; }
    internal PdfFont Font { get; public set; }
    public string ToolTip { get; public set; }
    public PdfXfaCaption Caption { get; public set; }
    public PdfColor ForeColor { get; public set; }
    public PdfXfaBorder Border { get; public set; }
    public PdfXfaHorizontalAlignment HorizontalAlignment { get; public set; }
    public PdfXfaVerticalAlignment VerticalAlignment { get; public set; }
    internal PdfXfaRotateAngle get_Rotate();
    internal void set_Rotate(PdfXfaRotateAngle value);
    internal PdfXfaBorder get_CompleteBorder();
    internal void set_CompleteBorder(PdfXfaBorder value);
    public bool get_ReadOnly();
    public void set_ReadOnly(bool value);
    public float get_Width();
    public void set_Width(float value);
    public float get_Height();
    public void set_Height(float value);
    public PointF get_Location();
    public void set_Location(PointF value);
    internal PdfFont get_Font();
    public void set_Font(PdfFont value);
    public string get_ToolTip();
    public void set_ToolTip(string value);
    public PdfXfaCaption get_Caption();
    public void set_Caption(PdfXfaCaption value);
    public PdfColor get_ForeColor();
    public void set_ForeColor(PdfColor value);
    public PdfXfaBorder get_Border();
    public void set_Border(PdfXfaBorder value);
    public PdfXfaHorizontalAlignment get_HorizontalAlignment();
    public void set_HorizontalAlignment(PdfXfaHorizontalAlignment value);
    public PdfXfaVerticalAlignment get_VerticalAlignment();
    public void set_VerticalAlignment(PdfXfaVerticalAlignment value);
    internal SizeF GetSize();
    internal PdfFont GetFont();
    internal void ReadCommonProperties(XmlNode node);
    internal void ReadBorder(XmlNode node, bool complete);
    private void ReadCaption(XmlNode node);
    private void ReadFontInfo(XmlNode fNode);
    internal void CheckUnicodeFont(string text);
    internal void Save();
    private void SetMargin(XmlNode node);
    internal PdfCheckBoxStyle GetStyle(PdfXfaCheckedStyle style);
    internal string StyleToString(PdfCheckBoxStyle style);
    private void SetFont(XmlNode node);
    internal void SetNewAttribute(XmlNode node, string name, string value);
    internal int GetRotationAngle();
    internal RectangleF GetRenderingRect(RectangleF tempBounds);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class Syncfusion.Pdf.Xfa.PdfLoadedXfaTextBoxField : PdfLoadedXfaStyledField {
    private string m_text;
    internal string Node;
    private float m_minW;
    private float m_maxW;
    private float m_minH;
    private float m_maxH;
    private char m_passwordChar;
    private int m_maxLength;
    private int m_combLength;
    private bool m_passwordEdit;
    private PdfXfaTextBoxType m_type;
    internal bool m_isExData;
    private string m_altText;
    private PdfMargins m_innerMargin;
    private bool isSkipDefaultMargin;
    public float MaximumWidth { get; public set; }
    public float MaximumHeight { get; public set; }
    public float MinimumWidth { get; public set; }
    public float MinimumHeight { get; public set; }
    public string Text { get; public set; }
    public PdfXfaTextBoxType Type { get; public set; }
    public char PasswordCharacter { get; public set; }
    public int MaximumLength { get; public set; }
    public int CombLength { get; public set; }
    internal PdfLoadedXfaTextBoxField(string name);
    internal PdfLoadedXfaTextBoxField(string name, string text);
    public float get_MaximumWidth();
    public void set_MaximumWidth(float value);
    public float get_MaximumHeight();
    public void set_MaximumHeight(float value);
    public float get_MinimumWidth();
    public void set_MinimumWidth(float value);
    public float get_MinimumHeight();
    public void set_MinimumHeight(float value);
    public void set_Text(string value);
    public string get_Text();
    public PdfXfaTextBoxType get_Type();
    public void set_Type(PdfXfaTextBoxType value);
    public char get_PasswordCharacter();
    public void set_PasswordCharacter(char value);
    public int get_MaximumLength();
    public void set_MaximumLength(int value);
    public int get_CombLength();
    public void set_CombLength(int value);
    internal SizeF GetFieldSize();
    private float GetWidth();
    internal void Read(XmlNode node, XmlDocument dataSetDoc);
    internal void DrawField(PdfGraphics graphics, RectangleF bounds);
    private RectangleF GetBounds(RectangleF bounds1);
    internal void Save();
    internal void Fill(XmlWriter dataSetWriter, PdfLoadedXfaForm form);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Syncfusion.Pdf.Xfa.PdfLoadedXfaTextElement : PdfLoadedXfaStyledField {
    private string m_text;
    internal string alterText;
    internal bool isExData;
    public string Text { get; public set; }
    public string get_Text();
    public void set_Text(string value);
    internal void Read(XmlNode node);
    internal void DrawTextElement(PdfGraphics graphics, RectangleF bounds);
    internal SizeF GetSize();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class Syncfusion.Pdf.Xfa.PdfXfaBorder : object {
    private PdfXfaHandedness m_handedness;
    private PdfXfaVisibility m_visibility;
    private PdfXfaEdge m_left;
    private PdfXfaEdge m_right;
    private PdfXfaEdge m_bottom;
    private PdfXfaEdge m_top;
    private PdfColor m_color;
    private float m_width;
    private PdfXfaBorderStyle m_borderStyle;
    private string m_presenceTxt;
    private PdfXfaBrush m_fillColor;
    public PdfXfaBrush FillColor { get; public set; }
    public PdfXfaHandedness Handedness { get; public set; }
    public PdfXfaVisibility Visibility { get; public set; }
    public PdfXfaEdge LeftEdge { get; public set; }
    public PdfXfaEdge RightEdge { get; public set; }
    public PdfXfaEdge TopEdge { get; public set; }
    public PdfXfaEdge BottomEdge { get; public set; }
    public PdfColor Color { get; public set; }
    public float Width { get; public set; }
    public PdfXfaBorderStyle Style { get; public set; }
    public PdfXfaBorder(PdfColor color);
    public PdfXfaBrush get_FillColor();
    public void set_FillColor(PdfXfaBrush value);
    public PdfXfaHandedness get_Handedness();
    public void set_Handedness(PdfXfaHandedness value);
    public PdfXfaVisibility get_Visibility();
    public void set_Visibility(PdfXfaVisibility value);
    public PdfXfaEdge get_LeftEdge();
    public void set_LeftEdge(PdfXfaEdge value);
    public PdfXfaEdge get_RightEdge();
    public void set_RightEdge(PdfXfaEdge value);
    public PdfXfaEdge get_TopEdge();
    public void set_TopEdge(PdfXfaEdge value);
    public PdfXfaEdge get_BottomEdge();
    public void set_BottomEdge(PdfXfaEdge value);
    public PdfColor get_Color();
    public void set_Color(PdfColor value);
    public float get_Width();
    public void set_Width(float value);
    public PdfXfaBorderStyle get_Style();
    public void set_Style(PdfXfaBorderStyle value);
    internal void DrawBorder(PdfGraphics graphics, RectangleF bounds);
    private void DrawEdge(PdfGraphics graphics, PdfPen pen, PointF point, PointF point1);
    internal PdfBorderStyle GetBorderStyle();
    internal void ApplyAcroBorder(PdfStyledField field);
    internal PdfBrush GetBrush(RectangleF bounds);
    internal PdfPen GetFlattenPen();
    internal PdfPen GetPen();
    internal void Read(XmlNode node);
    internal void ReadFillBrush(XmlNode node);
    private bool ValidateColor(String[] words);
    private PdfXfaLinearType GetLinearType(string type);
    private PdfXfaRadialType GetRadialType(string type);
    internal static PdfXfaBorder ReadBorder(XmlNode node);
    internal void Save(XmlNode node);
    private void CreateNewEdgeNode(XmlNode node, PdfXfaEdge edge);
    private void SetNewAttribute(XmlNode node, string name, string value);
}
public enum Syncfusion.Pdf.Xfa.PdfXfaBorderStyle : Enum {
    public int value__;
    public static PdfXfaBorderStyle None;
    public static PdfXfaBorderStyle Solid;
    public static PdfXfaBorderStyle Dashed;
    public static PdfXfaBorderStyle Dotted;
    public static PdfXfaBorderStyle DashDot;
    public static PdfXfaBorderStyle DashDotDot;
    public static PdfXfaBorderStyle Lowered;
    public static PdfXfaBorderStyle Raised;
    public static PdfXfaBorderStyle Etched;
    public static PdfXfaBorderStyle Embossed;
}
public abstract class Syncfusion.Pdf.Xfa.PdfXfaBrush : object {
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class Syncfusion.Pdf.Xfa.PdfXfaButtonField : PdfXfaStyledField {
    private PdfHighlightMode m_highlight;
    private string m_rolloverText;
    private string m_downText;
    private string m_content;
    internal PdfXfaForm parent;
    public PdfHighlightMode Highlight { get; public set; }
    public string MouseRolloverText { get; public set; }
    public string MouseDownText { get; public set; }
    public string Content { get; public set; }
    public PdfXfaButtonField(string name, SizeF buttonSize);
    public PdfXfaButtonField(string name, float width, float height);
    public PdfHighlightMode get_Highlight();
    public void set_Highlight(PdfHighlightMode value);
    public string get_MouseRolloverText();
    public void set_MouseRolloverText(string value);
    public string get_MouseDownText();
    public void set_MouseDownText(string value);
    public string get_Content();
    public void set_Content(string value);
    internal void Save(XfaWriter xfaWriter);
    internal PdfField SaveAcroForm(PdfPage page, RectangleF bounds, string name);
    public object Clone();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class Syncfusion.Pdf.Xfa.PdfXfaCaption : object {
    private string m_text;
    internal float m_width;
    private PdfFont m_font;
    private PdfXfaHorizontalAlignment m_hAlign;
    private PdfXfaVerticalAlignment m_vAlign;
    private PdfXfaPosition m_position;
    private PdfColor m_foreColor;
    internal XmlNode currentNode;
    private string hAlign;
    private string vAlign;
    private RectangleF m_bounds;
    private PdfPage m_page;
    internal PdfXfaField parent;
    public string Text { get; public set; }
    public PdfFont Font { get; public set; }
    public PdfXfaHorizontalAlignment HorizontalAlignment { get; public set; }
    public PdfXfaVerticalAlignment VerticalAlignment { get; public set; }
    public PdfXfaPosition Position { get; public set; }
    public PdfColor ForeColor { get; public set; }
    public float Width { get; public set; }
    internal PdfXfaCaption(bool flag);
    public string get_Text();
    public void set_Text(string value);
    public PdfFont get_Font();
    public void set_Font(PdfFont value);
    public PdfXfaHorizontalAlignment get_HorizontalAlignment();
    public void set_HorizontalAlignment(PdfXfaHorizontalAlignment value);
    public PdfXfaVerticalAlignment get_VerticalAlignment();
    public void set_VerticalAlignment(PdfXfaVerticalAlignment value);
    public PdfXfaPosition get_Position();
    public void set_Position(PdfXfaPosition value);
    public PdfColor get_ForeColor();
    public void set_ForeColor(PdfColor value);
    public float get_Width();
    public void set_Width(float value);
    internal void Save(XfaWriter xfaWriter);
    internal void DrawText(PdfPageBase page, RectangleF bounds);
    internal void DrawText(PdfGraphics graphics, RectangleF bounds);
    internal void DrawText(PdfGraphics graphics, RectangleF bounds, int rotationAngle);
    internal void DrawText(PdfPageBase page, RectangleF bounds, int rotationAngle);
    private PdfTextAlignment ConvertToPdfTextAlignment(PdfXfaHorizontalAlignment align);
    internal SizeF MeasureString();
    internal SizeF MeasureString(string text);
    public object Clone();
    internal void Read(XmlNode node);
    internal void Save(XmlNode node);
    private void SetNewAttribute(XmlNode node, string name, string value);
    private float ConvertToPoint(string value);
    private void ReadFontInfo(XmlNode fNode);
}
public enum Syncfusion.Pdf.Xfa.PdfXfaCheckBoxAppearance : Enum {
    public int value__;
    public static PdfXfaCheckBoxAppearance Square;
    public static PdfXfaCheckBoxAppearance Round;
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class Syncfusion.Pdf.Xfa.PdfXfaCheckBoxField : PdfXfaStyledField {
    private PdfXfaCheckedStyle m_checkedStyle;
    private PdfXfaCheckBoxAppearance m_checkBoxAppearance;
    private bool m_isChecked;
    private float m_checkBoxSize;
    private PdfXfaCaption m_caption;
    internal PdfXfaForm parent;
    public PdfXfaCaption Caption { get; public set; }
    public bool IsChecked { get; public set; }
    public PdfXfaCheckedStyle CheckedStyle { get; public set; }
    public PdfXfaCheckBoxAppearance CheckBoxAppearance { get; public set; }
    public float CheckBoxSize { get; public set; }
    public PdfXfaCheckBoxField(string name, SizeF size);
    public PdfXfaCheckBoxField(string name, SizeF size, bool isChecked);
    public PdfXfaCheckBoxField(string name, float width, float height);
    public PdfXfaCheckBoxField(string name, float width, float height, bool isChecked);
    public PdfXfaCaption get_Caption();
    public void set_Caption(PdfXfaCaption value);
    public bool get_IsChecked();
    public void set_IsChecked(bool value);
    public void set_CheckedStyle(PdfXfaCheckedStyle value);
    public PdfXfaCheckedStyle get_CheckedStyle();
    public void set_CheckBoxAppearance(PdfXfaCheckBoxAppearance value);
    public PdfXfaCheckBoxAppearance get_CheckBoxAppearance();
    public float get_CheckBoxSize();
    public void set_CheckBoxSize(float value);
    internal void Save(XfaWriter xfaWriter);
    internal PdfField SaveAcroForm(PdfPage page, RectangleF bounds, string name);
    private PdfCheckBoxStyle GetStyle(PdfXfaCheckedStyle style);
    public object Clone();
}
public enum Syncfusion.Pdf.Xfa.PdfXfaCheckedStyle : Enum {
    public int value__;
    public static PdfXfaCheckedStyle Default;
    public static PdfXfaCheckedStyle Check;
    public static PdfXfaCheckedStyle Circle;
    public static PdfXfaCheckedStyle Cross;
    public static PdfXfaCheckedStyle Diamond;
    public static PdfXfaCheckedStyle Square;
    public static PdfXfaCheckedStyle Star;
}
public enum Syncfusion.Pdf.Xfa.PdfXfaCircleAppearance : Enum {
    public int value__;
    public static PdfXfaCircleAppearance Circle;
    public static PdfXfaCircleAppearance Ellipse;
    public static PdfXfaCircleAppearance Arc;
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class Syncfusion.Pdf.Xfa.PdfXfaCircleField : PdfXfaField {
    private int m_sweepAngle;
    private int m_startAngle;
    private PdfXfaCircleAppearance m_Appearance;
    private string m_toolTip;
    private PdfXfaRotateAngle m_rotate;
    private float m_width;
    private float m_height;
    private PdfXfaBorder m_border;
    internal PdfXfaForm parent;
    public PdfXfaBorder Border { get; public set; }
    public string ToolTip { get; public set; }
    public int StartAngle { get; public set; }
    public int SweepAngle { get; public set; }
    public PdfXfaCircleAppearance Appearance { get; public set; }
    public PdfXfaRotateAngle Rotate { get; public set; }
    public float Width { get; public set; }
    public float Height { get; public set; }
    public PdfXfaCircleField(string name, SizeF size);
    public PdfXfaCircleField(string name, float width, float height);
    public PdfXfaBorder get_Border();
    public void set_Border(PdfXfaBorder value);
    public string get_ToolTip();
    public void set_ToolTip(string value);
    public int get_StartAngle();
    public void set_StartAngle(int value);
    public int get_SweepAngle();
    public void set_SweepAngle(int value);
    public PdfXfaCircleAppearance get_Appearance();
    public void set_Appearance(PdfXfaCircleAppearance value);
    public PdfXfaRotateAngle get_Rotate();
    public void set_Rotate(PdfXfaRotateAngle value);
    public void set_Width(float value);
    public float get_Width();
    public void set_Height(float value);
    public float get_Height();
    internal void Save(XfaWriter xfaWriter);
    internal void SaveAcroForm(PdfPage page, RectangleF bounds);
    private int GetRotationAngle();
    internal SizeF GetSize();
    public object Clone();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class Syncfusion.Pdf.Xfa.PdfXfaComboBoxField : PdfXfaStyledField {
    private bool m_allowTextEntry;
    private List`1<string> m_items;
    private int m_selectedIndex;
    private string m_selectedValue;
    private PdfXfaCaption m_caption;
    internal PdfPage m_page;
    internal RectangleF currentBounds;
    internal PdfXfaForm parent;
    private object m_dataSource;
    private PdfPaddings m_padding;
    public PdfPaddings Padding { get; public set; }
    public object DataSource { get; public set; }
    public PdfXfaCaption Caption { get; public set; }
    public List`1<string> Items { get; public set; }
    public int SelectedIndex { get; public set; }
    public string SelectedValue { get; public set; }
    public bool AllowTextEntry { get; public set; }
    public PdfXfaComboBoxField(string name, SizeF size);
    public PdfXfaComboBoxField(string name, SizeF size, List`1<string> items);
    public PdfXfaComboBoxField(string name, float width, float height);
    public PdfXfaComboBoxField(string name, float width, float height, List`1<string> items);
    public PdfPaddings get_Padding();
    public void set_Padding(PdfPaddings value);
    public object get_DataSource();
    public void set_DataSource(object value);
    public PdfXfaCaption get_Caption();
    public void set_Caption(PdfXfaCaption value);
    public List`1<string> get_Items();
    public void set_Items(List`1<string> value);
    public int get_SelectedIndex();
    public void set_SelectedIndex(int value);
    public string get_SelectedValue();
    public void set_SelectedValue(string value);
    public bool get_AllowTextEntry();
    public void set_AllowTextEntry(bool value);
    internal void Save(XfaWriter xfaWriter);
    internal PdfField SaveAcroForm(PdfPage page, RectangleF bounds, string name);
    private void SetSize(XfaWriter xfaWriter);
    public object Clone();
}
public class Syncfusion.Pdf.Xfa.PdfXfaCorner : object {
    private bool m_isInverted;
    private float m_thickness;
    private float m_radius;
    private PdfXfaBorderStyle m_borderStyle;
    private PdfColor m_borderColor;
    private PdfXfaVisibility m_visibility;
    private PdfXfaCornerShape m_shape;
    public PdfXfaCornerShape Shape { get; public set; }
    public bool IsInverted { get; public set; }
    public PdfColor BorderColor { get; public set; }
    public PdfXfaVisibility Visibility { get; public set; }
    public float Thickness { get; public set; }
    public float Radius { get; public set; }
    public PdfXfaBorderStyle BorderStyle { get; public set; }
    public PdfXfaCornerShape get_Shape();
    public void set_Shape(PdfXfaCornerShape value);
    public bool get_IsInverted();
    public void set_IsInverted(bool value);
    public PdfColor get_BorderColor();
    public void set_BorderColor(PdfColor value);
    public PdfXfaVisibility get_Visibility();
    public void set_Visibility(PdfXfaVisibility value);
    public float get_Thickness();
    public void set_Thickness(float value);
    public float get_Radius();
    public void set_Radius(float value);
    public PdfXfaBorderStyle get_BorderStyle();
    public void set_BorderStyle(PdfXfaBorderStyle value);
}
public enum Syncfusion.Pdf.Xfa.PdfXfaCornerShape : Enum {
    public int value__;
    public static PdfXfaCornerShape Square;
    public static PdfXfaCornerShape Round;
}
public enum Syncfusion.Pdf.Xfa.PdfXfaDatePattern : Enum {
    public int value__;
    public static PdfXfaDatePattern Default;
    public static PdfXfaDatePattern Short;
    public static PdfXfaDatePattern Medium;
    public static PdfXfaDatePattern Long;
    public static PdfXfaDatePattern Full;
    public static PdfXfaDatePattern MDYY;
    public static PdfXfaDatePattern MMMD_YYYY;
    public static PdfXfaDatePattern MMMMD_YYYY;
    public static PdfXfaDatePattern EEEE_MMMMD_YYYY;
    public static PdfXfaDatePattern MDYYYY;
    public static PdfXfaDatePattern MMDDYY;
    public static PdfXfaDatePattern MMDDYYYY;
    public static PdfXfaDatePattern YYMMDD;
    public static PdfXfaDatePattern YYYYMMDD;
    public static PdfXfaDatePattern DDMMMYY;
    public static PdfXfaDatePattern EEEEMMMMDDYYYY;
    public static PdfXfaDatePattern MMMMDDYYYY;
    public static PdfXfaDatePattern EEEEDDMMMMYYYY;
    public static PdfXfaDatePattern DDMMMMYYYY;
    public static PdfXfaDatePattern MMMMYYYY;
    public static PdfXfaDatePattern DDMMYYYY;
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class Syncfusion.Pdf.Xfa.PdfXfaDateTimeField : PdfXfaStyledField {
    private DateTime m_value;
    private PdfXfaDatePattern m_datePatterns;
    private PdfXfaTimePattern m_timePatterns;
    private PdfXfaDateTimeFormat m_format;
    private bool m_requireValidation;
    internal bool isSet;
    private PdfXfaCaption m_caption;
    internal PdfXfaForm parent;
    private PdfPaddings m_padding;
    public PdfPaddings Padding { get; public set; }
    public PdfXfaCaption Caption { get; public set; }
    public DateTime Value { get; public set; }
    public PdfXfaDatePattern DatePattern { get; public set; }
    public PdfXfaDateTimeFormat Format { get; public set; }
    public PdfXfaTimePattern TimePattern { get; public set; }
    public bool RequireValidation { get; public set; }
    public PdfXfaDateTimeField(string name, SizeF size);
    public PdfXfaDateTimeField(string name, float width, float height);
    public PdfPaddings get_Padding();
    public void set_Padding(PdfPaddings value);
    public PdfXfaCaption get_Caption();
    public void set_Caption(PdfXfaCaption value);
    public DateTime get_Value();
    public void set_Value(DateTime value);
    public PdfXfaDatePattern get_DatePattern();
    public void set_DatePattern(PdfXfaDatePattern value);
    public PdfXfaDateTimeFormat get_Format();
    public void set_Format(PdfXfaDateTimeFormat value);
    public PdfXfaTimePattern get_TimePattern();
    public void set_TimePattern(PdfXfaTimePattern value);
    public bool get_RequireValidation();
    public void set_RequireValidation(bool value);
    internal void Save(XfaWriter xfaWriter);
    internal PdfField SaveAcroForm(PdfPage page, RectangleF bounds, string name);
    private string GetDatePattern(PdfXfaDatePattern pattern);
    private string GetTimePattern(PdfXfaTimePattern pattern);
    private string GetDateTimePattern(PdfXfaDatePattern d, PdfXfaTimePattern t);
    private void SetSize(XfaWriter xfaWriter);
    private string GetDatePattern();
    public object Clone();
}
public enum Syncfusion.Pdf.Xfa.PdfXfaDateTimeFormat : Enum {
    public int value__;
    public static PdfXfaDateTimeFormat Date;
    public static PdfXfaDateTimeFormat Time;
    public static PdfXfaDateTimeFormat DateTime;
}
public enum Syncfusion.Pdf.Xfa.PdfXfaDateTimePattern : Enum {
    public int value__;
    public static PdfXfaDateTimePattern Default;
    public static PdfXfaDateTimePattern Short;
    public static PdfXfaDateTimePattern Medium;
    public static PdfXfaDateTimePattern Long;
    public static PdfXfaDateTimePattern Full;
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class Syncfusion.Pdf.Xfa.PdfXfaDocument : object {
    private PdfXfaPageCollection m_pages;
    private PdfXfaForm m_form;
    internal int m_pageCount;
    private PdfDocument m_document;
    private PdfFileStructure m_fileStructure;
    internal PdfXfaType formType;
    internal XmlWriter dataSetWriter;
    internal PdfArray m_imageArray;
    internal string m_formName;
    private PdfXfaPageSettings m_pageSettings;
    public PdfXfaPageSettings PageSettings { get; public set; }
    public PdfXfaPageCollection Pages { get; internal set; }
    public PdfXfaForm XfaForm { get; public set; }
    public string FormName { get; public set; }
    public PdfXfaPageSettings get_PageSettings();
    public void set_PageSettings(PdfXfaPageSettings value);
    public PdfXfaPageCollection get_Pages();
    internal void set_Pages(PdfXfaPageCollection value);
    public PdfXfaForm get_XfaForm();
    public void set_XfaForm(PdfXfaForm value);
    public string get_FormName();
    public void set_FormName(string value);
    internal void Save(PdfDocument doc);
    public void Save(Stream stream, PdfXfaType type);
    public void Close();
    public sealed virtual object Clone();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class Syncfusion.Pdf.Xfa.PdfXfaEdge : object {
    private float m_thikness;
    private PdfXfaBorderStyle m_borderStyle;
    private PdfColor m_borderColor;
    private PdfXfaVisibility m_visibility;
    private string m_presenceTxt;
    public PdfColor Color { get; public set; }
    public PdfXfaVisibility Visibility { get; public set; }
    public float Thickness { get; public set; }
    public PdfXfaBorderStyle BorderStyle { get; public set; }
    public PdfColor get_Color();
    public void set_Color(PdfColor value);
    public PdfXfaVisibility get_Visibility();
    public void set_Visibility(PdfXfaVisibility value);
    public float get_Thickness();
    public void set_Thickness(float value);
    public PdfXfaBorderStyle get_BorderStyle();
    public void set_BorderStyle(PdfXfaBorderStyle value);
    internal void Read(XmlNode node, PdfXfaEdge edge);
    private float ConvertToPoint(string value);
    private void ReadStroke(string value, PdfXfaEdge edge);
    internal void Save(XmlNode node);
    private void SetNewAttribute(XmlNode node, string name, string value);
    internal object Clone();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public abstract class Syncfusion.Pdf.Xfa.PdfXfaField : object {
    private string m_name;
    private PdfMargins m_margins;
    private PdfXfaVisibility m_visibility;
    internal string LSFN;
    internal bool m_isRendered;
    public string Name { get; public set; }
    public PdfMargins Margins { get; public set; }
    public PdfXfaVisibility Visibility { get; public set; }
    public string get_Name();
    public void set_Name(string value);
    public PdfMargins get_Margins();
    public void set_Margins(PdfMargins value);
    public PdfXfaVisibility get_Visibility();
    public void set_Visibility(PdfXfaVisibility value);
    internal PdfTextAlignment ConvertToPdfTextAlignment(PdfXfaHorizontalAlignment align);
    internal void SetFont(PdfDocumentBase doc, PdfFont font);
    internal RectangleF GetBounds(RectangleF bounds, PdfXfaRotateAngle rotate, PdfXfaCaption caption);
    internal string GetPattern(string patternText);
    internal string TrimDatePattern(string patternText);
    internal string TrimTimePattern(string patternText);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[DefaultMemberAttribute("Item")]
public class Syncfusion.Pdf.Xfa.PdfXfaFieldCollection : PdfCollection {
    private int subFormCount;
    public PdfXfaField Item { get; }
    public int Count { get; }
    public PdfXfaField get_Item(int offset);
    public int get_Count();
    public void Add(PdfXfaField field);
    public void Remove(PdfXfaField field);
    public void RemoveAt(int index);
    public void Clear();
    public void insert(int index, PdfXfaField field);
    public int IndexOf(PdfXfaField field);
    internal object Clone();
}
public enum Syncfusion.Pdf.Xfa.PdfXfaFlowDirection : Enum {
    public int value__;
    public static PdfXfaFlowDirection Horizontal;
    public static PdfXfaFlowDirection Vertical;
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class Syncfusion.Pdf.Xfa.PdfXfaForm : PdfXfaField {
    private PdfXfaFlowDirection m_flowDirection;
    private PdfXfaFieldCollection m_fields;
    internal XmlWriter m_dataSetWriter;
    private int m_fieldCount;
    internal PdfDocument m_document;
    internal PdfArray m_imageArray;
    private PdfXfaBorder m_border;
    private float m_width;
    private bool m_readOnly;
    private PdfXfaPage m_xfaPage;
    internal PdfPage m_page;
    internal PdfXfaForm m_parent;
    internal PdfXfaType m_formType;
    internal PdfXfaDocument m_xfaDocument;
    internal PointF m_startPoint;
    internal PointF m_currentPoint;
    internal SizeF m_maxSize;
    internal string m_name;
    internal PdfFieldCollection m_acroFields;
    internal List`1<string> m_subFormNames;
    internal List`1<string> m_fieldNames;
    internal SizeF m_size;
    private SizeF m_maximumSize;
    private PointF m_currentPosition;
    private SizeF m_pageSize;
    private float m_height;
    private List`1<float> m_borderHeight;
    private int m_borderCount;
    private PdfXfaPage m_tempPage;
    internal bool m_isReadOnly;
    public PdfXfaFlowDirection FlowDirection { get; public set; }
    public PdfXfaBorder Border { get; public set; }
    public PdfXfaFieldCollection Fields { get; internal set; }
    public bool ReadOnly { get; public set; }
    public float Width { get; public set; }
    public PdfXfaPage Page { get; public set; }
    public PdfXfaForm(float width);
    public PdfXfaForm(string name, float width);
    public PdfXfaForm(string name, PdfXfaPage xfaPage, float width);
    public PdfXfaForm(string name, PdfXfaFlowDirection flowDirection, float width);
    public PdfXfaForm(PdfXfaPage xfaPage, PdfXfaFlowDirection flowDirection, float width);
    public PdfXfaForm(PdfXfaFlowDirection flowDirection, float width);
    public PdfXfaForm(string name, PdfXfaPage xfaPage, PdfXfaFlowDirection flowDirection, float width);
    public PdfXfaFlowDirection get_FlowDirection();
    public void set_FlowDirection(PdfXfaFlowDirection value);
    public PdfXfaBorder get_Border();
    public void set_Border(PdfXfaBorder value);
    public PdfXfaFieldCollection get_Fields();
    internal void set_Fields(PdfXfaFieldCollection value);
    public bool get_ReadOnly();
    public void set_ReadOnly(bool value);
    public void set_Width(float value);
    public float get_Width();
    public PdfXfaPage get_Page();
    public void set_Page(PdfXfaPage value);
    internal void Save(PdfDocument document, PdfXfaType type);
    internal void SaveMainForm(XfaWriter xfaWriter);
    internal void AddForm(XfaWriter xfaWriter);
    private void DrawEdge(PdfXfaEdge edge, PointF startPont, PointF endPoint, PdfPage page);
    private PdfDashStyle GetPenDashStyle(PdfXfaBorderStyle style);
    internal void AddSubForm(PdfXfaForm subForm, XfaWriter xfaWriter);
    internal string GetFieldName(string name);
    internal string GetSubFormName(string name);
    internal void AddSubForm(XfaWriter xfaWriter);
    internal void BreakPage(XfaWriter writer, PdfXfaPage page);
    private void GetBackgroundHeight(PdfXfaForm subForm);
    private void DrawBackground(PdfXfaForm tempForm);
    private PdfPage AddPdfPage(PdfXfaPage xfaPage);
    private void SetCurrentPoint(PdfXfaForm subForm);
    private void SetBackgroundHeight(PdfXfaForm subForm, float height);
    private void ParseSubForm(PdfXfaForm subform);
    private void Message();
    public sealed virtual object Clone();
}
public enum Syncfusion.Pdf.Xfa.PdfXfaHandedness : Enum {
    public int value__;
    public static PdfXfaHandedness Right;
    public static PdfXfaHandedness Left;
    public static PdfXfaHandedness Even;
}
public enum Syncfusion.Pdf.Xfa.PdfXfaHorizontalAlignment : Enum {
    public int value__;
    public static PdfXfaHorizontalAlignment Left;
    public static PdfXfaHorizontalAlignment Center;
    public static PdfXfaHorizontalAlignment Right;
    public static PdfXfaHorizontalAlignment Justify;
    public static PdfXfaHorizontalAlignment JustifyAll;
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class Syncfusion.Pdf.Xfa.PdfXfaImage : PdfXfaField {
    private PdfStream m_imageStream;
    private SizeF m_size;
    private RectangleF m_bounds;
    private string m_subFormName;
    private PdfXfaRotateAngle m_rotate;
    internal PdfXfaForm parent;
    private PdfBitmap m_image;
    internal string imageBase64String;
    internal string imageFormat;
    internal bool isBase64Type;
    internal PdfStream ImageStream { get; internal set; }
    public SizeF Size { get; public set; }
    internal RectangleF ImageBounds { get; internal set; }
    internal string SubFormName { get; internal set; }
    public PdfXfaRotateAngle Rotate { get; public set; }
    public PdfXfaImage(string name, Stream stream);
    public PdfXfaImage(string name, Stream stream, SizeF size);
    public PdfXfaImage(string name, Stream stream, float width, float height);
    internal PdfXfaImage(PdfBitmap image, RectangleF bounds);
    internal PdfStream get_ImageStream();
    internal void set_ImageStream(PdfStream value);
    public SizeF get_Size();
    public void set_Size(SizeF value);
    internal void set_ImageBounds(RectangleF value);
    internal RectangleF get_ImageBounds();
    internal void set_SubFormName(string value);
    internal string get_SubFormName();
    public PdfXfaRotateAngle get_Rotate();
    public void set_Rotate(PdfXfaRotateAngle value);
    private Byte[] StreamToByteArray(Stream stream);
    private string GetImageType(ImageFormat imf);
    internal void Save(int fieldCount, string imageName, XfaWriter xfaWriter);
    internal void SaveAcroForm(PdfPage page, RectangleF bounds);
    internal SizeF GetSize();
    private int GetRotationAngle();
    internal object Clone();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class Syncfusion.Pdf.Xfa.PdfXfaLine : PdfXfaField {
    internal PointF m_startLocation;
    internal PointF m_endLocation;
    private float mThickness;
    private PdfColor m_color;
    internal PdfXfaForm parent;
    public PdfColor Color { get; public set; }
    public float Thickness { get; public set; }
    public PdfXfaLine(PointF startLocation, PointF endLocation, float thickness);
    public PdfColor get_Color();
    public void set_Color(PdfColor value);
    public float get_Thickness();
    public void set_Thickness(float value);
    internal void Save(XfaWriter xfaWriter);
    internal void SaveAcroForm(PdfPage page, RectangleF bounds);
    internal SizeF GetSize();
    public object Clone();
}
public class Syncfusion.Pdf.Xfa.PdfXfaLinearBrush : PdfXfaBrush {
    private PdfColor m_startColor;
    private PdfColor m_endColor;
    private PdfXfaLinearType m_type;
    public PdfColor StartColor { get; public set; }
    public PdfColor EndColor { get; public set; }
    public PdfXfaLinearType Type { get; public set; }
    public PdfXfaLinearBrush(PdfColor startColor, PdfColor endColor);
    public PdfXfaLinearBrush(PdfColor startColor, PdfColor endColor, PdfXfaLinearType type);
    public PdfColor get_StartColor();
    public void set_StartColor(PdfColor value);
    public PdfColor get_EndColor();
    public void set_EndColor(PdfColor value);
    public PdfXfaLinearType get_Type();
    public void set_Type(PdfXfaLinearType value);
}
public enum Syncfusion.Pdf.Xfa.PdfXfaLinearType : Enum {
    public int value__;
    public static PdfXfaLinearType LeftToRight;
    public static PdfXfaLinearType RightToLeft;
    public static PdfXfaLinearType BottomToTop;
    public static PdfXfaLinearType TopToBottom;
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class Syncfusion.Pdf.Xfa.PdfXfaListBoxField : PdfXfaStyledField {
    private int m_selectedIndex;
    private string m_selectedValue;
    private List`1<string> m_items;
    private PdfXfaSelectionMode m_selectionMode;
    private PdfXfaCaption m_caption;
    internal RectangleF currentBounds;
    internal PdfXfaForm parent;
    private object m_dataSource;
    private PdfPaddings m_padding;
    public PdfPaddings Padding { get; public set; }
    public object DataSource { get; public set; }
    public PdfXfaCaption Caption { get; public set; }
    public List`1<string> Items { get; public set; }
    public int SelectedIndex { get; public set; }
    public string SelectedValue { get; public set; }
    public PdfXfaSelectionMode SelectionMode { get; public set; }
    public PdfXfaListBoxField(string name, SizeF size);
    public PdfXfaListBoxField(string name, SizeF size, List`1<string> items);
    public PdfXfaListBoxField(string name, float width, float height);
    public PdfXfaListBoxField(string name, float width, float height, List`1<string> items);
    public PdfPaddings get_Padding();
    public void set_Padding(PdfPaddings value);
    public object get_DataSource();
    public void set_DataSource(object value);
    public PdfXfaCaption get_Caption();
    public void set_Caption(PdfXfaCaption value);
    public List`1<string> get_Items();
    public void set_Items(List`1<string> value);
    public int get_SelectedIndex();
    public void set_SelectedIndex(int value);
    public string get_SelectedValue();
    public void set_SelectedValue(string value);
    public PdfXfaSelectionMode get_SelectionMode();
    public void set_SelectionMode(PdfXfaSelectionMode value);
    internal void Save(XfaWriter xfaWriter);
    internal PdfField SaveAcroForm(PdfPage page, RectangleF bounds, string name);
    private void SetSize(XfaWriter xfaWriter);
    public object Clone();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class Syncfusion.Pdf.Xfa.PdfXfaNumericField : PdfXfaStyledField {
    private double m_value;
    private int m_combLength;
    private PdfXfaNumericType m_fieldType;
    private PdfPaddings m_padding;
    private PdfXfaCaption m_caption;
    private string m_patternString;
    internal PdfXfaForm parent;
    private string m_culture;
    public string Culture { get; public set; }
    public PdfXfaCaption Caption { get; public set; }
    public PdfPaddings Padding { get; public set; }
    public double NumericValue { get; public set; }
    public int CombLength { get; public set; }
    public PdfXfaNumericType FieldType { get; public set; }
    public string PatternString { get; public set; }
    public PdfXfaNumericField(string name, SizeF size);
    public PdfXfaNumericField(string name, float width, float height);
    public string get_Culture();
    public void set_Culture(string value);
    public PdfXfaCaption get_Caption();
    public void set_Caption(PdfXfaCaption value);
    public PdfPaddings get_Padding();
    public void set_Padding(PdfPaddings value);
    public void set_NumericValue(double value);
    public double get_NumericValue();
    public int get_CombLength();
    public void set_CombLength(int value);
    public PdfXfaNumericType get_FieldType();
    public void set_FieldType(PdfXfaNumericType value);
    public string get_PatternString();
    public void set_PatternString(string value);
    internal void Save(XfaWriter xfaWriter);
    internal PdfField SaveAcroForm(PdfPage page, RectangleF bounds, string name);
    private void SetSize(XfaWriter xfaWriter);
    public object Clone();
}
public enum Syncfusion.Pdf.Xfa.PdfXfaNumericType : Enum {
    public int value__;
    public static PdfXfaNumericType Float;
    public static PdfXfaNumericType Decimal;
    public static PdfXfaNumericType Integer;
    public static PdfXfaNumericType Currency;
    public static PdfXfaNumericType Percent;
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class Syncfusion.Pdf.Xfa.PdfXfaPage : object {
    internal int pageId;
    internal bool isAdded;
    internal bool isBreaked;
    internal PdfXfaPageSettings pageSettings;
    internal void Save(XfaWriter writer);
    public SizeF GetClientSize();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[DefaultMemberAttribute("Item")]
public class Syncfusion.Pdf.Xfa.PdfXfaPageCollection : object {
    internal List`1<PdfXfaPage> m_pages;
    internal PdfXfaDocument m_parent;
    public PdfXfaPage Item { get; }
    public PdfXfaPage get_Item(int index);
    public PdfXfaPage Add();
    private void SetPageSettings(PdfXfaPage page);
    internal object Clone();
}
public enum Syncfusion.Pdf.Xfa.PdfXfaPageOrientation : Enum {
    public int value__;
    public static PdfXfaPageOrientation Portrait;
    public static PdfXfaPageOrientation Landscape;
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class Syncfusion.Pdf.Xfa.PdfXfaPageSettings : object {
    private PdfXfaPageOrientation m_pageOrientation;
    private SizeF m_size;
    private PdfMargins m_margins;
    public PdfXfaPageOrientation PageOrientation { get; public set; }
    public SizeF PageSize { get; public set; }
    public PdfMargins Margins { get; public set; }
    public PdfXfaPageOrientation get_PageOrientation();
    public void set_PageOrientation(PdfXfaPageOrientation value);
    public SizeF get_PageSize();
    public void set_PageSize(SizeF value);
    public PdfMargins get_Margins();
    public void set_Margins(PdfMargins value);
}
public enum Syncfusion.Pdf.Xfa.PdfXfaPosition : Enum {
    public int value__;
    public static PdfXfaPosition Left;
    public static PdfXfaPosition Right;
    public static PdfXfaPosition Top;
    public static PdfXfaPosition Bottom;
}
public class Syncfusion.Pdf.Xfa.PdfXfaRadialBrush : PdfXfaBrush {
    private PdfColor m_startColor;
    private PdfColor m_endColor;
    private PdfXfaRadialType m_type;
    public PdfColor StartColor { get; public set; }
    public PdfColor EndColor { get; public set; }
    public PdfXfaRadialType Type { get; public set; }
    public PdfXfaRadialBrush(PdfColor startColor, PdfColor endColor);
    public PdfXfaRadialBrush(PdfColor startColor, PdfColor endColor, PdfXfaRadialType type);
    public PdfColor get_StartColor();
    public void set_StartColor(PdfColor value);
    public PdfColor get_EndColor();
    public void set_EndColor(PdfColor value);
    public PdfXfaRadialType get_Type();
    public void set_Type(PdfXfaRadialType value);
}
public enum Syncfusion.Pdf.Xfa.PdfXfaRadialType : Enum {
    public int value__;
    public static PdfXfaRadialType CenterToEdge;
    public static PdfXfaRadialType EdgeToCenter;
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class Syncfusion.Pdf.Xfa.PdfXfaRadioButtonField : PdfXfaStyledField {
    private string m_toolTip;
    private PdfXfaRotateAngle m_rotate;
    private PdfXfaCheckedStyle m_checkedStyle;
    private PdfXfaCheckBoxAppearance m_radioButtonAppearance;
    private bool m_isChecked;
    private float m_radioButtonSize;
    private PdfXfaCaption m_caption;
    internal PdfXfaField parent;
    public bool IsChecked { get; public set; }
    public PdfXfaCaption Caption { get; public set; }
    public PdfXfaCheckedStyle CheckedStyle { get; public set; }
    public PdfXfaCheckBoxAppearance RadioButtonAppearance { get; public set; }
    public float RadioButtonSize { get; public set; }
    public PdfXfaRadioButtonField(string name, SizeF size);
    public PdfXfaRadioButtonField(string name, float width, float height);
    public bool get_IsChecked();
    public void set_IsChecked(bool value);
    public PdfXfaCaption get_Caption();
    public void set_Caption(PdfXfaCaption value);
    public void set_CheckedStyle(PdfXfaCheckedStyle value);
    public PdfXfaCheckedStyle get_CheckedStyle();
    public void set_RadioButtonAppearance(PdfXfaCheckBoxAppearance value);
    public PdfXfaCheckBoxAppearance get_RadioButtonAppearance();
    public float get_RadioButtonSize();
    public void set_RadioButtonSize(float value);
    internal void Save(XfaWriter xfaWriter, int index);
    internal void SetMFTP(XfaWriter xfaWriter);
    internal PdfRadioButtonListItem SaveAcroForm(PdfPage page, RectangleF bounds);
    private PdfCheckBoxStyle GetStyle(PdfXfaCheckedStyle style);
    public object Clone();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class Syncfusion.Pdf.Xfa.PdfXfaRadioButtonGroup : PdfXfaField {
    internal PdfXfaRadioButtonListItem m_radioList;
    internal int selectedItem;
    private PdfXfaFlowDirection m_layout;
    internal PdfXfaForm parent;
    internal SizeF Size;
    private bool m_readOnly;
    public bool ReadOnly { get; public set; }
    public PdfXfaRadioButtonListItem Items { get; public set; }
    public PdfXfaFlowDirection FlowDirection { get; public set; }
    public PdfXfaRadioButtonGroup(string name);
    public bool get_ReadOnly();
    public void set_ReadOnly(bool value);
    public PdfXfaRadioButtonListItem get_Items();
    public void set_Items(PdfXfaRadioButtonListItem value);
    public PdfXfaFlowDirection get_FlowDirection();
    public void set_FlowDirection(PdfXfaFlowDirection value);
    internal void Save(XfaWriter xfaWriter);
    public object Clone();
}
[NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public class Syncfusion.Pdf.Xfa.PdfXfaRadioButtonListItem : List`1<PdfXfaRadioButtonField> {
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class Syncfusion.Pdf.Xfa.PdfXfaRectangleField : PdfXfaField {
    private PdfXfaCorner m_corner;
    private float m_radius;
    private PdfXfaRotateAngle m_rotate;
    private PdfXfaBorder m_border;
    private string m_toolTip;
    private float m_width;
    private float m_height;
    internal PdfXfaForm parent;
    public PdfXfaBorder Border { get; public set; }
    public string ToolTip { get; public set; }
    public PdfXfaCorner Corner { get; public set; }
    public PdfXfaRotateAngle Rotate { get; public set; }
    public float Width { get; public set; }
    public float Height { get; public set; }
    public PdfXfaRectangleField(string name, SizeF size);
    public PdfXfaRectangleField(string name, float width, float height);
    public PdfXfaBorder get_Border();
    public void set_Border(PdfXfaBorder value);
    public string get_ToolTip();
    public void set_ToolTip(string value);
    public PdfXfaCorner get_Corner();
    public void set_Corner(PdfXfaCorner value);
    public PdfXfaRotateAngle get_Rotate();
    public void set_Rotate(PdfXfaRotateAngle value);
    public void set_Width(float value);
    public float get_Width();
    public void set_Height(float value);
    public float get_Height();
    internal void Save(XfaWriter xfaWriter);
    internal void SaveAcroForm(PdfPage page, RectangleF bounds);
    private int GetRotationAngle();
    internal SizeF GetSize();
    public object Clone();
}
public enum Syncfusion.Pdf.Xfa.PdfXfaRotateAngle : Enum {
    public int value__;
    public static PdfXfaRotateAngle RotateAngle0;
    public static PdfXfaRotateAngle RotateAngle90;
    public static PdfXfaRotateAngle RotateAngle180;
    public static PdfXfaRotateAngle RotateAngle270;
}
public enum Syncfusion.Pdf.Xfa.PdfXfaSelectionMode : Enum {
    public int value__;
    public static PdfXfaSelectionMode Single;
    public static PdfXfaSelectionMode Multiple;
}
public class Syncfusion.Pdf.Xfa.PdfXfaSolidBrush : PdfXfaBrush {
    private PdfColor m_color;
    public PdfColor Color { get; public set; }
    public PdfXfaSolidBrush(PdfColor color);
    public PdfColor get_Color();
    public void set_Color(PdfColor value);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public abstract class Syncfusion.Pdf.Xfa.PdfXfaStyledField : PdfXfaField {
    private string m_toolTip;
    private PdfFont m_font;
    private PdfColor m_foreColor;
    private PdfXfaHorizontalAlignment m_hAlign;
    private PdfXfaVerticalAlignment m_vAlign;
    private PdfXfaRotateAngle m_rotate;
    private PdfXfaBorder m_border;
    private bool m_readOnly;
    private float m_width;
    private float m_height;
    internal PdfXfaForm parent;
    public float Width { get; public set; }
    public float Height { get; public set; }
    public PdfXfaBorder Border { get; public set; }
    public string ToolTip { get; public set; }
    public bool ReadOnly { get; public set; }
    public PdfFont Font { get; public set; }
    public PdfColor ForeColor { get; public set; }
    public PdfXfaHorizontalAlignment HorizontalAlignment { get; public set; }
    public PdfXfaVerticalAlignment VerticalAlignment { get; public set; }
    public PdfXfaRotateAngle Rotate { get; public set; }
    public void set_Width(float value);
    public float get_Width();
    public void set_Height(float value);
    public float get_Height();
    public PdfXfaBorder get_Border();
    public void set_Border(PdfXfaBorder value);
    public string get_ToolTip();
    public void set_ToolTip(string value);
    public bool get_ReadOnly();
    public void set_ReadOnly(bool value);
    public PdfFont get_Font();
    public void set_Font(PdfFont value);
    public PdfColor get_ForeColor();
    public void set_ForeColor(PdfColor value);
    public PdfXfaHorizontalAlignment get_HorizontalAlignment();
    public void set_HorizontalAlignment(PdfXfaHorizontalAlignment value);
    public PdfXfaVerticalAlignment get_VerticalAlignment();
    public void set_VerticalAlignment(PdfXfaVerticalAlignment value);
    public PdfXfaRotateAngle get_Rotate();
    public void set_Rotate(PdfXfaRotateAngle value);
    internal void SetMFTP(XfaWriter xfaWriter);
    internal SizeF GetSize();
    internal int GetRotationAngle();
}
internal enum Syncfusion.Pdf.Xfa.PdfXfaTargetType : Enum {
    public int value__;
    public static PdfXfaTargetType ContentArea;
    public static PdfXfaTargetType PageArea;
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class Syncfusion.Pdf.Xfa.PdfXfaTextBoxField : PdfXfaStyledField {
    private float m_minimumHeight;
    private float m_minimumWidth;
    private float m_maxHeight;
    private float m_maxWidth;
    private string m_text;
    private int m_maxLength;
    private int m_combLength;
    private char m_passwordChar;
    private PdfPaddings m_padding;
    private PdfXfaTextBoxType m_type;
    private PdfXfaCaption m_caption;
    internal PdfXfaForm parent;
    public PdfXfaCaption Caption { get; public set; }
    public PdfXfaTextBoxType Type { get; public set; }
    public PdfPaddings Padding { get; public set; }
    public float MinimumHeight { get; public set; }
    public float MinimumWidth { get; public set; }
    public float MaximumHeight { get; public set; }
    public float MaximumWidth { get; public set; }
    public string Text { get; public set; }
    public int MaximumLength { get; public set; }
    public int CombLength { get; public set; }
    public char PasswordCharacter { get; public set; }
    public PdfXfaTextBoxField(string fieldName, SizeF minimumSize);
    public PdfXfaTextBoxField(string fieldName, SizeF minimumSize, string defaultText);
    public PdfXfaTextBoxField(string fieldName, SizeF minimumSize, string defaultText, PdfXfaTextBoxType fieldType);
    public PdfXfaTextBoxField(string fieldName, SizeF minimumSize, PdfXfaTextBoxType fieldType);
    public PdfXfaTextBoxField(string fieldName, float minWidth, float minHeight);
    public PdfXfaTextBoxField(string fieldName, float minWidth, float minHeight, string defaultText);
    public PdfXfaTextBoxField(string fieldName, float minWidth, float minHeight, PdfXfaTextBoxType fieldType);
    public PdfXfaTextBoxField(string fieldName, float minWidth, float minHeight, string defaultText, PdfXfaTextBoxType fieldType);
    public PdfXfaCaption get_Caption();
    public void set_Caption(PdfXfaCaption value);
    public PdfXfaTextBoxType get_Type();
    public void set_Type(PdfXfaTextBoxType value);
    public PdfPaddings get_Padding();
    public void set_Padding(PdfPaddings value);
    public void set_MinimumHeight(float value);
    public float get_MinimumHeight();
    public void set_MinimumWidth(float value);
    public float get_MinimumWidth();
    public void set_MaximumHeight(float value);
    public float get_MaximumHeight();
    public void set_MaximumWidth(float value);
    public float get_MaximumWidth();
    public void set_Text(string value);
    public string get_Text();
    public int get_MaximumLength();
    public void set_MaximumLength(int value);
    public int get_CombLength();
    public void set_CombLength(int value);
    public char get_PasswordCharacter();
    public void set_PasswordCharacter(char value);
    internal void Save(XfaWriter xfaWriter, PdfXfaType type);
    internal void Save(XfaWriter xfaWriter);
    internal PdfField SaveAcroForm(PdfPage page, RectangleF bounds, string name);
    private void SetSize(XfaWriter xfaWriter, PdfXfaType type);
    internal SizeF GetSize();
    public sealed virtual object Clone();
}
public enum Syncfusion.Pdf.Xfa.PdfXfaTextBoxType : Enum {
    public int value__;
    public static PdfXfaTextBoxType SingleLine;
    public static PdfXfaTextBoxType Multiline;
    public static PdfXfaTextBoxType Password;
    public static PdfXfaTextBoxType Comb;
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class Syncfusion.Pdf.Xfa.PdfXfaTextElement : PdfXfaField {
    private string m_text;
    private PdfXfaRotateAngle m_rotate;
    private PdfFont m_font;
    private PdfColor m_foreColor;
    private float m_width;
    private float m_height;
    private PdfXfaHorizontalAlignment m_hAlign;
    private PdfXfaVerticalAlignment m_vAlign;
    internal PdfXfaForm parent;
    public PdfXfaHorizontalAlignment HorizontalAlignment { get; public set; }
    public PdfXfaVerticalAlignment VerticalAlignment { get; public set; }
    public string Text { get; public set; }
    public PdfXfaRotateAngle Rotate { get; public set; }
    public PdfFont Font { get; public set; }
    public PdfColor ForeColor { get; public set; }
    public float Width { get; public set; }
    public float Height { get; public set; }
    public PdfXfaTextElement(string text);
    public PdfXfaTextElement(string text, float width, float height);
    public PdfXfaTextElement(string text, PdfFont font);
    public PdfXfaTextElement(string text, PdfFont font, float width, float height);
    public PdfXfaHorizontalAlignment get_HorizontalAlignment();
    public void set_HorizontalAlignment(PdfXfaHorizontalAlignment value);
    public PdfXfaVerticalAlignment get_VerticalAlignment();
    public void set_VerticalAlignment(PdfXfaVerticalAlignment value);
    public string get_Text();
    public void set_Text(string value);
    public PdfXfaRotateAngle get_Rotate();
    public void set_Rotate(PdfXfaRotateAngle value);
    public PdfFont get_Font();
    public void set_Font(PdfFont value);
    public PdfColor get_ForeColor();
    public void set_ForeColor(PdfColor value);
    public void set_Width(float value);
    public float get_Width();
    public void set_Height(float value);
    public float get_Height();
    internal void Save(XfaWriter xfaWriter);
    internal void SaveAcroForm(PdfPage page, RectangleF bounds);
    private int GetRotationAngle();
    internal SizeF GetSize();
    public object Clone();
}
public enum Syncfusion.Pdf.Xfa.PdfXfaTimePattern : Enum {
    public int value__;
    public static PdfXfaTimePattern Default;
    public static PdfXfaTimePattern Short;
    public static PdfXfaTimePattern Medium;
    public static PdfXfaTimePattern Long;
    public static PdfXfaTimePattern Full;
    public static PdfXfaTimePattern H_MM_A;
    public static PdfXfaTimePattern H_MM_SS_A;
    public static PdfXfaTimePattern H_MM_SS_A_Z;
    public static PdfXfaTimePattern HH_MM_SS_A;
    public static PdfXfaTimePattern H_MM_SS;
    public static PdfXfaTimePattern HH_MM_SS;
}
public enum Syncfusion.Pdf.Xfa.PdfXfaType : Enum {
    public int value__;
    public static PdfXfaType Dynamic;
    public static PdfXfaType Static;
}
public enum Syncfusion.Pdf.Xfa.PdfXfaVerticalAlignment : Enum {
    public int value__;
    public static PdfXfaVerticalAlignment Top;
    public static PdfXfaVerticalAlignment Middle;
    public static PdfXfaVerticalAlignment Bottom;
}
public enum Syncfusion.Pdf.Xfa.PdfXfaVisibility : Enum {
    public int value__;
    public static PdfXfaVisibility Visible;
    public static PdfXfaVisibility Hidden;
    public static PdfXfaVisibility Inactive;
    public static PdfXfaVisibility Invisible;
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Syncfusion.Pdf.Xfa.XfaConstants : object {
    public static string Solid;
    public static string Dashed;
    public static string Dotted;
    public static string DashDot;
    public static string DashDotDot;
    public static string Lowered;
    public static string Raised;
    public static string Etched;
    public static string Embossed;
    public static string Center;
    public static string Justify;
    public static string JustifyAll;
    public static string Left;
    public static string Right;
    public static string Even;
    public static string Middle;
    public static string Top;
    public static string Bottom;
    public static string Hidden;
    public static string Visible;
    public static string Invisible;
    public static string Inactive;
    public static string Area;
    public static string Config;
    public static string Preamble;
    public static string Postamble;
    public static string Text;
    public static string Value;
    public static string Para;
    public static string Name;
    public static string ID;
    public static string Template;
    public static string SubForm;
    public static string Font;
    public static string PS;
    public static string PA;
    public static string CA;
    public static string Creator;
    public static string Producer;
    public static string FontInfo;
    public static string Version;
    public static string Caption;
    public static string Items;
    public static string Width;
    public static string Height;
    public static string MinHeight;
    public static string MinWidth;
    public static string MaxHeight;
    public static string MaxWidth;
    public static string LI;
    public static string RI;
    public static string TI;
    public static string BI;
    public static string UI;
    public static string Present;
    public static string Embed;
    public static string SM;
    public static string XFA;
    public static string Tagged;
    public static string Encryption;
    public static string Permissions;
    public static string AC;
    public static string CC;
    public static string FFF;
    public static string MA;
    public static string Print;
    public static string PHQ;
    public static string Change;
    public static string PTM;
    public static string Level;
    public static string CLS;
    public static string Linearized;
    public static string Acrobat;
    public static string Acrobat7;
    public static string DR;
    public static string Interactive;
    public static string DA;
    public static string DataSets;
    public static string Compression;
    public static string Stock;
    public static string Medium;
    public static string Layout;
    public static string lr_tb;
    public static string tb;
    public static string Field;
    public static string Margin;
    public static string Draw;
    public static string Line;
    public static string Edge;
    public static string Thick;
    public static string Slope;
    public static string AT;
    public static string IMG;
    public static string HREF;
    public static string Reserve;
    public static string Shape;
    public static string Mark;
    public static string Assist;
    public static string ToolTip;
    public static string Size;
    public static string CheckButton;
    public static string TextEdit;
    public static string ImageEdit;
    public static string Button;
    public static string Border;
    public static string Stroke;
    public static string Fill;
    public static string Color;
    public static string VAlign;
    public static string HAlign;
    public static string MultiLine;
    public static string ExclGroup;
    public static string ChoiceList;
    public static string DTE;
    public static string PasswordEdit;
    public static string PasswordChar;
    public static string Rotate;
    public static string ReadOnly;
    public static string Access;
    public static string Arc;
    public static string NumericEdit;
    public static string Rect;
    public static string Corner;
    public static string Radius;
    public static string Join;
    public static string Presence;
    public static string Radial;
    public static string Type;
    public static string Linear;
    public static string Integer;
    public static string Float;
    public static string Decimal;
    public static string Point;
    public static string MaxChars;
    public static string Comb;
    public static string XFAImages;
    public static string BreakBefore;
    public static string BreakAfter;
    public static string Break;
    public static string TargetType;
    public static string Target;
    public static string StartNew;
    public static string BeforeTarget;
    public static string AfterTarget;
    public static string Placement;
    public static string ExternalData;
    public static string TypeFace;
    public static string Weight;
    public static string Posture;
    public static string Linethrough;
    public static string UnderLine;
    public static string Hand;
    public static string Format;
    public static string Picture;
    public static string Date;
    public static string DateTime;
    public static string Time;
    public static string Aspect;
    public static string Open;
    public static string Keep;
    public static string Intact;
    public static string Locale;
    public static string X;
    public static string Y;
    public static string Short;
    public static string Long;
    public static string Orientation;
    public static string SubformSet;
    public static string ColumnWidths;
    public static string Bind;
    public static string Ref;
    public static char Separator;
    public static string Match;
    public static string Overflow;
    public static string RL_tb;
    public static string Row;
    public static string Table;
    public static string ContentType;
}
internal enum Syncfusion.Pdf.Xfa.XfaImageAspectRadio : Enum {
    public int value__;
    public static XfaImageAspectRadio Proportionally;
    public static XfaImageAspectRadio None;
    public static XfaImageAspectRadio Actual;
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Syncfusion.Pdf.Xfa.XfaWriter : object {
    private PdfXfaForm m_xfaForm;
    private XmlWriter m_writer;
    internal int m_fieldCount;
    internal int m_subFormFieldCount;
    private PdfXfaDocument xfaDocument;
    internal XmlWriter Write { get; internal set; }
    internal XmlWriter get_Write();
    internal void set_Write(XmlWriter value);
    internal PdfStream WriteDocumentTemplate(PdfXfaForm XfaForm);
    internal PdfStream WritePreamble();
    internal void StartDataSets(XmlWriter dataWriter);
    internal void EndDataSets(XmlWriter dataWriter);
    internal PdfStream WritePostable();
    internal PdfStream WriteConfig();
    internal void WriteUI(string name, Dictionary`2<string, string> values, PdfXfaBorder border);
    internal void WriteUI(string name, Dictionary`2<string, string> values, PdfXfaBorder border, PdfPaddings padding);
    internal void WriteUI(string name, Dictionary`2<string, string> values, PdfXfaBorder border, int comb);
    internal void WriteUI(string name, Dictionary`2<string, string> values, PdfXfaBorder border, int comb, PdfPaddings padding);
    internal void WriteValue(string text, int maxChar);
    internal void WriteValue(string text, string value, int maxChar);
    internal void WriteMargins(float l, float r, float b, float t);
    internal void WriteMargins(PdfMargins margins);
    internal void WriteFontInfo(PdfFont font, PdfColor foreColor);
    private void WriteFontInfo(string name, float size, PdfFontStyle style, PdfColor fillColor);
    internal void SetSize(float fixedHeight, float fixedWidth, float minHeight, float minWidth);
    internal void SetSize(float fixedHeight, float fixedWidth, float minHeight, float minWidth, float maxHeight, float maxWidth);
    internal void DrawLine(float thickness, string slope, string color);
    internal void WriteCaption(string text, float reserve, PdfXfaHorizontalAlignment hAlign, PdfXfaVerticalAlignment vAligh);
    internal void WriteItems(string text);
    internal void WriteItems(string rollOver, string down);
    internal void WriteListItems(List`1<string> list, string saveString);
    internal void WriteToolTip(string text);
    internal void DrawFillColor(PdfColor fillColor);
    internal void WriteLocation(PointF location);
    internal void WritePragraph(PdfXfaVerticalAlignment vAlign, PdfXfaHorizontalAlignment hAlign);
    internal void WritePattern(string value, bool isvalidate);
    internal void DrawBorder(PdfXfaBorder border, bool isSkip);
    internal void DrawBorder(PdfXfaBorder border);
    internal void DrawBorder(PdfXfaBorder border, PdfXfaBrush fillColor);
    internal void DrawEdge(PdfXfaEdge edge);
    internal void DrawCorner(PdfXfaCorner corner);
    internal void DrawColor(PdfColor color);
    private void DrawStroke(PdfXfaBorderStyle style);
    internal void DrawFillColor(PdfXfaBrush fill);
    internal void DrawRadialBrush(PdfXfaRadialBrush rBrush);
    internal void DrawLinearBrush(PdfXfaLinearBrush lBrush);
    internal void SetRPR(PdfXfaRotateAngle rotation, PdfXfaVisibility presence, bool isReadOnly);
    internal string GetDatePattern(PdfXfaDatePattern pattern);
    internal string GetTimePattern(PdfXfaTimePattern pattern);
    internal string GetDateTimePattern(PdfXfaDatePattern d, PdfXfaTimePattern t);
    internal string GetDatePattern(string pattern);
    internal string GetTimePattern(string pattern);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class Syncfusion.Pdf.Xmp.BasicJobTicketSchema : XmpSchema {
    private static string c_prefix;
    private static string c_name;
    private static string c_propJobRef;
    public XmpSchemaType SchemaType { get; }
    protected string Name { get; }
    protected string Prefix { get; }
    public XmpArray JobRef { get; }
    protected internal BasicJobTicketSchema(XmpMetadata xmp);
    public virtual XmpSchemaType get_SchemaType();
    protected virtual string get_Name();
    protected virtual string get_Prefix();
    public XmpArray get_JobRef();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class Syncfusion.Pdf.Xmp.BasicSchema : XmpSchema {
    private static string c_prefix;
    private static string c_name;
    private static string c_propAdvisory;
    private static string c_propIdentifier;
    private static string c_propLabel;
    private static string c_propNickname;
    private static string c_propBaseUrl;
    private static string c_propCreatorTool;
    private static string c_propCreateData;
    private static string c_propMetadataDate;
    private static string c_propModifyDate;
    private static string c_propThumbnail;
    private static string c_propRating;
    internal bool m_externalCreationDate;
    internal bool m_externalModifyDate;
    public XmpSchemaType SchemaType { get; }
    protected string Name { get; }
    protected string Prefix { get; }
    public XmpArray Advisory { get; }
    public XmpArray Identifier { get; }
    public string Label { get; public set; }
    public string Nickname { get; public set; }
    public Uri BaseURL { get; public set; }
    public string CreatorTool { get; public set; }
    public DateTime CreateDate { get; public set; }
    public DateTime MetadataDate { get; public set; }
    public DateTime ModifyDate { get; public set; }
    public XmpArray Thumbnails { get; }
    public XmpArray Rating { get; }
    protected internal BasicSchema(XmpMetadata xmp);
    public virtual XmpSchemaType get_SchemaType();
    protected virtual string get_Name();
    protected virtual string get_Prefix();
    public XmpArray get_Advisory();
    public XmpArray get_Identifier();
    public string get_Label();
    public void set_Label(string value);
    public string get_Nickname();
    public void set_Nickname(string value);
    public Uri get_BaseURL();
    public void set_BaseURL(Uri value);
    public string get_CreatorTool();
    public void set_CreatorTool(string value);
    public DateTime get_CreateDate();
    public void set_CreateDate(DateTime value);
    public DateTime get_MetadataDate();
    public void set_MetadataDate(DateTime value);
    public DateTime get_ModifyDate();
    public void set_ModifyDate(DateTime value);
    public XmpArray get_Thumbnails();
    public XmpArray get_Rating();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[DefaultMemberAttribute("Item")]
public class Syncfusion.Pdf.Xmp.CustomSchema : XmpSchema {
    private string m_namespace;
    private string m_namespaceUri;
    private Dictionary`2<string, string> m_customdata;
    internal XmpMetadata m_Xmp;
    public string Item { get; public set; }
    internal Dictionary`2<string, string> CustomData { get; internal set; }
    public XmpSchemaType SchemaType { get; }
    protected string Prefix { get; }
    protected string Name { get; }
    public CustomSchema(XmpMetadata xmp, string xmlNamespace, string namespaceUri);
    public string get_Item(string name);
    public void set_Item(string name, string value);
    internal Dictionary`2<string, string> get_CustomData();
    internal void set_CustomData(Dictionary`2<string, string> value);
    internal bool ContainsKey(string key);
    public virtual XmpSchemaType get_SchemaType();
    protected virtual string get_Prefix();
    protected virtual string get_Name();
    protected virtual XElement GetEntityXml();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class Syncfusion.Pdf.Xmp.DublinCoreSchema : XmpSchema {
    private static string c_prefix;
    private static string c_name;
    private static string c_coverage;
    private static string c_identifier;
    private static string c_format;
    private static string c_source;
    private static string c_subject;
    private static string c_type;
    private static string c_contributor;
    private static string c_creator;
    private static string c_date;
    private static string c_publisher;
    private static string c_relation;
    private static string c_description;
    private static string c_rights;
    private static string c_title;
    private static string c_mimeType;
    public XmpSchemaType SchemaType { get; }
    protected string Name { get; }
    protected string Prefix { get; }
    public XmpArray Contributor { get; }
    public string Coverage { get; public set; }
    public XmpArray Creator { get; }
    public XmpArray Date { get; }
    public XmpLangArray Description { get; }
    public string Identifier { get; public set; }
    public XmpArray Publisher { get; }
    public XmpArray Relation { get; }
    public XmpLangArray Rights { get; }
    public string Source { get; public set; }
    public XmpArray Sublect { get; }
    public XmpLangArray Title { get; }
    public XmpArray Type { get; }
    protected internal DublinCoreSchema(XmpMetadata xmp);
    public virtual XmpSchemaType get_SchemaType();
    protected virtual string get_Name();
    protected virtual string get_Prefix();
    public XmpArray get_Contributor();
    public string get_Coverage();
    public void set_Coverage(string value);
    public XmpArray get_Creator();
    public XmpArray get_Date();
    public XmpLangArray get_Description();
    public string get_Identifier();
    public void set_Identifier(string value);
    public XmpArray get_Publisher();
    public XmpArray get_Relation();
    public XmpLangArray get_Rights();
    public string get_Source();
    public void set_Source(string value);
    public XmpArray get_Sublect();
    public XmpLangArray get_Title();
    public XmpArray get_Type();
    protected virtual void CreateEntity();
}
internal class Syncfusion.Pdf.Xmp.NamespaceDoc : object {
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class Syncfusion.Pdf.Xmp.PagedTextSchema : XmpSchema {
    private static string c_prefix;
    private static string c_name;
    private static string c_NPages;
    private static string c_Fonts;
    private static string c_PlateName;
    private static string c_Colorants;
    private static string c_MaxPageSize;
    public XmpSchemaType SchemaType { get; }
    protected string Name { get; }
    protected string Prefix { get; }
    public XmpDimensionsStruct MaxPageSize { get; }
    public int NPages { get; public set; }
    public XmpArray Fonts { get; }
    public XmpArray PlateNames { get; }
    public XmpArray Colorants { get; }
    protected internal PagedTextSchema(XmpMetadata xmp);
    public virtual XmpSchemaType get_SchemaType();
    protected virtual string get_Name();
    protected virtual string get_Prefix();
    public XmpDimensionsStruct get_MaxPageSize();
    public int get_NPages();
    public void set_NPages(int value);
    public XmpArray get_Fonts();
    public XmpArray get_PlateNames();
    public XmpArray get_Colorants();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class Syncfusion.Pdf.Xmp.PDFSchema : XmpSchema {
    private static string c_prefix;
    private static string c_name;
    private static string c_Keywords;
    private static string c_PDFVersion;
    private static string c_Producer;
    public XmpSchemaType SchemaType { get; }
    protected string Name { get; }
    protected string Prefix { get; }
    public string Keywords { get; public set; }
    public string PDFVersion { get; public set; }
    public string Producer { get; public set; }
    protected internal PDFSchema(XmpMetadata xmp);
    public virtual XmpSchemaType get_SchemaType();
    protected virtual string get_Name();
    protected virtual string get_Prefix();
    public string get_Keywords();
    public void set_Keywords(string value);
    public string get_PDFVersion();
    public void set_PDFVersion(string value);
    public string get_Producer();
    public void set_Producer(string value);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class Syncfusion.Pdf.Xmp.RightsManagementSchema : XmpSchema {
    private static string c_prefix;
    private static string c_name;
    private static string c_Certificate;
    private static string c_Marked;
    private static string c_Owner;
    private static string c_UsageTerms;
    private static string c_WebStatement;
    public XmpSchemaType SchemaType { get; }
    protected string Name { get; }
    protected string Prefix { get; }
    public Uri Certificate { get; public set; }
    public bool Marked { get; public set; }
    public XmpArray Owner { get; }
    public XmpLangArray UsageTerms { get; }
    public Uri WebStatement { get; public set; }
    protected internal RightsManagementSchema(XmpMetadata xmp);
    public virtual XmpSchemaType get_SchemaType();
    protected virtual string get_Name();
    protected virtual string get_Prefix();
    public Uri get_Certificate();
    public void set_Certificate(Uri value);
    public bool get_Marked();
    public void set_Marked(bool value);
    public XmpArray get_Owner();
    public XmpLangArray get_UsageTerms();
    public Uri get_WebStatement();
    public void set_WebStatement(Uri value);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class Syncfusion.Pdf.Xmp.XmpArray : XmpCollection {
    internal static string c_dateFormat;
    private XmpArrayType _mArrayType;
    public String[] Items { get; }
    protected XmpArrayType ArrayType { get; }
    internal XmpArray(XmpMetadata xmp, XNode parent, string prefix, string localName, string namespaceURI, XmpArrayType type);
    public String[] get_Items();
    protected virtual XmpArrayType get_ArrayType();
    public void Add(string value);
    public void Add(int value);
    public void Add(float value);
    public void Add(DateTime value);
    public void Add(DateTime value, string format);
    public void Add(XmpStructure structure);
    private XElement CreateItem();
    private String[] GetArrayValues();
    private void ChangeParent(XNode parent, XmpEntityBase entity);
}
public enum Syncfusion.Pdf.Xmp.XmpArrayType : Enum {
    public int value__;
    public static XmpArrayType Unknown;
    public static XmpArrayType Bag;
    public static XmpArrayType Seq;
    public static XmpArrayType Alt;
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public abstract class Syncfusion.Pdf.Xmp.XmpCollection : XmpType {
    protected static string c_itemName;
    public int Count { get; }
    protected XmpArrayType ArrayType { get; }
    protected XElement ItemsContainer { get; }
    internal XmpCollection(XmpMetadata xmp, XNode parent, string prefix, string localName, string namespaceURI);
    public int get_Count();
    protected abstract virtual XmpArrayType get_ArrayType();
    protected XElement get_ItemsContainer();
    protected virtual void CreateEntity();
    protected IEnumerable`1<XElement> GetArrayItems();
    private string GetArrayName();
    private int GetItemsCount();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class Syncfusion.Pdf.Xmp.XmpColorantStruct : XmpStructure {
    private static string c_prefix;
    private static string c_name;
    private static string c_swatchName;
    private static string c_mode;
    private static string c_type;
    private static string c_cyan;
    private static string c_magenta;
    private static string c_black;
    private static string c_red;
    private static string c_green;
    private static string c_blue;
    private static string c_L;
    private static string c_A;
    private static string c_B;
    private static string c_yellow;
    protected string StructurePrefix { get; }
    protected string StructureURI { get; }
    public float Yellow { get; public set; }
    public float B { get; public set; }
    public float A { get; public set; }
    public float L { get; public set; }
    public float Blue { get; public set; }
    public float Green { get; public set; }
    public float Red { get; public set; }
    public float Black { get; public set; }
    public float Magenta { get; public set; }
    public float Cyan { get; public set; }
    public string Type { get; public set; }
    public string Mode { get; public set; }
    public string SwatchName { get; public set; }
    internal XmpColorantStruct(XmpMetadata xmp, XNode parent, string prefix, string localName, string namespaceURI, bool insideArray);
    protected virtual string get_StructurePrefix();
    protected virtual string get_StructureURI();
    public float get_Yellow();
    public void set_Yellow(float value);
    public float get_B();
    public void set_B(float value);
    public float get_A();
    public void set_A(float value);
    public float get_L();
    public void set_L(float value);
    public float get_Blue();
    public void set_Blue(float value);
    public float get_Green();
    public void set_Green(float value);
    public float get_Red();
    public void set_Red(float value);
    public float get_Black();
    public void set_Black(float value);
    public float get_Magenta();
    public void set_Magenta(float value);
    public float get_Cyan();
    public void set_Cyan(float value);
    public string get_Type();
    public void set_Type(string value);
    public string get_Mode();
    public void set_Mode(string value);
    public string get_SwatchName();
    public void set_SwatchName(string value);
    protected virtual void InitializeEntities();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class Syncfusion.Pdf.Xmp.XmpDimensionsStruct : XmpStructure {
    private static string c_prefix;
    private static string c_name;
    private static string c_width;
    private static string c_height;
    private static string c_unit;
    public float Width { get; public set; }
    public float Height { get; public set; }
    public string Unit { get; public set; }
    protected string StructurePrefix { get; }
    protected string StructureURI { get; }
    internal XmpDimensionsStruct(XmpMetadata xmp, XNode parent, string prefix, string localName, string namespaceURI, bool insideArray);
    public float get_Width();
    public void set_Width(float value);
    public float get_Height();
    public void set_Height(float value);
    public string get_Unit();
    public void set_Unit(string value);
    protected virtual string get_StructurePrefix();
    protected virtual string get_StructureURI();
    protected virtual void InitializeEntities();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public abstract class Syncfusion.Pdf.Xmp.XmpEntityBase : object {
    private XElement m_xmlParent;
    private string m_entityPrefix;
    private string m_localName;
    private string m_namespaceURI;
    public XElement XmlData { get; }
    protected internal bool Exists { get; }
    protected internal XElement EntityParent { get; }
    protected internal string EntityPrefix { get; }
    protected internal string EntityName { get; }
    protected internal string EntityNamespaceURI { get; }
    protected bool SuspendInitialization { get; }
    protected internal XmpEntityBase(XNode parent, string prefix, string localName, string namespaceURI);
    public XElement get_XmlData();
    protected internal bool get_Exists();
    protected internal XElement get_EntityParent();
    protected internal string get_EntityPrefix();
    protected internal string get_EntityName();
    protected internal string get_EntityNamespaceURI();
    protected bool get_SuspendInitialization();
    protected virtual void Initialize();
    protected virtual bool CheckIfExists();
    protected virtual bool GetSuspend();
    protected abstract virtual void CreateEntity();
    protected abstract virtual XElement GetEntityXml();
    internal void SetXmlParent(XNode parent);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class Syncfusion.Pdf.Xmp.XmpFontStruct : XmpStructure {
    private static string c_prefix;
    private static string c_name;
    private static string c_fontName;
    private static string c_fontFamily;
    private static string c_fontFace;
    private static string c_fontType;
    private static string c_versionString;
    private static string c_composite;
    private static string c_fontFileName;
    private static string c_childFontFiles;
    protected string StructurePrefix { get; }
    protected string StructureURI { get; }
    public string FontName { get; public set; }
    public string FontFamily { get; public set; }
    public string FontFace { get; public set; }
    public string FontType { get; public set; }
    public string VersionString { get; public set; }
    public bool Composite { get; public set; }
    public string FontFileName { get; public set; }
    public XmpArray ChildFontFiles { get; }
    internal XmpFontStruct(XmpMetadata xmp, XNode parent, string prefix, string localName, string namespaceURI, bool insideArray);
    protected virtual string get_StructurePrefix();
    protected virtual string get_StructureURI();
    public string get_FontName();
    public void set_FontName(string value);
    public string get_FontFamily();
    public void set_FontFamily(string value);
    public string get_FontFace();
    public void set_FontFace(string value);
    public string get_FontType();
    public void set_FontType(string value);
    public string get_VersionString();
    public void set_VersionString(string value);
    public bool get_Composite();
    public void set_Composite(bool value);
    public string get_FontFileName();
    public void set_FontFileName(string value);
    public XmpArray get_ChildFontFiles();
    protected virtual void InitializeEntities();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class Syncfusion.Pdf.Xmp.XmpJobStruct : XmpStructure {
    private static string c_prefix;
    private static string c_structName;
    private static string c_name;
    private static string c_id;
    private static string c_url;
    public string Name { get; public set; }
    public string ID { get; public set; }
    public Uri Url { get; public set; }
    protected string StructurePrefix { get; }
    protected string StructureURI { get; }
    internal XmpJobStruct(XmpMetadata xmp, XNode parent, string prefix, string localName, string namespaceURI, bool insideArray);
    public string get_Name();
    public void set_Name(string value);
    public string get_ID();
    public void set_ID(string value);
    public Uri get_Url();
    public void set_Url(Uri value);
    protected virtual string get_StructurePrefix();
    protected virtual string get_StructureURI();
    protected virtual void InitializeEntities();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[DefaultMemberAttribute("Item")]
public class Syncfusion.Pdf.Xmp.XmpLangArray : XmpCollection {
    private static string c_langName;
    private static string c_langAttribute;
    public string DefaultText { get; public set; }
    public string Item { get; public set; }
    protected XmpArrayType ArrayType { get; }
    internal XmpLangArray(XmpMetadata xmp, XNode parent, string prefix, string localName, string namespaceURI);
    public string get_DefaultText();
    public void set_DefaultText(string value);
    public string get_Item(string lang);
    public void set_Item(string lang, string value);
    protected virtual XmpArrayType get_ArrayType();
    public void Add(string lang, string value);
    protected virtual void CreateEntity();
    private XElement CreateItem(string lang);
    private XElement GetItem(string lang);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class Syncfusion.Pdf.Xmp.XmpMetadata : object {
    protected internal static string c_xpathRdf;
    protected internal static string c_xmlnsUri;
    protected internal static string c_xmlUri;
    protected internal static string c_rdfPrefix;
    protected internal static string c_customSchema;
    protected internal static string c_xmlnsPrefix;
    protected internal static string c_xmlPefix;
    protected internal static string c_rdfUri;
    private static string c_startPacket;
    private static string c_xmpMetaUri;
    private static string c_endPacket;
    protected internal static string c_rdfPdfa;
    protected internal static string c_xap;
    protected internal static string c_pdfschema;
    protected internal static string c_dublinSchema;
    private static string c_zugferd1_0;
    private static string c_zugferd2_0;
    private static string c_zugferd2_1;
    private static string c_pdfaExtension;
    private static string c_pdfaProperty;
    private static string c_pdfaSchema;
    private static string c_rdfPdfua;
    private XDocument m_xmlDocument;
    private XmlNamespaceManager m_nmpManager;
    private DublinCoreSchema m_dublinCoreSchema;
    private PagedTextSchema m_pagedTextSchemaSchema;
    private BasicJobTicketSchema m_basicJobTicketSchema;
    private BasicSchema m_basicSchema;
    private RightsManagementSchema m_rightsManagementSchema;
    private PDFSchema m_pdfSchema;
    private CustomSchema m_customSchema;
    private PdfStream m_stream;
    internal bool isLoadedDocument;
    private PdfDocumentInformation m_documentInfo;
    internal bool m_hasAttributes;
    public XDocument XmlData { get; }
    internal PdfStream XmpStream { get; }
    public XmlNamespaceManager NamespaceManager { get; }
    internal PdfDocumentInformation DocumentInfo { get; internal set; }
    public DublinCoreSchema DublinCoreSchema { get; }
    public PagedTextSchema PagedTextSchema { get; }
    public BasicJobTicketSchema BasicJobTicketSchema { get; }
    public BasicSchema BasicSchema { get; }
    public RightsManagementSchema RightsManagementSchema { get; }
    public PDFSchema PDFSchema { get; }
    internal CustomSchema CustomSchema { get; }
    internal XElement Xmpmeta { get; }
    internal XElement Rdf { get; }
    private IPdfPrimitive Syncfusion.Pdf.IPdfWrapper.Element { get; }
    public XmpMetadata(PdfDocumentInformation documentInfo);
    public XmpMetadata(XDocument xmp);
    public XDocument get_XmlData();
    internal PdfStream get_XmpStream();
    public XmlNamespaceManager get_NamespaceManager();
    internal PdfDocumentInformation get_DocumentInfo();
    internal void set_DocumentInfo(PdfDocumentInformation value);
    public DublinCoreSchema get_DublinCoreSchema();
    public PagedTextSchema get_PagedTextSchema();
    public BasicJobTicketSchema get_BasicJobTicketSchema();
    public BasicSchema get_BasicSchema();
    public RightsManagementSchema get_RightsManagementSchema();
    public PDFSchema get_PDFSchema();
    internal CustomSchema get_CustomSchema();
    internal XElement get_Xmpmeta();
    internal XElement get_Rdf();
    public void Load(XDocument xmp);
    public void Add(XElement schema);
    private void Init(PdfDocumentInformation documentInfo);
    private void InitStream();
    private void CreateStartPacket();
    private void CreateXmpmeta();
    private void CreateRdf(PdfDocumentInformation documentInfo);
    private void AddZugferdConformance(XElement rdf, XElement pdfA, XNamespace xNamespace, PdfDocumentInformation documentInfo);
    private XElement CreateConformanceElement(PdfConformanceLevel conformance, XNamespace xNamespace);
    private void CreateUAConformanceElement(XElement rdf, XNamespace xNamespace);
    private void AddPdfUAConformance(XElement rdf, XNamespace xNamespace, PdfDocumentInformation documentInfo);
    private void CreateDublinCoreContainer(XElement dublinDesc, string containerName, string value, bool defaultLang, XmpArrayType element);
    private void CreateEndPacket();
    private void Reset();
    private void ImportNamespaces(XElement elm, XmlNamespaceManager nsm);
    private string GetDateTime(DateTime dateTime);
    internal XElement CreateElement(string name);
    internal XElement CreateElement(XNamespace prefix, string localName, string namespaceURI);
    internal XAttribute CreateAttribute(XNamespace name, string value);
    internal XAttribute CreateAttribute(XNamespace prefix, string localName, string namespaceURI, string value);
    internal string AddNamespace(string prefix, string namespaceURI);
    private sealed virtual override IPdfPrimitive Syncfusion.Pdf.IPdfWrapper.get_Element();
    private void BeginSave(object sender, SavePdfPrimitiveEventArgs ars);
    private void EndSave(object sender, SavePdfPrimitiveEventArgs ars);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public abstract class Syncfusion.Pdf.Xmp.XmpSchema : XmpEntityBase {
    internal static string c_schemaTagName;
    private static string c_xPathDescription;
    private XmpMetadata m_xmp;
    private Dictionary`2<string, object> m_properties;
    public XmpSchemaType SchemaType { get; }
    protected string Prefix { get; }
    protected string Name { get; }
    protected internal XmpMetadata Xmp { get; }
    protected internal XmpSchema(XmpMetadata xmp);
    public abstract virtual XmpSchemaType get_SchemaType();
    protected abstract virtual string get_Prefix();
    protected abstract virtual string get_Name();
    protected internal XmpMetadata get_Xmp();
    protected virtual void CreateEntity();
    protected virtual XElement GetEntityXml();
    protected XmpSimpleType CreateSimpleProperty(string name);
    protected XmpSimpleType GetSimpleProperty(string name);
    protected XmpArray CreateArray(string name, XmpArrayType arrayType);
    protected XmpArray GetArray(string name, XmpArrayType arrayType);
    protected XmpLangArray CreateLangArray(string name);
    protected XmpLangArray GetLangArray(string name);
    protected XmpStructure GetStructure(string name, XmpStructureType type);
    protected XmpStructure CreateStructure(string name, XmpStructureType type);
    public XmpStructure CreateStructure(XmpStructureType type);
}
public enum Syncfusion.Pdf.Xmp.XmpSchemaType : Enum {
    public int value__;
    public static XmpSchemaType DublinCoreSchema;
    public static XmpSchemaType BasicSchema;
    public static XmpSchemaType RightsManagementSchema;
    public static XmpSchemaType BasicJobTicketSchema;
    public static XmpSchemaType PagedTextSchema;
    public static XmpSchemaType PDFSchema;
    public static XmpSchemaType Custom;
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class Syncfusion.Pdf.Xmp.XmpSimpleType : XmpType {
    public string Value { get; public set; }
    internal XmpSimpleType(XmpMetadata xmp, XNode parent, string prefix, string localName, string namespaceURI);
    public string get_Value();
    public void set_Value(string value);
    protected internal void SetBool(bool value);
    protected internal bool GetBool();
    protected internal void SetReal(float value);
    protected internal float GetReal();
    protected internal void SetInt(int value);
    protected internal int GetInt();
    protected internal void SetUri(Uri value);
    protected internal Uri GetUri();
    protected internal void SetDateTime(DateTime value);
    protected internal DateTime GetDateTime();
    protected virtual void CreateEntity();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public abstract class Syncfusion.Pdf.Xmp.XmpStructure : XmpType {
    private Dictionary`2<string, object> m_properties;
    private bool m_bInsideArray;
    private bool _mBSuspend;
    private bool m_bInitialized;
    protected internal XElement InnerXmlData { get; }
    protected string StructurePrefix { get; }
    protected string StructureURI { get; }
    internal XmpStructure(XmpMetadata xmp, XNode parent, string prefix, string localName, string namespaceURI);
    internal XmpStructure(XmpMetadata xmp, XNode parent, string prefix, string localName, string namespaceURI, bool insideArray);
    protected internal XElement get_InnerXmlData();
    protected abstract virtual string get_StructurePrefix();
    protected abstract virtual string get_StructureURI();
    protected virtual void CreateEntity();
    protected virtual XElement GetEntityXml();
    protected virtual bool GetSuspend();
    protected virtual bool CheckIfExists();
    protected abstract virtual void InitializeEntities();
    protected XmpSimpleType CreateSimpleProperty(string name);
    protected XmpSimpleType GetSimpleProperty(string name);
    protected XmpSimpleType CreateSimpleProperty(string name, XNode parent);
    protected XmpSimpleType GetSimpleProperty(string name, XNode parent);
    protected XmpArray CreateArray(string name, XmpArrayType arrayType);
    protected XmpArray GetArray(string name, XmpArrayType arrayType);
    protected void CreateStructureContent();
    private XElement GetDescriptionElement();
    private XElement GetContentParent();
}
public enum Syncfusion.Pdf.Xmp.XmpStructureType : Enum {
    public int value__;
    public static XmpStructureType Dimensions;
    public static XmpStructureType Font;
    public static XmpStructureType Colorant;
    public static XmpStructureType Thumbnail;
    public static XmpStructureType Job;
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class Syncfusion.Pdf.Xmp.XmpThumbnailStruct : XmpStructure {
    private static string c_prefix;
    private static string c_name;
    private static string c_height;
    private static string c_width;
    private static string c_format;
    private static string c_image;
    protected string StructurePrefix { get; }
    protected string StructureURI { get; }
    public float Height { get; public set; }
    public float Width { get; public set; }
    public string Format { get; public set; }
    public Byte[] Image { get; public set; }
    internal XmpThumbnailStruct(XmpMetadata xmp, XNode parent, string prefix, string localName, string namespaceURI, bool insideArray);
    protected virtual string get_StructurePrefix();
    protected virtual string get_StructureURI();
    public float get_Height();
    public void set_Height(float value);
    public float get_Width();
    public void set_Width(float value);
    public string get_Format();
    public void set_Format(string value);
    public Byte[] get_Image();
    public void set_Image(Byte[] value);
    protected virtual void InitializeEntities();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public abstract class Syncfusion.Pdf.Xmp.XmpType : XmpEntityBase {
    private XmpMetadata m_xmp;
    protected internal XmpMetadata Xmp { get; }
    internal XmpType(XmpMetadata xmp, XNode parent, string prefix, string localName, string namespaceURI);
    protected internal XmpMetadata get_Xmp();
    protected virtual XElement GetEntityXml();
    protected virtual void CreateEntity();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Syncfusion.Pdf.Xmp.XmpUtils : object {
    private static string c_False;
    private static string c_True;
    private static string c_realPattern;
    private static string c_dateFormat;
    public static void SetTextValue(XElement parent, string value);
    public static void SetBoolValue(XElement parent, bool value);
    public static bool GetBoolValue(string value);
    public static void SetRealValue(XElement parent, float value);
    public static float GetRealValue(string value);
    public static void SetIntValue(XElement parent, int value);
    public static int GetIntValue(string value);
    public static void SetUriValue(XElement parent, Uri value);
    public static Uri GetUriValue(string value);
    public static void SetDateTimeValue(XElement parent, DateTime value);
    public static DateTime GetDateTimeValue(string value);
    public static void SetXmlValue(XElement parent, XElement child);
    private static void ClearChildren(XNode node);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Syncfusion.Pdf.XObjectElement : object {
    private string m_objectName;
    private string m_objectType;
    private PdfMatrix m_imageInfo;
    private PdfDictionary m_xObjectDictionary;
    private bool m_isExtractTextData;
    private bool m_isExtractLineCollection;
    internal bool IsPdfium;
    internal bool isExportAsImage;
    internal List`1<TextElement> m_extractTextElement;
    internal bool m_isPrintSelected;
    internal double m_pageHeight;
    internal bool IsExtractTextData { get; internal set; }
    internal bool IsExtractLineCollection { get; internal set; }
    internal List`1<TextElement> ExtractTextElements { get; internal set; }
    internal string ObjectName { get; internal set; }
    internal PdfMatrix ImageInfo { get; internal set; }
    internal PdfDictionary XObjectDictionary { get; internal set; }
    internal string ObjectType { get; internal set; }
    public XObjectElement(PdfDictionary xobjectDictionary, string name);
    public XObjectElement(PdfDictionary xobjectDictionary, string name, PdfMatrix tm);
    internal bool get_IsExtractTextData();
    internal void set_IsExtractTextData(bool value);
    internal bool get_IsExtractLineCollection();
    internal void set_IsExtractLineCollection(bool value);
    internal List`1<TextElement> get_ExtractTextElements();
    internal void set_ExtractTextElements(List`1<TextElement> value);
    internal string get_ObjectName();
    internal void set_ObjectName(string value);
    internal PdfMatrix get_ImageInfo();
    internal void set_ImageInfo(PdfMatrix value);
    internal PdfDictionary get_XObjectDictionary();
    internal void set_XObjectDictionary(PdfDictionary value);
    internal string get_ObjectType();
    internal void set_ObjectType(string value);
    public PdfRecordCollection Render(PdfPageResources resources);
    public Stack`1<GraphicsState> Render(GraphicsObject g, PdfPageResources resources, Stack`1<GraphicsState> graphicsStates, Stack`1<GraphicObjectData> m_objects, float currentPageHeight, List`1& glyphList);
    private void GetObjectType();
}
public enum Syncfusion.Pdf.ZugferdConformanceLevel : Enum {
    public int value__;
    public static ZugferdConformanceLevel None;
    public static ZugferdConformanceLevel Basic;
    public static ZugferdConformanceLevel Comfort;
    public static ZugferdConformanceLevel Extended;
    public static ZugferdConformanceLevel Minimum;
    public static ZugferdConformanceLevel EN16931;
    public static ZugferdConformanceLevel Basic_WL;
}
public enum Syncfusion.Pdf.ZugferdVersion : Enum {
    public int value__;
    public static ZugferdVersion ZugferdVersion1_0;
    public static ZugferdVersion ZugferdVersion2_0;
    public static ZugferdVersion ZugferdVersion2_1;
}
internal class Syncfusion.PdfViewer.Base.Array : PostScriptOperators {
    [NullableContextAttribute("1")]
public virtual void Execute(FontInterpreter interpreter);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Syncfusion.PdfViewer.Base.BaseType1Font : PostScriptObj {
    private CharacterBuilder buildChar;
    private Dictionary`2<string, GlyphInfo> glyphOutlines;
    private KeyProperty`1<PostScriptArray> fontMatrix;
    private KeyProperty`1<FontData> fontInfo;
    private KeyProperty`1<PostScriptArray> encoding;
    private KeyProperty`1<PostScriptDict> charStrings;
    private KeyProperty`1<KeyPrivate> priv;
    private object SyncObj;
    public PostScriptArray FontMatrix { get; }
    public FontData FontInfo { get; }
    public PostScriptArray Encoding { get; }
    public PostScriptDict CharStrings { get; }
    public KeyPrivate Private { get; }
    public PostScriptArray get_FontMatrix();
    public FontData get_FontInfo();
    public PostScriptArray get_Encoding();
    public PostScriptDict get_CharStrings();
    public KeyPrivate get_Private();
    public ushort GetAdvancedWidth(Glyph glyph);
    public void GetGlyphOutlines(Glyph glyph, double fontSize);
    public sealed virtual GlyphInfo GetGlyphData(string name);
    public sealed virtual Byte[] GetSubr(int index);
    public sealed virtual Byte[] GetGlobalSubr(int index);
    internal string GetGlyphName(ushort cid);
    private GlyphInfo ReadGlyphData(string name);
}
internal class Syncfusion.PdfViewer.Base.Begin : PostScriptOperators {
    [NullableContextAttribute("1")]
public virtual void Execute(FontInterpreter interpreter);
}
internal class Syncfusion.PdfViewer.Base.BezierSegment : PathSegment {
    [CompilerGeneratedAttribute]
private Point <Point1>k__BackingField;
    [CompilerGeneratedAttribute]
private Point <Point2>k__BackingField;
    [CompilerGeneratedAttribute]
private Point <Point3>k__BackingField;
    public Point Point1 { get; public set; }
    public Point Point2 { get; public set; }
    public Point Point3 { get; public set; }
    [CompilerGeneratedAttribute]
public Point get_Point1();
    [CompilerGeneratedAttribute]
public void set_Point1(Point value);
    [CompilerGeneratedAttribute]
public Point get_Point2();
    [CompilerGeneratedAttribute]
public void set_Point2(Point value);
    [CompilerGeneratedAttribute]
public Point get_Point3();
    [CompilerGeneratedAttribute]
public void set_Point3(Point value);
    [NullableContextAttribute("1")]
public virtual PathSegment Clone();
    public virtual void Transform(Matrix transformMatrix);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal static class Syncfusion.PdfViewer.Base.BitsAssistant : object {
    internal static bool GetBit(int n, byte bit);
    internal static Byte[] GetBits(byte bt);
    internal static byte ToByte(Byte[] bits, int offset, int count);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Syncfusion.PdfViewer.Base.BlankEnumerable`1 : object {
    private static TElement[] instance;
    public static IEnumerable`1<TElement> Instance { get; }
    public static IEnumerable`1<TElement> get_Instance();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Syncfusion.PdfViewer.Base.Buffer`1 : ValueType {
    internal TElement[] items;
    internal int count;
    internal Buffer`1(IEnumerable`1<TElement> source);
    internal TElement[] ToArray();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal abstract class Syncfusion.PdfViewer.Base.ByteEncodingBase : object {
    private PdfRangeCalculator range;
    [CompilerGeneratedAttribute]
private static ByteEncodingCollectionBase <DictByteEncodings>k__BackingField;
    [CompilerGeneratedAttribute]
private static ByteEncodingCollectionBase <CharStringByteEncodings>k__BackingField;
    public static ByteEncodingCollectionBase DictByteEncodings { get; private set; }
    public static ByteEncodingCollectionBase CharStringByteEncodings { get; private set; }
    private static ByteEncodingBase();
    public ByteEncodingBase(byte start, byte end);
    [CompilerGeneratedAttribute]
public static ByteEncodingCollectionBase get_DictByteEncodings();
    [CompilerGeneratedAttribute]
private static void set_DictByteEncodings(ByteEncodingCollectionBase value);
    [CompilerGeneratedAttribute]
public static ByteEncodingCollectionBase get_CharStringByteEncodings();
    [CompilerGeneratedAttribute]
private static void set_CharStringByteEncodings(ByteEncodingCollectionBase value);
    private static void InitializeDictByteEncodings();
    private static void InitializeCharStringByteEncodings();
    public abstract virtual object Read(EncodedDataParser reader);
    public bool IsInRange(byte b0);
}
[NullableContextAttribute("1")]
[NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal class Syncfusion.PdfViewer.Base.ByteEncodingCollectionBase : List`1<ByteEncodingBase> {
    public ByteEncodingBase FindEncoding(byte b0);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal static class Syncfusion.PdfViewer.Base.BytesAssistant : object {
    public static int CID_BYTES_COUNT;
    public static char GetUnicodeChar(int i);
    public static int GetInt(Byte[] bytes, int offset, int count);
    public static int GetInt(Byte[] bytes);
    private static Byte[] GetBytes(Byte[] bytes);
    public static int ToInt16(Byte[] bytes, int offset, int count);
    public static int ToInt32(Byte[] bytes, int offset, int count);
    public static Byte[] RemoveWhiteSpace(Byte[] data);
    public static void GetBytes(int b, Byte[] output);
}
internal class Syncfusion.PdfViewer.Base.CallGSubr : Operator {
    [NullableContextAttribute("1")]
public virtual void Execute(CharacterBuilder interpreter);
}
internal class Syncfusion.PdfViewer.Base.CallOtherSubr : Operator {
    [NullableContextAttribute("1")]
public virtual void Execute(CharacterBuilder interpreter);
}
internal class Syncfusion.PdfViewer.Base.CallSubr : Operator {
    [NullableContextAttribute("1")]
public virtual void Execute(CharacterBuilder interpreter);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Syncfusion.PdfViewer.Base.CharacterBuilder : object {
    private static Dictionary`2<OperatorDescriptor, Operator> operators;
    private static OperatorDescriptor endChar;
    private static HintOperator vStem;
    private IBuildCharacterOwner buildCharHolder;
    private OperandCollector postScriptStack;
    private OperandCollector operands;
    [CompilerGeneratedAttribute]
private PathFigure <CurrentPathFigure>k__BackingField;
    [CompilerGeneratedAttribute]
private GlyphOutlinesCollection <GlyphOutlines>k__BackingField;
    [CompilerGeneratedAttribute]
private Point <CurrentPoint>k__BackingField;
    [CompilerGeneratedAttribute]
private Point <BottomLeft>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<int> <Width>k__BackingField;
    [CompilerGeneratedAttribute]
private int <Hints>k__BackingField;
    internal OperandCollector Operands { get; }
    internal OperandCollector PostScriptStack { get; }
    internal PathFigure CurrentPathFigure { get; internal set; }
    internal GlyphOutlinesCollection GlyphOutlines { get; private set; }
    internal Point CurrentPoint { get; internal set; }
    internal Point BottomLeft { get; internal set; }
    internal Nullable`1<int> Width { get; internal set; }
    internal int Hints { get; internal set; }
    private static CharacterBuilder();
    public CharacterBuilder(IBuildCharacterOwner subrsHodler);
    internal OperandCollector get_Operands();
    internal OperandCollector get_PostScriptStack();
    [CompilerGeneratedAttribute]
internal PathFigure get_CurrentPathFigure();
    [CompilerGeneratedAttribute]
internal void set_CurrentPathFigure(PathFigure value);
    [CompilerGeneratedAttribute]
internal GlyphOutlinesCollection get_GlyphOutlines();
    [CompilerGeneratedAttribute]
private void set_GlyphOutlines(GlyphOutlinesCollection value);
    [CompilerGeneratedAttribute]
internal Point get_CurrentPoint();
    [CompilerGeneratedAttribute]
internal void set_CurrentPoint(Point value);
    [CompilerGeneratedAttribute]
internal Point get_BottomLeft();
    [CompilerGeneratedAttribute]
internal void set_BottomLeft(Point value);
    [CompilerGeneratedAttribute]
internal Nullable`1<int> get_Width();
    [CompilerGeneratedAttribute]
internal void set_Width(Nullable`1<int> value);
    [CompilerGeneratedAttribute]
internal int get_Hints();
    [CompilerGeneratedAttribute]
internal void set_Hints(int value);
    internal static Point CalculatePoint(CharacterBuilder interpreter, int dx, int dy);
    private static void InitializePathConstructionOperators();
    private static bool IsOperator(byte b);
    private static bool IsTwoByteOperator(byte b);
    public void ExecuteSubr(int index);
    public void ExecuteGlobalSubr(int index);
    public void CombineChars(string accentedChar, string baseChar, int dx, int dy);
    public void Execute(Byte[] data);
    private void ExecuteInternal(Byte[] data);
    private int GetMaskSize();
    private void ExecuteOperator(OperatorDescriptor descr, EncodedDataParser reader);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Syncfusion.PdfViewer.Base.CharCode : ValueType {
    private Byte[] bytes;
    private int intValue;
    public int BytesCount { get; }
    public Byte[] Bytes { get; }
    public int IntValue { get; public set; }
    public bool IsEmpty { get; }
    public CharCode(Byte[] bytes);
    public CharCode(byte b);
    public CharCode(ushort us);
    public CharCode(int ii);
    public int get_BytesCount();
    public Byte[] get_Bytes();
    public int get_IntValue();
    public void set_IntValue(int value);
    public bool get_IsEmpty();
    private static void InsureCharCodes(CharCode left, CharCode right);
    public static CharCode op_Increment(CharCode cc);
    public static bool op_LessThan(CharCode left, CharCode right);
    public static bool op_Equality(CharCode left, CharCode right);
    public static bool op_GreaterThan(CharCode left, CharCode right);
    public static bool op_Inequality(CharCode left, CharCode right);
    public static bool op_LessThanOrEqual(CharCode left, CharCode right);
    public static bool op_GreaterThanOrEqual(CharCode left, CharCode right);
    public virtual string ToString();
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal static class Syncfusion.PdfViewer.Base.Chars : object {
    public static char NotDef;
    public static char Null;
    public static byte SingleByteSpace;
    public static char Ap;
    public static char Qu;
    public static char Space;
    public static char Tab;
    public static char LF;
    public static char FF;
    public static char CR;
    public static char DecimalPoint;
    public static char LiteralStringStart;
    public static char LiteralStringEnd;
    public static char HexadecimalStringStart;
    public static char HexadecimalStringEnd;
    public static char Comment;
    public static char Name;
    public static char ArrayStart;
    public static char ArrayEnd;
    public static char ExecuteableArrayStart;
    public static char ExecuteableArrayEnd;
    public static char StringEscapeCharacter;
    public static char Minus;
    public static char Plus;
    public static char VerticalBar;
    public static Char[] FontFamilyDelimiters;
    private static Chars();
    public static bool IsWhiteSpace(int b);
    public static bool IsOctalChar(int b);
    public static bool IsHexChar(int b);
    public static bool IsDelimiter(int b);
    public static bool IsLetter(int b);
    public static bool IsValidNumberChar(IPostScriptParser reader);
    public static bool IsValidHexCharacter(int ch);
    private static bool IsDigitOrDecimalPoint(char ch);
}
internal class Syncfusion.PdfViewer.Base.CharStringEncryption : EncryptionStdHelper {
    [NullableContextAttribute("1")]
public CharStringEncryption(PostScriptParser reader);
    public virtual void Initialize();
}
internal class Syncfusion.PdfViewer.Base.ClearToMark : PostScriptOperators {
    [NullableContextAttribute("1")]
public virtual void Execute(FontInterpreter interpreter);
}
internal class Syncfusion.PdfViewer.Base.CloseFile : PostScriptOperators {
    [NullableContextAttribute("1")]
public virtual void Execute(FontInterpreter interpreter);
}
internal class Syncfusion.PdfViewer.Base.ClosePath : Operator {
    [NullableContextAttribute("1")]
public virtual void Execute(CharacterBuilder buildChar);
}
internal class Syncfusion.PdfViewer.Base.CompareDelegate`2 : MulticastDelegate {
    public CompareDelegate`2(object object, IntPtr method);
    [NullableContextAttribute("1")]
public virtual int Invoke(T1 left, T2 right);
    public virtual IAsyncResult BeginInvoke(T1 left, T2 right, AsyncCallback callback, object object);
    public virtual int EndInvoke(IAsyncResult result);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Syncfusion.PdfViewer.Base.Copy : PostScriptOperators {
    public virtual void Execute(FontInterpreter interpreter);
    private static void ExecuteFirstForm(FontInterpreter interpreter, int n);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal static class Syncfusion.PdfViewer.Base.Countable : object {
    public static int Count(IEnumerable`1<TSource> source);
    public static bool Any(IEnumerable`1<TSource> source);
    public static bool All(IEnumerable`1<TSource> source, Func`2<TSource, bool> predicate);
    public static bool Any(IEnumerable`1<TSource> source, Func`2<TSource, bool> predicate);
    public static IEnumerable`1<TResult> OfType(IEnumerable source);
    [IteratorStateMachineAttribute("Syncfusion.PdfViewer.Base.Countable/<OfTypeIterator>d__5`1")]
private static IEnumerable`1<TResult> OfTypeIterator(IEnumerable source);
    public static TSource FirstOrDefault(IEnumerable`1<TSource> source);
    public static TSource FirstOrDefault(IEnumerable`1<TSource> source, Func`2<TSource, bool> predicate);
    public static TSource First(IEnumerable`1<TSource> source);
    public static TSource First(IEnumerable`1<TSource> source, Func`2<TSource, bool> selector);
    public static bool Contains(IEnumerable`1<TSource> source, TSource value);
    public static bool Contains(IEnumerable`1<TSource> source, TSource value, IEqualityComparer`1<TSource> comparer);
    public static TSource[] ToArray(IEnumerable`1<TSource> source);
    public static List`1<TSource> ToList(IEnumerable`1<TSource> source);
    public static IEnumerable`1<TResult> Empty();
    public static byte Max(IEnumerable`1<byte> source);
    public static byte Max(IEnumerable`1<TSource> source, Func`2<TSource, byte> selector);
    public static double Sum(IEnumerable`1<double> source);
    public static int Sum(IEnumerable`1<int> source);
    public static int Sum(IEnumerable`1<TSource> source, Func`2<TSource, int> selector);
    [IteratorStateMachineAttribute("Syncfusion.PdfViewer.Base.Countable/<Skip>d__20`1")]
public static IEnumerable`1<TSource> Skip(IEnumerable`1<TSource> source, int count);
    [IteratorStateMachineAttribute("Syncfusion.PdfViewer.Base.Countable/<Select>d__21`2")]
public static IEnumerable`1<TResult> Select(IEnumerable`1<TSource> source, Func`2<TSource, TResult> selector);
    [IteratorStateMachineAttribute("Syncfusion.PdfViewer.Base.Countable/<Where>d__22`1")]
public static IEnumerable`1<TSource> Where(IEnumerable`1<TSource> source, Func`2<TSource, bool> predicate);
    public static IEnumerable`1<TSource> Take(IEnumerable`1<TSource> source, int count);
    [IteratorStateMachineAttribute("Syncfusion.PdfViewer.Base.Countable/<TakeIterator>d__24`1")]
private static IEnumerable`1<TSource> TakeIterator(IEnumerable`1<TSource> source, int count);
    [IteratorStateMachineAttribute("Syncfusion.PdfViewer.Base.Countable/<ConcatIterator>d__25`1")]
private static IEnumerable`1<TSource> ConcatIterator(IEnumerable`1<TSource> first, IEnumerable`1<TSource> second);
    public static TSource Last(IEnumerable`1<TSource> source);
    public static IOrderedCountable`1<TSource> OrderBy(IEnumerable`1<TSource> source, Func`2<TSource, TKey> keySelector);
    public static IOrderedCountable`1<TSource> OrderBy(IEnumerable`1<TSource> source, Func`2<TSource, TKey> keySelector, IComparer`1<TKey> comparer);
    public static TSource ElementAt(IEnumerable`1<TSource> source, int index);
    public static TSource LastOrDefault(IEnumerable`1<TSource> source);
    public static TSource LastOrDefault(IEnumerable`1<TSource> source, Func`2<TSource, bool> predicate);
    public static TSource SingleOrDefault(IEnumerable`1<TSource> source);
    public static TSource SingleOrDefault(IEnumerable`1<TSource> source, Func`2<TSource, bool> predicate);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal abstract class Syncfusion.PdfViewer.Base.CountableSortingHelper`1 : object {
    internal abstract virtual int CompareKeys(int index1, int index2);
    internal abstract virtual void ComputeKeys(TElement[] elements, int count);
    private void QuickSort(Int32[] map, int left, int right);
    internal Int32[] Sort(TElement[] elements, int count);
}
internal class Syncfusion.PdfViewer.Base.CurrentDict : PostScriptOperators {
    [NullableContextAttribute("1")]
public virtual void Execute(FontInterpreter interpreter);
}
internal class Syncfusion.PdfViewer.Base.CurrentFile : PostScriptOperators {
    [NullableContextAttribute("1")]
public virtual void Execute(FontInterpreter interpreter);
}
internal class Syncfusion.PdfViewer.Base.Def : PostScriptOperators {
    [NullableContextAttribute("1")]
public virtual void Execute(FontInterpreter interpreter);
}
internal class Syncfusion.PdfViewer.Base.DefineFont : PostScriptOperators {
    [NullableContextAttribute("1")]
public virtual void Execute(FontInterpreter interpreter);
}
internal class Syncfusion.PdfViewer.Base.DeviceCMYK : object {
    protected virtual override void Finalize();
    private void InitializeTransform();
}
internal class Syncfusion.PdfViewer.Base.Dict : PostScriptOperators {
    [NullableContextAttribute("1")]
public virtual void Execute(FontInterpreter interpreter);
}
internal class Syncfusion.PdfViewer.Base.Div : Operator {
    [NullableContextAttribute("1")]
public virtual void Execute(CharacterBuilder buildChar);
}
internal class Syncfusion.PdfViewer.Base.Dup : PostScriptOperators {
    [NullableContextAttribute("1")]
public virtual void Execute(FontInterpreter interpreter);
}
internal class Syncfusion.PdfViewer.Base.EExec : PostScriptOperators {
    [NullableContextAttribute("1")]
public virtual void Execute(FontInterpreter interpreter);
}
internal class Syncfusion.PdfViewer.Base.EExecEncryption : EncryptionStdHelper {
    [NullableContextAttribute("1")]
public EExecEncryption(PostScriptParser reader);
    public virtual void Initialize();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Syncfusion.PdfViewer.Base.EncodedDataParser : FontFileParser {
    private ByteEncodingCollectionBase encodings;
    public EncodedDataParser(Byte[] data, ByteEncodingCollectionBase encodings);
    public object ReadOperand();
}
internal class Syncfusion.PdfViewer.Base.EncodingConverter : object {
    [NullableContextAttribute("1")]
public sealed virtual object Convert(Type resultType, object value);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Syncfusion.PdfViewer.Base.EncryptionCollection : object {
    private List`1<EncryptionStdHelper> encryptionCollection;
    public bool HasEncryption { get; }
    public bool get_HasEncryption();
    public void PushEncryption(EncryptionStdHelper encryption);
    public void PopEncryption();
    public byte Decrypt(byte b);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal abstract class Syncfusion.PdfViewer.Base.EncryptionStdHelper : object {
    private static ushort C1;
    private static ushort C2;
    private int randomBytesCount;
    private PostScriptParser reader;
    private ushort r;
    public int RandomBytesCount { get; }
    protected PostScriptParser Reader { get; }
    public EncryptionStdHelper(PostScriptParser reader, ushort r, int n);
    public int get_RandomBytesCount();
    protected PostScriptParser get_Reader();
    public abstract virtual void Initialize();
    public byte Decrypt(byte cipher);
}
internal class Syncfusion.PdfViewer.Base.End : PostScriptOperators {
    [NullableContextAttribute("1")]
public virtual void Execute(FontInterpreter interpreter);
}
internal class Syncfusion.PdfViewer.Base.EndChar : Operator {
    [NullableContextAttribute("1")]
public virtual void Execute(CharacterBuilder buildChar);
}
[NullableContextAttribute("1")]
[NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal class Syncfusion.PdfViewer.Base.EnumerableSorter`2 : CountableSortingHelper`1<TElement> {
    internal Func`2<TElement, TKey> keySelector;
    internal IComparer`1<TKey> comparer;
    internal bool descending;
    internal CountableSortingHelper`1<TElement> next;
    internal TKey[] keys;
    internal EnumerableSorter`2(Func`2<TElement, TKey> keySelector, IComparer`1<TKey> comparer, bool descending, CountableSortingHelper`1<TElement> next);
    internal virtual int CompareKeys(int index1, int index2);
    internal virtual void ComputeKeys(TElement[] elements, int count);
}
internal class Syncfusion.PdfViewer.Base.Exch : PostScriptOperators {
    [NullableContextAttribute("1")]
public virtual void Execute(FontInterpreter interpreter);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal static class Syncfusion.PdfViewer.Base.Extensions : object {
    private static int BUFFER_SIZE;
    public static T1 FindElement(IEnumerable`1<T1> collection, T2 index, CompareDelegate`2<T1, T2> comparer);
    internal static Byte[] ReadAllBytes(Stream reader);
    private static T1 FindElement(IEnumerable`1<T1> collection, int lo, int hi, T2 element, CompareDelegate`2<T1, T2> comparer);
}
internal enum Syncfusion.PdfViewer.Base.FillRule : Enum {
    public int value__;
    public static FillRule EvenOdd;
    public static FillRule Nonzero;
}
internal class Syncfusion.PdfViewer.Base.FiveByteFixedEncodingBase : ByteEncodingBase {
    [NullableContextAttribute("1")]
public virtual object Read(EncodedDataParser reader);
}
internal class Syncfusion.PdfViewer.Base.FiveByteIntegerEncodingBase : ByteEncodingBase {
    [NullableContextAttribute("1")]
public virtual object Read(EncodedDataParser reader);
}
internal class Syncfusion.PdfViewer.Base.Flex : Operator {
    [NullableContextAttribute("1")]
public virtual void Execute(CharacterBuilder buildChar);
}
internal class Syncfusion.PdfViewer.Base.Flex1 : Operator {
    [NullableContextAttribute("1")]
public virtual void Execute(CharacterBuilder buildChar);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Syncfusion.PdfViewer.Base.FontData : PostScriptObj {
    private KeyProperty`1<string> familyName;
    private KeyProperty`1<string> weight;
    private KeyProperty`1<double> italicAngle;
    public string FamilyName { get; }
    public string Weight { get; }
    public double ItalicAngle { get; }
    public string get_FamilyName();
    public string get_Weight();
    public double get_ItalicAngle();
}
internal class Syncfusion.PdfViewer.Base.FontDirectory : PostScriptOperators {
    [NullableContextAttribute("1")]
public virtual void Execute(FontInterpreter interpreter);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal abstract class Syncfusion.PdfViewer.Base.FontFileParser : object {
    private Byte[] data;
    private Stack`1<long> beginReadingPositions;
    private long position;
    public bool EndOfFile { get; }
    public int Length { get; }
    public long Position { get; public set; }
    public FontFileParser(Byte[] data);
    public sealed virtual bool get_EndOfFile();
    public int get_Length();
    public virtual long get_Position();
    public virtual void set_Position(long value);
    public virtual void BeginReadingBlock();
    public virtual void EndReadingBlock();
    public virtual byte Read();
    public virtual byte Peek(int skip);
    public int Read(Byte[] buffer, int count);
    public int ReadBE(Byte[] buffer, int count);
    public virtual void Seek(long offset, SeekOrigin origin);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Syncfusion.PdfViewer.Base.FontInterpreter : object {
    private Dictionary`2<string, BaseType1Font> fonts;
    private PostScriptDict systemDict;
    [CompilerGeneratedAttribute]
private OperandCollector <Operands>k__BackingField;
    [CompilerGeneratedAttribute]
private Stack`1<PostScriptDict> <DictionaryStack>k__BackingField;
    [CompilerGeneratedAttribute]
private Stack`1<PostScriptArray> <ArrayStack>k__BackingField;
    [CompilerGeneratedAttribute]
private PostScriptParser <Reader>k__BackingField;
    [CompilerGeneratedAttribute]
private PostScriptArray <RD>k__BackingField;
    [CompilerGeneratedAttribute]
private PostScriptArray <ND>k__BackingField;
    [CompilerGeneratedAttribute]
private PostScriptArray <NP>k__BackingField;
    internal OperandCollector Operands { get; private set; }
    internal Stack`1<PostScriptDict> DictionaryStack { get; private set; }
    internal Stack`1<PostScriptArray> ArrayStack { get; private set; }
    internal PostScriptDict CurrentDictionary { get; }
    internal PostScriptArray CurrentArray { get; }
    internal PostScriptParser Reader { get; private set; }
    internal PostScriptDict SystemDict { get; }
    internal PostScriptArray RD { get; internal set; }
    internal PostScriptArray ND { get; internal set; }
    internal PostScriptArray NP { get; internal set; }
    public Dictionary`2<string, BaseType1Font> Fonts { get; }
    [CompilerGeneratedAttribute]
internal OperandCollector get_Operands();
    [CompilerGeneratedAttribute]
private void set_Operands(OperandCollector value);
    [CompilerGeneratedAttribute]
internal Stack`1<PostScriptDict> get_DictionaryStack();
    [CompilerGeneratedAttribute]
private void set_DictionaryStack(Stack`1<PostScriptDict> value);
    [CompilerGeneratedAttribute]
internal Stack`1<PostScriptArray> get_ArrayStack();
    [CompilerGeneratedAttribute]
private void set_ArrayStack(Stack`1<PostScriptArray> value);
    internal PostScriptDict get_CurrentDictionary();
    internal PostScriptArray get_CurrentArray();
    [CompilerGeneratedAttribute]
internal PostScriptParser get_Reader();
    [CompilerGeneratedAttribute]
private void set_Reader(PostScriptParser value);
    internal PostScriptDict get_SystemDict();
    [CompilerGeneratedAttribute]
internal PostScriptArray get_RD();
    [CompilerGeneratedAttribute]
internal void set_RD(PostScriptArray value);
    [CompilerGeneratedAttribute]
internal PostScriptArray get_ND();
    [CompilerGeneratedAttribute]
internal void set_ND(PostScriptArray value);
    [CompilerGeneratedAttribute]
internal PostScriptArray get_NP();
    [CompilerGeneratedAttribute]
internal void set_NP(PostScriptArray value);
    public Dictionary`2<string, BaseType1Font> get_Fonts();
    private static object ParseOperand(Token token, PostScriptParser reader);
    private static object ParseBool(string b);
    private static int ParseInt(string str);
    private static double ParseReal(string str);
    private static PostScriptArray ParseArray(PostScriptParser reader);
    private static PostScriptDict ParseDictionary(PostScriptParser reader);
    public void Execute(Byte[] data);
    internal void ExecuteProcedure(PostScriptArray proc);
    private void InitializeSystemDict();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal abstract class Syncfusion.PdfViewer.Base.FontSource : object {
    public string FontFamily { get; }
    public bool IsBold { get; }
    public bool IsItalic { get; }
    public short Ascender { get; }
    public short Descender { get; }
    public abstract virtual string get_FontFamily();
    public abstract virtual bool get_IsBold();
    public abstract virtual bool get_IsItalic();
    public abstract virtual short get_Ascender();
    public abstract virtual short get_Descender();
    public virtual void GetAdvancedWidth(Glyph glyph);
    public virtual void GetGlyphOutlines(Glyph glyph, double fontSize);
    public virtual void GetGlyphName(Glyph glyph);
}
internal class Syncfusion.PdfViewer.Base.For : PostScriptOperators {
    [NullableContextAttribute("1")]
public virtual void Execute(FontInterpreter interpreter);
}
internal class Syncfusion.PdfViewer.Base.Get : PostScriptOperators {
    [NullableContextAttribute("1")]
public virtual void Execute(FontInterpreter interpreter);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Syncfusion.PdfViewer.Base.Glyph : Glyph {
    private double descent;
    private string m_embededFontFamily;
    private double m_matrixFontSize;
    [CompilerGeneratedAttribute]
private bool <IsReplace>k__BackingField;
    [CompilerGeneratedAttribute]
private int <FontId>k__BackingField;
    [CompilerGeneratedAttribute]
private CharCode <CharId>k__BackingField;
    [CompilerGeneratedAttribute]
private string <ToUnicode>k__BackingField;
    [CompilerGeneratedAttribute]
private string <FontFamily>k__BackingField;
    [CompilerGeneratedAttribute]
private FontStyle <FontStyle>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsBold>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsItalic>k__BackingField;
    [CompilerGeneratedAttribute]
private Color <TextColor>k__BackingField;
    [CompilerGeneratedAttribute]
private double <FontSize>k__BackingField;
    [CompilerGeneratedAttribute]
private double <Rise>k__BackingField;
    [CompilerGeneratedAttribute]
private double <CharSpacing>k__BackingField;
    [CompilerGeneratedAttribute]
private double <WordSpacing>k__BackingField;
    [CompilerGeneratedAttribute]
private double <HorizontalScaling>k__BackingField;
    [CompilerGeneratedAttribute]
private double <Width>k__BackingField;
    [CompilerGeneratedAttribute]
private double <Ascent>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsStroked>k__BackingField;
    [CompilerGeneratedAttribute]
private Matrix <TransformMatrix>k__BackingField;
    [CompilerGeneratedAttribute]
private Size <Size>k__BackingField;
    [CompilerGeneratedAttribute]
private Rect <BoundingRect>k__BackingField;
    [CompilerGeneratedAttribute]
private int <ZIndex>k__BackingField;
    [CompilerGeneratedAttribute]
private PathGeometry <Clip>k__BackingField;
    [CompilerGeneratedAttribute]
private double <StrokeThickness>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsRotated>k__BackingField;
    [CompilerGeneratedAttribute]
private int <RotationAngle>k__BackingField;
    internal string EmbededFontFamily { get; internal set; }
    internal double MatrixFontSize { get; internal set; }
    internal bool IsReplace { get; internal set; }
    public int FontId { get; public set; }
    public CharCode CharId { get; public set; }
    public string ToUnicode { get; public set; }
    public string FontFamily { get; public set; }
    public FontStyle FontStyle { get; public set; }
    public bool IsBold { get; public set; }
    public bool IsItalic { get; public set; }
    public Color TextColor { get; public set; }
    public double FontSize { get; public set; }
    public double Rise { get; public set; }
    public double CharSpacing { get; public set; }
    public double WordSpacing { get; public set; }
    public double HorizontalScaling { get; public set; }
    public double Width { get; public set; }
    public double Ascent { get; public set; }
    public double Descent { get; public set; }
    public bool IsStroked { get; public set; }
    public Matrix TransformMatrix { get; public set; }
    public Size Size { get; public set; }
    public Rect BoundingRect { get; public set; }
    public bool IsSpace { get; }
    public int ZIndex { get; public set; }
    public PathGeometry Clip { get; public set; }
    public bool HasChildren { get; }
    public double StrokeThickness { get; public set; }
    public bool IsRotated { get; public set; }
    public int RotationAngle { get; public set; }
    internal string get_EmbededFontFamily();
    internal void set_EmbededFontFamily(string value);
    internal double get_MatrixFontSize();
    internal void set_MatrixFontSize(double value);
    [CompilerGeneratedAttribute]
internal bool get_IsReplace();
    [CompilerGeneratedAttribute]
internal void set_IsReplace(bool value);
    [CompilerGeneratedAttribute]
public int get_FontId();
    [CompilerGeneratedAttribute]
public void set_FontId(int value);
    [CompilerGeneratedAttribute]
public CharCode get_CharId();
    [CompilerGeneratedAttribute]
public void set_CharId(CharCode value);
    [CompilerGeneratedAttribute]
public string get_ToUnicode();
    [CompilerGeneratedAttribute]
public void set_ToUnicode(string value);
    [CompilerGeneratedAttribute]
public string get_FontFamily();
    [CompilerGeneratedAttribute]
public void set_FontFamily(string value);
    [CompilerGeneratedAttribute]
public FontStyle get_FontStyle();
    [CompilerGeneratedAttribute]
public void set_FontStyle(FontStyle value);
    [CompilerGeneratedAttribute]
public bool get_IsBold();
    [CompilerGeneratedAttribute]
public void set_IsBold(bool value);
    [CompilerGeneratedAttribute]
public bool get_IsItalic();
    [CompilerGeneratedAttribute]
public void set_IsItalic(bool value);
    [CompilerGeneratedAttribute]
public Color get_TextColor();
    [CompilerGeneratedAttribute]
public void set_TextColor(Color value);
    [CompilerGeneratedAttribute]
public double get_FontSize();
    [CompilerGeneratedAttribute]
public void set_FontSize(double value);
    [CompilerGeneratedAttribute]
public double get_Rise();
    [CompilerGeneratedAttribute]
public void set_Rise(double value);
    [CompilerGeneratedAttribute]
public double get_CharSpacing();
    [CompilerGeneratedAttribute]
public void set_CharSpacing(double value);
    [CompilerGeneratedAttribute]
public double get_WordSpacing();
    [CompilerGeneratedAttribute]
public void set_WordSpacing(double value);
    [CompilerGeneratedAttribute]
public double get_HorizontalScaling();
    [CompilerGeneratedAttribute]
public void set_HorizontalScaling(double value);
    [CompilerGeneratedAttribute]
public double get_Width();
    [CompilerGeneratedAttribute]
public void set_Width(double value);
    [CompilerGeneratedAttribute]
public double get_Ascent();
    [CompilerGeneratedAttribute]
public void set_Ascent(double value);
    public double get_Descent();
    public void set_Descent(double value);
    [CompilerGeneratedAttribute]
public bool get_IsStroked();
    [CompilerGeneratedAttribute]
public void set_IsStroked(bool value);
    [CompilerGeneratedAttribute]
public Matrix get_TransformMatrix();
    [CompilerGeneratedAttribute]
public void set_TransformMatrix(Matrix value);
    [CompilerGeneratedAttribute]
public Size get_Size();
    [CompilerGeneratedAttribute]
public void set_Size(Size value);
    [CompilerGeneratedAttribute]
public Rect get_BoundingRect();
    [CompilerGeneratedAttribute]
public void set_BoundingRect(Rect value);
    public bool get_IsSpace();
    [CompilerGeneratedAttribute]
public int get_ZIndex();
    [CompilerGeneratedAttribute]
public void set_ZIndex(int value);
    [CompilerGeneratedAttribute]
public PathGeometry get_Clip();
    [CompilerGeneratedAttribute]
public void set_Clip(PathGeometry value);
    public bool get_HasChildren();
    [CompilerGeneratedAttribute]
public double get_StrokeThickness();
    [CompilerGeneratedAttribute]
public void set_StrokeThickness(double value);
    [CompilerGeneratedAttribute]
public bool get_IsRotated();
    [CompilerGeneratedAttribute]
public void set_IsRotated(bool value);
    [CompilerGeneratedAttribute]
public int get_RotationAngle();
    [CompilerGeneratedAttribute]
public void set_RotationAngle(int value);
    public Rect Arrange(Matrix transformMatrix);
    public virtual string ToString();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Syncfusion.PdfViewer.Base.GlyphInfo : object {
    [CompilerGeneratedAttribute]
private GlyphOutlinesCollection <Oultlines>k__BackingField;
    [CompilerGeneratedAttribute]
private ushort <AdvancedWidth>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <HasWidth>k__BackingField;
    public GlyphOutlinesCollection Oultlines { get; private set; }
    public ushort AdvancedWidth { get; private set; }
    public bool HasWidth { get; private set; }
    public GlyphInfo(GlyphOutlinesCollection outlines, Nullable`1<ushort> width);
    [CompilerGeneratedAttribute]
public GlyphOutlinesCollection get_Oultlines();
    [CompilerGeneratedAttribute]
private void set_Oultlines(GlyphOutlinesCollection value);
    [CompilerGeneratedAttribute]
public ushort get_AdvancedWidth();
    [CompilerGeneratedAttribute]
private void set_AdvancedWidth(ushort value);
    [CompilerGeneratedAttribute]
public bool get_HasWidth();
    [CompilerGeneratedAttribute]
private void set_HasWidth(bool value);
}
[NullableContextAttribute("1")]
[NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal class Syncfusion.PdfViewer.Base.GlyphOutlinesCollection : List`1<PathFigure> {
    public GlyphOutlinesCollection Clone();
    public void Transform(Matrix transformMatrix);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Syncfusion.PdfViewer.Base.GlyphWriter : object {
    private MemoryStream glyphStream;
    private static string charSet;
    public bool is1C;
    private String[] charForGlyphIndex;
    private int max;
    private Double[] operands;
    private int operandReached;
    private Single[] pt;
    private double xs;
    private double ys;
    private double x;
    private double y;
    private int ptCount;
    private int currentOp;
    private int hintCount;
    private bool allowAll;
    private double h;
    private PointF CurrentLocation;
    private PdfUnitConvertor m_convertor;
    internal Dictionary`2<string, Byte[]> glyphs;
    internal Dictionary`2<int, string> UnicodeCharMapTable;
    internal Double[] FontMatrix;
    internal bool HasBaseEncoding;
    public int GlobalBias;
    public GlyphWriter(Dictionary`2<string, Byte[]> glyphCharSet, bool isC1);
    public GlyphWriter(Dictionary`2<string, Byte[]> glyphCharSet, int bias, bool isC1);
    private static GlyphWriter();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Syncfusion.PdfViewer.Base.GraphicObjectData : object {
    internal float m_mitterLength;
    private string m_currentFont;
    private float m_fontSize;
    private float m_textLeading;
    private float m_characterSpacing;
    private float m_wordSpacing;
    internal Matrix Ctm;
    internal Matrix textLineMatrix;
    internal Matrix textMatrix;
    internal Matrix documentMatrix;
    internal Matrix textMatrixUpdate;
    internal Matrix drawing2dMatrixCTM;
    internal float HorizontalScaling;
    internal int Rise;
    internal Matrix transformMatrixTM;
    internal float m_strokingOpacity;
    internal float m_nonStrokingOpacity;
    internal string CurrentFont { get; internal set; }
    internal float FontSize { get; internal set; }
    internal float TextLeading { get; internal set; }
    internal float CharacterSpacing { get; internal set; }
    internal float WordSpacing { get; internal set; }
    internal string get_CurrentFont();
    internal void set_CurrentFont(string value);
    internal float get_FontSize();
    internal void set_FontSize(float value);
    internal float get_TextLeading();
    internal void set_TextLeading(float value);
    internal float get_CharacterSpacing();
    internal void set_CharacterSpacing(float value);
    internal float get_WordSpacing();
    internal void set_WordSpacing(float value);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Syncfusion.PdfViewer.Base.GraphicsObject : object {
    private Matrix m_transformMatrix;
    private GraphicsState m_graphicState;
    internal Matrix TransformMatrix { get; internal set; }
    internal Matrix get_TransformMatrix();
    internal void set_TransformMatrix(Matrix value);
    internal GraphicsState Save();
    internal void Restore(GraphicsState graphicState);
    internal void MultiplyTransform(Matrix matrix);
    internal void ScaleTransform(double scaleX, double scaleY);
    internal void TranslateTransform(double offsetX, double offsetY);
    internal void RotateTransform(double angle);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Syncfusion.PdfViewer.Base.GraphicsState : object {
    private Matrix m_transformMatrix;
    internal Matrix TransformMatrix { get; internal set; }
    internal Matrix get_TransformMatrix();
    internal void set_TransformMatrix(Matrix value);
    internal void Save(GraphicsState graphicState);
    internal void Restore(GraphicsState graphicState);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal static class Syncfusion.PdfViewer.Base.Helper : object {
    public static bool ParseInteger(object number, Int32& res);
    public static bool ParseReal(object number, Double& res);
    public static Byte[] CreateByteArray(Byte[] bytes);
}
internal class Syncfusion.PdfViewer.Base.HFlex : Operator {
    [NullableContextAttribute("1")]
public virtual void Execute(CharacterBuilder buildChar);
}
internal class Syncfusion.PdfViewer.Base.HFlex1 : Operator {
    [NullableContextAttribute("1")]
public virtual void Execute(CharacterBuilder buildChar);
}
internal class Syncfusion.PdfViewer.Base.HHCurveTo : Operator {
    [NullableContextAttribute("1")]
public virtual void Execute(CharacterBuilder interpreter);
}
internal class Syncfusion.PdfViewer.Base.HintMaskOperator : HintOperator {
    [NullableContextAttribute("1")]
public void Execute(CharacterBuilder interpreter, Byte[] mask);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Syncfusion.PdfViewer.Base.HintOperator : Operator {
    private static void ReadWidth(CharacterBuilder interpreter);
    public virtual void Execute(CharacterBuilder interpreter);
    internal void Execute(CharacterBuilder interpreter, Int32& count);
}
internal class Syncfusion.PdfViewer.Base.HLineTo : Operator {
    [NullableContextAttribute("1")]
public virtual void Execute(CharacterBuilder interpreter);
}
internal class Syncfusion.PdfViewer.Base.HMoveTo : Operator {
    [NullableContextAttribute("1")]
public virtual void Execute(CharacterBuilder interpreter);
}
internal class Syncfusion.PdfViewer.Base.Hsbw : Operator {
    [NullableContextAttribute("1")]
public virtual void Execute(CharacterBuilder buildChar);
}
internal class Syncfusion.PdfViewer.Base.HVCurveTo : Operator {
    [NullableContextAttribute("1")]
public virtual void Execute(CharacterBuilder interpreter);
}
[NullableContextAttribute("1")]
internal interface Syncfusion.PdfViewer.Base.IBuildCharacterOwner {
    public abstract virtual Byte[] GetSubr(int index);
    public abstract virtual Byte[] GetGlobalSubr(int index);
    public abstract virtual GlyphInfo GetGlyphData(string glyphName);
}
[NullableContextAttribute("1")]
internal interface Syncfusion.PdfViewer.Base.IConverter {
    public abstract virtual object Convert(Type resultType, object value);
}
internal class Syncfusion.PdfViewer.Base.If : PostScriptOperators {
    [NullableContextAttribute("1")]
public virtual void Execute(FontInterpreter interpreter);
}
internal class Syncfusion.PdfViewer.Base.IfElse : PostScriptOperators {
    [NullableContextAttribute("1")]
public virtual void Execute(FontInterpreter interpreter);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Syncfusion.PdfViewer.Base.ImageRenderer : object {
    private bool m_isNegative;
    private Dictionary`2<string, bool> m_layersVisibilityDictionary;
    private bool m_skipRendering;
    private int m_inlayersCount;
    internal bool IsTextSearch;
    internal bool IsPdfium;
    private String[] m_rectangleValue;
    private bool m_isTrEntry;
    private bool m_isExtendedGraphicStateContainsSMask;
    public bool IsExtendedGraphicsState;
    public bool IsGraphicsState;
    public bool IsPdfiumRendering;
    public Color TextColor;
    internal Matrix transformMatrix;
    internal GraphicsObject m_graphicsObject;
    internal PointF currentTransformLocation;
    private Char[] m_symbolChars;
    private Char[] m_startText;
    private Char[] m_endText;
    private PdfPageResources m_resources;
    private PdfRecordCollection m_contentElements;
    private PointF m_currentLocation;
    private bool m_beginText;
    private RectangleF m_clipRectangle;
    private float m_mitterLength;
    internal Stack`1<GraphicsState> m_graphicsState;
    internal Stack`1<GraphicObjectData> m_objects;
    private float m_textScaling;
    private bool textMatrix;
    private float m_textElementWidth;
    private String[] m_backupColorElements;
    private string m_backupColorSpace;
    private PointF m_endTextPosition;
    private bool m_isCurrentPositionChanged;
    internal bool isFindText;
    internal bool isExportAsImage;
    internal bool isExtractLineCollection;
    private PdfViewerExceptions exception;
    private DeviceCMYK decodecmykColor;
    private String[] m_dashedLine;
    private bool isNegativeFont;
    private string m_clippingPath;
    private float m_lineCap;
    private float m_lineJoin;
    private int RenderingMode;
    private float m_opacity;
    private List`1<RectangleF> m_clipRectangleList;
    private bool IsTransparentText;
    private List`1<CffGlyphs> m_glyphDataCollection;
    private Matrix m_imageCommonMatrix;
    public char findpath;
    private bool isScaledText;
    private float currentPageHeight;
    public bool isBlack;
    private Dictionary`2<SystemFontFontDescriptor, SystemFontOpenTypeFontSource> testdict;
    private PdfDictionary m_inlineParameters;
    internal Dictionary`2<string, string> substitutedFontsList;
    private List`1<string> BIparameter;
    internal List`1<Glyph> imageRenderGlyphList;
    internal List`1<TextElement> extractTextElement;
    internal float pageRotation;
    internal float zoomFactor;
    private bool isNextFill;
    private bool isWinAnsiEncoding;
    private int m_tilingType;
    private bool m_isExtractTextData;
    internal bool m_extractTags;
    private int m_mcid;
    internal Dictionary`2<int, string> m_abbreviationCollection;
    private string m_currentFontName;
    internal bool continueOnError;
    private Matrix XFormsMatrix;
    private Matrix m_d1Matrix;
    private Matrixx m_d0Matrix;
    private Matrix m_type3TextLineMatrix;
    private float m_type3FontScallingFactor;
    private PdfRecordCollection m_type3RecordCollection;
    private bool m_isType3Font;
    private TransformationStack m_transformations;
    private FontStructure m_type3FontStruct;
    private float m_spacingWidth;
    private string m_type3GlyphID;
    private float m_type3WhiteSpaceWidth;
    private Dictionary`2<string, List`1<List`1<int>>> m_type3GlyphPath;
    private bool m_istype3FontContainCTRM;
    private MemoryStream m_outStream;
    internal PathGeometry CurrentGeometry;
    private PathGeometry BackupCurrentGeometry;
    private PathFigure m_currentPath;
    private bool containsImage;
    internal int xobjectGraphicsCount;
    internal bool isXGraphics;
    private String[] clipRectShape;
    private bool isRect;
    internal float m_characterSpacing;
    internal float m_wordSpacing;
    internal bool m_selectablePrintDocument;
    private float m_textAngle;
    internal float m_pageHeight;
    internal bool m_isPrintSelected;
    internal bool IsExtractTextData { get; internal set; }
    internal Dictionary`2<string, bool> LayersVisibilityDictionary { get; internal set; }
    private PointF CurrentLocation { get; private set; }
    internal float StrokingOpacity { get; internal set; }
    internal float NonStrokingOpacity { get; internal set; }
    private RectangleF ClipRectangle { get; private set; }
    private float MitterLength { get; private set; }
    private float TextScaling { get; private set; }
    private GraphicObjectData Objects { get; }
    private string CurrentFont { get; private set; }
    private float FontSize { get; private set; }
    private float TextLeading { get; private set; }
    private PathFigure CurrentPath { get; private set; }
    private Matrix CTRM { get; private set; }
    private Matrix TextLineMatrix { get; private set; }
    private Matrix TextMatrix { get; private set; }
    private Matrix DocumentMatrix { get; private set; }
    private Matrix TextMatrixUpdate { get; private set; }
    private Matrix Drawing2dMatrixCTM { get; private set; }
    private float HorizontalScaling { get; private set; }
    private int Rise { get; private set; }
    private Matrix TransformMatrixTM { get; private set; }
    private float CharacterSpacing { get; private set; }
    private float WordSpacing { get; private set; }
    public ImageRenderer(PdfRecordCollection contentElements, PdfPageResources resources, float pageBottom, float left, DeviceCMYK cmyk);
    public ImageRenderer(PdfRecordCollection contentElements, PdfPageResources resources, GraphicsObject g, DeviceCMYK cmyk, float pageHeight);
    internal bool get_IsExtractTextData();
    internal void set_IsExtractTextData(bool value);
    internal Dictionary`2<string, bool> get_LayersVisibilityDictionary();
    internal void set_LayersVisibilityDictionary(Dictionary`2<string, bool> value);
    private PointF get_CurrentLocation();
    private void set_CurrentLocation(PointF value);
    internal float get_StrokingOpacity();
    internal void set_StrokingOpacity(float value);
    internal float get_NonStrokingOpacity();
    internal void set_NonStrokingOpacity(float value);
    private RectangleF get_ClipRectangle();
    private void set_ClipRectangle(RectangleF value);
    private float get_MitterLength();
    private void set_MitterLength(float value);
    private float get_TextScaling();
    private void set_TextScaling(float value);
    private GraphicObjectData get_Objects();
    private string get_CurrentFont();
    private void set_CurrentFont(string value);
    private float get_FontSize();
    private void set_FontSize(float value);
    private float get_TextLeading();
    private void set_TextLeading(float value);
    private PathFigure get_CurrentPath();
    private void set_CurrentPath(PathFigure value);
    private Matrix get_CTRM();
    private void set_CTRM(Matrix value);
    private Matrix get_TextLineMatrix();
    private void set_TextLineMatrix(Matrix value);
    private Matrix get_TextMatrix();
    private void set_TextMatrix(Matrix value);
    private Matrix get_DocumentMatrix();
    private void set_DocumentMatrix(Matrix value);
    private Matrix get_TextMatrixUpdate();
    private void set_TextMatrixUpdate(Matrix value);
    private Matrix get_Drawing2dMatrixCTM();
    private void set_Drawing2dMatrixCTM(Matrix value);
    private float get_HorizontalScaling();
    private void set_HorizontalScaling(float value);
    private int get_Rise();
    private void set_Rise(int value);
    private Matrix get_TransformMatrixTM();
    private void set_TransformMatrixTM(Matrix value);
    private Matrix SetMatrix(double a, double b, double c, double d, double e, double f);
    private void SetTextMatrix(double a, double b, double c, double d, double e, double f);
    private void MoveToNextLineWithCurrentTextLeading();
    private Matrix GetTextRenderingMatrix(bool isPath);
    private Matrix GetTextRenderingMatrix();
    private void MoveToNextLine(double tx, double ty);
    private float FloatParse(string textString);
    public void RenderAsImage();
    private void GetInlineImageParameters(List`1<string> element);
    private string RemoveUnwantedChar(string originalString);
    private void GetDecodeParams(string decodeParam, Int32& predictor, Int32& columns, Int32& colors, Int32& k, String& blackis1);
    private void MoveToNextLineWithLeading(String[] element);
    private void SetTextLeading(float txtLeading);
    private void RenderFont(String[] fontElements);
    private void RenderTextElement(String[] textElements, string tokenType);
    private void UpdateTextMatrix(double tj);
    private void RenderType3GlyphImagesTJ(FontStructure structure, List`1<RenderedString> decodedCollection);
    private void RenderType3GlyphImages(FontStructure structure, string renderingText);
    private void RenderTextElementWithLeading(String[] textElements, string tokenType);
    private List`1<Glyph> ReplaceLigatureFromGlyphList(List`1<Glyph> textElementList);
    private void RenderTextElementWithSpacing(String[] textElements, string tokenType);
    public bool IsValidEmail(string email);
    private Color GetColor(String[] colorElement, string colorSpace);
    private Color ConvertCMYKtoRGB(float c, float m, float y, float k);
    private void DrawNewLine();
    private void GetWordSpacing(String[] spacing);
    private void GetCharacterSpacing(String[] spacing);
    private void GetScalingFactor(String[] scaling);
    private Matrix CalculateTextMatrixupdate(Matrix m, float Width, bool isImage);
    private Matrix GetTransformationMatrix(Matrix transform);
    private void AddLine(String[] line);
    private void AddBezierCurve(String[] curve);
    private void AddBezierCurve2(String[] curve);
    private void AddBezierCurve3(String[] curve);
    private void BeginPath(String[] point);
    private void BeginPath(float x, float y);
    private void EndPath();
    private void AddLine(float x, float y);
    private void GetXObject(String[] xobjectElement);
    private Matrix CalculateType3TextMatrixupdate(Matrix m, float Width, bool isImage);
    private void GetColorSpaceValue(String[] colorspaceelement);
    private float get_CharacterSpacing();
    private void set_CharacterSpacing(float value);
    private float get_WordSpacing();
    private void set_WordSpacing(float value);
}
internal class Syncfusion.PdfViewer.Base.Index : PostScriptOperators {
    [NullableContextAttribute("1")]
public virtual void Execute(FontInterpreter interpreter);
}
public interface Syncfusion.PdfViewer.Base.IOrderedCountable`1 {
    [NullableContextAttribute("1")]
public abstract virtual IOrderedCountable`1<TElement> CreateOrderedEnumerable(Func`2<TElement, TKey> keySelector, IComparer`1<TKey> comparer, bool descending);
}
internal interface Syncfusion.PdfViewer.Base.IPostScriptParser {
    public bool EndOfFile { get; }
    public abstract virtual bool get_EndOfFile();
    public abstract virtual byte Peek(int skip);
    public abstract virtual byte Read();
}
[NullableContextAttribute("1")]
internal interface Syncfusion.PdfViewer.Base.IProperty {
    public KeyPropertyDescriptor Descriptor { get; }
    public abstract virtual KeyPropertyDescriptor get_Descriptor();
    public abstract virtual bool SetValue(object value);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Syncfusion.PdfViewer.Base.KeyPrivate : PostScriptObj {
    private KeyProperty`1<PostScriptArray> subrs;
    private KeyProperty`1<PostScriptArray> otherSubrs;
    private Dictionary`2<int, Byte[]> subroutines;
    public PostScriptArray Subrs { get; }
    public PostScriptArray OtherSubrs { get; }
    public PostScriptArray get_Subrs();
    public PostScriptArray get_OtherSubrs();
    public Byte[] GetSubr(int index);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Syncfusion.PdfViewer.Base.KeyProperty`1 : object {
    private IConverter converter;
    private T value;
    [CompilerGeneratedAttribute]
private KeyPropertyDescriptor <Descriptor>k__BackingField;
    public KeyPropertyDescriptor Descriptor { get; public set; }
    public KeyProperty`1(KeyPropertyDescriptor descriptor);
    public KeyProperty`1(KeyPropertyDescriptor descriptor, IConverter converter);
    public KeyProperty`1(KeyPropertyDescriptor descriptor, T defaultValue);
    public KeyProperty`1(KeyPropertyDescriptor descriptor, IConverter converter, T defaultValue);
    [CompilerGeneratedAttribute]
public sealed virtual KeyPropertyDescriptor get_Descriptor();
    [CompilerGeneratedAttribute]
public void set_Descriptor(KeyPropertyDescriptor value);
    public T GetValue();
    public sealed virtual bool SetValue(object value);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Syncfusion.PdfViewer.Base.KeyPropertyDescriptor : object {
    [CompilerGeneratedAttribute]
private string <Name>k__BackingField;
    public string Name { get; public set; }
    [CompilerGeneratedAttribute]
public string get_Name();
    [CompilerGeneratedAttribute]
public void set_Name(string value);
}
internal class Syncfusion.PdfViewer.Base.Known : PostScriptOperators {
    [NullableContextAttribute("1")]
public virtual void Execute(FontInterpreter interpreter);
}
internal class Syncfusion.PdfViewer.Base.LineSegment : PathSegment {
    [CompilerGeneratedAttribute]
private Point <Point>k__BackingField;
    public Point Point { get; public set; }
    [CompilerGeneratedAttribute]
public Point get_Point();
    [CompilerGeneratedAttribute]
public void set_Point(Point value);
    [NullableContextAttribute("1")]
public virtual PathSegment Clone();
    public virtual void Transform(Matrix transformMatrix);
}
internal class Syncfusion.PdfViewer.Base.Mark : PostScriptOperators {
    [NullableContextAttribute("1")]
public virtual void Execute(FontInterpreter interpreter);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Syncfusion.PdfViewer.Base.Matrix : ValueType {
    private MatrixTypes type;
    [CompilerGeneratedAttribute]
private double <M11>k__BackingField;
    [CompilerGeneratedAttribute]
private double <M12>k__BackingField;
    [CompilerGeneratedAttribute]
private double <M21>k__BackingField;
    [CompilerGeneratedAttribute]
private double <M22>k__BackingField;
    [CompilerGeneratedAttribute]
private double <OffsetX>k__BackingField;
    [CompilerGeneratedAttribute]
private double <OffsetY>k__BackingField;
    public static Matrix Identity { get; }
    public double Determinant { get; }
    public double M11 { get; public set; }
    public double M12 { get; public set; }
    public double M21 { get; public set; }
    public double M22 { get; public set; }
    public double OffsetX { get; public set; }
    public double OffsetY { get; public set; }
    public Matrix(double m11, double m12, double m21, double m22, double offsetX, double offsetY);
    public static Matrix get_Identity();
    public double get_Determinant();
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public double get_M11();
    [CompilerGeneratedAttribute]
public void set_M11(double value);
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public double get_M12();
    [CompilerGeneratedAttribute]
public void set_M12(double value);
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public double get_M21();
    [CompilerGeneratedAttribute]
public void set_M21(double value);
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public double get_M22();
    [CompilerGeneratedAttribute]
public void set_M22(double value);
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public double get_OffsetX();
    [CompilerGeneratedAttribute]
public void set_OffsetX(double value);
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public double get_OffsetY();
    [CompilerGeneratedAttribute]
public void set_OffsetY(double value);
    public static Matrix op_Multiply(Matrix matrix1, Matrix matrix2);
    public static bool op_Equality(Matrix a, Matrix b);
    public static bool op_Inequality(Matrix a, Matrix b);
    public bool IsIdentity();
    public Matrix Translate(double offsetX, double offsetY);
    public Matrix Scale(double scaleX, double scaleY, double centerX, double centerY);
    public Matrix ScaleAppend(double scaleX, double scaleY, double centerX, double centerY);
    public Matrix Rotate(double angle, double centerX, double centerY);
    public bool Equals(Matrix value);
    public double Transform(double d);
    public Point Transform(Point point);
    internal Matrix Clone();
    public Rect Transform(Rect rect);
    public virtual int GetHashCode();
    public virtual bool Equals(object obj);
    public virtual string ToString();
    private void CheckMatrixType();
    private void SetMatrix(double m11, double m12, double m21, double m22, double offsetX, double offsetY, MatrixTypes type);
    public double TransformX(double x);
}
internal enum Syncfusion.PdfViewer.Base.MatrixTypes : Enum {
    public int value__;
    public static MatrixTypes Identity;
    public static MatrixTypes Scaling;
    public static MatrixTypes Translation;
    public static MatrixTypes Unknown;
}
internal class Syncfusion.PdfViewer.Base.Matrixx : ValueType {
    [CompilerGeneratedAttribute]
private double <M11>k__BackingField;
    [CompilerGeneratedAttribute]
private double <M12>k__BackingField;
    internal Matrixx Identity { get; }
    internal double M11 { get; internal set; }
    internal double M12 { get; internal set; }
    internal Matrixx(double m11, double m12);
    internal Matrixx get_Identity();
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
internal double get_M11();
    [CompilerGeneratedAttribute]
internal void set_M11(double value);
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
internal double get_M12();
    [CompilerGeneratedAttribute]
internal void set_M12(double value);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Syncfusion.PdfViewer.Base.ND : PostScriptOperators {
    public static bool IsNDOperator(string name);
    public virtual void Execute(FontInterpreter interpreter);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Syncfusion.PdfViewer.Base.Nibble : object {
    private byte value;
    public Nibble(byte value);
    public static Nibble[] GetNibbles(byte b);
    public static bool op_Equality(Nibble left, Nibble right);
    public static bool op_Inequality(Nibble left, Nibble right);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    public virtual string ToString();
}
internal class Syncfusion.PdfViewer.Base.NoAccess : PostScriptOperators {
    [NullableContextAttribute("1")]
public virtual void Execute(FontInterpreter interpreter);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Syncfusion.PdfViewer.Base.NP : PostScriptOperators {
    public static bool IsNPOperator(string name);
    public virtual void Execute(FontInterpreter interpreter);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Syncfusion.PdfViewer.Base.OperandCollector : object {
    private LinkedList`1<object> store;
    public int Count { get; }
    public object First { get; }
    public object Last { get; }
    public int get_Count();
    public object get_First();
    public object get_Last();
    public object GetElementAt(Origin origin, int index);
    public void AddLast(object obj);
    public void AddFirst(object obj);
    public object GetLast();
    public T GetLastAs();
    public int GetLastAsInt();
    public double GetLastAsReal();
    public object GetFirst();
    public T GetFirstAs();
    public int GetFirstAsInt();
    public double GetFirstAsReal();
    public void Clear();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal abstract class Syncfusion.PdfViewer.Base.Operator : object {
    internal static Point CalculatePoint(CharacterBuilder interpreter, int dx, int dy);
    internal static void HLineTo(CharacterBuilder interpreter, int dx);
    internal static void VLineTo(CharacterBuilder interpreter, int dy);
    internal static void LineTo(CharacterBuilder interpreter, int dx, int dy);
    internal static void CurveTo(CharacterBuilder interpreter, int dxa, int dya, int dxb, int dyb, int dxc, int dyc);
    internal static void MoveTo(CharacterBuilder interpreter, int dx, int dy);
    internal static void ReadWidth(CharacterBuilder interpreter, int operands);
    public abstract virtual void Execute(CharacterBuilder buildChar);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Syncfusion.PdfViewer.Base.OperatorDescriptor : object {
    internal static byte TwoByteOperatorFirstByte;
    private Byte[] value;
    private object defaultValue;
    private int hashCode;
    public object DefaultValue { get; }
    public OperatorDescriptor(byte b0);
    public OperatorDescriptor(Byte[] bytes);
    public OperatorDescriptor(byte b0, object defaultValue);
    public OperatorDescriptor(Byte[] bytes, object defaultValue);
    public object get_DefaultValue();
    private void CalculateHashCode();
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    public virtual string ToString();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal abstract class Syncfusion.PdfViewer.Base.OrderedCountable`1 : object {
    internal IEnumerable`1<TElement> source;
    internal abstract virtual CountableSortingHelper`1<TElement> GetEnumerableSorter(CountableSortingHelper`1<TElement> next);
    [IteratorStateMachineAttribute("Syncfusion.PdfViewer.Base.OrderedCountable`1/<GetEnumerator>d__2")]
public sealed virtual IEnumerator`1<TElement> GetEnumerator();
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
    private sealed virtual override IOrderedCountable`1<TElement> Syncfusion.PdfViewer.Base.IOrderedCountable<TElement>.CreateOrderedEnumerable(Func`2<TElement, TKey> keySelector, IComparer`1<TKey> comparer, bool descending);
}
[NullableContextAttribute("1")]
[NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal class Syncfusion.PdfViewer.Base.OrderedEnumerable`2 : OrderedCountable`1<TElement> {
    internal OrderedCountable`1<TElement> parent;
    internal Func`2<TElement, TKey> keySelector;
    internal IComparer`1<TKey> comparer;
    internal bool descending;
    internal OrderedEnumerable`2(IEnumerable`1<TElement> source, Func`2<TElement, TKey> keySelector, IComparer`1<TKey> comparer, bool descending);
    internal virtual CountableSortingHelper`1<TElement> GetEnumerableSorter(CountableSortingHelper`1<TElement> next);
}
internal enum Syncfusion.PdfViewer.Base.Origin : Enum {
    public int value__;
    public static Origin Begin;
    public static Origin End;
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Syncfusion.PdfViewer.Base.PathFigure : object {
    [CompilerGeneratedAttribute]
private List`1<PathSegment> <Segments>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsClosed>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsFilled>k__BackingField;
    [CompilerGeneratedAttribute]
private Point <StartPoint>k__BackingField;
    public List`1<PathSegment> Segments { get; public set; }
    public bool IsClosed { get; public set; }
    public bool IsFilled { get; public set; }
    public Point StartPoint { get; public set; }
    [CompilerGeneratedAttribute]
public List`1<PathSegment> get_Segments();
    [CompilerGeneratedAttribute]
public void set_Segments(List`1<PathSegment> value);
    [CompilerGeneratedAttribute]
public bool get_IsClosed();
    [CompilerGeneratedAttribute]
public void set_IsClosed(bool value);
    [CompilerGeneratedAttribute]
public bool get_IsFilled();
    [CompilerGeneratedAttribute]
public void set_IsFilled(bool value);
    [CompilerGeneratedAttribute]
public Point get_StartPoint();
    [CompilerGeneratedAttribute]
public void set_StartPoint(Point value);
    public PathFigure Clone();
    internal void Transform(Matrix transformMatrix);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Syncfusion.PdfViewer.Base.PathGeometry : object {
    [CompilerGeneratedAttribute]
private List`1<PathFigure> <Figures>k__BackingField;
    [CompilerGeneratedAttribute]
private FillRule <FillRule>k__BackingField;
    [CompilerGeneratedAttribute]
private Matrix <TransformMatrix>k__BackingField;
    public List`1<PathFigure> Figures { get; public set; }
    public FillRule FillRule { get; public set; }
    public Matrix TransformMatrix { get; public set; }
    public bool IsEmpty { get; }
    [CompilerGeneratedAttribute]
public List`1<PathFigure> get_Figures();
    [CompilerGeneratedAttribute]
public void set_Figures(List`1<PathFigure> value);
    [CompilerGeneratedAttribute]
public FillRule get_FillRule();
    [CompilerGeneratedAttribute]
public void set_FillRule(FillRule value);
    [CompilerGeneratedAttribute]
public Matrix get_TransformMatrix();
    [CompilerGeneratedAttribute]
public void set_TransformMatrix(Matrix value);
    public bool get_IsEmpty();
    internal static PathGeometry CreateRectangle(Rect rect);
    private static void Compare(Point point, Double& minX, Double& maxX, Double& minY, Double& maxY);
    public PathGeometry Clone();
    public Rect GetBoundingRect();
}
internal abstract class Syncfusion.PdfViewer.Base.PathSegment : object {
    [NullableContextAttribute("1")]
public abstract virtual PathSegment Clone();
    public abstract virtual void Transform(Matrix transformMatrix);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal static class Syncfusion.PdfViewer.Base.PdfHelper : object {
    public static Matrix CalculateTextMatrix(Matrix m, Glyph glyph);
    public static bool UnboxDouble(object obj, Double& res);
    public static bool GetBit(int n, byte bit);
    public static double GetDistance(Point p1, Point p2);
    public static bool UnboxBool(object obj, Boolean& res);
    public static bool UnboxInt(object obj, Int32& res);
    [NullableContextAttribute("0")]
public static bool EnumTryParse(string valueAsString, TEnum& value, bool ignoreCase);
    public static Rect GetBoundingRect(Rect rect, Matrix matrix);
    private static void TransformPoints(Matrix matrix, Point[] points);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal static class Syncfusion.PdfViewer.Base.PdfKeywords : object {
    internal static string True;
    internal static string False;
    internal static string IndirectReference;
    internal static string Null;
    internal static string StartXRef;
    internal static string XRef;
    internal static string Trailer;
    internal static string StreamStart;
    internal static string StreamEnd;
    internal static string IndirectObjectStart;
    internal static string IndirectObjectEnd;
    internal static string PdfHeader;
    internal static string BinaryMarker;
    internal static string EndOfFile;
    internal static string DictionaryStart;
    internal static string DictionaryEnd;
    internal static string EndOfInlineImage;
    internal static string StandardEncoding;
    internal static string ISOLatin1Encoding;
    public static bool IsKeyword(string str);
    internal static object GetValue(string keyword);
}
internal class Syncfusion.PdfViewer.Base.PdfRangeCalculator : object {
    [CompilerGeneratedAttribute]
private int <RangeStart>k__BackingField;
    [CompilerGeneratedAttribute]
private int <RangeEnd>k__BackingField;
    public int RangeStart { get; private set; }
    public int RangeEnd { get; private set; }
    public PdfRangeCalculator(int start, int end);
    [CompilerGeneratedAttribute]
public int get_RangeStart();
    [CompilerGeneratedAttribute]
private void set_RangeStart(int value);
    [CompilerGeneratedAttribute]
public int get_RangeEnd();
    [CompilerGeneratedAttribute]
private void set_RangeEnd(int value);
    public bool IsInRange(int value);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Syncfusion.PdfViewer.Base.PdfViewerExceptions : object {
    private static StringBuilder m_exceptions;
    public StringBuilder Exceptions { get; public set; }
    private static PdfViewerExceptions();
    public StringBuilder get_Exceptions();
    public void set_Exceptions(StringBuilder value);
}
internal class Syncfusion.PdfViewer.Base.Point : ValueType {
    internal double _x;
    internal double _y;
    public double X { get; public set; }
    public double Y { get; public set; }
    public Point(double x, double y);
    public double get_X();
    public void set_X(double value);
    public double get_Y();
    public void set_Y(double value);
    public static Point op_Implicit(Point p);
    public static PointF op_Implicit(Point p);
    public static Point op_Implicit(Point p);
    public static Point op_Implicit(PointF p);
    public static Point Add(Point point, Vector vector);
    public static bool Equals(Point point1, Point point2);
    [NullableContextAttribute("1")]
public virtual bool Equals(object o);
    public bool Equals(Point value);
    public virtual int GetHashCode();
    public void Offset(double offsetX, double offsetY);
    public static Point op_Addition(Point point, Vector vector);
    public static bool op_Equality(Point point1, Point point2);
    public static Size op_Explicit(Point point);
    public static Vector op_Explicit(Point point);
    public static bool op_Inequality(Point point1, Point point2);
    public static Point op_Subtraction(Point point, Vector vector);
    public static Vector op_Subtraction(Point point1, Point point2);
    public static Point Subtract(Point point, Vector vector);
    public static Vector Subtract(Point point1, Point point2);
    [NullableContextAttribute("1")]
private sealed virtual override string System.IFormattable.ToString(string format, IFormatProvider provider);
}
internal class Syncfusion.PdfViewer.Base.Pop : Operator {
    [NullableContextAttribute("1")]
public virtual void Execute(CharacterBuilder buildChar);
}
internal class Syncfusion.PdfViewer.Base.Pops : PostScriptOperators {
    [NullableContextAttribute("1")]
public virtual void Execute(FontInterpreter interpreter);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[DefaultMemberAttribute("Item")]
internal class Syncfusion.PdfViewer.Base.PostScriptArray : PostScriptObj {
    private List`1<object> store;
    public static PostScriptArray MatrixIdentity { get; }
    public object Item { get; public set; }
    public int Count { get; }
    public bool IsReadOnly { get; }
    public PostScriptArray(int capacity);
    public PostScriptArray(Object[] initialValue);
    public static PostScriptArray get_MatrixIdentity();
    public sealed virtual object get_Item(int index);
    public sealed virtual void set_Item(int index, object value);
    public sealed virtual int get_Count();
    public sealed virtual bool get_IsReadOnly();
    public Matrix ToMatrix();
    public sealed virtual int IndexOf(object item);
    public sealed virtual void Insert(int index, object item);
    public sealed virtual void RemoveAt(int index);
    public sealed virtual void Add(object item);
    public sealed virtual void Clear();
    public sealed virtual bool Contains(object item);
    public sealed virtual void CopyTo(Object[] array, int arrayIndex);
    public sealed virtual bool Remove(object item);
    public sealed virtual IEnumerator`1<object> GetEnumerator();
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
    public void Load(Object[] content);
    public T GetElementAs(int index);
    public virtual string ToString();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[DefaultMemberAttribute("Item")]
internal class Syncfusion.PdfViewer.Base.PostScriptDict : PostScriptObj {
    private Dictionary`2<string, object> collection;
    public ICollection`1<string> Keys { get; }
    public ICollection`1<object> Values { get; }
    public object Item { get; public set; }
    public int Count { get; }
    public bool IsReadOnly { get; }
    public PostScriptDict(int capacity);
    public sealed virtual ICollection`1<string> get_Keys();
    public sealed virtual ICollection`1<object> get_Values();
    public sealed virtual object get_Item(string key);
    public sealed virtual void set_Item(string key, object value);
    public sealed virtual int get_Count();
    public sealed virtual bool get_IsReadOnly();
    public sealed virtual void Add(string key, object value);
    public sealed virtual bool ContainsKey(string key);
    public sealed virtual bool Remove(string key);
    public sealed virtual bool TryGetValue(string key, Object& value);
    public sealed virtual void Add(KeyValuePair`2<string, object> item);
    public sealed virtual void Clear();
    public sealed virtual bool Contains(KeyValuePair`2<string, object> item);
    public sealed virtual void CopyTo(KeyValuePair`2[] array, int arrayIndex);
    public sealed virtual bool Remove(KeyValuePair`2<string, object> item);
    public sealed virtual IEnumerator`1<KeyValuePair`2<string, object>> GetEnumerator();
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
    public T GetElementAs(string key);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal abstract class Syncfusion.PdfViewer.Base.PostScriptObj : object {
    private Dictionary`2<string, IProperty> properties;
    public void Load(PostScriptDict fromDict);
    protected KeyProperty`1<T> CreateProperty(KeyPropertyDescriptor descriptor);
    protected KeyProperty`1<T> CreateProperty(KeyPropertyDescriptor descriptor, IConverter converter);
    protected KeyProperty`1<T> CreateProperty(KeyPropertyDescriptor descriptor, T defaultValue);
    protected KeyProperty`1<T> CreateProperty(KeyPropertyDescriptor descriptor, IConverter converter, T defaultValue);
    private void RegisterProperty(KeyPropertyDescriptor descriptor, IProperty property);
    private void RegisterProperty(IProperty property);
}
internal class Syncfusion.PdfViewer.Base.PostScriptObjectConverter : object {
    [NullableContextAttribute("1")]
public sealed virtual object Convert(Type resultType, object value);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal abstract class Syncfusion.PdfViewer.Base.PostScriptOperators : object {
    internal static string Array;
    internal static string Begin;
    internal static string ClearToMark;
    internal static string CloseFile;
    internal static string CurrentDict;
    internal static string CurrentFile;
    internal static string Def;
    internal static string DefineFont;
    internal static string Dict;
    internal static string Dup;
    internal static string EExec;
    internal static string End;
    internal static string Exch;
    internal static string For;
    internal static string Get;
    internal static string Index;
    internal static string Put;
    internal static string RD;
    internal static string RDAlternate;
    internal static string Mark;
    internal static string ND;
    internal static string NDAlternate;
    internal static string NoAccess;
    internal static string NP;
    internal static string NPAlternate;
    internal static string ReadString;
    internal static string String;
    internal static string Pop;
    internal static string Copy;
    internal static string SystemDict;
    internal static string Known;
    internal static string If;
    internal static string IfElse;
    internal static string FontDirectory;
    private static Dictionary`2<string, PostScriptOperators> operators;
    private static PostScriptOperators();
    public static bool IsOperator(string str);
    public static PostScriptOperators FindOperator(string op);
    private static void InitializeOperators();
    public abstract virtual void Execute(FontInterpreter interpreter);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Syncfusion.PdfViewer.Base.PostScriptParser : FontFileParser {
    private EncryptionCollection encryption;
    private Queue`1<byte> decryptedBuffer;
    [CompilerGeneratedAttribute]
private string <Result>k__BackingField;
    public string Result { get; public set; }
    public long Position { get; }
    public PostScriptParser(Byte[] data);
    [CompilerGeneratedAttribute]
public string get_Result();
    [CompilerGeneratedAttribute]
public void set_Result(string value);
    public virtual long get_Position();
    public Token ReadToken();
    internal void SkipUnusedCharacters();
    internal void GoToNextLine();
    internal void SkipWhiteSpaces();
    private Token ReadOperatorOrKeyword();
    private Token ReadName();
    private Token ReadNumber();
    private Token ReadHexadecimalString();
    private Token ReadLiteralString();
    public virtual void BeginReadingBlock();
    public virtual void EndReadingBlock();
    public virtual void Seek(long offset, SeekOrigin origin);
    public virtual byte Read();
    public virtual byte Peek(int skip);
    public void PushEncryption(EncryptionStdHelper encrypt);
    public void PopEncryption();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal static class Syncfusion.PdfViewer.Base.PostScriptParserHelper : object {
    private static Int32[] charValues;
    private static PostScriptParserHelper();
    public static void GoToNextLine(IPostScriptParser reader);
    public static void SkipUnusedCharacters(IPostScriptParser reader);
    public static void SkipWhiteSpaces(IPostScriptParser reader);
    public static string GetString(Byte[] bytes);
    public static string ReadNumber(IPostScriptParser reader);
    public static string ReadName(IPostScriptParser reader);
    public static string ReadKeyword(IPostScriptParser reader);
    public static Byte[] ReadHexadecimalString(IPostScriptParser reader);
    public static Byte[] ReadLiteralString(IPostScriptParser reader);
    public static Byte[] GetBytesFromHexString(string hexString);
    public static bool IsValidEscape(int b);
    public static char GetSymbolFromEscapeSymbol(int symbol);
    private static bool TryReadHexChar(IPostScriptParser reader, String& result);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[DefaultMemberAttribute("Item")]
internal class Syncfusion.PdfViewer.Base.PostScriptStrHelper : object {
    private Char[] value;
    public string Value { get; }
    public int Capacity { get; }
    public char Item { get; public set; }
    public PostScriptStrHelper(string str);
    public PostScriptStrHelper(int capacity);
    public string get_Value();
    public int get_Capacity();
    public char get_Item(int index);
    public void set_Item(int index, char value);
    public Byte[] ToByteArray();
    public virtual string ToString();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal static class Syncfusion.PdfViewer.Base.PredefinedFontFamilies : object {
    private static Dictionary`2<string, string> mapping;
    private static PredefinedFontFamilies();
    public static string CreateFontKey(string font);
    public static bool TryGetFontFamily(string font, String& fontFamily);
    private static void RegisterFontFamily(string fontFamily);
    private static void RegisterFontFamily(string fontFamily, string realFontFamily);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Syncfusion.PdfViewer.Base.PredefinedTextEncoding : object {
    private String[] names;
    private Dictionary`2<string, byte> mapping;
    [CompilerGeneratedAttribute]
private static PredefinedTextEncoding <PdfDocEncoding>k__BackingField;
    [CompilerGeneratedAttribute]
private static PredefinedTextEncoding <WinAnsiEncoding>k__BackingField;
    [CompilerGeneratedAttribute]
private static PredefinedTextEncoding <MacRomanEncoding>k__BackingField;
    [CompilerGeneratedAttribute]
private static PredefinedTextEncoding <StandardMacRomanEncoding>k__BackingField;
    [CompilerGeneratedAttribute]
private static PredefinedTextEncoding <StandardEncoding>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Name>k__BackingField;
    public static PredefinedTextEncoding PdfDocEncoding { get; private set; }
    public static PredefinedTextEncoding WinAnsiEncoding { get; private set; }
    public static PredefinedTextEncoding MacRomanEncoding { get; private set; }
    public static PredefinedTextEncoding StandardMacRomanEncoding { get; private set; }
    public static PredefinedTextEncoding StandardEncoding { get; private set; }
    public string Name { get; private set; }
    private static PredefinedTextEncoding();
    [CompilerGeneratedAttribute]
public static PredefinedTextEncoding get_PdfDocEncoding();
    [CompilerGeneratedAttribute]
private static void set_PdfDocEncoding(PredefinedTextEncoding value);
    [CompilerGeneratedAttribute]
public static PredefinedTextEncoding get_WinAnsiEncoding();
    [CompilerGeneratedAttribute]
private static void set_WinAnsiEncoding(PredefinedTextEncoding value);
    [CompilerGeneratedAttribute]
public static PredefinedTextEncoding get_MacRomanEncoding();
    [CompilerGeneratedAttribute]
private static void set_MacRomanEncoding(PredefinedTextEncoding value);
    [CompilerGeneratedAttribute]
public static PredefinedTextEncoding get_StandardMacRomanEncoding();
    [CompilerGeneratedAttribute]
private static void set_StandardMacRomanEncoding(PredefinedTextEncoding value);
    [CompilerGeneratedAttribute]
public static PredefinedTextEncoding get_StandardEncoding();
    [CompilerGeneratedAttribute]
private static void set_StandardEncoding(PredefinedTextEncoding value);
    [CompilerGeneratedAttribute]
public string get_Name();
    [CompilerGeneratedAttribute]
private void set_Name(string value);
    private static void InitializePdfEncoding();
    private static void InitializeWinAnsiEncoding();
    private static void InitializeMacEncoding();
    private static void InitializeStandardMacEncoding();
    private static void InitializeStandardEncoding();
    public static PredefinedTextEncoding GetPredefinedEncoding(string encoding);
    private void Init();
    private void InitMapping();
    public String[] GetNames();
    public byte GetCharId(string name);
    internal static void InitializePredefinedEncoding();
    internal static void Dispose();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Syncfusion.PdfViewer.Base.PresettedEncoding : object {
    private UInt16[] sids;
    [CompilerGeneratedAttribute]
private static PresettedEncoding <StandardEncoding>k__BackingField;
    [CompilerGeneratedAttribute]
private static PresettedEncoding <ExpertEncoding>k__BackingField;
    public static PresettedEncoding StandardEncoding { get; private set; }
    public static PresettedEncoding ExpertEncoding { get; private set; }
    private static PresettedEncoding();
    [CompilerGeneratedAttribute]
public static PresettedEncoding get_StandardEncoding();
    [CompilerGeneratedAttribute]
private static void set_StandardEncoding(PresettedEncoding value);
    [CompilerGeneratedAttribute]
public static PresettedEncoding get_ExpertEncoding();
    [CompilerGeneratedAttribute]
private static void set_ExpertEncoding(PresettedEncoding value);
    public static PresettedEncoding GetPredefinedEncoding(int b);
    public static bool IsPredefinedEncoding(int b);
    private static void InitializeExpertEncoding();
    private static void InitializeStandardEncoding();
    public PostScriptArray ToArray();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal static class Syncfusion.PdfViewer.Base.PresettedEncodings : object {
    [CompilerGeneratedAttribute]
private static String[] <StandardEncoding>k__BackingField;
    public static String[] StandardEncoding { get; private set; }
    private static PresettedEncodings();
    [CompilerGeneratedAttribute]
public static String[] get_StandardEncoding();
    [CompilerGeneratedAttribute]
private static void set_StandardEncoding(String[] value);
    private static void InitializeStandardEncoding();
    public static PostScriptArray CreateEncoding(string predefinedEncoding);
}
internal class Syncfusion.PdfViewer.Base.Put : PostScriptOperators {
    [NullableContextAttribute("1")]
public virtual void Execute(FontInterpreter interpreter);
}
internal class Syncfusion.PdfViewer.Base.QuadraticBezierSegment : PathSegment {
    [CompilerGeneratedAttribute]
private Point <Point1>k__BackingField;
    [CompilerGeneratedAttribute]
private Point <Point2>k__BackingField;
    public Point Point1 { get; public set; }
    public Point Point2 { get; public set; }
    [CompilerGeneratedAttribute]
public Point get_Point1();
    [CompilerGeneratedAttribute]
public void set_Point1(Point value);
    [CompilerGeneratedAttribute]
public Point get_Point2();
    [CompilerGeneratedAttribute]
public void set_Point2(Point value);
    [NullableContextAttribute("1")]
public virtual PathSegment Clone();
    public virtual void Transform(Matrix transformMatrix);
}
internal class Syncfusion.PdfViewer.Base.RCurveLine : Operator {
    [NullableContextAttribute("1")]
public virtual void Execute(CharacterBuilder interpreter);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Syncfusion.PdfViewer.Base.RD : PostScriptOperators {
    public static bool IsRDOperator(string name);
    public virtual void Execute(FontInterpreter interpreter);
}
internal class Syncfusion.PdfViewer.Base.ReadString : PostScriptOperators {
    [NullableContextAttribute("1")]
public virtual void Execute(FontInterpreter interpreter);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Syncfusion.PdfViewer.Base.RealByteEncodingBase : ByteEncodingBase {
    private static Dictionary`2<Nibble, string> nibbleMapping;
    private static Nibble endOfNumber;
    private static RealByteEncodingBase();
    public virtual object Read(EncodedDataParser reader);
}
internal class Syncfusion.PdfViewer.Base.Rect : ValueType {
    internal double _x;
    internal double _y;
    internal double _width;
    internal double _height;
    private static Rect s_empty;
    public double Bottom { get; }
    public Point BottomLeft { get; }
    public Point BottomRight { get; }
    public static Rect Empty { get; }
    public double Height { get; public set; }
    public bool IsEmpty { get; }
    public double Left { get; }
    public Point Location { get; public set; }
    public double Right { get; }
    public Size Size { get; public set; }
    public double Top { get; }
    public Point TopLeft { get; }
    public Point TopRight { get; }
    public double Width { get; public set; }
    public double X { get; public set; }
    public double Y { get; public set; }
    private static Rect();
    public Rect(Point location, Size size);
    public Rect(double x, double y, double width, double height);
    public Rect(Point point1, Point point2);
    public Rect(Size size);
    public double get_Bottom();
    public Point get_BottomLeft();
    public Point get_BottomRight();
    public static Rect get_Empty();
    public double get_Height();
    public void set_Height(double value);
    public bool get_IsEmpty();
    public double get_Left();
    public Point get_Location();
    public void set_Location(Point value);
    public double get_Right();
    public Size get_Size();
    public void set_Size(Size value);
    public double get_Top();
    public Point get_TopLeft();
    public Point get_TopRight();
    public double get_Width();
    public void set_Width(double value);
    public double get_X();
    public void set_X(double value);
    public double get_Y();
    public void set_Y(double value);
    public static Rectangle op_Implicit(Rect p);
    public static RectangleF op_Implicit(Rect p);
    public bool Contains(Point point);
    public bool Contains(double x, double y);
    public bool Contains(Rect rect);
    private bool ContainsInternal(double x, double y);
    private static Rect CreateEmptyRect();
    public static bool Equals(Rect rect1, Rect rect2);
    [NullableContextAttribute("1")]
public virtual bool Equals(object o);
    public bool Equals(Rect value);
    public virtual int GetHashCode();
    public void Inflate(Size size);
    public void Inflate(double width, double height);
    public static Rect Inflate(Rect rect, Size size);
    public static Rect Inflate(Rect rect, double width, double height);
    public void Intersect(Rect rect);
    public static Rect Intersect(Rect rect1, Rect rect2);
    public bool IntersectsWith(Rect rect);
    public void Offset(Vector offsetVector);
    public void Offset(double offsetX, double offsetY);
    public static Rect Offset(Rect rect, Vector offsetVector);
    public static Rect Offset(Rect rect, double offsetX, double offsetY);
    public static bool op_Equality(Rect rect1, Rect rect2);
    public static bool op_Inequality(Rect rect1, Rect rect2);
    public void Scale(double scaleX, double scaleY);
    [NullableContextAttribute("1")]
private sealed virtual override string System.IFormattable.ToString(string format, IFormatProvider provider);
    public void Union(Rect rect);
    public static Rect Union(Rect rect1, Rect rect2);
    public void Union(Point point);
    public static Rect Union(Rect rect, Point point);
}
internal class Syncfusion.PdfViewer.Base.Return : Operator {
    [NullableContextAttribute("1")]
public virtual void Execute(CharacterBuilder interpreter);
}
internal class Syncfusion.PdfViewer.Base.RLineCurve : Operator {
    [NullableContextAttribute("1")]
public virtual void Execute(CharacterBuilder interpreter);
}
internal class Syncfusion.PdfViewer.Base.RLineTo : Operator {
    [NullableContextAttribute("1")]
public virtual void Execute(CharacterBuilder interpreter);
}
internal class Syncfusion.PdfViewer.Base.RMoveTo : Operator {
    [NullableContextAttribute("1")]
public virtual void Execute(CharacterBuilder interpreter);
}
internal class Syncfusion.PdfViewer.Base.RRCurveTo : Operator {
    [NullableContextAttribute("1")]
public virtual void Execute(CharacterBuilder interpreter);
}
internal class Syncfusion.PdfViewer.Base.Sbw : Operator {
    [NullableContextAttribute("1")]
public virtual void Execute(CharacterBuilder buildChar);
}
internal class Syncfusion.PdfViewer.Base.Seac : Operator {
    [NullableContextAttribute("1")]
public virtual void Execute(CharacterBuilder buildChar);
}
internal class Syncfusion.PdfViewer.Base.SetCurrentPoint : Operator {
    [NullableContextAttribute("1")]
public virtual void Execute(CharacterBuilder buildChar);
}
internal class Syncfusion.PdfViewer.Base.SingleByteIntegerEncodingBase : ByteEncodingBase {
    [NullableContextAttribute("1")]
public virtual object Read(EncodedDataParser reader);
}
internal class Syncfusion.PdfViewer.Base.Size : ValueType {
    internal double _width;
    internal double _height;
    private static Size s_empty;
    public static Size Empty { get; }
    public double Height { get; public set; }
    public bool IsEmpty { get; }
    public double Width { get; public set; }
    private static Size();
    public Size(double width, double height);
    public static Size get_Empty();
    public double get_Height();
    public void set_Height(double value);
    public bool get_IsEmpty();
    public double get_Width();
    public void set_Width(double value);
    private static Size CreateEmptySize();
    public static bool Equals(Size size1, Size size2);
    [NullableContextAttribute("1")]
public virtual bool Equals(object o);
    public bool Equals(Size value);
    public virtual int GetHashCode();
    public static bool op_Equality(Size size1, Size size2);
    public static Vector op_Explicit(Size size);
    public static Point op_Explicit(Size size);
    public static bool op_Inequality(Size size1, Size size2);
    [NullableContextAttribute("1")]
private sealed virtual override string System.IFormattable.ToString(string format, IFormatProvider provider);
}
internal class Syncfusion.PdfViewer.Base.StandardFontDescriptor : object {
    [CompilerGeneratedAttribute]
private double <Ascent>k__BackingField;
    [CompilerGeneratedAttribute]
private double <Descent>k__BackingField;
    public double Ascent { get; public set; }
    public double Descent { get; public set; }
    [CompilerGeneratedAttribute]
public double get_Ascent();
    [CompilerGeneratedAttribute]
public void set_Ascent(double value);
    [CompilerGeneratedAttribute]
public double get_Descent();
    [CompilerGeneratedAttribute]
public void set_Descent(double value);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Syncfusion.PdfViewer.Base.StdFontReader : object {
    private static int HeadersCount;
    private static int LastHeader;
    private Byte[] data;
    private StdHeader[] headers;
    private long position;
    public void ReadHeaders();
    public UInt32 ReadUInt();
    public byte Read();
    public Byte[] ReadData(Byte[] data);
    private bool ReadLE(Byte[] buffer, int count);
    private bool IsPositionInHeader(long position);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Syncfusion.PdfViewer.Base.StdFontsAssistant : object {
    private static string Courier;
    private static string CourierBold;
    private static string CourierBoldOblique;
    private static string CourierOblique;
    private static string Helvetica;
    private static string HelveticaBold;
    private static string HelveticaBoldOblique;
    private static string HelveticaOblique;
    private static string TimesRoman;
    private static string TimesBold;
    private static string TimesBoldItalic;
    private static string TimesItalic;
    private static string Symbol;
    private static string ZapfDingbats;
    private static Dictionary`2<string, string> alternativeNames;
    internal static Dictionary`2<string, StandardFontDescriptor> standardFontDescriptors;
    private static Dictionary`2<string, Byte[]> standardFontStreams;
    private Dictionary`2<string, Type1FontSource> standardFontSources;
    private StdFontsAssistant systemFontsManager;
    private object syncObj;
    public StdFontsAssistant SystemFontsManager { get; }
    private static StdFontsAssistant();
    public StdFontsAssistant get_SystemFontsManager();
    public static string StripFontName(string fontName);
    public static void InitializeStandardFontStreams();
    public static bool IsStandardFontName(string name);
    public static bool IsAlternativeStdFontAvailable(string name);
    public static StandardFontDescriptor GetStandardFontDescriptor(string fontName);
    public Type1FontSource GetStandardFontSource(string fontName);
    public Type1FontSource GetType1FallbackFontSource(string fontName);
    private static Stream GetApplicationResourceStream(string fontName);
    private static string GetStandardFontName(string fontName);
    private static void RegisterStandardFontStream(string fontName, Stream stream);
    private static void RegisterStandardFontDescriptor(string name, StandardFontDescriptor fontDescriptor);
    private static bool IsBold(string styles);
    private static bool IsItalic(string styles);
    internal static void InitializeStandardFontDescriptors();
    private static void InitializeAlternativeNames();
    private static string GetFontStylesFromFontName(string fontName);
    private static void RegisterAlternativeName(string original, String[] alternatives);
    private static Type1FontSource CreateFontSource(Byte[] data);
    private void InitializeStandardFontSources();
    private void RegisterStandardFontSource(string fontName, Type1FontSource fontSource);
    public static void GetFontFamily(string fontName, String& fontFamily, FontStyle& fontStyle);
    internal void Dispose();
}
internal class Syncfusion.PdfViewer.Base.StdHeader : object {
    private long offset;
    private int headerLength;
    [CompilerGeneratedAttribute]
private UInt32 <NextHeaderOffset>k__BackingField;
    public long Offset { get; }
    public int HeaderLength { get; }
    public UInt32 NextHeaderOffset { get; private set; }
    public StdHeader(long offset, int headerLength);
    public long get_Offset();
    public int get_HeaderLength();
    [CompilerGeneratedAttribute]
public UInt32 get_NextHeaderOffset();
    [CompilerGeneratedAttribute]
private void set_NextHeaderOffset(UInt32 value);
    [NullableContextAttribute("1")]
public void Read(StdFontReader reader);
    public bool IsPositionInside(long position);
}
internal class Syncfusion.PdfViewer.Base.String : PostScriptOperators {
    [NullableContextAttribute("1")]
public virtual void Execute(FontInterpreter interpreter);
}
internal class Syncfusion.PdfViewer.Base.SystemDict : PostScriptOperators {
    [NullableContextAttribute("1")]
public virtual void Execute(FontInterpreter interpteret);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Syncfusion.PdfViewer.Base.TextElement : object {
    internal float TextHorizontalScaling;
    private SystemFontOpenTypeFontSource openTypeFontSource;
    private String[] names;
    private SystemFontFontsManager systemFontsManager;
    private Nullable`1<CharCode> firstCode;
    internal static StdFontsAssistant manager;
    internal Matrix documentMatrix;
    internal int Rise;
    internal Matrix textLineMatrix;
    internal Matrix Ctm;
    internal Matrix transformMatrix;
    private FontSource FontSource;
    private TransformationStack transformations;
    internal string FontID;
    private bool m_isMpdfFont;
    internal static Dictionary`2<string, FontSource> fontSourceCache;
    internal Dictionary`2<string, double> ReverseMapTable;
    internal bool IsType1Font;
    internal bool Is1C;
    internal CffGlyphs m_cffGlyphs;
    internal Dictionary`2<string, Byte[]> m_type1FontGlyphs;
    internal Font textFont;
    internal string renderedText;
    private float CharSizeMultiplier;
    internal string m_fontName;
    internal FontStyle m_fontStyle;
    internal float m_fontSize;
    internal Color m_textcolor;
    internal string m_fontEncoding;
    internal string m_text;
    internal RenderedString renderedString;
    internal int m_finalAngle;
    private bool m_spaceCheck;
    internal float m_wordSpacing;
    internal float m_characterSpacing;
    internal float m_textScaling;
    internal int m_renderingMode;
    private Font m_font;
    internal bool isNegativeFont;
    private static Dictionary`2<string, string> fontList;
    private PdfViewerExceptions exceptions;
    internal Dictionary`2<int, int> FontGlyphWidths;
    internal float DefaultGlyphWidth;
    internal bool IsTransparentText;
    internal bool IsCID;
    internal bool IsFindText;
    internal bool IsPdfium;
    internal Dictionary`2<double, string> CharacterMapTable;
    internal Dictionary`2<int, string> differenceTable;
    internal Dictionary`2<string, string> differenceMappedTable;
    internal Dictionary`2<int, int> OctDecMapTable;
    internal Dictionary`2<int, int> EncodedTextBytes;
    internal Dictionary`2<int, int> CidToGidReverseMapTable;
    internal Dictionary`2<int, string> UnicodeCharMapTable;
    internal FontFile2 Fontfile2Glyph;
    internal float Textscalingfactor;
    internal FontStructure structure;
    internal bool IsContainFontfile2;
    public float currentGlyphWidth;
    internal bool Isembeddedfont;
    internal int FontFlag;
    internal float LineWidth;
    internal Dictionary`2<SystemFontFontDescriptor, SystemFontOpenTypeFontSource> testdict;
    internal Image type3GlyphImage;
    internal Matrix type3TextMatrix;
    internal List`1<Glyph> textElementGlyphList;
    internal float pageRotation;
    internal float zoomFactor;
    internal List`1<object> htmldata;
    internal Dictionary`2<string, string> SubstitutedFontsList;
    private object fontResourceLocker;
    private bool m_isExtractTextData;
    private string m_embeddedFontFamily;
    internal bool m_isRectation;
    private bool m_isUpdated;
    private bool m_isFound;
    internal bool isExtractText;
    internal bool isRedaction;
    internal int m_mcid;
    private int dpiY;
    private Int64[] MacRomanToUnicode;
    [CompilerGeneratedAttribute]
private CharCode <CharID>k__BackingField;
    private string m_zapfPostScript;
    internal Color m_brushColor;
    private Dictionary`2<int, string> m_macEncodeTable;
    [CompilerGeneratedAttribute]
private bool <IsTextGlyphAdded>k__BackingField;
    internal int RotateAngle { get; internal set; }
    internal bool IsExtractTextData { get; internal set; }
    internal string FontName { get; internal set; }
    internal Font Font { get; internal set; }
    internal CharCode CharID { get; internal set; }
    internal Color TextColor { get; internal set; }
    internal FontStyle FontStyle { get; internal set; }
    internal float FontSize { get; internal set; }
    public string ZapfPostScript { get; public set; }
    internal string FontEncoding { get; internal set; }
    internal string Text { get; internal set; }
    internal float WordSpacing { get; internal set; }
    internal float CharacterSpacing { get; internal set; }
    internal float TextScaling { get; internal set; }
    internal int RenderingMode { get; internal set; }
    internal Color BrushColor { get; internal set; }
    internal bool IsNonsymbolic { get; }
    private bool IsTextGlyphAdded { get; private set; }
    internal SystemFontFontsManager SystemFontsManager { get; }
    internal TextElement(string text);
    internal TextElement(string text, Matrix transformMatrix);
    internal TextElement(Image img, Matrix transformMatrix);
    private static TextElement();
    internal int get_RotateAngle();
    internal void set_RotateAngle(int value);
    internal bool get_IsExtractTextData();
    internal void set_IsExtractTextData(bool value);
    internal string get_FontName();
    internal void set_FontName(string value);
    internal Font get_Font();
    internal void set_Font(Font value);
    [CompilerGeneratedAttribute]
internal CharCode get_CharID();
    [CompilerGeneratedAttribute]
internal void set_CharID(CharCode value);
    internal Color get_TextColor();
    internal void set_TextColor(Color value);
    internal FontStyle get_FontStyle();
    internal void set_FontStyle(FontStyle value);
    internal float get_FontSize();
    internal void set_FontSize(float value);
    public string get_ZapfPostScript();
    public void set_ZapfPostScript(string value);
    internal string get_FontEncoding();
    internal void set_FontEncoding(string value);
    internal string get_Text();
    internal void set_Text(string value);
    internal float get_WordSpacing();
    internal void set_WordSpacing(float value);
    internal float get_CharacterSpacing();
    internal void set_CharacterSpacing(float value);
    internal float get_TextScaling();
    internal void set_TextScaling(float value);
    internal int get_RenderingMode();
    internal void set_RenderingMode(int value);
    private Matrix GetTextRenderingMatrix();
    private String[] GetStandardFontEncodingNames();
    public virtual double GetGlyphWidth(Glyph glyph);
    private double GetSystemFontGlyphWidth(Glyph glyph);
    private string GetGlyphName(Glyph glyph);
    private void GlyphToSLCoordinates(Glyph glyph);
    private Matrix GetTransformationMatrix(Matrix transform);
    private void UpdateTextMatrix(double tj);
    private void UpdateTextMatrix(Glyph glyph);
    private Matrix CalculateTextMatrix(Matrix m, Glyph glyph);
    internal Color get_BrushColor();
    internal void set_BrushColor(Color value);
    private string ResolveFontName(string matrixImplFontName);
    internal bool get_IsNonsymbolic();
    private bool GetFlag(byte bit);
    public bool GetBit(int n, byte bit);
    private int GetInt(Byte[] val);
    internal float Render(GraphicsObject g, PointF currentLocation, double textScaling, Dictionary`2<int, int> gWidths, double type1Height, Dictionary`2<int, string> differenceTable, Dictionary`2<string, string> differenceMappedTable, Dictionary`2<int, string> differenceEncoding, Matrix& txtMatrix);
    private bool DrawSystemFontGlyphShape(char letter, GraphicsObject g, Matrix& temptextmatrix);
    internal float RenderWithSpace(GraphicsObject g, PointF currentLocation, List`1<RenderedString> decodedList, List`1<float> characterSpacings, double textScaling, Dictionary`2<int, int> gWidths, double type1Height, Dictionary`2<int, string> differenceTable, Dictionary`2<string, string> differenceMappedTable, Dictionary`2<int, string> differenceEncoding, Matrix& textmatrix);
    [CompilerGeneratedAttribute]
private void set_IsTextGlyphAdded(bool value);
    [CompilerGeneratedAttribute]
private bool get_IsTextGlyphAdded();
    private void GetMacEncodeTable();
    private void RenderReverseMapTableByte(char character, GraphicsObject g);
    private ushort GetGlyphID(string glyphName);
    private ushort GetGlyphsFromMacintoshRomanWithoutEncoding(SystemFontCMapTable roman, string glyphName);
    private ushort GetGlyphsFromMicrosoftSymbolWithoutEncoding(SystemFontCMapTable unicode, string glyphName);
    private void CalculateByteToAppend(SystemFontCMapTable unicode);
    private bool TryAppendByte(byte b, UInt16& res);
    private ushort GetGlyphsFromMacintoshRomanWithEncoding(SystemFontCMapTable cMapTable, string glyphName);
    private ushort GetGlyphsFromMicrosoftUnicodeWithEncoding(SystemFontCMapTable unicode, string glyphName);
    private string GetName(byte b);
    private void Initialize();
    private void MapDifferenceElement();
    private ushort GetGlyphIdFromPostTable(string name);
    internal SystemFontFontsManager get_SystemFontsManager();
    public void DrawGlyphs(float glyphwidth, GraphicsObject g, Matrix& temptextmatrix, string glyphChar);
    internal string MapEscapeSequence(char letter);
    internal bool isMpdfaaFonts();
    private string SkipEscapeSequence(string text);
    internal void CheckFontStyle(string fontName);
    internal static string CheckFontName(string fontName);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Syncfusion.PdfViewer.Base.TexturePaint : object {
    private int m_heights;
    private int m_widths;
    private string m_images;
    public int Height { get; public set; }
    public int Width { get; public set; }
    public string Image { get; public set; }
    public int get_Height();
    public void set_Height(int value);
    public int get_Width();
    public void set_Width(int value);
    public string get_Image();
    public void set_Image(string value);
}
internal class Syncfusion.PdfViewer.Base.ThreeByteIntegerEncodingBase : ByteEncodingBase {
    [NullableContextAttribute("1")]
public virtual object Read(EncodedDataParser reader);
}
internal enum Syncfusion.PdfViewer.Base.Token : Enum {
    public int value__;
    public static Token Operator;
    public static Token Integer;
    public static Token Real;
    public static Token Name;
    public static Token ArrayStart;
    public static Token ArrayEnd;
    public static Token Unknown;
    public static Token Keyword;
    public static Token String;
    public static Token Boolean;
    public static Token DictionaryStart;
    public static Token Null;
    public static Token EndOfFile;
    public static Token DictionaryEnd;
    public static Token StartXRef;
    public static Token XRef;
    public static Token StreamStart;
    public static Token StreamEnd;
    public static Token IndirectObjectStart;
    public static Token IndirectObjectEnd;
    public static Token IndirectReference;
    public static Token Trailer;
}
internal class Syncfusion.PdfViewer.Base.TransformationStack : object {
    private Matrix currentTransform;
    private Matrix _initialTransform;
    [NullableAttribute("1")]
private Stack`1<Matrix> transformStack;
    public Matrix CurrentTransform { get; }
    public TransformationStack(Matrix initialTransform);
    public Matrix get_CurrentTransform();
    public void PushTransform(Matrix transformMatrix);
    public void PopTransform();
    public void Clear();
}
internal class Syncfusion.PdfViewer.Base.TwoByteIntegerEncodingType1Base : ByteEncodingBase {
    [NullableContextAttribute("1")]
public virtual object Read(EncodedDataParser reader);
}
internal class Syncfusion.PdfViewer.Base.TwoByteIntegerEncodingType2Base : ByteEncodingBase {
    [NullableContextAttribute("1")]
public virtual object Read(EncodedDataParser reader);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal static class Syncfusion.PdfViewer.Base.Type1Converters : object {
    [CompilerGeneratedAttribute]
private static EncodingConverter <EncodingConverter>k__BackingField;
    [CompilerGeneratedAttribute]
private static PostScriptObjectConverter <PostScriptObjectConverter>k__BackingField;
    public static EncodingConverter EncodingConverter { get; private set; }
    public static PostScriptObjectConverter PostScriptObjectConverter { get; private set; }
    private static Type1Converters();
    [CompilerGeneratedAttribute]
public static EncodingConverter get_EncodingConverter();
    [CompilerGeneratedAttribute]
private static void set_EncodingConverter(EncodingConverter value);
    [CompilerGeneratedAttribute]
public static PostScriptObjectConverter get_PostScriptObjectConverter();
    [CompilerGeneratedAttribute]
private static void set_PostScriptObjectConverter(PostScriptObjectConverter value);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Syncfusion.PdfViewer.Base.Type1FontReader : PostScriptParser {
    public Type1FontReader(Byte[] data);
    public static Byte[] StripData(Byte[] data);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Syncfusion.PdfViewer.Base.Type1FontSource : FontSource {
    [CompilerGeneratedAttribute]
private BaseType1Font <Font>k__BackingField;
    public string FontFamily { get; }
    public bool IsBold { get; }
    public bool IsItalic { get; }
    public short Ascender { get; }
    public short Descender { get; }
    public BaseType1Font Font { get; private set; }
    public Type1FontSource(Byte[] data);
    public virtual string get_FontFamily();
    public virtual bool get_IsBold();
    public virtual bool get_IsItalic();
    public virtual short get_Ascender();
    public virtual short get_Descender();
    [CompilerGeneratedAttribute]
public BaseType1Font get_Font();
    [CompilerGeneratedAttribute]
private void set_Font(BaseType1Font value);
    public virtual void GetGlyphName(Glyph glyph);
    private void Initialize(Byte[] data);
    public virtual void GetAdvancedWidth(Glyph glyph);
    public virtual void GetGlyphOutlines(Glyph glyph, double fontSize);
}
internal class Syncfusion.PdfViewer.Base.Vector : ValueType {
    internal double _x;
    internal double _y;
    public double Length { get; }
    public double LengthSquared { get; }
    public double X { get; public set; }
    public double Y { get; public set; }
    public Vector(double x, double y);
    public double get_Length();
    public double get_LengthSquared();
    public double get_X();
    public void set_X(double value);
    public double get_Y();
    public void set_Y(double value);
    public static Vector Add(Vector vector1, Vector vector2);
    public static Point Add(Vector vector, Point point);
    public static double AngleBetween(Vector vector1, Vector vector2);
    public static double CrossProduct(Vector vector1, Vector vector2);
    public static double Determinant(Vector vector1, Vector vector2);
    public static Vector Divide(Vector vector, double scalar);
    public static bool Equals(Vector vector1, Vector vector2);
    [NullableContextAttribute("1")]
public virtual bool Equals(object o);
    public bool Equals(Vector value);
    public virtual int GetHashCode();
    public static Vector Multiply(Vector vector, double scalar);
    public static Vector Multiply(double scalar, Vector vector);
    public static double Multiply(Vector vector1, Vector vector2);
    public void Negate();
    public static Vector op_Addition(Vector vector1, Vector vector2);
    public static Point op_Addition(Vector vector, Point point);
    public static Vector op_Division(Vector vector, double scalar);
    public static bool op_Equality(Vector vector1, Vector vector2);
    public static Size op_Explicit(Vector vector);
    public static Point op_Explicit(Vector vector);
    public static bool op_Inequality(Vector vector1, Vector vector2);
    public static Vector op_Multiply(Vector vector, double scalar);
    public static Vector op_Multiply(double scalar, Vector vector);
    public static double op_Multiply(Vector vector1, Vector vector2);
    public static Vector op_Subtraction(Vector vector1, Vector vector2);
    public static Vector op_UnaryNegation(Vector vector);
    public static Vector Subtract(Vector vector1, Vector vector2);
    [NullableContextAttribute("1")]
private sealed virtual override string System.IFormattable.ToString(string format, IFormatProvider formatProvider);
}
internal class Syncfusion.PdfViewer.Base.VHCurveTo : Operator {
    [NullableContextAttribute("1")]
public virtual void Execute(CharacterBuilder interpreter);
}
internal class Syncfusion.PdfViewer.Base.VLineTo : Operator {
    [NullableContextAttribute("1")]
public virtual void Execute(CharacterBuilder interpreter);
}
internal class Syncfusion.PdfViewer.Base.VMoveTo : Operator {
    [NullableContextAttribute("1")]
public virtual void Execute(CharacterBuilder interpreter);
}
internal class Syncfusion.PdfViewer.Base.VVCurveTo : Operator {
    [NullableContextAttribute("1")]
public virtual void Execute(CharacterBuilder interpreter);
}
internal enum System.Drawing.Drawing2D.PathPointType : Enum {
    public int value__;
    public static PathPointType Start;
    public static PathPointType Line;
    public static PathPointType Bezier3;
    public static PathPointType Bezier;
    public static PathPointType PathTypeMask;
    public static PathPointType DashMode;
    public static PathPointType PathMarker;
    public static PathPointType CloseSubpath;
}
[CompilerGeneratedAttribute]
[EmbeddedAttribute]
[AttributeUsageAttribute("27524")]
internal class System.Runtime.CompilerServices.NullableAttribute : Attribute {
    public Byte[] NullableFlags;
    public NullableAttribute(byte );
    public NullableAttribute(Byte[] );
}
[CompilerGeneratedAttribute]
[EmbeddedAttribute]
[AttributeUsageAttribute("5196")]
internal class System.Runtime.CompilerServices.NullableContextAttribute : Attribute {
    public byte Flag;
    public NullableContextAttribute(byte );
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class System.Text.Windows1252Encoding : Encoding {
    private static Int32[] m_charCodeTable;
    private static Windows1252Encoding();
    public virtual Byte[] GetBytes(string s);
    public virtual string GetString(Byte[] bytes, int index, int count);
    public virtual int GetByteCount(Char[] chars, int index, int count);
    public virtual int GetBytes(Char[] chars, int charIndex, int charCount, Byte[] bytes, int byteIndex);
    public virtual int GetCharCount(Byte[] bytes, int index, int count);
    public virtual int GetChars(Byte[] bytes, int byteIndex, int byteCount, Char[] chars, int charIndex);
    public virtual int GetMaxByteCount(int charCount);
    public virtual int GetMaxCharCount(int byteCount);
}
internal class TextProperties : object {
    private Color m_strokingBrush;
    private RectangleF m_bounds;
    internal Color StrokingBrush { get; }
    internal RectangleF Bounds { get; }
    internal TextProperties(Color brush, RectangleF bounds);
    internal TextProperties(RectangleF bounds);
    internal Color get_StrokingBrush();
    internal RectangleF get_Bounds();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class TextSearchItem : object {
    [CompilerGeneratedAttribute]
private string <SearchWord>k__BackingField;
    [CompilerGeneratedAttribute]
private TextSearchOptions <SearchOption>k__BackingField;
    internal string SearchWord { get; internal set; }
    internal TextSearchOptions SearchOption { get; internal set; }
    public TextSearchItem(string searchWord, TextSearchOptions searchOption);
    [CompilerGeneratedAttribute]
internal string get_SearchWord();
    [CompilerGeneratedAttribute]
internal void set_SearchWord(string value);
    [CompilerGeneratedAttribute]
internal TextSearchOptions get_SearchOption();
    [CompilerGeneratedAttribute]
internal void set_SearchOption(TextSearchOptions value);
}
[FlagsAttribute]
public enum TextSearchOptions : Enum {
    public int value__;
    public static TextSearchOptions None;
    public static TextSearchOptions WholeWords;
    public static TextSearchOptions CaseSensitive;
}
