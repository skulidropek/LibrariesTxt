[DebuggerDisplayAttribute("{_thisType}, AnyOfType = {_currentType}; Type = {_currentValueType?.Name}; Value = '{ToString()}'")]
internal class AnyOfTypes.AnyOf`2 : ValueType {
    private int _numberOfTypes;
    private object _currentValue;
    private Type _currentValueType;
    private AnyOfType _currentType;
    private TFirst _first;
    private TSecond _second;
    private string _thisType { get; }
    public AnyOfType[] AnyOfTypes { get; }
    public Type[] Types { get; }
    public bool IsUndefined { get; }
    public bool IsFirst { get; }
    public bool IsSecond { get; }
    public TFirst First { get; }
    public TSecond Second { get; }
    public AnyOfType CurrentType { get; }
    public object CurrentValue { get; }
    public Type CurrentValueType { get; }
    public AnyOf`2(TFirst value);
    public AnyOf`2(TSecond value);
    [IsReadOnlyAttribute]
private string get__thisType();
    [IsReadOnlyAttribute]
public AnyOfType[] get_AnyOfTypes();
    [IsReadOnlyAttribute]
public Type[] get_Types();
    public bool get_IsUndefined();
    public bool get_IsFirst();
    public bool get_IsSecond();
    public static AnyOf`2<TFirst, TSecond> op_Implicit(TFirst value);
    public static TFirst op_Implicit(AnyOf`2<TFirst, TSecond> this);
    public TFirst get_First();
    public static AnyOf`2<TFirst, TSecond> op_Implicit(TSecond value);
    public static TSecond op_Implicit(AnyOf`2<TFirst, TSecond> this);
    public TSecond get_Second();
    private void Validate(AnyOfType desiredType);
    public AnyOfType get_CurrentType();
    public object get_CurrentValue();
    public Type get_CurrentValueType();
    public virtual int GetHashCode();
    private bool Equals(AnyOf`2<TFirst, TSecond> other);
    public static bool op_Equality(AnyOf`2<TFirst, TSecond> obj1, AnyOf`2<TFirst, TSecond> obj2);
    public static bool op_Inequality(AnyOf`2<TFirst, TSecond> obj1, AnyOf`2<TFirst, TSecond> obj2);
    public virtual bool Equals(object obj);
    public virtual string ToString();
}
internal enum AnyOfTypes.AnyOfType : Enum {
    public int value__;
    public static AnyOfType Undefined;
    public static AnyOfType First;
    public static AnyOfType Second;
    public static AnyOfType Third;
    public static AnyOfType Fourth;
    public static AnyOfType Fifth;
    public static AnyOfType Sixth;
    public static AnyOfType Seventh;
    public static AnyOfType Eighth;
    public static AnyOfType Ninth;
    public static AnyOfType Tenth;
}
internal static class AnyOfTypes.HashCodeCalculator : object {
    public static int GetHashCode(IEnumerable`1<object> hashFieldValues);
    [CompilerGeneratedAttribute]
internal static int <GetHashCode>g__HashCodeAggregator|0_0(int hashCode, object value);
}
[CompilerGeneratedAttribute]
[EmbeddedAttribute]
internal class Microsoft.CodeAnalysis.EmbeddedAttribute : Attribute {
}
[AttributeUsageAttribute("2048")]
[DebuggerNonUserCodeAttribute]
internal class System.Diagnostics.CodeAnalysis.NotNullWhenAttribute : Attribute {
    [CompilerGeneratedAttribute]
private bool <ReturnValue>k__BackingField;
    public bool ReturnValue { get; }
    public NotNullWhenAttribute(bool returnValue);
    [CompilerGeneratedAttribute]
public bool get_ReturnValue();
}
internal static class System.Linq.Dynamic.Core.AssemblyBuilderFactory : object {
    [NullableContextAttribute("1")]
public static AssemblyBuilder DefineDynamicAssembly(AssemblyName name, AssemblyBuilderAccess access);
}
public enum System.Linq.Dynamic.Core.Config.StringLiteralParsingType : Enum {
    public byte value__;
    public static StringLiteralParsingType Default;
    public static StringLiteralParsingType EscapeDoubleQuoteByTwoDoubleQuotes;
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public abstract class System.Linq.Dynamic.Core.CustomTypeProviders.AbstractDynamicLinqCustomTypeProvider : object {
    protected IEnumerable`1<Type> FindTypesMarkedWithDynamicLinqTypeAttribute(IEnumerable`1<Assembly> assemblies);
    protected Type ResolveType(IEnumerable`1<Assembly> assemblies, string typeName);
    protected Type ResolveTypeBySimpleName(IEnumerable`1<Assembly> assemblies, string simpleTypeName);
    protected Type[] GetAssemblyTypesWithDynamicLinqTypeAttribute(IEnumerable`1<Assembly> assemblies);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class System.Linq.Dynamic.Core.CustomTypeProviders.DefaultDynamicLinqCustomTypeProvider : AbstractDynamicLinqCustomTypeProvider {
    private IAssemblyHelper _assemblyHelper;
    private bool _cacheCustomTypes;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private HashSet`1<Type> _cachedCustomTypes;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private Dictionary`2<Type, List`1<MethodInfo>> _cachedExtensionMethods;
    [ObsoleteAttribute("Please use the DefaultDynamicLinqCustomTypeProvider(ParsingConfig config, bool cacheCustomTypes = true) constructor.")]
public DefaultDynamicLinqCustomTypeProvider(bool cacheCustomTypes);
    public DefaultDynamicLinqCustomTypeProvider(ParsingConfig config, bool cacheCustomTypes);
    public virtual HashSet`1<Type> GetCustomTypes();
    public sealed virtual Dictionary`2<Type, List`1<MethodInfo>> GetExtensionMethods();
    public sealed virtual Type ResolveType(string typeName);
    public sealed virtual Type ResolveTypeBySimpleName(string simpleTypeName);
    private HashSet`1<Type> GetCustomTypesInternal();
    private Dictionary`2<Type, List`1<MethodInfo>> GetExtensionMethodsInternal();
}
[AttributeUsageAttribute("1052")]
public class System.Linq.Dynamic.Core.CustomTypeProviders.DynamicLinqTypeAttribute : Attribute {
}
public interface System.Linq.Dynamic.Core.CustomTypeProviders.IDynamicLinkCustomTypeProvider {
}
[NullableContextAttribute("1")]
public interface System.Linq.Dynamic.Core.CustomTypeProviders.IDynamicLinqCustomTypeProvider {
    public abstract virtual HashSet`1<Type> GetCustomTypes();
    public abstract virtual Dictionary`2<Type, List`1<MethodInfo>> GetExtensionMethods();
    public abstract virtual Type ResolveType(string typeName);
    public abstract virtual Type ResolveTypeBySimpleName(string simpleTypeName);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class System.Linq.Dynamic.Core.DefaultAssemblyHelper : object {
    private ParsingConfig _config;
    public DefaultAssemblyHelper(ParsingConfig parsingConfig);
    public sealed virtual Assembly[] GetAssemblies();
}
public class System.Linq.Dynamic.Core.DefaultQueryableAnalyzer : object {
    [NullableContextAttribute("1")]
public sealed virtual bool SupportsLinqToObjects(IQueryable query, IQueryProvider provider);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[DefaultMemberAttribute("Item")]
public abstract class System.Linq.Dynamic.Core.DynamicClass : DynamicObject {
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private Dictionary`2<string, object> _propertiesDictionary;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private Dictionary`2<string, object> Properties { get; }
    [NullableAttribute("2")]
public object Item { get; public set; }
    private Dictionary`2<string, object> get_Properties();
    [NullableContextAttribute("2")]
public T GetDynamicPropertyValue(string propertyName);
    public object GetDynamicPropertyValue(string propertyName);
    public void SetDynamicPropertyValue(string propertyName, T value);
    public void SetDynamicPropertyValue(string propertyName, object value);
    public object get_Item(string name);
    public void set_Item(string name, object value);
    public virtual IEnumerable`1<string> GetDynamicMemberNames();
    public virtual bool TryGetMember(GetMemberBinder binder, Object& result);
    public virtual bool TrySetMember(SetMemberBinder binder, object value);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public static class System.Linq.Dynamic.Core.DynamicClassFactory : object {
    private static string DynamicAssemblyName;
    private static string DynamicModuleName;
    private static CustomAttributeBuilder CompilerGeneratedAttributeBuilder;
    private static CustomAttributeBuilder DebuggerBrowsableAttributeBuilder;
    private static CustomAttributeBuilder DebuggerHiddenAttributeBuilder;
    private static ConstructorInfo ObjectCtor;
    private static MethodInfo ObjectToString;
    private static ConstructorInfo StringBuilderCtor;
    private static MethodInfo StringBuilderAppendString;
    private static MethodInfo StringBuilderAppendObject;
    private static Type EqualityComparer;
    private static ConcurrentDictionary`2<string, Type> GeneratedTypes;
    private static ModuleBuilder ModuleBuilder;
    private static int _index;
    private static DynamicClassFactory();
    public static Type CreateGenericComparerType(Type comparerGenericType, Type comparerType);
    public static Type CreateType(IList`1<DynamicProperty> properties, bool createParameterCtor);
    private static Type EmitType(IList`1<DynamicProperty> properties, bool createParameterCtor);
    private static void EmitEqualityOperators(TypeBuilder typeBuilder, MethodBuilder equals);
    private static string GenerateKey(IEnumerable`1<DynamicProperty> dynamicProperties, bool createParameterCtor);
    private static string Escape(string str);
    internal static void ClearGeneratedTypes();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ExtensionAttribute]
public static class System.Linq.Dynamic.Core.DynamicEnumerableAsyncExtensions : object {
    private static MethodInfo ToListAsyncGenericMethod;
    private static DynamicEnumerableAsyncExtensions();
    [AsyncStateMachineAttribute("System.Linq.Dynamic.Core.DynamicEnumerableAsyncExtensions/<ToDynamicArrayAsync>d__2")]
[ExtensionAttribute]
public static Task`1<Object[]> ToDynamicArrayAsync(IEnumerable source, Type type, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("System.Linq.Dynamic.Core.DynamicEnumerableAsyncExtensions/<ToDynamicArrayAsync>d__3")]
[ExtensionAttribute]
public static Task`1<Object[]> ToDynamicArrayAsync(IEnumerable source, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("System.Linq.Dynamic.Core.DynamicEnumerableAsyncExtensions/<ToDynamicArrayAsync>d__4`1")]
[ExtensionAttribute]
public static Task`1<T[]> ToDynamicArrayAsync(IEnumerable source, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("System.Linq.Dynamic.Core.DynamicEnumerableAsyncExtensions/<ToDynamicListAsync>d__5")]
[ExtensionAttribute]
public static Task`1<List`1<object>> ToDynamicListAsync(IEnumerable source, Type type, CancellationToken cancellationToken);
    [ExtensionAttribute]
public static Task`1<List`1<object>> ToDynamicListAsync(IEnumerable source, CancellationToken cancellationToken);
    [ExtensionAttribute]
public static Task`1<List`1<T>> ToDynamicListAsync(IEnumerable source, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("System.Linq.Dynamic.Core.DynamicEnumerableAsyncExtensions/<ToListAsync>d__8`1")]
private static Task`1<List`1<T>> ToListAsync(IEnumerable source, CancellationToken cancellationToken);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ExtensionAttribute]
public static class System.Linq.Dynamic.Core.DynamicEnumerableExtensions : object {
    private static MethodInfo ToDynamicArrayGenericMethod;
    private static DynamicEnumerableExtensions();
    [ExtensionAttribute]
public static Object[] ToDynamicArray(IEnumerable source);
    [ExtensionAttribute]
public static T[] ToDynamicArray(IEnumerable source);
    [ExtensionAttribute]
public static Object[] ToDynamicArray(IEnumerable source, Type type);
    [ExtensionAttribute]
public static List`1<object> ToDynamicList(IEnumerable source);
    [ExtensionAttribute]
public static List`1<object> ToDynamicList(IEnumerable source, Type type);
    [ExtensionAttribute]
public static List`1<T> ToDynamicList(IEnumerable source);
    internal static T[] CastToArray(IEnumerable source);
    internal static List`1<T> CastToList(IEnumerable source);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public static class System.Linq.Dynamic.Core.DynamicExpressionParser : object {
    public static LambdaExpression ParseLambda(ParsingConfig parsingConfig, bool createParameterCtor, Type resultType, string expression, Object[] values);
    public static LambdaExpression ParseLambda(Type delegateType, ParsingConfig parsingConfig, bool createParameterCtor, Type resultType, string expression, Object[] values);
    public static Expression`1<Func`1<TResult>> ParseLambda(ParsingConfig parsingConfig, bool createParameterCtor, string expression, Object[] values);
    public static Expression`1<Func`1<TResult>> ParseLambda(Type delegateType, ParsingConfig parsingConfig, bool createParameterCtor, string expression, Object[] values);
    public static LambdaExpression ParseLambda(ParsingConfig parsingConfig, bool createParameterCtor, ParameterExpression[] parameters, Type resultType, string expression, Object[] values);
    [NullableContextAttribute("2")]
public static LambdaExpression ParseLambda(Type delegateType, ParsingConfig parsingConfig, bool createParameterCtor, ParameterExpression[] parameters, Type resultType, string expression, Object[] values);
    public static Expression`1<Func`1<TResult>> ParseLambda(ParsingConfig parsingConfig, bool createParameterCtor, ParameterExpression[] parameters, string expression, Object[] values);
    public static Expression`1<Func`1<TResult>> ParseLambda(Type delegateType, ParsingConfig parsingConfig, bool createParameterCtor, ParameterExpression[] parameters, string expression, Object[] values);
    public static LambdaExpression ParseLambda(bool createParameterCtor, Type itType, Type resultType, string expression, Object[] values);
    [NullableContextAttribute("2")]
public static Expression`1<Func`2<T, TResult>> ParseLambda(ParsingConfig parsingConfig, bool createParameterCtor, string expression, Object[] values);
    public static Expression`1<Func`2<T, TResult>> ParseLambda(Type delegateType, ParsingConfig parsingConfig, bool createParameterCtor, string expression, Object[] values);
    public static LambdaExpression ParseLambda(ParsingConfig parsingConfig, Type resultType, string expression, Object[] values);
    public static LambdaExpression ParseLambda(Type delegateType, ParsingConfig parsingConfig, Type resultType, string expression, Object[] values);
    public static LambdaExpression ParseLambda(Type resultType, string expression, Object[] values);
    public static LambdaExpression ParseLambda(Type itType, Type resultType, string expression, Object[] values);
    public static LambdaExpression ParseLambda(ParsingConfig parsingConfig, Type itType, Type resultType, string expression, Object[] values);
    public static LambdaExpression ParseLambda(Type delegateType, ParsingConfig parsingConfig, Type itType, Type resultType, string expression, Object[] values);
    public static LambdaExpression ParseLambda(ParsingConfig parsingConfig, bool createParameterCtor, Type itType, Type resultType, string expression, Object[] values);
    public static LambdaExpression ParseLambda(Type delegateType, ParsingConfig parsingConfig, bool createParameterCtor, Type itType, Type resultType, string expression, Object[] values);
    public static LambdaExpression ParseLambda(ParameterExpression[] parameters, Type resultType, string expression, Object[] values);
    public static LambdaExpression ParseLambda(Type delegateType, ParameterExpression[] parameters, Type resultType, string expression, Object[] values);
    public static LambdaExpression ParseLambda(ParsingConfig parsingConfig, ParameterExpression[] parameters, Type resultType, string expression, Object[] values);
    public static LambdaExpression ParseLambda(Type delegateType, ParsingConfig parsingConfig, ParameterExpression[] parameters, Type resultType, string expression, Object[] values);
    public static LambdaExpression ParseLambda(bool createParameterCtor, ParameterExpression[] parameters, Type resultType, string expression, Object[] values);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class System.Linq.Dynamic.Core.DynamicGetMemberBinder : GetMemberBinder {
    private static MethodInfo DynamicGetMemberMethod;
    public DynamicGetMemberBinder(string name, ParsingConfig config);
    private static DynamicGetMemberBinder();
    public virtual DynamicMetaObject FallbackGetMember(DynamicMetaObject target, DynamicMetaObject errorSuggestion);
    public static object GetDynamicMember(object value, string name, bool ignoreCase);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class System.Linq.Dynamic.Core.DynamicOrdering : object {
    public Expression Selector;
    public bool Ascending;
    public string MethodName;
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class System.Linq.Dynamic.Core.DynamicProperty : object {
    [CompilerGeneratedAttribute]
private string <Name>k__BackingField;
    [CompilerGeneratedAttribute]
private Type <Type>k__BackingField;
    public string Name { get; }
    public Type Type { get; }
    public DynamicProperty(string name, Type type);
    [CompilerGeneratedAttribute]
public string get_Name();
    [CompilerGeneratedAttribute]
public Type get_Type();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ExtensionAttribute]
public static class System.Linq.Dynamic.Core.DynamicQueryableExtensions : object {
    private static TraceSource TraceSource;
    private static MethodInfo _AllPredicate;
    private static MethodInfo _any;
    private static MethodInfo _anyPredicate;
    private static MethodInfo _cast;
    private static MethodInfo _count;
    private static MethodInfo _countPredicate;
    private static MethodInfo _defaultIfEmpty;
    private static MethodInfo _defaultIfEmptyWithParam;
    private static MethodInfo _distinct;
    private static MethodInfo _first;
    private static MethodInfo _firstPredicate;
    private static MethodInfo _firstOrDefault;
    private static MethodInfo _firstOrDefaultPredicate;
    private static MethodInfo _last;
    private static MethodInfo _lastPredicate;
    private static MethodInfo _lastDefault;
    private static MethodInfo _lastDefaultPredicate;
    private static MethodInfo _longCount;
    private static MethodInfo _longCountPredicate;
    private static MethodInfo _max;
    private static MethodInfo _maxPredicate;
    private static MethodInfo _min;
    private static MethodInfo _minPredicate;
    private static MethodInfo _ofType;
    private static MethodInfo _singlePredicate;
    private static MethodInfo _singleDefaultPredicate;
    private static MethodInfo _skip;
    private static MethodInfo _skipWhilePredicate;
    private static MethodInfo _take;
    private static MethodInfo _takeWhilePredicate;
    private static DynamicQueryableExtensions();
    private static Expression OptimizeExpression(Expression expression);
    [ExtensionAttribute]
public static object Aggregate(IQueryable source, string function, string member);
    [ExtensionAttribute]
public static bool All(IQueryable source, string predicate, Object[] args);
    [ExtensionAttribute]
public static bool All(IQueryable source, ParsingConfig config, string predicate, Object[] args);
    [ExtensionAttribute]
public static bool Any(IQueryable source);
    [ExtensionAttribute]
public static bool Any(IQueryable source, ParsingConfig config, string predicate, Object[] args);
    [ExtensionAttribute]
public static bool Any(IQueryable source, string predicate, Object[] args);
    [ExtensionAttribute]
public static bool Any(IQueryable source, LambdaExpression lambda);
    [ExtensionAttribute]
public static double Average(IQueryable source);
    [ExtensionAttribute]
public static double Average(IQueryable source, ParsingConfig config, string predicate, Object[] args);
    [ExtensionAttribute]
public static double Average(IQueryable source, string predicate, Object[] args);
    [ExtensionAttribute]
public static double Average(IQueryable source, LambdaExpression lambda);
    [IteratorStateMachineAttribute("System.Linq.Dynamic.Core.DynamicQueryableExtensions/<AsDynamicEnumerable>d__16")]
[ExtensionAttribute]
public static IEnumerable`1<object> AsDynamicEnumerable(IQueryable source);
    [ExtensionAttribute]
public static IQueryable Cast(IQueryable source, Type type);
    [ExtensionAttribute]
public static IQueryable Cast(IQueryable source, ParsingConfig config, string typeName);
    [ExtensionAttribute]
public static IQueryable Cast(IQueryable source, string typeName);
    [ExtensionAttribute]
public static int Count(IQueryable source);
    [ExtensionAttribute]
public static int Count(IQueryable source, ParsingConfig config, string predicate, Object[] args);
    [ExtensionAttribute]
public static int Count(IQueryable source, string predicate, Object[] args);
    [ExtensionAttribute]
public static int Count(IQueryable source, LambdaExpression lambda);
    [ExtensionAttribute]
public static IQueryable DefaultIfEmpty(IQueryable source);
    [ExtensionAttribute]
public static IQueryable DefaultIfEmpty(IQueryable source, object defaultValue);
    [ExtensionAttribute]
public static IQueryable Distinct(IQueryable source);
    [ExtensionAttribute]
public static object First(IQueryable source);
    [ExtensionAttribute]
public static object First(IQueryable source, ParsingConfig config, string predicate, Object[] args);
    [ExtensionAttribute]
public static object First(IQueryable source, string predicate, Object[] args);
    [ExtensionAttribute]
public static object First(IQueryable source, LambdaExpression lambda);
    [ExtensionAttribute]
public static object FirstOrDefault(IQueryable source);
    [ExtensionAttribute]
public static object FirstOrDefault(IQueryable source, ParsingConfig config, string predicate, Object[] args);
    [ExtensionAttribute]
public static object FirstOrDefault(IQueryable source, string predicate, Object[] args);
    [ExtensionAttribute]
public static object FirstOrDefault(IQueryable source, LambdaExpression lambda);
    [ExtensionAttribute]
public static IQueryable GroupBy(IQueryable source, ParsingConfig config, string keySelector, string resultSelector, Object[] args);
    [ExtensionAttribute]
public static IQueryable GroupBy(IQueryable source, ParsingConfig config, string keySelector, string resultSelector, IEqualityComparer equalityComparer, Object[] args);
    internal static IQueryable InternalGroupBy(IQueryable source, ParsingConfig config, string keySelector, string resultSelector, IEqualityComparer equalityComparer, Object[] args);
    [ExtensionAttribute]
public static IQueryable GroupBy(IQueryable source, string keySelector, string resultSelector, Object[] args);
    [ExtensionAttribute]
public static IQueryable GroupBy(IQueryable source, string keySelector, string resultSelector, IEqualityComparer equalityComparer, Object[] args);
    [ExtensionAttribute]
public static IQueryable GroupBy(IQueryable source, ParsingConfig config, string keySelector, string resultSelector);
    [ExtensionAttribute]
public static IQueryable GroupBy(IQueryable source, string keySelector, string resultSelector);
    [ExtensionAttribute]
public static IQueryable GroupBy(IQueryable source, ParsingConfig config, string keySelector, string resultSelector, IEqualityComparer equalityComparer);
    [ExtensionAttribute]
public static IQueryable GroupBy(IQueryable source, string keySelector, string resultSelector, IEqualityComparer equalityComparer);
    [ExtensionAttribute]
public static IQueryable GroupBy(IQueryable source, ParsingConfig config, string keySelector, Object[] args);
    [ExtensionAttribute]
public static IQueryable GroupBy(IQueryable source, ParsingConfig config, string keySelector, IEqualityComparer equalityComparer, Object[] args);
    internal static IQueryable InternalGroupBy(IQueryable source, ParsingConfig config, string keySelector, IEqualityComparer equalityComparer, Object[] args);
    [ExtensionAttribute]
public static IQueryable GroupBy(IQueryable source, string keySelector, Object[] args);
    [ExtensionAttribute]
public static IQueryable GroupBy(IQueryable source, string keySelector, IEqualityComparer equalityComparer, Object[] args);
    [ExtensionAttribute]
public static IEnumerable`1<GroupResult> GroupByMany(IEnumerable`1<TElement> source, ParsingConfig config, String[] keySelectors);
    [ExtensionAttribute]
public static IEnumerable`1<GroupResult> GroupByMany(IEnumerable`1<TElement> source, String[] keySelectors);
    [ExtensionAttribute]
public static IEnumerable`1<GroupResult> GroupByMany(IEnumerable`1<TElement> source, Func`2[] keySelectors);
    private static IEnumerable`1<GroupResult> GroupByManyInternal(IEnumerable`1<TElement> source, Func`2[] keySelectors, int currentSelector);
    [ExtensionAttribute]
public static IQueryable GroupJoin(IQueryable outer, ParsingConfig config, IEnumerable inner, string outerKeySelector, string innerKeySelector, string resultSelector, Object[] args);
    [ExtensionAttribute]
public static IQueryable GroupJoin(IQueryable outer, IEnumerable inner, string outerKeySelector, string innerKeySelector, string resultSelector, Object[] args);
    [ExtensionAttribute]
public static IQueryable Join(IQueryable outer, ParsingConfig config, IEnumerable inner, string outerKeySelector, string innerKeySelector, string resultSelector, Object[] args);
    [ExtensionAttribute]
public static IQueryable Join(IQueryable outer, IEnumerable inner, string outerKeySelector, string innerKeySelector, string resultSelector, Object[] args);
    [ExtensionAttribute]
public static IQueryable`1<TElement> Join(IQueryable`1<TElement> outer, ParsingConfig config, IEnumerable`1<TElement> inner, string outerKeySelector, string innerKeySelector, string resultSelector, Object[] args);
    [ExtensionAttribute]
public static IQueryable`1<TElement> Join(IQueryable`1<TElement> outer, IEnumerable`1<TElement> inner, string outerKeySelector, string innerKeySelector, string resultSelector, Object[] args);
    [ExtensionAttribute]
public static object Last(IQueryable source);
    [ExtensionAttribute]
public static object Last(IQueryable source, ParsingConfig config, string predicate, Object[] args);
    [ExtensionAttribute]
public static object Last(IQueryable source, string predicate, Object[] args);
    [ExtensionAttribute]
public static object Last(IQueryable source, LambdaExpression lambda);
    [ExtensionAttribute]
public static object LastOrDefault(IQueryable source);
    [ExtensionAttribute]
public static object LastOrDefault(IQueryable source, ParsingConfig config, string predicate, Object[] args);
    [ExtensionAttribute]
public static object LastOrDefault(IQueryable source, string predicate, Object[] args);
    [ExtensionAttribute]
public static object LastOrDefault(IQueryable source, LambdaExpression lambda);
    [ExtensionAttribute]
public static long LongCount(IQueryable source);
    [ExtensionAttribute]
public static long LongCount(IQueryable source, ParsingConfig config, string predicate, Object[] args);
    [ExtensionAttribute]
public static long LongCount(IQueryable source, string predicate, Object[] args);
    [ExtensionAttribute]
public static long LongCount(IQueryable source, LambdaExpression lambda);
    [ExtensionAttribute]
public static object Max(IQueryable source);
    [ExtensionAttribute]
public static object Max(IQueryable source, ParsingConfig config, string predicate, Object[] args);
    [ExtensionAttribute]
public static object Max(IQueryable source, string predicate, Object[] args);
    [ExtensionAttribute]
public static object Max(IQueryable source, LambdaExpression lambda);
    [ExtensionAttribute]
public static object Min(IQueryable source);
    [ExtensionAttribute]
public static object Min(IQueryable source, ParsingConfig config, string predicate, Object[] args);
    [ExtensionAttribute]
public static object Min(IQueryable source, string predicate, Object[] args);
    [ExtensionAttribute]
public static object Min(IQueryable source, LambdaExpression lambda);
    [ExtensionAttribute]
public static IQueryable OfType(IQueryable source, Type type);
    [ExtensionAttribute]
public static IQueryable OfType(IQueryable source, ParsingConfig config, string typeName);
    [ExtensionAttribute]
public static IQueryable OfType(IQueryable source, string typeName);
    [ExtensionAttribute]
public static IOrderedQueryable`1<TSource> OrderBy(IQueryable`1<TSource> source, ParsingConfig config, string ordering, Object[] args);
    [ExtensionAttribute]
public static IOrderedQueryable`1<TSource> OrderBy(IQueryable`1<TSource> source, string ordering, Object[] args);
    [ExtensionAttribute]
public static IOrderedQueryable`1<TSource> OrderBy(IQueryable`1<TSource> source, ParsingConfig config, string ordering, IComparer comparer, Object[] args);
    [ExtensionAttribute]
public static IOrderedQueryable`1<TSource> OrderBy(IQueryable`1<TSource> source, string ordering, IComparer comparer, Object[] args);
    [ExtensionAttribute]
public static IOrderedQueryable OrderBy(IQueryable source, ParsingConfig config, string ordering, Object[] args);
    [ExtensionAttribute]
public static IOrderedQueryable OrderBy(IQueryable source, ParsingConfig config, string ordering, IComparer comparer, Object[] args);
    internal static IOrderedQueryable InternalOrderBy(IQueryable source, ParsingConfig config, string ordering, object comparer, Object[] args);
    [ExtensionAttribute]
public static IOrderedQueryable OrderBy(IQueryable source, string ordering, Object[] args);
    [ExtensionAttribute]
public static IOrderedQueryable OrderBy(IQueryable source, string ordering, IComparer comparer, Object[] args);
    [ExtensionAttribute]
public static IQueryable Page(IQueryable source, int page, int pageSize);
    [ExtensionAttribute]
public static IQueryable`1<TSource> Page(IQueryable`1<TSource> source, int page, int pageSize);
    [ExtensionAttribute]
public static PagedResult PageResult(IQueryable source, int page, int pageSize, Nullable`1<int> rowCount);
    [ExtensionAttribute]
public static PagedResult`1<TSource> PageResult(IQueryable`1<TSource> source, int page, int pageSize, Nullable`1<int> rowCount);
    [ExtensionAttribute]
public static IQueryable Reverse(IQueryable source);
    [ExtensionAttribute]
public static IQueryable Select(IQueryable source, ParsingConfig config, string selector, Object[] args);
    [ExtensionAttribute]
public static IQueryable Select(IQueryable source, string selector, Object[] args);
    [ExtensionAttribute]
public static IQueryable`1<TResult> Select(IQueryable source, ParsingConfig config, string selector, Object[] args);
    [ExtensionAttribute]
public static IQueryable`1<TResult> Select(IQueryable source, string selector, Object[] args);
    [ExtensionAttribute]
public static IQueryable Select(IQueryable source, ParsingConfig config, Type resultType, string selector, Object[] args);
    [ExtensionAttribute]
public static IQueryable Select(IQueryable source, Type resultType, string selector, Object[] args);
    [ExtensionAttribute]
public static IQueryable SelectMany(IQueryable source, ParsingConfig config, string selector, Object[] args);
    [ExtensionAttribute]
public static IQueryable SelectMany(IQueryable source, string selector, Object[] args);
    [ExtensionAttribute]
public static IQueryable SelectMany(IQueryable source, ParsingConfig config, Type resultType, string selector, Object[] args);
    [ExtensionAttribute]
public static IQueryable SelectMany(IQueryable source, Type resultType, string selector, Object[] args);
    private static IQueryable SelectManyInternal(IQueryable source, ParsingConfig config, Type resultType, string selector, Object[] args);
    [ExtensionAttribute]
public static IQueryable`1<TResult> SelectMany(IQueryable source, ParsingConfig config, string selector, Object[] args);
    [ExtensionAttribute]
public static IQueryable`1<TResult> SelectMany(IQueryable source, string selector, Object[] args);
    [ExtensionAttribute]
public static IQueryable SelectMany(IQueryable source, ParsingConfig config, string collectionSelector, string resultSelector, Object[] collectionSelectorArgs, Object[] resultSelectorArgs);
    [ExtensionAttribute]
public static IQueryable SelectMany(IQueryable source, string collectionSelector, string resultSelector, Object[] collectionSelectorArgs, Object[] resultSelectorArgs);
    [ExtensionAttribute]
public static IQueryable SelectMany(IQueryable source, ParsingConfig config, string collectionSelector, string resultSelector, string collectionParameterName, string resultParameterName, Object[] collectionSelectorArgs, Object[] resultSelectorArgs);
    [ExtensionAttribute]
public static IQueryable SelectMany(IQueryable source, string collectionSelector, string resultSelector, string collectionParameterName, string resultParameterName, Object[] collectionSelectorArgs, Object[] resultSelectorArgs);
    [ExtensionAttribute]
public static object Single(IQueryable source);
    [ExtensionAttribute]
public static object Single(IQueryable source, ParsingConfig config, string predicate, Object[] args);
    [ExtensionAttribute]
public static object Single(IQueryable source, string predicate, Object[] args);
    [ExtensionAttribute]
public static object Single(IQueryable source, LambdaExpression lambda);
    [ExtensionAttribute]
public static object SingleOrDefault(IQueryable source);
    [ExtensionAttribute]
public static object SingleOrDefault(IQueryable source, ParsingConfig config, string predicate, Object[] args);
    [ExtensionAttribute]
public static object SingleOrDefault(IQueryable source, string predicate, Object[] args);
    [ExtensionAttribute]
public static object SingleOrDefault(IQueryable source, LambdaExpression lambda);
    [ExtensionAttribute]
public static IQueryable Skip(IQueryable source, int count);
    [ExtensionAttribute]
public static IQueryable SkipWhile(IQueryable source, ParsingConfig config, string predicate, Object[] args);
    [ExtensionAttribute]
public static IQueryable SkipWhile(IQueryable source, string predicate, Object[] args);
    [ExtensionAttribute]
public static object Sum(IQueryable source);
    [ExtensionAttribute]
public static object Sum(IQueryable source, ParsingConfig config, string predicate, Object[] args);
    [ExtensionAttribute]
public static object Sum(IQueryable source, string predicate, Object[] args);
    [ExtensionAttribute]
public static object Sum(IQueryable source, LambdaExpression lambda);
    [ExtensionAttribute]
public static IQueryable Take(IQueryable source, int count);
    [ExtensionAttribute]
public static IQueryable TakeWhile(IQueryable source, ParsingConfig config, string predicate, Object[] args);
    [ExtensionAttribute]
public static IQueryable TakeWhile(IQueryable source, string predicate, Object[] args);
    [ExtensionAttribute]
public static IOrderedQueryable`1<TSource> ThenBy(IOrderedQueryable`1<TSource> source, ParsingConfig config, string ordering, Object[] args);
    [ExtensionAttribute]
public static IOrderedQueryable`1<TSource> ThenBy(IOrderedQueryable`1<TSource> source, string ordering, Object[] args);
    [ExtensionAttribute]
public static IOrderedQueryable`1<TSource> ThenBy(IOrderedQueryable`1<TSource> source, ParsingConfig config, string ordering, IComparer comparer, Object[] args);
    [ExtensionAttribute]
public static IOrderedQueryable`1<TSource> ThenBy(IOrderedQueryable`1<TSource> source, string ordering, IComparer comparer, Object[] args);
    [ExtensionAttribute]
public static IOrderedQueryable ThenBy(IOrderedQueryable source, ParsingConfig config, string ordering, Object[] args);
    [ExtensionAttribute]
public static IOrderedQueryable ThenBy(IOrderedQueryable source, ParsingConfig config, string ordering, IComparer comparer, Object[] args);
    internal static IOrderedQueryable InternalThenBy(IOrderedQueryable source, ParsingConfig config, string ordering, IComparer comparer, Object[] args);
    [ExtensionAttribute]
public static IOrderedQueryable ThenBy(IOrderedQueryable source, string ordering, Object[] args);
    [ExtensionAttribute]
public static IOrderedQueryable ThenBy(IOrderedQueryable source, string ordering, IComparer comparer, Object[] args);
    [ExtensionAttribute]
public static IQueryable`1<TSource> Where(IQueryable`1<TSource> source, ParsingConfig config, string predicate, Object[] args);
    [ExtensionAttribute]
public static IQueryable`1<TSource> Where(IQueryable`1<TSource> source, string predicate, Object[] args);
    [ExtensionAttribute]
public static IQueryable Where(IQueryable source, ParsingConfig config, string predicate, Object[] args);
    [ExtensionAttribute]
public static IQueryable Where(IQueryable source, string predicate, Object[] args);
    [ExtensionAttribute]
public static IQueryable Where(IQueryable source, LambdaExpression lambda);
    [ExtensionAttribute]
public static IQueryable`1<TSource> Where(IQueryable`1<TSource> source, LambdaExpression lambda);
    private static bool SupportsLinqToObjects(ParsingConfig config, IQueryable query);
    private static void CheckOuterAndInnerTypes(ParsingConfig config, bool createParameterCtor, Type outerType, Type innerType, string outerKeySelector, string innerKeySelector, LambdaExpression& outerSelectorLambda, LambdaExpression& innerSelectorLambda, Object[] args);
    private static IQueryable CreateQuery(MethodInfo operatorMethodInfo, IQueryable source);
    private static IQueryable CreateQuery(MethodInfo operatorMethodInfo, IQueryable source, LambdaExpression expression);
    private static IQueryable CreateQuery(MethodInfo operatorMethodInfo, IQueryable source, Expression expression);
    private static object Execute(MethodInfo operatorMethodInfo, IQueryable source);
    private static TResult Execute(MethodInfo operatorMethodInfo, IQueryable source);
    private static object Execute(MethodInfo operatorMethodInfo, IQueryable source, LambdaExpression expression);
    private static object Execute(MethodInfo operatorMethodInfo, IQueryable source, Expression expression);
    private static TResult Execute(MethodInfo operatorMethodInfo, IQueryable source, LambdaExpression expression);
    private static TResult Execute(MethodInfo operatorMethodInfo, IQueryable source, Expression expression);
    private static TResult ConvertResultIfNeeded(object result);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ExtensionAttribute]
public static class System.Linq.Dynamic.Core.DynamicQueryableWithFormattableStringExtensions : object {
    private static Regex ReplaceArgumentsRegex;
    private static DynamicQueryableWithFormattableStringExtensions();
    [ExtensionAttribute]
public static IQueryable WhereInterpolated(IQueryable source, ParsingConfig config, FormattableString predicate);
    [ExtensionAttribute]
public static IQueryable WhereInterpolated(IQueryable source, FormattableString predicate);
    [ExtensionAttribute]
public static IQueryable`1<TSource> WhereInterpolated(IQueryable`1<TSource> source, ParsingConfig config, FormattableString predicate);
    [ExtensionAttribute]
public static IQueryable`1<TSource> WhereInterpolated(IQueryable`1<TSource> source, FormattableString predicate);
    [ExtensionAttribute]
public static bool AllInterpolated(IQueryable source, FormattableString predicate);
    [ExtensionAttribute]
public static bool AllInterpolated(IQueryable source, ParsingConfig config, FormattableString predicate);
    [ExtensionAttribute]
public static bool AnyInterpolated(IQueryable source, ParsingConfig config, FormattableString predicate);
    [ExtensionAttribute]
public static bool AnyInterpolated(IQueryable source, FormattableString predicate);
    [ExtensionAttribute]
public static double AverageInterpolated(IQueryable source, ParsingConfig config, FormattableString predicate);
    [ExtensionAttribute]
public static double AverageInterpolated(IQueryable source, FormattableString predicate);
    [ExtensionAttribute]
public static object SingleInterpolated(IQueryable source, ParsingConfig config, FormattableString predicate);
    [ExtensionAttribute]
public static object SingleInterpolated(IQueryable source, FormattableString predicate);
    [ExtensionAttribute]
public static object SingleOrDefaultInterpolated(IQueryable source, ParsingConfig config, FormattableString predicate);
    [ExtensionAttribute]
public static object SingleOrDefaultInterpolated(IQueryable source, FormattableString predicate);
    [ExtensionAttribute]
public static IQueryable SkipWhileInterpolated(IQueryable source, ParsingConfig config, FormattableString predicate);
    [ExtensionAttribute]
public static IQueryable SkipWhileInterpolated(IQueryable source, FormattableString predicate);
    [ExtensionAttribute]
public static IQueryable TakeWhileInterpolated(IQueryable source, ParsingConfig config, FormattableString predicate);
    [ExtensionAttribute]
public static IQueryable TakeWhileInterpolated(IQueryable source, FormattableString predicate);
    [ExtensionAttribute]
public static object SumInterpolated(IQueryable source, ParsingConfig config, FormattableString predicate);
    [ExtensionAttribute]
public static object SumInterpolated(IQueryable source, FormattableString predicate);
    [ExtensionAttribute]
public static int CountInterpolated(IQueryable source, ParsingConfig config, FormattableString predicate);
    [ExtensionAttribute]
public static int CountInterpolated(IQueryable source, FormattableString predicate);
    [ExtensionAttribute]
public static object FirstInterpolated(IQueryable source, ParsingConfig config, FormattableString predicate);
    [ExtensionAttribute]
public static object FirstInterpolated(IQueryable source, FormattableString predicate);
    [ExtensionAttribute]
public static object FirstOrDefaultInterpolated(IQueryable source, ParsingConfig config, FormattableString predicate);
    [ExtensionAttribute]
public static object FirstOrDefaultInterpolated(IQueryable source, FormattableString predicate);
    [ExtensionAttribute]
public static object LastInterpolated(IQueryable source, ParsingConfig config, FormattableString predicate);
    [ExtensionAttribute]
public static object LastInterpolated(IQueryable source, FormattableString predicate);
    [ExtensionAttribute]
public static object LastOrDefaultInterpolated(IQueryable source, ParsingConfig config, FormattableString predicate);
    [ExtensionAttribute]
public static object LastOrDefaultInterpolated(IQueryable source, FormattableString predicate);
    [ExtensionAttribute]
public static long LongCountInterpolated(IQueryable source, ParsingConfig config, FormattableString predicate);
    [ExtensionAttribute]
public static long LongCountInterpolated(IQueryable source, FormattableString predicate);
    [ExtensionAttribute]
public static object MaxInterpolated(IQueryable source, ParsingConfig config, FormattableString predicate);
    [ExtensionAttribute]
public static object MaxInterpolated(IQueryable source, FormattableString predicate);
    [ExtensionAttribute]
public static object MinInterpolated(IQueryable source, ParsingConfig config, FormattableString predicate);
    [ExtensionAttribute]
public static object MinInterpolated(IQueryable source, FormattableString predicate);
    [ExtensionAttribute]
public static IQueryable SelectInterpolated(IQueryable source, ParsingConfig config, FormattableString selector);
    [ExtensionAttribute]
public static IQueryable SelectInterpolated(IQueryable source, ParsingConfig config, Type resultType, FormattableString selector);
    [ExtensionAttribute]
public static IQueryable SelectInterpolated(IQueryable source, FormattableString selector);
    [ExtensionAttribute]
public static IQueryable`1<TResult> SelectInterpolated(IQueryable source, ParsingConfig config, FormattableString selector);
    [ExtensionAttribute]
public static IQueryable`1<TResult> SelectInterpolated(IQueryable source, FormattableString selector);
    [ExtensionAttribute]
public static IQueryable SelectManyInterpolated(IQueryable source, ParsingConfig config, FormattableString collectionSelector, FormattableString resultSelector);
    [ExtensionAttribute]
public static IQueryable SelectManyInterpolated(IQueryable source, ParsingConfig config, FormattableString selector);
    [ExtensionAttribute]
public static IQueryable SelectManyInterpolated(IQueryable source, ParsingConfig config, Type resultType, FormattableString selector);
    [ExtensionAttribute]
public static IQueryable SelectManyInterpolated(IQueryable source, FormattableString collectionSelector, FormattableString resultSelector);
    [ExtensionAttribute]
public static IQueryable SelectManyInterpolated(IQueryable source, FormattableString selector);
    [ExtensionAttribute]
public static IQueryable SelectManyInterpolated(IQueryable source, Type resultType, FormattableString selector);
    [ExtensionAttribute]
public static IQueryable`1<TResult> SelectManyInterpolated(IQueryable source, ParsingConfig config, FormattableString selector);
    [ExtensionAttribute]
public static IQueryable`1<TResult> SelectManyInterpolated(IQueryable source, FormattableString selector);
    [ExtensionAttribute]
public static IOrderedQueryable OrderByInterpolated(IQueryable source, ParsingConfig config, FormattableString ordering, IComparer comparer);
    [ExtensionAttribute]
public static IOrderedQueryable OrderByInterpolated(IQueryable source, ParsingConfig config, FormattableString ordering);
    [ExtensionAttribute]
public static IOrderedQueryable OrderByInterpolated(IQueryable source, FormattableString ordering, IComparer comparer);
    [ExtensionAttribute]
public static IOrderedQueryable OrderByInterpolated(IQueryable source, FormattableString ordering);
    [ExtensionAttribute]
public static IOrderedQueryable`1<TSource> OrderByInterpolated(IQueryable`1<TSource> source, ParsingConfig config, FormattableString ordering, IComparer comparer);
    [ExtensionAttribute]
public static IOrderedQueryable`1<TSource> OrderByInterpolated(IQueryable`1<TSource> source, ParsingConfig config, FormattableString ordering);
    [ExtensionAttribute]
public static IOrderedQueryable`1<TSource> OrderByInterpolated(IQueryable`1<TSource> source, FormattableString ordering, IComparer comparer);
    [ExtensionAttribute]
public static IOrderedQueryable`1<TSource> OrderByInterpolated(IQueryable`1<TSource> source, FormattableString ordering);
    [ExtensionAttribute]
public static IOrderedQueryable ThenByInterpolated(IOrderedQueryable source, ParsingConfig config, FormattableString ordering, IComparer comparer);
    [ExtensionAttribute]
public static IOrderedQueryable ThenByInterpolated(IOrderedQueryable source, ParsingConfig config, FormattableString ordering);
    [ExtensionAttribute]
public static IOrderedQueryable ThenByInterpolated(IOrderedQueryable source, FormattableString ordering, IComparer comparer);
    [ExtensionAttribute]
public static IOrderedQueryable ThenByInterpolated(IOrderedQueryable source, FormattableString ordering);
    [ExtensionAttribute]
public static IOrderedQueryable`1<TSource> ThenByInterpolated(IOrderedQueryable`1<TSource> source, ParsingConfig config, FormattableString ordering, IComparer comparer);
    [ExtensionAttribute]
public static IOrderedQueryable`1<TSource> ThenByInterpolated(IOrderedQueryable`1<TSource> source, ParsingConfig config, FormattableString ordering);
    [ExtensionAttribute]
public static IOrderedQueryable`1<TSource> ThenByInterpolated(IOrderedQueryable`1<TSource> source, FormattableString ordering, IComparer comparer);
    [ExtensionAttribute]
public static IOrderedQueryable`1<TSource> ThenByInterpolated(IOrderedQueryable`1<TSource> source, FormattableString ordering);
    private static string ParseFormattableString(FormattableString predicate, Object[]& args);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class System.Linq.Dynamic.Core.Exceptions.ParseException : Exception {
    [CompilerGeneratedAttribute]
private int <Position>k__BackingField;
    public int Position { get; }
    public ParseException(string message, int position, Exception innerException);
    [CompilerGeneratedAttribute]
public int get_Position();
    public virtual string ToString();
}
public class System.Linq.Dynamic.Core.ExtensibilityPoint : object {
    [NullableAttribute("1")]
public static Func`2<Expression, Expression> QueryOptimizer;
    private static ExtensibilityPoint();
}
[ExtensionAttribute]
internal static class System.Linq.Dynamic.Core.Extensions.LinqExtensions : object {
    [NullableContextAttribute("1")]
[ExtensionAttribute]
public static IEnumerable`1<T> WhereNotNull(IEnumerable`1<T> sequence);
}
[ExtensionAttribute]
internal static class System.Linq.Dynamic.Core.Extensions.TokenIdExtensions : object {
    [ExtensionAttribute]
internal static bool IsEqualityOperator(TokenId tokenId);
    [ExtensionAttribute]
internal static bool IsComparisonOperator(TokenId tokenId);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class System.Linq.Dynamic.Core.GroupResult : object {
    [DynamicAttribute]
[CompilerGeneratedAttribute]
private object <Key>k__BackingField;
    [CompilerGeneratedAttribute]
private int <Count>k__BackingField;
    [CompilerGeneratedAttribute]
private IEnumerable <Items>k__BackingField;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilerGeneratedAttribute]
private IEnumerable`1<GroupResult> <Subgroups>k__BackingField;
    [DynamicAttribute]
public object Key { get; internal set; }
    public int Count { get; internal set; }
    public IEnumerable Items { get; internal set; }
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public IEnumerable`1<GroupResult> Subgroups { get; internal set; }
    [CompilerGeneratedAttribute]
public object get_Key();
    [CompilerGeneratedAttribute]
internal void set_Key(object value);
    [CompilerGeneratedAttribute]
public int get_Count();
    [CompilerGeneratedAttribute]
internal void set_Count(int value);
    [CompilerGeneratedAttribute]
public IEnumerable get_Items();
    [CompilerGeneratedAttribute]
internal void set_Items(IEnumerable value);
    [CompilerGeneratedAttribute]
public IEnumerable`1<GroupResult> get_Subgroups();
    [CompilerGeneratedAttribute]
internal void set_Subgroups(IEnumerable`1<GroupResult> value);
    public virtual string ToString();
}
[NullableContextAttribute("1")]
public interface System.Linq.Dynamic.Core.IAssemblyHelper {
    public abstract virtual Assembly[] GetAssemblies();
}
[NullableContextAttribute("1")]
public interface System.Linq.Dynamic.Core.IQueryableAnalyzer {
    public abstract virtual bool SupportsLinqToObjects(IQueryable query, IQueryProvider provider);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class System.Linq.Dynamic.Core.PagedResult : object {
    [CompilerGeneratedAttribute]
private IQueryable <Queryable>k__BackingField;
    [CompilerGeneratedAttribute]
private int <CurrentPage>k__BackingField;
    [CompilerGeneratedAttribute]
private int <PageCount>k__BackingField;
    [CompilerGeneratedAttribute]
private int <PageSize>k__BackingField;
    [CompilerGeneratedAttribute]
private int <RowCount>k__BackingField;
    public IQueryable Queryable { get; public set; }
    public int CurrentPage { get; public set; }
    public int PageCount { get; public set; }
    public int PageSize { get; public set; }
    public int RowCount { get; public set; }
    [CompilerGeneratedAttribute]
public IQueryable get_Queryable();
    [CompilerGeneratedAttribute]
public void set_Queryable(IQueryable value);
    [CompilerGeneratedAttribute]
public int get_CurrentPage();
    [CompilerGeneratedAttribute]
public void set_CurrentPage(int value);
    [CompilerGeneratedAttribute]
public int get_PageCount();
    [CompilerGeneratedAttribute]
public void set_PageCount(int value);
    [CompilerGeneratedAttribute]
public int get_PageSize();
    [CompilerGeneratedAttribute]
public void set_PageSize(int value);
    [CompilerGeneratedAttribute]
public int get_RowCount();
    [CompilerGeneratedAttribute]
public void set_RowCount(int value);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class System.Linq.Dynamic.Core.PagedResult`1 : PagedResult {
    [CompilerGeneratedAttribute]
private IQueryable`1<TSource> <Queryable>k__BackingField;
    public IQueryable`1<TSource> Queryable { get; public set; }
    [CompilerGeneratedAttribute]
public IQueryable`1<TSource> get_Queryable();
    [CompilerGeneratedAttribute]
public void set_Queryable(IQueryable`1<TSource> value);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal static class System.Linq.Dynamic.Core.ParameterExpressionHelper : object {
    public static ParameterExpression CreateParameterExpression(Type type, string name, bool renameEmpty);
    internal static string GenerateRandomWord();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class System.Linq.Dynamic.Core.Parser.ConstantExpressionHelper : object {
    private SlidingCache`2<object, Expression> _expressions;
    private SlidingCache`2<Expression, string> _literals;
    public ConstantExpressionHelper(ParsingConfig config);
    public bool TryGetText(Expression expression, String& text);
    public Expression CreateLiteral(object value, string text);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal static class System.Linq.Dynamic.Core.Parser.ConstantExpressionHelperFactory : object {
    private static object Lock;
    [NullableAttribute("2")]
private static ConstantExpressionHelper _instance;
    private static ConstantExpressionHelperFactory();
    public static ConstantExpressionHelper GetInstance(ParsingConfig config);
}
internal class System.Linq.Dynamic.Core.Parser.ConstantExpressionWrapper : object {
    [NullableContextAttribute("1")]
public sealed virtual void Wrap(Expression& expression);
    [NullableContextAttribute("2")]
public sealed virtual bool TryUnwrapAsValue(MemberExpression expression, TValue& value);
    [NullableContextAttribute("2")]
public sealed virtual bool TryUnwrapAsConstantExpression(MemberExpression expression, ConstantExpression& value);
    [NullableContextAttribute("1")]
private static MemberExpression Wrap(TValue value);
}
internal static class System.Linq.Dynamic.Core.Parser.Constants : object {
    [NullableContextAttribute("1")]
public static bool IsNull(Expression exp);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal static class System.Linq.Dynamic.Core.Parser.EnumerationsFromMscorlib : object {
    public static IDictionary`2<string, Type> PredefinedEnumerationTypes;
    private static EnumerationsFromMscorlib();
    private static IEnumerable`1<Type> AddEnumsFromAssembly(string assemblyName);
    private static void Add(IGrouping`2<string, Type> group);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class System.Linq.Dynamic.Core.Parser.ExpressionHelper : object {
    private IConstantExpressionWrapper _constantExpressionWrapper;
    private ParsingConfig _parsingConfig;
    internal ExpressionHelper(ParsingConfig parsingConfig);
    public sealed virtual void WrapConstantExpression(Expression& argument);
    [NullableContextAttribute("2")]
public sealed virtual bool TryUnwrapAsValue(Expression expression, TValue& value);
    [NullableContextAttribute("2")]
public sealed virtual bool TryUnwrapAsConstantExpression(Expression expression, ConstantExpression& value);
    [NullableContextAttribute("2")]
public sealed virtual bool TryUnwrapAsConstantExpression(Expression expression, ConstantExpression& value);
    public sealed virtual bool ConvertNumericTypeToBiggestCommonTypeForBinaryOperator(Expression& left, Expression& right);
    public sealed virtual Expression GenerateAdd(Expression left, Expression right);
    public sealed virtual Expression GenerateStringConcat(Expression left, Expression right);
    public sealed virtual Expression GenerateSubtract(Expression left, Expression right);
    public sealed virtual Expression GenerateEqual(Expression left, Expression right);
    public sealed virtual Expression GenerateNotEqual(Expression left, Expression right);
    public sealed virtual Expression GenerateGreaterThan(Expression left, Expression right);
    public sealed virtual Expression GenerateGreaterThanEqual(Expression left, Expression right);
    public sealed virtual Expression GenerateLessThan(Expression left, Expression right);
    public sealed virtual Expression GenerateLessThanEqual(Expression left, Expression right);
    public sealed virtual void OptimizeForEqualityIfPossible(Expression& left, Expression& right);
    [NullableContextAttribute("2")]
public sealed virtual Expression OptimizeStringForEqualityIfPossible(string text, Type type);
    public sealed virtual bool MemberExpressionIsDynamic(Expression expression);
    public sealed virtual Expression ConvertToExpandoObjectAndCreateDynamicExpression(Expression expression, Type type, string propertyName);
    private void WrapConstantExpressions(Expression& left, Expression& right);
    public sealed virtual bool TryGenerateAndAlsoNotNullExpression(Expression sourceExpression, bool addSelf, Expression& generatedExpression);
    [NullableContextAttribute("2")]
public sealed virtual bool ExpressionQualifiesForNullPropagation(Expression expression);
    public sealed virtual Expression GenerateDefaultExpression(Type type);
    public sealed virtual Expression ConvertAnyArrayToObjectArray(Expression arrayExpression);
    [NullableContextAttribute("2")]
private Expression GetMemberExpression(Expression expression);
    private List`1<Expression> CollectExpressions(bool addSelf, Expression sourceExpression);
    private void TryConvertTypes(Expression& left, Expression& right);
    private static Expression GenerateStaticMethodCall(string methodName, Expression left, Expression right);
    private static MethodInfo GetStaticMethod(string methodName, Expression left, Expression right);
    private static Expression GetMethodCallExpression(MethodCallExpression methodCallExpression);
    [NullableContextAttribute("2")]
private static Expression GetUnaryExpression(UnaryExpression unaryExpression);
    private static Object[] ConvertIfIEnumerableHasValues(IEnumerable input);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class System.Linq.Dynamic.Core.Parser.ExpressionParser : object {
    private static String[] OutKeywords;
    private static string DiscardVariable;
    private static string MethodOrderBy;
    private static string MethodOrderByDescending;
    private static string MethodThenBy;
    private static string MethodThenByDescending;
    private ParsingConfig _parsingConfig;
    private MethodFinder _methodFinder;
    private IKeywordsHelper _keywordsHelper;
    private TextParser _textParser;
    private NumberParser _numberParser;
    private IExpressionHelper _expressionHelper;
    private ConstantExpressionHelper _constantExpressionHelper;
    private ITypeFinder _typeFinder;
    private ITypeConverterFactory _typeConverterFactory;
    private Dictionary`2<string, object> _internals;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private Dictionary`2<string, object> _symbols;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private IDictionary`2<string, object> _externals;
    [NullableAttribute("2")]
private ParameterExpression _it;
    [NullableAttribute("2")]
private ParameterExpression _parent;
    [NullableAttribute("2")]
private ParameterExpression _root;
    [NullableAttribute("2")]
private Type _resultType;
    private bool _createParameterCtor;
    [CompilerGeneratedAttribute]
private string <ItName>k__BackingField;
    [CompilerGeneratedAttribute]
private string <LastLambdaItName>k__BackingField;
    public string ItName { get; private set; }
    public string LastLambdaItName { get; private set; }
    [NullableContextAttribute("2")]
public ExpressionParser(ParameterExpression[] parameters, string expression, Object[] values, ParsingConfig parsingConfig);
    private static ExpressionParser();
    [CompilerGeneratedAttribute]
public string get_ItName();
    [CompilerGeneratedAttribute]
private void set_ItName(string value);
    [CompilerGeneratedAttribute]
public string get_LastLambdaItName();
    [CompilerGeneratedAttribute]
private void set_LastLambdaItName(string value);
    private void ProcessParameters(ParameterExpression[] parameters);
    private void ProcessValues(Object[] values);
    private void AddSymbol(string name, object value);
    public Expression Parse(Type resultType, bool createParameterCtor);
    private Expression ParseOutKeyword();
    internal IList`1<DynamicOrdering> ParseOrdering(bool forceThenBy);
    private Expression ParseConditionalOperator();
    private Expression ParseNullCoalescingOperator();
    private Expression ParseLambdaOperator();
    private Expression ParseOrOperator();
    private Expression ParseAndOperator();
    private Expression ParseIn();
    private Expression ParseLogicalAndOrOperator();
    private Expression ParseComparisonOperator();
    private static bool HasImplicitConversion(Type baseType, Type targetType);
    private static ConstantExpression ParseEnumToConstantExpression(int pos, Type leftType, ConstantExpression constantExpr);
    private static object ParseConstantExpressionToEnum(int pos, Type leftType, ConstantExpression constantExpr);
    private Expression ParseShiftOperator();
    private Expression ParseAdditive();
    private Expression ParseArithmetic();
    private Expression ParseUnary();
    private Expression ParsePrimary();
    private Expression ParsePrimaryStart();
    private Expression ParseStringLiteralAsStringExpressionOrTypeExpression();
    private AnyOf`2<Expression, Type> ParseStringLiteral(bool forceParseAsString);
    private string ParseStringAndEscape(string text);
    private Expression ParseIntegerLiteral();
    private Expression ParseRealLiteral();
    private Expression ParseParenExpression();
    private Expression ParseIdentifier();
    private Expression ParseIt();
    private Expression ParseParent();
    private Expression ParseRoot();
    private Expression ParseFunctionIsNull();
    private Expression ParseFunctionIif();
    private Expression ParseFunctionNullPropagation();
    private Expression ParseFunctionIs();
    private Expression ParseFunctionAs();
    private Expression ParseFunctionCast();
    private Expression GenerateConditional(Expression test, Expression expressionIfTrue, Expression expressionIfFalse, bool nullPropagating, int errorPos);
    private Expression ParseNew();
    private Expression CreateArrayInitializerExpression(List`1<Expression> expressions, Type newType);
    private Expression CreateNewExpression(List`1<DynamicProperty> properties, List`1<Expression> expressions, Type newType);
    private Expression ParseLambdaInvocation(LambdaExpression lambda);
    private Expression ParseTypeAccess(Type type, bool getNext);
    private bool TryGenerateConversion(Expression sourceExpression, Type destinationType, Expression& expression);
    [NullableContextAttribute("2")]
private Expression ParseMemberAccess(Type type, Expression expression, string id);
    private bool TryFindPropertyOrField(Type type, string id, Expression expression, Expression& propertyOrFieldExpression);
    private static Expression CallMethod(Expression expression, MethodInfo methodToCall, Expression[] args);
    private Expression ParseAsLambda(string id);
    private Expression ParseAsEnumOrNestedClass(string id);
    private bool TryParseEnumerable(Expression instance, Type elementType, string methodName, int errorPos, Type type, Expression[]& args, Expression& expression);
    private Type ResolveTypeFromArgumentExpression(string functionName, Expression argumentExpression, Nullable`1<int> arguments);
    private Type ResolveTypeFromExpressionValue(string functionName, ConstantExpression constantExpression, string argument);
    private Type ResolveTypeStringFromArgument(string typeName);
    private Expression[] ParseArgumentList();
    private Expression[] ParseArguments();
    private Expression ParseElementAccess(Expression expr);
    internal static Type ToNullableType(Type type);
    private static bool TryGetMemberName(Expression expression, String& memberName);
    private void CheckAndPromoteOperand(Type signatures, string opName, Expression& expr, int errorPos);
    private bool TryGetOverloadedEqualityOperator(TokenId tokenId, Expression& left, Expression& right, Expression[]& args);
    private bool TryGetOverloadedImplicitOperator(TokenId tokenId, Expression& left, Expression& right);
    private void CheckAndPromoteOperands(Type signatures, TokenId opId, string opName, Expression& left, Expression& right, int errorPos);
    private static Exception IncompatibleOperandError(string opName, Expression expr, int errorPos);
    private static Exception IncompatibleOperandsError(string opName, Expression left, Expression right, int errorPos);
    private MemberInfo FindPropertyOrField(Type type, string memberName, bool staticAccess);
    private bool TokenIdentifierIs(string id);
    private string GetIdentifier();
    private string GetIdentifierAs();
    private static string SanitizeId(string id);
    private Exception ParseError(string format, Object[] args);
    private static Exception ParseError(int pos, string format, Object[] args);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class System.Linq.Dynamic.Core.Parser.ExpressionPromoter : object {
    private NumberParser _numberParser;
    private ConstantExpressionHelper _constantExpressionHelper;
    public ExpressionPromoter(ParsingConfig config);
    public virtual Expression Promote(Expression expr, Type type, bool exact, bool convertExpr);
}
[NullableContextAttribute("2")]
internal interface System.Linq.Dynamic.Core.Parser.IConstantExpressionWrapper {
    [NullableContextAttribute("1")]
public abstract virtual void Wrap(Expression& expression);
    public abstract virtual bool TryUnwrapAsValue(MemberExpression expression, TValue& value);
    public abstract virtual bool TryUnwrapAsConstantExpression(MemberExpression expression, ConstantExpression& value);
}
[NullableContextAttribute("1")]
internal interface System.Linq.Dynamic.Core.Parser.IExpressionHelper {
    public abstract virtual bool ConvertNumericTypeToBiggestCommonTypeForBinaryOperator(Expression& left, Expression& right);
    public abstract virtual Expression GenerateAdd(Expression left, Expression right);
    public abstract virtual Expression GenerateEqual(Expression left, Expression right);
    public abstract virtual Expression GenerateGreaterThan(Expression left, Expression right);
    public abstract virtual Expression GenerateGreaterThanEqual(Expression left, Expression right);
    public abstract virtual Expression GenerateLessThan(Expression left, Expression right);
    public abstract virtual Expression GenerateLessThanEqual(Expression left, Expression right);
    public abstract virtual Expression GenerateNotEqual(Expression left, Expression right);
    public abstract virtual Expression GenerateStringConcat(Expression left, Expression right);
    public abstract virtual Expression GenerateSubtract(Expression left, Expression right);
    public abstract virtual void OptimizeForEqualityIfPossible(Expression& left, Expression& right);
    public abstract virtual Expression OptimizeStringForEqualityIfPossible(string text, Type type);
    public abstract virtual bool TryGenerateAndAlsoNotNullExpression(Expression sourceExpression, bool addSelf, Expression& generatedExpression);
    public abstract virtual bool ExpressionQualifiesForNullPropagation(Expression expression);
    public abstract virtual void WrapConstantExpression(Expression& argument);
    [NullableContextAttribute("2")]
public abstract virtual bool TryUnwrapAsValue(Expression expression, TValue& value);
    [NullableContextAttribute("2")]
public abstract virtual bool TryUnwrapAsConstantExpression(Expression expression, ConstantExpression& value);
    [NullableContextAttribute("2")]
public abstract virtual bool TryUnwrapAsConstantExpression(Expression expression, ConstantExpression& value);
    public abstract virtual bool MemberExpressionIsDynamic(Expression expression);
    public abstract virtual Expression ConvertToExpandoObjectAndCreateDynamicExpression(Expression expression, Type type, string propertyName);
    public abstract virtual Expression GenerateDefaultExpression(Type type);
    public abstract virtual Expression ConvertAnyArrayToObjectArray(Expression arrayExpression);
}
[NullableContextAttribute("1")]
public interface System.Linq.Dynamic.Core.Parser.IExpressionPromoter {
    public abstract virtual Expression Promote(Expression expr, Type type, bool exact, bool convertExpr);
}
[NullableContextAttribute("1")]
internal interface System.Linq.Dynamic.Core.Parser.IKeywordsHelper {
    public abstract virtual bool TryGetValue(string name, Object& keyWordOrType);
}
[NullableContextAttribute("2")]
internal interface System.Linq.Dynamic.Core.Parser.ITypeFinder {
    public abstract virtual Type FindTypeByName(string name, ParameterExpression[] expressions, bool forceUseCustomTypeProvider);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class System.Linq.Dynamic.Core.Parser.KeywordsHelper : object {
    public static string KEYWORD_IT;
    public static string KEYWORD_PARENT;
    public static string KEYWORD_ROOT;
    public static string SYMBOL_IT;
    public static string SYMBOL_PARENT;
    public static string SYMBOL_ROOT;
    public static string FUNCTION_IIF;
    public static string FUNCTION_ISNULL;
    public static string FUNCTION_NEW;
    public static string FUNCTION_NULLPROPAGATION;
    public static string FUNCTION_IS;
    public static string FUNCTION_AS;
    public static string FUNCTION_CAST;
    private ParsingConfig _config;
    private Dictionary`2<string, object> _keywordMapping;
    private static Dictionary`2<string, object> PreDefinedTypeMapping;
    private Dictionary`2<string, object> _customTypeMapping;
    private static KeywordsHelper();
    public KeywordsHelper(ParsingConfig config);
    public sealed virtual bool TryGetValue(string name, Object& keyWordOrType);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class System.Linq.Dynamic.Core.Parser.NumberParser : object {
    private static Regex RegexBinary32;
    private static Regex RegexBinary64;
    private static Char[] Qualifiers;
    private static Char[] QualifiersHex;
    private static String[] QualifiersReal;
    private ConstantExpressionHelper _constantExpressionHelper;
    private CultureInfo _culture;
    [NullableContextAttribute("2")]
public NumberParser(ParsingConfig config);
    private static NumberParser();
    public Expression ParseIntegerLiteral(int tokenPosition, string text);
    public Expression ParseRealLiteral(string text, char qualifier, bool stripQualifier);
    public bool TryParseNumber(string text, Type type, Object& result);
    public object ParseNumber(string text, Type type);
    private Expression ParseAsBinary(int tokenPosition, string text, bool isNegative);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal static class System.Linq.Dynamic.Core.Parser.PredefinedTypesHelper : object {
    public static IDictionary`2<string, Type> PredefinedTypesShorthands;
    public static IDictionary`2<Type, int> PredefinedTypes;
    private static PredefinedTypesHelper();
    private static void TryAdd(string typeName, int x);
    public static bool IsPredefinedType(ParsingConfig config, Type type);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal static class System.Linq.Dynamic.Core.Parser.StringParser : object {
    private static string TwoDoubleQuotes;
    private static string SingleDoubleQuote;
    internal static string ParseStringAndUnescape(string s, int pos);
    internal static string ParseStringAndUnescapeTwoDoubleQuotesByASingleDoubleQuote(string input, int position);
    private static string ReplaceTwoDoubleQuotesByASingleDoubleQuote(string input, int position);
}
internal enum System.Linq.Dynamic.Core.Parser.SupportedMethods.CompareConversionType : Enum {
    public int value__;
    public static CompareConversionType Both;
    public static CompareConversionType First;
    public static CompareConversionType Second;
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class System.Linq.Dynamic.Core.Parser.SupportedMethods.MethodData : object {
    [CompilerGeneratedAttribute]
private MethodBase <MethodBase>k__BackingField;
    [CompilerGeneratedAttribute]
private ParameterInfo[] <Parameters>k__BackingField;
    [CompilerGeneratedAttribute]
private Expression[] <Args>k__BackingField;
    public MethodBase MethodBase { get; public set; }
    public ParameterInfo[] Parameters { get; public set; }
    public Expression[] Args { get; public set; }
    [CompilerGeneratedAttribute]
public MethodBase get_MethodBase();
    [CompilerGeneratedAttribute]
public void set_MethodBase(MethodBase value);
    [CompilerGeneratedAttribute]
public ParameterInfo[] get_Parameters();
    [CompilerGeneratedAttribute]
public void set_Parameters(ParameterInfo[] value);
    [CompilerGeneratedAttribute]
public Expression[] get_Args();
    [CompilerGeneratedAttribute]
public void set_Args(Expression[] value);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class System.Linq.Dynamic.Core.Parser.SupportedMethods.MethodFinder : object {
    private ParsingConfig _parsingConfig;
    private IExpressionHelper _expressionHelper;
    public MethodFinder(ParsingConfig parsingConfig, IExpressionHelper expressionHelper);
    public bool TryFindAverageMethod(Type callType, Type parameterType, MethodInfo& averageMethod);
    public void CheckAggregateMethodAndTryUpdateArgsToMatchMethodArgs(string methodName, Expression[]& args);
    public bool ContainsMethod(Type type, string methodName, bool staticAccess);
    public bool ContainsMethod(Type type, string methodName, bool staticAccess, Expression instance, Expression[]& args);
    [NullableContextAttribute("2")]
public int FindMethod(Type type, string methodName, bool staticAccess, Expression& instance, Expression[]& args, MethodBase& method);
    public int FindBestMethodBasedOnArguments(IEnumerable`1<MethodBase> methods, Expression[]& args, MethodBase& method);
    public int FindIndexer(Type type, Expression[] args, MethodBase& method);
    private bool IsApplicable(MethodData method, Expression[] args);
    private static bool FirstIsBetterThanSecond(Expression[] args, MethodData first, MethodData second);
    private static CompareConversionType CompareConversions(Type source, Type first, Type second);
    private static IEnumerable`1<Type> SelfAndBaseTypes(Type type);
    [IteratorStateMachineAttribute("System.Linq.Dynamic.Core.Parser.SupportedMethods.MethodFinder/<SelfAndBaseClasses>d__15")]
private static IEnumerable`1<Type> SelfAndBaseClasses(Type type);
    private static void AddInterfaces(ICollection`1<Type> types, Type type);
}
internal interface System.Linq.Dynamic.Core.Parser.SupportedOperands.IAddSignatures {
    public abstract virtual void F(TimeSpan x, TimeSpan y);
    public abstract virtual void F(TimeSpan x, Nullable`1<TimeSpan> y);
    public abstract virtual void F(Nullable`1<TimeSpan> x, TimeSpan y);
    public abstract virtual void F(Nullable`1<TimeSpan> x, Nullable`1<TimeSpan> y);
    public abstract virtual void F(DateTime x, TimeSpan y);
    public abstract virtual void F(DateTime x, Nullable`1<TimeSpan> y);
    public abstract virtual void F(Nullable`1<DateTime> x, TimeSpan y);
    public abstract virtual void F(Nullable`1<DateTime> x, Nullable`1<TimeSpan> y);
}
internal interface System.Linq.Dynamic.Core.Parser.SupportedOperands.IArithmeticSignatures {
    public abstract virtual void F(int x, int y);
    public abstract virtual void F(UInt32 x, UInt32 y);
    public abstract virtual void F(long x, long y);
    public abstract virtual void F(ulong x, ulong y);
    public abstract virtual void F(float x, float y);
    public abstract virtual void F(double x, double y);
    public abstract virtual void F(decimal x, decimal y);
    public abstract virtual void F(Nullable`1<int> x, Nullable`1<int> y);
    public abstract virtual void F(Nullable`1<UInt32> x, Nullable`1<UInt32> y);
    public abstract virtual void F(Nullable`1<long> x, Nullable`1<long> y);
    public abstract virtual void F(Nullable`1<ulong> x, Nullable`1<ulong> y);
    public abstract virtual void F(Nullable`1<float> x, Nullable`1<float> y);
    public abstract virtual void F(Nullable`1<double> x, Nullable`1<double> y);
    public abstract virtual void F(Nullable`1<decimal> x, Nullable`1<decimal> y);
}
internal interface System.Linq.Dynamic.Core.Parser.SupportedOperands.IEqualitySignatures {
    public abstract virtual void F(bool x, bool y);
    public abstract virtual void F(Nullable`1<bool> x, Nullable`1<bool> y);
    public abstract virtual void F(Guid x, Guid y);
    public abstract virtual void F(Nullable`1<Guid> x, Nullable`1<Guid> y);
}
internal interface System.Linq.Dynamic.Core.Parser.SupportedOperands.ILogicalSignatures {
    public abstract virtual void F(bool x, bool y);
    public abstract virtual void F(Nullable`1<bool> x, Nullable`1<bool> y);
}
internal interface System.Linq.Dynamic.Core.Parser.SupportedOperands.INegationSignatures {
    public abstract virtual void F(int x);
    public abstract virtual void F(long x);
    public abstract virtual void F(float x);
    public abstract virtual void F(double x);
    public abstract virtual void F(decimal x);
    public abstract virtual void F(Nullable`1<int> x);
    public abstract virtual void F(Nullable`1<long> x);
    public abstract virtual void F(Nullable`1<float> x);
    public abstract virtual void F(Nullable`1<double> x);
    public abstract virtual void F(Nullable`1<decimal> x);
}
internal interface System.Linq.Dynamic.Core.Parser.SupportedOperands.INotSignatures {
    public abstract virtual void F(bool x);
    public abstract virtual void F(Nullable`1<bool> x);
}
internal interface System.Linq.Dynamic.Core.Parser.SupportedOperands.IRelationalSignatures {
    [NullableContextAttribute("1")]
public abstract virtual void F(string x, string y);
    public abstract virtual void F(char x, char y);
    public abstract virtual void F(DateTime x, DateTime y);
    public abstract virtual void F(DateTimeOffset x, DateTimeOffset y);
    public abstract virtual void F(TimeSpan x, TimeSpan y);
    public abstract virtual void F(Nullable`1<char> x, Nullable`1<char> y);
    public abstract virtual void F(Nullable`1<DateTime> x, Nullable`1<DateTime> y);
    public abstract virtual void F(Nullable`1<DateTimeOffset> x, Nullable`1<DateTimeOffset> y);
    public abstract virtual void F(Nullable`1<TimeSpan> x, Nullable`1<TimeSpan> y);
}
internal interface System.Linq.Dynamic.Core.Parser.SupportedOperands.IShiftSignatures {
    public abstract virtual void F(int x, int y);
    public abstract virtual void F(UInt32 x, int y);
    public abstract virtual void F(long x, int y);
    public abstract virtual void F(ulong x, int y);
    public abstract virtual void F(Nullable`1<int> x, int y);
    public abstract virtual void F(Nullable`1<UInt32> x, int y);
    public abstract virtual void F(Nullable`1<long> x, int y);
    public abstract virtual void F(Nullable`1<ulong> x, int y);
    public abstract virtual void F(int x, Nullable`1<int> y);
    public abstract virtual void F(UInt32 x, Nullable`1<int> y);
    public abstract virtual void F(long x, Nullable`1<int> y);
    public abstract virtual void F(ulong x, Nullable`1<int> y);
    public abstract virtual void F(Nullable`1<int> x, Nullable`1<int> y);
    public abstract virtual void F(Nullable`1<UInt32> x, Nullable`1<int> y);
    public abstract virtual void F(Nullable`1<long> x, Nullable`1<int> y);
    public abstract virtual void F(Nullable`1<ulong> x, Nullable`1<int> y);
}
internal interface System.Linq.Dynamic.Core.Parser.SupportedOperands.ISubtractSignatures {
    public abstract virtual void F(DateTime x, DateTime y);
    public abstract virtual void F(DateTime x, Nullable`1<DateTime> y);
    public abstract virtual void F(Nullable`1<DateTime> x, DateTime y);
    public abstract virtual void F(Nullable`1<DateTime> x, Nullable`1<DateTime> y);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class System.Linq.Dynamic.Core.Parser.TypeFinder : object {
    private IKeywordsHelper _keywordsHelper;
    private ParsingConfig _parsingConfig;
    public TypeFinder(ParsingConfig parsingConfig, IKeywordsHelper keywordsHelper);
    [NullableContextAttribute("2")]
public sealed virtual Type FindTypeByName(string name, ParameterExpression[] expressions, bool forceUseCustomTypeProvider);
    private Type ResolveTypeByUsingCustomTypeProvider(string name, bool forceUseCustomTypeProvider);
    private bool TryResolveTypeUsingExpressions(string name, ParameterExpression[] expressions, Type& result);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal static class System.Linq.Dynamic.Core.Parser.TypeHelper : object {
    public static bool TryGetFirstGenericArgument(Type type, Type& genericType);
    [NullableContextAttribute("2")]
public static bool TryFindGenericType(Type generic, Type type, Type& foundType);
    public static bool IsCompatibleWith(Type source, Type target);
    public static bool IsClass(Type type);
    public static bool IsStruct(Type type);
    public static bool IsEnumType(Type type);
    public static bool IsNumericType(Type type);
    public static bool IsNullableType(Type type);
    public static bool TypeCanBeNull(Type type);
    public static Type ToNullableType(Type type);
    public static bool IsSignedIntegralType(Type type);
    public static bool IsUnsignedIntegralType(Type type);
    private static int GetNumericTypeKind(Type type);
    public static string GetTypeName(Type type);
    public static Type GetNullableType(Type type);
    public static Type GetNonNullableType(Type type);
    public static Type GetUnderlyingType(Type type);
    public static IList`1<Type> GetSelfAndBaseTypes(Type type, bool excludeObject);
    [IteratorStateMachineAttribute("System.Linq.Dynamic.Core.Parser.TypeHelper/<GetSelfAndBaseClasses>d__18")]
private static IEnumerable`1<Type> GetSelfAndBaseClasses(Type type);
    private static void AddInterface(ICollection`1<Type> types, Type type);
    [NullableContextAttribute("2")]
public static bool TryParseEnum(string value, Type type, Object& enumValue);
    [NullableContextAttribute("2")]
public static bool IsDictionary(Type type);
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
internal class System.Linq.Dynamic.Core.Parser.WrappedValue`1 : object {
    [NullableAttribute("1")]
[CompilerGeneratedAttribute]
private TValue <Value>k__BackingField;
    [NullableAttribute("1")]
public TValue Value { get; }
    [NullableContextAttribute("1")]
public WrappedValue`1(TValue value);
    [NullableContextAttribute("1")]
[CompilerGeneratedAttribute]
public TValue get_Value();
    public static bool op_Equality(WrappedValue`1<TValue> left, WrappedValue`1<TValue> right);
    public static bool op_Inequality(WrappedValue`1<TValue> left, WrappedValue`1<TValue> right);
    public static bool op_Equality(WrappedValue`1<TValue> left, TValue right);
    public static bool op_Inequality(WrappedValue`1<TValue> left, TValue right);
    public static bool op_Equality(TValue left, WrappedValue`1<TValue> right);
    public static bool op_Inequality(TValue left, WrappedValue`1<TValue> right);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class System.Linq.Dynamic.Core.ParsingConfig : object {
    [NullableAttribute("2")]
private IDynamicLinkCustomTypeProvider _customTypeProvider;
    [NullableAttribute("2")]
private IExpressionPromoter _expressionPromoter;
    [NullableAttribute("2")]
private IQueryableAnalyzer _queryableAnalyzer;
    [CompilerGeneratedAttribute]
private static ParsingConfig <Default>k__BackingField;
    [CompilerGeneratedAttribute]
private static ParsingConfig <DefaultEFCore21>k__BackingField;
    [CompilerGeneratedAttribute]
private static ParsingConfig <DefaultCosmosDb>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsCaseSensitive>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <LoadAdditionalAssembliesFromCurrentDomainBaseDirectory>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <AreContextKeywordsEnabled>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <EvaluateGroupByAtDatabase>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <UseParameterizedNamesInDynamicQuery>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <AllowNewToEvaluateAnyType>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <RenameParameterExpression>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <RenameEmptyParameterExpressionNames>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <DisableMemberAccessToIndexAccessorFallback>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <ResolveTypesBySimpleName>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <SupportEnumerationsFromSystemNamespace>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <DateTimeIsParsedAsUTC>k__BackingField;
    [NullableAttribute("2")]
[CompilerGeneratedAttribute]
private CultureInfo <NumberParseCulture>k__BackingField;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilerGeneratedAttribute]
private IDictionary`2<Type, TypeConverter> <TypeConverters>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <NullPropagatingUseDefaultValueForNonNullableValueTypes>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <SupportCastingToFullyQualifiedTypeAsString>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <PrioritizePropertyOrFieldOverTheType>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <SupportDotInPropertyNames>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <DisallowNewKeyword>k__BackingField;
    [NullableAttribute("2")]
[CompilerGeneratedAttribute]
private CacheConfig <ConstantExpressionCacheConfig>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <ConvertObjectToSupportComparison>k__BackingField;
    [CompilerGeneratedAttribute]
private StringLiteralParsingType <StringLiteralParsing>k__BackingField;
    public static ParsingConfig Default { get; }
    public static ParsingConfig DefaultEFCore21 { get; }
    public static ParsingConfig DefaultCosmosDb { get; }
    public bool IsCaseSensitive { get; public set; }
    [NullableAttribute("2")]
public IDynamicLinkCustomTypeProvider CustomTypeProvider { get; public set; }
    public bool LoadAdditionalAssembliesFromCurrentDomainBaseDirectory { get; public set; }
    public IExpressionPromoter ExpressionPromoter { get; public set; }
    public IQueryableAnalyzer QueryableAnalyzer { get; public set; }
    public bool AreContextKeywordsEnabled { get; public set; }
    public bool EvaluateGroupByAtDatabase { get; public set; }
    public bool UseParameterizedNamesInDynamicQuery { get; public set; }
    public bool AllowNewToEvaluateAnyType { get; public set; }
    public bool RenameParameterExpression { get; public set; }
    public bool RenameEmptyParameterExpressionNames { get; public set; }
    public bool DisableMemberAccessToIndexAccessorFallback { get; public set; }
    public bool ResolveTypesBySimpleName { get; public set; }
    public bool SupportEnumerationsFromSystemNamespace { get; public set; }
    public bool DateTimeIsParsedAsUTC { get; public set; }
    [NullableAttribute("2")]
public CultureInfo NumberParseCulture { get; public set; }
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public IDictionary`2<Type, TypeConverter> TypeConverters { get; public set; }
    public bool NullPropagatingUseDefaultValueForNonNullableValueTypes { get; public set; }
    public bool SupportCastingToFullyQualifiedTypeAsString { get; public set; }
    public bool PrioritizePropertyOrFieldOverTheType { get; public set; }
    public bool SupportDotInPropertyNames { get; public set; }
    public bool DisallowNewKeyword { get; public set; }
    [NullableAttribute("2")]
public CacheConfig ConstantExpressionCacheConfig { get; public set; }
    public bool ConvertObjectToSupportComparison { get; public set; }
    public StringLiteralParsingType StringLiteralParsing { get; public set; }
    private static ParsingConfig();
    [CompilerGeneratedAttribute]
public static ParsingConfig get_Default();
    [CompilerGeneratedAttribute]
public static ParsingConfig get_DefaultEFCore21();
    [CompilerGeneratedAttribute]
public static ParsingConfig get_DefaultCosmosDb();
    [CompilerGeneratedAttribute]
public bool get_IsCaseSensitive();
    [CompilerGeneratedAttribute]
public void set_IsCaseSensitive(bool value);
    [NullableContextAttribute("2")]
public IDynamicLinkCustomTypeProvider get_CustomTypeProvider();
    [NullableContextAttribute("2")]
public void set_CustomTypeProvider(IDynamicLinkCustomTypeProvider value);
    [CompilerGeneratedAttribute]
public bool get_LoadAdditionalAssembliesFromCurrentDomainBaseDirectory();
    [CompilerGeneratedAttribute]
public void set_LoadAdditionalAssembliesFromCurrentDomainBaseDirectory(bool value);
    public IExpressionPromoter get_ExpressionPromoter();
    public void set_ExpressionPromoter(IExpressionPromoter value);
    public IQueryableAnalyzer get_QueryableAnalyzer();
    public void set_QueryableAnalyzer(IQueryableAnalyzer value);
    [CompilerGeneratedAttribute]
public bool get_AreContextKeywordsEnabled();
    [CompilerGeneratedAttribute]
public void set_AreContextKeywordsEnabled(bool value);
    [CompilerGeneratedAttribute]
public bool get_EvaluateGroupByAtDatabase();
    [CompilerGeneratedAttribute]
public void set_EvaluateGroupByAtDatabase(bool value);
    [CompilerGeneratedAttribute]
public bool get_UseParameterizedNamesInDynamicQuery();
    [CompilerGeneratedAttribute]
public void set_UseParameterizedNamesInDynamicQuery(bool value);
    [CompilerGeneratedAttribute]
public bool get_AllowNewToEvaluateAnyType();
    [CompilerGeneratedAttribute]
public void set_AllowNewToEvaluateAnyType(bool value);
    [CompilerGeneratedAttribute]
public bool get_RenameParameterExpression();
    [CompilerGeneratedAttribute]
public void set_RenameParameterExpression(bool value);
    [CompilerGeneratedAttribute]
public bool get_RenameEmptyParameterExpressionNames();
    [CompilerGeneratedAttribute]
public void set_RenameEmptyParameterExpressionNames(bool value);
    [CompilerGeneratedAttribute]
public bool get_DisableMemberAccessToIndexAccessorFallback();
    [CompilerGeneratedAttribute]
public void set_DisableMemberAccessToIndexAccessorFallback(bool value);
    [CompilerGeneratedAttribute]
public bool get_ResolveTypesBySimpleName();
    [CompilerGeneratedAttribute]
public void set_ResolveTypesBySimpleName(bool value);
    [CompilerGeneratedAttribute]
public bool get_SupportEnumerationsFromSystemNamespace();
    [CompilerGeneratedAttribute]
public void set_SupportEnumerationsFromSystemNamespace(bool value);
    [CompilerGeneratedAttribute]
public bool get_DateTimeIsParsedAsUTC();
    [CompilerGeneratedAttribute]
public void set_DateTimeIsParsedAsUTC(bool value);
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public CultureInfo get_NumberParseCulture();
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public void set_NumberParseCulture(CultureInfo value);
    [CompilerGeneratedAttribute]
public IDictionary`2<Type, TypeConverter> get_TypeConverters();
    [CompilerGeneratedAttribute]
public void set_TypeConverters(IDictionary`2<Type, TypeConverter> value);
    [CompilerGeneratedAttribute]
public bool get_NullPropagatingUseDefaultValueForNonNullableValueTypes();
    [CompilerGeneratedAttribute]
public void set_NullPropagatingUseDefaultValueForNonNullableValueTypes(bool value);
    [CompilerGeneratedAttribute]
public bool get_SupportCastingToFullyQualifiedTypeAsString();
    [CompilerGeneratedAttribute]
public void set_SupportCastingToFullyQualifiedTypeAsString(bool value);
    [CompilerGeneratedAttribute]
public bool get_PrioritizePropertyOrFieldOverTheType();
    [CompilerGeneratedAttribute]
public void set_PrioritizePropertyOrFieldOverTheType(bool value);
    [CompilerGeneratedAttribute]
public bool get_SupportDotInPropertyNames();
    [CompilerGeneratedAttribute]
public void set_SupportDotInPropertyNames(bool value);
    [CompilerGeneratedAttribute]
public bool get_DisallowNewKeyword();
    [CompilerGeneratedAttribute]
public void set_DisallowNewKeyword(bool value);
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public CacheConfig get_ConstantExpressionCacheConfig();
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public void set_ConstantExpressionCacheConfig(CacheConfig value);
    [CompilerGeneratedAttribute]
public bool get_ConvertObjectToSupportComparison();
    [CompilerGeneratedAttribute]
public void set_ConvertObjectToSupportComparison(bool value);
    [CompilerGeneratedAttribute]
public StringLiteralParsingType get_StringLiteralParsing();
    [CompilerGeneratedAttribute]
public void set_StringLiteralParsing(StringLiteralParsingType value);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal static class System.Linq.Dynamic.Core.Res : object {
    public static string AmbiguousConstructorInvocation;
    public static string AmbiguousIndexerInvocation;
    public static string AmbiguousMethodInvocation;
    public static string ArgsIncompatibleWithLambda;
    public static string BinaryCharExpected;
    public static string BothTypesConvertToOther;
    public static string CannotConvertValue;
    public static string CannotIndexMultiDimArray;
    public static string CloseBracketExpected;
    public static string CloseBracketOrCommaExpected;
    public static string CloseParenOrCommaExpected;
    public static string CloseParenOrOperatorExpected;
    public static string ColonExpected;
    public static string DigitExpected;
    public static string DotExpected;
    public static string DotOrOpenParenExpected;
    public static string DotOrOpenParenOrStringLiteralExpected;
    public static string DynamicExpandoObjectIsNotSupported;
    public static string DuplicateIdentifier;
    public static string EnumTypeNotFound;
    public static string EnumValueExpected;
    public static string EnumValueNotDefined;
    public static string ExpressionExpected;
    public static string ExpressionTypeMismatch;
    public static string FirstExprMustBeBool;
    public static string FunctionRequiresOneArg;
    public static string FunctionRequiresOneNotNullArg;
    public static string FunctionRequiresNotNullArgOfType;
    public static string FunctionRequiresOneOrTwoArgs;
    public static string HexCharExpected;
    public static string IQueryableProviderNotAsync;
    public static string IdentifierExpected;
    public static string IdentifierImplementingInterfaceExpected;
    public static string IifRequiresThreeArgs;
    public static string IncompatibleOperand;
    public static string IncompatibleOperands;
    public static string IncompatibleTypes;
    public static string InvalidBinaryIntegerLiteral;
    public static string InvalidCharacter;
    public static string InvalidCharacterLiteral;
    public static string InvalidIndex;
    public static string InvalidIntegerLiteral;
    public static string InvalidIntegerQualifier;
    public static string InvalidRealLiteral;
    public static string InvalidStringQuoteCharacter;
    public static string InvalidStringLength;
    public static string IsNullRequiresTwoArgs;
    public static string MethodIsVoid;
    public static string MethodsAreInaccessible;
    public static string MinusCannotBeAppliedToUnsignedInteger;
    public static string MissingAsClause;
    public static string NeitherTypeConvertsToOther;
    public static string NewOperatorIsNotAllowed;
    public static string NoApplicableIndexer;
    public static string NoApplicableMethod;
    public static string NoItInScope;
    public static string NoMatchingConstructor;
    public static string NoParentInScope;
    public static string NoRootInScope;
    public static string NullPropagationRequiresCorrectArgs;
    public static string NullPropagationRequiresValidExpression;
    public static string OpenBracketExpected;
    public static string OpenCurlyParenExpected;
    public static string OpenParenExpected;
    public static string OpenParenOrIdentifierExpected;
    public static string OutKeywordRequiresDiscard;
    public static string ParseExceptionFormat;
    public static string SyntaxError;
    public static string TokenExpected;
    public static string TypeHasNoNullableForm;
    public static string TypeNotFound;
    public static string UnexpectedUnclosedString;
    public static string UnexpectedUnrecognizedEscapeSequence;
    public static string UnknownIdentifier;
    public static string UnknownPropertyOrField;
    public static string UnterminatedStringLiteral;
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class System.Linq.Dynamic.Core.Tokenizer.TextParser : object {
    private static char DefaultNumberDecimalSeparator;
    private static Char[] EscapeCharacters;
    private static Dictionary`2<string, TokenId> PredefinedOperatorAliases;
    private char _numberDecimalSeparator;
    private string _text;
    private int _textLen;
    private ParsingConfig _parsingConfig;
    private int _textPos;
    private char _ch;
    public Token CurrentToken;
    public TextParser(ParsingConfig config, string text);
    private static TextParser();
    public TextParser Clone();
    public char PeekNextChar();
    public void NextToken();
    [NullableContextAttribute("2")]
public void ValidateToken(TokenId tokenId, string errorMessage);
    private void SetTextPos(int pos);
    private void NextChar();
    private void ValidateExpression();
    private void ValidateDigit();
    private void ValidateHexChar();
    private void ValidateBinaryChar();
    private Exception ParseError(string format, Object[] args);
    private static Exception ParseError(int pos, string format, Object[] args);
    private static TokenId GetAliasedTokenId(TokenId tokenId, string alias);
    private static bool IsHexChar(char c);
    private static bool IsZeroOrOne(char c);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class System.Linq.Dynamic.Core.Tokenizer.Token : ValueType {
    [CompilerGeneratedAttribute]
private TokenId <Id>k__BackingField;
    [CompilerGeneratedAttribute]
private TokenId <OriginalId>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Text>k__BackingField;
    [CompilerGeneratedAttribute]
private int <Pos>k__BackingField;
    public TokenId Id { get; public set; }
    public TokenId OriginalId { get; public set; }
    public string Text { get; public set; }
    public int Pos { get; public set; }
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public TokenId get_Id();
    [CompilerGeneratedAttribute]
public void set_Id(TokenId value);
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public TokenId get_OriginalId();
    [CompilerGeneratedAttribute]
public void set_OriginalId(TokenId value);
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public string get_Text();
    [CompilerGeneratedAttribute]
public void set_Text(string value);
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public int get_Pos();
    [CompilerGeneratedAttribute]
public void set_Pos(int value);
}
public enum System.Linq.Dynamic.Core.Tokenizer.TokenId : Enum {
    public int value__;
    public static TokenId Unknown;
    public static TokenId End;
    public static TokenId Identifier;
    public static TokenId StringLiteral;
    public static TokenId IntegerLiteral;
    public static TokenId RealLiteral;
    public static TokenId Exclamation;
    public static TokenId Percent;
    public static TokenId Ampersand;
    public static TokenId OpenParen;
    public static TokenId CloseParen;
    public static TokenId OpenCurlyParen;
    public static TokenId CloseCurlyParen;
    public static TokenId Asterisk;
    public static TokenId Plus;
    public static TokenId Comma;
    public static TokenId Minus;
    public static TokenId Dot;
    public static TokenId Slash;
    public static TokenId Colon;
    public static TokenId LessThan;
    public static TokenId Equal;
    public static TokenId GreaterThan;
    public static TokenId Question;
    public static TokenId OpenBracket;
    public static TokenId CloseBracket;
    public static TokenId Bar;
    public static TokenId ExclamationEqual;
    public static TokenId DoubleAmpersand;
    public static TokenId LessThanEqual;
    public static TokenId LessGreater;
    public static TokenId DoubleEqual;
    public static TokenId GreaterThanEqual;
    public static TokenId DoubleBar;
    public static TokenId DoubleGreaterThan;
    public static TokenId DoubleLessThan;
    public static TokenId NullCoalescing;
    public static TokenId Lambda;
    public static TokenId NullPropagation;
}
internal class System.Linq.Dynamic.Core.TypeConverters.CustomDateTimeConverter : DateTimeOffsetConverter {
    [NullableContextAttribute("1")]
public virtual object ConvertFrom(ITypeDescriptorContext context, CultureInfo culture, object value);
}
[NullableContextAttribute("1")]
internal interface System.Linq.Dynamic.Core.TypeConverters.ITypeConverterFactory {
    public abstract virtual TypeConverter GetConverter(Type type);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class System.Linq.Dynamic.Core.TypeConverters.TypeConverterFactory : object {
    private ParsingConfig _config;
    public TypeConverterFactory(ParsingConfig config);
    public sealed virtual TypeConverter GetConverter(Type type);
}
public class System.Linq.Dynamic.Core.Util.Cache.CacheConfig : object {
    [CompilerGeneratedAttribute]
private TimeSpan <TimeToLive>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<int> <MinItemsTrigger>k__BackingField;
    [CompilerGeneratedAttribute]
private TimeSpan <CleanupFrequency>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <ReturnExpiredItems>k__BackingField;
    public TimeSpan TimeToLive { get; public set; }
    public Nullable`1<int> MinItemsTrigger { get; public set; }
    public TimeSpan CleanupFrequency { get; public set; }
    public bool ReturnExpiredItems { get; public set; }
    [CompilerGeneratedAttribute]
public TimeSpan get_TimeToLive();
    [CompilerGeneratedAttribute]
public void set_TimeToLive(TimeSpan value);
    [CompilerGeneratedAttribute]
public Nullable`1<int> get_MinItemsTrigger();
    [CompilerGeneratedAttribute]
public void set_MinItemsTrigger(Nullable`1<int> value);
    [CompilerGeneratedAttribute]
public TimeSpan get_CleanupFrequency();
    [CompilerGeneratedAttribute]
public void set_CleanupFrequency(TimeSpan value);
    [CompilerGeneratedAttribute]
public bool get_ReturnExpiredItems();
    [CompilerGeneratedAttribute]
public void set_ReturnExpiredItems(bool value);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class System.Linq.Dynamic.Core.Util.Cache.CacheEntry`1 : ValueType {
    [CompilerGeneratedAttribute]
private TValue <Value>k__BackingField;
    [CompilerGeneratedAttribute]
private DateTime <ExpirationTime>k__BackingField;
    public TValue Value { get; }
    public DateTime ExpirationTime { get; }
    public CacheEntry`1(TValue value, DateTime expirationTime);
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public TValue get_Value();
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public DateTime get_ExpirationTime();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class System.Linq.Dynamic.Core.Util.Cache.SlidingCache`2 : object {
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private ConcurrentDictionary`2<TKey, CacheEntry`1<TValue>> _cache;
    private TimeSpan _cleanupFrequency;
    private IDateTimeUtils _dateTimeProvider;
    private Action _deleteExpiredCachedItemsDelegate;
    private Nullable`1<long> _minCacheItemsBeforeCleanup;
    private bool _returnExpiredItems;
    private DateTime _lastCleanupTime;
    private int _cleanupLocked;
    [CompilerGeneratedAttribute]
private TimeSpan <TimeToLive>k__BackingField;
    public TimeSpan TimeToLive { get; }
    public int Count { get; }
    [NullableContextAttribute("2")]
public SlidingCache`2(TimeSpan timeToLive, Nullable`1<TimeSpan> cleanupFrequency, Nullable`1<long> minCacheItemsBeforeCleanup, IDateTimeUtils dateTimeProvider, bool returnExpiredItems);
    public SlidingCache`2(CacheConfig cacheConfig, IDateTimeUtils dateTimeProvider);
    [CompilerGeneratedAttribute]
public TimeSpan get_TimeToLive();
    public int get_Count();
    public void AddOrUpdate(TKey key, TValue value);
    public bool TryGetValue(TKey key, TValue& value);
    public bool Remove(TKey key);
    private void CleanupIfNeeded();
    private void Cleanup();
}
internal static class System.Linq.Dynamic.Core.Util.Cache.SlidingCacheConstants : object {
    public static TimeSpan DefaultCleanupFrequency;
    public static TimeSpan DefaultTimeToLive;
    private static SlidingCacheConstants();
}
internal class System.Linq.Dynamic.Core.Util.DateTimeUtils : object {
    public DateTime UtcNow { get; }
    public sealed virtual DateTime get_UtcNow();
}
internal interface System.Linq.Dynamic.Core.Util.IDateTimeUtils {
    public DateTime UtcNow { get; }
    public abstract virtual DateTime get_UtcNow();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class System.Linq.Dynamic.Core.Util.ParameterExpressionRenamer : ExpressionVisitor {
    private string _newName;
    private string _oldName;
    [NullableAttribute("2")]
private ParameterExpression _parameterExpression;
    public ParameterExpressionRenamer(string newName);
    public ParameterExpressionRenamer(string oldName, string newName);
    public Expression Rename(Expression expression, ParameterExpression& parameterExpression);
    protected virtual Expression VisitParameter(ParameterExpression node);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal static class System.Linq.Dynamic.Core.Util.QueryableMethodFinder : object {
    public static MethodInfo GetGenericMethod(string name);
    public static MethodInfo GetMethod(string name, Type argumentType, Type returnType, int parameterCount, Func`2<MethodInfo, bool> predicate);
    public static MethodInfo GetMethod(string name, Type returnType, int parameterCount, Func`2<MethodInfo, bool> predicate);
    public static MethodInfo GetMethodWithExpressionParameter(string name);
    public static MethodInfo GetMethodWithIntParameter(string name);
    public static MethodInfo GetMethod(string name, int parameterCount, Func`2<MethodInfo, bool> predicate);
}
internal static class System.Linq.Dynamic.Core.Util.RuntimeInformationUtils : object {
    public static bool IsBlazorWASM;
    private static RuntimeInformationUtils();
}
internal static class System.Linq.Dynamic.Core.Util.TaskUtils : object {
    [NullableContextAttribute("1")]
public static void Run(Action action);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[DebuggerStepThroughAttribute]
internal static class System.Linq.Dynamic.Core.Validation.Check : object {
    public static T Condition(T value, Predicate`1<T> predicate, string parameterName);
    public static T NotNull(T value, string parameterName);
    public static T NotNull(T value, string parameterName, string propertyName);
    public static IEnumerable`1<T> NotNullOrEmpty(IEnumerable`1<T> value, string parameterName);
    [NullableContextAttribute("2")]
public static string NotEmpty(string value, string parameterName);
    [NullableContextAttribute("2")]
public static string NotNullOrEmpty(string value, string parameterName);
    [NullableContextAttribute("2")]
public static string NotNullOrWhiteSpace(string value, string parameterName);
    public static IEnumerable`1<T> HasNoNulls(IEnumerable`1<T> value, string parameterName);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal static class System.Linq.Dynamic.Core.Validation.CoreStrings : object {
    public static string ArgumentPropertyNull(string property, string argument);
    public static string ArgumentIsEmpty(string argumentName);
    public static string CollectionArgumentIsEmpty(string argumentName);
}
internal class System.Linq.Dynamic.Core.Validation.ValidatedNotNullAttribute : Attribute {
}
[ExtensionAttribute]
internal static class System.Linq.Expressions.LambdaExpressionExtensions : object {
    [NullableContextAttribute("1")]
[ExtensionAttribute]
public static Type GetReturnType(LambdaExpression lambdaExpression);
}
[ExtensionAttribute]
internal static class System.Reflection.CustomIntrospectionExtensions : object {
    [NullableContextAttribute("1")]
[ExtensionAttribute]
public static Type[] GetGenericTypeArguments(TypeInfo typeInfo);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ExtensionAttribute]
internal static class System.Reflection.CustomTypeBuilderExtensions : object {
    [ExtensionAttribute]
public static Type CreateType(TypeBuilder tb);
    [ExtensionAttribute]
public static PropertyBuilder DefineProperty(TypeBuilder tb, string name, PropertyAttributes attributes, CallingConventions callingConvention, Type returnType, Type[] parameterTypes);
    [ExtensionAttribute]
public static Type AsType(TypeBuilder builder);
    [ExtensionAttribute]
public static Type AsType(GenericTypeParameterBuilder builder);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[AttributeUsageAttribute("2048")]
internal class System.Runtime.CompilerServices.CallerArgumentExpressionAttribute : Attribute {
    [CompilerGeneratedAttribute]
private string <ParameterName>k__BackingField;
    public string ParameterName { get; }
    public CallerArgumentExpressionAttribute(string parameterName);
    [CompilerGeneratedAttribute]
public string get_ParameterName();
}
[CompilerGeneratedAttribute]
[EmbeddedAttribute]
[AttributeUsageAttribute("27524")]
internal class System.Runtime.CompilerServices.NullableAttribute : Attribute {
    public Byte[] NullableFlags;
    public NullableAttribute(byte );
    public NullableAttribute(Byte[] );
}
[CompilerGeneratedAttribute]
[EmbeddedAttribute]
[AttributeUsageAttribute("5196")]
internal class System.Runtime.CompilerServices.NullableContextAttribute : Attribute {
    public byte Flag;
    public NullableContextAttribute(byte );
}
[CompilerGeneratedAttribute]
[EmbeddedAttribute]
[AttributeUsageAttribute("2")]
internal class System.Runtime.CompilerServices.RefSafetyRulesAttribute : Attribute {
    public int Version;
    public RefSafetyRulesAttribute(int );
}
[ExtensionAttribute]
internal static class System.StringExtensions : object {
    [NullableContextAttribute("2")]
[ExtensionAttribute]
public static bool IsNullOrWhiteSpace(string value);
}
