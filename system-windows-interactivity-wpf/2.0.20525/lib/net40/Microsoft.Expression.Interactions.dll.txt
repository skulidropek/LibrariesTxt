[DebuggerNonUserCodeAttribute]
[CompilerGeneratedAttribute]
[GeneratedCodeAttribute("System.Resources.Tools.StronglyTypedResourceBuilder", "2.0.0.0")]
internal class ExceptionStringTable : object {
    private static ResourceManager resourceMan;
    private static CultureInfo resourceCulture;
    [EditorBrowsableAttribute("2")]
internal static ResourceManager ResourceManager { get; }
    [EditorBrowsableAttribute("2")]
internal static CultureInfo Culture { get; internal set; }
    internal static string CallMethodActionValidMethodNotFoundExceptionMessage { get; }
    internal static string ChangePropertyActionAmbiguousAdditionOperationExceptionMessage { get; }
    internal static string ChangePropertyActionCannotAnimateTargetTypeExceptionMessage { get; }
    internal static string ChangePropertyActionCannotFindPropertyNameExceptionMessage { get; }
    internal static string ChangePropertyActionCannotIncrementAnimatedPropertyChangeExceptionMessage { get; }
    internal static string ChangePropertyActionCannotIncrementWriteOnlyPropertyExceptionMessage { get; }
    internal static string ChangePropertyActionCannotSetValueExceptionMessage { get; }
    internal static string ChangePropertyActionPropertyIsReadOnlyExceptionMessage { get; }
    internal static string DataStateBehaviorStateNameNotFoundExceptionMessage { get; }
    internal static string GoToStateActionTargetHasNoStateGroups { get; }
    internal static string InvalidLeftOperand { get; }
    internal static string InvalidOperands { get; }
    internal static string InvalidRightOperand { get; }
    internal static string UnsupportedRemoveTargetExceptionMessage { get; }
    internal static ResourceManager get_ResourceManager();
    internal static CultureInfo get_Culture();
    internal static void set_Culture(CultureInfo value);
    internal static string get_CallMethodActionValidMethodNotFoundExceptionMessage();
    internal static string get_ChangePropertyActionAmbiguousAdditionOperationExceptionMessage();
    internal static string get_ChangePropertyActionCannotAnimateTargetTypeExceptionMessage();
    internal static string get_ChangePropertyActionCannotFindPropertyNameExceptionMessage();
    internal static string get_ChangePropertyActionCannotIncrementAnimatedPropertyChangeExceptionMessage();
    internal static string get_ChangePropertyActionCannotIncrementWriteOnlyPropertyExceptionMessage();
    internal static string get_ChangePropertyActionCannotSetValueExceptionMessage();
    internal static string get_ChangePropertyActionPropertyIsReadOnlyExceptionMessage();
    internal static string get_DataStateBehaviorStateNameNotFoundExceptionMessage();
    internal static string get_GoToStateActionTargetHasNoStateGroups();
    internal static string get_InvalidLeftOperand();
    internal static string get_InvalidOperands();
    internal static string get_InvalidRightOperand();
    internal static string get_UnsupportedRemoveTargetExceptionMessage();
}
internal static class Microsoft.Expression.BlendSDK.RuntimeVersion : object {
    public static string AssemblyVersion;
}
internal static class Microsoft.Expression.BlendSDK.VersionConstants : object {
    public static string Major;
    public static string Minor;
    public static string Build;
    public static string Revision;
    public static string AssemblyVersion;
    public static string AssemblyFileVersion;
}
internal static class Microsoft.Expression.Interactivity.ComparisonLogic : object {
    internal static bool EvaluateImpl(object leftOperand, ComparisonConditionType operatorType, object rightOperand);
    private static bool EvaluateComparable(IComparable leftOperand, ComparisonConditionType operatorType, IComparable rightOperand);
}
public class Microsoft.Expression.Interactivity.Core.ActionCommand : object {
    private Action action;
    private Action`1<object> objectAction;
    private EventHandler CanExecuteChanged;
    public ActionCommand(Action action);
    public ActionCommand(Action`1<object> objectAction);
    private void add_CanExecuteChanged(EventHandler value);
    private void remove_CanExecuteChanged(EventHandler value);
    private sealed virtual override void System.Windows.Input.ICommand.add_CanExecuteChanged(EventHandler value);
    private sealed virtual override void System.Windows.Input.ICommand.remove_CanExecuteChanged(EventHandler value);
    private sealed virtual override bool System.Windows.Input.ICommand.CanExecute(object parameter);
    public sealed virtual void Execute(object parameter);
}
public class Microsoft.Expression.Interactivity.Core.CallMethodAction : TriggerAction`1<DependencyObject> {
    private List`1<MethodDescriptor> methodDescriptors;
    public static DependencyProperty TargetObjectProperty;
    public static DependencyProperty MethodNameProperty;
    [CompilerGeneratedAttribute]
private static Func`2<MethodDescriptor, int> CS$<>9__CachedAnonymousMethodDelegate4;
    public object TargetObject { get; public set; }
    public string MethodName { get; public set; }
    private object Target { get; }
    private static CallMethodAction();
    public object get_TargetObject();
    public void set_TargetObject(object value);
    public string get_MethodName();
    public void set_MethodName(string value);
    private object get_Target();
    protected virtual void Invoke(object parameter);
    protected virtual void OnAttached();
    protected virtual void OnDetaching();
    private MethodDescriptor FindBestMethod(object parameter);
    private void UpdateMethodInfo();
    private bool IsMethodValid(MethodInfo method);
    private static bool AreMethodParamsValid(ParameterInfo[] methodParams);
    private static void OnMethodNameChanged(DependencyObject sender, DependencyPropertyChangedEventArgs args);
    private static void OnTargetObjectChanged(DependencyObject sender, DependencyPropertyChangedEventArgs args);
    [CompilerGeneratedAttribute]
private static int <UpdateMethodInfo>b__3(MethodDescriptor methodDescriptor);
}
public class Microsoft.Expression.Interactivity.Core.ChangePropertyAction : TargetedTriggerAction`1<object> {
    public static DependencyProperty PropertyNameProperty;
    public static DependencyProperty ValueProperty;
    public static DependencyProperty DurationProperty;
    public static DependencyProperty IncrementProperty;
    public string PropertyName { get; public set; }
    public object Value { get; public set; }
    public Duration Duration { get; public set; }
    public bool Increment { get; public set; }
    private static ChangePropertyAction();
    public string get_PropertyName();
    public void set_PropertyName(string value);
    public object get_Value();
    public void set_Value(object value);
    public Duration get_Duration();
    public void set_Duration(Duration value);
    public bool get_Increment();
    public void set_Increment(bool value);
    protected virtual void Invoke(object parameter);
    private void AnimatePropertyChange(PropertyInfo propertyInfo, object fromValue, object newValue);
    private static object GetCurrentPropertyValue(object target, PropertyInfo propertyInfo);
    private void ValidateAnimationPossible(Type targetType);
    private Timeline CreateKeyFrameAnimation(object newValue, object fromValue);
    private Timeline CreatePointAnimation(Point fromValue, Point newValue);
    private Timeline CreateColorAnimation(Color fromValue, Color newValue);
    private Timeline CreateDoubleAnimation(double fromValue, double newValue);
    private void ValidateProperty(PropertyInfo propertyInfo);
    private object IncrementCurrentValue(PropertyInfo propertyInfo);
    private static object TryAddition(object currentValue, object value);
}
public class Microsoft.Expression.Interactivity.Core.ComparisonCondition : Freezable {
    public static DependencyProperty LeftOperandProperty;
    public static DependencyProperty OperatorProperty;
    public static DependencyProperty RightOperandProperty;
    public object LeftOperand { get; public set; }
    public object RightOperand { get; public set; }
    public ComparisonConditionType Operator { get; public set; }
    private static ComparisonCondition();
    protected virtual Freezable CreateInstanceCore();
    public object get_LeftOperand();
    public void set_LeftOperand(object value);
    public object get_RightOperand();
    public void set_RightOperand(object value);
    public ComparisonConditionType get_Operator();
    public void set_Operator(ComparisonConditionType value);
    public bool Evaluate();
    private void EnsureBindingUpToDate();
}
public enum Microsoft.Expression.Interactivity.Core.ComparisonConditionType : Enum {
    public int value__;
    public static ComparisonConditionType Equal;
    public static ComparisonConditionType NotEqual;
    public static ComparisonConditionType LessThan;
    public static ComparisonConditionType LessThanOrEqual;
    public static ComparisonConditionType GreaterThan;
    public static ComparisonConditionType GreaterThanOrEqual;
}
[ContentPropertyAttribute("Conditions")]
public class Microsoft.Expression.Interactivity.Core.ConditionalExpression : Freezable {
    public static DependencyProperty ConditionsProperty;
    public static DependencyProperty ForwardChainingProperty;
    public ForwardChaining ForwardChaining { get; public set; }
    public ConditionCollection Conditions { get; }
    private static ConditionalExpression();
    protected virtual Freezable CreateInstanceCore();
    public ForwardChaining get_ForwardChaining();
    public void set_ForwardChaining(ForwardChaining value);
    public ConditionCollection get_Conditions();
    public sealed virtual bool Evaluate();
}
[ContentPropertyAttribute("Condition")]
public class Microsoft.Expression.Interactivity.Core.ConditionBehavior : Behavior`1<TriggerBase> {
    public static DependencyProperty ConditionProperty;
    public ICondition Condition { get; public set; }
    private static ConditionBehavior();
    public ICondition get_Condition();
    public void set_Condition(ICondition value);
    protected virtual void OnAttached();
    protected virtual void OnDetaching();
    private void OnPreviewInvoke(object sender, PreviewInvokeEventArgs e);
}
public class Microsoft.Expression.Interactivity.Core.ConditionCollection : FreezableCollection`1<ComparisonCondition> {
}
public class Microsoft.Expression.Interactivity.Core.DataStateBehavior : Behavior`1<FrameworkElement> {
    public static DependencyProperty BindingProperty;
    public static DependencyProperty ValueProperty;
    public static DependencyProperty TrueStateProperty;
    public static DependencyProperty FalseStateProperty;
    public object Binding { get; public set; }
    public object Value { get; public set; }
    public string TrueState { get; public set; }
    public string FalseState { get; public set; }
    private FrameworkElement TargetObject { get; }
    private IEnumerable`1<VisualState> TargetedVisualStates { get; }
    private static DataStateBehavior();
    public object get_Binding();
    public void set_Binding(object value);
    public object get_Value();
    public void set_Value(object value);
    public string get_TrueState();
    public void set_TrueState(string value);
    public string get_FalseState();
    public void set_FalseState(string value);
    private FrameworkElement get_TargetObject();
    protected virtual void OnAttached();
    private void ValidateStateNamesDeferred();
    internal static bool IsElementLoaded(FrameworkElement element);
    private void ValidateStateNames();
    private void ValidateStateName(string stateName);
    private IEnumerable`1<VisualState> get_TargetedVisualStates();
    private static void OnBindingChanged(DependencyObject obj, DependencyPropertyChangedEventArgs args);
    private static void OnValueChanged(DependencyObject obj, DependencyPropertyChangedEventArgs args);
    private static void OnTrueStateChanged(DependencyObject obj, DependencyPropertyChangedEventArgs args);
    private static void OnFalseStateChanged(DependencyObject obj, DependencyPropertyChangedEventArgs args);
    private void Evaluate();
    [CompilerGeneratedAttribute]
private void <ValidateStateNamesDeferred>b__0(object o, RoutedEventArgs e);
}
public class Microsoft.Expression.Interactivity.Core.DataStoreChangedTrigger : PropertyChangedTrigger {
}
public class Microsoft.Expression.Interactivity.Core.DataTrigger : PropertyChangedTrigger {
    public static DependencyProperty ValueProperty;
    public static DependencyProperty ComparisonProperty;
    public object Value { get; public set; }
    public ComparisonConditionType Comparison { get; public set; }
    private static DataTrigger();
    public object get_Value();
    public void set_Value(object value);
    public ComparisonConditionType get_Comparison();
    public void set_Comparison(ComparisonConditionType value);
    protected virtual void EvaluateBindingChange(object args);
    private static void OnValueChanged(object sender, DependencyPropertyChangedEventArgs args);
    private static void OnComparisonChanged(object sender, DependencyPropertyChangedEventArgs args);
    private bool Compare();
}
public class Microsoft.Expression.Interactivity.Core.ExtendedVisualStateManager : VisualStateManager {
    public static DependencyProperty UseFluidLayoutProperty;
    public static DependencyProperty RuntimeVisibilityPropertyProperty;
    internal static DependencyProperty OriginalLayoutValuesProperty;
    internal static DependencyProperty LayoutStoryboardProperty;
    internal static DependencyProperty CurrentStateProperty;
    public static DependencyProperty TransitionEffectProperty;
    internal static DependencyProperty TransitionEffectStoryboardProperty;
    internal static DependencyProperty DidCacheBackgroundProperty;
    internal static DependencyProperty CachedBackgroundProperty;
    internal static DependencyProperty CachedEffectProperty;
    private static List`1<FrameworkElement> MovingElements;
    private static Storyboard LayoutTransitionStoryboard;
    private static List`1<DependencyProperty> LayoutProperties;
    private static List`1<DependencyProperty> ChildAffectingLayoutProperties;
    private bool changingState;
    public static bool IsRunningFluidLayoutTransition { get; }
    private static ExtendedVisualStateManager();
    public static bool get_IsRunningFluidLayoutTransition();
    public static bool GetUseFluidLayout(DependencyObject obj);
    public static void SetUseFluidLayout(DependencyObject obj, bool value);
    public static DependencyProperty GetRuntimeVisibilityProperty(DependencyObject obj);
    public static void SetRuntimeVisibilityProperty(DependencyObject obj, DependencyProperty value);
    internal static List`1<OriginalLayoutValueRecord> GetOriginalLayoutValues(DependencyObject obj);
    internal static void SetOriginalLayoutValues(DependencyObject obj, List`1<OriginalLayoutValueRecord> value);
    internal static Storyboard GetLayoutStoryboard(DependencyObject obj);
    internal static void SetLayoutStoryboard(DependencyObject obj, Storyboard value);
    internal static VisualState GetCurrentState(DependencyObject obj);
    internal static void SetCurrentState(DependencyObject obj, VisualState value);
    public static TransitionEffect GetTransitionEffect(DependencyObject obj);
    public static void SetTransitionEffect(DependencyObject obj, TransitionEffect value);
    internal static Storyboard GetTransitionEffectStoryboard(DependencyObject obj);
    internal static void SetTransitionEffectStoryboard(DependencyObject obj, Storyboard value);
    internal static bool GetDidCacheBackground(DependencyObject obj);
    internal static void SetDidCacheBackground(DependencyObject obj, bool value);
    internal static object GetCachedBackground(DependencyObject obj);
    internal static void SetCachedBackground(DependencyObject obj, object value);
    internal static Effect GetCachedEffect(DependencyObject obj);
    internal static void SetCachedEffect(DependencyObject obj, Effect value);
    private static bool IsVisibilityProperty(DependencyProperty property);
    private static DependencyProperty LayoutPropertyFromTimeline(Timeline timeline, bool forceRuntimeProperty);
    protected virtual bool GoToStateCore(FrameworkElement control, FrameworkElement stateGroupsRoot, string stateName, VisualStateGroup group, VisualState state, bool useTransitions);
    private static void control_LayoutUpdated(object sender, EventArgs e);
    private static void StopAnimations();
    private static bool PrepareTransitionEffectImage(FrameworkElement stateGroupsRoot, bool useTransitions, VisualTransition transition);
    private bool TransitionEffectAwareGoToStateCore(FrameworkElement control, FrameworkElement stateGroupsRoot, string stateName, VisualStateGroup group, VisualState state, bool useTransitions, VisualTransition transition, bool animateWithTransitionEffect, VisualState previousState);
    private static bool FinishesWithZeroOpacity(FrameworkElement control, FrameworkElement stateGroupsRoot, VisualState state, VisualState previousState);
    private static bool TimelineIsAnimatingRootOpacity(Timeline timeline, FrameworkElement control, FrameworkElement stateGroupsRoot);
    private static void AnimateTransitionEffect(FrameworkElement stateGroupsRoot, VisualTransition transition);
    private static void FinishTransitionEffectAnimation(FrameworkElement stateGroupsRoot);
    private static VisualTransition FindTransition(VisualStateGroup group, VisualState previousState, VisualState state);
    private static Storyboard ExtractLayoutStoryboard(VisualState state);
    private static List`1<FrameworkElement> FindTargetElements(FrameworkElement control, FrameworkElement templateRoot, Storyboard layoutStoryboard, List`1<OriginalLayoutValueRecord> originalValueRecords, List`1<FrameworkElement> movingElements);
    private static object GetTimelineTarget(FrameworkElement control, FrameworkElement templateRoot, Timeline timeline);
    private static Dictionary`2<FrameworkElement, Rect> GetRectsOfTargets(List`1<FrameworkElement> targets, List`1<FrameworkElement> movingElements);
    internal static Rect GetLayoutRect(FrameworkElement element);
    private static Dictionary`2<FrameworkElement, double> GetOldOpacities(FrameworkElement control, FrameworkElement templateRoot, Storyboard layoutStoryboard, List`1<OriginalLayoutValueRecord> originalValueRecords, List`1<FrameworkElement> movingElements);
    private static void SetLayoutStoryboardProperties(FrameworkElement control, FrameworkElement templateRoot, Storyboard layoutStoryboard, List`1<OriginalLayoutValueRecord> originalValueRecords);
    private static object GetValueFromTimeline(Timeline timeline, Boolean& gotValue);
    private static void WrapMovingElementsInCanvases(List`1<FrameworkElement> movingElements, Dictionary`2<FrameworkElement, Rect> oldRects, Dictionary`2<FrameworkElement, Rect> newRects);
    private static void UnwrapMovingElementsFromCanvases(List`1<FrameworkElement> movingElements);
    private static void CopyLayoutProperties(FrameworkElement source, FrameworkElement target, bool restoring);
    private static Storyboard CreateLayoutTransitionStoryboard(VisualTransition transition, List`1<FrameworkElement> movingElements, Dictionary`2<FrameworkElement, double> oldOpacities);
    private static void TransferLocalValue(FrameworkElement element, DependencyProperty sourceProperty, DependencyProperty destProperty);
    private static object CacheLocalValueHelper(DependencyObject dependencyObject, DependencyProperty property);
    private static void ReplaceCachedLocalValueHelper(FrameworkElement element, DependencyProperty property, object value);
    private static bool IsClose(double a, double b);
}
public enum Microsoft.Expression.Interactivity.Core.ForwardChaining : Enum {
    public int value__;
    public static ForwardChaining And;
    public static ForwardChaining Or;
}
public class Microsoft.Expression.Interactivity.Core.GoToStateAction : TargetedTriggerAction`1<FrameworkElement> {
    public static DependencyProperty UseTransitionsProperty;
    public static DependencyProperty StateNameProperty;
    [CompilerGeneratedAttribute]
private FrameworkElement <StateTarget>k__BackingField;
    public bool UseTransitions { get; public set; }
    public string StateName { get; public set; }
    private FrameworkElement StateTarget { get; private set; }
    private bool IsTargetObjectSet { get; }
    private static GoToStateAction();
    public bool get_UseTransitions();
    public void set_UseTransitions(bool value);
    public string get_StateName();
    public void set_StateName(string value);
    [CompilerGeneratedAttribute]
private FrameworkElement get_StateTarget();
    [CompilerGeneratedAttribute]
private void set_StateTarget(FrameworkElement value);
    private bool get_IsTargetObjectSet();
    protected virtual void OnTargetChanged(FrameworkElement oldTarget, FrameworkElement newTarget);
    protected virtual void Invoke(object parameter);
    internal void InvokeImpl(FrameworkElement stateTarget);
}
public interface Microsoft.Expression.Interactivity.Core.ICondition {
    public abstract virtual bool Evaluate();
}
public class Microsoft.Expression.Interactivity.Core.LaunchUriOrFileAction : TriggerAction`1<DependencyObject> {
    public static DependencyProperty PathProperty;
    public string Path { get; public set; }
    private static LaunchUriOrFileAction();
    public string get_Path();
    public void set_Path(string value);
    protected virtual void Invoke(object parameter);
}
public class Microsoft.Expression.Interactivity.Core.PropertyChangedTrigger : TriggerBase`1<DependencyObject> {
    public static DependencyProperty BindingProperty;
    public object Binding { get; public set; }
    private static PropertyChangedTrigger();
    public object get_Binding();
    public void set_Binding(object value);
    protected virtual void EvaluateBindingChange(object args);
    protected virtual void OnAttached();
    protected virtual void OnDetaching();
    private void OnPreviewInvoke(object sender, PreviewInvokeEventArgs e);
    private static void OnBindingChanged(DependencyObject sender, DependencyPropertyChangedEventArgs args);
}
public class Microsoft.Expression.Interactivity.Core.RemoveElementAction : TargetedTriggerAction`1<FrameworkElement> {
    protected virtual void Invoke(object parameter);
}
[DefaultTriggerAttribute("System.Windows.UIElement", "System.Windows.Interactivity.EventTrigger", "Mono.Cecil.CustomAttributeArgument")]
public class Microsoft.Expression.Interactivity.Core.SetDataStoreValueAction : ChangePropertyAction {
}
public class Microsoft.Expression.Interactivity.Core.TimerTrigger : EventTrigger {
    public static DependencyProperty MillisecondsPerTickProperty;
    public static DependencyProperty TotalTicksProperty;
    private DispatcherTimer timer;
    private EventArgs eventArgs;
    private int tickCount;
    public double MillisecondsPerTick { get; public set; }
    public int TotalTicks { get; public set; }
    private static TimerTrigger();
    public double get_MillisecondsPerTick();
    public void set_MillisecondsPerTick(double value);
    public int get_TotalTicks();
    public void set_TotalTicks(int value);
    protected virtual void OnEvent(EventArgs eventArgs);
    protected virtual void OnDetaching();
    internal void StartTimer();
    internal void StopTimer();
    private void OnTimerTick(object sender, EventArgs e);
}
internal static class Microsoft.Expression.Interactivity.DataBindingHelper : object {
    private static Dictionary`2<Type, IList`1<DependencyProperty>> DependenciesPropertyCache;
    private static DataBindingHelper();
    public static void EnsureDataBindingUpToDateOnMembers(DependencyObject dpObject);
    public static void EnsureDataBindingOnActionsUpToDate(TriggerBase`1<DependencyObject> trigger);
    public static void EnsureBindingUpToDate(DependencyObject target, DependencyProperty dp);
}
public class Microsoft.Expression.Interactivity.Input.KeyTrigger : EventTriggerBase`1<UIElement> {
    public static DependencyProperty KeyProperty;
    public static DependencyProperty ModifiersProperty;
    public static DependencyProperty ActiveOnFocusProperty;
    public static DependencyProperty FiredOnProperty;
    private UIElement targetElement;
    public Key Key { get; public set; }
    public ModifierKeys Modifiers { get; public set; }
    public bool ActiveOnFocus { get; public set; }
    public KeyTriggerFiredOn FiredOn { get; public set; }
    private static KeyTrigger();
    public Key get_Key();
    public void set_Key(Key value);
    public ModifierKeys get_Modifiers();
    public void set_Modifiers(ModifierKeys value);
    public bool get_ActiveOnFocus();
    public void set_ActiveOnFocus(bool value);
    public KeyTriggerFiredOn get_FiredOn();
    public void set_FiredOn(KeyTriggerFiredOn value);
    protected virtual string GetEventName();
    private void OnKeyPress(object sender, KeyEventArgs e);
    private static ModifierKeys GetActualModifiers(Key key, ModifierKeys modifiers);
    protected virtual void OnEvent(EventArgs eventArgs);
    protected virtual void OnDetaching();
    private static UIElement GetRoot(DependencyObject current);
}
public enum Microsoft.Expression.Interactivity.Input.KeyTriggerFiredOn : Enum {
    public int value__;
    public static KeyTriggerFiredOn KeyDown;
    public static KeyTriggerFiredOn KeyUp;
}
public class Microsoft.Expression.Interactivity.Input.TranslateZoomRotateBehavior : Behavior`1<FrameworkElement> {
    private static double HardMinimumScale;
    private Transform cachedRenderTransform;
    private bool isDragging;
    private bool isAdjustingTransform;
    private Point lastMousePoint;
    private double lastScaleX;
    private double lastScaleY;
    public static DependencyProperty SupportedGesturesProperty;
    public static DependencyProperty TranslateFrictionProperty;
    public static DependencyProperty RotationalFrictionProperty;
    public static DependencyProperty ConstrainToParentBoundsProperty;
    public static DependencyProperty MinimumScaleProperty;
    public static DependencyProperty MaximumScaleProperty;
    public ManipulationModes SupportedGestures { get; public set; }
    public double TranslateFriction { get; public set; }
    public double RotationalFriction { get; public set; }
    public bool ConstrainToParentBounds { get; public set; }
    public double MinimumScale { get; public set; }
    public double MaximumScale { get; public set; }
    private Transform RenderTransform { get; private set; }
    private Point RenderTransformOriginInElementCoordinates { get; }
    private Matrix FullTransformValue { get; }
    private MatrixTransform MatrixTransform { get; }
    private FrameworkElement ParentElement { get; }
    private static TranslateZoomRotateBehavior();
    public ManipulationModes get_SupportedGestures();
    public void set_SupportedGestures(ManipulationModes value);
    public double get_TranslateFriction();
    public void set_TranslateFriction(double value);
    public double get_RotationalFriction();
    public void set_RotationalFriction(double value);
    public bool get_ConstrainToParentBounds();
    public void set_ConstrainToParentBounds(bool value);
    public double get_MinimumScale();
    public void set_MinimumScale(double value);
    public double get_MaximumScale();
    public void set_MaximumScale(double value);
    private static void frictionChanged(DependencyObject sender, DependencyPropertyChangedEventArgs e);
    private static object coerceFriction(DependencyObject sender, object value);
    private Transform get_RenderTransform();
    private void set_RenderTransform(Transform value);
    private Point get_RenderTransformOriginInElementCoordinates();
    private Matrix get_FullTransformValue();
    private MatrixTransform get_MatrixTransform();
    private FrameworkElement get_ParentElement();
    internal void EnsureTransform();
    internal void ApplyRotationTransform(double angle, Point rotationPoint);
    internal void ApplyScaleTransform(double scaleX, double scaleY, Point scalePoint);
    internal void ApplyTranslateTransform(double x, double y);
    private void ManipulationStarting(object sender, ManipulationStartingEventArgs e);
    private void ManipulationInertiaStarting(object sender, ManipulationInertiaStartingEventArgs e);
    private void ManipulationDelta(object sender, ManipulationDeltaEventArgs e);
    private void MouseLeftButtonDown(object sender, MouseButtonEventArgs e);
    private void MouseLeftButtonUp(object sender, MouseButtonEventArgs e);
    private void AssociatedObject_LostMouseCapture(object sender, MouseEventArgs e);
    private void AssociatedObject_MouseMove(object sender, MouseEventArgs e);
    protected virtual void OnAttached();
    protected virtual void OnDetaching();
}
public class Microsoft.Expression.Interactivity.Layout.AdornerContainer : Adorner {
    private UIElement child;
    public UIElement Child { get; public set; }
    protected int VisualChildrenCount { get; }
    public AdornerContainer(UIElement adornedElement);
    protected virtual Size ArrangeOverride(Size finalSize);
    public UIElement get_Child();
    public void set_Child(UIElement value);
    protected virtual int get_VisualChildrenCount();
    protected virtual Visual GetVisualChild(int index);
}
public class Microsoft.Expression.Interactivity.Layout.FluidMoveBehavior : FluidMoveBehaviorBase {
    public static DependencyProperty DurationProperty;
    public static DependencyProperty InitialTagProperty;
    public static DependencyProperty InitialTagPathProperty;
    private static DependencyProperty InitialIdentityTagProperty;
    public static DependencyProperty FloatAboveProperty;
    public static DependencyProperty EaseXProperty;
    public static DependencyProperty EaseYProperty;
    private static DependencyProperty OverlayProperty;
    private static DependencyProperty CacheDuringOverlayProperty;
    private static DependencyProperty HasTransformWrapperProperty;
    private static Dictionary`2<object, Storyboard> TransitionStoryboardDictionary;
    public Duration Duration { get; public set; }
    public TagType InitialTag { get; public set; }
    public string InitialTagPath { get; public set; }
    public bool FloatAbove { get; public set; }
    public IEasingFunction EaseX { get; public set; }
    public IEasingFunction EaseY { get; public set; }
    protected bool ShouldSkipInitialLayout { get; }
    private static FluidMoveBehavior();
    public Duration get_Duration();
    public void set_Duration(Duration value);
    public TagType get_InitialTag();
    public void set_InitialTag(TagType value);
    public string get_InitialTagPath();
    public void set_InitialTagPath(string value);
    private static object GetInitialIdentityTag(DependencyObject obj);
    private static void SetInitialIdentityTag(DependencyObject obj, object value);
    public bool get_FloatAbove();
    public void set_FloatAbove(bool value);
    public IEasingFunction get_EaseX();
    public void set_EaseX(IEasingFunction value);
    public IEasingFunction get_EaseY();
    public void set_EaseY(IEasingFunction value);
    private static object GetOverlay(DependencyObject obj);
    private static void SetOverlay(DependencyObject obj, object value);
    private static object GetCacheDuringOverlay(DependencyObject obj);
    private static void SetCacheDuringOverlay(DependencyObject obj, object value);
    private static bool GetHasTransformWrapper(DependencyObject obj);
    private static void SetHasTransformWrapper(DependencyObject obj, bool value);
    protected virtual bool get_ShouldSkipInitialLayout();
    protected virtual void EnsureTags(FrameworkElement child);
    internal virtual void UpdateLayoutTransitionCore(FrameworkElement child, FrameworkElement root, object tag, TagData newTagData);
    private Storyboard CreateTransitionStoryboard(FrameworkElement child, bool usingBeforeLoaded, Rect& layoutRect, Rect& currentRect);
    private static void AddTransform(FrameworkElement child, Transform transform);
    private static Transform GetTransform(FrameworkElement child);
    private static void RemoveTransform(FrameworkElement child);
    private static void TransferLocalValue(FrameworkElement element, DependencyProperty source, DependencyProperty dest);
    private static bool IsClose(double a, double b);
    private static bool IsEmptyRect(Rect rect);
}
public abstract class Microsoft.Expression.Interactivity.Layout.FluidMoveBehaviorBase : Behavior`1<FrameworkElement> {
    public static DependencyProperty AppliesToProperty;
    public static DependencyProperty IsActiveProperty;
    public static DependencyProperty TagProperty;
    public static DependencyProperty TagPathProperty;
    protected static DependencyProperty IdentityTagProperty;
    internal static Dictionary`2<object, TagData> TagDictionary;
    private static DateTime NextToLastPurgeTick;
    private static DateTime LastPurgeTick;
    private static TimeSpan MinTickDelta;
    public FluidMoveScope AppliesTo { get; public set; }
    public bool IsActive { get; public set; }
    public TagType Tag { get; public set; }
    public string TagPath { get; public set; }
    protected bool ShouldSkipInitialLayout { get; }
    private static FluidMoveBehaviorBase();
    public FluidMoveScope get_AppliesTo();
    public void set_AppliesTo(FluidMoveScope value);
    public bool get_IsActive();
    public void set_IsActive(bool value);
    public TagType get_Tag();
    public void set_Tag(TagType value);
    public string get_TagPath();
    public void set_TagPath(string value);
    protected static object GetIdentityTag(DependencyObject obj);
    protected static void SetIdentityTag(DependencyObject obj, object value);
    protected virtual void OnAttached();
    protected virtual void OnDetaching();
    private void AssociatedObject_LayoutUpdated(object sender, EventArgs e);
    private void UpdateLayoutTransition(FrameworkElement child);
    protected virtual bool get_ShouldSkipInitialLayout();
    internal abstract virtual void UpdateLayoutTransitionCore(FrameworkElement child, FrameworkElement root, object tag, TagData newTagData);
    protected virtual void EnsureTags(FrameworkElement child);
    private static FrameworkElement GetVisualRoot(FrameworkElement child);
    internal static Rect TranslateRect(Rect rect, FrameworkElement from, FrameworkElement to);
}
public enum Microsoft.Expression.Interactivity.Layout.FluidMoveScope : Enum {
    public int value__;
    public static FluidMoveScope Self;
    public static FluidMoveScope Children;
}
public class Microsoft.Expression.Interactivity.Layout.FluidMoveSetTagBehavior : FluidMoveBehaviorBase {
    internal virtual void UpdateLayoutTransitionCore(FrameworkElement child, FrameworkElement root, object tag, TagData newTagData);
}
public class Microsoft.Expression.Interactivity.Layout.MouseDragElementBehavior : Behavior`1<FrameworkElement> {
    private bool settingPosition;
    private Point relativePosition;
    private Transform cachedRenderTransform;
    private MouseEventHandler DragBegun;
    private MouseEventHandler Dragging;
    private MouseEventHandler DragFinished;
    public static DependencyProperty XProperty;
    public static DependencyProperty YProperty;
    public static DependencyProperty ConstrainToParentBoundsProperty;
    public double X { get; public set; }
    public double Y { get; public set; }
    public bool ConstrainToParentBounds { get; public set; }
    private Point ActualPosition { get; }
    private Rect ElementBounds { get; }
    private FrameworkElement ParentElement { get; }
    private UIElement RootElement { get; }
    private Transform RenderTransform { get; private set; }
    private static MouseDragElementBehavior();
    public void add_DragBegun(MouseEventHandler value);
    public void remove_DragBegun(MouseEventHandler value);
    public void add_Dragging(MouseEventHandler value);
    public void remove_Dragging(MouseEventHandler value);
    public void add_DragFinished(MouseEventHandler value);
    public void remove_DragFinished(MouseEventHandler value);
    public double get_X();
    public void set_X(double value);
    public double get_Y();
    public void set_Y(double value);
    public bool get_ConstrainToParentBounds();
    public void set_ConstrainToParentBounds(bool value);
    private static void OnXChanged(object sender, DependencyPropertyChangedEventArgs args);
    private static void OnYChanged(object sender, DependencyPropertyChangedEventArgs args);
    private static void OnConstrainToParentBoundsChanged(object sender, DependencyPropertyChangedEventArgs args);
    private Point get_ActualPosition();
    private Rect get_ElementBounds();
    private FrameworkElement get_ParentElement();
    private UIElement get_RootElement();
    private Transform get_RenderTransform();
    private void set_RenderTransform(Transform value);
    private void UpdatePosition(Point point);
    private void ApplyTranslation(double x, double y);
    internal void ApplyTranslationTransform(double x, double y);
    internal static Transform CloneTransform(Transform transform);
    private void UpdatePosition();
    internal void StartDrag(Point positionInElementCoordinates);
    internal void HandleDrag(Point newPositionInElementCoordinates);
    internal void EndDrag();
    private void OnMouseLeftButtonDown(object sender, MouseButtonEventArgs e);
    private void OnLostMouseCapture(object sender, MouseEventArgs e);
    private void OnMouseLeftButtonUp(object sender, MouseButtonEventArgs e);
    private void OnMouseMove(object sender, MouseEventArgs e);
    private static bool RectContainsRect(Rect rect1, Rect rect2);
    private static Point TransformAsVector(GeneralTransform transform, double x, double y);
    private static Point GetTransformOffset(GeneralTransform transform);
    protected virtual void OnAttached();
    protected virtual void OnDetaching();
}
public enum Microsoft.Expression.Interactivity.Layout.TagType : Enum {
    public int value__;
    public static TagType Element;
    public static TagType DataContext;
}
[CLSCompliantAttribute("False")]
public class Microsoft.Expression.Interactivity.Media.ControlStoryboardAction : StoryboardAction {
    public static DependencyProperty ControlStoryboardProperty;
    public ControlStoryboardOption ControlStoryboardOption { get; public set; }
    private static ControlStoryboardAction();
    public ControlStoryboardOption get_ControlStoryboardOption();
    public void set_ControlStoryboardOption(ControlStoryboardOption value);
    protected virtual void Invoke(object parameter);
}
public enum Microsoft.Expression.Interactivity.Media.ControlStoryboardOption : Enum {
    public int value__;
    public static ControlStoryboardOption Play;
    public static ControlStoryboardOption Stop;
    public static ControlStoryboardOption TogglePlayPause;
    public static ControlStoryboardOption Pause;
    public static ControlStoryboardOption Resume;
    public static ControlStoryboardOption SkipToFill;
}
public class Microsoft.Expression.Interactivity.Media.PlaySoundAction : TriggerAction`1<DependencyObject> {
    public static DependencyProperty SourceProperty;
    public static DependencyProperty VolumeProperty;
    public Uri Source { get; public set; }
    public double Volume { get; public set; }
    private static PlaySoundAction();
    public Uri get_Source();
    public void set_Source(Uri value);
    public double get_Volume();
    public void set_Volume(double value);
    protected virtual void SetMediaElementProperties(MediaElement mediaElement);
    protected virtual void Invoke(object parameter);
}
public abstract class Microsoft.Expression.Interactivity.Media.StoryboardAction : TriggerAction`1<DependencyObject> {
    public static DependencyProperty StoryboardProperty;
    public Storyboard Storyboard { get; public set; }
    private static StoryboardAction();
    public Storyboard get_Storyboard();
    public void set_Storyboard(Storyboard value);
    private static void OnStoryboardChanged(DependencyObject sender, DependencyPropertyChangedEventArgs args);
    protected virtual void OnStoryboardChanged(DependencyPropertyChangedEventArgs args);
}
public class Microsoft.Expression.Interactivity.Media.StoryboardCompletedTrigger : StoryboardTrigger {
    protected virtual void OnDetaching();
    protected virtual void OnStoryboardChanged(DependencyPropertyChangedEventArgs args);
    private void Storyboard_Completed(object sender, EventArgs e);
}
public abstract class Microsoft.Expression.Interactivity.Media.StoryboardTrigger : TriggerBase`1<DependencyObject> {
    public static DependencyProperty StoryboardProperty;
    public Storyboard Storyboard { get; public set; }
    private static StoryboardTrigger();
    public Storyboard get_Storyboard();
    public void set_Storyboard(Storyboard value);
    private static void OnStoryboardChanged(DependencyObject sender, DependencyPropertyChangedEventArgs args);
    protected virtual void OnStoryboardChanged(DependencyPropertyChangedEventArgs args);
}
internal static class Microsoft.Expression.Interactivity.TypeConverterHelper : object {
    internal static object DoConversionFrom(TypeConverter converter, object value);
    private static bool ShouldEatException(Exception e);
    internal static TypeConverter GetTypeConverter(Type type);
}
public static class Microsoft.Expression.Interactivity.VisualStateUtilities : object {
    public static bool GoToState(FrameworkElement element, string stateName, bool useTransitions);
    public static IList GetVisualStateGroups(FrameworkElement targetObject);
    public static bool TryFindNearestStatefulControl(FrameworkElement contextElement, FrameworkElement& resolvedControl);
    private static bool HasVisualStateGroupsDefined(FrameworkElement frameworkElement);
    internal static FrameworkElement FindNearestStatefulControl(FrameworkElement contextElement);
    private static bool ShouldContinueTreeWalk(FrameworkElement element);
    private static FrameworkElement FindTemplatedParent(FrameworkElement parent);
}
public abstract class Microsoft.Expression.Media.Effects.TransitionEffect : ShaderEffect {
    public static DependencyProperty InputProperty;
    public static DependencyProperty OldImageProperty;
    public static DependencyProperty ProgressProperty;
    public Brush Input { get; public set; }
    public Brush OldImage { get; public set; }
    public double Progress { get; public set; }
    private static TransitionEffect();
    public TransitionEffect CloneCurrentValue();
    protected abstract virtual TransitionEffect DeepCopy();
    public Brush get_Input();
    public void set_Input(Brush value);
    public Brush get_OldImage();
    public void set_OldImage(Brush value);
    public double get_Progress();
    public void set_Progress(double value);
}
