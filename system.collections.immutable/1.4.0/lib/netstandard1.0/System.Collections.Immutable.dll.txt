internal static class FxResources.System.Collections.Immutable.SR : object {
}
internal interface System.Collections.Generic.IHashKeyCollection`1 {
    public IEqualityComparer`1<TKey> KeyComparer { get; }
    public abstract virtual IEqualityComparer`1<TKey> get_KeyComparer();
}
internal interface System.Collections.Generic.ISortKeyCollection`1 {
    public IComparer`1<TKey> KeyComparer { get; }
    public abstract virtual IComparer`1<TKey> get_KeyComparer();
}
internal static class System.Collections.Immutable.AllocFreeConcurrentStack : object {
    [ThreadStaticAttribute]
internal static Dictionary`2<Type, object> t_stacks;
}
internal static class System.Collections.Immutable.AllocFreeConcurrentStack`1 : object {
    private static int MaxSize;
    private static Type s_typeOfT;
    private static Stack`1<RefAsValueType`1<T>> ThreadLocalStack { get; }
    private static AllocFreeConcurrentStack`1();
    public static void TryAdd(T item);
    public static bool TryTake(T& item);
    private static Stack`1<RefAsValueType`1<T>> get_ThreadLocalStack();
}
internal class System.Collections.Immutable.DictionaryEnumerator`2 : object {
    private IEnumerator`1<KeyValuePair`2<TKey, TValue>> _inner;
    public DictionaryEntry Entry { get; }
    public object Key { get; }
    public object Value { get; }
    public object Current { get; }
    internal DictionaryEnumerator`2(IEnumerator`1<KeyValuePair`2<TKey, TValue>> inner);
    public sealed virtual DictionaryEntry get_Entry();
    public sealed virtual object get_Key();
    public sealed virtual object get_Value();
    public sealed virtual object get_Current();
    public sealed virtual bool MoveNext();
    public sealed virtual void Reset();
}
internal class System.Collections.Immutable.DisposableEnumeratorAdapter`2 : ValueType {
    private IEnumerator`1<T> _enumeratorObject;
    private TEnumerator _enumeratorStruct;
    public T Current { get; }
    internal DisposableEnumeratorAdapter`2(TEnumerator enumerator);
    internal DisposableEnumeratorAdapter`2(IEnumerator`1<T> enumerator);
    public T get_Current();
    public bool MoveNext();
    public sealed virtual void Dispose();
    public DisposableEnumeratorAdapter`2<T, TEnumerator> GetEnumerator();
}
internal interface System.Collections.Immutable.IBinaryTree {
    public int Height { get; }
    public bool IsEmpty { get; }
    public int Count { get; }
    public IBinaryTree Left { get; }
    public IBinaryTree Right { get; }
    public abstract virtual int get_Height();
    public abstract virtual bool get_IsEmpty();
    public abstract virtual int get_Count();
    public abstract virtual IBinaryTree get_Left();
    public abstract virtual IBinaryTree get_Right();
}
internal interface System.Collections.Immutable.IBinaryTree`1 {
    public T Value { get; }
    public IBinaryTree`1<T> Left { get; }
    public IBinaryTree`1<T> Right { get; }
    public abstract virtual T get_Value();
    public abstract virtual IBinaryTree`1<T> get_Left();
    public abstract virtual IBinaryTree`1<T> get_Right();
}
internal interface System.Collections.Immutable.IImmutableArray {
    public Array Array { get; }
    public abstract virtual Array get_Array();
}
public interface System.Collections.Immutable.IImmutableDictionary`2 {
    public abstract virtual IImmutableDictionary`2<TKey, TValue> Clear();
    public abstract virtual IImmutableDictionary`2<TKey, TValue> Add(TKey key, TValue value);
    public abstract virtual IImmutableDictionary`2<TKey, TValue> AddRange(IEnumerable`1<KeyValuePair`2<TKey, TValue>> pairs);
    public abstract virtual IImmutableDictionary`2<TKey, TValue> SetItem(TKey key, TValue value);
    public abstract virtual IImmutableDictionary`2<TKey, TValue> SetItems(IEnumerable`1<KeyValuePair`2<TKey, TValue>> items);
    public abstract virtual IImmutableDictionary`2<TKey, TValue> RemoveRange(IEnumerable`1<TKey> keys);
    public abstract virtual IImmutableDictionary`2<TKey, TValue> Remove(TKey key);
    public abstract virtual bool Contains(KeyValuePair`2<TKey, TValue> pair);
    public abstract virtual bool TryGetKey(TKey equalKey, TKey& actualKey);
}
internal interface System.Collections.Immutable.IImmutableDictionaryInternal`2 {
    public abstract virtual bool ContainsValue(TValue value);
}
public interface System.Collections.Immutable.IImmutableList`1 {
    public abstract virtual IImmutableList`1<T> Clear();
    public abstract virtual int IndexOf(T item, int index, int count, IEqualityComparer`1<T> equalityComparer);
    public abstract virtual int LastIndexOf(T item, int index, int count, IEqualityComparer`1<T> equalityComparer);
    public abstract virtual IImmutableList`1<T> Add(T value);
    public abstract virtual IImmutableList`1<T> AddRange(IEnumerable`1<T> items);
    public abstract virtual IImmutableList`1<T> Insert(int index, T element);
    public abstract virtual IImmutableList`1<T> InsertRange(int index, IEnumerable`1<T> items);
    public abstract virtual IImmutableList`1<T> Remove(T value, IEqualityComparer`1<T> equalityComparer);
    public abstract virtual IImmutableList`1<T> RemoveAll(Predicate`1<T> match);
    public abstract virtual IImmutableList`1<T> RemoveRange(IEnumerable`1<T> items, IEqualityComparer`1<T> equalityComparer);
    public abstract virtual IImmutableList`1<T> RemoveRange(int index, int count);
    public abstract virtual IImmutableList`1<T> RemoveAt(int index);
    public abstract virtual IImmutableList`1<T> SetItem(int index, T value);
    public abstract virtual IImmutableList`1<T> Replace(T oldValue, T newValue, IEqualityComparer`1<T> equalityComparer);
}
internal interface System.Collections.Immutable.IImmutableListQueries`1 {
    public abstract virtual ImmutableList`1<TOutput> ConvertAll(Func`2<T, TOutput> converter);
    public abstract virtual void ForEach(Action`1<T> action);
    public abstract virtual ImmutableList`1<T> GetRange(int index, int count);
    public abstract virtual void CopyTo(T[] array);
    public abstract virtual void CopyTo(T[] array, int arrayIndex);
    public abstract virtual void CopyTo(int index, T[] array, int arrayIndex, int count);
    public abstract virtual bool Exists(Predicate`1<T> match);
    public abstract virtual T Find(Predicate`1<T> match);
    public abstract virtual ImmutableList`1<T> FindAll(Predicate`1<T> match);
    public abstract virtual int FindIndex(Predicate`1<T> match);
    public abstract virtual int FindIndex(int startIndex, Predicate`1<T> match);
    public abstract virtual int FindIndex(int startIndex, int count, Predicate`1<T> match);
    public abstract virtual T FindLast(Predicate`1<T> match);
    public abstract virtual int FindLastIndex(Predicate`1<T> match);
    public abstract virtual int FindLastIndex(int startIndex, Predicate`1<T> match);
    public abstract virtual int FindLastIndex(int startIndex, int count, Predicate`1<T> match);
    public abstract virtual bool TrueForAll(Predicate`1<T> match);
    public abstract virtual int BinarySearch(T item);
    public abstract virtual int BinarySearch(T item, IComparer`1<T> comparer);
    public abstract virtual int BinarySearch(int index, int count, T item, IComparer`1<T> comparer);
}
public interface System.Collections.Immutable.IImmutableQueue`1 {
    public bool IsEmpty { get; }
    public abstract virtual bool get_IsEmpty();
    public abstract virtual IImmutableQueue`1<T> Clear();
    public abstract virtual T Peek();
    public abstract virtual IImmutableQueue`1<T> Enqueue(T value);
    public abstract virtual IImmutableQueue`1<T> Dequeue();
}
public interface System.Collections.Immutable.IImmutableSet`1 {
    public abstract virtual IImmutableSet`1<T> Clear();
    public abstract virtual bool Contains(T value);
    public abstract virtual IImmutableSet`1<T> Add(T value);
    public abstract virtual IImmutableSet`1<T> Remove(T value);
    public abstract virtual bool TryGetValue(T equalValue, T& actualValue);
    public abstract virtual IImmutableSet`1<T> Intersect(IEnumerable`1<T> other);
    public abstract virtual IImmutableSet`1<T> Except(IEnumerable`1<T> other);
    public abstract virtual IImmutableSet`1<T> SymmetricExcept(IEnumerable`1<T> other);
    public abstract virtual IImmutableSet`1<T> Union(IEnumerable`1<T> other);
    public abstract virtual bool SetEquals(IEnumerable`1<T> other);
    public abstract virtual bool IsProperSubsetOf(IEnumerable`1<T> other);
    public abstract virtual bool IsProperSupersetOf(IEnumerable`1<T> other);
    public abstract virtual bool IsSubsetOf(IEnumerable`1<T> other);
    public abstract virtual bool IsSupersetOf(IEnumerable`1<T> other);
    public abstract virtual bool Overlaps(IEnumerable`1<T> other);
}
public interface System.Collections.Immutable.IImmutableStack`1 {
    public bool IsEmpty { get; }
    public abstract virtual bool get_IsEmpty();
    public abstract virtual IImmutableStack`1<T> Clear();
    public abstract virtual IImmutableStack`1<T> Push(T value);
    public abstract virtual IImmutableStack`1<T> Pop();
    public abstract virtual T Peek();
}
[ExtensionAttribute]
public static class System.Collections.Immutable.ImmutableArray : object {
    internal static Byte[] TwoElementArray;
    private static ImmutableArray();
    public static ImmutableArray`1<T> Create();
    public static ImmutableArray`1<T> Create(T item);
    public static ImmutableArray`1<T> Create(T item1, T item2);
    public static ImmutableArray`1<T> Create(T item1, T item2, T item3);
    public static ImmutableArray`1<T> Create(T item1, T item2, T item3, T item4);
    public static ImmutableArray`1<T> CreateRange(IEnumerable`1<T> items);
    public static ImmutableArray`1<T> Create(T[] items);
    public static ImmutableArray`1<T> Create(T[] items, int start, int length);
    public static ImmutableArray`1<T> Create(ImmutableArray`1<T> items, int start, int length);
    public static ImmutableArray`1<TResult> CreateRange(ImmutableArray`1<TSource> items, Func`2<TSource, TResult> selector);
    public static ImmutableArray`1<TResult> CreateRange(ImmutableArray`1<TSource> items, int start, int length, Func`2<TSource, TResult> selector);
    public static ImmutableArray`1<TResult> CreateRange(ImmutableArray`1<TSource> items, Func`3<TSource, TArg, TResult> selector, TArg arg);
    public static ImmutableArray`1<TResult> CreateRange(ImmutableArray`1<TSource> items, int start, int length, Func`3<TSource, TArg, TResult> selector, TArg arg);
    public static Builder<T> CreateBuilder();
    public static Builder<T> CreateBuilder(int initialCapacity);
    [ExtensionAttribute]
public static ImmutableArray`1<TSource> ToImmutableArray(IEnumerable`1<TSource> items);
    [ExtensionAttribute]
public static int BinarySearch(ImmutableArray`1<T> array, T value);
    [ExtensionAttribute]
public static int BinarySearch(ImmutableArray`1<T> array, T value, IComparer`1<T> comparer);
    [ExtensionAttribute]
public static int BinarySearch(ImmutableArray`1<T> array, int index, int length, T value);
    [ExtensionAttribute]
public static int BinarySearch(ImmutableArray`1<T> array, int index, int length, T value, IComparer`1<T> comparer);
    internal static ImmutableArray`1<T> CreateDefensiveCopy(T[] items);
}
[DefaultMemberAttribute("Item")]
[DebuggerDisplayAttribute("{DebuggerDisplay,nq}")]
[NonVersionableAttribute]
public class System.Collections.Immutable.ImmutableArray`1 : ValueType {
    public static ImmutableArray`1<T> Empty;
    [DebuggerBrowsableAttribute("3")]
internal T[] array;
    private T System.Collections.Generic.IList<T>.Item { get; private set; }
    [DebuggerBrowsableAttribute("0")]
private bool System.Collections.Generic.ICollection<T>.IsReadOnly { get; }
    [DebuggerBrowsableAttribute("0")]
private int System.Collections.Generic.ICollection<T>.Count { get; }
    [DebuggerBrowsableAttribute("0")]
private int System.Collections.Generic.IReadOnlyCollection<T>.Count { get; }
    private T System.Collections.Generic.IReadOnlyList<T>.Item { get; }
    [ExcludeFromCodeCoverageAttribute]
[DebuggerBrowsableAttribute("0")]
private bool System.Collections.IList.IsFixedSize { get; }
    [ExcludeFromCodeCoverageAttribute]
[DebuggerBrowsableAttribute("0")]
private bool System.Collections.IList.IsReadOnly { get; }
    [ExcludeFromCodeCoverageAttribute]
[DebuggerBrowsableAttribute("0")]
private int System.Collections.ICollection.Count { get; }
    [ExcludeFromCodeCoverageAttribute]
[DebuggerBrowsableAttribute("0")]
private bool System.Collections.ICollection.IsSynchronized { get; }
    [ExcludeFromCodeCoverageAttribute]
[DebuggerBrowsableAttribute("0")]
private object System.Collections.ICollection.SyncRoot { get; }
    [ExcludeFromCodeCoverageAttribute]
private object System.Collections.IList.Item { get; private set; }
    public T Item { get; }
    [DebuggerBrowsableAttribute("0")]
public bool IsEmpty { get; }
    [DebuggerBrowsableAttribute("0")]
public int Length { get; }
    [DebuggerBrowsableAttribute("0")]
public bool IsDefault { get; }
    [DebuggerBrowsableAttribute("0")]
public bool IsDefaultOrEmpty { get; }
    [DebuggerBrowsableAttribute("0")]
private Array System.Collections.Immutable.IImmutableArray.Array { get; }
    [DebuggerBrowsableAttribute("0")]
private string DebuggerDisplay { get; }
    internal ImmutableArray`1(T[] items);
    private static ImmutableArray`1();
    private sealed virtual override T System.Collections.Generic.IList<T>.get_Item(int index);
    private sealed virtual override void System.Collections.Generic.IList<T>.set_Item(int index, T value);
    private sealed virtual override bool System.Collections.Generic.ICollection<T>.get_IsReadOnly();
    private sealed virtual override int System.Collections.Generic.ICollection<T>.get_Count();
    private sealed virtual override int System.Collections.Generic.IReadOnlyCollection<T>.get_Count();
    private sealed virtual override T System.Collections.Generic.IReadOnlyList<T>.get_Item(int index);
    public sealed virtual int IndexOf(T item);
    public int IndexOf(T item, int startIndex, IEqualityComparer`1<T> equalityComparer);
    public int IndexOf(T item, int startIndex);
    public int IndexOf(T item, int startIndex, int count);
    public sealed virtual int IndexOf(T item, int startIndex, int count, IEqualityComparer`1<T> equalityComparer);
    public int LastIndexOf(T item);
    public int LastIndexOf(T item, int startIndex);
    public int LastIndexOf(T item, int startIndex, int count);
    public sealed virtual int LastIndexOf(T item, int startIndex, int count, IEqualityComparer`1<T> equalityComparer);
    public sealed virtual bool Contains(T item);
    public ImmutableArray`1<T> Insert(int index, T item);
    public ImmutableArray`1<T> InsertRange(int index, IEnumerable`1<T> items);
    public ImmutableArray`1<T> InsertRange(int index, ImmutableArray`1<T> items);
    public ImmutableArray`1<T> Add(T item);
    public ImmutableArray`1<T> AddRange(IEnumerable`1<T> items);
    public ImmutableArray`1<T> AddRange(ImmutableArray`1<T> items);
    public ImmutableArray`1<T> SetItem(int index, T item);
    public ImmutableArray`1<T> Replace(T oldValue, T newValue);
    public ImmutableArray`1<T> Replace(T oldValue, T newValue, IEqualityComparer`1<T> equalityComparer);
    public ImmutableArray`1<T> Remove(T item);
    public ImmutableArray`1<T> Remove(T item, IEqualityComparer`1<T> equalityComparer);
    public ImmutableArray`1<T> RemoveAt(int index);
    public ImmutableArray`1<T> RemoveRange(int index, int length);
    public ImmutableArray`1<T> RemoveRange(IEnumerable`1<T> items);
    public ImmutableArray`1<T> RemoveRange(IEnumerable`1<T> items, IEqualityComparer`1<T> equalityComparer);
    public ImmutableArray`1<T> RemoveRange(ImmutableArray`1<T> items);
    public ImmutableArray`1<T> RemoveRange(ImmutableArray`1<T> items, IEqualityComparer`1<T> equalityComparer);
    public ImmutableArray`1<T> RemoveAll(Predicate`1<T> match);
    public ImmutableArray`1<T> Clear();
    public ImmutableArray`1<T> Sort();
    public ImmutableArray`1<T> Sort(Comparison`1<T> comparison);
    public ImmutableArray`1<T> Sort(IComparer`1<T> comparer);
    public ImmutableArray`1<T> Sort(int index, int count, IComparer`1<T> comparer);
    public IEnumerable`1<TResult> OfType();
    private sealed virtual override void System.Collections.Generic.IList<T>.Insert(int index, T item);
    private sealed virtual override void System.Collections.Generic.IList<T>.RemoveAt(int index);
    private sealed virtual override void System.Collections.Generic.ICollection<T>.Add(T item);
    private sealed virtual override void System.Collections.Generic.ICollection<T>.Clear();
    private sealed virtual override bool System.Collections.Generic.ICollection<T>.Remove(T item);
    [ExcludeFromCodeCoverageAttribute]
private sealed virtual override IImmutableList`1<T> System.Collections.Immutable.IImmutableList<T>.Clear();
    [ExcludeFromCodeCoverageAttribute]
private sealed virtual override IImmutableList`1<T> System.Collections.Immutable.IImmutableList<T>.Add(T value);
    [ExcludeFromCodeCoverageAttribute]
private sealed virtual override IImmutableList`1<T> System.Collections.Immutable.IImmutableList<T>.AddRange(IEnumerable`1<T> items);
    [ExcludeFromCodeCoverageAttribute]
private sealed virtual override IImmutableList`1<T> System.Collections.Immutable.IImmutableList<T>.Insert(int index, T element);
    [ExcludeFromCodeCoverageAttribute]
private sealed virtual override IImmutableList`1<T> System.Collections.Immutable.IImmutableList<T>.InsertRange(int index, IEnumerable`1<T> items);
    [ExcludeFromCodeCoverageAttribute]
private sealed virtual override IImmutableList`1<T> System.Collections.Immutable.IImmutableList<T>.Remove(T value, IEqualityComparer`1<T> equalityComparer);
    [ExcludeFromCodeCoverageAttribute]
private sealed virtual override IImmutableList`1<T> System.Collections.Immutable.IImmutableList<T>.RemoveAll(Predicate`1<T> match);
    [ExcludeFromCodeCoverageAttribute]
private sealed virtual override IImmutableList`1<T> System.Collections.Immutable.IImmutableList<T>.RemoveRange(IEnumerable`1<T> items, IEqualityComparer`1<T> equalityComparer);
    [ExcludeFromCodeCoverageAttribute]
private sealed virtual override IImmutableList`1<T> System.Collections.Immutable.IImmutableList<T>.RemoveRange(int index, int count);
    [ExcludeFromCodeCoverageAttribute]
private sealed virtual override IImmutableList`1<T> System.Collections.Immutable.IImmutableList<T>.RemoveAt(int index);
    [ExcludeFromCodeCoverageAttribute]
private sealed virtual override IImmutableList`1<T> System.Collections.Immutable.IImmutableList<T>.SetItem(int index, T value);
    private sealed virtual override IImmutableList`1<T> System.Collections.Immutable.IImmutableList<T>.Replace(T oldValue, T newValue, IEqualityComparer`1<T> equalityComparer);
    [ExcludeFromCodeCoverageAttribute]
private sealed virtual override int System.Collections.IList.Add(object value);
    [ExcludeFromCodeCoverageAttribute]
private sealed virtual override void System.Collections.IList.Clear();
    [ExcludeFromCodeCoverageAttribute]
private sealed virtual override bool System.Collections.IList.Contains(object value);
    [ExcludeFromCodeCoverageAttribute]
private sealed virtual override int System.Collections.IList.IndexOf(object value);
    [ExcludeFromCodeCoverageAttribute]
private sealed virtual override void System.Collections.IList.Insert(int index, object value);
    private sealed virtual override bool System.Collections.IList.get_IsFixedSize();
    private sealed virtual override bool System.Collections.IList.get_IsReadOnly();
    private sealed virtual override int System.Collections.ICollection.get_Count();
    private sealed virtual override bool System.Collections.ICollection.get_IsSynchronized();
    private sealed virtual override object System.Collections.ICollection.get_SyncRoot();
    [ExcludeFromCodeCoverageAttribute]
private sealed virtual override void System.Collections.IList.Remove(object value);
    [ExcludeFromCodeCoverageAttribute]
private sealed virtual override void System.Collections.IList.RemoveAt(int index);
    private sealed virtual override object System.Collections.IList.get_Item(int index);
    private sealed virtual override void System.Collections.IList.set_Item(int index, object value);
    [ExcludeFromCodeCoverageAttribute]
private sealed virtual override void System.Collections.ICollection.CopyTo(Array array, int index);
    private sealed virtual override bool System.Collections.IStructuralEquatable.Equals(object other, IEqualityComparer comparer);
    private sealed virtual override int System.Collections.IStructuralEquatable.GetHashCode(IEqualityComparer comparer);
    private sealed virtual override int System.Collections.IStructuralComparable.CompareTo(object other, IComparer comparer);
    private ImmutableArray`1<T> RemoveAtRange(ICollection`1<int> indicesToRemove);
    [NonVersionableAttribute]
public static bool op_Equality(ImmutableArray`1<T> left, ImmutableArray`1<T> right);
    [NonVersionableAttribute]
public static bool op_Inequality(ImmutableArray`1<T> left, ImmutableArray`1<T> right);
    public static bool op_Equality(Nullable`1<ImmutableArray`1<T>> left, Nullable`1<ImmutableArray`1<T>> right);
    public static bool op_Inequality(Nullable`1<ImmutableArray`1<T>> left, Nullable`1<ImmutableArray`1<T>> right);
    [NonVersionableAttribute]
public T get_Item(int index);
    [NonVersionableAttribute]
public bool get_IsEmpty();
    [NonVersionableAttribute]
public int get_Length();
    public bool get_IsDefault();
    public bool get_IsDefaultOrEmpty();
    private sealed virtual override Array System.Collections.Immutable.IImmutableArray.get_Array();
    private string get_DebuggerDisplay();
    public void CopyTo(T[] destination);
    public sealed virtual void CopyTo(T[] destination, int destinationIndex);
    public void CopyTo(int sourceIndex, T[] destination, int destinationIndex, int length);
    public Builder<T> ToBuilder();
    public Enumerator<T> GetEnumerator();
    public virtual int GetHashCode();
    public virtual bool Equals(object obj);
    [NonVersionableAttribute]
public sealed virtual bool Equals(ImmutableArray`1<T> other);
    public static ImmutableArray`1<T> CastUp(ImmutableArray`1<TDerived> items);
    public ImmutableArray`1<TOther> CastArray();
    public ImmutableArray`1<TOther> As();
    private sealed virtual override IEnumerator`1<T> System.Collections.Generic.IEnumerable<T>.GetEnumerator();
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
    internal void ThrowNullRefIfNotInitialized();
    private void ThrowInvalidOperationIfNotInitialized();
}
internal class System.Collections.Immutable.ImmutableArrayBuilderDebuggerProxy`1 : object {
    private Builder<T> _builder;
    [DebuggerBrowsableAttribute("3")]
public T[] A { get; }
    public ImmutableArrayBuilderDebuggerProxy`1(Builder<T> builder);
    public T[] get_A();
}
[ExtensionAttribute]
public static class System.Collections.Immutable.ImmutableDictionary : object {
    public static ImmutableDictionary`2<TKey, TValue> Create();
    public static ImmutableDictionary`2<TKey, TValue> Create(IEqualityComparer`1<TKey> keyComparer);
    public static ImmutableDictionary`2<TKey, TValue> Create(IEqualityComparer`1<TKey> keyComparer, IEqualityComparer`1<TValue> valueComparer);
    public static ImmutableDictionary`2<TKey, TValue> CreateRange(IEnumerable`1<KeyValuePair`2<TKey, TValue>> items);
    public static ImmutableDictionary`2<TKey, TValue> CreateRange(IEqualityComparer`1<TKey> keyComparer, IEnumerable`1<KeyValuePair`2<TKey, TValue>> items);
    public static ImmutableDictionary`2<TKey, TValue> CreateRange(IEqualityComparer`1<TKey> keyComparer, IEqualityComparer`1<TValue> valueComparer, IEnumerable`1<KeyValuePair`2<TKey, TValue>> items);
    public static Builder<TKey, TValue> CreateBuilder();
    public static Builder<TKey, TValue> CreateBuilder(IEqualityComparer`1<TKey> keyComparer);
    public static Builder<TKey, TValue> CreateBuilder(IEqualityComparer`1<TKey> keyComparer, IEqualityComparer`1<TValue> valueComparer);
    [ExtensionAttribute]
public static ImmutableDictionary`2<TKey, TValue> ToImmutableDictionary(IEnumerable`1<TSource> source, Func`2<TSource, TKey> keySelector, Func`2<TSource, TValue> elementSelector, IEqualityComparer`1<TKey> keyComparer, IEqualityComparer`1<TValue> valueComparer);
    [ExtensionAttribute]
public static ImmutableDictionary`2<TKey, TValue> ToImmutableDictionary(IEnumerable`1<TSource> source, Func`2<TSource, TKey> keySelector, Func`2<TSource, TValue> elementSelector, IEqualityComparer`1<TKey> keyComparer);
    [ExtensionAttribute]
public static ImmutableDictionary`2<TKey, TSource> ToImmutableDictionary(IEnumerable`1<TSource> source, Func`2<TSource, TKey> keySelector);
    [ExtensionAttribute]
public static ImmutableDictionary`2<TKey, TSource> ToImmutableDictionary(IEnumerable`1<TSource> source, Func`2<TSource, TKey> keySelector, IEqualityComparer`1<TKey> keyComparer);
    [ExtensionAttribute]
public static ImmutableDictionary`2<TKey, TValue> ToImmutableDictionary(IEnumerable`1<TSource> source, Func`2<TSource, TKey> keySelector, Func`2<TSource, TValue> elementSelector);
    [ExtensionAttribute]
public static ImmutableDictionary`2<TKey, TValue> ToImmutableDictionary(IEnumerable`1<KeyValuePair`2<TKey, TValue>> source, IEqualityComparer`1<TKey> keyComparer, IEqualityComparer`1<TValue> valueComparer);
    [ExtensionAttribute]
public static ImmutableDictionary`2<TKey, TValue> ToImmutableDictionary(IEnumerable`1<KeyValuePair`2<TKey, TValue>> source, IEqualityComparer`1<TKey> keyComparer);
    [ExtensionAttribute]
public static ImmutableDictionary`2<TKey, TValue> ToImmutableDictionary(IEnumerable`1<KeyValuePair`2<TKey, TValue>> source);
    [ExtensionAttribute]
public static bool Contains(IImmutableDictionary`2<TKey, TValue> map, TKey key, TValue value);
    [ExtensionAttribute]
public static TValue GetValueOrDefault(IImmutableDictionary`2<TKey, TValue> dictionary, TKey key);
    [ExtensionAttribute]
public static TValue GetValueOrDefault(IImmutableDictionary`2<TKey, TValue> dictionary, TKey key, TValue defaultValue);
}
[DefaultMemberAttribute("Item")]
[DebuggerDisplayAttribute("Count = {Count}")]
[DebuggerTypeProxyAttribute("System.Collections.Immutable.ImmutableDictionaryDebuggerProxy`2")]
public class System.Collections.Immutable.ImmutableDictionary`2 : object {
    public static ImmutableDictionary`2<TKey, TValue> Empty;
    private static Action`1<KeyValuePair`2<int, HashBucket<TKey, TValue>>> s_FreezeBucketAction;
    private int _count;
    private SortedInt32KeyNode`1<HashBucket<TKey, TValue>> _root;
    private Comparers<TKey, TValue> _comparers;
    public int Count { get; }
    public bool IsEmpty { get; }
    public IEqualityComparer`1<TKey> KeyComparer { get; }
    public IEqualityComparer`1<TValue> ValueComparer { get; }
    public IEnumerable`1<TKey> Keys { get; }
    public IEnumerable`1<TValue> Values { get; }
    private ICollection`1<TKey> System.Collections.Generic.IDictionary<TKey,TValue>.Keys { get; }
    private ICollection`1<TValue> System.Collections.Generic.IDictionary<TKey,TValue>.Values { get; }
    private MutationInput<TKey, TValue> Origin { get; }
    public TValue Item { get; }
    private TValue System.Collections.Generic.IDictionary<TKey,TValue>.Item { get; private set; }
    private bool System.Collections.Generic.ICollection<System.Collections.Generic.KeyValuePair<TKey,TValue>>.IsReadOnly { get; }
    private bool System.Collections.IDictionary.IsFixedSize { get; }
    private bool System.Collections.IDictionary.IsReadOnly { get; }
    private ICollection System.Collections.IDictionary.Keys { get; }
    private ICollection System.Collections.IDictionary.Values { get; }
    internal SortedInt32KeyNode`1<HashBucket<TKey, TValue>> Root { get; }
    private object System.Collections.IDictionary.Item { get; private set; }
    [DebuggerBrowsableAttribute("0")]
private object System.Collections.ICollection.SyncRoot { get; }
    [DebuggerBrowsableAttribute("0")]
private bool System.Collections.ICollection.IsSynchronized { get; }
    private ImmutableDictionary`2(SortedInt32KeyNode`1<HashBucket<TKey, TValue>> root, Comparers<TKey, TValue> comparers, int count);
    private ImmutableDictionary`2(Comparers<TKey, TValue> comparers);
    private static ImmutableDictionary`2();
    public ImmutableDictionary`2<TKey, TValue> Clear();
    public sealed virtual int get_Count();
    public bool get_IsEmpty();
    public sealed virtual IEqualityComparer`1<TKey> get_KeyComparer();
    public IEqualityComparer`1<TValue> get_ValueComparer();
    [IteratorStateMachineAttribute("System.Collections.Immutable.ImmutableDictionary`2/<get_Keys>d__25")]
public sealed virtual IEnumerable`1<TKey> get_Keys();
    [IteratorStateMachineAttribute("System.Collections.Immutable.ImmutableDictionary`2/<get_Values>d__27")]
public sealed virtual IEnumerable`1<TValue> get_Values();
    [ExcludeFromCodeCoverageAttribute]
private sealed virtual override IImmutableDictionary`2<TKey, TValue> System.Collections.Immutable.IImmutableDictionary<TKey,TValue>.Clear();
    private sealed virtual override ICollection`1<TKey> System.Collections.Generic.IDictionary<TKey,TValue>.get_Keys();
    private sealed virtual override ICollection`1<TValue> System.Collections.Generic.IDictionary<TKey,TValue>.get_Values();
    private MutationInput<TKey, TValue> get_Origin();
    public sealed virtual TValue get_Item(TKey key);
    private sealed virtual override TValue System.Collections.Generic.IDictionary<TKey,TValue>.get_Item(TKey key);
    private sealed virtual override void System.Collections.Generic.IDictionary<TKey,TValue>.set_Item(TKey key, TValue value);
    private sealed virtual override bool System.Collections.Generic.ICollection<System.Collections.Generic.KeyValuePair<TKey,TValue>>.get_IsReadOnly();
    public Builder<TKey, TValue> ToBuilder();
    public ImmutableDictionary`2<TKey, TValue> Add(TKey key, TValue value);
    public ImmutableDictionary`2<TKey, TValue> AddRange(IEnumerable`1<KeyValuePair`2<TKey, TValue>> pairs);
    public ImmutableDictionary`2<TKey, TValue> SetItem(TKey key, TValue value);
    public ImmutableDictionary`2<TKey, TValue> SetItems(IEnumerable`1<KeyValuePair`2<TKey, TValue>> items);
    public ImmutableDictionary`2<TKey, TValue> Remove(TKey key);
    public ImmutableDictionary`2<TKey, TValue> RemoveRange(IEnumerable`1<TKey> keys);
    public sealed virtual bool ContainsKey(TKey key);
    public sealed virtual bool Contains(KeyValuePair`2<TKey, TValue> pair);
    public sealed virtual bool TryGetValue(TKey key, TValue& value);
    public sealed virtual bool TryGetKey(TKey equalKey, TKey& actualKey);
    public ImmutableDictionary`2<TKey, TValue> WithComparers(IEqualityComparer`1<TKey> keyComparer, IEqualityComparer`1<TValue> valueComparer);
    public ImmutableDictionary`2<TKey, TValue> WithComparers(IEqualityComparer`1<TKey> keyComparer);
    public sealed virtual bool ContainsValue(TValue value);
    public Enumerator<TKey, TValue> GetEnumerator();
    [ExcludeFromCodeCoverageAttribute]
private sealed virtual override IImmutableDictionary`2<TKey, TValue> System.Collections.Immutable.IImmutableDictionary<TKey,TValue>.Add(TKey key, TValue value);
    [ExcludeFromCodeCoverageAttribute]
private sealed virtual override IImmutableDictionary`2<TKey, TValue> System.Collections.Immutable.IImmutableDictionary<TKey,TValue>.SetItem(TKey key, TValue value);
    private sealed virtual override IImmutableDictionary`2<TKey, TValue> System.Collections.Immutable.IImmutableDictionary<TKey,TValue>.SetItems(IEnumerable`1<KeyValuePair`2<TKey, TValue>> items);
    [ExcludeFromCodeCoverageAttribute]
private sealed virtual override IImmutableDictionary`2<TKey, TValue> System.Collections.Immutable.IImmutableDictionary<TKey,TValue>.AddRange(IEnumerable`1<KeyValuePair`2<TKey, TValue>> pairs);
    [ExcludeFromCodeCoverageAttribute]
private sealed virtual override IImmutableDictionary`2<TKey, TValue> System.Collections.Immutable.IImmutableDictionary<TKey,TValue>.RemoveRange(IEnumerable`1<TKey> keys);
    [ExcludeFromCodeCoverageAttribute]
private sealed virtual override IImmutableDictionary`2<TKey, TValue> System.Collections.Immutable.IImmutableDictionary<TKey,TValue>.Remove(TKey key);
    private sealed virtual override void System.Collections.Generic.IDictionary<TKey,TValue>.Add(TKey key, TValue value);
    private sealed virtual override bool System.Collections.Generic.IDictionary<TKey,TValue>.Remove(TKey key);
    private sealed virtual override void System.Collections.Generic.ICollection<System.Collections.Generic.KeyValuePair<TKey,TValue>>.Add(KeyValuePair`2<TKey, TValue> item);
    private sealed virtual override void System.Collections.Generic.ICollection<System.Collections.Generic.KeyValuePair<TKey,TValue>>.Clear();
    private sealed virtual override bool System.Collections.Generic.ICollection<System.Collections.Generic.KeyValuePair<TKey,TValue>>.Remove(KeyValuePair`2<TKey, TValue> item);
    private sealed virtual override void System.Collections.Generic.ICollection<System.Collections.Generic.KeyValuePair<TKey,TValue>>.CopyTo(KeyValuePair`2[] array, int arrayIndex);
    private sealed virtual override bool System.Collections.IDictionary.get_IsFixedSize();
    private sealed virtual override bool System.Collections.IDictionary.get_IsReadOnly();
    private sealed virtual override ICollection System.Collections.IDictionary.get_Keys();
    private sealed virtual override ICollection System.Collections.IDictionary.get_Values();
    internal SortedInt32KeyNode`1<HashBucket<TKey, TValue>> get_Root();
    private sealed virtual override void System.Collections.IDictionary.Add(object key, object value);
    private sealed virtual override bool System.Collections.IDictionary.Contains(object key);
    private sealed virtual override IDictionaryEnumerator System.Collections.IDictionary.GetEnumerator();
    private sealed virtual override void System.Collections.IDictionary.Remove(object key);
    private sealed virtual override object System.Collections.IDictionary.get_Item(object key);
    private sealed virtual override void System.Collections.IDictionary.set_Item(object key, object value);
    private sealed virtual override void System.Collections.IDictionary.Clear();
    private sealed virtual override void System.Collections.ICollection.CopyTo(Array array, int arrayIndex);
    private sealed virtual override object System.Collections.ICollection.get_SyncRoot();
    private sealed virtual override bool System.Collections.ICollection.get_IsSynchronized();
    private sealed virtual override IEnumerator`1<KeyValuePair`2<TKey, TValue>> System.Collections.Generic.IEnumerable<System.Collections.Generic.KeyValuePair<TKey,TValue>>.GetEnumerator();
    [ExcludeFromCodeCoverageAttribute]
private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
    private static ImmutableDictionary`2<TKey, TValue> EmptyWithComparers(Comparers<TKey, TValue> comparers);
    private static bool TryCastToImmutableMap(IEnumerable`1<KeyValuePair`2<TKey, TValue>> sequence, ImmutableDictionary`2& other);
    private static bool ContainsKey(TKey key, MutationInput<TKey, TValue> origin);
    private static bool Contains(KeyValuePair`2<TKey, TValue> keyValuePair, MutationInput<TKey, TValue> origin);
    private static bool TryGetValue(TKey key, MutationInput<TKey, TValue> origin, TValue& value);
    private static bool TryGetKey(TKey equalKey, MutationInput<TKey, TValue> origin, TKey& actualKey);
    private static MutationResult<TKey, TValue> Add(TKey key, TValue value, KeyCollisionBehavior<TKey, TValue> behavior, MutationInput<TKey, TValue> origin);
    private static MutationResult<TKey, TValue> AddRange(IEnumerable`1<KeyValuePair`2<TKey, TValue>> items, MutationInput<TKey, TValue> origin, KeyCollisionBehavior<TKey, TValue> collisionBehavior);
    private static MutationResult<TKey, TValue> Remove(TKey key, MutationInput<TKey, TValue> origin);
    private static SortedInt32KeyNode`1<HashBucket<TKey, TValue>> UpdateRoot(SortedInt32KeyNode`1<HashBucket<TKey, TValue>> root, int hashCode, HashBucket<TKey, TValue> newBucket, IEqualityComparer`1<HashBucket<TKey, TValue>> hashBucketComparer);
    private static ImmutableDictionary`2<TKey, TValue> Wrap(SortedInt32KeyNode`1<HashBucket<TKey, TValue>> root, Comparers<TKey, TValue> comparers, int count);
    private ImmutableDictionary`2<TKey, TValue> Wrap(SortedInt32KeyNode`1<HashBucket<TKey, TValue>> root, int adjustedCountIfDifferentRoot);
    private ImmutableDictionary`2<TKey, TValue> AddRange(IEnumerable`1<KeyValuePair`2<TKey, TValue>> pairs, bool avoidToHashMap);
}
internal class System.Collections.Immutable.ImmutableDictionaryBuilderDebuggerProxy`2 : object {
    private Builder<TKey, TValue> _map;
    private KeyValuePair`2[] _contents;
    [DebuggerBrowsableAttribute("3")]
public KeyValuePair`2[] Contents { get; }
    public ImmutableDictionaryBuilderDebuggerProxy`2(Builder<TKey, TValue> map);
    public KeyValuePair`2[] get_Contents();
}
internal class System.Collections.Immutable.ImmutableDictionaryDebuggerProxy`2 : ImmutableEnumerableDebuggerProxy`1<KeyValuePair`2<TKey, TValue>> {
    public ImmutableDictionaryDebuggerProxy`2(IImmutableDictionary`2<TKey, TValue> dictionary);
}
internal class System.Collections.Immutable.ImmutableEnumerableDebuggerProxy`1 : object {
    private IEnumerable`1<T> _enumerable;
    private T[] _cachedContents;
    [DebuggerBrowsableAttribute("3")]
public T[] Contents { get; }
    public ImmutableEnumerableDebuggerProxy`1(IEnumerable`1<T> enumerable);
    public T[] get_Contents();
}
[ExtensionAttribute]
internal static class System.Collections.Immutable.ImmutableExtensions : object {
    [ExtensionAttribute]
internal static IOrderedCollection`1<T> AsOrderedCollection(IEnumerable`1<T> sequence);
    [ExtensionAttribute]
internal static void ClearFastWhenEmpty(Stack`1<T> stack);
    [ExtensionAttribute]
internal static DisposableEnumeratorAdapter`2<T, TEnumerator> GetEnumerableDisposable(IEnumerable`1<T> enumerable);
    [ExtensionAttribute]
internal static bool TryGetCount(IEnumerable`1<T> sequence, Int32& count);
    [ExtensionAttribute]
internal static bool TryGetCount(IEnumerable sequence, Int32& count);
    internal static int GetCount(IEnumerable`1& sequence);
    [ExtensionAttribute]
internal static bool TryCopyTo(IEnumerable`1<T> sequence, T[] array, int arrayIndex);
    [ExtensionAttribute]
internal static T[] ToArray(IEnumerable`1<T> sequence, int count);
}
[ExtensionAttribute]
public static class System.Collections.Immutable.ImmutableHashSet : object {
    public static ImmutableHashSet`1<T> Create();
    public static ImmutableHashSet`1<T> Create(IEqualityComparer`1<T> equalityComparer);
    public static ImmutableHashSet`1<T> Create(T item);
    public static ImmutableHashSet`1<T> Create(IEqualityComparer`1<T> equalityComparer, T item);
    public static ImmutableHashSet`1<T> CreateRange(IEnumerable`1<T> items);
    public static ImmutableHashSet`1<T> CreateRange(IEqualityComparer`1<T> equalityComparer, IEnumerable`1<T> items);
    public static ImmutableHashSet`1<T> Create(T[] items);
    public static ImmutableHashSet`1<T> Create(IEqualityComparer`1<T> equalityComparer, T[] items);
    public static Builder<T> CreateBuilder();
    public static Builder<T> CreateBuilder(IEqualityComparer`1<T> equalityComparer);
    [ExtensionAttribute]
public static ImmutableHashSet`1<TSource> ToImmutableHashSet(IEnumerable`1<TSource> source, IEqualityComparer`1<TSource> equalityComparer);
    [ExtensionAttribute]
public static ImmutableHashSet`1<TSource> ToImmutableHashSet(IEnumerable`1<TSource> source);
}
[DebuggerDisplayAttribute("Count = {Count}")]
[DebuggerTypeProxyAttribute("System.Collections.Immutable.ImmutableEnumerableDebuggerProxy`1")]
public class System.Collections.Immutable.ImmutableHashSet`1 : object {
    public static ImmutableHashSet`1<T> Empty;
    private static Action`1<KeyValuePair`2<int, HashBucket<T>>> s_FreezeBucketAction;
    private IEqualityComparer`1<T> _equalityComparer;
    private int _count;
    private SortedInt32KeyNode`1<HashBucket<T>> _root;
    public int Count { get; }
    public bool IsEmpty { get; }
    public IEqualityComparer`1<T> KeyComparer { get; }
    [DebuggerBrowsableAttribute("0")]
private object System.Collections.ICollection.SyncRoot { get; }
    [DebuggerBrowsableAttribute("0")]
private bool System.Collections.ICollection.IsSynchronized { get; }
    internal IBinaryTree Root { get; }
    private MutationInput<T> Origin { get; }
    private bool System.Collections.Generic.ICollection<T>.IsReadOnly { get; }
    internal ImmutableHashSet`1(IEqualityComparer`1<T> equalityComparer);
    private ImmutableHashSet`1(SortedInt32KeyNode`1<HashBucket<T>> root, IEqualityComparer`1<T> equalityComparer, int count);
    private static ImmutableHashSet`1();
    public ImmutableHashSet`1<T> Clear();
    public sealed virtual int get_Count();
    public bool get_IsEmpty();
    public sealed virtual IEqualityComparer`1<T> get_KeyComparer();
    [ExcludeFromCodeCoverageAttribute]
private sealed virtual override IImmutableSet`1<T> System.Collections.Immutable.IImmutableSet<T>.Clear();
    private sealed virtual override object System.Collections.ICollection.get_SyncRoot();
    private sealed virtual override bool System.Collections.ICollection.get_IsSynchronized();
    internal IBinaryTree get_Root();
    private MutationInput<T> get_Origin();
    public Builder<T> ToBuilder();
    public ImmutableHashSet`1<T> Add(T item);
    public ImmutableHashSet`1<T> Remove(T item);
    public sealed virtual bool TryGetValue(T equalValue, T& actualValue);
    public ImmutableHashSet`1<T> Union(IEnumerable`1<T> other);
    public ImmutableHashSet`1<T> Intersect(IEnumerable`1<T> other);
    public ImmutableHashSet`1<T> Except(IEnumerable`1<T> other);
    public ImmutableHashSet`1<T> SymmetricExcept(IEnumerable`1<T> other);
    public sealed virtual bool SetEquals(IEnumerable`1<T> other);
    public sealed virtual bool IsProperSubsetOf(IEnumerable`1<T> other);
    public sealed virtual bool IsProperSupersetOf(IEnumerable`1<T> other);
    public sealed virtual bool IsSubsetOf(IEnumerable`1<T> other);
    public sealed virtual bool IsSupersetOf(IEnumerable`1<T> other);
    public sealed virtual bool Overlaps(IEnumerable`1<T> other);
    [ExcludeFromCodeCoverageAttribute]
private sealed virtual override IImmutableSet`1<T> System.Collections.Immutable.IImmutableSet<T>.Add(T item);
    [ExcludeFromCodeCoverageAttribute]
private sealed virtual override IImmutableSet`1<T> System.Collections.Immutable.IImmutableSet<T>.Remove(T item);
    [ExcludeFromCodeCoverageAttribute]
private sealed virtual override IImmutableSet`1<T> System.Collections.Immutable.IImmutableSet<T>.Union(IEnumerable`1<T> other);
    [ExcludeFromCodeCoverageAttribute]
private sealed virtual override IImmutableSet`1<T> System.Collections.Immutable.IImmutableSet<T>.Intersect(IEnumerable`1<T> other);
    [ExcludeFromCodeCoverageAttribute]
private sealed virtual override IImmutableSet`1<T> System.Collections.Immutable.IImmutableSet<T>.Except(IEnumerable`1<T> other);
    [ExcludeFromCodeCoverageAttribute]
private sealed virtual override IImmutableSet`1<T> System.Collections.Immutable.IImmutableSet<T>.SymmetricExcept(IEnumerable`1<T> other);
    public sealed virtual bool Contains(T item);
    public ImmutableHashSet`1<T> WithComparer(IEqualityComparer`1<T> equalityComparer);
    private sealed virtual override bool System.Collections.Generic.ISet<T>.Add(T item);
    private sealed virtual override void System.Collections.Generic.ISet<T>.ExceptWith(IEnumerable`1<T> other);
    private sealed virtual override void System.Collections.Generic.ISet<T>.IntersectWith(IEnumerable`1<T> other);
    private sealed virtual override void System.Collections.Generic.ISet<T>.SymmetricExceptWith(IEnumerable`1<T> other);
    private sealed virtual override void System.Collections.Generic.ISet<T>.UnionWith(IEnumerable`1<T> other);
    private sealed virtual override bool System.Collections.Generic.ICollection<T>.get_IsReadOnly();
    private sealed virtual override void System.Collections.Generic.ICollection<T>.CopyTo(T[] array, int arrayIndex);
    private sealed virtual override void System.Collections.Generic.ICollection<T>.Add(T item);
    private sealed virtual override void System.Collections.Generic.ICollection<T>.Clear();
    private sealed virtual override bool System.Collections.Generic.ICollection<T>.Remove(T item);
    private sealed virtual override void System.Collections.ICollection.CopyTo(Array array, int arrayIndex);
    public sealed virtual Enumerator<T> GetEnumerator();
    private sealed virtual override IEnumerator`1<T> System.Collections.Generic.IEnumerable<T>.GetEnumerator();
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
    private static bool IsSupersetOf(IEnumerable`1<T> other, MutationInput<T> origin);
    private static MutationResult<T> Add(T item, MutationInput<T> origin);
    private static MutationResult<T> Remove(T item, MutationInput<T> origin);
    private static bool Contains(T item, MutationInput<T> origin);
    private static MutationResult<T> Union(IEnumerable`1<T> other, MutationInput<T> origin);
    private static bool Overlaps(IEnumerable`1<T> other, MutationInput<T> origin);
    private static bool SetEquals(IEnumerable`1<T> other, MutationInput<T> origin);
    private static SortedInt32KeyNode`1<HashBucket<T>> UpdateRoot(SortedInt32KeyNode`1<HashBucket<T>> root, int hashCode, HashBucket<T> newBucket);
    private static MutationResult<T> Intersect(IEnumerable`1<T> other, MutationInput<T> origin);
    private static MutationResult<T> Except(IEnumerable`1<T> other, IEqualityComparer`1<T> equalityComparer, SortedInt32KeyNode`1<HashBucket<T>> root);
    private static MutationResult<T> SymmetricExcept(IEnumerable`1<T> other, MutationInput<T> origin);
    private static bool IsProperSubsetOf(IEnumerable`1<T> other, MutationInput<T> origin);
    private static bool IsProperSupersetOf(IEnumerable`1<T> other, MutationInput<T> origin);
    private static bool IsSubsetOf(IEnumerable`1<T> other, MutationInput<T> origin);
    private static ImmutableHashSet`1<T> Wrap(SortedInt32KeyNode`1<HashBucket<T>> root, IEqualityComparer`1<T> equalityComparer, int count);
    private ImmutableHashSet`1<T> Wrap(SortedInt32KeyNode`1<HashBucket<T>> root, int adjustedCountIfDifferentRoot);
    private ImmutableHashSet`1<T> Union(IEnumerable`1<T> items, bool avoidWithComparer);
}
public static class System.Collections.Immutable.ImmutableInterlocked : object {
    public static bool Update(T& location, Func`2<T, T> transformer);
    public static bool Update(T& location, Func`3<T, TArg, T> transformer, TArg transformerArgument);
    public static ImmutableArray`1<T> InterlockedExchange(ImmutableArray`1& location, ImmutableArray`1<T> value);
    public static ImmutableArray`1<T> InterlockedCompareExchange(ImmutableArray`1& location, ImmutableArray`1<T> value, ImmutableArray`1<T> comparand);
    public static bool InterlockedInitialize(ImmutableArray`1& location, ImmutableArray`1<T> value);
    public static TValue GetOrAdd(ImmutableDictionary`2& location, TKey key, Func`3<TKey, TArg, TValue> valueFactory, TArg factoryArgument);
    public static TValue GetOrAdd(ImmutableDictionary`2& location, TKey key, Func`2<TKey, TValue> valueFactory);
    public static TValue GetOrAdd(ImmutableDictionary`2& location, TKey key, TValue value);
    public static TValue AddOrUpdate(ImmutableDictionary`2& location, TKey key, Func`2<TKey, TValue> addValueFactory, Func`3<TKey, TValue, TValue> updateValueFactory);
    public static TValue AddOrUpdate(ImmutableDictionary`2& location, TKey key, TValue addValue, Func`3<TKey, TValue, TValue> updateValueFactory);
    public static bool TryAdd(ImmutableDictionary`2& location, TKey key, TValue value);
    public static bool TryUpdate(ImmutableDictionary`2& location, TKey key, TValue newValue, TValue comparisonValue);
    public static bool TryRemove(ImmutableDictionary`2& location, TKey key, TValue& value);
    public static bool TryPop(ImmutableStack`1& location, T& value);
    public static void Push(ImmutableStack`1& location, T value);
    public static bool TryDequeue(ImmutableQueue`1& location, T& value);
    public static void Enqueue(ImmutableQueue`1& location, T value);
}
[ExtensionAttribute]
public static class System.Collections.Immutable.ImmutableList : object {
    public static ImmutableList`1<T> Create();
    public static ImmutableList`1<T> Create(T item);
    public static ImmutableList`1<T> CreateRange(IEnumerable`1<T> items);
    public static ImmutableList`1<T> Create(T[] items);
    public static Builder<T> CreateBuilder();
    [ExtensionAttribute]
public static ImmutableList`1<TSource> ToImmutableList(IEnumerable`1<TSource> source);
    [ExtensionAttribute]
public static IImmutableList`1<T> Replace(IImmutableList`1<T> list, T oldValue, T newValue);
    [ExtensionAttribute]
public static IImmutableList`1<T> Remove(IImmutableList`1<T> list, T value);
    [ExtensionAttribute]
public static IImmutableList`1<T> RemoveRange(IImmutableList`1<T> list, IEnumerable`1<T> items);
    [ExtensionAttribute]
public static int IndexOf(IImmutableList`1<T> list, T item);
    [ExtensionAttribute]
public static int IndexOf(IImmutableList`1<T> list, T item, IEqualityComparer`1<T> equalityComparer);
    [ExtensionAttribute]
public static int IndexOf(IImmutableList`1<T> list, T item, int startIndex);
    [ExtensionAttribute]
public static int IndexOf(IImmutableList`1<T> list, T item, int startIndex, int count);
    [ExtensionAttribute]
public static int LastIndexOf(IImmutableList`1<T> list, T item);
    [ExtensionAttribute]
public static int LastIndexOf(IImmutableList`1<T> list, T item, IEqualityComparer`1<T> equalityComparer);
    [ExtensionAttribute]
public static int LastIndexOf(IImmutableList`1<T> list, T item, int startIndex);
    [ExtensionAttribute]
public static int LastIndexOf(IImmutableList`1<T> list, T item, int startIndex, int count);
}
[DefaultMemberAttribute("Item")]
[DebuggerDisplayAttribute("Count = {Count}")]
[DebuggerTypeProxyAttribute("System.Collections.Immutable.ImmutableListDebuggerProxy`1")]
public class System.Collections.Immutable.ImmutableList`1 : object {
    public static ImmutableList`1<T> Empty;
    private Node<T> _root;
    [DebuggerBrowsableAttribute("0")]
public bool IsEmpty { get; }
    public int Count { get; }
    [DebuggerBrowsableAttribute("0")]
private object System.Collections.ICollection.SyncRoot { get; }
    [DebuggerBrowsableAttribute("0")]
private bool System.Collections.ICollection.IsSynchronized { get; }
    public T Item { get; }
    private T System.Collections.Immutable.IOrderedCollection<T>.Item { get; }
    private T System.Collections.Generic.IList<T>.Item { get; private set; }
    private bool System.Collections.Generic.ICollection<T>.IsReadOnly { get; }
    private bool System.Collections.IList.IsFixedSize { get; }
    private bool System.Collections.IList.IsReadOnly { get; }
    private object System.Collections.IList.Item { get; private set; }
    internal Node<T> Root { get; }
    private ImmutableList`1(Node<T> root);
    private static ImmutableList`1();
    public ImmutableList`1<T> Clear();
    public sealed virtual int BinarySearch(T item);
    public sealed virtual int BinarySearch(T item, IComparer`1<T> comparer);
    public sealed virtual int BinarySearch(int index, int count, T item, IComparer`1<T> comparer);
    public bool get_IsEmpty();
    private sealed virtual override IImmutableList`1<T> System.Collections.Immutable.IImmutableList<T>.Clear();
    public sealed virtual int get_Count();
    private sealed virtual override object System.Collections.ICollection.get_SyncRoot();
    private sealed virtual override bool System.Collections.ICollection.get_IsSynchronized();
    public sealed virtual T get_Item(int index);
    private sealed virtual override T System.Collections.Immutable.IOrderedCollection<T>.get_Item(int index);
    public Builder<T> ToBuilder();
    public ImmutableList`1<T> Add(T value);
    public ImmutableList`1<T> AddRange(IEnumerable`1<T> items);
    public ImmutableList`1<T> Insert(int index, T item);
    public ImmutableList`1<T> InsertRange(int index, IEnumerable`1<T> items);
    public ImmutableList`1<T> Remove(T value);
    public ImmutableList`1<T> Remove(T value, IEqualityComparer`1<T> equalityComparer);
    public ImmutableList`1<T> RemoveRange(int index, int count);
    public ImmutableList`1<T> RemoveRange(IEnumerable`1<T> items);
    public ImmutableList`1<T> RemoveRange(IEnumerable`1<T> items, IEqualityComparer`1<T> equalityComparer);
    public ImmutableList`1<T> RemoveAt(int index);
    public ImmutableList`1<T> RemoveAll(Predicate`1<T> match);
    public ImmutableList`1<T> SetItem(int index, T value);
    public ImmutableList`1<T> Replace(T oldValue, T newValue);
    public ImmutableList`1<T> Replace(T oldValue, T newValue, IEqualityComparer`1<T> equalityComparer);
    public ImmutableList`1<T> Reverse();
    public ImmutableList`1<T> Reverse(int index, int count);
    public ImmutableList`1<T> Sort();
    public ImmutableList`1<T> Sort(Comparison`1<T> comparison);
    public ImmutableList`1<T> Sort(IComparer`1<T> comparer);
    public ImmutableList`1<T> Sort(int index, int count, IComparer`1<T> comparer);
    public sealed virtual void ForEach(Action`1<T> action);
    public sealed virtual void CopyTo(T[] array);
    public sealed virtual void CopyTo(T[] array, int arrayIndex);
    public sealed virtual void CopyTo(int index, T[] array, int arrayIndex, int count);
    public sealed virtual ImmutableList`1<T> GetRange(int index, int count);
    public sealed virtual ImmutableList`1<TOutput> ConvertAll(Func`2<T, TOutput> converter);
    public sealed virtual bool Exists(Predicate`1<T> match);
    public sealed virtual T Find(Predicate`1<T> match);
    public sealed virtual ImmutableList`1<T> FindAll(Predicate`1<T> match);
    public sealed virtual int FindIndex(Predicate`1<T> match);
    public sealed virtual int FindIndex(int startIndex, Predicate`1<T> match);
    public sealed virtual int FindIndex(int startIndex, int count, Predicate`1<T> match);
    public sealed virtual T FindLast(Predicate`1<T> match);
    public sealed virtual int FindLastIndex(Predicate`1<T> match);
    public sealed virtual int FindLastIndex(int startIndex, Predicate`1<T> match);
    public sealed virtual int FindLastIndex(int startIndex, int count, Predicate`1<T> match);
    public sealed virtual int IndexOf(T item, int index, int count, IEqualityComparer`1<T> equalityComparer);
    public sealed virtual int LastIndexOf(T item, int index, int count, IEqualityComparer`1<T> equalityComparer);
    public sealed virtual bool TrueForAll(Predicate`1<T> match);
    public sealed virtual bool Contains(T value);
    public sealed virtual int IndexOf(T value);
    [ExcludeFromCodeCoverageAttribute]
private sealed virtual override IImmutableList`1<T> System.Collections.Immutable.IImmutableList<T>.Add(T value);
    [ExcludeFromCodeCoverageAttribute]
private sealed virtual override IImmutableList`1<T> System.Collections.Immutable.IImmutableList<T>.AddRange(IEnumerable`1<T> items);
    [ExcludeFromCodeCoverageAttribute]
private sealed virtual override IImmutableList`1<T> System.Collections.Immutable.IImmutableList<T>.Insert(int index, T item);
    [ExcludeFromCodeCoverageAttribute]
private sealed virtual override IImmutableList`1<T> System.Collections.Immutable.IImmutableList<T>.InsertRange(int index, IEnumerable`1<T> items);
    [ExcludeFromCodeCoverageAttribute]
private sealed virtual override IImmutableList`1<T> System.Collections.Immutable.IImmutableList<T>.Remove(T value, IEqualityComparer`1<T> equalityComparer);
    [ExcludeFromCodeCoverageAttribute]
private sealed virtual override IImmutableList`1<T> System.Collections.Immutable.IImmutableList<T>.RemoveAll(Predicate`1<T> match);
    [ExcludeFromCodeCoverageAttribute]
private sealed virtual override IImmutableList`1<T> System.Collections.Immutable.IImmutableList<T>.RemoveRange(IEnumerable`1<T> items, IEqualityComparer`1<T> equalityComparer);
    [ExcludeFromCodeCoverageAttribute]
private sealed virtual override IImmutableList`1<T> System.Collections.Immutable.IImmutableList<T>.RemoveRange(int index, int count);
    [ExcludeFromCodeCoverageAttribute]
private sealed virtual override IImmutableList`1<T> System.Collections.Immutable.IImmutableList<T>.RemoveAt(int index);
    [ExcludeFromCodeCoverageAttribute]
private sealed virtual override IImmutableList`1<T> System.Collections.Immutable.IImmutableList<T>.SetItem(int index, T value);
    private sealed virtual override IImmutableList`1<T> System.Collections.Immutable.IImmutableList<T>.Replace(T oldValue, T newValue, IEqualityComparer`1<T> equalityComparer);
    private sealed virtual override IEnumerator`1<T> System.Collections.Generic.IEnumerable<T>.GetEnumerator();
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
    private sealed virtual override void System.Collections.Generic.IList<T>.Insert(int index, T item);
    private sealed virtual override void System.Collections.Generic.IList<T>.RemoveAt(int index);
    private sealed virtual override T System.Collections.Generic.IList<T>.get_Item(int index);
    private sealed virtual override void System.Collections.Generic.IList<T>.set_Item(int index, T value);
    private sealed virtual override void System.Collections.Generic.ICollection<T>.Add(T item);
    private sealed virtual override void System.Collections.Generic.ICollection<T>.Clear();
    private sealed virtual override bool System.Collections.Generic.ICollection<T>.get_IsReadOnly();
    private sealed virtual override bool System.Collections.Generic.ICollection<T>.Remove(T item);
    private sealed virtual override void System.Collections.ICollection.CopyTo(Array array, int arrayIndex);
    private sealed virtual override int System.Collections.IList.Add(object value);
    private sealed virtual override void System.Collections.IList.RemoveAt(int index);
    private sealed virtual override void System.Collections.IList.Clear();
    private sealed virtual override bool System.Collections.IList.Contains(object value);
    private sealed virtual override int System.Collections.IList.IndexOf(object value);
    private sealed virtual override void System.Collections.IList.Insert(int index, object value);
    private sealed virtual override bool System.Collections.IList.get_IsFixedSize();
    private sealed virtual override bool System.Collections.IList.get_IsReadOnly();
    private sealed virtual override void System.Collections.IList.Remove(object value);
    private sealed virtual override object System.Collections.IList.get_Item(int index);
    private sealed virtual override void System.Collections.IList.set_Item(int index, object value);
    public sealed virtual Enumerator<T> GetEnumerator();
    internal Node<T> get_Root();
    private static ImmutableList`1<T> WrapNode(Node<T> root);
    private static bool TryCastToImmutableList(IEnumerable`1<T> sequence, ImmutableList`1& other);
    private static bool IsCompatibleObject(object value);
    private ImmutableList`1<T> Wrap(Node<T> root);
    private static ImmutableList`1<T> CreateRange(IEnumerable`1<T> items);
}
internal class System.Collections.Immutable.ImmutableListBuilderDebuggerProxy`1 : object {
    private Builder<T> _list;
    private T[] _cachedContents;
    [DebuggerBrowsableAttribute("3")]
public T[] Contents { get; }
    public ImmutableListBuilderDebuggerProxy`1(Builder<T> builder);
    public T[] get_Contents();
}
internal class System.Collections.Immutable.ImmutableListDebuggerProxy`1 : object {
    private ImmutableList`1<T> _list;
    private T[] _cachedContents;
    [DebuggerBrowsableAttribute("3")]
public T[] Contents { get; }
    public ImmutableListDebuggerProxy`1(ImmutableList`1<T> list);
    public T[] get_Contents();
}
[ExtensionAttribute]
public static class System.Collections.Immutable.ImmutableQueue : object {
    public static ImmutableQueue`1<T> Create();
    public static ImmutableQueue`1<T> Create(T item);
    public static ImmutableQueue`1<T> CreateRange(IEnumerable`1<T> items);
    public static ImmutableQueue`1<T> Create(T[] items);
    [ExtensionAttribute]
public static IImmutableQueue`1<T> Dequeue(IImmutableQueue`1<T> queue, T& value);
}
[DebuggerDisplayAttribute("IsEmpty = {IsEmpty}")]
[DebuggerTypeProxyAttribute("System.Collections.Immutable.ImmutableEnumerableDebuggerProxy`1")]
public class System.Collections.Immutable.ImmutableQueue`1 : object {
    private static ImmutableQueue`1<T> s_EmptyField;
    private ImmutableStack`1<T> _backwards;
    private ImmutableStack`1<T> _forwards;
    private ImmutableStack`1<T> _backwardsReversed;
    public bool IsEmpty { get; }
    public static ImmutableQueue`1<T> Empty { get; }
    private ImmutableStack`1<T> BackwardsReversed { get; }
    internal ImmutableQueue`1(ImmutableStack`1<T> forwards, ImmutableStack`1<T> backwards);
    private static ImmutableQueue`1();
    public ImmutableQueue`1<T> Clear();
    public sealed virtual bool get_IsEmpty();
    public static ImmutableQueue`1<T> get_Empty();
    private sealed virtual override IImmutableQueue`1<T> System.Collections.Immutable.IImmutableQueue<T>.Clear();
    private ImmutableStack`1<T> get_BackwardsReversed();
    public sealed virtual T Peek();
    public ImmutableQueue`1<T> Enqueue(T value);
    private sealed virtual override IImmutableQueue`1<T> System.Collections.Immutable.IImmutableQueue<T>.Enqueue(T value);
    public ImmutableQueue`1<T> Dequeue();
    public ImmutableQueue`1<T> Dequeue(T& value);
    private sealed virtual override IImmutableQueue`1<T> System.Collections.Immutable.IImmutableQueue<T>.Dequeue();
    public Enumerator<T> GetEnumerator();
    private sealed virtual override IEnumerator`1<T> System.Collections.Generic.IEnumerable<T>.GetEnumerator();
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
}
[ExtensionAttribute]
public static class System.Collections.Immutable.ImmutableSortedDictionary : object {
    public static ImmutableSortedDictionary`2<TKey, TValue> Create();
    public static ImmutableSortedDictionary`2<TKey, TValue> Create(IComparer`1<TKey> keyComparer);
    public static ImmutableSortedDictionary`2<TKey, TValue> Create(IComparer`1<TKey> keyComparer, IEqualityComparer`1<TValue> valueComparer);
    public static ImmutableSortedDictionary`2<TKey, TValue> CreateRange(IEnumerable`1<KeyValuePair`2<TKey, TValue>> items);
    public static ImmutableSortedDictionary`2<TKey, TValue> CreateRange(IComparer`1<TKey> keyComparer, IEnumerable`1<KeyValuePair`2<TKey, TValue>> items);
    public static ImmutableSortedDictionary`2<TKey, TValue> CreateRange(IComparer`1<TKey> keyComparer, IEqualityComparer`1<TValue> valueComparer, IEnumerable`1<KeyValuePair`2<TKey, TValue>> items);
    public static Builder<TKey, TValue> CreateBuilder();
    public static Builder<TKey, TValue> CreateBuilder(IComparer`1<TKey> keyComparer);
    public static Builder<TKey, TValue> CreateBuilder(IComparer`1<TKey> keyComparer, IEqualityComparer`1<TValue> valueComparer);
    [ExtensionAttribute]
public static ImmutableSortedDictionary`2<TKey, TValue> ToImmutableSortedDictionary(IEnumerable`1<TSource> source, Func`2<TSource, TKey> keySelector, Func`2<TSource, TValue> elementSelector, IComparer`1<TKey> keyComparer, IEqualityComparer`1<TValue> valueComparer);
    [ExtensionAttribute]
public static ImmutableSortedDictionary`2<TKey, TValue> ToImmutableSortedDictionary(IEnumerable`1<TSource> source, Func`2<TSource, TKey> keySelector, Func`2<TSource, TValue> elementSelector, IComparer`1<TKey> keyComparer);
    [ExtensionAttribute]
public static ImmutableSortedDictionary`2<TKey, TValue> ToImmutableSortedDictionary(IEnumerable`1<TSource> source, Func`2<TSource, TKey> keySelector, Func`2<TSource, TValue> elementSelector);
    [ExtensionAttribute]
public static ImmutableSortedDictionary`2<TKey, TValue> ToImmutableSortedDictionary(IEnumerable`1<KeyValuePair`2<TKey, TValue>> source, IComparer`1<TKey> keyComparer, IEqualityComparer`1<TValue> valueComparer);
    [ExtensionAttribute]
public static ImmutableSortedDictionary`2<TKey, TValue> ToImmutableSortedDictionary(IEnumerable`1<KeyValuePair`2<TKey, TValue>> source, IComparer`1<TKey> keyComparer);
    [ExtensionAttribute]
public static ImmutableSortedDictionary`2<TKey, TValue> ToImmutableSortedDictionary(IEnumerable`1<KeyValuePair`2<TKey, TValue>> source);
}
[DefaultMemberAttribute("Item")]
[DebuggerDisplayAttribute("Count = {Count}")]
[DebuggerTypeProxyAttribute("System.Collections.Immutable.ImmutableDictionaryDebuggerProxy`2")]
public class System.Collections.Immutable.ImmutableSortedDictionary`2 : object {
    public static ImmutableSortedDictionary`2<TKey, TValue> Empty;
    private Node<TKey, TValue> _root;
    private int _count;
    private IComparer`1<TKey> _keyComparer;
    private IEqualityComparer`1<TValue> _valueComparer;
    public IEqualityComparer`1<TValue> ValueComparer { get; }
    public bool IsEmpty { get; }
    public int Count { get; }
    public IEnumerable`1<TKey> Keys { get; }
    public IEnumerable`1<TValue> Values { get; }
    private ICollection`1<TKey> System.Collections.Generic.IDictionary<TKey,TValue>.Keys { get; }
    private ICollection`1<TValue> System.Collections.Generic.IDictionary<TKey,TValue>.Values { get; }
    private bool System.Collections.Generic.ICollection<System.Collections.Generic.KeyValuePair<TKey,TValue>>.IsReadOnly { get; }
    public IComparer`1<TKey> KeyComparer { get; }
    internal Node<TKey, TValue> Root { get; }
    public TValue Item { get; }
    private TValue System.Collections.Generic.IDictionary<TKey,TValue>.Item { get; private set; }
    private bool System.Collections.IDictionary.IsFixedSize { get; }
    private bool System.Collections.IDictionary.IsReadOnly { get; }
    private ICollection System.Collections.IDictionary.Keys { get; }
    private ICollection System.Collections.IDictionary.Values { get; }
    private object System.Collections.IDictionary.Item { get; private set; }
    [DebuggerBrowsableAttribute("0")]
private object System.Collections.ICollection.SyncRoot { get; }
    [DebuggerBrowsableAttribute("0")]
private bool System.Collections.ICollection.IsSynchronized { get; }
    internal ImmutableSortedDictionary`2(IComparer`1<TKey> keyComparer, IEqualityComparer`1<TValue> valueComparer);
    private ImmutableSortedDictionary`2(Node<TKey, TValue> root, int count, IComparer`1<TKey> keyComparer, IEqualityComparer`1<TValue> valueComparer);
    private static ImmutableSortedDictionary`2();
    public ImmutableSortedDictionary`2<TKey, TValue> Clear();
    public IEqualityComparer`1<TValue> get_ValueComparer();
    public bool get_IsEmpty();
    public sealed virtual int get_Count();
    public sealed virtual IEnumerable`1<TKey> get_Keys();
    public sealed virtual IEnumerable`1<TValue> get_Values();
    private sealed virtual override IImmutableDictionary`2<TKey, TValue> System.Collections.Immutable.IImmutableDictionary<TKey,TValue>.Clear();
    private sealed virtual override ICollection`1<TKey> System.Collections.Generic.IDictionary<TKey,TValue>.get_Keys();
    private sealed virtual override ICollection`1<TValue> System.Collections.Generic.IDictionary<TKey,TValue>.get_Values();
    private sealed virtual override bool System.Collections.Generic.ICollection<System.Collections.Generic.KeyValuePair<TKey,TValue>>.get_IsReadOnly();
    public sealed virtual IComparer`1<TKey> get_KeyComparer();
    internal Node<TKey, TValue> get_Root();
    public sealed virtual TValue get_Item(TKey key);
    private sealed virtual override TValue System.Collections.Generic.IDictionary<TKey,TValue>.get_Item(TKey key);
    private sealed virtual override void System.Collections.Generic.IDictionary<TKey,TValue>.set_Item(TKey key, TValue value);
    public Builder<TKey, TValue> ToBuilder();
    public ImmutableSortedDictionary`2<TKey, TValue> Add(TKey key, TValue value);
    public ImmutableSortedDictionary`2<TKey, TValue> SetItem(TKey key, TValue value);
    public ImmutableSortedDictionary`2<TKey, TValue> SetItems(IEnumerable`1<KeyValuePair`2<TKey, TValue>> items);
    public ImmutableSortedDictionary`2<TKey, TValue> AddRange(IEnumerable`1<KeyValuePair`2<TKey, TValue>> items);
    public ImmutableSortedDictionary`2<TKey, TValue> Remove(TKey value);
    public ImmutableSortedDictionary`2<TKey, TValue> RemoveRange(IEnumerable`1<TKey> keys);
    public ImmutableSortedDictionary`2<TKey, TValue> WithComparers(IComparer`1<TKey> keyComparer, IEqualityComparer`1<TValue> valueComparer);
    public ImmutableSortedDictionary`2<TKey, TValue> WithComparers(IComparer`1<TKey> keyComparer);
    public bool ContainsValue(TValue value);
    [ExcludeFromCodeCoverageAttribute]
private sealed virtual override IImmutableDictionary`2<TKey, TValue> System.Collections.Immutable.IImmutableDictionary<TKey,TValue>.Add(TKey key, TValue value);
    [ExcludeFromCodeCoverageAttribute]
private sealed virtual override IImmutableDictionary`2<TKey, TValue> System.Collections.Immutable.IImmutableDictionary<TKey,TValue>.SetItem(TKey key, TValue value);
    private sealed virtual override IImmutableDictionary`2<TKey, TValue> System.Collections.Immutable.IImmutableDictionary<TKey,TValue>.SetItems(IEnumerable`1<KeyValuePair`2<TKey, TValue>> items);
    [ExcludeFromCodeCoverageAttribute]
private sealed virtual override IImmutableDictionary`2<TKey, TValue> System.Collections.Immutable.IImmutableDictionary<TKey,TValue>.AddRange(IEnumerable`1<KeyValuePair`2<TKey, TValue>> pairs);
    [ExcludeFromCodeCoverageAttribute]
private sealed virtual override IImmutableDictionary`2<TKey, TValue> System.Collections.Immutable.IImmutableDictionary<TKey,TValue>.RemoveRange(IEnumerable`1<TKey> keys);
    [ExcludeFromCodeCoverageAttribute]
private sealed virtual override IImmutableDictionary`2<TKey, TValue> System.Collections.Immutable.IImmutableDictionary<TKey,TValue>.Remove(TKey key);
    public sealed virtual bool ContainsKey(TKey key);
    public sealed virtual bool Contains(KeyValuePair`2<TKey, TValue> pair);
    public sealed virtual bool TryGetValue(TKey key, TValue& value);
    public sealed virtual bool TryGetKey(TKey equalKey, TKey& actualKey);
    private sealed virtual override void System.Collections.Generic.IDictionary<TKey,TValue>.Add(TKey key, TValue value);
    private sealed virtual override bool System.Collections.Generic.IDictionary<TKey,TValue>.Remove(TKey key);
    private sealed virtual override void System.Collections.Generic.ICollection<System.Collections.Generic.KeyValuePair<TKey,TValue>>.Add(KeyValuePair`2<TKey, TValue> item);
    private sealed virtual override void System.Collections.Generic.ICollection<System.Collections.Generic.KeyValuePair<TKey,TValue>>.Clear();
    private sealed virtual override bool System.Collections.Generic.ICollection<System.Collections.Generic.KeyValuePair<TKey,TValue>>.Remove(KeyValuePair`2<TKey, TValue> item);
    private sealed virtual override void System.Collections.Generic.ICollection<System.Collections.Generic.KeyValuePair<TKey,TValue>>.CopyTo(KeyValuePair`2[] array, int arrayIndex);
    private sealed virtual override bool System.Collections.IDictionary.get_IsFixedSize();
    private sealed virtual override bool System.Collections.IDictionary.get_IsReadOnly();
    private sealed virtual override ICollection System.Collections.IDictionary.get_Keys();
    private sealed virtual override ICollection System.Collections.IDictionary.get_Values();
    private sealed virtual override void System.Collections.IDictionary.Add(object key, object value);
    private sealed virtual override bool System.Collections.IDictionary.Contains(object key);
    private sealed virtual override IDictionaryEnumerator System.Collections.IDictionary.GetEnumerator();
    private sealed virtual override void System.Collections.IDictionary.Remove(object key);
    private sealed virtual override object System.Collections.IDictionary.get_Item(object key);
    private sealed virtual override void System.Collections.IDictionary.set_Item(object key, object value);
    private sealed virtual override void System.Collections.IDictionary.Clear();
    private sealed virtual override void System.Collections.ICollection.CopyTo(Array array, int index);
    private sealed virtual override object System.Collections.ICollection.get_SyncRoot();
    private sealed virtual override bool System.Collections.ICollection.get_IsSynchronized();
    [ExcludeFromCodeCoverageAttribute]
private sealed virtual override IEnumerator`1<KeyValuePair`2<TKey, TValue>> System.Collections.Generic.IEnumerable<System.Collections.Generic.KeyValuePair<TKey,TValue>>.GetEnumerator();
    [ExcludeFromCodeCoverageAttribute]
private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
    public Enumerator<TKey, TValue> GetEnumerator();
    private static ImmutableSortedDictionary`2<TKey, TValue> Wrap(Node<TKey, TValue> root, int count, IComparer`1<TKey> keyComparer, IEqualityComparer`1<TValue> valueComparer);
    private static bool TryCastToImmutableMap(IEnumerable`1<KeyValuePair`2<TKey, TValue>> sequence, ImmutableSortedDictionary`2& other);
    private ImmutableSortedDictionary`2<TKey, TValue> AddRange(IEnumerable`1<KeyValuePair`2<TKey, TValue>> items, bool overwriteOnCollision, bool avoidToSortedMap);
    private ImmutableSortedDictionary`2<TKey, TValue> Wrap(Node<TKey, TValue> root, int adjustedCountIfDifferentRoot);
    private ImmutableSortedDictionary`2<TKey, TValue> FillFromEmpty(IEnumerable`1<KeyValuePair`2<TKey, TValue>> items, bool overwriteOnCollision);
}
internal class System.Collections.Immutable.ImmutableSortedDictionaryBuilderDebuggerProxy`2 : object {
    private Builder<TKey, TValue> _map;
    private KeyValuePair`2[] _contents;
    [DebuggerBrowsableAttribute("3")]
public KeyValuePair`2[] Contents { get; }
    public ImmutableSortedDictionaryBuilderDebuggerProxy`2(Builder<TKey, TValue> map);
    public KeyValuePair`2[] get_Contents();
}
[ExtensionAttribute]
public static class System.Collections.Immutable.ImmutableSortedSet : object {
    public static ImmutableSortedSet`1<T> Create();
    public static ImmutableSortedSet`1<T> Create(IComparer`1<T> comparer);
    public static ImmutableSortedSet`1<T> Create(T item);
    public static ImmutableSortedSet`1<T> Create(IComparer`1<T> comparer, T item);
    public static ImmutableSortedSet`1<T> CreateRange(IEnumerable`1<T> items);
    public static ImmutableSortedSet`1<T> CreateRange(IComparer`1<T> comparer, IEnumerable`1<T> items);
    public static ImmutableSortedSet`1<T> Create(T[] items);
    public static ImmutableSortedSet`1<T> Create(IComparer`1<T> comparer, T[] items);
    public static Builder<T> CreateBuilder();
    public static Builder<T> CreateBuilder(IComparer`1<T> comparer);
    [ExtensionAttribute]
public static ImmutableSortedSet`1<TSource> ToImmutableSortedSet(IEnumerable`1<TSource> source, IComparer`1<TSource> comparer);
    [ExtensionAttribute]
public static ImmutableSortedSet`1<TSource> ToImmutableSortedSet(IEnumerable`1<TSource> source);
}
[DefaultMemberAttribute("Item")]
[DebuggerDisplayAttribute("Count = {Count}")]
[DebuggerTypeProxyAttribute("System.Collections.Immutable.ImmutableEnumerableDebuggerProxy`1")]
public class System.Collections.Immutable.ImmutableSortedSet`1 : object {
    private static float RefillOverIncrementalThreshold;
    public static ImmutableSortedSet`1<T> Empty;
    private Node<T> _root;
    private IComparer`1<T> _comparer;
    public T Max { get; }
    public T Min { get; }
    public bool IsEmpty { get; }
    public int Count { get; }
    public IComparer`1<T> KeyComparer { get; }
    internal IBinaryTree Root { get; }
    public T Item { get; }
    private bool System.Collections.Generic.ICollection<T>.IsReadOnly { get; }
    private T System.Collections.Generic.IList<T>.Item { get; private set; }
    private bool System.Collections.IList.IsFixedSize { get; }
    private bool System.Collections.IList.IsReadOnly { get; }
    [DebuggerBrowsableAttribute("0")]
private object System.Collections.ICollection.SyncRoot { get; }
    [DebuggerBrowsableAttribute("0")]
private bool System.Collections.ICollection.IsSynchronized { get; }
    private object System.Collections.IList.Item { get; private set; }
    internal ImmutableSortedSet`1(IComparer`1<T> comparer);
    private ImmutableSortedSet`1(Node<T> root, IComparer`1<T> comparer);
    private static ImmutableSortedSet`1();
    public ImmutableSortedSet`1<T> Clear();
    public T get_Max();
    public T get_Min();
    public bool get_IsEmpty();
    public sealed virtual int get_Count();
    public sealed virtual IComparer`1<T> get_KeyComparer();
    internal IBinaryTree get_Root();
    public sealed virtual T get_Item(int index);
    public Builder<T> ToBuilder();
    public ImmutableSortedSet`1<T> Add(T value);
    public ImmutableSortedSet`1<T> Remove(T value);
    public sealed virtual bool TryGetValue(T equalValue, T& actualValue);
    public ImmutableSortedSet`1<T> Intersect(IEnumerable`1<T> other);
    public ImmutableSortedSet`1<T> Except(IEnumerable`1<T> other);
    public ImmutableSortedSet`1<T> SymmetricExcept(IEnumerable`1<T> other);
    public ImmutableSortedSet`1<T> Union(IEnumerable`1<T> other);
    public ImmutableSortedSet`1<T> WithComparer(IComparer`1<T> comparer);
    public sealed virtual bool SetEquals(IEnumerable`1<T> other);
    public sealed virtual bool IsProperSubsetOf(IEnumerable`1<T> other);
    public sealed virtual bool IsProperSupersetOf(IEnumerable`1<T> other);
    public sealed virtual bool IsSubsetOf(IEnumerable`1<T> other);
    public sealed virtual bool IsSupersetOf(IEnumerable`1<T> other);
    public sealed virtual bool Overlaps(IEnumerable`1<T> other);
    public IEnumerable`1<T> Reverse();
    public sealed virtual int IndexOf(T item);
    public sealed virtual bool Contains(T value);
    [ExcludeFromCodeCoverageAttribute]
private sealed virtual override IImmutableSet`1<T> System.Collections.Immutable.IImmutableSet<T>.Clear();
    [ExcludeFromCodeCoverageAttribute]
private sealed virtual override IImmutableSet`1<T> System.Collections.Immutable.IImmutableSet<T>.Add(T value);
    [ExcludeFromCodeCoverageAttribute]
private sealed virtual override IImmutableSet`1<T> System.Collections.Immutable.IImmutableSet<T>.Remove(T value);
    [ExcludeFromCodeCoverageAttribute]
private sealed virtual override IImmutableSet`1<T> System.Collections.Immutable.IImmutableSet<T>.Intersect(IEnumerable`1<T> other);
    [ExcludeFromCodeCoverageAttribute]
private sealed virtual override IImmutableSet`1<T> System.Collections.Immutable.IImmutableSet<T>.Except(IEnumerable`1<T> other);
    [ExcludeFromCodeCoverageAttribute]
private sealed virtual override IImmutableSet`1<T> System.Collections.Immutable.IImmutableSet<T>.SymmetricExcept(IEnumerable`1<T> other);
    [ExcludeFromCodeCoverageAttribute]
private sealed virtual override IImmutableSet`1<T> System.Collections.Immutable.IImmutableSet<T>.Union(IEnumerable`1<T> other);
    private sealed virtual override bool System.Collections.Generic.ISet<T>.Add(T item);
    private sealed virtual override void System.Collections.Generic.ISet<T>.ExceptWith(IEnumerable`1<T> other);
    private sealed virtual override void System.Collections.Generic.ISet<T>.IntersectWith(IEnumerable`1<T> other);
    private sealed virtual override void System.Collections.Generic.ISet<T>.SymmetricExceptWith(IEnumerable`1<T> other);
    private sealed virtual override void System.Collections.Generic.ISet<T>.UnionWith(IEnumerable`1<T> other);
    private sealed virtual override bool System.Collections.Generic.ICollection<T>.get_IsReadOnly();
    private sealed virtual override void System.Collections.Generic.ICollection<T>.CopyTo(T[] array, int arrayIndex);
    private sealed virtual override void System.Collections.Generic.ICollection<T>.Add(T item);
    private sealed virtual override void System.Collections.Generic.ICollection<T>.Clear();
    private sealed virtual override bool System.Collections.Generic.ICollection<T>.Remove(T item);
    private sealed virtual override T System.Collections.Generic.IList<T>.get_Item(int index);
    private sealed virtual override void System.Collections.Generic.IList<T>.set_Item(int index, T value);
    private sealed virtual override void System.Collections.Generic.IList<T>.Insert(int index, T item);
    private sealed virtual override void System.Collections.Generic.IList<T>.RemoveAt(int index);
    private sealed virtual override bool System.Collections.IList.get_IsFixedSize();
    private sealed virtual override bool System.Collections.IList.get_IsReadOnly();
    private sealed virtual override object System.Collections.ICollection.get_SyncRoot();
    private sealed virtual override bool System.Collections.ICollection.get_IsSynchronized();
    private sealed virtual override int System.Collections.IList.Add(object value);
    private sealed virtual override void System.Collections.IList.Clear();
    private sealed virtual override bool System.Collections.IList.Contains(object value);
    private sealed virtual override int System.Collections.IList.IndexOf(object value);
    private sealed virtual override void System.Collections.IList.Insert(int index, object value);
    private sealed virtual override void System.Collections.IList.Remove(object value);
    private sealed virtual override void System.Collections.IList.RemoveAt(int index);
    private sealed virtual override object System.Collections.IList.get_Item(int index);
    private sealed virtual override void System.Collections.IList.set_Item(int index, object value);
    private sealed virtual override void System.Collections.ICollection.CopyTo(Array array, int index);
    [ExcludeFromCodeCoverageAttribute]
private sealed virtual override IEnumerator`1<T> System.Collections.Generic.IEnumerable<T>.GetEnumerator();
    [ExcludeFromCodeCoverageAttribute]
private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
    public sealed virtual Enumerator<T> GetEnumerator();
    private static bool TryCastToImmutableSortedSet(IEnumerable`1<T> sequence, ImmutableSortedSet`1& other);
    private static ImmutableSortedSet`1<T> Wrap(Node<T> root, IComparer`1<T> comparer);
    private ImmutableSortedSet`1<T> UnionIncremental(IEnumerable`1<T> items);
    private ImmutableSortedSet`1<T> Wrap(Node<T> root);
    private ImmutableSortedSet`1<T> LeafToRootRefill(IEnumerable`1<T> addedItems);
}
internal class System.Collections.Immutable.ImmutableSortedSetBuilderDebuggerProxy`1 : object {
    private Builder<T> _set;
    private T[] _contents;
    [DebuggerBrowsableAttribute("3")]
public T[] Contents { get; }
    public ImmutableSortedSetBuilderDebuggerProxy`1(Builder<T> builder);
    public T[] get_Contents();
}
[ExtensionAttribute]
public static class System.Collections.Immutable.ImmutableStack : object {
    public static ImmutableStack`1<T> Create();
    public static ImmutableStack`1<T> Create(T item);
    public static ImmutableStack`1<T> CreateRange(IEnumerable`1<T> items);
    public static ImmutableStack`1<T> Create(T[] items);
    [ExtensionAttribute]
public static IImmutableStack`1<T> Pop(IImmutableStack`1<T> stack, T& value);
}
[DebuggerDisplayAttribute("IsEmpty = {IsEmpty}; Top = {_head}")]
[DebuggerTypeProxyAttribute("System.Collections.Immutable.ImmutableEnumerableDebuggerProxy`1")]
public class System.Collections.Immutable.ImmutableStack`1 : object {
    private static ImmutableStack`1<T> s_EmptyField;
    private T _head;
    private ImmutableStack`1<T> _tail;
    public static ImmutableStack`1<T> Empty { get; }
    public bool IsEmpty { get; }
    private ImmutableStack`1(T head, ImmutableStack`1<T> tail);
    private static ImmutableStack`1();
    public static ImmutableStack`1<T> get_Empty();
    public ImmutableStack`1<T> Clear();
    private sealed virtual override IImmutableStack`1<T> System.Collections.Immutable.IImmutableStack<T>.Clear();
    public sealed virtual bool get_IsEmpty();
    public sealed virtual T Peek();
    public ImmutableStack`1<T> Push(T value);
    private sealed virtual override IImmutableStack`1<T> System.Collections.Immutable.IImmutableStack<T>.Push(T value);
    public ImmutableStack`1<T> Pop();
    public ImmutableStack`1<T> Pop(T& value);
    private sealed virtual override IImmutableStack`1<T> System.Collections.Immutable.IImmutableStack<T>.Pop();
    public Enumerator<T> GetEnumerator();
    private sealed virtual override IEnumerator`1<T> System.Collections.Generic.IEnumerable<T>.GetEnumerator();
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
    internal ImmutableStack`1<T> Reverse();
}
[DefaultMemberAttribute("Item")]
internal interface System.Collections.Immutable.IOrderedCollection`1 {
    public int Count { get; }
    public T Item { get; }
    public abstract virtual int get_Count();
    public abstract virtual T get_Item(int index);
}
internal interface System.Collections.Immutable.ISecurePooledObjectUser {
    public int PoolUserId { get; }
    public abstract virtual int get_PoolUserId();
}
internal interface System.Collections.Immutable.IStrongEnumerable`2 {
    public abstract virtual TEnumerator GetEnumerator();
}
internal interface System.Collections.Immutable.IStrongEnumerator`1 {
    public T Current { get; }
    public abstract virtual T get_Current();
    public abstract virtual bool MoveNext();
}
internal class System.Collections.Immutable.KeysCollectionAccessor`2 : KeysOrValuesCollectionAccessor`3<TKey, TValue, TKey> {
    internal KeysCollectionAccessor`2(IImmutableDictionary`2<TKey, TValue> dictionary);
    public virtual bool Contains(TKey item);
}
internal abstract class System.Collections.Immutable.KeysOrValuesCollectionAccessor`3 : object {
    private IImmutableDictionary`2<TKey, TValue> _dictionary;
    private IEnumerable`1<T> _keysOrValues;
    public bool IsReadOnly { get; }
    public int Count { get; }
    protected IImmutableDictionary`2<TKey, TValue> Dictionary { get; }
    [DebuggerBrowsableAttribute("0")]
private bool System.Collections.ICollection.IsSynchronized { get; }
    [DebuggerBrowsableAttribute("0")]
private object System.Collections.ICollection.SyncRoot { get; }
    protected KeysOrValuesCollectionAccessor`3(IImmutableDictionary`2<TKey, TValue> dictionary, IEnumerable`1<T> keysOrValues);
    public sealed virtual bool get_IsReadOnly();
    public sealed virtual int get_Count();
    protected IImmutableDictionary`2<TKey, TValue> get_Dictionary();
    public sealed virtual void Add(T item);
    public sealed virtual void Clear();
    public abstract virtual bool Contains(T item);
    public sealed virtual void CopyTo(T[] array, int arrayIndex);
    public sealed virtual bool Remove(T item);
    public sealed virtual IEnumerator`1<T> GetEnumerator();
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
    private sealed virtual override void System.Collections.ICollection.CopyTo(Array array, int arrayIndex);
    private sealed virtual override bool System.Collections.ICollection.get_IsSynchronized();
    private sealed virtual override object System.Collections.ICollection.get_SyncRoot();
}
[DebuggerDisplayAttribute("{Value,nq}")]
internal class System.Collections.Immutable.RefAsValueType`1 : ValueType {
    internal T Value;
    internal RefAsValueType`1(T value);
}
internal static class System.Collections.Immutable.Requires : object {
    [DebuggerStepThroughAttribute]
public static void NotNull(T value, string parameterName);
    [DebuggerStepThroughAttribute]
public static T NotNullPassthrough(T value, string parameterName);
    [DebuggerStepThroughAttribute]
public static void NotNullAllowStructs(T value, string parameterName);
    [DebuggerStepThroughAttribute]
private static void FailArgumentNullException(string parameterName);
    [DebuggerStepThroughAttribute]
public static void Range(bool condition, string parameterName, string message);
    [DebuggerStepThroughAttribute]
public static void FailRange(string parameterName, string message);
    [DebuggerStepThroughAttribute]
public static void Argument(bool condition, string parameterName, string message);
    [DebuggerStepThroughAttribute]
public static void Argument(bool condition);
    [DebuggerStepThroughAttribute]
public static void FailObjectDisposed(TDisposed disposed);
}
internal class System.Collections.Immutable.SecureObjectPool : object {
    private static int s_poolUserIdCounter;
    internal static int UnassignedId;
    internal static int NewId();
}
internal class System.Collections.Immutable.SecureObjectPool`2 : object {
    public void TryAdd(TCaller caller, SecurePooledObject`1<T> item);
    public bool TryTake(TCaller caller, SecurePooledObject`1& item);
    public SecurePooledObject`1<T> PrepNew(TCaller caller, T newValue);
}
internal class System.Collections.Immutable.SecurePooledObject`1 : object {
    private T _value;
    private int _owner;
    internal int Owner { get; internal set; }
    internal SecurePooledObject`1(T newValue);
    internal int get_Owner();
    internal void set_Owner(int value);
    internal T Use(TCaller& caller);
    internal bool TryUse(TCaller& caller, T& value);
    internal bool IsOwned(TCaller& caller);
}
[DebuggerDisplayAttribute("{_key} = {_value}")]
internal class System.Collections.Immutable.SortedInt32KeyNode`1 : object {
    internal static SortedInt32KeyNode`1<TValue> EmptyNode;
    private int _key;
    private TValue _value;
    private bool _frozen;
    private byte _height;
    private SortedInt32KeyNode`1<TValue> _left;
    private SortedInt32KeyNode`1<TValue> _right;
    public bool IsEmpty { get; }
    public int Height { get; }
    public SortedInt32KeyNode`1<TValue> Left { get; }
    public SortedInt32KeyNode`1<TValue> Right { get; }
    private IBinaryTree System.Collections.Immutable.IBinaryTree.Left { get; }
    private IBinaryTree System.Collections.Immutable.IBinaryTree.Right { get; }
    private int System.Collections.Immutable.IBinaryTree.Count { get; }
    public KeyValuePair`2<int, TValue> Value { get; }
    internal IEnumerable`1<TValue> Values { get; }
    private SortedInt32KeyNode`1(int key, TValue value, SortedInt32KeyNode`1<TValue> left, SortedInt32KeyNode`1<TValue> right, bool frozen);
    private static SortedInt32KeyNode`1();
    public sealed virtual bool get_IsEmpty();
    public sealed virtual int get_Height();
    public SortedInt32KeyNode`1<TValue> get_Left();
    public SortedInt32KeyNode`1<TValue> get_Right();
    private sealed virtual override IBinaryTree System.Collections.Immutable.IBinaryTree.get_Left();
    private sealed virtual override IBinaryTree System.Collections.Immutable.IBinaryTree.get_Right();
    private sealed virtual override int System.Collections.Immutable.IBinaryTree.get_Count();
    public KeyValuePair`2<int, TValue> get_Value();
    [IteratorStateMachineAttribute("System.Collections.Immutable.SortedInt32KeyNode`1/<get_Values>d__26")]
internal IEnumerable`1<TValue> get_Values();
    public Enumerator<TValue> GetEnumerator();
    internal SortedInt32KeyNode`1<TValue> SetItem(int key, TValue value, IEqualityComparer`1<TValue> valueComparer, Boolean& replacedExistingValue, Boolean& mutated);
    internal SortedInt32KeyNode`1<TValue> Remove(int key, Boolean& mutated);
    internal TValue GetValueOrDefault(int key);
    internal bool TryGetValue(int key, TValue& value);
    internal void Freeze(Action`1<KeyValuePair`2<int, TValue>> freezeAction);
    private static SortedInt32KeyNode`1<TValue> RotateLeft(SortedInt32KeyNode`1<TValue> tree);
    private static SortedInt32KeyNode`1<TValue> RotateRight(SortedInt32KeyNode`1<TValue> tree);
    private static SortedInt32KeyNode`1<TValue> DoubleLeft(SortedInt32KeyNode`1<TValue> tree);
    private static SortedInt32KeyNode`1<TValue> DoubleRight(SortedInt32KeyNode`1<TValue> tree);
    private static int Balance(SortedInt32KeyNode`1<TValue> tree);
    private static bool IsRightHeavy(SortedInt32KeyNode`1<TValue> tree);
    private static bool IsLeftHeavy(SortedInt32KeyNode`1<TValue> tree);
    private static SortedInt32KeyNode`1<TValue> MakeBalanced(SortedInt32KeyNode`1<TValue> tree);
    private SortedInt32KeyNode`1<TValue> SetOrAdd(int key, TValue value, IEqualityComparer`1<TValue> valueComparer, bool overwriteExistingValue, Boolean& replacedExistingValue, Boolean& mutated);
    private SortedInt32KeyNode`1<TValue> RemoveRecursive(int key, Boolean& mutated);
    private SortedInt32KeyNode`1<TValue> Mutate(SortedInt32KeyNode`1<TValue> left, SortedInt32KeyNode`1<TValue> right);
    private SortedInt32KeyNode`1<TValue> Search(int key);
}
[AttributeUsageAttribute("2048")]
internal class System.Collections.Immutable.ValidatedNotNullAttribute : Attribute {
}
internal class System.Collections.Immutable.ValuesCollectionAccessor`2 : KeysOrValuesCollectionAccessor`3<TKey, TValue, TValue> {
    internal ValuesCollectionAccessor`2(IImmutableDictionary`2<TKey, TValue> dictionary);
    public virtual bool Contains(TValue item);
}
[AttributeUsageAttribute("748")]
internal class System.Diagnostics.CodeAnalysis.ExcludeFromCodeCoverageAttribute : Attribute {
}
[ExtensionAttribute]
public static class System.Linq.ImmutableArrayExtensions : object {
    [ExtensionAttribute]
public static IEnumerable`1<TResult> Select(ImmutableArray`1<T> immutableArray, Func`2<T, TResult> selector);
    [ExtensionAttribute]
public static IEnumerable`1<TResult> SelectMany(ImmutableArray`1<TSource> immutableArray, Func`2<TSource, IEnumerable`1<TCollection>> collectionSelector, Func`3<TSource, TCollection, TResult> resultSelector);
    [ExtensionAttribute]
public static IEnumerable`1<T> Where(ImmutableArray`1<T> immutableArray, Func`2<T, bool> predicate);
    [ExtensionAttribute]
public static bool Any(ImmutableArray`1<T> immutableArray);
    [ExtensionAttribute]
public static bool Any(ImmutableArray`1<T> immutableArray, Func`2<T, bool> predicate);
    [ExtensionAttribute]
public static bool All(ImmutableArray`1<T> immutableArray, Func`2<T, bool> predicate);
    [ExtensionAttribute]
public static bool SequenceEqual(ImmutableArray`1<TBase> immutableArray, ImmutableArray`1<TDerived> items, IEqualityComparer`1<TBase> comparer);
    [ExtensionAttribute]
public static bool SequenceEqual(ImmutableArray`1<TBase> immutableArray, IEnumerable`1<TDerived> items, IEqualityComparer`1<TBase> comparer);
    [ExtensionAttribute]
public static bool SequenceEqual(ImmutableArray`1<TBase> immutableArray, ImmutableArray`1<TDerived> items, Func`3<TBase, TBase, bool> predicate);
    [ExtensionAttribute]
public static T Aggregate(ImmutableArray`1<T> immutableArray, Func`3<T, T, T> func);
    [ExtensionAttribute]
public static TAccumulate Aggregate(ImmutableArray`1<T> immutableArray, TAccumulate seed, Func`3<TAccumulate, T, TAccumulate> func);
    [ExtensionAttribute]
public static TResult Aggregate(ImmutableArray`1<T> immutableArray, TAccumulate seed, Func`3<TAccumulate, T, TAccumulate> func, Func`2<TAccumulate, TResult> resultSelector);
    [ExtensionAttribute]
public static T ElementAt(ImmutableArray`1<T> immutableArray, int index);
    [ExtensionAttribute]
public static T ElementAtOrDefault(ImmutableArray`1<T> immutableArray, int index);
    [ExtensionAttribute]
public static T First(ImmutableArray`1<T> immutableArray, Func`2<T, bool> predicate);
    [ExtensionAttribute]
public static T First(ImmutableArray`1<T> immutableArray);
    [ExtensionAttribute]
public static T FirstOrDefault(ImmutableArray`1<T> immutableArray);
    [ExtensionAttribute]
public static T FirstOrDefault(ImmutableArray`1<T> immutableArray, Func`2<T, bool> predicate);
    [ExtensionAttribute]
public static T Last(ImmutableArray`1<T> immutableArray);
    [ExtensionAttribute]
public static T Last(ImmutableArray`1<T> immutableArray, Func`2<T, bool> predicate);
    [ExtensionAttribute]
public static T LastOrDefault(ImmutableArray`1<T> immutableArray);
    [ExtensionAttribute]
public static T LastOrDefault(ImmutableArray`1<T> immutableArray, Func`2<T, bool> predicate);
    [ExtensionAttribute]
public static T Single(ImmutableArray`1<T> immutableArray);
    [ExtensionAttribute]
public static T Single(ImmutableArray`1<T> immutableArray, Func`2<T, bool> predicate);
    [ExtensionAttribute]
public static T SingleOrDefault(ImmutableArray`1<T> immutableArray);
    [ExtensionAttribute]
public static T SingleOrDefault(ImmutableArray`1<T> immutableArray, Func`2<T, bool> predicate);
    [ExtensionAttribute]
public static Dictionary`2<TKey, T> ToDictionary(ImmutableArray`1<T> immutableArray, Func`2<T, TKey> keySelector);
    [ExtensionAttribute]
public static Dictionary`2<TKey, TElement> ToDictionary(ImmutableArray`1<T> immutableArray, Func`2<T, TKey> keySelector, Func`2<T, TElement> elementSelector);
    [ExtensionAttribute]
public static Dictionary`2<TKey, T> ToDictionary(ImmutableArray`1<T> immutableArray, Func`2<T, TKey> keySelector, IEqualityComparer`1<TKey> comparer);
    [ExtensionAttribute]
public static Dictionary`2<TKey, TElement> ToDictionary(ImmutableArray`1<T> immutableArray, Func`2<T, TKey> keySelector, Func`2<T, TElement> elementSelector, IEqualityComparer`1<TKey> comparer);
    [ExtensionAttribute]
public static T[] ToArray(ImmutableArray`1<T> immutableArray);
    [ExtensionAttribute]
public static T First(Builder<T> builder);
    [ExtensionAttribute]
public static T FirstOrDefault(Builder<T> builder);
    [ExtensionAttribute]
public static T Last(Builder<T> builder);
    [ExtensionAttribute]
public static T LastOrDefault(Builder<T> builder);
    [ExtensionAttribute]
public static bool Any(Builder<T> builder);
    [IteratorStateMachineAttribute("System.Linq.ImmutableArrayExtensions/<SelectManyIterator>d__36`3")]
[ExtensionAttribute]
private static IEnumerable`1<TResult> SelectManyIterator(ImmutableArray`1<TSource> immutableArray, Func`2<TSource, IEnumerable`1<TCollection>> collectionSelector, Func`3<TSource, TCollection, TResult> resultSelector);
}
[AttributeUsageAttribute("32767")]
internal class System.Runtime.CompilerServices.__BlockReflectionAttribute : Attribute {
}
[AttributeUsageAttribute("108")]
internal class System.Runtime.Versioning.NonVersionableAttribute : Attribute {
}
internal static class System.SR : object {
    private static ResourceManager s_resourceManager;
    private static string s_resourcesName;
    private static ResourceManager ResourceManager { get; }
    internal static string ArrayInitializedStateNotEqual { get; }
    internal static string ArrayLengthsNotEqual { get; }
    internal static string CannotFindOldValue { get; }
    internal static string CapacityMustBeGreaterThanOrEqualToCount { get; }
    internal static string CapacityMustEqualCountOnMove { get; }
    internal static string CollectionModifiedDuringEnumeration { get; }
    internal static string DuplicateKey { get; }
    internal static string InvalidEmptyOperation { get; }
    internal static string InvalidOperationOnDefaultArray { get; }
    internal static Type ResourceType { get; }
    private static ResourceManager get_ResourceManager();
    private static bool UsingResourceKeys();
    internal static string GetResourceString(string resourceKey, string defaultString);
    internal static string Format(string resourceFormat, Object[] args);
    internal static string Format(string resourceFormat, object p1);
    internal static string Format(string resourceFormat, object p1, object p2);
    internal static string Format(string resourceFormat, object p1, object p2, object p3);
    internal static string get_ArrayInitializedStateNotEqual();
    internal static string get_ArrayLengthsNotEqual();
    internal static string get_CannotFindOldValue();
    internal static string get_CapacityMustBeGreaterThanOrEqualToCount();
    internal static string get_CapacityMustEqualCountOnMove();
    internal static string get_CollectionModifiedDuringEnumeration();
    internal static string get_DuplicateKey();
    internal static string get_InvalidEmptyOperation();
    internal static string get_InvalidOperationOnDefaultArray();
    internal static Type get_ResourceType();
}
