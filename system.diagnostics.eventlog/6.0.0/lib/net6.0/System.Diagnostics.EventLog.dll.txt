internal static class FxResources.System.Diagnostics.EventLog.SR : object {
}
public class System.Diagnostics.EntryWrittenEventArgs : EventArgs {
    public EventLogEntry Entry { get; }
    public EntryWrittenEventArgs(EventLogEntry entry);
    public EventLogEntry get_Entry();
}
public class System.Diagnostics.EntryWrittenEventHandler : MulticastDelegate {
    public EntryWrittenEventHandler(object object, IntPtr method);
    public virtual void Invoke(object sender, EntryWrittenEventArgs e);
    public virtual IAsyncResult BeginInvoke(object sender, EntryWrittenEventArgs e, AsyncCallback callback, object object);
    public virtual void EndInvoke(IAsyncResult result);
}
public class System.Diagnostics.Eventing.Reader.EventBookmark : object {
}
public class System.Diagnostics.Eventing.Reader.EventKeyword : object {
    public string DisplayName { get; }
    public string Name { get; }
    public long Value { get; }
    public string get_DisplayName();
    public string get_Name();
    public long get_Value();
}
public class System.Diagnostics.Eventing.Reader.EventLevel : object {
    public string DisplayName { get; }
    public string Name { get; }
    public int Value { get; }
    public string get_DisplayName();
    public string get_Name();
    public int get_Value();
}
public class System.Diagnostics.Eventing.Reader.EventLogConfiguration : object {
    public bool IsClassicLog { get; }
    public bool IsEnabled { get; public set; }
    public string LogFilePath { get; public set; }
    public EventLogIsolation LogIsolation { get; }
    public EventLogMode LogMode { get; public set; }
    public string LogName { get; }
    public EventLogType LogType { get; }
    public long MaximumSizeInBytes { get; public set; }
    public string OwningProviderName { get; }
    public Nullable`1<int> ProviderBufferSize { get; }
    public Nullable`1<Guid> ProviderControlGuid { get; }
    public Nullable`1<long> ProviderKeywords { get; public set; }
    public Nullable`1<int> ProviderLatency { get; }
    public Nullable`1<int> ProviderLevel { get; public set; }
    public Nullable`1<int> ProviderMaximumNumberOfBuffers { get; }
    public Nullable`1<int> ProviderMinimumNumberOfBuffers { get; }
    public IEnumerable`1<string> ProviderNames { get; }
    public string SecurityDescriptor { get; public set; }
    public EventLogConfiguration(string logName);
    public EventLogConfiguration(string logName, EventLogSession session);
    public bool get_IsClassicLog();
    public bool get_IsEnabled();
    public void set_IsEnabled(bool value);
    public string get_LogFilePath();
    public void set_LogFilePath(string value);
    public EventLogIsolation get_LogIsolation();
    public EventLogMode get_LogMode();
    public void set_LogMode(EventLogMode value);
    public string get_LogName();
    public EventLogType get_LogType();
    public long get_MaximumSizeInBytes();
    public void set_MaximumSizeInBytes(long value);
    public string get_OwningProviderName();
    public Nullable`1<int> get_ProviderBufferSize();
    public Nullable`1<Guid> get_ProviderControlGuid();
    public Nullable`1<long> get_ProviderKeywords();
    public void set_ProviderKeywords(Nullable`1<long> value);
    public Nullable`1<int> get_ProviderLatency();
    public Nullable`1<int> get_ProviderLevel();
    public void set_ProviderLevel(Nullable`1<int> value);
    public Nullable`1<int> get_ProviderMaximumNumberOfBuffers();
    public Nullable`1<int> get_ProviderMinimumNumberOfBuffers();
    public IEnumerable`1<string> get_ProviderNames();
    public string get_SecurityDescriptor();
    public void set_SecurityDescriptor(string value);
    public sealed virtual void Dispose();
    protected virtual void Dispose(bool disposing);
    public void SaveChanges();
}
public class System.Diagnostics.Eventing.Reader.EventLogException : Exception {
    public string Message { get; }
    protected EventLogException(int errorCode);
    protected EventLogException(SerializationInfo serializationInfo, StreamingContext streamingContext);
    public EventLogException(string message);
    public EventLogException(string message, Exception innerException);
    public virtual string get_Message();
    public virtual void GetObjectData(SerializationInfo info, StreamingContext context);
}
public class System.Diagnostics.Eventing.Reader.EventLogInformation : object {
    public Nullable`1<int> Attributes { get; }
    public Nullable`1<DateTime> CreationTime { get; }
    public Nullable`1<long> FileSize { get; }
    public Nullable`1<bool> IsLogFull { get; }
    public Nullable`1<DateTime> LastAccessTime { get; }
    public Nullable`1<DateTime> LastWriteTime { get; }
    public Nullable`1<long> OldestRecordNumber { get; }
    public Nullable`1<long> RecordCount { get; }
    public Nullable`1<int> get_Attributes();
    public Nullable`1<DateTime> get_CreationTime();
    public Nullable`1<long> get_FileSize();
    public Nullable`1<bool> get_IsLogFull();
    public Nullable`1<DateTime> get_LastAccessTime();
    public Nullable`1<DateTime> get_LastWriteTime();
    public Nullable`1<long> get_OldestRecordNumber();
    public Nullable`1<long> get_RecordCount();
}
public class System.Diagnostics.Eventing.Reader.EventLogInvalidDataException : EventLogException {
    protected EventLogInvalidDataException(SerializationInfo serializationInfo, StreamingContext streamingContext);
    public EventLogInvalidDataException(string message);
    public EventLogInvalidDataException(string message, Exception innerException);
}
public enum System.Diagnostics.Eventing.Reader.EventLogIsolation : Enum {
    public int value__;
    public static EventLogIsolation Application;
    public static EventLogIsolation System;
    public static EventLogIsolation Custom;
}
public class System.Diagnostics.Eventing.Reader.EventLogLink : object {
    public string DisplayName { get; }
    public bool IsImported { get; }
    public string LogName { get; }
    public string get_DisplayName();
    public bool get_IsImported();
    public string get_LogName();
}
public enum System.Diagnostics.Eventing.Reader.EventLogMode : Enum {
    public int value__;
    public static EventLogMode Circular;
    public static EventLogMode AutoBackup;
    public static EventLogMode Retain;
}
public class System.Diagnostics.Eventing.Reader.EventLogNotFoundException : EventLogException {
    protected EventLogNotFoundException(SerializationInfo serializationInfo, StreamingContext streamingContext);
    public EventLogNotFoundException(string message);
    public EventLogNotFoundException(string message, Exception innerException);
}
public class System.Diagnostics.Eventing.Reader.EventLogPropertySelector : object {
    public EventLogPropertySelector(IEnumerable`1<string> propertyQueries);
    public sealed virtual void Dispose();
    protected virtual void Dispose(bool disposing);
}
public class System.Diagnostics.Eventing.Reader.EventLogProviderDisabledException : EventLogException {
    protected EventLogProviderDisabledException(SerializationInfo serializationInfo, StreamingContext streamingContext);
    public EventLogProviderDisabledException(string message);
    public EventLogProviderDisabledException(string message, Exception innerException);
}
public class System.Diagnostics.Eventing.Reader.EventLogQuery : object {
    public bool ReverseDirection { get; public set; }
    public EventLogSession Session { get; public set; }
    public bool TolerateQueryErrors { get; public set; }
    public EventLogQuery(string path, PathType pathType);
    public EventLogQuery(string path, PathType pathType, string query);
    public bool get_ReverseDirection();
    public void set_ReverseDirection(bool value);
    public EventLogSession get_Session();
    public void set_Session(EventLogSession value);
    public bool get_TolerateQueryErrors();
    public void set_TolerateQueryErrors(bool value);
}
public class System.Diagnostics.Eventing.Reader.EventLogReader : object {
    public int BatchSize { get; public set; }
    public IList`1<EventLogStatus> LogStatus { get; }
    public EventLogReader(EventLogQuery eventQuery);
    public EventLogReader(EventLogQuery eventQuery, EventBookmark bookmark);
    public EventLogReader(string path);
    public EventLogReader(string path, PathType pathType);
    public int get_BatchSize();
    public void set_BatchSize(int value);
    public IList`1<EventLogStatus> get_LogStatus();
    public void CancelReading();
    public sealed virtual void Dispose();
    protected virtual void Dispose(bool disposing);
    public EventRecord ReadEvent();
    public EventRecord ReadEvent(TimeSpan timeout);
    public void Seek(EventBookmark bookmark);
    public void Seek(EventBookmark bookmark, long offset);
    public void Seek(SeekOrigin origin, long offset);
}
public class System.Diagnostics.Eventing.Reader.EventLogReadingException : EventLogException {
    protected EventLogReadingException(SerializationInfo serializationInfo, StreamingContext streamingContext);
    public EventLogReadingException(string message);
    public EventLogReadingException(string message, Exception innerException);
}
public class System.Diagnostics.Eventing.Reader.EventLogRecord : EventRecord {
    public Nullable`1<Guid> ActivityId { get; }
    public EventBookmark Bookmark { get; }
    public string ContainerLog { get; }
    public int Id { get; }
    public Nullable`1<long> Keywords { get; }
    public IEnumerable`1<string> KeywordsDisplayNames { get; }
    public Nullable`1<byte> Level { get; }
    public string LevelDisplayName { get; }
    public string LogName { get; }
    public string MachineName { get; }
    public IEnumerable`1<int> MatchedQueryIds { get; }
    public Nullable`1<short> Opcode { get; }
    public string OpcodeDisplayName { get; }
    public Nullable`1<int> ProcessId { get; }
    public IList`1<EventProperty> Properties { get; }
    public Nullable`1<Guid> ProviderId { get; }
    public string ProviderName { get; }
    public Nullable`1<int> Qualifiers { get; }
    public Nullable`1<long> RecordId { get; }
    public Nullable`1<Guid> RelatedActivityId { get; }
    public Nullable`1<int> Task { get; }
    public string TaskDisplayName { get; }
    public Nullable`1<int> ThreadId { get; }
    public Nullable`1<DateTime> TimeCreated { get; }
    public SecurityIdentifier UserId { get; }
    public Nullable`1<byte> Version { get; }
    public virtual Nullable`1<Guid> get_ActivityId();
    public virtual EventBookmark get_Bookmark();
    public string get_ContainerLog();
    public virtual int get_Id();
    public virtual Nullable`1<long> get_Keywords();
    public virtual IEnumerable`1<string> get_KeywordsDisplayNames();
    public virtual Nullable`1<byte> get_Level();
    public virtual string get_LevelDisplayName();
    public virtual string get_LogName();
    public virtual string get_MachineName();
    public IEnumerable`1<int> get_MatchedQueryIds();
    public virtual Nullable`1<short> get_Opcode();
    public virtual string get_OpcodeDisplayName();
    public virtual Nullable`1<int> get_ProcessId();
    public virtual IList`1<EventProperty> get_Properties();
    public virtual Nullable`1<Guid> get_ProviderId();
    public virtual string get_ProviderName();
    public virtual Nullable`1<int> get_Qualifiers();
    public virtual Nullable`1<long> get_RecordId();
    public virtual Nullable`1<Guid> get_RelatedActivityId();
    public virtual Nullable`1<int> get_Task();
    public virtual string get_TaskDisplayName();
    public virtual Nullable`1<int> get_ThreadId();
    public virtual Nullable`1<DateTime> get_TimeCreated();
    public virtual SecurityIdentifier get_UserId();
    public virtual Nullable`1<byte> get_Version();
    protected virtual void Dispose(bool disposing);
    public virtual string FormatDescription();
    public virtual string FormatDescription(IEnumerable`1<object> values);
    public IList`1<object> GetPropertyValues(EventLogPropertySelector propertySelector);
    public virtual string ToXml();
}
public class System.Diagnostics.Eventing.Reader.EventLogSession : object {
    public static EventLogSession GlobalSession { get; }
    public EventLogSession(string server);
    public EventLogSession(string server, string domain, string user, SecureString password, SessionAuthentication logOnType);
    public static EventLogSession get_GlobalSession();
    public void CancelCurrentOperations();
    public void ClearLog(string logName);
    public void ClearLog(string logName, string backupPath);
    public sealed virtual void Dispose();
    protected virtual void Dispose(bool disposing);
    public void ExportLog(string path, PathType pathType, string query, string targetFilePath);
    public void ExportLog(string path, PathType pathType, string query, string targetFilePath, bool tolerateQueryErrors);
    public void ExportLogAndMessages(string path, PathType pathType, string query, string targetFilePath);
    public void ExportLogAndMessages(string path, PathType pathType, string query, string targetFilePath, bool tolerateQueryErrors, CultureInfo targetCultureInfo);
    public EventLogInformation GetLogInformation(string logName, PathType pathType);
    public IEnumerable`1<string> GetLogNames();
    public IEnumerable`1<string> GetProviderNames();
}
public class System.Diagnostics.Eventing.Reader.EventLogStatus : object {
    public string LogName { get; }
    public int StatusCode { get; }
    public string get_LogName();
    public int get_StatusCode();
}
public enum System.Diagnostics.Eventing.Reader.EventLogType : Enum {
    public int value__;
    public static EventLogType Administrative;
    public static EventLogType Operational;
    public static EventLogType Analytical;
    public static EventLogType Debug;
}
public class System.Diagnostics.Eventing.Reader.EventLogWatcher : object {
    public bool Enabled { get; public set; }
    public EventLogWatcher(EventLogQuery eventQuery);
    public EventLogWatcher(EventLogQuery eventQuery, EventBookmark bookmark);
    public EventLogWatcher(EventLogQuery eventQuery, EventBookmark bookmark, bool readExistingEvents);
    public EventLogWatcher(string path);
    public bool get_Enabled();
    public void set_Enabled(bool value);
    public void add_EventRecordWritten(EventHandler`1<EventRecordWrittenEventArgs> value);
    public void remove_EventRecordWritten(EventHandler`1<EventRecordWrittenEventArgs> value);
    public sealed virtual void Dispose();
    protected virtual void Dispose(bool disposing);
}
public class System.Diagnostics.Eventing.Reader.EventMetadata : object {
    public string Description { get; }
    public long Id { get; }
    public IEnumerable`1<EventKeyword> Keywords { get; }
    public EventLevel Level { get; }
    public EventLogLink LogLink { get; }
    public EventOpcode Opcode { get; }
    public EventTask Task { get; }
    public string Template { get; }
    public byte Version { get; }
    public string get_Description();
    public long get_Id();
    public IEnumerable`1<EventKeyword> get_Keywords();
    public EventLevel get_Level();
    public EventLogLink get_LogLink();
    public EventOpcode get_Opcode();
    public EventTask get_Task();
    public string get_Template();
    public byte get_Version();
}
public class System.Diagnostics.Eventing.Reader.EventOpcode : object {
    public string DisplayName { get; }
    public string Name { get; }
    public int Value { get; }
    public string get_DisplayName();
    public string get_Name();
    public int get_Value();
}
public class System.Diagnostics.Eventing.Reader.EventProperty : object {
    public object Value { get; }
    public object get_Value();
}
public abstract class System.Diagnostics.Eventing.Reader.EventRecord : object {
    public Nullable`1<Guid> ActivityId { get; }
    public EventBookmark Bookmark { get; }
    public int Id { get; }
    public Nullable`1<long> Keywords { get; }
    public IEnumerable`1<string> KeywordsDisplayNames { get; }
    public Nullable`1<byte> Level { get; }
    public string LevelDisplayName { get; }
    public string LogName { get; }
    public string MachineName { get; }
    public Nullable`1<short> Opcode { get; }
    public string OpcodeDisplayName { get; }
    public Nullable`1<int> ProcessId { get; }
    public IList`1<EventProperty> Properties { get; }
    public Nullable`1<Guid> ProviderId { get; }
    public string ProviderName { get; }
    public Nullable`1<int> Qualifiers { get; }
    public Nullable`1<long> RecordId { get; }
    public Nullable`1<Guid> RelatedActivityId { get; }
    public Nullable`1<int> Task { get; }
    public string TaskDisplayName { get; }
    public Nullable`1<int> ThreadId { get; }
    public Nullable`1<DateTime> TimeCreated { get; }
    public SecurityIdentifier UserId { get; }
    public Nullable`1<byte> Version { get; }
    public abstract virtual Nullable`1<Guid> get_ActivityId();
    public abstract virtual EventBookmark get_Bookmark();
    public abstract virtual int get_Id();
    public abstract virtual Nullable`1<long> get_Keywords();
    public abstract virtual IEnumerable`1<string> get_KeywordsDisplayNames();
    public abstract virtual Nullable`1<byte> get_Level();
    public abstract virtual string get_LevelDisplayName();
    public abstract virtual string get_LogName();
    public abstract virtual string get_MachineName();
    public abstract virtual Nullable`1<short> get_Opcode();
    public abstract virtual string get_OpcodeDisplayName();
    public abstract virtual Nullable`1<int> get_ProcessId();
    public abstract virtual IList`1<EventProperty> get_Properties();
    public abstract virtual Nullable`1<Guid> get_ProviderId();
    public abstract virtual string get_ProviderName();
    public abstract virtual Nullable`1<int> get_Qualifiers();
    public abstract virtual Nullable`1<long> get_RecordId();
    public abstract virtual Nullable`1<Guid> get_RelatedActivityId();
    public abstract virtual Nullable`1<int> get_Task();
    public abstract virtual string get_TaskDisplayName();
    public abstract virtual Nullable`1<int> get_ThreadId();
    public abstract virtual Nullable`1<DateTime> get_TimeCreated();
    public abstract virtual SecurityIdentifier get_UserId();
    public abstract virtual Nullable`1<byte> get_Version();
    public sealed virtual void Dispose();
    protected virtual void Dispose(bool disposing);
    public abstract virtual string FormatDescription();
    public abstract virtual string FormatDescription(IEnumerable`1<object> values);
    public abstract virtual string ToXml();
}
public class System.Diagnostics.Eventing.Reader.EventRecordWrittenEventArgs : EventArgs {
    public Exception EventException { get; }
    public EventRecord EventRecord { get; }
    public Exception get_EventException();
    public EventRecord get_EventRecord();
}
public class System.Diagnostics.Eventing.Reader.EventTask : object {
    public string DisplayName { get; }
    public Guid EventGuid { get; }
    public string Name { get; }
    public int Value { get; }
    public string get_DisplayName();
    public Guid get_EventGuid();
    public string get_Name();
    public int get_Value();
}
public enum System.Diagnostics.Eventing.Reader.PathType : Enum {
    public int value__;
    public static PathType LogName;
    public static PathType FilePath;
}
public class System.Diagnostics.Eventing.Reader.ProviderMetadata : object {
    public string DisplayName { get; }
    public IEnumerable`1<EventMetadata> Events { get; }
    public Uri HelpLink { get; }
    public Guid Id { get; }
    public IList`1<EventKeyword> Keywords { get; }
    public IList`1<EventLevel> Levels { get; }
    public IList`1<EventLogLink> LogLinks { get; }
    public string MessageFilePath { get; }
    public string Name { get; }
    public IList`1<EventOpcode> Opcodes { get; }
    public string ParameterFilePath { get; }
    public string ResourceFilePath { get; }
    public IList`1<EventTask> Tasks { get; }
    public ProviderMetadata(string providerName);
    public ProviderMetadata(string providerName, EventLogSession session, CultureInfo targetCultureInfo);
    public string get_DisplayName();
    public IEnumerable`1<EventMetadata> get_Events();
    public Uri get_HelpLink();
    public Guid get_Id();
    public IList`1<EventKeyword> get_Keywords();
    public IList`1<EventLevel> get_Levels();
    public IList`1<EventLogLink> get_LogLinks();
    public string get_MessageFilePath();
    public string get_Name();
    public IList`1<EventOpcode> get_Opcodes();
    public string get_ParameterFilePath();
    public string get_ResourceFilePath();
    public IList`1<EventTask> get_Tasks();
    public sealed virtual void Dispose();
    protected virtual void Dispose(bool disposing);
}
public enum System.Diagnostics.Eventing.Reader.SessionAuthentication : Enum {
    public int value__;
    public static SessionAuthentication Default;
    public static SessionAuthentication Negotiate;
    public static SessionAuthentication Kerberos;
    public static SessionAuthentication Ntlm;
}
[FlagsAttribute]
public enum System.Diagnostics.Eventing.Reader.StandardEventKeywords : Enum {
    public long value__;
    public static StandardEventKeywords None;
    public static StandardEventKeywords ResponseTime;
    public static StandardEventKeywords WdiContext;
    public static StandardEventKeywords WdiDiagnostic;
    public static StandardEventKeywords Sqm;
    public static StandardEventKeywords AuditFailure;
    [ObsoleteAttribute("StandardEventKeywords.CorrelationHint has an incorrect value and has been deprecated. Use CorrelationHint2 instead.")]
public static StandardEventKeywords CorrelationHint;
    public static StandardEventKeywords AuditSuccess;
    public static StandardEventKeywords CorrelationHint2;
    public static StandardEventKeywords EventLogClassic;
}
public enum System.Diagnostics.Eventing.Reader.StandardEventLevel : Enum {
    public int value__;
    public static StandardEventLevel LogAlways;
    public static StandardEventLevel Critical;
    public static StandardEventLevel Error;
    public static StandardEventLevel Warning;
    public static StandardEventLevel Informational;
    public static StandardEventLevel Verbose;
}
public enum System.Diagnostics.Eventing.Reader.StandardEventOpcode : Enum {
    public int value__;
    public static StandardEventOpcode Info;
    public static StandardEventOpcode Start;
    public static StandardEventOpcode Stop;
    public static StandardEventOpcode DataCollectionStart;
    public static StandardEventOpcode DataCollectionStop;
    public static StandardEventOpcode Extension;
    public static StandardEventOpcode Reply;
    public static StandardEventOpcode Resume;
    public static StandardEventOpcode Suspend;
    public static StandardEventOpcode Send;
    public static StandardEventOpcode Receive;
}
public enum System.Diagnostics.Eventing.Reader.StandardEventTask : Enum {
    public int value__;
    public static StandardEventTask None;
}
public class System.Diagnostics.EventInstance : object {
    public int CategoryId { get; public set; }
    public EventLogEntryType EntryType { get; public set; }
    public long InstanceId { get; public set; }
    public EventInstance(long instanceId, int categoryId);
    public EventInstance(long instanceId, int categoryId, EventLogEntryType entryType);
    public int get_CategoryId();
    public void set_CategoryId(int value);
    public EventLogEntryType get_EntryType();
    public void set_EntryType(EventLogEntryType value);
    public long get_InstanceId();
    public void set_InstanceId(long value);
}
[DefaultEventAttribute("EntryWritten")]
public class System.Diagnostics.EventLog : Component {
    [BrowsableAttribute("False")]
[DefaultValueAttribute("False")]
public bool EnableRaisingEvents { get; public set; }
    [BrowsableAttribute("False")]
[DesignerSerializationVisibilityAttribute("0")]
public EventLogEntryCollection Entries { get; }
    [DefaultValueAttribute("")]
[ReadOnlyAttribute("True")]
[SettingsBindableAttribute("True")]
public string Log { get; public set; }
    [BrowsableAttribute("False")]
public string LogDisplayName { get; }
    [DefaultValueAttribute(".")]
[ReadOnlyAttribute("True")]
[SettingsBindableAttribute("True")]
public string MachineName { get; public set; }
    [BrowsableAttribute("False")]
[DesignerSerializationVisibilityAttribute("0")]
public long MaximumKilobytes { get; public set; }
    [BrowsableAttribute("False")]
public int MinimumRetentionDays { get; }
    [BrowsableAttribute("False")]
public OverflowAction OverflowAction { get; }
    [DefaultValueAttribute("")]
[ReadOnlyAttribute("True")]
[SettingsBindableAttribute("True")]
public string Source { get; public set; }
    [BrowsableAttribute("False")]
[DefaultValueAttribute("")]
public ISynchronizeInvoke SynchronizingObject { get; public set; }
    public EventLog(string logName);
    public EventLog(string logName, string machineName);
    public EventLog(string logName, string machineName, string source);
    public bool get_EnableRaisingEvents();
    public void set_EnableRaisingEvents(bool value);
    public EventLogEntryCollection get_Entries();
    public string get_Log();
    public void set_Log(string value);
    public string get_LogDisplayName();
    public string get_MachineName();
    public void set_MachineName(string value);
    public long get_MaximumKilobytes();
    public void set_MaximumKilobytes(long value);
    public int get_MinimumRetentionDays();
    public OverflowAction get_OverflowAction();
    public string get_Source();
    public void set_Source(string value);
    public ISynchronizeInvoke get_SynchronizingObject();
    public void set_SynchronizingObject(ISynchronizeInvoke value);
    public void add_EntryWritten(EntryWrittenEventHandler value);
    public void remove_EntryWritten(EntryWrittenEventHandler value);
    public sealed virtual void BeginInit();
    public void Clear();
    public void Close();
    public static void CreateEventSource(EventSourceCreationData sourceData);
    public static void CreateEventSource(string source, string logName);
    [ObsoleteAttribute("EventLog.CreateEventSource has been deprecated. Use System.Diagnostics.EventLog.CreateEventSource(EventSourceCreationData sourceData) instead.")]
public static void CreateEventSource(string source, string logName, string machineName);
    public static void Delete(string logName);
    public static void Delete(string logName, string machineName);
    public static void DeleteEventSource(string source);
    public static void DeleteEventSource(string source, string machineName);
    protected virtual void Dispose(bool disposing);
    public sealed virtual void EndInit();
    public static bool Exists(string logName);
    public static bool Exists(string logName, string machineName);
    public static EventLog[] GetEventLogs();
    public static EventLog[] GetEventLogs(string machineName);
    public static string LogNameFromSourceName(string source, string machineName);
    public void ModifyOverflowPolicy(OverflowAction action, int retentionDays);
    public void RegisterDisplayName(string resourceFile, long resourceId);
    public static bool SourceExists(string source);
    public static bool SourceExists(string source, string machineName);
    public void WriteEntry(string message);
    public void WriteEntry(string message, EventLogEntryType type);
    public void WriteEntry(string message, EventLogEntryType type, int eventID);
    public void WriteEntry(string message, EventLogEntryType type, int eventID, short category);
    public void WriteEntry(string message, EventLogEntryType type, int eventID, short category, Byte[] rawData);
    public static void WriteEntry(string source, string message);
    public static void WriteEntry(string source, string message, EventLogEntryType type);
    public static void WriteEntry(string source, string message, EventLogEntryType type, int eventID);
    public static void WriteEntry(string source, string message, EventLogEntryType type, int eventID, short category);
    public static void WriteEntry(string source, string message, EventLogEntryType type, int eventID, short category, Byte[] rawData);
    public void WriteEvent(EventInstance instance, Byte[] data, Object[] values);
    public void WriteEvent(EventInstance instance, Object[] values);
    public static void WriteEvent(string source, EventInstance instance, Byte[] data, Object[] values);
    public static void WriteEvent(string source, EventInstance instance, Object[] values);
}
[DesignTimeVisibleAttribute("False")]
[ToolboxItemAttribute("False")]
public class System.Diagnostics.EventLogEntry : Component {
    public string Category { get; }
    public short CategoryNumber { get; }
    public Byte[] Data { get; }
    public EventLogEntryType EntryType { get; }
    [ObsoleteAttribute("EventLogEntry.EventID has been deprecated. Use System.Diagnostics.EventLogEntry.InstanceId instead.")]
public int EventID { get; }
    public int Index { get; }
    public long InstanceId { get; }
    public string MachineName { get; }
    [EditorAttribute("System.ComponentModel.Design.BinaryEditor, System.Design, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a", "System.Drawing.Design.UITypeEditor, System.Drawing, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a")]
public string Message { get; }
    public String[] ReplacementStrings { get; }
    public string Source { get; }
    public DateTime TimeGenerated { get; }
    public DateTime TimeWritten { get; }
    public string UserName { get; }
    public string get_Category();
    public short get_CategoryNumber();
    public Byte[] get_Data();
    public EventLogEntryType get_EntryType();
    public int get_EventID();
    public int get_Index();
    public long get_InstanceId();
    public string get_MachineName();
    public string get_Message();
    public String[] get_ReplacementStrings();
    public string get_Source();
    public DateTime get_TimeGenerated();
    public DateTime get_TimeWritten();
    public string get_UserName();
    public bool Equals(EventLogEntry otherEntry);
    private sealed virtual override void System.Runtime.Serialization.ISerializable.GetObjectData(SerializationInfo info, StreamingContext context);
}
[DefaultMemberAttribute("Item")]
public class System.Diagnostics.EventLogEntryCollection : object {
    public int Count { get; }
    public EventLogEntry Item { get; }
    private bool System.Collections.ICollection.IsSynchronized { get; }
    private object System.Collections.ICollection.SyncRoot { get; }
    public sealed virtual int get_Count();
    public virtual EventLogEntry get_Item(int index);
    private sealed virtual override bool System.Collections.ICollection.get_IsSynchronized();
    private sealed virtual override object System.Collections.ICollection.get_SyncRoot();
    public void CopyTo(EventLogEntry[] entries, int index);
    public sealed virtual IEnumerator GetEnumerator();
    private sealed virtual override void System.Collections.ICollection.CopyTo(Array array, int index);
}
public enum System.Diagnostics.EventLogEntryType : Enum {
    public int value__;
    public static EventLogEntryType Error;
    public static EventLogEntryType Warning;
    public static EventLogEntryType Information;
    public static EventLogEntryType SuccessAudit;
    public static EventLogEntryType FailureAudit;
}
public class System.Diagnostics.EventLogTraceListener : TraceListener {
    public EventLog EventLog { get; public set; }
    public string Name { get; public set; }
    public EventLogTraceListener(EventLog eventLog);
    public EventLogTraceListener(string source);
    public EventLog get_EventLog();
    public void set_EventLog(EventLog value);
    public virtual string get_Name();
    public virtual void set_Name(string value);
    public virtual void Close();
    protected virtual void Dispose(bool disposing);
    [ComVisibleAttribute("False")]
public virtual void TraceData(TraceEventCache eventCache, string source, TraceEventType severity, int id, object data);
    [ComVisibleAttribute("False")]
public virtual void TraceData(TraceEventCache eventCache, string source, TraceEventType severity, int id, Object[] data);
    [ComVisibleAttribute("False")]
public virtual void TraceEvent(TraceEventCache eventCache, string source, TraceEventType severity, int id, string message);
    [ComVisibleAttribute("False")]
public virtual void TraceEvent(TraceEventCache eventCache, string source, TraceEventType severity, int id, string format, Object[] args);
    public virtual void Write(string message);
    public virtual void WriteLine(string message);
}
public class System.Diagnostics.EventSourceCreationData : object {
    public int CategoryCount { get; public set; }
    public string CategoryResourceFile { get; public set; }
    public string LogName { get; public set; }
    public string MachineName { get; public set; }
    public string MessageResourceFile { get; public set; }
    public string ParameterResourceFile { get; public set; }
    public string Source { get; public set; }
    public EventSourceCreationData(string source, string logName);
    public int get_CategoryCount();
    public void set_CategoryCount(int value);
    public string get_CategoryResourceFile();
    public void set_CategoryResourceFile(string value);
    public string get_LogName();
    public void set_LogName(string value);
    public string get_MachineName();
    public void set_MachineName(string value);
    public string get_MessageResourceFile();
    public void set_MessageResourceFile(string value);
    public string get_ParameterResourceFile();
    public void set_ParameterResourceFile(string value);
    public string get_Source();
    public void set_Source(string value);
}
public enum System.Diagnostics.OverflowAction : Enum {
    public int value__;
    public static OverflowAction DoNotOverwrite;
    public static OverflowAction OverwriteAsNeeded;
    public static OverflowAction OverwriteOlder;
}
internal static class System.SR : object {
    private static bool s_usingResourceKeys;
    private static ResourceManager s_resourceManager;
    internal static ResourceManager ResourceManager { get; }
    internal static string BadLogName { get; }
    internal static string CannotDeleteEqualSource { get; }
    internal static string CantMonitorEventLog { get; }
    internal static string CantOpenLog { get; }
    internal static string CantOpenLogAccess { get; }
    internal static string CantReadLogEntryAt { get; }
    internal static string CantRetrieveEntries { get; }
    internal static string DuplicateLogName { get; }
    internal static string EventID { get; }
    internal static string IndexOutOfBounds { get; }
    internal static string InitTwice { get; }
    internal static string InvalidCustomerLogName { get; }
    internal static string InvalidParameter { get; }
    internal static string InvalidParameterFormat { get; }
    internal static string LocalLogAlreadyExistsAsSource { get; }
    internal static string LocalRegKeyMissing { get; }
    internal static string LocalSourceAlreadyExists { get; }
    internal static string LocalSourceNotRegistered { get; }
    internal static string LogDoesNotExists { get; }
    internal static string LogEntryTooLong { get; }
    internal static string LogSourceMismatch { get; }
    internal static string MaximumKilobytesOutOfRange { get; }
    internal static string MessageNotFormatted { get; }
    internal static string MissingLog { get; }
    internal static string MissingLogProperty { get; }
    internal static string MissingParameter { get; }
    internal static string NeedSourceToOpen { get; }
    internal static string NeedSourceToWrite { get; }
    internal static string NoCurrentEntry { get; }
    internal static string NoLogName { get; }
    internal static string ParameterTooLong { get; }
    internal static string PlatformNotSupported_EventLog { get; }
    internal static string RegKeyMissing { get; }
    internal static string RegKeyMissingShort { get; }
    internal static string RegKeyNoAccess { get; }
    internal static string RentionDaysOutOfRange { get; }
    internal static string SomeLogsInaccessible { get; }
    internal static string SomeLogsInaccessibleToCreate { get; }
    internal static string SourceAlreadyExists { get; }
    internal static string SourceNotRegistered { get; }
    internal static string TooManyReplacementStrings { get; }
    internal static string LogAlreadyExistsAsSource { get; }
    internal static string NotSupported_IONonFileDevices { get; }
    private static SR();
    private static bool UsingResourceKeys();
    internal static string GetResourceString(string resourceKey);
    internal static string GetResourceString(string resourceKey, string defaultString);
    internal static string Format(string resourceFormat, object p1);
    internal static string Format(string resourceFormat, object p1, object p2);
    internal static string Format(string resourceFormat, object p1, object p2, object p3);
    internal static string Format(string resourceFormat, Object[] args);
    internal static string Format(IFormatProvider provider, string resourceFormat, object p1);
    internal static string Format(IFormatProvider provider, string resourceFormat, object p1, object p2);
    internal static string Format(IFormatProvider provider, string resourceFormat, object p1, object p2, object p3);
    internal static string Format(IFormatProvider provider, string resourceFormat, Object[] args);
    internal static ResourceManager get_ResourceManager();
    internal static string get_BadLogName();
    internal static string get_CannotDeleteEqualSource();
    internal static string get_CantMonitorEventLog();
    internal static string get_CantOpenLog();
    internal static string get_CantOpenLogAccess();
    internal static string get_CantReadLogEntryAt();
    internal static string get_CantRetrieveEntries();
    internal static string get_DuplicateLogName();
    internal static string get_EventID();
    internal static string get_IndexOutOfBounds();
    internal static string get_InitTwice();
    internal static string get_InvalidCustomerLogName();
    internal static string get_InvalidParameter();
    internal static string get_InvalidParameterFormat();
    internal static string get_LocalLogAlreadyExistsAsSource();
    internal static string get_LocalRegKeyMissing();
    internal static string get_LocalSourceAlreadyExists();
    internal static string get_LocalSourceNotRegistered();
    internal static string get_LogDoesNotExists();
    internal static string get_LogEntryTooLong();
    internal static string get_LogSourceMismatch();
    internal static string get_MaximumKilobytesOutOfRange();
    internal static string get_MessageNotFormatted();
    internal static string get_MissingLog();
    internal static string get_MissingLogProperty();
    internal static string get_MissingParameter();
    internal static string get_NeedSourceToOpen();
    internal static string get_NeedSourceToWrite();
    internal static string get_NoCurrentEntry();
    internal static string get_NoLogName();
    internal static string get_ParameterTooLong();
    internal static string get_PlatformNotSupported_EventLog();
    internal static string get_RegKeyMissing();
    internal static string get_RegKeyMissingShort();
    internal static string get_RegKeyNoAccess();
    internal static string get_RentionDaysOutOfRange();
    internal static string get_SomeLogsInaccessible();
    internal static string get_SomeLogsInaccessibleToCreate();
    internal static string get_SourceAlreadyExists();
    internal static string get_SourceNotRegistered();
    internal static string get_TooManyReplacementStrings();
    internal static string get_LogAlreadyExistsAsSource();
    internal static string get_NotSupported_IONonFileDevices();
}
