internal static class FxResources.System.Diagnostics.EventLog.SR : object {
}
internal static class Interop : object {
    internal static int HRESULT_FROM_WIN32(int errorCode);
}
internal class Microsoft.Win32.SafeHandles.SafeEventLogReadHandle : SafeHandleZeroOrMinusOneIsInvalid {
    protected virtual bool ReleaseHandle();
}
internal class Microsoft.Win32.SafeHandles.SafeEventLogWriteHandle : SafeHandleZeroOrMinusOneIsInvalid {
    protected virtual bool ReleaseHandle();
}
internal class Microsoft.Win32.SafeHandles.SafeLibraryHandle : SafeHandleZeroOrMinusOneIsInvalid {
    internal SafeLibraryHandle(IntPtr value);
    protected virtual bool ReleaseHandle();
}
internal static class Microsoft.Win32.UnsafeNativeMethods : object {
    internal static int ERROR_EVT_MESSAGE_NOT_FOUND;
    internal static int ERROR_EVT_MESSAGE_ID_NOT_FOUND;
    internal static int ERROR_EVT_UNRESOLVED_VALUE_INSERT;
    internal static int ERROR_EVT_UNRESOLVED_PARAMETER_INSERT;
    internal static int ERROR_EVT_MAX_INSERTS_REACHED;
    internal static int ERROR_EVT_MESSAGE_LOCALE_NOT_FOUND;
    internal static int ERROR_MUI_FILE_NOT_FOUND;
    [LibraryImportAttribute("wevtapi.dll")]
[GeneratedCodeAttribute("Microsoft.Interop.LibraryImportGenerator", "9.0.10.17209")]
[SkipLocalsInitAttribute]
internal static EventLogHandle EvtQuery(EventLogHandle session, string path, string query, int flags);
    [LibraryImportAttribute("wevtapi.dll")]
[GeneratedCodeAttribute("Microsoft.Interop.LibraryImportGenerator", "9.0.10.17209")]
[SkipLocalsInitAttribute]
internal static bool EvtSeek(EventLogHandle resultSet, long position, EventLogHandle bookmark, int timeout, EvtSeekFlags flags);
    [LibraryImportAttribute("wevtapi.dll")]
[GeneratedCodeAttribute("Microsoft.Interop.LibraryImportGenerator", "9.0.10.17209")]
[SkipLocalsInitAttribute]
internal static EventLogHandle EvtSubscribe(EventLogHandle session, SafeWaitHandle signalEvent, string path, string query, EventLogHandle bookmark, IntPtr context, IntPtr callback, int flags);
    [LibraryImportAttribute("wevtapi.dll")]
[GeneratedCodeAttribute("Microsoft.Interop.LibraryImportGenerator", "9.0.10.17209")]
[SkipLocalsInitAttribute]
internal static bool EvtNext(EventLogHandle queryHandle, int eventSize, IntPtr[] events, int timeout, int flags, Int32& returned);
    [LibraryImportAttribute("wevtapi.dll")]
[GeneratedCodeAttribute("Microsoft.Interop.LibraryImportGenerator", "9.0.10.17209")]
[SkipLocalsInitAttribute]
internal static bool EvtCancel(EventLogHandle handle);
    [LibraryImportAttribute("wevtapi.dll")]
[GeneratedCodeAttribute("Microsoft.Interop.LibraryImportGenerator", "9.0.10.17209")]
[SkipLocalsInitAttribute]
internal static bool EvtClose(IntPtr handle);
    [LibraryImportAttribute("wevtapi.dll")]
[GeneratedCodeAttribute("Microsoft.Interop.LibraryImportGenerator", "9.0.10.17209")]
[SkipLocalsInitAttribute]
internal static bool EvtGetEventInfo(EventLogHandle eventHandle, EvtEventPropertyId propertyId, int bufferSize, IntPtr bufferPtr, Int32& bufferUsed);
    [LibraryImportAttribute("wevtapi.dll")]
[GeneratedCodeAttribute("Microsoft.Interop.LibraryImportGenerator", "9.0.10.17209")]
[SkipLocalsInitAttribute]
internal static bool EvtGetQueryInfo(EventLogHandle queryHandle, EvtQueryPropertyId propertyId, int bufferSize, IntPtr buffer, Int32& bufferRequired);
    [LibraryImportAttribute("wevtapi.dll")]
[GeneratedCodeAttribute("Microsoft.Interop.LibraryImportGenerator", "9.0.10.17209")]
[SkipLocalsInitAttribute]
internal static EventLogHandle EvtOpenPublisherMetadata(EventLogHandle session, string publisherId, string logFilePath, int locale, int flags);
    [LibraryImportAttribute("wevtapi.dll")]
[GeneratedCodeAttribute("Microsoft.Interop.LibraryImportGenerator", "9.0.10.17209")]
[SkipLocalsInitAttribute]
internal static bool EvtGetPublisherMetadataProperty(EventLogHandle publisherMetadataHandle, EvtPublisherMetadataPropertyId propertyId, int flags, int publisherMetadataPropertyBufferSize, IntPtr publisherMetadataPropertyBuffer, Int32& publisherMetadataPropertyBufferUsed);
    [LibraryImportAttribute("wevtapi.dll")]
[GeneratedCodeAttribute("Microsoft.Interop.LibraryImportGenerator", "9.0.10.17209")]
[SkipLocalsInitAttribute]
internal static bool EvtGetObjectArraySize(EventLogHandle objectArray, Int32& objectArraySize);
    [LibraryImportAttribute("wevtapi.dll")]
[GeneratedCodeAttribute("Microsoft.Interop.LibraryImportGenerator", "9.0.10.17209")]
[SkipLocalsInitAttribute]
internal static bool EvtGetObjectArrayProperty(EventLogHandle objectArray, int propertyId, int arrayIndex, int flags, int propertyValueBufferSize, IntPtr propertyValueBuffer, Int32& propertyValueBufferUsed);
    [LibraryImportAttribute("wevtapi.dll")]
[GeneratedCodeAttribute("Microsoft.Interop.LibraryImportGenerator", "9.0.10.17209")]
[SkipLocalsInitAttribute]
internal static EventLogHandle EvtOpenEventMetadataEnum(EventLogHandle publisherMetadata, int flags);
    [LibraryImportAttribute("wevtapi.dll")]
[GeneratedCodeAttribute("Microsoft.Interop.LibraryImportGenerator", "9.0.10.17209")]
[SkipLocalsInitAttribute]
internal static EventLogHandle EvtNextEventMetadata(EventLogHandle eventMetadataEnum, int flags);
    [LibraryImportAttribute("wevtapi.dll")]
[GeneratedCodeAttribute("Microsoft.Interop.LibraryImportGenerator", "9.0.10.17209")]
[SkipLocalsInitAttribute]
internal static bool EvtGetEventMetadataProperty(EventLogHandle eventMetadata, EvtEventMetadataPropertyId propertyId, int flags, int eventMetadataPropertyBufferSize, IntPtr eventMetadataPropertyBuffer, Int32& eventMetadataPropertyBufferUsed);
    [LibraryImportAttribute("wevtapi.dll")]
[GeneratedCodeAttribute("Microsoft.Interop.LibraryImportGenerator", "9.0.10.17209")]
[SkipLocalsInitAttribute]
internal static EventLogHandle EvtOpenChannelEnum(EventLogHandle session, int flags);
    [LibraryImportAttribute("wevtapi.dll")]
[GeneratedCodeAttribute("Microsoft.Interop.LibraryImportGenerator", "9.0.10.17209")]
[SkipLocalsInitAttribute]
internal static bool EvtNextChannelPath(EventLogHandle channelEnum, int channelPathBufferSize, Char[] channelPathBuffer, Int32& channelPathBufferUsed);
    [LibraryImportAttribute("wevtapi.dll")]
[GeneratedCodeAttribute("Microsoft.Interop.LibraryImportGenerator", "9.0.10.17209")]
[SkipLocalsInitAttribute]
internal static EventLogHandle EvtOpenPublisherEnum(EventLogHandle session, int flags);
    [LibraryImportAttribute("wevtapi.dll")]
[GeneratedCodeAttribute("Microsoft.Interop.LibraryImportGenerator", "9.0.10.17209")]
[SkipLocalsInitAttribute]
internal static bool EvtNextPublisherId(EventLogHandle publisherEnum, int publisherIdBufferSize, Char[] publisherIdBuffer, Int32& publisherIdBufferUsed);
    [LibraryImportAttribute("wevtapi.dll")]
[GeneratedCodeAttribute("Microsoft.Interop.LibraryImportGenerator", "9.0.10.17209")]
[SkipLocalsInitAttribute]
internal static EventLogHandle EvtOpenChannelConfig(EventLogHandle session, string channelPath, int flags);
    [LibraryImportAttribute("wevtapi.dll")]
[GeneratedCodeAttribute("Microsoft.Interop.LibraryImportGenerator", "9.0.10.17209")]
[SkipLocalsInitAttribute]
internal static bool EvtSaveChannelConfig(EventLogHandle channelConfig, int flags);
    [LibraryImportAttribute("wevtapi.dll")]
[GeneratedCodeAttribute("Microsoft.Interop.LibraryImportGenerator", "9.0.10.17209")]
[SkipLocalsInitAttribute]
internal static bool EvtSetChannelConfigProperty(EventLogHandle channelConfig, EvtChannelConfigPropertyId propertyId, int flags, EvtVariant& propertyValue);
    [LibraryImportAttribute("wevtapi.dll")]
[GeneratedCodeAttribute("Microsoft.Interop.LibraryImportGenerator", "9.0.10.17209")]
[SkipLocalsInitAttribute]
internal static bool EvtGetChannelConfigProperty(EventLogHandle channelConfig, EvtChannelConfigPropertyId propertyId, int flags, int propertyValueBufferSize, IntPtr propertyValueBuffer, Int32& propertyValueBufferUsed);
    [LibraryImportAttribute("wevtapi.dll")]
[GeneratedCodeAttribute("Microsoft.Interop.LibraryImportGenerator", "9.0.10.17209")]
[SkipLocalsInitAttribute]
internal static EventLogHandle EvtOpenLog(EventLogHandle session, string path, PathType flags);
    [LibraryImportAttribute("wevtapi.dll")]
[GeneratedCodeAttribute("Microsoft.Interop.LibraryImportGenerator", "9.0.10.17209")]
[SkipLocalsInitAttribute]
internal static bool EvtGetLogInfo(EventLogHandle log, EvtLogPropertyId propertyId, int propertyValueBufferSize, IntPtr propertyValueBuffer, Int32& propertyValueBufferUsed);
    [LibraryImportAttribute("wevtapi.dll")]
[GeneratedCodeAttribute("Microsoft.Interop.LibraryImportGenerator", "9.0.10.17209")]
[SkipLocalsInitAttribute]
internal static bool EvtExportLog(EventLogHandle session, string channelPath, string query, string targetFilePath, int flags);
    [LibraryImportAttribute("wevtapi.dll")]
[GeneratedCodeAttribute("Microsoft.Interop.LibraryImportGenerator", "9.0.10.17209")]
[SkipLocalsInitAttribute]
internal static bool EvtArchiveExportedLog(EventLogHandle session, string logFilePath, int locale, int flags);
    [LibraryImportAttribute("wevtapi.dll")]
[GeneratedCodeAttribute("Microsoft.Interop.LibraryImportGenerator", "9.0.10.17209")]
[SkipLocalsInitAttribute]
internal static bool EvtClearLog(EventLogHandle session, string channelPath, string targetFilePath, int flags);
    [LibraryImportAttribute("wevtapi.dll")]
[GeneratedCodeAttribute("Microsoft.Interop.LibraryImportGenerator", "9.0.10.17209")]
[SkipLocalsInitAttribute]
internal static EventLogHandle EvtCreateRenderContext(int valuePathsCount, String[] valuePaths, EvtRenderContextFlags flags);
    [LibraryImportAttribute("wevtapi.dll")]
[GeneratedCodeAttribute("Microsoft.Interop.LibraryImportGenerator", "9.0.10.17209")]
[SkipLocalsInitAttribute]
internal static bool EvtRender(EventLogHandle context, EventLogHandle eventHandle, EvtRenderFlags flags, int buffSize, Char[] buffer, Int32& buffUsed, Int32& propCount);
    [LibraryImportAttribute("wevtapi.dll")]
[GeneratedCodeAttribute("Microsoft.Interop.LibraryImportGenerator", "9.0.10.17209")]
[SkipLocalsInitAttribute]
internal static bool EvtRender(EventLogHandle context, EventLogHandle eventHandle, EvtRenderFlags flags, int buffSize, IntPtr buffer, Int32& buffUsed, Int32& propCount);
    [LibraryImportAttribute("wevtapi.dll")]
[GeneratedCodeAttribute("Microsoft.Interop.LibraryImportGenerator", "9.0.10.17209")]
[SkipLocalsInitAttribute]
internal static bool EvtFormatMessage(EventLogHandle publisherMetadataHandle, EventLogHandle eventHandle, UInt32 messageId, int valueCount, EvtStringVariant[] values, EvtFormatMessageFlags flags, int bufferSize, Char[] buffer, Int32& bufferUsed);
    [LibraryImportAttribute("wevtapi.dll")]
[GeneratedCodeAttribute("Microsoft.Interop.LibraryImportGenerator", "9.0.10.17209")]
[SkipLocalsInitAttribute]
internal static bool EvtFormatMessageBuffer(EventLogHandle publisherMetadataHandle, EventLogHandle eventHandle, UInt32 messageId, int valueCount, IntPtr values, EvtFormatMessageFlags flags, int bufferSize, IntPtr buffer, Int32& bufferUsed);
    [LibraryImportAttribute("wevtapi.dll")]
[GeneratedCodeAttribute("Microsoft.Interop.LibraryImportGenerator", "9.0.10.17209")]
[SkipLocalsInitAttribute]
internal static EventLogHandle EvtOpenSession(EvtLoginClass loginClass, EvtRpcLogin& login, int timeout, int flags);
    [LibraryImportAttribute("wevtapi.dll")]
[GeneratedCodeAttribute("Microsoft.Interop.LibraryImportGenerator", "9.0.10.17209")]
[SkipLocalsInitAttribute]
internal static EventLogHandle EvtCreateBookmark(string bookmarkXml);
    [LibraryImportAttribute("wevtapi.dll")]
[GeneratedCodeAttribute("Microsoft.Interop.LibraryImportGenerator", "9.0.10.17209")]
[SkipLocalsInitAttribute]
internal static bool EvtUpdateBookmark(EventLogHandle bookmark, EventLogHandle eventHandle);
    [CompilerGeneratedAttribute]
internal static IntPtr <EvtQuery>g____PInvoke|28_0(IntPtr __session_native, UInt16* __path_native, UInt16* __query_native, int __flags_native);
    [CompilerGeneratedAttribute]
internal static int <EvtSeek>g____PInvoke|29_0(IntPtr __resultSet_native, long __position_native, IntPtr __bookmark_native, int __timeout_native, EvtSeekFlags __flags_native);
    [CompilerGeneratedAttribute]
internal static IntPtr <EvtSubscribe>g____PInvoke|30_0(IntPtr __session_native, IntPtr __signalEvent_native, UInt16* __path_native, UInt16* __query_native, IntPtr __bookmark_native, IntPtr __context_native, IntPtr __callback_native, int __flags_native);
    [CompilerGeneratedAttribute]
internal static int <EvtNext>g____PInvoke|31_0(IntPtr __queryHandle_native, int __eventSize_native, IntPtr* __events_native, int __timeout_native, int __flags_native, Int32* __returned_native);
    [CompilerGeneratedAttribute]
internal static int <EvtCancel>g____PInvoke|32_0(IntPtr __handle_native);
    [CompilerGeneratedAttribute]
internal static int <EvtClose>g____PInvoke|33_0(IntPtr __handle_native);
    [CompilerGeneratedAttribute]
internal static int <EvtGetEventInfo>g____PInvoke|34_0(IntPtr __eventHandle_native, EvtEventPropertyId __propertyId_native, int __bufferSize_native, IntPtr __bufferPtr_native, Int32* __bufferUsed_native);
    [CompilerGeneratedAttribute]
internal static int <EvtGetQueryInfo>g____PInvoke|35_0(IntPtr __queryHandle_native, EvtQueryPropertyId __propertyId_native, int __bufferSize_native, IntPtr __buffer_native, Int32* __bufferRequired_native);
    [CompilerGeneratedAttribute]
internal static IntPtr <EvtOpenPublisherMetadata>g____PInvoke|36_0(IntPtr __session_native, UInt16* __publisherId_native, UInt16* __logFilePath_native, int __locale_native, int __flags_native);
    [CompilerGeneratedAttribute]
internal static int <EvtGetPublisherMetadataProperty>g____PInvoke|37_0(IntPtr __publisherMetadataHandle_native, EvtPublisherMetadataPropertyId __propertyId_native, int __flags_native, int __publisherMetadataPropertyBufferSize_native, IntPtr __publisherMetadataPropertyBuffer_native, Int32* __publisherMetadataPropertyBufferUsed_native);
    [CompilerGeneratedAttribute]
internal static int <EvtGetObjectArraySize>g____PInvoke|38_0(IntPtr __objectArray_native, Int32* __objectArraySize_native);
    [CompilerGeneratedAttribute]
internal static int <EvtGetObjectArrayProperty>g____PInvoke|39_0(IntPtr __objectArray_native, int __propertyId_native, int __arrayIndex_native, int __flags_native, int __propertyValueBufferSize_native, IntPtr __propertyValueBuffer_native, Int32* __propertyValueBufferUsed_native);
    [CompilerGeneratedAttribute]
internal static IntPtr <EvtOpenEventMetadataEnum>g____PInvoke|40_0(IntPtr __publisherMetadata_native, int __flags_native);
    [CompilerGeneratedAttribute]
internal static IntPtr <EvtNextEventMetadata>g____PInvoke|41_0(IntPtr __eventMetadataEnum_native, int __flags_native);
    [CompilerGeneratedAttribute]
internal static int <EvtGetEventMetadataProperty>g____PInvoke|42_0(IntPtr __eventMetadata_native, EvtEventMetadataPropertyId __propertyId_native, int __flags_native, int __eventMetadataPropertyBufferSize_native, IntPtr __eventMetadataPropertyBuffer_native, Int32* __eventMetadataPropertyBufferUsed_native);
    [CompilerGeneratedAttribute]
internal static IntPtr <EvtOpenChannelEnum>g____PInvoke|43_0(IntPtr __session_native, int __flags_native);
    [CompilerGeneratedAttribute]
internal static int <EvtNextChannelPath>g____PInvoke|44_0(IntPtr __channelEnum_native, int __channelPathBufferSize_native, Char* __channelPathBuffer_native, Int32* __channelPathBufferUsed_native);
    [CompilerGeneratedAttribute]
internal static IntPtr <EvtOpenPublisherEnum>g____PInvoke|45_0(IntPtr __session_native, int __flags_native);
    [CompilerGeneratedAttribute]
internal static int <EvtNextPublisherId>g____PInvoke|46_0(IntPtr __publisherEnum_native, int __publisherIdBufferSize_native, Char* __publisherIdBuffer_native, Int32* __publisherIdBufferUsed_native);
    [CompilerGeneratedAttribute]
internal static IntPtr <EvtOpenChannelConfig>g____PInvoke|47_0(IntPtr __session_native, UInt16* __channelPath_native, int __flags_native);
    [CompilerGeneratedAttribute]
internal static int <EvtSaveChannelConfig>g____PInvoke|48_0(IntPtr __channelConfig_native, int __flags_native);
    [CompilerGeneratedAttribute]
internal static int <EvtSetChannelConfigProperty>g____PInvoke|49_0(IntPtr __channelConfig_native, EvtChannelConfigPropertyId __propertyId_native, int __flags_native, EvtVariant* __propertyValue_native);
    [CompilerGeneratedAttribute]
internal static int <EvtGetChannelConfigProperty>g____PInvoke|50_0(IntPtr __channelConfig_native, EvtChannelConfigPropertyId __propertyId_native, int __flags_native, int __propertyValueBufferSize_native, IntPtr __propertyValueBuffer_native, Int32* __propertyValueBufferUsed_native);
    [CompilerGeneratedAttribute]
internal static IntPtr <EvtOpenLog>g____PInvoke|51_0(IntPtr __session_native, UInt16* __path_native, PathType __flags_native);
    [CompilerGeneratedAttribute]
internal static int <EvtGetLogInfo>g____PInvoke|52_0(IntPtr __log_native, EvtLogPropertyId __propertyId_native, int __propertyValueBufferSize_native, IntPtr __propertyValueBuffer_native, Int32* __propertyValueBufferUsed_native);
    [CompilerGeneratedAttribute]
internal static int <EvtExportLog>g____PInvoke|53_0(IntPtr __session_native, UInt16* __channelPath_native, UInt16* __query_native, UInt16* __targetFilePath_native, int __flags_native);
    [CompilerGeneratedAttribute]
internal static int <EvtArchiveExportedLog>g____PInvoke|54_0(IntPtr __session_native, UInt16* __logFilePath_native, int __locale_native, int __flags_native);
    [CompilerGeneratedAttribute]
internal static int <EvtClearLog>g____PInvoke|55_0(IntPtr __session_native, UInt16* __channelPath_native, UInt16* __targetFilePath_native, int __flags_native);
    [CompilerGeneratedAttribute]
internal static IntPtr <EvtCreateRenderContext>g____PInvoke|56_0(int __valuePathsCount_native, IntPtr* __valuePaths_native, EvtRenderContextFlags __flags_native);
    [CompilerGeneratedAttribute]
internal static int <EvtRender>g____PInvoke|57_0(IntPtr __context_native, IntPtr __eventHandle_native, EvtRenderFlags __flags_native, int __buffSize_native, Char* __buffer_native, Int32* __buffUsed_native, Int32* __propCount_native);
    [CompilerGeneratedAttribute]
internal static int <EvtRender>g____PInvoke|58_0(IntPtr __context_native, IntPtr __eventHandle_native, EvtRenderFlags __flags_native, int __buffSize_native, IntPtr __buffer_native, Int32* __buffUsed_native, Int32* __propCount_native);
    [CompilerGeneratedAttribute]
internal static int <EvtFormatMessage>g____PInvoke|60_0(IntPtr __publisherMetadataHandle_native, IntPtr __eventHandle_native, UInt32 __messageId_native, int __valueCount_native, Native* __values_native, EvtFormatMessageFlags __flags_native, int __bufferSize_native, Char* __buffer_native, Int32* __bufferUsed_native);
    [CompilerGeneratedAttribute]
internal static int <EvtFormatMessageBuffer>g____PInvoke|61_0(IntPtr __publisherMetadataHandle_native, IntPtr __eventHandle_native, UInt32 __messageId_native, int __valueCount_native, IntPtr __values_native, EvtFormatMessageFlags __flags_native, int __bufferSize_native, IntPtr __buffer_native, Int32* __bufferUsed_native);
    [CompilerGeneratedAttribute]
internal static IntPtr <EvtOpenSession>g____PInvoke|62_0(EvtLoginClass __loginClass_native, Native* __login_native, int __timeout_native, int __flags_native);
    [CompilerGeneratedAttribute]
internal static IntPtr <EvtCreateBookmark>g____PInvoke|63_0(UInt16* __bookmarkXml_native);
    [CompilerGeneratedAttribute]
internal static int <EvtUpdateBookmark>g____PInvoke|64_0(IntPtr __bookmark_native, IntPtr __eventHandle_native);
}
public class System.Diagnostics.EntryWrittenEventArgs : EventArgs {
    [CompilerGeneratedAttribute]
private EventLogEntry <Entry>k__BackingField;
    public EventLogEntry Entry { get; }
    public EntryWrittenEventArgs(EventLogEntry entry);
    [CompilerGeneratedAttribute]
public EventLogEntry get_Entry();
}
public class System.Diagnostics.EntryWrittenEventHandler : MulticastDelegate {
    public EntryWrittenEventHandler(object object, IntPtr method);
    public virtual void Invoke(object sender, EntryWrittenEventArgs e);
    public virtual IAsyncResult BeginInvoke(object sender, EntryWrittenEventArgs e, AsyncCallback callback, object object);
    public virtual void EndInvoke(IAsyncResult result);
}
internal class System.Diagnostics.Eventing.Reader.CoTaskMemSafeHandle : SafeHandle {
    public bool IsInvalid { get; }
    public static CoTaskMemSafeHandle Zero { get; }
    internal void SetMemory(IntPtr handle);
    internal IntPtr GetMemory();
    public virtual bool get_IsInvalid();
    protected virtual bool ReleaseHandle();
    public static CoTaskMemSafeHandle get_Zero();
}
internal class System.Diagnostics.Eventing.Reader.CoTaskMemUnicodeSafeHandle : SafeHandle {
    public bool IsInvalid { get; }
    public static CoTaskMemUnicodeSafeHandle Zero { get; }
    internal CoTaskMemUnicodeSafeHandle(IntPtr handle, bool ownsHandle);
    internal void SetMemory(IntPtr handle);
    internal IntPtr GetMemory();
    public virtual bool get_IsInvalid();
    protected virtual bool ReleaseHandle();
    public static CoTaskMemUnicodeSafeHandle get_Zero();
}
public class System.Diagnostics.Eventing.Reader.EventBookmark : object {
    [CompilerGeneratedAttribute]
private string <BookmarkXml>k__BackingField;
    public string BookmarkXml { get; }
    public EventBookmark(string bookmarkXml);
    [CompilerGeneratedAttribute]
public string get_BookmarkXml();
}
public class System.Diagnostics.Eventing.Reader.EventKeyword : object {
    private string _name;
    private string _displayName;
    private bool _dataReady;
    private ProviderMetadata _pmReference;
    private object _syncObject;
    [CompilerGeneratedAttribute]
private long <Value>k__BackingField;
    public string Name { get; }
    public long Value { get; }
    public string DisplayName { get; }
    internal EventKeyword(long value, ProviderMetadata pmReference);
    internal EventKeyword(string name, long value, string displayName);
    internal void PrepareData();
    public string get_Name();
    [CompilerGeneratedAttribute]
public long get_Value();
    public string get_DisplayName();
}
public class System.Diagnostics.Eventing.Reader.EventLevel : object {
    private string _name;
    private string _displayName;
    private bool _dataReady;
    private ProviderMetadata _pmReference;
    private object _syncObject;
    [CompilerGeneratedAttribute]
private int <Value>k__BackingField;
    public string Name { get; }
    public int Value { get; }
    public string DisplayName { get; }
    internal EventLevel(int value, ProviderMetadata pmReference);
    internal EventLevel(string name, int value, string displayName);
    internal void PrepareData();
    public string get_Name();
    [CompilerGeneratedAttribute]
public int get_Value();
    public string get_DisplayName();
}
public class System.Diagnostics.Eventing.Reader.EventLogConfiguration : object {
    private EventLogHandle _handle;
    private EventLogSession _session;
    [CompilerGeneratedAttribute]
private string <LogName>k__BackingField;
    public string LogName { get; }
    public EventLogType LogType { get; }
    public EventLogIsolation LogIsolation { get; }
    public bool IsEnabled { get; public set; }
    public bool IsClassicLog { get; }
    public string SecurityDescriptor { get; public set; }
    public string LogFilePath { get; public set; }
    public long MaximumSizeInBytes { get; public set; }
    public EventLogMode LogMode { get; public set; }
    public string OwningProviderName { get; }
    public IEnumerable`1<string> ProviderNames { get; }
    public Nullable`1<int> ProviderLevel { get; public set; }
    public Nullable`1<long> ProviderKeywords { get; public set; }
    public Nullable`1<int> ProviderBufferSize { get; }
    public Nullable`1<int> ProviderMinimumNumberOfBuffers { get; }
    public Nullable`1<int> ProviderMaximumNumberOfBuffers { get; }
    public Nullable`1<int> ProviderLatency { get; }
    public Nullable`1<Guid> ProviderControlGuid { get; }
    public EventLogConfiguration(string logName);
    public EventLogConfiguration(string logName, EventLogSession session);
    [CompilerGeneratedAttribute]
public string get_LogName();
    public EventLogType get_LogType();
    public EventLogIsolation get_LogIsolation();
    public bool get_IsEnabled();
    public void set_IsEnabled(bool value);
    public bool get_IsClassicLog();
    public string get_SecurityDescriptor();
    public void set_SecurityDescriptor(string value);
    public string get_LogFilePath();
    public void set_LogFilePath(string value);
    public long get_MaximumSizeInBytes();
    public void set_MaximumSizeInBytes(long value);
    public EventLogMode get_LogMode();
    public void set_LogMode(EventLogMode value);
    public string get_OwningProviderName();
    public IEnumerable`1<string> get_ProviderNames();
    public Nullable`1<int> get_ProviderLevel();
    public void set_ProviderLevel(Nullable`1<int> value);
    public Nullable`1<long> get_ProviderKeywords();
    public void set_ProviderKeywords(Nullable`1<long> value);
    public Nullable`1<int> get_ProviderBufferSize();
    public Nullable`1<int> get_ProviderMinimumNumberOfBuffers();
    public Nullable`1<int> get_ProviderMaximumNumberOfBuffers();
    public Nullable`1<int> get_ProviderLatency();
    public Nullable`1<Guid> get_ProviderControlGuid();
    public void SaveChanges();
    public sealed virtual void Dispose();
    protected virtual void Dispose(bool disposing);
}
public class System.Diagnostics.Eventing.Reader.EventLogException : Exception {
    private int _errorCode;
    public string Message { get; }
    public EventLogException(string message);
    public EventLogException(string message, Exception innerException);
    protected EventLogException(int errorCode);
    [ObsoleteAttribute("This API supports obsolete formatter-based serialization. It should not be called or extended by application code.")]
[EditorBrowsableAttribute("1")]
protected EventLogException(SerializationInfo serializationInfo, StreamingContext streamingContext);
    internal static void Throw(int errorCode);
    public virtual string get_Message();
    [ObsoleteAttribute("This API supports obsolete formatter-based serialization. It should not be called or extended by application code.")]
[EditorBrowsableAttribute("1")]
public virtual void GetObjectData(SerializationInfo info, StreamingContext context);
}
internal class System.Diagnostics.Eventing.Reader.EventLogHandle : SafeHandle {
    public bool IsInvalid { get; }
    public static EventLogHandle Zero { get; }
    internal EventLogHandle(IntPtr handle, bool ownsHandle);
    public virtual bool get_IsInvalid();
    protected virtual bool ReleaseHandle();
    public static EventLogHandle get_Zero();
}
public class System.Diagnostics.Eventing.Reader.EventLogInformation : object {
    [CompilerGeneratedAttribute]
private Nullable`1<DateTime> <CreationTime>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<DateTime> <LastAccessTime>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<DateTime> <LastWriteTime>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<long> <FileSize>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<int> <Attributes>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<long> <RecordCount>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<long> <OldestRecordNumber>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<bool> <IsLogFull>k__BackingField;
    public Nullable`1<DateTime> CreationTime { get; }
    public Nullable`1<DateTime> LastAccessTime { get; }
    public Nullable`1<DateTime> LastWriteTime { get; }
    public Nullable`1<long> FileSize { get; }
    public Nullable`1<int> Attributes { get; }
    public Nullable`1<long> RecordCount { get; }
    public Nullable`1<long> OldestRecordNumber { get; }
    public Nullable`1<bool> IsLogFull { get; }
    internal EventLogInformation(EventLogSession session, string channelName, PathType pathType);
    [CompilerGeneratedAttribute]
public Nullable`1<DateTime> get_CreationTime();
    [CompilerGeneratedAttribute]
public Nullable`1<DateTime> get_LastAccessTime();
    [CompilerGeneratedAttribute]
public Nullable`1<DateTime> get_LastWriteTime();
    [CompilerGeneratedAttribute]
public Nullable`1<long> get_FileSize();
    [CompilerGeneratedAttribute]
public Nullable`1<int> get_Attributes();
    [CompilerGeneratedAttribute]
public Nullable`1<long> get_RecordCount();
    [CompilerGeneratedAttribute]
public Nullable`1<long> get_OldestRecordNumber();
    [CompilerGeneratedAttribute]
public Nullable`1<bool> get_IsLogFull();
}
public class System.Diagnostics.Eventing.Reader.EventLogInvalidDataException : EventLogException {
    public EventLogInvalidDataException(string message);
    public EventLogInvalidDataException(string message, Exception innerException);
    internal EventLogInvalidDataException(int errorCode);
    [ObsoleteAttribute("This API supports obsolete formatter-based serialization. It should not be called or extended by application code.")]
[EditorBrowsableAttribute("1")]
protected EventLogInvalidDataException(SerializationInfo serializationInfo, StreamingContext streamingContext);
}
public enum System.Diagnostics.Eventing.Reader.EventLogIsolation : Enum {
    public int value__;
    public static EventLogIsolation Application;
    public static EventLogIsolation System;
    public static EventLogIsolation Custom;
}
public class System.Diagnostics.Eventing.Reader.EventLogLink : object {
    private string _channelName;
    private bool _isImported;
    private string _displayName;
    private bool _dataReady;
    private ProviderMetadata _pmReference;
    private object _syncObject;
    [CompilerGeneratedAttribute]
private UInt32 <ChannelId>k__BackingField;
    public string LogName { get; }
    public bool IsImported { get; }
    public string DisplayName { get; }
    internal UInt32 ChannelId { get; }
    internal EventLogLink(UInt32 channelId, ProviderMetadata pmReference);
    internal EventLogLink(string channelName, bool isImported, string displayName, UInt32 channelId);
    private void PrepareData();
    public string get_LogName();
    public bool get_IsImported();
    public string get_DisplayName();
    [CompilerGeneratedAttribute]
internal UInt32 get_ChannelId();
}
public enum System.Diagnostics.Eventing.Reader.EventLogMode : Enum {
    public int value__;
    public static EventLogMode Circular;
    public static EventLogMode AutoBackup;
    public static EventLogMode Retain;
}
public class System.Diagnostics.Eventing.Reader.EventLogNotFoundException : EventLogException {
    public EventLogNotFoundException(string message);
    public EventLogNotFoundException(string message, Exception innerException);
    internal EventLogNotFoundException(int errorCode);
    [ObsoleteAttribute("This API supports obsolete formatter-based serialization. It should not be called or extended by application code.")]
[EditorBrowsableAttribute("1")]
protected EventLogNotFoundException(SerializationInfo serializationInfo, StreamingContext streamingContext);
}
public class System.Diagnostics.Eventing.Reader.EventLogPropertySelector : object {
    [CompilerGeneratedAttribute]
private EventLogHandle <Handle>k__BackingField;
    internal EventLogHandle Handle { get; }
    public EventLogPropertySelector(IEnumerable`1<string> propertyQueries);
    [CompilerGeneratedAttribute]
internal EventLogHandle get_Handle();
    public sealed virtual void Dispose();
    protected virtual void Dispose(bool disposing);
}
public class System.Diagnostics.Eventing.Reader.EventLogProviderDisabledException : EventLogException {
    public EventLogProviderDisabledException(string message);
    public EventLogProviderDisabledException(string message, Exception innerException);
    internal EventLogProviderDisabledException(int errorCode);
    [ObsoleteAttribute("This API supports obsolete formatter-based serialization. It should not be called or extended by application code.")]
[EditorBrowsableAttribute("1")]
protected EventLogProviderDisabledException(SerializationInfo serializationInfo, StreamingContext streamingContext);
}
public class System.Diagnostics.Eventing.Reader.EventLogQuery : object {
    [CompilerGeneratedAttribute]
private EventLogSession <Session>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <TolerateQueryErrors>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <ReverseDirection>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Path>k__BackingField;
    [CompilerGeneratedAttribute]
private PathType <ThePathType>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Query>k__BackingField;
    public EventLogSession Session { get; public set; }
    public bool TolerateQueryErrors { get; public set; }
    public bool ReverseDirection { get; public set; }
    internal string Path { get; }
    internal PathType ThePathType { get; }
    internal string Query { get; }
    public EventLogQuery(string path, PathType pathType);
    public EventLogQuery(string path, PathType pathType, string query);
    [CompilerGeneratedAttribute]
public EventLogSession get_Session();
    [CompilerGeneratedAttribute]
public void set_Session(EventLogSession value);
    [CompilerGeneratedAttribute]
public bool get_TolerateQueryErrors();
    [CompilerGeneratedAttribute]
public void set_TolerateQueryErrors(bool value);
    [CompilerGeneratedAttribute]
public bool get_ReverseDirection();
    [CompilerGeneratedAttribute]
public void set_ReverseDirection(bool value);
    [CompilerGeneratedAttribute]
internal string get_Path();
    [CompilerGeneratedAttribute]
internal PathType get_ThePathType();
    [CompilerGeneratedAttribute]
internal string get_Query();
}
public class System.Diagnostics.Eventing.Reader.EventLogReader : object {
    private EventLogQuery _eventQuery;
    private int _batchSize;
    private EventLogHandle _handle;
    private IntPtr[] _eventsBuffer;
    private int _currentIndex;
    private int _eventCount;
    private bool _isEof;
    private ProviderMetadataCachedInformation _cachedMetadataInformation;
    public int BatchSize { get; public set; }
    public IList`1<EventLogStatus> LogStatus { get; }
    public EventLogReader(string path);
    public EventLogReader(string path, PathType pathType);
    public EventLogReader(EventLogQuery eventQuery);
    public EventLogReader(EventLogQuery eventQuery, EventBookmark bookmark);
    public int get_BatchSize();
    public void set_BatchSize(int value);
    private bool GetNextBatch(TimeSpan ts);
    public EventRecord ReadEvent();
    public EventRecord ReadEvent(TimeSpan timeout);
    public sealed virtual void Dispose();
    protected virtual void Dispose(bool disposing);
    internal void SeekReset();
    internal void SeekCommon(long offset);
    public void Seek(EventBookmark bookmark);
    public void Seek(EventBookmark bookmark, long offset);
    public void Seek(SeekOrigin origin, long offset);
    public void CancelReading();
    public IList`1<EventLogStatus> get_LogStatus();
}
public class System.Diagnostics.Eventing.Reader.EventLogReadingException : EventLogException {
    public EventLogReadingException(string message);
    public EventLogReadingException(string message, Exception innerException);
    internal EventLogReadingException(int errorCode);
    [ObsoleteAttribute("This API supports obsolete formatter-based serialization. It should not be called or extended by application code.")]
[EditorBrowsableAttribute("1")]
protected EventLogReadingException(SerializationInfo serializationInfo, StreamingContext streamingContext);
}
public class System.Diagnostics.Eventing.Reader.EventLogRecord : EventRecord {
    private EventLogSession _session;
    private SystemProperties _systemProperties;
    private string _containerChannel;
    private Int32[] _matchedQueryIds;
    private object _syncObject;
    private string _levelName;
    private string _taskName;
    private string _opcodeName;
    private IEnumerable`1<string> _keywordsNames;
    private bool _levelNameReady;
    private bool _taskNameReady;
    private bool _opcodeNameReady;
    private ProviderMetadataCachedInformation _cachedMetadataInformation;
    [CompilerGeneratedAttribute]
private EventLogHandle <Handle>k__BackingField;
    internal EventLogHandle Handle { get; }
    public int Id { get; }
    public Nullable`1<byte> Version { get; }
    public Nullable`1<int> Qualifiers { get; }
    public Nullable`1<byte> Level { get; }
    public Nullable`1<int> Task { get; }
    public Nullable`1<short> Opcode { get; }
    public Nullable`1<long> Keywords { get; }
    public Nullable`1<long> RecordId { get; }
    public string ProviderName { get; }
    public Nullable`1<Guid> ProviderId { get; }
    public string LogName { get; }
    public Nullable`1<int> ProcessId { get; }
    public Nullable`1<int> ThreadId { get; }
    public string MachineName { get; }
    public SecurityIdentifier UserId { get; }
    public Nullable`1<DateTime> TimeCreated { get; }
    public Nullable`1<Guid> ActivityId { get; }
    public Nullable`1<Guid> RelatedActivityId { get; }
    public string ContainerLog { get; }
    public IEnumerable`1<int> MatchedQueryIds { get; }
    public EventBookmark Bookmark { get; }
    public string LevelDisplayName { get; }
    public string OpcodeDisplayName { get; }
    public string TaskDisplayName { get; }
    public IEnumerable`1<string> KeywordsDisplayNames { get; }
    public IList`1<EventProperty> Properties { get; }
    internal EventLogRecord(EventLogHandle handle, EventLogSession session, ProviderMetadataCachedInformation cachedMetadataInfo);
    [CompilerGeneratedAttribute]
internal EventLogHandle get_Handle();
    internal void PrepareSystemData();
    public virtual int get_Id();
    public virtual Nullable`1<byte> get_Version();
    public virtual Nullable`1<int> get_Qualifiers();
    public virtual Nullable`1<byte> get_Level();
    public virtual Nullable`1<int> get_Task();
    public virtual Nullable`1<short> get_Opcode();
    public virtual Nullable`1<long> get_Keywords();
    public virtual Nullable`1<long> get_RecordId();
    public virtual string get_ProviderName();
    public virtual Nullable`1<Guid> get_ProviderId();
    public virtual string get_LogName();
    public virtual Nullable`1<int> get_ProcessId();
    public virtual Nullable`1<int> get_ThreadId();
    public virtual string get_MachineName();
    public virtual SecurityIdentifier get_UserId();
    public virtual Nullable`1<DateTime> get_TimeCreated();
    public virtual Nullable`1<Guid> get_ActivityId();
    public virtual Nullable`1<Guid> get_RelatedActivityId();
    public string get_ContainerLog();
    public IEnumerable`1<int> get_MatchedQueryIds();
    public virtual EventBookmark get_Bookmark();
    public virtual string FormatDescription();
    public virtual string FormatDescription(IEnumerable`1<object> values);
    public virtual string get_LevelDisplayName();
    public virtual string get_OpcodeDisplayName();
    public virtual string get_TaskDisplayName();
    public virtual IEnumerable`1<string> get_KeywordsDisplayNames();
    public virtual IList`1<EventProperty> get_Properties();
    public IList`1<object> GetPropertyValues(EventLogPropertySelector propertySelector);
    public virtual string ToXml();
    protected virtual void Dispose(bool disposing);
    internal static EventLogHandle GetBookmarkHandleFromBookmark(EventBookmark bookmark);
}
public class System.Diagnostics.Eventing.Reader.EventLogSession : object {
    internal EventLogHandle renderContextHandleSystem;
    internal EventLogHandle renderContextHandleUser;
    private object _syncObject;
    private string _server;
    private string _user;
    private string _domain;
    private SessionAuthentication _logOnType;
    [CompilerGeneratedAttribute]
private EventLogHandle <Handle>k__BackingField;
    private static EventLogSession s_globalSession;
    internal EventLogHandle Handle { get; }
    public static EventLogSession GlobalSession { get; }
    public EventLogSession(string server);
    public EventLogSession(string server, string domain, string user, SecureString password, SessionAuthentication logOnType);
    private static EventLogSession();
    internal void SetupSystemContext();
    internal void SetupUserContext();
    [CompilerGeneratedAttribute]
internal EventLogHandle get_Handle();
    public sealed virtual void Dispose();
    protected virtual void Dispose(bool disposing);
    public void CancelCurrentOperations();
    public static EventLogSession get_GlobalSession();
    public IEnumerable`1<string> GetProviderNames();
    public IEnumerable`1<string> GetLogNames();
    public EventLogInformation GetLogInformation(string logName, PathType pathType);
    public void ExportLog(string path, PathType pathType, string query, string targetFilePath);
    public void ExportLog(string path, PathType pathType, string query, string targetFilePath, bool tolerateQueryErrors);
    public void ExportLogAndMessages(string path, PathType pathType, string query, string targetFilePath);
    public void ExportLogAndMessages(string path, PathType pathType, string query, string targetFilePath, bool tolerateQueryErrors, CultureInfo targetCultureInfo);
    public void ClearLog(string logName);
    public void ClearLog(string logName, string backupPath);
}
public class System.Diagnostics.Eventing.Reader.EventLogStatus : object {
    [CompilerGeneratedAttribute]
private string <LogName>k__BackingField;
    [CompilerGeneratedAttribute]
private int <StatusCode>k__BackingField;
    public string LogName { get; }
    public int StatusCode { get; }
    internal EventLogStatus(string channelName, int win32ErrorCode);
    [CompilerGeneratedAttribute]
public string get_LogName();
    [CompilerGeneratedAttribute]
public int get_StatusCode();
}
public enum System.Diagnostics.Eventing.Reader.EventLogType : Enum {
    public int value__;
    public static EventLogType Administrative;
    public static EventLogType Operational;
    public static EventLogType Analytical;
    public static EventLogType Debug;
}
public class System.Diagnostics.Eventing.Reader.EventLogWatcher : object {
    [CompilerGeneratedAttribute]
private EventHandler`1<EventRecordWrittenEventArgs> EventRecordWritten;
    private EventLogQuery _eventQuery;
    private EventBookmark _bookmark;
    private bool _readExistingEvents;
    private EventLogHandle _handle;
    private IntPtr[] _eventsBuffer;
    private int _numEventsInBuffer;
    private bool _isSubscribing;
    private int _callbackThreadId;
    private AutoResetEvent _subscriptionWaitHandle;
    private AutoResetEvent _unregisterDoneHandle;
    private RegisteredWaitHandle _registeredWaitHandle;
    private ProviderMetadataCachedInformation cachedMetadataInformation;
    private EventLogException asyncException;
    public bool Enabled { get; public set; }
    public EventLogWatcher(string path);
    public EventLogWatcher(EventLogQuery eventQuery);
    public EventLogWatcher(EventLogQuery eventQuery, EventBookmark bookmark);
    public EventLogWatcher(EventLogQuery eventQuery, EventBookmark bookmark, bool readExistingEvents);
    [CompilerGeneratedAttribute]
public void add_EventRecordWritten(EventHandler`1<EventRecordWrittenEventArgs> value);
    [CompilerGeneratedAttribute]
public void remove_EventRecordWritten(EventHandler`1<EventRecordWrittenEventArgs> value);
    public bool get_Enabled();
    public void set_Enabled(bool value);
    internal void StopSubscribing();
    internal void StartSubscribing();
    internal void SubscribedEventsAvailableCallback(object state, bool timedOut);
    private void RequestEvents();
    private void IssueCallback(EventRecordWrittenEventArgs eventArgs);
    private void HandleEventsRequestCompletion();
    public sealed virtual void Dispose();
    protected virtual void Dispose(bool disposing);
}
public class System.Diagnostics.Eventing.Reader.EventMetadata : object {
    private byte _channelId;
    private byte _level;
    private short _opcode;
    private int _task;
    private long _keywords;
    private ProviderMetadata _pmReference;
    [CompilerGeneratedAttribute]
private long <Id>k__BackingField;
    [CompilerGeneratedAttribute]
private byte <Version>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Template>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Description>k__BackingField;
    public long Id { get; }
    public byte Version { get; }
    public EventLogLink LogLink { get; }
    public EventLevel Level { get; }
    public EventOpcode Opcode { get; }
    public EventTask Task { get; }
    public IEnumerable`1<EventKeyword> Keywords { get; }
    public string Template { get; }
    public string Description { get; }
    internal EventMetadata(UInt32 id, byte version, byte channelId, byte level, byte opcode, short task, long keywords, string template, string description, ProviderMetadata pmReference);
    [CompilerGeneratedAttribute]
public long get_Id();
    [CompilerGeneratedAttribute]
public byte get_Version();
    public EventLogLink get_LogLink();
    public EventLevel get_Level();
    public EventOpcode get_Opcode();
    public EventTask get_Task();
    public IEnumerable`1<EventKeyword> get_Keywords();
    [CompilerGeneratedAttribute]
public string get_Template();
    [CompilerGeneratedAttribute]
public string get_Description();
}
public class System.Diagnostics.Eventing.Reader.EventOpcode : object {
    private int _value;
    private string _name;
    private string _displayName;
    private bool _dataReady;
    private ProviderMetadata _pmReference;
    private object _syncObject;
    public string Name { get; }
    public int Value { get; }
    public string DisplayName { get; }
    internal EventOpcode(int value, ProviderMetadata pmReference);
    internal EventOpcode(string name, int value, string displayName);
    internal void PrepareData();
    public string get_Name();
    public int get_Value();
    public string get_DisplayName();
}
public class System.Diagnostics.Eventing.Reader.EventProperty : object {
    [CompilerGeneratedAttribute]
private object <Value>k__BackingField;
    public object Value { get; }
    internal EventProperty(object value);
    [CompilerGeneratedAttribute]
public object get_Value();
}
public abstract class System.Diagnostics.Eventing.Reader.EventRecord : object {
    public int Id { get; }
    public Nullable`1<byte> Version { get; }
    public Nullable`1<byte> Level { get; }
    public Nullable`1<int> Task { get; }
    public Nullable`1<short> Opcode { get; }
    public Nullable`1<long> Keywords { get; }
    public Nullable`1<long> RecordId { get; }
    public string ProviderName { get; }
    public Nullable`1<Guid> ProviderId { get; }
    public string LogName { get; }
    public Nullable`1<int> ProcessId { get; }
    public Nullable`1<int> ThreadId { get; }
    public string MachineName { get; }
    public SecurityIdentifier UserId { get; }
    public Nullable`1<DateTime> TimeCreated { get; }
    public Nullable`1<Guid> ActivityId { get; }
    public Nullable`1<Guid> RelatedActivityId { get; }
    public Nullable`1<int> Qualifiers { get; }
    public string LevelDisplayName { get; }
    public string OpcodeDisplayName { get; }
    public string TaskDisplayName { get; }
    public IEnumerable`1<string> KeywordsDisplayNames { get; }
    public EventBookmark Bookmark { get; }
    public IList`1<EventProperty> Properties { get; }
    public abstract virtual int get_Id();
    public abstract virtual Nullable`1<byte> get_Version();
    public abstract virtual Nullable`1<byte> get_Level();
    public abstract virtual Nullable`1<int> get_Task();
    public abstract virtual Nullable`1<short> get_Opcode();
    public abstract virtual Nullable`1<long> get_Keywords();
    public abstract virtual Nullable`1<long> get_RecordId();
    public abstract virtual string get_ProviderName();
    public abstract virtual Nullable`1<Guid> get_ProviderId();
    public abstract virtual string get_LogName();
    public abstract virtual Nullable`1<int> get_ProcessId();
    public abstract virtual Nullable`1<int> get_ThreadId();
    public abstract virtual string get_MachineName();
    public abstract virtual SecurityIdentifier get_UserId();
    public abstract virtual Nullable`1<DateTime> get_TimeCreated();
    public abstract virtual Nullable`1<Guid> get_ActivityId();
    public abstract virtual Nullable`1<Guid> get_RelatedActivityId();
    public abstract virtual Nullable`1<int> get_Qualifiers();
    public abstract virtual string FormatDescription();
    public abstract virtual string FormatDescription(IEnumerable`1<object> values);
    public abstract virtual string get_LevelDisplayName();
    public abstract virtual string get_OpcodeDisplayName();
    public abstract virtual string get_TaskDisplayName();
    public abstract virtual IEnumerable`1<string> get_KeywordsDisplayNames();
    public abstract virtual EventBookmark get_Bookmark();
    public abstract virtual IList`1<EventProperty> get_Properties();
    public abstract virtual string ToXml();
    public sealed virtual void Dispose();
    protected virtual void Dispose(bool disposing);
}
public class System.Diagnostics.Eventing.Reader.EventRecordWrittenEventArgs : EventArgs {
    [CompilerGeneratedAttribute]
private EventRecord <EventRecord>k__BackingField;
    [CompilerGeneratedAttribute]
private Exception <EventException>k__BackingField;
    public EventRecord EventRecord { get; }
    public Exception EventException { get; }
    internal EventRecordWrittenEventArgs(EventLogRecord record);
    internal EventRecordWrittenEventArgs(Exception exception);
    [CompilerGeneratedAttribute]
public EventRecord get_EventRecord();
    [CompilerGeneratedAttribute]
public Exception get_EventException();
}
public class System.Diagnostics.Eventing.Reader.EventTask : object {
    private string _name;
    private string _displayName;
    private Guid _guid;
    private bool _dataReady;
    private ProviderMetadata _pmReference;
    private object _syncObject;
    [CompilerGeneratedAttribute]
private int <Value>k__BackingField;
    public string Name { get; }
    public int Value { get; }
    public string DisplayName { get; }
    public Guid EventGuid { get; }
    internal EventTask(int value, ProviderMetadata pmReference);
    internal EventTask(string name, int value, string displayName, Guid guid);
    internal void PrepareData();
    public string get_Name();
    [CompilerGeneratedAttribute]
public int get_Value();
    public string get_DisplayName();
    public Guid get_EventGuid();
}
internal static class System.Diagnostics.Eventing.Reader.NativeWrapper : object {
    public static EventLogHandle EvtQuery(EventLogHandle session, string path, string query, int flags);
    public static void EvtSeek(EventLogHandle resultSet, long position, EventLogHandle bookmark, int timeout, EvtSeekFlags flags);
    public static bool EvtNext(EventLogHandle queryHandle, int eventSize, IntPtr[] events, int timeout, int flags, Int32& returned);
    public static void EvtCancel(EventLogHandle handle);
    public static void EvtClose(IntPtr handle);
    public static EventLogHandle EvtOpenProviderMetadata(EventLogHandle session, string ProviderId, string logFilePath, int flags);
    public static int EvtGetObjectArraySize(EventLogHandle objectArray);
    public static EventLogHandle EvtOpenEventMetadataEnum(EventLogHandle ProviderMetadata, int flags);
    public static EventLogHandle EvtNextEventMetadata(EventLogHandle eventMetadataEnum, int flags);
    public static EventLogHandle EvtOpenChannelEnum(EventLogHandle session, int flags);
    public static EventLogHandle EvtOpenProviderEnum(EventLogHandle session, int flags);
    public static EventLogHandle EvtOpenChannelConfig(EventLogHandle session, string channelPath, int flags);
    public static void EvtSaveChannelConfig(EventLogHandle channelConfig, int flags);
    public static EventLogHandle EvtOpenLog(EventLogHandle session, string path, PathType flags);
    public static void EvtExportLog(EventLogHandle session, string channelPath, string query, string targetFilePath, int flags);
    public static void EvtArchiveExportedLog(EventLogHandle session, string logFilePath, int locale, int flags);
    public static void EvtClearLog(EventLogHandle session, string channelPath, string targetFilePath, int flags);
    public static EventLogHandle EvtCreateRenderContext(int valuePathsCount, String[] valuePaths, EvtRenderContextFlags flags);
    public static string EvtRenderXml(EventLogHandle context, EventLogHandle eventHandle, Char[] buffer);
    public static EventLogHandle EvtOpenSession(EvtLoginClass loginClass, EvtRpcLogin& login, int timeout, int flags);
    public static EventLogHandle EvtCreateBookmark(string bookmarkXml);
    public static void EvtUpdateBookmark(EventLogHandle bookmark, EventLogHandle eventHandle);
    public static object EvtGetEventInfo(EventLogHandle handle, EvtEventPropertyId enumType);
    public static object EvtGetQueryInfo(EventLogHandle handle, EvtQueryPropertyId enumType);
    public static object EvtGetPublisherMetadataProperty(EventLogHandle pmHandle, EvtPublisherMetadataPropertyId thePropertyId);
    internal static EventLogHandle EvtGetPublisherMetadataPropertyHandle(EventLogHandle pmHandle, EvtPublisherMetadataPropertyId thePropertyId);
    public static string EvtFormatMessage(EventLogHandle handle, UInt32 msgId);
    public static object EvtGetObjectArrayProperty(EventLogHandle objArrayHandle, int index, int thePropertyId);
    public static object EvtGetEventMetadataProperty(EventLogHandle handle, EvtEventMetadataPropertyId enumType);
    public static object EvtGetChannelConfigProperty(EventLogHandle handle, EvtChannelConfigPropertyId enumType);
    public static void EvtSetChannelConfigProperty(EventLogHandle handle, EvtChannelConfigPropertyId enumType, object val);
    public static string EvtNextChannelPath(EventLogHandle handle, Boolean& finish);
    public static string EvtNextPublisherId(EventLogHandle handle, Boolean& finish);
    public static object EvtGetLogInfo(EventLogHandle handle, EvtLogPropertyId enumType);
    public static void EvtRenderBufferWithContextSystem(EventLogHandle contextHandle, EventLogHandle eventHandle, EvtRenderFlags flag, SystemProperties systemProperties);
    public static IList`1<object> EvtRenderBufferWithContextUserOrValues(EventLogHandle contextHandle, EventLogHandle eventHandle);
    public static string EvtFormatMessageRenderName(EventLogHandle pmHandle, EventLogHandle eventHandle, EvtFormatMessageFlags flag);
    public static IEnumerable`1<string> EvtFormatMessageRenderKeywords(EventLogHandle pmHandle, EventLogHandle eventHandle, EvtFormatMessageFlags flag);
    public static string EvtRenderBookmark(EventLogHandle eventHandle);
    public static string EvtFormatMessageFormatDescription(EventLogHandle handle, EventLogHandle eventHandle, String[] values);
    private static object ConvertToObject(EvtVariant val);
    public static object ConvertToObject(EvtVariant val, EvtVariantType desiredType);
    public static string ConvertToString(EvtVariant val);
    public static string ConvertToAnsiString(EvtVariant val);
    public static EventLogHandle ConvertToSafeHandle(EvtVariant val);
    public static T[] ConvertToArray(EvtVariant val);
    public static Boolean[] ConvertToBoolArray(EvtVariant val);
    public static DateTime[] ConvertToFileTimeArray(EvtVariant val);
    public static DateTime[] ConvertToSysTimeArray(EvtVariant val);
    public static String[] ConvertToStringArray(EvtVariant val, bool ansi);
    private static bool IsNotFoundCase(int error);
}
public enum System.Diagnostics.Eventing.Reader.PathType : Enum {
    public int value__;
    public static PathType LogName;
    public static PathType FilePath;
}
public class System.Diagnostics.Eventing.Reader.ProviderMetadata : object {
    private EventLogHandle _handle;
    private EventLogHandle _defaultProviderHandle;
    private EventLogSession _session;
    private string _providerName;
    private CultureInfo _cultureInfo;
    private string _logFilePath;
    private IList`1<EventLevel> _levels;
    private IList`1<EventOpcode> _opcodes;
    private IList`1<EventTask> _tasks;
    private IList`1<EventKeyword> _keywords;
    private IList`1<EventLevel> _standardLevels;
    private IList`1<EventOpcode> _standardOpcodes;
    private IList`1<EventTask> _standardTasks;
    private IList`1<EventKeyword> _standardKeywords;
    private IList`1<EventLogLink> _channelReferences;
    private object _syncObject;
    internal EventLogHandle Handle { get; }
    public string Name { get; }
    public Guid Id { get; }
    public string MessageFilePath { get; }
    public string ResourceFilePath { get; }
    public string ParameterFilePath { get; }
    public Uri HelpLink { get; }
    private UInt32 ProviderMessageID { get; }
    public string DisplayName { get; }
    public IList`1<EventLogLink> LogLinks { get; }
    public IList`1<EventLevel> Levels { get; }
    public IList`1<EventOpcode> Opcodes { get; }
    public IList`1<EventKeyword> Keywords { get; }
    public IList`1<EventTask> Tasks { get; }
    public IEnumerable`1<EventMetadata> Events { get; }
    public ProviderMetadata(string providerName);
    public ProviderMetadata(string providerName, EventLogSession session, CultureInfo targetCultureInfo);
    internal ProviderMetadata(string providerName, EventLogSession session, CultureInfo targetCultureInfo, string logFilePath);
    internal EventLogHandle get_Handle();
    public string get_Name();
    public Guid get_Id();
    public string get_MessageFilePath();
    public string get_ResourceFilePath();
    public string get_ParameterFilePath();
    public Uri get_HelpLink();
    private UInt32 get_ProviderMessageID();
    public string get_DisplayName();
    public IList`1<EventLogLink> get_LogLinks();
    internal string FindStandardLevelDisplayName(string name, UInt32 value);
    internal string FindStandardOpcodeDisplayName(string name, UInt32 value);
    internal string FindStandardKeywordDisplayName(string name, long value);
    internal string FindStandardTaskDisplayName(string name, UInt32 value);
    internal object GetProviderListProperty(EventLogHandle providerHandle, EvtPublisherMetadataPropertyId metadataProperty);
    public IList`1<EventLevel> get_Levels();
    public IList`1<EventOpcode> get_Opcodes();
    public IList`1<EventKeyword> get_Keywords();
    public IList`1<EventTask> get_Tasks();
    public IEnumerable`1<EventMetadata> get_Events();
    internal void CheckReleased();
    public sealed virtual void Dispose();
    protected virtual void Dispose(bool disposing);
}
internal class System.Diagnostics.Eventing.Reader.ProviderMetadataCachedInformation : object {
    private Dictionary`2<ProviderMetadataId, CacheItem> _cache;
    private int _maximumCacheSize;
    private EventLogSession _session;
    private string _logfile;
    public ProviderMetadataCachedInformation(EventLogSession session, string logfile, int maximumCacheSize);
    private bool IsCacheFull();
    private bool IsProviderinCache(ProviderMetadataId key);
    private void DeleteCacheEntry(ProviderMetadataId key);
    private void AddCacheEntry(ProviderMetadataId key, ProviderMetadata pm);
    private void FlushOldestEntry();
    private static void UpdateCacheValueInfoForHit(CacheItem cacheItem);
    private ProviderMetadata GetProviderMetadata(ProviderMetadataId key);
    public string GetFormatDescription(string ProviderName, EventLogHandle eventHandle);
    public string GetFormatDescription(string ProviderName, EventLogHandle eventHandle, String[] values);
    public string GetLevelDisplayName(string ProviderName, EventLogHandle eventHandle);
    public string GetOpcodeDisplayName(string ProviderName, EventLogHandle eventHandle);
    public string GetTaskDisplayName(string ProviderName, EventLogHandle eventHandle);
    public IEnumerable`1<string> GetKeywordDisplayNames(string ProviderName, EventLogHandle eventHandle);
}
public enum System.Diagnostics.Eventing.Reader.SessionAuthentication : Enum {
    public int value__;
    public static SessionAuthentication Default;
    public static SessionAuthentication Negotiate;
    public static SessionAuthentication Kerberos;
    public static SessionAuthentication Ntlm;
}
[FlagsAttribute]
public enum System.Diagnostics.Eventing.Reader.StandardEventKeywords : Enum {
    public long value__;
    public static StandardEventKeywords None;
    public static StandardEventKeywords ResponseTime;
    public static StandardEventKeywords WdiContext;
    public static StandardEventKeywords WdiDiagnostic;
    public static StandardEventKeywords Sqm;
    public static StandardEventKeywords AuditFailure;
    public static StandardEventKeywords AuditSuccess;
    [ObsoleteAttribute("StandardEventKeywords.CorrelationHint has an incorrect value and has been deprecated. Use CorrelationHint2 instead.")]
public static StandardEventKeywords CorrelationHint;
    public static StandardEventKeywords CorrelationHint2;
    public static StandardEventKeywords EventLogClassic;
}
public enum System.Diagnostics.Eventing.Reader.StandardEventLevel : Enum {
    public int value__;
    public static StandardEventLevel LogAlways;
    public static StandardEventLevel Critical;
    public static StandardEventLevel Error;
    public static StandardEventLevel Warning;
    public static StandardEventLevel Informational;
    public static StandardEventLevel Verbose;
}
public enum System.Diagnostics.Eventing.Reader.StandardEventOpcode : Enum {
    public int value__;
    public static StandardEventOpcode Info;
    public static StandardEventOpcode Start;
    public static StandardEventOpcode Stop;
    public static StandardEventOpcode DataCollectionStart;
    public static StandardEventOpcode DataCollectionStop;
    public static StandardEventOpcode Extension;
    public static StandardEventOpcode Reply;
    public static StandardEventOpcode Resume;
    public static StandardEventOpcode Suspend;
    public static StandardEventOpcode Send;
    public static StandardEventOpcode Receive;
}
public enum System.Diagnostics.Eventing.Reader.StandardEventTask : Enum {
    public int value__;
    public static StandardEventTask None;
}
public class System.Diagnostics.EventInstance : object {
    private int _categoryNumber;
    private EventLogEntryType _entryType;
    private long _instanceId;
    public int CategoryId { get; public set; }
    public EventLogEntryType EntryType { get; public set; }
    public long InstanceId { get; public set; }
    public EventInstance(long instanceId, int categoryId);
    public EventInstance(long instanceId, int categoryId, EventLogEntryType entryType);
    public int get_CategoryId();
    public void set_CategoryId(int value);
    public EventLogEntryType get_EntryType();
    public void set_EntryType(EventLogEntryType value);
    public long get_InstanceId();
    public void set_InstanceId(long value);
}
[DefaultEventAttribute("EntryWritten")]
public class System.Diagnostics.EventLog : Component {
    private static string EventLogKey;
    internal static string DllName;
    internal static string AltDllName;
    private static string eventLogMutexName;
    private static int DefaultMaxSize;
    private EventLogInternal _underlyingEventLog;
    [BrowsableAttribute("False")]
[DesignerSerializationVisibilityAttribute("0")]
public EventLogEntryCollection Entries { get; }
    [BrowsableAttribute("False")]
public string LogDisplayName { get; }
    [ReadOnlyAttribute("True")]
[DefaultValueAttribute("")]
[SettingsBindableAttribute("True")]
public string Log { get; public set; }
    [ReadOnlyAttribute("True")]
[DefaultValueAttribute(".")]
[SettingsBindableAttribute("True")]
public string MachineName { get; public set; }
    [DesignerSerializationVisibilityAttribute("0")]
[BrowsableAttribute("False")]
public long MaximumKilobytes { get; public set; }
    [BrowsableAttribute("False")]
public OverflowAction OverflowAction { get; }
    [BrowsableAttribute("False")]
public int MinimumRetentionDays { get; }
    internal bool ComponentDesignMode { get; }
    [BrowsableAttribute("False")]
[DefaultValueAttribute("False")]
public bool EnableRaisingEvents { get; public set; }
    [BrowsableAttribute("False")]
[DefaultValueAttribute("")]
public ISynchronizeInvoke SynchronizingObject { get; public set; }
    [ReadOnlyAttribute("True")]
[DefaultValueAttribute("")]
[SettingsBindableAttribute("True")]
public string Source { get; public set; }
    public EventLog(string logName);
    public EventLog(string logName, string machineName);
    public EventLog(string logName, string machineName, string source);
    public EventLogEntryCollection get_Entries();
    public string get_LogDisplayName();
    public string get_Log();
    public void set_Log(string value);
    public string get_MachineName();
    public void set_MachineName(string value);
    public long get_MaximumKilobytes();
    public void set_MaximumKilobytes(long value);
    public OverflowAction get_OverflowAction();
    public int get_MinimumRetentionDays();
    internal bool get_ComponentDesignMode();
    internal object ComponentGetService(Type service);
    public bool get_EnableRaisingEvents();
    public void set_EnableRaisingEvents(bool value);
    public ISynchronizeInvoke get_SynchronizingObject();
    public void set_SynchronizingObject(ISynchronizeInvoke value);
    public string get_Source();
    public void set_Source(string value);
    public void add_EntryWritten(EntryWrittenEventHandler value);
    public void remove_EntryWritten(EntryWrittenEventHandler value);
    public sealed virtual void BeginInit();
    public void Clear();
    public void Close();
    public static void CreateEventSource(string source, string logName);
    [ObsoleteAttribute("EventLog.CreateEventSource has been deprecated. Use System.Diagnostics.EventLog.CreateEventSource(EventSourceCreationData sourceData) instead.")]
public static void CreateEventSource(string source, string logName, string machineName);
    public static void CreateEventSource(EventSourceCreationData sourceData);
    public static void Delete(string logName);
    public static void Delete(string logName, string machineName);
    public static void DeleteEventSource(string source);
    public static void DeleteEventSource(string source, string machineName);
    protected virtual void Dispose(bool disposing);
    public sealed virtual void EndInit();
    public static bool Exists(string logName);
    public static bool Exists(string logName, string machineName);
    private static RegistryKey FindSourceRegistration(string source, string machineName, bool readOnly);
    private static RegistryKey FindSourceRegistration(string source, string machineName, bool readOnly, bool wantToCreate);
    public static EventLog[] GetEventLogs();
    public static EventLog[] GetEventLogs(string machineName);
    internal static RegistryKey GetEventLogRegKey(string machine, bool writable);
    [UnconditionalSuppressMessageAttribute("SingleFile", "IL3000: Avoid accessing Assembly file path when publishing as a single file")]
internal static string GetDllPath(string machineName);
    public static bool SourceExists(string source);
    public static bool SourceExists(string source, string machineName);
    internal static bool SourceExists(string source, string machineName, bool wantToCreate);
    public static string LogNameFromSourceName(string source, string machineName);
    internal static string _InternalLogNameFromSourceName(string source, string machineName);
    public void ModifyOverflowPolicy(OverflowAction action, int retentionDays);
    public void RegisterDisplayName(string resourceFile, long resourceId);
    private static void SetSpecialLogRegValues(RegistryKey logKey);
    private static void SetSpecialSourceRegValues(RegistryKey sourceLogKey, EventSourceCreationData sourceData);
    private static string FixupPath(string path);
    internal static string TryFormatMessage(SafeLibraryHandle hModule, UInt32 messageNum, String[] insertionStrings);
    internal static string UnsafeTryFormatMessage(SafeLibraryHandle hModule, UInt32 messageNum, String[] insertionStrings);
    private static bool CharIsPrintable(char c);
    internal static bool ValidLogName(string logName, bool ignoreEmpty);
    public void WriteEntry(string message);
    public static void WriteEntry(string source, string message);
    public void WriteEntry(string message, EventLogEntryType type);
    public static void WriteEntry(string source, string message, EventLogEntryType type);
    public void WriteEntry(string message, EventLogEntryType type, int eventID);
    public static void WriteEntry(string source, string message, EventLogEntryType type, int eventID);
    public void WriteEntry(string message, EventLogEntryType type, int eventID, short category);
    public static void WriteEntry(string source, string message, EventLogEntryType type, int eventID, short category);
    public static void WriteEntry(string source, string message, EventLogEntryType type, int eventID, short category, Byte[] rawData);
    public void WriteEntry(string message, EventLogEntryType type, int eventID, short category, Byte[] rawData);
    public void WriteEvent(EventInstance instance, Object[] values);
    public void WriteEvent(EventInstance instance, Byte[] data, Object[] values);
    public static void WriteEvent(string source, EventInstance instance, Object[] values);
    public static void WriteEvent(string source, EventInstance instance, Byte[] data, Object[] values);
    private static string CheckAndNormalizeSourceName(string source);
}
[ToolboxItemAttribute("False")]
[DesignTimeVisibleAttribute("False")]
public class System.Diagnostics.EventLogEntry : Component {
    internal Byte[] dataBuf;
    internal int bufOffset;
    private EventLogInternal owner;
    private string category;
    private string message;
    private static DateTime beginningOfTime;
    public string MachineName { get; }
    public Byte[] Data { get; }
    public int Index { get; }
    public string Category { get; }
    public short CategoryNumber { get; }
    [ObsoleteAttribute("EventLogEntry.EventID has been deprecated. Use System.Diagnostics.EventLogEntry.InstanceId instead.")]
public int EventID { get; }
    public EventLogEntryType EntryType { get; }
    [EditorAttribute("System.ComponentModel.Design.BinaryEditor, System.Design, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a", "System.Drawing.Design.UITypeEditor, System.Drawing, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a")]
public string Message { get; }
    public string Source { get; }
    public String[] ReplacementStrings { get; }
    public long InstanceId { get; }
    public DateTime TimeGenerated { get; }
    public DateTime TimeWritten { get; }
    public string UserName { get; }
    internal EventLogEntry(Byte[] buf, int offset, EventLogInternal log);
    private static EventLogEntry();
    public string get_MachineName();
    public Byte[] get_Data();
    public int get_Index();
    public string get_Category();
    public short get_CategoryNumber();
    public int get_EventID();
    public EventLogEntryType get_EntryType();
    public string get_Message();
    public string get_Source();
    public String[] get_ReplacementStrings();
    public long get_InstanceId();
    public DateTime get_TimeGenerated();
    public DateTime get_TimeWritten();
    public string get_UserName();
    private static char CharFrom(Byte[] buf, int offset);
    public bool Equals(EventLogEntry otherEntry);
    private static int IntFrom(Byte[] buf, int offset);
    internal string ReplaceMessageParameters(string msg, String[] insertionStrings);
    private static RegistryKey GetSourceRegKey(string logName, string source, string machineName);
    private string GetMessageLibraryNames(string libRegKey);
    private static short ShortFrom(Byte[] buf, int offset);
    private sealed virtual override void System.Runtime.Serialization.ISerializable.GetObjectData(SerializationInfo info, StreamingContext context);
}
[DefaultMemberAttribute("Item")]
public class System.Diagnostics.EventLogEntryCollection : object {
    private EventLogInternal _log;
    public int Count { get; }
    public EventLogEntry Item { get; }
    private bool System.Collections.ICollection.IsSynchronized { get; }
    private object System.Collections.ICollection.SyncRoot { get; }
    internal EventLogEntryCollection(EventLogInternal log);
    public sealed virtual int get_Count();
    public virtual EventLogEntry get_Item(int index);
    public void CopyTo(EventLogEntry[] entries, int index);
    public sealed virtual IEnumerator GetEnumerator();
    internal EventLogEntry GetEntryAtNoThrow(int index);
    private sealed virtual override bool System.Collections.ICollection.get_IsSynchronized();
    private sealed virtual override object System.Collections.ICollection.get_SyncRoot();
    private sealed virtual override void System.Collections.ICollection.CopyTo(Array array, int index);
}
public enum System.Diagnostics.EventLogEntryType : Enum {
    public int value__;
    public static EventLogEntryType Error;
    public static EventLogEntryType Warning;
    public static EventLogEntryType Information;
    public static EventLogEntryType SuccessAudit;
    public static EventLogEntryType FailureAudit;
}
internal class System.Diagnostics.EventLogInternal : object {
    private EventLogEntryCollection entriesCollection;
    internal string logName;
    private int lastSeenCount;
    internal string machineName;
    internal EntryWrittenEventHandler onEntryWrittenHandler;
    private SafeEventLogReadHandle readHandle;
    internal string sourceName;
    private SafeEventLogWriteHandle writeHandle;
    private string logDisplayName;
    private static int BUF_SIZE;
    private int bytesCached;
    private Byte[] cache;
    private int firstCachedEntry;
    private int lastSeenEntry;
    private int lastSeenPos;
    private ISynchronizeInvoke synchronizingObject;
    private EventLog parent;
    private static string EventLogKey;
    private static string eventLogMutexName;
    private static int SecondsPerDay;
    private static int Flag_notifying;
    private static int Flag_forwards;
    private static int Flag_initializing;
    internal static int Flag_monitoring;
    private static int Flag_registeredAsListener;
    private static int Flag_writeGranted;
    private static int Flag_disposed;
    private static int Flag_sourceVerified;
    private BitVector32 boolFlags;
    private Hashtable messageLibraries;
    private static Hashtable listenerInfos;
    private object m_InstanceLockObject;
    private static object s_InternalSyncObject;
    private object InstanceLockObject { get; }
    private static object InternalSyncObject { get; }
    public EventLogEntryCollection Entries { get; }
    internal int EntryCount { get; }
    private bool IsOpen { get; }
    private bool IsOpenForRead { get; }
    private bool IsOpenForWrite { get; }
    public string LogDisplayName { get; }
    public string Log { get; }
    public string MachineName { get; }
    public long MaximumKilobytes { get; public set; }
    internal Hashtable MessageLibraries { get; }
    public OverflowAction OverflowAction { get; }
    public int MinimumRetentionDays { get; }
    public bool EnableRaisingEvents { get; public set; }
    private int OldestEntryNumber { get; }
    internal SafeEventLogReadHandle ReadHandle { get; }
    public ISynchronizeInvoke SynchronizingObject { get; public set; }
    public string Source { get; }
    public EventLogInternal(string logName, string machineName);
    public EventLogInternal(string logName, string machineName, string source);
    public EventLogInternal(string logName, string machineName, string source, EventLog parent);
    private static EventLogInternal();
    private object get_InstanceLockObject();
    private static object get_InternalSyncObject();
    public EventLogEntryCollection get_Entries();
    internal int get_EntryCount();
    private bool get_IsOpen();
    private bool get_IsOpenForRead();
    private bool get_IsOpenForWrite();
    public string get_LogDisplayName();
    public string get_Log();
    private string GetLogName(string currentMachineName);
    public string get_MachineName();
    public long get_MaximumKilobytes();
    public void set_MaximumKilobytes(long value);
    internal Hashtable get_MessageLibraries();
    public OverflowAction get_OverflowAction();
    public int get_MinimumRetentionDays();
    public bool get_EnableRaisingEvents();
    public void set_EnableRaisingEvents(bool value);
    private int get_OldestEntryNumber();
    internal SafeEventLogReadHandle get_ReadHandle();
    public ISynchronizeInvoke get_SynchronizingObject();
    public void set_SynchronizingObject(ISynchronizeInvoke value);
    public string get_Source();
    private static void AddListenerComponent(EventLogInternal component, string compMachineName, string compLogName);
    public void add_EntryWritten(EntryWrittenEventHandler value);
    public void remove_EntryWritten(EntryWrittenEventHandler value);
    public sealed virtual void BeginInit();
    public void Clear();
    public void Close();
    private void Close(string currentMachineName);
    private void CompletionCallback();
    public sealed virtual void Dispose();
    internal void Dispose(bool disposing);
    public sealed virtual void EndInit();
    internal string FormatMessageWrapper(string dllNameList, UInt32 messageNum, String[] insertionStrings);
    internal EventLogEntry[] GetAllEntries();
    private int GetCachedEntryPos(int entryIndex);
    internal EventLogEntry GetEntryAt(int index);
    internal EventLogEntry GetEntryAtNoThrow(int index);
    private EventLogEntry GetEntryWithOldest(int index);
    internal static RegistryKey GetEventLogRegKey(string machine, bool writable);
    private RegistryKey GetLogRegKey(string currentMachineName, bool writable);
    private object GetLogRegValue(string currentMachineName, string valuename);
    private int GetNextEntryPos(int pos);
    private int GetPreviousEntryPos(int pos);
    private static int IntFrom(Byte[] buf, int offset);
    public void ModifyOverflowPolicy(OverflowAction action, int retentionDays);
    private void OpenForRead(string currentMachineName);
    private void OpenForWrite(string currentMachineName);
    public void RegisterDisplayName(string resourceFile, long resourceId);
    private void Reset(string currentMachineName);
    private static void RemoveListenerComponent(EventLogInternal component, string compLogName);
    private void StartListening(string currentMachineName, string currentLogName);
    private void StartRaisingEvents(string currentMachineName, string currentLogName);
    private static void StaticCompletionCallback(object context, bool wasSignaled);
    private void StopListening(string currentLogName);
    private void StopRaisingEvents(string currentLogName);
    private static bool CharIsPrintable(char c);
    internal static bool ValidLogName(string logName, bool ignoreEmpty);
    private void VerifyAndCreateSource(string sourceName, string currentMachineName);
    public void WriteEntry(string message, EventLogEntryType type, int eventID, short category, Byte[] rawData);
    public void WriteEvent(EventInstance instance, Byte[] data, Object[] values);
    private void InternalWriteEvent(UInt32 eventID, ushort category, EventLogEntryType type, String[] strings, Byte[] rawData, string currentMachineName);
}
public class System.Diagnostics.EventLogTraceListener : TraceListener {
    private bool _nameSet;
    [CompilerGeneratedAttribute]
private EventLog <EventLog>k__BackingField;
    public EventLog EventLog { get; public set; }
    public string Name { get; public set; }
    public EventLogTraceListener(EventLog eventLog);
    public EventLogTraceListener(string source);
    [CompilerGeneratedAttribute]
public EventLog get_EventLog();
    [CompilerGeneratedAttribute]
public void set_EventLog(EventLog value);
    public virtual string get_Name();
    public virtual void set_Name(string value);
    public virtual void Close();
    protected virtual void Dispose(bool disposing);
    public virtual void Write(string message);
    public virtual void WriteLine(string message);
    [ComVisibleAttribute("False")]
public virtual void TraceEvent(TraceEventCache eventCache, string source, TraceEventType severity, int id, string format, Object[] args);
    [ComVisibleAttribute("False")]
public virtual void TraceEvent(TraceEventCache eventCache, string source, TraceEventType severity, int id, string message);
    [ComVisibleAttribute("False")]
public virtual void TraceData(TraceEventCache eventCache, string source, TraceEventType severity, int id, object data);
    [ComVisibleAttribute("False")]
public virtual void TraceData(TraceEventCache eventCache, string source, TraceEventType severity, int id, Object[] data);
    private static EventInstance CreateEventInstance(TraceEventType severity, int id);
}
public class System.Diagnostics.EventSourceCreationData : object {
    private int _categoryCount;
    [CompilerGeneratedAttribute]
private string <LogName>k__BackingField;
    [CompilerGeneratedAttribute]
private string <MachineName>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Source>k__BackingField;
    [CompilerGeneratedAttribute]
private string <MessageResourceFile>k__BackingField;
    [CompilerGeneratedAttribute]
private string <ParameterResourceFile>k__BackingField;
    [CompilerGeneratedAttribute]
private string <CategoryResourceFile>k__BackingField;
    public string LogName { get; public set; }
    public string MachineName { get; public set; }
    public string Source { get; public set; }
    public string MessageResourceFile { get; public set; }
    public string ParameterResourceFile { get; public set; }
    public string CategoryResourceFile { get; public set; }
    public int CategoryCount { get; public set; }
    public EventSourceCreationData(string source, string logName);
    internal EventSourceCreationData(string source, string logName, string machineName);
    [CompilerGeneratedAttribute]
public string get_LogName();
    [CompilerGeneratedAttribute]
public void set_LogName(string value);
    [CompilerGeneratedAttribute]
public string get_MachineName();
    [CompilerGeneratedAttribute]
public void set_MachineName(string value);
    [CompilerGeneratedAttribute]
public string get_Source();
    [CompilerGeneratedAttribute]
public void set_Source(string value);
    [CompilerGeneratedAttribute]
public string get_MessageResourceFile();
    [CompilerGeneratedAttribute]
public void set_MessageResourceFile(string value);
    [CompilerGeneratedAttribute]
public string get_ParameterResourceFile();
    [CompilerGeneratedAttribute]
public void set_ParameterResourceFile(string value);
    [CompilerGeneratedAttribute]
public string get_CategoryResourceFile();
    [CompilerGeneratedAttribute]
public void set_CategoryResourceFile(string value);
    public int get_CategoryCount();
    public void set_CategoryCount(int value);
}
internal static class System.Diagnostics.NetFrameworkUtils : object {
    internal static void EnterMutex(string name, Mutex& mutex);
    internal static void EnterMutexWithoutGlobal(string mutexName, Mutex& mutex);
    private static bool SafeWaitForMutex(Mutex mutexIn, Mutex& mutexOut);
    private static bool SafeWaitForMutexOnce(Mutex mutexIn, Mutex& mutexOut);
    internal static string GetLatestBuildDllDirectory(string machineName);
    private static int GetLargestBuildNumberFromKey(RegistryKey rootKey);
    private static string GetLocalBuildDirectory();
}
public enum System.Diagnostics.OverflowAction : Enum {
    public int value__;
    public static OverflowAction DoNotOverwrite;
    public static OverflowAction OverwriteAsNeeded;
    public static OverflowAction OverwriteOlder;
}
internal static class System.Obsoletions : object {
    internal static string SharedUrlFormat;
    internal static string SystemTextEncodingUTF7Message;
    internal static string SystemTextEncodingUTF7DiagId;
    internal static string PrincipalPermissionAttributeMessage;
    internal static string PrincipalPermissionAttributeDiagId;
    internal static string CodeAccessSecurityMessage;
    internal static string CodeAccessSecurityDiagId;
    internal static string ConstrainedExecutionRegionMessage;
    internal static string ConstrainedExecutionRegionDiagId;
    internal static string GlobalAssemblyCacheMessage;
    internal static string GlobalAssemblyCacheDiagId;
    internal static string ThreadAbortMessage;
    internal static string ThreadResetAbortMessage;
    internal static string ThreadAbortDiagId;
    internal static string DefaultCryptoAlgorithmsMessage;
    internal static string DefaultCryptoAlgorithmsDiagId;
    internal static string CreatePdbGeneratorMessage;
    internal static string CreatePdbGeneratorDiagId;
    internal static string AuthenticationManagerMessage;
    internal static string AuthenticationManagerDiagId;
    internal static string RemotingApisMessage;
    internal static string RemotingApisDiagId;
    internal static string BinaryFormatterMessage;
    internal static string BinaryFormatterDiagId;
    internal static string CodeBaseMessage;
    internal static string CodeBaseDiagId;
    internal static string EscapeUriStringMessage;
    internal static string EscapeUriStringDiagId;
    internal static string WebRequestMessage;
    internal static string WebRequestDiagId;
    internal static string DisablePrivateReflectionAttributeMessage;
    internal static string DisablePrivateReflectionAttributeDiagId;
    internal static string GetContextInfoMessage;
    internal static string GetContextInfoDiagId;
    internal static string StrongNameKeyPairMessage;
    internal static string StrongNameKeyPairDiagId;
    internal static string ReflectionOnlyLoadingMessage;
    internal static string ReflectionOnlyLoadingDiagId;
    internal static string RuntimeEnvironmentMessage;
    internal static string RuntimeEnvironmentDiagId;
    internal static string JsonSerializerOptionsIgnoreNullValuesMessage;
    internal static string JsonSerializerOptionsIgnoreNullValuesDiagId;
    internal static string DerivedCryptographicTypesMessage;
    internal static string DerivedCryptographicTypesDiagId;
    internal static string RijndaelMessage;
    internal static string RijndaelDiagId;
    internal static string RNGCryptoServiceProviderMessage;
    internal static string RNGCryptoServiceProviderDiagId;
    internal static string AppDomainCreateUnloadMessage;
    internal static string AppDomainCreateUnloadDiagId;
    internal static string SuppressIldasmAttributeMessage;
    internal static string SuppressIldasmAttributeDiagId;
    internal static string X509CertificateImmutableMessage;
    internal static string X509CertificateImmutableDiagId;
    internal static string PublicKeyPropertyMessage;
    internal static string PublicKeyPropertyDiagId;
    internal static string X509CertificatePrivateKeyMessage;
    internal static string X509CertificatePrivateKeyDiagId;
    internal static string ProduceLegacyHmacValuesMessage;
    internal static string ProduceLegacyHmacValuesDiagId;
    internal static string UseManagedSha1Message;
    internal static string UseManagedSha1DiagId;
    internal static string CryptoConfigEncodeOIDMessage;
    internal static string CryptoConfigEncodeOIDDiagId;
    internal static string CorruptedStateRecoveryMessage;
    internal static string CorruptedStateRecoveryDiagId;
    internal static string Rfc2898CryptDeriveKeyMessage;
    internal static string Rfc2898CryptDeriveKeyDiagId;
    internal static string CmsSignerCspParamsCtorMessage;
    internal static string CmsSignerCspParamsCtorDiagId;
    internal static string SignerInfoCounterSigMessage;
    internal static string SignerInfoCounterSigDiagId;
    internal static string RegexCompileToAssemblyMessage;
    internal static string RegexCompileToAssemblyDiagId;
    internal static string AssemblyNameMembersMessage;
    internal static string AssemblyNameMembersDiagId;
    internal static string SystemDataSerializationFormatBinaryMessage;
    internal static string SystemDataSerializationFormatBinaryDiagId;
    internal static string TlsVersion10and11Message;
    internal static string TlsVersion10and11DiagId;
    internal static string EncryptionPolicyMessage;
    internal static string EncryptionPolicyDiagId;
    internal static string Rfc2898OutdatedCtorMessage;
    internal static string Rfc2898OutdatedCtorDiagId;
    internal static string EccXmlExportImportMessage;
    internal static string EccXmlExportImportDiagId;
    internal static string EcDhPublicKeyBlobMessage;
    internal static string EcDhPublicKeyBlobDiagId;
    internal static string AssemblyNameCodeBaseMessage;
    internal static string AssemblyNameCodeBaseDiagId;
    internal static string CryptoStringFactoryMessage;
    internal static string CryptoStringFactoryDiagId;
    internal static string ControlledExecutionRunMessage;
    internal static string ControlledExecutionRunDiagId;
    internal static string XmlSecureResolverMessage;
    internal static string XmlSecureResolverDiagId;
    internal static string RsaEncryptDecryptValueMessage;
    internal static string RsaEncryptDecryptDiagId;
    internal static string JsonSerializerOptionsAddContextMessage;
    internal static string JsonSerializerOptionsAddContextDiagId;
    internal static string LegacyFormatterMessage;
    internal static string LegacyFormatterDiagId;
    internal static string LegacyFormatterImplMessage;
    internal static string LegacyFormatterImplDiagId;
    internal static string RegexExtensibilityImplMessage;
    internal static string RegexExtensibilityDiagId;
    internal static string AesGcmTagConstructorMessage;
    internal static string AesGcmTagConstructorDiagId;
    internal static string ThreadVolatileReadWriteMessage;
    internal static string ThreadVolatileReadWriteDiagId;
}
internal static class System.SR : object {
    private static bool s_usingResourceKeys;
    private static ResourceManager s_resourceManager;
    internal static ResourceManager ResourceManager { get; }
    internal static string BadLogName { get; }
    internal static string CannotDeleteEqualSource { get; }
    internal static string CantMonitorEventLog { get; }
    internal static string CantOpenLog { get; }
    internal static string CantOpenLogAccess { get; }
    internal static string CantReadLogEntryAt { get; }
    internal static string CantRetrieveEntries { get; }
    internal static string EventID { get; }
    internal static string IndexOutOfBounds { get; }
    internal static string InitTwice { get; }
    internal static string InvalidCustomerLogName { get; }
    internal static string InvalidParameter { get; }
    internal static string InvalidParameterFormat { get; }
    internal static string LocalLogAlreadyExistsAsSource { get; }
    internal static string LocalRegKeyMissing { get; }
    internal static string LocalSourceAlreadyExists { get; }
    internal static string LocalSourceNotRegistered { get; }
    internal static string LogDoesNotExists { get; }
    internal static string LogEntryTooLong { get; }
    internal static string LogSourceMismatch { get; }
    internal static string MaximumKilobytesOutOfRange { get; }
    internal static string MessageNotFormatted { get; }
    internal static string MissingLog { get; }
    internal static string MissingLogProperty { get; }
    internal static string MissingParameter { get; }
    internal static string NeedSourceToOpen { get; }
    internal static string NeedSourceToWrite { get; }
    internal static string NoCurrentEntry { get; }
    internal static string NoLogName { get; }
    internal static string ParameterTooLong { get; }
    internal static string PlatformNotSupported_EventLog { get; }
    internal static string RegKeyMissing { get; }
    internal static string RegKeyMissingShort { get; }
    internal static string RegKeyNoAccess { get; }
    internal static string RentionDaysOutOfRange { get; }
    internal static string SomeLogsInaccessible { get; }
    internal static string SomeLogsInaccessibleToCreate { get; }
    internal static string SourceAlreadyExists { get; }
    internal static string SourceNotRegistered { get; }
    internal static string TooManyReplacementStrings { get; }
    internal static string LogAlreadyExistsAsSource { get; }
    private static SR();
    internal static bool UsingResourceKeys();
    private static string GetResourceString(string resourceKey);
    private static string GetResourceString(string resourceKey, string defaultString);
    internal static string Format(string resourceFormat, object p1);
    internal static string Format(string resourceFormat, object p1, object p2);
    internal static string Format(string resourceFormat, object p1, object p2, object p3);
    internal static string Format(string resourceFormat, Object[] args);
    internal static string Format(IFormatProvider provider, string resourceFormat, object p1);
    internal static string Format(IFormatProvider provider, string resourceFormat, object p1, object p2);
    internal static string Format(IFormatProvider provider, string resourceFormat, object p1, object p2, object p3);
    internal static string Format(IFormatProvider provider, string resourceFormat, Object[] args);
    internal static ResourceManager get_ResourceManager();
    internal static string get_BadLogName();
    internal static string get_CannotDeleteEqualSource();
    internal static string get_CantMonitorEventLog();
    internal static string get_CantOpenLog();
    internal static string get_CantOpenLogAccess();
    internal static string get_CantReadLogEntryAt();
    internal static string get_CantRetrieveEntries();
    internal static string get_EventID();
    internal static string get_IndexOutOfBounds();
    internal static string get_InitTwice();
    internal static string get_InvalidCustomerLogName();
    internal static string get_InvalidParameter();
    internal static string get_InvalidParameterFormat();
    internal static string get_LocalLogAlreadyExistsAsSource();
    internal static string get_LocalRegKeyMissing();
    internal static string get_LocalSourceAlreadyExists();
    internal static string get_LocalSourceNotRegistered();
    internal static string get_LogDoesNotExists();
    internal static string get_LogEntryTooLong();
    internal static string get_LogSourceMismatch();
    internal static string get_MaximumKilobytesOutOfRange();
    internal static string get_MessageNotFormatted();
    internal static string get_MissingLog();
    internal static string get_MissingLogProperty();
    internal static string get_MissingParameter();
    internal static string get_NeedSourceToOpen();
    internal static string get_NeedSourceToWrite();
    internal static string get_NoCurrentEntry();
    internal static string get_NoLogName();
    internal static string get_ParameterTooLong();
    internal static string get_PlatformNotSupported_EventLog();
    internal static string get_RegKeyMissing();
    internal static string get_RegKeyMissingShort();
    internal static string get_RegKeyNoAccess();
    internal static string get_RentionDaysOutOfRange();
    internal static string get_SomeLogsInaccessible();
    internal static string get_SomeLogsInaccessibleToCreate();
    internal static string get_SourceAlreadyExists();
    internal static string get_SourceNotRegistered();
    internal static string get_TooManyReplacementStrings();
    internal static string get_LogAlreadyExistsAsSource();
}
