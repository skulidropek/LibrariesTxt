internal static class FxResources.System.Dynamic.Runtime.SR : object {
}
internal static class System.Collections.Generic.EnumerableHelpers : object {
    internal static T[] ToArray(IEnumerable`1<T> source);
    internal static T[] ToArray(IEnumerable`1<T> source, Int32& length);
}
public abstract class System.Dynamic.BinaryOperationBinder : DynamicMetaObjectBinder {
    private ExpressionType _operation;
    public Type ReturnType { get; }
    public ExpressionType Operation { get; }
    internal bool IsStandardBinder { get; }
    protected BinaryOperationBinder(ExpressionType operation);
    public sealed virtual Type get_ReturnType();
    public ExpressionType get_Operation();
    public DynamicMetaObject FallbackBinaryOperation(DynamicMetaObject target, DynamicMetaObject arg);
    public abstract virtual DynamicMetaObject FallbackBinaryOperation(DynamicMetaObject target, DynamicMetaObject arg, DynamicMetaObject errorSuggestion);
    public sealed virtual DynamicMetaObject Bind(DynamicMetaObject target, DynamicMetaObject[] args);
    internal sealed virtual bool get_IsStandardBinder();
    internal static bool OperationIsValid(ExpressionType operation);
}
[DebuggerTypeProxyAttribute("System.Dynamic.BindingRestrictions/BindingRestrictionsProxy")]
[DebuggerDisplayAttribute("{DebugView}")]
public abstract class System.Dynamic.BindingRestrictions : object {
    public static BindingRestrictions Empty;
    private static int TypeRestrictionHash;
    private static int InstanceRestrictionHash;
    private static int CustomRestrictionHash;
    private string DebugView { get; }
    private static BindingRestrictions();
    internal abstract virtual Expression GetExpression();
    public BindingRestrictions Merge(BindingRestrictions restrictions);
    public static BindingRestrictions GetTypeRestriction(Expression expression, Type type);
    internal static BindingRestrictions GetTypeRestriction(DynamicMetaObject obj);
    public static BindingRestrictions GetInstanceRestriction(Expression expression, object instance);
    public static BindingRestrictions GetExpressionRestriction(Expression expression);
    public static BindingRestrictions Combine(IList`1<DynamicMetaObject> contributingObjects);
    public Expression ToExpression();
    private string get_DebugView();
}
public class System.Dynamic.CallInfo : object {
    private int _argCount;
    private ReadOnlyCollection`1<string> _argNames;
    public int ArgumentCount { get; }
    public ReadOnlyCollection`1<string> ArgumentNames { get; }
    public CallInfo(int argCount, String[] argNames);
    public CallInfo(int argCount, IEnumerable`1<string> argNames);
    public int get_ArgumentCount();
    public ReadOnlyCollection`1<string> get_ArgumentNames();
    public virtual int GetHashCode();
    public virtual bool Equals(object obj);
}
public abstract class System.Dynamic.ConvertBinder : DynamicMetaObjectBinder {
    private Type _type;
    private bool _explicit;
    public Type Type { get; }
    public bool Explicit { get; }
    internal bool IsStandardBinder { get; }
    public Type ReturnType { get; }
    protected ConvertBinder(Type type, bool explicit);
    public Type get_Type();
    public bool get_Explicit();
    public DynamicMetaObject FallbackConvert(DynamicMetaObject target);
    public abstract virtual DynamicMetaObject FallbackConvert(DynamicMetaObject target, DynamicMetaObject errorSuggestion);
    public sealed virtual DynamicMetaObject Bind(DynamicMetaObject target, DynamicMetaObject[] args);
    internal sealed virtual bool get_IsStandardBinder();
    public sealed virtual Type get_ReturnType();
}
public abstract class System.Dynamic.CreateInstanceBinder : DynamicMetaObjectBinder {
    private CallInfo _callInfo;
    public Type ReturnType { get; }
    public CallInfo CallInfo { get; }
    internal bool IsStandardBinder { get; }
    protected CreateInstanceBinder(CallInfo callInfo);
    public sealed virtual Type get_ReturnType();
    public CallInfo get_CallInfo();
    public DynamicMetaObject FallbackCreateInstance(DynamicMetaObject target, DynamicMetaObject[] args);
    public abstract virtual DynamicMetaObject FallbackCreateInstance(DynamicMetaObject target, DynamicMetaObject[] args, DynamicMetaObject errorSuggestion);
    public sealed virtual DynamicMetaObject Bind(DynamicMetaObject target, DynamicMetaObject[] args);
    internal sealed virtual bool get_IsStandardBinder();
}
public abstract class System.Dynamic.DeleteIndexBinder : DynamicMetaObjectBinder {
    private CallInfo _callInfo;
    public Type ReturnType { get; }
    public CallInfo CallInfo { get; }
    internal bool IsStandardBinder { get; }
    protected DeleteIndexBinder(CallInfo callInfo);
    public sealed virtual Type get_ReturnType();
    public CallInfo get_CallInfo();
    public sealed virtual DynamicMetaObject Bind(DynamicMetaObject target, DynamicMetaObject[] args);
    internal sealed virtual bool get_IsStandardBinder();
    public DynamicMetaObject FallbackDeleteIndex(DynamicMetaObject target, DynamicMetaObject[] indexes);
    public abstract virtual DynamicMetaObject FallbackDeleteIndex(DynamicMetaObject target, DynamicMetaObject[] indexes, DynamicMetaObject errorSuggestion);
}
public abstract class System.Dynamic.DeleteMemberBinder : DynamicMetaObjectBinder {
    private string _name;
    private bool _ignoreCase;
    public string Name { get; }
    public bool IgnoreCase { get; }
    public Type ReturnType { get; }
    internal bool IsStandardBinder { get; }
    protected DeleteMemberBinder(string name, bool ignoreCase);
    public string get_Name();
    public bool get_IgnoreCase();
    public sealed virtual Type get_ReturnType();
    public DynamicMetaObject FallbackDeleteMember(DynamicMetaObject target);
    public abstract virtual DynamicMetaObject FallbackDeleteMember(DynamicMetaObject target, DynamicMetaObject errorSuggestion);
    public sealed virtual DynamicMetaObject Bind(DynamicMetaObject target, DynamicMetaObject[] args);
    internal sealed virtual bool get_IsStandardBinder();
}
public class System.Dynamic.DynamicMetaObject : object {
    private Expression _expression;
    private BindingRestrictions _restrictions;
    private object _value;
    private bool _hasValue;
    public static DynamicMetaObject[] EmptyMetaObjects;
    public Expression Expression { get; }
    public BindingRestrictions Restrictions { get; }
    public object Value { get; }
    public bool HasValue { get; }
    public Type RuntimeType { get; }
    public Type LimitType { get; }
    public DynamicMetaObject(Expression expression, BindingRestrictions restrictions);
    public DynamicMetaObject(Expression expression, BindingRestrictions restrictions, object value);
    private static DynamicMetaObject();
    public Expression get_Expression();
    public BindingRestrictions get_Restrictions();
    public object get_Value();
    public bool get_HasValue();
    public Type get_RuntimeType();
    public Type get_LimitType();
    public virtual DynamicMetaObject BindConvert(ConvertBinder binder);
    public virtual DynamicMetaObject BindGetMember(GetMemberBinder binder);
    public virtual DynamicMetaObject BindSetMember(SetMemberBinder binder, DynamicMetaObject value);
    public virtual DynamicMetaObject BindDeleteMember(DeleteMemberBinder binder);
    public virtual DynamicMetaObject BindGetIndex(GetIndexBinder binder, DynamicMetaObject[] indexes);
    public virtual DynamicMetaObject BindSetIndex(SetIndexBinder binder, DynamicMetaObject[] indexes, DynamicMetaObject value);
    public virtual DynamicMetaObject BindDeleteIndex(DeleteIndexBinder binder, DynamicMetaObject[] indexes);
    public virtual DynamicMetaObject BindInvokeMember(InvokeMemberBinder binder, DynamicMetaObject[] args);
    public virtual DynamicMetaObject BindInvoke(InvokeBinder binder, DynamicMetaObject[] args);
    public virtual DynamicMetaObject BindCreateInstance(CreateInstanceBinder binder, DynamicMetaObject[] args);
    public virtual DynamicMetaObject BindUnaryOperation(UnaryOperationBinder binder);
    public virtual DynamicMetaObject BindBinaryOperation(BinaryOperationBinder binder, DynamicMetaObject arg);
    public virtual IEnumerable`1<string> GetDynamicMemberNames();
    internal static Expression[] GetExpressions(DynamicMetaObject[] objects);
    public static DynamicMetaObject Create(object value, Expression expression);
}
public abstract class System.Dynamic.DynamicMetaObjectBinder : CallSiteBinder {
    public Type ReturnType { get; }
    internal bool IsStandardBinder { get; }
    public virtual Type get_ReturnType();
    public sealed virtual Expression Bind(Object[] args, ReadOnlyCollection`1<ParameterExpression> parameters, LabelTarget returnLabel);
    private static DynamicMetaObject[] CreateArgumentMetaObjects(Object[] args, ReadOnlyCollection`1<ParameterExpression> parameters);
    public abstract virtual DynamicMetaObject Bind(DynamicMetaObject target, DynamicMetaObject[] args);
    public Expression GetUpdateExpression(Type type);
    public DynamicMetaObject Defer(DynamicMetaObject target, DynamicMetaObject[] args);
    public DynamicMetaObject Defer(DynamicMetaObject[] args);
    private DynamicMetaObject MakeDeferred(BindingRestrictions rs, DynamicMetaObject[] args);
    internal virtual bool get_IsStandardBinder();
}
public class System.Dynamic.DynamicObject : object {
    public virtual bool TryGetMember(GetMemberBinder binder, Object& result);
    public virtual bool TrySetMember(SetMemberBinder binder, object value);
    public virtual bool TryDeleteMember(DeleteMemberBinder binder);
    public virtual bool TryInvokeMember(InvokeMemberBinder binder, Object[] args, Object& result);
    public virtual bool TryConvert(ConvertBinder binder, Object& result);
    public virtual bool TryCreateInstance(CreateInstanceBinder binder, Object[] args, Object& result);
    public virtual bool TryInvoke(InvokeBinder binder, Object[] args, Object& result);
    public virtual bool TryBinaryOperation(BinaryOperationBinder binder, object arg, Object& result);
    public virtual bool TryUnaryOperation(UnaryOperationBinder binder, Object& result);
    public virtual bool TryGetIndex(GetIndexBinder binder, Object[] indexes, Object& result);
    public virtual bool TrySetIndex(SetIndexBinder binder, Object[] indexes, object value);
    public virtual bool TryDeleteIndex(DeleteIndexBinder binder, Object[] indexes);
    public virtual IEnumerable`1<string> GetDynamicMemberNames();
    public virtual DynamicMetaObject GetMetaObject(Expression parameter);
}
internal class System.Dynamic.ExpandoClass : object {
    private String[] _keys;
    private int _hashCode;
    private Dictionary`2<int, List`1<WeakReference>> _transitions;
    private static int EmptyHashCode;
    internal static ExpandoClass Empty;
    internal String[] Keys { get; }
    internal ExpandoClass(String[] keys, int hashCode);
    private static ExpandoClass();
    internal ExpandoClass FindNewClass(string newKey);
    private List`1<WeakReference> GetTransitionList(int hashCode);
    internal int GetValueIndex(string name, bool caseInsensitive, ExpandoObject obj);
    internal int GetValueIndexCaseSensitive(string name);
    private int GetValueIndexCaseInsensitive(string name, ExpandoObject obj);
    internal String[] get_Keys();
}
public class System.Dynamic.ExpandoObject : object {
    internal object LockObject;
    private ExpandoData _data;
    private int _count;
    internal static object Uninitialized;
    internal static int AmbiguousMatchFound;
    internal static int NoMatch;
    private PropertyChangedEventHandler _propertyChanged;
    internal ExpandoClass Class { get; }
    private ICollection`1<string> System.Collections.Generic.IDictionary<System.String,System.Object>.Keys { get; }
    private ICollection`1<object> System.Collections.Generic.IDictionary<System.String,System.Object>.Values { get; }
    private object System.Collections.Generic.IDictionary<System.String,System.Object>.Item { get; private set; }
    private int System.Collections.Generic.ICollection<System.Collections.Generic.KeyValuePair<System.String,System.Object>>.Count { get; }
    private bool System.Collections.Generic.ICollection<System.Collections.Generic.KeyValuePair<System.String,System.Object>>.IsReadOnly { get; }
    private static ExpandoObject();
    internal bool TryGetValue(object indexClass, int index, string name, bool ignoreCase, Object& value);
    internal void TrySetValue(object indexClass, int index, object value, string name, bool ignoreCase, bool add);
    internal bool TryDeleteValue(object indexClass, int index, string name, bool ignoreCase, object deleteValue);
    internal bool IsDeletedMember(int index);
    internal ExpandoClass get_Class();
    private ExpandoData PromoteClassCore(ExpandoClass oldClass, ExpandoClass newClass);
    internal void PromoteClass(object oldClass, object newClass);
    private sealed virtual override DynamicMetaObject System.Dynamic.IDynamicMetaObjectProvider.GetMetaObject(Expression parameter);
    private void TryAddMember(string key, object value);
    private bool TryGetValueForKey(string key, Object& value);
    private bool ExpandoContainsKey(string key);
    private sealed virtual override ICollection`1<string> System.Collections.Generic.IDictionary<System.String,System.Object>.get_Keys();
    private sealed virtual override ICollection`1<object> System.Collections.Generic.IDictionary<System.String,System.Object>.get_Values();
    private sealed virtual override object System.Collections.Generic.IDictionary<System.String,System.Object>.get_Item(string key);
    private sealed virtual override void System.Collections.Generic.IDictionary<System.String,System.Object>.set_Item(string key, object value);
    private sealed virtual override void System.Collections.Generic.IDictionary<System.String,System.Object>.Add(string key, object value);
    private sealed virtual override bool System.Collections.Generic.IDictionary<System.String,System.Object>.ContainsKey(string key);
    private sealed virtual override bool System.Collections.Generic.IDictionary<System.String,System.Object>.Remove(string key);
    private sealed virtual override bool System.Collections.Generic.IDictionary<System.String,System.Object>.TryGetValue(string key, Object& value);
    private sealed virtual override int System.Collections.Generic.ICollection<System.Collections.Generic.KeyValuePair<System.String,System.Object>>.get_Count();
    private sealed virtual override bool System.Collections.Generic.ICollection<System.Collections.Generic.KeyValuePair<System.String,System.Object>>.get_IsReadOnly();
    private sealed virtual override void System.Collections.Generic.ICollection<System.Collections.Generic.KeyValuePair<System.String,System.Object>>.Add(KeyValuePair`2<string, object> item);
    private sealed virtual override void System.Collections.Generic.ICollection<System.Collections.Generic.KeyValuePair<System.String,System.Object>>.Clear();
    private sealed virtual override bool System.Collections.Generic.ICollection<System.Collections.Generic.KeyValuePair<System.String,System.Object>>.Contains(KeyValuePair`2<string, object> item);
    private sealed virtual override void System.Collections.Generic.ICollection<System.Collections.Generic.KeyValuePair<System.String,System.Object>>.CopyTo(KeyValuePair`2[] array, int arrayIndex);
    private sealed virtual override bool System.Collections.Generic.ICollection<System.Collections.Generic.KeyValuePair<System.String,System.Object>>.Remove(KeyValuePair`2<string, object> item);
    private sealed virtual override IEnumerator`1<KeyValuePair`2<string, object>> System.Collections.Generic.IEnumerable<System.Collections.Generic.KeyValuePair<System.String,System.Object>>.GetEnumerator();
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
    [IteratorStateMachineAttribute("System.Dynamic.ExpandoObject/<GetExpandoEnumerator>d__46")]
private IEnumerator`1<KeyValuePair`2<string, object>> GetExpandoEnumerator(ExpandoData data, int version);
    private sealed virtual override void System.ComponentModel.INotifyPropertyChanged.add_PropertyChanged(PropertyChangedEventHandler value);
    private sealed virtual override void System.ComponentModel.INotifyPropertyChanged.remove_PropertyChanged(PropertyChangedEventHandler value);
}
public abstract class System.Dynamic.GetIndexBinder : DynamicMetaObjectBinder {
    private CallInfo _callInfo;
    public Type ReturnType { get; }
    public CallInfo CallInfo { get; }
    internal bool IsStandardBinder { get; }
    protected GetIndexBinder(CallInfo callInfo);
    public sealed virtual Type get_ReturnType();
    public CallInfo get_CallInfo();
    public sealed virtual DynamicMetaObject Bind(DynamicMetaObject target, DynamicMetaObject[] args);
    internal sealed virtual bool get_IsStandardBinder();
    public DynamicMetaObject FallbackGetIndex(DynamicMetaObject target, DynamicMetaObject[] indexes);
    public abstract virtual DynamicMetaObject FallbackGetIndex(DynamicMetaObject target, DynamicMetaObject[] indexes, DynamicMetaObject errorSuggestion);
}
public abstract class System.Dynamic.GetMemberBinder : DynamicMetaObjectBinder {
    private string _name;
    private bool _ignoreCase;
    public Type ReturnType { get; }
    public string Name { get; }
    public bool IgnoreCase { get; }
    internal bool IsStandardBinder { get; }
    protected GetMemberBinder(string name, bool ignoreCase);
    public sealed virtual Type get_ReturnType();
    public string get_Name();
    public bool get_IgnoreCase();
    public DynamicMetaObject FallbackGetMember(DynamicMetaObject target);
    public abstract virtual DynamicMetaObject FallbackGetMember(DynamicMetaObject target, DynamicMetaObject errorSuggestion);
    public sealed virtual DynamicMetaObject Bind(DynamicMetaObject target, DynamicMetaObject[] args);
    internal sealed virtual bool get_IsStandardBinder();
}
public interface System.Dynamic.IDynamicMetaObjectProvider {
    public abstract virtual DynamicMetaObject GetMetaObject(Expression parameter);
}
public interface System.Dynamic.IInvokeOnGetBinder {
    public bool InvokeOnGet { get; }
    public abstract virtual bool get_InvokeOnGet();
}
public abstract class System.Dynamic.InvokeBinder : DynamicMetaObjectBinder {
    private CallInfo _callInfo;
    public Type ReturnType { get; }
    public CallInfo CallInfo { get; }
    internal bool IsStandardBinder { get; }
    protected InvokeBinder(CallInfo callInfo);
    public sealed virtual Type get_ReturnType();
    public CallInfo get_CallInfo();
    public DynamicMetaObject FallbackInvoke(DynamicMetaObject target, DynamicMetaObject[] args);
    public abstract virtual DynamicMetaObject FallbackInvoke(DynamicMetaObject target, DynamicMetaObject[] args, DynamicMetaObject errorSuggestion);
    public sealed virtual DynamicMetaObject Bind(DynamicMetaObject target, DynamicMetaObject[] args);
    internal sealed virtual bool get_IsStandardBinder();
}
public abstract class System.Dynamic.InvokeMemberBinder : DynamicMetaObjectBinder {
    private string _name;
    private bool _ignoreCase;
    private CallInfo _callInfo;
    public Type ReturnType { get; }
    public string Name { get; }
    public bool IgnoreCase { get; }
    public CallInfo CallInfo { get; }
    internal bool IsStandardBinder { get; }
    protected InvokeMemberBinder(string name, bool ignoreCase, CallInfo callInfo);
    public sealed virtual Type get_ReturnType();
    public string get_Name();
    public bool get_IgnoreCase();
    public CallInfo get_CallInfo();
    public sealed virtual DynamicMetaObject Bind(DynamicMetaObject target, DynamicMetaObject[] args);
    internal sealed virtual bool get_IsStandardBinder();
    public DynamicMetaObject FallbackInvokeMember(DynamicMetaObject target, DynamicMetaObject[] args);
    public abstract virtual DynamicMetaObject FallbackInvokeMember(DynamicMetaObject target, DynamicMetaObject[] args, DynamicMetaObject errorSuggestion);
    public abstract virtual DynamicMetaObject FallbackInvoke(DynamicMetaObject target, DynamicMetaObject[] args, DynamicMetaObject errorSuggestion);
}
public abstract class System.Dynamic.SetIndexBinder : DynamicMetaObjectBinder {
    private CallInfo _callInfo;
    public Type ReturnType { get; }
    public CallInfo CallInfo { get; }
    internal bool IsStandardBinder { get; }
    protected SetIndexBinder(CallInfo callInfo);
    public sealed virtual Type get_ReturnType();
    public CallInfo get_CallInfo();
    public sealed virtual DynamicMetaObject Bind(DynamicMetaObject target, DynamicMetaObject[] args);
    internal sealed virtual bool get_IsStandardBinder();
    public DynamicMetaObject FallbackSetIndex(DynamicMetaObject target, DynamicMetaObject[] indexes, DynamicMetaObject value);
    public abstract virtual DynamicMetaObject FallbackSetIndex(DynamicMetaObject target, DynamicMetaObject[] indexes, DynamicMetaObject value, DynamicMetaObject errorSuggestion);
}
public abstract class System.Dynamic.SetMemberBinder : DynamicMetaObjectBinder {
    private string _name;
    private bool _ignoreCase;
    public Type ReturnType { get; }
    public string Name { get; }
    public bool IgnoreCase { get; }
    internal bool IsStandardBinder { get; }
    protected SetMemberBinder(string name, bool ignoreCase);
    public sealed virtual Type get_ReturnType();
    public string get_Name();
    public bool get_IgnoreCase();
    public sealed virtual DynamicMetaObject Bind(DynamicMetaObject target, DynamicMetaObject[] args);
    internal sealed virtual bool get_IsStandardBinder();
    public DynamicMetaObject FallbackSetMember(DynamicMetaObject target, DynamicMetaObject value);
    public abstract virtual DynamicMetaObject FallbackSetMember(DynamicMetaObject target, DynamicMetaObject value, DynamicMetaObject errorSuggestion);
}
public abstract class System.Dynamic.UnaryOperationBinder : DynamicMetaObjectBinder {
    private ExpressionType _operation;
    public Type ReturnType { get; }
    public ExpressionType Operation { get; }
    internal bool IsStandardBinder { get; }
    protected UnaryOperationBinder(ExpressionType operation);
    public sealed virtual Type get_ReturnType();
    public ExpressionType get_Operation();
    public DynamicMetaObject FallbackUnaryOperation(DynamicMetaObject target);
    public abstract virtual DynamicMetaObject FallbackUnaryOperation(DynamicMetaObject target, DynamicMetaObject errorSuggestion);
    public sealed virtual DynamicMetaObject Bind(DynamicMetaObject target, DynamicMetaObject[] args);
    internal sealed virtual bool get_IsStandardBinder();
    internal static bool OperationIsValid(ExpressionType operation);
}
internal static class System.Dynamic.UpdateDelegates : object {
}
[DefaultMemberAttribute("Item")]
internal class System.Dynamic.Utils.CacheDict`2 : object {
    private int mask;
    private Entry[] entries;
    unknown TValue Item {internal set; }
    internal CacheDict`2(int size);
    private static int AlignSize(int size);
    internal bool TryGetValue(TKey key, TValue& value);
    internal void Add(TKey key, TValue value);
    internal void set_Item(TKey key, TValue value);
}
[ExtensionAttribute]
internal static class System.Dynamic.Utils.CollectionExtensions : object {
    [ExtensionAttribute]
public static T[] AddFirst(IList`1<T> list, T item);
    [ExtensionAttribute]
public static ReadOnlyCollection`1<T> ToReadOnly(IEnumerable`1<T> enumerable);
    [ExtensionAttribute]
public static int ListHashCode(IEnumerable`1<T> list);
    [ExtensionAttribute]
public static bool ListEquals(ReadOnlyCollection`1<T> first, ReadOnlyCollection`1<T> second);
    [ExtensionAttribute]
public static T[] RemoveFirst(T[] array);
    [ExtensionAttribute]
public static T[] RemoveLast(T[] array);
    [ExtensionAttribute]
public static U[] Map(ICollection`1<T> collection, Func`2<T, U> select);
    [ExtensionAttribute]
public static T[] AddLast(IList`1<T> list, T item);
    [ExtensionAttribute]
public static T First(IEnumerable`1<T> source);
}
internal static class System.Dynamic.Utils.ContractUtils : object {
    public static Exception Unreachable { get; }
    public static Exception get_Unreachable();
    public static void Requires(bool precondition, string paramName);
    public static void RequiresNotNull(object value, string paramName);
    public static void RequiresNotNull(object value, string paramName, int index);
    public static void RequiresNotEmpty(ICollection`1<T> collection, string paramName);
    public static void RequiresNotEmptyList(IReadOnlyList`1<T> collection, string paramName);
    public static void RequiresNotNullItems(IList`1<T> array, string arrayName);
    private static string GetParamName(string paramName, int index);
    public static void RequiresArrayRange(IList`1<T> array, int offset, int count, string offsetName, string countName);
    public static void Requires(bool precondition);
}
internal static class System.Dynamic.Utils.EmptyReadOnlyCollection`1 : object {
    public static ReadOnlyCollection`1<T> Instance;
    private static EmptyReadOnlyCollection`1();
}
internal static class System.Dynamic.Utils.Error : object {
    internal static Exception EnumerationIsDone();
    internal static Exception CollectionModifiedWhileEnumerating();
    internal static Exception TypeContainsGenericParameters(object p0, string paramName);
    internal static Exception TypeContainsGenericParameters(object p0, string paramName, int index);
    internal static Exception TypeIsGeneric(object p0, string paramName);
    internal static Exception TypeIsGeneric(object p0, string paramName, int index);
    internal static Exception IncorrectNumberOfConstructorArguments();
    internal static Exception ExpressionTypeDoesNotMatchMethodParameter(object p0, object p1, object p2, string paramName);
    internal static Exception ExpressionTypeDoesNotMatchMethodParameter(object p0, object p1, object p2, string paramName, int index);
    internal static Exception ExpressionTypeDoesNotMatchParameter(object p0, object p1, string paramName);
    internal static Exception ExpressionTypeDoesNotMatchParameter(object p0, object p1, string paramName, int index);
    internal static Exception IncorrectNumberOfLambdaArguments();
    internal static Exception IncorrectNumberOfMethodCallArguments(object p0, string paramName);
    internal static Exception ExpressionTypeDoesNotMatchConstructorParameter(object p0, object p1, string paramName);
    internal static Exception ExpressionTypeDoesNotMatchConstructorParameter(object p0, object p1, string paramName, int index);
    internal static Exception ExpressionMustBeReadable(string paramName);
    internal static Exception ExpressionMustBeReadable(string paramName, int index);
    private static string GetParamName(string paramName, int index);
    internal static Exception ArgCntMustBeGreaterThanNameCnt();
    internal static Exception DynamicObjectResultNotAssignable(object p0, object p1, object p2, object p3);
    internal static Exception NoOrInvalidRuleProduced();
    internal static Exception TypeParameterIsNotDelegate(object p0);
    internal static Exception FirstArgumentMustBeCallSite();
    internal static Exception OutOfRange(object p0, object p1);
    internal static Exception BinderNotCompatibleWithCallSite(object p0, object p1, object p2);
    internal static Exception DynamicBinderResultNotAssignable(object p0, object p1, object p2);
    internal static Exception DynamicBindingNeedsRestrictions(object p0, object p1);
    internal static Exception BindingCannotBeNull();
    internal static Exception TypeMustBeDerivedFromSystemDelegate();
    internal static Exception InvalidMetaObjectCreated(object p0);
    internal static Exception AmbiguousMatchInExpandoObject(object p0);
    internal static Exception SameKeyExistsInExpando(object p0);
    internal static Exception KeyDoesNotExistInExpando(object p0);
    internal static Exception CollectionReadOnly();
    internal static Exception ArgumentTypeCannotBeVoid();
}
internal static class System.Dynamic.Utils.ExpressionUtils : object {
    public static ReadOnlyCollection`1<T> ReturnReadOnly(IList`1& collection);
    public static ReadOnlyCollection`1<Expression> ReturnReadOnly(IArgumentProvider provider, Object& collection);
    public static T ReturnObject(object collectionOrT);
    public static void ValidateArgumentTypes(MethodBase method, ExpressionType nodeKind, ReadOnlyCollection`1& arguments, string methodParamName);
    public static void ValidateArgumentCount(MethodBase method, ExpressionType nodeKind, int count, ParameterInfo[] pis);
    public static Expression ValidateOneArgument(MethodBase method, ExpressionType nodeKind, Expression arguments, ParameterInfo pi, string methodParamName, string argumentParamName, int index);
    public static void RequiresCanRead(Expression expression, string paramName, int idx);
    public static bool TryQuote(Type parameterType, Expression& argument);
    internal static ParameterInfo[] GetParametersForValidation(MethodBase method, ExpressionType nodeKind);
}
internal static class System.Dynamic.Utils.ExpressionVisitorUtils : object {
    public static Expression[] VisitArguments(ExpressionVisitor visitor, IArgumentProvider nodes);
}
[DefaultMemberAttribute("Item")]
internal class System.Dynamic.Utils.ListArgumentProvider : object {
    private IArgumentProvider _provider;
    private Expression _arg0;
    public Expression Item { get; public set; }
    public int Count { get; }
    public bool IsReadOnly { get; }
    internal ListArgumentProvider(IArgumentProvider provider, Expression arg0);
    public sealed virtual int IndexOf(Expression item);
    public sealed virtual void Insert(int index, Expression item);
    public sealed virtual void RemoveAt(int index);
    public sealed virtual Expression get_Item(int index);
    public sealed virtual void set_Item(int index, Expression value);
    public sealed virtual void Add(Expression item);
    public sealed virtual void Clear();
    public sealed virtual bool Contains(Expression item);
    public sealed virtual void CopyTo(Expression[] array, int arrayIndex);
    public sealed virtual int get_Count();
    public sealed virtual bool get_IsReadOnly();
    public sealed virtual bool Remove(Expression item);
    [IteratorStateMachineAttribute("System.Dynamic.Utils.ListArgumentProvider/<GetEnumerator>d__18")]
public sealed virtual IEnumerator`1<Expression> GetEnumerator();
    [IteratorStateMachineAttribute("System.Dynamic.Utils.ListArgumentProvider/<System-Collections-IEnumerable-GetEnumerator>d__19")]
private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
}
internal static class System.Dynamic.Utils.Strings : object {
    internal static string InvalidArgumentValue { get; }
    internal static string NonEmptyCollectionRequired { get; }
    internal static string CollectionModifiedWhileEnumerating { get; }
    internal static string EnumerationIsDone { get; }
    internal static string ExpressionMustBeReadable { get; }
    internal static string IncorrectNumberOfLambdaArguments { get; }
    internal static string IncorrectNumberOfConstructorArguments { get; }
    internal static string ArgCntMustBeGreaterThanNameCnt { get; }
    internal static string NoOrInvalidRuleProduced { get; }
    internal static string FirstArgumentMustBeCallSite { get; }
    internal static string BindingCannotBeNull { get; }
    internal static string TypeMustBeDerivedFromSystemDelegate { get; }
    internal static string CollectionReadOnly { get; }
    internal static string ArgumentTypeCannotBeVoid { get; }
    internal static string MethodPreconditionViolated { get; }
    internal static string get_InvalidArgumentValue();
    internal static string get_NonEmptyCollectionRequired();
    internal static string InvalidNullValue(object p0);
    internal static string InvalidObjectType(object p0, object p1);
    internal static string TypeContainsGenericParameters(object p0);
    internal static string TypeIsGeneric(object p0);
    internal static string get_CollectionModifiedWhileEnumerating();
    internal static string get_EnumerationIsDone();
    internal static string get_ExpressionMustBeReadable();
    internal static string ExpressionTypeDoesNotMatchMethodParameter(object p0, object p1, object p2);
    internal static string ExpressionTypeDoesNotMatchParameter(object p0, object p1);
    internal static string ExpressionTypeDoesNotMatchConstructorParameter(object p0, object p1);
    internal static string IncorrectNumberOfMethodCallArguments(object p0);
    internal static string get_IncorrectNumberOfLambdaArguments();
    internal static string get_IncorrectNumberOfConstructorArguments();
    internal static string get_ArgCntMustBeGreaterThanNameCnt();
    internal static string DynamicObjectResultNotAssignable(object p0, object p1, object p2, object p3);
    internal static string get_NoOrInvalidRuleProduced();
    internal static string TypeParameterIsNotDelegate(object p0);
    internal static string get_FirstArgumentMustBeCallSite();
    internal static string OutOfRange(object p0, object p1);
    internal static string BinderNotCompatibleWithCallSite(object p0, object p1, object p2);
    internal static string DynamicBinderResultNotAssignable(object p0, object p1, object p2);
    internal static string DynamicBindingNeedsRestrictions(object p0, object p1);
    internal static string get_BindingCannotBeNull();
    internal static string get_TypeMustBeDerivedFromSystemDelegate();
    internal static string InvalidMetaObjectCreated(object p0);
    internal static string AmbiguousMatchInExpandoObject(object p0);
    internal static string SameKeyExistsInExpando(object p0);
    internal static string KeyDoesNotExistInExpando(object p0);
    internal static string get_CollectionReadOnly();
    internal static string get_ArgumentTypeCannotBeVoid();
    internal static string get_MethodPreconditionViolated();
}
[ExtensionAttribute]
internal static class System.Dynamic.Utils.TypeExtensions : object {
    private static CacheDict`2<MethodBase, ParameterInfo[]> s_paramInfoCache;
    private static TypeExtensions();
    [ExtensionAttribute]
internal static ParameterInfo[] GetParametersCached(MethodBase method);
    [ExtensionAttribute]
public static bool IsSubclassOf(Type source, Type other);
    [ExtensionAttribute]
public static Type GetReturnType(MethodBase mi);
}
[ExtensionAttribute]
internal static class System.Dynamic.Utils.TypeUtils : object {
    private static Assembly s_mscorlib;
    private static Assembly _mscorlib { get; }
    public static bool AreEquivalent(Type t1, Type t2);
    [ExtensionAttribute]
public static bool IsEquivalentTo(Type t1, Type t2);
    public static bool AreReferenceAssignable(Type dest, Type src);
    public static bool IsSameOrSubclass(Type type, Type subType);
    public static void ValidateType(Type type, string paramName);
    public static void ValidateType(Type type, string paramName, int index);
    private static Assembly get__mscorlib();
    [ExtensionAttribute]
public static bool CanCache(Type t);
}
internal class System.Linq.Expressions.Compiler.AssemblyGen : object {
    private static AssemblyGen s_assembly;
    private AssemblyBuilder _myAssembly;
    private ModuleBuilder _myModule;
    private int _index;
    private static AssemblyGen Assembly { get; }
    private static AssemblyGen get_Assembly();
    private TypeBuilder DefineType(string name, Type parent, TypeAttributes attr);
    internal static TypeBuilder DefineDelegateType(string name);
}
internal static class System.Linq.Expressions.Compiler.DelegateHelpers : object {
    private static TypeInfo _DelegateCache;
    private static int MaximumArity;
    private static DelegateHelpers();
    private static Type MakeNewCustomDelegate(Type[] types);
    private static TypeInfo NextTypeInfo(Type initialArg, TypeInfo curTypeInfo);
    private static Type TryMakeVBStyledCallSite(Type[] types);
    internal static Type MakeNewDelegate(Type[] types);
    internal static Type GetFuncType(Type[] types);
    internal static Type GetActionType(Type[] types);
    internal static Type MakeCallSiteDelegate(ReadOnlyCollection`1<Expression> types, Type returnType);
    internal static Type MakeDeferredSiteDelegate(DynamicMetaObject[] args, Type returnType);
    private static bool IsByRef(DynamicMetaObject mo);
    internal static TypeInfo NextTypeInfo(Type initialArg);
    internal static TypeInfo GetNextTypeInfo(Type initialArg, TypeInfo curTypeInfo);
}
[ExtensionAttribute]
internal static class System.Linq.Expressions.Compiler.TypeInfoExtensions : object {
    [ExtensionAttribute]
public static Type MakeDelegateType(TypeInfo info, Type retType, Expression[] args);
    [ExtensionAttribute]
public static Type MakeDelegateType(TypeInfo info, Type retType, IList`1<Expression> args);
}
public class System.Linq.Expressions.DynamicExpression : Expression {
    private CallSiteBinder _binder;
    private Type _delegateType;
    public bool CanReduce { get; }
    public Type Type { get; }
    public ExpressionType NodeType { get; }
    public CallSiteBinder Binder { get; }
    public Type DelegateType { get; }
    public ReadOnlyCollection`1<Expression> Arguments { get; }
    private int System.Linq.Expressions.IArgumentProvider.ArgumentCount { get; }
    internal DynamicExpression(Type delegateType, CallSiteBinder binder);
    public virtual bool get_CanReduce();
    public virtual Expression Reduce();
    internal static DynamicExpression Make(Type returnType, Type delegateType, CallSiteBinder binder, ReadOnlyCollection`1<Expression> arguments);
    internal static DynamicExpression Make(Type returnType, Type delegateType, CallSiteBinder binder, Expression arg0);
    internal static DynamicExpression Make(Type returnType, Type delegateType, CallSiteBinder binder, Expression arg0, Expression arg1);
    internal static DynamicExpression Make(Type returnType, Type delegateType, CallSiteBinder binder, Expression arg0, Expression arg1, Expression arg2);
    internal static DynamicExpression Make(Type returnType, Type delegateType, CallSiteBinder binder, Expression arg0, Expression arg1, Expression arg2, Expression arg3);
    public virtual Type get_Type();
    public sealed virtual ExpressionType get_NodeType();
    public CallSiteBinder get_Binder();
    public sealed virtual Type get_DelegateType();
    public ReadOnlyCollection`1<Expression> get_Arguments();
    internal virtual ReadOnlyCollection`1<Expression> GetOrMakeArguments();
    protected virtual Expression Accept(ExpressionVisitor visitor);
    internal virtual DynamicExpression Rewrite(Expression[] args);
    public DynamicExpression Update(IEnumerable`1<Expression> arguments);
    private sealed virtual override Expression System.Linq.Expressions.IArgumentProvider.GetArgument(int index);
    private sealed virtual override int System.Linq.Expressions.IArgumentProvider.get_ArgumentCount();
    public static DynamicExpression Dynamic(CallSiteBinder binder, Type returnType, Expression[] arguments);
    public static DynamicExpression Dynamic(CallSiteBinder binder, Type returnType, IEnumerable`1<Expression> arguments);
    public static DynamicExpression Dynamic(CallSiteBinder binder, Type returnType, Expression arg0);
    public static DynamicExpression Dynamic(CallSiteBinder binder, Type returnType, Expression arg0, Expression arg1);
    public static DynamicExpression Dynamic(CallSiteBinder binder, Type returnType, Expression arg0, Expression arg1, Expression arg2);
    public static DynamicExpression Dynamic(CallSiteBinder binder, Type returnType, Expression arg0, Expression arg1, Expression arg2, Expression arg3);
    public static DynamicExpression MakeDynamic(Type delegateType, CallSiteBinder binder, IEnumerable`1<Expression> arguments);
    public static DynamicExpression MakeDynamic(Type delegateType, CallSiteBinder binder, Expression[] arguments);
    public static DynamicExpression MakeDynamic(Type delegateType, CallSiteBinder binder, Expression arg0);
    public static DynamicExpression MakeDynamic(Type delegateType, CallSiteBinder binder, Expression arg0, Expression arg1);
    public static DynamicExpression MakeDynamic(Type delegateType, CallSiteBinder binder, Expression arg0, Expression arg1, Expression arg2);
    public static DynamicExpression MakeDynamic(Type delegateType, CallSiteBinder binder, Expression arg0, Expression arg1, Expression arg2, Expression arg3);
    private sealed virtual override Expression System.Linq.Expressions.IDynamicExpression.Rewrite(Expression[] args);
    private sealed virtual override object System.Linq.Expressions.IDynamicExpression.CreateCallSite();
}
internal class System.Linq.Expressions.DynamicExpression1 : DynamicExpression {
    private object _arg0;
    private int System.Linq.Expressions.IArgumentProvider.ArgumentCount { get; }
    internal DynamicExpression1(Type delegateType, CallSiteBinder binder, Expression arg0);
    private sealed virtual override Expression System.Linq.Expressions.IArgumentProvider.GetArgument(int index);
    private sealed virtual override int System.Linq.Expressions.IArgumentProvider.get_ArgumentCount();
    internal virtual ReadOnlyCollection`1<Expression> GetOrMakeArguments();
    internal virtual DynamicExpression Rewrite(Expression[] args);
}
internal class System.Linq.Expressions.DynamicExpression2 : DynamicExpression {
    private object _arg0;
    private Expression _arg1;
    private int System.Linq.Expressions.IArgumentProvider.ArgumentCount { get; }
    internal DynamicExpression2(Type delegateType, CallSiteBinder binder, Expression arg0, Expression arg1);
    private sealed virtual override Expression System.Linq.Expressions.IArgumentProvider.GetArgument(int index);
    private sealed virtual override int System.Linq.Expressions.IArgumentProvider.get_ArgumentCount();
    internal virtual ReadOnlyCollection`1<Expression> GetOrMakeArguments();
    internal virtual DynamicExpression Rewrite(Expression[] args);
}
internal class System.Linq.Expressions.DynamicExpression3 : DynamicExpression {
    private object _arg0;
    private Expression _arg1;
    private Expression _arg2;
    private int System.Linq.Expressions.IArgumentProvider.ArgumentCount { get; }
    internal DynamicExpression3(Type delegateType, CallSiteBinder binder, Expression arg0, Expression arg1, Expression arg2);
    private sealed virtual override Expression System.Linq.Expressions.IArgumentProvider.GetArgument(int index);
    private sealed virtual override int System.Linq.Expressions.IArgumentProvider.get_ArgumentCount();
    internal virtual ReadOnlyCollection`1<Expression> GetOrMakeArguments();
    internal virtual DynamicExpression Rewrite(Expression[] args);
}
internal class System.Linq.Expressions.DynamicExpression4 : DynamicExpression {
    private object _arg0;
    private Expression _arg1;
    private Expression _arg2;
    private Expression _arg3;
    private int System.Linq.Expressions.IArgumentProvider.ArgumentCount { get; }
    internal DynamicExpression4(Type delegateType, CallSiteBinder binder, Expression arg0, Expression arg1, Expression arg2, Expression arg3);
    private sealed virtual override Expression System.Linq.Expressions.IArgumentProvider.GetArgument(int index);
    private sealed virtual override int System.Linq.Expressions.IArgumentProvider.get_ArgumentCount();
    internal virtual ReadOnlyCollection`1<Expression> GetOrMakeArguments();
    internal virtual DynamicExpression Rewrite(Expression[] args);
}
internal class System.Linq.Expressions.DynamicExpressionN : DynamicExpression {
    private IList`1<Expression> _arguments;
    private int System.Linq.Expressions.IArgumentProvider.ArgumentCount { get; }
    internal DynamicExpressionN(Type delegateType, CallSiteBinder binder, IList`1<Expression> arguments);
    private sealed virtual override Expression System.Linq.Expressions.IArgumentProvider.GetArgument(int index);
    private sealed virtual override int System.Linq.Expressions.IArgumentProvider.get_ArgumentCount();
    internal virtual ReadOnlyCollection`1<Expression> GetOrMakeArguments();
    internal virtual DynamicExpression Rewrite(Expression[] args);
}
public class System.Linq.Expressions.DynamicExpressionVisitor : ExpressionVisitor {
    protected internal virtual Expression VisitDynamic(DynamicExpression node);
}
internal class System.Linq.Expressions.ExpressionExtension : object {
    public static DynamicExpression MakeDynamic(Type delegateType, CallSiteBinder binder, Expression[] arguments);
    public static DynamicExpression MakeDynamic(Type delegateType, CallSiteBinder binder, IEnumerable`1<Expression> arguments);
    public static DynamicExpression MakeDynamic(Type delegateType, CallSiteBinder binder, Expression arg0);
    public static DynamicExpression MakeDynamic(Type delegateType, CallSiteBinder binder, Expression arg0, Expression arg1);
    public static DynamicExpression MakeDynamic(Type delegateType, CallSiteBinder binder, Expression arg0, Expression arg1, Expression arg2);
    public static DynamicExpression MakeDynamic(Type delegateType, CallSiteBinder binder, Expression arg0, Expression arg1, Expression arg2, Expression arg3);
    private static MethodInfo GetValidMethodForDynamic(Type delegateType);
    public static DynamicExpression Dynamic(CallSiteBinder binder, Type returnType, Expression[] arguments);
    public static DynamicExpression Dynamic(CallSiteBinder binder, Type returnType, Expression arg0);
    public static DynamicExpression Dynamic(CallSiteBinder binder, Type returnType, Expression arg0, Expression arg1);
    public static DynamicExpression Dynamic(CallSiteBinder binder, Type returnType, Expression arg0, Expression arg1, Expression arg2);
    public static DynamicExpression Dynamic(CallSiteBinder binder, Type returnType, Expression arg0, Expression arg1, Expression arg2, Expression arg3);
    public static DynamicExpression Dynamic(CallSiteBinder binder, Type returnType, IEnumerable`1<Expression> arguments);
    private static DynamicExpression MakeDynamic(CallSiteBinder binder, Type returnType, ReadOnlyCollection`1<Expression> args);
    private static void ValidateDynamicArgument(Expression arg, string paramName);
    private static void ValidateDynamicArgument(Expression arg, string paramName, int index);
}
internal class System.Linq.Expressions.TypedDynamicExpression1 : DynamicExpression1 {
    private Type _retType;
    public Type Type { get; }
    internal TypedDynamicExpression1(Type retType, Type delegateType, CallSiteBinder binder, Expression arg0);
    public sealed virtual Type get_Type();
}
internal class System.Linq.Expressions.TypedDynamicExpression2 : DynamicExpression2 {
    private Type _retType;
    public Type Type { get; }
    internal TypedDynamicExpression2(Type retType, Type delegateType, CallSiteBinder binder, Expression arg0, Expression arg1);
    public sealed virtual Type get_Type();
}
internal class System.Linq.Expressions.TypedDynamicExpression3 : DynamicExpression3 {
    private Type _retType;
    public Type Type { get; }
    internal TypedDynamicExpression3(Type retType, Type delegateType, CallSiteBinder binder, Expression arg0, Expression arg1, Expression arg2);
    public sealed virtual Type get_Type();
}
internal class System.Linq.Expressions.TypedDynamicExpression4 : DynamicExpression4 {
    private Type _retType;
    public Type Type { get; }
    internal TypedDynamicExpression4(Type retType, Type delegateType, CallSiteBinder binder, Expression arg0, Expression arg1, Expression arg2, Expression arg3);
    public sealed virtual Type get_Type();
}
internal class System.Linq.Expressions.TypedDynamicExpressionN : DynamicExpressionN {
    private Type _returnType;
    public Type Type { get; }
    internal TypedDynamicExpressionN(Type returnType, Type delegateType, CallSiteBinder binder, IList`1<Expression> arguments);
    public sealed virtual Type get_Type();
}
public class System.Runtime.CompilerServices.CallSite : object {
    private static CacheDict`2 modreq(System.Runtime.CompilerServices.IsVolatile) s_siteCtors;
    internal CallSiteBinder _binder;
    internal bool _match;
    public CallSiteBinder Binder { get; }
    internal CallSite(CallSiteBinder binder);
    public CallSiteBinder get_Binder();
    public static CallSite Create(Type delegateType, CallSiteBinder binder);
}
public class System.Runtime.CompilerServices.CallSite`1 : CallSite {
    public T Target;
    internal T[] Rules;
    private static T s_cachedUpdate;
    private static T modreq(System.Runtime.CompilerServices.IsVolatile) s_cachedNoMatch;
    private static int MaxRules;
    public T Update { get; }
    private CallSite`1(CallSiteBinder binder);
    public T get_Update();
    internal CallSite`1<T> CreateMatchMaker();
    public static CallSite`1<T> Create(CallSiteBinder binder);
    private T GetUpdateDelegate();
    private T GetUpdateDelegate(T& addr);
    private void ClearRuleCache();
    internal void AddRule(T newRule);
    internal void MoveRule(int i);
    internal T MakeUpdateDelegate();
    private T CreateCustomUpdateDelegate(MethodInfo invoke);
    private T CreateCustomNoMatchDelegate(MethodInfo invoke);
    private static Expression Convert(Expression arg, Type type);
}
public abstract class System.Runtime.CompilerServices.CallSiteBinder : object {
    private static LabelTarget s_updateLabel;
    internal Dictionary`2<Type, object> Cache;
    public static LabelTarget UpdateLabel { get; }
    private static CallSiteBinder();
    public static LabelTarget get_UpdateLabel();
    public abstract virtual Expression Bind(Object[] args, ReadOnlyCollection`1<ParameterExpression> parameters, LabelTarget returnLabel);
    public virtual T BindDelegate(CallSite`1<T> site, Object[] args);
    internal T BindCore(CallSite`1<T> site, Object[] args);
    protected void CacheTarget(T target);
    private static Expression`1<T> Stitch(Expression binding, LambdaSignature`1<T> signature);
    internal RuleCache`1<T> GetRuleCache();
}
public static class System.Runtime.CompilerServices.CallSiteHelpers : object {
    private static Type s_knownNonDynamicMethodType;
    private static CallSiteHelpers();
    public static bool IsInternalFrame(MethodBase mb);
}
[EditorBrowsableAttribute("1")]
[DebuggerStepThroughAttribute]
public static class System.Runtime.CompilerServices.CallSiteOps : object {
    [ObsoleteAttribute("do not use this method", "True")]
[EditorBrowsableAttribute("1")]
public static CallSite`1<T> CreateMatchmaker(CallSite`1<T> site);
    [ObsoleteAttribute("do not use this method", "True")]
[EditorBrowsableAttribute("1")]
public static bool SetNotMatched(CallSite site);
    [ObsoleteAttribute("do not use this method", "True")]
[EditorBrowsableAttribute("1")]
public static bool GetMatch(CallSite site);
    [ObsoleteAttribute("do not use this method", "True")]
[EditorBrowsableAttribute("1")]
public static void ClearMatch(CallSite site);
    [ObsoleteAttribute("do not use this method", "True")]
[EditorBrowsableAttribute("1")]
public static void AddRule(CallSite`1<T> site, T rule);
    [ObsoleteAttribute("do not use this method", "True")]
[EditorBrowsableAttribute("1")]
public static void UpdateRules(CallSite`1<T> this, int matched);
    [ObsoleteAttribute("do not use this method", "True")]
[EditorBrowsableAttribute("1")]
public static T[] GetRules(CallSite`1<T> site);
    [ObsoleteAttribute("do not use this method", "True")]
[EditorBrowsableAttribute("1")]
public static RuleCache`1<T> GetRuleCache(CallSite`1<T> site);
    [ObsoleteAttribute("do not use this method", "True")]
[EditorBrowsableAttribute("1")]
public static void MoveRule(RuleCache`1<T> cache, T rule, int i);
    [ObsoleteAttribute("do not use this method", "True")]
[EditorBrowsableAttribute("1")]
public static T[] GetCachedRules(RuleCache`1<T> cache);
    [ObsoleteAttribute("do not use this method", "True")]
[EditorBrowsableAttribute("1")]
public static T Bind(CallSiteBinder binder, CallSite`1<T> site, Object[] args);
}
[AttributeUsageAttribute("10636")]
public class System.Runtime.CompilerServices.DynamicAttribute : Attribute {
    private Boolean[] _transformFlags;
    public IList`1<bool> TransformFlags { get; }
    public DynamicAttribute(Boolean[] transformFlags);
    public IList`1<bool> get_TransformFlags();
}
[DefaultMemberAttribute("Item")]
internal class System.Runtime.CompilerServices.ReadOnlyCollectionBuilder`1 : object {
    private static int DefaultCapacity;
    private T[] _items;
    private int _size;
    private int _version;
    private object _syncRoot;
    public int Capacity { get; public set; }
    public int Count { get; }
    public T Item { get; public set; }
    private bool System.Collections.Generic.ICollection<T>.IsReadOnly { get; }
    private bool System.Collections.IList.IsReadOnly { get; }
    private bool System.Collections.IList.IsFixedSize { get; }
    private object System.Collections.IList.Item { get; private set; }
    private bool System.Collections.ICollection.IsSynchronized { get; }
    private object System.Collections.ICollection.SyncRoot { get; }
    public ReadOnlyCollectionBuilder`1(int capacity);
    public ReadOnlyCollectionBuilder`1(IEnumerable`1<T> collection);
    public int get_Capacity();
    public void set_Capacity(int value);
    public sealed virtual int get_Count();
    public sealed virtual int IndexOf(T item);
    public sealed virtual void Insert(int index, T item);
    public sealed virtual void RemoveAt(int index);
    public sealed virtual T get_Item(int index);
    public sealed virtual void set_Item(int index, T value);
    public sealed virtual void Add(T item);
    public sealed virtual void Clear();
    public sealed virtual bool Contains(T item);
    public sealed virtual void CopyTo(T[] array, int arrayIndex);
    private sealed virtual override bool System.Collections.Generic.ICollection<T>.get_IsReadOnly();
    public sealed virtual bool Remove(T item);
    public sealed virtual IEnumerator`1<T> GetEnumerator();
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
    private sealed virtual override bool System.Collections.IList.get_IsReadOnly();
    private sealed virtual override int System.Collections.IList.Add(object value);
    private sealed virtual override bool System.Collections.IList.Contains(object value);
    private sealed virtual override int System.Collections.IList.IndexOf(object value);
    private sealed virtual override void System.Collections.IList.Insert(int index, object value);
    private sealed virtual override bool System.Collections.IList.get_IsFixedSize();
    private sealed virtual override void System.Collections.IList.Remove(object value);
    private sealed virtual override object System.Collections.IList.get_Item(int index);
    private sealed virtual override void System.Collections.IList.set_Item(int index, object value);
    private sealed virtual override void System.Collections.ICollection.CopyTo(Array array, int index);
    private sealed virtual override bool System.Collections.ICollection.get_IsSynchronized();
    private sealed virtual override object System.Collections.ICollection.get_SyncRoot();
    public void Reverse();
    public void Reverse(int index, int count);
    public T[] ToArray();
    public ReadOnlyCollection`1<T> ToReadOnlyCollection();
    private void EnsureCapacity(int min);
    private static bool IsCompatibleObject(object value);
    private static void ValidateNullValue(object value, string argument);
    private static void ThrowInvalidTypeException(object value, string argument);
}
[EditorBrowsableAttribute("1")]
[DebuggerStepThroughAttribute]
public class System.Runtime.CompilerServices.RuleCache`1 : object {
    private T[] _rules;
    private object _cacheLock;
    private static int MaxRules;
    private static int InsertPosition;
    internal T[] GetRules();
    internal void MoveRule(T rule, int i);
    internal void AddRule(T newRule);
    internal void ReplaceRule(T oldRule, T newRule);
    private static T[] AddOrInsert(T[] rules, T item);
}
public static class System.Runtime.CompilerServices.RuntimeOps : object {
    [ObsoleteAttribute("do not use this method", "True")]
[EditorBrowsableAttribute("1")]
public static bool ExpandoTryGetValue(ExpandoObject expando, object indexClass, int index, string name, bool ignoreCase, Object& value);
    [ObsoleteAttribute("do not use this method", "True")]
[EditorBrowsableAttribute("1")]
public static object ExpandoTrySetValue(ExpandoObject expando, object indexClass, int index, object value, string name, bool ignoreCase);
    [ObsoleteAttribute("do not use this method", "True")]
[EditorBrowsableAttribute("1")]
public static bool ExpandoTryDeleteValue(ExpandoObject expando, object indexClass, int index, string name, bool ignoreCase);
    [ObsoleteAttribute("do not use this method", "True")]
[EditorBrowsableAttribute("1")]
public static bool ExpandoCheckVersion(ExpandoObject expando, object version);
    [ObsoleteAttribute("do not use this method", "True")]
[EditorBrowsableAttribute("1")]
public static void ExpandoPromoteClass(ExpandoObject expando, object oldClass, object newClass);
}
internal class System.Runtime.CompilerServices.TrueReadOnlyCollection`1 : ReadOnlyCollection`1<T> {
    public TrueReadOnlyCollection`1(T[] list);
}
internal static class System.SR : object {
    private static ResourceManager s_resourceManager;
    private static string s_resourcesName;
    private static ResourceManager ResourceManager { get; }
    internal static string ArgCntMustBeGreaterThanNameCnt { get; }
    internal static string DynamicObjectResultNotAssignable { get; }
    internal static string NoOrInvalidRuleProduced { get; }
    internal static string TypeParameterIsNotDelegate { get; }
    internal static string FirstArgumentMustBeCallSite { get; }
    internal static string OutOfRange { get; }
    internal static string BinderNotCompatibleWithCallSite { get; }
    internal static string DynamicBinderResultNotAssignable { get; }
    internal static string DynamicBindingNeedsRestrictions { get; }
    internal static string BindingCannotBeNull { get; }
    internal static string TypeMustBeDerivedFromSystemDelegate { get; }
    internal static string InvalidMetaObjectCreated { get; }
    internal static string AmbiguousMatchInExpandoObject { get; }
    internal static string SameKeyExistsInExpando { get; }
    internal static string KeyDoesNotExistInExpando { get; }
    internal static string CollectionModifiedWhileEnumerating { get; }
    internal static string CollectionReadOnly { get; }
    internal static string ArgumentTypeCannotBeVoid { get; }
    internal static string MethodPreconditionViolated { get; }
    internal static string InvalidArgumentValue { get; }
    internal static string NonEmptyCollectionRequired { get; }
    internal static string InvalidNullValue { get; }
    internal static string InvalidObjectType { get; }
    internal static string TypeContainsGenericParameters { get; }
    internal static string TypeIsGeneric { get; }
    internal static string EnumerationIsDone { get; }
    internal static string ExpressionMustBeReadable { get; }
    internal static string ExpressionTypeDoesNotMatchMethodParameter { get; }
    internal static string ExpressionTypeDoesNotMatchParameter { get; }
    internal static string ExpressionTypeDoesNotMatchConstructorParameter { get; }
    internal static string IncorrectNumberOfMethodCallArguments { get; }
    internal static string IncorrectNumberOfLambdaArguments { get; }
    internal static string IncorrectNumberOfConstructorArguments { get; }
    internal static Type ResourceType { get; }
    private static ResourceManager get_ResourceManager();
    private static bool UsingResourceKeys();
    internal static string GetResourceString(string resourceKey, string defaultString);
    internal static string Format(string resourceFormat, Object[] args);
    internal static string Format(string resourceFormat, object p1);
    internal static string Format(string resourceFormat, object p1, object p2);
    internal static string Format(string resourceFormat, object p1, object p2, object p3);
    internal static string get_ArgCntMustBeGreaterThanNameCnt();
    internal static string get_DynamicObjectResultNotAssignable();
    internal static string get_NoOrInvalidRuleProduced();
    internal static string get_TypeParameterIsNotDelegate();
    internal static string get_FirstArgumentMustBeCallSite();
    internal static string get_OutOfRange();
    internal static string get_BinderNotCompatibleWithCallSite();
    internal static string get_DynamicBinderResultNotAssignable();
    internal static string get_DynamicBindingNeedsRestrictions();
    internal static string get_BindingCannotBeNull();
    internal static string get_TypeMustBeDerivedFromSystemDelegate();
    internal static string get_InvalidMetaObjectCreated();
    internal static string get_AmbiguousMatchInExpandoObject();
    internal static string get_SameKeyExistsInExpando();
    internal static string get_KeyDoesNotExistInExpando();
    internal static string get_CollectionModifiedWhileEnumerating();
    internal static string get_CollectionReadOnly();
    internal static string get_ArgumentTypeCannotBeVoid();
    internal static string get_MethodPreconditionViolated();
    internal static string get_InvalidArgumentValue();
    internal static string get_NonEmptyCollectionRequired();
    internal static string get_InvalidNullValue();
    internal static string get_InvalidObjectType();
    internal static string get_TypeContainsGenericParameters();
    internal static string get_TypeIsGeneric();
    internal static string get_EnumerationIsDone();
    internal static string get_ExpressionMustBeReadable();
    internal static string get_ExpressionTypeDoesNotMatchMethodParameter();
    internal static string get_ExpressionTypeDoesNotMatchParameter();
    internal static string get_ExpressionTypeDoesNotMatchConstructorParameter();
    internal static string get_IncorrectNumberOfMethodCallArguments();
    internal static string get_IncorrectNumberOfLambdaArguments();
    internal static string get_IncorrectNumberOfConstructorArguments();
    internal static Type get_ResourceType();
}
