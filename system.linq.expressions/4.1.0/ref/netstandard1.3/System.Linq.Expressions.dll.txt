public class System.Linq.Expressions.BinaryExpression : Expression {
    public bool CanReduce { get; }
    public LambdaExpression Conversion { get; }
    public bool IsLifted { get; }
    public bool IsLiftedToNull { get; }
    public Expression Left { get; }
    public MethodInfo Method { get; }
    public Expression Right { get; }
    public virtual bool get_CanReduce();
    public LambdaExpression get_Conversion();
    public bool get_IsLifted();
    public bool get_IsLiftedToNull();
    public Expression get_Left();
    public MethodInfo get_Method();
    public Expression get_Right();
    protected internal virtual Expression Accept(ExpressionVisitor visitor);
    public virtual Expression Reduce();
    public BinaryExpression Update(Expression left, LambdaExpression conversion, Expression right);
}
public class System.Linq.Expressions.BlockExpression : Expression {
    public ReadOnlyCollection`1<Expression> Expressions { get; }
    public ExpressionType NodeType { get; }
    public Expression Result { get; }
    public Type Type { get; }
    public ReadOnlyCollection`1<ParameterExpression> Variables { get; }
    public ReadOnlyCollection`1<Expression> get_Expressions();
    public sealed virtual ExpressionType get_NodeType();
    public Expression get_Result();
    public virtual Type get_Type();
    public ReadOnlyCollection`1<ParameterExpression> get_Variables();
    protected internal virtual Expression Accept(ExpressionVisitor visitor);
    public BlockExpression Update(IEnumerable`1<ParameterExpression> variables, IEnumerable`1<Expression> expressions);
}
public class System.Linq.Expressions.CatchBlock : object {
    public Expression Body { get; }
    public Expression Filter { get; }
    public Type Test { get; }
    public ParameterExpression Variable { get; }
    public Expression get_Body();
    public Expression get_Filter();
    public Type get_Test();
    public ParameterExpression get_Variable();
    public virtual string ToString();
    public CatchBlock Update(ParameterExpression variable, Expression filter, Expression body);
}
public class System.Linq.Expressions.ConditionalExpression : Expression {
    public Expression IfFalse { get; }
    public Expression IfTrue { get; }
    public ExpressionType NodeType { get; }
    public Expression Test { get; }
    public Type Type { get; }
    public Expression get_IfFalse();
    public Expression get_IfTrue();
    public sealed virtual ExpressionType get_NodeType();
    public Expression get_Test();
    public virtual Type get_Type();
    protected internal virtual Expression Accept(ExpressionVisitor visitor);
    public ConditionalExpression Update(Expression test, Expression ifTrue, Expression ifFalse);
}
public class System.Linq.Expressions.ConstantExpression : Expression {
    public ExpressionType NodeType { get; }
    public Type Type { get; }
    public object Value { get; }
    public sealed virtual ExpressionType get_NodeType();
    public virtual Type get_Type();
    public object get_Value();
    protected internal virtual Expression Accept(ExpressionVisitor visitor);
}
public class System.Linq.Expressions.DebugInfoExpression : Expression {
    public SymbolDocumentInfo Document { get; }
    public int EndColumn { get; }
    public int EndLine { get; }
    public bool IsClear { get; }
    public ExpressionType NodeType { get; }
    public int StartColumn { get; }
    public int StartLine { get; }
    public Type Type { get; }
    public SymbolDocumentInfo get_Document();
    public virtual int get_EndColumn();
    public virtual int get_EndLine();
    public virtual bool get_IsClear();
    public sealed virtual ExpressionType get_NodeType();
    public virtual int get_StartColumn();
    public virtual int get_StartLine();
    public sealed virtual Type get_Type();
    protected internal virtual Expression Accept(ExpressionVisitor visitor);
}
public class System.Linq.Expressions.DefaultExpression : Expression {
    public ExpressionType NodeType { get; }
    public Type Type { get; }
    public sealed virtual ExpressionType get_NodeType();
    public sealed virtual Type get_Type();
    protected internal virtual Expression Accept(ExpressionVisitor visitor);
}
public class System.Linq.Expressions.ElementInit : object {
    public MethodInfo AddMethod { get; }
    public ReadOnlyCollection`1<Expression> Arguments { get; }
    private int System.Linq.Expressions.IArgumentProvider.ArgumentCount { get; }
    public MethodInfo get_AddMethod();
    public ReadOnlyCollection`1<Expression> get_Arguments();
    private sealed virtual override int System.Linq.Expressions.IArgumentProvider.get_ArgumentCount();
    private sealed virtual override Expression System.Linq.Expressions.IArgumentProvider.GetArgument(int index);
    public virtual string ToString();
    public ElementInit Update(IEnumerable`1<Expression> arguments);
}
public abstract class System.Linq.Expressions.Expression : object {
    public bool CanReduce { get; }
    public ExpressionType NodeType { get; }
    public Type Type { get; }
    public virtual bool get_CanReduce();
    public virtual ExpressionType get_NodeType();
    public virtual Type get_Type();
    protected internal virtual Expression Accept(ExpressionVisitor visitor);
    public static BinaryExpression Add(Expression left, Expression right);
    public static BinaryExpression Add(Expression left, Expression right, MethodInfo method);
    public static BinaryExpression AddAssign(Expression left, Expression right);
    public static BinaryExpression AddAssign(Expression left, Expression right, MethodInfo method);
    public static BinaryExpression AddAssign(Expression left, Expression right, MethodInfo method, LambdaExpression conversion);
    public static BinaryExpression AddAssignChecked(Expression left, Expression right);
    public static BinaryExpression AddAssignChecked(Expression left, Expression right, MethodInfo method);
    public static BinaryExpression AddAssignChecked(Expression left, Expression right, MethodInfo method, LambdaExpression conversion);
    public static BinaryExpression AddChecked(Expression left, Expression right);
    public static BinaryExpression AddChecked(Expression left, Expression right, MethodInfo method);
    public static BinaryExpression And(Expression left, Expression right);
    public static BinaryExpression And(Expression left, Expression right, MethodInfo method);
    public static BinaryExpression AndAlso(Expression left, Expression right);
    public static BinaryExpression AndAlso(Expression left, Expression right, MethodInfo method);
    public static BinaryExpression AndAssign(Expression left, Expression right);
    public static BinaryExpression AndAssign(Expression left, Expression right, MethodInfo method);
    public static BinaryExpression AndAssign(Expression left, Expression right, MethodInfo method, LambdaExpression conversion);
    public static IndexExpression ArrayAccess(Expression array, IEnumerable`1<Expression> indexes);
    public static IndexExpression ArrayAccess(Expression array, Expression[] indexes);
    public static MethodCallExpression ArrayIndex(Expression array, IEnumerable`1<Expression> indexes);
    public static BinaryExpression ArrayIndex(Expression array, Expression index);
    public static MethodCallExpression ArrayIndex(Expression array, Expression[] indexes);
    public static UnaryExpression ArrayLength(Expression array);
    public static BinaryExpression Assign(Expression left, Expression right);
    public static MemberAssignment Bind(MemberInfo member, Expression expression);
    public static MemberAssignment Bind(MethodInfo propertyAccessor, Expression expression);
    public static BlockExpression Block(IEnumerable`1<Expression> expressions);
    public static BlockExpression Block(IEnumerable`1<ParameterExpression> variables, IEnumerable`1<Expression> expressions);
    public static BlockExpression Block(IEnumerable`1<ParameterExpression> variables, Expression[] expressions);
    public static BlockExpression Block(Expression arg0, Expression arg1);
    public static BlockExpression Block(Expression arg0, Expression arg1, Expression arg2);
    public static BlockExpression Block(Expression arg0, Expression arg1, Expression arg2, Expression arg3);
    public static BlockExpression Block(Expression arg0, Expression arg1, Expression arg2, Expression arg3, Expression arg4);
    public static BlockExpression Block(Expression[] expressions);
    public static BlockExpression Block(Type type, IEnumerable`1<Expression> expressions);
    public static BlockExpression Block(Type type, IEnumerable`1<ParameterExpression> variables, IEnumerable`1<Expression> expressions);
    public static BlockExpression Block(Type type, IEnumerable`1<ParameterExpression> variables, Expression[] expressions);
    public static BlockExpression Block(Type type, Expression[] expressions);
    public static GotoExpression Break(LabelTarget target);
    public static GotoExpression Break(LabelTarget target, Expression value);
    public static GotoExpression Break(LabelTarget target, Expression value, Type type);
    public static GotoExpression Break(LabelTarget target, Type type);
    public static MethodCallExpression Call(Expression instance, MethodInfo method);
    public static MethodCallExpression Call(Expression instance, MethodInfo method, IEnumerable`1<Expression> arguments);
    public static MethodCallExpression Call(Expression instance, MethodInfo method, Expression arg0, Expression arg1);
    public static MethodCallExpression Call(Expression instance, MethodInfo method, Expression arg0, Expression arg1, Expression arg2);
    public static MethodCallExpression Call(Expression instance, MethodInfo method, Expression[] arguments);
    public static MethodCallExpression Call(Expression instance, string methodName, Type[] typeArguments, Expression[] arguments);
    public static MethodCallExpression Call(MethodInfo method, IEnumerable`1<Expression> arguments);
    public static MethodCallExpression Call(MethodInfo method, Expression arg0);
    public static MethodCallExpression Call(MethodInfo method, Expression arg0, Expression arg1);
    public static MethodCallExpression Call(MethodInfo method, Expression arg0, Expression arg1, Expression arg2);
    public static MethodCallExpression Call(MethodInfo method, Expression arg0, Expression arg1, Expression arg2, Expression arg3);
    public static MethodCallExpression Call(MethodInfo method, Expression arg0, Expression arg1, Expression arg2, Expression arg3, Expression arg4);
    public static MethodCallExpression Call(MethodInfo method, Expression[] arguments);
    public static MethodCallExpression Call(Type type, string methodName, Type[] typeArguments, Expression[] arguments);
    public static CatchBlock Catch(ParameterExpression variable, Expression body);
    public static CatchBlock Catch(ParameterExpression variable, Expression body, Expression filter);
    public static CatchBlock Catch(Type type, Expression body);
    public static CatchBlock Catch(Type type, Expression body, Expression filter);
    public static DebugInfoExpression ClearDebugInfo(SymbolDocumentInfo document);
    public static BinaryExpression Coalesce(Expression left, Expression right);
    public static BinaryExpression Coalesce(Expression left, Expression right, LambdaExpression conversion);
    public static ConditionalExpression Condition(Expression test, Expression ifTrue, Expression ifFalse);
    public static ConditionalExpression Condition(Expression test, Expression ifTrue, Expression ifFalse, Type type);
    public static ConstantExpression Constant(object value);
    public static ConstantExpression Constant(object value, Type type);
    public static GotoExpression Continue(LabelTarget target);
    public static GotoExpression Continue(LabelTarget target, Type type);
    public static UnaryExpression Convert(Expression expression, Type type);
    public static UnaryExpression Convert(Expression expression, Type type, MethodInfo method);
    public static UnaryExpression ConvertChecked(Expression expression, Type type);
    public static UnaryExpression ConvertChecked(Expression expression, Type type, MethodInfo method);
    public static DebugInfoExpression DebugInfo(SymbolDocumentInfo document, int startLine, int startColumn, int endLine, int endColumn);
    public static UnaryExpression Decrement(Expression expression);
    public static UnaryExpression Decrement(Expression expression, MethodInfo method);
    public static DefaultExpression Default(Type type);
    public static BinaryExpression Divide(Expression left, Expression right);
    public static BinaryExpression Divide(Expression left, Expression right, MethodInfo method);
    public static BinaryExpression DivideAssign(Expression left, Expression right);
    public static BinaryExpression DivideAssign(Expression left, Expression right, MethodInfo method);
    public static BinaryExpression DivideAssign(Expression left, Expression right, MethodInfo method, LambdaExpression conversion);
    public static ElementInit ElementInit(MethodInfo addMethod, IEnumerable`1<Expression> arguments);
    public static ElementInit ElementInit(MethodInfo addMethod, Expression[] arguments);
    public static DefaultExpression Empty();
    public static BinaryExpression Equal(Expression left, Expression right);
    public static BinaryExpression Equal(Expression left, Expression right, bool liftToNull, MethodInfo method);
    public static BinaryExpression ExclusiveOr(Expression left, Expression right);
    public static BinaryExpression ExclusiveOr(Expression left, Expression right, MethodInfo method);
    public static BinaryExpression ExclusiveOrAssign(Expression left, Expression right);
    public static BinaryExpression ExclusiveOrAssign(Expression left, Expression right, MethodInfo method);
    public static BinaryExpression ExclusiveOrAssign(Expression left, Expression right, MethodInfo method, LambdaExpression conversion);
    public static MemberExpression Field(Expression expression, FieldInfo field);
    public static MemberExpression Field(Expression expression, string fieldName);
    public static MemberExpression Field(Expression expression, Type type, string fieldName);
    public static Type GetActionType(Type[] typeArgs);
    public static Type GetDelegateType(Type[] typeArgs);
    public static Type GetFuncType(Type[] typeArgs);
    public static GotoExpression Goto(LabelTarget target);
    public static GotoExpression Goto(LabelTarget target, Expression value);
    public static GotoExpression Goto(LabelTarget target, Expression value, Type type);
    public static GotoExpression Goto(LabelTarget target, Type type);
    public static BinaryExpression GreaterThan(Expression left, Expression right);
    public static BinaryExpression GreaterThan(Expression left, Expression right, bool liftToNull, MethodInfo method);
    public static BinaryExpression GreaterThanOrEqual(Expression left, Expression right);
    public static BinaryExpression GreaterThanOrEqual(Expression left, Expression right, bool liftToNull, MethodInfo method);
    public static ConditionalExpression IfThen(Expression test, Expression ifTrue);
    public static ConditionalExpression IfThenElse(Expression test, Expression ifTrue, Expression ifFalse);
    public static UnaryExpression Increment(Expression expression);
    public static UnaryExpression Increment(Expression expression, MethodInfo method);
    public static InvocationExpression Invoke(Expression expression, IEnumerable`1<Expression> arguments);
    public static InvocationExpression Invoke(Expression expression, Expression[] arguments);
    public static UnaryExpression IsFalse(Expression expression);
    public static UnaryExpression IsFalse(Expression expression, MethodInfo method);
    public static UnaryExpression IsTrue(Expression expression);
    public static UnaryExpression IsTrue(Expression expression, MethodInfo method);
    public static LabelTarget Label();
    public static LabelExpression Label(LabelTarget target);
    public static LabelExpression Label(LabelTarget target, Expression defaultValue);
    public static LabelTarget Label(string name);
    public static LabelTarget Label(Type type);
    public static LabelTarget Label(Type type, string name);
    public static LambdaExpression Lambda(Expression body, bool tailCall, IEnumerable`1<ParameterExpression> parameters);
    public static LambdaExpression Lambda(Expression body, bool tailCall, ParameterExpression[] parameters);
    public static LambdaExpression Lambda(Expression body, IEnumerable`1<ParameterExpression> parameters);
    public static LambdaExpression Lambda(Expression body, ParameterExpression[] parameters);
    public static LambdaExpression Lambda(Expression body, string name, bool tailCall, IEnumerable`1<ParameterExpression> parameters);
    public static LambdaExpression Lambda(Expression body, string name, IEnumerable`1<ParameterExpression> parameters);
    public static LambdaExpression Lambda(Type delegateType, Expression body, bool tailCall, IEnumerable`1<ParameterExpression> parameters);
    public static LambdaExpression Lambda(Type delegateType, Expression body, bool tailCall, ParameterExpression[] parameters);
    public static LambdaExpression Lambda(Type delegateType, Expression body, IEnumerable`1<ParameterExpression> parameters);
    public static LambdaExpression Lambda(Type delegateType, Expression body, ParameterExpression[] parameters);
    public static LambdaExpression Lambda(Type delegateType, Expression body, string name, bool tailCall, IEnumerable`1<ParameterExpression> parameters);
    public static LambdaExpression Lambda(Type delegateType, Expression body, string name, IEnumerable`1<ParameterExpression> parameters);
    public static Expression`1<TDelegate> Lambda(Expression body, bool tailCall, IEnumerable`1<ParameterExpression> parameters);
    public static Expression`1<TDelegate> Lambda(Expression body, bool tailCall, ParameterExpression[] parameters);
    public static Expression`1<TDelegate> Lambda(Expression body, IEnumerable`1<ParameterExpression> parameters);
    public static Expression`1<TDelegate> Lambda(Expression body, ParameterExpression[] parameters);
    public static Expression`1<TDelegate> Lambda(Expression body, string name, bool tailCall, IEnumerable`1<ParameterExpression> parameters);
    public static Expression`1<TDelegate> Lambda(Expression body, string name, IEnumerable`1<ParameterExpression> parameters);
    public static BinaryExpression LeftShift(Expression left, Expression right);
    public static BinaryExpression LeftShift(Expression left, Expression right, MethodInfo method);
    public static BinaryExpression LeftShiftAssign(Expression left, Expression right);
    public static BinaryExpression LeftShiftAssign(Expression left, Expression right, MethodInfo method);
    public static BinaryExpression LeftShiftAssign(Expression left, Expression right, MethodInfo method, LambdaExpression conversion);
    public static BinaryExpression LessThan(Expression left, Expression right);
    public static BinaryExpression LessThan(Expression left, Expression right, bool liftToNull, MethodInfo method);
    public static BinaryExpression LessThanOrEqual(Expression left, Expression right);
    public static BinaryExpression LessThanOrEqual(Expression left, Expression right, bool liftToNull, MethodInfo method);
    public static MemberListBinding ListBind(MemberInfo member, IEnumerable`1<ElementInit> initializers);
    public static MemberListBinding ListBind(MemberInfo member, ElementInit[] initializers);
    public static MemberListBinding ListBind(MethodInfo propertyAccessor, IEnumerable`1<ElementInit> initializers);
    public static MemberListBinding ListBind(MethodInfo propertyAccessor, ElementInit[] initializers);
    public static ListInitExpression ListInit(NewExpression newExpression, IEnumerable`1<ElementInit> initializers);
    public static ListInitExpression ListInit(NewExpression newExpression, IEnumerable`1<Expression> initializers);
    public static ListInitExpression ListInit(NewExpression newExpression, ElementInit[] initializers);
    public static ListInitExpression ListInit(NewExpression newExpression, Expression[] initializers);
    public static ListInitExpression ListInit(NewExpression newExpression, MethodInfo addMethod, IEnumerable`1<Expression> initializers);
    public static ListInitExpression ListInit(NewExpression newExpression, MethodInfo addMethod, Expression[] initializers);
    public static LoopExpression Loop(Expression body);
    public static LoopExpression Loop(Expression body, LabelTarget break);
    public static LoopExpression Loop(Expression body, LabelTarget break, LabelTarget continue);
    public static BinaryExpression MakeBinary(ExpressionType binaryType, Expression left, Expression right);
    public static BinaryExpression MakeBinary(ExpressionType binaryType, Expression left, Expression right, bool liftToNull, MethodInfo method);
    public static BinaryExpression MakeBinary(ExpressionType binaryType, Expression left, Expression right, bool liftToNull, MethodInfo method, LambdaExpression conversion);
    public static CatchBlock MakeCatchBlock(Type type, ParameterExpression variable, Expression body, Expression filter);
    public static GotoExpression MakeGoto(GotoExpressionKind kind, LabelTarget target, Expression value, Type type);
    public static IndexExpression MakeIndex(Expression instance, PropertyInfo indexer, IEnumerable`1<Expression> arguments);
    public static MemberExpression MakeMemberAccess(Expression expression, MemberInfo member);
    public static TryExpression MakeTry(Type type, Expression body, Expression finally, Expression fault, IEnumerable`1<CatchBlock> handlers);
    public static UnaryExpression MakeUnary(ExpressionType unaryType, Expression operand, Type type);
    public static UnaryExpression MakeUnary(ExpressionType unaryType, Expression operand, Type type, MethodInfo method);
    public static MemberMemberBinding MemberBind(MemberInfo member, IEnumerable`1<MemberBinding> bindings);
    public static MemberMemberBinding MemberBind(MemberInfo member, MemberBinding[] bindings);
    public static MemberMemberBinding MemberBind(MethodInfo propertyAccessor, IEnumerable`1<MemberBinding> bindings);
    public static MemberMemberBinding MemberBind(MethodInfo propertyAccessor, MemberBinding[] bindings);
    public static MemberInitExpression MemberInit(NewExpression newExpression, IEnumerable`1<MemberBinding> bindings);
    public static MemberInitExpression MemberInit(NewExpression newExpression, MemberBinding[] bindings);
    public static BinaryExpression Modulo(Expression left, Expression right);
    public static BinaryExpression Modulo(Expression left, Expression right, MethodInfo method);
    public static BinaryExpression ModuloAssign(Expression left, Expression right);
    public static BinaryExpression ModuloAssign(Expression left, Expression right, MethodInfo method);
    public static BinaryExpression ModuloAssign(Expression left, Expression right, MethodInfo method, LambdaExpression conversion);
    public static BinaryExpression Multiply(Expression left, Expression right);
    public static BinaryExpression Multiply(Expression left, Expression right, MethodInfo method);
    public static BinaryExpression MultiplyAssign(Expression left, Expression right);
    public static BinaryExpression MultiplyAssign(Expression left, Expression right, MethodInfo method);
    public static BinaryExpression MultiplyAssign(Expression left, Expression right, MethodInfo method, LambdaExpression conversion);
    public static BinaryExpression MultiplyAssignChecked(Expression left, Expression right);
    public static BinaryExpression MultiplyAssignChecked(Expression left, Expression right, MethodInfo method);
    public static BinaryExpression MultiplyAssignChecked(Expression left, Expression right, MethodInfo method, LambdaExpression conversion);
    public static BinaryExpression MultiplyChecked(Expression left, Expression right);
    public static BinaryExpression MultiplyChecked(Expression left, Expression right, MethodInfo method);
    public static UnaryExpression Negate(Expression expression);
    public static UnaryExpression Negate(Expression expression, MethodInfo method);
    public static UnaryExpression NegateChecked(Expression expression);
    public static UnaryExpression NegateChecked(Expression expression, MethodInfo method);
    public static NewExpression New(ConstructorInfo constructor);
    public static NewExpression New(ConstructorInfo constructor, IEnumerable`1<Expression> arguments);
    public static NewExpression New(ConstructorInfo constructor, IEnumerable`1<Expression> arguments, IEnumerable`1<MemberInfo> members);
    public static NewExpression New(ConstructorInfo constructor, IEnumerable`1<Expression> arguments, MemberInfo[] members);
    public static NewExpression New(ConstructorInfo constructor, Expression[] arguments);
    public static NewExpression New(Type type);
    public static NewArrayExpression NewArrayBounds(Type type, IEnumerable`1<Expression> bounds);
    public static NewArrayExpression NewArrayBounds(Type type, Expression[] bounds);
    public static NewArrayExpression NewArrayInit(Type type, IEnumerable`1<Expression> initializers);
    public static NewArrayExpression NewArrayInit(Type type, Expression[] initializers);
    public static UnaryExpression Not(Expression expression);
    public static UnaryExpression Not(Expression expression, MethodInfo method);
    public static BinaryExpression NotEqual(Expression left, Expression right);
    public static BinaryExpression NotEqual(Expression left, Expression right, bool liftToNull, MethodInfo method);
    public static UnaryExpression OnesComplement(Expression expression);
    public static UnaryExpression OnesComplement(Expression expression, MethodInfo method);
    public static BinaryExpression Or(Expression left, Expression right);
    public static BinaryExpression Or(Expression left, Expression right, MethodInfo method);
    public static BinaryExpression OrAssign(Expression left, Expression right);
    public static BinaryExpression OrAssign(Expression left, Expression right, MethodInfo method);
    public static BinaryExpression OrAssign(Expression left, Expression right, MethodInfo method, LambdaExpression conversion);
    public static BinaryExpression OrElse(Expression left, Expression right);
    public static BinaryExpression OrElse(Expression left, Expression right, MethodInfo method);
    public static ParameterExpression Parameter(Type type);
    public static ParameterExpression Parameter(Type type, string name);
    public static UnaryExpression PostDecrementAssign(Expression expression);
    public static UnaryExpression PostDecrementAssign(Expression expression, MethodInfo method);
    public static UnaryExpression PostIncrementAssign(Expression expression);
    public static UnaryExpression PostIncrementAssign(Expression expression, MethodInfo method);
    public static BinaryExpression Power(Expression left, Expression right);
    public static BinaryExpression Power(Expression left, Expression right, MethodInfo method);
    public static BinaryExpression PowerAssign(Expression left, Expression right);
    public static BinaryExpression PowerAssign(Expression left, Expression right, MethodInfo method);
    public static BinaryExpression PowerAssign(Expression left, Expression right, MethodInfo method, LambdaExpression conversion);
    public static UnaryExpression PreDecrementAssign(Expression expression);
    public static UnaryExpression PreDecrementAssign(Expression expression, MethodInfo method);
    public static UnaryExpression PreIncrementAssign(Expression expression);
    public static UnaryExpression PreIncrementAssign(Expression expression, MethodInfo method);
    public static MemberExpression Property(Expression expression, MethodInfo propertyAccessor);
    public static MemberExpression Property(Expression expression, PropertyInfo property);
    public static IndexExpression Property(Expression instance, PropertyInfo indexer, IEnumerable`1<Expression> arguments);
    public static IndexExpression Property(Expression instance, PropertyInfo indexer, Expression[] arguments);
    public static MemberExpression Property(Expression expression, string propertyName);
    public static IndexExpression Property(Expression instance, string propertyName, Expression[] arguments);
    public static MemberExpression Property(Expression expression, Type type, string propertyName);
    public static MemberExpression PropertyOrField(Expression expression, string propertyOrFieldName);
    public static UnaryExpression Quote(Expression expression);
    public virtual Expression Reduce();
    public Expression ReduceAndCheck();
    public Expression ReduceExtensions();
    public static BinaryExpression ReferenceEqual(Expression left, Expression right);
    public static BinaryExpression ReferenceNotEqual(Expression left, Expression right);
    public static UnaryExpression Rethrow();
    public static UnaryExpression Rethrow(Type type);
    public static GotoExpression Return(LabelTarget target);
    public static GotoExpression Return(LabelTarget target, Expression value);
    public static GotoExpression Return(LabelTarget target, Expression value, Type type);
    public static GotoExpression Return(LabelTarget target, Type type);
    public static BinaryExpression RightShift(Expression left, Expression right);
    public static BinaryExpression RightShift(Expression left, Expression right, MethodInfo method);
    public static BinaryExpression RightShiftAssign(Expression left, Expression right);
    public static BinaryExpression RightShiftAssign(Expression left, Expression right, MethodInfo method);
    public static BinaryExpression RightShiftAssign(Expression left, Expression right, MethodInfo method, LambdaExpression conversion);
    public static RuntimeVariablesExpression RuntimeVariables(IEnumerable`1<ParameterExpression> variables);
    public static RuntimeVariablesExpression RuntimeVariables(ParameterExpression[] variables);
    public static BinaryExpression Subtract(Expression left, Expression right);
    public static BinaryExpression Subtract(Expression left, Expression right, MethodInfo method);
    public static BinaryExpression SubtractAssign(Expression left, Expression right);
    public static BinaryExpression SubtractAssign(Expression left, Expression right, MethodInfo method);
    public static BinaryExpression SubtractAssign(Expression left, Expression right, MethodInfo method, LambdaExpression conversion);
    public static BinaryExpression SubtractAssignChecked(Expression left, Expression right);
    public static BinaryExpression SubtractAssignChecked(Expression left, Expression right, MethodInfo method);
    public static BinaryExpression SubtractAssignChecked(Expression left, Expression right, MethodInfo method, LambdaExpression conversion);
    public static BinaryExpression SubtractChecked(Expression left, Expression right);
    public static BinaryExpression SubtractChecked(Expression left, Expression right, MethodInfo method);
    public static SwitchExpression Switch(Expression switchValue, Expression defaultBody, SwitchCase[] cases);
    public static SwitchExpression Switch(Expression switchValue, Expression defaultBody, MethodInfo comparison, IEnumerable`1<SwitchCase> cases);
    public static SwitchExpression Switch(Expression switchValue, Expression defaultBody, MethodInfo comparison, SwitchCase[] cases);
    public static SwitchExpression Switch(Expression switchValue, SwitchCase[] cases);
    public static SwitchExpression Switch(Type type, Expression switchValue, Expression defaultBody, MethodInfo comparison, IEnumerable`1<SwitchCase> cases);
    public static SwitchExpression Switch(Type type, Expression switchValue, Expression defaultBody, MethodInfo comparison, SwitchCase[] cases);
    public static SwitchCase SwitchCase(Expression body, IEnumerable`1<Expression> testValues);
    public static SwitchCase SwitchCase(Expression body, Expression[] testValues);
    public static SymbolDocumentInfo SymbolDocument(string fileName);
    public static SymbolDocumentInfo SymbolDocument(string fileName, Guid language);
    public static SymbolDocumentInfo SymbolDocument(string fileName, Guid language, Guid languageVendor);
    public static SymbolDocumentInfo SymbolDocument(string fileName, Guid language, Guid languageVendor, Guid documentType);
    public static UnaryExpression Throw(Expression value);
    public static UnaryExpression Throw(Expression value, Type type);
    public virtual string ToString();
    public static TryExpression TryCatch(Expression body, CatchBlock[] handlers);
    public static TryExpression TryCatchFinally(Expression body, Expression finally, CatchBlock[] handlers);
    public static TryExpression TryFault(Expression body, Expression fault);
    public static TryExpression TryFinally(Expression body, Expression finally);
    public static bool TryGetActionType(Type[] typeArgs, Type& actionType);
    public static bool TryGetFuncType(Type[] typeArgs, Type& funcType);
    public static UnaryExpression TypeAs(Expression expression, Type type);
    public static TypeBinaryExpression TypeEqual(Expression expression, Type type);
    public static TypeBinaryExpression TypeIs(Expression expression, Type type);
    public static UnaryExpression UnaryPlus(Expression expression);
    public static UnaryExpression UnaryPlus(Expression expression, MethodInfo method);
    public static UnaryExpression Unbox(Expression expression, Type type);
    public static ParameterExpression Variable(Type type);
    public static ParameterExpression Variable(Type type, string name);
    protected internal virtual Expression VisitChildren(ExpressionVisitor visitor);
}
public class System.Linq.Expressions.Expression`1 : LambdaExpression {
    protected internal virtual Expression Accept(ExpressionVisitor visitor);
    public TDelegate Compile();
    public Expression`1<TDelegate> Update(Expression body, IEnumerable`1<ParameterExpression> parameters);
}
public enum System.Linq.Expressions.ExpressionType : Enum {
    public int value__;
    public static ExpressionType Add;
    public static ExpressionType AddAssign;
    public static ExpressionType AddAssignChecked;
    public static ExpressionType AddChecked;
    public static ExpressionType And;
    public static ExpressionType AndAlso;
    public static ExpressionType AndAssign;
    public static ExpressionType ArrayIndex;
    public static ExpressionType ArrayLength;
    public static ExpressionType Assign;
    public static ExpressionType Block;
    public static ExpressionType Call;
    public static ExpressionType Coalesce;
    public static ExpressionType Conditional;
    public static ExpressionType Constant;
    public static ExpressionType Convert;
    public static ExpressionType ConvertChecked;
    public static ExpressionType DebugInfo;
    public static ExpressionType Decrement;
    public static ExpressionType Default;
    public static ExpressionType Divide;
    public static ExpressionType DivideAssign;
    public static ExpressionType Dynamic;
    public static ExpressionType Equal;
    public static ExpressionType ExclusiveOr;
    public static ExpressionType ExclusiveOrAssign;
    public static ExpressionType Extension;
    public static ExpressionType Goto;
    public static ExpressionType GreaterThan;
    public static ExpressionType GreaterThanOrEqual;
    public static ExpressionType Increment;
    public static ExpressionType Index;
    public static ExpressionType Invoke;
    public static ExpressionType IsFalse;
    public static ExpressionType IsTrue;
    public static ExpressionType Label;
    public static ExpressionType Lambda;
    public static ExpressionType LeftShift;
    public static ExpressionType LeftShiftAssign;
    public static ExpressionType LessThan;
    public static ExpressionType LessThanOrEqual;
    public static ExpressionType ListInit;
    public static ExpressionType Loop;
    public static ExpressionType MemberAccess;
    public static ExpressionType MemberInit;
    public static ExpressionType Modulo;
    public static ExpressionType ModuloAssign;
    public static ExpressionType Multiply;
    public static ExpressionType MultiplyAssign;
    public static ExpressionType MultiplyAssignChecked;
    public static ExpressionType MultiplyChecked;
    public static ExpressionType Negate;
    public static ExpressionType NegateChecked;
    public static ExpressionType New;
    public static ExpressionType NewArrayBounds;
    public static ExpressionType NewArrayInit;
    public static ExpressionType Not;
    public static ExpressionType NotEqual;
    public static ExpressionType OnesComplement;
    public static ExpressionType Or;
    public static ExpressionType OrAssign;
    public static ExpressionType OrElse;
    public static ExpressionType Parameter;
    public static ExpressionType PostDecrementAssign;
    public static ExpressionType PostIncrementAssign;
    public static ExpressionType Power;
    public static ExpressionType PowerAssign;
    public static ExpressionType PreDecrementAssign;
    public static ExpressionType PreIncrementAssign;
    public static ExpressionType Quote;
    public static ExpressionType RightShift;
    public static ExpressionType RightShiftAssign;
    public static ExpressionType RuntimeVariables;
    public static ExpressionType Subtract;
    public static ExpressionType SubtractAssign;
    public static ExpressionType SubtractAssignChecked;
    public static ExpressionType SubtractChecked;
    public static ExpressionType Switch;
    public static ExpressionType Throw;
    public static ExpressionType Try;
    public static ExpressionType TypeAs;
    public static ExpressionType TypeEqual;
    public static ExpressionType TypeIs;
    public static ExpressionType UnaryPlus;
    public static ExpressionType Unbox;
}
public abstract class System.Linq.Expressions.ExpressionVisitor : object {
    public ReadOnlyCollection`1<Expression> Visit(ReadOnlyCollection`1<Expression> nodes);
    public virtual Expression Visit(Expression node);
    public static ReadOnlyCollection`1<T> Visit(ReadOnlyCollection`1<T> nodes, Func`2<T, T> elementVisitor);
    public T VisitAndConvert(T node, string callerName);
    public ReadOnlyCollection`1<T> VisitAndConvert(ReadOnlyCollection`1<T> nodes, string callerName);
    protected internal virtual Expression VisitBinary(BinaryExpression node);
    protected internal virtual Expression VisitBlock(BlockExpression node);
    protected virtual CatchBlock VisitCatchBlock(CatchBlock node);
    protected internal virtual Expression VisitConditional(ConditionalExpression node);
    protected internal virtual Expression VisitConstant(ConstantExpression node);
    protected internal virtual Expression VisitDebugInfo(DebugInfoExpression node);
    protected internal virtual Expression VisitDefault(DefaultExpression node);
    protected virtual ElementInit VisitElementInit(ElementInit node);
    protected internal virtual Expression VisitExtension(Expression node);
    protected internal virtual Expression VisitGoto(GotoExpression node);
    protected internal virtual Expression VisitIndex(IndexExpression node);
    protected internal virtual Expression VisitInvocation(InvocationExpression node);
    protected internal virtual Expression VisitLabel(LabelExpression node);
    protected virtual LabelTarget VisitLabelTarget(LabelTarget node);
    protected internal virtual Expression VisitLambda(Expression`1<T> node);
    protected internal virtual Expression VisitListInit(ListInitExpression node);
    protected internal virtual Expression VisitLoop(LoopExpression node);
    protected internal virtual Expression VisitMember(MemberExpression node);
    protected virtual MemberAssignment VisitMemberAssignment(MemberAssignment node);
    protected virtual MemberBinding VisitMemberBinding(MemberBinding node);
    protected internal virtual Expression VisitMemberInit(MemberInitExpression node);
    protected virtual MemberListBinding VisitMemberListBinding(MemberListBinding node);
    protected virtual MemberMemberBinding VisitMemberMemberBinding(MemberMemberBinding node);
    protected internal virtual Expression VisitMethodCall(MethodCallExpression node);
    protected internal virtual Expression VisitNew(NewExpression node);
    protected internal virtual Expression VisitNewArray(NewArrayExpression node);
    protected internal virtual Expression VisitParameter(ParameterExpression node);
    protected internal virtual Expression VisitRuntimeVariables(RuntimeVariablesExpression node);
    protected internal virtual Expression VisitSwitch(SwitchExpression node);
    protected virtual SwitchCase VisitSwitchCase(SwitchCase node);
    protected internal virtual Expression VisitTry(TryExpression node);
    protected internal virtual Expression VisitTypeBinary(TypeBinaryExpression node);
    protected internal virtual Expression VisitUnary(UnaryExpression node);
}
public class System.Linq.Expressions.GotoExpression : Expression {
    public GotoExpressionKind Kind { get; }
    public ExpressionType NodeType { get; }
    public LabelTarget Target { get; }
    public Type Type { get; }
    public Expression Value { get; }
    public GotoExpressionKind get_Kind();
    public sealed virtual ExpressionType get_NodeType();
    public LabelTarget get_Target();
    public sealed virtual Type get_Type();
    public Expression get_Value();
    protected internal virtual Expression Accept(ExpressionVisitor visitor);
    public GotoExpression Update(LabelTarget target, Expression value);
}
public enum System.Linq.Expressions.GotoExpressionKind : Enum {
    public int value__;
    public static GotoExpressionKind Break;
    public static GotoExpressionKind Continue;
    public static GotoExpressionKind Goto;
    public static GotoExpressionKind Return;
}
public interface System.Linq.Expressions.IArgumentProvider {
    public int ArgumentCount { get; }
    public abstract virtual int get_ArgumentCount();
    public abstract virtual Expression GetArgument(int index);
}
public interface System.Linq.Expressions.IDynamicExpression {
    public Type DelegateType { get; }
    public abstract virtual Type get_DelegateType();
    public abstract virtual object CreateCallSite();
    public abstract virtual Expression Rewrite(Expression[] args);
}
public class System.Linq.Expressions.IndexExpression : Expression {
    public ReadOnlyCollection`1<Expression> Arguments { get; }
    public PropertyInfo Indexer { get; }
    public ExpressionType NodeType { get; }
    public Expression Object { get; }
    private int System.Linq.Expressions.IArgumentProvider.ArgumentCount { get; }
    public Type Type { get; }
    public ReadOnlyCollection`1<Expression> get_Arguments();
    public PropertyInfo get_Indexer();
    public sealed virtual ExpressionType get_NodeType();
    public Expression get_Object();
    private sealed virtual override int System.Linq.Expressions.IArgumentProvider.get_ArgumentCount();
    public sealed virtual Type get_Type();
    protected internal virtual Expression Accept(ExpressionVisitor visitor);
    private sealed virtual override Expression System.Linq.Expressions.IArgumentProvider.GetArgument(int index);
    public IndexExpression Update(Expression object, IEnumerable`1<Expression> arguments);
}
public class System.Linq.Expressions.InvocationExpression : Expression {
    public ReadOnlyCollection`1<Expression> Arguments { get; }
    public Expression Expression { get; }
    public ExpressionType NodeType { get; }
    private int System.Linq.Expressions.IArgumentProvider.ArgumentCount { get; }
    public Type Type { get; }
    public ReadOnlyCollection`1<Expression> get_Arguments();
    public Expression get_Expression();
    public sealed virtual ExpressionType get_NodeType();
    private sealed virtual override int System.Linq.Expressions.IArgumentProvider.get_ArgumentCount();
    public sealed virtual Type get_Type();
    protected internal virtual Expression Accept(ExpressionVisitor visitor);
    private sealed virtual override Expression System.Linq.Expressions.IArgumentProvider.GetArgument(int index);
    public InvocationExpression Update(Expression expression, IEnumerable`1<Expression> arguments);
}
public class System.Linq.Expressions.LabelExpression : Expression {
    public Expression DefaultValue { get; }
    public ExpressionType NodeType { get; }
    public LabelTarget Target { get; }
    public Type Type { get; }
    public Expression get_DefaultValue();
    public sealed virtual ExpressionType get_NodeType();
    public LabelTarget get_Target();
    public sealed virtual Type get_Type();
    protected internal virtual Expression Accept(ExpressionVisitor visitor);
    public LabelExpression Update(LabelTarget target, Expression defaultValue);
}
public class System.Linq.Expressions.LabelTarget : object {
    public string Name { get; }
    public Type Type { get; }
    public string get_Name();
    public Type get_Type();
    public virtual string ToString();
}
public abstract class System.Linq.Expressions.LambdaExpression : Expression {
    public Expression Body { get; }
    public string Name { get; }
    public ExpressionType NodeType { get; }
    public ReadOnlyCollection`1<ParameterExpression> Parameters { get; }
    public Type ReturnType { get; }
    public bool TailCall { get; }
    public Type Type { get; }
    public Expression get_Body();
    public string get_Name();
    public sealed virtual ExpressionType get_NodeType();
    public ReadOnlyCollection`1<ParameterExpression> get_Parameters();
    public Type get_ReturnType();
    public bool get_TailCall();
    public sealed virtual Type get_Type();
    public Delegate Compile();
}
public class System.Linq.Expressions.ListInitExpression : Expression {
    public bool CanReduce { get; }
    public ReadOnlyCollection`1<ElementInit> Initializers { get; }
    public NewExpression NewExpression { get; }
    public ExpressionType NodeType { get; }
    public Type Type { get; }
    public virtual bool get_CanReduce();
    public ReadOnlyCollection`1<ElementInit> get_Initializers();
    public NewExpression get_NewExpression();
    public sealed virtual ExpressionType get_NodeType();
    public sealed virtual Type get_Type();
    protected internal virtual Expression Accept(ExpressionVisitor visitor);
    public virtual Expression Reduce();
    public ListInitExpression Update(NewExpression newExpression, IEnumerable`1<ElementInit> initializers);
}
public class System.Linq.Expressions.LoopExpression : Expression {
    public Expression Body { get; }
    public LabelTarget BreakLabel { get; }
    public LabelTarget ContinueLabel { get; }
    public ExpressionType NodeType { get; }
    public Type Type { get; }
    public Expression get_Body();
    public LabelTarget get_BreakLabel();
    public LabelTarget get_ContinueLabel();
    public sealed virtual ExpressionType get_NodeType();
    public sealed virtual Type get_Type();
    protected internal virtual Expression Accept(ExpressionVisitor visitor);
    public LoopExpression Update(LabelTarget breakLabel, LabelTarget continueLabel, Expression body);
}
public class System.Linq.Expressions.MemberAssignment : MemberBinding {
    public Expression Expression { get; }
    public Expression get_Expression();
    public MemberAssignment Update(Expression expression);
}
public abstract class System.Linq.Expressions.MemberBinding : object {
    public MemberBindingType BindingType { get; }
    public MemberInfo Member { get; }
    public MemberBindingType get_BindingType();
    public MemberInfo get_Member();
    public virtual string ToString();
}
public enum System.Linq.Expressions.MemberBindingType : Enum {
    public int value__;
    public static MemberBindingType Assignment;
    public static MemberBindingType ListBinding;
    public static MemberBindingType MemberBinding;
}
public class System.Linq.Expressions.MemberExpression : Expression {
    public Expression Expression { get; }
    public MemberInfo Member { get; }
    public ExpressionType NodeType { get; }
    public Expression get_Expression();
    public MemberInfo get_Member();
    public sealed virtual ExpressionType get_NodeType();
    protected internal virtual Expression Accept(ExpressionVisitor visitor);
    public MemberExpression Update(Expression expression);
}
public class System.Linq.Expressions.MemberInitExpression : Expression {
    public ReadOnlyCollection`1<MemberBinding> Bindings { get; }
    public bool CanReduce { get; }
    public NewExpression NewExpression { get; }
    public ExpressionType NodeType { get; }
    public Type Type { get; }
    public ReadOnlyCollection`1<MemberBinding> get_Bindings();
    public virtual bool get_CanReduce();
    public NewExpression get_NewExpression();
    public sealed virtual ExpressionType get_NodeType();
    public sealed virtual Type get_Type();
    protected internal virtual Expression Accept(ExpressionVisitor visitor);
    public virtual Expression Reduce();
    public MemberInitExpression Update(NewExpression newExpression, IEnumerable`1<MemberBinding> bindings);
}
public class System.Linq.Expressions.MemberListBinding : MemberBinding {
    public ReadOnlyCollection`1<ElementInit> Initializers { get; }
    public ReadOnlyCollection`1<ElementInit> get_Initializers();
    public MemberListBinding Update(IEnumerable`1<ElementInit> initializers);
}
public class System.Linq.Expressions.MemberMemberBinding : MemberBinding {
    public ReadOnlyCollection`1<MemberBinding> Bindings { get; }
    public ReadOnlyCollection`1<MemberBinding> get_Bindings();
    public MemberMemberBinding Update(IEnumerable`1<MemberBinding> bindings);
}
public class System.Linq.Expressions.MethodCallExpression : Expression {
    public ReadOnlyCollection`1<Expression> Arguments { get; }
    public MethodInfo Method { get; }
    public ExpressionType NodeType { get; }
    public Expression Object { get; }
    private int System.Linq.Expressions.IArgumentProvider.ArgumentCount { get; }
    public Type Type { get; }
    public ReadOnlyCollection`1<Expression> get_Arguments();
    public MethodInfo get_Method();
    public sealed virtual ExpressionType get_NodeType();
    public Expression get_Object();
    private sealed virtual override int System.Linq.Expressions.IArgumentProvider.get_ArgumentCount();
    public sealed virtual Type get_Type();
    protected internal virtual Expression Accept(ExpressionVisitor visitor);
    private sealed virtual override Expression System.Linq.Expressions.IArgumentProvider.GetArgument(int index);
    public MethodCallExpression Update(Expression object, IEnumerable`1<Expression> arguments);
}
public class System.Linq.Expressions.NewArrayExpression : Expression {
    public ReadOnlyCollection`1<Expression> Expressions { get; }
    public Type Type { get; }
    public ReadOnlyCollection`1<Expression> get_Expressions();
    public sealed virtual Type get_Type();
    protected internal virtual Expression Accept(ExpressionVisitor visitor);
    public NewArrayExpression Update(IEnumerable`1<Expression> expressions);
}
public class System.Linq.Expressions.NewExpression : Expression {
    public ReadOnlyCollection`1<Expression> Arguments { get; }
    public ConstructorInfo Constructor { get; }
    public ReadOnlyCollection`1<MemberInfo> Members { get; }
    public ExpressionType NodeType { get; }
    private int System.Linq.Expressions.IArgumentProvider.ArgumentCount { get; }
    public Type Type { get; }
    public ReadOnlyCollection`1<Expression> get_Arguments();
    public ConstructorInfo get_Constructor();
    public ReadOnlyCollection`1<MemberInfo> get_Members();
    public sealed virtual ExpressionType get_NodeType();
    private sealed virtual override int System.Linq.Expressions.IArgumentProvider.get_ArgumentCount();
    public virtual Type get_Type();
    protected internal virtual Expression Accept(ExpressionVisitor visitor);
    private sealed virtual override Expression System.Linq.Expressions.IArgumentProvider.GetArgument(int index);
    public NewExpression Update(IEnumerable`1<Expression> arguments);
}
public class System.Linq.Expressions.ParameterExpression : Expression {
    public bool IsByRef { get; }
    public string Name { get; }
    public ExpressionType NodeType { get; }
    public Type Type { get; }
    public bool get_IsByRef();
    public string get_Name();
    public sealed virtual ExpressionType get_NodeType();
    public virtual Type get_Type();
    protected internal virtual Expression Accept(ExpressionVisitor visitor);
}
public class System.Linq.Expressions.RuntimeVariablesExpression : Expression {
    public ExpressionType NodeType { get; }
    public Type Type { get; }
    public ReadOnlyCollection`1<ParameterExpression> Variables { get; }
    public sealed virtual ExpressionType get_NodeType();
    public sealed virtual Type get_Type();
    public ReadOnlyCollection`1<ParameterExpression> get_Variables();
    protected internal virtual Expression Accept(ExpressionVisitor visitor);
    public RuntimeVariablesExpression Update(IEnumerable`1<ParameterExpression> variables);
}
public class System.Linq.Expressions.SwitchCase : object {
    public Expression Body { get; }
    public ReadOnlyCollection`1<Expression> TestValues { get; }
    public Expression get_Body();
    public ReadOnlyCollection`1<Expression> get_TestValues();
    public virtual string ToString();
    public SwitchCase Update(IEnumerable`1<Expression> testValues, Expression body);
}
public class System.Linq.Expressions.SwitchExpression : Expression {
    public ReadOnlyCollection`1<SwitchCase> Cases { get; }
    public MethodInfo Comparison { get; }
    public Expression DefaultBody { get; }
    public ExpressionType NodeType { get; }
    public Expression SwitchValue { get; }
    public Type Type { get; }
    public ReadOnlyCollection`1<SwitchCase> get_Cases();
    public MethodInfo get_Comparison();
    public Expression get_DefaultBody();
    public sealed virtual ExpressionType get_NodeType();
    public Expression get_SwitchValue();
    public sealed virtual Type get_Type();
    protected internal virtual Expression Accept(ExpressionVisitor visitor);
    public SwitchExpression Update(Expression switchValue, IEnumerable`1<SwitchCase> cases, Expression defaultBody);
}
public class System.Linq.Expressions.SymbolDocumentInfo : object {
    public Guid DocumentType { get; }
    public string FileName { get; }
    public Guid Language { get; }
    public Guid LanguageVendor { get; }
    public virtual Guid get_DocumentType();
    public string get_FileName();
    public virtual Guid get_Language();
    public virtual Guid get_LanguageVendor();
}
public class System.Linq.Expressions.TryExpression : Expression {
    public Expression Body { get; }
    public Expression Fault { get; }
    public Expression Finally { get; }
    public ReadOnlyCollection`1<CatchBlock> Handlers { get; }
    public ExpressionType NodeType { get; }
    public Type Type { get; }
    public Expression get_Body();
    public Expression get_Fault();
    public Expression get_Finally();
    public ReadOnlyCollection`1<CatchBlock> get_Handlers();
    public sealed virtual ExpressionType get_NodeType();
    public sealed virtual Type get_Type();
    protected internal virtual Expression Accept(ExpressionVisitor visitor);
    public TryExpression Update(Expression body, IEnumerable`1<CatchBlock> handlers, Expression finally, Expression fault);
}
public class System.Linq.Expressions.TypeBinaryExpression : Expression {
    public Expression Expression { get; }
    public ExpressionType NodeType { get; }
    public Type Type { get; }
    public Type TypeOperand { get; }
    public Expression get_Expression();
    public sealed virtual ExpressionType get_NodeType();
    public sealed virtual Type get_Type();
    public Type get_TypeOperand();
    protected internal virtual Expression Accept(ExpressionVisitor visitor);
    public TypeBinaryExpression Update(Expression expression);
}
public class System.Linq.Expressions.UnaryExpression : Expression {
    public bool CanReduce { get; }
    public bool IsLifted { get; }
    public bool IsLiftedToNull { get; }
    public MethodInfo Method { get; }
    public ExpressionType NodeType { get; }
    public Expression Operand { get; }
    public Type Type { get; }
    public virtual bool get_CanReduce();
    public bool get_IsLifted();
    public bool get_IsLiftedToNull();
    public MethodInfo get_Method();
    public sealed virtual ExpressionType get_NodeType();
    public Expression get_Operand();
    public sealed virtual Type get_Type();
    protected internal virtual Expression Accept(ExpressionVisitor visitor);
    public virtual Expression Reduce();
    public UnaryExpression Update(Expression operand);
}
public interface System.Linq.IOrderedQueryable {
}
public interface System.Linq.IOrderedQueryable`1 {
}
public interface System.Linq.IQueryable {
    public Type ElementType { get; }
    public Expression Expression { get; }
    public IQueryProvider Provider { get; }
    public abstract virtual Type get_ElementType();
    public abstract virtual Expression get_Expression();
    public abstract virtual IQueryProvider get_Provider();
}
public interface System.Linq.IQueryable`1 {
}
public interface System.Linq.IQueryProvider {
    public abstract virtual IQueryable CreateQuery(Expression expression);
    public abstract virtual IQueryable`1<TElement> CreateQuery(Expression expression);
    public abstract virtual object Execute(Expression expression);
    public abstract virtual TResult Execute(Expression expression);
}
