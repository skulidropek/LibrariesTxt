internal static class FxResources.System.Linq.Expressions.SR : object {
}
internal static class System.Collections.Generic.EnumerableHelpers : object {
    internal static T[] ToArray(IEnumerable`1<T> source);
    internal static T[] ToArray(IEnumerable`1<T> source, Int32& length);
}
[ConditionalAttribute("DEBUG")]
[AttributeUsageAttribute("32767")]
internal class System.Diagnostics.CodeAnalysis.ExcludeFromCodeCoverageAttribute : Attribute {
}
[DefaultMemberAttribute("Item")]
internal class System.Dynamic.Utils.CacheDict`2 : object {
    private int mask;
    private Entry[] entries;
    unknown TValue Item {internal set; }
    internal CacheDict`2(int size);
    private static int AlignSize(int size);
    internal bool TryGetValue(TKey key, TValue& value);
    internal void Add(TKey key, TValue value);
    internal void set_Item(TKey key, TValue value);
}
[ExtensionAttribute]
internal static class System.Dynamic.Utils.CollectionExtensions : object {
    [ExtensionAttribute]
public static ReadOnlyCollection`1<T> ToReadOnly(IEnumerable`1<T> enumerable);
    [ExtensionAttribute]
public static int ListHashCode(IEnumerable`1<T> list);
    [ExtensionAttribute]
public static bool ListEquals(ReadOnlyCollection`1<T> first, ReadOnlyCollection`1<T> second);
    [ExtensionAttribute]
public static T[] RemoveFirst(T[] array);
    [ExtensionAttribute]
public static T[] RemoveLast(T[] array);
    [ExtensionAttribute]
public static U[] Map(ICollection`1<T> collection, Func`2<T, U> select);
}
internal static class System.Dynamic.Utils.ContractUtils : object {
    public static Exception Unreachable { get; }
    public static Exception get_Unreachable();
    public static void Requires(bool precondition, string paramName);
    public static void RequiresNotNull(object value, string paramName);
    public static void RequiresNotEmpty(ICollection`1<T> collection, string paramName);
    public static void RequiresNotEmptyList(IReadOnlyList`1<T> collection, string paramName);
    public static void RequiresNotNullItems(IList`1<T> array, string arrayName);
}
internal static class System.Dynamic.Utils.DelegateHelpers : object {
    internal static Delegate CreateObjectArrayDelegate(Type delegateType, Func`2<Object[], object> handler);
    private static Delegate CreateObjectArrayDelegateRefEmit(Type delegateType, Func`2<Object[], object> handler);
    private static Type ConvertToBoxableType(Type t);
}
internal static class System.Dynamic.Utils.EmptyReadOnlyCollection`1 : object {
    public static ReadOnlyCollection`1<T> Instance;
    private static EmptyReadOnlyCollection`1();
}
internal static class System.Dynamic.Utils.Error : object {
    internal static Exception EnumerationIsDone();
    internal static Exception CollectionModifiedWhileEnumerating();
    internal static Exception TypeContainsGenericParameters(object p0, string paramName);
    internal static Exception TypeIsGeneric(object p0, string paramName);
    internal static Exception IncorrectNumberOfConstructorArguments();
    internal static Exception ExpressionTypeDoesNotMatchMethodParameter(object p0, object p1, object p2);
    internal static Exception ExpressionTypeDoesNotMatchParameter(object p0, object p1);
    internal static Exception IncorrectNumberOfLambdaArguments();
    internal static Exception IncorrectNumberOfMethodCallArguments(object p0);
    internal static Exception ExpressionTypeDoesNotMatchConstructorParameter(object p0, object p1);
}
internal static class System.Dynamic.Utils.ExpressionUtils : object {
    public static ReadOnlyCollection`1<T> ReturnReadOnly(IList`1& collection);
    public static ReadOnlyCollection`1<Expression> ReturnReadOnly(IArgumentProvider provider, Object& collection);
    public static T ReturnObject(object collectionOrT);
    public static void ValidateArgumentTypes(MethodBase method, ExpressionType nodeKind, ReadOnlyCollection`1& arguments);
    public static void ValidateArgumentCount(MethodBase method, ExpressionType nodeKind, int count, ParameterInfo[] pis);
    public static Expression ValidateOneArgument(MethodBase method, ExpressionType nodeKind, Expression arguments, ParameterInfo pi);
    public static void RequiresCanRead(Expression expression, string paramName);
    public static bool TryQuote(Type parameterType, Expression& argument);
    internal static ParameterInfo[] GetParametersForValidation(MethodBase method, ExpressionType nodeKind);
}
internal static class System.Dynamic.Utils.ExpressionVisitorUtils : object {
    public static Expression[] VisitArguments(ExpressionVisitor visitor, IArgumentProvider nodes);
}
[DefaultMemberAttribute("Item")]
internal class System.Dynamic.Utils.ListArgumentProvider : object {
    private IArgumentProvider _provider;
    private Expression _arg0;
    public Expression Item { get; public set; }
    public int Count { get; }
    public bool IsReadOnly { get; }
    internal ListArgumentProvider(IArgumentProvider provider, Expression arg0);
    public sealed virtual int IndexOf(Expression item);
    public sealed virtual void Insert(int index, Expression item);
    public sealed virtual void RemoveAt(int index);
    public sealed virtual Expression get_Item(int index);
    public sealed virtual void set_Item(int index, Expression value);
    public sealed virtual void Add(Expression item);
    public sealed virtual void Clear();
    public sealed virtual bool Contains(Expression item);
    public sealed virtual void CopyTo(Expression[] array, int arrayIndex);
    public sealed virtual int get_Count();
    public sealed virtual bool get_IsReadOnly();
    public sealed virtual bool Remove(Expression item);
    [IteratorStateMachineAttribute("System.Dynamic.Utils.ListArgumentProvider/<GetEnumerator>d__18")]
public sealed virtual IEnumerator`1<Expression> GetEnumerator();
    [IteratorStateMachineAttribute("System.Dynamic.Utils.ListArgumentProvider/<System-Collections-IEnumerable-GetEnumerator>d__19")]
private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
}
internal static class System.Dynamic.Utils.Strings : object {
    internal static string InvalidArgumentValue { get; }
    internal static string NonEmptyCollectionRequired { get; }
    internal static string CollectionModifiedWhileEnumerating { get; }
    internal static string EnumerationIsDone { get; }
    internal static string ExpressionMustBeReadable { get; }
    internal static string IncorrectNumberOfLambdaArguments { get; }
    internal static string IncorrectNumberOfConstructorArguments { get; }
    internal static string get_InvalidArgumentValue();
    internal static string get_NonEmptyCollectionRequired();
    internal static string InvalidNullValue(object p0);
    internal static string InvalidObjectType(object p0, object p1);
    internal static string TypeContainsGenericParameters(object p0);
    internal static string TypeIsGeneric(object p0);
    internal static string get_CollectionModifiedWhileEnumerating();
    internal static string get_EnumerationIsDone();
    internal static string get_ExpressionMustBeReadable();
    internal static string ExpressionTypeDoesNotMatchMethodParameter(object p0, object p1, object p2);
    internal static string ExpressionTypeDoesNotMatchParameter(object p0, object p1);
    internal static string ExpressionTypeDoesNotMatchConstructorParameter(object p0, object p1);
    internal static string IncorrectNumberOfMethodCallArguments(object p0);
    internal static string get_IncorrectNumberOfLambdaArguments();
    internal static string get_IncorrectNumberOfConstructorArguments();
}
[ExtensionAttribute]
internal static class System.Dynamic.Utils.TypeExtensions : object {
    private static CacheDict`2<MethodBase, ParameterInfo[]> s_paramInfoCache;
    private static TypeExtensions();
    [ExtensionAttribute]
internal static ParameterInfo[] GetParametersCached(MethodBase method);
    [ExtensionAttribute]
public static bool IsSubclassOf(Type source, Type other);
    [ExtensionAttribute]
public static MethodInfo GetAnyStaticMethodValidated(Type type, string name, Type[] types);
    [ExtensionAttribute]
private static bool MatchesArgumentTypes(MethodInfo mi, Type[] argTypes);
    [ExtensionAttribute]
public static TypeCode GetTypeCode(Type type);
    [IteratorStateMachineAttribute("System.Dynamic.Utils.TypeExtensions/<GetStaticMethods>d__6")]
[ExtensionAttribute]
public static IEnumerable`1<MethodInfo> GetStaticMethods(Type type);
    [ExtensionAttribute]
public static MethodInfo GetAnyStaticMethod(Type type, string name);
    [ExtensionAttribute]
public static MethodInfo[] GetMethodsIgnoreCase(Type type, BindingFlags flags, string name);
}
[ExtensionAttribute]
internal static class System.Dynamic.Utils.TypeUtils : object {
    private static Assembly s_mscorlib;
    private static Assembly _mscorlib { get; }
    public static bool AreEquivalent(Type t1, Type t2);
    [ExtensionAttribute]
public static bool IsEquivalentTo(Type t1, Type t2);
    public static bool AreReferenceAssignable(Type dest, Type src);
    public static bool IsSameOrSubclass(Type type, Type subType);
    public static void ValidateType(Type type, string paramName);
    private static Assembly get__mscorlib();
    [ExtensionAttribute]
public static bool CanCache(Type t);
    [ExtensionAttribute]
public static Type GetNonNullableType(Type type);
    public static Type GetNullableType(Type type);
    [ExtensionAttribute]
public static bool IsNullableType(Type type);
    public static bool IsBool(Type type);
    public static bool IsNumeric(Type type);
    public static bool IsInteger(Type type);
    public static bool IsInteger64(Type type);
    public static bool IsArithmetic(Type type);
    public static bool IsUnsignedInt(Type type);
    public static bool IsIntegerOrBool(Type type);
    public static bool IsNumericOrBool(Type type);
    public static bool IsValidInstanceType(MemberInfo member, Type instanceType);
    public static bool HasIdentityPrimitiveOrNullableConversion(Type source, Type dest);
    public static bool HasReferenceConversion(Type source, Type dest);
    private static bool IsCovariant(Type t);
    private static bool IsContravariant(Type t);
    private static bool IsInvariant(Type t);
    private static bool IsDelegate(Type t);
    public static bool IsLegalExplicitVariantDelegateConversion(Type source, Type dest);
    public static bool IsConvertible(Type type);
    public static bool HasReferenceEquality(Type left, Type right);
    public static bool HasBuiltInEqualityOperator(Type left, Type right);
    public static bool IsImplicitlyConvertible(Type source, Type destination);
    public static MethodInfo GetUserDefinedCoercionMethod(Type convertFrom, Type convertToType, bool implicitOnly);
    private static MethodInfo FindConversionOperator(IEnumerable`1<MethodInfo> methods, Type typeFrom, Type typeTo, bool implicitOnly);
    private static bool IsImplicitNumericConversion(Type source, Type destination);
    private static bool IsImplicitReferenceConversion(Type source, Type destination);
    private static bool IsImplicitBoxingConversion(Type source, Type destination);
    private static bool IsImplicitNullableConversion(Type source, Type destination);
    public static Type FindGenericType(Type definition, Type type);
    public static MethodInfo GetBooleanOperator(Type type, string name);
    [ExtensionAttribute]
public static Type GetNonRefType(Type type);
    [ExtensionAttribute]
public static bool IsVector(Type type);
}
internal class System.Linq.Expressions.AssignBinaryExpression : BinaryExpression {
    public Type Type { get; }
    public ExpressionType NodeType { get; }
    internal AssignBinaryExpression(Expression left, Expression right);
    public sealed virtual Type get_Type();
    public sealed virtual ExpressionType get_NodeType();
}
[DebuggerTypeProxyAttribute("System.Linq.Expressions.Expression/BinaryExpressionProxy")]
public class System.Linq.Expressions.BinaryExpression : Expression {
    private Expression _left;
    private Expression _right;
    public bool CanReduce { get; }
    public Expression Right { get; }
    public Expression Left { get; }
    public MethodInfo Method { get; }
    public LambdaExpression Conversion { get; }
    public bool IsLifted { get; }
    public bool IsLiftedToNull { get; }
    internal bool IsLiftedLogical { get; }
    internal bool IsReferenceComparison { get; }
    internal BinaryExpression(Expression left, Expression right);
    public virtual bool get_CanReduce();
    private static bool IsOpAssignment(ExpressionType op);
    public Expression get_Right();
    public Expression get_Left();
    public MethodInfo get_Method();
    internal virtual MethodInfo GetMethod();
    public BinaryExpression Update(Expression left, LambdaExpression conversion, Expression right);
    public virtual Expression Reduce();
    private static ExpressionType GetBinaryOpFromAssignmentOp(ExpressionType op);
    private Expression ReduceVariable();
    private Expression ReduceMember();
    private Expression ReduceIndex();
    public LambdaExpression get_Conversion();
    internal virtual LambdaExpression GetConversion();
    public bool get_IsLifted();
    public bool get_IsLiftedToNull();
    protected internal virtual Expression Accept(ExpressionVisitor visitor);
    internal static Expression Create(ExpressionType nodeType, Expression left, Expression right, Type type, MethodInfo method, LambdaExpression conversion);
    internal bool get_IsLiftedLogical();
    internal bool get_IsReferenceComparison();
    internal Expression ReduceUserdefinedLifted();
}
internal class System.Linq.Expressions.Block2 : BlockExpression {
    private object _arg0;
    private Expression _arg1;
    internal int ExpressionCount { get; }
    internal Block2(Expression arg0, Expression arg1);
    internal virtual Expression GetExpression(int index);
    internal virtual int get_ExpressionCount();
    internal virtual ReadOnlyCollection`1<Expression> GetOrMakeExpressions();
    internal virtual BlockExpression Rewrite(ReadOnlyCollection`1<ParameterExpression> variables, Expression[] args);
}
internal class System.Linq.Expressions.Block3 : BlockExpression {
    private object _arg0;
    private Expression _arg1;
    private Expression _arg2;
    internal int ExpressionCount { get; }
    internal Block3(Expression arg0, Expression arg1, Expression arg2);
    internal virtual Expression GetExpression(int index);
    internal virtual int get_ExpressionCount();
    internal virtual ReadOnlyCollection`1<Expression> GetOrMakeExpressions();
    internal virtual BlockExpression Rewrite(ReadOnlyCollection`1<ParameterExpression> variables, Expression[] args);
}
internal class System.Linq.Expressions.Block4 : BlockExpression {
    private object _arg0;
    private Expression _arg1;
    private Expression _arg2;
    private Expression _arg3;
    internal int ExpressionCount { get; }
    internal Block4(Expression arg0, Expression arg1, Expression arg2, Expression arg3);
    internal virtual Expression GetExpression(int index);
    internal virtual int get_ExpressionCount();
    internal virtual ReadOnlyCollection`1<Expression> GetOrMakeExpressions();
    internal virtual BlockExpression Rewrite(ReadOnlyCollection`1<ParameterExpression> variables, Expression[] args);
}
internal class System.Linq.Expressions.Block5 : BlockExpression {
    private object _arg0;
    private Expression _arg1;
    private Expression _arg2;
    private Expression _arg3;
    private Expression _arg4;
    internal int ExpressionCount { get; }
    internal Block5(Expression arg0, Expression arg1, Expression arg2, Expression arg3, Expression arg4);
    internal virtual Expression GetExpression(int index);
    internal virtual int get_ExpressionCount();
    internal virtual ReadOnlyCollection`1<Expression> GetOrMakeExpressions();
    internal virtual BlockExpression Rewrite(ReadOnlyCollection`1<ParameterExpression> variables, Expression[] args);
}
[DebuggerTypeProxyAttribute("System.Linq.Expressions.Expression/BlockExpressionProxy")]
public class System.Linq.Expressions.BlockExpression : Expression {
    public ReadOnlyCollection`1<Expression> Expressions { get; }
    public ReadOnlyCollection`1<ParameterExpression> Variables { get; }
    public Expression Result { get; }
    public ExpressionType NodeType { get; }
    public Type Type { get; }
    internal int ExpressionCount { get; }
    public ReadOnlyCollection`1<Expression> get_Expressions();
    public ReadOnlyCollection`1<ParameterExpression> get_Variables();
    public Expression get_Result();
    protected internal virtual Expression Accept(ExpressionVisitor visitor);
    public sealed virtual ExpressionType get_NodeType();
    public virtual Type get_Type();
    public BlockExpression Update(IEnumerable`1<ParameterExpression> variables, IEnumerable`1<Expression> expressions);
    internal virtual Expression GetExpression(int index);
    internal virtual int get_ExpressionCount();
    internal virtual ReadOnlyCollection`1<Expression> GetOrMakeExpressions();
    internal virtual ReadOnlyCollection`1<ParameterExpression> GetOrMakeVariables();
    internal virtual BlockExpression Rewrite(ReadOnlyCollection`1<ParameterExpression> variables, Expression[] args);
    internal static ReadOnlyCollection`1<Expression> ReturnReadOnlyExpressions(BlockExpression provider, Object& collection);
}
[DefaultMemberAttribute("Item")]
internal class System.Linq.Expressions.BlockExpressionList : object {
    private BlockExpression _block;
    private Expression _arg0;
    public Expression Item { get; public set; }
    public int Count { get; }
    public bool IsReadOnly { get; }
    internal BlockExpressionList(BlockExpression provider, Expression arg0);
    public sealed virtual int IndexOf(Expression item);
    public sealed virtual void Insert(int index, Expression item);
    public sealed virtual void RemoveAt(int index);
    public sealed virtual Expression get_Item(int index);
    public sealed virtual void set_Item(int index, Expression value);
    public sealed virtual void Add(Expression item);
    public sealed virtual void Clear();
    public sealed virtual bool Contains(Expression item);
    public sealed virtual void CopyTo(Expression[] array, int arrayIndex);
    public sealed virtual int get_Count();
    public sealed virtual bool get_IsReadOnly();
    public sealed virtual bool Remove(Expression item);
    [IteratorStateMachineAttribute("System.Linq.Expressions.BlockExpressionList/<GetEnumerator>d__18")]
public sealed virtual IEnumerator`1<Expression> GetEnumerator();
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
}
internal class System.Linq.Expressions.BlockN : BlockExpression {
    private IList`1<Expression> _expressions;
    internal int ExpressionCount { get; }
    internal BlockN(IList`1<Expression> expressions);
    internal virtual Expression GetExpression(int index);
    internal virtual int get_ExpressionCount();
    internal virtual ReadOnlyCollection`1<Expression> GetOrMakeExpressions();
    internal virtual BlockExpression Rewrite(ReadOnlyCollection`1<ParameterExpression> variables, Expression[] args);
}
internal class System.Linq.Expressions.ByRefParameterExpression : TypedParameterExpression {
    internal ByRefParameterExpression(Type type, string name);
    internal virtual bool GetIsByRef();
}
[DebuggerTypeProxyAttribute("System.Linq.Expressions.Expression/CatchBlockProxy")]
public class System.Linq.Expressions.CatchBlock : object {
    private Type _test;
    private ParameterExpression _var;
    private Expression _body;
    private Expression _filter;
    public ParameterExpression Variable { get; }
    public Type Test { get; }
    public Expression Body { get; }
    public Expression Filter { get; }
    internal CatchBlock(Type test, ParameterExpression variable, Expression body, Expression filter);
    public ParameterExpression get_Variable();
    public Type get_Test();
    public Expression get_Body();
    public Expression get_Filter();
    public virtual string ToString();
    public CatchBlock Update(ParameterExpression variable, Expression filter, Expression body);
}
internal class System.Linq.Expressions.ClearDebugInfoExpression : DebugInfoExpression {
    public bool IsClear { get; }
    public int StartLine { get; }
    public int StartColumn { get; }
    public int EndLine { get; }
    public int EndColumn { get; }
    internal ClearDebugInfoExpression(SymbolDocumentInfo document);
    public virtual bool get_IsClear();
    public virtual int get_StartLine();
    public virtual int get_StartColumn();
    public virtual int get_EndLine();
    public virtual int get_EndColumn();
}
internal class System.Linq.Expressions.CoalesceConversionBinaryExpression : BinaryExpression {
    private LambdaExpression _conversion;
    public ExpressionType NodeType { get; }
    public Type Type { get; }
    internal CoalesceConversionBinaryExpression(Expression left, Expression right, LambdaExpression conversion);
    internal virtual LambdaExpression GetConversion();
    public sealed virtual ExpressionType get_NodeType();
    public sealed virtual Type get_Type();
}
internal static class System.Linq.Expressions.Compiler.DelegateHelpers : object {
    private static TypeInfo _DelegateCache;
    private static int MaximumArity;
    private static DelegateHelpers();
    private static Type MakeNewCustomDelegate(Type[] types);
    private static TypeInfo NextTypeInfo(Type initialArg, TypeInfo curTypeInfo);
    private static Type TryMakeVBStyledCallSite(Type[] types);
    internal static Type MakeNewDelegate(Type[] types);
    internal static Type GetFuncType(Type[] types);
    internal static Type GetActionType(Type[] types);
    internal static Type MakeDelegateType(Type[] types);
}
[DebuggerTypeProxyAttribute("System.Linq.Expressions.Expression/ConditionalExpressionProxy")]
public class System.Linq.Expressions.ConditionalExpression : Expression {
    private Expression _test;
    private Expression _true;
    public ExpressionType NodeType { get; }
    public Type Type { get; }
    public Expression Test { get; }
    public Expression IfTrue { get; }
    public Expression IfFalse { get; }
    internal ConditionalExpression(Expression test, Expression ifTrue);
    internal static ConditionalExpression Make(Expression test, Expression ifTrue, Expression ifFalse, Type type);
    public sealed virtual ExpressionType get_NodeType();
    public virtual Type get_Type();
    public Expression get_Test();
    public Expression get_IfTrue();
    public Expression get_IfFalse();
    internal virtual Expression GetFalse();
    protected internal virtual Expression Accept(ExpressionVisitor visitor);
    public ConditionalExpression Update(Expression test, Expression ifTrue, Expression ifFalse);
}
[DebuggerTypeProxyAttribute("System.Linq.Expressions.Expression/ConstantExpressionProxy")]
public class System.Linq.Expressions.ConstantExpression : Expression {
    private object _value;
    public Type Type { get; }
    public ExpressionType NodeType { get; }
    public object Value { get; }
    internal ConstantExpression(object value);
    public virtual Type get_Type();
    public sealed virtual ExpressionType get_NodeType();
    public object get_Value();
    protected internal virtual Expression Accept(ExpressionVisitor visitor);
}
[DebuggerTypeProxyAttribute("System.Linq.Expressions.Expression/DebugInfoExpressionProxy")]
public class System.Linq.Expressions.DebugInfoExpression : Expression {
    private SymbolDocumentInfo _document;
    public Type Type { get; }
    public ExpressionType NodeType { get; }
    public int StartLine { get; }
    public int StartColumn { get; }
    public int EndLine { get; }
    public int EndColumn { get; }
    public SymbolDocumentInfo Document { get; }
    public bool IsClear { get; }
    internal DebugInfoExpression(SymbolDocumentInfo document);
    public sealed virtual Type get_Type();
    public sealed virtual ExpressionType get_NodeType();
    public virtual int get_StartLine();
    public virtual int get_StartColumn();
    public virtual int get_EndLine();
    public virtual int get_EndColumn();
    public SymbolDocumentInfo get_Document();
    public virtual bool get_IsClear();
    protected internal virtual Expression Accept(ExpressionVisitor visitor);
}
internal class System.Linq.Expressions.DebugViewWriter : ExpressionVisitor {
    private static int Tab;
    private static int MaxColumn;
    private TextWriter _out;
    private int _column;
    private Stack`1<int> _stack;
    private int _delta;
    private Flow _flow;
    private Queue`1<LambdaExpression> _lambdas;
    private Dictionary`2<LambdaExpression, int> _lambdaIds;
    private Dictionary`2<ParameterExpression, int> _paramIds;
    private Dictionary`2<LabelTarget, int> _labelIds;
    private int Base { get; }
    private int Delta { get; }
    private int Depth { get; }
    private DebugViewWriter(TextWriter file);
    private int get_Base();
    private int get_Delta();
    private int get_Depth();
    private void Indent();
    private void Dedent();
    private void NewLine();
    private static int GetId(T e, Dictionary`2& ids);
    private int GetLambdaId(LambdaExpression le);
    private int GetParamId(ParameterExpression p);
    private int GetLabelTargetId(LabelTarget target);
    internal static void WriteTo(Expression node, TextWriter writer);
    private void WriteTo(Expression node);
    private void Out(string s);
    private void Out(Flow before, string s);
    private void Out(string s, Flow after);
    private void Out(Flow before, string s, Flow after);
    private void WriteLine();
    private void Write(string s);
    private Flow GetFlow(Flow flow);
    private Flow CheckBreak(Flow flow);
    private void VisitExpressions(char open, IList`1<T> expressions);
    private void VisitExpressions(char open, char separator, IList`1<T> expressions);
    private void VisitDeclarations(IList`1<ParameterExpression> expressions);
    private void VisitExpressions(char open, char separator, IList`1<T> expressions, Action`1<T> visit);
    protected internal virtual Expression VisitBinary(BinaryExpression node);
    protected internal virtual Expression VisitParameter(ParameterExpression node);
    protected internal virtual Expression VisitLambda(Expression`1<T> node);
    private static bool IsSimpleExpression(Expression node);
    protected internal virtual Expression VisitConditional(ConditionalExpression node);
    protected internal virtual Expression VisitConstant(ConstantExpression node);
    private static string GetConstantValueSuffix(Type type);
    protected internal virtual Expression VisitRuntimeVariables(RuntimeVariablesExpression node);
    private void OutMember(Expression node, Expression instance, MemberInfo member);
    protected internal virtual Expression VisitMember(MemberExpression node);
    protected internal virtual Expression VisitInvocation(InvocationExpression node);
    private static bool NeedsParentheses(Expression parent, Expression child);
    private static int GetOperatorPrecedence(Expression node);
    private void ParenthesizedVisit(Expression parent, Expression nodeToVisit);
    protected internal virtual Expression VisitMethodCall(MethodCallExpression node);
    protected internal virtual Expression VisitNewArray(NewArrayExpression node);
    protected internal virtual Expression VisitNew(NewExpression node);
    protected virtual ElementInit VisitElementInit(ElementInit node);
    protected internal virtual Expression VisitListInit(ListInitExpression node);
    protected virtual MemberAssignment VisitMemberAssignment(MemberAssignment assignment);
    protected virtual MemberListBinding VisitMemberListBinding(MemberListBinding binding);
    protected virtual MemberMemberBinding VisitMemberMemberBinding(MemberMemberBinding binding);
    protected internal virtual Expression VisitMemberInit(MemberInitExpression node);
    protected internal virtual Expression VisitTypeBinary(TypeBinaryExpression node);
    protected internal virtual Expression VisitUnary(UnaryExpression node);
    protected internal virtual Expression VisitBlock(BlockExpression node);
    protected internal virtual Expression VisitDefault(DefaultExpression node);
    protected internal virtual Expression VisitLabel(LabelExpression node);
    protected internal virtual Expression VisitGoto(GotoExpression node);
    protected internal virtual Expression VisitLoop(LoopExpression node);
    protected virtual SwitchCase VisitSwitchCase(SwitchCase node);
    protected internal virtual Expression VisitSwitch(SwitchExpression node);
    protected virtual CatchBlock VisitCatchBlock(CatchBlock node);
    protected internal virtual Expression VisitTry(TryExpression node);
    protected internal virtual Expression VisitIndex(IndexExpression node);
    protected internal virtual Expression VisitExtension(Expression node);
    protected internal virtual Expression VisitDebugInfo(DebugInfoExpression node);
    private void DumpLabel(LabelTarget target);
    private string GetLabelTargetName(LabelTarget target);
    private void WriteLambda(LambdaExpression lambda);
    private string GetLambdaName(LambdaExpression lambda);
    private static bool ContainsWhiteSpace(string name);
    private static string QuoteName(string name);
    private static string GetDisplayName(string name);
    [CompilerGeneratedAttribute]
private void <VisitExpressions>b__37_0(T e);
    [CompilerGeneratedAttribute]
private void <VisitDeclarations>b__38_0(ParameterExpression variable);
    [CompilerGeneratedAttribute]
private void <VisitListInit>b__58_0(ElementInit e);
    [CompilerGeneratedAttribute]
private void <VisitMemberListBinding>b__60_0(ElementInit e);
    [CompilerGeneratedAttribute]
private void <VisitMemberMemberBinding>b__61_0(MemberBinding e);
    [CompilerGeneratedAttribute]
private void <VisitMemberInit>b__62_0(MemberBinding e);
}
[DebuggerTypeProxyAttribute("System.Linq.Expressions.Expression/DefaultExpressionProxy")]
public class System.Linq.Expressions.DefaultExpression : Expression {
    private Type _type;
    public Type Type { get; }
    public ExpressionType NodeType { get; }
    internal DefaultExpression(Type type);
    public sealed virtual Type get_Type();
    public sealed virtual ExpressionType get_NodeType();
    protected internal virtual Expression Accept(ExpressionVisitor visitor);
}
public class System.Linq.Expressions.ElementInit : object {
    private MethodInfo _addMethod;
    private ReadOnlyCollection`1<Expression> _arguments;
    public MethodInfo AddMethod { get; }
    public ReadOnlyCollection`1<Expression> Arguments { get; }
    public int ArgumentCount { get; }
    internal ElementInit(MethodInfo addMethod, ReadOnlyCollection`1<Expression> arguments);
    public MethodInfo get_AddMethod();
    public ReadOnlyCollection`1<Expression> get_Arguments();
    public sealed virtual Expression GetArgument(int index);
    public sealed virtual int get_ArgumentCount();
    public virtual string ToString();
    public ElementInit Update(IEnumerable`1<Expression> arguments);
}
internal static class System.Linq.Expressions.Error : object {
    internal static Exception ReducibleMustOverrideReduce();
    internal static Exception MustReduceToDifferent();
    internal static Exception ReducedNotCompatible();
    internal static Exception SetterHasNoParams(string paramName);
    internal static Exception PropertyCannotHaveRefType(string paramName);
    internal static Exception IndexesOfSetGetMustMatch(string paramName);
    internal static Exception AccessorsCannotHaveVarArgs(string paramName);
    internal static Exception AccessorsCannotHaveByRefArgs(string paramName);
    internal static Exception BoundsCannotBeLessThanOne(string paramName);
    internal static Exception TypeMustNotBeByRef(string paramName);
    internal static Exception TypeMustNotBePointer(string paramName);
    internal static Exception TypeDoesNotHaveConstructorForTheSignature();
    internal static Exception SetterMustBeVoid(string paramName);
    internal static Exception PropertyTypeMustMatchSetter(string paramName);
    internal static Exception BothAccessorsMustBeStatic(string paramName);
    internal static Exception OnlyStaticMethodsHaveNullInstance();
    internal static Exception PropertyTypeCannotBeVoid(string paramName);
    internal static Exception InvalidUnboxType(string paramName);
    internal static Exception ArgumentMustNotHaveValueType(string paramName);
    internal static Exception MustBeReducible();
    internal static Exception DefaultBodyMustBeSupplied(string paramName);
    internal static Exception LabelMustBeVoidOrHaveExpression(string paramName);
    internal static Exception LabelTypeMustBeVoid(string paramName);
    internal static Exception QuotedExpressionMustBeLambda(string paramName);
    internal static Exception VariableMustNotBeByRef(object p0, object p1, string paramName);
    internal static Exception DuplicateVariable(object p0, string paramName);
    internal static Exception StartEndMustBeOrdered();
    internal static Exception FaultCannotHaveCatchOrFinally(string paramName);
    internal static Exception TryMustHaveCatchFinallyOrFault();
    internal static Exception BodyOfCatchMustHaveSameTypeAsBodyOfTry();
    internal static Exception ExtensionNodeMustOverrideProperty(object p0);
    internal static Exception UserDefinedOperatorMustBeStatic(object p0, string paramName);
    internal static Exception UserDefinedOperatorMustNotBeVoid(object p0, string paramName);
    internal static Exception CoercionOperatorNotDefined(object p0, object p1);
    internal static Exception UnaryOperatorNotDefined(object p0, object p1);
    internal static Exception BinaryOperatorNotDefined(object p0, object p1, object p2);
    internal static Exception ReferenceEqualityNotDefined(object p0, object p1);
    internal static Exception OperandTypesDoNotMatchParameters(object p0, object p1);
    internal static Exception OverloadOperatorTypeDoesNotMatchConversionType(object p0, object p1);
    internal static Exception ConversionIsNotSupportedForArithmeticTypes();
    internal static Exception ArgumentMustBeArray(string paramName);
    internal static Exception ArgumentMustBeBoolean(string paramName);
    internal static Exception EqualityMustReturnBoolean(object p0, string paramName);
    internal static Exception ArgumentMustBeFieldInfoOrPropertyInfo(string paramName);
    internal static Exception ArgumentMustBeFieldInfoOrPropertyInfoOrMethod(string paramName);
    internal static Exception ArgumentMustBeInstanceMember(string paramName);
    internal static Exception ArgumentMustBeInteger(string paramName);
    internal static Exception ArgumentMustBeArrayIndexType(string paramName);
    internal static Exception ArgumentMustBeSingleDimensionalArrayType(string paramName);
    internal static Exception ArgumentTypesMustMatch();
    internal static Exception CannotAutoInitializeValueTypeElementThroughProperty(object p0);
    internal static Exception CannotAutoInitializeValueTypeMemberThroughProperty(object p0);
    internal static Exception IncorrectTypeForTypeAs(object p0, string paramName);
    internal static Exception CoalesceUsedOnNonNullType();
    internal static Exception ExpressionTypeCannotInitializeArrayType(object p0, object p1);
    internal static Exception ExpressionTypeDoesNotMatchConstructorParameter(object p0, object p1);
    internal static Exception ArgumentTypeDoesNotMatchMember(object p0, object p1);
    internal static Exception ArgumentMemberNotDeclOnType(object p0, object p1);
    internal static Exception ExpressionTypeDoesNotMatchMethodParameter(object p0, object p1, object p2);
    internal static Exception ExpressionTypeDoesNotMatchReturn(object p0, object p1);
    internal static Exception ExpressionTypeDoesNotMatchAssignment(object p0, object p1);
    internal static Exception ExpressionTypeDoesNotMatchLabel(object p0, object p1);
    internal static Exception ExpressionTypeNotInvocable(object p0, string paramName);
    internal static Exception FieldNotDefinedForType(object p0, object p1);
    internal static Exception InstanceFieldNotDefinedForType(object p0, object p1);
    internal static Exception FieldInfoNotDefinedForType(object p0, object p1, object p2);
    internal static Exception IncorrectNumberOfIndexes();
    internal static Exception IncorrectNumberOfLambdaDeclarationParameters();
    internal static Exception IncorrectNumberOfMethodCallArguments(object p0);
    internal static Exception IncorrectNumberOfConstructorArguments();
    internal static Exception IncorrectNumberOfMembersForGivenConstructor();
    internal static Exception IncorrectNumberOfArgumentsForMembers();
    internal static Exception LambdaTypeMustBeDerivedFromSystemDelegate();
    internal static Exception MemberNotFieldOrProperty(object p0, string paramName);
    internal static Exception MethodContainsGenericParameters(object p0, string paramName);
    internal static Exception MethodIsGeneric(object p0, string paramName);
    internal static Exception MethodNotPropertyAccessor(object p0, object p1, string paramName);
    internal static Exception PropertyDoesNotHaveGetter(object p0, string paramName);
    internal static Exception PropertyDoesNotHaveSetter(object p0, string paramName);
    internal static Exception PropertyDoesNotHaveAccessor(object p0, string paramName);
    internal static Exception NotAMemberOfType(object p0, object p1);
    internal static Exception ExpressionNotSupportedForType(object p0, object p1);
    internal static Exception ExpressionNotSupportedForNullableType(object p0, object p1);
    internal static Exception ParameterExpressionNotValidAsDelegate(object p0, object p1);
    internal static Exception PropertyNotDefinedForType(object p0, object p1);
    internal static Exception InstancePropertyNotDefinedForType(object p0, object p1);
    internal static Exception InstancePropertyWithoutParameterNotDefinedForType(object p0, object p1);
    internal static Exception InstancePropertyWithSpecifiedParametersNotDefinedForType(object p0, object p1, object p2);
    internal static Exception InstanceAndMethodTypeMismatch(object p0, object p1, object p2);
    internal static Exception TypeMissingDefaultConstructor(object p0, string paramName);
    internal static Exception ElementInitializerMethodNotAdd(string paramName);
    internal static Exception ElementInitializerMethodNoRefOutParam(object p0, object p1, string paramName);
    internal static Exception ElementInitializerMethodWithZeroArgs(string paramName);
    internal static Exception ElementInitializerMethodStatic(string paramName);
    internal static Exception TypeNotIEnumerable(object p0, string paramName);
    internal static Exception UnexpectedCoalesceOperator();
    internal static Exception InvalidCast(object p0, object p1);
    internal static Exception UnhandledBinary(object p0);
    internal static Exception UnhandledBinding();
    internal static Exception UnhandledBindingType(object p0);
    internal static Exception UnhandledConvert(object p0);
    internal static Exception UnhandledExpressionType(object p0);
    internal static Exception UnhandledUnary(object p0);
    internal static Exception UnknownBindingType();
    internal static Exception UserDefinedOpMustHaveConsistentTypes(object p0, object p1);
    internal static Exception UserDefinedOpMustHaveValidReturnType(object p0, object p1);
    internal static Exception LogicalOperatorMustHaveBooleanOperators(object p0, object p1);
    internal static Exception MethodDoesNotExistOnType(object p0, object p1);
    internal static Exception MethodWithArgsDoesNotExistOnType(object p0, object p1);
    internal static Exception GenericMethodWithArgsDoesNotExistOnType(object p0, object p1);
    internal static Exception MethodWithMoreThanOneMatch(object p0, object p1);
    internal static Exception PropertyWithMoreThanOneMatch(object p0, object p1);
    internal static Exception IncorrectNumberOfTypeArgsForFunc(string paramName);
    internal static Exception IncorrectNumberOfTypeArgsForAction(string paramName);
    internal static Exception ArgumentCannotBeOfTypeVoid(string paramName);
    internal static Exception OutOfRange(string paramName, object p1);
    internal static Exception LabelTargetAlreadyDefined(object p0);
    internal static Exception LabelTargetUndefined(object p0);
    internal static Exception ControlCannotLeaveFinally();
    internal static Exception ControlCannotLeaveFilterTest();
    internal static Exception AmbiguousJump(object p0);
    internal static Exception ControlCannotEnterTry();
    internal static Exception ControlCannotEnterExpression();
    internal static Exception NonLocalJumpWithValue(object p0);
    internal static Exception ExtensionNotReduced();
    internal static Exception CannotCompileConstant(object p0);
    internal static Exception CannotCompileDynamic();
    internal static Exception InvalidLvalue(ExpressionType p0);
    internal static Exception InvalidMemberType(object p0);
    internal static Exception UnknownLiftType(object p0);
    internal static Exception IllegalNewGenericParams(object p0, string paramName);
    internal static Exception UndefinedVariable(object p0, object p1, object p2);
    internal static Exception CannotCloseOverByRef(object p0, object p1);
    internal static Exception UnexpectedVarArgsCall(object p0);
    internal static Exception RethrowRequiresCatch();
    internal static Exception TryNotAllowedInFilter();
    internal static Exception MustRewriteToSameNode(object p0, object p1, object p2);
    internal static Exception MustRewriteChildToSameType(object p0, object p1, object p2);
    internal static Exception MustRewriteWithoutMethod(object p0, object p1);
    internal static Exception TryNotSupportedForMethodsWithRefArgs(object p0);
    internal static Exception TryNotSupportedForValueTypeInstances(object p0);
    internal static Exception HomogeneousAppDomainRequired();
    internal static Exception TestValueTypeDoesNotMatchComparisonMethodParameter(object p0, object p1);
    internal static Exception SwitchValueTypeDoesNotMatchComparisonMethodParameter(object p0, object p1);
    internal static Exception PdbGeneratorNeedsExpressionCompiler();
    internal static Exception ArgumentOutOfRange(string paramName);
    internal static Exception NotSupported();
    internal static Exception NonStaticConstructorRequired(string paramName);
    internal static Exception NonAbstractConstructorRequired();
}
public abstract class System.Linq.Expressions.Expression : object {
    private static CacheDict`2<Type, MethodInfo> s_lambdaDelegateCache;
    private static CacheDict`2 modreq(System.Runtime.CompilerServices.IsVolatile) s_lambdaFactories;
    private static ConditionalWeakTable`2<Expression, ExtensionInfo> s_legacyCtorSupportTable;
    public ExpressionType NodeType { get; }
    public Type Type { get; }
    public bool CanReduce { get; }
    private string DebugView { get; }
    [ObsoleteAttribute("use a different constructor that does not take ExpressionType. Then override NodeType and Type properties to provide the values that would be specified to this constructor.")]
protected Expression(ExpressionType nodeType, Type type);
    private static Expression();
    public static BinaryExpression Assign(Expression left, Expression right);
    private static BinaryExpression GetUserDefinedBinaryOperator(ExpressionType binaryType, string name, Expression left, Expression right, bool liftToNull);
    private static BinaryExpression GetMethodBasedBinaryOperator(ExpressionType binaryType, Expression left, Expression right, MethodInfo method, bool liftToNull);
    private static BinaryExpression GetMethodBasedAssignOperator(ExpressionType binaryType, Expression left, Expression right, MethodInfo method, LambdaExpression conversion, bool liftToNull);
    private static BinaryExpression GetUserDefinedBinaryOperatorOrThrow(ExpressionType binaryType, string name, Expression left, Expression right, bool liftToNull);
    private static BinaryExpression GetUserDefinedAssignOperatorOrThrow(ExpressionType binaryType, string name, Expression left, Expression right, LambdaExpression conversion, bool liftToNull);
    private static MethodInfo GetUserDefinedBinaryOperator(ExpressionType binaryType, Type leftType, Type rightType, string name);
    private static bool IsLiftingConditionalLogicalOperator(Type left, Type right, MethodInfo method, ExpressionType binaryType);
    internal static bool ParameterIsAssignable(ParameterInfo pi, Type argType);
    private static void ValidateParamswithOperandsOrThrow(Type paramType, Type operandType, ExpressionType exprType, string name);
    private static void ValidateOperator(MethodInfo method, string paramName);
    private static void ValidateMethodInfo(MethodInfo method, string paramName);
    private static bool IsNullComparison(Expression left, Expression right);
    private static bool IsNullConstant(Expression e);
    private static void ValidateUserDefinedConditionalLogicOperator(ExpressionType nodeType, Type left, Type right, MethodInfo method);
    private static void VerifyOpTrueFalse(ExpressionType nodeType, Type left, MethodInfo opTrue);
    private static bool IsValidLiftedConditionalLogicalOperator(Type left, Type right, ParameterInfo[] pms);
    public static BinaryExpression MakeBinary(ExpressionType binaryType, Expression left, Expression right);
    public static BinaryExpression MakeBinary(ExpressionType binaryType, Expression left, Expression right, bool liftToNull, MethodInfo method);
    public static BinaryExpression MakeBinary(ExpressionType binaryType, Expression left, Expression right, bool liftToNull, MethodInfo method, LambdaExpression conversion);
    public static BinaryExpression Equal(Expression left, Expression right);
    public static BinaryExpression Equal(Expression left, Expression right, bool liftToNull, MethodInfo method);
    public static BinaryExpression ReferenceEqual(Expression left, Expression right);
    public static BinaryExpression NotEqual(Expression left, Expression right);
    public static BinaryExpression NotEqual(Expression left, Expression right, bool liftToNull, MethodInfo method);
    public static BinaryExpression ReferenceNotEqual(Expression left, Expression right);
    private static BinaryExpression GetEqualityComparisonOperator(ExpressionType binaryType, string opName, Expression left, Expression right, bool liftToNull);
    public static BinaryExpression GreaterThan(Expression left, Expression right);
    public static BinaryExpression GreaterThan(Expression left, Expression right, bool liftToNull, MethodInfo method);
    public static BinaryExpression LessThan(Expression left, Expression right);
    public static BinaryExpression LessThan(Expression left, Expression right, bool liftToNull, MethodInfo method);
    public static BinaryExpression GreaterThanOrEqual(Expression left, Expression right);
    public static BinaryExpression GreaterThanOrEqual(Expression left, Expression right, bool liftToNull, MethodInfo method);
    public static BinaryExpression LessThanOrEqual(Expression left, Expression right);
    public static BinaryExpression LessThanOrEqual(Expression left, Expression right, bool liftToNull, MethodInfo method);
    private static BinaryExpression GetComparisonOperator(ExpressionType binaryType, string opName, Expression left, Expression right, bool liftToNull);
    public static BinaryExpression AndAlso(Expression left, Expression right);
    public static BinaryExpression AndAlso(Expression left, Expression right, MethodInfo method);
    public static BinaryExpression OrElse(Expression left, Expression right);
    public static BinaryExpression OrElse(Expression left, Expression right, MethodInfo method);
    public static BinaryExpression Coalesce(Expression left, Expression right);
    public static BinaryExpression Coalesce(Expression left, Expression right, LambdaExpression conversion);
    private static Type ValidateCoalesceArgTypes(Type left, Type right);
    public static BinaryExpression Add(Expression left, Expression right);
    public static BinaryExpression Add(Expression left, Expression right, MethodInfo method);
    public static BinaryExpression AddAssign(Expression left, Expression right);
    public static BinaryExpression AddAssign(Expression left, Expression right, MethodInfo method);
    public static BinaryExpression AddAssign(Expression left, Expression right, MethodInfo method, LambdaExpression conversion);
    private static void ValidateOpAssignConversionLambda(LambdaExpression conversion, Expression left, MethodInfo method, ExpressionType nodeType);
    public static BinaryExpression AddAssignChecked(Expression left, Expression right);
    public static BinaryExpression AddAssignChecked(Expression left, Expression right, MethodInfo method);
    public static BinaryExpression AddAssignChecked(Expression left, Expression right, MethodInfo method, LambdaExpression conversion);
    public static BinaryExpression AddChecked(Expression left, Expression right);
    public static BinaryExpression AddChecked(Expression left, Expression right, MethodInfo method);
    public static BinaryExpression Subtract(Expression left, Expression right);
    public static BinaryExpression Subtract(Expression left, Expression right, MethodInfo method);
    public static BinaryExpression SubtractAssign(Expression left, Expression right);
    public static BinaryExpression SubtractAssign(Expression left, Expression right, MethodInfo method);
    public static BinaryExpression SubtractAssign(Expression left, Expression right, MethodInfo method, LambdaExpression conversion);
    public static BinaryExpression SubtractAssignChecked(Expression left, Expression right);
    public static BinaryExpression SubtractAssignChecked(Expression left, Expression right, MethodInfo method);
    public static BinaryExpression SubtractAssignChecked(Expression left, Expression right, MethodInfo method, LambdaExpression conversion);
    public static BinaryExpression SubtractChecked(Expression left, Expression right);
    public static BinaryExpression SubtractChecked(Expression left, Expression right, MethodInfo method);
    public static BinaryExpression Divide(Expression left, Expression right);
    public static BinaryExpression Divide(Expression left, Expression right, MethodInfo method);
    public static BinaryExpression DivideAssign(Expression left, Expression right);
    public static BinaryExpression DivideAssign(Expression left, Expression right, MethodInfo method);
    public static BinaryExpression DivideAssign(Expression left, Expression right, MethodInfo method, LambdaExpression conversion);
    public static BinaryExpression Modulo(Expression left, Expression right);
    public static BinaryExpression Modulo(Expression left, Expression right, MethodInfo method);
    public static BinaryExpression ModuloAssign(Expression left, Expression right);
    public static BinaryExpression ModuloAssign(Expression left, Expression right, MethodInfo method);
    public static BinaryExpression ModuloAssign(Expression left, Expression right, MethodInfo method, LambdaExpression conversion);
    public static BinaryExpression Multiply(Expression left, Expression right);
    public static BinaryExpression Multiply(Expression left, Expression right, MethodInfo method);
    public static BinaryExpression MultiplyAssign(Expression left, Expression right);
    public static BinaryExpression MultiplyAssign(Expression left, Expression right, MethodInfo method);
    public static BinaryExpression MultiplyAssign(Expression left, Expression right, MethodInfo method, LambdaExpression conversion);
    public static BinaryExpression MultiplyAssignChecked(Expression left, Expression right);
    public static BinaryExpression MultiplyAssignChecked(Expression left, Expression right, MethodInfo method);
    public static BinaryExpression MultiplyAssignChecked(Expression left, Expression right, MethodInfo method, LambdaExpression conversion);
    public static BinaryExpression MultiplyChecked(Expression left, Expression right);
    public static BinaryExpression MultiplyChecked(Expression left, Expression right, MethodInfo method);
    private static bool IsSimpleShift(Type left, Type right);
    private static Type GetResultTypeOfShift(Type left, Type right);
    public static BinaryExpression LeftShift(Expression left, Expression right);
    public static BinaryExpression LeftShift(Expression left, Expression right, MethodInfo method);
    public static BinaryExpression LeftShiftAssign(Expression left, Expression right);
    public static BinaryExpression LeftShiftAssign(Expression left, Expression right, MethodInfo method);
    public static BinaryExpression LeftShiftAssign(Expression left, Expression right, MethodInfo method, LambdaExpression conversion);
    public static BinaryExpression RightShift(Expression left, Expression right);
    public static BinaryExpression RightShift(Expression left, Expression right, MethodInfo method);
    public static BinaryExpression RightShiftAssign(Expression left, Expression right);
    public static BinaryExpression RightShiftAssign(Expression left, Expression right, MethodInfo method);
    public static BinaryExpression RightShiftAssign(Expression left, Expression right, MethodInfo method, LambdaExpression conversion);
    public static BinaryExpression And(Expression left, Expression right);
    public static BinaryExpression And(Expression left, Expression right, MethodInfo method);
    public static BinaryExpression AndAssign(Expression left, Expression right);
    public static BinaryExpression AndAssign(Expression left, Expression right, MethodInfo method);
    public static BinaryExpression AndAssign(Expression left, Expression right, MethodInfo method, LambdaExpression conversion);
    public static BinaryExpression Or(Expression left, Expression right);
    public static BinaryExpression Or(Expression left, Expression right, MethodInfo method);
    public static BinaryExpression OrAssign(Expression left, Expression right);
    public static BinaryExpression OrAssign(Expression left, Expression right, MethodInfo method);
    public static BinaryExpression OrAssign(Expression left, Expression right, MethodInfo method, LambdaExpression conversion);
    public static BinaryExpression ExclusiveOr(Expression left, Expression right);
    public static BinaryExpression ExclusiveOr(Expression left, Expression right, MethodInfo method);
    public static BinaryExpression ExclusiveOrAssign(Expression left, Expression right);
    public static BinaryExpression ExclusiveOrAssign(Expression left, Expression right, MethodInfo method);
    public static BinaryExpression ExclusiveOrAssign(Expression left, Expression right, MethodInfo method, LambdaExpression conversion);
    public static BinaryExpression Power(Expression left, Expression right);
    public static BinaryExpression Power(Expression left, Expression right, MethodInfo method);
    public static BinaryExpression PowerAssign(Expression left, Expression right);
    public static BinaryExpression PowerAssign(Expression left, Expression right, MethodInfo method);
    public static BinaryExpression PowerAssign(Expression left, Expression right, MethodInfo method, LambdaExpression conversion);
    public static BinaryExpression ArrayIndex(Expression array, Expression index);
    public static BlockExpression Block(Expression arg0, Expression arg1);
    public static BlockExpression Block(Expression arg0, Expression arg1, Expression arg2);
    public static BlockExpression Block(Expression arg0, Expression arg1, Expression arg2, Expression arg3);
    public static BlockExpression Block(Expression arg0, Expression arg1, Expression arg2, Expression arg3, Expression arg4);
    public static BlockExpression Block(Expression[] expressions);
    public static BlockExpression Block(IEnumerable`1<Expression> expressions);
    public static BlockExpression Block(Type type, Expression[] expressions);
    public static BlockExpression Block(Type type, IEnumerable`1<Expression> expressions);
    public static BlockExpression Block(IEnumerable`1<ParameterExpression> variables, Expression[] expressions);
    public static BlockExpression Block(Type type, IEnumerable`1<ParameterExpression> variables, Expression[] expressions);
    public static BlockExpression Block(IEnumerable`1<ParameterExpression> variables, IEnumerable`1<Expression> expressions);
    public static BlockExpression Block(Type type, IEnumerable`1<ParameterExpression> variables, IEnumerable`1<Expression> expressions);
    private static BlockExpression BlockCore(Type type, ReadOnlyCollection`1<ParameterExpression> variables, ReadOnlyCollection`1<Expression> expressions);
    internal static void ValidateVariables(ReadOnlyCollection`1<ParameterExpression> varList, string collectionName);
    private static BlockExpression GetOptimizedBlockExpression(IReadOnlyList`1<Expression> expressions);
    public static CatchBlock Catch(Type type, Expression body);
    public static CatchBlock Catch(ParameterExpression variable, Expression body);
    public static CatchBlock Catch(Type type, Expression body, Expression filter);
    public static CatchBlock Catch(ParameterExpression variable, Expression body, Expression filter);
    public static CatchBlock MakeCatchBlock(Type type, ParameterExpression variable, Expression body, Expression filter);
    public static ConditionalExpression Condition(Expression test, Expression ifTrue, Expression ifFalse);
    public static ConditionalExpression Condition(Expression test, Expression ifTrue, Expression ifFalse, Type type);
    public static ConditionalExpression IfThen(Expression test, Expression ifTrue);
    public static ConditionalExpression IfThenElse(Expression test, Expression ifTrue, Expression ifFalse);
    public static ConstantExpression Constant(object value);
    public static ConstantExpression Constant(object value, Type type);
    public static DebugInfoExpression DebugInfo(SymbolDocumentInfo document, int startLine, int startColumn, int endLine, int endColumn);
    public static DebugInfoExpression ClearDebugInfo(SymbolDocumentInfo document);
    private static void ValidateSpan(int startLine, int startColumn, int endLine, int endColumn);
    public static DefaultExpression Empty();
    public static DefaultExpression Default(Type type);
    public static ElementInit ElementInit(MethodInfo addMethod, Expression[] arguments);
    public static ElementInit ElementInit(MethodInfo addMethod, IEnumerable`1<Expression> arguments);
    private static void ValidateElementInitAddMethodInfo(MethodInfo addMethod, string paramName);
    public virtual ExpressionType get_NodeType();
    public virtual Type get_Type();
    public virtual bool get_CanReduce();
    public virtual Expression Reduce();
    protected internal virtual Expression VisitChildren(ExpressionVisitor visitor);
    protected internal virtual Expression Accept(ExpressionVisitor visitor);
    public Expression ReduceAndCheck();
    public Expression ReduceExtensions();
    public virtual string ToString();
    private string get_DebugView();
    internal static ReadOnlyCollection`1<T> ReturnReadOnly(IList`1& collection);
    internal static ReadOnlyCollection`1<Expression> ReturnReadOnly(IArgumentProvider provider, Object& collection);
    internal static T ReturnObject(object collectionOrT);
    private static void RequiresCanRead(Expression expression, string paramName);
    private static void RequiresCanRead(IReadOnlyList`1<Expression> items, string paramName);
    private static void RequiresCanWrite(Expression expression, string paramName);
    public static GotoExpression Break(LabelTarget target);
    public static GotoExpression Break(LabelTarget target, Expression value);
    public static GotoExpression Break(LabelTarget target, Type type);
    public static GotoExpression Break(LabelTarget target, Expression value, Type type);
    public static GotoExpression Continue(LabelTarget target);
    public static GotoExpression Continue(LabelTarget target, Type type);
    public static GotoExpression Return(LabelTarget target);
    public static GotoExpression Return(LabelTarget target, Type type);
    public static GotoExpression Return(LabelTarget target, Expression value);
    public static GotoExpression Return(LabelTarget target, Expression value, Type type);
    public static GotoExpression Goto(LabelTarget target);
    public static GotoExpression Goto(LabelTarget target, Type type);
    public static GotoExpression Goto(LabelTarget target, Expression value);
    public static GotoExpression Goto(LabelTarget target, Expression value, Type type);
    public static GotoExpression MakeGoto(GotoExpressionKind kind, LabelTarget target, Expression value, Type type);
    private static void ValidateGoto(LabelTarget target, Expression& value, string targetParameter, string valueParameter);
    private static void ValidateGotoType(Type expectedType, Expression& value, string paramName);
    public static IndexExpression MakeIndex(Expression instance, PropertyInfo indexer, IEnumerable`1<Expression> arguments);
    public static IndexExpression ArrayAccess(Expression array, Expression[] indexes);
    public static IndexExpression ArrayAccess(Expression array, IEnumerable`1<Expression> indexes);
    public static IndexExpression Property(Expression instance, string propertyName, Expression[] arguments);
    private static PropertyInfo FindInstanceProperty(Type type, string propertyName, Expression[] arguments);
    private static string GetArgTypesString(Expression[] arguments);
    private static PropertyInfo FindProperty(Type type, string propertyName, Expression[] arguments, BindingFlags flags);
    private static int FindBestProperty(IEnumerable`1<PropertyInfo> properties, Expression[] args, PropertyInfo& property);
    private static bool IsCompatible(PropertyInfo pi, Expression[] args);
    public static IndexExpression Property(Expression instance, PropertyInfo indexer, Expression[] arguments);
    public static IndexExpression Property(Expression instance, PropertyInfo indexer, IEnumerable`1<Expression> arguments);
    private static void ValidateIndexedProperty(Expression instance, PropertyInfo property, ReadOnlyCollection`1& argList);
    private static void ValidateAccessor(Expression instance, MethodInfo method, ParameterInfo[] indexes, ReadOnlyCollection`1& arguments);
    private static void ValidateAccessorArgumentTypes(MethodInfo method, ParameterInfo[] indexes, ReadOnlyCollection`1& arguments);
    internal static InvocationExpression Invoke(Expression expression);
    internal static InvocationExpression Invoke(Expression expression, Expression arg0);
    internal static InvocationExpression Invoke(Expression expression, Expression arg0, Expression arg1);
    internal static InvocationExpression Invoke(Expression expression, Expression arg0, Expression arg1, Expression arg2);
    internal static InvocationExpression Invoke(Expression expression, Expression arg0, Expression arg1, Expression arg2, Expression arg3);
    internal static InvocationExpression Invoke(Expression expression, Expression arg0, Expression arg1, Expression arg2, Expression arg3, Expression arg4);
    public static InvocationExpression Invoke(Expression expression, Expression[] arguments);
    public static InvocationExpression Invoke(Expression expression, IEnumerable`1<Expression> arguments);
    internal static MethodInfo GetInvokeMethod(Expression expression);
    public static LabelExpression Label(LabelTarget target);
    public static LabelExpression Label(LabelTarget target, Expression defaultValue);
    public static LabelTarget Label();
    public static LabelTarget Label(string name);
    public static LabelTarget Label(Type type);
    public static LabelTarget Label(Type type, string name);
    internal static LambdaExpression CreateLambda(Type delegateType, Expression body, string name, bool tailCall, ReadOnlyCollection`1<ParameterExpression> parameters);
    public static Expression`1<TDelegate> Lambda(Expression body, ParameterExpression[] parameters);
    public static Expression`1<TDelegate> Lambda(Expression body, bool tailCall, ParameterExpression[] parameters);
    public static Expression`1<TDelegate> Lambda(Expression body, IEnumerable`1<ParameterExpression> parameters);
    public static Expression`1<TDelegate> Lambda(Expression body, bool tailCall, IEnumerable`1<ParameterExpression> parameters);
    public static Expression`1<TDelegate> Lambda(Expression body, string name, IEnumerable`1<ParameterExpression> parameters);
    public static Expression`1<TDelegate> Lambda(Expression body, string name, bool tailCall, IEnumerable`1<ParameterExpression> parameters);
    public static LambdaExpression Lambda(Expression body, ParameterExpression[] parameters);
    public static LambdaExpression Lambda(Expression body, bool tailCall, ParameterExpression[] parameters);
    public static LambdaExpression Lambda(Expression body, IEnumerable`1<ParameterExpression> parameters);
    public static LambdaExpression Lambda(Expression body, bool tailCall, IEnumerable`1<ParameterExpression> parameters);
    public static LambdaExpression Lambda(Type delegateType, Expression body, ParameterExpression[] parameters);
    public static LambdaExpression Lambda(Type delegateType, Expression body, bool tailCall, ParameterExpression[] parameters);
    public static LambdaExpression Lambda(Type delegateType, Expression body, IEnumerable`1<ParameterExpression> parameters);
    public static LambdaExpression Lambda(Type delegateType, Expression body, bool tailCall, IEnumerable`1<ParameterExpression> parameters);
    public static LambdaExpression Lambda(Expression body, string name, IEnumerable`1<ParameterExpression> parameters);
    public static LambdaExpression Lambda(Expression body, string name, bool tailCall, IEnumerable`1<ParameterExpression> parameters);
    public static LambdaExpression Lambda(Type delegateType, Expression body, string name, IEnumerable`1<ParameterExpression> parameters);
    public static LambdaExpression Lambda(Type delegateType, Expression body, string name, bool tailCall, IEnumerable`1<ParameterExpression> parameters);
    private static void ValidateLambdaArgs(Type delegateType, Expression& body, ReadOnlyCollection`1<ParameterExpression> parameters);
    private static bool ValidateTryGetFuncActionArgs(Type[] typeArgs);
    public static Type GetFuncType(Type[] typeArgs);
    public static bool TryGetFuncType(Type[] typeArgs, Type& funcType);
    public static Type GetActionType(Type[] typeArgs);
    public static bool TryGetActionType(Type[] typeArgs, Type& actionType);
    public static Type GetDelegateType(Type[] typeArgs);
    public static ListInitExpression ListInit(NewExpression newExpression, Expression[] initializers);
    public static ListInitExpression ListInit(NewExpression newExpression, IEnumerable`1<Expression> initializers);
    public static ListInitExpression ListInit(NewExpression newExpression, MethodInfo addMethod, Expression[] initializers);
    public static ListInitExpression ListInit(NewExpression newExpression, MethodInfo addMethod, IEnumerable`1<Expression> initializers);
    public static ListInitExpression ListInit(NewExpression newExpression, ElementInit[] initializers);
    public static ListInitExpression ListInit(NewExpression newExpression, IEnumerable`1<ElementInit> initializers);
    public static LoopExpression Loop(Expression body);
    public static LoopExpression Loop(Expression body, LabelTarget break);
    public static LoopExpression Loop(Expression body, LabelTarget break, LabelTarget continue);
    public static MemberAssignment Bind(MemberInfo member, Expression expression);
    public static MemberAssignment Bind(MethodInfo propertyAccessor, Expression expression);
    private static void ValidateSettableFieldOrPropertyMember(MemberInfo member, Type& memberType);
    public static MemberExpression Field(Expression expression, FieldInfo field);
    public static MemberExpression Field(Expression expression, string fieldName);
    public static MemberExpression Field(Expression expression, Type type, string fieldName);
    public static MemberExpression Property(Expression expression, string propertyName);
    public static MemberExpression Property(Expression expression, Type type, string propertyName);
    public static MemberExpression Property(Expression expression, PropertyInfo property);
    public static MemberExpression Property(Expression expression, MethodInfo propertyAccessor);
    private static PropertyInfo GetProperty(MethodInfo mi, string paramName);
    private static bool CheckMethod(MethodInfo method, MethodInfo propertyMethod);
    public static MemberExpression PropertyOrField(Expression expression, string propertyOrFieldName);
    public static MemberExpression MakeMemberAccess(Expression expression, MemberInfo member);
    public static MemberInitExpression MemberInit(NewExpression newExpression, MemberBinding[] bindings);
    public static MemberInitExpression MemberInit(NewExpression newExpression, IEnumerable`1<MemberBinding> bindings);
    public static MemberListBinding ListBind(MemberInfo member, ElementInit[] initializers);
    public static MemberListBinding ListBind(MemberInfo member, IEnumerable`1<ElementInit> initializers);
    public static MemberListBinding ListBind(MethodInfo propertyAccessor, ElementInit[] initializers);
    public static MemberListBinding ListBind(MethodInfo propertyAccessor, IEnumerable`1<ElementInit> initializers);
    private static void ValidateListInitArgs(Type listType, ReadOnlyCollection`1<ElementInit> initializers, string listTypeParamName);
    public static MemberMemberBinding MemberBind(MemberInfo member, MemberBinding[] bindings);
    public static MemberMemberBinding MemberBind(MemberInfo member, IEnumerable`1<MemberBinding> bindings);
    public static MemberMemberBinding MemberBind(MethodInfo propertyAccessor, MemberBinding[] bindings);
    public static MemberMemberBinding MemberBind(MethodInfo propertyAccessor, IEnumerable`1<MemberBinding> bindings);
    private static void ValidateGettableFieldOrPropertyMember(MemberInfo member, Type& memberType);
    private static void ValidateMemberInitArgs(Type type, ReadOnlyCollection`1<MemberBinding> bindings);
    internal static MethodCallExpression Call(MethodInfo method);
    public static MethodCallExpression Call(MethodInfo method, Expression arg0);
    public static MethodCallExpression Call(MethodInfo method, Expression arg0, Expression arg1);
    public static MethodCallExpression Call(MethodInfo method, Expression arg0, Expression arg1, Expression arg2);
    public static MethodCallExpression Call(MethodInfo method, Expression arg0, Expression arg1, Expression arg2, Expression arg3);
    public static MethodCallExpression Call(MethodInfo method, Expression arg0, Expression arg1, Expression arg2, Expression arg3, Expression arg4);
    public static MethodCallExpression Call(MethodInfo method, Expression[] arguments);
    public static MethodCallExpression Call(MethodInfo method, IEnumerable`1<Expression> arguments);
    public static MethodCallExpression Call(Expression instance, MethodInfo method);
    public static MethodCallExpression Call(Expression instance, MethodInfo method, Expression[] arguments);
    internal static MethodCallExpression Call(Expression instance, MethodInfo method, Expression arg0);
    public static MethodCallExpression Call(Expression instance, MethodInfo method, Expression arg0, Expression arg1);
    public static MethodCallExpression Call(Expression instance, MethodInfo method, Expression arg0, Expression arg1, Expression arg2);
    public static MethodCallExpression Call(Expression instance, string methodName, Type[] typeArguments, Expression[] arguments);
    public static MethodCallExpression Call(Type type, string methodName, Type[] typeArguments, Expression[] arguments);
    public static MethodCallExpression Call(Expression instance, MethodInfo method, IEnumerable`1<Expression> arguments);
    private static ParameterInfo[] ValidateMethodAndGetParameters(Expression instance, MethodInfo method);
    private static void ValidateStaticOrInstanceMethod(Expression instance, MethodInfo method);
    private static void ValidateCallInstanceType(Type instanceType, MethodInfo method);
    public static void ValidateArgumentTypes(MethodBase method, ExpressionType nodeKind, ReadOnlyCollection`1& arguments);
    private static ParameterInfo[] GetParametersForValidation(MethodBase method, ExpressionType nodeKind);
    public static void ValidateArgumentCount(MethodBase method, ExpressionType nodeKind, int count, ParameterInfo[] pis);
    public static Expression ValidateOneArgument(MethodBase method, ExpressionType nodeKind, Expression arg, ParameterInfo pi);
    private static bool TryQuote(Type parameterType, Expression& argument);
    private static MethodInfo FindMethod(Type type, string methodName, Type[] typeArgs, Expression[] args, BindingFlags flags);
    private static int FindBestMethod(IEnumerable`1<MethodInfo> methods, Type[] typeArgs, Expression[] args, MethodInfo& method);
    private static bool IsCompatible(MethodBase m, Expression[] args);
    private static MethodInfo ApplyTypeArgs(MethodInfo m, Type[] typeArgs);
    public static MethodCallExpression ArrayIndex(Expression array, Expression[] indexes);
    public static MethodCallExpression ArrayIndex(Expression array, IEnumerable`1<Expression> indexes);
    public static NewArrayExpression NewArrayInit(Type type, Expression[] initializers);
    public static NewArrayExpression NewArrayInit(Type type, IEnumerable`1<Expression> initializers);
    public static NewArrayExpression NewArrayBounds(Type type, Expression[] bounds);
    public static NewArrayExpression NewArrayBounds(Type type, IEnumerable`1<Expression> bounds);
    public static NewExpression New(ConstructorInfo constructor);
    public static NewExpression New(ConstructorInfo constructor, Expression[] arguments);
    public static NewExpression New(ConstructorInfo constructor, IEnumerable`1<Expression> arguments);
    public static NewExpression New(ConstructorInfo constructor, IEnumerable`1<Expression> arguments, IEnumerable`1<MemberInfo> members);
    public static NewExpression New(ConstructorInfo constructor, IEnumerable`1<Expression> arguments, MemberInfo[] members);
    public static NewExpression New(Type type);
    private static void ValidateNewArgs(ConstructorInfo constructor, ReadOnlyCollection`1& arguments, ReadOnlyCollection`1& members);
    private static void ValidateAnonymousTypeMember(MemberInfo& member, Type& memberType);
    private static void ValidateConstructor(ConstructorInfo constructor, string paramName);
    public static ParameterExpression Parameter(Type type);
    public static ParameterExpression Variable(Type type);
    public static ParameterExpression Parameter(Type type, string name);
    public static ParameterExpression Variable(Type type, string name);
    public static RuntimeVariablesExpression RuntimeVariables(ParameterExpression[] variables);
    public static RuntimeVariablesExpression RuntimeVariables(IEnumerable`1<ParameterExpression> variables);
    public static SwitchCase SwitchCase(Expression body, Expression[] testValues);
    public static SwitchCase SwitchCase(Expression body, IEnumerable`1<Expression> testValues);
    public static SwitchExpression Switch(Expression switchValue, SwitchCase[] cases);
    public static SwitchExpression Switch(Expression switchValue, Expression defaultBody, SwitchCase[] cases);
    public static SwitchExpression Switch(Expression switchValue, Expression defaultBody, MethodInfo comparison, SwitchCase[] cases);
    public static SwitchExpression Switch(Type type, Expression switchValue, Expression defaultBody, MethodInfo comparison, SwitchCase[] cases);
    public static SwitchExpression Switch(Expression switchValue, Expression defaultBody, MethodInfo comparison, IEnumerable`1<SwitchCase> cases);
    public static SwitchExpression Switch(Type type, Expression switchValue, Expression defaultBody, MethodInfo comparison, IEnumerable`1<SwitchCase> cases);
    private static void ValidateSwitchCaseType(Expression case, bool customType, Type resultType, string parameterName);
    public static SymbolDocumentInfo SymbolDocument(string fileName);
    public static SymbolDocumentInfo SymbolDocument(string fileName, Guid language);
    public static SymbolDocumentInfo SymbolDocument(string fileName, Guid language, Guid languageVendor);
    public static SymbolDocumentInfo SymbolDocument(string fileName, Guid language, Guid languageVendor, Guid documentType);
    public static TryExpression TryFault(Expression body, Expression fault);
    public static TryExpression TryFinally(Expression body, Expression finally);
    public static TryExpression TryCatch(Expression body, CatchBlock[] handlers);
    public static TryExpression TryCatchFinally(Expression body, Expression finally, CatchBlock[] handlers);
    public static TryExpression MakeTry(Type type, Expression body, Expression finally, Expression fault, IEnumerable`1<CatchBlock> handlers);
    private static void ValidateTryAndCatchHaveSameType(Type type, Expression tryBody, ReadOnlyCollection`1<CatchBlock> handlers);
    public static TypeBinaryExpression TypeIs(Expression expression, Type type);
    public static TypeBinaryExpression TypeEqual(Expression expression, Type type);
    public static UnaryExpression MakeUnary(ExpressionType unaryType, Expression operand, Type type);
    public static UnaryExpression MakeUnary(ExpressionType unaryType, Expression operand, Type type, MethodInfo method);
    private static UnaryExpression GetUserDefinedUnaryOperatorOrThrow(ExpressionType unaryType, string name, Expression operand);
    private static UnaryExpression GetUserDefinedUnaryOperator(ExpressionType unaryType, string name, Expression operand);
    private static UnaryExpression GetMethodBasedUnaryOperator(ExpressionType unaryType, Expression operand, MethodInfo method);
    private static UnaryExpression GetUserDefinedCoercionOrThrow(ExpressionType coercionType, Expression expression, Type convertToType);
    private static UnaryExpression GetUserDefinedCoercion(ExpressionType coercionType, Expression expression, Type convertToType);
    private static UnaryExpression GetMethodBasedCoercionOperator(ExpressionType unaryType, Expression operand, Type convertToType, MethodInfo method);
    public static UnaryExpression Negate(Expression expression);
    public static UnaryExpression Negate(Expression expression, MethodInfo method);
    public static UnaryExpression UnaryPlus(Expression expression);
    public static UnaryExpression UnaryPlus(Expression expression, MethodInfo method);
    public static UnaryExpression NegateChecked(Expression expression);
    public static UnaryExpression NegateChecked(Expression expression, MethodInfo method);
    public static UnaryExpression Not(Expression expression);
    public static UnaryExpression Not(Expression expression, MethodInfo method);
    public static UnaryExpression IsFalse(Expression expression);
    public static UnaryExpression IsFalse(Expression expression, MethodInfo method);
    public static UnaryExpression IsTrue(Expression expression);
    public static UnaryExpression IsTrue(Expression expression, MethodInfo method);
    public static UnaryExpression OnesComplement(Expression expression);
    public static UnaryExpression OnesComplement(Expression expression, MethodInfo method);
    public static UnaryExpression TypeAs(Expression expression, Type type);
    public static UnaryExpression Unbox(Expression expression, Type type);
    public static UnaryExpression Convert(Expression expression, Type type);
    public static UnaryExpression Convert(Expression expression, Type type, MethodInfo method);
    public static UnaryExpression ConvertChecked(Expression expression, Type type);
    public static UnaryExpression ConvertChecked(Expression expression, Type type, MethodInfo method);
    public static UnaryExpression ArrayLength(Expression array);
    public static UnaryExpression Quote(Expression expression);
    public static UnaryExpression Rethrow();
    public static UnaryExpression Rethrow(Type type);
    public static UnaryExpression Throw(Expression value);
    public static UnaryExpression Throw(Expression value, Type type);
    public static UnaryExpression Increment(Expression expression);
    public static UnaryExpression Increment(Expression expression, MethodInfo method);
    public static UnaryExpression Decrement(Expression expression);
    public static UnaryExpression Decrement(Expression expression, MethodInfo method);
    public static UnaryExpression PreIncrementAssign(Expression expression);
    public static UnaryExpression PreIncrementAssign(Expression expression, MethodInfo method);
    public static UnaryExpression PreDecrementAssign(Expression expression);
    public static UnaryExpression PreDecrementAssign(Expression expression, MethodInfo method);
    public static UnaryExpression PostIncrementAssign(Expression expression);
    public static UnaryExpression PostIncrementAssign(Expression expression, MethodInfo method);
    public static UnaryExpression PostDecrementAssign(Expression expression);
    public static UnaryExpression PostDecrementAssign(Expression expression, MethodInfo method);
    private static UnaryExpression MakeOpAssignUnary(ExpressionType kind, Expression expression, MethodInfo method);
}
public class System.Linq.Expressions.Expression`1 : LambdaExpression {
    public Expression`1(Expression body, string name, bool tailCall, ReadOnlyCollection`1<ParameterExpression> parameters);
    public TDelegate Compile();
    public TDelegate Compile(bool preferInterpretation);
    public Expression`1<TDelegate> Update(Expression body, IEnumerable`1<ParameterExpression> parameters);
    protected internal virtual Expression Accept(ExpressionVisitor visitor);
}
public class System.Linq.Expressions.ExpressionCreator`1 : object {
    public static LambdaExpression CreateExpressionFunc(Expression body, string name, bool tailCall, ReadOnlyCollection`1<ParameterExpression> parameters);
}
internal class System.Linq.Expressions.ExpressionStringBuilder : ExpressionVisitor {
    private StringBuilder _out;
    private Dictionary`2<object, int> _ids;
    public virtual string ToString();
    private void AddLabel(LabelTarget label);
    private int GetLabelId(LabelTarget label);
    private void AddParam(ParameterExpression p);
    private int GetParamId(ParameterExpression p);
    private void Out(string s);
    private void Out(char c);
    internal static string ExpressionToString(Expression node);
    internal static string CatchBlockToString(CatchBlock node);
    internal static string SwitchCaseToString(SwitchCase node);
    internal static string MemberBindingToString(MemberBinding node);
    internal static string ElementInitBindingToString(ElementInit node);
    private void VisitExpressions(char open, IList`1<T> expressions, char close);
    private void VisitExpressions(char open, IList`1<T> expressions, char close, string seperator);
    protected internal virtual Expression VisitBinary(BinaryExpression node);
    protected internal virtual Expression VisitParameter(ParameterExpression node);
    protected internal virtual Expression VisitLambda(Expression`1<T> node);
    protected internal virtual Expression VisitListInit(ListInitExpression node);
    protected internal virtual Expression VisitConditional(ConditionalExpression node);
    protected internal virtual Expression VisitConstant(ConstantExpression node);
    protected internal virtual Expression VisitDebugInfo(DebugInfoExpression node);
    protected internal virtual Expression VisitRuntimeVariables(RuntimeVariablesExpression node);
    private void OutMember(Expression instance, MemberInfo member);
    protected internal virtual Expression VisitMember(MemberExpression node);
    protected internal virtual Expression VisitMemberInit(MemberInitExpression node);
    protected virtual MemberAssignment VisitMemberAssignment(MemberAssignment assignment);
    protected virtual MemberListBinding VisitMemberListBinding(MemberListBinding binding);
    protected virtual MemberMemberBinding VisitMemberMemberBinding(MemberMemberBinding binding);
    protected virtual ElementInit VisitElementInit(ElementInit initializer);
    protected internal virtual Expression VisitInvocation(InvocationExpression node);
    protected internal virtual Expression VisitMethodCall(MethodCallExpression node);
    protected internal virtual Expression VisitNewArray(NewArrayExpression node);
    protected internal virtual Expression VisitNew(NewExpression node);
    protected internal virtual Expression VisitTypeBinary(TypeBinaryExpression node);
    protected internal virtual Expression VisitUnary(UnaryExpression node);
    protected internal virtual Expression VisitBlock(BlockExpression node);
    protected internal virtual Expression VisitDefault(DefaultExpression node);
    protected internal virtual Expression VisitLabel(LabelExpression node);
    protected internal virtual Expression VisitGoto(GotoExpression node);
    protected internal virtual Expression VisitLoop(LoopExpression node);
    protected virtual SwitchCase VisitSwitchCase(SwitchCase node);
    protected internal virtual Expression VisitSwitch(SwitchExpression node);
    protected virtual CatchBlock VisitCatchBlock(CatchBlock node);
    protected internal virtual Expression VisitTry(TryExpression node);
    protected internal virtual Expression VisitIndex(IndexExpression node);
    protected internal virtual Expression VisitExtension(Expression node);
    private void DumpLabel(LabelTarget target);
}
public enum System.Linq.Expressions.ExpressionType : Enum {
    public int value__;
    public static ExpressionType Add;
    public static ExpressionType AddChecked;
    public static ExpressionType And;
    public static ExpressionType AndAlso;
    public static ExpressionType ArrayLength;
    public static ExpressionType ArrayIndex;
    public static ExpressionType Call;
    public static ExpressionType Coalesce;
    public static ExpressionType Conditional;
    public static ExpressionType Constant;
    public static ExpressionType Convert;
    public static ExpressionType ConvertChecked;
    public static ExpressionType Divide;
    public static ExpressionType Equal;
    public static ExpressionType ExclusiveOr;
    public static ExpressionType GreaterThan;
    public static ExpressionType GreaterThanOrEqual;
    public static ExpressionType Invoke;
    public static ExpressionType Lambda;
    public static ExpressionType LeftShift;
    public static ExpressionType LessThan;
    public static ExpressionType LessThanOrEqual;
    public static ExpressionType ListInit;
    public static ExpressionType MemberAccess;
    public static ExpressionType MemberInit;
    public static ExpressionType Modulo;
    public static ExpressionType Multiply;
    public static ExpressionType MultiplyChecked;
    public static ExpressionType Negate;
    public static ExpressionType UnaryPlus;
    public static ExpressionType NegateChecked;
    public static ExpressionType New;
    public static ExpressionType NewArrayInit;
    public static ExpressionType NewArrayBounds;
    public static ExpressionType Not;
    public static ExpressionType NotEqual;
    public static ExpressionType Or;
    public static ExpressionType OrElse;
    public static ExpressionType Parameter;
    public static ExpressionType Power;
    public static ExpressionType Quote;
    public static ExpressionType RightShift;
    public static ExpressionType Subtract;
    public static ExpressionType SubtractChecked;
    public static ExpressionType TypeAs;
    public static ExpressionType TypeIs;
    public static ExpressionType Assign;
    public static ExpressionType Block;
    public static ExpressionType DebugInfo;
    public static ExpressionType Decrement;
    public static ExpressionType Dynamic;
    public static ExpressionType Default;
    public static ExpressionType Extension;
    public static ExpressionType Goto;
    public static ExpressionType Increment;
    public static ExpressionType Index;
    public static ExpressionType Label;
    public static ExpressionType RuntimeVariables;
    public static ExpressionType Loop;
    public static ExpressionType Switch;
    public static ExpressionType Throw;
    public static ExpressionType Try;
    public static ExpressionType Unbox;
    public static ExpressionType AddAssign;
    public static ExpressionType AndAssign;
    public static ExpressionType DivideAssign;
    public static ExpressionType ExclusiveOrAssign;
    public static ExpressionType LeftShiftAssign;
    public static ExpressionType ModuloAssign;
    public static ExpressionType MultiplyAssign;
    public static ExpressionType OrAssign;
    public static ExpressionType PowerAssign;
    public static ExpressionType RightShiftAssign;
    public static ExpressionType SubtractAssign;
    public static ExpressionType AddAssignChecked;
    public static ExpressionType MultiplyAssignChecked;
    public static ExpressionType SubtractAssignChecked;
    public static ExpressionType PreIncrementAssign;
    public static ExpressionType PreDecrementAssign;
    public static ExpressionType PostIncrementAssign;
    public static ExpressionType PostDecrementAssign;
    public static ExpressionType TypeEqual;
    public static ExpressionType OnesComplement;
    public static ExpressionType IsTrue;
    public static ExpressionType IsFalse;
}
public abstract class System.Linq.Expressions.ExpressionVisitor : object {
    public virtual Expression Visit(Expression node);
    public ReadOnlyCollection`1<Expression> Visit(ReadOnlyCollection`1<Expression> nodes);
    private Expression[] VisitArguments(IArgumentProvider nodes);
    public static ReadOnlyCollection`1<T> Visit(ReadOnlyCollection`1<T> nodes, Func`2<T, T> elementVisitor);
    public T VisitAndConvert(T node, string callerName);
    public ReadOnlyCollection`1<T> VisitAndConvert(ReadOnlyCollection`1<T> nodes, string callerName);
    protected internal virtual Expression VisitBinary(BinaryExpression node);
    protected internal virtual Expression VisitBlock(BlockExpression node);
    protected internal virtual Expression VisitConditional(ConditionalExpression node);
    protected internal virtual Expression VisitConstant(ConstantExpression node);
    protected internal virtual Expression VisitDebugInfo(DebugInfoExpression node);
    protected internal virtual Expression VisitDefault(DefaultExpression node);
    protected internal virtual Expression VisitExtension(Expression node);
    protected internal virtual Expression VisitGoto(GotoExpression node);
    protected internal virtual Expression VisitInvocation(InvocationExpression node);
    protected virtual LabelTarget VisitLabelTarget(LabelTarget node);
    protected internal virtual Expression VisitLabel(LabelExpression node);
    protected internal virtual Expression VisitLambda(Expression`1<T> node);
    protected internal virtual Expression VisitLoop(LoopExpression node);
    protected internal virtual Expression VisitMember(MemberExpression node);
    protected internal virtual Expression VisitIndex(IndexExpression node);
    protected internal virtual Expression VisitMethodCall(MethodCallExpression node);
    protected internal virtual Expression VisitNewArray(NewArrayExpression node);
    protected internal virtual Expression VisitNew(NewExpression node);
    protected internal virtual Expression VisitParameter(ParameterExpression node);
    protected internal virtual Expression VisitRuntimeVariables(RuntimeVariablesExpression node);
    protected virtual SwitchCase VisitSwitchCase(SwitchCase node);
    protected internal virtual Expression VisitSwitch(SwitchExpression node);
    protected virtual CatchBlock VisitCatchBlock(CatchBlock node);
    protected internal virtual Expression VisitTry(TryExpression node);
    protected internal virtual Expression VisitTypeBinary(TypeBinaryExpression node);
    protected internal virtual Expression VisitUnary(UnaryExpression node);
    protected internal virtual Expression VisitMemberInit(MemberInitExpression node);
    protected internal virtual Expression VisitListInit(ListInitExpression node);
    protected virtual ElementInit VisitElementInit(ElementInit node);
    protected virtual MemberBinding VisitMemberBinding(MemberBinding node);
    protected virtual MemberAssignment VisitMemberAssignment(MemberAssignment node);
    protected virtual MemberMemberBinding VisitMemberMemberBinding(MemberMemberBinding node);
    protected virtual MemberListBinding VisitMemberListBinding(MemberListBinding node);
    private static UnaryExpression ValidateUnary(UnaryExpression before, UnaryExpression after);
    private static BinaryExpression ValidateBinary(BinaryExpression before, BinaryExpression after);
    private static SwitchExpression ValidateSwitch(SwitchExpression before, SwitchExpression after);
    private static void ValidateChildType(Type before, Type after, string methodName);
}
internal class System.Linq.Expressions.FieldExpression : MemberExpression {
    private FieldInfo _field;
    public Type Type { get; }
    public FieldExpression(Expression expression, FieldInfo member);
    internal virtual MemberInfo GetMember();
    public sealed virtual Type get_Type();
}
internal class System.Linq.Expressions.FullConditionalExpression : ConditionalExpression {
    private Expression _false;
    internal FullConditionalExpression(Expression test, Expression ifTrue, Expression ifFalse);
    internal virtual Expression GetFalse();
}
internal class System.Linq.Expressions.FullConditionalExpressionWithType : FullConditionalExpression {
    private Type _type;
    public Type Type { get; }
    internal FullConditionalExpressionWithType(Expression test, Expression ifTrue, Expression ifFalse, Type type);
    public sealed virtual Type get_Type();
}
[DebuggerTypeProxyAttribute("System.Linq.Expressions.Expression/GotoExpressionProxy")]
public class System.Linq.Expressions.GotoExpression : Expression {
    private GotoExpressionKind _kind;
    private Expression _value;
    private LabelTarget _target;
    private Type _type;
    public Type Type { get; }
    public ExpressionType NodeType { get; }
    public Expression Value { get; }
    public LabelTarget Target { get; }
    public GotoExpressionKind Kind { get; }
    internal GotoExpression(GotoExpressionKind kind, LabelTarget target, Expression value, Type type);
    public sealed virtual Type get_Type();
    public sealed virtual ExpressionType get_NodeType();
    public Expression get_Value();
    public LabelTarget get_Target();
    public GotoExpressionKind get_Kind();
    protected internal virtual Expression Accept(ExpressionVisitor visitor);
    public GotoExpression Update(LabelTarget target, Expression value);
}
public enum System.Linq.Expressions.GotoExpressionKind : Enum {
    public int value__;
    public static GotoExpressionKind Goto;
    public static GotoExpressionKind Return;
    public static GotoExpressionKind Break;
    public static GotoExpressionKind Continue;
}
public interface System.Linq.Expressions.IArgumentProvider {
    public int ArgumentCount { get; }
    public abstract virtual Expression GetArgument(int index);
    public abstract virtual int get_ArgumentCount();
}
public interface System.Linq.Expressions.IDynamicExpression {
    public Type DelegateType { get; }
    public abstract virtual Type get_DelegateType();
    public abstract virtual Expression Rewrite(Expression[] args);
    public abstract virtual object CreateCallSite();
}
[DebuggerTypeProxyAttribute("System.Linq.Expressions.Expression/IndexExpressionProxy")]
public class System.Linq.Expressions.IndexExpression : Expression {
    private Expression _instance;
    private PropertyInfo _indexer;
    private IList`1<Expression> _arguments;
    public ExpressionType NodeType { get; }
    public Type Type { get; }
    public Expression Object { get; }
    public PropertyInfo Indexer { get; }
    public ReadOnlyCollection`1<Expression> Arguments { get; }
    public int ArgumentCount { get; }
    internal IndexExpression(Expression instance, PropertyInfo indexer, IList`1<Expression> arguments);
    public sealed virtual ExpressionType get_NodeType();
    public sealed virtual Type get_Type();
    public Expression get_Object();
    public PropertyInfo get_Indexer();
    public ReadOnlyCollection`1<Expression> get_Arguments();
    public IndexExpression Update(Expression object, IEnumerable`1<Expression> arguments);
    public sealed virtual Expression GetArgument(int index);
    public sealed virtual int get_ArgumentCount();
    protected internal virtual Expression Accept(ExpressionVisitor visitor);
    internal Expression Rewrite(Expression instance, Expression[] arguments);
}
internal class System.Linq.Expressions.InstanceMethodCallExpression : MethodCallExpression {
    private Expression _instance;
    public InstanceMethodCallExpression(MethodInfo method, Expression instance);
    internal virtual Expression GetInstance();
}
internal class System.Linq.Expressions.InstanceMethodCallExpression0 : InstanceMethodCallExpression {
    public int ArgumentCount { get; }
    public InstanceMethodCallExpression0(MethodInfo method, Expression instance);
    public virtual Expression GetArgument(int index);
    public virtual int get_ArgumentCount();
    internal virtual ReadOnlyCollection`1<Expression> GetOrMakeArguments();
    internal virtual MethodCallExpression Rewrite(Expression instance, IList`1<Expression> args);
}
internal class System.Linq.Expressions.InstanceMethodCallExpression1 : InstanceMethodCallExpression {
    private object _arg0;
    public int ArgumentCount { get; }
    public InstanceMethodCallExpression1(MethodInfo method, Expression instance, Expression arg0);
    public virtual Expression GetArgument(int index);
    public virtual int get_ArgumentCount();
    internal virtual ReadOnlyCollection`1<Expression> GetOrMakeArguments();
    internal virtual MethodCallExpression Rewrite(Expression instance, IList`1<Expression> args);
}
internal class System.Linq.Expressions.InstanceMethodCallExpression2 : InstanceMethodCallExpression {
    private object _arg0;
    private Expression _arg1;
    public int ArgumentCount { get; }
    public InstanceMethodCallExpression2(MethodInfo method, Expression instance, Expression arg0, Expression arg1);
    public virtual Expression GetArgument(int index);
    public virtual int get_ArgumentCount();
    internal virtual ReadOnlyCollection`1<Expression> GetOrMakeArguments();
    internal virtual MethodCallExpression Rewrite(Expression instance, IList`1<Expression> args);
}
internal class System.Linq.Expressions.InstanceMethodCallExpression3 : InstanceMethodCallExpression {
    private object _arg0;
    private Expression _arg1;
    private Expression _arg2;
    public int ArgumentCount { get; }
    public InstanceMethodCallExpression3(MethodInfo method, Expression instance, Expression arg0, Expression arg1, Expression arg2);
    public virtual Expression GetArgument(int index);
    public virtual int get_ArgumentCount();
    internal virtual ReadOnlyCollection`1<Expression> GetOrMakeArguments();
    internal virtual MethodCallExpression Rewrite(Expression instance, IList`1<Expression> args);
}
internal class System.Linq.Expressions.InstanceMethodCallExpressionN : InstanceMethodCallExpression {
    private IList`1<Expression> _arguments;
    public int ArgumentCount { get; }
    public InstanceMethodCallExpressionN(MethodInfo method, Expression instance, IList`1<Expression> args);
    public virtual Expression GetArgument(int index);
    public virtual int get_ArgumentCount();
    internal virtual ReadOnlyCollection`1<Expression> GetOrMakeArguments();
    internal virtual MethodCallExpression Rewrite(Expression instance, IList`1<Expression> args);
}
internal abstract class System.Linq.Expressions.Interpreter.AddInstruction : Instruction {
    private static Instruction s_int16;
    private static Instruction s_int32;
    private static Instruction s_int64;
    private static Instruction s_UInt16;
    private static Instruction s_UInt32;
    private static Instruction s_UInt64;
    private static Instruction s_single;
    private static Instruction s_double;
    public int ConsumedStack { get; }
    public int ProducedStack { get; }
    public string InstructionName { get; }
    public virtual int get_ConsumedStack();
    public virtual int get_ProducedStack();
    public virtual string get_InstructionName();
    public static Instruction Create(Type type);
}
internal abstract class System.Linq.Expressions.Interpreter.AddOvfInstruction : Instruction {
    private static Instruction s_int16;
    private static Instruction s_int32;
    private static Instruction s_int64;
    private static Instruction s_UInt16;
    private static Instruction s_UInt32;
    private static Instruction s_UInt64;
    public int ConsumedStack { get; }
    public int ProducedStack { get; }
    public string InstructionName { get; }
    public virtual int get_ConsumedStack();
    public virtual int get_ProducedStack();
    public virtual string get_InstructionName();
    public static Instruction Create(Type type);
}
internal enum System.Linq.Expressions.Interpreter.AnalyzeTypeIsResult : Enum {
    public int value__;
    public static AnalyzeTypeIsResult KnownFalse;
    public static AnalyzeTypeIsResult KnownTrue;
    public static AnalyzeTypeIsResult KnownAssignable;
    public static AnalyzeTypeIsResult Unknown;
}
internal abstract class System.Linq.Expressions.Interpreter.AndInstruction : Instruction {
    private static Instruction s_SByte;
    private static Instruction s_int16;
    private static Instruction s_int32;
    private static Instruction s_int64;
    private static Instruction s_byte;
    private static Instruction s_UInt16;
    private static Instruction s_UInt32;
    private static Instruction s_UInt64;
    private static Instruction s_bool;
    public int ConsumedStack { get; }
    public int ProducedStack { get; }
    public string InstructionName { get; }
    public virtual int get_ConsumedStack();
    public virtual int get_ProducedStack();
    public virtual string get_InstructionName();
    public static Instruction Create(Type type);
}
internal class System.Linq.Expressions.Interpreter.ArrayByRefUpdater : ByRefUpdater {
    private LocalDefinition _array;
    private LocalDefinition _index;
    public ArrayByRefUpdater(LocalDefinition array, LocalDefinition index, int argumentIndex);
    public virtual void Update(InterpretedFrame frame, object value);
    public virtual void UndefineTemps(InstructionList instructions, LocalVariables locals);
}
internal class System.Linq.Expressions.Interpreter.ArrayLengthInstruction : Instruction {
    public static ArrayLengthInstruction Instance;
    public int ConsumedStack { get; }
    public int ProducedStack { get; }
    public string InstructionName { get; }
    private static ArrayLengthInstruction();
    public virtual int get_ConsumedStack();
    public virtual int get_ProducedStack();
    public virtual string get_InstructionName();
    public virtual int Run(InterpretedFrame frame);
}
internal static class System.Linq.Expressions.Interpreter.Assert : object {
    [ConditionalAttribute("DEBUG")]
public static void NotNull(object var);
}
internal class System.Linq.Expressions.Interpreter.AssignLocalBoxedInstruction : LocalAccessInstruction {
    public int ConsumedStack { get; }
    public int ProducedStack { get; }
    public string InstructionName { get; }
    internal AssignLocalBoxedInstruction(int index);
    public virtual int get_ConsumedStack();
    public virtual int get_ProducedStack();
    public virtual string get_InstructionName();
    public virtual int Run(InterpretedFrame frame);
}
internal class System.Linq.Expressions.Interpreter.AssignLocalInstruction : LocalAccessInstruction {
    public int ConsumedStack { get; }
    public int ProducedStack { get; }
    public string InstructionName { get; }
    internal AssignLocalInstruction(int index);
    public virtual int get_ConsumedStack();
    public virtual int get_ProducedStack();
    public virtual string get_InstructionName();
    public virtual int Run(InterpretedFrame frame);
    public sealed virtual Instruction BoxIfIndexMatches(int index);
}
internal class System.Linq.Expressions.Interpreter.AssignLocalToClosureInstruction : LocalAccessInstruction {
    public int ConsumedStack { get; }
    public int ProducedStack { get; }
    public string InstructionName { get; }
    internal AssignLocalToClosureInstruction(int index);
    public virtual int get_ConsumedStack();
    public virtual int get_ProducedStack();
    public virtual string get_InstructionName();
    public virtual int Run(InterpretedFrame frame);
}
internal class System.Linq.Expressions.Interpreter.BranchFalseInstruction : OffsetInstruction {
    private static Instruction[] s_cache;
    public string InstructionName { get; }
    public Instruction[] Cache { get; }
    public int ConsumedStack { get; }
    public virtual string get_InstructionName();
    public virtual Instruction[] get_Cache();
    public virtual int get_ConsumedStack();
    public virtual int Run(InterpretedFrame frame);
}
internal class System.Linq.Expressions.Interpreter.BranchInstruction : OffsetInstruction {
    private static Instruction[][][] s_caches;
    internal bool _hasResult;
    internal bool _hasValue;
    public string InstructionName { get; }
    public Instruction[] Cache { get; }
    public int ConsumedStack { get; }
    public int ProducedStack { get; }
    public BranchInstruction(bool hasResult, bool hasValue);
    public virtual string get_InstructionName();
    public virtual Instruction[] get_Cache();
    public virtual int get_ConsumedStack();
    public virtual int get_ProducedStack();
    public virtual int Run(InterpretedFrame frame);
}
internal class System.Linq.Expressions.Interpreter.BranchLabel : object {
    internal static int UnknownIndex;
    internal static int UnknownDepth;
    internal int _labelIndex;
    internal int _targetIndex;
    internal int _stackDepth;
    internal int _continuationStackDepth;
    private List`1<int> _forwardBranchFixups;
    internal int LabelIndex { get; internal set; }
    internal bool HasRuntimeLabel { get; }
    internal int TargetIndex { get; }
    internal int StackDepth { get; }
    internal int get_LabelIndex();
    internal void set_LabelIndex(int value);
    internal bool get_HasRuntimeLabel();
    internal int get_TargetIndex();
    internal int get_StackDepth();
    internal RuntimeLabel ToRuntimeLabel();
    internal void Mark(InstructionList instructions);
    internal void AddBranch(InstructionList instructions, int branchIndex);
    internal void FixupBranch(InstructionList instructions, int branchIndex);
}
internal class System.Linq.Expressions.Interpreter.BranchTrueInstruction : OffsetInstruction {
    private static Instruction[] s_cache;
    public string InstructionName { get; }
    public Instruction[] Cache { get; }
    public int ConsumedStack { get; }
    public virtual string get_InstructionName();
    public virtual Instruction[] get_Cache();
    public virtual int get_ConsumedStack();
    public virtual int Run(InterpretedFrame frame);
}
internal class System.Linq.Expressions.Interpreter.ByRefMethodInfoCallInstruction : CallInstruction {
    private ByRefUpdater[] _byrefArgs;
    private MethodInfo _target;
    private int _argumentCount;
    public int ArgumentCount { get; }
    public int ProducedStack { get; }
    internal ByRefMethodInfoCallInstruction(MethodInfo target, int argumentCount, ByRefUpdater[] byrefArgs);
    public virtual int get_ArgumentCount();
    public virtual int get_ProducedStack();
    public sealed virtual int Run(InterpretedFrame frame);
}
internal class System.Linq.Expressions.Interpreter.ByRefNewInstruction : Instruction {
    private ByRefUpdater[] _byrefArgs;
    private ConstructorInfo _constructor;
    private int _argCount;
    public int ConsumedStack { get; }
    public int ProducedStack { get; }
    public string InstructionName { get; }
    internal ByRefNewInstruction(ConstructorInfo target, ByRefUpdater[] byrefArgs);
    public virtual int get_ConsumedStack();
    public virtual int get_ProducedStack();
    public virtual string get_InstructionName();
    public sealed virtual int Run(InterpretedFrame frame);
}
internal abstract class System.Linq.Expressions.Interpreter.ByRefUpdater : object {
    public int ArgumentIndex;
    public ByRefUpdater(int argumentIndex);
    public abstract virtual void Update(InterpretedFrame frame, object value);
    public virtual void UndefineTemps(InstructionList instructions, LocalVariables locals);
}
internal abstract class System.Linq.Expressions.Interpreter.CallInstruction : Instruction {
    private static int MaxHelpers;
    private static int MaxArgs;
    public int ArgumentCount { get; }
    public string InstructionName { get; }
    public int ConsumedStack { get; }
    public abstract virtual int get_ArgumentCount();
    public virtual string get_InstructionName();
    public static CallInstruction Create(MethodInfo info);
    public static CallInstruction Create(MethodInfo info, ParameterInfo[] parameters);
    private static CallInstruction GetArrayAccessor(MethodInfo info, int argumentCount);
    public static void ArrayItemSetter1(Array array, int index0, object value);
    public static void ArrayItemSetter2(Array array, int index0, int index1, object value);
    public static void ArrayItemSetter3(Array array, int index0, int index1, int index2, object value);
    public virtual int get_ConsumedStack();
    public virtual string ToString();
    protected static bool TryGetLightLambdaTarget(object instance, LightLambda& lightLambda);
    protected object InterpretLambdaInvoke(LightLambda targetLambda, Object[] args);
    public virtual object InvokeInstance(object instance, Object[] args);
    public virtual object Invoke(Object[] args);
    public virtual object Invoke();
    public virtual object Invoke(object arg0);
    public virtual object Invoke(object arg0, object arg1);
    public virtual object Invoke(object arg0, object arg1, object arg2);
    public virtual object Invoke(object arg0, object arg1, object arg2, object arg3);
    public virtual object Invoke(object arg0, object arg1, object arg2, object arg3, object arg4);
    public virtual object Invoke(object arg0, object arg1, object arg2, object arg3, object arg4, object arg5);
    public virtual object Invoke(object arg0, object arg1, object arg2, object arg3, object arg4, object arg5, object arg6);
    public virtual object Invoke(object arg0, object arg1, object arg2, object arg3, object arg4, object arg5, object arg6, object arg7);
    public virtual object Invoke(object arg0, object arg1, object arg2, object arg3, object arg4, object arg5, object arg6, object arg7, object arg8);
}
internal abstract class System.Linq.Expressions.Interpreter.CastInstruction : Instruction {
    private static CastInstruction s_boolean;
    private static CastInstruction s_byte;
    private static CastInstruction s_char;
    private static CastInstruction s_dateTime;
    private static CastInstruction s_decimal;
    private static CastInstruction s_double;
    private static CastInstruction s_int16;
    private static CastInstruction s_int32;
    private static CastInstruction s_int64;
    private static CastInstruction s_SByte;
    private static CastInstruction s_single;
    private static CastInstruction s_string;
    private static CastInstruction s_UInt16;
    private static CastInstruction s_UInt32;
    private static CastInstruction s_UInt64;
    public int ConsumedStack { get; }
    public int ProducedStack { get; }
    public string InstructionName { get; }
    public virtual int get_ConsumedStack();
    public virtual int get_ProducedStack();
    public virtual string get_InstructionName();
    public static Instruction Create(Type t);
}
internal class System.Linq.Expressions.Interpreter.CastReferenceToEnumInstruction : CastInstruction {
    private Type _t;
    public CastReferenceToEnumInstruction(Type t);
    public virtual int Run(InterpretedFrame frame);
}
internal class System.Linq.Expressions.Interpreter.CastToEnumInstruction : CastInstruction {
    private Type _t;
    public CastToEnumInstruction(Type t);
    public virtual int Run(InterpretedFrame frame);
}
internal class System.Linq.Expressions.Interpreter.CoalescingBranchInstruction : OffsetInstruction {
    private static Instruction[] s_cache;
    public string InstructionName { get; }
    public Instruction[] Cache { get; }
    public int ConsumedStack { get; }
    public int ProducedStack { get; }
    public virtual string get_InstructionName();
    public virtual Instruction[] get_Cache();
    public virtual int get_ConsumedStack();
    public virtual int get_ProducedStack();
    public virtual int Run(InterpretedFrame frame);
}
internal static class System.Linq.Expressions.Interpreter.ConstantCheck : object {
    internal static bool IsNull(Expression e);
    internal static AnalyzeTypeIsResult AnalyzeTypeIs(TypeBinaryExpression typeIs);
    private static AnalyzeTypeIsResult AnalyzeTypeIs(Expression operand, Type testType);
}
internal class System.Linq.Expressions.Interpreter.ConvertHelper : object {
    public static int ToInt32NoNull(object val);
}
internal class System.Linq.Expressions.Interpreter.CreateDelegateInstruction : Instruction {
    private LightDelegateCreator _creator;
    public int ConsumedStack { get; }
    public int ProducedStack { get; }
    public string InstructionName { get; }
    internal CreateDelegateInstruction(LightDelegateCreator delegateCreator);
    public virtual int get_ConsumedStack();
    public virtual int get_ProducedStack();
    public virtual string get_InstructionName();
    public virtual int Run(InterpretedFrame frame);
}
internal class System.Linq.Expressions.Interpreter.DebugInfo : object {
    public int StartLine;
    public int EndLine;
    public int Index;
    public string FileName;
    public bool IsClear;
    private static DebugInfoComparer s_debugComparer;
    private static DebugInfo();
    public static DebugInfo GetMatchingDebugInfo(DebugInfo[] debugInfos, int index);
    public virtual string ToString();
}
internal abstract class System.Linq.Expressions.Interpreter.DecrementInstruction : Instruction {
    private static Instruction s_int16;
    private static Instruction s_int32;
    private static Instruction s_int64;
    private static Instruction s_UInt16;
    private static Instruction s_UInt32;
    private static Instruction s_UInt64;
    private static Instruction s_single;
    private static Instruction s_double;
    public int ConsumedStack { get; }
    public int ProducedStack { get; }
    public string InstructionName { get; }
    public virtual int get_ConsumedStack();
    public virtual int get_ProducedStack();
    public virtual string get_InstructionName();
    public static Instruction Create(Type type);
}
internal class System.Linq.Expressions.Interpreter.DefaultValueInstruction : Instruction {
    private Type _type;
    public int ConsumedStack { get; }
    public int ProducedStack { get; }
    public string InstructionName { get; }
    internal DefaultValueInstruction(Type type);
    public virtual int get_ConsumedStack();
    public virtual int get_ProducedStack();
    public virtual string get_InstructionName();
    public virtual int Run(InterpretedFrame frame);
    public virtual string ToString();
}
internal abstract class System.Linq.Expressions.Interpreter.DivInstruction : Instruction {
    private static Instruction s_int16;
    private static Instruction s_int32;
    private static Instruction s_int64;
    private static Instruction s_UInt16;
    private static Instruction s_UInt32;
    private static Instruction s_UInt64;
    private static Instruction s_single;
    private static Instruction s_double;
    public int ConsumedStack { get; }
    public int ProducedStack { get; }
    public string InstructionName { get; }
    public virtual int get_ConsumedStack();
    public virtual int get_ProducedStack();
    public virtual string get_InstructionName();
    public static Instruction Create(Type type);
}
internal class System.Linq.Expressions.Interpreter.DupInstruction : Instruction {
    internal static DupInstruction Instance;
    public int ConsumedStack { get; }
    public int ProducedStack { get; }
    public string InstructionName { get; }
    private static DupInstruction();
    public virtual int get_ConsumedStack();
    public virtual int get_ProducedStack();
    public virtual string get_InstructionName();
    public virtual int Run(InterpretedFrame frame);
    public virtual string ToString();
}
internal class System.Linq.Expressions.Interpreter.EnterExceptionFilterInstruction : Instruction {
    internal static EnterExceptionFilterInstruction Instance;
    public string InstructionName { get; }
    public int ConsumedStack { get; }
    public int ProducedStack { get; }
    private static EnterExceptionFilterInstruction();
    public virtual string get_InstructionName();
    public virtual int get_ConsumedStack();
    public virtual int get_ProducedStack();
    public virtual int Run(InterpretedFrame frame);
}
internal class System.Linq.Expressions.Interpreter.EnterExceptionHandlerInstruction : Instruction {
    internal static EnterExceptionHandlerInstruction Void;
    internal static EnterExceptionHandlerInstruction NonVoid;
    private bool _hasValue;
    public string InstructionName { get; }
    public int ConsumedStack { get; }
    public int ProducedStack { get; }
    private EnterExceptionHandlerInstruction(bool hasValue);
    private static EnterExceptionHandlerInstruction();
    public virtual string get_InstructionName();
    public virtual int get_ConsumedStack();
    public virtual int get_ProducedStack();
    public virtual int Run(InterpretedFrame frame);
}
internal class System.Linq.Expressions.Interpreter.EnterFaultInstruction : IndexedBranchInstruction {
    private static EnterFaultInstruction[] s_cache;
    public string InstructionName { get; }
    public int ProducedStack { get; }
    private EnterFaultInstruction(int labelIndex);
    private static EnterFaultInstruction();
    public virtual string get_InstructionName();
    public virtual int get_ProducedStack();
    internal static EnterFaultInstruction Create(int labelIndex);
    public virtual int Run(InterpretedFrame frame);
}
internal class System.Linq.Expressions.Interpreter.EnterFinallyInstruction : IndexedBranchInstruction {
    private static EnterFinallyInstruction[] s_cache;
    public string InstructionName { get; }
    public int ProducedStack { get; }
    public int ConsumedContinuations { get; }
    private EnterFinallyInstruction(int labelIndex);
    private static EnterFinallyInstruction();
    public virtual string get_InstructionName();
    public virtual int get_ProducedStack();
    public virtual int get_ConsumedContinuations();
    internal static EnterFinallyInstruction Create(int labelIndex);
    public virtual int Run(InterpretedFrame frame);
}
internal class System.Linq.Expressions.Interpreter.EnterTryCatchFinallyInstruction : IndexedBranchInstruction {
    private bool _hasFinally;
    private TryCatchFinallyHandler _tryHandler;
    public int ProducedContinuations { get; }
    public string InstructionName { get; }
    private EnterTryCatchFinallyInstruction(int targetIndex, bool hasFinally);
    internal void SetTryHandler(TryCatchFinallyHandler tryHandler);
    public virtual int get_ProducedContinuations();
    internal static EnterTryCatchFinallyInstruction CreateTryFinally(int labelIndex);
    internal static EnterTryCatchFinallyInstruction CreateTryCatch();
    public virtual int Run(InterpretedFrame frame);
    public virtual string get_InstructionName();
    public virtual string ToString();
}
internal class System.Linq.Expressions.Interpreter.EnterTryFaultInstruction : IndexedBranchInstruction {
    private TryFaultHandler _tryHandler;
    public int ProducedContinuations { get; }
    public string InstructionName { get; }
    internal EnterTryFaultInstruction(int targetIndex);
    internal void SetTryHandler(TryFaultHandler tryHandler);
    public virtual int get_ProducedContinuations();
    public virtual int Run(InterpretedFrame frame);
    public virtual string get_InstructionName();
}
internal abstract class System.Linq.Expressions.Interpreter.EqualInstruction : Instruction {
    private static Instruction s_reference;
    private static Instruction s_boolean;
    private static Instruction s_SByte;
    private static Instruction s_int16;
    private static Instruction s_char;
    private static Instruction s_int32;
    private static Instruction s_int64;
    private static Instruction s_byte;
    private static Instruction s_UInt16;
    private static Instruction s_UInt32;
    private static Instruction s_UInt64;
    private static Instruction s_single;
    private static Instruction s_double;
    private static Instruction s_referenceLiftedToNull;
    private static Instruction s_booleanLiftedToNull;
    private static Instruction s_SByteLiftedToNull;
    private static Instruction s_int16LiftedToNull;
    private static Instruction s_charLiftedToNull;
    private static Instruction s_int32LiftedToNull;
    private static Instruction s_int64LiftedToNull;
    private static Instruction s_byteLiftedToNull;
    private static Instruction s_UInt16LiftedToNull;
    private static Instruction s_UInt32LiftedToNull;
    private static Instruction s_UInt64LiftedToNull;
    private static Instruction s_singleLiftedToNull;
    private static Instruction s_doubleLiftedToNull;
    public int ConsumedStack { get; }
    public int ProducedStack { get; }
    public string InstructionName { get; }
    public virtual int get_ConsumedStack();
    public virtual int get_ProducedStack();
    public virtual string get_InstructionName();
    public static Instruction Create(Type type, bool liftedToNull);
    public virtual string ToString();
}
internal class System.Linq.Expressions.Interpreter.ExceptionFilter : object {
    public int LabelIndex;
    public int StartIndex;
    public int EndIndex;
    internal ExceptionFilter(int labelIndex, int start, int end);
}
internal class System.Linq.Expressions.Interpreter.ExceptionHandler : object {
    public Type ExceptionType;
    public int LabelIndex;
    public int HandlerStartIndex;
    public int HandlerEndIndex;
    public ExceptionFilter Filter;
    internal TryCatchFinallyHandler Parent;
    internal ExceptionHandler(int labelIndex, int handlerStartIndex, int handlerEndIndex, Type exceptionType, ExceptionFilter filter);
    internal void SetParent(TryCatchFinallyHandler tryHandler);
    public bool Matches(Type exceptionType);
    public virtual string ToString();
}
internal static class System.Linq.Expressions.Interpreter.ExceptionHelpers : object {
    public static Exception UpdateForRethrow(Exception rethrow);
}
internal abstract class System.Linq.Expressions.Interpreter.ExclusiveOrInstruction : Instruction {
    private static Instruction s_SByte;
    private static Instruction s_int16;
    private static Instruction s_int32;
    private static Instruction s_int64;
    private static Instruction s_byte;
    private static Instruction s_UInt16;
    private static Instruction s_UInt32;
    private static Instruction s_UInt64;
    private static Instruction s_bool;
    public int ConsumedStack { get; }
    public int ProducedStack { get; }
    public string InstructionName { get; }
    public virtual int get_ConsumedStack();
    public virtual int get_ProducedStack();
    public virtual string get_InstructionName();
    public static Instruction Create(Type type);
    private static TypeCode GetTypeCode(Type type);
}
internal class System.Linq.Expressions.Interpreter.FieldByRefUpdater : ByRefUpdater {
    private Nullable`1<LocalDefinition> _object;
    private FieldInfo _field;
    public FieldByRefUpdater(Nullable`1<LocalDefinition> obj, FieldInfo field, int argumentIndex);
    public virtual void Update(InterpretedFrame frame, object value);
    public virtual void UndefineTemps(InstructionList instructions, LocalVariables locals);
}
internal class System.Linq.Expressions.Interpreter.GetArrayItemInstruction : Instruction {
    internal static GetArrayItemInstruction Instruction;
    public int ConsumedStack { get; }
    public int ProducedStack { get; }
    public string InstructionName { get; }
    private static GetArrayItemInstruction();
    public virtual int get_ConsumedStack();
    public virtual int get_ProducedStack();
    public virtual string get_InstructionName();
    public virtual int Run(InterpretedFrame frame);
}
internal class System.Linq.Expressions.Interpreter.GotoInstruction : IndexedBranchInstruction {
    private static int Variants;
    private static GotoInstruction[] s_cache;
    private bool _hasResult;
    private bool _hasValue;
    private bool _labelTargetGetsValue;
    public string InstructionName { get; }
    public int ConsumedContinuations { get; }
    public int ProducedContinuations { get; }
    public int ConsumedStack { get; }
    public int ProducedStack { get; }
    private GotoInstruction(int targetIndex, bool hasResult, bool hasValue, bool labelTargetGetsValue);
    private static GotoInstruction();
    public virtual string get_InstructionName();
    public virtual int get_ConsumedContinuations();
    public virtual int get_ProducedContinuations();
    public virtual int get_ConsumedStack();
    public virtual int get_ProducedStack();
    internal static GotoInstruction Create(int labelIndex, bool hasResult, bool hasValue, bool labelTargetGetsValue);
    public virtual int Run(InterpretedFrame frame);
}
internal abstract class System.Linq.Expressions.Interpreter.GreaterThanInstruction : Instruction {
    private object _nullValue;
    private static Instruction s_SByte;
    private static Instruction s_int16;
    private static Instruction s_char;
    private static Instruction s_int32;
    private static Instruction s_int64;
    private static Instruction s_byte;
    private static Instruction s_UInt16;
    private static Instruction s_UInt32;
    private static Instruction s_UInt64;
    private static Instruction s_single;
    private static Instruction s_double;
    private static Instruction s_liftedToNullSByte;
    private static Instruction s_liftedToNullInt16;
    private static Instruction s_liftedToNullChar;
    private static Instruction s_liftedToNullInt32;
    private static Instruction s_liftedToNullInt64;
    private static Instruction s_liftedToNullByte;
    private static Instruction s_liftedToNullUInt16;
    private static Instruction s_liftedToNullUInt32;
    private static Instruction s_liftedToNullUInt64;
    private static Instruction s_liftedToNullSingle;
    private static Instruction s_liftedToNullDouble;
    public int ConsumedStack { get; }
    public int ProducedStack { get; }
    public string InstructionName { get; }
    private GreaterThanInstruction(object nullValue);
    public virtual int get_ConsumedStack();
    public virtual int get_ProducedStack();
    public virtual string get_InstructionName();
    public static Instruction Create(Type type, bool liftedToNull);
    public virtual string ToString();
}
internal abstract class System.Linq.Expressions.Interpreter.GreaterThanOrEqualInstruction : Instruction {
    private object _nullValue;
    private static Instruction s_SByte;
    private static Instruction s_int16;
    private static Instruction s_char;
    private static Instruction s_int32;
    private static Instruction s_int64;
    private static Instruction s_byte;
    private static Instruction s_UInt16;
    private static Instruction s_UInt32;
    private static Instruction s_UInt64;
    private static Instruction s_single;
    private static Instruction s_double;
    private static Instruction s_liftedToNullSByte;
    private static Instruction s_liftedToNullInt16;
    private static Instruction s_liftedToNullChar;
    private static Instruction s_liftedToNullInt32;
    private static Instruction s_liftedToNullInt64;
    private static Instruction s_liftedToNullByte;
    private static Instruction s_liftedToNullUInt16;
    private static Instruction s_liftedToNullUInt32;
    private static Instruction s_liftedToNullUInt64;
    private static Instruction s_liftedToNullSingle;
    private static Instruction s_liftedToNullDouble;
    public int ConsumedStack { get; }
    public int ProducedStack { get; }
    public string InstructionName { get; }
    private GreaterThanOrEqualInstruction(object nullValue);
    public virtual int get_ConsumedStack();
    public virtual int get_ProducedStack();
    public virtual string get_InstructionName();
    public static Instruction Create(Type type, bool liftedToNull);
    public virtual string ToString();
}
[DefaultMemberAttribute("Item")]
internal class System.Linq.Expressions.Interpreter.HybridReferenceDictionary`2 : object {
    private KeyValuePair`2[] _keysAndValues;
    private Dictionary`2<TKey, TValue> _dict;
    private int _count;
    private static int _arraySize;
    public int Count { get; }
    public TValue Item { get; public set; }
    public HybridReferenceDictionary`2(int initialCapicity);
    public bool TryGetValue(TKey key, TValue& value);
    public bool Remove(TKey key);
    public bool ContainsKey(TKey key);
    public int get_Count();
    public IEnumerator`1<KeyValuePair`2<TKey, TValue>> GetEnumerator();
    [IteratorStateMachineAttribute("System.Linq.Expressions.Interpreter.HybridReferenceDictionary`2/<GetEnumeratorWorker>d__12")]
private IEnumerator`1<KeyValuePair`2<TKey, TValue>> GetEnumeratorWorker();
    public TValue get_Item(TKey key);
    public void set_Item(TKey key, TValue value);
}
internal interface System.Linq.Expressions.Interpreter.IBoxableInstruction {
    public abstract virtual Instruction BoxIfIndexMatches(int index);
}
internal abstract class System.Linq.Expressions.Interpreter.IncrementInstruction : Instruction {
    private static Instruction s_int16;
    private static Instruction s_int32;
    private static Instruction s_int64;
    private static Instruction s_UInt16;
    private static Instruction s_UInt32;
    private static Instruction s_UInt64;
    private static Instruction s_single;
    private static Instruction s_double;
    public int ConsumedStack { get; }
    public int ProducedStack { get; }
    public string InstructionName { get; }
    public virtual int get_ConsumedStack();
    public virtual int get_ProducedStack();
    public virtual string get_InstructionName();
    public static Instruction Create(Type type);
}
internal abstract class System.Linq.Expressions.Interpreter.IndexedBranchInstruction : Instruction {
    protected static int CacheSize;
    internal int _labelIndex;
    public IndexedBranchInstruction(int labelIndex);
    public RuntimeLabel GetLabel(InterpretedFrame frame);
    public virtual string ToDebugString(int instructionIndex, object cookie, Func`2<int, int> labelIndexer, IList`1<object> objects);
    public virtual string ToString();
}
internal class System.Linq.Expressions.Interpreter.IndexMethodByRefUpdater : ByRefUpdater {
    private MethodInfo _indexer;
    private Nullable`1<LocalDefinition> _obj;
    private LocalDefinition[] _args;
    public IndexMethodByRefUpdater(Nullable`1<LocalDefinition> obj, LocalDefinition[] args, MethodInfo indexer, int argumentIndex);
    public virtual void Update(InterpretedFrame frame, object value);
    public virtual void UndefineTemps(InstructionList instructions, LocalVariables locals);
}
internal abstract class System.Linq.Expressions.Interpreter.InitializeLocalInstruction : LocalAccessInstruction {
    internal InitializeLocalInstruction(int index);
}
internal abstract class System.Linq.Expressions.Interpreter.Instruction : object {
    public static int UnknownInstrIndex;
    public int ConsumedStack { get; }
    public int ProducedStack { get; }
    public int ConsumedContinuations { get; }
    public int ProducedContinuations { get; }
    public int StackBalance { get; }
    public int ContinuationsBalance { get; }
    public string InstructionName { get; }
    public virtual int get_ConsumedStack();
    public virtual int get_ProducedStack();
    public virtual int get_ConsumedContinuations();
    public virtual int get_ProducedContinuations();
    public int get_StackBalance();
    public int get_ContinuationsBalance();
    public abstract virtual int Run(InterpretedFrame frame);
    public abstract virtual string get_InstructionName();
    public virtual string ToString();
    public virtual string ToDebugString(int instructionIndex, object cookie, Func`2<int, int> labelIndexer, IList`1<object> objects);
    public virtual object GetDebugCookie(LightCompiler compiler);
    protected static void NullCheck(object o);
}
[DebuggerTypeProxyAttribute("System.Linq.Expressions.Interpreter.InstructionArray/DebugView")]
internal class System.Linq.Expressions.Interpreter.InstructionArray : ValueType {
    internal int MaxStackDepth;
    internal int MaxContinuationDepth;
    internal Instruction[] Instructions;
    internal Object[] Objects;
    internal RuntimeLabel[] Labels;
    internal List`1<KeyValuePair`2<int, object>> DebugCookies;
    internal InstructionArray(int maxStackDepth, int maxContinuationDepth, Instruction[] instructions, Object[] objects, RuntimeLabel[] labels, List`1<KeyValuePair`2<int, object>> debugCookies);
}
[DebuggerTypeProxyAttribute("System.Linq.Expressions.Interpreter.InstructionList/DebugView")]
internal class System.Linq.Expressions.Interpreter.InstructionList : object {
    private List`1<Instruction> _instructions;
    private List`1<object> _objects;
    private int _currentStackDepth;
    private int _maxStackDepth;
    private int _currentContinuationsDepth;
    private int _maxContinuationDepth;
    private int _runtimeLabelCount;
    private List`1<BranchLabel> _labels;
    private List`1<KeyValuePair`2<int, object>> _debugCookies;
    private static int PushIntMinCachedValue;
    private static int PushIntMaxCachedValue;
    private static int CachedObjectCount;
    private static Instruction s_null;
    private static Instruction s_true;
    private static Instruction s_false;
    private static Instruction[] s_ints;
    private static Instruction[] s_loadObjectCached;
    private static int LocalInstrCacheSize;
    private static Instruction[] s_loadLocal;
    private static Instruction[] s_loadLocalBoxed;
    private static Instruction[] s_loadLocalFromClosure;
    private static Instruction[] s_loadLocalFromClosureBoxed;
    private static Instruction[] s_assignLocal;
    private static Instruction[] s_storeLocal;
    private static Instruction[] s_assignLocalBoxed;
    private static Instruction[] s_storeLocalBoxed;
    private static Instruction[] s_assignLocalToClosure;
    private static Dictionary`2<FieldInfo, Instruction> s_loadFields;
    private static RuntimeLabel[] s_emptyRuntimeLabels;
    public int Count { get; }
    public int CurrentStackDepth { get; }
    public int CurrentContinuationsDepth { get; }
    public int MaxStackDepth { get; }
    private static InstructionList();
    public void Emit(Instruction instruction);
    private void UpdateStackDepth(Instruction instruction);
    [ConditionalAttribute("DEBUG")]
public void SetDebugCookie(object cookie);
    public int get_Count();
    public int get_CurrentStackDepth();
    public int get_CurrentContinuationsDepth();
    public int get_MaxStackDepth();
    internal Instruction GetInstruction(int index);
    public InstructionArray ToArray();
    public void EmitLoad(object value);
    public void EmitLoad(bool value);
    public void EmitLoad(object value, Type type);
    public void EmitDup();
    public void EmitPop();
    internal void SwitchToBoxed(int index, int instructionIndex);
    public void EmitLoadLocal(int index);
    public void EmitLoadLocalBoxed(int index);
    internal static Instruction LoadLocalBoxed(int index);
    public void EmitLoadLocalFromClosure(int index);
    public void EmitLoadLocalFromClosureBoxed(int index);
    public void EmitAssignLocal(int index);
    public void EmitStoreLocal(int index);
    public void EmitAssignLocalBoxed(int index);
    internal static Instruction AssignLocalBoxed(int index);
    public void EmitStoreLocalBoxed(int index);
    internal static Instruction StoreLocalBoxed(int index);
    public void EmitAssignLocalToClosure(int index);
    public void EmitStoreLocalToClosure(int index);
    public void EmitInitializeLocal(int index, Type type);
    internal void EmitInitializeParameter(int index);
    internal static Instruction Parameter(int index);
    internal static Instruction ParameterBox(int index);
    internal static Instruction InitReference(int index);
    internal static Instruction InitImmutableRefBox(int index);
    public void EmitNewRuntimeVariables(int count);
    public void EmitGetArrayItem();
    public void EmitSetArrayItem();
    public void EmitNewArray(Type elementType);
    public void EmitNewArrayBounds(Type elementType, int rank);
    public void EmitNewArrayInit(Type elementType, int elementCount);
    public void EmitAdd(Type type, bool checked);
    public void EmitSub(Type type, bool checked);
    public void EmitMul(Type type, bool checked);
    public void EmitDiv(Type type);
    public void EmitModulo(Type type);
    public void EmitExclusiveOr(Type type);
    public void EmitAnd(Type type);
    public void EmitOr(Type type);
    public void EmitLeftShift(Type type);
    public void EmitRightShift(Type type);
    public void EmitEqual(Type type, bool liftedToNull);
    public void EmitNotEqual(Type type, bool liftedToNull);
    public void EmitLessThan(Type type, bool liftedToNull);
    public void EmitLessThanOrEqual(Type type, bool liftedToNull);
    public void EmitGreaterThan(Type type, bool liftedToNull);
    public void EmitGreaterThanOrEqual(Type type, bool liftedToNull);
    public void EmitNumericConvertChecked(TypeCode from, TypeCode to, bool isLiftedToNull);
    public void EmitNumericConvertUnchecked(TypeCode from, TypeCode to, bool isLiftedToNull);
    public void EmitCast(Type toType);
    public void EmitCastToEnum(Type toType);
    public void EmitCastReferenceToEnum(Type toType);
    public void EmitNot(Type type);
    public void EmitDefaultValue(Type type);
    public void EmitNew(ConstructorInfo constructorInfo);
    public void EmitByRefNew(ConstructorInfo constructorInfo, ByRefUpdater[] updaters);
    internal void EmitCreateDelegate(LightDelegateCreator creator);
    public void EmitTypeEquals();
    public void EmitNullableTypeEquals();
    public void EmitArrayLength();
    public void EmitNegate(Type type);
    public void EmitNegateChecked(Type type);
    public void EmitOnesComplement(Type type);
    public void EmitIncrement(Type type);
    public void EmitDecrement(Type type);
    public void EmitTypeIs(Type type);
    public void EmitTypeAs(Type type);
    public void EmitLoadField(FieldInfo field);
    private Instruction GetLoadField(FieldInfo field);
    public void EmitStoreField(FieldInfo field);
    public void EmitCall(MethodInfo method);
    public void EmitCall(MethodInfo method, ParameterInfo[] parameters);
    public void EmitByRefCall(MethodInfo method, ParameterInfo[] parameters, ByRefUpdater[] byrefArgs);
    public void EmitNullableCall(MethodInfo method, ParameterInfo[] parameters);
    private RuntimeLabel[] BuildRuntimeLabels();
    public BranchLabel MakeLabel();
    internal void FixupBranch(int branchIndex, int offset);
    private int EnsureLabelIndex(BranchLabel label);
    public int MarkRuntimeLabel();
    public void MarkLabel(BranchLabel label);
    public void EmitGoto(BranchLabel label, bool hasResult, bool hasValue, bool labelTargetGetsValue);
    private void EmitBranch(OffsetInstruction instruction, BranchLabel label);
    public void EmitBranch(BranchLabel label);
    public void EmitBranch(BranchLabel label, bool hasResult, bool hasValue);
    public void EmitCoalescingBranch(BranchLabel leftNotNull);
    public void EmitBranchTrue(BranchLabel elseLabel);
    public void EmitBranchFalse(BranchLabel elseLabel);
    public void EmitThrow();
    public void EmitThrowVoid();
    public void EmitRethrow();
    public void EmitRethrowVoid();
    public void EmitEnterTryFinally(BranchLabel finallyStartLabel);
    public void EmitEnterTryCatch();
    public EnterTryFaultInstruction EmitEnterTryFault(BranchLabel tryEnd);
    public void EmitEnterFinally(BranchLabel finallyStartLabel);
    public void EmitLeaveFinally();
    public void EmitEnterFault(BranchLabel faultStartLabel);
    public void EmitLeaveFault();
    public void EmitEnterExceptionFilter();
    public void EmitLeaveExceptionFilter();
    public void EmitEnterExceptionHandlerNonVoid();
    public void EmitEnterExceptionHandlerVoid();
    public void EmitLeaveExceptionHandler(bool hasValue, BranchLabel tryExpressionEndLabel);
    public void EmitIntSwitch(Dictionary`2<T, int> cases);
    public void EmitStringSwitch(Dictionary`2<string, int> cases, StrongBox`1<int> nullCase);
}
internal class System.Linq.Expressions.Interpreter.InterpretedFrame : object {
    [ThreadStaticAttribute]
public static InterpretedFrame CurrentFrame;
    internal Interpreter Interpreter;
    internal InterpretedFrame _parent;
    private Int32[] _continuations;
    private int _continuationIndex;
    private int _pendingContinuation;
    private object _pendingValue;
    public Object[] Data;
    public IStrongBox[] Closure;
    public int StackIndex;
    public int InstructionIndex;
    public string Name { get; }
    public InterpretedFrame Parent { get; }
    internal InterpretedFrame(Interpreter interpreter, IStrongBox[] closure);
    public DebugInfo GetDebugInfo(int instructionIndex);
    public string get_Name();
    public void Push(object value);
    public void Push(bool value);
    public void Push(int value);
    public void Push(byte value);
    public void Push(sbyte value);
    public void Push(short value);
    public void Push(ushort value);
    public object Pop();
    internal void SetStackDepth(int depth);
    public object Peek();
    public void Dup();
    public InterpretedFrame get_Parent();
    public static bool IsInterpretedFrame(MethodBase method);
    [IteratorStateMachineAttribute("System.Linq.Expressions.Interpreter.InterpretedFrame/<GetStackTraceDebugInfo>d__29")]
public IEnumerable`1<InterpretedFrameInfo> GetStackTraceDebugInfo();
    internal void SaveTraceToException(Exception exception);
    public static InterpretedFrameInfo[] GetExceptionStackTrace(Exception exception);
    internal InterpretedFrame Enter();
    internal void Leave(InterpretedFrame prevFrame);
    internal bool IsJumpHappened();
    public void RemoveContinuation();
    public void PushContinuation(int continuation);
    public int YieldToCurrentContinuation();
    public int YieldToPendingContinuation();
    internal void PushPendingContinuation();
    internal void PopPendingContinuation();
    public int Goto(int labelIndex, object value, bool gotoExceptionHandler);
}
internal class System.Linq.Expressions.Interpreter.InterpretedFrameInfo : ValueType {
    public string MethodName;
    public DebugInfo DebugInfo;
    public InterpretedFrameInfo(string methodName, DebugInfo info);
    public virtual string ToString();
}
internal class System.Linq.Expressions.Interpreter.Interpreter : object {
    internal static object NoValue;
    internal static int RethrowOnReturn;
    private int _localCount;
    private HybridReferenceDictionary`2<LabelTarget, BranchLabel> _labelMapping;
    private Dictionary`2<ParameterExpression, LocalVariable> _closureVariables;
    private InstructionArray _instructions;
    internal Object[] _objects;
    internal RuntimeLabel[] _labels;
    internal string _name;
    internal DebugInfo[] _debugInfos;
    internal int ClosureSize { get; }
    internal int LocalCount { get; }
    internal InstructionArray Instructions { get; }
    internal Dictionary`2<ParameterExpression, LocalVariable> ClosureVariables { get; }
    internal HybridReferenceDictionary`2<LabelTarget, BranchLabel> LabelMapping { get; }
    internal int ReturnAndRethrowLabelIndex { get; }
    internal Interpreter(string name, LocalVariables locals, HybridReferenceDictionary`2<LabelTarget, BranchLabel> labelMapping, InstructionArray instructions, DebugInfo[] debugInfos);
    private static Interpreter();
    internal int get_ClosureSize();
    internal int get_LocalCount();
    internal InstructionArray get_Instructions();
    internal Dictionary`2<ParameterExpression, LocalVariable> get_ClosureVariables();
    internal HybridReferenceDictionary`2<LabelTarget, BranchLabel> get_LabelMapping();
    public void Run(InterpretedFrame frame);
    internal int get_ReturnAndRethrowLabelIndex();
}
internal class System.Linq.Expressions.Interpreter.IntSwitchInstruction`1 : Instruction {
    private Dictionary`2<T, int> _cases;
    public string InstructionName { get; }
    public int ConsumedStack { get; }
    public int ProducedStack { get; }
    internal IntSwitchInstruction`1(Dictionary`2<T, int> cases);
    public virtual string get_InstructionName();
    public virtual int get_ConsumedStack();
    public virtual int get_ProducedStack();
    public virtual int Run(InterpretedFrame frame);
}
internal class System.Linq.Expressions.Interpreter.LabelInfo : object {
    private LabelTarget _node;
    private BranchLabel _label;
    private object _definitions;
    private List`1<LabelScopeInfo> _references;
    private bool _acrossBlockJump;
    private bool HasDefinitions { get; }
    private bool HasMultipleDefinitions { get; }
    internal LabelInfo(LabelTarget node);
    internal BranchLabel GetLabel(LightCompiler compiler);
    internal void Reference(LabelScopeInfo block);
    internal void Define(LabelScopeInfo block);
    private void ValidateJump(LabelScopeInfo reference);
    internal void ValidateFinish();
    private void EnsureLabel(LightCompiler compiler);
    private bool DefinedIn(LabelScopeInfo scope);
    private bool get_HasDefinitions();
    private LabelScopeInfo FirstDefinition();
    private void AddDefinition(LabelScopeInfo scope);
    private bool get_HasMultipleDefinitions();
    internal static T CommonNode(T first, T second, Func`2<T, T> parent);
}
internal class System.Linq.Expressions.Interpreter.LabelScopeInfo : object {
    private HybridReferenceDictionary`2<LabelTarget, LabelInfo> _labels;
    internal LabelScopeKind Kind;
    internal LabelScopeInfo Parent;
    internal bool CanJumpInto { get; }
    internal LabelScopeInfo(LabelScopeInfo parent, LabelScopeKind kind);
    internal bool get_CanJumpInto();
    internal bool ContainsTarget(LabelTarget target);
    internal bool TryGetLabelInfo(LabelTarget target, LabelInfo& info);
    internal void AddLabelInfo(LabelTarget target, LabelInfo info);
}
internal enum System.Linq.Expressions.Interpreter.LabelScopeKind : Enum {
    public int value__;
    public static LabelScopeKind Statement;
    public static LabelScopeKind Block;
    public static LabelScopeKind Switch;
    public static LabelScopeKind Lambda;
    public static LabelScopeKind Try;
    public static LabelScopeKind Catch;
    public static LabelScopeKind Finally;
    public static LabelScopeKind Filter;
    public static LabelScopeKind Expression;
}
internal class System.Linq.Expressions.Interpreter.LeaveExceptionFilterInstruction : Instruction {
    internal static LeaveExceptionFilterInstruction Instance;
    public string InstructionName { get; }
    public int ConsumedStack { get; }
    public int ProducedStack { get; }
    private static LeaveExceptionFilterInstruction();
    public virtual string get_InstructionName();
    public virtual int get_ConsumedStack();
    public virtual int get_ProducedStack();
    public virtual int Run(InterpretedFrame frame);
}
internal class System.Linq.Expressions.Interpreter.LeaveExceptionHandlerInstruction : IndexedBranchInstruction {
    private static LeaveExceptionHandlerInstruction[] s_cache;
    private bool _hasValue;
    public string InstructionName { get; }
    public int ConsumedStack { get; }
    public int ProducedStack { get; }
    private LeaveExceptionHandlerInstruction(int labelIndex, bool hasValue);
    private static LeaveExceptionHandlerInstruction();
    public virtual string get_InstructionName();
    public virtual int get_ConsumedStack();
    public virtual int get_ProducedStack();
    internal static LeaveExceptionHandlerInstruction Create(int labelIndex, bool hasValue);
    public virtual int Run(InterpretedFrame frame);
}
internal class System.Linq.Expressions.Interpreter.LeaveFaultInstruction : Instruction {
    internal static Instruction Instance;
    public int ConsumedStack { get; }
    public int ConsumedContinuations { get; }
    public string InstructionName { get; }
    private static LeaveFaultInstruction();
    public virtual int get_ConsumedStack();
    public virtual int get_ConsumedContinuations();
    public virtual string get_InstructionName();
    public virtual int Run(InterpretedFrame frame);
}
internal class System.Linq.Expressions.Interpreter.LeaveFinallyInstruction : Instruction {
    internal static Instruction Instance;
    public int ConsumedStack { get; }
    public string InstructionName { get; }
    private static LeaveFinallyInstruction();
    public virtual int get_ConsumedStack();
    public virtual string get_InstructionName();
    public virtual int Run(InterpretedFrame frame);
}
internal abstract class System.Linq.Expressions.Interpreter.LeftShiftInstruction : Instruction {
    private static Instruction s_SByte;
    private static Instruction s_int16;
    private static Instruction s_int32;
    private static Instruction s_int64;
    private static Instruction s_byte;
    private static Instruction s_UInt16;
    private static Instruction s_UInt32;
    private static Instruction s_UInt64;
    public int ConsumedStack { get; }
    public int ProducedStack { get; }
    public string InstructionName { get; }
    public virtual int get_ConsumedStack();
    public virtual int get_ProducedStack();
    public virtual string get_InstructionName();
    public static Instruction Create(Type type);
}
internal abstract class System.Linq.Expressions.Interpreter.LessThanInstruction : Instruction {
    private object _nullValue;
    private static Instruction s_SByte;
    private static Instruction s_int16;
    private static Instruction s_char;
    private static Instruction s_int32;
    private static Instruction s_int64;
    private static Instruction s_byte;
    private static Instruction s_UInt16;
    private static Instruction s_UInt32;
    private static Instruction s_UInt64;
    private static Instruction s_single;
    private static Instruction s_double;
    private static Instruction s_liftedToNullSByte;
    private static Instruction s_liftedToNullInt16;
    private static Instruction s_liftedToNullChar;
    private static Instruction s_liftedToNullInt32;
    private static Instruction s_liftedToNullInt64;
    private static Instruction s_liftedToNullByte;
    private static Instruction s_liftedToNullUInt16;
    private static Instruction s_liftedToNullUInt32;
    private static Instruction s_liftedToNullUInt64;
    private static Instruction s_liftedToNullSingle;
    private static Instruction s_liftedToNullDouble;
    public int ConsumedStack { get; }
    public int ProducedStack { get; }
    public string InstructionName { get; }
    private LessThanInstruction(object nullValue);
    public virtual int get_ConsumedStack();
    public virtual int get_ProducedStack();
    public virtual string get_InstructionName();
    public static Instruction Create(Type type, bool liftedToNull);
}
internal abstract class System.Linq.Expressions.Interpreter.LessThanOrEqualInstruction : Instruction {
    private object _nullValue;
    private static Instruction s_SByte;
    private static Instruction s_int16;
    private static Instruction s_char;
    private static Instruction s_int32;
    private static Instruction s_int64;
    private static Instruction s_byte;
    private static Instruction s_UInt16;
    private static Instruction s_UInt32;
    private static Instruction s_UInt64;
    private static Instruction s_single;
    private static Instruction s_double;
    private static Instruction s_liftedToNullSByte;
    private static Instruction s_liftedToNullInt16;
    private static Instruction s_liftedToNullChar;
    private static Instruction s_liftedToNullInt32;
    private static Instruction s_liftedToNullInt64;
    private static Instruction s_liftedToNullByte;
    private static Instruction s_liftedToNullUInt16;
    private static Instruction s_liftedToNullUInt32;
    private static Instruction s_liftedToNullUInt64;
    private static Instruction s_liftedToNullSingle;
    private static Instruction s_liftedToNullDouble;
    public int ConsumedStack { get; }
    public int ProducedStack { get; }
    public string InstructionName { get; }
    private LessThanOrEqualInstruction(object nullValue);
    public virtual int get_ConsumedStack();
    public virtual int get_ProducedStack();
    public virtual string get_InstructionName();
    public static Instruction Create(Type type, bool liftedToNull);
}
internal class System.Linq.Expressions.Interpreter.LightCompiler : object {
    private InstructionList _instructions;
    private LocalVariables _locals;
    private List`1<DebugInfo> _debugInfos;
    private HybridReferenceDictionary`2<LabelTarget, LabelInfo> _treeLabels;
    private LabelScopeInfo _labelBlock;
    private Stack`1<ParameterExpression> _exceptionForRethrowStack;
    private LightCompiler _parent;
    private static LocalDefinition[] s_emptyLocals;
    public InstructionList Instructions { get; }
    public LocalVariables Locals { get; }
    private LightCompiler(LightCompiler parent);
    private static LightCompiler();
    public InstructionList get_Instructions();
    public LocalVariables get_Locals();
    public LightDelegateCreator CompileTop(LambdaExpression node);
    private Interpreter MakeInterpreter(string lambdaName);
    private void CompileConstantExpression(Expression expr);
    private void CompileDefaultExpression(Expression expr);
    private void CompileDefaultExpression(Type type);
    private LocalVariable EnsureAvailableForClosure(ParameterExpression expr);
    private LocalVariable ResolveLocal(ParameterExpression variable);
    public void CompileGetVariable(ParameterExpression variable);
    private void EmitCopyValueType(Type valueType);
    private void LoadLocalNoValueTypeCopy(ParameterExpression variable);
    private bool MaybeMutableValueType(Type type);
    public void CompileGetBoxedVariable(ParameterExpression variable);
    public void CompileSetVariable(ParameterExpression variable, bool isVoid);
    public void CompileParameterExpression(Expression expr);
    private void CompileBlockExpression(Expression expr, bool asVoid);
    private LocalDefinition[] CompileBlockStart(BlockExpression node);
    private void CompileBlockEnd(LocalDefinition[] locals);
    private void CompileIndexExpression(Expression expr);
    private void EmitIndexGet(IndexExpression index);
    private void CompileIndexAssignment(BinaryExpression node, bool asVoid);
    private void CompileMemberAssignment(BinaryExpression node, bool asVoid);
    private void CompileMemberAssignment(bool asVoid, MemberInfo refMember, Expression value);
    private void CompileVariableAssignment(BinaryExpression node, bool asVoid);
    private void CompileAssignBinaryExpression(Expression expr, bool asVoid);
    private static bool IsNullableOrReferenceType(Type t);
    private void CompileBinaryExpression(Expression expr);
    private void CompileEqual(Expression left, Expression right, bool liftedToNull);
    private void CompileNotEqual(Expression left, Expression right, bool liftedToNull);
    private void CompileComparison(BinaryExpression node);
    private void CompileArithmetic(ExpressionType nodeType, Expression left, Expression right);
    private void CompileConvertUnaryExpression(Expression expr);
    private void CompileConvertToType(Type typeFrom, Type typeTo, bool isChecked, bool isLiftedToNull);
    private void CompileNotExpression(UnaryExpression node);
    private void CompileUnaryExpression(Expression expr);
    private void EmitUnaryMethodCall(UnaryExpression node);
    private void EmitUnaryBoolCheck(UnaryExpression node);
    private void CompileAndAlsoBinaryExpression(Expression expr);
    private void CompileOrElseBinaryExpression(Expression expr);
    private void CompileLogicalBinaryExpression(BinaryExpression b, bool andAlso);
    private void CompileMethodLogicalBinaryExpression(BinaryExpression expr, bool andAlso);
    private void CompileLiftedLogicalBinaryExpression(BinaryExpression node, bool andAlso);
    private void CompileUnliftedLogicalBinaryExpression(BinaryExpression expr, bool andAlso);
    private void CompileConditionalExpression(Expression expr, bool asVoid);
    private void CompileLoopExpression(Expression expr);
    private void CompileSwitchExpression(Expression expr);
    private void CompileIntSwitchExpression(SwitchExpression node);
    private void CompileStringSwitchExpression(SwitchExpression node);
    private void CompileLabelExpression(Expression expr);
    private void CompileGotoExpression(Expression expr);
    public void PushLabelBlock(LabelScopeKind type);
    public void PopLabelBlock(LabelScopeKind kind);
    private LabelInfo EnsureLabel(LabelTarget node);
    private LabelInfo ReferenceLabel(LabelTarget node);
    internal LabelInfo DefineLabel(LabelTarget node);
    private bool TryPushLabelBlock(Expression node);
    private void DefineBlockLabels(Expression node);
    private HybridReferenceDictionary`2<LabelTarget, BranchLabel> GetBranchMapping();
    private void CheckRethrow();
    private void CompileThrowUnaryExpression(Expression expr, bool asVoid);
    private void CompileTryExpression(Expression expr);
    private void CompileTryFaultExpression(TryExpression expr);
    private void CompileMethodCallExpression(Expression expr);
    private ByRefUpdater CompileArrayIndexAddress(Expression array, Expression index, int argumentIndex);
    private void EmitThisForMethodCall(Expression node);
    private static bool ShouldWritebackNode(Expression node);
    private ByRefUpdater CompileAddress(Expression node, int index);
    private ByRefUpdater CompileMultiDimArrayAccess(Expression array, IList`1<Expression> arguments, int index);
    private void CompileNewExpression(Expression expr);
    private void CompileMemberExpression(Expression expr);
    private void CompileMember(Expression from, MemberInfo member);
    private void CompileNewArrayExpression(Expression expr);
    private void CompileDebugInfoExpression(Expression expr);
    private void CompileRuntimeVariablesExpression(Expression expr);
    private void CompileLambdaExpression(Expression expr);
    private void CompileCoalesceBinaryExpression(Expression expr);
    private void CompileInvocationExpression(Expression expr);
    private void CompileListInitExpression(Expression expr);
    private void CompileListInit(IList`1<ElementInit> initializers);
    private void CompileMemberInitExpression(Expression expr);
    private void CompileMemberInit(ReadOnlyCollection`1<MemberBinding> bindings);
    private static Type GetMemberType(MemberInfo member);
    private void CompileQuoteUnaryExpression(Expression expr);
    private void CompileUnboxUnaryExpression(Expression expr);
    private void CompileTypeEqualExpression(Expression expr);
    private void CompileTypeAsExpression(UnaryExpression node);
    private void CompileTypeIsExpression(Expression expr);
    internal void Compile(Expression expr, bool asVoid);
    internal void CompileAsVoid(Expression expr);
    private void CompileNoLabelPush(Expression expr);
    public void Compile(Expression expr);
}
internal class System.Linq.Expressions.Interpreter.LightDelegateCreator : object {
    private Interpreter _interpreter;
    private Expression _lambda;
    internal Interpreter Interpreter { get; }
    private Type DelegateType { get; }
    internal LightDelegateCreator(Interpreter interpreter, LambdaExpression lambda);
    internal Interpreter get_Interpreter();
    public Delegate CreateDelegate();
    internal Delegate CreateDelegate(IStrongBox[] closure);
    private Type get_DelegateType();
}
public class System.Linq.Expressions.Interpreter.LightLambda : object {
    private IStrongBox[] _closure;
    private Interpreter _interpreter;
    private LightDelegateCreator _delegateCreator;
    internal LightLambda(LightDelegateCreator delegateCreator, IStrongBox[] closure);
    internal Delegate MakeDelegate(Type delegateType);
    private InterpretedFrame MakeFrame();
    public object Run(Object[] arguments);
    public object RunVoid(Object[] arguments);
}
internal class System.Linq.Expressions.Interpreter.LoadCachedObjectInstruction : Instruction {
    private UInt32 _index;
    public int ProducedStack { get; }
    public string InstructionName { get; }
    internal LoadCachedObjectInstruction(UInt32 index);
    public virtual int get_ProducedStack();
    public virtual string get_InstructionName();
    public virtual int Run(InterpretedFrame frame);
    public virtual string ToDebugString(int instructionIndex, object cookie, Func`2<int, int> labelIndexer, IList`1<object> objects);
    public virtual string ToString();
}
internal class System.Linq.Expressions.Interpreter.LoadFieldInstruction : Instruction {
    private FieldInfo _field;
    public string InstructionName { get; }
    public int ConsumedStack { get; }
    public int ProducedStack { get; }
    public LoadFieldInstruction(FieldInfo field);
    public virtual string get_InstructionName();
    public virtual int get_ConsumedStack();
    public virtual int get_ProducedStack();
    public virtual int Run(InterpretedFrame frame);
}
internal class System.Linq.Expressions.Interpreter.LoadLocalBoxedInstruction : LocalAccessInstruction {
    public int ProducedStack { get; }
    public string InstructionName { get; }
    internal LoadLocalBoxedInstruction(int index);
    public virtual int get_ProducedStack();
    public virtual string get_InstructionName();
    public virtual int Run(InterpretedFrame frame);
}
internal class System.Linq.Expressions.Interpreter.LoadLocalFromClosureBoxedInstruction : LocalAccessInstruction {
    public int ProducedStack { get; }
    public string InstructionName { get; }
    internal LoadLocalFromClosureBoxedInstruction(int index);
    public virtual int get_ProducedStack();
    public virtual string get_InstructionName();
    public virtual int Run(InterpretedFrame frame);
}
internal class System.Linq.Expressions.Interpreter.LoadLocalFromClosureInstruction : LocalAccessInstruction {
    public int ProducedStack { get; }
    public string InstructionName { get; }
    internal LoadLocalFromClosureInstruction(int index);
    public virtual int get_ProducedStack();
    public virtual string get_InstructionName();
    public virtual int Run(InterpretedFrame frame);
}
internal class System.Linq.Expressions.Interpreter.LoadLocalInstruction : LocalAccessInstruction {
    public int ProducedStack { get; }
    public string InstructionName { get; }
    internal LoadLocalInstruction(int index);
    public virtual int get_ProducedStack();
    public virtual string get_InstructionName();
    public virtual int Run(InterpretedFrame frame);
    public sealed virtual Instruction BoxIfIndexMatches(int index);
}
internal class System.Linq.Expressions.Interpreter.LoadObjectInstruction : Instruction {
    private object _value;
    public int ProducedStack { get; }
    public string InstructionName { get; }
    internal LoadObjectInstruction(object value);
    public virtual int get_ProducedStack();
    public virtual string get_InstructionName();
    public virtual int Run(InterpretedFrame frame);
    public virtual string ToString();
}
internal class System.Linq.Expressions.Interpreter.LoadStaticFieldInstruction : Instruction {
    private FieldInfo _field;
    public string InstructionName { get; }
    public int ProducedStack { get; }
    public LoadStaticFieldInstruction(FieldInfo field);
    public virtual string get_InstructionName();
    public virtual int get_ProducedStack();
    public virtual int Run(InterpretedFrame frame);
}
internal abstract class System.Linq.Expressions.Interpreter.LocalAccessInstruction : Instruction {
    internal int _index;
    protected LocalAccessInstruction(int index);
    public virtual string ToDebugString(int instructionIndex, object cookie, Func`2<int, int> labelIndexer, IList`1<object> objects);
}
internal class System.Linq.Expressions.Interpreter.LocalDefinition : ValueType {
    private int _index;
    private ParameterExpression _parameter;
    public int Index { get; }
    public ParameterExpression Parameter { get; }
    internal LocalDefinition(int localIndex, ParameterExpression parameter);
    public int get_Index();
    public ParameterExpression get_Parameter();
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    public static bool op_Equality(LocalDefinition self, LocalDefinition other);
    public static bool op_Inequality(LocalDefinition self, LocalDefinition other);
}
internal class System.Linq.Expressions.Interpreter.LocalVariable : object {
    private static int IsBoxedFlag;
    private static int InClosureFlag;
    public int Index;
    private int _flags;
    public bool IsBoxed { get; public set; }
    public bool InClosure { get; }
    internal LocalVariable(int index, bool closure);
    public bool get_IsBoxed();
    public void set_IsBoxed(bool value);
    public bool get_InClosure();
    internal Expression LoadFromArray(Expression frameData, Expression closure, Type parameterType);
    public virtual string ToString();
}
internal class System.Linq.Expressions.Interpreter.LocalVariables : object {
    private HybridReferenceDictionary`2<ParameterExpression, VariableScope> _variables;
    private Dictionary`2<ParameterExpression, LocalVariable> _closureVariables;
    private int _localCount;
    private int _maxLocalCount;
    public int LocalCount { get; }
    internal Dictionary`2<ParameterExpression, LocalVariable> ClosureVariables { get; }
    public LocalDefinition DefineLocal(ParameterExpression variable, int start);
    public void UndefineLocal(LocalDefinition definition, int end);
    internal void Box(ParameterExpression variable, InstructionList instructions);
    public int get_LocalCount();
    public int GetOrDefineLocal(ParameterExpression var);
    public int GetLocalIndex(ParameterExpression var);
    public bool TryGetLocalOrClosure(ParameterExpression var, LocalVariable& local);
    internal Dictionary`2<ParameterExpression, LocalVariable> CopyLocals();
    internal bool ContainsVariable(ParameterExpression variable);
    internal Dictionary`2<ParameterExpression, LocalVariable> get_ClosureVariables();
    internal LocalVariable AddClosureVariable(ParameterExpression variable);
}
internal class System.Linq.Expressions.Interpreter.MethodInfoCallInstruction : CallInstruction {
    private MethodInfo _target;
    private int _argumentCount;
    public int ArgumentCount { get; }
    public int ProducedStack { get; }
    internal MethodInfoCallInstruction(MethodInfo target, int argumentCount);
    public virtual int get_ArgumentCount();
    public virtual int get_ProducedStack();
    public virtual object Invoke(Object[] args);
    public virtual object Invoke();
    public virtual object Invoke(object arg0);
    public virtual object Invoke(object arg0, object arg1);
    public virtual object InvokeInstance(object instance, Object[] args);
    private object InvokeWorker(Object[] args);
    private static Object[] SkipFirstArg(Object[] args);
    public virtual int Run(InterpretedFrame frame);
}
internal abstract class System.Linq.Expressions.Interpreter.ModuloInstruction : Instruction {
    private static Instruction s_int16;
    private static Instruction s_int32;
    private static Instruction s_int64;
    private static Instruction s_UInt16;
    private static Instruction s_UInt32;
    private static Instruction s_UInt64;
    private static Instruction s_single;
    private static Instruction s_double;
    public int ConsumedStack { get; }
    public int ProducedStack { get; }
    public string InstructionName { get; }
    public virtual int get_ConsumedStack();
    public virtual int get_ProducedStack();
    public virtual string get_InstructionName();
    public static Instruction Create(Type type);
}
internal abstract class System.Linq.Expressions.Interpreter.MulInstruction : Instruction {
    private static Instruction s_int16;
    private static Instruction s_int32;
    private static Instruction s_int64;
    private static Instruction s_UInt16;
    private static Instruction s_UInt32;
    private static Instruction s_UInt64;
    private static Instruction s_single;
    private static Instruction s_double;
    public int ConsumedStack { get; }
    public int ProducedStack { get; }
    public string InstructionName { get; }
    public virtual int get_ConsumedStack();
    public virtual int get_ProducedStack();
    public virtual string get_InstructionName();
    public static Instruction Create(Type type);
}
internal abstract class System.Linq.Expressions.Interpreter.MulOvfInstruction : Instruction {
    private static Instruction s_int16;
    private static Instruction s_int32;
    private static Instruction s_int64;
    private static Instruction s_UInt16;
    private static Instruction s_UInt32;
    private static Instruction s_UInt64;
    public int ConsumedStack { get; }
    public int ProducedStack { get; }
    public string InstructionName { get; }
    public virtual int get_ConsumedStack();
    public virtual int get_ProducedStack();
    public virtual string get_InstructionName();
    public static Instruction Create(Type type);
}
internal abstract class System.Linq.Expressions.Interpreter.NegateCheckedInstruction : Instruction {
    private static Instruction s_int16;
    private static Instruction s_int32;
    private static Instruction s_int64;
    private static Instruction s_single;
    private static Instruction s_double;
    public int ConsumedStack { get; }
    public int ProducedStack { get; }
    public string InstructionName { get; }
    public virtual int get_ConsumedStack();
    public virtual int get_ProducedStack();
    public virtual string get_InstructionName();
    public static Instruction Create(Type type);
}
internal abstract class System.Linq.Expressions.Interpreter.NegateInstruction : Instruction {
    private static Instruction s_int16;
    private static Instruction s_int32;
    private static Instruction s_int64;
    private static Instruction s_single;
    private static Instruction s_double;
    public int ConsumedStack { get; }
    public int ProducedStack { get; }
    public string InstructionName { get; }
    public virtual int get_ConsumedStack();
    public virtual int get_ProducedStack();
    public virtual string get_InstructionName();
    public static Instruction Create(Type type);
}
internal class System.Linq.Expressions.Interpreter.NewArrayBoundsInstruction : Instruction {
    private Type _elementType;
    private int _rank;
    public int ConsumedStack { get; }
    public int ProducedStack { get; }
    public string InstructionName { get; }
    internal NewArrayBoundsInstruction(Type elementType, int rank);
    public virtual int get_ConsumedStack();
    public virtual int get_ProducedStack();
    public virtual string get_InstructionName();
    public virtual int Run(InterpretedFrame frame);
}
internal class System.Linq.Expressions.Interpreter.NewArrayInitInstruction : Instruction {
    private Type _elementType;
    private int _elementCount;
    public int ConsumedStack { get; }
    public int ProducedStack { get; }
    public string InstructionName { get; }
    internal NewArrayInitInstruction(Type elementType, int elementCount);
    public virtual int get_ConsumedStack();
    public virtual int get_ProducedStack();
    public virtual string get_InstructionName();
    public virtual int Run(InterpretedFrame frame);
}
internal class System.Linq.Expressions.Interpreter.NewArrayInstruction : Instruction {
    private Type _elementType;
    public int ConsumedStack { get; }
    public int ProducedStack { get; }
    public string InstructionName { get; }
    internal NewArrayInstruction(Type elementType);
    public virtual int get_ConsumedStack();
    public virtual int get_ProducedStack();
    public virtual string get_InstructionName();
    public virtual int Run(InterpretedFrame frame);
}
internal class System.Linq.Expressions.Interpreter.NewInstruction : Instruction {
    private ConstructorInfo _constructor;
    private int _argCount;
    public int ConsumedStack { get; }
    public int ProducedStack { get; }
    public string InstructionName { get; }
    public NewInstruction(ConstructorInfo constructor);
    public virtual int get_ConsumedStack();
    public virtual int get_ProducedStack();
    public virtual string get_InstructionName();
    public virtual int Run(InterpretedFrame frame);
    public virtual string ToString();
}
internal abstract class System.Linq.Expressions.Interpreter.NotEqualInstruction : Instruction {
    private static Instruction s_reference;
    private static Instruction s_boolean;
    private static Instruction s_SByte;
    private static Instruction s_int16;
    private static Instruction s_char;
    private static Instruction s_int32;
    private static Instruction s_int64;
    private static Instruction s_byte;
    private static Instruction s_UInt16;
    private static Instruction s_UInt32;
    private static Instruction s_UInt64;
    private static Instruction s_single;
    private static Instruction s_double;
    private static Instruction s_referenceLiftedToNull;
    private static Instruction s_booleanLiftedToNull;
    private static Instruction s_SByteLiftedToNull;
    private static Instruction s_int16LiftedToNull;
    private static Instruction s_charLiftedToNull;
    private static Instruction s_int32LiftedToNull;
    private static Instruction s_int64LiftedToNull;
    private static Instruction s_byteLiftedToNull;
    private static Instruction s_UInt16LiftedToNull;
    private static Instruction s_UInt32LiftedToNull;
    private static Instruction s_UInt64LiftedToNull;
    private static Instruction s_singleLiftedToNull;
    private static Instruction s_doubleLiftedToNull;
    public int ConsumedStack { get; }
    public int ProducedStack { get; }
    public string InstructionName { get; }
    public virtual int get_ConsumedStack();
    public virtual int get_ProducedStack();
    public virtual string get_InstructionName();
    public static Instruction Create(Type type, bool liftedToNull);
}
internal abstract class System.Linq.Expressions.Interpreter.NotInstruction : Instruction {
    public static Instruction _Bool;
    public static Instruction _Int64;
    public static Instruction _Int32;
    public static Instruction _Int16;
    public static Instruction _UInt64;
    public static Instruction _UInt32;
    public static Instruction _UInt16;
    public static Instruction _Byte;
    public static Instruction _SByte;
    public int ConsumedStack { get; }
    public int ProducedStack { get; }
    public string InstructionName { get; }
    public virtual int get_ConsumedStack();
    public virtual int get_ProducedStack();
    public virtual string get_InstructionName();
    public static Instruction Create(Type t);
}
internal abstract class System.Linq.Expressions.Interpreter.NullableMethodCallInstruction : Instruction {
    private static NullableMethodCallInstruction s_hasValue;
    private static NullableMethodCallInstruction s_value;
    private static NullableMethodCallInstruction s_equals;
    private static NullableMethodCallInstruction s_getHashCode;
    private static NullableMethodCallInstruction s_getValueOrDefault1;
    private static NullableMethodCallInstruction s_toString;
    public int ConsumedStack { get; }
    public int ProducedStack { get; }
    public string InstructionName { get; }
    public virtual int get_ConsumedStack();
    public virtual int get_ProducedStack();
    public virtual string get_InstructionName();
    public static Instruction Create(string method, int argCount, MethodInfo mi);
    public static Instruction CreateGetValue();
}
internal class System.Linq.Expressions.Interpreter.NullableTypeEqualsInstruction : Instruction {
    public static NullableTypeEqualsInstruction Instance;
    public int ConsumedStack { get; }
    public int ProducedStack { get; }
    public string InstructionName { get; }
    private static NullableTypeEqualsInstruction();
    public virtual int get_ConsumedStack();
    public virtual int get_ProducedStack();
    public virtual string get_InstructionName();
    public virtual int Run(InterpretedFrame frame);
}
internal class System.Linq.Expressions.Interpreter.NullCheckInstruction : Instruction {
    public static Instruction Instance;
    public int ConsumedStack { get; }
    public int ProducedStack { get; }
    public string InstructionName { get; }
    private static NullCheckInstruction();
    public virtual int get_ConsumedStack();
    public virtual int get_ProducedStack();
    public virtual string get_InstructionName();
    public virtual int Run(InterpretedFrame frame);
}
internal abstract class System.Linq.Expressions.Interpreter.NumericConvertInstruction : Instruction {
    internal TypeCode _from;
    internal TypeCode _to;
    private bool _isLiftedToNull;
    public string InstructionName { get; }
    public int ConsumedStack { get; }
    public int ProducedStack { get; }
    protected NumericConvertInstruction(TypeCode from, TypeCode to, bool isLiftedToNull);
    public sealed virtual int Run(InterpretedFrame frame);
    protected abstract virtual object Convert(object obj);
    public virtual string get_InstructionName();
    public virtual int get_ConsumedStack();
    public virtual int get_ProducedStack();
    public virtual string ToString();
}
internal abstract class System.Linq.Expressions.Interpreter.OffsetInstruction : Instruction {
    internal static int Unknown;
    internal static int CacheSize;
    protected int _offset;
    public Instruction[] Cache { get; }
    public abstract virtual Instruction[] get_Cache();
    public Instruction Fixup(int offset);
    public virtual string ToDebugString(int instructionIndex, object cookie, Func`2<int, int> labelIndexer, IList`1<object> objects);
    public virtual string ToString();
}
internal abstract class System.Linq.Expressions.Interpreter.OnesComplementInstruction : Instruction {
    private static Instruction s_byte;
    private static Instruction s_sbyte;
    private static Instruction s_int16;
    private static Instruction s_int32;
    private static Instruction s_int64;
    private static Instruction s_UInt16;
    private static Instruction s_UInt32;
    private static Instruction s_UInt64;
    public int ConsumedStack { get; }
    public int ProducedStack { get; }
    public string InstructionName { get; }
    public virtual int get_ConsumedStack();
    public virtual int get_ProducedStack();
    public virtual string get_InstructionName();
    public static Instruction Create(Type type);
}
internal abstract class System.Linq.Expressions.Interpreter.OrInstruction : Instruction {
    private static Instruction s_SByte;
    private static Instruction s_int16;
    private static Instruction s_int32;
    private static Instruction s_int64;
    private static Instruction s_byte;
    private static Instruction s_UInt16;
    private static Instruction s_UInt32;
    private static Instruction s_UInt64;
    private static Instruction s_bool;
    public int ConsumedStack { get; }
    public int ProducedStack { get; }
    public string InstructionName { get; }
    public virtual int get_ConsumedStack();
    public virtual int get_ProducedStack();
    public virtual string get_InstructionName();
    public static Instruction Create(Type type);
}
internal class System.Linq.Expressions.Interpreter.ParameterByRefUpdater : ByRefUpdater {
    private LocalVariable _parameter;
    public ParameterByRefUpdater(LocalVariable parameter, int argumentIndex);
    public virtual void Update(InterpretedFrame frame, object value);
}
internal class System.Linq.Expressions.Interpreter.PopInstruction : Instruction {
    internal static PopInstruction Instance;
    public int ConsumedStack { get; }
    public string InstructionName { get; }
    private static PopInstruction();
    public virtual int get_ConsumedStack();
    public virtual string get_InstructionName();
    public virtual int Run(InterpretedFrame frame);
    public virtual string ToString();
}
internal class System.Linq.Expressions.Interpreter.PropertyByRefUpdater : ByRefUpdater {
    private Nullable`1<LocalDefinition> _object;
    private PropertyInfo _property;
    public PropertyByRefUpdater(Nullable`1<LocalDefinition> obj, PropertyInfo property, int argumentIndex);
    public virtual void Update(InterpretedFrame frame, object value);
    public virtual void UndefineTemps(InstructionList instructions, LocalVariables locals);
}
internal class System.Linq.Expressions.Interpreter.QuoteInstruction : Instruction {
    private Expression _operand;
    private Dictionary`2<ParameterExpression, LocalVariable> _hoistedVariables;
    public int ConsumedStack { get; }
    public int ProducedStack { get; }
    public string InstructionName { get; }
    public QuoteInstruction(Expression operand, Dictionary`2<ParameterExpression, LocalVariable> hoistedVariables);
    public virtual int get_ConsumedStack();
    public virtual int get_ProducedStack();
    public virtual string get_InstructionName();
    public virtual int Run(InterpretedFrame frame);
}
internal class System.Linq.Expressions.Interpreter.RethrowException : Exception {
}
internal abstract class System.Linq.Expressions.Interpreter.RightShiftInstruction : Instruction {
    private static Instruction s_SByte;
    private static Instruction s_int16;
    private static Instruction s_int32;
    private static Instruction s_int64;
    private static Instruction s_byte;
    private static Instruction s_UInt16;
    private static Instruction s_UInt32;
    private static Instruction s_UInt64;
    public int ConsumedStack { get; }
    public int ProducedStack { get; }
    public string InstructionName { get; }
    public virtual int get_ConsumedStack();
    public virtual int get_ProducedStack();
    public virtual string get_InstructionName();
    public static Instruction Create(Type type);
}
internal class System.Linq.Expressions.Interpreter.RuntimeLabel : ValueType {
    public int Index;
    public int StackDepth;
    public int ContinuationStackDepth;
    public RuntimeLabel(int index, int continuationStackDepth, int stackDepth);
    public virtual string ToString();
}
internal class System.Linq.Expressions.Interpreter.RuntimeVariables : object {
    private IStrongBox[] _boxes;
    private int System.Runtime.CompilerServices.IRuntimeVariables.Count { get; }
    private object System.Runtime.CompilerServices.IRuntimeVariables.Item { get; private set; }
    private RuntimeVariables(IStrongBox[] boxes);
    private sealed virtual override int System.Runtime.CompilerServices.IRuntimeVariables.get_Count();
    private sealed virtual override object System.Runtime.CompilerServices.IRuntimeVariables.get_Item(int index);
    private sealed virtual override void System.Runtime.CompilerServices.IRuntimeVariables.set_Item(int index, object value);
    internal static IRuntimeVariables Create(IStrongBox[] boxes);
}
internal class System.Linq.Expressions.Interpreter.RuntimeVariablesInstruction : Instruction {
    private int _count;
    public int ProducedStack { get; }
    public int ConsumedStack { get; }
    public string InstructionName { get; }
    public RuntimeVariablesInstruction(int count);
    public virtual int get_ProducedStack();
    public virtual int get_ConsumedStack();
    public virtual int Run(InterpretedFrame frame);
    public virtual string get_InstructionName();
    public virtual string ToString();
}
internal class System.Linq.Expressions.Interpreter.ScriptingRuntimeHelpers : object {
    private static object Int32_m;
    private static object Int32_0;
    private static object Int32_1;
    private static object Int32_2;
    internal static object True;
    internal static object False;
    private static ScriptingRuntimeHelpers();
    public static object Int32ToObject(int i);
    public static object BooleanToObject(bool b);
    internal static object GetPrimitiveDefaultValue(Type type);
}
internal class System.Linq.Expressions.Interpreter.SetArrayItemInstruction : Instruction {
    internal static SetArrayItemInstruction Instruction;
    public int ConsumedStack { get; }
    public int ProducedStack { get; }
    public string InstructionName { get; }
    private static SetArrayItemInstruction();
    public virtual int get_ConsumedStack();
    public virtual int get_ProducedStack();
    public virtual string get_InstructionName();
    public virtual int Run(InterpretedFrame frame);
}
internal class System.Linq.Expressions.Interpreter.StoreFieldInstruction : Instruction {
    private FieldInfo _field;
    public string InstructionName { get; }
    public int ConsumedStack { get; }
    public int ProducedStack { get; }
    public StoreFieldInstruction(FieldInfo field);
    public virtual string get_InstructionName();
    public virtual int get_ConsumedStack();
    public virtual int get_ProducedStack();
    public virtual int Run(InterpretedFrame frame);
}
internal class System.Linq.Expressions.Interpreter.StoreLocalBoxedInstruction : LocalAccessInstruction {
    public int ConsumedStack { get; }
    public int ProducedStack { get; }
    public string InstructionName { get; }
    internal StoreLocalBoxedInstruction(int index);
    public virtual int get_ConsumedStack();
    public virtual int get_ProducedStack();
    public virtual string get_InstructionName();
    public virtual int Run(InterpretedFrame frame);
}
internal class System.Linq.Expressions.Interpreter.StoreLocalInstruction : LocalAccessInstruction {
    public int ConsumedStack { get; }
    public string InstructionName { get; }
    internal StoreLocalInstruction(int index);
    public virtual int get_ConsumedStack();
    public virtual string get_InstructionName();
    public virtual int Run(InterpretedFrame frame);
    public sealed virtual Instruction BoxIfIndexMatches(int index);
}
internal class System.Linq.Expressions.Interpreter.StoreStaticFieldInstruction : Instruction {
    private FieldInfo _field;
    public string InstructionName { get; }
    public int ConsumedStack { get; }
    public int ProducedStack { get; }
    public StoreStaticFieldInstruction(FieldInfo field);
    public virtual string get_InstructionName();
    public virtual int get_ConsumedStack();
    public virtual int get_ProducedStack();
    public virtual int Run(InterpretedFrame frame);
}
internal class System.Linq.Expressions.Interpreter.StringSwitchInstruction : Instruction {
    private Dictionary`2<string, int> _cases;
    private StrongBox`1<int> _nullCase;
    public string InstructionName { get; }
    public int ConsumedStack { get; }
    public int ProducedStack { get; }
    internal StringSwitchInstruction(Dictionary`2<string, int> cases, StrongBox`1<int> nullCase);
    public virtual string get_InstructionName();
    public virtual int get_ConsumedStack();
    public virtual int get_ProducedStack();
    public virtual int Run(InterpretedFrame frame);
}
internal abstract class System.Linq.Expressions.Interpreter.SubInstruction : Instruction {
    private static Instruction s_int16;
    private static Instruction s_int32;
    private static Instruction s_int64;
    private static Instruction s_UInt16;
    private static Instruction s_UInt32;
    private static Instruction s_UInt64;
    private static Instruction s_single;
    private static Instruction s_double;
    public int ConsumedStack { get; }
    public int ProducedStack { get; }
    public string InstructionName { get; }
    public virtual int get_ConsumedStack();
    public virtual int get_ProducedStack();
    public virtual string get_InstructionName();
    public static Instruction Create(Type type);
}
internal abstract class System.Linq.Expressions.Interpreter.SubOvfInstruction : Instruction {
    private static Instruction s_int16;
    private static Instruction s_int32;
    private static Instruction s_int64;
    private static Instruction s_UInt16;
    private static Instruction s_UInt32;
    private static Instruction s_UInt64;
    public int ConsumedStack { get; }
    public int ProducedStack { get; }
    public string InstructionName { get; }
    public virtual int get_ConsumedStack();
    public virtual int get_ProducedStack();
    public virtual string get_InstructionName();
    public static Instruction Create(Type type);
}
internal class System.Linq.Expressions.Interpreter.ThrowInstruction : Instruction {
    internal static ThrowInstruction Throw;
    internal static ThrowInstruction VoidThrow;
    internal static ThrowInstruction Rethrow;
    internal static ThrowInstruction VoidRethrow;
    private bool _hasResult;
    private bool _rethrow;
    public string InstructionName { get; }
    public int ProducedStack { get; }
    public int ConsumedStack { get; }
    private ThrowInstruction(bool hasResult, bool isRethrow);
    private static ThrowInstruction();
    public virtual string get_InstructionName();
    public virtual int get_ProducedStack();
    public virtual int get_ConsumedStack();
    public virtual int Run(InterpretedFrame frame);
}
internal class System.Linq.Expressions.Interpreter.TryCatchFinallyHandler : object {
    internal int TryStartIndex;
    internal int TryEndIndex;
    internal int FinallyStartIndex;
    internal int FinallyEndIndex;
    internal int GotoEndTargetIndex;
    private ExceptionHandler[] _handlers;
    internal bool IsFinallyBlockExist { get; }
    internal bool IsCatchBlockExist { get; }
    internal TryCatchFinallyHandler(int tryStart, int tryEnd, int gotoEndTargetIndex, ExceptionHandler[] handlers);
    internal TryCatchFinallyHandler(int tryStart, int tryEnd, int gotoEndLabelIndex, int finallyStart, int finallyEnd, ExceptionHandler[] handlers);
    internal bool get_IsFinallyBlockExist();
    internal bool get_IsCatchBlockExist();
    internal bool HasHandler(InterpretedFrame frame, Exception& exception, ExceptionHandler& handler);
    internal bool FilterPasses(InterpretedFrame frame, Exception& exception, ExceptionFilter filter);
}
internal class System.Linq.Expressions.Interpreter.TryFaultHandler : object {
    internal int TryStartIndex;
    internal int TryEndIndex;
    internal int FinallyStartIndex;
    internal int FinallyEndIndex;
    internal TryFaultHandler(int tryStart, int tryEnd, int finallyStart, int finallyEnd);
}
internal class System.Linq.Expressions.Interpreter.TypeAsInstruction : Instruction {
    private Type _type;
    public int ConsumedStack { get; }
    public int ProducedStack { get; }
    public string InstructionName { get; }
    internal TypeAsInstruction(Type type);
    public virtual int get_ConsumedStack();
    public virtual int get_ProducedStack();
    public virtual string get_InstructionName();
    public virtual int Run(InterpretedFrame frame);
    public virtual string ToString();
}
internal class System.Linq.Expressions.Interpreter.TypeEqualsInstruction : Instruction {
    public static TypeEqualsInstruction Instance;
    public int ConsumedStack { get; }
    public int ProducedStack { get; }
    public string InstructionName { get; }
    private static TypeEqualsInstruction();
    public virtual int get_ConsumedStack();
    public virtual int get_ProducedStack();
    public virtual string get_InstructionName();
    public virtual int Run(InterpretedFrame frame);
}
internal class System.Linq.Expressions.Interpreter.TypeIsInstruction : Instruction {
    private Type _type;
    public int ConsumedStack { get; }
    public int ProducedStack { get; }
    public string InstructionName { get; }
    internal TypeIsInstruction(Type type);
    public virtual int get_ConsumedStack();
    public virtual int get_ProducedStack();
    public virtual string get_InstructionName();
    public virtual int Run(InterpretedFrame frame);
    public virtual string ToString();
}
internal class System.Linq.Expressions.Interpreter.ValueTypeCopyInstruction : Instruction {
    public static ValueTypeCopyInstruction Instruction;
    public int ConsumedStack { get; }
    public int ProducedStack { get; }
    public string InstructionName { get; }
    private static ValueTypeCopyInstruction();
    public virtual int get_ConsumedStack();
    public virtual int get_ProducedStack();
    public virtual string get_InstructionName();
    public virtual int Run(InterpretedFrame frame);
}
[DebuggerTypeProxyAttribute("System.Linq.Expressions.Expression/InvocationExpressionProxy")]
public class System.Linq.Expressions.InvocationExpression : Expression {
    private Expression _lambda;
    private Type _returnType;
    public Type Type { get; }
    public ExpressionType NodeType { get; }
    public Expression Expression { get; }
    public ReadOnlyCollection`1<Expression> Arguments { get; }
    public int ArgumentCount { get; }
    internal LambdaExpression LambdaOperand { get; }
    internal InvocationExpression(Expression lambda, Type returnType);
    public sealed virtual Type get_Type();
    public sealed virtual ExpressionType get_NodeType();
    public Expression get_Expression();
    public ReadOnlyCollection`1<Expression> get_Arguments();
    public InvocationExpression Update(Expression expression, IEnumerable`1<Expression> arguments);
    internal virtual ReadOnlyCollection`1<Expression> GetOrMakeArguments();
    public virtual Expression GetArgument(int index);
    public virtual int get_ArgumentCount();
    protected internal virtual Expression Accept(ExpressionVisitor visitor);
    internal virtual InvocationExpression Rewrite(Expression lambda, Expression[] arguments);
    internal LambdaExpression get_LambdaOperand();
}
internal class System.Linq.Expressions.InvocationExpression0 : InvocationExpression {
    public int ArgumentCount { get; }
    public InvocationExpression0(Expression lambda, Type returnType);
    internal virtual ReadOnlyCollection`1<Expression> GetOrMakeArguments();
    public virtual Expression GetArgument(int index);
    public virtual int get_ArgumentCount();
    internal virtual InvocationExpression Rewrite(Expression lambda, Expression[] arguments);
}
internal class System.Linq.Expressions.InvocationExpression1 : InvocationExpression {
    private object _arg0;
    public int ArgumentCount { get; }
    public InvocationExpression1(Expression lambda, Type returnType, Expression arg0);
    internal virtual ReadOnlyCollection`1<Expression> GetOrMakeArguments();
    public virtual Expression GetArgument(int index);
    public virtual int get_ArgumentCount();
    internal virtual InvocationExpression Rewrite(Expression lambda, Expression[] arguments);
}
internal class System.Linq.Expressions.InvocationExpression2 : InvocationExpression {
    private object _arg0;
    private Expression _arg1;
    public int ArgumentCount { get; }
    public InvocationExpression2(Expression lambda, Type returnType, Expression arg0, Expression arg1);
    internal virtual ReadOnlyCollection`1<Expression> GetOrMakeArguments();
    public virtual Expression GetArgument(int index);
    public virtual int get_ArgumentCount();
    internal virtual InvocationExpression Rewrite(Expression lambda, Expression[] arguments);
}
internal class System.Linq.Expressions.InvocationExpression3 : InvocationExpression {
    private object _arg0;
    private Expression _arg1;
    private Expression _arg2;
    public int ArgumentCount { get; }
    public InvocationExpression3(Expression lambda, Type returnType, Expression arg0, Expression arg1, Expression arg2);
    internal virtual ReadOnlyCollection`1<Expression> GetOrMakeArguments();
    public virtual Expression GetArgument(int index);
    public virtual int get_ArgumentCount();
    internal virtual InvocationExpression Rewrite(Expression lambda, Expression[] arguments);
}
internal class System.Linq.Expressions.InvocationExpression4 : InvocationExpression {
    private object _arg0;
    private Expression _arg1;
    private Expression _arg2;
    private Expression _arg3;
    public int ArgumentCount { get; }
    public InvocationExpression4(Expression lambda, Type returnType, Expression arg0, Expression arg1, Expression arg2, Expression arg3);
    internal virtual ReadOnlyCollection`1<Expression> GetOrMakeArguments();
    public virtual Expression GetArgument(int index);
    public virtual int get_ArgumentCount();
    internal virtual InvocationExpression Rewrite(Expression lambda, Expression[] arguments);
}
internal class System.Linq.Expressions.InvocationExpression5 : InvocationExpression {
    private object _arg0;
    private Expression _arg1;
    private Expression _arg2;
    private Expression _arg3;
    private Expression _arg4;
    public int ArgumentCount { get; }
    public InvocationExpression5(Expression lambda, Type returnType, Expression arg0, Expression arg1, Expression arg2, Expression arg3, Expression arg4);
    internal virtual ReadOnlyCollection`1<Expression> GetOrMakeArguments();
    public virtual Expression GetArgument(int index);
    public virtual int get_ArgumentCount();
    internal virtual InvocationExpression Rewrite(Expression lambda, Expression[] arguments);
}
internal class System.Linq.Expressions.InvocationExpressionN : InvocationExpression {
    private IList`1<Expression> _arguments;
    public int ArgumentCount { get; }
    public InvocationExpressionN(Expression lambda, IList`1<Expression> arguments, Type returnType);
    internal virtual ReadOnlyCollection`1<Expression> GetOrMakeArguments();
    public virtual Expression GetArgument(int index);
    public virtual int get_ArgumentCount();
    internal virtual InvocationExpression Rewrite(Expression lambda, Expression[] arguments);
}
[DebuggerTypeProxyAttribute("System.Linq.Expressions.Expression/LabelExpressionProxy")]
public class System.Linq.Expressions.LabelExpression : Expression {
    private Expression _defaultValue;
    private LabelTarget _target;
    public Type Type { get; }
    public ExpressionType NodeType { get; }
    public LabelTarget Target { get; }
    public Expression DefaultValue { get; }
    internal LabelExpression(LabelTarget label, Expression defaultValue);
    public sealed virtual Type get_Type();
    public sealed virtual ExpressionType get_NodeType();
    public LabelTarget get_Target();
    public Expression get_DefaultValue();
    protected internal virtual Expression Accept(ExpressionVisitor visitor);
    public LabelExpression Update(LabelTarget target, Expression defaultValue);
}
public class System.Linq.Expressions.LabelTarget : object {
    private Type _type;
    private string _name;
    public string Name { get; }
    public Type Type { get; }
    internal LabelTarget(Type type, string name);
    public string get_Name();
    public Type get_Type();
    public virtual string ToString();
}
[DebuggerTypeProxyAttribute("System.Linq.Expressions.Expression/LambdaExpressionProxy")]
public abstract class System.Linq.Expressions.LambdaExpression : Expression {
    private string _name;
    private Expression _body;
    private ReadOnlyCollection`1<ParameterExpression> _parameters;
    private Type _delegateType;
    private bool _tailCall;
    public Type Type { get; }
    public ExpressionType NodeType { get; }
    public ReadOnlyCollection`1<ParameterExpression> Parameters { get; }
    public string Name { get; }
    public Expression Body { get; }
    public Type ReturnType { get; }
    public bool TailCall { get; }
    internal LambdaExpression(Type delegateType, string name, Expression body, bool tailCall, ReadOnlyCollection`1<ParameterExpression> parameters);
    public sealed virtual Type get_Type();
    public sealed virtual ExpressionType get_NodeType();
    public ReadOnlyCollection`1<ParameterExpression> get_Parameters();
    public string get_Name();
    public Expression get_Body();
    public Type get_ReturnType();
    public bool get_TailCall();
    public Delegate Compile();
    public Delegate Compile(bool preferInterpretation);
}
[DebuggerTypeProxyAttribute("System.Linq.Expressions.Expression/ListInitExpressionProxy")]
public class System.Linq.Expressions.ListInitExpression : Expression {
    private NewExpression _newExpression;
    private ReadOnlyCollection`1<ElementInit> _initializers;
    public ExpressionType NodeType { get; }
    public Type Type { get; }
    public bool CanReduce { get; }
    public NewExpression NewExpression { get; }
    public ReadOnlyCollection`1<ElementInit> Initializers { get; }
    internal ListInitExpression(NewExpression newExpression, ReadOnlyCollection`1<ElementInit> initializers);
    public sealed virtual ExpressionType get_NodeType();
    public sealed virtual Type get_Type();
    public virtual bool get_CanReduce();
    public NewExpression get_NewExpression();
    public ReadOnlyCollection`1<ElementInit> get_Initializers();
    protected internal virtual Expression Accept(ExpressionVisitor visitor);
    public virtual Expression Reduce();
    public ListInitExpression Update(NewExpression newExpression, IEnumerable`1<ElementInit> initializers);
}
internal class System.Linq.Expressions.LogicalBinaryExpression : BinaryExpression {
    private ExpressionType _nodeType;
    public Type Type { get; }
    public ExpressionType NodeType { get; }
    internal LogicalBinaryExpression(ExpressionType nodeType, Expression left, Expression right);
    public sealed virtual Type get_Type();
    public sealed virtual ExpressionType get_NodeType();
}
[DebuggerTypeProxyAttribute("System.Linq.Expressions.Expression/LoopExpressionProxy")]
public class System.Linq.Expressions.LoopExpression : Expression {
    private Expression _body;
    private LabelTarget _break;
    private LabelTarget _continue;
    public Type Type { get; }
    public ExpressionType NodeType { get; }
    public Expression Body { get; }
    public LabelTarget BreakLabel { get; }
    public LabelTarget ContinueLabel { get; }
    internal LoopExpression(Expression body, LabelTarget break, LabelTarget continue);
    public sealed virtual Type get_Type();
    public sealed virtual ExpressionType get_NodeType();
    public Expression get_Body();
    public LabelTarget get_BreakLabel();
    public LabelTarget get_ContinueLabel();
    protected internal virtual Expression Accept(ExpressionVisitor visitor);
    public LoopExpression Update(LabelTarget breakLabel, LabelTarget continueLabel, Expression body);
}
public class System.Linq.Expressions.MemberAssignment : MemberBinding {
    private Expression _expression;
    public Expression Expression { get; }
    internal MemberAssignment(MemberInfo member, Expression expression);
    public Expression get_Expression();
    public MemberAssignment Update(Expression expression);
}
public abstract class System.Linq.Expressions.MemberBinding : object {
    private MemberBindingType _type;
    private MemberInfo _member;
    public MemberBindingType BindingType { get; }
    public MemberInfo Member { get; }
    [ObsoleteAttribute("Do not use this constructor. It will be removed in future releases.")]
protected MemberBinding(MemberBindingType type, MemberInfo member);
    public MemberBindingType get_BindingType();
    public MemberInfo get_Member();
    public virtual string ToString();
}
public enum System.Linq.Expressions.MemberBindingType : Enum {
    public int value__;
    public static MemberBindingType Assignment;
    public static MemberBindingType MemberBinding;
    public static MemberBindingType ListBinding;
}
[DebuggerTypeProxyAttribute("System.Linq.Expressions.Expression/MemberExpressionProxy")]
public class System.Linq.Expressions.MemberExpression : Expression {
    private Expression _expression;
    public MemberInfo Member { get; }
    public Expression Expression { get; }
    public ExpressionType NodeType { get; }
    internal MemberExpression(Expression expression);
    public MemberInfo get_Member();
    public Expression get_Expression();
    internal static PropertyExpression Make(Expression expression, PropertyInfo property);
    internal static FieldExpression Make(Expression expression, FieldInfo field);
    internal static MemberExpression Make(Expression expression, MemberInfo member);
    public sealed virtual ExpressionType get_NodeType();
    internal virtual MemberInfo GetMember();
    protected internal virtual Expression Accept(ExpressionVisitor visitor);
    public MemberExpression Update(Expression expression);
}
[DebuggerTypeProxyAttribute("System.Linq.Expressions.Expression/MemberInitExpressionProxy")]
public class System.Linq.Expressions.MemberInitExpression : Expression {
    private NewExpression _newExpression;
    private ReadOnlyCollection`1<MemberBinding> _bindings;
    public Type Type { get; }
    public bool CanReduce { get; }
    public ExpressionType NodeType { get; }
    public NewExpression NewExpression { get; }
    public ReadOnlyCollection`1<MemberBinding> Bindings { get; }
    internal MemberInitExpression(NewExpression newExpression, ReadOnlyCollection`1<MemberBinding> bindings);
    public sealed virtual Type get_Type();
    public virtual bool get_CanReduce();
    public sealed virtual ExpressionType get_NodeType();
    public NewExpression get_NewExpression();
    public ReadOnlyCollection`1<MemberBinding> get_Bindings();
    protected internal virtual Expression Accept(ExpressionVisitor visitor);
    public virtual Expression Reduce();
    internal static Expression ReduceMemberInit(Expression objExpression, ReadOnlyCollection`1<MemberBinding> bindings, bool keepOnStack);
    internal static Expression ReduceListInit(Expression listExpression, ReadOnlyCollection`1<ElementInit> initializers, bool keepOnStack);
    internal static Expression ReduceMemberBinding(ParameterExpression objVar, MemberBinding binding);
    public MemberInitExpression Update(NewExpression newExpression, IEnumerable`1<MemberBinding> bindings);
}
public class System.Linq.Expressions.MemberListBinding : MemberBinding {
    private ReadOnlyCollection`1<ElementInit> _initializers;
    public ReadOnlyCollection`1<ElementInit> Initializers { get; }
    internal MemberListBinding(MemberInfo member, ReadOnlyCollection`1<ElementInit> initializers);
    public ReadOnlyCollection`1<ElementInit> get_Initializers();
    public MemberListBinding Update(IEnumerable`1<ElementInit> initializers);
}
public class System.Linq.Expressions.MemberMemberBinding : MemberBinding {
    private ReadOnlyCollection`1<MemberBinding> _bindings;
    public ReadOnlyCollection`1<MemberBinding> Bindings { get; }
    internal MemberMemberBinding(MemberInfo member, ReadOnlyCollection`1<MemberBinding> bindings);
    public ReadOnlyCollection`1<MemberBinding> get_Bindings();
    public MemberMemberBinding Update(IEnumerable`1<MemberBinding> bindings);
}
internal class System.Linq.Expressions.MethodBinaryExpression : SimpleBinaryExpression {
    private MethodInfo _method;
    internal MethodBinaryExpression(ExpressionType nodeType, Expression left, Expression right, Type type, MethodInfo method);
    internal virtual MethodInfo GetMethod();
}
[DebuggerTypeProxyAttribute("System.Linq.Expressions.Expression/MethodCallExpressionProxy")]
public class System.Linq.Expressions.MethodCallExpression : Expression {
    private MethodInfo _method;
    public ExpressionType NodeType { get; }
    public Type Type { get; }
    public MethodInfo Method { get; }
    public Expression Object { get; }
    public ReadOnlyCollection`1<Expression> Arguments { get; }
    public int ArgumentCount { get; }
    internal MethodCallExpression(MethodInfo method);
    internal virtual Expression GetInstance();
    public sealed virtual ExpressionType get_NodeType();
    public sealed virtual Type get_Type();
    public MethodInfo get_Method();
    public Expression get_Object();
    public ReadOnlyCollection`1<Expression> get_Arguments();
    public MethodCallExpression Update(Expression object, IEnumerable`1<Expression> arguments);
    internal virtual ReadOnlyCollection`1<Expression> GetOrMakeArguments();
    protected internal virtual Expression Accept(ExpressionVisitor visitor);
    internal virtual MethodCallExpression Rewrite(Expression instance, IList`1<Expression> args);
    public virtual Expression GetArgument(int index);
    public virtual int get_ArgumentCount();
}
internal class System.Linq.Expressions.MethodCallExpression0 : MethodCallExpression {
    public int ArgumentCount { get; }
    public MethodCallExpression0(MethodInfo method);
    public virtual Expression GetArgument(int index);
    public virtual int get_ArgumentCount();
    internal virtual ReadOnlyCollection`1<Expression> GetOrMakeArguments();
    internal virtual MethodCallExpression Rewrite(Expression instance, IList`1<Expression> args);
}
internal class System.Linq.Expressions.MethodCallExpression1 : MethodCallExpression {
    private object _arg0;
    public int ArgumentCount { get; }
    public MethodCallExpression1(MethodInfo method, Expression arg0);
    public virtual Expression GetArgument(int index);
    public virtual int get_ArgumentCount();
    internal virtual ReadOnlyCollection`1<Expression> GetOrMakeArguments();
    internal virtual MethodCallExpression Rewrite(Expression instance, IList`1<Expression> args);
}
internal class System.Linq.Expressions.MethodCallExpression2 : MethodCallExpression {
    private object _arg0;
    private Expression _arg1;
    public int ArgumentCount { get; }
    public MethodCallExpression2(MethodInfo method, Expression arg0, Expression arg1);
    public virtual Expression GetArgument(int index);
    public virtual int get_ArgumentCount();
    internal virtual ReadOnlyCollection`1<Expression> GetOrMakeArguments();
    internal virtual MethodCallExpression Rewrite(Expression instance, IList`1<Expression> args);
}
internal class System.Linq.Expressions.MethodCallExpression3 : MethodCallExpression {
    private object _arg0;
    private Expression _arg1;
    private Expression _arg2;
    public int ArgumentCount { get; }
    public MethodCallExpression3(MethodInfo method, Expression arg0, Expression arg1, Expression arg2);
    public virtual Expression GetArgument(int index);
    public virtual int get_ArgumentCount();
    internal virtual ReadOnlyCollection`1<Expression> GetOrMakeArguments();
    internal virtual MethodCallExpression Rewrite(Expression instance, IList`1<Expression> args);
}
internal class System.Linq.Expressions.MethodCallExpression4 : MethodCallExpression {
    private object _arg0;
    private Expression _arg1;
    private Expression _arg2;
    private Expression _arg3;
    public int ArgumentCount { get; }
    public MethodCallExpression4(MethodInfo method, Expression arg0, Expression arg1, Expression arg2, Expression arg3);
    public virtual Expression GetArgument(int index);
    public virtual int get_ArgumentCount();
    internal virtual ReadOnlyCollection`1<Expression> GetOrMakeArguments();
    internal virtual MethodCallExpression Rewrite(Expression instance, IList`1<Expression> args);
}
internal class System.Linq.Expressions.MethodCallExpression5 : MethodCallExpression {
    private object _arg0;
    private Expression _arg1;
    private Expression _arg2;
    private Expression _arg3;
    private Expression _arg4;
    public int ArgumentCount { get; }
    public MethodCallExpression5(MethodInfo method, Expression arg0, Expression arg1, Expression arg2, Expression arg3, Expression arg4);
    public virtual Expression GetArgument(int index);
    public virtual int get_ArgumentCount();
    internal virtual ReadOnlyCollection`1<Expression> GetOrMakeArguments();
    internal virtual MethodCallExpression Rewrite(Expression instance, IList`1<Expression> args);
}
internal class System.Linq.Expressions.MethodCallExpressionN : MethodCallExpression {
    private IList`1<Expression> _arguments;
    public int ArgumentCount { get; }
    public MethodCallExpressionN(MethodInfo method, IList`1<Expression> args);
    public virtual Expression GetArgument(int index);
    public virtual int get_ArgumentCount();
    internal virtual ReadOnlyCollection`1<Expression> GetOrMakeArguments();
    internal virtual MethodCallExpression Rewrite(Expression instance, IList`1<Expression> args);
}
internal class System.Linq.Expressions.NewArrayBoundsExpression : NewArrayExpression {
    public ExpressionType NodeType { get; }
    internal NewArrayBoundsExpression(Type type, ReadOnlyCollection`1<Expression> expressions);
    public sealed virtual ExpressionType get_NodeType();
}
[DebuggerTypeProxyAttribute("System.Linq.Expressions.Expression/NewArrayExpressionProxy")]
public class System.Linq.Expressions.NewArrayExpression : Expression {
    private ReadOnlyCollection`1<Expression> _expressions;
    private Type _type;
    public Type Type { get; }
    public ReadOnlyCollection`1<Expression> Expressions { get; }
    internal NewArrayExpression(Type type, ReadOnlyCollection`1<Expression> expressions);
    internal static NewArrayExpression Make(ExpressionType nodeType, Type type, ReadOnlyCollection`1<Expression> expressions);
    public sealed virtual Type get_Type();
    public ReadOnlyCollection`1<Expression> get_Expressions();
    protected internal virtual Expression Accept(ExpressionVisitor visitor);
    public NewArrayExpression Update(IEnumerable`1<Expression> expressions);
}
internal class System.Linq.Expressions.NewArrayInitExpression : NewArrayExpression {
    public ExpressionType NodeType { get; }
    internal NewArrayInitExpression(Type type, ReadOnlyCollection`1<Expression> expressions);
    public sealed virtual ExpressionType get_NodeType();
}
[DebuggerTypeProxyAttribute("System.Linq.Expressions.Expression/NewExpressionProxy")]
public class System.Linq.Expressions.NewExpression : Expression {
    private ConstructorInfo _constructor;
    private IList`1<Expression> _arguments;
    private ReadOnlyCollection`1<MemberInfo> _members;
    public Type Type { get; }
    public ExpressionType NodeType { get; }
    public ConstructorInfo Constructor { get; }
    public ReadOnlyCollection`1<Expression> Arguments { get; }
    public int ArgumentCount { get; }
    public ReadOnlyCollection`1<MemberInfo> Members { get; }
    internal NewExpression(ConstructorInfo constructor, IList`1<Expression> arguments, ReadOnlyCollection`1<MemberInfo> members);
    public virtual Type get_Type();
    public sealed virtual ExpressionType get_NodeType();
    public ConstructorInfo get_Constructor();
    public ReadOnlyCollection`1<Expression> get_Arguments();
    public sealed virtual Expression GetArgument(int index);
    public sealed virtual int get_ArgumentCount();
    public ReadOnlyCollection`1<MemberInfo> get_Members();
    protected internal virtual Expression Accept(ExpressionVisitor visitor);
    public NewExpression Update(IEnumerable`1<Expression> arguments);
}
internal class System.Linq.Expressions.NewValueTypeExpression : NewExpression {
    private Type _valueType;
    public Type Type { get; }
    internal NewValueTypeExpression(Type type, ReadOnlyCollection`1<Expression> arguments, ReadOnlyCollection`1<MemberInfo> members);
    public sealed virtual Type get_Type();
}
internal class System.Linq.Expressions.OpAssignMethodConversionBinaryExpression : MethodBinaryExpression {
    private LambdaExpression _conversion;
    internal OpAssignMethodConversionBinaryExpression(ExpressionType nodeType, Expression left, Expression right, Type type, MethodInfo method, LambdaExpression conversion);
    internal virtual LambdaExpression GetConversion();
}
[DebuggerTypeProxyAttribute("System.Linq.Expressions.Expression/ParameterExpressionProxy")]
public class System.Linq.Expressions.ParameterExpression : Expression {
    private string _name;
    public Type Type { get; }
    public ExpressionType NodeType { get; }
    public string Name { get; }
    public bool IsByRef { get; }
    internal ParameterExpression(string name);
    internal static ParameterExpression Make(Type type, string name, bool isByRef);
    public virtual Type get_Type();
    public sealed virtual ExpressionType get_NodeType();
    public string get_Name();
    public bool get_IsByRef();
    internal virtual bool GetIsByRef();
    protected internal virtual Expression Accept(ExpressionVisitor visitor);
}
internal class System.Linq.Expressions.PrimitiveParameterExpression`1 : ParameterExpression {
    public Type Type { get; }
    internal PrimitiveParameterExpression`1(string name);
    public sealed virtual Type get_Type();
}
internal class System.Linq.Expressions.PropertyExpression : MemberExpression {
    private PropertyInfo _property;
    public Type Type { get; }
    public PropertyExpression(Expression expression, PropertyInfo member);
    internal virtual MemberInfo GetMember();
    public sealed virtual Type get_Type();
}
[DebuggerTypeProxyAttribute("System.Linq.Expressions.Expression/RuntimeVariablesExpressionProxy")]
public class System.Linq.Expressions.RuntimeVariablesExpression : Expression {
    private ReadOnlyCollection`1<ParameterExpression> _variables;
    public Type Type { get; }
    public ExpressionType NodeType { get; }
    public ReadOnlyCollection`1<ParameterExpression> Variables { get; }
    internal RuntimeVariablesExpression(ReadOnlyCollection`1<ParameterExpression> variables);
    public sealed virtual Type get_Type();
    public sealed virtual ExpressionType get_NodeType();
    public ReadOnlyCollection`1<ParameterExpression> get_Variables();
    protected internal virtual Expression Accept(ExpressionVisitor visitor);
    public RuntimeVariablesExpression Update(IEnumerable`1<ParameterExpression> variables);
}
internal class System.Linq.Expressions.Scope1 : ScopeExpression {
    private object _body;
    internal int ExpressionCount { get; }
    internal Scope1(IList`1<ParameterExpression> variables, Expression body);
    private Scope1(IList`1<ParameterExpression> variables, object body);
    internal virtual Expression GetExpression(int index);
    internal virtual int get_ExpressionCount();
    internal virtual ReadOnlyCollection`1<Expression> GetOrMakeExpressions();
    internal virtual BlockExpression Rewrite(ReadOnlyCollection`1<ParameterExpression> variables, Expression[] args);
}
internal class System.Linq.Expressions.ScopeExpression : BlockExpression {
    private IList`1<ParameterExpression> _variables;
    protected IList`1<ParameterExpression> VariablesList { get; }
    internal ScopeExpression(IList`1<ParameterExpression> variables);
    internal virtual ReadOnlyCollection`1<ParameterExpression> GetOrMakeVariables();
    protected IList`1<ParameterExpression> get_VariablesList();
    internal IList`1<ParameterExpression> ReuseOrValidateVariables(ReadOnlyCollection`1<ParameterExpression> variables);
}
internal class System.Linq.Expressions.ScopeN : ScopeExpression {
    private IList`1<Expression> _body;
    protected IList`1<Expression> Body { get; }
    internal int ExpressionCount { get; }
    internal ScopeN(IList`1<ParameterExpression> variables, IList`1<Expression> body);
    protected IList`1<Expression> get_Body();
    internal virtual Expression GetExpression(int index);
    internal virtual int get_ExpressionCount();
    internal virtual ReadOnlyCollection`1<Expression> GetOrMakeExpressions();
    internal virtual BlockExpression Rewrite(ReadOnlyCollection`1<ParameterExpression> variables, Expression[] args);
}
internal class System.Linq.Expressions.ScopeWithType : ScopeN {
    private Type _type;
    public Type Type { get; }
    internal ScopeWithType(IList`1<ParameterExpression> variables, IList`1<Expression> expressions, Type type);
    public sealed virtual Type get_Type();
    internal virtual BlockExpression Rewrite(ReadOnlyCollection`1<ParameterExpression> variables, Expression[] args);
}
internal class System.Linq.Expressions.SimpleBinaryExpression : BinaryExpression {
    private ExpressionType _nodeType;
    private Type _type;
    public ExpressionType NodeType { get; }
    public Type Type { get; }
    internal SimpleBinaryExpression(ExpressionType nodeType, Expression left, Expression right, Type type);
    public sealed virtual ExpressionType get_NodeType();
    public sealed virtual Type get_Type();
}
internal class System.Linq.Expressions.SpanDebugInfoExpression : DebugInfoExpression {
    private int _startLine;
    private int _startColumn;
    private int _endLine;
    private int _endColumn;
    public int StartLine { get; }
    public int StartColumn { get; }
    public int EndLine { get; }
    public int EndColumn { get; }
    public bool IsClear { get; }
    internal SpanDebugInfoExpression(SymbolDocumentInfo document, int startLine, int startColumn, int endLine, int endColumn);
    public virtual int get_StartLine();
    public virtual int get_StartColumn();
    public virtual int get_EndLine();
    public virtual int get_EndColumn();
    public virtual bool get_IsClear();
    protected internal virtual Expression Accept(ExpressionVisitor visitor);
}
internal static class System.Linq.Expressions.Strings : object {
    internal static string ReducibleMustOverrideReduce { get; }
    internal static string MustReduceToDifferent { get; }
    internal static string ReducedNotCompatible { get; }
    internal static string SetterHasNoParams { get; }
    internal static string PropertyCannotHaveRefType { get; }
    internal static string IndexesOfSetGetMustMatch { get; }
    internal static string AccessorsCannotHaveVarArgs { get; }
    internal static string AccessorsCannotHaveByRefArgs { get; }
    internal static string BoundsCannotBeLessThanOne { get; }
    internal static string TypeMustNotBeByRef { get; }
    internal static string TypeMustNotBePointer { get; }
    internal static string TypeDoesNotHaveConstructorForTheSignature { get; }
    internal static string SetterMustBeVoid { get; }
    internal static string PropertyTypeMustMatchSetter { get; }
    internal static string BothAccessorsMustBeStatic { get; }
    internal static string OnlyStaticFieldsHaveNullInstance { get; }
    internal static string OnlyStaticPropertiesHaveNullInstance { get; }
    internal static string OnlyStaticMethodsHaveNullInstance { get; }
    internal static string PropertyTypeCannotBeVoid { get; }
    internal static string InvalidUnboxType { get; }
    internal static string ExpressionMustBeWriteable { get; }
    internal static string ArgumentMustNotHaveValueType { get; }
    internal static string MustBeReducible { get; }
    internal static string AllTestValuesMustHaveSameType { get; }
    internal static string AllCaseBodiesMustHaveSameType { get; }
    internal static string DefaultBodyMustBeSupplied { get; }
    internal static string LabelMustBeVoidOrHaveExpression { get; }
    internal static string LabelTypeMustBeVoid { get; }
    internal static string QuotedExpressionMustBeLambda { get; }
    internal static string StartEndMustBeOrdered { get; }
    internal static string FaultCannotHaveCatchOrFinally { get; }
    internal static string TryMustHaveCatchFinallyOrFault { get; }
    internal static string BodyOfCatchMustHaveSameTypeAsBodyOfTry { get; }
    internal static string ConversionIsNotSupportedForArithmeticTypes { get; }
    internal static string ArgumentMustBeArray { get; }
    internal static string ArgumentMustBeBoolean { get; }
    internal static string ArgumentMustBeFieldInfoOrPropertyInfo { get; }
    internal static string ArgumentMustBeFieldInfoOrPropertyInfoOrMethod { get; }
    internal static string ArgumentMustBeInstanceMember { get; }
    internal static string ArgumentMustBeInteger { get; }
    internal static string ArgumentMustBeArrayIndexType { get; }
    internal static string ArgumentMustBeSingleDimensionalArrayType { get; }
    internal static string ArgumentTypesMustMatch { get; }
    internal static string CoalesceUsedOnNonNullType { get; }
    internal static string IncorrectNumberOfIndexes { get; }
    internal static string IncorrectNumberOfLambdaDeclarationParameters { get; }
    internal static string IncorrectNumberOfMembersForGivenConstructor { get; }
    internal static string IncorrectNumberOfArgumentsForMembers { get; }
    internal static string LambdaTypeMustBeDerivedFromSystemDelegate { get; }
    internal static string ElementInitializerMethodNotAdd { get; }
    internal static string ElementInitializerMethodWithZeroArgs { get; }
    internal static string ElementInitializerMethodStatic { get; }
    internal static string UnexpectedCoalesceOperator { get; }
    internal static string UnhandledBinding { get; }
    internal static string UnknownBindingType { get; }
    internal static string IncorrectNumberOfTypeArgsForFunc { get; }
    internal static string IncorrectNumberOfTypeArgsForAction { get; }
    internal static string ArgumentCannotBeOfTypeVoid { get; }
    internal static string ControlCannotLeaveFinally { get; }
    internal static string ControlCannotLeaveFilterTest { get; }
    internal static string ControlCannotEnterTry { get; }
    internal static string ControlCannotEnterExpression { get; }
    internal static string ExtensionNotReduced { get; }
    internal static string CannotCompileDynamic { get; }
    internal static string RethrowRequiresCatch { get; }
    internal static string TryNotAllowedInFilter { get; }
    internal static string HomogeneousAppDomainRequired { get; }
    internal static string PdbGeneratorNeedsExpressionCompiler { get; }
    internal static string NonStaticConstructorRequired { get; }
    internal static string NonAbstractConstructorRequired { get; }
    internal static string get_ReducibleMustOverrideReduce();
    internal static string get_MustReduceToDifferent();
    internal static string get_ReducedNotCompatible();
    internal static string get_SetterHasNoParams();
    internal static string get_PropertyCannotHaveRefType();
    internal static string get_IndexesOfSetGetMustMatch();
    internal static string get_AccessorsCannotHaveVarArgs();
    internal static string get_AccessorsCannotHaveByRefArgs();
    internal static string get_BoundsCannotBeLessThanOne();
    internal static string get_TypeMustNotBeByRef();
    internal static string get_TypeMustNotBePointer();
    internal static string get_TypeDoesNotHaveConstructorForTheSignature();
    internal static string get_SetterMustBeVoid();
    internal static string get_PropertyTypeMustMatchSetter();
    internal static string get_BothAccessorsMustBeStatic();
    internal static string get_OnlyStaticFieldsHaveNullInstance();
    internal static string get_OnlyStaticPropertiesHaveNullInstance();
    internal static string get_OnlyStaticMethodsHaveNullInstance();
    internal static string get_PropertyTypeCannotBeVoid();
    internal static string get_InvalidUnboxType();
    internal static string get_ExpressionMustBeWriteable();
    internal static string get_ArgumentMustNotHaveValueType();
    internal static string get_MustBeReducible();
    internal static string get_AllTestValuesMustHaveSameType();
    internal static string get_AllCaseBodiesMustHaveSameType();
    internal static string get_DefaultBodyMustBeSupplied();
    internal static string get_LabelMustBeVoidOrHaveExpression();
    internal static string get_LabelTypeMustBeVoid();
    internal static string get_QuotedExpressionMustBeLambda();
    internal static string VariableMustNotBeByRef(object p0, object p1);
    internal static string DuplicateVariable(object p0);
    internal static string get_StartEndMustBeOrdered();
    internal static string get_FaultCannotHaveCatchOrFinally();
    internal static string get_TryMustHaveCatchFinallyOrFault();
    internal static string get_BodyOfCatchMustHaveSameTypeAsBodyOfTry();
    internal static string ExtensionNodeMustOverrideProperty(object p0);
    internal static string UserDefinedOperatorMustBeStatic(object p0);
    internal static string UserDefinedOperatorMustNotBeVoid(object p0);
    internal static string CoercionOperatorNotDefined(object p0, object p1);
    internal static string UnaryOperatorNotDefined(object p0, object p1);
    internal static string BinaryOperatorNotDefined(object p0, object p1, object p2);
    internal static string ReferenceEqualityNotDefined(object p0, object p1);
    internal static string OperandTypesDoNotMatchParameters(object p0, object p1);
    internal static string OverloadOperatorTypeDoesNotMatchConversionType(object p0, object p1);
    internal static string get_ConversionIsNotSupportedForArithmeticTypes();
    internal static string get_ArgumentMustBeArray();
    internal static string get_ArgumentMustBeBoolean();
    internal static string EqualityMustReturnBoolean(object p0);
    internal static string get_ArgumentMustBeFieldInfoOrPropertyInfo();
    internal static string get_ArgumentMustBeFieldInfoOrPropertyInfoOrMethod();
    internal static string get_ArgumentMustBeInstanceMember();
    internal static string get_ArgumentMustBeInteger();
    internal static string get_ArgumentMustBeArrayIndexType();
    internal static string get_ArgumentMustBeSingleDimensionalArrayType();
    internal static string get_ArgumentTypesMustMatch();
    internal static string CannotAutoInitializeValueTypeElementThroughProperty(object p0);
    internal static string CannotAutoInitializeValueTypeMemberThroughProperty(object p0);
    internal static string IncorrectTypeForTypeAs(object p0);
    internal static string get_CoalesceUsedOnNonNullType();
    internal static string ExpressionTypeCannotInitializeArrayType(object p0, object p1);
    internal static string ArgumentTypeDoesNotMatchMember(object p0, object p1);
    internal static string ArgumentMemberNotDeclOnType(object p0, object p1);
    internal static string ExpressionTypeDoesNotMatchReturn(object p0, object p1);
    internal static string ExpressionTypeDoesNotMatchAssignment(object p0, object p1);
    internal static string ExpressionTypeDoesNotMatchLabel(object p0, object p1);
    internal static string ExpressionTypeNotInvocable(object p0);
    internal static string FieldNotDefinedForType(object p0, object p1);
    internal static string InstanceFieldNotDefinedForType(object p0, object p1);
    internal static string FieldInfoNotDefinedForType(object p0, object p1, object p2);
    internal static string get_IncorrectNumberOfIndexes();
    internal static string get_IncorrectNumberOfLambdaDeclarationParameters();
    internal static string get_IncorrectNumberOfMembersForGivenConstructor();
    internal static string get_IncorrectNumberOfArgumentsForMembers();
    internal static string get_LambdaTypeMustBeDerivedFromSystemDelegate();
    internal static string MemberNotFieldOrProperty(object p0);
    internal static string MethodContainsGenericParameters(object p0);
    internal static string MethodIsGeneric(object p0);
    internal static string MethodNotPropertyAccessor(object p0, object p1);
    internal static string PropertyDoesNotHaveGetter(object p0);
    internal static string PropertyDoesNotHaveSetter(object p0);
    internal static string PropertyDoesNotHaveAccessor(object p0);
    internal static string NotAMemberOfType(object p0, object p1);
    internal static string ExpressionNotSupportedForType(object p0, object p1);
    internal static string ExpressionNotSupportedForNullableType(object p0, object p1);
    internal static string ParameterExpressionNotValidAsDelegate(object p0, object p1);
    internal static string PropertyNotDefinedForType(object p0, object p1);
    internal static string InstancePropertyNotDefinedForType(object p0, object p1);
    internal static string InstancePropertyWithoutParameterNotDefinedForType(object p0, object p1);
    internal static string InstancePropertyWithSpecifiedParametersNotDefinedForType(object p0, object p1, object p2);
    internal static string InstanceAndMethodTypeMismatch(object p0, object p1, object p2);
    internal static string TypeMissingDefaultConstructor(object p0);
    internal static string get_ElementInitializerMethodNotAdd();
    internal static string ElementInitializerMethodNoRefOutParam(object p0, object p1);
    internal static string get_ElementInitializerMethodWithZeroArgs();
    internal static string get_ElementInitializerMethodStatic();
    internal static string TypeNotIEnumerable(object p0);
    internal static string get_UnexpectedCoalesceOperator();
    internal static string InvalidCast(object p0, object p1);
    internal static string UnhandledBinary(object p0);
    internal static string get_UnhandledBinding();
    internal static string UnhandledBindingType(object p0);
    internal static string UnhandledConvert(object p0);
    internal static string UnhandledExpressionType(object p0);
    internal static string UnhandledUnary(object p0);
    internal static string get_UnknownBindingType();
    internal static string UserDefinedOpMustHaveConsistentTypes(object p0, object p1);
    internal static string UserDefinedOpMustHaveValidReturnType(object p0, object p1);
    internal static string LogicalOperatorMustHaveBooleanOperators(object p0, object p1);
    internal static string MethodDoesNotExistOnType(object p0, object p1);
    internal static string MethodWithArgsDoesNotExistOnType(object p0, object p1);
    internal static string GenericMethodWithArgsDoesNotExistOnType(object p0, object p1);
    internal static string MethodWithMoreThanOneMatch(object p0, object p1);
    internal static string PropertyWithMoreThanOneMatch(object p0, object p1);
    internal static string get_IncorrectNumberOfTypeArgsForFunc();
    internal static string get_IncorrectNumberOfTypeArgsForAction();
    internal static string get_ArgumentCannotBeOfTypeVoid();
    internal static string OutOfRange(object p0, object p1);
    internal static string LabelTargetAlreadyDefined(object p0);
    internal static string LabelTargetUndefined(object p0);
    internal static string get_ControlCannotLeaveFinally();
    internal static string get_ControlCannotLeaveFilterTest();
    internal static string AmbiguousJump(object p0);
    internal static string get_ControlCannotEnterTry();
    internal static string get_ControlCannotEnterExpression();
    internal static string NonLocalJumpWithValue(object p0);
    internal static string get_ExtensionNotReduced();
    internal static string CannotCompileConstant(object p0);
    internal static string get_CannotCompileDynamic();
    internal static string InvalidLvalue(object p0);
    internal static string InvalidMemberType(object p0);
    internal static string UnknownLiftType(object p0);
    internal static string IllegalNewGenericParams(object p0);
    internal static string UndefinedVariable(object p0, object p1, object p2);
    internal static string CannotCloseOverByRef(object p0, object p1);
    internal static string UnexpectedVarArgsCall(object p0);
    internal static string get_RethrowRequiresCatch();
    internal static string get_TryNotAllowedInFilter();
    internal static string MustRewriteToSameNode(object p0, object p1, object p2);
    internal static string MustRewriteChildToSameType(object p0, object p1, object p2);
    internal static string MustRewriteWithoutMethod(object p0, object p1);
    internal static string TryNotSupportedForMethodsWithRefArgs(object p0);
    internal static string TryNotSupportedForValueTypeInstances(object p0);
    internal static string get_HomogeneousAppDomainRequired();
    internal static string TestValueTypeDoesNotMatchComparisonMethodParameter(object p0, object p1);
    internal static string SwitchValueTypeDoesNotMatchComparisonMethodParameter(object p0, object p1);
    internal static string get_PdbGeneratorNeedsExpressionCompiler();
    internal static string get_NonStaticConstructorRequired();
    internal static string get_NonAbstractConstructorRequired();
}
[DebuggerTypeProxyAttribute("System.Linq.Expressions.Expression/SwitchCaseProxy")]
public class System.Linq.Expressions.SwitchCase : object {
    private ReadOnlyCollection`1<Expression> _testValues;
    private Expression _body;
    public ReadOnlyCollection`1<Expression> TestValues { get; }
    public Expression Body { get; }
    internal SwitchCase(Expression body, ReadOnlyCollection`1<Expression> testValues);
    public ReadOnlyCollection`1<Expression> get_TestValues();
    public Expression get_Body();
    public virtual string ToString();
    public SwitchCase Update(IEnumerable`1<Expression> testValues, Expression body);
}
[DebuggerTypeProxyAttribute("System.Linq.Expressions.Expression/SwitchExpressionProxy")]
public class System.Linq.Expressions.SwitchExpression : Expression {
    private Type _type;
    private Expression _switchValue;
    private ReadOnlyCollection`1<SwitchCase> _cases;
    private Expression _defaultBody;
    private MethodInfo _comparison;
    public Type Type { get; }
    public ExpressionType NodeType { get; }
    public Expression SwitchValue { get; }
    public ReadOnlyCollection`1<SwitchCase> Cases { get; }
    public Expression DefaultBody { get; }
    public MethodInfo Comparison { get; }
    internal bool IsLifted { get; }
    internal SwitchExpression(Type type, Expression switchValue, Expression defaultBody, MethodInfo comparison, ReadOnlyCollection`1<SwitchCase> cases);
    public sealed virtual Type get_Type();
    public sealed virtual ExpressionType get_NodeType();
    public Expression get_SwitchValue();
    public ReadOnlyCollection`1<SwitchCase> get_Cases();
    public Expression get_DefaultBody();
    public MethodInfo get_Comparison();
    protected internal virtual Expression Accept(ExpressionVisitor visitor);
    internal bool get_IsLifted();
    public SwitchExpression Update(Expression switchValue, IEnumerable`1<SwitchCase> cases, Expression defaultBody);
}
public class System.Linq.Expressions.SymbolDocumentInfo : object {
    private string _fileName;
    internal static Guid DocumentType_Text;
    public string FileName { get; }
    public Guid Language { get; }
    public Guid LanguageVendor { get; }
    public Guid DocumentType { get; }
    internal SymbolDocumentInfo(string fileName);
    private static SymbolDocumentInfo();
    public string get_FileName();
    public virtual Guid get_Language();
    public virtual Guid get_LanguageVendor();
    public virtual Guid get_DocumentType();
}
internal class System.Linq.Expressions.SymbolDocumentWithGuids : SymbolDocumentInfo {
    private Guid _language;
    private Guid _vendor;
    private Guid _documentType;
    public Guid Language { get; }
    public Guid LanguageVendor { get; }
    public Guid DocumentType { get; }
    internal SymbolDocumentWithGuids(string fileName, Guid& language);
    internal SymbolDocumentWithGuids(string fileName, Guid& language, Guid& vendor);
    internal SymbolDocumentWithGuids(string fileName, Guid& language, Guid& vendor, Guid& documentType);
    public virtual Guid get_Language();
    public virtual Guid get_LanguageVendor();
    public virtual Guid get_DocumentType();
}
[DebuggerTypeProxyAttribute("System.Linq.Expressions.Expression/TryExpressionProxy")]
public class System.Linq.Expressions.TryExpression : Expression {
    private Type _type;
    private Expression _body;
    private ReadOnlyCollection`1<CatchBlock> _handlers;
    private Expression _finally;
    private Expression _fault;
    public Type Type { get; }
    public ExpressionType NodeType { get; }
    public Expression Body { get; }
    public ReadOnlyCollection`1<CatchBlock> Handlers { get; }
    public Expression Finally { get; }
    public Expression Fault { get; }
    internal TryExpression(Type type, Expression body, Expression finally, Expression fault, ReadOnlyCollection`1<CatchBlock> handlers);
    public sealed virtual Type get_Type();
    public sealed virtual ExpressionType get_NodeType();
    public Expression get_Body();
    public ReadOnlyCollection`1<CatchBlock> get_Handlers();
    public Expression get_Finally();
    public Expression get_Fault();
    protected internal virtual Expression Accept(ExpressionVisitor visitor);
    public TryExpression Update(Expression body, IEnumerable`1<CatchBlock> handlers, Expression finally, Expression fault);
}
[DebuggerTypeProxyAttribute("System.Linq.Expressions.Expression/TypeBinaryExpressionProxy")]
public class System.Linq.Expressions.TypeBinaryExpression : Expression {
    private Expression _expression;
    private Type _typeOperand;
    private ExpressionType _nodeKind;
    public Type Type { get; }
    public ExpressionType NodeType { get; }
    public Expression Expression { get; }
    public Type TypeOperand { get; }
    internal TypeBinaryExpression(Expression expression, Type typeOperand, ExpressionType nodeKind);
    public sealed virtual Type get_Type();
    public sealed virtual ExpressionType get_NodeType();
    public Expression get_Expression();
    public Type get_TypeOperand();
    internal Expression ReduceTypeEqual();
    private Expression ByValParameterTypeEqual(ParameterExpression value);
    private Expression ReduceConstantTypeEqual();
    protected internal virtual Expression Accept(ExpressionVisitor visitor);
    public TypeBinaryExpression Update(Expression expression);
}
internal class System.Linq.Expressions.TypedConstantExpression : ConstantExpression {
    private Type _type;
    public Type Type { get; }
    internal TypedConstantExpression(object value, Type type);
    public sealed virtual Type get_Type();
}
internal class System.Linq.Expressions.TypedParameterExpression : ParameterExpression {
    private Type _paramType;
    public Type Type { get; }
    internal TypedParameterExpression(Type type, string name);
    public sealed virtual Type get_Type();
}
[DebuggerTypeProxyAttribute("System.Linq.Expressions.Expression/UnaryExpressionProxy")]
public class System.Linq.Expressions.UnaryExpression : Expression {
    private Expression _operand;
    private MethodInfo _method;
    private ExpressionType _nodeType;
    private Type _type;
    public Type Type { get; }
    public ExpressionType NodeType { get; }
    public Expression Operand { get; }
    public MethodInfo Method { get; }
    public bool IsLifted { get; }
    public bool IsLiftedToNull { get; }
    public bool CanReduce { get; }
    private bool IsPrefix { get; }
    internal UnaryExpression(ExpressionType nodeType, Expression expression, Type type, MethodInfo method);
    public sealed virtual Type get_Type();
    public sealed virtual ExpressionType get_NodeType();
    public Expression get_Operand();
    public MethodInfo get_Method();
    public bool get_IsLifted();
    public bool get_IsLiftedToNull();
    protected internal virtual Expression Accept(ExpressionVisitor visitor);
    public virtual bool get_CanReduce();
    public virtual Expression Reduce();
    private bool get_IsPrefix();
    private UnaryExpression FunctionalOp(Expression operand);
    private Expression ReduceVariable();
    private Expression ReduceMember();
    private Expression ReduceIndex();
    public UnaryExpression Update(Expression operand);
}
internal static class System.Linq.Expressions.Utils : object {
    private static DefaultExpression s_voidInstance;
    private static Utils();
    public static DefaultExpression Empty();
}
public interface System.Linq.IOrderedQueryable {
}
public interface System.Linq.IOrderedQueryable`1 {
}
public interface System.Linq.IQueryable {
    public Expression Expression { get; }
    public Type ElementType { get; }
    public IQueryProvider Provider { get; }
    public abstract virtual Expression get_Expression();
    public abstract virtual Type get_ElementType();
    public abstract virtual IQueryProvider get_Provider();
}
public interface System.Linq.IQueryable`1 {
}
public interface System.Linq.IQueryProvider {
    public abstract virtual IQueryable CreateQuery(Expression expression);
    public abstract virtual IQueryable`1<TElement> CreateQuery(Expression expression);
    public abstract virtual object Execute(Expression expression);
    public abstract virtual TResult Execute(Expression expression);
}
internal static class System.NotImplemented : object {
    internal static Exception ByDesign { get; }
    internal static Exception get_ByDesign();
    internal static Exception ByDesignWithMessage(string message);
}
internal class System.Runtime.CompilerServices.__BlockReflectionAttribute : Attribute {
}
[DefaultMemberAttribute("Item")]
public interface System.Runtime.CompilerServices.IRuntimeVariables {
    public int Count { get; }
    public object Item { get; public set; }
    public abstract virtual int get_Count();
    public abstract virtual object get_Item(int index);
    public abstract virtual void set_Item(int index, object value);
}
[DefaultMemberAttribute("Item")]
internal class System.Runtime.CompilerServices.ReadOnlyCollectionBuilder`1 : object {
    private static int DefaultCapacity;
    private T[] _items;
    private int _size;
    private int _version;
    private object _syncRoot;
    public int Capacity { get; public set; }
    public int Count { get; }
    public T Item { get; public set; }
    private bool System.Collections.Generic.ICollection<T>.IsReadOnly { get; }
    private bool System.Collections.IList.IsReadOnly { get; }
    private bool System.Collections.IList.IsFixedSize { get; }
    private object System.Collections.IList.Item { get; private set; }
    private bool System.Collections.ICollection.IsSynchronized { get; }
    private object System.Collections.ICollection.SyncRoot { get; }
    public ReadOnlyCollectionBuilder`1(int capacity);
    public ReadOnlyCollectionBuilder`1(IEnumerable`1<T> collection);
    public int get_Capacity();
    public void set_Capacity(int value);
    public sealed virtual int get_Count();
    public sealed virtual int IndexOf(T item);
    public sealed virtual void Insert(int index, T item);
    public sealed virtual void RemoveAt(int index);
    public sealed virtual T get_Item(int index);
    public sealed virtual void set_Item(int index, T value);
    public sealed virtual void Add(T item);
    public sealed virtual void Clear();
    public sealed virtual bool Contains(T item);
    public sealed virtual void CopyTo(T[] array, int arrayIndex);
    private sealed virtual override bool System.Collections.Generic.ICollection<T>.get_IsReadOnly();
    public sealed virtual bool Remove(T item);
    public sealed virtual IEnumerator`1<T> GetEnumerator();
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
    private sealed virtual override bool System.Collections.IList.get_IsReadOnly();
    private sealed virtual override int System.Collections.IList.Add(object value);
    private sealed virtual override bool System.Collections.IList.Contains(object value);
    private sealed virtual override int System.Collections.IList.IndexOf(object value);
    private sealed virtual override void System.Collections.IList.Insert(int index, object value);
    private sealed virtual override bool System.Collections.IList.get_IsFixedSize();
    private sealed virtual override void System.Collections.IList.Remove(object value);
    private sealed virtual override object System.Collections.IList.get_Item(int index);
    private sealed virtual override void System.Collections.IList.set_Item(int index, object value);
    private sealed virtual override void System.Collections.ICollection.CopyTo(Array array, int index);
    private sealed virtual override bool System.Collections.ICollection.get_IsSynchronized();
    private sealed virtual override object System.Collections.ICollection.get_SyncRoot();
    public void Reverse();
    public void Reverse(int index, int count);
    public T[] ToArray();
    public ReadOnlyCollection`1<T> ToReadOnlyCollection();
    private void EnsureCapacity(int min);
    private static bool IsCompatibleObject(object value);
    private static void ValidateNullValue(object value, string argument);
    private static void ThrowInvalidTypeException(object value, string argument);
}
internal class System.Runtime.CompilerServices.TrueReadOnlyCollection`1 : ReadOnlyCollection`1<T> {
    public TrueReadOnlyCollection`1(T[] list);
}
internal static class System.SR : object {
    private static ResourceManager s_resourceManager;
    private static string s_resourcesName;
    private static ResourceManager ResourceManager { get; }
    internal static string ReducibleMustOverrideReduce { get; }
    internal static string MustReduceToDifferent { get; }
    internal static string ReducedNotCompatible { get; }
    internal static string SetterHasNoParams { get; }
    internal static string PropertyCannotHaveRefType { get; }
    internal static string IndexesOfSetGetMustMatch { get; }
    internal static string AccessorsCannotHaveVarArgs { get; }
    internal static string AccessorsCannotHaveByRefArgs { get; }
    internal static string BoundsCannotBeLessThanOne { get; }
    internal static string TypeMustNotBeByRef { get; }
    internal static string TypeMustNotBePointer { get; }
    internal static string TypeDoesNotHaveConstructorForTheSignature { get; }
    internal static string SetterMustBeVoid { get; }
    internal static string PropertyTypeMustMatchSetter { get; }
    internal static string BothAccessorsMustBeStatic { get; }
    internal static string OnlyStaticFieldsHaveNullInstance { get; }
    internal static string OnlyStaticPropertiesHaveNullInstance { get; }
    internal static string OnlyStaticMethodsHaveNullInstance { get; }
    internal static string PropertyTypeCannotBeVoid { get; }
    internal static string InvalidUnboxType { get; }
    internal static string ExpressionMustBeWriteable { get; }
    internal static string ArgumentMustNotHaveValueType { get; }
    internal static string MustBeReducible { get; }
    internal static string AllTestValuesMustHaveSameType { get; }
    internal static string AllCaseBodiesMustHaveSameType { get; }
    internal static string DefaultBodyMustBeSupplied { get; }
    internal static string LabelMustBeVoidOrHaveExpression { get; }
    internal static string LabelTypeMustBeVoid { get; }
    internal static string QuotedExpressionMustBeLambda { get; }
    internal static string VariableMustNotBeByRef { get; }
    internal static string DuplicateVariable { get; }
    internal static string StartEndMustBeOrdered { get; }
    internal static string FaultCannotHaveCatchOrFinally { get; }
    internal static string TryMustHaveCatchFinallyOrFault { get; }
    internal static string BodyOfCatchMustHaveSameTypeAsBodyOfTry { get; }
    internal static string ExtensionNodeMustOverrideProperty { get; }
    internal static string UserDefinedOperatorMustBeStatic { get; }
    internal static string UserDefinedOperatorMustNotBeVoid { get; }
    internal static string CoercionOperatorNotDefined { get; }
    internal static string UnaryOperatorNotDefined { get; }
    internal static string BinaryOperatorNotDefined { get; }
    internal static string ReferenceEqualityNotDefined { get; }
    internal static string OperandTypesDoNotMatchParameters { get; }
    internal static string OverloadOperatorTypeDoesNotMatchConversionType { get; }
    internal static string ConversionIsNotSupportedForArithmeticTypes { get; }
    internal static string ArgumentMustBeArray { get; }
    internal static string ArgumentMustBeBoolean { get; }
    internal static string EqualityMustReturnBoolean { get; }
    internal static string ArgumentMustBeFieldInfoOrPropertyInfo { get; }
    internal static string ArgumentMustBeFieldInfoOrPropertyInfoOrMethod { get; }
    internal static string ArgumentMustBeInstanceMember { get; }
    internal static string ArgumentMustBeInteger { get; }
    internal static string ArgumentMustBeArrayIndexType { get; }
    internal static string ArgumentMustBeSingleDimensionalArrayType { get; }
    internal static string ArgumentTypesMustMatch { get; }
    internal static string CannotAutoInitializeValueTypeElementThroughProperty { get; }
    internal static string CannotAutoInitializeValueTypeMemberThroughProperty { get; }
    internal static string IncorrectTypeForTypeAs { get; }
    internal static string CoalesceUsedOnNonNullType { get; }
    internal static string ExpressionTypeCannotInitializeArrayType { get; }
    internal static string ArgumentTypeDoesNotMatchMember { get; }
    internal static string ArgumentMemberNotDeclOnType { get; }
    internal static string ExpressionTypeDoesNotMatchReturn { get; }
    internal static string ExpressionTypeDoesNotMatchAssignment { get; }
    internal static string ExpressionTypeDoesNotMatchLabel { get; }
    internal static string ExpressionTypeNotInvocable { get; }
    internal static string FieldNotDefinedForType { get; }
    internal static string InstanceFieldNotDefinedForType { get; }
    internal static string FieldInfoNotDefinedForType { get; }
    internal static string IncorrectNumberOfIndexes { get; }
    internal static string IncorrectNumberOfLambdaDeclarationParameters { get; }
    internal static string IncorrectNumberOfMembersForGivenConstructor { get; }
    internal static string IncorrectNumberOfArgumentsForMembers { get; }
    internal static string LambdaTypeMustBeDerivedFromSystemDelegate { get; }
    internal static string MemberNotFieldOrProperty { get; }
    internal static string MethodContainsGenericParameters { get; }
    internal static string MethodIsGeneric { get; }
    internal static string MethodNotPropertyAccessor { get; }
    internal static string PropertyDoesNotHaveGetter { get; }
    internal static string PropertyDoesNotHaveSetter { get; }
    internal static string PropertyDoesNotHaveAccessor { get; }
    internal static string NotAMemberOfType { get; }
    internal static string ExpressionNotSupportedForType { get; }
    internal static string ExpressionNotSupportedForNullableType { get; }
    internal static string UnsupportedExpressionType { get; }
    internal static string ParameterExpressionNotValidAsDelegate { get; }
    internal static string PropertyNotDefinedForType { get; }
    internal static string InstancePropertyNotDefinedForType { get; }
    internal static string InstancePropertyWithoutParameterNotDefinedForType { get; }
    internal static string InstancePropertyWithSpecifiedParametersNotDefinedForType { get; }
    internal static string InstanceAndMethodTypeMismatch { get; }
    internal static string TypeContainsGenericParameters { get; }
    internal static string TypeIsGeneric { get; }
    internal static string TypeMissingDefaultConstructor { get; }
    internal static string ElementInitializerMethodNotAdd { get; }
    internal static string ElementInitializerMethodNoRefOutParam { get; }
    internal static string ElementInitializerMethodWithZeroArgs { get; }
    internal static string ElementInitializerMethodStatic { get; }
    internal static string TypeNotIEnumerable { get; }
    internal static string UnexpectedCoalesceOperator { get; }
    internal static string InvalidCast { get; }
    internal static string UnhandledBinary { get; }
    internal static string UnhandledBinding { get; }
    internal static string UnhandledBindingType { get; }
    internal static string UnhandledConvert { get; }
    internal static string UnhandledExpressionType { get; }
    internal static string UnhandledUnary { get; }
    internal static string UnknownBindingType { get; }
    internal static string UserDefinedOpMustHaveConsistentTypes { get; }
    internal static string UserDefinedOpMustHaveValidReturnType { get; }
    internal static string LogicalOperatorMustHaveBooleanOperators { get; }
    internal static string MethodDoesNotExistOnType { get; }
    internal static string MethodWithArgsDoesNotExistOnType { get; }
    internal static string GenericMethodWithArgsDoesNotExistOnType { get; }
    internal static string MethodWithMoreThanOneMatch { get; }
    internal static string PropertyWithMoreThanOneMatch { get; }
    internal static string IncorrectNumberOfTypeArgsForFunc { get; }
    internal static string IncorrectNumberOfTypeArgsForAction { get; }
    internal static string ArgumentCannotBeOfTypeVoid { get; }
    internal static string OutOfRange { get; }
    internal static string LabelTargetAlreadyDefined { get; }
    internal static string LabelTargetUndefined { get; }
    internal static string ControlCannotLeaveFinally { get; }
    internal static string ControlCannotLeaveFilterTest { get; }
    internal static string AmbiguousJump { get; }
    internal static string ControlCannotEnterTry { get; }
    internal static string ControlCannotEnterExpression { get; }
    internal static string NonLocalJumpWithValue { get; }
    internal static string ExtensionNotReduced { get; }
    internal static string CannotCompileConstant { get; }
    internal static string CannotCompileDynamic { get; }
    internal static string InvalidLvalue { get; }
    internal static string InvalidMemberType { get; }
    internal static string UnknownLiftType { get; }
    internal static string IllegalNewGenericParams { get; }
    internal static string UndefinedVariable { get; }
    internal static string CannotCloseOverByRef { get; }
    internal static string UnexpectedVarArgsCall { get; }
    internal static string RethrowRequiresCatch { get; }
    internal static string TryNotAllowedInFilter { get; }
    internal static string MustRewriteToSameNode { get; }
    internal static string MustRewriteChildToSameType { get; }
    internal static string MustRewriteWithoutMethod { get; }
    internal static string InvalidNullValue { get; }
    internal static string InvalidObjectType { get; }
    internal static string TryNotSupportedForMethodsWithRefArgs { get; }
    internal static string TryNotSupportedForValueTypeInstances { get; }
    internal static string EnumerationIsDone { get; }
    internal static string HomogeneousAppDomainRequired { get; }
    internal static string TestValueTypeDoesNotMatchComparisonMethodParameter { get; }
    internal static string SwitchValueTypeDoesNotMatchComparisonMethodParameter { get; }
    internal static string PdbGeneratorNeedsExpressionCompiler { get; }
    internal static string InvalidArgumentValue { get; }
    internal static string NonEmptyCollectionRequired { get; }
    internal static string CollectionModifiedWhileEnumerating { get; }
    internal static string ExpressionMustBeReadable { get; }
    internal static string ExpressionTypeDoesNotMatchMethodParameter { get; }
    internal static string ExpressionTypeDoesNotMatchParameter { get; }
    internal static string ExpressionTypeDoesNotMatchConstructorParameter { get; }
    internal static string IncorrectNumberOfMethodCallArguments { get; }
    internal static string IncorrectNumberOfLambdaArguments { get; }
    internal static string IncorrectNumberOfConstructorArguments { get; }
    internal static string OperatorNotImplementedForType { get; }
    internal static string NonStaticConstructorRequired { get; }
    internal static string NonAbstractConstructorRequired { get; }
    internal static Type ResourceType { get; }
    private static ResourceManager get_ResourceManager();
    private static bool UsingResourceKeys();
    internal static string GetResourceString(string resourceKey, string defaultString);
    internal static string Format(string resourceFormat, Object[] args);
    internal static string Format(string resourceFormat, object p1);
    internal static string Format(string resourceFormat, object p1, object p2);
    internal static string Format(string resourceFormat, object p1, object p2, object p3);
    internal static string get_ReducibleMustOverrideReduce();
    internal static string get_MustReduceToDifferent();
    internal static string get_ReducedNotCompatible();
    internal static string get_SetterHasNoParams();
    internal static string get_PropertyCannotHaveRefType();
    internal static string get_IndexesOfSetGetMustMatch();
    internal static string get_AccessorsCannotHaveVarArgs();
    internal static string get_AccessorsCannotHaveByRefArgs();
    internal static string get_BoundsCannotBeLessThanOne();
    internal static string get_TypeMustNotBeByRef();
    internal static string get_TypeMustNotBePointer();
    internal static string get_TypeDoesNotHaveConstructorForTheSignature();
    internal static string get_SetterMustBeVoid();
    internal static string get_PropertyTypeMustMatchSetter();
    internal static string get_BothAccessorsMustBeStatic();
    internal static string get_OnlyStaticFieldsHaveNullInstance();
    internal static string get_OnlyStaticPropertiesHaveNullInstance();
    internal static string get_OnlyStaticMethodsHaveNullInstance();
    internal static string get_PropertyTypeCannotBeVoid();
    internal static string get_InvalidUnboxType();
    internal static string get_ExpressionMustBeWriteable();
    internal static string get_ArgumentMustNotHaveValueType();
    internal static string get_MustBeReducible();
    internal static string get_AllTestValuesMustHaveSameType();
    internal static string get_AllCaseBodiesMustHaveSameType();
    internal static string get_DefaultBodyMustBeSupplied();
    internal static string get_LabelMustBeVoidOrHaveExpression();
    internal static string get_LabelTypeMustBeVoid();
    internal static string get_QuotedExpressionMustBeLambda();
    internal static string get_VariableMustNotBeByRef();
    internal static string get_DuplicateVariable();
    internal static string get_StartEndMustBeOrdered();
    internal static string get_FaultCannotHaveCatchOrFinally();
    internal static string get_TryMustHaveCatchFinallyOrFault();
    internal static string get_BodyOfCatchMustHaveSameTypeAsBodyOfTry();
    internal static string get_ExtensionNodeMustOverrideProperty();
    internal static string get_UserDefinedOperatorMustBeStatic();
    internal static string get_UserDefinedOperatorMustNotBeVoid();
    internal static string get_CoercionOperatorNotDefined();
    internal static string get_UnaryOperatorNotDefined();
    internal static string get_BinaryOperatorNotDefined();
    internal static string get_ReferenceEqualityNotDefined();
    internal static string get_OperandTypesDoNotMatchParameters();
    internal static string get_OverloadOperatorTypeDoesNotMatchConversionType();
    internal static string get_ConversionIsNotSupportedForArithmeticTypes();
    internal static string get_ArgumentMustBeArray();
    internal static string get_ArgumentMustBeBoolean();
    internal static string get_EqualityMustReturnBoolean();
    internal static string get_ArgumentMustBeFieldInfoOrPropertyInfo();
    internal static string get_ArgumentMustBeFieldInfoOrPropertyInfoOrMethod();
    internal static string get_ArgumentMustBeInstanceMember();
    internal static string get_ArgumentMustBeInteger();
    internal static string get_ArgumentMustBeArrayIndexType();
    internal static string get_ArgumentMustBeSingleDimensionalArrayType();
    internal static string get_ArgumentTypesMustMatch();
    internal static string get_CannotAutoInitializeValueTypeElementThroughProperty();
    internal static string get_CannotAutoInitializeValueTypeMemberThroughProperty();
    internal static string get_IncorrectTypeForTypeAs();
    internal static string get_CoalesceUsedOnNonNullType();
    internal static string get_ExpressionTypeCannotInitializeArrayType();
    internal static string get_ArgumentTypeDoesNotMatchMember();
    internal static string get_ArgumentMemberNotDeclOnType();
    internal static string get_ExpressionTypeDoesNotMatchReturn();
    internal static string get_ExpressionTypeDoesNotMatchAssignment();
    internal static string get_ExpressionTypeDoesNotMatchLabel();
    internal static string get_ExpressionTypeNotInvocable();
    internal static string get_FieldNotDefinedForType();
    internal static string get_InstanceFieldNotDefinedForType();
    internal static string get_FieldInfoNotDefinedForType();
    internal static string get_IncorrectNumberOfIndexes();
    internal static string get_IncorrectNumberOfLambdaDeclarationParameters();
    internal static string get_IncorrectNumberOfMembersForGivenConstructor();
    internal static string get_IncorrectNumberOfArgumentsForMembers();
    internal static string get_LambdaTypeMustBeDerivedFromSystemDelegate();
    internal static string get_MemberNotFieldOrProperty();
    internal static string get_MethodContainsGenericParameters();
    internal static string get_MethodIsGeneric();
    internal static string get_MethodNotPropertyAccessor();
    internal static string get_PropertyDoesNotHaveGetter();
    internal static string get_PropertyDoesNotHaveSetter();
    internal static string get_PropertyDoesNotHaveAccessor();
    internal static string get_NotAMemberOfType();
    internal static string get_ExpressionNotSupportedForType();
    internal static string get_ExpressionNotSupportedForNullableType();
    internal static string get_UnsupportedExpressionType();
    internal static string get_ParameterExpressionNotValidAsDelegate();
    internal static string get_PropertyNotDefinedForType();
    internal static string get_InstancePropertyNotDefinedForType();
    internal static string get_InstancePropertyWithoutParameterNotDefinedForType();
    internal static string get_InstancePropertyWithSpecifiedParametersNotDefinedForType();
    internal static string get_InstanceAndMethodTypeMismatch();
    internal static string get_TypeContainsGenericParameters();
    internal static string get_TypeIsGeneric();
    internal static string get_TypeMissingDefaultConstructor();
    internal static string get_ElementInitializerMethodNotAdd();
    internal static string get_ElementInitializerMethodNoRefOutParam();
    internal static string get_ElementInitializerMethodWithZeroArgs();
    internal static string get_ElementInitializerMethodStatic();
    internal static string get_TypeNotIEnumerable();
    internal static string get_UnexpectedCoalesceOperator();
    internal static string get_InvalidCast();
    internal static string get_UnhandledBinary();
    internal static string get_UnhandledBinding();
    internal static string get_UnhandledBindingType();
    internal static string get_UnhandledConvert();
    internal static string get_UnhandledExpressionType();
    internal static string get_UnhandledUnary();
    internal static string get_UnknownBindingType();
    internal static string get_UserDefinedOpMustHaveConsistentTypes();
    internal static string get_UserDefinedOpMustHaveValidReturnType();
    internal static string get_LogicalOperatorMustHaveBooleanOperators();
    internal static string get_MethodDoesNotExistOnType();
    internal static string get_MethodWithArgsDoesNotExistOnType();
    internal static string get_GenericMethodWithArgsDoesNotExistOnType();
    internal static string get_MethodWithMoreThanOneMatch();
    internal static string get_PropertyWithMoreThanOneMatch();
    internal static string get_IncorrectNumberOfTypeArgsForFunc();
    internal static string get_IncorrectNumberOfTypeArgsForAction();
    internal static string get_ArgumentCannotBeOfTypeVoid();
    internal static string get_OutOfRange();
    internal static string get_LabelTargetAlreadyDefined();
    internal static string get_LabelTargetUndefined();
    internal static string get_ControlCannotLeaveFinally();
    internal static string get_ControlCannotLeaveFilterTest();
    internal static string get_AmbiguousJump();
    internal static string get_ControlCannotEnterTry();
    internal static string get_ControlCannotEnterExpression();
    internal static string get_NonLocalJumpWithValue();
    internal static string get_ExtensionNotReduced();
    internal static string get_CannotCompileConstant();
    internal static string get_CannotCompileDynamic();
    internal static string get_InvalidLvalue();
    internal static string get_InvalidMemberType();
    internal static string get_UnknownLiftType();
    internal static string get_IllegalNewGenericParams();
    internal static string get_UndefinedVariable();
    internal static string get_CannotCloseOverByRef();
    internal static string get_UnexpectedVarArgsCall();
    internal static string get_RethrowRequiresCatch();
    internal static string get_TryNotAllowedInFilter();
    internal static string get_MustRewriteToSameNode();
    internal static string get_MustRewriteChildToSameType();
    internal static string get_MustRewriteWithoutMethod();
    internal static string get_InvalidNullValue();
    internal static string get_InvalidObjectType();
    internal static string get_TryNotSupportedForMethodsWithRefArgs();
    internal static string get_TryNotSupportedForValueTypeInstances();
    internal static string get_EnumerationIsDone();
    internal static string get_HomogeneousAppDomainRequired();
    internal static string get_TestValueTypeDoesNotMatchComparisonMethodParameter();
    internal static string get_SwitchValueTypeDoesNotMatchComparisonMethodParameter();
    internal static string get_PdbGeneratorNeedsExpressionCompiler();
    internal static string get_InvalidArgumentValue();
    internal static string get_NonEmptyCollectionRequired();
    internal static string get_CollectionModifiedWhileEnumerating();
    internal static string get_ExpressionMustBeReadable();
    internal static string get_ExpressionTypeDoesNotMatchMethodParameter();
    internal static string get_ExpressionTypeDoesNotMatchParameter();
    internal static string get_ExpressionTypeDoesNotMatchConstructorParameter();
    internal static string get_IncorrectNumberOfMethodCallArguments();
    internal static string get_IncorrectNumberOfLambdaArguments();
    internal static string get_IncorrectNumberOfConstructorArguments();
    internal static string get_OperatorNotImplementedForType();
    internal static string get_NonStaticConstructorRequired();
    internal static string get_NonAbstractConstructorRequired();
    internal static Type get_ResourceType();
}
