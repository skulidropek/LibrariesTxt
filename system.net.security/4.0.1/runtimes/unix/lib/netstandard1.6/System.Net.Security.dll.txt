internal static class FxResources.System.Net.Security.SR : object {
}
internal static class Interop : object {
}
[ExtensionAttribute]
internal static class InteropErrorExtensions : object {
    [ExtensionAttribute]
public static ErrorInfo Info(Error error);
}
internal abstract class Microsoft.Win32.SafeHandles.CriticalHandleMinusOneIsInvalid : CriticalHandle {
    public bool IsInvalid { get; }
    public virtual bool get_IsInvalid();
}
internal abstract class Microsoft.Win32.SafeHandles.CriticalHandleZeroOrMinusOneIsInvalid : CriticalHandle {
    public bool IsInvalid { get; }
    public virtual bool get_IsInvalid();
}
[SecurityCriticalAttribute]
internal class Microsoft.Win32.SafeHandles.SafeAsn1BitStringHandle : SafeHandle {
    public bool IsInvalid { get; }
    protected virtual bool ReleaseHandle();
    public virtual bool get_IsInvalid();
}
[SecurityCriticalAttribute]
internal class Microsoft.Win32.SafeHandles.SafeAsn1ObjectHandle : SafeHandle {
    public bool IsInvalid { get; }
    protected virtual bool ReleaseHandle();
    public virtual bool get_IsInvalid();
}
[SecurityCriticalAttribute]
internal class Microsoft.Win32.SafeHandles.SafeAsn1OctetStringHandle : SafeHandle {
    public bool IsInvalid { get; }
    protected virtual bool ReleaseHandle();
    public virtual bool get_IsInvalid();
}
[SecurityCriticalAttribute]
internal class Microsoft.Win32.SafeHandles.SafeAsn1StringHandle : SafeHandle {
    public bool IsInvalid { get; }
    protected virtual bool ReleaseHandle();
    public virtual bool get_IsInvalid();
}
[SecurityCriticalAttribute]
internal class Microsoft.Win32.SafeHandles.SafeBioHandle : SafeHandle {
    public bool IsInvalid { get; }
    protected virtual bool ReleaseHandle();
    public virtual bool get_IsInvalid();
}
internal class Microsoft.Win32.SafeHandles.SafeChannelBindingHandle : SafeHandle {
    private static int CertHashMaxSize;
    private static Byte[] s_tlsServerEndPointByteArray;
    private static Byte[] s_tlsUniqueByteArray;
    private static int s_secChannelBindingSize;
    private int _cbtPrefixByteArraySize;
    [CompilerGeneratedAttribute]
private int <Length>k__BackingField;
    [CompilerGeneratedAttribute]
private IntPtr <CertHashPtr>k__BackingField;
    internal int Length { get; private set; }
    internal IntPtr CertHashPtr { get; private set; }
    public bool IsInvalid { get; }
    internal SafeChannelBindingHandle(ChannelBindingKind kind);
    private static SafeChannelBindingHandle();
    [CompilerGeneratedAttribute]
internal int get_Length();
    [CompilerGeneratedAttribute]
private void set_Length(int value);
    [CompilerGeneratedAttribute]
internal IntPtr get_CertHashPtr();
    [CompilerGeneratedAttribute]
private void set_CertHashPtr(IntPtr value);
    internal void SetCertHash(Byte[] certHashBytes);
    private Byte[] GetPrefixBytes(ChannelBindingKind kind);
    internal void SetCertHashLength(int certHashLength);
    public virtual bool get_IsInvalid();
    protected virtual bool ReleaseHandle();
}
[SecurityCriticalAttribute]
internal class Microsoft.Win32.SafeHandles.SafeEkuExtensionHandle : SafeHandle {
    public bool IsInvalid { get; }
    protected virtual bool ReleaseHandle();
    public virtual bool get_IsInvalid();
}
internal class Microsoft.Win32.SafeHandles.SafeGssContextHandle : SafeHandle {
    public bool IsInvalid { get; }
    public virtual bool get_IsInvalid();
    protected virtual bool ReleaseHandle();
}
internal class Microsoft.Win32.SafeHandles.SafeGssCredHandle : SafeHandle {
    public bool IsInvalid { get; }
    public static SafeGssCredHandle Create(string username, string password, bool isNtlmOnly);
    public virtual bool get_IsInvalid();
    protected virtual bool ReleaseHandle();
}
internal class Microsoft.Win32.SafeHandles.SafeGssNameHandle : SafeHandle {
    public bool IsInvalid { get; }
    public static SafeGssNameHandle CreateUser(string name);
    public static SafeGssNameHandle CreatePrincipal(string name);
    public virtual bool get_IsInvalid();
    protected virtual bool ReleaseHandle();
}
internal abstract class Microsoft.Win32.SafeHandles.SafeHandleZeroOrMinusOneIsInvalid : SafeHandle {
    public bool IsInvalid { get; }
    protected SafeHandleZeroOrMinusOneIsInvalid(bool ownsHandle);
    public virtual bool get_IsInvalid();
}
internal abstract class Microsoft.Win32.SafeHandles.SafeInteriorHandle : SafeHandle {
    private SafeHandle _parent;
    public bool IsInvalid { get; }
    protected SafeInteriorHandle(IntPtr invalidHandleValue, bool ownsHandle);
    protected virtual bool ReleaseHandle();
    public virtual bool get_IsInvalid();
    internal void SetParent(SafeHandle parent);
    internal static TInteriorHandle OpenInteriorHandle(Func`2<TExteriorHandle, TInteriorHandle> accessor, TExteriorHandle exteriorHandle);
    internal static TInteriorHandle OpenInteriorHandle(Func`3<TExteriorHandle, TArg1, TInteriorHandle> accessor, TExteriorHandle exteriorHandle, TArg1 arg1);
}
internal class Microsoft.Win32.SafeHandles.SafeSharedAsn1IntegerHandle : SafeInteriorHandle {
}
internal class Microsoft.Win32.SafeHandles.SafeSharedAsn1ObjectHandle : SafeInteriorHandle {
}
internal class Microsoft.Win32.SafeHandles.SafeSharedAsn1StringHandle : SafeInteriorHandle {
}
internal class Microsoft.Win32.SafeHandles.SafeSharedX509NameHandle : SafeInteriorHandle {
}
internal class Microsoft.Win32.SafeHandles.SafeSharedX509NameStackHandle : SafeInteriorHandle {
}
internal class Microsoft.Win32.SafeHandles.SafeSharedX509StackHandle : SafeInteriorHandle {
    internal static SafeSharedX509StackHandle InvalidHandle;
    private static SafeSharedX509StackHandle();
}
internal class Microsoft.Win32.SafeHandles.SafeSslContextHandle : SafeHandle {
    public bool IsInvalid { get; }
    internal SafeSslContextHandle(IntPtr handle, bool ownsHandle);
    public virtual bool get_IsInvalid();
    protected virtual bool ReleaseHandle();
}
internal class Microsoft.Win32.SafeHandles.SafeSslHandle : SafeHandle {
    private SafeBioHandle _readBio;
    private SafeBioHandle _writeBio;
    private bool _isServer;
    private bool _handshakeCompleted;
    public bool IsServer { get; }
    public SafeBioHandle InputBio { get; }
    public SafeBioHandle OutputBio { get; }
    public bool IsInvalid { get; }
    internal SafeSslHandle(IntPtr validSslPointer, bool ownsHandle);
    public bool get_IsServer();
    public SafeBioHandle get_InputBio();
    public SafeBioHandle get_OutputBio();
    internal void MarkHandshakeCompleted();
    public static SafeSslHandle Create(SafeSslContextHandle context, bool isServer);
    public virtual bool get_IsInvalid();
    protected virtual bool ReleaseHandle();
    private void Disconnect();
}
internal class Microsoft.Win32.SafeHandles.SafeX509CrlHandle : SafeHandle {
    public bool IsInvalid { get; }
    protected virtual bool ReleaseHandle();
    public virtual bool get_IsInvalid();
}
[SecurityCriticalAttribute]
internal class Microsoft.Win32.SafeHandles.SafeX509ExtensionHandle : SafeHandle {
    public bool IsInvalid { get; }
    protected virtual bool ReleaseHandle();
    public virtual bool get_IsInvalid();
}
[SecurityCriticalAttribute]
internal class Microsoft.Win32.SafeHandles.SafeX509Handle : SafeHandle {
    internal static SafeX509Handle InvalidHandle;
    public bool IsInvalid { get; }
    private static SafeX509Handle();
    [SecurityCriticalAttribute]
protected virtual bool ReleaseHandle();
    [SecurityCriticalAttribute]
public virtual bool get_IsInvalid();
}
[SecurityCriticalAttribute]
internal class Microsoft.Win32.SafeHandles.SafeX509NameHandle : SafeHandle {
    public bool IsInvalid { get; }
    protected virtual bool ReleaseHandle();
    public virtual bool get_IsInvalid();
}
[SecurityCriticalAttribute]
internal class Microsoft.Win32.SafeHandles.SafeX509NameStackHandle : SafeHandle {
    public bool IsInvalid { get; }
    protected virtual bool ReleaseHandle();
    public virtual bool get_IsInvalid();
}
internal class Microsoft.Win32.SafeHandles.SafeX509StackHandle : SafeHandle {
    public bool IsInvalid { get; }
    protected virtual bool ReleaseHandle();
    public virtual bool get_IsInvalid();
}
internal class Microsoft.Win32.SafeHandles.SafeX509StoreCtxHandle : SafeHandle {
    public bool IsInvalid { get; }
    internal SafeX509StoreCtxHandle(IntPtr handle, bool ownsHandle);
    protected virtual bool ReleaseHandle();
    public virtual bool get_IsInvalid();
}
[SecurityCriticalAttribute]
internal class Microsoft.Win32.SafeHandles.SafeX509StoreHandle : SafeHandle {
    public bool IsInvalid { get; }
    protected virtual bool ReleaseHandle();
    public virtual bool get_IsInvalid();
}
internal class System.DBNull : object {
    public static DBNull Value;
    private static DBNull();
}
internal class System.Gen2GcCallback : object {
    private Func`2<object, bool> _callback;
    private GCHandle _weakTargetObj;
    public static void Register(Func`2<object, bool> callback, object targetObj);
    [SecuritySafeCriticalAttribute]
private void Setup(Func`2<object, bool> callback, object targetObj);
    [SecuritySafeCriticalAttribute]
protected virtual override void Finalize();
}
internal static class System.IO.__Error : object {
    internal static Exception GetStreamIsClosed();
    internal static Exception GetReadNotSupported();
    internal static Exception GetWriteNotSupported();
}
[ExtensionAttribute]
internal static class System.IO.StreamApmExtensions : object {
    [ExtensionAttribute]
public static IAsyncResult BeginRead(Stream stream, Byte[] buffer, int offset, int count, AsyncCallback callback, object state);
    [ExtensionAttribute]
public static int EndRead(Stream stream, IAsyncResult asyncResult);
    [ExtensionAttribute]
public static IAsyncResult BeginWrite(Stream stream, Byte[] buffer, int offset, int count, AsyncCallback callback, object state);
    [ExtensionAttribute]
public static void EndWrite(Stream stream, IAsyncResult asyncResult);
}
internal class System.Net.AsyncProtocolCallback : MulticastDelegate {
    public AsyncProtocolCallback(object object, IntPtr method);
    public virtual void Invoke(AsyncProtocolRequest asyncRequest);
    public virtual IAsyncResult BeginInvoke(AsyncProtocolRequest asyncRequest, AsyncCallback callback, object object);
    public virtual void EndInvoke(IAsyncResult result);
}
internal class System.Net.AsyncProtocolRequest : object {
    private AsyncProtocolCallback _callback;
    private int _completionStatus;
    private static int StatusNotStarted;
    private static int StatusCompleted;
    private static int StatusCheckedOnSyncCompletion;
    public LazyAsyncResult UserAsyncResult;
    public int Result;
    public object AsyncState;
    public Byte[] Buffer;
    public int Offset;
    public int Count;
    internal object AsyncObject { get; }
    public bool MustCompleteSynchronously { get; }
    internal bool IsUserCompleted { get; }
    public AsyncProtocolRequest(LazyAsyncResult userAsyncResult);
    public void SetNextRequest(Byte[] buffer, int offset, int count, AsyncProtocolCallback callback);
    internal object get_AsyncObject();
    internal void CompleteRequest(int result);
    public bool get_MustCompleteSynchronously();
    internal void CompleteWithError(Exception e);
    internal void CompleteUser();
    internal void CompleteUser(object userResult);
    internal bool get_IsUserCompleted();
}
internal class System.Net.BufferAsyncResult : LazyAsyncResult {
    public Byte[] Buffer;
    public int Offset;
    public int Count;
    public bool IsWrite;
    public BufferAsyncResult(object asyncObject, Byte[] buffer, int offset, int count, object asyncState, AsyncCallback asyncCallback);
    public BufferAsyncResult(object asyncObject, Byte[] buffer, int offset, int count, bool isWrite, object asyncState, AsyncCallback asyncCallback);
}
internal class System.Net.CallbackClosure : object {
    private AsyncCallback _savedCallback;
    private ExecutionContext _savedContext;
    internal AsyncCallback AsyncCallback { get; }
    internal ExecutionContext Context { get; }
    internal CallbackClosure(ExecutionContext context, AsyncCallback callback);
    internal bool IsCompatible(AsyncCallback callback);
    internal AsyncCallback get_AsyncCallback();
    internal ExecutionContext get_Context();
}
internal static class System.Net.CertificateValidationPal : object {
    private static object s_lockObject;
    private static X509Store s_userCertStore;
    private static CertificateValidationPal();
    internal static SslPolicyErrors VerifyCertificateProperties(X509Chain chain, X509Certificate2 remoteCertificate, bool checkCertName, bool isServer, string hostName);
    internal static X509Certificate2 GetRemoteCertificate(SafeDeleteContext securityContext, X509Certificate2Collection& remoteCertificateStore);
    internal static String[] GetRequestCertificateAuthorities(SafeDeleteContext securityContext);
    internal static X509Store EnsureStoreOpened(bool isMachineStore);
    private static X509Store EnsureStoreOpened(X509Store& storeField, StoreLocation storeLocation);
    private static int QueryContextRemoteCertificate(SafeDeleteContext securityContext, SafeFreeCertContext& remoteCertContext);
}
internal class System.Net.ContextAwareResult : LazyAsyncResult {
    private ExecutionContext modreq(System.Runtime.CompilerServices.IsVolatile) _context;
    private object _lock;
    private StateFlags _flags;
    internal ExecutionContext ContextCopy { get; }
    internal ContextAwareResult(object myObject, object myState, AsyncCallback myCallBack);
    internal ContextAwareResult(bool captureIdentity, bool forceCaptureContext, object myObject, object myState, AsyncCallback myCallBack);
    internal ContextAwareResult(bool captureIdentity, bool forceCaptureContext, bool threadSafeContextCopy, object myObject, object myState, AsyncCallback myCallBack);
    internal ExecutionContext get_ContextCopy();
    internal object StartPostingAsyncOp();
    internal object StartPostingAsyncOp(bool lockCapture);
    internal bool FinishPostingAsyncOp();
    internal bool FinishPostingAsyncOp(CallbackClosure& closure);
    protected virtual void Cleanup();
    private bool CaptureOrComplete(ExecutionContext& cachedContext, bool returnContext);
    protected virtual void Complete(IntPtr userToken);
    private void CompleteCallback();
    private void SafeCaptureIdentity();
    private void CleanupInternal();
}
internal static class System.Net.ContextFlagsAdapterPal : object {
    private static ContextFlagMapping[] s_contextFlagMapping;
    private static ContextFlagsAdapterPal();
    internal static ContextFlagsPal GetContextFlagsPalFromInterop(GssFlags gssFlags, bool isServer);
    internal static GssFlags GetInteropFromContextFlagsPal(ContextFlagsPal flags, bool isServer);
}
[FlagsAttribute]
internal enum System.Net.ContextFlagsPal : Enum {
    public int value__;
    public static ContextFlagsPal None;
    public static ContextFlagsPal Delegate;
    public static ContextFlagsPal MutualAuth;
    public static ContextFlagsPal ReplayDetect;
    public static ContextFlagsPal SequenceDetect;
    public static ContextFlagsPal Confidentiality;
    public static ContextFlagsPal UseSessionKey;
    public static ContextFlagsPal AllocateMemory;
    public static ContextFlagsPal Connection;
    public static ContextFlagsPal InitExtendedError;
    public static ContextFlagsPal AcceptExtendedError;
    public static ContextFlagsPal InitStream;
    public static ContextFlagsPal AcceptStream;
    public static ContextFlagsPal InitIntegrity;
    public static ContextFlagsPal AcceptIntegrity;
    public static ContextFlagsPal InitManualCredValidation;
    public static ContextFlagsPal InitUseSuppliedCreds;
    public static ContextFlagsPal InitIdentify;
    public static ContextFlagsPal AcceptIdentify;
    public static ContextFlagsPal ProxyBindings;
    public static ContextFlagsPal AllowMissingBindings;
    public static ContextFlagsPal UnverifiedTargetName;
}
[EventSourceAttribute]
internal class System.Net.EventSourceLogging : EventSource {
    private static EventSourceLogging s_log;
    public static EventSourceLogging Log { get; }
    private static EventSourceLogging();
    public static EventSourceLogging get_Log();
    [EventAttribute("1")]
public void DebugMessage(string message);
    [EventAttribute("2")]
public void DebugDumpArray(Byte[] bufferSegmentArray);
    [EventAttribute("3")]
public void WarningDumpArray(string message);
    [EventAttribute("4")]
public void FunctionStart(string functionName, string parameters);
    [EventAttribute("5")]
public void FunctionStop(string functionName, string result);
    [EventAttribute("6")]
public void WarningMessage(string message);
    [EventAttribute("7")]
public void AssertFailed(string message, string detailMessage);
    [EventAttribute("8")]
public void CriticalMessage(string message, string detailMessage);
}
internal static class System.Net.ExceptionCheck : object {
    internal static bool IsFatal(Exception exception);
}
internal class System.Net.FixedSizeReader : object {
    private static AsyncCallback s_readCallback;
    private Stream _transport;
    private AsyncProtocolRequest _request;
    private int _totalRead;
    public FixedSizeReader(Stream transport);
    private static FixedSizeReader();
    public int ReadPacket(Byte[] buffer, int offset, int count);
    public void AsyncReadPacket(AsyncProtocolRequest request);
    private void StartReading();
    private bool CheckCompletionBeforeNextRead(int bytes);
    private static void ReadCallback(IAsyncResult transportResult);
}
internal class System.Net.FrameHeader : object {
    public static int IgnoreValue;
    public static int HandshakeDoneId;
    public static int HandshakeErrId;
    public static int HandshakeId;
    public static int DefaultMajorV;
    public static int DefaultMinorV;
    private int _MessageId;
    private int _MajorV;
    private int _MinorV;
    private int _PayloadSize;
    public int Size { get; }
    public int MaxMessageSize { get; }
    public int MessageId { get; public set; }
    public int MajorV { get; }
    public int MinorV { get; }
    public int PayloadSize { get; public set; }
    public FrameHeader(int messageId, int majorV, int minorV);
    public int get_Size();
    public int get_MaxMessageSize();
    public int get_MessageId();
    public void set_MessageId(int value);
    public int get_MajorV();
    public int get_MinorV();
    public int get_PayloadSize();
    public void set_PayloadSize(int value);
    public void CopyTo(Byte[] dest, int start);
    public void CopyFrom(Byte[] bytes, int start, FrameHeader verifier);
}
internal static class System.Net.GlobalLog : object {
    [ThreadStaticAttribute]
private static Stack`1<ThreadKinds> t_threadKindStack;
    private static Stack`1<ThreadKinds> ThreadKindStack { get; }
    internal static ThreadKinds CurrentThreadKind { get; }
    public static bool IsEnabled { get; }
    private static Stack`1<ThreadKinds> get_ThreadKindStack();
    internal static ThreadKinds get_CurrentThreadKind();
    internal static IDisposable SetThreadKind(ThreadKinds kind);
    internal static void SetThreadSource(ThreadKinds source);
    internal static void ThreadContract(ThreadKinds kind, string errorMsg);
    internal static void ThreadContract(ThreadKinds kind, ThreadKinds allowedSources, string errorMsg);
    public static void Print(string msg);
    public static void Enter(string functionName);
    public static void Enter(string functionName, string parameters);
    public static void AssertFormat(string messageFormat, Object[] data);
    public static void Assert(string message);
    public static void Assert(string message, string detailMessage);
    public static void Leave(string functionName);
    public static void Leave(string functionName, string result);
    public static void Leave(string functionName, int returnval);
    public static void Leave(string functionName, bool returnval);
    public static void Dump(Byte[] buffer, int length);
    public static void Dump(Byte[] buffer, int offset, int length);
    public static bool get_IsEnabled();
}
internal class System.Net.InternalException : Exception {
}
internal static class System.Net.IntPtrHelper : object {
    internal static IntPtr Add(IntPtr a, int b);
    internal static long Subtract(IntPtr a, IntPtr b);
}
internal class System.Net.LazyAsyncResult : object {
    private static int HighBit;
    private static int ForceAsyncCount;
    [ThreadStaticAttribute]
private static ThreadContext s_threadContext;
    private object _asyncObject;
    private object _asyncState;
    private AsyncCallback _asyncCallback;
    private object _result;
    private int _errorCode;
    private int _intCompleted;
    private bool _endCalled;
    private bool _userEvent;
    private object _event;
    private static ThreadContext CurrentThreadContext { get; }
    internal object AsyncObject { get; }
    public object AsyncState { get; }
    protected AsyncCallback AsyncCallback { get; protected set; }
    public WaitHandle AsyncWaitHandle { get; }
    public bool CompletedSynchronously { get; }
    public bool IsCompleted { get; }
    internal bool InternalPeekCompleted { get; }
    internal object Result { get; internal set; }
    internal bool EndCalled { get; internal set; }
    internal int ErrorCode { get; internal set; }
    internal LazyAsyncResult(object myObject, object myState, AsyncCallback myCallBack);
    internal LazyAsyncResult(object myObject, object myState, AsyncCallback myCallBack, object result);
    private static ThreadContext get_CurrentThreadContext();
    internal object get_AsyncObject();
    public sealed virtual object get_AsyncState();
    protected AsyncCallback get_AsyncCallback();
    protected void set_AsyncCallback(AsyncCallback value);
    public sealed virtual WaitHandle get_AsyncWaitHandle();
    private bool LazilyCreateEvent(ManualResetEvent& waitHandle);
    [ConditionalAttribute("DEBUG")]
protected void DebugProtectState(bool protect);
    public sealed virtual bool get_CompletedSynchronously();
    public sealed virtual bool get_IsCompleted();
    internal bool get_InternalPeekCompleted();
    internal object get_Result();
    internal void set_Result(object value);
    internal bool get_EndCalled();
    internal void set_EndCalled(bool value);
    internal int get_ErrorCode();
    internal void set_ErrorCode(int value);
    protected void ProtectedInvokeCallback(object result, IntPtr userToken);
    internal void InvokeCallback(object result);
    internal void InvokeCallback();
    protected virtual void Complete(IntPtr userToken);
    private static void WorkerThreadComplete(object state);
    protected virtual void Cleanup();
    internal object InternalWaitForCompletion();
    private object WaitForCompletion(bool snap);
    internal void InternalCleanup();
}
internal static class System.Net.LoggingHash : object {
    internal static string GetObjectName(object obj);
    internal static int HashInt(object objectValue);
    internal static string ObjectToString(object objectValue);
    private static string ExceptionMessage(Exception exception);
    internal static string HashString(object objectValue);
    internal static Object[] GetObjectLogHash(object obj);
}
internal class System.Net.NegotiationInfoClass : object {
    internal static string NTLM;
    internal static string Kerberos;
    internal static string Negotiate;
}
[EventSourceAttribute]
internal class System.Net.NetEventSource : EventSource {
    private static int FunctionStartId;
    private static int FunctionStopId;
    private static int CriticalExceptionId;
    private static int CriticalErrorId;
    private static NetEventSource s_log;
    public static NetEventSource Log { get; }
    private static NetEventSource();
    public static NetEventSource get_Log();
    [NonEventAttribute]
internal static void Enter(ComponentType componentType, object obj, string method, object paramObject);
    [EventAttribute("1")]
internal void FunctionStart(string callerName, int callerHash, string method, string parametersName, int parametersHash, ComponentType componentType);
    [NonEventAttribute]
internal static void Exit(ComponentType componentType, object obj, string method, object retObject);
    [EventAttribute("2")]
internal void FunctionStop(string callerName, int callerHash, string method, string parametersName, int parametersHash, ComponentType componentType);
    [NonEventAttribute]
internal static void Exception(ComponentType componentType, object obj, string method, Exception e);
    [EventAttribute("3")]
internal void CriticalException(string objName, string method, string message, int objHash, string stackTrace, ComponentType componentType);
    [NonEventAttribute]
internal static void PrintError(ComponentType componentType, string msg);
    [NonEventAttribute]
internal static void PrintError(ComponentType componentType, object obj, string method, string msg);
    [EventAttribute("4")]
internal void CriticalError(string message, string method, string objName, int objHash, ComponentType componentType);
}
internal class System.Net.NTAuthentication : object {
    private static ContextCallback s_InitializeCallback;
    private bool _isServer;
    private SafeFreeCredentials _credentialsHandle;
    private SafeDeleteContext _securityContext;
    private string _spn;
    private string _clientSpecifiedSpn;
    private int _tokenSize;
    private ContextFlagsPal _requestedContextFlags;
    private ContextFlagsPal _contextFlags;
    private bool _isCompleted;
    private string _protocolName;
    private string _lastProtocolName;
    private string _package;
    private ChannelBinding _channelBinding;
    internal bool IsCompleted { get; }
    internal bool IsValidContext { get; }
    internal string AssociatedName { get; }
    internal bool IsConfidentialityFlag { get; }
    internal bool IsIntegrityFlag { get; }
    internal bool IsMutualAuthFlag { get; }
    internal bool IsDelegationFlag { get; }
    internal bool IsIdentifyFlag { get; }
    internal string Spn { get; }
    internal string ClientSpecifiedSpn { get; }
    internal bool IsServer { get; }
    internal bool IsKerberos { get; }
    internal bool IsNTLM { get; }
    internal string ProtocolName { get; }
    internal NTAuthentication(bool isServer, string package, NetworkCredential credential, string spn, ContextFlagsPal requestedContextFlags, ChannelBinding channelBinding);
    private static NTAuthentication();
    internal bool get_IsCompleted();
    internal bool get_IsValidContext();
    internal string get_AssociatedName();
    internal bool get_IsConfidentialityFlag();
    internal bool get_IsIntegrityFlag();
    internal bool get_IsMutualAuthFlag();
    internal bool get_IsDelegationFlag();
    internal bool get_IsIdentifyFlag();
    internal string get_Spn();
    internal string get_ClientSpecifiedSpn();
    internal bool get_IsServer();
    internal bool get_IsKerberos();
    internal bool get_IsNTLM();
    internal string get_ProtocolName();
    private static void InitializeCallback(object state);
    private void Initialize(bool isServer, string package, NetworkCredential credential, string spn, ContextFlagsPal requestedContextFlags, ChannelBinding channelBinding);
    internal SafeDeleteContext GetContext(SecurityStatusPal& status);
    internal void CloseContext();
    internal Byte[] GetOutgoingBlob(Byte[] incomingBlob, bool throwOnError, SecurityStatusPal& statusCode);
    internal int Encrypt(Byte[] buffer, int offset, int count, Byte[]& output, UInt32 sequenceNumber);
    internal int Decrypt(Byte[] payload, int offset, int count, Int32& newOffset, UInt32 expectedSeqNumber);
    private string GetClientSpecifiedSpn();
}
public abstract class System.Net.Security.AuthenticatedStream : Stream {
    private Stream _innerStream;
    private bool _leaveStreamOpen;
    public bool LeaveInnerStreamOpen { get; }
    protected Stream InnerStream { get; }
    public bool IsAuthenticated { get; }
    public bool IsMutuallyAuthenticated { get; }
    public bool IsEncrypted { get; }
    public bool IsSigned { get; }
    public bool IsServer { get; }
    protected AuthenticatedStream(Stream innerStream, bool leaveInnerStreamOpen);
    public bool get_LeaveInnerStreamOpen();
    protected Stream get_InnerStream();
    protected virtual void Dispose(bool disposing);
    public abstract virtual bool get_IsAuthenticated();
    public abstract virtual bool get_IsMutuallyAuthenticated();
    public abstract virtual bool get_IsEncrypted();
    public abstract virtual bool get_IsSigned();
    public abstract virtual bool get_IsServer();
}
internal static class System.Net.Security.CertificateValidation : object {
    internal static SslPolicyErrors BuildChainAndVerifyProperties(X509Chain chain, X509Certificate2 remoteCertificate, bool checkCertName, string hostName);
}
public enum System.Net.Security.EncryptionPolicy : Enum {
    public int value__;
    public static EncryptionPolicy RequireEncryption;
    public static EncryptionPolicy AllowNoEncryption;
    public static EncryptionPolicy NoEncryption;
}
public class System.Net.Security.LocalCertificateSelectionCallback : MulticastDelegate {
    public LocalCertificateSelectionCallback(object object, IntPtr method);
    public virtual X509Certificate Invoke(object sender, string targetHost, X509CertificateCollection localCertificates, X509Certificate remoteCertificate, String[] acceptableIssuers);
    public virtual IAsyncResult BeginInvoke(object sender, string targetHost, X509CertificateCollection localCertificates, X509Certificate remoteCertificate, String[] acceptableIssuers, AsyncCallback callback, object object);
    public virtual X509Certificate EndInvoke(IAsyncResult result);
}
internal class System.Net.Security.LocalCertSelectionCallback : MulticastDelegate {
    public LocalCertSelectionCallback(object object, IntPtr method);
    public virtual X509Certificate Invoke(string targetHost, X509CertificateCollection localCertificates, X509Certificate2 remoteCertificate, String[] acceptableIssuers);
    public virtual IAsyncResult BeginInvoke(string targetHost, X509CertificateCollection localCertificates, X509Certificate2 remoteCertificate, String[] acceptableIssuers, AsyncCallback callback, object object);
    public virtual X509Certificate EndInvoke(IAsyncResult result);
}
internal class System.Net.Security.NegoState : object {
    private static Byte[] s_emptyMessage;
    private static AsyncCallback s_readCallback;
    private static AsyncCallback s_writeCallback;
    private Stream _innerStream;
    private bool _leaveStreamOpen;
    private Exception _exception;
    private StreamFramer _framer;
    private NTAuthentication _context;
    private int _nestedAuth;
    internal static int ERROR_TRUST_FAILURE;
    internal static int MaxReadFrameSize;
    internal static int MaxWriteDataSize;
    private bool _canRetryAuthentication;
    private ProtectionLevel _expectedProtectionLevel;
    private TokenImpersonationLevel _expectedImpersonationLevel;
    private UInt32 _writeSequenceNumber;
    private UInt32 _readSequenceNumber;
    private ExtendedProtectionPolicy _extendedProtectionPolicy;
    private bool _remoteOk;
    internal static string DefaultPackage { get; }
    internal bool IsAuthenticated { get; }
    internal bool IsMutuallyAuthenticated { get; }
    internal bool IsEncrypted { get; }
    internal bool IsSigned { get; }
    internal bool IsServer { get; }
    internal bool CanGetSecureStream { get; }
    internal TokenImpersonationLevel AllowedImpersonation { get; }
    private TokenImpersonationLevel PrivateImpersonationLevel { get; }
    private bool HandshakeComplete { get; }
    internal NegoState(Stream innerStream, bool leaveStreamOpen);
    private static NegoState();
    internal static string get_DefaultPackage();
    internal IIdentity GetIdentity();
    internal void ValidateCreateContext(string package, NetworkCredential credential, string servicePrincipalName, ExtendedProtectionPolicy policy, ProtectionLevel protectionLevel, TokenImpersonationLevel impersonationLevel);
    internal void ValidateCreateContext(string package, bool isServer, NetworkCredential credential, string servicePrincipalName, ChannelBinding channelBinding, ProtectionLevel protectionLevel, TokenImpersonationLevel impersonationLevel);
    private Exception SetException(Exception e);
    internal bool get_IsAuthenticated();
    internal bool get_IsMutuallyAuthenticated();
    internal bool get_IsEncrypted();
    internal bool get_IsSigned();
    internal bool get_IsServer();
    internal bool get_CanGetSecureStream();
    internal TokenImpersonationLevel get_AllowedImpersonation();
    private TokenImpersonationLevel get_PrivateImpersonationLevel();
    private bool get_HandshakeComplete();
    internal void CheckThrow(bool authSucessCheck);
    internal void Close();
    internal void ProcessAuthentication(LazyAsyncResult lazyResult);
    internal void EndProcessAuthentication(IAsyncResult result);
    private bool CheckSpn();
    private void StartSendBlob(Byte[] message, LazyAsyncResult lazyResult);
    private void CheckCompletionBeforeNextReceive(LazyAsyncResult lazyResult);
    private void StartReceiveBlob(LazyAsyncResult lazyResult);
    private void ProcessReceivedBlob(Byte[] message, LazyAsyncResult lazyResult);
    private void CheckCompletionBeforeNextSend(Byte[] message, LazyAsyncResult lazyResult);
    private void StartSendAuthResetSignal(LazyAsyncResult lazyResult, Byte[] message, Exception exception);
    private static void WriteCallback(IAsyncResult transportResult);
    private static void ReadCallback(IAsyncResult transportResult);
    internal static bool IsError(SecurityStatusPal status);
    private Byte[] GetOutgoingBlob(Byte[] incomingBlob, Exception& e);
    internal int EncryptData(Byte[] buffer, int offset, int count, Byte[]& outBuffer);
    internal int DecryptData(Byte[] buffer, int offset, int count, Int32& newOffset);
    internal static void ThrowCredentialException(long error);
    internal static bool IsLogonDeniedException(Exception exception);
}
public class System.Net.Security.NegotiateStream : AuthenticatedStream {
    private NegoState _negoState;
    private string _package;
    private IIdentity _remoteIdentity;
    private static AsyncCallback s_writeCallback;
    private static AsyncProtocolCallback s_readCallback;
    private int _NestedWrite;
    private int _NestedRead;
    private Byte[] _ReadHeader;
    private Byte[] _InternalBuffer;
    private int _InternalOffset;
    private int _InternalBufferCount;
    private FixedSizeReader _FrameReader;
    public bool IsAuthenticated { get; }
    public bool IsMutuallyAuthenticated { get; }
    public bool IsEncrypted { get; }
    public bool IsSigned { get; }
    public bool IsServer { get; }
    public TokenImpersonationLevel ImpersonationLevel { get; }
    public IIdentity RemoteIdentity { get; }
    public bool CanSeek { get; }
    public bool CanRead { get; }
    public bool CanTimeout { get; }
    public bool CanWrite { get; }
    public int ReadTimeout { get; public set; }
    public int WriteTimeout { get; public set; }
    public long Length { get; }
    public long Position { get; public set; }
    private Byte[] InternalBuffer { get; }
    private int InternalOffset { get; }
    private int InternalBufferCount { get; }
    public NegotiateStream(Stream innerStream);
    public NegotiateStream(Stream innerStream, bool leaveInnerStreamOpen);
    private static NegotiateStream();
    private IAsyncResult BeginAuthenticateAsClient(AsyncCallback asyncCallback, object asyncState);
    private IAsyncResult BeginAuthenticateAsClient(NetworkCredential credential, string targetName, AsyncCallback asyncCallback, object asyncState);
    private IAsyncResult BeginAuthenticateAsClient(NetworkCredential credential, ChannelBinding binding, string targetName, AsyncCallback asyncCallback, object asyncState);
    private IAsyncResult BeginAuthenticateAsClient(NetworkCredential credential, string targetName, ProtectionLevel requiredProtectionLevel, TokenImpersonationLevel allowedImpersonationLevel, AsyncCallback asyncCallback, object asyncState);
    private IAsyncResult BeginAuthenticateAsClient(NetworkCredential credential, ChannelBinding binding, string targetName, ProtectionLevel requiredProtectionLevel, TokenImpersonationLevel allowedImpersonationLevel, AsyncCallback asyncCallback, object asyncState);
    private void EndAuthenticateAsClient(IAsyncResult asyncResult);
    private IAsyncResult BeginAuthenticateAsServer(AsyncCallback asyncCallback, object asyncState);
    private IAsyncResult BeginAuthenticateAsServer(ExtendedProtectionPolicy policy, AsyncCallback asyncCallback, object asyncState);
    private IAsyncResult BeginAuthenticateAsServer(NetworkCredential credential, ProtectionLevel requiredProtectionLevel, TokenImpersonationLevel requiredImpersonationLevel, AsyncCallback asyncCallback, object asyncState);
    private IAsyncResult BeginAuthenticateAsServer(NetworkCredential credential, ExtendedProtectionPolicy policy, ProtectionLevel requiredProtectionLevel, TokenImpersonationLevel requiredImpersonationLevel, AsyncCallback asyncCallback, object asyncState);
    private void EndAuthenticateAsServer(IAsyncResult asyncResult);
    public virtual Task AuthenticateAsClientAsync();
    public virtual Task AuthenticateAsClientAsync(NetworkCredential credential, string targetName);
    public virtual Task AuthenticateAsClientAsync(NetworkCredential credential, string targetName, ProtectionLevel requiredProtectionLevel, TokenImpersonationLevel allowedImpersonationLevel);
    public virtual Task AuthenticateAsClientAsync(NetworkCredential credential, ChannelBinding binding, string targetName);
    public virtual Task AuthenticateAsClientAsync(NetworkCredential credential, ChannelBinding binding, string targetName, ProtectionLevel requiredProtectionLevel, TokenImpersonationLevel allowedImpersonationLevel);
    public virtual Task AuthenticateAsServerAsync();
    public virtual Task AuthenticateAsServerAsync(ExtendedProtectionPolicy policy);
    public virtual Task AuthenticateAsServerAsync(NetworkCredential credential, ProtectionLevel requiredProtectionLevel, TokenImpersonationLevel requiredImpersonationLevel);
    public virtual Task AuthenticateAsServerAsync(NetworkCredential credential, ExtendedProtectionPolicy policy, ProtectionLevel requiredProtectionLevel, TokenImpersonationLevel requiredImpersonationLevel);
    public virtual bool get_IsAuthenticated();
    public virtual bool get_IsMutuallyAuthenticated();
    public virtual bool get_IsEncrypted();
    public virtual bool get_IsSigned();
    public virtual bool get_IsServer();
    public virtual TokenImpersonationLevel get_ImpersonationLevel();
    public virtual IIdentity get_RemoteIdentity();
    public virtual bool get_CanSeek();
    public virtual bool get_CanRead();
    public virtual bool get_CanTimeout();
    public virtual bool get_CanWrite();
    public virtual int get_ReadTimeout();
    public virtual void set_ReadTimeout(int value);
    public virtual int get_WriteTimeout();
    public virtual void set_WriteTimeout(int value);
    public virtual long get_Length();
    public virtual long get_Position();
    public virtual void set_Position(long value);
    public virtual void SetLength(long value);
    public virtual long Seek(long offset, SeekOrigin origin);
    public virtual void Flush();
    protected virtual void Dispose(bool disposing);
    public virtual int Read(Byte[] buffer, int offset, int count);
    public virtual void Write(Byte[] buffer, int offset, int count);
    private IAsyncResult BeginRead(Byte[] buffer, int offset, int count, AsyncCallback asyncCallback, object asyncState);
    private int EndRead(IAsyncResult asyncResult);
    private IAsyncResult BeginWrite(Byte[] buffer, int offset, int count, AsyncCallback asyncCallback, object asyncState);
    private void EndWrite(IAsyncResult asyncResult);
    public virtual Task`1<int> ReadAsync(Byte[] buffer, int offset, int size, CancellationToken cancellationToken);
    public virtual Task WriteAsync(Byte[] buffer, int offset, int size, CancellationToken cancellationToken);
    private void InitializeStreamPart();
    private Byte[] get_InternalBuffer();
    private int get_InternalOffset();
    private int get_InternalBufferCount();
    private void DecrementInternalBufferCount(int decrCount);
    private void EnsureInternalBufferSize(int bytes);
    private void AdjustInternalBufferOffsetSize(int bytes, int offset);
    private void ValidateParameters(Byte[] buffer, int offset, int count);
    private void ProcessWrite(Byte[] buffer, int offset, int count, AsyncProtocolRequest asyncRequest);
    private void StartWriting(Byte[] buffer, int offset, int count, AsyncProtocolRequest asyncRequest);
    private int ProcessRead(Byte[] buffer, int offset, int count, AsyncProtocolRequest asyncRequest);
    private int StartReading(Byte[] buffer, int offset, int count, AsyncProtocolRequest asyncRequest);
    private int StartFrameHeader(Byte[] buffer, int offset, int count, AsyncProtocolRequest asyncRequest);
    private int StartFrameBody(int readBytes, Byte[] buffer, int offset, int count, AsyncProtocolRequest asyncRequest);
    private int ProcessFrameBody(int readBytes, Byte[] buffer, int offset, int count, AsyncProtocolRequest asyncRequest);
    private static void WriteCallback(IAsyncResult transportResult);
    private static void ReadCallback(AsyncProtocolRequest asyncRequest);
}
internal static class System.Net.Security.NegotiateStreamPal : object {
    private static int NTE_FAIL;
    internal static IIdentity GetIdentity(NTAuthentication context);
    private static bool GssInitSecurityContext(SafeGssContextHandle& context, SafeGssCredHandle credential, bool isNtlm, SafeGssNameHandle targetName, GssFlags inFlags, Byte[] buffer, Byte[]& outputBuffer, UInt32& outFlags, Int32& isNtlmUsed);
    private static Byte[] GssWrap(SafeGssContextHandle context, bool encrypt, Byte[] buffer, int offset, int count);
    private static int GssUnwrap(SafeGssContextHandle context, Byte[] buffer, int offset, int count);
    internal static string QueryContextAssociatedName(SafeDeleteContext securityContext);
    internal static string QueryContextAuthenticationPackage(SafeDeleteContext securityContext);
    internal static int QueryMaxTokenSize(string package);
    internal static string QueryContextClientSpecifiedSpn(SafeDeleteContext securityContext);
    internal static SafeFreeCredentials AcquireDefaultCredential(string package, bool isServer);
    internal static SafeFreeCredentials AcquireCredentialsHandle(string package, bool isServer, NetworkCredential credential);
    internal static SecurityStatusPal InitializeSecurityContext(SafeFreeCredentials credentialsHandle, SafeDeleteContext& securityContext, string spn, ContextFlagsPal requestedContextFlags, SecurityBuffer[] inSecurityBufferArray, SecurityBuffer outSecurityBuffer, ContextFlagsPal& contextFlags);
    internal static SecurityStatusPal CompleteAuthToken(SafeDeleteContext& securityContext, SecurityBuffer[] inSecurityBufferArray);
    internal static SecurityStatusPal AcceptSecurityContext(SafeFreeCredentials credentialsHandle, SafeDeleteContext& securityContext, ContextFlagsPal requestedContextFlags, SecurityBuffer[] inSecurityBufferArray, SecurityBuffer outSecurityBuffer, ContextFlagsPal& contextFlags);
    internal static void ValidateImpersonationLevel(TokenImpersonationLevel impersonationLevel);
    internal static Win32Exception CreateExceptionFromError(SecurityStatusPal statusCode);
    internal static int Encrypt(SafeDeleteContext securityContext, Byte[] buffer, int offset, int count, bool isConfidential, bool isNtlm, Byte[]& output, UInt32 sequenceNumber);
    internal static int Decrypt(SafeDeleteContext securityContext, Byte[] buffer, int offset, int count, bool isConfidential, bool isNtlm, Int32& newOffset, UInt32 sequenceNumber);
    private static SecurityStatusPal EstablishSecurityContext(SafeFreeNegoCredentials credential, SafeDeleteContext& context, string targetName, ContextFlagsPal inFlags, SecurityBuffer inputBuffer, SecurityBuffer outputBuffer, ContextFlagsPal& outFlags);
}
public enum System.Net.Security.ProtectionLevel : Enum {
    public int value__;
    public static ProtectionLevel None;
    public static ProtectionLevel Sign;
    public static ProtectionLevel EncryptAndSign;
}
internal class System.Net.Security.ProtocolToken : object {
    internal SecurityStatusPal Status;
    internal Byte[] Payload;
    internal int Size;
    internal bool Failed { get; }
    internal bool Done { get; }
    internal bool Renegotiate { get; }
    internal bool CloseConnection { get; }
    internal ProtocolToken(Byte[] data, SecurityStatusPal status);
    internal bool get_Failed();
    internal bool get_Done();
    internal bool get_Renegotiate();
    internal bool get_CloseConnection();
    internal Exception GetException();
}
public class System.Net.Security.RemoteCertificateValidationCallback : MulticastDelegate {
    public RemoteCertificateValidationCallback(object object, IntPtr method);
    public virtual bool Invoke(object sender, X509Certificate certificate, X509Chain chain, SslPolicyErrors sslPolicyErrors);
    public virtual IAsyncResult BeginInvoke(object sender, X509Certificate certificate, X509Chain chain, SslPolicyErrors sslPolicyErrors, AsyncCallback callback, object object);
    public virtual bool EndInvoke(IAsyncResult result);
}
internal class System.Net.Security.RemoteCertValidationCallback : MulticastDelegate {
    public RemoteCertValidationCallback(object object, IntPtr method);
    public virtual bool Invoke(string host, X509Certificate2 certificate, X509Chain chain, SslPolicyErrors sslPolicyErrors);
    public virtual IAsyncResult BeginInvoke(string host, X509Certificate2 certificate, X509Chain chain, SslPolicyErrors sslPolicyErrors, AsyncCallback callback, object object);
    public virtual bool EndInvoke(IAsyncResult result);
}
internal class System.Net.Security.SafeCredentialReference : CriticalHandleMinusOneIsInvalid {
    internal SafeFreeCredentials Target;
    private SafeCredentialReference(SafeFreeCredentials target);
    internal static SafeCredentialReference CreateReference(SafeFreeCredentials target);
    protected virtual bool ReleaseHandle();
}
internal abstract class System.Net.Security.SafeDeleteContext : SafeHandle {
    private SafeFreeCredentials _credential;
    public bool IsInvalid { get; }
    protected SafeDeleteContext(SafeFreeCredentials credential);
    public virtual bool get_IsInvalid();
    protected virtual bool ReleaseHandle();
}
internal class System.Net.Security.SafeDeleteNegoContext : SafeDeleteContext {
    private SafeGssNameHandle _targetName;
    private SafeGssContextHandle _context;
    private bool _isNtlmUsed;
    public SafeGssNameHandle TargetName { get; }
    public bool IsNtlmUsed { get; }
    public SafeGssContextHandle GssContext { get; }
    public SafeDeleteNegoContext(SafeFreeNegoCredentials credential, string targetName);
    public SafeGssNameHandle get_TargetName();
    public bool get_IsNtlmUsed();
    public SafeGssContextHandle get_GssContext();
    public void SetGssContext(SafeGssContextHandle context);
    public void SetAuthenticationPackage(bool isNtlmUsed);
    protected virtual void Dispose(bool disposing);
}
internal class System.Net.Security.SafeDeleteSslContext : SafeDeleteContext {
    private SafeSslHandle _sslContext;
    public SafeSslHandle SslContext { get; }
    public bool IsInvalid { get; }
    public SafeDeleteSslContext(SafeFreeSslCredentials credential, bool isServer, bool remoteCertRequired);
    public SafeSslHandle get_SslContext();
    public virtual bool get_IsInvalid();
    protected virtual void Dispose(bool disposing);
}
internal class System.Net.Security.SafeFreeCertContext : SafeHandle {
    private SafeX509Handle _certificate;
    public bool IsInvalid { get; }
    public SafeFreeCertContext(SafeX509Handle certificate);
    public virtual bool get_IsInvalid();
    protected virtual bool ReleaseHandle();
}
internal class System.Net.Security.SafeFreeContextBufferChannelBinding : ChannelBinding {
    private SafeChannelBindingHandle _channelBinding;
    public int Size { get; }
    public bool IsInvalid { get; }
    public SafeFreeContextBufferChannelBinding(SafeChannelBindingHandle binding);
    public virtual int get_Size();
    public virtual bool get_IsInvalid();
    protected virtual bool ReleaseHandle();
}
internal abstract class System.Net.Security.SafeFreeCredentials : SafeHandle {
    protected SafeFreeCredentials(IntPtr handle, bool ownsHandle);
}
internal class System.Net.Security.SafeFreeNegoCredentials : SafeFreeCredentials {
    private SafeGssCredHandle _credential;
    private bool _isNtlmOnly;
    private string _userName;
    private bool _isDefault;
    public SafeGssCredHandle GssCredential { get; }
    public bool IsNtlmOnly { get; }
    public string UserName { get; }
    public bool IsDefault { get; }
    public bool IsInvalid { get; }
    public SafeFreeNegoCredentials(bool isNtlmOnly, string username, string password, string domain);
    public SafeGssCredHandle get_GssCredential();
    public bool get_IsNtlmOnly();
    public string get_UserName();
    public bool get_IsDefault();
    public virtual bool get_IsInvalid();
    protected virtual bool ReleaseHandle();
}
internal class System.Net.Security.SafeFreeSslCredentials : SafeFreeCredentials {
    private SafeX509Handle _certHandle;
    private SafeEvpPKeyHandle _certKeyHandle;
    private SslProtocols _protocols;
    private EncryptionPolicy _policy;
    internal SafeX509Handle CertHandle { get; }
    internal SafeEvpPKeyHandle CertKeyHandle { get; }
    internal SslProtocols Protocols { get; }
    internal EncryptionPolicy Policy { get; }
    public bool IsInvalid { get; }
    public SafeFreeSslCredentials(X509Certificate certificate, SslProtocols protocols, EncryptionPolicy policy);
    internal SafeX509Handle get_CertHandle();
    internal SafeEvpPKeyHandle get_CertKeyHandle();
    internal SslProtocols get_Protocols();
    internal EncryptionPolicy get_Policy();
    public virtual bool get_IsInvalid();
    protected virtual bool ReleaseHandle();
}
internal class System.Net.Security.SecureChannel : object {
    internal static int ReadHeaderSize;
    private SafeFreeCredentials _credentialsHandle;
    private SafeDeleteContext _securityContext;
    private string _destination;
    private string _hostName;
    private bool _serverMode;
    private bool _remoteCertRequired;
    private SslProtocols _sslProtocols;
    private EncryptionPolicy _encryptionPolicy;
    private SslConnectionInfo _connectionInfo;
    private X509Certificate _serverCertificate;
    private X509Certificate _selectedClientCertificate;
    private bool _isRemoteCertificateAvailable;
    private X509CertificateCollection _clientCertificates;
    private LocalCertSelectionCallback _certSelectionDelegate;
    private int _headerSize;
    private int _trailerSize;
    private int _maxDataSize;
    private bool _checkCertRevocation;
    private bool _checkCertName;
    private bool _refreshCredentialNeeded;
    private Oid _serverAuthOid;
    private Oid _clientAuthOid;
    internal X509Certificate LocalServerCertificate { get; }
    internal X509Certificate LocalClientCertificate { get; }
    internal bool IsRemoteCertificateAvailable { get; }
    internal bool CheckCertRevocationStatus { get; }
    internal X509CertificateCollection ClientCertificates { get; }
    internal int HeaderSize { get; }
    internal int MaxDataSize { get; }
    internal SslConnectionInfo ConnectionInfo { get; }
    internal bool IsValidContext { get; }
    internal bool IsServer { get; }
    internal bool RemoteCertRequired { get; }
    internal SecureChannel(string hostname, bool serverMode, SslProtocols sslProtocols, X509Certificate serverCertificate, X509CertificateCollection clientCertificates, bool remoteCertRequired, bool checkCertName, bool checkCertRevocationStatus, EncryptionPolicy encryptionPolicy, LocalCertSelectionCallback certSelectionDelegate);
    internal X509Certificate get_LocalServerCertificate();
    internal X509Certificate get_LocalClientCertificate();
    internal bool get_IsRemoteCertificateAvailable();
    internal ChannelBinding GetChannelBinding(ChannelBindingKind kind);
    internal bool get_CheckCertRevocationStatus();
    internal X509CertificateCollection get_ClientCertificates();
    internal int get_HeaderSize();
    internal int get_MaxDataSize();
    internal SslConnectionInfo get_ConnectionInfo();
    internal bool get_IsValidContext();
    internal bool get_IsServer();
    internal bool get_RemoteCertRequired();
    internal void SetRefreshCredentialNeeded();
    internal void Close();
    private X509Certificate2 EnsurePrivateKey(X509Certificate certificate);
    private static X509Certificate2 MakeEx(X509Certificate certificate);
    private String[] GetRequestCertificateAuthorities();
    private bool AcquireClientCredentials(Byte[]& thumbPrint);
    private bool AcquireServerCredentials(Byte[]& thumbPrint);
    internal ProtocolToken NextMessage(Byte[] incoming, int offset, int count);
    private SecurityStatusPal GenerateToken(Byte[] input, int offset, int count, Byte[]& output);
    internal void ProcessHandshakeSuccess();
    internal SecurityStatusPal Encrypt(Byte[] buffer, int offset, int size, Byte[]& output, Int32& resultSize);
    internal SecurityStatusPal Decrypt(Byte[] payload, Int32& offset, Int32& count);
    internal bool VerifyRemoteCertificate(RemoteCertValidationCallback remoteCertValidationCallback);
}
internal class System.Net.Security.SecurityBuffer : object {
    public int size;
    public SecurityBufferType type;
    public Byte[] token;
    public SafeHandle unmanagedToken;
    public int offset;
    public SecurityBuffer(Byte[] data, int offset, int size, SecurityBufferType tokentype);
    public SecurityBuffer(Byte[] data, SecurityBufferType tokentype);
    public SecurityBuffer(int size, SecurityBufferType tokentype);
    public SecurityBuffer(ChannelBinding binding);
}
internal enum System.Net.Security.SecurityBufferType : Enum {
    public int value__;
    public static SecurityBufferType Empty;
    public static SecurityBufferType Data;
    public static SecurityBufferType Token;
    public static SecurityBufferType Parameters;
    public static SecurityBufferType Missing;
    public static SecurityBufferType Extra;
    public static SecurityBufferType Trailer;
    public static SecurityBufferType Header;
    public static SecurityBufferType Padding;
    public static SecurityBufferType Stream;
    public static SecurityBufferType ChannelBindings;
    public static SecurityBufferType TargetHost;
    public static SecurityBufferType ReadOnlyFlag;
    public static SecurityBufferType ReadOnlyWithChecksum;
}
internal static class System.Net.Security.SslSessionsCache : object {
    private static int CheckExpiredModulo;
    private static ConcurrentDictionary`2<SslCredKey, SafeCredentialReference> s_cachedCreds;
    private static SslSessionsCache();
    internal static SafeFreeCredentials TryCachedCredential(Byte[] thumbPrint, SslProtocols sslProtocols, bool isServer, EncryptionPolicy encryptionPolicy);
    internal static void CacheCredential(SafeFreeCredentials creds, Byte[] thumbPrint, SslProtocols sslProtocols, bool isServer, EncryptionPolicy encryptionPolicy);
}
internal class System.Net.Security.SslState : object {
    private static int s_uniqueNameInteger;
    private static AsyncProtocolCallback s_partialFrameCallback;
    private static AsyncProtocolCallback s_readFrameCallback;
    private static AsyncCallback s_writeCallback;
    private RemoteCertValidationCallback _certValidationDelegate;
    private LocalCertSelectionCallback _certSelectionDelegate;
    private Stream _innerStream;
    private SslStreamInternal _secureStream;
    private FixedSizeReader _reader;
    private int _nestedAuth;
    private SecureChannel _context;
    private bool _handshakeCompleted;
    private bool _certValidationFailed;
    private SecurityStatusPal _securityStatus;
    private ExceptionDispatchInfo _exception;
    private CachedSessionStatus _CachedSession;
    private Byte[] _queuedReadData;
    private int _queuedReadCount;
    private bool _pendingReHandshake;
    private static int MaxQueuedReadBytes;
    private static int LockNone;
    private static int LockWrite;
    private static int LockHandshake;
    private static int LockPendingWrite;
    private static int LockRead;
    private static int LockPendingRead;
    private int _lockWriteState;
    private object _queuedWriteStateRequest;
    private int _lockReadState;
    private object _queuedReadStateRequest;
    private EncryptionPolicy _encryptionPolicy;
    private Framing _Framing;
    internal bool IsAuthenticated { get; }
    internal bool IsMutuallyAuthenticated { get; }
    internal bool RemoteCertRequired { get; }
    internal bool IsServer { get; }
    internal X509Certificate LocalCertificate { get; }
    private X509Certificate InternalLocalCertificate { get; }
    internal bool CheckCertRevocationStatus { get; }
    internal SecurityStatusPal LastSecurityStatus { get; }
    internal bool IsCertValidationFailed { get; }
    internal bool DataAvailable { get; }
    internal CipherAlgorithmType CipherAlgorithm { get; }
    internal int CipherStrength { get; }
    internal HashAlgorithmType HashAlgorithm { get; }
    internal int HashStrength { get; }
    internal ExchangeAlgorithmType KeyExchangeAlgorithm { get; }
    internal int KeyExchangeStrength { get; }
    internal SslProtocols SslProtocol { get; }
    internal Stream InnerStream { get; }
    internal SslStreamInternal SecureStream { get; }
    internal int HeaderSize { get; }
    internal int MaxDataSize { get; }
    private bool HandshakeCompleted { get; }
    private SecureChannel Context { get; }
    internal SslState(Stream innerStream, RemoteCertValidationCallback certValidationCallback, LocalCertSelectionCallback certSelectionCallback, EncryptionPolicy encryptionPolicy);
    private static SslState();
    internal void ValidateCreateContext(bool isServer, string targetHost, SslProtocols enabledSslProtocols, X509Certificate serverCertificate, X509CertificateCollection clientCertificates, bool remoteCertRequired, bool checkCertRevocationStatus);
    internal void ValidateCreateContext(bool isServer, string targetHost, SslProtocols enabledSslProtocols, X509Certificate serverCertificate, X509CertificateCollection clientCertificates, bool remoteCertRequired, bool checkCertRevocationStatus, bool checkCertName);
    internal bool get_IsAuthenticated();
    internal bool get_IsMutuallyAuthenticated();
    internal bool get_RemoteCertRequired();
    internal bool get_IsServer();
    internal void SetCertValidationDelegate(RemoteCertValidationCallback certValidationCallback);
    internal X509Certificate get_LocalCertificate();
    private X509Certificate get_InternalLocalCertificate();
    internal ChannelBinding GetChannelBinding(ChannelBindingKind kind);
    internal bool get_CheckCertRevocationStatus();
    internal SecurityStatusPal get_LastSecurityStatus();
    internal bool get_IsCertValidationFailed();
    internal bool get_DataAvailable();
    internal CipherAlgorithmType get_CipherAlgorithm();
    internal int get_CipherStrength();
    internal HashAlgorithmType get_HashAlgorithm();
    internal int get_HashStrength();
    internal ExchangeAlgorithmType get_KeyExchangeAlgorithm();
    internal int get_KeyExchangeStrength();
    internal SslProtocols get_SslProtocol();
    internal Stream get_InnerStream();
    internal SslStreamInternal get_SecureStream();
    internal int get_HeaderSize();
    internal int get_MaxDataSize();
    private ExceptionDispatchInfo SetException(Exception e);
    private bool get_HandshakeCompleted();
    private SecureChannel get_Context();
    internal void CheckThrow(bool authSucessCheck);
    internal void Flush();
    internal void Close();
    internal SecurityStatusPal EncryptData(Byte[] buffer, int offset, int count, Byte[]& outBuffer, Int32& outSize);
    internal SecurityStatusPal DecryptData(Byte[] buffer, Int32& offset, Int32& count);
    private SecurityStatusPal PrivateDecryptData(Byte[] buffer, Int32& offset, Int32& count);
    private Exception EnqueueOldKeyDecryptedData(Byte[] buffer, int offset, int count);
    internal int CheckOldKeyDecryptedData(Byte[] buffer, int offset, int count);
    internal void ProcessAuthentication(LazyAsyncResult lazyResult);
    internal void ReplyOnReAuthentication(Byte[] buffer);
    private void ForceAuthentication(bool receiveFirst, Byte[] buffer, AsyncProtocolRequest asyncRequest);
    internal void EndProcessAuthentication(IAsyncResult result);
    internal void InternalEndProcessAuthentication(LazyAsyncResult lazyResult);
    private void StartSendBlob(Byte[] incoming, int count, AsyncProtocolRequest asyncRequest);
    private void CheckCompletionBeforeNextReceive(ProtocolToken message, AsyncProtocolRequest asyncRequest);
    private void StartReceiveBlob(Byte[] buffer, AsyncProtocolRequest asyncRequest);
    private void StartReadFrame(Byte[] buffer, int readBytes, AsyncProtocolRequest asyncRequest);
    private void ProcessReceivedBlob(Byte[] buffer, int count, AsyncProtocolRequest asyncRequest);
    private void StartSendAuthResetSignal(ProtocolToken message, AsyncProtocolRequest asyncRequest, ExceptionDispatchInfo exception);
    private bool CompleteHandshake();
    private static void WriteCallback(IAsyncResult transportResult);
    private static void PartialFrameCallback(AsyncProtocolRequest asyncRequest);
    private static void ReadFrameCallback(AsyncProtocolRequest asyncRequest);
    private bool CheckEnqueueHandshakeRead(Byte[]& buffer, AsyncProtocolRequest request);
    private void FinishHandshakeRead(int newState);
    internal int CheckEnqueueRead(Byte[] buffer, int offset, int count, AsyncProtocolRequest request);
    internal void FinishRead(Byte[] renegotiateBuffer);
    internal bool CheckEnqueueWrite(AsyncProtocolRequest asyncRequest);
    internal void FinishWrite();
    private bool CheckEnqueueHandshake(Byte[] buffer, AsyncProtocolRequest asyncRequest);
    private void FinishHandshake(Exception e, AsyncProtocolRequest asyncRequest);
    private static Byte[] EnsureBufferSize(Byte[] buffer, int copyCount, int size);
    private Framing DetectFraming(Byte[] bytes, int length);
    internal int GetRemainingFrameSize(Byte[] buffer, int dataSize);
    private void AsyncResumeHandshake(object state);
    private void AsyncResumeHandshakeRead(object state);
    private void CompleteRequestWaitCallback(object state);
    private void RehandshakeCompleteCallback(IAsyncResult result);
}
public class System.Net.Security.SslStream : AuthenticatedStream {
    private SslState _sslState;
    private RemoteCertificateValidationCallback _userCertificateValidationCallback;
    private LocalCertificateSelectionCallback _userCertificateSelectionCallback;
    private object _remoteCertificateOrBytes;
    public TransportContext TransportContext { get; }
    public bool IsAuthenticated { get; }
    public bool IsMutuallyAuthenticated { get; }
    public bool IsEncrypted { get; }
    public bool IsSigned { get; }
    public bool IsServer { get; }
    public SslProtocols SslProtocol { get; }
    public bool CheckCertRevocationStatus { get; }
    public X509Certificate LocalCertificate { get; }
    public X509Certificate RemoteCertificate { get; }
    public CipherAlgorithmType CipherAlgorithm { get; }
    public int CipherStrength { get; }
    public HashAlgorithmType HashAlgorithm { get; }
    public int HashStrength { get; }
    public ExchangeAlgorithmType KeyExchangeAlgorithm { get; }
    public int KeyExchangeStrength { get; }
    public bool CanSeek { get; }
    public bool CanRead { get; }
    public bool CanTimeout { get; }
    public bool CanWrite { get; }
    public int ReadTimeout { get; public set; }
    public int WriteTimeout { get; public set; }
    public long Length { get; }
    public long Position { get; public set; }
    public SslStream(Stream innerStream);
    public SslStream(Stream innerStream, bool leaveInnerStreamOpen);
    public SslStream(Stream innerStream, bool leaveInnerStreamOpen, RemoteCertificateValidationCallback userCertificateValidationCallback);
    public SslStream(Stream innerStream, bool leaveInnerStreamOpen, RemoteCertificateValidationCallback userCertificateValidationCallback, LocalCertificateSelectionCallback userCertificateSelectionCallback);
    public SslStream(Stream innerStream, bool leaveInnerStreamOpen, RemoteCertificateValidationCallback userCertificateValidationCallback, LocalCertificateSelectionCallback userCertificateSelectionCallback, EncryptionPolicy encryptionPolicy);
    private bool UserCertValidationCallbackWrapper(string hostName, X509Certificate2 certificate, X509Chain chain, SslPolicyErrors sslPolicyErrors);
    private X509Certificate UserCertSelectionCallbackWrapper(string targetHost, X509CertificateCollection localCertificates, X509Certificate remoteCertificate, String[] acceptableIssuers);
    internal virtual IAsyncResult BeginAuthenticateAsClient(string targetHost, AsyncCallback asyncCallback, object asyncState);
    internal virtual IAsyncResult BeginAuthenticateAsClient(string targetHost, X509CertificateCollection clientCertificates, SslProtocols enabledSslProtocols, bool checkCertificateRevocation, AsyncCallback asyncCallback, object asyncState);
    internal virtual void EndAuthenticateAsClient(IAsyncResult asyncResult);
    internal virtual IAsyncResult BeginAuthenticateAsServer(X509Certificate serverCertificate, AsyncCallback asyncCallback, object asyncState);
    internal virtual IAsyncResult BeginAuthenticateAsServer(X509Certificate serverCertificate, bool clientCertificateRequired, SslProtocols enabledSslProtocols, bool checkCertificateRevocation, AsyncCallback asyncCallback, object asyncState);
    internal virtual void EndAuthenticateAsServer(IAsyncResult asyncResult);
    public TransportContext get_TransportContext();
    internal ChannelBinding GetChannelBinding(ChannelBindingKind kind);
    public virtual Task AuthenticateAsClientAsync(string targetHost);
    public virtual Task AuthenticateAsClientAsync(string targetHost, X509CertificateCollection clientCertificates, SslProtocols enabledSslProtocols, bool checkCertificateRevocation);
    public virtual Task AuthenticateAsServerAsync(X509Certificate serverCertificate);
    public virtual Task AuthenticateAsServerAsync(X509Certificate serverCertificate, bool clientCertificateRequired, SslProtocols enabledSslProtocols, bool checkCertificateRevocation);
    public virtual bool get_IsAuthenticated();
    public virtual bool get_IsMutuallyAuthenticated();
    public virtual bool get_IsEncrypted();
    public virtual bool get_IsSigned();
    public virtual bool get_IsServer();
    public virtual SslProtocols get_SslProtocol();
    public virtual bool get_CheckCertRevocationStatus();
    public virtual X509Certificate get_LocalCertificate();
    public virtual X509Certificate get_RemoteCertificate();
    public virtual CipherAlgorithmType get_CipherAlgorithm();
    public virtual int get_CipherStrength();
    public virtual HashAlgorithmType get_HashAlgorithm();
    public virtual int get_HashStrength();
    public virtual ExchangeAlgorithmType get_KeyExchangeAlgorithm();
    public virtual int get_KeyExchangeStrength();
    public virtual bool get_CanSeek();
    public virtual bool get_CanRead();
    public virtual bool get_CanTimeout();
    public virtual bool get_CanWrite();
    public virtual int get_ReadTimeout();
    public virtual void set_ReadTimeout(int value);
    public virtual int get_WriteTimeout();
    public virtual void set_WriteTimeout(int value);
    public virtual long get_Length();
    public virtual long get_Position();
    public virtual void set_Position(long value);
    public virtual void SetLength(long value);
    public virtual long Seek(long offset, SeekOrigin origin);
    public virtual void Flush();
    protected virtual void Dispose(bool disposing);
    public virtual int ReadByte();
    public virtual int Read(Byte[] buffer, int offset, int count);
    public void Write(Byte[] buffer);
    public virtual void Write(Byte[] buffer, int offset, int count);
    private IAsyncResult BeginRead(Byte[] buffer, int offset, int count, AsyncCallback asyncCallback, object asyncState);
    private int EndRead(IAsyncResult asyncResult);
    private IAsyncResult BeginWrite(Byte[] buffer, int offset, int count, AsyncCallback asyncCallback, object asyncState);
    private void EndWrite(IAsyncResult asyncResult);
    public virtual Task`1<int> ReadAsync(Byte[] buffer, int offset, int size, CancellationToken cancellationToken);
    public virtual Task WriteAsync(Byte[] buffer, int offset, int size, CancellationToken cancellationToken);
}
internal class System.Net.Security.SslStreamInternal : object {
    private static AsyncCallback s_writeCallback;
    private static AsyncProtocolCallback s_resumeAsyncWriteCallback;
    private static AsyncProtocolCallback s_resumeAsyncReadCallback;
    private static AsyncProtocolCallback s_readHeaderCallback;
    private static AsyncProtocolCallback s_readFrameCallback;
    private static int PinnableReadBufferSize;
    private static PinnableBufferCache s_PinnableReadBufferCache;
    private static int PinnableWriteBufferSize;
    private static PinnableBufferCache s_PinnableWriteBufferCache;
    private SslState _sslState;
    private int _nestedWrite;
    private int _nestedRead;
    private Byte[] _internalBuffer;
    private bool _internalBufferFromPinnableCache;
    private Byte[] _pinnableOutputBuffer;
    private Byte[] _pinnableOutputBufferInUse;
    private int _internalOffset;
    private int _internalBufferCount;
    private FixedSizeReader _reader;
    internal bool DataAvailable { get; }
    private Byte[] InternalBuffer { get; }
    private int InternalOffset { get; }
    private int InternalBufferCount { get; }
    internal SslStreamInternal(SslState sslState);
    private static SslStreamInternal();
    private void FreeReadBuffer();
    protected virtual override void Finalize();
    internal int ReadByte();
    internal int Read(Byte[] buffer, int offset, int count);
    internal void Write(Byte[] buffer, int offset, int count);
    internal IAsyncResult BeginRead(Byte[] buffer, int offset, int count, AsyncCallback asyncCallback, object asyncState);
    internal int EndRead(IAsyncResult asyncResult);
    internal IAsyncResult BeginWrite(Byte[] buffer, int offset, int count, AsyncCallback asyncCallback, object asyncState);
    internal void EndWrite(IAsyncResult asyncResult);
    internal bool get_DataAvailable();
    private Byte[] get_InternalBuffer();
    private int get_InternalOffset();
    private int get_InternalBufferCount();
    private void SkipBytes(int decrCount);
    private void EnsureInternalBufferSize(int curOffset, int addSize);
    private void ValidateParameters(Byte[] buffer, int offset, int count);
    private void ProcessWrite(Byte[] buffer, int offset, int count, AsyncProtocolRequest asyncRequest);
    private void StartWriting(Byte[] buffer, int offset, int count, AsyncProtocolRequest asyncRequest);
    private int ProcessRead(Byte[] buffer, int offset, int count, AsyncProtocolRequest asyncRequest);
    private int StartReading(Byte[] buffer, int offset, int count, AsyncProtocolRequest asyncRequest);
    private int StartFrameHeader(Byte[] buffer, int offset, int count, AsyncProtocolRequest asyncRequest);
    private int StartFrameBody(int readBytes, Byte[] buffer, int offset, int count, AsyncProtocolRequest asyncRequest);
    private int ProcessFrameBody(int readBytes, Byte[] buffer, int offset, int count, AsyncProtocolRequest asyncRequest);
    private int ProcessReadErrorCode(SecurityStatusPal status, Byte[] buffer, int offset, int count, AsyncProtocolRequest asyncRequest, Byte[] extraBuffer);
    private static void WriteCallback(IAsyncResult transportResult);
    private static void ResumeAsyncReadCallback(AsyncProtocolRequest request);
    private static void ResumeAsyncWriteCallback(AsyncProtocolRequest asyncRequest);
    private static void ReadHeaderCallback(AsyncProtocolRequest asyncRequest);
    private static void ReadFrameCallback(AsyncProtocolRequest asyncRequest);
}
internal static class System.Net.Security.SSPIHandleCache : object {
    private static int c_MaxCacheSize;
    private static SafeCredentialReference[] s_cacheSlots;
    private static int s_current;
    private static SSPIHandleCache();
    internal static void CacheCredential(SafeFreeCredentials newHandle);
}
[EventSourceAttribute]
internal class System.Net.SecurityEventSource : EventSource {
    private static int EnumerateSecurityPackagesId;
    private static int SspiPackageNotFoundId;
    private static int AcquireDefaultCredentialId;
    private static int AcquireCredentialsHandleId;
    private static int SecureChannelCtorId;
    private static int LocatingPrivateKeyId;
    private static int CertIsType2Id;
    private static int FoundCertInStoreId;
    private static int NotFoundCertInStoreId;
    private static int InitializeSecurityContextId;
    private static int SecurityContextInputBufferId;
    private static int SecurityContextInputBuffersId;
    private static int AcceptSecuritContextId;
    private static int OperationReturnedSomethingId;
    private static int RemoteCertificateId;
    private static int CertificateFromDelegateId;
    private static int NoDelegateNoClientCertId;
    private static int NoDelegateButClientCertId;
    private static int AttemptingRestartUsingCertId;
    private static int NoIssuersTryAllCertsId;
    private static int LookForMatchingCertsId;
    private static int SelectedCertId;
    private static int CertsAfterFilteringId;
    private static int FindingMatchingCertsId;
    private static int UsingCachedCredentialId;
    private static int SspiSelectedCipherSuitId;
    private static int RemoteCertificateErrorId;
    private static int RemoteVertificateValidId;
    private static int RemoteCertificateSuccesId;
    private static int REmoteCertificateInvalidId;
    private static SecurityEventSource s_log;
    public static SecurityEventSource Log { get; }
    private static SecurityEventSource();
    public static SecurityEventSource get_Log();
    [EventAttribute("1")]
internal void EnumerateSecurityPackages(string securityPackage);
    [EventAttribute("2")]
internal void SspiPackageNotFound(string packageName);
    [NonEventAttribute]
internal static void SecureChannelCtor(object secureChannel, string hostname, X509CertificateCollection clientCertificates, EncryptionPolicy encryptionPolicy);
    [EventAttribute("5")]
internal void SecureChannelCtor(string hostname, int secureChannelHash, int clientCertificatesCount, EncryptionPolicy encryptionPolicy);
    [EventAttribute("6")]
internal void LocatingPrivateKey(string x509Certificate, int secureChannelHash);
    [EventAttribute("7")]
internal void CertIsType2(int secureChannelHash);
    [EventAttribute("8")]
internal void FoundCertInStore(string store, int secureChannelHash);
    [EventAttribute("9")]
internal void NotFoundCertInStore(int secureChannelHash);
    [EventAttribute("15")]
internal void RemoteCertificate(string remoteCertificate);
    [EventAttribute("16")]
internal void CertificateFromDelegate(int secureChannelHash);
    [EventAttribute("17")]
internal void NoDelegateNoClientCert(int secureChannelHash);
    [EventAttribute("18")]
internal void NoDelegateButClientCert(int secureChannelHash);
    [EventAttribute("19")]
internal void AttemptingRestartUsingCert(string clientCertificate, int secureChannelHash);
    [EventAttribute("20")]
internal void NoIssuersTryAllCerts(int secureChannelHash);
    [EventAttribute("21")]
internal void LookForMatchingCerts(int issuersCount, int secureChannelHash);
    [EventAttribute("22")]
internal void SelectedCert(string clientCertificate, int secureChannelHash);
    [EventAttribute("23")]
internal void CertsAfterFiltering(int filteredCertsCount, int secureChannelHash);
    [EventAttribute("24")]
internal void FindingMatchingCerts(int secureChannelHash);
    [EventAttribute("25")]
internal void UsingCachedCredential(int secureChannelHash);
    [EventAttribute("26")]
internal void SspiSelectedCipherSuite(string process, SslProtocols sslProtocol, CipherAlgorithmType cipherAlgorithm, int cipherStrength, HashAlgorithmType hashAlgorithm, int hashStrength, ExchangeAlgorithmType keyExchangeAlgorithm, int keyExchangeStrength);
    [EventAttribute("27")]
internal void RemoteCertificateError(int secureChannelHash, string message);
    [EventAttribute("28")]
internal void RemoteCertDeclaredValid(int secureChannelHash);
    [EventAttribute("29")]
internal void RemoteCertHasNoErrors(int secureChannelHash);
    [EventAttribute("30")]
internal void RemoteCertUserDeclaredInvalid(int secureChannelHash);
}
internal static class System.Net.SecurityProtocol : object {
    public static SslProtocols AllowedSecurityProtocols;
    public static SslProtocols DefaultSecurityProtocols;
    public static void ThrowOnNotAllowed(SslProtocols protocols, bool allowNone);
}
internal class System.Net.SecurityStatusPal : ValueType {
    public SecurityStatusPalErrorCode ErrorCode;
    public Exception Exception;
    public SecurityStatusPal(SecurityStatusPalErrorCode errorCode, Exception exception);
    public virtual string ToString();
}
internal enum System.Net.SecurityStatusPalErrorCode : Enum {
    public int value__;
    public static SecurityStatusPalErrorCode NotSet;
    public static SecurityStatusPalErrorCode OK;
    public static SecurityStatusPalErrorCode ContinueNeeded;
    public static SecurityStatusPalErrorCode CompleteNeeded;
    public static SecurityStatusPalErrorCode CompAndContinue;
    public static SecurityStatusPalErrorCode ContextExpired;
    public static SecurityStatusPalErrorCode CredentialsNeeded;
    public static SecurityStatusPalErrorCode Renegotiate;
    public static SecurityStatusPalErrorCode OutOfMemory;
    public static SecurityStatusPalErrorCode InvalidHandle;
    public static SecurityStatusPalErrorCode Unsupported;
    public static SecurityStatusPalErrorCode TargetUnknown;
    public static SecurityStatusPalErrorCode InternalError;
    public static SecurityStatusPalErrorCode PackageNotFound;
    public static SecurityStatusPalErrorCode NotOwner;
    public static SecurityStatusPalErrorCode CannotInstall;
    public static SecurityStatusPalErrorCode InvalidToken;
    public static SecurityStatusPalErrorCode CannotPack;
    public static SecurityStatusPalErrorCode QopNotSupported;
    public static SecurityStatusPalErrorCode NoImpersonation;
    public static SecurityStatusPalErrorCode LogonDenied;
    public static SecurityStatusPalErrorCode UnknownCredentials;
    public static SecurityStatusPalErrorCode NoCredentials;
    public static SecurityStatusPalErrorCode MessageAltered;
    public static SecurityStatusPalErrorCode OutOfSequence;
    public static SecurityStatusPalErrorCode NoAuthenticatingAuthority;
    public static SecurityStatusPalErrorCode IncompleteMessage;
    public static SecurityStatusPalErrorCode IncompleteCredentials;
    public static SecurityStatusPalErrorCode BufferNotEnough;
    public static SecurityStatusPalErrorCode WrongPrincipal;
    public static SecurityStatusPalErrorCode TimeSkew;
    public static SecurityStatusPalErrorCode UntrustedRoot;
    public static SecurityStatusPalErrorCode IllegalMessage;
    public static SecurityStatusPalErrorCode CertUnknown;
    public static SecurityStatusPalErrorCode CertExpired;
    public static SecurityStatusPalErrorCode AlgorithmMismatch;
    public static SecurityStatusPalErrorCode SecurityQosFailed;
    public static SecurityStatusPalErrorCode SmartcardLogonRequired;
    public static SecurityStatusPalErrorCode UnsupportedPreauth;
    public static SecurityStatusPalErrorCode BadBinding;
}
[FlagsAttribute]
internal enum System.Net.SourceLevels : Enum {
    public int value__;
    public static SourceLevels Off;
    public static SourceLevels Critical;
    public static SourceLevels Error;
    public static SourceLevels Warning;
    public static SourceLevels Information;
    public static SourceLevels Verbose;
    public static SourceLevels ActivityTracing;
    public static SourceLevels All;
}
internal class System.Net.SourceSwitch : object {
    public bool ShouldTrace(TraceEventType eventType);
}
internal class System.Net.SslConnectionInfo : object {
    public int Protocol;
    public int DataCipherAlg;
    public int DataKeySize;
    public int DataHashAlg;
    public int DataHashKeySize;
    public int KeyExchangeAlg;
    public int KeyExchKeySize;
    internal SslConnectionInfo(SafeSslHandle sslContext);
    private SslProtocols MapProtocolVersion(string protocolVersion);
}
internal class System.Net.SslStreamContext : TransportContext {
    private SslStream _sslStream;
    internal SslStreamContext(SslStream sslStream);
    public virtual ChannelBinding GetChannelBinding(ChannelBindingKind kind);
}
internal static class System.Net.SslStreamPal : object {
    private static StreamSizes s_streamSizes;
    internal static bool StartMutualAuthAsAnonymous;
    private static SslStreamPal();
    public static Exception GetException(SecurityStatusPal status);
    public static void VerifyPackageInfo();
    public static SecurityStatusPal AcceptSecurityContext(SafeFreeCredentials& credential, SafeDeleteContext& context, SecurityBuffer inputBuffer, SecurityBuffer outputBuffer, bool remoteCertRequired);
    public static SecurityStatusPal InitializeSecurityContext(SafeFreeCredentials& credential, SafeDeleteContext& context, string targetName, SecurityBuffer inputBuffer, SecurityBuffer outputBuffer);
    public static SecurityStatusPal InitializeSecurityContext(SafeFreeCredentials credential, SafeDeleteContext& context, string targetName, SecurityBuffer[] inputBuffers, SecurityBuffer outputBuffer);
    public static SafeFreeCredentials AcquireCredentialsHandle(X509Certificate certificate, SslProtocols protocols, EncryptionPolicy policy, bool isServer);
    public static SecurityStatusPal EncryptMessage(SafeDeleteContext securityContext, Byte[] input, int offset, int size, int headerSize, int trailerSize, Byte[]& output, Int32& resultSize);
    public static SecurityStatusPal DecryptMessage(SafeDeleteContext securityContext, Byte[] buffer, Int32& offset, Int32& count);
    public static SafeFreeContextBufferChannelBinding QueryContextChannelBinding(SafeDeleteContext securityContext, ChannelBindingKind attribute);
    public static void QueryContextStreamSizes(SafeDeleteContext securityContext, StreamSizes& streamSizes);
    public static void QueryContextConnectionInfo(SafeDeleteContext securityContext, SslConnectionInfo& connectionInfo);
    private static SecurityStatusPal HandshakeInternal(SafeFreeCredentials credential, SafeDeleteContext& context, SecurityBuffer inputBuffer, SecurityBuffer outputBuffer, bool isServer, bool remoteCertRequired);
    private static SecurityStatusPal EncryptDecryptHelper(SafeDeleteContext securityContext, Byte[] input, int offset, int size, bool encrypt, Byte[]& output, Int32& resultSize);
}
internal class System.Net.StreamFramer : object {
    private Stream _transport;
    private bool _eof;
    private FrameHeader _writeHeader;
    private FrameHeader _curReadHeader;
    private FrameHeader _readVerifier;
    private Byte[] _readHeaderBuffer;
    private Byte[] _writeHeaderBuffer;
    private AsyncCallback _readFrameCallback;
    private AsyncCallback _beginWriteCallback;
    public FrameHeader ReadHeader { get; }
    public FrameHeader WriteHeader { get; }
    public Stream Transport { get; }
    public StreamFramer(Stream Transport);
    public FrameHeader get_ReadHeader();
    public FrameHeader get_WriteHeader();
    public Stream get_Transport();
    public Byte[] ReadMessage();
    public IAsyncResult BeginReadMessage(AsyncCallback asyncCallback, object stateObject);
    private void ReadFrameCallback(IAsyncResult transportResult);
    private void ReadFrameComplete(IAsyncResult transportResult);
    public Byte[] EndReadMessage(IAsyncResult asyncResult);
    public void WriteMessage(Byte[] message);
    public IAsyncResult BeginWriteMessage(Byte[] message, AsyncCallback asyncCallback, object stateObject);
    private void BeginWriteCallback(IAsyncResult transportResult);
    private void BeginWriteComplete(IAsyncResult transportResult);
    public void EndWriteMessage(IAsyncResult asyncResult);
}
internal class System.Net.StreamSizes : object {
    public int header;
    public int trailer;
    public int maximumMessage;
}
[FlagsAttribute]
internal enum System.Net.ThreadKinds : Enum {
    public int value__;
    public static ThreadKinds Unknown;
    public static ThreadKinds User;
    public static ThreadKinds System;
    public static ThreadKinds Sync;
    public static ThreadKinds Async;
    public static ThreadKinds Timer;
    public static ThreadKinds CompletionPort;
    public static ThreadKinds Worker;
    public static ThreadKinds Finalization;
    public static ThreadKinds Other;
    public static ThreadKinds OwnerMask;
    public static ThreadKinds SyncMask;
    public static ThreadKinds SourceMask;
    public static ThreadKinds SafeSources;
    public static ThreadKinds ThreadPool;
}
internal enum System.Net.TraceEventType : Enum {
    public int value__;
    public static TraceEventType Critical;
    public static TraceEventType Error;
    public static TraceEventType Warning;
    public static TraceEventType Information;
    public static TraceEventType Verbose;
    public static TraceEventType Start;
    public static TraceEventType Stop;
    public static TraceEventType Suspend;
    public static TraceEventType Resume;
    public static TraceEventType Transfer;
}
internal class System.Net.TraceSource : object {
    public SourceSwitch Switch { get; }
    public TraceSource(string name);
    public TraceSource(string name, SourceLevels defaultLevel);
    public void Close();
    public void Flush();
    public void TraceEvent(TraceEventType eventType, int id);
    public void TraceEvent(TraceEventType eventType, int id, string message);
    public void TraceEvent(TraceEventType eventType, int id, string format, Object[] args);
    public void TraceData(TraceEventType eventType, int id, object data);
    public void TraceData(TraceEventType eventType, int id, Object[] data);
    public void TraceInformation(string message);
    public void TraceInformation(string format, Object[] args);
    public void TraceTransfer(int id, string message, Guid relatedActivityId);
    public SourceSwitch get_Switch();
}
internal class System.Net.UriScheme : object {
    public static string Http;
    public static string Https;
    public static string Ws;
    public static string Wss;
    public static string SchemeDelimiter;
}
internal class System.Net.WorkerAsyncResult : LazyAsyncResult {
    public Byte[] Buffer;
    public int Offset;
    public int End;
    public bool HeaderDone;
    public WorkerAsyncResult(object asyncObject, object asyncState, AsyncCallback savedAsyncCallback, Byte[] buffer, int offset, int end);
}
internal static class System.NotImplemented : object {
    internal static Exception ByDesign { get; }
    internal static Exception get_ByDesign();
    internal static Exception ByDesignWithMessage(string message);
}
internal class System.PinnableBufferCache : object {
    private static int DefaultNumberOfBuffers;
    private string _cacheName;
    private Func`1<object> _factory;
    private ConcurrentStack`1<object> _freeList;
    private List`1<object> _notGen2;
    private int _gen1CountAtLastRestock;
    private int _msecNoUseBeyondFreeListSinceThisTime;
    private bool _moreThanFreeListNeeded;
    private int _buffersUnderManagement;
    private int _restockSize;
    private bool _trimmingExperimentInProgress;
    private int _minBufferCount;
    private int _numAllocCalls;
    public PinnableBufferCache(string cacheName, int numberOfElements);
    internal PinnableBufferCache(string cacheName, Func`1<object> factory);
    public Byte[] AllocateBuffer();
    public void FreeBuffer(Byte[] buffer);
    [SecuritySafeCriticalAttribute]
internal object Allocate();
    [SecuritySafeCriticalAttribute]
internal void Free(object buffer);
    [SecuritySafeCriticalAttribute]
private void Restock(Object& returnBuffer);
    [SecuritySafeCriticalAttribute]
private bool AgePendingBuffers();
    private void CreateNewBuffers();
    [SecuritySafeCriticalAttribute]
private static bool Gen2GcCallbackFunc(object targetObj);
    [SecuritySafeCriticalAttribute]
private bool TrimFreeListIfNeeded();
}
[EventSourceAttribute]
internal class System.PinnableBufferCacheEventSource : EventSource {
    public static PinnableBufferCacheEventSource Log;
    private static PinnableBufferCacheEventSource();
    [EventAttribute("1")]
public void DebugMessage(string message);
    [EventAttribute("2")]
public void DebugMessage1(string message, long value);
    [EventAttribute("3")]
public void DebugMessage2(string message, long value1, long value2);
    [EventAttribute("18")]
public void DebugMessage3(string message, long value1, long value2, long value3);
    [EventAttribute("4")]
public void Create(string cacheName);
    [EventAttribute("5")]
public void AllocateBuffer(string cacheName, ulong objectId, int objectHash, int objectGen, int freeCountAfter);
    [EventAttribute("6")]
public void AllocateBufferFromNotGen2(string cacheName, int notGen2CountAfter);
    [EventAttribute("7")]
public void AllocateBufferCreatingNewBuffers(string cacheName, int totalBuffsBefore, int objectCount);
    [EventAttribute("8")]
public void AllocateBufferAged(string cacheName, int agedCount);
    [EventAttribute("9")]
public void AllocateBufferFreeListEmpty(string cacheName, int notGen2CountBefore);
    [EventAttribute("10")]
public void FreeBuffer(string cacheName, ulong objectId, int objectHash, int freeCountBefore);
    [EventAttribute("11")]
public void FreeBufferStillTooYoung(string cacheName, int notGen2CountBefore);
    [EventAttribute("13")]
public void TrimCheck(string cacheName, int totalBuffs, bool neededMoreThanFreeList, int deltaMSec);
    [EventAttribute("14")]
public void TrimFree(string cacheName, int totalBuffs, int freeListCount, int toBeFreed);
    [EventAttribute("15")]
public void TrimExperiment(string cacheName, int totalBuffs, int freeListCount, int numTrimTrial);
    [EventAttribute("16")]
public void TrimFreeSizeOK(string cacheName, int totalBuffs, int freeListCount);
    [EventAttribute("17")]
public void TrimFlush(string cacheName, int totalBuffs, int freeListCount, int notGen2CountBefore);
    [EventAttribute("20")]
public void AgePendingBuffersResults(string cacheName, int promotedToFreeListCount, int heldBackCount);
    [EventAttribute("21")]
public void WalkFreeListResult(string cacheName, int freeListCount, int gen0BuffersInFreeList);
    internal static ulong AddressOf(object obj);
    [SecuritySafeCriticalAttribute]
internal static long AddressOfByteArray(Byte[] array);
}
public class System.Security.Authentication.AuthenticationException : Exception {
    public AuthenticationException(string message);
    public AuthenticationException(string message, Exception innerException);
}
public class System.Security.Authentication.ExtendedProtection.ExtendedProtectionPolicy : object {
    private static string policyEnforcementName;
    private static string protectionScenarioName;
    private static string customServiceNamesName;
    private static string customChannelBindingName;
    private ServiceNameCollection _customServiceNames;
    private PolicyEnforcement _policyEnforcement;
    private ProtectionScenario _protectionScenario;
    private ChannelBinding _customChannelBinding;
    public ServiceNameCollection CustomServiceNames { get; }
    public PolicyEnforcement PolicyEnforcement { get; }
    public ProtectionScenario ProtectionScenario { get; }
    public ChannelBinding CustomChannelBinding { get; }
    public static bool OSSupportsExtendedProtection { get; }
    public ExtendedProtectionPolicy(PolicyEnforcement policyEnforcement, ProtectionScenario protectionScenario, ServiceNameCollection customServiceNames);
    public ExtendedProtectionPolicy(PolicyEnforcement policyEnforcement, ProtectionScenario protectionScenario, ICollection customServiceNames);
    public ExtendedProtectionPolicy(PolicyEnforcement policyEnforcement, ChannelBinding customChannelBinding);
    public ExtendedProtectionPolicy(PolicyEnforcement policyEnforcement);
    public ServiceNameCollection get_CustomServiceNames();
    public PolicyEnforcement get_PolicyEnforcement();
    public ProtectionScenario get_ProtectionScenario();
    public ChannelBinding get_CustomChannelBinding();
    public virtual string ToString();
    public static bool get_OSSupportsExtendedProtection();
}
public enum System.Security.Authentication.ExtendedProtection.PolicyEnforcement : Enum {
    public int value__;
    public static PolicyEnforcement Never;
    public static PolicyEnforcement WhenSupported;
    public static PolicyEnforcement Always;
}
public enum System.Security.Authentication.ExtendedProtection.ProtectionScenario : Enum {
    public int value__;
    public static ProtectionScenario TransportSelected;
    public static ProtectionScenario TrustedProxy;
}
public class System.Security.Authentication.ExtendedProtection.ServiceNameCollection : object {
    private List`1<object> _list;
    public int Count { get; }
    private bool System.Collections.ICollection.IsSynchronized { get; }
    private object System.Collections.ICollection.SyncRoot { get; }
    private IList NonGenericList { get; }
    public ServiceNameCollection(ICollection items);
    private ServiceNameCollection(List`1<object> list, string serviceName);
    private ServiceNameCollection(List`1<object> list, IEnumerable serviceNames);
    private ServiceNameCollection(List`1<object> list, int additionalCapacity);
    public sealed virtual int get_Count();
    public bool Contains(string searchServiceName);
    public sealed virtual IEnumerator GetEnumerator();
    public ServiceNameCollection Merge(string serviceName);
    public ServiceNameCollection Merge(IEnumerable serviceNames);
    private void AddIfNew(IEnumerable serviceNames, bool expectStrings);
    private void AddIfNew(List`1<string> serviceNames);
    private void AddIfNew(List`1<object> serviceNames);
    private void AddIfNew(string serviceName);
    private static int GetCountOrOne(IEnumerable collection);
    private static string NormalizeServiceName(string inputServiceName);
    private sealed virtual override bool System.Collections.ICollection.get_IsSynchronized();
    private sealed virtual override object System.Collections.ICollection.get_SyncRoot();
    private sealed virtual override void System.Collections.ICollection.CopyTo(Array array, int index);
    private IList get_NonGenericList();
}
public class System.Security.Authentication.InvalidCredentialException : AuthenticationException {
    public InvalidCredentialException(string message);
    public InvalidCredentialException(string message, Exception innerException);
}
internal static class System.SR : object {
    private static ResourceManager s_resourceManager;
    private static string s_resourcesName;
    private static ResourceManager ResourceManager { get; }
    internal static string Arg_RankMultiDimNotSupported { get; }
    internal static string ArgumentOutOfRange_NeedNonNegNum { get; }
    internal static string Arg_ArrayPlusOffTooSmall { get; }
    internal static string net_noseek { get; }
    internal static string net_mustbeuri { get; }
    internal static string net_securitypackagesupport { get; }
    internal static string net_securityprotocolnotsupported { get; }
    internal static string net_MethodNotImplementedException { get; }
    internal static string net_completed_result { get; }
    internal static string net_io_readfailure { get; }
    internal static string net_io_connectionclosed { get; }
    internal static string net_io_invalidnestedcall { get; }
    internal static string net_io_invalidendcall { get; }
    internal static string net_io_must_be_rw_stream { get; }
    internal static string net_io_header_id { get; }
    internal static string net_io_out_range { get; }
    internal static string net_io_encrypt { get; }
    internal static string net_io_decrypt { get; }
    internal static string net_io_read { get; }
    internal static string net_io_write { get; }
    internal static string net_io_eof { get; }
    internal static string net_io_async_result { get; }
    internal static string net_ssl_io_frame { get; }
    internal static string net_ssl_io_cert_validation { get; }
    internal static string net_ssl_io_no_server_cert { get; }
    internal static string net_auth_bad_client_creds { get; }
    internal static string net_auth_bad_client_creds_or_target_mismatch { get; }
    internal static string net_auth_context_expectation { get; }
    internal static string net_auth_context_expectation_remote { get; }
    internal static string net_auth_supported_impl_levels { get; }
    internal static string net_auth_reauth { get; }
    internal static string net_auth_noauth { get; }
    internal static string net_auth_client_server { get; }
    internal static string net_auth_SSPI { get; }
    internal static string net_auth_eof { get; }
    internal static string net_auth_alert { get; }
    internal static string net_auth_ignored_reauth { get; }
    internal static string net_auth_message_not_encrypted { get; }
    internal static string net_auth_must_specify_extended_protection_scheme { get; }
    internal static string net_frame_size { get; }
    internal static string net_frame_read_io { get; }
    internal static string net_frame_read_size { get; }
    internal static string net_frame_max_size { get; }
    internal static string net_offset_plus_count { get; }
    internal static string net_invalid_enum { get; }
    internal static string net_log_exception { get; }
    internal static string event_EnumerateSecurityPackages { get; }
    internal static string event_SspiPackageNotFound { get; }
    internal static string event_SecurityContextInputBuffer { get; }
    internal static string event_SecurityContextInputBuffers { get; }
    internal static string event_SspiSelectedCipherSuite { get; }
    internal static string event_RemoteCertificate { get; }
    internal static string event_LocatingPrivateKey { get; }
    internal static string event_CertIsType2 { get; }
    internal static string event_FoundCertInStore { get; }
    internal static string event_NotFoundCertInStore { get; }
    internal static string net_log_open_store_failed { get; }
    internal static string event_CertificateFromDelegate { get; }
    internal static string event_NoDelegateNoClientCert { get; }
    internal static string event_NoDelegateButClientCert { get; }
    internal static string event_AttemptingRestartUsingCert { get; }
    internal static string event_NoIssuersTryAllCerts { get; }
    internal static string event_LookForMatchingCerts { get; }
    internal static string event_SelectedCert { get; }
    internal static string event_CertsAfterFiltering { get; }
    internal static string event_FindingMatchingCerts { get; }
    internal static string event_UsingCachedCredential { get; }
    internal static string event_RemoteCertDeclaredValid { get; }
    internal static string event_RemoteCertUserDeclaredInvalid { get; }
    internal static string event_RemoteCertHasNoErrors { get; }
    internal static string net_log_remote_cert_has_errors { get; }
    internal static string net_log_remote_cert_not_available { get; }
    internal static string net_log_remote_cert_name_mismatch { get; }
    internal static string event_OperationReturnedSomething { get; }
    internal static string net_log_operation_failed_with_error { get; }
    internal static string SSPIInvalidHandleType { get; }
    internal static string security_ExtendedProtectionPolicy_UseDifferentConstructorForNever { get; }
    internal static string security_ExtendedProtectionPolicy_NoEmptyServiceNameCollection { get; }
    internal static string security_ServiceNameCollection_EmptyServiceName { get; }
    internal static string ObjectDisposed_StreamIsClosed { get; }
    internal static string NotSupported_UnreadableStream { get; }
    internal static string NotSupported_UnwritableStream { get; }
    internal static string net_allocate_ssl_context_failed { get; }
    internal static string net_generic_operation_failed { get; }
    internal static string net_ssl_decrypt_failed { get; }
    internal static string net_ssl_encrypt_failed { get; }
    internal static string net_get_ssl_method_failed { get; }
    internal static string net_ssl_check_private_key_failed { get; }
    internal static string net_ssl_handshake_failed_error { get; }
    internal static string net_ssl_read_bio_failed_error { get; }
    internal static string net_ssl_use_cert_failed { get; }
    internal static string net_ssl_use_private_key_failed { get; }
    internal static string net_ssl_write_bio_failed_error { get; }
    internal static string net_ssl_x509Name_push_failed_error { get; }
    internal static string net_ssl_get_connection_info_failed { get; }
    internal static string net_ssl_get_channel_binding_token_failed { get; }
    internal static string net_ssl_invalid_certificate { get; }
    internal static string net_ssl_encryptionpolicy_notsupported { get; }
    internal static string net_gssapi_operation_failed_detailed { get; }
    internal static string net_gssapi_operation_failed { get; }
    internal static string net_context_establishment_failed { get; }
    internal static string net_context_wrap_failed { get; }
    internal static string net_context_unwrap_failed { get; }
    internal static string net_context_buffer_too_small { get; }
    internal static string net_nego_channel_binding_not_supported { get; }
    internal static string net_ntlm_not_possible_default_cred { get; }
    internal static string net_nego_server_not_supported { get; }
    internal static string net_nego_protection_level_not_supported { get; }
    internal static string net_nego_not_supported_empty_target_with_defaultcreds { get; }
    internal static Type ResourceType { get; }
    private static ResourceManager get_ResourceManager();
    private static bool UsingResourceKeys();
    internal static string GetResourceString(string resourceKey, string defaultString);
    internal static string Format(string resourceFormat, Object[] args);
    internal static string Format(string resourceFormat, object p1);
    internal static string Format(string resourceFormat, object p1, object p2);
    internal static string Format(string resourceFormat, object p1, object p2, object p3);
    internal static string get_Arg_RankMultiDimNotSupported();
    internal static string get_ArgumentOutOfRange_NeedNonNegNum();
    internal static string get_Arg_ArrayPlusOffTooSmall();
    internal static string get_net_noseek();
    internal static string get_net_mustbeuri();
    internal static string get_net_securitypackagesupport();
    internal static string get_net_securityprotocolnotsupported();
    internal static string get_net_MethodNotImplementedException();
    internal static string get_net_completed_result();
    internal static string get_net_io_readfailure();
    internal static string get_net_io_connectionclosed();
    internal static string get_net_io_invalidnestedcall();
    internal static string get_net_io_invalidendcall();
    internal static string get_net_io_must_be_rw_stream();
    internal static string get_net_io_header_id();
    internal static string get_net_io_out_range();
    internal static string get_net_io_encrypt();
    internal static string get_net_io_decrypt();
    internal static string get_net_io_read();
    internal static string get_net_io_write();
    internal static string get_net_io_eof();
    internal static string get_net_io_async_result();
    internal static string get_net_ssl_io_frame();
    internal static string get_net_ssl_io_cert_validation();
    internal static string get_net_ssl_io_no_server_cert();
    internal static string get_net_auth_bad_client_creds();
    internal static string get_net_auth_bad_client_creds_or_target_mismatch();
    internal static string get_net_auth_context_expectation();
    internal static string get_net_auth_context_expectation_remote();
    internal static string get_net_auth_supported_impl_levels();
    internal static string get_net_auth_reauth();
    internal static string get_net_auth_noauth();
    internal static string get_net_auth_client_server();
    internal static string get_net_auth_SSPI();
    internal static string get_net_auth_eof();
    internal static string get_net_auth_alert();
    internal static string get_net_auth_ignored_reauth();
    internal static string get_net_auth_message_not_encrypted();
    internal static string get_net_auth_must_specify_extended_protection_scheme();
    internal static string get_net_frame_size();
    internal static string get_net_frame_read_io();
    internal static string get_net_frame_read_size();
    internal static string get_net_frame_max_size();
    internal static string get_net_offset_plus_count();
    internal static string get_net_invalid_enum();
    internal static string get_net_log_exception();
    internal static string get_event_EnumerateSecurityPackages();
    internal static string get_event_SspiPackageNotFound();
    internal static string get_event_SecurityContextInputBuffer();
    internal static string get_event_SecurityContextInputBuffers();
    internal static string get_event_SspiSelectedCipherSuite();
    internal static string get_event_RemoteCertificate();
    internal static string get_event_LocatingPrivateKey();
    internal static string get_event_CertIsType2();
    internal static string get_event_FoundCertInStore();
    internal static string get_event_NotFoundCertInStore();
    internal static string get_net_log_open_store_failed();
    internal static string get_event_CertificateFromDelegate();
    internal static string get_event_NoDelegateNoClientCert();
    internal static string get_event_NoDelegateButClientCert();
    internal static string get_event_AttemptingRestartUsingCert();
    internal static string get_event_NoIssuersTryAllCerts();
    internal static string get_event_LookForMatchingCerts();
    internal static string get_event_SelectedCert();
    internal static string get_event_CertsAfterFiltering();
    internal static string get_event_FindingMatchingCerts();
    internal static string get_event_UsingCachedCredential();
    internal static string get_event_RemoteCertDeclaredValid();
    internal static string get_event_RemoteCertUserDeclaredInvalid();
    internal static string get_event_RemoteCertHasNoErrors();
    internal static string get_net_log_remote_cert_has_errors();
    internal static string get_net_log_remote_cert_not_available();
    internal static string get_net_log_remote_cert_name_mismatch();
    internal static string get_event_OperationReturnedSomething();
    internal static string get_net_log_operation_failed_with_error();
    internal static string get_SSPIInvalidHandleType();
    internal static string get_security_ExtendedProtectionPolicy_UseDifferentConstructorForNever();
    internal static string get_security_ExtendedProtectionPolicy_NoEmptyServiceNameCollection();
    internal static string get_security_ServiceNameCollection_EmptyServiceName();
    internal static string get_ObjectDisposed_StreamIsClosed();
    internal static string get_NotSupported_UnreadableStream();
    internal static string get_NotSupported_UnwritableStream();
    internal static string get_net_allocate_ssl_context_failed();
    internal static string get_net_generic_operation_failed();
    internal static string get_net_ssl_decrypt_failed();
    internal static string get_net_ssl_encrypt_failed();
    internal static string get_net_get_ssl_method_failed();
    internal static string get_net_ssl_check_private_key_failed();
    internal static string get_net_ssl_handshake_failed_error();
    internal static string get_net_ssl_read_bio_failed_error();
    internal static string get_net_ssl_use_cert_failed();
    internal static string get_net_ssl_use_private_key_failed();
    internal static string get_net_ssl_write_bio_failed_error();
    internal static string get_net_ssl_x509Name_push_failed_error();
    internal static string get_net_ssl_get_connection_info_failed();
    internal static string get_net_ssl_get_channel_binding_token_failed();
    internal static string get_net_ssl_invalid_certificate();
    internal static string get_net_ssl_encryptionpolicy_notsupported();
    internal static string get_net_gssapi_operation_failed_detailed();
    internal static string get_net_gssapi_operation_failed();
    internal static string get_net_context_establishment_failed();
    internal static string get_net_context_wrap_failed();
    internal static string get_net_context_unwrap_failed();
    internal static string get_net_context_buffer_too_small();
    internal static string get_net_nego_channel_binding_not_supported();
    internal static string get_net_ntlm_not_possible_default_cred();
    internal static string get_net_nego_server_not_supported();
    internal static string get_net_nego_protection_level_not_supported();
    internal static string get_net_nego_not_supported_empty_target_with_defaultcreds();
    internal static Type get_ResourceType();
}
internal static class System.Threading.Tasks.TaskToApm : object {
    public static IAsyncResult Begin(Task task, AsyncCallback callback, object state);
    public static void End(IAsyncResult asyncResult);
    public static TResult End(IAsyncResult asyncResult);
    private static void InvokeCallbackWhenTaskCompletes(Task antecedent, AsyncCallback callback, IAsyncResult asyncResult);
}
