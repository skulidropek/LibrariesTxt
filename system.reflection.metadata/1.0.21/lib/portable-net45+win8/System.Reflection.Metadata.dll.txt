[FlagsAttribute]
public enum System.Reflection.AssemblyFlags : Enum {
    public int value__;
    public static AssemblyFlags PublicKey;
    public static AssemblyFlags Retargetable;
    public static AssemblyFlags WindowsRuntime;
    public static AssemblyFlags ContentTypeMask;
    public static AssemblyFlags DisableJitCompileOptimizer;
    public static AssemblyFlags EnableJitCompileTracking;
}
public enum System.Reflection.AssemblyHashAlgorithm : Enum {
    public int value__;
    public static AssemblyHashAlgorithm None;
    public static AssemblyHashAlgorithm MD5;
    public static AssemblyHashAlgorithm Sha1;
    public static AssemblyHashAlgorithm Sha256;
    public static AssemblyHashAlgorithm Sha384;
    public static AssemblyHashAlgorithm Sha512;
}
public enum System.Reflection.DeclarativeSecurityAction : Enum {
    public short value__;
    public static DeclarativeSecurityAction None;
    public static DeclarativeSecurityAction Demand;
    public static DeclarativeSecurityAction Assert;
    public static DeclarativeSecurityAction Deny;
    public static DeclarativeSecurityAction PermitOnly;
    public static DeclarativeSecurityAction LinkDemand;
    public static DeclarativeSecurityAction InheritanceDemand;
    public static DeclarativeSecurityAction RequestMinimum;
    public static DeclarativeSecurityAction RequestOptional;
    public static DeclarativeSecurityAction RequestRefuse;
}
internal abstract class System.Reflection.Internal.AbstractMemoryBlock : object {
    public Byte* Pointer { get; }
    public int Size { get; }
    public abstract virtual Byte* get_Pointer();
    public abstract virtual int get_Size();
    public abstract virtual ImmutableArray`1<byte> GetContent(int offset);
    public ImmutableArray`1<byte> GetContent();
    public sealed virtual void Dispose();
    protected abstract virtual void Dispose(bool disposing);
    protected static ImmutableArray`1<byte> CreateImmutableArray(Byte* ptr, int length);
}
internal static class System.Reflection.Internal.BitArithmetic : object {
    internal static int CountBits(ulong v);
}
internal class System.Reflection.Internal.ByteArrayMemoryBlock : AbstractMemoryBlock {
    private ByteArrayMemoryProvider _provider;
    private int _start;
    private int _size;
    public Byte* Pointer { get; }
    public int Size { get; }
    internal ByteArrayMemoryBlock(ByteArrayMemoryProvider provider, int start, int size);
    protected virtual void Dispose(bool disposing);
    public virtual Byte* get_Pointer();
    public virtual int get_Size();
    public virtual ImmutableArray`1<byte> GetContent(int offset);
}
internal class System.Reflection.Internal.ByteArrayMemoryProvider : MemoryBlockProvider {
    internal ImmutableArray`1<byte> array;
    private StrongBox`1<GCHandle> _pinned;
    public int Size { get; }
    internal Byte* Pointer { get; }
    public ByteArrayMemoryProvider(ImmutableArray`1<byte> array);
    protected virtual void Finalize();
    protected virtual void Dispose(bool disposing);
    public virtual int get_Size();
    protected virtual AbstractMemoryBlock GetMemoryBlockImpl(int start, int size);
    public virtual Stream GetStream(StreamConstraints& constraints);
    internal Byte* get_Pointer();
}
internal static class System.Reflection.Internal.EmptyArray`1 : object {
    internal static T[] Instance;
    private static EmptyArray`1();
}
[ExtensionAttribute]
internal static class System.Reflection.Internal.EncodingHelper : object {
    public static int PooledBufferSize;
    private static ObjectPool`1<Byte[]> s_pool;
    private static Encoding_GetString s_getStringPlatform;
    [CompilerGeneratedAttribute]
private static Func`1<Byte[]> CS$<>9__CachedAnonymousMethodDelegate4;
    internal static bool TestOnly_LightUpEnabled { get; internal set; }
    private static EncodingHelper();
    public static string DecodeUtf8(Byte* bytes, int byteCount, Byte[] prefix, MetadataStringDecoder utf8Decoder);
    private static string DecodeUtf8Prefixed(Byte* bytes, int byteCount, Byte[] prefix, MetadataStringDecoder utf8Decoder);
    private static Byte[] AcquireBuffer(int byteCount);
    private static void ReleaseBuffer(Byte[] buffer);
    [ExtensionAttribute]
public static string GetString(Encoding encoding, Byte* bytes, int byteCount);
    private static string GetStringPortable(Encoding encoding, Byte* bytes, int byteCount);
    private static Encoding_GetString LoadGetStringPlatform();
    private static string GetStringUsingCreateStringFromEncoding(String_CreateStringFromEncoding createStringFromEncoding, Byte* bytes, int byteCount, Encoding encoding);
    internal static bool get_TestOnly_LightUpEnabled();
    internal static void set_TestOnly_LightUpEnabled(bool value);
    [CompilerGeneratedAttribute]
private static Byte[] <.cctor>b__3();
}
internal class System.Reflection.Internal.ExternalMemoryBlock : AbstractMemoryBlock {
    private object _memoryOwner;
    private Byte* _buffer;
    private int _size;
    public Byte* Pointer { get; }
    public int Size { get; }
    public ExternalMemoryBlock(object memoryOwner, Byte* buffer, int size);
    protected virtual void Dispose(bool disposing);
    public virtual Byte* get_Pointer();
    public virtual int get_Size();
    public virtual ImmutableArray`1<byte> GetContent(int offset);
}
internal class System.Reflection.Internal.ExternalMemoryBlockProvider : MemoryBlockProvider {
    private Byte* _memory;
    private int _size;
    public int Size { get; }
    public Byte* Pointer { get; }
    public ExternalMemoryBlockProvider(Byte* memory, int size);
    public virtual int get_Size();
    protected virtual AbstractMemoryBlock GetMemoryBlockImpl(int start, int size);
    public virtual Stream GetStream(StreamConstraints& constraints);
    protected virtual void Dispose(bool disposing);
    public Byte* get_Pointer();
}
internal static class System.Reflection.Internal.FileStreamReadLightUp : object {
    internal static Lazy`1<Type> FileStreamType;
    internal static Lazy`1<PropertyInfo> SafeFileHandle;
    internal static bool readFileCompatNotAvailable;
    internal static bool readFileModernNotAvailable;
    internal static bool safeFileHandleNotAvailable;
    [CompilerGeneratedAttribute]
private static Func`1<Type> CS$<>9__CachedAnonymousMethodDelegate2;
    [CompilerGeneratedAttribute]
private static Func`1<PropertyInfo> CS$<>9__CachedAnonymousMethodDelegate3;
    private static FileStreamReadLightUp();
    internal static bool IsFileStream(Stream stream);
    internal static SafeHandle GetSafeFileHandle(Stream stream);
    internal static bool TryReadFile(Stream stream, Byte* buffer, long start, int size);
    [CompilerGeneratedAttribute]
private static Type <.cctor>b__0();
    [CompilerGeneratedAttribute]
private static PropertyInfo <.cctor>b__1();
}
internal static class System.Reflection.Internal.ImmutableByteArrayInterop : object {
    internal static ImmutableArray`1<byte> DangerousCreateFromUnderlyingArray(Byte[]& array);
    internal static Byte[] DangerousGetUnderlyingArray(ImmutableArray`1<byte> array);
}
internal class System.Reflection.Internal.ImmutableMemoryStream : Stream {
    private ImmutableArray`1<byte> _array;
    private int _position;
    public bool CanRead { get; }
    public bool CanSeek { get; }
    public bool CanWrite { get; }
    public long Length { get; }
    public long Position { get; public set; }
    internal ImmutableMemoryStream(ImmutableArray`1<byte> array);
    public ImmutableArray`1<byte> GetBuffer();
    public virtual bool get_CanRead();
    public virtual bool get_CanSeek();
    public virtual bool get_CanWrite();
    public virtual long get_Length();
    public virtual long get_Position();
    public virtual void set_Position(long value);
    public virtual void Flush();
    public virtual int Read(Byte[] buffer, int offset, int count);
    public virtual long Seek(long offset, SeekOrigin origin);
    public virtual void SetLength(long value);
    public virtual void Write(Byte[] buffer, int offset, int count);
}
internal static class System.Reflection.Internal.LightUpHelper : object {
    internal static Type GetType(string typeName, String[] assemblyNames);
    internal static MethodInfo GetMethod(Type type, string name, Type[] parameterTypes);
}
[DebuggerDisplayAttribute("{GetDebuggerDisplay(),nq}")]
internal class System.Reflection.Internal.MemoryBlock : ValueType {
    internal Byte* Pointer;
    internal int Length;
    internal MemoryBlock(Byte* buffer, int length);
    private void CheckBounds(int offset, int byteCount);
    private static void ThrowOutOfBounds();
    private static void ThrowReferenceOverflow();
    internal Byte[] ToArray();
    private string GetDebuggerDisplay();
    internal string GetDebuggerDisplay(Int32& displayedBytes);
    internal MemoryBlock GetMemoryBlockAt(int offset, int length);
    internal byte PeekByte(int offset);
    internal int PeekInt32(int offset);
    internal UInt32 PeekUInt32(int offset);
    internal int PeekCompressedInteger(int offset, Int32& numberOfBytesRead);
    internal ushort PeekUInt16(int offset);
    internal UInt32 PeekTaggedReference(int offset, bool smallRefSize);
    internal UInt32 PeekReferenceUnchecked(int offset, bool smallRefSize);
    internal int PeekReference(int offset, bool smallRefSize);
    internal int PeekHeapReference(int offset, bool smallRefSize);
    internal Guid PeekGuid(int offset);
    internal string PeekUtf16(int offset, int byteCount);
    internal string PeekUtf8(int offset, int byteCount);
    internal string PeekUtf8NullTerminated(int offset, Byte[] prefix, MetadataStringDecoder utf8Decoder, Int32& numberOfBytesRead, char terminator);
    internal int GetUtf8NullTerminatedLength(int offset, Int32& numberOfBytesRead, char terminator);
    internal int Utf8NullTerminatedOffsetOfAsciiChar(int startOffset, char asciiChar);
    internal bool Utf8NullTerminatedEquals(int offset, string text, MetadataStringDecoder utf8Decoder, char terminator);
    internal bool Utf8NullTerminatedStartsWith(int offset, string text, MetadataStringDecoder utf8Decoder, char terminator);
    private FastComparisonResult Utf8NullTerminatedFastCompare(int offset, string text, char terminator);
    internal bool Utf8NullTerminatedStringStartsWithAsciiPrefix(int offset, string asciiPrefix);
    internal int CompareUtf8NullTerminatedStringWithAsciiString(int offset, string asciiString);
    internal Byte[] PeekBytes(int offset, int byteCount);
    internal int IndexOf(byte b, int start);
    internal int BinarySearch(String[] asciiKeys, int offset);
    internal int BinarySearchForSlot(int rowCount, int rowSize, int referenceOffset, UInt32 referenceValue, bool isReferenceSmall);
    internal int BinarySearchReference(int rowCount, int rowSize, int referenceOffset, UInt32 referenceValue, bool isReferenceSmall);
    internal int BinarySearchReference(Int32[] ptrTable, int rowSize, int referenceOffset, UInt32 referenceValue, bool isReferenceSmall);
    internal void BinarySearchReferenceRange(int rowCount, int rowSize, int referenceOffset, UInt32 referenceValue, bool isReferenceSmall, Int32& startRowNumber, Int32& endRowNumber);
    internal void BinarySearchReferenceRange(Int32[] ptrTable, int rowSize, int referenceOffset, UInt32 referenceValue, bool isReferenceSmall, Int32& startRowNumber, Int32& endRowNumber);
    internal int LinearSearchReference(int rowSize, int referenceOffset, UInt32 referenceValue, bool isReferenceSmall);
    internal bool IsOrderedByReferenceAscending(int rowSize, int referenceOffset, bool isReferenceSmall);
    internal Int32[] BuildPtrTable(int numberOfRows, int rowSize, int referenceOffset, bool isReferenceSmall);
    private void ReadColumn(UInt32[] result, int rowSize, int referenceOffset, bool isReferenceSmall);
    internal bool PeekHeapValueOffsetAndSize(int index, Int32& offset, Int32& size);
}
internal abstract class System.Reflection.Internal.MemoryBlockProvider : object {
    public int Size { get; }
    public AbstractMemoryBlock GetMemoryBlock();
    public AbstractMemoryBlock GetMemoryBlock(int start, int size);
    protected abstract virtual AbstractMemoryBlock GetMemoryBlockImpl(int start, int size);
    public abstract virtual Stream GetStream(StreamConstraints& constraints);
    public abstract virtual int get_Size();
    protected abstract virtual void Dispose(bool disposing);
    public sealed virtual void Dispose();
}
internal static class System.Reflection.Internal.MemoryMapLightUp : object {
    private static Type s_lazyMemoryMappedFileType;
    private static Type s_lazyMemoryMappedViewAccessorType;
    private static Type s_lazyMemoryMappedFileAccessType;
    private static Type s_lazyMemoryMappedFileSecurityType;
    private static Type s_lazyHandleInheritabilityType;
    private static MethodInfo s_lazyCreateFromFile;
    private static MethodInfo s_lazyCreateFromFileClassic;
    private static MethodInfo s_lazyCreateViewAccessor;
    private static PropertyInfo s_lazySafeMemoryMappedViewHandle;
    private static PropertyInfo s_lazyPointerOffset;
    private static FieldInfo s_lazyInternalViewField;
    private static PropertyInfo s_lazyInternalPointerOffset;
    private static object s_MemoryMappedFileAccess_Read;
    private static object s_HandleInheritability_None;
    private static object s_LongZero;
    private static object s_True;
    private static Nullable`1<bool> s_lazyIsAvailable;
    internal static bool IsAvailable { get; }
    private static MemoryMapLightUp();
    internal static bool get_IsAvailable();
    private static bool TryLoadType(string typeName, string modernAssembly, string classicAssembly, Type& type);
    private static bool TryLoadTypes();
    private static bool TryLoadMembers();
    internal static IDisposable CreateMemoryMap(Stream stream);
    internal static IDisposable CreateViewAccessor(object memoryMap, long start, int size);
    internal static Byte* AcquirePointer(object accessor, SafeBuffer& safeBuffer);
}
internal class System.Reflection.Internal.MemoryMappedFileBlock : AbstractMemoryBlock {
    private int _size;
    private IDisposable _accessor;
    private Byte* _pointer;
    private SafeBuffer _safeBuffer;
    public Byte* Pointer { get; }
    public int Size { get; }
    internal MemoryMappedFileBlock(IDisposable accessor, SafeBuffer safeBuffer, Byte* pointer, int size);
    protected virtual void Finalize();
    protected virtual void Dispose(bool disposing);
    public virtual Byte* get_Pointer();
    public virtual int get_Size();
    public virtual ImmutableArray`1<byte> GetContent(int offset);
}
internal class System.Reflection.Internal.NativeHeapMemoryBlock : AbstractMemoryBlock {
    private Byte* _pointer;
    private int _size;
    public Byte* Pointer { get; }
    public int Size { get; }
    internal NativeHeapMemoryBlock(int size);
    protected virtual void Finalize();
    protected virtual void Dispose(bool disposing);
    public virtual Byte* get_Pointer();
    public virtual int get_Size();
    public virtual ImmutableArray`1<byte> GetContent(int offset);
}
internal class System.Reflection.Internal.ObjectPool`1 : object {
    private Element[] _items;
    private Func`1<T> _factory;
    internal ObjectPool`1(Func`1<T> factory);
    internal ObjectPool`1(Func`1<T> factory, int size);
    private T CreateInstance();
    internal T Allocate();
    internal void Free(T obj);
}
internal class System.Reflection.Internal.ReadOnlyUnmanagedMemoryStream : Stream {
    private Byte* _data;
    private int _length;
    private int _position;
    public bool CanRead { get; }
    public bool CanSeek { get; }
    public bool CanWrite { get; }
    public long Length { get; }
    public long Position { get; public set; }
    public ReadOnlyUnmanagedMemoryStream(Byte* data, int length);
    public virtual int ReadByte();
    public virtual int Read(Byte[] buffer, int offset, int count);
    public virtual void Flush();
    public virtual bool get_CanRead();
    public virtual bool get_CanSeek();
    public virtual bool get_CanWrite();
    public virtual long get_Length();
    public virtual long get_Position();
    public virtual void set_Position(long value);
    public virtual long Seek(long offset, SeekOrigin origin);
    public virtual void SetLength(long value);
    public virtual void Write(Byte[] buffer, int offset, int count);
}
internal class System.Reflection.Internal.StreamConstraints : ValueType {
    public object GuardOpt;
    public long ImageStart;
    public int ImageSize;
    public StreamConstraints(object guardOpt, long startPosition, int imageSize);
}
[ExtensionAttribute]
internal static class System.Reflection.Internal.StreamExtensions : object {
    internal static int StreamCopyBufferSize;
    [ExtensionAttribute]
internal static void CopyTo(Stream source, Byte* destination, int size);
}
internal class System.Reflection.Internal.StreamMemoryBlockProvider : MemoryBlockProvider {
    internal static int MemoryMapThreshold;
    private Stream _stream;
    private object _streamGuard;
    private bool _leaveOpen;
    private bool _useMemoryMap;
    private bool _isFileStream;
    private long _imageStart;
    private int _imageSize;
    private IDisposable _lazyMemoryMap;
    public int Size { get; }
    public StreamMemoryBlockProvider(Stream stream, long imageStart, int imageSize, bool isFileStream, bool leaveOpen);
    protected virtual void Dispose(bool disposing);
    public virtual int get_Size();
    internal static NativeHeapMemoryBlock ReadMemoryBlockNoLock(Stream stream, bool isFileStream, long start, int size);
    protected virtual AbstractMemoryBlock GetMemoryBlockImpl(int start, int size);
    public virtual Stream GetStream(StreamConstraints& constraints);
    private bool TryCreateMemoryMappedFileBlock(long start, int size, MemoryMappedFileBlock& block);
}
[FlagsAttribute]
public enum System.Reflection.ManifestResourceAttributes : Enum {
    public int value__;
    public static ManifestResourceAttributes Public;
    public static ManifestResourceAttributes Private;
    public static ManifestResourceAttributes VisibilityMask;
}
public class System.Reflection.Metadata.AssemblyDefinition : ValueType {
    private MetadataReader _reader;
    public AssemblyHashAlgorithm HashAlgorithm { get; }
    public Version Version { get; }
    public AssemblyFlags Flags { get; }
    public StringHandle Name { get; }
    public StringHandle Culture { get; }
    public BlobHandle PublicKey { get; }
    internal AssemblyDefinition(MetadataReader reader);
    public AssemblyHashAlgorithm get_HashAlgorithm();
    public Version get_Version();
    public AssemblyFlags get_Flags();
    public StringHandle get_Name();
    public StringHandle get_Culture();
    public BlobHandle get_PublicKey();
    public CustomAttributeHandleCollection GetCustomAttributes();
    public DeclarativeSecurityAttributeHandleCollection GetDeclarativeSecurityAttributes();
}
public class System.Reflection.Metadata.AssemblyDefinitionHandle : ValueType {
    private static UInt32 tokenType;
    private static byte tokenTypeSmall;
    private int _rowId;
    public bool IsNil { get; }
    internal int RowId { get; }
    internal AssemblyDefinitionHandle(int rowId);
    internal static AssemblyDefinitionHandle FromRowId(int rowId);
    public static Handle op_Implicit(AssemblyDefinitionHandle handle);
    public static EntityHandle op_Implicit(AssemblyDefinitionHandle handle);
    public static AssemblyDefinitionHandle op_Explicit(Handle handle);
    public static AssemblyDefinitionHandle op_Explicit(EntityHandle handle);
    public bool get_IsNil();
    internal int get_RowId();
    public static bool op_Equality(AssemblyDefinitionHandle left, AssemblyDefinitionHandle right);
    public virtual bool Equals(object obj);
    public sealed virtual bool Equals(AssemblyDefinitionHandle other);
    public virtual int GetHashCode();
    public static bool op_Inequality(AssemblyDefinitionHandle left, AssemblyDefinitionHandle right);
}
public class System.Reflection.Metadata.AssemblyFile : ValueType {
    private MetadataReader _reader;
    private int _rowId;
    private AssemblyFileHandle Handle { get; }
    public bool ContainsMetadata { get; }
    public StringHandle Name { get; }
    public BlobHandle HashValue { get; }
    internal AssemblyFile(MetadataReader reader, AssemblyFileHandle handle);
    private AssemblyFileHandle get_Handle();
    public bool get_ContainsMetadata();
    public StringHandle get_Name();
    public BlobHandle get_HashValue();
    public CustomAttributeHandleCollection GetCustomAttributes();
}
public class System.Reflection.Metadata.AssemblyFileHandle : ValueType {
    private static UInt32 tokenType;
    private static byte tokenTypeSmall;
    private int _rowId;
    public bool IsNil { get; }
    internal int RowId { get; }
    private AssemblyFileHandle(int rowId);
    internal static AssemblyFileHandle FromRowId(int rowId);
    public static Handle op_Implicit(AssemblyFileHandle handle);
    public static EntityHandle op_Implicit(AssemblyFileHandle handle);
    public static AssemblyFileHandle op_Explicit(Handle handle);
    public static AssemblyFileHandle op_Explicit(EntityHandle handle);
    public bool get_IsNil();
    internal int get_RowId();
    public static bool op_Equality(AssemblyFileHandle left, AssemblyFileHandle right);
    public virtual bool Equals(object obj);
    public sealed virtual bool Equals(AssemblyFileHandle other);
    public virtual int GetHashCode();
    public static bool op_Inequality(AssemblyFileHandle left, AssemblyFileHandle right);
}
public class System.Reflection.Metadata.AssemblyFileHandleCollection : ValueType {
    private int _lastRowId;
    public int Count { get; }
    internal AssemblyFileHandleCollection(int lastRowId);
    public sealed virtual int get_Count();
    public Enumerator GetEnumerator();
    private sealed virtual override IEnumerator`1<AssemblyFileHandle> System.Collections.Generic.IEnumerable<System.Reflection.Metadata.AssemblyFileHandle>.GetEnumerator();
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
}
public class System.Reflection.Metadata.AssemblyReference : ValueType {
    private MetadataReader _reader;
    private UInt32 _treatmentAndRowId;
    private static Version s_version_4_0_0_0;
    private int RowId { get; }
    private bool IsVirtual { get; }
    public Version Version { get; }
    public AssemblyFlags Flags { get; }
    public StringHandle Name { get; }
    public StringHandle Culture { get; }
    public BlobHandle PublicKeyOrToken { get; }
    public BlobHandle HashValue { get; }
    internal AssemblyReference(MetadataReader reader, UInt32 treatmentAndRowId);
    private static AssemblyReference();
    private int get_RowId();
    private bool get_IsVirtual();
    public Version get_Version();
    public AssemblyFlags get_Flags();
    public StringHandle get_Name();
    public StringHandle get_Culture();
    public BlobHandle get_PublicKeyOrToken();
    public BlobHandle get_HashValue();
    public CustomAttributeHandleCollection GetCustomAttributes();
    private Version GetVirtualVersion();
    private AssemblyFlags GetVirtualFlags();
    private StringHandle GetVirtualName();
    private VirtualIndex GetVirtualNameIndex(VirtualIndex index);
    private StringHandle GetVirtualCulture();
    private BlobHandle GetVirtualPublicKeyOrToken();
    private BlobHandle GetVirtualHashValue();
    private CustomAttributeHandleCollection GetVirtualCustomAttributes();
}
public class System.Reflection.Metadata.AssemblyReferenceHandle : ValueType {
    private static UInt32 tokenType;
    private static byte tokenTypeSmall;
    private UInt32 _value;
    internal UInt32 Value { get; }
    private UInt32 VToken { get; }
    public bool IsNil { get; }
    internal bool IsVirtual { get; }
    internal int RowId { get; }
    private AssemblyReferenceHandle(UInt32 value);
    internal static AssemblyReferenceHandle FromRowId(int rowId);
    internal static AssemblyReferenceHandle FromVirtualIndex(VirtualIndex virtualIndex);
    public static Handle op_Implicit(AssemblyReferenceHandle handle);
    public static EntityHandle op_Implicit(AssemblyReferenceHandle handle);
    public static AssemblyReferenceHandle op_Explicit(Handle handle);
    public static AssemblyReferenceHandle op_Explicit(EntityHandle handle);
    internal UInt32 get_Value();
    private UInt32 get_VToken();
    public bool get_IsNil();
    internal bool get_IsVirtual();
    internal int get_RowId();
    public static bool op_Equality(AssemblyReferenceHandle left, AssemblyReferenceHandle right);
    public virtual bool Equals(object obj);
    public sealed virtual bool Equals(AssemblyReferenceHandle other);
    public virtual int GetHashCode();
    public static bool op_Inequality(AssemblyReferenceHandle left, AssemblyReferenceHandle right);
}
public class System.Reflection.Metadata.AssemblyReferenceHandleCollection : ValueType {
    private MetadataReader _reader;
    public int Count { get; }
    internal AssemblyReferenceHandleCollection(MetadataReader reader);
    public sealed virtual int get_Count();
    public Enumerator GetEnumerator();
    private sealed virtual override IEnumerator`1<AssemblyReferenceHandle> System.Collections.Generic.IEnumerable<System.Reflection.Metadata.AssemblyReferenceHandle>.GetEnumerator();
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
}
public class System.Reflection.Metadata.BlobHandle : ValueType {
    internal static int TemplateParameterOffset_AttributeUsageTarget;
    private UInt32 _value;
    public bool IsNil { get; }
    internal bool IsVirtual { get; }
    private ushort VirtualValue { get; }
    private BlobHandle(UInt32 value);
    internal static BlobHandle FromOffset(int heapOffset);
    internal static BlobHandle FromVirtualIndex(VirtualIndex virtualIndex, ushort virtualValue);
    internal void SubstituteTemplateParameters(Byte[] blob);
    public static Handle op_Implicit(BlobHandle handle);
    public static BlobHandle op_Explicit(Handle handle);
    public bool get_IsNil();
    internal int GetHeapOffset();
    internal VirtualIndex GetVirtualIndex();
    internal bool get_IsVirtual();
    private ushort get_VirtualValue();
    public virtual bool Equals(object obj);
    public sealed virtual bool Equals(BlobHandle other);
    public virtual int GetHashCode();
    public static bool op_Equality(BlobHandle left, BlobHandle right);
    public static bool op_Inequality(BlobHandle left, BlobHandle right);
}
[DebuggerDisplayAttribute("{GetDebuggerDisplay(),nq}")]
public class System.Reflection.Metadata.BlobReader : ValueType {
    internal static int InvalidCompressedInteger;
    private static Char[] _nullCharArray;
    private MemoryBlock _block;
    private Byte* _endPointer;
    private Byte* _currentPointer;
    private static UInt32[] s_corEncodeTokenArray;
    public int Length { get; }
    public int Offset { get; }
    public int RemainingBytes { get; }
    public BlobReader(Byte* buffer, int length);
    internal BlobReader(MemoryBlock block);
    private static BlobReader();
    private string GetDebuggerDisplay();
    public int get_Length();
    public int get_Offset();
    public int get_RemainingBytes();
    public void Reset();
    internal bool SeekOffset(int offset);
    internal void SkipBytes(int count);
    internal void Align(byte alignment);
    internal bool TryAlign(byte alignment);
    internal MemoryBlock GetMemoryBlockAt(int offset, int length);
    private static void ThrowOutOfBounds();
    private void CheckBounds(int offset, int byteCount);
    private void CheckBounds(int byteCount);
    private Byte* GetCurrentPointerAndAdvance(int length);
    private Byte* GetCurrentPointerAndAdvance1();
    public bool ReadBoolean();
    public sbyte ReadSByte();
    public byte ReadByte();
    public char ReadChar();
    public short ReadInt16();
    public ushort ReadUInt16();
    public int ReadInt32();
    public UInt32 ReadUInt32();
    public long ReadInt64();
    public ulong ReadUInt64();
    public float ReadSingle();
    public double ReadDouble();
    public SignatureHeader ReadSignatureHeader();
    public string ReadUTF8(int byteCount);
    public string ReadUTF16(int byteCount);
    public Byte[] ReadBytes(int byteCount);
    internal string ReadUtf8NullTerminated();
    private int ReadCompressedIntegerOrInvalid();
    public bool TryReadCompressedInteger(Int32& value);
    public int ReadCompressedInteger();
    public bool TryReadCompressedSignedInteger(Int32& value);
    public int ReadCompressedSignedInteger();
    private static void ThrowInvalidCompressedInteger();
    private static void ThrowInvalidSerializedString();
    public SerializationTypeCode ReadSerializationTypeCode();
    public SignatureTypeCode ReadSignatureTypeCode();
    public string ReadSerializedString();
    public EntityHandle ReadTypeHandle();
}
public class System.Reflection.Metadata.Constant : ValueType {
    private MetadataReader _reader;
    private int _rowId;
    private ConstantHandle Handle { get; }
    public ConstantTypeCode TypeCode { get; }
    public BlobHandle Value { get; }
    public EntityHandle Parent { get; }
    internal Constant(MetadataReader reader, int rowId);
    private ConstantHandle get_Handle();
    public ConstantTypeCode get_TypeCode();
    public BlobHandle get_Value();
    public EntityHandle get_Parent();
}
public class System.Reflection.Metadata.ConstantHandle : ValueType {
    private static UInt32 tokenType;
    private static byte tokenTypeSmall;
    private int _rowId;
    public bool IsNil { get; }
    internal int RowId { get; }
    private ConstantHandle(int rowId);
    internal static ConstantHandle FromRowId(int rowId);
    public static Handle op_Implicit(ConstantHandle handle);
    public static EntityHandle op_Implicit(ConstantHandle handle);
    public static ConstantHandle op_Explicit(Handle handle);
    public static ConstantHandle op_Explicit(EntityHandle handle);
    public bool get_IsNil();
    internal int get_RowId();
    public static bool op_Equality(ConstantHandle left, ConstantHandle right);
    public virtual bool Equals(object obj);
    public sealed virtual bool Equals(ConstantHandle other);
    public virtual int GetHashCode();
    public static bool op_Inequality(ConstantHandle left, ConstantHandle right);
}
public enum System.Reflection.Metadata.ConstantTypeCode : Enum {
    public byte value__;
    public static ConstantTypeCode Invalid;
    public static ConstantTypeCode Boolean;
    public static ConstantTypeCode Char;
    public static ConstantTypeCode SByte;
    public static ConstantTypeCode Byte;
    public static ConstantTypeCode Int16;
    public static ConstantTypeCode UInt16;
    public static ConstantTypeCode Int32;
    public static ConstantTypeCode UInt32;
    public static ConstantTypeCode Int64;
    public static ConstantTypeCode UInt64;
    public static ConstantTypeCode Single;
    public static ConstantTypeCode Double;
    public static ConstantTypeCode String;
    public static ConstantTypeCode NullReference;
}
public class System.Reflection.Metadata.CustomAttribute : ValueType {
    private MetadataReader _reader;
    private UInt32 _treatmentAndRowId;
    private int RowId { get; }
    private CustomAttributeHandle Handle { get; }
    private MethodDefTreatment Treatment { get; }
    public EntityHandle Constructor { get; }
    public EntityHandle Parent { get; }
    public BlobHandle Value { get; }
    internal CustomAttribute(MetadataReader reader, UInt32 treatmentAndRowId);
    private int get_RowId();
    private CustomAttributeHandle get_Handle();
    private MethodDefTreatment get_Treatment();
    public EntityHandle get_Constructor();
    public EntityHandle get_Parent();
    public BlobHandle get_Value();
    private BlobHandle GetProjectedValue();
    private BlobHandle GetProjectedValue(CustomAttributeValueTreatment treatment);
    private static AttributeTargets ProjectAttributeTargetValue(UInt32 rawValue);
}
public class System.Reflection.Metadata.CustomAttributeHandle : ValueType {
    private static UInt32 tokenType;
    private static byte tokenTypeSmall;
    private int _rowId;
    public bool IsNil { get; }
    internal int RowId { get; }
    private CustomAttributeHandle(int rowId);
    internal static CustomAttributeHandle FromRowId(int rowId);
    public static Handle op_Implicit(CustomAttributeHandle handle);
    public static EntityHandle op_Implicit(CustomAttributeHandle handle);
    public static CustomAttributeHandle op_Explicit(Handle handle);
    public static CustomAttributeHandle op_Explicit(EntityHandle handle);
    public bool get_IsNil();
    internal int get_RowId();
    public static bool op_Equality(CustomAttributeHandle left, CustomAttributeHandle right);
    public virtual bool Equals(object obj);
    public sealed virtual bool Equals(CustomAttributeHandle other);
    public virtual int GetHashCode();
    public static bool op_Inequality(CustomAttributeHandle left, CustomAttributeHandle right);
}
public class System.Reflection.Metadata.CustomAttributeHandleCollection : ValueType {
    private MetadataReader _reader;
    private int _firstRowId;
    private int _lastRowId;
    public int Count { get; }
    internal CustomAttributeHandleCollection(MetadataReader reader);
    internal CustomAttributeHandleCollection(MetadataReader reader, EntityHandle handle);
    public sealed virtual int get_Count();
    public Enumerator GetEnumerator();
    private sealed virtual override IEnumerator`1<CustomAttributeHandle> System.Collections.Generic.IEnumerable<System.Reflection.Metadata.CustomAttributeHandle>.GetEnumerator();
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
}
public enum System.Reflection.Metadata.CustomAttributeNamedArgumentKind : Enum {
    public byte value__;
    public static CustomAttributeNamedArgumentKind Field;
    public static CustomAttributeNamedArgumentKind Property;
}
public class System.Reflection.Metadata.DeclarativeSecurityAttribute : ValueType {
    private MetadataReader _reader;
    private int _rowId;
    private DeclarativeSecurityAttributeHandle Handle { get; }
    public DeclarativeSecurityAction Action { get; }
    public EntityHandle Parent { get; }
    public BlobHandle PermissionSet { get; }
    internal DeclarativeSecurityAttribute(MetadataReader reader, int rowId);
    private DeclarativeSecurityAttributeHandle get_Handle();
    public DeclarativeSecurityAction get_Action();
    public EntityHandle get_Parent();
    public BlobHandle get_PermissionSet();
}
public class System.Reflection.Metadata.DeclarativeSecurityAttributeHandle : ValueType {
    private static UInt32 tokenType;
    private static byte tokenTypeSmall;
    private int _rowId;
    public bool IsNil { get; }
    internal int RowId { get; }
    private DeclarativeSecurityAttributeHandle(int rowId);
    internal static DeclarativeSecurityAttributeHandle FromRowId(int rowId);
    public static Handle op_Implicit(DeclarativeSecurityAttributeHandle handle);
    public static EntityHandle op_Implicit(DeclarativeSecurityAttributeHandle handle);
    public static DeclarativeSecurityAttributeHandle op_Explicit(Handle handle);
    public static DeclarativeSecurityAttributeHandle op_Explicit(EntityHandle handle);
    public bool get_IsNil();
    internal int get_RowId();
    public static bool op_Equality(DeclarativeSecurityAttributeHandle left, DeclarativeSecurityAttributeHandle right);
    public virtual bool Equals(object obj);
    public sealed virtual bool Equals(DeclarativeSecurityAttributeHandle other);
    public virtual int GetHashCode();
    public static bool op_Inequality(DeclarativeSecurityAttributeHandle left, DeclarativeSecurityAttributeHandle right);
}
public class System.Reflection.Metadata.DeclarativeSecurityAttributeHandleCollection : ValueType {
    private MetadataReader _reader;
    private int _firstRowId;
    private int _lastRowId;
    public int Count { get; }
    internal DeclarativeSecurityAttributeHandleCollection(MetadataReader reader);
    internal DeclarativeSecurityAttributeHandleCollection(MetadataReader reader, EntityHandle handle);
    public sealed virtual int get_Count();
    public Enumerator GetEnumerator();
    private sealed virtual override IEnumerator`1<DeclarativeSecurityAttributeHandle> System.Collections.Generic.IEnumerable<System.Reflection.Metadata.DeclarativeSecurityAttributeHandle>.GetEnumerator();
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
}
internal class System.Reflection.Metadata.Ecma335.AssemblyOSTableReader : ValueType {
    internal int NumberOfRows;
    private int _OSPlatformIdOffset;
    private int _OSMajorVersionIdOffset;
    private int _OSMinorVersionIdOffset;
    internal int RowSize;
    internal MemoryBlock Block;
    internal AssemblyOSTableReader(int numberOfRows, MemoryBlock containingBlock, int containingBlockOffset);
}
internal class System.Reflection.Metadata.Ecma335.AssemblyProcessorTableReader : ValueType {
    internal int NumberOfRows;
    private int _ProcessorOffset;
    internal int RowSize;
    internal MemoryBlock Block;
    internal AssemblyProcessorTableReader(int numberOfRows, MemoryBlock containingBlock, int containingBlockOffset);
}
internal class System.Reflection.Metadata.Ecma335.AssemblyRefOSTableReader : ValueType {
    internal int NumberOfRows;
    private bool _IsAssemblyRefTableRowRefSizeSmall;
    private int _OSPlatformIdOffset;
    private int _OSMajorVersionIdOffset;
    private int _OSMinorVersionIdOffset;
    private int _AssemblyRefOffset;
    internal int RowSize;
    internal MemoryBlock Block;
    internal AssemblyRefOSTableReader(int numberOfRows, int assemblyRefTableRowRefSize, MemoryBlock containingBlock, int containingBlockOffset);
}
internal class System.Reflection.Metadata.Ecma335.AssemblyRefProcessorTableReader : ValueType {
    internal int NumberOfRows;
    private bool _IsAssemblyRefTableRowSizeSmall;
    private int _ProcessorOffset;
    private int _AssemblyRefOffset;
    internal int RowSize;
    internal MemoryBlock Block;
    internal AssemblyRefProcessorTableReader(int numberOfRows, int assemblyRefTableRowRefSize, MemoryBlock containingBlock, int containingBlockOffset);
}
internal class System.Reflection.Metadata.Ecma335.AssemblyRefTableReader : ValueType {
    internal int NumberOfNonVirtualRows;
    internal int NumberOfVirtualRows;
    private bool _IsStringHeapRefSizeSmall;
    private bool _IsBlobHeapRefSizeSmall;
    private int _MajorVersionOffset;
    private int _MinorVersionOffset;
    private int _BuildNumberOffset;
    private int _RevisionNumberOffset;
    private int _FlagsOffset;
    private int _PublicKeyOrTokenOffset;
    private int _NameOffset;
    private int _CultureOffset;
    private int _HashValueOffset;
    internal int RowSize;
    internal MemoryBlock Block;
    internal AssemblyRefTableReader(int numberOfRows, int stringHeapRefSize, int blobHeapRefSize, MemoryBlock containingBlock, int containingBlockOffset, MetadataKind metadataKind);
    internal Version GetVersion(int rowId);
    internal AssemblyFlags GetFlags(int rowId);
    internal BlobHandle GetPublicKeyOrToken(int rowId);
    internal StringHandle GetName(int rowId);
    internal StringHandle GetCulture(int rowId);
    internal BlobHandle GetHashValue(int rowId);
}
internal class System.Reflection.Metadata.Ecma335.AssemblyTableReader : ValueType {
    internal int NumberOfRows;
    private bool _IsStringHeapRefSizeSmall;
    private bool _IsBlobHeapRefSizeSmall;
    private int _HashAlgIdOffset;
    private int _MajorVersionOffset;
    private int _MinorVersionOffset;
    private int _BuildNumberOffset;
    private int _RevisionNumberOffset;
    private int _FlagsOffset;
    private int _PublicKeyOffset;
    private int _NameOffset;
    private int _CultureOffset;
    internal int RowSize;
    internal MemoryBlock Block;
    internal AssemblyTableReader(int numberOfRows, int stringHeapRefSize, int blobHeapRefSize, MemoryBlock containingBlock, int containingBlockOffset);
    internal AssemblyHashAlgorithm GetHashAlgorithm();
    internal Version GetVersion();
    internal AssemblyFlags GetFlags();
    internal BlobHandle GetPublicKey();
    internal StringHandle GetName();
    internal StringHandle GetCulture();
}
internal class System.Reflection.Metadata.Ecma335.BlobStreamReader : ValueType {
    private VirtualHeapBlobTable _lazyVirtualHeapBlobs;
    private static Byte[][] s_virtualHeapBlobs;
    internal MemoryBlock Block;
    internal BlobStreamReader(MemoryBlock block, MetadataKind metadataKind);
    internal Byte[] GetBytes(BlobHandle handle);
    internal BlobReader GetBlobReader(BlobHandle handle);
    internal BlobHandle GetNextHandle(BlobHandle handle);
    internal Byte[] GetVirtualBlobArray(BlobHandle handle, bool unique);
}
internal class System.Reflection.Metadata.Ecma335.ClassLayoutTableReader : ValueType {
    internal int NumberOfRows;
    private bool _IsTypeDefTableRowRefSizeSmall;
    private int _PackagingSizeOffset;
    private int _ClassSizeOffset;
    private int _ParentOffset;
    internal int RowSize;
    internal MemoryBlock Block;
    internal ClassLayoutTableReader(int numberOfRows, bool declaredSorted, int typeDefTableRowRefSize, MemoryBlock containingBlock, int containingBlockOffset);
    internal TypeDefinitionHandle GetParent(int rowId);
    internal ushort GetPackingSize(int rowId);
    internal UInt32 GetClassSize(int rowId);
    internal int FindRow(TypeDefinitionHandle typeDef);
    private bool CheckSorted();
}
internal class System.Reflection.Metadata.Ecma335.ConstantTableReader : ValueType {
    internal int NumberOfRows;
    private bool _IsHasConstantRefSizeSmall;
    private bool _IsBlobHeapRefSizeSmall;
    private int _TypeOffset;
    private int _ParentOffset;
    private int _ValueOffset;
    internal int RowSize;
    internal MemoryBlock Block;
    internal ConstantTableReader(int numberOfRows, bool declaredSorted, int hasConstantRefSize, int blobHeapRefSize, MemoryBlock containingBlock, int containingBlockOffset);
    internal ConstantTypeCode GetType(ConstantHandle handle);
    internal BlobHandle GetValue(ConstantHandle handle);
    internal EntityHandle GetParent(ConstantHandle handle);
    internal ConstantHandle FindConstant(EntityHandle parentHandle);
    private bool CheckSorted();
}
internal static class System.Reflection.Metadata.Ecma335.COR20Constants : object {
    internal static int SizeOfCorHeader;
    internal static UInt32 COR20MetadataSignature;
    internal static int MinimumSizeofMetadataHeader;
    internal static int SizeofStorageHeader;
    internal static int MinimumSizeofStreamHeader;
    internal static string StringStreamName;
    internal static string BlobStreamName;
    internal static string GUIDStreamName;
    internal static string UserStringStreamName;
    internal static string CompressedMetadataTableStreamName;
    internal static string UncompressedMetadataTableStreamName;
    internal static string MinimalDeltaMetadataTableStreamName;
    internal static int LargeStreamHeapSize;
}
internal enum System.Reflection.Metadata.Ecma335.CorElementType : Enum {
    public byte value__;
    public static CorElementType Invalid;
    public static CorElementType ELEMENT_TYPE_VOID;
    public static CorElementType ELEMENT_TYPE_BOOLEAN;
    public static CorElementType ELEMENT_TYPE_CHAR;
    public static CorElementType ELEMENT_TYPE_I1;
    public static CorElementType ELEMENT_TYPE_U1;
    public static CorElementType ELEMENT_TYPE_I2;
    public static CorElementType ELEMENT_TYPE_U2;
    public static CorElementType ELEMENT_TYPE_I4;
    public static CorElementType ELEMENT_TYPE_U4;
    public static CorElementType ELEMENT_TYPE_I8;
    public static CorElementType ELEMENT_TYPE_U8;
    public static CorElementType ELEMENT_TYPE_R4;
    public static CorElementType ELEMENT_TYPE_R8;
    public static CorElementType ELEMENT_TYPE_STRING;
    public static CorElementType ELEMENT_TYPE_PTR;
    public static CorElementType ELEMENT_TYPE_BYREF;
    public static CorElementType ELEMENT_TYPE_VALUETYPE;
    public static CorElementType ELEMENT_TYPE_CLASS;
    public static CorElementType ELEMENT_TYPE_VAR;
    public static CorElementType ELEMENT_TYPE_ARRAY;
    public static CorElementType ELEMENT_TYPE_GENERICINST;
    public static CorElementType ELEMENT_TYPE_TYPEDBYREF;
    public static CorElementType ELEMENT_TYPE_I;
    public static CorElementType ELEMENT_TYPE_U;
    public static CorElementType ELEMENT_TYPE_FNPTR;
    public static CorElementType ELEMENT_TYPE_OBJECT;
    public static CorElementType ELEMENT_TYPE_SZARRAY;
    public static CorElementType ELEMENT_TYPE_MVAR;
    public static CorElementType ELEMENT_TYPE_CMOD_REQD;
    public static CorElementType ELEMENT_TYPE_CMOD_OPT;
    public static CorElementType ELEMENT_TYPE_HANDLE;
    public static CorElementType ELEMENT_TYPE_SENTINEL;
    public static CorElementType ELEMENT_TYPE_PINNED;
}
internal class System.Reflection.Metadata.Ecma335.CustomAttributeTableReader : ValueType {
    internal int NumberOfRows;
    private bool _IsHasCustomAttributeRefSizeSmall;
    private bool _IsCustomAttributeTypeRefSizeSmall;
    private bool _IsBlobHeapRefSizeSmall;
    private int _ParentOffset;
    private int _TypeOffset;
    private int _ValueOffset;
    internal int RowSize;
    internal MemoryBlock Block;
    internal Int32[] PtrTable;
    internal CustomAttributeTableReader(int numberOfRows, bool declaredSorted, int hasCustomAttributeRefSize, int customAttributeTypeRefSize, int blobHeapRefSize, MemoryBlock containingBlock, int containingBlockOffset);
    internal EntityHandle GetParent(CustomAttributeHandle handle);
    internal EntityHandle GetConstructor(CustomAttributeHandle handle);
    internal BlobHandle GetValue(CustomAttributeHandle handle);
    private UInt32 GetParentTag(int index);
    internal void GetAttributeRange(EntityHandle parentHandle, Int32& firstImplRowId, Int32& lastImplRowId);
    private bool CheckSorted();
}
[FlagsAttribute]
internal enum System.Reflection.Metadata.Ecma335.CustomAttributeTreatment : Enum {
    public byte value__;
    public static CustomAttributeTreatment None;
    public static CustomAttributeTreatment WinMD;
}
internal static class System.Reflection.Metadata.Ecma335.CustomAttributeTypeTag : object {
    internal static int NumberOfBits;
    internal static int LargeRowSize;
    internal static UInt32 MethodDef;
    internal static UInt32 MemberRef;
    internal static UInt32 TagMask;
    internal static ulong TagToTokenTypeByteVector;
    internal static TableMask TablesReferenced;
    internal static EntityHandle ConvertToHandle(UInt32 customAttributeType);
}
[FlagsAttribute]
internal enum System.Reflection.Metadata.Ecma335.CustomAttributeValueTreatment : Enum {
    public byte value__;
    public static CustomAttributeValueTreatment None;
    public static CustomAttributeValueTreatment AttributeUsageAllowSingle;
    public static CustomAttributeValueTreatment AttributeUsageAllowMultiple;
    public static CustomAttributeValueTreatment AttributeUsageVersionAttribute;
    public static CustomAttributeValueTreatment AttributeUsageDeprecatedAttribute;
}
internal class System.Reflection.Metadata.Ecma335.DeclSecurityTableReader : ValueType {
    internal int NumberOfRows;
    private bool _IsHasDeclSecurityRefSizeSmall;
    private bool _IsBlobHeapRefSizeSmall;
    private int _ActionOffset;
    private int _ParentOffset;
    private int _PermissionSetOffset;
    internal int RowSize;
    internal MemoryBlock Block;
    internal DeclSecurityTableReader(int numberOfRows, bool declaredSorted, int hasDeclSecurityRefSize, int blobHeapRefSize, MemoryBlock containingBlock, int containingBlockOffset);
    internal DeclarativeSecurityAction GetAction(int rowId);
    internal EntityHandle GetParent(int rowId);
    internal BlobHandle GetPermissionSet(int rowId);
    internal void GetAttributeRange(EntityHandle parentToken, Int32& firstImplRowId, Int32& lastImplRowId);
    private bool CheckSorted();
}
public class System.Reflection.Metadata.Ecma335.EditAndContinueLogEntry : ValueType {
    private EntityHandle _handle;
    private EditAndContinueOperation _operation;
    public EntityHandle Handle { get; }
    public EditAndContinueOperation Operation { get; }
    public EditAndContinueLogEntry(EntityHandle handle, EditAndContinueOperation operation);
    public EntityHandle get_Handle();
    public EditAndContinueOperation get_Operation();
    public virtual bool Equals(object obj);
    public sealed virtual bool Equals(EditAndContinueLogEntry other);
    public virtual int GetHashCode();
}
public enum System.Reflection.Metadata.Ecma335.EditAndContinueOperation : Enum {
    public int value__;
    public static EditAndContinueOperation Default;
    public static EditAndContinueOperation AddMethod;
    public static EditAndContinueOperation AddField;
    public static EditAndContinueOperation AddParameter;
    public static EditAndContinueOperation AddProperty;
    public static EditAndContinueOperation AddEvent;
}
internal class System.Reflection.Metadata.Ecma335.EnCLogTableReader : ValueType {
    internal int NumberOfRows;
    private int _TokenOffset;
    private int _FuncCodeOffset;
    internal int RowSize;
    internal MemoryBlock Block;
    internal EnCLogTableReader(int numberOfRows, MemoryBlock containingBlock, int containingBlockOffset, MetadataStreamKind metadataStreamKind);
    internal UInt32 GetToken(int rowId);
    internal EditAndContinueOperation GetFuncCode(int rowId);
}
internal class System.Reflection.Metadata.Ecma335.EnCMapTableReader : ValueType {
    internal int NumberOfRows;
    private int _TokenOffset;
    internal int RowSize;
    internal MemoryBlock Block;
    internal EnCMapTableReader(int numberOfRows, MemoryBlock containingBlock, int containingBlockOffset);
    internal UInt32 GetToken(int rowId);
}
internal class System.Reflection.Metadata.Ecma335.EventMapTableReader : ValueType {
    internal int NumberOfRows;
    private bool _IsTypeDefTableRowRefSizeSmall;
    private bool _IsEventRefSizeSmall;
    private int _ParentOffset;
    private int _EventListOffset;
    internal int RowSize;
    internal MemoryBlock Block;
    internal EventMapTableReader(int numberOfRows, int typeDefTableRowRefSize, int eventRefSize, MemoryBlock containingBlock, int containingBlockOffset);
    internal int FindEventMapRowIdFor(TypeDefinitionHandle typeDef);
    internal TypeDefinitionHandle GetParentType(int rowId);
    internal int GetEventListStartFor(int rowId);
}
internal class System.Reflection.Metadata.Ecma335.EventPtrTableReader : ValueType {
    internal int NumberOfRows;
    private bool _IsEventTableRowRefSizeSmall;
    private int _EventOffset;
    internal int RowSize;
    internal MemoryBlock Block;
    internal EventPtrTableReader(int numberOfRows, int eventTableRowRefSize, MemoryBlock containingBlock, int containingBlockOffset);
    internal EventDefinitionHandle GetEventFor(int rowId);
}
internal class System.Reflection.Metadata.Ecma335.EventTableReader : ValueType {
    internal int NumberOfRows;
    private bool _IsTypeDefOrRefRefSizeSmall;
    private bool _IsStringHeapRefSizeSmall;
    private int _FlagsOffset;
    private int _NameOffset;
    private int _EventTypeOffset;
    internal int RowSize;
    internal MemoryBlock Block;
    internal EventTableReader(int numberOfRows, int typeDefOrRefRefSize, int stringHeapRefSize, MemoryBlock containingBlock, int containingBlockOffset);
    internal EventAttributes GetFlags(EventDefinitionHandle handle);
    internal StringHandle GetName(EventDefinitionHandle handle);
    internal EntityHandle GetEventType(EventDefinitionHandle handle);
}
[ExtensionAttribute]
public static class System.Reflection.Metadata.Ecma335.ExportedTypeExtensions : object {
    [ExtensionAttribute]
public static int GetTypeDefinitionId(ExportedType exportedType);
}
internal class System.Reflection.Metadata.Ecma335.ExportedTypeTableReader : ValueType {
    internal int NumberOfRows;
    private bool _IsImplementationRefSizeSmall;
    private bool _IsStringHeapRefSizeSmall;
    private int _FlagsOffset;
    private int _TypeDefIdOffset;
    private int _TypeNameOffset;
    private int _TypeNamespaceOffset;
    private int _ImplementationOffset;
    internal int RowSize;
    internal MemoryBlock Block;
    internal ExportedTypeTableReader(int numberOfRows, int implementationRefSize, int stringHeapRefSize, MemoryBlock containingBlock, int containingBlockOffset);
    internal StringHandle GetTypeName(int rowId);
    internal StringHandle GetTypeNamespaceString(int rowId);
    internal NamespaceDefinitionHandle GetTypeNamespace(int rowId);
    internal EntityHandle GetImplementation(int rowId);
    internal TypeAttributes GetFlags(int rowId);
    internal int GetTypeDefId(int rowId);
    internal int GetNamespace(int rowId);
}
[FlagsAttribute]
internal enum System.Reflection.Metadata.Ecma335.FieldDefTreatment : Enum {
    public byte value__;
    public static FieldDefTreatment None;
    public static FieldDefTreatment EnumValue;
}
internal class System.Reflection.Metadata.Ecma335.FieldLayoutTableReader : ValueType {
    internal int NumberOfRows;
    private bool _IsFieldTableRowRefSizeSmall;
    private int _OffsetOffset;
    private int _FieldOffset;
    internal int RowSize;
    internal MemoryBlock Block;
    internal FieldLayoutTableReader(int numberOfRows, bool declaredSorted, int fieldTableRowRefSize, MemoryBlock containingBlock, int containingBlockOffset);
    internal int FindFieldLayoutRowId(FieldDefinitionHandle handle);
    internal UInt32 GetOffset(int rowId);
    internal FieldDefinitionHandle GetField(int rowId);
    private bool CheckSorted();
}
internal class System.Reflection.Metadata.Ecma335.FieldMarshalTableReader : ValueType {
    internal int NumberOfRows;
    private bool _IsHasFieldMarshalRefSizeSmall;
    private bool _IsBlobHeapRefSizeSmall;
    private int _ParentOffset;
    private int _NativeTypeOffset;
    internal int RowSize;
    internal MemoryBlock Block;
    internal FieldMarshalTableReader(int numberOfRows, bool declaredSorted, int hasFieldMarshalRefSize, int blobHeapRefSize, MemoryBlock containingBlock, int containingBlockOffset);
    internal EntityHandle GetParent(int rowId);
    internal BlobHandle GetNativeType(int rowId);
    internal int FindFieldMarshalRowId(EntityHandle handle);
    private bool CheckSorted();
}
internal class System.Reflection.Metadata.Ecma335.FieldPtrTableReader : ValueType {
    internal int NumberOfRows;
    private bool _IsFieldTableRowRefSizeSmall;
    private int _FieldOffset;
    internal int RowSize;
    internal MemoryBlock Block;
    internal FieldPtrTableReader(int numberOfRows, int fieldTableRowRefSize, MemoryBlock containingBlock, int containingBlockOffset);
    internal FieldDefinitionHandle GetFieldFor(int rowId);
    internal int GetRowIdForFieldDefRow(int fieldDefRowId);
}
internal class System.Reflection.Metadata.Ecma335.FieldRVATableReader : ValueType {
    internal int NumberOfRows;
    private bool _IsFieldTableRowRefSizeSmall;
    private int _RVAOffset;
    private int _FieldOffset;
    internal int RowSize;
    internal MemoryBlock Block;
    internal FieldRVATableReader(int numberOfRows, bool declaredSorted, int fieldTableRowRefSize, MemoryBlock containingBlock, int containingBlockOffset);
    internal int GetRva(int rowId);
    internal int FindFieldRvaRowId(int fieldDefRowId);
    private bool CheckSorted();
}
internal class System.Reflection.Metadata.Ecma335.FieldTableReader : ValueType {
    internal int NumberOfRows;
    private bool _IsStringHeapRefSizeSmall;
    private bool _IsBlobHeapRefSizeSmall;
    private int _FlagsOffset;
    private int _NameOffset;
    private int _SignatureOffset;
    internal int RowSize;
    internal MemoryBlock Block;
    internal FieldTableReader(int numberOfRows, int stringHeapRefSize, int blobHeapRefSize, MemoryBlock containingBlock, int containingBlockOffset);
    internal StringHandle GetName(FieldDefinitionHandle handle);
    internal FieldAttributes GetFlags(FieldDefinitionHandle handle);
    internal BlobHandle GetSignature(FieldDefinitionHandle handle);
}
internal class System.Reflection.Metadata.Ecma335.FileTableReader : ValueType {
    internal int NumberOfRows;
    private bool _IsStringHeapRefSizeSmall;
    private bool _IsBlobHeapRefSizeSmall;
    private int _FlagsOffset;
    private int _NameOffset;
    private int _HashValueOffset;
    internal int RowSize;
    internal MemoryBlock Block;
    internal FileTableReader(int numberOfRows, int stringHeapRefSize, int blobHeapRefSize, MemoryBlock containingBlock, int containingBlockOffset);
    internal BlobHandle GetHashValue(AssemblyFileHandle handle);
    internal UInt32 GetFlags(AssemblyFileHandle handle);
    internal StringHandle GetName(AssemblyFileHandle handle);
}
internal class System.Reflection.Metadata.Ecma335.GenericParamConstraintTableReader : ValueType {
    internal int NumberOfRows;
    private bool _IsGenericParamTableRowRefSizeSmall;
    private bool _IsTypeDefOrRefRefSizeSmall;
    private int _OwnerOffset;
    private int _ConstraintOffset;
    internal int RowSize;
    internal MemoryBlock Block;
    internal GenericParamConstraintTableReader(int numberOfRows, bool declaredSorted, int genericParamTableRowRefSize, int typeDefOrRefRefSize, MemoryBlock containingBlock, int containingBlockOffset);
    internal GenericParameterConstraintHandleCollection FindConstraintsForGenericParam(GenericParameterHandle genericParameter);
    private bool CheckSorted();
    internal EntityHandle GetConstraint(GenericParameterConstraintHandle handle);
    internal GenericParameterHandle GetOwner(GenericParameterConstraintHandle handle);
}
internal class System.Reflection.Metadata.Ecma335.GenericParamTableReader : ValueType {
    internal int NumberOfRows;
    private bool _IsTypeOrMethodDefRefSizeSmall;
    private bool _IsStringHeapRefSizeSmall;
    private int _NumberOffset;
    private int _FlagsOffset;
    private int _OwnerOffset;
    private int _NameOffset;
    internal int RowSize;
    internal MemoryBlock Block;
    internal GenericParamTableReader(int numberOfRows, bool declaredSorted, int typeOrMethodDefRefSize, int stringHeapRefSize, MemoryBlock containingBlock, int containingBlockOffset);
    internal ushort GetNumber(GenericParameterHandle handle);
    internal GenericParameterAttributes GetFlags(GenericParameterHandle handle);
    internal StringHandle GetName(GenericParameterHandle handle);
    internal EntityHandle GetOwner(GenericParameterHandle handle);
    internal GenericParameterHandleCollection FindGenericParametersForType(TypeDefinitionHandle typeDef);
    internal GenericParameterHandleCollection FindGenericParametersForMethod(MethodDefinitionHandle methodDef);
    private int BinarySearchTag(UInt32 searchCodedTag, UInt16& genericParamCount);
    private bool CheckSorted();
}
internal class System.Reflection.Metadata.Ecma335.GuidStreamReader : ValueType {
    internal static int GuidSize;
    internal MemoryBlock Block;
    public GuidStreamReader(MemoryBlock block);
    internal Guid GetGuid(GuidHandle handle);
}
internal static class System.Reflection.Metadata.Ecma335.HandleType : object {
    internal static UInt32 Module;
    internal static UInt32 TypeRef;
    internal static UInt32 TypeDef;
    internal static UInt32 FieldDef;
    internal static UInt32 MethodDef;
    internal static UInt32 ParamDef;
    internal static UInt32 InterfaceImpl;
    internal static UInt32 MemberRef;
    internal static UInt32 Constant;
    internal static UInt32 CustomAttribute;
    internal static UInt32 DeclSecurity;
    internal static UInt32 Signature;
    internal static UInt32 EventMap;
    internal static UInt32 Event;
    internal static UInt32 PropertyMap;
    internal static UInt32 Property;
    internal static UInt32 MethodSemantics;
    internal static UInt32 MethodImpl;
    internal static UInt32 ModuleRef;
    internal static UInt32 TypeSpec;
    internal static UInt32 Assembly;
    internal static UInt32 AssemblyRef;
    internal static UInt32 File;
    internal static UInt32 ExportedType;
    internal static UInt32 ManifestResource;
    internal static UInt32 NestedClass;
    internal static UInt32 GenericParam;
    internal static UInt32 MethodSpec;
    internal static UInt32 GenericParamConstraint;
    internal static UInt32 UserString;
    internal static UInt32 Blob;
    internal static UInt32 Guid;
    internal static UInt32 String;
    internal static UInt32 DotTerminatedString;
    internal static UInt32 ReservedString1;
    internal static UInt32 ReservedString2;
    internal static UInt32 VirtualString;
    internal static UInt32 WinRTPrefixedString;
    internal static UInt32 ReservedVirtualString1;
    internal static UInt32 ReservedVirtualString2;
    internal static UInt32 Namespace;
    internal static UInt32 SyntheticNamespace;
    internal static UInt32 ReservedNamespace1;
    internal static UInt32 ReservedNamespace2;
    internal static UInt32 ReservedVirtualNamespace1;
    internal static UInt32 ReservedVirtualNamespace2;
    internal static UInt32 ReservedVirtualNamespace3;
    internal static UInt32 ReservedVirtualNamespace4;
    internal static UInt32 StringHeapTypeMask;
    internal static UInt32 StringOrNamespaceMask;
    internal static UInt32 HeapMask;
    internal static UInt32 TypeMask;
    internal static UInt32 VirtualBit;
    public static HandleKind ToHandleKind(UInt32 handleType);
}
internal static class System.Reflection.Metadata.Ecma335.HasConstantTag : object {
    internal static int NumberOfBits;
    internal static int LargeRowSize;
    internal static UInt32 Field;
    internal static UInt32 Param;
    internal static UInt32 Property;
    internal static UInt32 TagMask;
    internal static TableMask TablesReferenced;
    internal static UInt32 TagToTokenTypeByteVector;
    internal static EntityHandle ConvertToHandle(UInt32 hasConstant);
    internal static UInt32 ConvertToTag(EntityHandle token);
}
internal static class System.Reflection.Metadata.Ecma335.HasCustomAttributeTag : object {
    internal static int NumberOfBits;
    internal static int LargeRowSize;
    internal static UInt32 MethodDef;
    internal static UInt32 Field;
    internal static UInt32 TypeRef;
    internal static UInt32 TypeDef;
    internal static UInt32 Param;
    internal static UInt32 InterfaceImpl;
    internal static UInt32 MemberRef;
    internal static UInt32 Module;
    internal static UInt32 DeclSecurity;
    internal static UInt32 Property;
    internal static UInt32 Event;
    internal static UInt32 StandAloneSig;
    internal static UInt32 ModuleRef;
    internal static UInt32 TypeSpec;
    internal static UInt32 Assembly;
    internal static UInt32 AssemblyRef;
    internal static UInt32 File;
    internal static UInt32 ExportedType;
    internal static UInt32 ManifestResource;
    internal static UInt32 GenericParam;
    internal static UInt32 GenericParamConstraint;
    internal static UInt32 MethodSpec;
    internal static UInt32 TagMask;
    internal static UInt32 InvalidTokenType;
    internal static TableMask TablesReferenced;
    internal static UInt32[] TagToTokenTypeArray;
    private static HasCustomAttributeTag();
    internal static EntityHandle ConvertToHandle(UInt32 hasCustomAttribute);
    internal static UInt32 ConvertToTag(EntityHandle handle);
}
internal static class System.Reflection.Metadata.Ecma335.HasDeclSecurityTag : object {
    internal static int NumberOfBits;
    internal static int LargeRowSize;
    internal static UInt32 TypeDef;
    internal static UInt32 MethodDef;
    internal static UInt32 Assembly;
    internal static UInt32 TagMask;
    internal static TableMask TablesReferenced;
    internal static UInt32 TagToTokenTypeByteVector;
    internal static EntityHandle ConvertToHandle(UInt32 hasDeclSecurity);
    internal static UInt32 ConvertToTag(EntityHandle handle);
}
internal static class System.Reflection.Metadata.Ecma335.HasFieldMarshalTag : object {
    internal static int NumberOfBits;
    internal static int LargeRowSize;
    internal static UInt32 Field;
    internal static UInt32 Param;
    internal static UInt32 TagMask;
    internal static TableMask TablesReferenced;
    internal static UInt32 TagToTokenTypeByteVector;
    internal static EntityHandle ConvertToHandle(UInt32 hasFieldMarshal);
    internal static UInt32 ConvertToTag(EntityHandle handle);
}
internal static class System.Reflection.Metadata.Ecma335.HasSemanticsTag : object {
    internal static int NumberOfBits;
    internal static int LargeRowSize;
    internal static UInt32 Event;
    internal static UInt32 Property;
    internal static UInt32 TagMask;
    internal static TableMask TablesReferenced;
    internal static UInt32 TagToTokenTypeByteVector;
    internal static EntityHandle ConvertToHandle(UInt32 hasSemantic);
    internal static UInt32 ConvertEventHandleToTag(EventDefinitionHandle eventDef);
    internal static UInt32 ConvertPropertyHandleToTag(PropertyDefinitionHandle propertyDef);
}
internal static class System.Reflection.Metadata.Ecma335.HeapHandleType : object {
    internal static int OffsetBitCount;
    internal static UInt32 OffsetMask;
    internal static UInt32 VirtualBit;
    internal static UInt32 NonVirtualTypeMask;
    internal static UInt32 TypeMask;
    internal static bool IsValidHeapOffset(UInt32 offset);
}
public enum System.Reflection.Metadata.Ecma335.HeapIndex : Enum {
    public int value__;
    public static HeapIndex UserString;
    public static HeapIndex String;
    public static HeapIndex Blob;
    public static HeapIndex Guid;
}
internal static class System.Reflection.Metadata.Ecma335.HeapIndexExtensions : object {
    internal static int Count;
}
internal enum System.Reflection.Metadata.Ecma335.HeapSizeFlag : Enum {
    public byte value__;
    public static HeapSizeFlag StringHeapLarge;
    public static HeapSizeFlag GuidHeapLarge;
    public static HeapSizeFlag BlobHeapLarge;
    public static HeapSizeFlag EnCDeltas;
    public static HeapSizeFlag DeletedMarks;
}
internal static class System.Reflection.Metadata.Ecma335.ImplementationTag : object {
    internal static int NumberOfBits;
    internal static int LargeRowSize;
    internal static UInt32 File;
    internal static UInt32 AssemblyRef;
    internal static UInt32 ExportedType;
    internal static UInt32 TagMask;
    internal static UInt32 TagToTokenTypeByteVector;
    internal static TableMask TablesReferenced;
    internal static EntityHandle ConvertToHandle(UInt32 implementation);
}
internal class System.Reflection.Metadata.Ecma335.ImplMapTableReader : ValueType {
    internal int NumberOfRows;
    private bool _IsModuleRefTableRowRefSizeSmall;
    private bool _IsMemberForwardRowRefSizeSmall;
    private bool _IsStringHeapRefSizeSmall;
    private int _FlagsOffset;
    private int _MemberForwardedOffset;
    private int _ImportNameOffset;
    private int _ImportScopeOffset;
    internal int RowSize;
    internal MemoryBlock Block;
    internal ImplMapTableReader(int numberOfRows, bool declaredSorted, int moduleRefTableRowRefSize, int memberForwardedRefSize, int stringHeapRefSize, MemoryBlock containingBlock, int containingBlockOffset);
    internal MethodImport GetImport(int rowId);
    internal EntityHandle GetMemberForwarded(int rowId);
    internal int FindImplForMethod(MethodDefinitionHandle methodDef);
    private int BinarySearchTag(UInt32 searchCodedTag);
    private bool CheckSorted();
}
internal class System.Reflection.Metadata.Ecma335.InterfaceImplTableReader : ValueType {
    internal int NumberOfRows;
    private bool _IsTypeDefTableRowRefSizeSmall;
    private bool _IsTypeDefOrRefRefSizeSmall;
    private int _ClassOffset;
    private int _InterfaceOffset;
    internal int RowSize;
    internal MemoryBlock Block;
    internal InterfaceImplTableReader(int numberOfRows, bool declaredSorted, int typeDefTableRowRefSize, int typeDefOrRefRefSize, MemoryBlock containingBlock, int containingBlockOffset);
    private bool CheckSorted();
    internal void GetInterfaceImplRange(TypeDefinitionHandle typeDef, Int32& firstImplRowId, Int32& lastImplRowId);
    internal EntityHandle GetInterface(int rowId);
}
internal class System.Reflection.Metadata.Ecma335.ManifestResourceTableReader : ValueType {
    internal int NumberOfRows;
    private bool _IsImplementationRefSizeSmall;
    private bool _IsStringHeapRefSizeSmall;
    private int _OffsetOffset;
    private int _FlagsOffset;
    private int _NameOffset;
    private int _ImplementationOffset;
    internal int RowSize;
    internal MemoryBlock Block;
    internal ManifestResourceTableReader(int numberOfRows, int implementationRefSize, int stringHeapRefSize, MemoryBlock containingBlock, int containingBlockOffset);
    internal StringHandle GetName(ManifestResourceHandle handle);
    internal EntityHandle GetImplementation(ManifestResourceHandle handle);
    internal UInt32 GetOffset(ManifestResourceHandle handle);
    internal ManifestResourceAttributes GetFlags(ManifestResourceHandle handle);
}
internal static class System.Reflection.Metadata.Ecma335.MemberForwardedTag : object {
    internal static int NumberOfBits;
    internal static int LargeRowSize;
    internal static UInt32 Field;
    internal static UInt32 MethodDef;
    internal static UInt32 TagMask;
    internal static TableMask TablesReferenced;
    internal static UInt32 TagToTokenTypeByteVector;
    internal static EntityHandle ConvertToHandle(UInt32 memberForwarded);
    internal static UInt32 ConvertMethodDefToTag(MethodDefinitionHandle methodDef);
}
internal static class System.Reflection.Metadata.Ecma335.MemberRefParentTag : object {
    internal static int NumberOfBits;
    internal static int LargeRowSize;
    internal static UInt32 TypeDef;
    internal static UInt32 TypeRef;
    internal static UInt32 ModuleRef;
    internal static UInt32 MethodDef;
    internal static UInt32 TypeSpec;
    internal static UInt32 TagMask;
    internal static TableMask TablesReferenced;
    internal static ulong TagToTokenTypeByteVector;
    internal static EntityHandle ConvertToHandle(UInt32 memberRef);
}
internal class System.Reflection.Metadata.Ecma335.MemberRefTableReader : ValueType {
    internal int NumberOfRows;
    private bool _IsMemberRefParentRefSizeSmall;
    private bool _IsStringHeapRefSizeSmall;
    private bool _IsBlobHeapRefSizeSmall;
    private int _ClassOffset;
    private int _NameOffset;
    private int _SignatureOffset;
    internal int RowSize;
    internal MemoryBlock Block;
    internal MemberRefTableReader(int numberOfRows, int memberRefParentRefSize, int stringHeapRefSize, int blobHeapRefSize, MemoryBlock containingBlock, int containingBlockOffset);
    internal BlobHandle GetSignature(MemberReferenceHandle handle);
    internal StringHandle GetName(MemberReferenceHandle handle);
    internal EntityHandle GetClass(MemberReferenceHandle handle);
}
[FlagsAttribute]
internal enum System.Reflection.Metadata.Ecma335.MemberRefTreatment : Enum {
    public byte value__;
    public static MemberRefTreatment None;
    public static MemberRefTreatment Dispose;
}
public class System.Reflection.Metadata.Ecma335.MetadataAggregator : object {
    private ImmutableArray`1<ImmutableArray`1<int>> _heapSizes;
    private ImmutableArray`1<ImmutableArray`1<RowCounts>> _rowCounts;
    public MetadataAggregator(MetadataReader baseReader, IReadOnlyList`1<MetadataReader> deltaReaders);
    public MetadataAggregator(IReadOnlyList`1<int> baseTableRowCounts, IReadOnlyList`1<int> baseHeapSizes, IReadOnlyList`1<MetadataReader> deltaReaders);
    private MetadataAggregator(MetadataReader baseReader, IReadOnlyList`1<int> baseTableRowCounts, IReadOnlyList`1<int> baseHeapSizes, IReadOnlyList`1<MetadataReader> deltaReaders);
    internal MetadataAggregator(RowCounts[][] rowCounts, Int32[][] heapSizes);
    private static void CalculateBaseCounts(MetadataReader baseReader, IReadOnlyList`1& baseTableRowCounts, IReadOnlyList`1& baseHeapSizes);
    private static ImmutableArray`1<ImmutableArray`1<int>> CalculateHeapSizes(IReadOnlyList`1<int> baseSizes, IReadOnlyList`1<MetadataReader> deltaReaders);
    private static ImmutableArray`1<ImmutableArray`1<RowCounts>> CalculateRowCounts(IReadOnlyList`1<int> baseRowCounts, IReadOnlyList`1<MetadataReader> deltaReaders);
    private static ImmutableArray`1<ImmutableArray`1<T>> ToImmutable(T[][] array);
    internal static RowCounts[][] GetBaseRowCounts(IReadOnlyList`1<int> baseRowCounts, int generations);
    internal static void CalculateDeltaRowCountsForGeneration(RowCounts[][] rowCounts, int generation, EnCMapTableReader& encMapTable);
    public Handle GetGenerationHandle(Handle handle, Int32& generation);
}
internal class System.Reflection.Metadata.Ecma335.MetadataHeader : ValueType {
    internal UInt32 Signature;
    internal ushort MajorVersion;
    internal ushort MinorVersion;
    internal UInt32 ExtraData;
    internal int VersionStringSize;
    internal string VersionString;
}
[ExtensionAttribute]
public static class System.Reflection.Metadata.Ecma335.MetadataReaderExtensions : object {
    [ExtensionAttribute]
public static int GetTableRowCount(MetadataReader reader, TableIndex tableIndex);
    [ExtensionAttribute]
public static int GetTableRowSize(MetadataReader reader, TableIndex tableIndex);
    [ExtensionAttribute]
public static int GetTableMetadataOffset(MetadataReader reader, TableIndex tableIndex);
    [ExtensionAttribute]
private static MemoryBlock GetTableMetadataBlock(MetadataReader reader, TableIndex tableIndex);
    [ExtensionAttribute]
public static int GetHeapSize(MetadataReader reader, HeapIndex heapIndex);
    [ExtensionAttribute]
public static int GetHeapMetadataOffset(MetadataReader reader, HeapIndex heapIndex);
    [ExtensionAttribute]
private static MemoryBlock GetMetadataBlock(MetadataReader reader, HeapIndex heapIndex);
    [ExtensionAttribute]
public static UserStringHandle GetNextHandle(MetadataReader reader, UserStringHandle handle);
    [ExtensionAttribute]
public static BlobHandle GetNextHandle(MetadataReader reader, BlobHandle handle);
    [ExtensionAttribute]
public static StringHandle GetNextHandle(MetadataReader reader, StringHandle handle);
    [ExtensionAttribute]
public static IEnumerable`1<EditAndContinueLogEntry> GetEditAndContinueLogEntries(MetadataReader reader);
    [ExtensionAttribute]
public static IEnumerable`1<EntityHandle> GetEditAndContinueMapEntries(MetadataReader reader);
    [ExtensionAttribute]
public static IEnumerable`1<TypeDefinitionHandle> GetTypesWithProperties(MetadataReader reader);
    [ExtensionAttribute]
public static IEnumerable`1<TypeDefinitionHandle> GetTypesWithEvents(MetadataReader reader);
}
internal static class System.Reflection.Metadata.Ecma335.MetadataStreamConstants : object {
    internal static int SizeOfMetadataTableHeader;
    internal static UInt32 LargeTableRowCount;
}
internal enum System.Reflection.Metadata.Ecma335.MetadataStreamKind : Enum {
    public int value__;
    public static MetadataStreamKind Illegal;
    public static MetadataStreamKind Compressed;
    public static MetadataStreamKind Uncompressed;
}
internal class System.Reflection.Metadata.Ecma335.MetadataTableHeader : ValueType {
    internal UInt32 Reserved;
    internal byte MajorVersion;
    internal byte MinorVersion;
    internal HeapSizeFlag HeapSizeFlags;
    internal byte RowId;
    internal TableMask ValidTables;
    internal TableMask SortedTables;
    internal int GetNumberOfTablesPresent();
}
[ExtensionAttribute]
public static class System.Reflection.Metadata.Ecma335.MetadataTokens : object {
    public static int TableCount;
    public static int HeapCount;
    private static MetadataTokens();
    [ExtensionAttribute]
public static int GetRowNumber(MetadataReader reader, EntityHandle handle);
    [ExtensionAttribute]
public static int GetHeapOffset(MetadataReader reader, Handle handle);
    [ExtensionAttribute]
public static int GetToken(MetadataReader reader, Handle handle);
    private static int MapVirtualHandleRowId(MetadataReader reader, Handle handle);
    public static int GetRowNumber(EntityHandle handle);
    public static int GetHeapOffset(Handle handle);
    public static int GetToken(Handle handle);
    public static bool TryGetTableIndex(HandleKind type, TableIndex& index);
    public static bool TryGetHeapIndex(HandleKind type, HeapIndex& index);
    public static Handle Handle(int token);
    public static EntityHandle EntityHandle(int token);
    public static EntityHandle Handle(TableIndex tableIndex, int rowNumber);
    private static int ToRowId(int rowNumber);
    public static MethodDefinitionHandle MethodDefinitionHandle(int rowNumber);
    public static MethodImplementationHandle MethodImplementationHandle(int rowNumber);
    public static MethodSpecificationHandle MethodSpecificationHandle(int rowNumber);
    public static TypeDefinitionHandle TypeDefinitionHandle(int rowNumber);
    public static ExportedTypeHandle ExportedTypeHandle(int rowNumber);
    public static TypeReferenceHandle TypeReferenceHandle(int rowNumber);
    public static TypeSpecificationHandle TypeSpecificationHandle(int rowNumber);
    public static MemberReferenceHandle MemberReferenceHandle(int rowNumber);
    public static FieldDefinitionHandle FieldDefinitionHandle(int rowNumber);
    public static EventDefinitionHandle EventDefinitionHandle(int rowNumber);
    public static PropertyDefinitionHandle PropertyDefinitionHandle(int rowNumber);
    public static StandaloneSignatureHandle StandaloneSignatureHandle(int rowNumber);
    public static ParameterHandle ParameterHandle(int rowNumber);
    public static GenericParameterHandle GenericParameterHandle(int rowNumber);
    public static GenericParameterConstraintHandle GenericParameterConstraintHandle(int rowNumber);
    public static ModuleReferenceHandle ModuleReferenceHandle(int rowNumber);
    public static AssemblyReferenceHandle AssemblyReferenceHandle(int rowNumber);
    public static CustomAttributeHandle CustomAttributeHandle(int rowNumber);
    public static DeclarativeSecurityAttributeHandle DeclarativeSecurityAttributeHandle(int rowNumber);
    public static ConstantHandle ConstantHandle(int rowNumber);
    public static ManifestResourceHandle ManifestResourceHandle(int rowNumber);
    public static AssemblyFileHandle AssemblyFileHandle(int rowNumber);
    public static UserStringHandle UserStringHandle(int offset);
    public static StringHandle StringHandle(int offset);
    public static BlobHandle BlobHandle(int offset);
    public static GuidHandle GuidHandle(int offset);
    private static void ThrowEntityHandleRequired();
    private static void ThrowHeapHandleRequired();
    private static void ThrowEntityOrUserStringHandleRequired();
    private static void ThrowInvalidToken();
    private static void ThrowInvalidTableIndex();
}
internal static class System.Reflection.Metadata.Ecma335.MethodDefOrRefTag : object {
    internal static int NumberOfBits;
    internal static int LargeRowSize;
    internal static UInt32 MethodDef;
    internal static UInt32 MemberRef;
    internal static UInt32 TagMask;
    internal static TableMask TablesReferenced;
    internal static UInt32 TagToTokenTypeByteVector;
    internal static EntityHandle ConvertToHandle(UInt32 methodDefOrRef);
}
[FlagsAttribute]
internal enum System.Reflection.Metadata.Ecma335.MethodDefTreatment : Enum {
    public byte value__;
    public static MethodDefTreatment None;
    public static MethodDefTreatment KindMask;
    public static MethodDefTreatment Other;
    public static MethodDefTreatment DelegateMethod;
    public static MethodDefTreatment AttributeMethod;
    public static MethodDefTreatment InterfaceMethod;
    public static MethodDefTreatment Implementation;
    public static MethodDefTreatment HiddenInterfaceImplementation;
    public static MethodDefTreatment DisposeMethod;
    public static MethodDefTreatment MarkAbstractFlag;
    public static MethodDefTreatment MarkPublicFlag;
}
internal class System.Reflection.Metadata.Ecma335.MethodImplTableReader : ValueType {
    internal int NumberOfRows;
    private bool _IsTypeDefTableRowRefSizeSmall;
    private bool _IsMethodDefOrRefRefSizeSmall;
    private int _ClassOffset;
    private int _MethodBodyOffset;
    private int _MethodDeclarationOffset;
    internal int RowSize;
    internal MemoryBlock Block;
    internal MethodImplTableReader(int numberOfRows, bool declaredSorted, int typeDefTableRowRefSize, int methodDefOrRefRefSize, MemoryBlock containingBlock, int containingBlockOffset);
    internal TypeDefinitionHandle GetClass(MethodImplementationHandle handle);
    internal EntityHandle GetMethodBody(MethodImplementationHandle handle);
    internal EntityHandle GetMethodDeclaration(MethodImplementationHandle handle);
    internal void GetMethodImplRange(TypeDefinitionHandle typeDef, Int32& firstImplRowId, Int32& lastImplRowId);
    private bool CheckSorted();
}
internal class System.Reflection.Metadata.Ecma335.MethodPtrTableReader : ValueType {
    internal int NumberOfRows;
    private bool _IsMethodTableRowRefSizeSmall;
    private int _MethodOffset;
    internal int RowSize;
    internal MemoryBlock Block;
    internal MethodPtrTableReader(int numberOfRows, int methodTableRowRefSize, MemoryBlock containingBlock, int containingBlockOffset);
    internal MethodDefinitionHandle GetMethodFor(int rowId);
    internal int GetRowIdForMethodDefRow(int methodDefRowId);
}
internal class System.Reflection.Metadata.Ecma335.MethodSemanticsTableReader : ValueType {
    internal int NumberOfRows;
    private bool _IsMethodTableRowRefSizeSmall;
    private bool _IsHasSemanticRefSizeSmall;
    private int _SemanticsFlagOffset;
    private int _MethodOffset;
    private int _AssociationOffset;
    internal int RowSize;
    internal MemoryBlock Block;
    internal MethodSemanticsTableReader(int numberOfRows, bool declaredSorted, int methodTableRowRefSize, int hasSemanticRefSize, MemoryBlock containingBlock, int containingBlockOffset);
    internal MethodDefinitionHandle GetMethod(int rowId);
    internal MethodSemanticsAttributes GetSemantics(int rowId);
    internal EntityHandle GetAssociation(int rowId);
    internal int FindSemanticMethodsForEvent(EventDefinitionHandle eventDef, UInt16& methodCount);
    internal int FindSemanticMethodsForProperty(PropertyDefinitionHandle propertyDef, UInt16& methodCount);
    private int BinarySearchTag(UInt32 searchCodedTag, UInt16& methodCount);
    private bool CheckSorted();
}
internal class System.Reflection.Metadata.Ecma335.MethodSpecTableReader : ValueType {
    internal int NumberOfRows;
    private bool _IsMethodDefOrRefRefSizeSmall;
    private bool _IsBlobHeapRefSizeSmall;
    private int _MethodOffset;
    private int _InstantiationOffset;
    internal int RowSize;
    internal MemoryBlock Block;
    internal MethodSpecTableReader(int numberOfRows, int methodDefOrRefRefSize, int blobHeapRefSize, MemoryBlock containingBlock, int containingBlockOffset);
    internal EntityHandle GetMethod(MethodSpecificationHandle handle);
    internal BlobHandle GetInstantiation(MethodSpecificationHandle handle);
}
internal class System.Reflection.Metadata.Ecma335.MethodTableReader : ValueType {
    internal int NumberOfRows;
    private bool _IsParamRefSizeSmall;
    private bool _IsStringHeapRefSizeSmall;
    private bool _IsBlobHeapRefSizeSmall;
    private int _RVAOffset;
    private int _ImplFlagsOffset;
    private int _FlagsOffset;
    private int _NameOffset;
    private int _SignatureOffset;
    private int _ParamListOffset;
    internal int RowSize;
    internal MemoryBlock Block;
    internal MethodTableReader(int numberOfRows, int paramRefSize, int stringHeapRefSize, int blobHeapRefSize, MemoryBlock containingBlock, int containingBlockOffset);
    internal int GetParamStart(int rowId);
    internal BlobHandle GetSignature(MethodDefinitionHandle handle);
    internal int GetRva(MethodDefinitionHandle handle);
    internal StringHandle GetName(MethodDefinitionHandle handle);
    internal MethodAttributes GetFlags(MethodDefinitionHandle handle);
    internal MethodImplAttributes GetImplFlags(MethodDefinitionHandle handle);
    internal int GetNextRVA(int rva);
}
internal class System.Reflection.Metadata.Ecma335.ModuleRefTableReader : ValueType {
    internal int NumberOfRows;
    private bool _IsStringHeapRefSizeSmall;
    private int _NameOffset;
    internal int RowSize;
    internal MemoryBlock Block;
    internal ModuleRefTableReader(int numberOfRows, int stringHeapRefSize, MemoryBlock containingBlock, int containingBlockOffset);
    internal StringHandle GetName(ModuleReferenceHandle handle);
}
internal class System.Reflection.Metadata.Ecma335.ModuleTableReader : ValueType {
    internal int NumberOfRows;
    private bool _IsStringHeapRefSizeSmall;
    private bool _IsGUIDHeapRefSizeSmall;
    private int _GenerationOffset;
    private int _NameOffset;
    private int _MVIdOffset;
    private int _EnCIdOffset;
    private int _EnCBaseIdOffset;
    internal int RowSize;
    internal MemoryBlock Block;
    internal ModuleTableReader(int numberOfRows, int stringHeapRefSize, int guidHeapRefSize, MemoryBlock containingBlock, int containingBlockOffset);
    internal ushort GetGeneration();
    internal StringHandle GetName();
    internal GuidHandle GetMvid();
    internal GuidHandle GetEncId();
    internal GuidHandle GetEncBaseId();
}
internal class System.Reflection.Metadata.Ecma335.NamespaceCache : object {
    private MetadataReader _metadataReader;
    private object _namespaceTableAndListLock;
    private Dictionary`2<NamespaceDefinitionHandle, NamespaceData> _namespaceTable;
    private NamespaceData _rootNamespace;
    private ImmutableArray`1<NamespaceDefinitionHandle> _namespaceList;
    internal bool CacheIsRealized { get; }
    internal NamespaceCache(MetadataReader reader);
    internal bool get_CacheIsRealized();
    internal string GetFullName(NamespaceDefinitionHandle handle);
    internal NamespaceData GetRootNamespace();
    internal NamespaceData GetNamespaceData(NamespaceDefinitionHandle handle);
    private static void ThrowInvalidHandle();
    private StringHandle GetSimpleName(NamespaceDefinitionHandle fullNamespaceHandle, int segmentIndex);
    private void PopulateNamespaceTable();
    private void MergeDuplicateNamespaces(Dictionary`2<NamespaceDefinitionHandle, NamespaceDataBuilder> table, Dictionary`2& stringTable);
    private NamespaceDataBuilder SynthesizeNamespaceData(string fullName, NamespaceDefinitionHandle realChild);
    private void LinkChildDataToParentData(NamespaceDataBuilder child, NamespaceDataBuilder parent);
    private void LinkChildToParentNamespace(Dictionary`2<string, NamespaceDataBuilder> existingNamespaces, NamespaceDataBuilder realChild, List`1& syntheticNamespaces);
    private void ResolveParentChildRelationships(Dictionary`2<string, NamespaceDataBuilder> namespaces, List`1& syntheticNamespaces);
    private void PopulateTableWithTypeDefinitions(Dictionary`2<NamespaceDefinitionHandle, NamespaceDataBuilder> table);
    private void PopulateTableWithExportedTypes(Dictionary`2<NamespaceDefinitionHandle, NamespaceDataBuilder> table);
    private void PopulateNamespaceList();
    private void EnsureNamespaceTableIsPopulated();
    private void EnsureNamespaceListIsPopulated();
}
internal class System.Reflection.Metadata.Ecma335.NamespaceData : object {
    public StringHandle Name;
    public string FullName;
    public NamespaceDefinitionHandle Parent;
    public ImmutableArray`1<NamespaceDefinitionHandle> NamespaceDefinitions;
    public ImmutableArray`1<TypeDefinitionHandle> TypeDefinitions;
    public ImmutableArray`1<ExportedTypeHandle> ExportedTypes;
    public NamespaceData(StringHandle name, string fullName, NamespaceDefinitionHandle parent, ImmutableArray`1<NamespaceDefinitionHandle> namespaceDefinitions, ImmutableArray`1<TypeDefinitionHandle> typeDefinitions, ImmutableArray`1<ExportedTypeHandle> exportedTypes);
}
internal static class System.Reflection.Metadata.Ecma335.NamespaceHandleType : object {
    internal static UInt32 Namespace;
    internal static UInt32 SyntheticNamespace;
    internal static UInt32 ReservedNamespace1;
    internal static UInt32 ReservedNamespace2;
    internal static UInt32 ReservedVirtualNamespace1;
    internal static UInt32 ReservedVirtualNamespace2;
    internal static UInt32 ReservedVirtualNamespace3;
    internal static UInt32 ReservedVirtualNamespace4;
}
internal enum System.Reflection.Metadata.Ecma335.NamespaceKind : Enum {
    public byte value__;
    public static NamespaceKind Plain;
    public static NamespaceKind Synthetic;
}
internal class System.Reflection.Metadata.Ecma335.NestedClassTableReader : ValueType {
    internal int NumberOfRows;
    private bool _IsTypeDefTableRowRefSizeSmall;
    private int _NestedClassOffset;
    private int _EnclosingClassOffset;
    internal int RowSize;
    internal MemoryBlock Block;
    internal NestedClassTableReader(int numberOfRows, bool declaredSorted, int typeDefTableRowRefSize, MemoryBlock containingBlock, int containingBlockOffset);
    internal TypeDefinitionHandle GetNestedClass(int rowId);
    internal TypeDefinitionHandle GetEnclosingClass(int rowId);
    internal TypeDefinitionHandle FindEnclosingType(TypeDefinitionHandle nestedTypeDef);
    private bool CheckSorted();
}
internal class System.Reflection.Metadata.Ecma335.ParamPtrTableReader : ValueType {
    internal int NumberOfRows;
    private bool _IsParamTableRowRefSizeSmall;
    private int _ParamOffset;
    internal int RowSize;
    internal MemoryBlock Block;
    internal ParamPtrTableReader(int numberOfRows, int paramTableRowRefSize, MemoryBlock containingBlock, int containingBlockOffset);
    internal ParameterHandle GetParamFor(int rowId);
}
internal class System.Reflection.Metadata.Ecma335.ParamTableReader : ValueType {
    internal int NumberOfRows;
    private bool _IsStringHeapRefSizeSmall;
    private int _FlagsOffset;
    private int _SequenceOffset;
    private int _NameOffset;
    internal int RowSize;
    internal MemoryBlock Block;
    internal ParamTableReader(int numberOfRows, int stringHeapRefSize, MemoryBlock containingBlock, int containingBlockOffset);
    internal ParameterAttributes GetFlags(ParameterHandle handle);
    internal ushort GetSequence(ParameterHandle handle);
    internal StringHandle GetName(ParameterHandle handle);
}
internal class System.Reflection.Metadata.Ecma335.PropertyMapTableReader : ValueType {
    internal int NumberOfRows;
    private bool _IsTypeDefTableRowRefSizeSmall;
    private bool _IsPropertyRefSizeSmall;
    private int _ParentOffset;
    private int _PropertyListOffset;
    internal int RowSize;
    internal MemoryBlock Block;
    internal PropertyMapTableReader(int numberOfRows, int typeDefTableRowRefSize, int propertyRefSize, MemoryBlock containingBlock, int containingBlockOffset);
    internal int FindPropertyMapRowIdFor(TypeDefinitionHandle typeDef);
    internal TypeDefinitionHandle GetParentType(int rowId);
    internal int GetPropertyListStartFor(int rowId);
}
internal class System.Reflection.Metadata.Ecma335.PropertyPtrTableReader : ValueType {
    internal int NumberOfRows;
    private bool _IsPropertyTableRowRefSizeSmall;
    private int _PropertyOffset;
    internal int RowSize;
    internal MemoryBlock Block;
    internal PropertyPtrTableReader(int numberOfRows, int propertyTableRowRefSize, MemoryBlock containingBlock, int containingBlockOffset);
    internal PropertyDefinitionHandle GetPropertyFor(int rowId);
}
internal class System.Reflection.Metadata.Ecma335.PropertyTableReader : ValueType {
    internal int NumberOfRows;
    private bool _IsStringHeapRefSizeSmall;
    private bool _IsBlobHeapRefSizeSmall;
    private int _FlagsOffset;
    private int _NameOffset;
    private int _SignatureOffset;
    internal int RowSize;
    internal MemoryBlock Block;
    internal PropertyTableReader(int numberOfRows, int stringHeapRefSize, int blobHeapRefSize, MemoryBlock containingBlock, int containingBlockOffset);
    internal PropertyAttributes GetFlags(PropertyDefinitionHandle handle);
    internal StringHandle GetName(PropertyDefinitionHandle handle);
    internal BlobHandle GetSignature(PropertyDefinitionHandle handle);
}
internal static class System.Reflection.Metadata.Ecma335.ResolutionScopeTag : object {
    internal static int NumberOfBits;
    internal static int LargeRowSize;
    internal static UInt32 Module;
    internal static UInt32 ModuleRef;
    internal static UInt32 AssemblyRef;
    internal static UInt32 TypeRef;
    internal static UInt32 TagMask;
    internal static UInt32 TagToTokenTypeByteVector;
    internal static TableMask TablesReferenced;
    internal static EntityHandle ConvertToHandle(UInt32 resolutionScope);
}
internal class System.Reflection.Metadata.Ecma335.StandAloneSigTableReader : ValueType {
    internal int NumberOfRows;
    private bool _IsBlobHeapRefSizeSmall;
    private int _SignatureOffset;
    internal int RowSize;
    internal MemoryBlock Block;
    internal StandAloneSigTableReader(int numberOfRows, int blobHeapRefSize, MemoryBlock containingBlock, int containingBlockOffset);
    internal BlobHandle GetSignature(int rowId);
}
internal class System.Reflection.Metadata.Ecma335.StreamHeader : ValueType {
    internal UInt32 Offset;
    internal int Size;
    internal string Name;
}
internal static class System.Reflection.Metadata.Ecma335.StringHandleType : object {
    internal static UInt32 String;
    internal static UInt32 DotTerminatedString;
    internal static UInt32 ReservedString1;
    internal static UInt32 ReservedString2;
    internal static UInt32 VirtualString;
    internal static UInt32 WinRTPrefixedString;
    internal static UInt32 ReservedVirtualString1;
    internal static UInt32 ReservedVirtaulString2;
}
internal enum System.Reflection.Metadata.Ecma335.StringKind : Enum {
    public byte value__;
    public static StringKind Plain;
    public static StringKind Virtual;
    public static StringKind WinRTPrefixed;
    public static StringKind DotTerminated;
}
internal class System.Reflection.Metadata.Ecma335.StringStreamReader : ValueType {
    private static String[] s_virtualValues;
    internal MemoryBlock Block;
    internal StringStreamReader(MemoryBlock block, MetadataKind metadataKind);
    [ConditionalAttribute("DEBUG")]
private static void AssertFilled();
    private static MemoryBlock TrimEnd(MemoryBlock block);
    internal string GetVirtualValue(VirtualIndex index);
    internal string GetString(StringHandle handle, MetadataStringDecoder utf8Decoder);
    internal StringHandle GetNextHandle(StringHandle handle);
    internal bool Equals(StringHandle handle, string value, MetadataStringDecoder utf8Decoder);
    internal bool StartsWith(StringHandle handle, string value, MetadataStringDecoder utf8Decoder);
    internal bool EqualsRaw(StringHandle rawHandle, string asciiString);
    internal int IndexOfRaw(int startIndex, char asciiChar);
    internal bool StartsWithRaw(StringHandle rawHandle, string asciiPrefix);
    internal int BinarySearchRaw(String[] asciiKeys, StringHandle rawHandle);
}
public enum System.Reflection.Metadata.Ecma335.TableIndex : Enum {
    public byte value__;
    public static TableIndex Module;
    public static TableIndex TypeRef;
    public static TableIndex TypeDef;
    public static TableIndex FieldPtr;
    public static TableIndex Field;
    public static TableIndex MethodPtr;
    public static TableIndex MethodDef;
    public static TableIndex ParamPtr;
    public static TableIndex Param;
    public static TableIndex InterfaceImpl;
    public static TableIndex MemberRef;
    public static TableIndex Constant;
    public static TableIndex CustomAttribute;
    public static TableIndex FieldMarshal;
    public static TableIndex DeclSecurity;
    public static TableIndex ClassLayout;
    public static TableIndex FieldLayout;
    public static TableIndex StandAloneSig;
    public static TableIndex EventMap;
    public static TableIndex EventPtr;
    public static TableIndex Event;
    public static TableIndex PropertyMap;
    public static TableIndex PropertyPtr;
    public static TableIndex Property;
    public static TableIndex MethodSemantics;
    public static TableIndex MethodImpl;
    public static TableIndex ModuleRef;
    public static TableIndex TypeSpec;
    public static TableIndex ImplMap;
    public static TableIndex FieldRva;
    public static TableIndex EncLog;
    public static TableIndex EncMap;
    public static TableIndex Assembly;
    public static TableIndex AssemblyProcessor;
    public static TableIndex AssemblyOS;
    public static TableIndex AssemblyRef;
    public static TableIndex AssemblyRefProcessor;
    public static TableIndex AssemblyRefOS;
    public static TableIndex File;
    public static TableIndex ExportedType;
    public static TableIndex ManifestResource;
    public static TableIndex NestedClass;
    public static TableIndex GenericParam;
    public static TableIndex MethodSpec;
    public static TableIndex GenericParamConstraint;
}
internal static class System.Reflection.Metadata.Ecma335.TableIndexExtensions : object {
    internal static int Count;
}
[FlagsAttribute]
internal enum System.Reflection.Metadata.Ecma335.TableMask : Enum {
    public ulong value__;
    public static TableMask Module;
    public static TableMask TypeRef;
    public static TableMask TypeDef;
    public static TableMask FieldPtr;
    public static TableMask Field;
    public static TableMask MethodPtr;
    public static TableMask MethodDef;
    public static TableMask ParamPtr;
    public static TableMask Param;
    public static TableMask InterfaceImpl;
    public static TableMask MemberRef;
    public static TableMask Constant;
    public static TableMask CustomAttribute;
    public static TableMask FieldMarshal;
    public static TableMask DeclSecurity;
    public static TableMask ClassLayout;
    public static TableMask FieldLayout;
    public static TableMask StandAloneSig;
    public static TableMask EventMap;
    public static TableMask EventPtr;
    public static TableMask Event;
    public static TableMask PropertyMap;
    public static TableMask PropertyPtr;
    public static TableMask Property;
    public static TableMask MethodSemantics;
    public static TableMask MethodImpl;
    public static TableMask ModuleRef;
    public static TableMask TypeSpec;
    public static TableMask ImplMap;
    public static TableMask FieldRva;
    public static TableMask EnCLog;
    public static TableMask EnCMap;
    public static TableMask Assembly;
    public static TableMask AssemblyRef;
    public static TableMask File;
    public static TableMask ExportedType;
    public static TableMask ManifestResource;
    public static TableMask NestedClass;
    public static TableMask GenericParam;
    public static TableMask MethodSpec;
    public static TableMask GenericParamConstraint;
    public static TableMask PtrTables;
    public static TableMask V2_0_TablesMask;
}
internal static class System.Reflection.Metadata.Ecma335.TokenTypeIds : object {
    internal static UInt32 Module;
    internal static UInt32 TypeRef;
    internal static UInt32 TypeDef;
    internal static UInt32 FieldDef;
    internal static UInt32 MethodDef;
    internal static UInt32 ParamDef;
    internal static UInt32 InterfaceImpl;
    internal static UInt32 MemberRef;
    internal static UInt32 Constant;
    internal static UInt32 CustomAttribute;
    internal static UInt32 DeclSecurity;
    internal static UInt32 Signature;
    internal static UInt32 EventMap;
    internal static UInt32 Event;
    internal static UInt32 PropertyMap;
    internal static UInt32 Property;
    internal static UInt32 MethodSemantics;
    internal static UInt32 MethodImpl;
    internal static UInt32 ModuleRef;
    internal static UInt32 TypeSpec;
    internal static UInt32 Assembly;
    internal static UInt32 AssemblyRef;
    internal static UInt32 File;
    internal static UInt32 ExportedType;
    internal static UInt32 ManifestResource;
    internal static UInt32 NestedClass;
    internal static UInt32 GenericParam;
    internal static UInt32 MethodSpec;
    internal static UInt32 GenericParamConstraint;
    internal static UInt32 UserString;
    internal static int RowIdBitCount;
    internal static UInt32 RIDMask;
    internal static UInt32 TypeMask;
    internal static UInt32 VirtualBit;
    internal static bool IsEntityOrUserStringToken(UInt32 vToken);
    internal static bool IsEntityToken(UInt32 vToken);
    internal static bool IsValidRowId(UInt32 rowId);
    internal static bool IsValidRowId(int rowId);
}
internal static class System.Reflection.Metadata.Ecma335.TypeDefOrRefTag : object {
    internal static int NumberOfBits;
    internal static int LargeRowSize;
    internal static UInt32 TypeDef;
    internal static UInt32 TypeRef;
    internal static UInt32 TypeSpec;
    internal static UInt32 TagMask;
    internal static UInt32 TagToTokenTypeByteVector;
    internal static TableMask TablesReferenced;
    internal static EntityHandle ConvertToHandle(UInt32 typeDefOrRefTag);
}
internal class System.Reflection.Metadata.Ecma335.TypeDefTableReader : ValueType {
    internal int NumberOfRows;
    private bool _IsFieldRefSizeSmall;
    private bool _IsMethodRefSizeSmall;
    private bool _IsTypeDefOrRefRefSizeSmall;
    private bool _IsStringHeapRefSizeSmall;
    private int _FlagsOffset;
    private int _NameOffset;
    private int _NamespaceOffset;
    private int _ExtendsOffset;
    private int _FieldListOffset;
    private int _MethodListOffset;
    internal int RowSize;
    internal MemoryBlock Block;
    internal TypeDefTableReader(int numberOfRows, int fieldRefSize, int methodRefSize, int typeDefOrRefRefSize, int stringHeapRefSize, MemoryBlock containingBlock, int containingBlockOffset);
    internal TypeAttributes GetFlags(TypeDefinitionHandle handle);
    internal NamespaceDefinitionHandle GetNamespaceDefinition(TypeDefinitionHandle handle);
    internal StringHandle GetNamespace(TypeDefinitionHandle handle);
    internal StringHandle GetName(TypeDefinitionHandle handle);
    internal EntityHandle GetExtends(TypeDefinitionHandle handle);
    internal int GetFieldStart(int rowId);
    internal int GetMethodStart(int rowId);
    internal TypeDefinitionHandle FindTypeContainingMethod(int methodDefOrPtrRowId, int numberOfMethods);
    internal TypeDefinitionHandle FindTypeContainingField(int fieldDefOrPtrRowId, int numberOfFields);
}
[FlagsAttribute]
internal enum System.Reflection.Metadata.Ecma335.TypeDefTreatment : Enum {
    public byte value__;
    public static TypeDefTreatment None;
    public static TypeDefTreatment KindMask;
    public static TypeDefTreatment NormalNonAttribute;
    public static TypeDefTreatment NormalAttribute;
    public static TypeDefTreatment UnmangleWinRTName;
    public static TypeDefTreatment PrefixWinRTName;
    public static TypeDefTreatment RedirectedToClrType;
    public static TypeDefTreatment RedirectedToClrAttribute;
    public static TypeDefTreatment MarkAbstractFlag;
    public static TypeDefTreatment MarkInternalFlag;
}
internal static class System.Reflection.Metadata.Ecma335.TypeOrMethodDefTag : object {
    internal static int NumberOfBits;
    internal static int LargeRowSize;
    internal static UInt32 TypeDef;
    internal static UInt32 MethodDef;
    internal static UInt32 TagMask;
    internal static UInt32 TagToTokenTypeByteVector;
    internal static TableMask TablesReferenced;
    internal static EntityHandle ConvertToHandle(UInt32 typeOrMethodDef);
    internal static UInt32 ConvertTypeDefRowIdToTag(TypeDefinitionHandle typeDef);
    internal static UInt32 ConvertMethodDefToTag(MethodDefinitionHandle methodDef);
}
internal class System.Reflection.Metadata.Ecma335.TypeRefTableReader : ValueType {
    internal int NumberOfRows;
    private bool _IsResolutionScopeRefSizeSmall;
    private bool _IsStringHeapRefSizeSmall;
    private int _ResolutionScopeOffset;
    private int _NameOffset;
    private int _NamespaceOffset;
    internal int RowSize;
    internal MemoryBlock Block;
    internal TypeRefTableReader(int numberOfRows, int resolutionScopeRefSize, int stringHeapRefSize, MemoryBlock containingBlock, int containingBlockOffset);
    internal EntityHandle GetResolutionScope(TypeReferenceHandle handle);
    internal StringHandle GetName(TypeReferenceHandle handle);
    internal StringHandle GetNamespace(TypeReferenceHandle handle);
}
internal enum System.Reflection.Metadata.Ecma335.TypeRefTreatment : Enum {
    public byte value__;
    public static TypeRefTreatment None;
    public static TypeRefTreatment SystemDelegate;
    public static TypeRefTreatment SystemAttribute;
    public static TypeRefTreatment UseProjectionInfo;
}
internal class System.Reflection.Metadata.Ecma335.TypeSpecTableReader : ValueType {
    internal int NumberOfRows;
    private bool _IsBlobHeapRefSizeSmall;
    private int _SignatureOffset;
    internal int RowSize;
    internal MemoryBlock Block;
    internal TypeSpecTableReader(int numberOfRows, int blobHeapRefSize, MemoryBlock containingBlock, int containingBlockOffset);
    internal BlobHandle GetSignature(TypeSpecificationHandle handle);
}
internal class System.Reflection.Metadata.Ecma335.UserStringStreamReader : ValueType {
    internal MemoryBlock Block;
    public UserStringStreamReader(MemoryBlock block);
    internal string GetString(UserStringHandle handle);
    internal UserStringHandle GetNextHandle(UserStringHandle handle);
}
public class System.Reflection.Metadata.EntityHandle : ValueType {
    private UInt32 _vToken;
    public static ModuleDefinitionHandle ModuleDefinition;
    public static AssemblyDefinitionHandle AssemblyDefinition;
    internal UInt32 Type { get; }
    internal UInt32 VType { get; }
    internal bool IsVirtual { get; }
    public bool IsNil { get; }
    internal int RowId { get; }
    internal UInt32 SpecificHandleValue { get; }
    public HandleKind Kind { get; }
    internal int Token { get; }
    internal EntityHandle(UInt32 vToken);
    private static EntityHandle();
    public static Handle op_Implicit(EntityHandle handle);
    public static EntityHandle op_Explicit(Handle handle);
    internal UInt32 get_Type();
    internal UInt32 get_VType();
    internal bool get_IsVirtual();
    public bool get_IsNil();
    internal int get_RowId();
    internal UInt32 get_SpecificHandleValue();
    public HandleKind get_Kind();
    internal int get_Token();
    public virtual bool Equals(object obj);
    public sealed virtual bool Equals(EntityHandle other);
    public virtual int GetHashCode();
    public static bool op_Equality(EntityHandle left, EntityHandle right);
    public static bool op_Inequality(EntityHandle left, EntityHandle right);
    internal static int Compare(EntityHandle left, EntityHandle right);
}
public class System.Reflection.Metadata.EventAccessors : ValueType {
    private int _adderRowId;
    private int _removerRowId;
    private int _raiserRowId;
    public MethodDefinitionHandle Adder { get; }
    public MethodDefinitionHandle Remover { get; }
    public MethodDefinitionHandle Raiser { get; }
    internal EventAccessors(int adderRowId, int removerRowId, int raiserRowId);
    public MethodDefinitionHandle get_Adder();
    public MethodDefinitionHandle get_Remover();
    public MethodDefinitionHandle get_Raiser();
}
public class System.Reflection.Metadata.EventDefinition : ValueType {
    private MetadataReader _reader;
    private int _rowId;
    private EventDefinitionHandle Handle { get; }
    public StringHandle Name { get; }
    public EventAttributes Attributes { get; }
    public EntityHandle Type { get; }
    internal EventDefinition(MetadataReader reader, EventDefinitionHandle handle);
    private EventDefinitionHandle get_Handle();
    public StringHandle get_Name();
    public EventAttributes get_Attributes();
    public EntityHandle get_Type();
    public CustomAttributeHandleCollection GetCustomAttributes();
    public EventAccessors GetAccessors();
}
public class System.Reflection.Metadata.EventDefinitionHandle : ValueType {
    private static UInt32 tokenType;
    private static byte tokenTypeSmall;
    private int _rowId;
    public bool IsNil { get; }
    internal int RowId { get; }
    private EventDefinitionHandle(int rowId);
    internal static EventDefinitionHandle FromRowId(int rowId);
    public static Handle op_Implicit(EventDefinitionHandle handle);
    public static EntityHandle op_Implicit(EventDefinitionHandle handle);
    public static EventDefinitionHandle op_Explicit(Handle handle);
    public static EventDefinitionHandle op_Explicit(EntityHandle handle);
    public bool get_IsNil();
    internal int get_RowId();
    public static bool op_Equality(EventDefinitionHandle left, EventDefinitionHandle right);
    public virtual bool Equals(object obj);
    public sealed virtual bool Equals(EventDefinitionHandle other);
    public virtual int GetHashCode();
    public static bool op_Inequality(EventDefinitionHandle left, EventDefinitionHandle right);
}
public class System.Reflection.Metadata.EventDefinitionHandleCollection : ValueType {
    private MetadataReader _reader;
    private int _firstRowId;
    private int _lastRowId;
    public int Count { get; }
    internal EventDefinitionHandleCollection(MetadataReader reader);
    internal EventDefinitionHandleCollection(MetadataReader reader, TypeDefinitionHandle containingType);
    public sealed virtual int get_Count();
    public Enumerator GetEnumerator();
    private sealed virtual override IEnumerator`1<EventDefinitionHandle> System.Collections.Generic.IEnumerable<System.Reflection.Metadata.EventDefinitionHandle>.GetEnumerator();
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
}
public class System.Reflection.Metadata.ExceptionRegion : ValueType {
    private ExceptionRegionKind _kind;
    private int _tryOffset;
    private int _tryLength;
    private int _handlerOffset;
    private int _handlerLength;
    private int _classTokenOrFilterOffset;
    public ExceptionRegionKind Kind { get; }
    public int TryOffset { get; }
    public int TryLength { get; }
    public int HandlerOffset { get; }
    public int HandlerLength { get; }
    public int FilterOffset { get; }
    public EntityHandle CatchType { get; }
    internal ExceptionRegion(ExceptionRegionKind kind, int tryOffset, int tryLength, int handlerOffset, int handlerLength, int classTokenOrFilterOffset);
    public ExceptionRegionKind get_Kind();
    public int get_TryOffset();
    public int get_TryLength();
    public int get_HandlerOffset();
    public int get_HandlerLength();
    public int get_FilterOffset();
    public EntityHandle get_CatchType();
}
public enum System.Reflection.Metadata.ExceptionRegionKind : Enum {
    public ushort value__;
    public static ExceptionRegionKind Catch;
    public static ExceptionRegionKind Filter;
    public static ExceptionRegionKind Finally;
    public static ExceptionRegionKind Fault;
}
public class System.Reflection.Metadata.ExportedType : ValueType {
    internal MetadataReader reader;
    internal int rowId;
    private ExportedTypeHandle Handle { get; }
    public TypeAttributes Attributes { get; }
    public bool IsForwarder { get; }
    public StringHandle Name { get; }
    public StringHandle Namespace { get; }
    public NamespaceDefinitionHandle NamespaceDefinition { get; }
    public EntityHandle Implementation { get; }
    internal ExportedType(MetadataReader reader, int rowId);
    private ExportedTypeHandle get_Handle();
    public TypeAttributes get_Attributes();
    public bool get_IsForwarder();
    public StringHandle get_Name();
    public StringHandle get_Namespace();
    public NamespaceDefinitionHandle get_NamespaceDefinition();
    public EntityHandle get_Implementation();
    public CustomAttributeHandleCollection GetCustomAttributes();
}
public class System.Reflection.Metadata.ExportedTypeHandle : ValueType {
    private static UInt32 tokenType;
    private static byte tokenTypeSmall;
    private int _rowId;
    public bool IsNil { get; }
    internal int RowId { get; }
    private ExportedTypeHandle(int rowId);
    internal static ExportedTypeHandle FromRowId(int rowId);
    public static Handle op_Implicit(ExportedTypeHandle handle);
    public static EntityHandle op_Implicit(ExportedTypeHandle handle);
    public static ExportedTypeHandle op_Explicit(Handle handle);
    public static ExportedTypeHandle op_Explicit(EntityHandle handle);
    public bool get_IsNil();
    internal int get_RowId();
    public static bool op_Equality(ExportedTypeHandle left, ExportedTypeHandle right);
    public virtual bool Equals(object obj);
    public sealed virtual bool Equals(ExportedTypeHandle other);
    public virtual int GetHashCode();
    public static bool op_Inequality(ExportedTypeHandle left, ExportedTypeHandle right);
}
public class System.Reflection.Metadata.ExportedTypeHandleCollection : ValueType {
    private int _lastRowId;
    public int Count { get; }
    internal ExportedTypeHandleCollection(int lastRowId);
    public sealed virtual int get_Count();
    public Enumerator GetEnumerator();
    private sealed virtual override IEnumerator`1<ExportedTypeHandle> System.Collections.Generic.IEnumerable<System.Reflection.Metadata.ExportedTypeHandle>.GetEnumerator();
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
}
public class System.Reflection.Metadata.FieldDefinition : ValueType {
    private MetadataReader _reader;
    private UInt32 _treatmentAndRowId;
    private int RowId { get; }
    private FieldDefTreatment Treatment { get; }
    private FieldDefinitionHandle Handle { get; }
    public StringHandle Name { get; }
    public FieldAttributes Attributes { get; }
    public BlobHandle Signature { get; }
    internal FieldDefinition(MetadataReader reader, UInt32 treatmentAndRowId);
    private int get_RowId();
    private FieldDefTreatment get_Treatment();
    private FieldDefinitionHandle get_Handle();
    public StringHandle get_Name();
    public FieldAttributes get_Attributes();
    public BlobHandle get_Signature();
    public TypeDefinitionHandle GetDeclaringType();
    public ConstantHandle GetDefaultValue();
    public int GetRelativeVirtualAddress();
    public int GetOffset();
    public BlobHandle GetMarshallingDescriptor();
    public CustomAttributeHandleCollection GetCustomAttributes();
    private StringHandle GetProjectedName();
    private FieldAttributes GetProjectedFlags();
    private BlobHandle GetProjectedSignature();
}
public class System.Reflection.Metadata.FieldDefinitionHandle : ValueType {
    private static UInt32 tokenType;
    private static byte tokenTypeSmall;
    private int _rowId;
    public bool IsNil { get; }
    internal int RowId { get; }
    private FieldDefinitionHandle(int rowId);
    internal static FieldDefinitionHandle FromRowId(int rowId);
    public static Handle op_Implicit(FieldDefinitionHandle handle);
    public static EntityHandle op_Implicit(FieldDefinitionHandle handle);
    public static FieldDefinitionHandle op_Explicit(Handle handle);
    public static FieldDefinitionHandle op_Explicit(EntityHandle handle);
    public bool get_IsNil();
    internal int get_RowId();
    public static bool op_Equality(FieldDefinitionHandle left, FieldDefinitionHandle right);
    public virtual bool Equals(object obj);
    public sealed virtual bool Equals(FieldDefinitionHandle other);
    public virtual int GetHashCode();
    public static bool op_Inequality(FieldDefinitionHandle left, FieldDefinitionHandle right);
}
public class System.Reflection.Metadata.FieldDefinitionHandleCollection : ValueType {
    private MetadataReader _reader;
    private int _firstRowId;
    private int _lastRowId;
    public int Count { get; }
    internal FieldDefinitionHandleCollection(MetadataReader reader);
    internal FieldDefinitionHandleCollection(MetadataReader reader, TypeDefinitionHandle containingType);
    public sealed virtual int get_Count();
    public Enumerator GetEnumerator();
    private sealed virtual override IEnumerator`1<FieldDefinitionHandle> System.Collections.Generic.IEnumerable<System.Reflection.Metadata.FieldDefinitionHandle>.GetEnumerator();
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
}
public class System.Reflection.Metadata.GenericParameter : ValueType {
    private MetadataReader _reader;
    private int _rowId;
    private GenericParameterHandle Handle { get; }
    public EntityHandle Parent { get; }
    public GenericParameterAttributes Attributes { get; }
    public int Index { get; }
    public StringHandle Name { get; }
    internal GenericParameter(MetadataReader reader, GenericParameterHandle handle);
    private GenericParameterHandle get_Handle();
    public EntityHandle get_Parent();
    public GenericParameterAttributes get_Attributes();
    public int get_Index();
    public StringHandle get_Name();
    public GenericParameterConstraintHandleCollection GetConstraints();
    public CustomAttributeHandleCollection GetCustomAttributes();
}
public class System.Reflection.Metadata.GenericParameterConstraint : ValueType {
    private MetadataReader _reader;
    private int _rowId;
    private GenericParameterConstraintHandle Handle { get; }
    public GenericParameterHandle Parameter { get; }
    public EntityHandle Type { get; }
    internal GenericParameterConstraint(MetadataReader reader, GenericParameterConstraintHandle handle);
    private GenericParameterConstraintHandle get_Handle();
    public GenericParameterHandle get_Parameter();
    public EntityHandle get_Type();
    public CustomAttributeHandleCollection GetCustomAttributes();
}
public class System.Reflection.Metadata.GenericParameterConstraintHandle : ValueType {
    private static UInt32 tokenType;
    private static byte tokenTypeSmall;
    private int _rowId;
    public bool IsNil { get; }
    internal int RowId { get; }
    private GenericParameterConstraintHandle(int rowId);
    internal static GenericParameterConstraintHandle FromRowId(int rowId);
    public static Handle op_Implicit(GenericParameterConstraintHandle handle);
    public static EntityHandle op_Implicit(GenericParameterConstraintHandle handle);
    public static GenericParameterConstraintHandle op_Explicit(Handle handle);
    public static GenericParameterConstraintHandle op_Explicit(EntityHandle handle);
    public bool get_IsNil();
    internal int get_RowId();
    public static bool op_Equality(GenericParameterConstraintHandle left, GenericParameterConstraintHandle right);
    public virtual bool Equals(object obj);
    public sealed virtual bool Equals(GenericParameterConstraintHandle other);
    public virtual int GetHashCode();
    public static bool op_Inequality(GenericParameterConstraintHandle left, GenericParameterConstraintHandle right);
}
[DefaultMemberAttribute("Item")]
public class System.Reflection.Metadata.GenericParameterConstraintHandleCollection : ValueType {
    private int _firstRowId;
    private ushort _count;
    public int Count { get; }
    public GenericParameterConstraintHandle Item { get; }
    internal GenericParameterConstraintHandleCollection(int firstRowId, ushort count);
    public sealed virtual int get_Count();
    public sealed virtual GenericParameterConstraintHandle get_Item(int index);
    private static void ThrowIndexOutOfRange();
    public Enumerator GetEnumerator();
    private sealed virtual override IEnumerator`1<GenericParameterConstraintHandle> System.Collections.Generic.IEnumerable<System.Reflection.Metadata.GenericParameterConstraintHandle>.GetEnumerator();
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
}
public class System.Reflection.Metadata.GenericParameterHandle : ValueType {
    private static UInt32 tokenType;
    private static byte tokenTypeSmall;
    private int _rowId;
    public bool IsNil { get; }
    internal int RowId { get; }
    private GenericParameterHandle(int rowId);
    internal static GenericParameterHandle FromRowId(int rowId);
    public static Handle op_Implicit(GenericParameterHandle handle);
    public static EntityHandle op_Implicit(GenericParameterHandle handle);
    public static GenericParameterHandle op_Explicit(Handle handle);
    public static GenericParameterHandle op_Explicit(EntityHandle handle);
    public bool get_IsNil();
    internal int get_RowId();
    public static bool op_Equality(GenericParameterHandle left, GenericParameterHandle right);
    public virtual bool Equals(object obj);
    public sealed virtual bool Equals(GenericParameterHandle other);
    public virtual int GetHashCode();
    public static bool op_Inequality(GenericParameterHandle left, GenericParameterHandle right);
}
[DefaultMemberAttribute("Item")]
public class System.Reflection.Metadata.GenericParameterHandleCollection : ValueType {
    private int _firstRowId;
    private ushort _count;
    public int Count { get; }
    public GenericParameterHandle Item { get; }
    internal GenericParameterHandleCollection(int firstRowId, ushort count);
    public sealed virtual int get_Count();
    public sealed virtual GenericParameterHandle get_Item(int index);
    private static void ThrowIndexOutOfRange();
    public Enumerator GetEnumerator();
    private sealed virtual override IEnumerator`1<GenericParameterHandle> System.Collections.Generic.IEnumerable<System.Reflection.Metadata.GenericParameterHandle>.GetEnumerator();
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
}
public class System.Reflection.Metadata.GuidHandle : ValueType {
    private int _index;
    public bool IsNil { get; }
    internal int Index { get; }
    private GuidHandle(int index);
    internal static GuidHandle FromIndex(int heapIndex);
    public static Handle op_Implicit(GuidHandle handle);
    public static GuidHandle op_Explicit(Handle handle);
    public bool get_IsNil();
    internal int get_Index();
    public virtual bool Equals(object obj);
    public sealed virtual bool Equals(GuidHandle other);
    public virtual int GetHashCode();
    public static bool op_Equality(GuidHandle left, GuidHandle right);
    public static bool op_Inequality(GuidHandle left, GuidHandle right);
}
public class System.Reflection.Metadata.Handle : ValueType {
    private int _value;
    private byte _vType;
    public static ModuleDefinitionHandle ModuleDefinition;
    public static AssemblyDefinitionHandle AssemblyDefinition;
    internal int RowId { get; }
    internal int Offset { get; }
    internal UInt32 EntityHandleType { get; }
    internal UInt32 Type { get; }
    internal UInt32 EntityHandleValue { get; }
    internal UInt32 SpecificEntityHandleValue { get; }
    internal byte VType { get; }
    internal bool IsVirtual { get; }
    internal bool IsHeapHandle { get; }
    public HandleKind Kind { get; }
    public bool IsNil { get; }
    internal bool IsEntityOrUserStringHandle { get; }
    internal int Token { get; }
    internal Handle(byte vType, int value);
    private static Handle();
    internal static Handle FromVToken(UInt32 vToken);
    internal int get_RowId();
    internal int get_Offset();
    internal UInt32 get_EntityHandleType();
    internal UInt32 get_Type();
    internal UInt32 get_EntityHandleValue();
    internal UInt32 get_SpecificEntityHandleValue();
    internal byte get_VType();
    internal bool get_IsVirtual();
    internal bool get_IsHeapHandle();
    public HandleKind get_Kind();
    public bool get_IsNil();
    internal bool get_IsEntityOrUserStringHandle();
    internal int get_Token();
    public virtual bool Equals(object obj);
    public sealed virtual bool Equals(Handle other);
    public virtual int GetHashCode();
    public static bool op_Equality(Handle left, Handle right);
    public static bool op_Inequality(Handle left, Handle right);
    internal static int Compare(Handle left, Handle right);
    internal static void ThrowInvalidCast();
    internal static void ThrowInvalidCodedIndex();
}
public class System.Reflection.Metadata.HandleComparer : object {
    private static HandleComparer _default;
    public static HandleComparer Default { get; }
    private static HandleComparer();
    public static HandleComparer get_Default();
    public sealed virtual bool Equals(Handle x, Handle y);
    public sealed virtual bool Equals(EntityHandle x, EntityHandle y);
    public sealed virtual int GetHashCode(Handle obj);
    public sealed virtual int GetHashCode(EntityHandle obj);
    public sealed virtual int Compare(Handle x, Handle y);
    public sealed virtual int Compare(EntityHandle x, EntityHandle y);
}
public enum System.Reflection.Metadata.HandleKind : Enum {
    public byte value__;
    public static HandleKind ModuleDefinition;
    public static HandleKind TypeReference;
    public static HandleKind TypeDefinition;
    public static HandleKind FieldDefinition;
    public static HandleKind MethodDefinition;
    public static HandleKind Parameter;
    public static HandleKind InterfaceImplementation;
    public static HandleKind MemberReference;
    public static HandleKind Constant;
    public static HandleKind CustomAttribute;
    public static HandleKind DeclarativeSecurityAttribute;
    public static HandleKind StandaloneSignature;
    public static HandleKind EventDefinition;
    public static HandleKind PropertyDefinition;
    public static HandleKind MethodImplementation;
    public static HandleKind ModuleReference;
    public static HandleKind TypeSpecification;
    public static HandleKind AssemblyDefinition;
    public static HandleKind AssemblyFile;
    public static HandleKind AssemblyReference;
    public static HandleKind ExportedType;
    public static HandleKind GenericParameter;
    public static HandleKind MethodSpecification;
    public static HandleKind GenericParameterConstraint;
    public static HandleKind ManifestResource;
    public static HandleKind NamespaceDefinition;
    public static HandleKind UserString;
    public static HandleKind String;
    public static HandleKind Blob;
    public static HandleKind Guid;
}
[ExtensionAttribute]
internal static class System.Reflection.Metadata.HandleKindExtensions : object {
    [ExtensionAttribute]
internal static bool IsHeapHandle(HandleKind kind);
}
public class System.Reflection.Metadata.InterfaceImplementation : ValueType {
    private MetadataReader _reader;
    private int _rowId;
    private InterfaceImplementationHandle Handle { get; }
    public EntityHandle Interface { get; }
    internal InterfaceImplementation(MetadataReader reader, InterfaceImplementationHandle handle);
    private InterfaceImplementationHandle get_Handle();
    public EntityHandle get_Interface();
    public CustomAttributeHandleCollection GetCustomAttributes();
}
public class System.Reflection.Metadata.InterfaceImplementationHandle : ValueType {
    private static UInt32 tokenType;
    private static byte tokenTypeSmall;
    private int _rowId;
    public bool IsNil { get; }
    internal int RowId { get; }
    internal InterfaceImplementationHandle(int rowId);
    internal static InterfaceImplementationHandle FromRowId(int rowId);
    public static Handle op_Implicit(InterfaceImplementationHandle handle);
    public static EntityHandle op_Implicit(InterfaceImplementationHandle handle);
    public static InterfaceImplementationHandle op_Explicit(Handle handle);
    public static InterfaceImplementationHandle op_Explicit(EntityHandle handle);
    public bool get_IsNil();
    internal int get_RowId();
    public static bool op_Equality(InterfaceImplementationHandle left, InterfaceImplementationHandle right);
    public virtual bool Equals(object obj);
    public sealed virtual bool Equals(InterfaceImplementationHandle other);
    public virtual int GetHashCode();
    public static bool op_Inequality(InterfaceImplementationHandle left, InterfaceImplementationHandle right);
}
public class System.Reflection.Metadata.InterfaceImplementationHandleCollection : ValueType {
    private MetadataReader _reader;
    private int _firstRowId;
    private int _lastRowId;
    public int Count { get; }
    internal InterfaceImplementationHandleCollection(MetadataReader reader, TypeDefinitionHandle implementingType);
    public sealed virtual int get_Count();
    public Enumerator GetEnumerator();
    private sealed virtual override IEnumerator`1<InterfaceImplementationHandle> System.Collections.Generic.IEnumerable<System.Reflection.Metadata.InterfaceImplementationHandle>.GetEnumerator();
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
}
public class System.Reflection.Metadata.ManifestResource : ValueType {
    private MetadataReader _reader;
    private int _rowId;
    private ManifestResourceHandle Handle { get; }
    public long Offset { get; }
    public ManifestResourceAttributes Attributes { get; }
    public StringHandle Name { get; }
    public EntityHandle Implementation { get; }
    internal ManifestResource(MetadataReader reader, ManifestResourceHandle handle);
    private ManifestResourceHandle get_Handle();
    public long get_Offset();
    public ManifestResourceAttributes get_Attributes();
    public StringHandle get_Name();
    public EntityHandle get_Implementation();
    public CustomAttributeHandleCollection GetCustomAttributes();
}
public class System.Reflection.Metadata.ManifestResourceHandle : ValueType {
    private static UInt32 tokenType;
    private static byte tokenTypeSmall;
    private int _rowId;
    public bool IsNil { get; }
    internal int RowId { get; }
    private ManifestResourceHandle(int rowId);
    internal static ManifestResourceHandle FromRowId(int rowId);
    public static Handle op_Implicit(ManifestResourceHandle handle);
    public static EntityHandle op_Implicit(ManifestResourceHandle handle);
    public static ManifestResourceHandle op_Explicit(Handle handle);
    public static ManifestResourceHandle op_Explicit(EntityHandle handle);
    public bool get_IsNil();
    internal int get_RowId();
    public static bool op_Equality(ManifestResourceHandle left, ManifestResourceHandle right);
    public virtual bool Equals(object obj);
    public sealed virtual bool Equals(ManifestResourceHandle other);
    public virtual int GetHashCode();
    public static bool op_Inequality(ManifestResourceHandle left, ManifestResourceHandle right);
}
public class System.Reflection.Metadata.ManifestResourceHandleCollection : ValueType {
    private int _lastRowId;
    public int Count { get; }
    internal ManifestResourceHandleCollection(int lastRowId);
    public sealed virtual int get_Count();
    public Enumerator GetEnumerator();
    private sealed virtual override IEnumerator`1<ManifestResourceHandle> System.Collections.Generic.IEnumerable<System.Reflection.Metadata.ManifestResourceHandle>.GetEnumerator();
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
}
public class System.Reflection.Metadata.MemberReference : ValueType {
    private MetadataReader _reader;
    private UInt32 _treatmentAndRowId;
    private int RowId { get; }
    private MemberRefTreatment Treatment { get; }
    private MemberReferenceHandle Handle { get; }
    public EntityHandle Parent { get; }
    public StringHandle Name { get; }
    public BlobHandle Signature { get; }
    internal MemberReference(MetadataReader reader, UInt32 treatmentAndRowId);
    private int get_RowId();
    private MemberRefTreatment get_Treatment();
    private MemberReferenceHandle get_Handle();
    public EntityHandle get_Parent();
    public StringHandle get_Name();
    public BlobHandle get_Signature();
    public MemberReferenceKind GetKind();
    public CustomAttributeHandleCollection GetCustomAttributes();
    private EntityHandle GetProjectedParent();
    private StringHandle GetProjectedName();
    private BlobHandle GetProjectedSignature();
}
public class System.Reflection.Metadata.MemberReferenceHandle : ValueType {
    private static UInt32 tokenType;
    private static byte tokenTypeSmall;
    private int _rowId;
    public bool IsNil { get; }
    internal int RowId { get; }
    private MemberReferenceHandle(int rowId);
    internal static MemberReferenceHandle FromRowId(int rowId);
    public static Handle op_Implicit(MemberReferenceHandle handle);
    public static EntityHandle op_Implicit(MemberReferenceHandle handle);
    public static MemberReferenceHandle op_Explicit(Handle handle);
    public static MemberReferenceHandle op_Explicit(EntityHandle handle);
    public bool get_IsNil();
    internal int get_RowId();
    public static bool op_Equality(MemberReferenceHandle left, MemberReferenceHandle right);
    public virtual bool Equals(object obj);
    public sealed virtual bool Equals(MemberReferenceHandle other);
    public virtual int GetHashCode();
    public static bool op_Inequality(MemberReferenceHandle left, MemberReferenceHandle right);
}
public class System.Reflection.Metadata.MemberReferenceHandleCollection : ValueType {
    private int _lastRowId;
    public int Count { get; }
    internal MemberReferenceHandleCollection(int lastRowId);
    public sealed virtual int get_Count();
    public Enumerator GetEnumerator();
    private sealed virtual override IEnumerator`1<MemberReferenceHandle> System.Collections.Generic.IEnumerable<System.Reflection.Metadata.MemberReferenceHandle>.GetEnumerator();
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
}
public enum System.Reflection.Metadata.MemberReferenceKind : Enum {
    public int value__;
    public static MemberReferenceKind Method;
    public static MemberReferenceKind Field;
}
public enum System.Reflection.Metadata.MetadataKind : Enum {
    public int value__;
    public static MetadataKind Ecma335;
    public static MetadataKind WindowsMetadata;
    public static MetadataKind ManagedWindowsMetadata;
}
public class System.Reflection.Metadata.MetadataReader : object {
    private static int SmallIndexSize;
    private static int LargeIndexSize;
    internal static string ClrPrefix;
    private MetadataReaderOptions _options;
    internal MetadataStringDecoder utf8Decoder;
    internal NamespaceCache namespaceCache;
    private Dictionary`2<TypeDefinitionHandle, ImmutableArray`1<TypeDefinitionHandle>> _lazyNestedTypesMap;
    internal MemoryBlock Block;
    internal int WinMDMscorlibRef;
    private MetadataHeader _metadataHeader;
    private MetadataKind _metadataKind;
    private MetadataStreamKind _metadataStreamKind;
    internal StringStreamReader StringStream;
    internal BlobStreamReader BlobStream;
    internal GuidStreamReader GuidStream;
    internal UserStringStreamReader UserStringStream;
    internal bool IsMinimalDelta;
    private MetadataTableHeader _MetadataTableHeader;
    internal Int32[] TableRowCounts;
    internal ModuleTableReader ModuleTable;
    internal TypeRefTableReader TypeRefTable;
    internal TypeDefTableReader TypeDefTable;
    internal FieldPtrTableReader FieldPtrTable;
    internal FieldTableReader FieldTable;
    internal MethodPtrTableReader MethodPtrTable;
    internal MethodTableReader MethodDefTable;
    internal ParamPtrTableReader ParamPtrTable;
    internal ParamTableReader ParamTable;
    internal InterfaceImplTableReader InterfaceImplTable;
    internal MemberRefTableReader MemberRefTable;
    internal ConstantTableReader ConstantTable;
    internal CustomAttributeTableReader CustomAttributeTable;
    internal FieldMarshalTableReader FieldMarshalTable;
    internal DeclSecurityTableReader DeclSecurityTable;
    internal ClassLayoutTableReader ClassLayoutTable;
    internal FieldLayoutTableReader FieldLayoutTable;
    internal StandAloneSigTableReader StandAloneSigTable;
    internal EventMapTableReader EventMapTable;
    internal EventPtrTableReader EventPtrTable;
    internal EventTableReader EventTable;
    internal PropertyMapTableReader PropertyMapTable;
    internal PropertyPtrTableReader PropertyPtrTable;
    internal PropertyTableReader PropertyTable;
    internal MethodSemanticsTableReader MethodSemanticsTable;
    internal MethodImplTableReader MethodImplTable;
    internal ModuleRefTableReader ModuleRefTable;
    internal TypeSpecTableReader TypeSpecTable;
    internal ImplMapTableReader ImplMapTable;
    internal FieldRVATableReader FieldRvaTable;
    internal EnCLogTableReader EncLogTable;
    internal EnCMapTableReader EncMapTable;
    internal AssemblyTableReader AssemblyTable;
    internal AssemblyProcessorTableReader AssemblyProcessorTable;
    internal AssemblyOSTableReader AssemblyOSTable;
    internal AssemblyRefTableReader AssemblyRefTable;
    internal AssemblyRefProcessorTableReader AssemblyRefProcessorTable;
    internal AssemblyRefOSTableReader AssemblyRefOSTable;
    internal FileTableReader FileTable;
    internal ExportedTypeTableReader ExportedTypeTable;
    internal ManifestResourceTableReader ManifestResourceTable;
    internal NestedClassTableReader NestedClassTable;
    internal GenericParamTableReader GenericParamTable;
    internal MethodSpecTableReader MethodSpecTable;
    internal GenericParamConstraintTableReader GenericParamConstraintTable;
    internal static Byte[] WinRTPrefix;
    private static String[] s_projectedTypeNames;
    private static ProjectionInfo[] s_projectionInfos;
    internal NamespaceCache NamespaceCache { get; }
    internal bool UseFieldPtrTable { get; }
    internal bool UseMethodPtrTable { get; }
    internal bool UseParamPtrTable { get; }
    internal bool UseEventPtrTable { get; }
    internal bool UsePropertyPtrTable { get; }
    public MetadataReaderOptions Options { get; }
    public string MetadataVersion { get; }
    public MetadataKind MetadataKind { get; }
    public MetadataStringComparer StringComparer { get; }
    public bool IsAssembly { get; }
    public AssemblyReferenceHandleCollection AssemblyReferences { get; }
    public TypeDefinitionHandleCollection TypeDefinitions { get; }
    public TypeReferenceHandleCollection TypeReferences { get; }
    public CustomAttributeHandleCollection CustomAttributes { get; }
    public DeclarativeSecurityAttributeHandleCollection DeclarativeSecurityAttributes { get; }
    public MemberReferenceHandleCollection MemberReferences { get; }
    public ManifestResourceHandleCollection ManifestResources { get; }
    public AssemblyFileHandleCollection AssemblyFiles { get; }
    public ExportedTypeHandleCollection ExportedTypes { get; }
    public MethodDefinitionHandleCollection MethodDefinitions { get; }
    public FieldDefinitionHandleCollection FieldDefinitions { get; }
    public EventDefinitionHandleCollection EventDefinitions { get; }
    public PropertyDefinitionHandleCollection PropertyDefinitions { get; }
    public MetadataReader(Byte* metadata, int length);
    public MetadataReader(Byte* metadata, int length, MetadataReaderOptions options);
    public MetadataReader(Byte* metadata, int length, MetadataReaderOptions options, MetadataStringDecoder utf8Decoder);
    private static MetadataReader();
    private void ReadMetadataHeader(BlobReader& memReader);
    private MetadataKind GetMetadataKind(string versionString);
    private StreamHeader[] ReadStreamHeaders(BlobReader& memReader);
    private void InitializeStreamReaders(MemoryBlock& metadataRoot, StreamHeader[] streamHeaders, MemoryBlock& metadataTableStream);
    private void ReadMetadataTableHeader(BlobReader& memReader, Int32[]& metadataTableRowCounts);
    private void InitializeTableReaders(MemoryBlock metadataTablesMemoryBlock, Int32[] compressedRowCounts);
    private int ComputeCodedTokenSize(int largeRowSize, Int32[] rowCountArray, TableMask tablesReferenced);
    private bool IsDeclaredSorted(TableMask index);
    internal NamespaceCache get_NamespaceCache();
    internal bool get_UseFieldPtrTable();
    internal bool get_UseMethodPtrTable();
    internal bool get_UseParamPtrTable();
    internal bool get_UseEventPtrTable();
    internal bool get_UsePropertyPtrTable();
    internal void GetFieldRange(TypeDefinitionHandle typeDef, Int32& firstFieldRowId, Int32& lastFieldRowId);
    internal void GetMethodRange(TypeDefinitionHandle typeDef, Int32& firstMethodRowId, Int32& lastMethodRowId);
    internal void GetEventRange(TypeDefinitionHandle typeDef, Int32& firstEventRowId, Int32& lastEventRowId);
    internal void GetPropertyRange(TypeDefinitionHandle typeDef, Int32& firstPropertyRowId, Int32& lastPropertyRowId);
    internal void GetParameterRange(MethodDefinitionHandle methodDef, Int32& firstParamRowId, Int32& lastParamRowId);
    private static void ThrowValueArgumentNull();
    internal static void ThrowTableNotSorted(TableIndex tableIndex);
    public MetadataReaderOptions get_Options();
    public string get_MetadataVersion();
    public MetadataKind get_MetadataKind();
    public MetadataStringComparer get_StringComparer();
    public bool get_IsAssembly();
    public AssemblyReferenceHandleCollection get_AssemblyReferences();
    public TypeDefinitionHandleCollection get_TypeDefinitions();
    public TypeReferenceHandleCollection get_TypeReferences();
    public CustomAttributeHandleCollection get_CustomAttributes();
    public DeclarativeSecurityAttributeHandleCollection get_DeclarativeSecurityAttributes();
    public MemberReferenceHandleCollection get_MemberReferences();
    public ManifestResourceHandleCollection get_ManifestResources();
    public AssemblyFileHandleCollection get_AssemblyFiles();
    public ExportedTypeHandleCollection get_ExportedTypes();
    public MethodDefinitionHandleCollection get_MethodDefinitions();
    public FieldDefinitionHandleCollection get_FieldDefinitions();
    public EventDefinitionHandleCollection get_EventDefinitions();
    public PropertyDefinitionHandleCollection get_PropertyDefinitions();
    public AssemblyDefinition GetAssemblyDefinition();
    public string GetString(StringHandle handle);
    public string GetString(NamespaceDefinitionHandle handle);
    public Byte[] GetBlobBytes(BlobHandle handle);
    public ImmutableArray`1<byte> GetBlobContent(BlobHandle handle);
    public BlobReader GetBlobReader(BlobHandle handle);
    public string GetUserString(UserStringHandle handle);
    public Guid GetGuid(GuidHandle handle);
    public ModuleDefinition GetModuleDefinition();
    public AssemblyReference GetAssemblyReference(AssemblyReferenceHandle handle);
    public TypeDefinition GetTypeDefinition(TypeDefinitionHandle handle);
    public NamespaceDefinition GetNamespaceDefinitionRoot();
    public NamespaceDefinition GetNamespaceDefinition(NamespaceDefinitionHandle handle);
    private UInt32 GetTypeDefTreatmentAndRowId(TypeDefinitionHandle handle);
    public TypeReference GetTypeReference(TypeReferenceHandle handle);
    private UInt32 GetTypeRefTreatmentAndRowId(TypeReferenceHandle handle);
    public ExportedType GetExportedType(ExportedTypeHandle handle);
    public CustomAttributeHandleCollection GetCustomAttributes(EntityHandle handle);
    public CustomAttribute GetCustomAttribute(CustomAttributeHandle handle);
    private UInt32 GetCustomAttributeTreatmentAndRowId(CustomAttributeHandle handle);
    public DeclarativeSecurityAttribute GetDeclarativeSecurityAttribute(DeclarativeSecurityAttributeHandle handle);
    public Constant GetConstant(ConstantHandle handle);
    public MethodDefinition GetMethodDefinition(MethodDefinitionHandle handle);
    private UInt32 GetMethodDefTreatmentAndRowId(MethodDefinitionHandle handle);
    public FieldDefinition GetFieldDefinition(FieldDefinitionHandle handle);
    private UInt32 GetFieldDefTreatmentAndRowId(FieldDefinitionHandle handle);
    public PropertyDefinition GetPropertyDefinition(PropertyDefinitionHandle handle);
    public EventDefinition GetEventDefinition(EventDefinitionHandle handle);
    public MethodImplementation GetMethodImplementation(MethodImplementationHandle handle);
    public MemberReference GetMemberReference(MemberReferenceHandle handle);
    private UInt32 GetMemberRefTreatmentAndRowId(MemberReferenceHandle handle);
    public MethodSpecification GetMethodSpecification(MethodSpecificationHandle handle);
    public Parameter GetParameter(ParameterHandle handle);
    public GenericParameter GetGenericParameter(GenericParameterHandle handle);
    public GenericParameterConstraint GetGenericParameterConstraint(GenericParameterConstraintHandle handle);
    public ManifestResource GetManifestResource(ManifestResourceHandle handle);
    public AssemblyFile GetAssemblyFile(AssemblyFileHandle handle);
    public StandaloneSignature GetStandaloneSignature(StandaloneSignatureHandle handle);
    public TypeSpecification GetTypeSpecification(TypeSpecificationHandle handle);
    public ModuleReference GetModuleReference(ModuleReferenceHandle handle);
    public InterfaceImplementation GetInterfaceImplementation(InterfaceImplementationHandle handle);
    internal TypeDefinitionHandle GetDeclaringType(MethodDefinitionHandle methodDef);
    internal TypeDefinitionHandle GetDeclaringType(FieldDefinitionHandle fieldDef);
    private void InitializeNestedTypesMap();
    internal ImmutableArray`1<TypeDefinitionHandle> GetNestedTypes(TypeDefinitionHandle typeDef);
    private TypeDefTreatment GetWellKnownTypeDefinitionTreatment(TypeDefinitionHandle typeDef);
    private int GetProjectionIndexForTypeReference(TypeReferenceHandle typeRef, Boolean& isIDisposable);
    internal static AssemblyReferenceHandle GetProjectedAssemblyRef(int projectionIndex);
    internal static StringHandle GetProjectedName(int projectionIndex);
    internal static StringHandle GetProjectedNamespace(int projectionIndex);
    private static void InitializeProjectedTypes();
    [ConditionalAttribute("DEBUG")]
private static void AssertSorted(String[] keys);
    internal static String[] GetProjectedTypeNames();
    private static UInt32 TreatmentAndRowId(byte treatment, int rowId);
    internal UInt32 CalculateTypeDefTreatmentAndRowId(TypeDefinitionHandle handle);
    private bool IsClrImplementationType(TypeDefinitionHandle typeDef);
    internal UInt32 CalculateTypeRefTreatmentAndRowId(TypeReferenceHandle handle);
    private TypeRefTreatment GetSpecialTypeRefTreatment(TypeReferenceHandle handle);
    private bool IsSystemAttribute(TypeReferenceHandle handle);
    private bool IsSystemEnum(TypeReferenceHandle handle);
    private bool NeedsWinRTPrefix(TypeAttributes flags, EntityHandle extends);
    private UInt32 CalculateMethodDefTreatmentAndRowId(MethodDefinitionHandle methodDef);
    private MethodDefTreatment GetMethodTreatmentFromCustomAttributes(MethodDefinitionHandle methodDef);
    private UInt32 CalculateFieldDefTreatmentAndRowId(FieldDefinitionHandle handle);
    private UInt32 CalculateMemberRefTreatmentAndRowId(MemberReferenceHandle handle);
    private bool ImplementsRedirectedInterface(MemberReferenceHandle memberRef, Boolean& isIDisposable);
    private int FindMscorlibAssemblyRefNoProjection();
    internal CustomAttributeValueTreatment CalculateCustomAttributeValueTreatment(CustomAttributeHandle handle);
    private bool IsWindowsAttributeUsageAttribute(EntityHandle targetType, CustomAttributeHandle attributeHandle);
    private bool HasAttribute(EntityHandle token, string asciiNamespaceName, string asciiTypeName);
    private bool GetAttributeTypeNameRaw(CustomAttributeHandle caHandle, StringHandle& namespaceName, StringHandle& typeName);
    private EntityHandle GetAttributeTypeRaw(CustomAttributeHandle handle);
}
[FlagsAttribute]
public enum System.Reflection.Metadata.MetadataReaderOptions : Enum {
    public int value__;
    public static MetadataReaderOptions None;
    public static MetadataReaderOptions Default;
    public static MetadataReaderOptions ApplyWindowsRuntimeProjections;
}
[CompilerGeneratedAttribute]
[GeneratedCodeAttribute("System.Resources.Tools.StronglyTypedResourceBuilder", "4.0.0.0")]
[DebuggerNonUserCodeAttribute]
internal class System.Reflection.Metadata.MetadataResources : object {
    private static ResourceManager resourceMan;
    private static CultureInfo resourceCulture;
    [EditorBrowsableAttribute("2")]
internal static ResourceManager ResourceManager { get; }
    [EditorBrowsableAttribute("2")]
internal static CultureInfo Culture { get; internal set; }
    internal static string AssemblyTableInvalidNumberOfRows { get; }
    internal static string CantGetOffsetForVirtualHeapHandle { get; }
    internal static string EnCMapNotSorted { get; }
    internal static string HandleBelongsToFutureGeneration { get; }
    internal static string IllegalTablesInCompressedMetadataStream { get; }
    internal static string ImageTooSmall { get; }
    internal static string ImageTooSmallOrContainsInvalidOffsetOrCount { get; }
    internal static string InvalidCodedIndex { get; }
    internal static string InvalidCompressedInteger { get; }
    internal static string InvalidCorHeaderSize { get; }
    internal static string InvalidHandle { get; }
    internal static string InvalidLocalSignatureToken { get; }
    internal static string InvalidMetadataSectionSpan { get; }
    internal static string InvalidMetadataStreamFormat { get; }
    internal static string InvalidMethodHeader1 { get; }
    internal static string InvalidMethodHeader2 { get; }
    internal static string InvalidMethodRva { get; }
    internal static string InvalidNumberOfSections { get; }
    internal static string InvalidPESignature { get; }
    internal static string InvalidRowCount { get; }
    internal static string InvalidSectionName { get; }
    internal static string InvalidSehHeader { get; }
    internal static string InvalidSerializedString { get; }
    internal static string InvalidSignature { get; }
    internal static string InvalidToken { get; }
    internal static string InvalidTypeSize { get; }
    internal static string LitteEndianArchitectureRequired { get; }
    internal static string MetadataHeaderTooSmall { get; }
    internal static string MetadataImageDoesNotRepresentAnAssembly { get; }
    internal static string MetadataSignature { get; }
    internal static string MetadataStringDecoderEncodingMustBeUtf8 { get; }
    internal static string MetadataTableHeaderTooSmall { get; }
    internal static string MetadataTableNotSorted { get; }
    internal static string MetadataTablesTooSmall { get; }
    internal static string MissingDataDirectory { get; }
    internal static string ModuleTableInvalidNumberOfRows { get; }
    internal static string NegativeByteCountOrOffset { get; }
    internal static string NotEnoughSpaceForBlobStream { get; }
    internal static string NotEnoughSpaceForGUIDStream { get; }
    internal static string NotEnoughSpaceForMetadataStream { get; }
    internal static string NotEnoughSpaceForStreamHeaderName { get; }
    internal static string NotEnoughSpaceForStringStream { get; }
    internal static string NotEnoughSpaceForVersionString { get; }
    internal static string NotMetadataHeapHandle { get; }
    internal static string NotMetadataTableHandle { get; }
    internal static string NotMetadataTableOrUserStringHandle { get; }
    internal static string OutOfBoundsRead { get; }
    internal static string PEImageDoesNotHaveMetadata { get; }
    internal static string PEImageNotAvailable { get; }
    internal static string RowIdOrHeapOffsetTooLarge { get; }
    internal static string SectionTooSmall { get; }
    internal static string StreamHeaderTooSmall { get; }
    internal static string StreamMustSupportReadAndSeek { get; }
    internal static string StreamTooLarge { get; }
    internal static string TableRowCountSpaceTooSmall { get; }
    internal static string UnableToReadMetadataFile { get; }
    internal static string UnexpectedStreamEnd { get; }
    internal static string UnknownFileFormat { get; }
    internal static string UnknownPEMagicValue { get; }
    internal static string UnknownTables { get; }
    internal static string WinMDMissingMscorlibRef { get; }
    internal static ResourceManager get_ResourceManager();
    internal static CultureInfo get_Culture();
    internal static void set_Culture(CultureInfo value);
    internal static string get_AssemblyTableInvalidNumberOfRows();
    internal static string get_CantGetOffsetForVirtualHeapHandle();
    internal static string get_EnCMapNotSorted();
    internal static string get_HandleBelongsToFutureGeneration();
    internal static string get_IllegalTablesInCompressedMetadataStream();
    internal static string get_ImageTooSmall();
    internal static string get_ImageTooSmallOrContainsInvalidOffsetOrCount();
    internal static string get_InvalidCodedIndex();
    internal static string get_InvalidCompressedInteger();
    internal static string get_InvalidCorHeaderSize();
    internal static string get_InvalidHandle();
    internal static string get_InvalidLocalSignatureToken();
    internal static string get_InvalidMetadataSectionSpan();
    internal static string get_InvalidMetadataStreamFormat();
    internal static string get_InvalidMethodHeader1();
    internal static string get_InvalidMethodHeader2();
    internal static string get_InvalidMethodRva();
    internal static string get_InvalidNumberOfSections();
    internal static string get_InvalidPESignature();
    internal static string get_InvalidRowCount();
    internal static string get_InvalidSectionName();
    internal static string get_InvalidSehHeader();
    internal static string get_InvalidSerializedString();
    internal static string get_InvalidSignature();
    internal static string get_InvalidToken();
    internal static string get_InvalidTypeSize();
    internal static string get_LitteEndianArchitectureRequired();
    internal static string get_MetadataHeaderTooSmall();
    internal static string get_MetadataImageDoesNotRepresentAnAssembly();
    internal static string get_MetadataSignature();
    internal static string get_MetadataStringDecoderEncodingMustBeUtf8();
    internal static string get_MetadataTableHeaderTooSmall();
    internal static string get_MetadataTableNotSorted();
    internal static string get_MetadataTablesTooSmall();
    internal static string get_MissingDataDirectory();
    internal static string get_ModuleTableInvalidNumberOfRows();
    internal static string get_NegativeByteCountOrOffset();
    internal static string get_NotEnoughSpaceForBlobStream();
    internal static string get_NotEnoughSpaceForGUIDStream();
    internal static string get_NotEnoughSpaceForMetadataStream();
    internal static string get_NotEnoughSpaceForStreamHeaderName();
    internal static string get_NotEnoughSpaceForStringStream();
    internal static string get_NotEnoughSpaceForVersionString();
    internal static string get_NotMetadataHeapHandle();
    internal static string get_NotMetadataTableHandle();
    internal static string get_NotMetadataTableOrUserStringHandle();
    internal static string get_OutOfBoundsRead();
    internal static string get_PEImageDoesNotHaveMetadata();
    internal static string get_PEImageNotAvailable();
    internal static string get_RowIdOrHeapOffsetTooLarge();
    internal static string get_SectionTooSmall();
    internal static string get_StreamHeaderTooSmall();
    internal static string get_StreamMustSupportReadAndSeek();
    internal static string get_StreamTooLarge();
    internal static string get_TableRowCountSpaceTooSmall();
    internal static string get_UnableToReadMetadataFile();
    internal static string get_UnexpectedStreamEnd();
    internal static string get_UnknownFileFormat();
    internal static string get_UnknownPEMagicValue();
    internal static string get_UnknownTables();
    internal static string get_WinMDMissingMscorlibRef();
}
public class System.Reflection.Metadata.MetadataStringComparer : ValueType {
    private MetadataReader _reader;
    internal MetadataStringComparer(MetadataReader reader);
    public bool Equals(StringHandle handle, string value);
    public bool Equals(NamespaceDefinitionHandle handle, string value);
    public bool StartsWith(StringHandle handle, string value);
    private static void ThrowValueArgumentNull();
}
public class System.Reflection.Metadata.MetadataStringDecoder : object {
    private static MetadataStringDecoder s_defaultUTF8;
    private Encoding _encoding;
    public static MetadataStringDecoder DefaultUTF8 { get; }
    public Encoding Encoding { get; }
    public MetadataStringDecoder(Encoding encoding);
    private static MetadataStringDecoder();
    public static MetadataStringDecoder get_DefaultUTF8();
    public Encoding get_Encoding();
    public virtual string GetString(Byte* bytes, int byteCount);
}
public class System.Reflection.Metadata.MethodBodyBlock : object {
    private static byte ILTinyFormat;
    private static byte ILFatFormat;
    private static byte ILFormatMask;
    private static int ILTinyFormatSizeShift;
    private static byte ILMoreSects;
    private static byte ILInitLocals;
    private static byte ILFatFormatHeaderSize;
    private static int ILFatFormatHeaderSizeShift;
    private static byte SectEHTable;
    private static byte SectOptILTable;
    private static byte SectFatFormat;
    private static byte SectMoreSects;
    private MemoryBlock _il;
    private int _size;
    private ushort _maxStack;
    private bool _localVariablesInitialized;
    private StandaloneSignatureHandle _localSignature;
    private ImmutableArray`1<ExceptionRegion> _exceptionRegions;
    public int Size { get; }
    public int MaxStack { get; }
    public bool LocalVariablesInitialized { get; }
    public StandaloneSignatureHandle LocalSignature { get; }
    public ImmutableArray`1<ExceptionRegion> ExceptionRegions { get; }
    private MethodBodyBlock(bool localVariablesInitialized, ushort maxStack, StandaloneSignatureHandle localSignatureHandle, MemoryBlock il, ImmutableArray`1<ExceptionRegion> exceptionRegions, int size);
    public int get_Size();
    public int get_MaxStack();
    public bool get_LocalVariablesInitialized();
    public StandaloneSignatureHandle get_LocalSignature();
    public ImmutableArray`1<ExceptionRegion> get_ExceptionRegions();
    public Byte[] GetILBytes();
    public ImmutableArray`1<byte> GetILContent();
    public BlobReader GetILReader();
    public static MethodBodyBlock Create(BlobReader reader);
    private static ImmutableArray`1<ExceptionRegion> ReadSmallExceptionHandlers(BlobReader& memReader, int count);
    private static ImmutableArray`1<ExceptionRegion> ReadFatExceptionHandlers(BlobReader& memReader, int count);
}
public class System.Reflection.Metadata.MethodDefinition : ValueType {
    private MetadataReader _reader;
    private UInt32 _treatmentAndRowId;
    private int RowId { get; }
    private MethodDefTreatment Treatment { get; }
    private MethodDefinitionHandle Handle { get; }
    public StringHandle Name { get; }
    public BlobHandle Signature { get; }
    public int RelativeVirtualAddress { get; }
    public MethodAttributes Attributes { get; }
    public MethodImplAttributes ImplAttributes { get; }
    internal MethodDefinition(MetadataReader reader, UInt32 treatmentAndRowId);
    private int get_RowId();
    private MethodDefTreatment get_Treatment();
    private MethodDefinitionHandle get_Handle();
    public StringHandle get_Name();
    public BlobHandle get_Signature();
    public int get_RelativeVirtualAddress();
    public MethodAttributes get_Attributes();
    public MethodImplAttributes get_ImplAttributes();
    public TypeDefinitionHandle GetDeclaringType();
    public ParameterHandleCollection GetParameters();
    public GenericParameterHandleCollection GetGenericParameters();
    public MethodImport GetImport();
    public CustomAttributeHandleCollection GetCustomAttributes();
    public DeclarativeSecurityAttributeHandleCollection GetDeclarativeSecurityAttributes();
    private StringHandle GetProjectedName();
    private MethodAttributes GetProjectedFlags();
    private MethodImplAttributes GetProjectedImplFlags();
    private BlobHandle GetProjectedSignature();
    private int GetProjectedRelativeVirtualAddress();
}
public class System.Reflection.Metadata.MethodDefinitionHandle : ValueType {
    private static UInt32 tokenType;
    private static byte tokenTypeSmall;
    private int _rowId;
    public bool IsNil { get; }
    internal int RowId { get; }
    private MethodDefinitionHandle(int rowId);
    internal static MethodDefinitionHandle FromRowId(int rowId);
    public static Handle op_Implicit(MethodDefinitionHandle handle);
    public static EntityHandle op_Implicit(MethodDefinitionHandle handle);
    public static MethodDefinitionHandle op_Explicit(Handle handle);
    public static MethodDefinitionHandle op_Explicit(EntityHandle handle);
    public bool get_IsNil();
    internal int get_RowId();
    public static bool op_Equality(MethodDefinitionHandle left, MethodDefinitionHandle right);
    public virtual bool Equals(object obj);
    public sealed virtual bool Equals(MethodDefinitionHandle other);
    public virtual int GetHashCode();
    public static bool op_Inequality(MethodDefinitionHandle left, MethodDefinitionHandle right);
}
public class System.Reflection.Metadata.MethodDefinitionHandleCollection : ValueType {
    private MetadataReader _reader;
    private int _firstRowId;
    private int _lastRowId;
    public int Count { get; }
    internal MethodDefinitionHandleCollection(MetadataReader reader);
    internal MethodDefinitionHandleCollection(MetadataReader reader, TypeDefinitionHandle containingType);
    public sealed virtual int get_Count();
    public Enumerator GetEnumerator();
    private sealed virtual override IEnumerator`1<MethodDefinitionHandle> System.Collections.Generic.IEnumerable<System.Reflection.Metadata.MethodDefinitionHandle>.GetEnumerator();
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
}
public class System.Reflection.Metadata.MethodImplementation : ValueType {
    private MetadataReader _reader;
    private int _rowId;
    private MethodImplementationHandle Handle { get; }
    public TypeDefinitionHandle Type { get; }
    public EntityHandle MethodBody { get; }
    public EntityHandle MethodDeclaration { get; }
    internal MethodImplementation(MetadataReader reader, MethodImplementationHandle handle);
    private MethodImplementationHandle get_Handle();
    public TypeDefinitionHandle get_Type();
    public EntityHandle get_MethodBody();
    public EntityHandle get_MethodDeclaration();
    public CustomAttributeHandleCollection GetCustomAttributes();
}
public class System.Reflection.Metadata.MethodImplementationHandle : ValueType {
    private static UInt32 tokenType;
    private static byte tokenTypeSmall;
    private int _rowId;
    public bool IsNil { get; }
    internal int RowId { get; }
    private MethodImplementationHandle(int rowId);
    internal static MethodImplementationHandle FromRowId(int rowId);
    public static Handle op_Implicit(MethodImplementationHandle handle);
    public static EntityHandle op_Implicit(MethodImplementationHandle handle);
    public static MethodImplementationHandle op_Explicit(Handle handle);
    public static MethodImplementationHandle op_Explicit(EntityHandle handle);
    public bool get_IsNil();
    internal int get_RowId();
    public static bool op_Equality(MethodImplementationHandle left, MethodImplementationHandle right);
    public virtual bool Equals(object obj);
    public sealed virtual bool Equals(MethodImplementationHandle other);
    public virtual int GetHashCode();
    public static bool op_Inequality(MethodImplementationHandle left, MethodImplementationHandle right);
}
public class System.Reflection.Metadata.MethodImplementationHandleCollection : ValueType {
    private int _firstRowId;
    private int _lastRowId;
    public int Count { get; }
    internal MethodImplementationHandleCollection(MetadataReader reader, TypeDefinitionHandle containingType);
    public sealed virtual int get_Count();
    public Enumerator GetEnumerator();
    private sealed virtual override IEnumerator`1<MethodImplementationHandle> System.Collections.Generic.IEnumerable<System.Reflection.Metadata.MethodImplementationHandle>.GetEnumerator();
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
}
public class System.Reflection.Metadata.MethodImport : ValueType {
    private MethodImportAttributes _attributes;
    private StringHandle _name;
    private ModuleReferenceHandle _module;
    public MethodImportAttributes Attributes { get; }
    public StringHandle Name { get; }
    public ModuleReferenceHandle Module { get; }
    internal MethodImport(MethodImportAttributes attributes, StringHandle name, ModuleReferenceHandle module);
    public MethodImportAttributes get_Attributes();
    public StringHandle get_Name();
    public ModuleReferenceHandle get_Module();
}
public class System.Reflection.Metadata.MethodSpecification : ValueType {
    private MetadataReader _reader;
    private int _rowId;
    private MethodSpecificationHandle Handle { get; }
    public EntityHandle Method { get; }
    public BlobHandle Signature { get; }
    internal MethodSpecification(MetadataReader reader, MethodSpecificationHandle handle);
    private MethodSpecificationHandle get_Handle();
    public EntityHandle get_Method();
    public BlobHandle get_Signature();
    public CustomAttributeHandleCollection GetCustomAttributes();
}
public class System.Reflection.Metadata.MethodSpecificationHandle : ValueType {
    private static UInt32 tokenType;
    private static byte tokenTypeSmall;
    private int _rowId;
    public bool IsNil { get; }
    internal int RowId { get; }
    private MethodSpecificationHandle(int rowId);
    internal static MethodSpecificationHandle FromRowId(int rowId);
    public static Handle op_Implicit(MethodSpecificationHandle handle);
    public static EntityHandle op_Implicit(MethodSpecificationHandle handle);
    public static MethodSpecificationHandle op_Explicit(Handle handle);
    public static MethodSpecificationHandle op_Explicit(EntityHandle handle);
    public bool get_IsNil();
    internal int get_RowId();
    public static bool op_Equality(MethodSpecificationHandle left, MethodSpecificationHandle right);
    public virtual bool Equals(object obj);
    public sealed virtual bool Equals(MethodSpecificationHandle other);
    public virtual int GetHashCode();
    public static bool op_Inequality(MethodSpecificationHandle left, MethodSpecificationHandle right);
}
public class System.Reflection.Metadata.ModuleDefinition : ValueType {
    private MetadataReader _reader;
    public int Generation { get; }
    public StringHandle Name { get; }
    public GuidHandle Mvid { get; }
    public GuidHandle GenerationId { get; }
    public GuidHandle BaseGenerationId { get; }
    internal ModuleDefinition(MetadataReader reader);
    public int get_Generation();
    public StringHandle get_Name();
    public GuidHandle get_Mvid();
    public GuidHandle get_GenerationId();
    public GuidHandle get_BaseGenerationId();
}
public class System.Reflection.Metadata.ModuleDefinitionHandle : ValueType {
    private static UInt32 tokenType;
    private static byte tokenTypeSmall;
    private int _rowId;
    public bool IsNil { get; }
    internal int RowId { get; }
    internal ModuleDefinitionHandle(int rowId);
    internal static ModuleDefinitionHandle FromRowId(int rowId);
    public static Handle op_Implicit(ModuleDefinitionHandle handle);
    public static EntityHandle op_Implicit(ModuleDefinitionHandle handle);
    public static ModuleDefinitionHandle op_Explicit(Handle handle);
    public static ModuleDefinitionHandle op_Explicit(EntityHandle handle);
    public bool get_IsNil();
    internal int get_RowId();
    public static bool op_Equality(ModuleDefinitionHandle left, ModuleDefinitionHandle right);
    public virtual bool Equals(object obj);
    public sealed virtual bool Equals(ModuleDefinitionHandle other);
    public virtual int GetHashCode();
    public static bool op_Inequality(ModuleDefinitionHandle left, ModuleDefinitionHandle right);
}
public class System.Reflection.Metadata.ModuleReference : ValueType {
    private MetadataReader _reader;
    private int _rowId;
    private ModuleReferenceHandle Handle { get; }
    public StringHandle Name { get; }
    internal ModuleReference(MetadataReader reader, ModuleReferenceHandle handle);
    private ModuleReferenceHandle get_Handle();
    public StringHandle get_Name();
    public CustomAttributeHandleCollection GetCustomAttributes();
}
public class System.Reflection.Metadata.ModuleReferenceHandle : ValueType {
    private static UInt32 tokenType;
    private static byte tokenTypeSmall;
    private int _rowId;
    public bool IsNil { get; }
    internal int RowId { get; }
    private ModuleReferenceHandle(int rowId);
    internal static ModuleReferenceHandle FromRowId(int rowId);
    public static Handle op_Implicit(ModuleReferenceHandle handle);
    public static EntityHandle op_Implicit(ModuleReferenceHandle handle);
    public static ModuleReferenceHandle op_Explicit(Handle handle);
    public static ModuleReferenceHandle op_Explicit(EntityHandle handle);
    public bool get_IsNil();
    internal int get_RowId();
    public static bool op_Equality(ModuleReferenceHandle left, ModuleReferenceHandle right);
    public virtual bool Equals(object obj);
    public sealed virtual bool Equals(ModuleReferenceHandle other);
    public virtual int GetHashCode();
    public static bool op_Inequality(ModuleReferenceHandle left, ModuleReferenceHandle right);
}
public class System.Reflection.Metadata.NamespaceDefinition : ValueType {
    private NamespaceData _data;
    public StringHandle Name { get; }
    public NamespaceDefinitionHandle Parent { get; }
    public ImmutableArray`1<NamespaceDefinitionHandle> NamespaceDefinitions { get; }
    public ImmutableArray`1<TypeDefinitionHandle> TypeDefinitions { get; }
    public ImmutableArray`1<ExportedTypeHandle> ExportedTypes { get; }
    internal NamespaceDefinition(NamespaceData data);
    public StringHandle get_Name();
    public NamespaceDefinitionHandle get_Parent();
    public ImmutableArray`1<NamespaceDefinitionHandle> get_NamespaceDefinitions();
    public ImmutableArray`1<TypeDefinitionHandle> get_TypeDefinitions();
    public ImmutableArray`1<ExportedTypeHandle> get_ExportedTypes();
}
public class System.Reflection.Metadata.NamespaceDefinitionHandle : ValueType {
    private UInt32 _value;
    public bool IsNil { get; }
    internal bool IsVirtual { get; }
    internal NamespaceKind NamespaceKind { get; }
    internal bool HasFullName { get; }
    private NamespaceDefinitionHandle(UInt32 value);
    internal static NamespaceDefinitionHandle FromFullNameOffset(int stringHeapOffset);
    internal static NamespaceDefinitionHandle FromSimpleNameOffset(int stringHeapOffset);
    public static Handle op_Implicit(NamespaceDefinitionHandle handle);
    public static NamespaceDefinitionHandle op_Explicit(Handle handle);
    public bool get_IsNil();
    internal bool get_IsVirtual();
    internal int GetHeapOffset();
    internal NamespaceKind get_NamespaceKind();
    internal bool get_HasFullName();
    internal StringHandle GetFullName();
    public virtual bool Equals(object obj);
    public sealed virtual bool Equals(NamespaceDefinitionHandle other);
    public virtual int GetHashCode();
    public static bool op_Equality(NamespaceDefinitionHandle left, NamespaceDefinitionHandle right);
    public static bool op_Inequality(NamespaceDefinitionHandle left, NamespaceDefinitionHandle right);
}
public class System.Reflection.Metadata.Parameter : ValueType {
    private MetadataReader _reader;
    private int _rowId;
    private ParameterHandle Handle { get; }
    public ParameterAttributes Attributes { get; }
    public int SequenceNumber { get; }
    public StringHandle Name { get; }
    internal Parameter(MetadataReader reader, ParameterHandle handle);
    private ParameterHandle get_Handle();
    public ParameterAttributes get_Attributes();
    public int get_SequenceNumber();
    public StringHandle get_Name();
    public ConstantHandle GetDefaultValue();
    public BlobHandle GetMarshallingDescriptor();
    public CustomAttributeHandleCollection GetCustomAttributes();
}
public class System.Reflection.Metadata.ParameterHandle : ValueType {
    private static UInt32 tokenType;
    private static byte tokenTypeSmall;
    private int _rowId;
    public bool IsNil { get; }
    internal int RowId { get; }
    private ParameterHandle(int rowId);
    internal static ParameterHandle FromRowId(int rowId);
    public static Handle op_Implicit(ParameterHandle handle);
    public static EntityHandle op_Implicit(ParameterHandle handle);
    public static ParameterHandle op_Explicit(Handle handle);
    public static ParameterHandle op_Explicit(EntityHandle handle);
    public bool get_IsNil();
    internal int get_RowId();
    public static bool op_Equality(ParameterHandle left, ParameterHandle right);
    public virtual bool Equals(object obj);
    public sealed virtual bool Equals(ParameterHandle other);
    public virtual int GetHashCode();
    public static bool op_Inequality(ParameterHandle left, ParameterHandle right);
}
public class System.Reflection.Metadata.ParameterHandleCollection : ValueType {
    private MetadataReader _reader;
    private int _firstRowId;
    private int _lastRowId;
    public int Count { get; }
    internal ParameterHandleCollection(MetadataReader reader, MethodDefinitionHandle containingMethod);
    public sealed virtual int get_Count();
    public Enumerator GetEnumerator();
    private sealed virtual override IEnumerator`1<ParameterHandle> System.Collections.Generic.IEnumerable<System.Reflection.Metadata.ParameterHandle>.GetEnumerator();
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
}
[ExtensionAttribute]
[EditorBrowsableAttribute("1")]
public static class System.Reflection.Metadata.PEReaderExtensions : object {
    [ExtensionAttribute]
public static MethodBodyBlock GetMethodBody(PEReader peReader, int relativeVirtualAddress);
    [ExtensionAttribute]
public static MetadataReader GetMetadataReader(PEReader peReader);
    [ExtensionAttribute]
public static MetadataReader GetMetadataReader(PEReader peReader, MetadataReaderOptions options);
    [ExtensionAttribute]
public static MetadataReader GetMetadataReader(PEReader peReader, MetadataReaderOptions options, MetadataStringDecoder utf8Decoder);
}
public class System.Reflection.Metadata.PropertyAccessors : ValueType {
    private int _getterRowId;
    private int _setterRowId;
    public MethodDefinitionHandle Getter { get; }
    public MethodDefinitionHandle Setter { get; }
    internal PropertyAccessors(int getterRowId, int setterRowId);
    public MethodDefinitionHandle get_Getter();
    public MethodDefinitionHandle get_Setter();
}
public class System.Reflection.Metadata.PropertyDefinition : ValueType {
    private MetadataReader _reader;
    private int _rowId;
    private PropertyDefinitionHandle Handle { get; }
    public StringHandle Name { get; }
    public PropertyAttributes Attributes { get; }
    public BlobHandle Signature { get; }
    internal PropertyDefinition(MetadataReader reader, PropertyDefinitionHandle handle);
    private PropertyDefinitionHandle get_Handle();
    public StringHandle get_Name();
    public PropertyAttributes get_Attributes();
    public BlobHandle get_Signature();
    public ConstantHandle GetDefaultValue();
    public CustomAttributeHandleCollection GetCustomAttributes();
    public PropertyAccessors GetAccessors();
}
public class System.Reflection.Metadata.PropertyDefinitionHandle : ValueType {
    private static UInt32 tokenType;
    private static byte tokenTypeSmall;
    private int _rowId;
    public bool IsNil { get; }
    internal int RowId { get; }
    private PropertyDefinitionHandle(int rowId);
    internal static PropertyDefinitionHandle FromRowId(int rowId);
    public static Handle op_Implicit(PropertyDefinitionHandle handle);
    public static EntityHandle op_Implicit(PropertyDefinitionHandle handle);
    public static PropertyDefinitionHandle op_Explicit(Handle handle);
    public static PropertyDefinitionHandle op_Explicit(EntityHandle handle);
    public bool get_IsNil();
    internal int get_RowId();
    public static bool op_Equality(PropertyDefinitionHandle left, PropertyDefinitionHandle right);
    public virtual bool Equals(object obj);
    public sealed virtual bool Equals(PropertyDefinitionHandle other);
    public virtual int GetHashCode();
    public static bool op_Inequality(PropertyDefinitionHandle left, PropertyDefinitionHandle right);
}
public class System.Reflection.Metadata.PropertyDefinitionHandleCollection : ValueType {
    private MetadataReader _reader;
    private int _firstRowId;
    private int _lastRowId;
    public int Count { get; }
    internal PropertyDefinitionHandleCollection(MetadataReader reader);
    internal PropertyDefinitionHandleCollection(MetadataReader reader, TypeDefinitionHandle containingType);
    public sealed virtual int get_Count();
    public Enumerator GetEnumerator();
    private sealed virtual override IEnumerator`1<PropertyDefinitionHandle> System.Collections.Generic.IEnumerable<System.Reflection.Metadata.PropertyDefinitionHandle>.GetEnumerator();
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
}
public enum System.Reflection.Metadata.SerializationTypeCode : Enum {
    public byte value__;
    public static SerializationTypeCode Invalid;
    public static SerializationTypeCode Boolean;
    public static SerializationTypeCode Char;
    public static SerializationTypeCode SByte;
    public static SerializationTypeCode Byte;
    public static SerializationTypeCode Int16;
    public static SerializationTypeCode UInt16;
    public static SerializationTypeCode Int32;
    public static SerializationTypeCode UInt32;
    public static SerializationTypeCode Int64;
    public static SerializationTypeCode UInt64;
    public static SerializationTypeCode Single;
    public static SerializationTypeCode Double;
    public static SerializationTypeCode String;
    public static SerializationTypeCode SZArray;
    public static SerializationTypeCode Type;
    public static SerializationTypeCode TaggedObject;
    public static SerializationTypeCode Enum;
}
[FlagsAttribute]
public enum System.Reflection.Metadata.SignatureAttributes : Enum {
    public byte value__;
    public static SignatureAttributes None;
    public static SignatureAttributes Generic;
    public static SignatureAttributes Instance;
    public static SignatureAttributes ExplicitThis;
}
public enum System.Reflection.Metadata.SignatureCallingConvention : Enum {
    public byte value__;
    public static SignatureCallingConvention Default;
    public static SignatureCallingConvention CDecl;
    public static SignatureCallingConvention StdCall;
    public static SignatureCallingConvention ThisCall;
    public static SignatureCallingConvention FastCall;
    public static SignatureCallingConvention VarArgs;
}
public class System.Reflection.Metadata.SignatureHeader : ValueType {
    public static byte CallingConventionOrKindMask;
    private static byte maxCallingConvention;
    private byte _rawValue;
    public byte RawValue { get; }
    public SignatureCallingConvention CallingConvention { get; }
    public SignatureKind Kind { get; }
    public SignatureAttributes Attributes { get; }
    public bool HasExplicitThis { get; }
    public bool IsInstance { get; }
    public bool IsGeneric { get; }
    public SignatureHeader(byte rawValue);
    public byte get_RawValue();
    public SignatureCallingConvention get_CallingConvention();
    public SignatureKind get_Kind();
    public SignatureAttributes get_Attributes();
    public bool get_HasExplicitThis();
    public bool get_IsInstance();
    public bool get_IsGeneric();
    public virtual bool Equals(object obj);
    public sealed virtual bool Equals(SignatureHeader other);
    public virtual int GetHashCode();
    public static bool op_Equality(SignatureHeader left, SignatureHeader right);
    public static bool op_Inequality(SignatureHeader left, SignatureHeader right);
    public virtual string ToString();
}
public enum System.Reflection.Metadata.SignatureKind : Enum {
    public byte value__;
    public static SignatureKind Method;
    public static SignatureKind Field;
    public static SignatureKind LocalVariables;
    public static SignatureKind Property;
    public static SignatureKind MethodSpecification;
}
public enum System.Reflection.Metadata.SignatureTypeCode : Enum {
    public byte value__;
    public static SignatureTypeCode Invalid;
    public static SignatureTypeCode Void;
    public static SignatureTypeCode Boolean;
    public static SignatureTypeCode Char;
    public static SignatureTypeCode SByte;
    public static SignatureTypeCode Byte;
    public static SignatureTypeCode Int16;
    public static SignatureTypeCode UInt16;
    public static SignatureTypeCode Int32;
    public static SignatureTypeCode UInt32;
    public static SignatureTypeCode Int64;
    public static SignatureTypeCode UInt64;
    public static SignatureTypeCode Single;
    public static SignatureTypeCode Double;
    public static SignatureTypeCode String;
    public static SignatureTypeCode Pointer;
    public static SignatureTypeCode ByReference;
    public static SignatureTypeCode GenericTypeParameter;
    public static SignatureTypeCode Array;
    public static SignatureTypeCode GenericTypeInstance;
    public static SignatureTypeCode TypedReference;
    public static SignatureTypeCode IntPtr;
    public static SignatureTypeCode UIntPtr;
    public static SignatureTypeCode FunctionPointer;
    public static SignatureTypeCode Object;
    public static SignatureTypeCode SZArray;
    public static SignatureTypeCode GenericMethodParameter;
    public static SignatureTypeCode RequiredModifier;
    public static SignatureTypeCode OptionalModifier;
    public static SignatureTypeCode TypeHandle;
    public static SignatureTypeCode Sentinel;
    public static SignatureTypeCode Pinned;
}
public class System.Reflection.Metadata.StandaloneSignature : ValueType {
    private MetadataReader _reader;
    private int _rowId;
    private StandaloneSignatureHandle Handle { get; }
    public BlobHandle Signature { get; }
    internal StandaloneSignature(MetadataReader reader, StandaloneSignatureHandle handle);
    private StandaloneSignatureHandle get_Handle();
    public BlobHandle get_Signature();
    public CustomAttributeHandleCollection GetCustomAttributes();
}
public class System.Reflection.Metadata.StandaloneSignatureHandle : ValueType {
    private static UInt32 tokenType;
    private static byte tokenTypeSmall;
    private int _rowId;
    public bool IsNil { get; }
    internal int RowId { get; }
    private StandaloneSignatureHandle(int rowId);
    internal static StandaloneSignatureHandle FromRowId(int rowId);
    public static Handle op_Implicit(StandaloneSignatureHandle handle);
    public static EntityHandle op_Implicit(StandaloneSignatureHandle handle);
    public static StandaloneSignatureHandle op_Explicit(Handle handle);
    public static StandaloneSignatureHandle op_Explicit(EntityHandle handle);
    public bool get_IsNil();
    internal int get_RowId();
    public static bool op_Equality(StandaloneSignatureHandle left, StandaloneSignatureHandle right);
    public virtual bool Equals(object obj);
    public sealed virtual bool Equals(StandaloneSignatureHandle other);
    public virtual int GetHashCode();
    public static bool op_Inequality(StandaloneSignatureHandle left, StandaloneSignatureHandle right);
}
public class System.Reflection.Metadata.StringHandle : ValueType {
    private UInt32 _value;
    internal bool IsVirtual { get; }
    public bool IsNil { get; }
    internal StringKind StringKind { get; }
    private StringHandle(UInt32 value);
    internal static StringHandle FromOffset(int heapOffset);
    internal static StringHandle FromVirtualIndex(VirtualIndex virtualIndex);
    internal StringHandle WithWinRTPrefix();
    internal StringHandle WithDotTermination();
    internal StringHandle SuffixRaw(int prefixByteLength);
    public static Handle op_Implicit(StringHandle handle);
    public static StringHandle op_Explicit(Handle handle);
    internal bool get_IsVirtual();
    public bool get_IsNil();
    internal int GetHeapOffset();
    internal VirtualIndex GetVirtualIndex();
    internal StringKind get_StringKind();
    public virtual bool Equals(object obj);
    public sealed virtual bool Equals(StringHandle other);
    public virtual int GetHashCode();
    public static bool op_Equality(StringHandle left, StringHandle right);
    public static bool op_Inequality(StringHandle left, StringHandle right);
}
public class System.Reflection.Metadata.TypeDefinition : ValueType {
    private MetadataReader _reader;
    private UInt32 _treatmentAndRowId;
    private int RowId { get; }
    private TypeDefTreatment Treatment { get; }
    private TypeDefinitionHandle Handle { get; }
    public TypeAttributes Attributes { get; }
    public StringHandle Name { get; }
    public StringHandle Namespace { get; }
    public NamespaceDefinitionHandle NamespaceDefinition { get; }
    public EntityHandle BaseType { get; }
    internal TypeDefinition(MetadataReader reader, UInt32 treatmentAndRowId);
    private int get_RowId();
    private TypeDefTreatment get_Treatment();
    private TypeDefinitionHandle get_Handle();
    public TypeAttributes get_Attributes();
    public StringHandle get_Name();
    public StringHandle get_Namespace();
    public NamespaceDefinitionHandle get_NamespaceDefinition();
    public EntityHandle get_BaseType();
    public TypeLayout GetLayout();
    public TypeDefinitionHandle GetDeclaringType();
    public GenericParameterHandleCollection GetGenericParameters();
    public MethodDefinitionHandleCollection GetMethods();
    public FieldDefinitionHandleCollection GetFields();
    public PropertyDefinitionHandleCollection GetProperties();
    public EventDefinitionHandleCollection GetEvents();
    public ImmutableArray`1<TypeDefinitionHandle> GetNestedTypes();
    public MethodImplementationHandleCollection GetMethodImplementations();
    public InterfaceImplementationHandleCollection GetInterfaceImplementations();
    public CustomAttributeHandleCollection GetCustomAttributes();
    public DeclarativeSecurityAttributeHandleCollection GetDeclarativeSecurityAttributes();
    private TypeAttributes GetProjectedFlags();
    private StringHandle GetProjectedName();
    private NamespaceDefinitionHandle GetProjectedNamespace();
    private StringHandle GetProjectedNamespaceString();
    private EntityHandle GetProjectedBaseType();
}
public class System.Reflection.Metadata.TypeDefinitionHandle : ValueType {
    private static UInt32 tokenType;
    private static byte tokenTypeSmall;
    private int _rowId;
    public bool IsNil { get; }
    internal int RowId { get; }
    private TypeDefinitionHandle(int rowId);
    internal static TypeDefinitionHandle FromRowId(int rowId);
    public static Handle op_Implicit(TypeDefinitionHandle handle);
    public static EntityHandle op_Implicit(TypeDefinitionHandle handle);
    public static TypeDefinitionHandle op_Explicit(Handle handle);
    public static TypeDefinitionHandle op_Explicit(EntityHandle handle);
    public bool get_IsNil();
    internal int get_RowId();
    public static bool op_Equality(TypeDefinitionHandle left, TypeDefinitionHandle right);
    public virtual bool Equals(object obj);
    public sealed virtual bool Equals(TypeDefinitionHandle other);
    public virtual int GetHashCode();
    public static bool op_Inequality(TypeDefinitionHandle left, TypeDefinitionHandle right);
}
public class System.Reflection.Metadata.TypeDefinitionHandleCollection : ValueType {
    private int _lastRowId;
    public int Count { get; }
    internal TypeDefinitionHandleCollection(int lastRowId);
    public sealed virtual int get_Count();
    public Enumerator GetEnumerator();
    private sealed virtual override IEnumerator`1<TypeDefinitionHandle> System.Collections.Generic.IEnumerable<System.Reflection.Metadata.TypeDefinitionHandle>.GetEnumerator();
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
}
public class System.Reflection.Metadata.TypeLayout : ValueType {
    private int _size;
    private int _packingSize;
    public int Size { get; }
    public int PackingSize { get; }
    public bool IsDefault { get; }
    public TypeLayout(int size, int packingSize);
    public int get_Size();
    public int get_PackingSize();
    public bool get_IsDefault();
}
public class System.Reflection.Metadata.TypeReference : ValueType {
    private MetadataReader _reader;
    private UInt32 _treatmentAndRowId;
    private int RowId { get; }
    private TypeRefTreatment Treatment { get; }
    private TypeReferenceHandle Handle { get; }
    public EntityHandle ResolutionScope { get; }
    public StringHandle Name { get; }
    public StringHandle Namespace { get; }
    internal TypeReference(MetadataReader reader, UInt32 treatmentAndRowId);
    private int get_RowId();
    private TypeRefTreatment get_Treatment();
    private TypeReferenceHandle get_Handle();
    public EntityHandle get_ResolutionScope();
    public StringHandle get_Name();
    public StringHandle get_Namespace();
    private EntityHandle GetProjectedResolutionScope();
    private StringHandle GetProjectedName();
    private StringHandle GetProjectedNamespace();
}
public class System.Reflection.Metadata.TypeReferenceHandle : ValueType {
    private static UInt32 tokenType;
    private static byte tokenTypeSmall;
    private int _rowId;
    public bool IsNil { get; }
    internal int RowId { get; }
    private TypeReferenceHandle(int rowId);
    internal static TypeReferenceHandle FromRowId(int rowId);
    public static Handle op_Implicit(TypeReferenceHandle handle);
    public static EntityHandle op_Implicit(TypeReferenceHandle handle);
    public static TypeReferenceHandle op_Explicit(Handle handle);
    public static TypeReferenceHandle op_Explicit(EntityHandle handle);
    public bool get_IsNil();
    internal int get_RowId();
    public static bool op_Equality(TypeReferenceHandle left, TypeReferenceHandle right);
    public virtual bool Equals(object obj);
    public sealed virtual bool Equals(TypeReferenceHandle other);
    public virtual int GetHashCode();
    public static bool op_Inequality(TypeReferenceHandle left, TypeReferenceHandle right);
}
public class System.Reflection.Metadata.TypeReferenceHandleCollection : ValueType {
    private int _lastRowId;
    public int Count { get; }
    internal TypeReferenceHandleCollection(int lastRowId);
    public sealed virtual int get_Count();
    public Enumerator GetEnumerator();
    private sealed virtual override IEnumerator`1<TypeReferenceHandle> System.Collections.Generic.IEnumerable<System.Reflection.Metadata.TypeReferenceHandle>.GetEnumerator();
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
}
public class System.Reflection.Metadata.TypeSpecification : ValueType {
    private MetadataReader _reader;
    private int _rowId;
    private TypeSpecificationHandle Handle { get; }
    public BlobHandle Signature { get; }
    internal TypeSpecification(MetadataReader reader, TypeSpecificationHandle handle);
    private TypeSpecificationHandle get_Handle();
    public BlobHandle get_Signature();
    public CustomAttributeHandleCollection GetCustomAttributes();
}
public class System.Reflection.Metadata.TypeSpecificationHandle : ValueType {
    private static UInt32 tokenType;
    private static byte tokenTypeSmall;
    private int _rowId;
    public bool IsNil { get; }
    internal int RowId { get; }
    private TypeSpecificationHandle(int rowId);
    internal static TypeSpecificationHandle FromRowId(int rowId);
    public static Handle op_Implicit(TypeSpecificationHandle handle);
    public static EntityHandle op_Implicit(TypeSpecificationHandle handle);
    public static TypeSpecificationHandle op_Explicit(Handle handle);
    public static TypeSpecificationHandle op_Explicit(EntityHandle handle);
    public bool get_IsNil();
    internal int get_RowId();
    public static bool op_Equality(TypeSpecificationHandle left, TypeSpecificationHandle right);
    public virtual bool Equals(object obj);
    public sealed virtual bool Equals(TypeSpecificationHandle other);
    public virtual int GetHashCode();
    public static bool op_Inequality(TypeSpecificationHandle left, TypeSpecificationHandle right);
}
public class System.Reflection.Metadata.UserStringHandle : ValueType {
    private int _offset;
    public bool IsNil { get; }
    private UserStringHandle(int offset);
    internal static UserStringHandle FromOffset(int heapOffset);
    public static Handle op_Implicit(UserStringHandle handle);
    public static UserStringHandle op_Explicit(Handle handle);
    public bool get_IsNil();
    internal int GetHeapOffset();
    public static bool op_Equality(UserStringHandle left, UserStringHandle right);
    public virtual bool Equals(object obj);
    public sealed virtual bool Equals(UserStringHandle other);
    public virtual int GetHashCode();
    public static bool op_Inequality(UserStringHandle left, UserStringHandle right);
}
[FlagsAttribute]
public enum System.Reflection.MethodImportAttributes : Enum {
    public short value__;
    public static MethodImportAttributes None;
    public static MethodImportAttributes ExactSpelling;
    public static MethodImportAttributes BestFitMappingDisable;
    public static MethodImportAttributes BestFitMappingEnable;
    public static MethodImportAttributes BestFitMappingMask;
    public static MethodImportAttributes CharSetAnsi;
    public static MethodImportAttributes CharSetUnicode;
    public static MethodImportAttributes CharSetAuto;
    public static MethodImportAttributes CharSetMask;
    public static MethodImportAttributes ThrowOnUnmappableCharEnable;
    public static MethodImportAttributes ThrowOnUnmappableCharDisable;
    public static MethodImportAttributes ThrowOnUnmappableCharMask;
    public static MethodImportAttributes SetLastError;
    public static MethodImportAttributes CallingConventionWinApi;
    public static MethodImportAttributes CallingConventionCDecl;
    public static MethodImportAttributes CallingConventionStdCall;
    public static MethodImportAttributes CallingConventionThisCall;
    public static MethodImportAttributes CallingConventionFastCall;
    public static MethodImportAttributes CallingConventionMask;
}
[FlagsAttribute]
internal enum System.Reflection.MethodSemanticsAttributes : Enum {
    public int value__;
    public static MethodSemanticsAttributes Setter;
    public static MethodSemanticsAttributes Getter;
    public static MethodSemanticsAttributes Other;
    public static MethodSemanticsAttributes Adder;
    public static MethodSemanticsAttributes Remover;
    public static MethodSemanticsAttributes Raiser;
}
public enum System.Reflection.PortableExecutable.Characteristics : Enum {
    public ushort value__;
    public static Characteristics RelocsStripped;
    public static Characteristics ExecutableImage;
    public static Characteristics LineNumsStripped;
    public static Characteristics LocalSymsStripped;
    public static Characteristics AggressiveWSTrim;
    public static Characteristics LargeAddressAware;
    public static Characteristics BytesReversedLo;
    public static Characteristics Bit32Machine;
    public static Characteristics DebugStripped;
    public static Characteristics RemovableRunFromSwap;
    public static Characteristics NetRunFromSwap;
    public static Characteristics System;
    public static Characteristics Dll;
    public static Characteristics UpSystemOnly;
    public static Characteristics BytesReversedHi;
}
public class System.Reflection.PortableExecutable.CoffHeader : object {
    [CompilerGeneratedAttribute]
private Machine <Machine>k__BackingField;
    [CompilerGeneratedAttribute]
private short <NumberOfSections>k__BackingField;
    [CompilerGeneratedAttribute]
private int <TimeDateStamp>k__BackingField;
    [CompilerGeneratedAttribute]
private int <PointerToSymbolTable>k__BackingField;
    [CompilerGeneratedAttribute]
private int <NumberOfSymbols>k__BackingField;
    [CompilerGeneratedAttribute]
private short <SizeOfOptionalHeader>k__BackingField;
    [CompilerGeneratedAttribute]
private Characteristics <Characteristics>k__BackingField;
    public Machine Machine { get; private set; }
    public short NumberOfSections { get; private set; }
    public int TimeDateStamp { get; private set; }
    public int PointerToSymbolTable { get; private set; }
    public int NumberOfSymbols { get; private set; }
    public short SizeOfOptionalHeader { get; private set; }
    public Characteristics Characteristics { get; private set; }
    internal CoffHeader(PEBinaryReader& reader);
    [CompilerGeneratedAttribute]
public Machine get_Machine();
    [CompilerGeneratedAttribute]
private void set_Machine(Machine value);
    [CompilerGeneratedAttribute]
public short get_NumberOfSections();
    [CompilerGeneratedAttribute]
private void set_NumberOfSections(short value);
    [CompilerGeneratedAttribute]
public int get_TimeDateStamp();
    [CompilerGeneratedAttribute]
private void set_TimeDateStamp(int value);
    [CompilerGeneratedAttribute]
public int get_PointerToSymbolTable();
    [CompilerGeneratedAttribute]
private void set_PointerToSymbolTable(int value);
    [CompilerGeneratedAttribute]
public int get_NumberOfSymbols();
    [CompilerGeneratedAttribute]
private void set_NumberOfSymbols(int value);
    [CompilerGeneratedAttribute]
public short get_SizeOfOptionalHeader();
    [CompilerGeneratedAttribute]
private void set_SizeOfOptionalHeader(short value);
    [CompilerGeneratedAttribute]
public Characteristics get_Characteristics();
    [CompilerGeneratedAttribute]
private void set_Characteristics(Characteristics value);
}
[FlagsAttribute]
public enum System.Reflection.PortableExecutable.CorFlags : Enum {
    public int value__;
    public static CorFlags ILOnly;
    public static CorFlags Requires32Bit;
    public static CorFlags ILLibrary;
    public static CorFlags StrongNameSigned;
    public static CorFlags NativeEntryPoint;
    public static CorFlags TrackDebugData;
    public static CorFlags Prefers32Bit;
}
public class System.Reflection.PortableExecutable.CorHeader : object {
    [CompilerGeneratedAttribute]
private ushort <MajorRuntimeVersion>k__BackingField;
    [CompilerGeneratedAttribute]
private ushort <MinorRuntimeVersion>k__BackingField;
    [CompilerGeneratedAttribute]
private DirectoryEntry <MetadataDirectory>k__BackingField;
    [CompilerGeneratedAttribute]
private CorFlags <Flags>k__BackingField;
    [CompilerGeneratedAttribute]
private int <EntryPointTokenOrRelativeVirtualAddress>k__BackingField;
    [CompilerGeneratedAttribute]
private DirectoryEntry <ResourcesDirectory>k__BackingField;
    [CompilerGeneratedAttribute]
private DirectoryEntry <StrongNameSignatureDirectory>k__BackingField;
    [CompilerGeneratedAttribute]
private DirectoryEntry <CodeManagerTableDirectory>k__BackingField;
    [CompilerGeneratedAttribute]
private DirectoryEntry <VtableFixupsDirectory>k__BackingField;
    [CompilerGeneratedAttribute]
private DirectoryEntry <ExportAddressTableJumpsDirectory>k__BackingField;
    [CompilerGeneratedAttribute]
private DirectoryEntry <ManagedNativeHeaderDirectory>k__BackingField;
    public ushort MajorRuntimeVersion { get; private set; }
    public ushort MinorRuntimeVersion { get; private set; }
    public DirectoryEntry MetadataDirectory { get; private set; }
    public CorFlags Flags { get; private set; }
    public int EntryPointTokenOrRelativeVirtualAddress { get; private set; }
    public DirectoryEntry ResourcesDirectory { get; private set; }
    public DirectoryEntry StrongNameSignatureDirectory { get; private set; }
    public DirectoryEntry CodeManagerTableDirectory { get; private set; }
    public DirectoryEntry VtableFixupsDirectory { get; private set; }
    public DirectoryEntry ExportAddressTableJumpsDirectory { get; private set; }
    public DirectoryEntry ManagedNativeHeaderDirectory { get; private set; }
    internal CorHeader(PEBinaryReader& reader);
    [CompilerGeneratedAttribute]
public ushort get_MajorRuntimeVersion();
    [CompilerGeneratedAttribute]
private void set_MajorRuntimeVersion(ushort value);
    [CompilerGeneratedAttribute]
public ushort get_MinorRuntimeVersion();
    [CompilerGeneratedAttribute]
private void set_MinorRuntimeVersion(ushort value);
    [CompilerGeneratedAttribute]
public DirectoryEntry get_MetadataDirectory();
    [CompilerGeneratedAttribute]
private void set_MetadataDirectory(DirectoryEntry value);
    [CompilerGeneratedAttribute]
public CorFlags get_Flags();
    [CompilerGeneratedAttribute]
private void set_Flags(CorFlags value);
    [CompilerGeneratedAttribute]
public int get_EntryPointTokenOrRelativeVirtualAddress();
    [CompilerGeneratedAttribute]
private void set_EntryPointTokenOrRelativeVirtualAddress(int value);
    [CompilerGeneratedAttribute]
public DirectoryEntry get_ResourcesDirectory();
    [CompilerGeneratedAttribute]
private void set_ResourcesDirectory(DirectoryEntry value);
    [CompilerGeneratedAttribute]
public DirectoryEntry get_StrongNameSignatureDirectory();
    [CompilerGeneratedAttribute]
private void set_StrongNameSignatureDirectory(DirectoryEntry value);
    [CompilerGeneratedAttribute]
public DirectoryEntry get_CodeManagerTableDirectory();
    [CompilerGeneratedAttribute]
private void set_CodeManagerTableDirectory(DirectoryEntry value);
    [CompilerGeneratedAttribute]
public DirectoryEntry get_VtableFixupsDirectory();
    [CompilerGeneratedAttribute]
private void set_VtableFixupsDirectory(DirectoryEntry value);
    [CompilerGeneratedAttribute]
public DirectoryEntry get_ExportAddressTableJumpsDirectory();
    [CompilerGeneratedAttribute]
private void set_ExportAddressTableJumpsDirectory(DirectoryEntry value);
    [CompilerGeneratedAttribute]
public DirectoryEntry get_ManagedNativeHeaderDirectory();
    [CompilerGeneratedAttribute]
private void set_ManagedNativeHeaderDirectory(DirectoryEntry value);
}
public class System.Reflection.PortableExecutable.DirectoryEntry : ValueType {
    public int RelativeVirtualAddress;
    public int Size;
    internal DirectoryEntry(PEBinaryReader& reader);
}
[FlagsAttribute]
public enum System.Reflection.PortableExecutable.DllCharacteristics : Enum {
    public ushort value__;
    public static DllCharacteristics ProcessInit;
    public static DllCharacteristics ProcessTerm;
    public static DllCharacteristics ThreadInit;
    public static DllCharacteristics ThreadTerm;
    public static DllCharacteristics DynamicBase;
    public static DllCharacteristics NxCompatible;
    public static DllCharacteristics NoIsolation;
    public static DllCharacteristics NoSeh;
    public static DllCharacteristics NoBind;
    public static DllCharacteristics AppContainer;
    public static DllCharacteristics WdmDriver;
    public static DllCharacteristics TerminalServerAware;
}
public enum System.Reflection.PortableExecutable.Machine : Enum {
    public ushort value__;
    public static Machine Unknown;
    public static Machine I386;
    public static Machine WceMipsV2;
    public static Machine Alpha;
    public static Machine SH3;
    public static Machine SH3Dsp;
    public static Machine SH3E;
    public static Machine SH4;
    public static Machine SH5;
    public static Machine Arm;
    public static Machine Thumb;
    public static Machine ArmThumb2;
    public static Machine AM33;
    public static Machine PowerPC;
    public static Machine PowerPCFP;
    public static Machine IA64;
    public static Machine MIPS16;
    public static Machine Alpha64;
    public static Machine MipsFpu;
    public static Machine MipsFpu16;
    public static Machine Tricore;
    public static Machine Ebc;
    public static Machine Amd64;
    public static Machine M32R;
}
internal class System.Reflection.PortableExecutable.PEBinaryReader : ValueType {
    private long _startOffset;
    private long _maxOffset;
    private BinaryReader _reader;
    public int CurrentOffset { get; }
    public PEBinaryReader(Stream stream, int size);
    public int get_CurrentOffset();
    public void Seek(int offset);
    public Byte[] ReadBytes(int count);
    public byte ReadByte();
    public short ReadInt16();
    public ushort ReadUInt16();
    public int ReadInt32();
    public UInt32 ReadUInt32();
    public ulong ReadUInt64();
    public string ReadUTF8(int byteCount);
    public static int GetAndValidateSize(Stream peStream, Nullable`1<int> size);
    private void CheckBounds(UInt32 count);
    private void CheckBounds(long startPosition, int count);
    private static void ThrowImageTooSmall();
    internal static void ThrowImageTooSmallOrContainsInvalidOffsetOrCount();
}
internal static class System.Reflection.PortableExecutable.PEFileConstants : object {
    internal static ushort DosSignature;
    internal static int PESignatureOffsetLocation;
    internal static UInt32 PESignature;
    internal static int BasicPEHeaderSize;
    internal static int SizeofCOFFFileHeader;
    internal static int SizeofOptionalHeaderStandardFields32;
    internal static int SizeofOptionalHeaderStandardFields64;
    internal static int SizeofOptionalHeaderNTAdditionalFields32;
    internal static int SizeofOptionalHeaderNTAdditionalFields64;
    internal static int NumberofOptionalHeaderDirectoryEntries;
    internal static int SizeofOptionalHeaderDirectoriesEntries;
    internal static int SizeofSectionHeader;
    internal static int SizeofSectionName;
    internal static int SizeofResourceDirectory;
    internal static int SizeofResourceDirectoryEntry;
}
public class System.Reflection.PortableExecutable.PEHeader : object {
    [CompilerGeneratedAttribute]
private PEMagic <Magic>k__BackingField;
    [CompilerGeneratedAttribute]
private byte <MajorLinkerVersion>k__BackingField;
    [CompilerGeneratedAttribute]
private byte <MinorLinkerVersion>k__BackingField;
    [CompilerGeneratedAttribute]
private int <SizeOfCode>k__BackingField;
    [CompilerGeneratedAttribute]
private int <SizeOfInitializedData>k__BackingField;
    [CompilerGeneratedAttribute]
private int <SizeOfUninitializedData>k__BackingField;
    [CompilerGeneratedAttribute]
private int <AddressOfEntryPoint>k__BackingField;
    [CompilerGeneratedAttribute]
private int <BaseOfCode>k__BackingField;
    [CompilerGeneratedAttribute]
private int <BaseOfData>k__BackingField;
    [CompilerGeneratedAttribute]
private ulong <ImageBase>k__BackingField;
    [CompilerGeneratedAttribute]
private int <SectionAlignment>k__BackingField;
    [CompilerGeneratedAttribute]
private int <FileAlignment>k__BackingField;
    [CompilerGeneratedAttribute]
private ushort <MajorOperatingSystemVersion>k__BackingField;
    [CompilerGeneratedAttribute]
private ushort <MinorOperatingSystemVersion>k__BackingField;
    [CompilerGeneratedAttribute]
private ushort <MajorImageVersion>k__BackingField;
    [CompilerGeneratedAttribute]
private ushort <MinorImageVersion>k__BackingField;
    [CompilerGeneratedAttribute]
private ushort <MajorSubsystemVersion>k__BackingField;
    [CompilerGeneratedAttribute]
private ushort <MinorSubsystemVersion>k__BackingField;
    [CompilerGeneratedAttribute]
private int <SizeOfImage>k__BackingField;
    [CompilerGeneratedAttribute]
private int <SizeOfHeaders>k__BackingField;
    [CompilerGeneratedAttribute]
private UInt32 <CheckSum>k__BackingField;
    [CompilerGeneratedAttribute]
private Subsystem <Subsystem>k__BackingField;
    [CompilerGeneratedAttribute]
private DllCharacteristics <DllCharacteristics>k__BackingField;
    [CompilerGeneratedAttribute]
private ulong <SizeOfStackReserve>k__BackingField;
    [CompilerGeneratedAttribute]
private ulong <SizeOfStackCommit>k__BackingField;
    [CompilerGeneratedAttribute]
private ulong <SizeOfHeapReserve>k__BackingField;
    [CompilerGeneratedAttribute]
private ulong <SizeOfHeapCommit>k__BackingField;
    [CompilerGeneratedAttribute]
private int <NumberOfRvaAndSizes>k__BackingField;
    [CompilerGeneratedAttribute]
private DirectoryEntry <ExportTableDirectory>k__BackingField;
    [CompilerGeneratedAttribute]
private DirectoryEntry <ImportTableDirectory>k__BackingField;
    [CompilerGeneratedAttribute]
private DirectoryEntry <ResourceTableDirectory>k__BackingField;
    [CompilerGeneratedAttribute]
private DirectoryEntry <ExceptionTableDirectory>k__BackingField;
    [CompilerGeneratedAttribute]
private DirectoryEntry <CertificateTableDirectory>k__BackingField;
    [CompilerGeneratedAttribute]
private DirectoryEntry <BaseRelocationTableDirectory>k__BackingField;
    [CompilerGeneratedAttribute]
private DirectoryEntry <DebugTableDirectory>k__BackingField;
    [CompilerGeneratedAttribute]
private DirectoryEntry <CopyrightTableDirectory>k__BackingField;
    [CompilerGeneratedAttribute]
private DirectoryEntry <GlobalPointerTableDirectory>k__BackingField;
    [CompilerGeneratedAttribute]
private DirectoryEntry <ThreadLocalStorageTableDirectory>k__BackingField;
    [CompilerGeneratedAttribute]
private DirectoryEntry <LoadConfigTableDirectory>k__BackingField;
    [CompilerGeneratedAttribute]
private DirectoryEntry <BoundImportTableDirectory>k__BackingField;
    [CompilerGeneratedAttribute]
private DirectoryEntry <ImportAddressTableDirectory>k__BackingField;
    [CompilerGeneratedAttribute]
private DirectoryEntry <DelayImportTableDirectory>k__BackingField;
    [CompilerGeneratedAttribute]
private DirectoryEntry <CorHeaderTableDirectory>k__BackingField;
    public PEMagic Magic { get; private set; }
    public byte MajorLinkerVersion { get; private set; }
    public byte MinorLinkerVersion { get; private set; }
    public int SizeOfCode { get; private set; }
    public int SizeOfInitializedData { get; private set; }
    public int SizeOfUninitializedData { get; private set; }
    public int AddressOfEntryPoint { get; private set; }
    public int BaseOfCode { get; private set; }
    public int BaseOfData { get; private set; }
    public ulong ImageBase { get; private set; }
    public int SectionAlignment { get; private set; }
    public int FileAlignment { get; private set; }
    public ushort MajorOperatingSystemVersion { get; private set; }
    public ushort MinorOperatingSystemVersion { get; private set; }
    public ushort MajorImageVersion { get; private set; }
    public ushort MinorImageVersion { get; private set; }
    public ushort MajorSubsystemVersion { get; private set; }
    public ushort MinorSubsystemVersion { get; private set; }
    public int SizeOfImage { get; private set; }
    public int SizeOfHeaders { get; private set; }
    public UInt32 CheckSum { get; private set; }
    public Subsystem Subsystem { get; private set; }
    public DllCharacteristics DllCharacteristics { get; private set; }
    public ulong SizeOfStackReserve { get; private set; }
    public ulong SizeOfStackCommit { get; private set; }
    public ulong SizeOfHeapReserve { get; private set; }
    public ulong SizeOfHeapCommit { get; private set; }
    public int NumberOfRvaAndSizes { get; private set; }
    public DirectoryEntry ExportTableDirectory { get; private set; }
    public DirectoryEntry ImportTableDirectory { get; private set; }
    public DirectoryEntry ResourceTableDirectory { get; private set; }
    public DirectoryEntry ExceptionTableDirectory { get; private set; }
    public DirectoryEntry CertificateTableDirectory { get; private set; }
    public DirectoryEntry BaseRelocationTableDirectory { get; private set; }
    public DirectoryEntry DebugTableDirectory { get; private set; }
    public DirectoryEntry CopyrightTableDirectory { get; private set; }
    public DirectoryEntry GlobalPointerTableDirectory { get; private set; }
    public DirectoryEntry ThreadLocalStorageTableDirectory { get; private set; }
    public DirectoryEntry LoadConfigTableDirectory { get; private set; }
    public DirectoryEntry BoundImportTableDirectory { get; private set; }
    public DirectoryEntry ImportAddressTableDirectory { get; private set; }
    public DirectoryEntry DelayImportTableDirectory { get; private set; }
    public DirectoryEntry CorHeaderTableDirectory { get; private set; }
    internal PEHeader(PEBinaryReader& reader);
    [CompilerGeneratedAttribute]
public PEMagic get_Magic();
    [CompilerGeneratedAttribute]
private void set_Magic(PEMagic value);
    [CompilerGeneratedAttribute]
public byte get_MajorLinkerVersion();
    [CompilerGeneratedAttribute]
private void set_MajorLinkerVersion(byte value);
    [CompilerGeneratedAttribute]
public byte get_MinorLinkerVersion();
    [CompilerGeneratedAttribute]
private void set_MinorLinkerVersion(byte value);
    [CompilerGeneratedAttribute]
public int get_SizeOfCode();
    [CompilerGeneratedAttribute]
private void set_SizeOfCode(int value);
    [CompilerGeneratedAttribute]
public int get_SizeOfInitializedData();
    [CompilerGeneratedAttribute]
private void set_SizeOfInitializedData(int value);
    [CompilerGeneratedAttribute]
public int get_SizeOfUninitializedData();
    [CompilerGeneratedAttribute]
private void set_SizeOfUninitializedData(int value);
    [CompilerGeneratedAttribute]
public int get_AddressOfEntryPoint();
    [CompilerGeneratedAttribute]
private void set_AddressOfEntryPoint(int value);
    [CompilerGeneratedAttribute]
public int get_BaseOfCode();
    [CompilerGeneratedAttribute]
private void set_BaseOfCode(int value);
    [CompilerGeneratedAttribute]
public int get_BaseOfData();
    [CompilerGeneratedAttribute]
private void set_BaseOfData(int value);
    [CompilerGeneratedAttribute]
public ulong get_ImageBase();
    [CompilerGeneratedAttribute]
private void set_ImageBase(ulong value);
    [CompilerGeneratedAttribute]
public int get_SectionAlignment();
    [CompilerGeneratedAttribute]
private void set_SectionAlignment(int value);
    [CompilerGeneratedAttribute]
public int get_FileAlignment();
    [CompilerGeneratedAttribute]
private void set_FileAlignment(int value);
    [CompilerGeneratedAttribute]
public ushort get_MajorOperatingSystemVersion();
    [CompilerGeneratedAttribute]
private void set_MajorOperatingSystemVersion(ushort value);
    [CompilerGeneratedAttribute]
public ushort get_MinorOperatingSystemVersion();
    [CompilerGeneratedAttribute]
private void set_MinorOperatingSystemVersion(ushort value);
    [CompilerGeneratedAttribute]
public ushort get_MajorImageVersion();
    [CompilerGeneratedAttribute]
private void set_MajorImageVersion(ushort value);
    [CompilerGeneratedAttribute]
public ushort get_MinorImageVersion();
    [CompilerGeneratedAttribute]
private void set_MinorImageVersion(ushort value);
    [CompilerGeneratedAttribute]
public ushort get_MajorSubsystemVersion();
    [CompilerGeneratedAttribute]
private void set_MajorSubsystemVersion(ushort value);
    [CompilerGeneratedAttribute]
public ushort get_MinorSubsystemVersion();
    [CompilerGeneratedAttribute]
private void set_MinorSubsystemVersion(ushort value);
    [CompilerGeneratedAttribute]
public int get_SizeOfImage();
    [CompilerGeneratedAttribute]
private void set_SizeOfImage(int value);
    [CompilerGeneratedAttribute]
public int get_SizeOfHeaders();
    [CompilerGeneratedAttribute]
private void set_SizeOfHeaders(int value);
    [CompilerGeneratedAttribute]
public UInt32 get_CheckSum();
    [CompilerGeneratedAttribute]
private void set_CheckSum(UInt32 value);
    [CompilerGeneratedAttribute]
public Subsystem get_Subsystem();
    [CompilerGeneratedAttribute]
private void set_Subsystem(Subsystem value);
    [CompilerGeneratedAttribute]
public DllCharacteristics get_DllCharacteristics();
    [CompilerGeneratedAttribute]
private void set_DllCharacteristics(DllCharacteristics value);
    [CompilerGeneratedAttribute]
public ulong get_SizeOfStackReserve();
    [CompilerGeneratedAttribute]
private void set_SizeOfStackReserve(ulong value);
    [CompilerGeneratedAttribute]
public ulong get_SizeOfStackCommit();
    [CompilerGeneratedAttribute]
private void set_SizeOfStackCommit(ulong value);
    [CompilerGeneratedAttribute]
public ulong get_SizeOfHeapReserve();
    [CompilerGeneratedAttribute]
private void set_SizeOfHeapReserve(ulong value);
    [CompilerGeneratedAttribute]
public ulong get_SizeOfHeapCommit();
    [CompilerGeneratedAttribute]
private void set_SizeOfHeapCommit(ulong value);
    [CompilerGeneratedAttribute]
public int get_NumberOfRvaAndSizes();
    [CompilerGeneratedAttribute]
private void set_NumberOfRvaAndSizes(int value);
    [CompilerGeneratedAttribute]
public DirectoryEntry get_ExportTableDirectory();
    [CompilerGeneratedAttribute]
private void set_ExportTableDirectory(DirectoryEntry value);
    [CompilerGeneratedAttribute]
public DirectoryEntry get_ImportTableDirectory();
    [CompilerGeneratedAttribute]
private void set_ImportTableDirectory(DirectoryEntry value);
    [CompilerGeneratedAttribute]
public DirectoryEntry get_ResourceTableDirectory();
    [CompilerGeneratedAttribute]
private void set_ResourceTableDirectory(DirectoryEntry value);
    [CompilerGeneratedAttribute]
public DirectoryEntry get_ExceptionTableDirectory();
    [CompilerGeneratedAttribute]
private void set_ExceptionTableDirectory(DirectoryEntry value);
    [CompilerGeneratedAttribute]
public DirectoryEntry get_CertificateTableDirectory();
    [CompilerGeneratedAttribute]
private void set_CertificateTableDirectory(DirectoryEntry value);
    [CompilerGeneratedAttribute]
public DirectoryEntry get_BaseRelocationTableDirectory();
    [CompilerGeneratedAttribute]
private void set_BaseRelocationTableDirectory(DirectoryEntry value);
    [CompilerGeneratedAttribute]
public DirectoryEntry get_DebugTableDirectory();
    [CompilerGeneratedAttribute]
private void set_DebugTableDirectory(DirectoryEntry value);
    [CompilerGeneratedAttribute]
public DirectoryEntry get_CopyrightTableDirectory();
    [CompilerGeneratedAttribute]
private void set_CopyrightTableDirectory(DirectoryEntry value);
    [CompilerGeneratedAttribute]
public DirectoryEntry get_GlobalPointerTableDirectory();
    [CompilerGeneratedAttribute]
private void set_GlobalPointerTableDirectory(DirectoryEntry value);
    [CompilerGeneratedAttribute]
public DirectoryEntry get_ThreadLocalStorageTableDirectory();
    [CompilerGeneratedAttribute]
private void set_ThreadLocalStorageTableDirectory(DirectoryEntry value);
    [CompilerGeneratedAttribute]
public DirectoryEntry get_LoadConfigTableDirectory();
    [CompilerGeneratedAttribute]
private void set_LoadConfigTableDirectory(DirectoryEntry value);
    [CompilerGeneratedAttribute]
public DirectoryEntry get_BoundImportTableDirectory();
    [CompilerGeneratedAttribute]
private void set_BoundImportTableDirectory(DirectoryEntry value);
    [CompilerGeneratedAttribute]
public DirectoryEntry get_ImportAddressTableDirectory();
    [CompilerGeneratedAttribute]
private void set_ImportAddressTableDirectory(DirectoryEntry value);
    [CompilerGeneratedAttribute]
public DirectoryEntry get_DelayImportTableDirectory();
    [CompilerGeneratedAttribute]
private void set_DelayImportTableDirectory(DirectoryEntry value);
    [CompilerGeneratedAttribute]
public DirectoryEntry get_CorHeaderTableDirectory();
    [CompilerGeneratedAttribute]
private void set_CorHeaderTableDirectory(DirectoryEntry value);
}
public class System.Reflection.PortableExecutable.PEHeaders : object {
    private CoffHeader _coffHeader;
    private PEHeader _peHeader;
    private ImmutableArray`1<SectionHeader> _sectionHeaders;
    private CorHeader _corHeader;
    private int _metadataStartOffset;
    private int _metadataSize;
    private int _coffHeaderStartOffset;
    private int _corHeaderStartOffset;
    private int _peHeaderStartOffset;
    public int MetadataStartOffset { get; }
    public int MetadataSize { get; }
    public CoffHeader CoffHeader { get; }
    public int CoffHeaderStartOffset { get; }
    public bool IsCoffOnly { get; }
    public PEHeader PEHeader { get; }
    public int PEHeaderStartOffset { get; }
    public ImmutableArray`1<SectionHeader> SectionHeaders { get; }
    public CorHeader CorHeader { get; }
    public int CorHeaderStartOffset { get; }
    public bool IsConsoleApplication { get; }
    public bool IsDll { get; }
    public bool IsExe { get; }
    public PEHeaders(Stream peStream);
    public PEHeaders(Stream peStream, int size);
    private PEHeaders(Stream peStream, Nullable`1<int> sizeOpt);
    public int get_MetadataStartOffset();
    public int get_MetadataSize();
    public CoffHeader get_CoffHeader();
    public int get_CoffHeaderStartOffset();
    public bool get_IsCoffOnly();
    public PEHeader get_PEHeader();
    public int get_PEHeaderStartOffset();
    public ImmutableArray`1<SectionHeader> get_SectionHeaders();
    public CorHeader get_CorHeader();
    public int get_CorHeaderStartOffset();
    public bool get_IsConsoleApplication();
    public bool get_IsDll();
    public bool get_IsExe();
    private bool TryCalculateCorHeaderOffset(long peStreamSize, Int32& startOffset);
    private void SkipDosHeader(PEBinaryReader& reader, Boolean& isCOFFOnly);
    private ImmutableArray`1<SectionHeader> ReadSectionHeaders(PEBinaryReader& reader);
    public bool TryGetDirectoryOffset(DirectoryEntry directory, Int32& offset);
    public int GetContainingSectionIndex(int relativeVirtualAddress);
    private int IndexOfSection(string name);
    private void CalculateMetadataLocation(long peImageSize, Int32& start, Int32& size);
}
public enum System.Reflection.PortableExecutable.PEMagic : Enum {
    public ushort value__;
    public static PEMagic PE32;
    public static PEMagic PE32Plus;
}
public class System.Reflection.PortableExecutable.PEMemoryBlock : ValueType {
    private AbstractMemoryBlock _block;
    private int _offset;
    public Byte* Pointer { get; }
    public int Length { get; }
    internal PEMemoryBlock(AbstractMemoryBlock block, int offset);
    public Byte* get_Pointer();
    public int get_Length();
    public ImmutableArray`1<byte> GetContent();
}
public class System.Reflection.PortableExecutable.PEReader : object {
    private MemoryBlockProvider _peImage;
    private PEHeaders _lazyPEHeaders;
    private AbstractMemoryBlock _lazyMetadataBlock;
    private AbstractMemoryBlock _lazyImageBlock;
    private AbstractMemoryBlock[] _lazyPESectionBlocks;
    public PEHeaders PEHeaders { get; }
    public bool IsEntireImageAvailable { get; }
    public bool HasMetadata { get; }
    public PEReader(Byte* peImage, int size);
    public PEReader(Stream peStream);
    public PEReader(Stream peStream, PEStreamOptions options);
    public PEReader(Stream peStream, PEStreamOptions options, int size);
    private PEReader(Stream peStream, PEStreamOptions options, Nullable`1<int> sizeOpt);
    public PEReader(ImmutableArray`1<byte> peImage);
    public sealed virtual void Dispose();
    public PEHeaders get_PEHeaders();
    private void InitializePEHeaders();
    private static PEHeaders ReadPEHeadersNoLock(Stream stream, long imageStartPosition, int imageSize);
    private AbstractMemoryBlock GetEntireImageBlock();
    private AbstractMemoryBlock GetMetadataBlock();
    private AbstractMemoryBlock GetPESectionBlock(int index);
    public bool get_IsEntireImageAvailable();
    public PEMemoryBlock GetEntireImage();
    public bool get_HasMetadata();
    public PEMemoryBlock GetMetadata();
    public PEMemoryBlock GetSectionData(int relativeVirtualAddress);
}
[FlagsAttribute]
public enum System.Reflection.PortableExecutable.PEStreamOptions : Enum {
    public int value__;
    public static PEStreamOptions Default;
    public static PEStreamOptions LeaveOpen;
    public static PEStreamOptions PrefetchMetadata;
    public static PEStreamOptions PrefetchEntireImage;
}
[ExtensionAttribute]
internal static class System.Reflection.PortableExecutable.PEStreamOptionsExtensions : object {
    [ExtensionAttribute]
public static bool IsValid(PEStreamOptions options);
}
[FlagsAttribute]
public enum System.Reflection.PortableExecutable.SectionCharacteristics : Enum {
    public UInt32 value__;
    public static SectionCharacteristics TypeReg;
    public static SectionCharacteristics TypeDSect;
    public static SectionCharacteristics TypeNoLoad;
    public static SectionCharacteristics TypeGroup;
    public static SectionCharacteristics TypeNoPad;
    public static SectionCharacteristics TypeCopy;
    public static SectionCharacteristics ContainsCode;
    public static SectionCharacteristics ContainsInitializedData;
    public static SectionCharacteristics ContainsUninitializedData;
    public static SectionCharacteristics LinkerOther;
    public static SectionCharacteristics LinkerInfo;
    public static SectionCharacteristics TypeOver;
    public static SectionCharacteristics LinkerRemove;
    public static SectionCharacteristics LinkerComdat;
    public static SectionCharacteristics MemProtected;
    public static SectionCharacteristics NoDeferSpecExc;
    public static SectionCharacteristics GPRel;
    public static SectionCharacteristics MemFardata;
    public static SectionCharacteristics MemSysheap;
    public static SectionCharacteristics MemPurgeable;
    public static SectionCharacteristics Mem16Bit;
    public static SectionCharacteristics MemLocked;
    public static SectionCharacteristics MemPreload;
    public static SectionCharacteristics Align1Bytes;
    public static SectionCharacteristics Align2Bytes;
    public static SectionCharacteristics Align4Bytes;
    public static SectionCharacteristics Align8Bytes;
    public static SectionCharacteristics Align16Bytes;
    public static SectionCharacteristics Align32Bytes;
    public static SectionCharacteristics Align64Bytes;
    public static SectionCharacteristics Align128Bytes;
    public static SectionCharacteristics Align256Bytes;
    public static SectionCharacteristics Align512Bytes;
    public static SectionCharacteristics Align1024Bytes;
    public static SectionCharacteristics Align2048Bytes;
    public static SectionCharacteristics Align4096Bytes;
    public static SectionCharacteristics Align8192Bytes;
    public static SectionCharacteristics AlignMask;
    public static SectionCharacteristics LinkerNRelocOvfl;
    public static SectionCharacteristics MemDiscardable;
    public static SectionCharacteristics MemNotCached;
    public static SectionCharacteristics MemNotPaged;
    public static SectionCharacteristics MemShared;
    public static SectionCharacteristics MemExecute;
    public static SectionCharacteristics MemRead;
    public static SectionCharacteristics MemWrite;
}
public class System.Reflection.PortableExecutable.SectionHeader : ValueType {
    private int _virtualSize;
    private string _name;
    private int _virtualAddress;
    private int _sizeOfRawData;
    private int _pointerToRawData;
    private int _pointerToRelocations;
    private int _pointerToLineNumbers;
    private ushort _numberOfRelocations;
    private ushort _numberOfLineNumbers;
    private SectionCharacteristics _sectionCharacteristics;
    public string Name { get; }
    public int VirtualSize { get; }
    public int VirtualAddress { get; }
    public int SizeOfRawData { get; }
    public int PointerToRawData { get; }
    public int PointerToRelocations { get; }
    public int PointerToLineNumbers { get; }
    public ushort NumberOfRelocations { get; }
    public ushort NumberOfLineNumbers { get; }
    public SectionCharacteristics SectionCharacteristics { get; }
    internal SectionHeader(PEBinaryReader& reader);
    public string get_Name();
    public int get_VirtualSize();
    public int get_VirtualAddress();
    public int get_SizeOfRawData();
    public int get_PointerToRawData();
    public int get_PointerToRelocations();
    public int get_PointerToLineNumbers();
    public ushort get_NumberOfRelocations();
    public ushort get_NumberOfLineNumbers();
    public SectionCharacteristics get_SectionCharacteristics();
}
public enum System.Reflection.PortableExecutable.Subsystem : Enum {
    public ushort value__;
    public static Subsystem Unknown;
    public static Subsystem Native;
    public static Subsystem WindowsGui;
    public static Subsystem WindowsCui;
    public static Subsystem OS2Cui;
    public static Subsystem PosixCui;
    public static Subsystem NativeWindows;
    public static Subsystem WindowsCEGui;
    public static Subsystem EfiApplication;
    public static Subsystem EfiBootServiceDriver;
    public static Subsystem EfiRuntimeDriver;
    public static Subsystem EfiRom;
    public static Subsystem Xbox;
}
[ExtensionAttribute]
internal static class System.Reflection.TypeAttributesExtensions : object {
    private static TypeAttributes Forwarder;
    private static TypeAttributes NestedMask;
    [ExtensionAttribute]
public static bool IsForwarder(TypeAttributes flags);
    [ExtensionAttribute]
public static bool IsNested(TypeAttributes flags);
}
