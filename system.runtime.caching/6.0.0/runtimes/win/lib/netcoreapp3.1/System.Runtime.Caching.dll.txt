internal static class FxResources.System.Runtime.Caching.SR : object {
}
internal static class Interop : object {
}
public abstract class System.Runtime.Caching.CacheEntryChangeMonitor : ChangeMonitor {
    public ReadOnlyCollection`1<string> CacheKeys { get; }
    public DateTimeOffset LastModified { get; }
    public string RegionName { get; }
    public abstract virtual ReadOnlyCollection`1<string> get_CacheKeys();
    public abstract virtual DateTimeOffset get_LastModified();
    public abstract virtual string get_RegionName();
}
public class System.Runtime.Caching.CacheEntryRemovedArguments : object {
    private CacheItem _cacheItem;
    private ObjectCache _source;
    private CacheEntryRemovedReason _reason;
    public CacheItem CacheItem { get; }
    public CacheEntryRemovedReason RemovedReason { get; }
    public ObjectCache Source { get; }
    public CacheEntryRemovedArguments(ObjectCache source, CacheEntryRemovedReason reason, CacheItem cacheItem);
    public CacheItem get_CacheItem();
    public CacheEntryRemovedReason get_RemovedReason();
    public ObjectCache get_Source();
}
public class System.Runtime.Caching.CacheEntryRemovedCallback : MulticastDelegate {
    public CacheEntryRemovedCallback(object object, IntPtr method);
    public virtual void Invoke(CacheEntryRemovedArguments arguments);
    public virtual IAsyncResult BeginInvoke(CacheEntryRemovedArguments arguments, AsyncCallback callback, object object);
    public virtual void EndInvoke(IAsyncResult result);
}
public enum System.Runtime.Caching.CacheEntryRemovedReason : Enum {
    public int value__;
    public static CacheEntryRemovedReason Removed;
    public static CacheEntryRemovedReason Expired;
    public static CacheEntryRemovedReason Evicted;
    public static CacheEntryRemovedReason ChangeMonitorChanged;
    public static CacheEntryRemovedReason CacheSpecificEviction;
}
public class System.Runtime.Caching.CacheEntryUpdateArguments : object {
    private string _key;
    private CacheEntryRemovedReason _reason;
    private string _regionName;
    private ObjectCache _source;
    private CacheItem _updatedCacheItem;
    private CacheItemPolicy _updatedCacheItemPolicy;
    public string Key { get; }
    public CacheEntryRemovedReason RemovedReason { get; }
    public string RegionName { get; }
    public ObjectCache Source { get; }
    public CacheItem UpdatedCacheItem { get; public set; }
    public CacheItemPolicy UpdatedCacheItemPolicy { get; public set; }
    public CacheEntryUpdateArguments(ObjectCache source, CacheEntryRemovedReason reason, string key, string regionName);
    public string get_Key();
    public CacheEntryRemovedReason get_RemovedReason();
    public string get_RegionName();
    public ObjectCache get_Source();
    public CacheItem get_UpdatedCacheItem();
    public void set_UpdatedCacheItem(CacheItem value);
    public CacheItemPolicy get_UpdatedCacheItemPolicy();
    public void set_UpdatedCacheItemPolicy(CacheItemPolicy value);
}
public class System.Runtime.Caching.CacheEntryUpdateCallback : MulticastDelegate {
    public CacheEntryUpdateCallback(object object, IntPtr method);
    public virtual void Invoke(CacheEntryUpdateArguments arguments);
    public virtual IAsyncResult BeginInvoke(CacheEntryUpdateArguments arguments, AsyncCallback callback, object object);
    public virtual void EndInvoke(IAsyncResult result);
}
internal class System.Runtime.Caching.CacheExpires : object {
    internal static TimeSpan MIN_UPDATE_DELTA;
    internal static TimeSpan MIN_FLUSH_INTERVAL;
    internal static TimeSpan _tsPerBucket;
    private static int NUMBUCKETS;
    private static TimeSpan s_tsPerCycle;
    private MemoryCacheStore _cacheStore;
    private ExpiresBucket[] _buckets;
    private GCHandleRef`1<Timer> _timerHandleRef;
    private DateTime _utcLastFlush;
    private int _inFlush;
    internal MemoryCacheStore MemoryCacheStore { get; }
    internal CacheExpires(MemoryCacheStore cacheStore);
    private static CacheExpires();
    private int UtcCalcExpiresBucket(DateTime utcDate);
    private int FlushExpiredItems(bool checkDelta, bool useInsertBlock);
    internal int FlushExpiredItems(bool useInsertBlock);
    private void TimerCallback(object state);
    internal void EnableExpirationTimer(bool enable);
    internal MemoryCacheStore get_MemoryCacheStore();
    internal void Add(MemoryCacheEntry cacheEntry);
    internal void Remove(MemoryCacheEntry cacheEntry);
    internal void UtcUpdate(MemoryCacheEntry cacheEntry, DateTime utcNewExpires);
}
public class System.Runtime.Caching.CacheItem : object {
    [CompilerGeneratedAttribute]
private string <Key>k__BackingField;
    [CompilerGeneratedAttribute]
private object <Value>k__BackingField;
    [CompilerGeneratedAttribute]
private string <RegionName>k__BackingField;
    public string Key { get; public set; }
    public object Value { get; public set; }
    public string RegionName { get; public set; }
    public CacheItem(string key);
    public CacheItem(string key, object value);
    public CacheItem(string key, object value, string regionName);
    [CompilerGeneratedAttribute]
public string get_Key();
    [CompilerGeneratedAttribute]
public void set_Key(string value);
    [CompilerGeneratedAttribute]
public object get_Value();
    [CompilerGeneratedAttribute]
public void set_Value(object value);
    [CompilerGeneratedAttribute]
public string get_RegionName();
    [CompilerGeneratedAttribute]
public void set_RegionName(string value);
}
public class System.Runtime.Caching.CacheItemPolicy : object {
    private DateTimeOffset _absExpiry;
    private TimeSpan _sldExpiry;
    private Collection`1<ChangeMonitor> _changeMonitors;
    private CacheItemPriority _priority;
    private CacheEntryRemovedCallback _removedCallback;
    private CacheEntryUpdateCallback _updateCallback;
    public DateTimeOffset AbsoluteExpiration { get; public set; }
    public Collection`1<ChangeMonitor> ChangeMonitors { get; }
    public CacheItemPriority Priority { get; public set; }
    public CacheEntryRemovedCallback RemovedCallback { get; public set; }
    public TimeSpan SlidingExpiration { get; public set; }
    public CacheEntryUpdateCallback UpdateCallback { get; public set; }
    public DateTimeOffset get_AbsoluteExpiration();
    public void set_AbsoluteExpiration(DateTimeOffset value);
    public Collection`1<ChangeMonitor> get_ChangeMonitors();
    public CacheItemPriority get_Priority();
    public void set_Priority(CacheItemPriority value);
    public CacheEntryRemovedCallback get_RemovedCallback();
    public void set_RemovedCallback(CacheEntryRemovedCallback value);
    public TimeSpan get_SlidingExpiration();
    public void set_SlidingExpiration(TimeSpan value);
    public CacheEntryUpdateCallback get_UpdateCallback();
    public void set_UpdateCallback(CacheEntryUpdateCallback value);
}
public enum System.Runtime.Caching.CacheItemPriority : Enum {
    public int value__;
    public static CacheItemPriority Default;
    public static CacheItemPriority NotRemovable;
}
internal class System.Runtime.Caching.CacheMemoryMonitor : MemoryMonitor {
    private static long PRIVATE_BYTES_LIMIT_2GB;
    private static long PRIVATE_BYTES_LIMIT_3GB;
    private static long PRIVATE_BYTES_LIMIT_64BIT;
    private static int SAMPLE_COUNT;
    private static IMemoryCacheManager s_memoryCacheManager;
    private static long s_autoPrivateBytesLimit;
    private static long s_effectiveProcessMemoryLimit;
    private MemoryCache _memoryCache;
    private Int64[] _cacheSizeSamples;
    private DateTime[] _cacheSizeSampleTimes;
    private int _idx;
    private SRefMultiple _sizedRefMultiple;
    private int _gen2Count;
    private long _memoryLimit;
    internal long MemoryLimit { get; }
    private static long AutoPrivateBytesLimit { get; }
    internal static long EffectiveProcessMemoryLimit { get; }
    internal CacheMemoryMonitor(MemoryCache memoryCache, int cacheMemoryLimitMegabytes);
    private static CacheMemoryMonitor();
    internal long get_MemoryLimit();
    private void InitDisposableMembers(int cacheMemoryLimitMegabytes);
    private static long get_AutoPrivateBytesLimit();
    public sealed virtual void Dispose();
    internal static long get_EffectiveProcessMemoryLimit();
    protected virtual int GetCurrentPressure();
    internal virtual int GetPercentToTrim(DateTime lastTrimTime, int lastTrimPercent);
    internal void SetLimit(int cacheMemoryLimitMegabytes);
    private static void InitMemoryCacheManager();
}
internal class System.Runtime.Caching.CacheUsage : object {
    internal static TimeSpan NEWADD_INTERVAL;
    internal static TimeSpan CORRELATED_REQUEST_TIMEOUT;
    internal static TimeSpan MIN_LIFETIME_FOR_USAGE;
    private static byte NUMBUCKETS;
    private MemoryCacheStore _cacheStore;
    internal UsageBucket[] _buckets;
    private int _inFlush;
    internal MemoryCacheStore MemoryCacheStore { get; }
    internal CacheUsage(MemoryCacheStore cacheStore);
    private static CacheUsage();
    internal MemoryCacheStore get_MemoryCacheStore();
    internal void Add(MemoryCacheEntry cacheEntry);
    internal void Remove(MemoryCacheEntry cacheEntry);
    internal void Update(MemoryCacheEntry cacheEntry);
    internal int FlushUnderUsedItems(int toFlush);
}
public abstract class System.Runtime.Caching.ChangeMonitor : object {
    private static int INITIALIZED;
    private static int CHANGED;
    private static int INVOKED;
    private static int DISPOSED;
    private static object s_NOT_SET;
    private SafeBitVector32 _flags;
    private OnChangedCallback _onChangedCallback;
    private object _onChangedState;
    public bool HasChanged { get; }
    public bool IsDisposed { get; }
    public string UniqueId { get; }
    private static ChangeMonitor();
    private void DisposeHelper();
    private void OnChangedHelper(object state);
    protected abstract virtual void Dispose(bool disposing);
    protected void InitializationComplete();
    protected void OnChanged(object state);
    public bool get_HasChanged();
    public bool get_IsDisposed();
    public abstract virtual string get_UniqueId();
    public sealed virtual void Dispose();
    public void NotifyOnChanged(OnChangedCallback onChangedCallback);
}
internal class System.Runtime.Caching.Configuration.CachingSectionGroup : ConfigurationSectionGroup {
    [ConfigurationPropertyAttribute("memoryCache")]
public MemoryCacheSection MemoryCaches { get; }
    public MemoryCacheSection get_MemoryCaches();
}
internal static class System.Runtime.Caching.Configuration.ConfigUtil : object {
    internal static string CacheMemoryLimitMegabytes;
    internal static string PhysicalMemoryLimitPercentage;
    internal static string PollingInterval;
    internal static string UseMemoryCacheManager;
    internal static int DefaultPollingTimeMilliseconds;
    internal static int GetIntValue(NameValueCollection config, string valueName, int defaultValue, bool zeroAllowed, int maxValueAllowed);
    internal static int GetIntValueFromTimeSpan(NameValueCollection config, string valueName, int defaultValue);
    internal static bool GetBooleanValue(NameValueCollection config, string valueName, bool defaultValue);
}
internal class System.Runtime.Caching.Configuration.MemoryCacheElement : ConfigurationElement {
    private static ConfigurationProperty s_propName;
    private static ConfigurationProperty s_propPhysicalMemoryLimitPercentage;
    private static ConfigurationProperty s_propCacheMemoryLimitMegabytes;
    private static ConfigurationProperty s_propPollingInterval;
    private static ConfigurationPropertyCollection s_properties;
    protected ConfigurationPropertyCollection Properties { get; }
    [ConfigurationPropertyAttribute("name")]
[TypeConverterAttribute("System.Configuration.WhiteSpaceTrimStringConverter")]
[StringValidatorAttribute]
public string Name { get; public set; }
    [ConfigurationPropertyAttribute("physicalMemoryLimitPercentage")]
[IntegerValidatorAttribute]
public int PhysicalMemoryLimitPercentage { get; public set; }
    [ConfigurationPropertyAttribute("cacheMemoryLimitMegabytes")]
[IntegerValidatorAttribute]
public int CacheMemoryLimitMegabytes { get; public set; }
    [ConfigurationPropertyAttribute("pollingInterval")]
[TypeConverterAttribute("System.Configuration.InfiniteTimeSpanConverter")]
public TimeSpan PollingInterval { get; public set; }
    public MemoryCacheElement(string name);
    private static MemoryCacheElement();
    protected virtual ConfigurationPropertyCollection get_Properties();
    public string get_Name();
    public void set_Name(string value);
    public int get_PhysicalMemoryLimitPercentage();
    public void set_PhysicalMemoryLimitPercentage(int value);
    public int get_CacheMemoryLimitMegabytes();
    public void set_CacheMemoryLimitMegabytes(int value);
    public TimeSpan get_PollingInterval();
    public void set_PollingInterval(TimeSpan value);
}
internal class System.Runtime.Caching.Configuration.MemoryCacheSection : ConfigurationSection {
    private static ConfigurationProperty s_propNamedCaches;
    private static ConfigurationPropertyCollection s_properties;
    protected ConfigurationPropertyCollection Properties { get; }
    [ConfigurationPropertyAttribute("namedCaches")]
public MemoryCacheSettingsCollection NamedCaches { get; }
    private static MemoryCacheSection();
    protected virtual ConfigurationPropertyCollection get_Properties();
    public MemoryCacheSettingsCollection get_NamedCaches();
}
[DefaultMemberAttribute("Item")]
[ConfigurationCollectionAttribute]
internal class System.Runtime.Caching.Configuration.MemoryCacheSettingsCollection : ConfigurationElementCollection {
    private static ConfigurationPropertyCollection s_properties;
    protected ConfigurationPropertyCollection Properties { get; }
    public MemoryCacheElement Item { get; public set; }
    public MemoryCacheElement Item { get; }
    public ConfigurationElementCollectionType CollectionType { get; }
    private static MemoryCacheSettingsCollection();
    protected virtual ConfigurationPropertyCollection get_Properties();
    public MemoryCacheElement get_Item(int index);
    public void set_Item(int index, MemoryCacheElement value);
    public MemoryCacheElement get_Item(string key);
    public virtual ConfigurationElementCollectionType get_CollectionType();
    public int IndexOf(MemoryCacheElement cache);
    public void Add(MemoryCacheElement cache);
    public void Remove(MemoryCacheElement cache);
    public void RemoveAt(int index);
    public void Clear();
    protected virtual ConfigurationElement CreateNewElement();
    protected virtual ConfigurationElement CreateNewElement(string elementName);
    protected virtual object GetElementKey(ConfigurationElement element);
}
internal enum System.Runtime.Caching.CounterName : Enum {
    public int value__;
    public static CounterName Entries;
    public static CounterName Hits;
    public static CounterName HitRatio;
    public static CounterName HitRatioBase;
    public static CounterName Misses;
    public static CounterName Trims;
    public static CounterName Turnover;
}
internal class System.Runtime.Caching.Counters : EventSource {
    private static string EVENT_SOURCE_NAME_ROOT;
    private static int NUM_COUNTERS;
    private DiagnosticCounter[] _counters;
    private Int64[] _counterValues;
    internal Counters(string cacheName);
    private void InitDisposableMembers(string cacheName);
    private PollingCounter CreatePollingCounter(string name, string displayName, int counterIndex);
    public void Dispose();
    internal void Increment(CounterName name);
    internal void IncrementBy(CounterName name, long value);
    internal void Decrement(CounterName name);
    [CompilerGeneratedAttribute]
private double <InitDisposableMembers>b__5_0();
    [CompilerGeneratedAttribute]
private double <InitDisposableMembers>b__5_1();
}
internal static class System.Runtime.Caching.Dbg : object {
    [ConditionalAttribute("DEBUG")]
internal static void Trace(string tagName, string message, Exception e);
}
[FlagsAttribute]
public enum System.Runtime.Caching.DefaultCacheCapabilities : Enum {
    public int value__;
    public static DefaultCacheCapabilities None;
    public static DefaultCacheCapabilities InMemoryProvider;
    public static DefaultCacheCapabilities OutOfProcessProvider;
    public static DefaultCacheCapabilities CacheEntryChangeMonitors;
    public static DefaultCacheCapabilities AbsoluteExpirations;
    public static DefaultCacheCapabilities SlidingExpirations;
    public static DefaultCacheCapabilities CacheEntryUpdateCallback;
    public static DefaultCacheCapabilities CacheEntryRemovedCallback;
    public static DefaultCacheCapabilities CacheRegions;
}
internal enum System.Runtime.Caching.EntryState : Enum {
    public byte value__;
    public static EntryState NotInCache;
    public static EntryState AddingToCache;
    public static EntryState AddedToCache;
    public static EntryState RemovingFromCache;
    public static EntryState RemovedFromCache;
    public static EntryState Closed;
}
internal class System.Runtime.Caching.ExpiresBucket : object {
    private static int NUM_ENTRIES;
    private static int LENGTH_ENTRIES;
    private static int MIN_PAGES_INCREMENT;
    private static int MAX_PAGES_INCREMENT;
    private static double MIN_LOAD_FACTOR;
    private static int COUNTS_LENGTH;
    private static TimeSpan s_COUNT_INTERVAL;
    private CacheExpires _cacheExpires;
    private byte _bucket;
    private ExpiresPage[] _pages;
    private int _cEntriesInUse;
    private int _cPagesInUse;
    private int _cEntriesInFlush;
    private int _minEntriesInUse;
    private ExpiresPageList _freePageList;
    private ExpiresPageList _freeEntryList;
    private bool _blockReduce;
    private DateTime _utcMinExpires;
    private Int32[] _counts;
    private DateTime _utcLastCountReset;
    internal ExpiresBucket(CacheExpires cacheExpires, byte bucket, DateTime utcNow);
    private static ExpiresBucket();
    private void InitZeroPages();
    private void ResetCounts(DateTime utcNow);
    private int GetCountIndex(DateTime utcExpires);
    private void AddCount(DateTime utcExpires);
    private void RemoveCount(DateTime utcExpires);
    private int GetExpiresCount(DateTime utcExpires);
    private void AddToListHead(int pageIndex, ExpiresPageList& list);
    private void AddToListTail(int pageIndex, ExpiresPageList& list);
    private int RemoveFromListHead(ExpiresPageList& list);
    private void RemoveFromList(int pageIndex, ExpiresPageList& list);
    private void MoveToListHead(int pageIndex, ExpiresPageList& list);
    private void MoveToListTail(int pageIndex, ExpiresPageList& list);
    private void UpdateMinEntries();
    private void RemovePage(int pageIndex);
    private ExpiresEntryRef GetFreeExpiresEntry();
    private void AddExpiresEntryToFreeList(ExpiresEntryRef entryRef);
    private void Expand();
    private void Reduce();
    internal void AddCacheEntry(MemoryCacheEntry cacheEntry);
    private void RemoveCacheEntryNoLock(MemoryCacheEntry cacheEntry);
    internal void RemoveCacheEntry(MemoryCacheEntry cacheEntry);
    internal void UtcUpdateCacheEntry(MemoryCacheEntry cacheEntry, DateTime utcExpires);
    internal int FlushExpiredItems(DateTime utcNow, bool useInsertBlock);
}
internal class System.Runtime.Caching.ExpiresEntry : ValueType {
    internal DateTime _utcExpires;
    internal ExpiresEntryRef _next;
    internal int _cFree;
    internal MemoryCacheEntry _cacheEntry;
}
internal class System.Runtime.Caching.ExpiresEntryRef : ValueType {
    internal static ExpiresEntryRef INVALID;
    private static UInt32 ENTRY_MASK;
    private static int PAGE_SHIFT;
    private UInt32 _ref;
    internal int PageIndex { get; }
    internal int Index { get; }
    internal bool IsInvalid { get; }
    internal ExpiresEntryRef(int pageIndex, int entryIndex);
    private static ExpiresEntryRef();
    public virtual bool Equals(object value);
    public static bool op_Inequality(ExpiresEntryRef r1, ExpiresEntryRef r2);
    public static bool op_Equality(ExpiresEntryRef r1, ExpiresEntryRef r2);
    public virtual int GetHashCode();
    internal int get_PageIndex();
    internal int get_Index();
    internal bool get_IsInvalid();
}
internal class System.Runtime.Caching.ExpiresPage : ValueType {
    internal ExpiresEntry[] _entries;
    internal int _pageNext;
    internal int _pagePrev;
}
internal class System.Runtime.Caching.ExpiresPageList : ValueType {
    internal int _head;
    internal int _tail;
}
public abstract class System.Runtime.Caching.FileChangeMonitor : ChangeMonitor {
    public ReadOnlyCollection`1<string> FilePaths { get; }
    public DateTimeOffset LastModified { get; }
    public abstract virtual ReadOnlyCollection`1<string> get_FilePaths();
    public abstract virtual DateTimeOffset get_LastModified();
}
internal class System.Runtime.Caching.FileChangeNotificationSystem : object {
    private Hashtable _dirMonitors;
    private object _lock;
    private sealed virtual override void System.Runtime.Caching.Hosting.IFileChangeNotificationSystem.StartMonitoring(string filePath, OnChangedCallback onChangedCallback, Object& state, DateTimeOffset& lastWriteTime, Int64& fileSize);
    private sealed virtual override void System.Runtime.Caching.Hosting.IFileChangeNotificationSystem.StopMonitoring(string filePath, object state);
}
internal class System.Runtime.Caching.GCHandleRef`1 : object {
    private GCHandle _handle;
    private T _t;
    public T Target { get; }
    public GCHandleRef`1(T t);
    public T get_Target();
    public sealed virtual void Dispose();
}
public class System.Runtime.Caching.HostFileChangeMonitor : FileChangeMonitor {
    private static int MAX_CHAR_COUNT_OF_LONG_CONVERTED_TO_HEXADECIMAL_STRING;
    private static IFileChangeNotificationSystem s_fcn;
    private ReadOnlyCollection`1<string> _filePaths;
    private string _uniqueId;
    private object _fcnState;
    private DateTimeOffset _lastModified;
    public ReadOnlyCollection`1<string> FilePaths { get; }
    public string UniqueId { get; }
    public DateTimeOffset LastModified { get; }
    public HostFileChangeMonitor(IList`1<string> filePaths);
    private void InitDisposableMembers();
    private static void InitFCN();
    protected virtual void Dispose(bool disposing);
    public virtual ReadOnlyCollection`1<string> get_FilePaths();
    public virtual string get_UniqueId();
    public virtual DateTimeOffset get_LastModified();
    private static ReadOnlyCollection`1<string> SanitizeFilePathsList(IList`1<string> filePaths);
}
public interface System.Runtime.Caching.Hosting.IApplicationIdentifier {
    public abstract virtual string GetApplicationId();
}
public interface System.Runtime.Caching.Hosting.IFileChangeNotificationSystem {
    public abstract virtual void StartMonitoring(string filePath, OnChangedCallback onChangedCallback, Object& state, DateTimeOffset& lastWriteTime, Int64& fileSize);
    public abstract virtual void StopMonitoring(string filePath, object state);
}
public interface System.Runtime.Caching.Hosting.IMemoryCacheManager {
    public abstract virtual void UpdateCacheSize(long size, MemoryCache cache);
    public abstract virtual void ReleaseCache(MemoryCache cache);
}
[DefaultMemberAttribute("Item")]
public class System.Runtime.Caching.MemoryCache : ObjectCache {
    private static DefaultCacheCapabilities CAPABILITIES;
    private static TimeSpan s_oneYear;
    private static object s_initLock;
    private static MemoryCache s_defaultCache;
    private static CacheEntryRemovedCallback s_sentinelRemovedCallback;
    private GCHandleRef`1[] _storeRefs;
    private int _storeCount;
    private int _disposed;
    private MemoryCacheStatistics _stats;
    private string _name;
    private Counters _perfCounters;
    private bool _configLess;
    private bool _useMemoryCacheManager;
    private EventHandler _onAppDomainUnload;
    private UnhandledExceptionEventHandler _onUnhandledException;
    private static bool _countersSupported { get; }
    private bool IsDisposed { get; }
    internal bool ConfigLess { get; }
    internal Object[] AllSRefTargets { get; }
    public long CacheMemoryLimit { get; }
    public static MemoryCache Default { get; }
    public DefaultCacheCapabilities DefaultCacheCapabilities { get; }
    public string Name { get; }
    internal bool UseMemoryCacheManager { get; }
    public long PhysicalMemoryLimit { get; }
    public TimeSpan PollingInterval { get; }
    public object Item { get; public set; }
    public MemoryCache(string name, NameValueCollection config);
    public MemoryCache(string name, NameValueCollection config, bool ignoreConfigSection);
    private static MemoryCache();
    private static bool get__countersSupported();
    private bool get_IsDisposed();
    internal bool get_ConfigLess();
    internal MemoryCacheStore GetStore(MemoryCacheKey cacheKey);
    internal Object[] get_AllSRefTargets();
    private void InitDisposableMembers(NameValueCollection config);
    private void OnAppDomainUnload(object unusedObject, EventArgs unusedEventArgs);
    private void OnUnhandledException(object sender, UnhandledExceptionEventArgs eventArgs);
    private void ValidatePolicy(CacheItemPolicy policy);
    public long get_CacheMemoryLimit();
    public static MemoryCache get_Default();
    public virtual DefaultCacheCapabilities get_DefaultCacheCapabilities();
    public virtual string get_Name();
    internal bool get_UseMemoryCacheManager();
    public long get_PhysicalMemoryLimit();
    public TimeSpan get_PollingInterval();
    private void Init(NameValueCollection config);
    private object AddOrGetExistingInternal(string key, object value, CacheItemPolicy policy);
    public virtual CacheEntryChangeMonitor CreateCacheEntryChangeMonitor(IEnumerable`1<string> keys, string regionName);
    public sealed virtual void Dispose();
    private void DisposeSafeCritical();
    private object GetInternal(string key, string regionName);
    internal MemoryCacheEntry GetEntry(string key);
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
    protected virtual IEnumerator`1<KeyValuePair`2<string, object>> GetEnumerator();
    internal MemoryCacheEntry RemoveEntry(string key, MemoryCacheEntry entry, CacheEntryRemovedReason reason);
    public long Trim(int percent);
    public virtual object get_Item(string key);
    public virtual void set_Item(string key, object value);
    public virtual bool Contains(string key, string regionName);
    public virtual bool Add(CacheItem item, CacheItemPolicy policy);
    public virtual object AddOrGetExisting(string key, object value, DateTimeOffset absoluteExpiration, string regionName);
    public virtual CacheItem AddOrGetExisting(CacheItem item, CacheItemPolicy policy);
    public virtual object AddOrGetExisting(string key, object value, CacheItemPolicy policy, string regionName);
    public virtual object Get(string key, string regionName);
    public virtual CacheItem GetCacheItem(string key, string regionName);
    public virtual void Set(string key, object value, DateTimeOffset absoluteExpiration, string regionName);
    public virtual void Set(CacheItem item, CacheItemPolicy policy);
    public virtual void Set(string key, object value, CacheItemPolicy policy, string regionName);
    internal void Set(string key, object value, Collection`1<ChangeMonitor> changeMonitors, DateTimeOffset absoluteExpiration, TimeSpan slidingExpiration, CacheEntryUpdateCallback onUpdateCallback);
    public virtual object Remove(string key, string regionName);
    public object Remove(string key, CacheEntryRemovedReason reason, string regionName);
    public virtual long GetCount(string regionName);
    public long GetLastSize(string regionName);
    public virtual IDictionary`2<string, object> GetValues(IEnumerable`1<string> keys, string regionName);
    internal void UpdateConfig(NameValueCollection config);
}
internal class System.Runtime.Caching.MemoryCacheEntry : MemoryCacheKey {
    private object _value;
    private DateTime _utcCreated;
    private int _state;
    private DateTime _utcAbsExp;
    private TimeSpan _slidingExp;
    private ExpiresEntryRef _expiresEntryRef;
    private byte _expiresBucket;
    private byte _usageBucket;
    private UsageEntryRef _usageEntryRef;
    private DateTime _utcLastUpdateUsage;
    private CacheEntryRemovedCallback _callback;
    private SeldomUsedFields _fields;
    internal object Value { get; }
    internal DateTime UtcAbsExp { get; internal set; }
    internal DateTime UtcCreated { get; }
    internal ExpiresEntryRef ExpiresEntryRef { get; internal set; }
    internal byte ExpiresBucket { get; internal set; }
    internal TimeSpan SlidingExp { get; }
    internal EntryState State { get; internal set; }
    internal byte UsageBucket { get; }
    internal UsageEntryRef UsageEntryRef { get; internal set; }
    internal DateTime UtcLastUpdateUsage { get; internal set; }
    internal MemoryCacheEntry(string key, object value, DateTimeOffset absExp, TimeSpan slidingExp, CacheItemPriority priority, Collection`1<ChangeMonitor> dependencies, CacheEntryRemovedCallback removedCallback, MemoryCache cache);
    internal object get_Value();
    internal bool HasExpiration();
    internal DateTime get_UtcAbsExp();
    internal void set_UtcAbsExp(DateTime value);
    internal DateTime get_UtcCreated();
    internal ExpiresEntryRef get_ExpiresEntryRef();
    internal void set_ExpiresEntryRef(ExpiresEntryRef value);
    internal byte get_ExpiresBucket();
    internal void set_ExpiresBucket(byte value);
    internal bool InExpires();
    internal TimeSpan get_SlidingExp();
    internal EntryState get_State();
    internal void set_State(EntryState value);
    internal byte get_UsageBucket();
    internal UsageEntryRef get_UsageEntryRef();
    internal void set_UsageEntryRef(UsageEntryRef value);
    internal DateTime get_UtcLastUpdateUsage();
    internal void set_UtcLastUpdateUsage(DateTime value);
    internal void AddDependent(MemoryCache cache, MemoryCacheEntryChangeMonitor dependent);
    private void CallCacheEntryRemovedCallback(MemoryCache cache, CacheEntryRemovedReason reason);
    internal void CallNotifyOnChanged();
    internal bool CompareExchangeState(EntryState value, EntryState comparand);
    internal void ConfigureUpdateSentinel(MemoryCacheStore sentinelStore, MemoryCacheEntry sentinelEntry);
    internal bool HasUsage();
    internal bool InUsage();
    private void OnDependencyChanged(object state);
    internal void Release(MemoryCache cache, CacheEntryRemovedReason reason);
    internal void RemoveDependent(MemoryCacheEntryChangeMonitor dependent);
    internal void UpdateSlidingExp(DateTime utcNow, CacheExpires expires);
    internal void UpdateSlidingExpForUpdateSentinel();
    internal void UpdateUsage(DateTime utcNow, CacheUsage usage);
}
internal class System.Runtime.Caching.MemoryCacheEntryChangeMonitor : CacheEntryChangeMonitor {
    private static DateTime s_DATETIME_MINVALUE_UTC;
    private static int MAX_CHAR_COUNT_OF_LONG_CONVERTED_TO_HEXADECIMAL_STRING;
    private ReadOnlyCollection`1<string> _keys;
    private string _regionName;
    private string _uniqueId;
    private DateTimeOffset _lastModified;
    private List`1<MemoryCacheEntry> _dependencies;
    public ReadOnlyCollection`1<string> CacheKeys { get; }
    public string RegionName { get; }
    public string UniqueId { get; }
    public DateTimeOffset LastModified { get; }
    internal List`1<MemoryCacheEntry> Dependencies { get; }
    internal MemoryCacheEntryChangeMonitor(ReadOnlyCollection`1<string> keys, string regionName, MemoryCache cache);
    private static MemoryCacheEntryChangeMonitor();
    private void InitDisposableMembers(MemoryCache cache);
    private void StartMonitoring(MemoryCache cache, MemoryCacheEntry entry, Boolean& hasChanged, DateTime& utcCreated);
    protected virtual void Dispose(bool disposing);
    public virtual ReadOnlyCollection`1<string> get_CacheKeys();
    public virtual string get_RegionName();
    public virtual string get_UniqueId();
    public virtual DateTimeOffset get_LastModified();
    internal List`1<MemoryCacheEntry> get_Dependencies();
    internal void OnCacheEntryReleased();
}
internal class System.Runtime.Caching.MemoryCacheEqualityComparer : object {
    private sealed virtual override bool System.Collections.IEqualityComparer.Equals(object x, object y);
    private sealed virtual override int System.Collections.IEqualityComparer.GetHashCode(object obj);
}
internal class System.Runtime.Caching.MemoryCacheKey : object {
    private string _key;
    private int _hash;
    internal int Hash { get; }
    internal string Key { get; }
    internal MemoryCacheKey(string key);
    internal int get_Hash();
    internal string get_Key();
}
internal class System.Runtime.Caching.MemoryCacheStatistics : object {
    private static int MEMORYSTATUS_INTERVAL_5_SECONDS;
    private static int MEMORYSTATUS_INTERVAL_30_SECONDS;
    private int _configCacheMemoryLimitMegabytes;
    private int _configPhysicalMemoryLimitPercentage;
    private int _configPollingInterval;
    private int _inCacheManagerThread;
    private int _disposed;
    private long _lastTrimCount;
    private long _lastTrimDurationTicks;
    private int _lastTrimGen2Count;
    private int _lastTrimPercent;
    private DateTime _lastTrimTime;
    private int _pollingInterval;
    private GCHandleRef`1<Timer> _timerHandleRef;
    private object _timerLock;
    private long _totalCountBeforeTrim;
    private CacheMemoryMonitor _cacheMemoryMonitor;
    private MemoryCache _memoryCache;
    private PhysicalMemoryMonitor _physicalMemoryMonitor;
    private static bool _configSupported { get; }
    internal long CacheMemoryLimit { get; }
    internal long PhysicalMemoryLimit { get; }
    internal TimeSpan PollingInterval { get; }
    internal MemoryCacheStatistics(MemoryCache memoryCache, NameValueCollection config);
    private static bool get__configSupported();
    private void AdjustTimer();
    private void CacheManagerTimerCallback(object state);
    internal long GetLastSize();
    private int GetPercentToTrim();
    private void InitializeConfiguration(NameValueCollection config);
    private void InitDisposableMembers();
    private void SetTrimStats(long trimDurationTicks, long totalCountBeforeTrim, long trimCount);
    private void Update();
    internal long get_CacheMemoryLimit();
    internal long get_PhysicalMemoryLimit();
    internal TimeSpan get_PollingInterval();
    internal long CacheManagerThread(int minPercent);
    public sealed virtual void Dispose();
    internal void UpdateConfig(NameValueCollection config);
}
internal class System.Runtime.Caching.MemoryCacheStore : object {
    private static int INSERT_BLOCK_WAIT;
    private static int MAX_COUNT;
    private Hashtable _entries;
    private object _entriesLock;
    private CacheExpires _expires;
    private CacheUsage _usage;
    private int _disposed;
    private ManualResetEvent _insertBlock;
    private Boolean modreq(System.Runtime.CompilerServices.IsVolatile) _useInsertBlock;
    private MemoryCache _cache;
    private Counters _perfCounters;
    private static bool _countersSupported { get; }
    internal CacheUsage Usage { get; }
    internal int Count { get; }
    internal MemoryCacheStore(MemoryCache cache, Counters perfCounters);
    private static bool get__countersSupported();
    private void AddToCache(MemoryCacheEntry entry);
    private void InitDisposableMembers();
    private void RemoveFromCache(MemoryCacheEntry entry, CacheEntryRemovedReason reason, bool delayRelease);
    internal void UpdateExpAndUsage(MemoryCacheEntry entry, bool updatePerfCounters);
    private void WaitInsertBlock();
    internal CacheUsage get_Usage();
    internal MemoryCacheEntry AddOrGetExisting(MemoryCacheKey key, MemoryCacheEntry entry);
    internal void BlockInsert();
    internal void CopyTo(IDictionary h);
    internal int get_Count();
    public sealed virtual void Dispose();
    internal MemoryCacheEntry Get(MemoryCacheKey key);
    internal MemoryCacheEntry Remove(MemoryCacheKey key, MemoryCacheEntry entryToRemove, CacheEntryRemovedReason reason);
    internal void Set(MemoryCacheKey key, MemoryCacheEntry entry);
    internal long TrimInternal(int percent);
    internal void UnblockInsert();
}
internal abstract class System.Runtime.Caching.MemoryMonitor : object {
    protected static int TERABYTE_SHIFT;
    protected static long TERABYTE;
    protected static int GIGABYTE_SHIFT;
    protected static long GIGABYTE;
    protected static int MEGABYTE_SHIFT;
    protected static long MEGABYTE;
    protected static int KILOBYTE_SHIFT;
    protected static long KILOBYTE;
    protected static int HISTORY_COUNT;
    protected int _pressureHigh;
    protected int _pressureLow;
    protected int _i0;
    protected Int32[] _pressureHist;
    protected int _pressureTotal;
    private static long s_totalPhysical;
    private static long s_totalVirtual;
    internal static long TotalPhysical { get; }
    internal static long TotalVirtual { get; }
    internal int PressureLast { get; }
    internal int PressureHigh { get; }
    internal int PressureLow { get; }
    private static MemoryMonitor();
    internal static long get_TotalPhysical();
    internal static long get_TotalVirtual();
    internal int get_PressureLast();
    internal int get_PressureHigh();
    internal int get_PressureLow();
    internal bool IsAboveHighPressure();
    protected abstract virtual int GetCurrentPressure();
    internal abstract virtual int GetPercentToTrim(DateTime lastTrimTime, int lastTrimPercent);
    protected void InitHistory();
    internal void Update();
}
[DefaultMemberAttribute("Item")]
public abstract class System.Runtime.Caching.ObjectCache : object {
    private static IServiceProvider s_host;
    public static DateTimeOffset InfiniteAbsoluteExpiration;
    public static TimeSpan NoSlidingExpiration;
    public static IServiceProvider Host { get; public set; }
    public DefaultCacheCapabilities DefaultCacheCapabilities { get; }
    public string Name { get; }
    public object Item { get; public set; }
    private static ObjectCache();
    public static IServiceProvider get_Host();
    public static void set_Host(IServiceProvider value);
    public abstract virtual DefaultCacheCapabilities get_DefaultCacheCapabilities();
    public abstract virtual string get_Name();
    public abstract virtual object get_Item(string key);
    public abstract virtual void set_Item(string key, object value);
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
    public abstract virtual CacheEntryChangeMonitor CreateCacheEntryChangeMonitor(IEnumerable`1<string> keys, string regionName);
    private sealed virtual override IEnumerator`1<KeyValuePair`2<string, object>> System.Collections.Generic.IEnumerable<System.Collections.Generic.KeyValuePair<System.String,System.Object>>.GetEnumerator();
    protected abstract virtual IEnumerator`1<KeyValuePair`2<string, object>> GetEnumerator();
    public abstract virtual bool Contains(string key, string regionName);
    public virtual bool Add(string key, object value, DateTimeOffset absoluteExpiration, string regionName);
    public virtual bool Add(CacheItem item, CacheItemPolicy policy);
    public virtual bool Add(string key, object value, CacheItemPolicy policy, string regionName);
    public abstract virtual object AddOrGetExisting(string key, object value, DateTimeOffset absoluteExpiration, string regionName);
    public abstract virtual CacheItem AddOrGetExisting(CacheItem value, CacheItemPolicy policy);
    public abstract virtual object AddOrGetExisting(string key, object value, CacheItemPolicy policy, string regionName);
    public abstract virtual object Get(string key, string regionName);
    public abstract virtual CacheItem GetCacheItem(string key, string regionName);
    public abstract virtual void Set(string key, object value, DateTimeOffset absoluteExpiration, string regionName);
    public abstract virtual void Set(CacheItem item, CacheItemPolicy policy);
    public abstract virtual void Set(string key, object value, CacheItemPolicy policy, string regionName);
    public abstract virtual IDictionary`2<string, object> GetValues(IEnumerable`1<string> keys, string regionName);
    public virtual IDictionary`2<string, object> GetValues(string regionName, String[] keys);
    public abstract virtual object Remove(string key, string regionName);
    public abstract virtual long GetCount(string regionName);
}
public class System.Runtime.Caching.OnChangedCallback : MulticastDelegate {
    public OnChangedCallback(object object, IntPtr method);
    public virtual void Invoke(object state);
    public virtual IAsyncResult BeginInvoke(object state, AsyncCallback callback, object object);
    public virtual void EndInvoke(IAsyncResult result);
}
internal class System.Runtime.Caching.PhysicalMemoryMonitor : MemoryMonitor {
    private static int MinTotalMemoryTrimPercent;
    private static long TargetTotalMemoryTrimIntervalTicks;
    internal long MemoryLimit { get; }
    internal PhysicalMemoryMonitor(int physicalMemoryLimitPercentage);
    internal long get_MemoryLimit();
    internal virtual int GetPercentToTrim(DateTime lastTrimTime, int lastTrimPercent);
    internal void SetLimit(int physicalMemoryLimitPercentage);
    protected virtual int GetCurrentPressure();
}
internal static class System.Runtime.Caching.Resources.RH : object {
    public static string Format(string resource, Object[] args);
}
[DefaultMemberAttribute("Item")]
internal class System.Runtime.Caching.SafeBitVector32 : ValueType {
    private Int32 modreq(System.Runtime.CompilerServices.IsVolatile) _data;
    internal bool Item { get; internal set; }
    internal bool get_Item(int bit);
    internal void set_Item(int bit, bool value);
    internal bool ChangeValue(int bit, bool value);
}
internal class System.Runtime.Caching.SRefMultiple : object {
    internal long ApproximateSize { get; }
    internal SRefMultiple(Object[] targets);
    internal long get_ApproximateSize();
    internal void Dispose();
}
internal class System.Runtime.Caching.UsageBucket : object {
    private static int NUM_ENTRIES;
    private static int LENGTH_ENTRIES;
    private static int MIN_PAGES_INCREMENT;
    private static int MAX_PAGES_INCREMENT;
    private static double MIN_LOAD_FACTOR;
    private CacheUsage _cacheUsage;
    private byte _bucket;
    private UsagePage[] _pages;
    private int _cEntriesInUse;
    private int _cPagesInUse;
    private int _cEntriesInFlush;
    private int _minEntriesInUse;
    private UsagePageList _freePageList;
    private UsagePageList _freeEntryList;
    private UsageEntryRef _lastRefHead;
    private UsageEntryRef _lastRefTail;
    private UsageEntryRef _addRef2Head;
    private bool _blockReduce;
    internal UsageBucket(CacheUsage cacheUsage, byte bucket);
    private void InitZeroPages();
    private void AddToListHead(int pageIndex, UsagePageList& list);
    private void AddToListTail(int pageIndex, UsagePageList& list);
    private int RemoveFromListHead(UsagePageList& list);
    private void RemoveFromList(int pageIndex, UsagePageList& list);
    private void MoveToListHead(int pageIndex, UsagePageList& list);
    private void MoveToListTail(int pageIndex, UsagePageList& list);
    private void UpdateMinEntries();
    private void RemovePage(int pageIndex);
    private UsageEntryRef GetFreeUsageEntry();
    private void AddUsageEntryToFreeList(UsageEntryRef entryRef);
    private void Expand();
    private void Reduce();
    internal void AddCacheEntry(MemoryCacheEntry cacheEntry);
    private void RemoveEntryFromLastRefList(UsageEntryRef entryRef);
    internal void RemoveCacheEntry(MemoryCacheEntry cacheEntry);
    internal void UpdateCacheEntry(MemoryCacheEntry cacheEntry);
    internal int FlushUnderUsedItems(int maxFlush, bool force);
}
internal class System.Runtime.Caching.UsageEntry : ValueType {
    internal UsageEntryLink _ref1;
    internal int _cFree;
    internal UsageEntryLink _ref2;
    internal DateTime _utcDate;
    internal MemoryCacheEntry _cacheEntry;
}
internal class System.Runtime.Caching.UsageEntryLink : ValueType {
    internal UsageEntryRef _next;
    internal UsageEntryRef _prev;
}
internal class System.Runtime.Caching.UsageEntryRef : ValueType {
    internal static UsageEntryRef INVALID;
    private static UInt32 ENTRY_MASK;
    private static int PAGE_SHIFT;
    private UInt32 _ref;
    internal int PageIndex { get; }
    internal int Ref1Index { get; }
    internal int Ref2Index { get; }
    internal bool IsRef1 { get; }
    internal bool IsRef2 { get; }
    internal bool IsInvalid { get; }
    internal UsageEntryRef(int pageIndex, int entryIndex);
    private static UsageEntryRef();
    public virtual bool Equals(object value);
    public static bool op_Equality(UsageEntryRef r1, UsageEntryRef r2);
    public static bool op_Inequality(UsageEntryRef r1, UsageEntryRef r2);
    public virtual int GetHashCode();
    internal int get_PageIndex();
    internal int get_Ref1Index();
    internal int get_Ref2Index();
    internal bool get_IsRef1();
    internal bool get_IsRef2();
    internal bool get_IsInvalid();
}
internal class System.Runtime.Caching.UsagePage : ValueType {
    internal UsageEntry[] _entries;
    internal int _pageNext;
    internal int _pagePrev;
}
internal class System.Runtime.Caching.UsagePageList : ValueType {
    internal int _head;
    internal int _tail;
}
internal abstract class System.Runtime.Versioning.OSPlatformAttribute : Attribute {
    [CompilerGeneratedAttribute]
private string <PlatformName>k__BackingField;
    public string PlatformName { get; }
    private protected OSPlatformAttribute(string platformName);
    [CompilerGeneratedAttribute]
public string get_PlatformName();
}
[AttributeUsageAttribute("2047")]
internal class System.Runtime.Versioning.SupportedOSPlatformAttribute : OSPlatformAttribute {
    public SupportedOSPlatformAttribute(string platformName);
}
[AttributeUsageAttribute("448")]
internal class System.Runtime.Versioning.SupportedOSPlatformGuardAttribute : OSPlatformAttribute {
    public SupportedOSPlatformGuardAttribute(string platformName);
}
[AttributeUsageAttribute("1")]
internal class System.Runtime.Versioning.TargetPlatformAttribute : OSPlatformAttribute {
    public TargetPlatformAttribute(string platformName);
}
[AttributeUsageAttribute("2047")]
internal class System.Runtime.Versioning.UnsupportedOSPlatformAttribute : OSPlatformAttribute {
    public UnsupportedOSPlatformAttribute(string platformName);
}
[AttributeUsageAttribute("448")]
internal class System.Runtime.Versioning.UnsupportedOSPlatformGuardAttribute : OSPlatformAttribute {
    public UnsupportedOSPlatformGuardAttribute(string platformName);
}
internal static class System.SR : object {
    private static bool s_usingResourceKeys;
    private static ResourceManager s_resourceManager;
    internal static ResourceManager ResourceManager { get; }
    internal static string Config_unable_to_get_section { get; }
    internal static string TimeSpan_invalid_format { get; }
    internal static string Value_must_be_non_negative_integer { get; }
    internal static string Value_must_be_positive_integer { get; }
    internal static string Value_too_big { get; }
    internal static string Empty_collection { get; }
    internal static string Collection_contains_null_element { get; }
    internal static string Collection_contains_null_or_empty_string { get; }
    internal static string Method_already_invoked { get; }
    internal static string Property_already_set { get; }
    internal static string Invalid_state { get; }
    internal static string Init_not_complete { get; }
    internal static string Default_is_reserved { get; }
    internal static string Invalid_expiration_combination { get; }
    internal static string Invalid_callback_combination { get; }
    internal static string Invalid_argument_combination { get; }
    internal static string Update_callback_must_be_null { get; }
    internal static string Argument_out_of_range { get; }
    internal static string Empty_string_invalid { get; }
    internal static string RegionName_not_supported { get; }
    internal static string Value_must_be_boolean { get; }
    internal static string PlatformNotSupported_Caching { get; }
    internal static string PlatformNotSupported_PhysicalMemoryLimitPercentage { get; }
    private static SR();
    private static bool UsingResourceKeys();
    internal static string GetResourceString(string resourceKey);
    internal static string GetResourceString(string resourceKey, string defaultString);
    internal static string Format(string resourceFormat, object p1);
    internal static string Format(string resourceFormat, object p1, object p2);
    internal static string Format(string resourceFormat, object p1, object p2, object p3);
    internal static string Format(string resourceFormat, Object[] args);
    internal static string Format(IFormatProvider provider, string resourceFormat, object p1);
    internal static string Format(IFormatProvider provider, string resourceFormat, object p1, object p2);
    internal static string Format(IFormatProvider provider, string resourceFormat, object p1, object p2, object p3);
    internal static string Format(IFormatProvider provider, string resourceFormat, Object[] args);
    internal static ResourceManager get_ResourceManager();
    internal static string get_Config_unable_to_get_section();
    internal static string get_TimeSpan_invalid_format();
    internal static string get_Value_must_be_non_negative_integer();
    internal static string get_Value_must_be_positive_integer();
    internal static string get_Value_too_big();
    internal static string get_Empty_collection();
    internal static string get_Collection_contains_null_element();
    internal static string get_Collection_contains_null_or_empty_string();
    internal static string get_Method_already_invoked();
    internal static string get_Property_already_set();
    internal static string get_Invalid_state();
    internal static string get_Init_not_complete();
    internal static string get_Default_is_reserved();
    internal static string get_Invalid_expiration_combination();
    internal static string get_Invalid_callback_combination();
    internal static string get_Invalid_argument_combination();
    internal static string get_Update_callback_must_be_null();
    internal static string get_Argument_out_of_range();
    internal static string get_Empty_string_invalid();
    internal static string get_RegionName_not_supported();
    internal static string get_Value_must_be_boolean();
    internal static string get_PlatformNotSupported_Caching();
    internal static string get_PlatformNotSupported_PhysicalMemoryLimitPercentage();
}
