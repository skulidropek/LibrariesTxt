internal static class FxResources.System.Runtime.WindowsRuntime.SR : object {
}
internal static class Interop : object {
}
internal abstract class System.IO.NetFxToWinRtStreamAdapter : object {
    private Stream _managedStream;
    private bool _leaveUnderlyingStreamOpen;
    private StreamReadOperationOptimization _readOptimization;
    public bool CanRead { get; }
    public bool CanWrite { get; }
    public ulong Position { get; }
    public ulong Size { get; public set; }
    private NetFxToWinRtStreamAdapter(Stream stream, StreamReadOperationOptimization readOptimization);
    internal static NetFxToWinRtStreamAdapter Create(Stream stream);
    private static StreamReadOperationOptimization DetermineStreamReadOptimization(Stream stream);
    private static bool CanApplyReadMemoryStreamOptimization(Stream stream);
    internal void SetWonInitializationRace();
    public Stream GetManagedStream();
    private Stream EnsureNotDisposed();
    private sealed virtual override void System.IDisposable.Dispose();
    public sealed virtual IAsyncOperationWithProgress`2<IBuffer, UInt32> ReadAsync(IBuffer buffer, UInt32 count, InputStreamOptions options);
    public sealed virtual IAsyncOperationWithProgress`2<UInt32, UInt32> WriteAsync(IBuffer buffer);
    public sealed virtual IAsyncOperation`1<bool> FlushAsync();
    public sealed virtual void Seek(ulong position);
    public sealed virtual bool get_CanRead();
    public sealed virtual bool get_CanWrite();
    public sealed virtual ulong get_Position();
    public sealed virtual ulong get_Size();
    public void set_Size(ulong value);
    private static void ThrowCloningNotSuported(string methodName);
    public sealed virtual IRandomAccessStream CloneStream();
    public sealed virtual IInputStream GetInputStreamAt(ulong position);
    public sealed virtual IOutputStream GetOutputStreamAt(ulong position);
}
internal class System.IO.StreamFlushAsyncResult : StreamOperationAsyncResult {
    internal StreamFlushAsyncResult(IAsyncOperation`1<bool> asyncStreamFlushOperation, bool processCompletedOperationInCallback);
    internal virtual void ProcessConcreteCompletedOperation(IAsyncInfo completedOperation, Int64& bytesCompleted);
    private void ProcessConcreteCompletedOperation(IAsyncOperation`1<bool> completedOperation, Int64& bytesCompleted);
}
internal abstract class System.IO.StreamOperationAsyncResult : object {
    private AsyncCallback _userCompletionCallback;
    private object _userAsyncStateInfo;
    private IAsyncInfo _asyncStreamOperation;
    private Boolean modreq(System.Runtime.CompilerServices.IsVolatile) _completed;
    private Boolean modreq(System.Runtime.CompilerServices.IsVolatile) _callbackInvoked;
    private ManualResetEvent modreq(System.Runtime.CompilerServices.IsVolatile) _waitHandle;
    private long _bytesCompleted;
    private ExceptionDispatchInfo _errorInfo;
    private bool _processCompletedOperationInCallback;
    private IAsyncInfo _completedOperation;
    public object AsyncState { get; }
    internal bool ProcessCompletedOperationInCallback { get; }
    public WaitHandle AsyncWaitHandle { get; }
    public bool CompletedSynchronously { get; }
    public bool IsCompleted { get; }
    internal long BytesCompleted { get; }
    internal bool HasError { get; }
    protected internal StreamOperationAsyncResult(IAsyncInfo asyncStreamOperation, AsyncCallback userCompletionCallback, object userAsyncStateInfo, bool processCompletedOperationInCallback);
    private void ThrowWithIOExceptionDispatchInfo(Exception e);
    public sealed virtual object get_AsyncState();
    internal bool get_ProcessCompletedOperationInCallback();
    public sealed virtual WaitHandle get_AsyncWaitHandle();
    public sealed virtual bool get_CompletedSynchronously();
    public sealed virtual bool get_IsCompleted();
    internal void Wait();
    internal long get_BytesCompleted();
    internal bool get_HasError();
    internal void ThrowCachedError();
    internal bool CancelStreamOperation();
    internal void CloseStreamOperation();
    protected virtual override void Finalize();
    internal abstract virtual void ProcessConcreteCompletedOperation(IAsyncInfo completedOperation, Int64& bytesCompleted);
    private static void ProcessCompletedOperation_InvalidOperationThrowHelper(ExceptionDispatchInfo errInfo, string errMsg);
    internal void ProcessCompletedOperation();
    internal void StreamOperationCompletedCallback(IAsyncInfo completedOperation, AsyncStatus unusedCompletionStatus);
}
internal static class System.IO.StreamOperationsImplementation : object {
    internal static IAsyncOperationWithProgress`2<IBuffer, UInt32> ReadAsync_MemoryStream(Stream stream, IBuffer buffer, UInt32 count);
    internal static IAsyncOperationWithProgress`2<IBuffer, UInt32> ReadAsync_AbstractStream(Stream stream, IBuffer buffer, UInt32 count, InputStreamOptions options);
    internal static IAsyncOperationWithProgress`2<UInt32, UInt32> WriteAsync_AbstractStream(Stream stream, IBuffer buffer);
    internal static IAsyncOperation`1<bool> FlushAsync_AbstractStream(Stream stream);
}
internal class System.IO.StreamReadAsyncResult : StreamOperationAsyncResult {
    private IBuffer _userBuffer;
    internal StreamReadAsyncResult(IAsyncOperationWithProgress`2<IBuffer, UInt32> asyncStreamReadOperation, IBuffer buffer, AsyncCallback userCompletionCallback, object userAsyncStateInfo, bool processCompletedOperationInCallback);
    internal virtual void ProcessConcreteCompletedOperation(IAsyncInfo completedOperation, Int64& bytesCompleted);
    private void ProcessConcreteCompletedOperation(IAsyncOperationWithProgress`2<IBuffer, UInt32> completedOperation, Int64& bytesCompleted);
}
internal class System.IO.StreamWriteAsyncResult : StreamOperationAsyncResult {
    internal StreamWriteAsyncResult(IAsyncOperationWithProgress`2<UInt32, UInt32> asyncStreamWriteOperation, AsyncCallback userCompletionCallback, object userAsyncStateInfo, bool processCompletedOperationInCallback);
    internal virtual void ProcessConcreteCompletedOperation(IAsyncInfo completedOperation, Int64& bytesCompleted);
    private void ProcessConcreteCompletedOperation(IAsyncOperationWithProgress`2<UInt32, UInt32> completedOperation, Int64& bytesCompleted);
}
[ExtensionAttribute]
public static class System.IO.WindowsRuntimeStorageExtensions : object {
    [ExtensionAttribute]
[CLSCompliantAttribute("False")]
public static Task`1<Stream> OpenStreamForReadAsync(IStorageFile windowsRuntimeFile);
    [AsyncStateMachineAttribute("System.IO.WindowsRuntimeStorageExtensions/<OpenStreamForReadAsyncCore>d__1")]
[ExtensionAttribute]
private static Task`1<Stream> OpenStreamForReadAsyncCore(IStorageFile windowsRuntimeFile);
    [ExtensionAttribute]
[CLSCompliantAttribute("False")]
public static Task`1<Stream> OpenStreamForWriteAsync(IStorageFile windowsRuntimeFile);
    [AsyncStateMachineAttribute("System.IO.WindowsRuntimeStorageExtensions/<OpenStreamForWriteAsyncCore>d__3")]
[ExtensionAttribute]
private static Task`1<Stream> OpenStreamForWriteAsyncCore(IStorageFile windowsRuntimeFile, long offset);
    [ExtensionAttribute]
[CLSCompliantAttribute("False")]
public static Task`1<Stream> OpenStreamForReadAsync(IStorageFolder rootDirectory, string relativePath);
    [AsyncStateMachineAttribute("System.IO.WindowsRuntimeStorageExtensions/<OpenStreamForReadAsyncCore>d__5")]
[ExtensionAttribute]
private static Task`1<Stream> OpenStreamForReadAsyncCore(IStorageFolder rootDirectory, string relativePath);
    [ExtensionAttribute]
[CLSCompliantAttribute("False")]
public static Task`1<Stream> OpenStreamForWriteAsync(IStorageFolder rootDirectory, string relativePath, CreationCollisionOption creationCollisionOption);
    [AsyncStateMachineAttribute("System.IO.WindowsRuntimeStorageExtensions/<OpenStreamForWriteAsyncCore>d__7")]
[ExtensionAttribute]
private static Task`1<Stream> OpenStreamForWriteAsyncCore(IStorageFolder rootDirectory, string relativePath, CreationCollisionOption creationCollisionOption);
}
[ExtensionAttribute]
public static class System.IO.WindowsRuntimeStreamExtensions : object {
    private static int DefaultBufferSize;
    private static ConditionalWeakTable`2<object, Stream> s_winRtToNetFxAdapterMap;
    private static ConditionalWeakTable`2<Stream, NetFxToWinRtStreamAdapter> s_netFxToWinRtAdapterMap;
    private static WindowsRuntimeStreamExtensions();
    private static void EnsureAdapterBufferSize(Stream adapter, int requiredBufferSize, string methodName);
    [ExtensionAttribute]
[CLSCompliantAttribute("False")]
public static Stream AsStreamForRead(IInputStream windowsRuntimeStream);
    [ExtensionAttribute]
[CLSCompliantAttribute("False")]
public static Stream AsStreamForRead(IInputStream windowsRuntimeStream, int bufferSize);
    [ExtensionAttribute]
[CLSCompliantAttribute("False")]
public static Stream AsStreamForWrite(IOutputStream windowsRuntimeStream);
    [ExtensionAttribute]
[CLSCompliantAttribute("False")]
public static Stream AsStreamForWrite(IOutputStream windowsRuntimeStream, int bufferSize);
    [ExtensionAttribute]
[CLSCompliantAttribute("False")]
public static Stream AsStream(IRandomAccessStream windowsRuntimeStream);
    [ExtensionAttribute]
[CLSCompliantAttribute("False")]
public static Stream AsStream(IRandomAccessStream windowsRuntimeStream, int bufferSize);
    private static Stream AsStreamInternal(object windowsRuntimeStream, int bufferSize, string invokedMethodName, bool forceBufferSize);
    private static Stream WinRtToNetFxAdapterMap_GetValue(object winRtStream);
    private static Stream WinRtToNetFxAdapterMap_GetValue(object winRtStream, int bufferSize);
    private static Stream AsStreamInternalFactoryHelper(object windowsRuntimeStream, int bufferSize, string invokedMethodName, bool forceBufferSize);
    [ExtensionAttribute]
[CLSCompliantAttribute("False")]
public static IInputStream AsInputStream(Stream stream);
    [ExtensionAttribute]
[CLSCompliantAttribute("False")]
public static IOutputStream AsOutputStream(Stream stream);
    [ExtensionAttribute]
[CLSCompliantAttribute("False")]
public static IRandomAccessStream AsRandomAccessStream(Stream stream);
    private static object AsWindowsRuntimeStreamInternal(Stream stream);
    private static NetFxToWinRtStreamAdapter AsWindowsRuntimeStreamInternalFactoryHelper(Stream stream);
}
internal static class System.IO.WinRtIOHelper : object {
    internal static int DefaultIOBufferSize;
    internal static ExceptionDispatchInfo NativeExceptionToIOExceptionInfo(Exception nativeException);
    internal static void EnsureResultsInUserBuffer(IBuffer userBuffer, IBuffer resultBuffer);
}
internal class System.IO.WinRtToNetFxStreamAdapter : Stream {
    private Byte[] _oneByteBuffer;
    private bool _leaveUnderlyingStreamOpen;
    private object _winRtStream;
    private bool _canRead;
    private bool _canWrite;
    private bool _canSeek;
    private Byte[] OneByteBuffer { get; }
    public bool CanRead { get; }
    public bool CanWrite { get; }
    public bool CanSeek { get; }
    public long Length { get; }
    public long Position { get; public set; }
    private WinRtToNetFxStreamAdapter(object winRtStream, bool canRead, bool canWrite, bool canSeek);
    internal static WinRtToNetFxStreamAdapter Create(object windowsRuntimeStream);
    internal void SetWonInitializationRace();
    public TWinRtStream GetWindowsRuntimeStream();
    private Byte[] get_OneByteBuffer();
    private TWinRtStream EnsureNotDisposed();
    private void EnsureNotDisposed();
    private void EnsureCanRead();
    private void EnsureCanWrite();
    protected virtual void Dispose(bool disposing);
    public virtual bool get_CanRead();
    public virtual bool get_CanWrite();
    public virtual bool get_CanSeek();
    public virtual long get_Length();
    public virtual long get_Position();
    public virtual void set_Position(long value);
    public virtual long Seek(long offset, SeekOrigin origin);
    public virtual void SetLength(long value);
    private IAsyncResult BeginRead(Byte[] buffer, int offset, int count, AsyncCallback callback, object state, bool usedByBlockingWrapper);
    public virtual int EndRead(IAsyncResult asyncResult);
    public virtual Task`1<int> ReadAsync(Byte[] buffer, int offset, int count, CancellationToken cancellationToken);
    public virtual int Read(Byte[] buffer, int offset, int count);
    public virtual int ReadByte();
    public virtual IAsyncResult BeginWrite(Byte[] buffer, int offset, int count, AsyncCallback callback, object state);
    private IAsyncResult BeginWrite(Byte[] buffer, int offset, int count, AsyncCallback callback, object state, bool usedByBlockingWrapper);
    public virtual void EndWrite(IAsyncResult asyncResult);
    public virtual Task WriteAsync(Byte[] buffer, int offset, int count, CancellationToken cancellationToken);
    public virtual void Write(Byte[] buffer, int offset, int count);
    public virtual void WriteByte(byte value);
    public virtual void Flush();
    public virtual Task FlushAsync(CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("System.IO.WinRtToNetFxStreamAdapter/<ReadAsyncInternal>d__43")]
private Task`1<int> ReadAsyncInternal(Byte[] buffer, int offset, int count, CancellationToken cancellationToken);
}
internal static class System.Resources.UriUtility : object {
    public static string UriEncode(string str);
    private static char IntToHex(int n);
    private static bool IsUriUnreservedChar(char ch);
}
[FriendAccessAllowedAttribute]
internal class System.Resources.WindowsRuntimeResourceManager : WindowsRuntimeResourceManagerBase {
    private ResourceMap _resourceMap;
    private ResourceContext _clonedResourceContext;
    private string _clonedResourceContextFallBackList;
    private static Char[] s_charCultureSeparator;
    private static PackageInfo s_currentPackageInfo;
    private static List`1<PackageInfo> s_dependentPackageInfoList;
    private static ResourceContext s_globalResourceContext;
    private static String modreq(System.Runtime.CompilerServices.IsVolatile) s_globalResourceContextFallBackList;
    private static CultureInfo modreq(System.Runtime.CompilerServices.IsVolatile) s_globalResourceContextBestFitCultureInfo;
    private static ResourceManager modreq(System.Runtime.CompilerServices.IsVolatile) s_globalResourceManager;
    private static object s_objectForLock;
    public CultureInfo GlobalResourceContextBestFitCultureInfo { get; }
    private static WindowsRuntimeResourceManager();
    private static bool InitializeStatics();
    private static void InitializeStaticGlobalResourceContext(ResourceManager resourceManager);
    private static CultureInfo GetBestFitCultureFromLanguageList(List`1<string> languages);
    private static void InitializeStaticsForDependentPackages();
    private static void GlobalResourceContextChanged(object sender, IMapChangedEventArgs`1<string> e);
    private static bool LibpathMatchesPackagepath(string libpath, string packagepath);
    private static bool LibpathContainsPackagename(string libpath, string packagename);
    private static string FindPackageSimpleNameForFilename(string libpath);
    public virtual bool Initialize(string libpath, string reswFilename, PRIExceptionInfo& exceptionInfo);
    private static IReadOnlyList`1<string> StringToReadOnlyList(string s);
    private static string ReadOnlyListToString(IReadOnlyList`1<string> list);
    public virtual CultureInfo get_GlobalResourceContextBestFitCultureInfo();
    public virtual bool SetGlobalResourceContextDefaultCulture(CultureInfo ci);
    public virtual string GetString(string stringName, string startingCulture, string neutralResourcesCulture);
}
internal static class System.Runtime.InteropServices.HResults : object {
    internal static int S_OK;
    internal static int E_BOUNDS;
    internal static int E_ILLEGAL_STATE_CHANGE;
    internal static int E_ILLEGAL_METHOD_CALL;
    internal static int RO_E_CLOSED;
    internal static int E_ILLEGAL_DELEGATE_ASSIGNMENT;
    internal static int E_NOTIMPL;
    internal static int E_FAIL;
    internal static int E_INVALIDARG;
}
[GuidAttribute("94ea2b94-e9cc-49e0-c0ff-ee64ca8f5b90")]
[InterfaceTypeAttribute("1")]
internal interface System.Runtime.InteropServices.IAgileObject {
}
[GuidAttribute("00000003-0000-0000-c000-000000000046")]
[InterfaceTypeAttribute("1")]
internal interface System.Runtime.InteropServices.IMarshal {
    public abstract virtual void GetUnmarshalClass(Guid& riid, IntPtr pv, UInt32 dwDestContext, IntPtr pvDestContext, UInt32 mshlFlags, Guid& pCid);
    public abstract virtual void GetMarshalSizeMax(Guid& riid, IntPtr pv, UInt32 dwDestContext, IntPtr pvDestContext, UInt32 mshlflags, UInt32& pSize);
    public abstract virtual void MarshalInterface(IntPtr pStm, Guid& riid, IntPtr pv, UInt32 dwDestContext, IntPtr pvDestContext, UInt32 mshlflags);
    public abstract virtual void UnmarshalInterface(IntPtr pStm, Guid& riid, IntPtr& ppv);
    public abstract virtual void ReleaseMarshalData(IntPtr pStm);
    public abstract virtual void DisconnectObject(UInt32 dwReserved);
}
[CLSCompliantAttribute("False")]
public static class System.Runtime.InteropServices.WindowsRuntime.AsyncInfo : object {
    public static IAsyncAction Run(Func`2<CancellationToken, Task> taskProvider);
    public static IAsyncActionWithProgress`1<TProgress> Run(Func`3<CancellationToken, IProgress`1<TProgress>, Task> taskProvider);
    public static IAsyncOperation`1<TResult> Run(Func`2<CancellationToken, Task`1<TResult>> taskProvider);
    public static IAsyncOperationWithProgress`2<TResult, TProgress> Run(Func`3<CancellationToken, IProgress`1<TProgress>, Task`1<TResult>> taskProvider);
    internal static IAsyncAction CreateCompletedAction();
    internal static IAsyncActionWithProgress`1<TProgress> CreateCompletedAction();
    internal static IAsyncOperation`1<TResult> CreateCompletedOperation(TResult synchronousResult);
    internal static IAsyncOperationWithProgress`2<TResult, TProgress> CreateCompletedOperation(TResult synchronousResult);
    internal static IAsyncAction CreateFaultedAction(Exception error);
    internal static IAsyncActionWithProgress`1<TProgress> CreateFaultedAction(Exception error);
    internal static IAsyncOperation`1<TResult> CreateFaultedOperation(Exception error);
    internal static IAsyncOperationWithProgress`2<TResult, TProgress> CreateFaultedOperation(Exception error);
}
[GuidAttribute("905a0fef-bc53-11df-8c49-001e4fc686da")]
[InterfaceTypeAttribute("1")]
internal interface System.Runtime.InteropServices.WindowsRuntime.IBufferByteAccess {
    public abstract virtual IntPtr GetBuffer();
}
[GuidAttribute("e5af3542-ca67-4081-995b-709dd13792df")]
internal interface System.Runtime.InteropServices.WindowsRuntime.ICommand_WinRT {
    public abstract virtual EventRegistrationToken add_CanExecuteChanged(EventHandler`1<object> value);
    public abstract virtual void remove_CanExecuteChanged(EventRegistrationToken token);
    public abstract virtual bool CanExecute(object parameter);
    public abstract virtual void Execute(object parameter);
}
internal static class System.Runtime.InteropServices.WindowsRuntime.ICommandAdapterHelpers : object {
    internal static EventHandler`1<object> CreateWrapperHandler(EventHandler handler);
    internal static EventHandler CreateWrapperHandler(EventHandler`1<object> handler);
    internal static EventHandler`1<object> GetValueFromEquivalentKey(ConditionalWeakTable`2<EventHandler, EventHandler`1<object>> table, EventHandler key, CreateValueCallback<EventHandler, EventHandler`1<object>> callback);
}
internal class System.Runtime.InteropServices.WindowsRuntime.ICommandToManagedAdapter : object {
    private static ConditionalWeakTable`2<EventHandler, EventHandler`1<object>> s_weakTable;
    private static ICommandToManagedAdapter();
    private void add_CanExecuteChanged(EventHandler value);
    private void remove_CanExecuteChanged(EventHandler value);
    private bool CanExecute(object parameter);
    private void Execute(object parameter);
}
internal class System.Runtime.InteropServices.WindowsRuntime.ICommandToWinRTAdapter : object {
    private static ConditionalWeakTable`2<ICommand, EventRegistrationTokenTable`1<EventHandler>> s_weakTable;
    private static ICommandToWinRTAdapter();
    private EventRegistrationToken add_CanExecuteChanged(EventHandler`1<object> value);
    private void remove_CanExecuteChanged(EventRegistrationToken token);
    private bool CanExecute(object parameter);
    private void Execute(object parameter);
}
[GuidAttribute("28b167d5-1a31-465b-9b25-d5c3ae686c40")]
internal interface System.Runtime.InteropServices.WindowsRuntime.INotifyCollectionChanged_WinRT {
    public abstract virtual EventRegistrationToken add_CollectionChanged(NotifyCollectionChangedEventHandler value);
    public abstract virtual void remove_CollectionChanged(EventRegistrationToken token);
}
[GuidAttribute("4cf68d33-e3f2-4964-b85e-945b4f7e2f21")]
internal interface System.Runtime.InteropServices.WindowsRuntime.INotifyCollectionChangedEventArgs {
    public NotifyCollectionChangedAction Action { get; }
    public IList NewItems { get; }
    public IList OldItems { get; }
    public int NewStartingIndex { get; }
    public int OldStartingIndex { get; }
    public abstract virtual NotifyCollectionChangedAction get_Action();
    public abstract virtual IList get_NewItems();
    public abstract virtual IList get_OldItems();
    public abstract virtual int get_NewStartingIndex();
    public abstract virtual int get_OldStartingIndex();
}
[GuidAttribute("cf75d69c-f2f4-486b-b302-bb4c09baebfa")]
internal interface System.Runtime.InteropServices.WindowsRuntime.INotifyPropertyChanged_WinRT {
    public abstract virtual EventRegistrationToken add_PropertyChanged(PropertyChangedEventHandler value);
    public abstract virtual void remove_PropertyChanged(EventRegistrationToken token);
}
[GuidAttribute("4f33a9a0-5cf4-47a4-b16f-d7faaf17457e")]
internal interface System.Runtime.InteropServices.WindowsRuntime.IPropertyChangedEventArgs {
    public string PropertyName { get; }
    public abstract virtual string get_PropertyName();
}
internal static class System.Runtime.InteropServices.WindowsRuntime.NotifyCollectionChangedEventArgsMarshaler : object {
    internal static IntPtr ConvertToNative(NotifyCollectionChangedEventArgs managedArgs);
    internal static NotifyCollectionChangedEventArgs ConvertToManaged(IntPtr nativeArgsIP);
    internal static NotifyCollectionChangedEventArgs CreateNotifyCollectionChangedEventArgs(NotifyCollectionChangedAction action, IList newItems, IList oldItems, int newStartingIndex, int oldStartingIndex);
}
[GuidAttribute("ca10b37c-f382-4591-8557-5e24965279b0")]
internal class System.Runtime.InteropServices.WindowsRuntime.NotifyCollectionChangedEventHandler_WinRT : MulticastDelegate {
    public NotifyCollectionChangedEventHandler_WinRT(object object, IntPtr method);
    public virtual void Invoke(object sender, NotifyCollectionChangedEventArgs e);
    public virtual IAsyncResult BeginInvoke(object sender, NotifyCollectionChangedEventArgs e, AsyncCallback callback, object object);
    public virtual void EndInvoke(IAsyncResult result);
}
internal class System.Runtime.InteropServices.WindowsRuntime.NotifyCollectionChangedToManagedAdapter : object {
    internal void add_CollectionChanged(NotifyCollectionChangedEventHandler value);
    internal void remove_CollectionChanged(NotifyCollectionChangedEventHandler value);
}
internal class System.Runtime.InteropServices.WindowsRuntime.NotifyCollectionChangedToWinRTAdapter : object {
    private static ConditionalWeakTable`2<INotifyCollectionChanged, EventRegistrationTokenTable`1<NotifyCollectionChangedEventHandler>> s_weakTable;
    private static NotifyCollectionChangedToWinRTAdapter();
    internal EventRegistrationToken add_CollectionChanged(NotifyCollectionChangedEventHandler value);
    internal void remove_CollectionChanged(EventRegistrationToken token);
}
internal class System.Runtime.InteropServices.WindowsRuntime.NotifyPropertyChangedToManagedAdapter : object {
    internal void add_PropertyChanged(PropertyChangedEventHandler value);
    internal void remove_PropertyChanged(PropertyChangedEventHandler value);
}
internal class System.Runtime.InteropServices.WindowsRuntime.NotifyPropertyChangedToWinRTAdapter : object {
    private static ConditionalWeakTable`2<INotifyPropertyChanged, EventRegistrationTokenTable`1<PropertyChangedEventHandler>> s_weakTable;
    private static NotifyPropertyChangedToWinRTAdapter();
    internal EventRegistrationToken add_PropertyChanged(PropertyChangedEventHandler value);
    internal void remove_PropertyChanged(EventRegistrationToken token);
}
internal static class System.Runtime.InteropServices.WindowsRuntime.PropertyChangedEventArgsMarshaler : object {
    internal static IntPtr ConvertToNative(PropertyChangedEventArgs managedArgs);
    internal static PropertyChangedEventArgs ConvertToManaged(IntPtr nativeArgsIP);
}
[GuidAttribute("50f19c16-0a22-4d8e-a089-1ea9951657d2")]
internal class System.Runtime.InteropServices.WindowsRuntime.PropertyChangedEventHandler_WinRT : MulticastDelegate {
    public PropertyChangedEventHandler_WinRT(object object, IntPtr method);
    public virtual void Invoke(object sender, PropertyChangedEventArgs e);
    public virtual IAsyncResult BeginInvoke(object sender, PropertyChangedEventArgs e, AsyncCallback callback, object object);
    public virtual void EndInvoke(IAsyncResult result);
}
internal static class System.Runtime.InteropServices.WindowsRuntime.RestrictedErrorInfoHelper : object {
    internal static Exception AttachRestrictedErrorInfo(Exception e);
}
public class System.Runtime.InteropServices.WindowsRuntime.WindowsRuntimeBuffer : object {
    private static string WinTypesDLL;
    [ThreadStaticAttribute]
private static IMarshal s_winRtMarshalProxy;
    private Byte[] _data;
    private int _dataStartOffs;
    private int _usefulDataLength;
    private int _maxDataCapacity;
    private GCHandle _pinHandle;
    private IntPtr _dataPtr;
    private UInt32 Windows.Storage.Streams.IBuffer.Capacity { get; }
    private UInt32 Windows.Storage.Streams.IBuffer.Length { get; private set; }
    internal WindowsRuntimeBuffer(int capacity);
    internal WindowsRuntimeBuffer(Byte[] data, int offset, int length, int capacity);
    private static WindowsRuntimeBuffer();
    [CLSCompliantAttribute("False")]
public static IBuffer Create(int capacity);
    [CLSCompliantAttribute("False")]
public static IBuffer Create(Byte[] data, int offset, int length, int capacity);
    private static void EnsureHasMarshalProxy();
    internal void GetUnderlyingData(Byte[]& underlyingDataArray, Int32& underlyingDataArrayStartOffset);
    private Byte* PinUnderlyingData();
    protected virtual override void Finalize();
    private sealed virtual override UInt32 Windows.Storage.Streams.IBuffer.get_Capacity();
    private sealed virtual override UInt32 Windows.Storage.Streams.IBuffer.get_Length();
    private sealed virtual override void Windows.Storage.Streams.IBuffer.put_Length(UInt32 value);
    private sealed virtual override IntPtr System.Runtime.InteropServices.WindowsRuntime.IBufferByteAccess.GetBuffer();
    private sealed virtual override void System.Runtime.InteropServices.IMarshal.DisconnectObject(UInt32 dwReserved);
    private sealed virtual override void System.Runtime.InteropServices.IMarshal.GetMarshalSizeMax(Guid& riid, IntPtr pv, UInt32 dwDestContext, IntPtr pvDestContext, UInt32 mshlflags, UInt32& pSize);
    private sealed virtual override void System.Runtime.InteropServices.IMarshal.GetUnmarshalClass(Guid& riid, IntPtr pv, UInt32 dwDestContext, IntPtr pvDestContext, UInt32 mshlFlags, Guid& pCid);
    private sealed virtual override void System.Runtime.InteropServices.IMarshal.MarshalInterface(IntPtr pStm, Guid& riid, IntPtr pv, UInt32 dwDestContext, IntPtr pvDestContext, UInt32 mshlflags);
    private sealed virtual override void System.Runtime.InteropServices.IMarshal.ReleaseMarshalData(IntPtr pStm);
    private sealed virtual override void System.Runtime.InteropServices.IMarshal.UnmarshalInterface(IntPtr pStm, Guid& riid, IntPtr& ppv);
}
[ExtensionAttribute]
public static class System.Runtime.InteropServices.WindowsRuntime.WindowsRuntimeBufferExtensions : object {
    [ExtensionAttribute]
[CLSCompliantAttribute("False")]
public static IBuffer AsBuffer(Byte[] source);
    [ExtensionAttribute]
[CLSCompliantAttribute("False")]
public static IBuffer AsBuffer(Byte[] source, int offset, int length);
    [ExtensionAttribute]
[CLSCompliantAttribute("False")]
public static IBuffer AsBuffer(Byte[] source, int offset, int length, int capacity);
    [ExtensionAttribute]
[CLSCompliantAttribute("False")]
public static void CopyTo(Byte[] source, IBuffer destination);
    [ExtensionAttribute]
[CLSCompliantAttribute("False")]
public static void CopyTo(Byte[] source, int sourceIndex, IBuffer destination, UInt32 destinationIndex, int count);
    [ExtensionAttribute]
[CLSCompliantAttribute("False")]
public static Byte[] ToArray(IBuffer source);
    [ExtensionAttribute]
[CLSCompliantAttribute("False")]
public static Byte[] ToArray(IBuffer source, UInt32 sourceIndex, int count);
    [ExtensionAttribute]
[CLSCompliantAttribute("False")]
public static void CopyTo(IBuffer source, Byte[] destination);
    [ExtensionAttribute]
[CLSCompliantAttribute("False")]
public static void CopyTo(IBuffer source, UInt32 sourceIndex, Byte[] destination, int destinationIndex, int count);
    [ExtensionAttribute]
[CLSCompliantAttribute("False")]
public static void CopyTo(IBuffer source, IBuffer destination);
    [ExtensionAttribute]
[CLSCompliantAttribute("False")]
public static void CopyTo(IBuffer source, UInt32 sourceIndex, IBuffer destination, UInt32 destinationIndex, UInt32 count);
    [ExtensionAttribute]
internal static bool TryGetUnderlyingData(IBuffer buffer, Byte[]& underlyingDataArray, Int32& underlyingDataArrayStartOffset);
    [ExtensionAttribute]
[CLSCompliantAttribute("False")]
public static bool IsSameData(IBuffer buffer, IBuffer otherBuffer);
    [ExtensionAttribute]
[CLSCompliantAttribute("False")]
public static IBuffer GetWindowsRuntimeBuffer(MemoryStream underlyingStream);
    [ExtensionAttribute]
[CLSCompliantAttribute("False")]
public static IBuffer GetWindowsRuntimeBuffer(MemoryStream underlyingStream, int positionInStream, int length);
    [ExtensionAttribute]
[CLSCompliantAttribute("False")]
public static Stream AsStream(IBuffer source);
    [ExtensionAttribute]
[CLSCompliantAttribute("False")]
public static byte GetByte(IBuffer source, UInt32 byteOffset);
    [ExtensionAttribute]
private static IntPtr GetPointerAtOffset(IBuffer buffer, UInt32 offset);
    private static void MemCopy(IntPtr src, IntPtr dst, UInt32 count);
}
[ExtensionAttribute]
internal static class System.Runtime.WindowsRuntime.Internal.__Error : object {
    internal static void StreamIsClosed();
    internal static void SeekNotSupported();
    internal static void ReadNotSupported();
    internal static void WriteNotSupported();
    [ExtensionAttribute]
internal static void SetErrorCode(Exception ex, int code);
    [ExtensionAttribute]
internal static void TryDeregister(CancellationTokenRegistration ctr);
}
internal class System.Runtime.WindowsRuntime.Internal.Helpers : object {
    internal static void ZeroMemory(Byte* src, long len);
}
internal static class System.SR : object {
    private static ResourceManager s_resourceManager;
    private static string s_resourcesName;
    private static ResourceManager ResourceManager { get; }
    internal static string Argument_BufferIndexExceedsCapacity { get; }
    internal static string Argument_BufferLengthExceedsCapacity { get; }
    internal static string Argument_IndexOutOfArrayBounds { get; }
    internal static string Argument_InstancesImplementingIRASThatCanReadMustImplementIIS { get; }
    internal static string Argument_InstancesImplementingIRASThatCanWriteMustImplementIOS { get; }
    internal static string Argument_InsufficientArrayElementsAfterOffset { get; }
    internal static string Argument_InsufficientBufferCapacity { get; }
    internal static string Argument_InsufficientSpaceInSourceBuffer { get; }
    internal static string Argument_InsufficientSpaceInTargetBuffer { get; }
    internal static string Argument_NotSufficientCapabilitiesToConvertToWinRtStream { get; }
    internal static string Argument_ObjectMustBeWinRtStreamToConvertToNetFxStream { get; }
    internal static string Argument_RelativePathMayNotBeWhitespaceOnly { get; }
    internal static string Argument_StreamPositionBeyondEOS { get; }
    internal static string Argument_UnexpectedAsyncResult { get; }
    internal static string Argument_WinRtStreamCannotReadOrWrite { get; }
    internal static string ArgumentOutOfRange_CannotResizeStreamToNegative { get; }
    internal static string ArgumentOutOfRange_IO_CannotSeekToNegativePosition { get; }
    internal static string ArgumentOutOfRange_InvalidInputStreamOptionsEnumValue { get; }
    internal static string ArgumentOutOfRange_WinRtAdapterBufferSizeMayNotBeNegative { get; }
    internal static string InvalidOperation_CannotCallThisMethodInCurrentState { get; }
    internal static string InvalidOperation_CannotChangeBufferSizeOfWinRtStreamAdapter { get; }
    internal static string InvalidOperation_CannotChangeBufferSizeOfWinRtStreamAdapterToZero { get; }
    internal static string InvalidOperation_CannotGetResultsFromIncompleteOperation { get; }
    internal static string InvalidOperation_CannotSetCompletionHanlderMoreThanOnce { get; }
    internal static string InvalidOperation_CannotSetStreamSizeCannotWrite { get; }
    internal static string InvalidOperation_IllegalStateChange { get; }
    internal static string InvalidOperation_InvalidAsyncCompletion { get; }
    internal static string InvalidOperation_MultipleIOCompletionCallbackInvocation { get; }
    internal static string InvalidOperation_TaskProviderReturnedUnstartedTask { get; }
    internal static string InvalidOperation_UnexpectedAsyncOperationID { get; }
    internal static string InvalidOperation_UnstartedTaskSpecified { get; }
    internal static string IO_CannotSeekBeyondInt64MaxValue { get; }
    internal static string IO_CannotSetSizeBeyondInt64MaxValue { get; }
    internal static string IO_General { get; }
    internal static string IO_UnderlyingWinRTStreamTooLong_CannotUseLengthOrPosition { get; }
    internal static string NotImplemented_NativeRoutineNotFound { get; }
    internal static string NotSupported_CannotConvertNotReadableToInputStream { get; }
    internal static string NotSupported_CannotConvertNotSeekableToRandomAccessStream { get; }
    internal static string NotSupported_CannotConvertNotWritableToOutputStream { get; }
    internal static string NotSupported_CannotReadFromStream { get; }
    internal static string NotSupported_CannotSeekInStream { get; }
    internal static string NotSupported_CannotUseLength_StreamNotSeekable { get; }
    internal static string NotSupported_CannotUsePosition_StreamNotSeekable { get; }
    internal static string NotSupported_CannotWriteToStream { get; }
    internal static string NotSupported_CloningNotSupported { get; }
    internal static string NullReference_IOCompletionCallbackCannotProcessNullAsyncInfo { get; }
    internal static string NullReference_TaskProviderReturnedNull { get; }
    internal static string ObjectDisposed_AsyncInfoIsClosed { get; }
    internal static string ObjectDisposed_CannotPerformOperation { get; }
    internal static string WinRtCOM_Error { get; }
    internal static string ArgumentOutOfRange_MustBePositive { get; }
    internal static string ObjectDisposed_StreamClosed { get; }
    internal static string NotSupported_UnseekableStream { get; }
    internal static string NotSupported_UnreadableStream { get; }
    internal static string NotSupported_UnwritableStream { get; }
    internal static string ArgumentNull_Buffer { get; }
    internal static string ArgumentOutOfRange_NegFileSize { get; }
    internal static string NotSupported_CannotWriteToBufferedStreamIfReadBufferCannotBeFlushed { get; }
    internal static string Argument_InvalidSafeBufferOffLen { get; }
    internal static string InvalidOperation_CalledTwice { get; }
    internal static string ArgumentOutOfRange_LengthGreaterThanCapacity { get; }
    internal static string ArgumentOutOfRange_UnmanagedMemStreamWrapAround { get; }
    internal static string ArgumentOutOfRange_Enum { get; }
    internal static string NotSupported_UmsSafeBuffer { get; }
    internal static string IndexOutOfRange_UMSPosition { get; }
    internal static string ArgumentOutOfRange_UnmanagedMemStreamLength { get; }
    internal static string IO_SeekBeforeBegin { get; }
    internal static string Argument_InvalidSeekOrigin { get; }
    internal static string IO_FixedCapacity { get; }
    internal static string IO_StreamTooLong { get; }
    internal static string Arg_BufferTooSmall { get; }
    internal static string ArgumentOutOfRange_NeedNonNegNum { get; }
    internal static string Argument_InvalidOffLen { get; }
    internal static string ArgumentOutOfRange_StreamLength { get; }
    internal static string DirectUI_Empty { get; }
    internal static string InvalidOperation_SendNotSupportedOnWindowsRTSynchronizationContext { get; }
    internal static string UnauthorizedAccess_InternalBuffer { get; }
    internal static Type ResourceType { get; }
    private static ResourceManager get_ResourceManager();
    private static bool UsingResourceKeys();
    internal static string GetResourceString(string resourceKey, string defaultString);
    internal static string Format(string resourceFormat, Object[] args);
    internal static string Format(string resourceFormat, object p1);
    internal static string Format(string resourceFormat, object p1, object p2);
    internal static string Format(string resourceFormat, object p1, object p2, object p3);
    internal static string get_Argument_BufferIndexExceedsCapacity();
    internal static string get_Argument_BufferLengthExceedsCapacity();
    internal static string get_Argument_IndexOutOfArrayBounds();
    internal static string get_Argument_InstancesImplementingIRASThatCanReadMustImplementIIS();
    internal static string get_Argument_InstancesImplementingIRASThatCanWriteMustImplementIOS();
    internal static string get_Argument_InsufficientArrayElementsAfterOffset();
    internal static string get_Argument_InsufficientBufferCapacity();
    internal static string get_Argument_InsufficientSpaceInSourceBuffer();
    internal static string get_Argument_InsufficientSpaceInTargetBuffer();
    internal static string get_Argument_NotSufficientCapabilitiesToConvertToWinRtStream();
    internal static string get_Argument_ObjectMustBeWinRtStreamToConvertToNetFxStream();
    internal static string get_Argument_RelativePathMayNotBeWhitespaceOnly();
    internal static string get_Argument_StreamPositionBeyondEOS();
    internal static string get_Argument_UnexpectedAsyncResult();
    internal static string get_Argument_WinRtStreamCannotReadOrWrite();
    internal static string get_ArgumentOutOfRange_CannotResizeStreamToNegative();
    internal static string get_ArgumentOutOfRange_IO_CannotSeekToNegativePosition();
    internal static string get_ArgumentOutOfRange_InvalidInputStreamOptionsEnumValue();
    internal static string get_ArgumentOutOfRange_WinRtAdapterBufferSizeMayNotBeNegative();
    internal static string get_InvalidOperation_CannotCallThisMethodInCurrentState();
    internal static string get_InvalidOperation_CannotChangeBufferSizeOfWinRtStreamAdapter();
    internal static string get_InvalidOperation_CannotChangeBufferSizeOfWinRtStreamAdapterToZero();
    internal static string get_InvalidOperation_CannotGetResultsFromIncompleteOperation();
    internal static string get_InvalidOperation_CannotSetCompletionHanlderMoreThanOnce();
    internal static string get_InvalidOperation_CannotSetStreamSizeCannotWrite();
    internal static string get_InvalidOperation_IllegalStateChange();
    internal static string get_InvalidOperation_InvalidAsyncCompletion();
    internal static string get_InvalidOperation_MultipleIOCompletionCallbackInvocation();
    internal static string get_InvalidOperation_TaskProviderReturnedUnstartedTask();
    internal static string get_InvalidOperation_UnexpectedAsyncOperationID();
    internal static string get_InvalidOperation_UnstartedTaskSpecified();
    internal static string get_IO_CannotSeekBeyondInt64MaxValue();
    internal static string get_IO_CannotSetSizeBeyondInt64MaxValue();
    internal static string get_IO_General();
    internal static string get_IO_UnderlyingWinRTStreamTooLong_CannotUseLengthOrPosition();
    internal static string get_NotImplemented_NativeRoutineNotFound();
    internal static string get_NotSupported_CannotConvertNotReadableToInputStream();
    internal static string get_NotSupported_CannotConvertNotSeekableToRandomAccessStream();
    internal static string get_NotSupported_CannotConvertNotWritableToOutputStream();
    internal static string get_NotSupported_CannotReadFromStream();
    internal static string get_NotSupported_CannotSeekInStream();
    internal static string get_NotSupported_CannotUseLength_StreamNotSeekable();
    internal static string get_NotSupported_CannotUsePosition_StreamNotSeekable();
    internal static string get_NotSupported_CannotWriteToStream();
    internal static string get_NotSupported_CloningNotSupported();
    internal static string get_NullReference_IOCompletionCallbackCannotProcessNullAsyncInfo();
    internal static string get_NullReference_TaskProviderReturnedNull();
    internal static string get_ObjectDisposed_AsyncInfoIsClosed();
    internal static string get_ObjectDisposed_CannotPerformOperation();
    internal static string get_WinRtCOM_Error();
    internal static string get_ArgumentOutOfRange_MustBePositive();
    internal static string get_ObjectDisposed_StreamClosed();
    internal static string get_NotSupported_UnseekableStream();
    internal static string get_NotSupported_UnreadableStream();
    internal static string get_NotSupported_UnwritableStream();
    internal static string get_ArgumentNull_Buffer();
    internal static string get_ArgumentOutOfRange_NegFileSize();
    internal static string get_NotSupported_CannotWriteToBufferedStreamIfReadBufferCannotBeFlushed();
    internal static string get_Argument_InvalidSafeBufferOffLen();
    internal static string get_InvalidOperation_CalledTwice();
    internal static string get_ArgumentOutOfRange_LengthGreaterThanCapacity();
    internal static string get_ArgumentOutOfRange_UnmanagedMemStreamWrapAround();
    internal static string get_ArgumentOutOfRange_Enum();
    internal static string get_NotSupported_UmsSafeBuffer();
    internal static string get_IndexOutOfRange_UMSPosition();
    internal static string get_ArgumentOutOfRange_UnmanagedMemStreamLength();
    internal static string get_IO_SeekBeforeBegin();
    internal static string get_Argument_InvalidSeekOrigin();
    internal static string get_IO_FixedCapacity();
    internal static string get_IO_StreamTooLong();
    internal static string get_Arg_BufferTooSmall();
    internal static string get_ArgumentOutOfRange_NeedNonNegNum();
    internal static string get_Argument_InvalidOffLen();
    internal static string get_ArgumentOutOfRange_StreamLength();
    internal static string get_DirectUI_Empty();
    internal static string get_InvalidOperation_SendNotSupportedOnWindowsRTSynchronizationContext();
    internal static string get_UnauthorizedAccess_InternalBuffer();
    internal static Type get_ResourceType();
}
internal static class System.Threading.Tasks.AsyncInfoIdGenerator : object {
    internal static UInt32 InvalidId;
    private static Random s_idGenerator;
    private static AsyncInfoIdGenerator();
    internal static UInt32 CreateNext();
    internal static UInt32 EnsureInitializedThreadsafe(UInt32& id);
}
internal class System.Threading.Tasks.AsyncInfoToTaskBridge`2 : TaskCompletionSource`1<TResult> {
    private CancellationToken _ct;
    private CancellationTokenRegistration _ctr;
    private bool _completing;
    private object StateLock { get; }
    internal AsyncInfoToTaskBridge`2(CancellationToken cancellationToken);
    private object get_StateLock();
    internal void RegisterForCancellation(IAsyncInfo asyncInfo);
    internal void CompleteFromAsyncAction(IAsyncAction asyncInfo, AsyncStatus asyncStatus);
    internal void CompleteFromAsyncActionWithProgress(IAsyncActionWithProgress`1<TProgress> asyncInfo, AsyncStatus asyncStatus);
    internal void CompleteFromAsyncOperation(IAsyncOperation`1<TResult> asyncInfo, AsyncStatus asyncStatus);
    internal void CompleteFromAsyncOperationWithProgress(IAsyncOperationWithProgress`2<TResult, TProgress> asyncInfo, AsyncStatus asyncStatus);
    private void Complete(IAsyncInfo asyncInfo, Func`2<IAsyncInfo, TResult> getResultsFunction, AsyncStatus asyncStatus);
}
internal static class System.Threading.Tasks.ExceptionDispatchHelper : object {
    internal static void ThrowAsync(Exception exception, SynchronizationContext targetContext);
}
internal class System.Threading.Tasks.TaskToAsyncActionAdapter : TaskToAsyncInfoAdapter`4<AsyncActionCompletedHandler, VoidReferenceTypeParameter, VoidValueTypeParameter, VoidValueTypeParameter> {
    internal TaskToAsyncActionAdapter(Delegate taskGenerator);
    internal TaskToAsyncActionAdapter(Task underlyingTask, CancellationTokenSource underlyingCancelTokenSource);
    internal TaskToAsyncActionAdapter(bool isCanceled);
    public virtual void GetResults();
    internal virtual void OnCompleted(AsyncActionCompletedHandler userCompletionHandler, AsyncStatus asyncStatus);
    private sealed virtual override void Windows.Foundation.IAsyncAction.put_Completed(AsyncActionCompletedHandler handler);
}
internal class System.Threading.Tasks.TaskToAsyncActionWithProgressAdapter`1 : TaskToAsyncInfoAdapter`4<AsyncActionWithProgressCompletedHandler`1<TProgress>, AsyncActionProgressHandler`1<TProgress>, VoidValueTypeParameter, TProgress> {
    internal TaskToAsyncActionWithProgressAdapter`1(Delegate taskGenerator);
    internal TaskToAsyncActionWithProgressAdapter`1(bool isCanceled);
    public virtual void GetResults();
    internal virtual void OnCompleted(AsyncActionWithProgressCompletedHandler`1<TProgress> userCompletionHandler, AsyncStatus asyncStatus);
    internal virtual void OnProgress(AsyncActionProgressHandler`1<TProgress> userProgressHandler, TProgress progressInfo);
    private sealed virtual override void Windows.Foundation.IAsyncActionWithProgress<TProgress>.put_Progress(AsyncActionProgressHandler`1<TProgress> handler);
    private sealed virtual override void Windows.Foundation.IAsyncActionWithProgress<TProgress>.put_Completed(AsyncActionWithProgressCompletedHandler`1<TProgress> handler);
}
internal class System.Threading.Tasks.TaskToAsyncInfoAdapter`4 : object {
    private static int STATE_NOT_INITIALIZED;
    private static int STATE_STARTED;
    private static int STATE_RUN_TO_COMPLETION;
    private static int STATE_CANCELLATION_REQUESTED;
    private static int STATE_CANCELLATION_COMPLETED;
    private static int STATE_ERROR;
    private static int STATE_CLOSED;
    private static int STATEFLAG_COMPLETED_SYNCHRONOUSLY;
    private static int STATEFLAG_MUST_RUN_COMPLETION_HNDL_WHEN_SET;
    private static int STATEFLAG_COMPLETION_HNDL_NOT_YET_INVOKED;
    private static int STATEMASK_SELECT_ANY_ASYNC_STATE;
    private static int STATEMASK_CLEAR_ALL_ASYNC_STATES;
    private CancellationTokenSource _cancelTokenSource;
    private UInt32 _id;
    private Exception _error;
    private Int32 modreq(System.Runtime.CompilerServices.IsVolatile) _state;
    private object _dataContainer;
    private TCompletedHandler _completedHandler;
    private TProgressHandler _progressHandler;
    private SynchronizationContext _startingContext;
    internal bool CompletedSynchronously { get; }
    private bool IsInStartedState { get; }
    private bool IsInRunToCompletionState { get; }
    private bool IsInErrorState { get; }
    private bool IsInClosedState { get; }
    private bool IsInRunningState { get; }
    private bool IsInTerminalState { get; }
    internal Task Task { get; }
    internal CancellationTokenSource CancelTokenSource { get; }
    public TCompletedHandler Completed { get; public set; }
    public TProgressHandler Progress { get; public set; }
    public Exception ErrorCode { get; }
    public UInt32 Id { get; }
    public AsyncStatus Status { get; }
    internal TaskToAsyncInfoAdapter`4(Delegate taskProvider);
    internal TaskToAsyncInfoAdapter`4(Task underlyingTask, CancellationTokenSource underlyingCancelTokenSource, Progress`1<TProgressInfo> underlyingProgressDispatcher);
    internal TaskToAsyncInfoAdapter`4(TResult synchronousResult);
    private static InvalidOperationException CreateCannotGetResultsFromIncompleteOperationException(Exception cause);
    protected virtual override void Finalize();
    internal bool DangerousSetCompleted(TResult synchronousResult);
    internal bool DangerousSetCanceled();
    internal bool DangerousSetError(Exception error);
    internal bool get_CompletedSynchronously();
    private bool get_IsInStartedState();
    private bool get_IsInRunToCompletionState();
    private bool get_IsInErrorState();
    private bool get_IsInClosedState();
    private bool get_IsInRunningState();
    private bool get_IsInTerminalState();
    private bool CheckUniqueAsyncState(int state);
    private SynchronizationContext GetStartingContext();
    internal Task get_Task();
    internal CancellationTokenSource get_CancelTokenSource();
    internal void EnsureNotClosed();
    internal virtual void OnCompleted(TCompletedHandler userCompletionHandler, AsyncStatus asyncStatus);
    internal virtual void OnProgress(TProgressHandler userProgressHandler, TProgressInfo progressInfo);
    private void OnCompletedInvoker(AsyncStatus status);
    private void OnProgressInvokerCrossContext(TProgressHandler handler, TProgressInfo progressInfo);
    private sealed virtual override void System.IProgress<TProgressInfo>.Report(TProgressInfo value);
    private void OnReportChainedProgress(object sender, TProgressInfo progressInfo);
    private int SetAsyncState(int newAsyncState, int conditionBitMask, bool useCondition, Boolean& conditionFailed);
    private int SetState(int newStateSetMask, int newStateIgnoreMask, int conditionBitMask, bool useCondition, Boolean& conditionFailed);
    private int TransitionToTerminalState();
    private void TaskCompleted();
    private AsyncStatus GetStatus(int state);
    internal TResult GetResultsInternal();
    private Task InvokeTaskProvider(Delegate taskProvider);
    private void TransitionToClosed();
    public virtual TCompletedHandler get_Completed();
    public virtual void set_Completed(TCompletedHandler value);
    public virtual TProgressHandler get_Progress();
    public virtual void set_Progress(TProgressHandler value);
    public virtual void Cancel();
    public virtual void Close();
    public virtual Exception get_ErrorCode();
    public virtual UInt32 get_Id();
    public virtual AsyncStatus get_Status();
}
internal class System.Threading.Tasks.TaskToAsyncOperationAdapter`1 : TaskToAsyncInfoAdapter`4<AsyncOperationCompletedHandler`1<TResult>, VoidReferenceTypeParameter, TResult, VoidValueTypeParameter> {
    internal TaskToAsyncOperationAdapter`1(Delegate taskGenerator);
    internal TaskToAsyncOperationAdapter`1(Task underlyingTask, CancellationTokenSource underlyingCancelTokenSource);
    internal TaskToAsyncOperationAdapter`1(TResult synchronousResult);
    public virtual TResult GetResults();
    internal virtual void OnCompleted(AsyncOperationCompletedHandler`1<TResult> userCompletionHandler, AsyncStatus asyncStatus);
    private sealed virtual override void Windows.Foundation.IAsyncOperation<TResult>.put_Completed(AsyncOperationCompletedHandler`1<TResult> handler);
}
internal class System.Threading.Tasks.TaskToAsyncOperationWithProgressAdapter`2 : TaskToAsyncInfoAdapter`4<AsyncOperationWithProgressCompletedHandler`2<TResult, TProgress>, AsyncOperationProgressHandler`2<TResult, TProgress>, TResult, TProgress> {
    internal TaskToAsyncOperationWithProgressAdapter`2(Delegate taskGenerator);
    internal TaskToAsyncOperationWithProgressAdapter`2(TResult synchronousResult);
    public virtual TResult GetResults();
    internal virtual void OnCompleted(AsyncOperationWithProgressCompletedHandler`2<TResult, TProgress> userCompletionHandler, AsyncStatus asyncStatus);
    internal virtual void OnProgress(AsyncOperationProgressHandler`2<TResult, TProgress> userProgressHandler, TProgress progressInfo);
    private sealed virtual override void Windows.Foundation.IAsyncOperationWithProgress<TResult,TProgress>.put_Progress(AsyncOperationProgressHandler`2<TResult, TProgress> handler);
    private sealed virtual override void Windows.Foundation.IAsyncOperationWithProgress<TResult,TProgress>.put_Completed(AsyncOperationWithProgressCompletedHandler`2<TResult, TProgress> handler);
}
internal class System.Threading.WinRTSynchronizationContext : SynchronizationContext {
    private CoreDispatcher _dispatcher;
    internal WinRTSynchronizationContext(CoreDispatcher dispatcher);
    [SecuritySafeCriticalAttribute]
public virtual void Post(SendOrPostCallback d, object state);
    [SecuritySafeCriticalAttribute]
public virtual void Send(SendOrPostCallback d, object state);
    public virtual SynchronizationContext CreateCopy();
}
[FriendAccessAllowedAttribute]
internal class System.Threading.WinRTSynchronizationContextFactory : WinRTSynchronizationContextFactoryBase {
    private static ConditionalWeakTable`2<CoreDispatcher, WinRTSynchronizationContext> s_contextCache;
    private static WinRTSynchronizationContextFactory();
    public virtual SynchronizationContext Create(object dispatcherObj);
}
internal class System.VoidReferenceTypeParameter : object {
}
internal class System.VoidValueTypeParameter : ValueType {
}
[ExtensionAttribute]
[CLSCompliantAttribute("False")]
public static class System.WindowsRuntimeSystemExtensions : object {
    private static void ConcatenateCancelTokens(CancellationToken source, CancellationTokenSource sink, Task concatenationLifetime);
    private static void ConcatenateProgress(IAsyncActionWithProgress`1<TProgress> source, IProgress`1<TProgress> sink);
    private static void ConcatenateProgress(IAsyncOperationWithProgress`2<TResult, TProgress> source, IProgress`1<TProgress> sink);
    [ExtensionAttribute]
[EditorBrowsableAttribute("1")]
public static TaskAwaiter GetAwaiter(IAsyncAction source);
    [ExtensionAttribute]
public static Task AsTask(IAsyncAction source);
    [ExtensionAttribute]
public static Task AsTask(IAsyncAction source, CancellationToken cancellationToken);
    [ExtensionAttribute]
[EditorBrowsableAttribute("1")]
public static TaskAwaiter`1<TResult> GetAwaiter(IAsyncOperation`1<TResult> source);
    [ExtensionAttribute]
public static Task`1<TResult> AsTask(IAsyncOperation`1<TResult> source);
    [ExtensionAttribute]
public static Task`1<TResult> AsTask(IAsyncOperation`1<TResult> source, CancellationToken cancellationToken);
    [ExtensionAttribute]
[EditorBrowsableAttribute("1")]
public static TaskAwaiter GetAwaiter(IAsyncActionWithProgress`1<TProgress> source);
    [ExtensionAttribute]
public static Task AsTask(IAsyncActionWithProgress`1<TProgress> source);
    [ExtensionAttribute]
public static Task AsTask(IAsyncActionWithProgress`1<TProgress> source, CancellationToken cancellationToken);
    [ExtensionAttribute]
public static Task AsTask(IAsyncActionWithProgress`1<TProgress> source, IProgress`1<TProgress> progress);
    [ExtensionAttribute]
public static Task AsTask(IAsyncActionWithProgress`1<TProgress> source, CancellationToken cancellationToken, IProgress`1<TProgress> progress);
    [ExtensionAttribute]
[EditorBrowsableAttribute("1")]
public static TaskAwaiter`1<TResult> GetAwaiter(IAsyncOperationWithProgress`2<TResult, TProgress> source);
    [ExtensionAttribute]
public static Task`1<TResult> AsTask(IAsyncOperationWithProgress`2<TResult, TProgress> source);
    [ExtensionAttribute]
public static Task`1<TResult> AsTask(IAsyncOperationWithProgress`2<TResult, TProgress> source, CancellationToken cancellationToken);
    [ExtensionAttribute]
public static Task`1<TResult> AsTask(IAsyncOperationWithProgress`2<TResult, TProgress> source, IProgress`1<TProgress> progress);
    [ExtensionAttribute]
public static Task`1<TResult> AsTask(IAsyncOperationWithProgress`2<TResult, TProgress> source, CancellationToken cancellationToken, IProgress`1<TProgress> progress);
    [ExtensionAttribute]
public static IAsyncAction AsAsyncAction(Task source);
    [ExtensionAttribute]
public static IAsyncOperation`1<TResult> AsAsyncOperation(Task`1<TResult> source);
    private static void CommonlyUsedGenericInstantiations();
}
public class Windows.Foundation.Point : ValueType {
    internal float _x;
    internal float _y;
    public double X { get; public set; }
    public double Y { get; public set; }
    public Point(double x, double y);
    public double get_X();
    public void set_X(double value);
    public double get_Y();
    public void set_Y(double value);
    public virtual string ToString();
    public string ToString(IFormatProvider provider);
    private sealed virtual override string System.IFormattable.ToString(string format, IFormatProvider provider);
    private string ConvertToString(string format, IFormatProvider provider);
    public static bool op_Equality(Point point1, Point point2);
    public static bool op_Inequality(Point point1, Point point2);
    public virtual bool Equals(object o);
    public bool Equals(Point value);
    public virtual int GetHashCode();
}
public class Windows.Foundation.Rect : ValueType {
    private float _x;
    private float _y;
    private float _width;
    private float _height;
    private static double EmptyX;
    private static double EmptyY;
    private static double EmptyWidth;
    private static double EmptyHeight;
    private static Rect s_empty;
    public double X { get; public set; }
    public double Y { get; public set; }
    public double Width { get; public set; }
    public double Height { get; public set; }
    public double Left { get; }
    public double Top { get; }
    public double Right { get; }
    public double Bottom { get; }
    public static Rect Empty { get; }
    public bool IsEmpty { get; }
    public Rect(double x, double y, double width, double height);
    public Rect(Point point1, Point point2);
    public Rect(Point location, Size size);
    private static Rect();
    internal static Rect Create(double x, double y, double width, double height);
    public double get_X();
    public void set_X(double value);
    public double get_Y();
    public void set_Y(double value);
    public double get_Width();
    public void set_Width(double value);
    public double get_Height();
    public void set_Height(double value);
    public double get_Left();
    public double get_Top();
    public double get_Right();
    public double get_Bottom();
    public static Rect get_Empty();
    public bool get_IsEmpty();
    public bool Contains(Point point);
    public void Intersect(Rect rect);
    public void Union(Rect rect);
    public void Union(Point point);
    private bool ContainsInternal(double x, double y);
    internal bool IntersectsWith(Rect rect);
    private static Rect CreateEmptyRect();
    public virtual string ToString();
    public string ToString(IFormatProvider provider);
    private sealed virtual override string System.IFormattable.ToString(string format, IFormatProvider provider);
    internal string ConvertToString(string format, IFormatProvider provider);
    public bool Equals(Rect value);
    public static bool op_Equality(Rect rect1, Rect rect2);
    public static bool op_Inequality(Rect rect1, Rect rect2);
    public virtual bool Equals(object o);
    public virtual int GetHashCode();
}
public class Windows.Foundation.Size : ValueType {
    private float _width;
    private float _height;
    private static Size s_empty;
    public double Width { get; public set; }
    public double Height { get; public set; }
    public static Size Empty { get; }
    public bool IsEmpty { get; }
    public Size(double width, double height);
    private static Size();
    public double get_Width();
    public void set_Width(double value);
    public double get_Height();
    public void set_Height(double value);
    public static Size get_Empty();
    public bool get_IsEmpty();
    private static Size CreateEmptySize();
    public static bool op_Equality(Size size1, Size size2);
    public static bool op_Inequality(Size size1, Size size2);
    public virtual bool Equals(object o);
    public bool Equals(Size value);
    public virtual int GetHashCode();
    private static bool Equals(Size size1, Size size2);
    public virtual string ToString();
}
internal static class Windows.Foundation.TokenizerHelper : object {
    internal static char GetNumericListSeparator(IFormatProvider provider);
}
public class Windows.UI.Color : ValueType {
    private byte _A;
    private byte _R;
    private byte _G;
    private byte _B;
    public byte A { get; public set; }
    public byte R { get; public set; }
    public byte G { get; public set; }
    public byte B { get; public set; }
    public static Color FromArgb(byte a, byte r, byte g, byte b);
    public byte get_A();
    public void set_A(byte value);
    public byte get_R();
    public void set_R(byte value);
    public byte get_G();
    public void set_G(byte value);
    public byte get_B();
    public void set_B(byte value);
    public virtual string ToString();
    public string ToString(IFormatProvider provider);
    private sealed virtual override string System.IFormattable.ToString(string format, IFormatProvider provider);
    internal string ConvertToString(string format, IFormatProvider provider);
    public virtual int GetHashCode();
    public virtual bool Equals(object o);
    public bool Equals(Color color);
    public static bool op_Equality(Color color1, Color color2);
    public static bool op_Inequality(Color color1, Color color2);
}
