public class System.Action : MulticastDelegate {
    public Action(object object, IntPtr method);
    public virtual void Invoke();
    public virtual IAsyncResult BeginInvoke(AsyncCallback callback, object object);
    public virtual void EndInvoke(IAsyncResult result);
}
public class System.Action`1 : MulticastDelegate {
    public Action`1(object object, IntPtr method);
    public virtual void Invoke(T obj);
    public virtual IAsyncResult BeginInvoke(T obj, AsyncCallback callback, object object);
    public virtual void EndInvoke(IAsyncResult result);
}
public class System.Action`10 : MulticastDelegate {
    public Action`10(object object, IntPtr method);
    public virtual void Invoke(T1 arg1, T2 arg2, T3 arg3, T4 arg4, T5 arg5, T6 arg6, T7 arg7, T8 arg8, T9 arg9, T10 arg10);
    public virtual IAsyncResult BeginInvoke(T1 arg1, T2 arg2, T3 arg3, T4 arg4, T5 arg5, T6 arg6, T7 arg7, T8 arg8, T9 arg9, T10 arg10, AsyncCallback callback, object object);
    public virtual void EndInvoke(IAsyncResult result);
}
public class System.Action`11 : MulticastDelegate {
    public Action`11(object object, IntPtr method);
    public virtual void Invoke(T1 arg1, T2 arg2, T3 arg3, T4 arg4, T5 arg5, T6 arg6, T7 arg7, T8 arg8, T9 arg9, T10 arg10, T11 arg11);
    public virtual IAsyncResult BeginInvoke(T1 arg1, T2 arg2, T3 arg3, T4 arg4, T5 arg5, T6 arg6, T7 arg7, T8 arg8, T9 arg9, T10 arg10, T11 arg11, AsyncCallback callback, object object);
    public virtual void EndInvoke(IAsyncResult result);
}
public class System.Action`12 : MulticastDelegate {
    public Action`12(object object, IntPtr method);
    public virtual void Invoke(T1 arg1, T2 arg2, T3 arg3, T4 arg4, T5 arg5, T6 arg6, T7 arg7, T8 arg8, T9 arg9, T10 arg10, T11 arg11, T12 arg12);
    public virtual IAsyncResult BeginInvoke(T1 arg1, T2 arg2, T3 arg3, T4 arg4, T5 arg5, T6 arg6, T7 arg7, T8 arg8, T9 arg9, T10 arg10, T11 arg11, T12 arg12, AsyncCallback callback, object object);
    public virtual void EndInvoke(IAsyncResult result);
}
public class System.Action`13 : MulticastDelegate {
    public Action`13(object object, IntPtr method);
    public virtual void Invoke(T1 arg1, T2 arg2, T3 arg3, T4 arg4, T5 arg5, T6 arg6, T7 arg7, T8 arg8, T9 arg9, T10 arg10, T11 arg11, T12 arg12, T13 arg13);
    public virtual IAsyncResult BeginInvoke(T1 arg1, T2 arg2, T3 arg3, T4 arg4, T5 arg5, T6 arg6, T7 arg7, T8 arg8, T9 arg9, T10 arg10, T11 arg11, T12 arg12, T13 arg13, AsyncCallback callback, object object);
    public virtual void EndInvoke(IAsyncResult result);
}
public class System.Action`14 : MulticastDelegate {
    public Action`14(object object, IntPtr method);
    public virtual void Invoke(T1 arg1, T2 arg2, T3 arg3, T4 arg4, T5 arg5, T6 arg6, T7 arg7, T8 arg8, T9 arg9, T10 arg10, T11 arg11, T12 arg12, T13 arg13, T14 arg14);
    public virtual IAsyncResult BeginInvoke(T1 arg1, T2 arg2, T3 arg3, T4 arg4, T5 arg5, T6 arg6, T7 arg7, T8 arg8, T9 arg9, T10 arg10, T11 arg11, T12 arg12, T13 arg13, T14 arg14, AsyncCallback callback, object object);
    public virtual void EndInvoke(IAsyncResult result);
}
public class System.Action`15 : MulticastDelegate {
    public Action`15(object object, IntPtr method);
    public virtual void Invoke(T1 arg1, T2 arg2, T3 arg3, T4 arg4, T5 arg5, T6 arg6, T7 arg7, T8 arg8, T9 arg9, T10 arg10, T11 arg11, T12 arg12, T13 arg13, T14 arg14, T15 arg15);
    public virtual IAsyncResult BeginInvoke(T1 arg1, T2 arg2, T3 arg3, T4 arg4, T5 arg5, T6 arg6, T7 arg7, T8 arg8, T9 arg9, T10 arg10, T11 arg11, T12 arg12, T13 arg13, T14 arg14, T15 arg15, AsyncCallback callback, object object);
    public virtual void EndInvoke(IAsyncResult result);
}
public class System.Action`16 : MulticastDelegate {
    public Action`16(object object, IntPtr method);
    public virtual void Invoke(T1 arg1, T2 arg2, T3 arg3, T4 arg4, T5 arg5, T6 arg6, T7 arg7, T8 arg8, T9 arg9, T10 arg10, T11 arg11, T12 arg12, T13 arg13, T14 arg14, T15 arg15, T16 arg16);
    public virtual IAsyncResult BeginInvoke(T1 arg1, T2 arg2, T3 arg3, T4 arg4, T5 arg5, T6 arg6, T7 arg7, T8 arg8, T9 arg9, T10 arg10, T11 arg11, T12 arg12, T13 arg13, T14 arg14, T15 arg15, T16 arg16, AsyncCallback callback, object object);
    public virtual void EndInvoke(IAsyncResult result);
}
public class System.Action`2 : MulticastDelegate {
    public Action`2(object object, IntPtr method);
    public virtual void Invoke(T1 arg1, T2 arg2);
    public virtual IAsyncResult BeginInvoke(T1 arg1, T2 arg2, AsyncCallback callback, object object);
    public virtual void EndInvoke(IAsyncResult result);
}
public class System.Action`3 : MulticastDelegate {
    public Action`3(object object, IntPtr method);
    public virtual void Invoke(T1 arg1, T2 arg2, T3 arg3);
    public virtual IAsyncResult BeginInvoke(T1 arg1, T2 arg2, T3 arg3, AsyncCallback callback, object object);
    public virtual void EndInvoke(IAsyncResult result);
}
public class System.Action`4 : MulticastDelegate {
    public Action`4(object object, IntPtr method);
    public virtual void Invoke(T1 arg1, T2 arg2, T3 arg3, T4 arg4);
    public virtual IAsyncResult BeginInvoke(T1 arg1, T2 arg2, T3 arg3, T4 arg4, AsyncCallback callback, object object);
    public virtual void EndInvoke(IAsyncResult result);
}
public class System.Action`5 : MulticastDelegate {
    public Action`5(object object, IntPtr method);
    public virtual void Invoke(T1 arg1, T2 arg2, T3 arg3, T4 arg4, T5 arg5);
    public virtual IAsyncResult BeginInvoke(T1 arg1, T2 arg2, T3 arg3, T4 arg4, T5 arg5, AsyncCallback callback, object object);
    public virtual void EndInvoke(IAsyncResult result);
}
public class System.Action`6 : MulticastDelegate {
    public Action`6(object object, IntPtr method);
    public virtual void Invoke(T1 arg1, T2 arg2, T3 arg3, T4 arg4, T5 arg5, T6 arg6);
    public virtual IAsyncResult BeginInvoke(T1 arg1, T2 arg2, T3 arg3, T4 arg4, T5 arg5, T6 arg6, AsyncCallback callback, object object);
    public virtual void EndInvoke(IAsyncResult result);
}
public class System.Action`7 : MulticastDelegate {
    public Action`7(object object, IntPtr method);
    public virtual void Invoke(T1 arg1, T2 arg2, T3 arg3, T4 arg4, T5 arg5, T6 arg6, T7 arg7);
    public virtual IAsyncResult BeginInvoke(T1 arg1, T2 arg2, T3 arg3, T4 arg4, T5 arg5, T6 arg6, T7 arg7, AsyncCallback callback, object object);
    public virtual void EndInvoke(IAsyncResult result);
}
public class System.Action`8 : MulticastDelegate {
    public Action`8(object object, IntPtr method);
    public virtual void Invoke(T1 arg1, T2 arg2, T3 arg3, T4 arg4, T5 arg5, T6 arg6, T7 arg7, T8 arg8);
    public virtual IAsyncResult BeginInvoke(T1 arg1, T2 arg2, T3 arg3, T4 arg4, T5 arg5, T6 arg6, T7 arg7, T8 arg8, AsyncCallback callback, object object);
    public virtual void EndInvoke(IAsyncResult result);
}
public class System.Action`9 : MulticastDelegate {
    public Action`9(object object, IntPtr method);
    public virtual void Invoke(T1 arg1, T2 arg2, T3 arg3, T4 arg4, T5 arg5, T6 arg6, T7 arg7, T8 arg8, T9 arg9);
    public virtual IAsyncResult BeginInvoke(T1 arg1, T2 arg2, T3 arg3, T4 arg4, T5 arg5, T6 arg6, T7 arg7, T8 arg8, T9 arg9, AsyncCallback callback, object object);
    public virtual void EndInvoke(IAsyncResult result);
}
public static class System.Activator : object {
    public static object CreateInstance(Type type);
    public static object CreateInstance(Type type, Object[] args);
    public static T CreateInstance();
}
public class System.ArgumentException : Exception {
    public string Message { get; }
    public string ParamName { get; }
    public ArgumentException(string message);
    public ArgumentException(string message, Exception innerException);
    public ArgumentException(string message, string paramName);
    public ArgumentException(string message, string paramName, Exception innerException);
    public virtual string get_Message();
    public virtual string get_ParamName();
}
public class System.ArgumentNullException : ArgumentException {
    public ArgumentNullException(string paramName);
    public ArgumentNullException(string message, Exception innerException);
    public ArgumentNullException(string paramName, string message);
}
public class System.ArgumentOutOfRangeException : ArgumentException {
    public object ActualValue { get; }
    public string Message { get; }
    public ArgumentOutOfRangeException(string paramName);
    public ArgumentOutOfRangeException(string message, Exception innerException);
    public ArgumentOutOfRangeException(string paramName, object actualValue, string message);
    public ArgumentOutOfRangeException(string paramName, string message);
    public virtual object get_ActualValue();
    public virtual string get_Message();
}
public class System.ArithmeticException : Exception {
    public ArithmeticException(string message);
    public ArithmeticException(string message, Exception innerException);
}
public abstract class System.Array : object {
    public int Length { get; }
    public int Rank { get; }
    private int System.Collections.ICollection.Count { get; }
    private bool System.Collections.ICollection.IsSynchronized { get; }
    private object System.Collections.ICollection.SyncRoot { get; }
    private bool System.Collections.IList.IsFixedSize { get; }
    private bool System.Collections.IList.IsReadOnly { get; }
    private object System.Collections.IList.Item { get; private set; }
    [SecuritySafeCriticalAttribute]
public int get_Length();
    [SecuritySafeCriticalAttribute]
public int get_Rank();
    private sealed virtual override int System.Collections.ICollection.get_Count();
    private sealed virtual override bool System.Collections.ICollection.get_IsSynchronized();
    private sealed virtual override object System.Collections.ICollection.get_SyncRoot();
    private sealed virtual override bool System.Collections.IList.get_IsFixedSize();
    private sealed virtual override bool System.Collections.IList.get_IsReadOnly();
    private sealed virtual override object System.Collections.IList.get_Item(int index);
    private sealed virtual override void System.Collections.IList.set_Item(int index, object value);
    public static int BinarySearch(Array array, int index, int length, object value);
    [SecuritySafeCriticalAttribute]
public static int BinarySearch(Array array, int index, int length, object value, IComparer comparer);
    public static int BinarySearch(Array array, object value);
    public static int BinarySearch(Array array, object value, IComparer comparer);
    public static int BinarySearch(T[] array, T value);
    public static int BinarySearch(T[] array, T value, IComparer`1<T> comparer);
    public static int BinarySearch(T[] array, int index, int length, T value);
    public static int BinarySearch(T[] array, int index, int length, T value, IComparer`1<T> comparer);
    [SecuritySafeCriticalAttribute]
public static void Clear(Array array, int index, int length);
    public object Clone();
    [SecuritySafeCriticalAttribute]
public static void ConstrainedCopy(Array sourceArray, int sourceIndex, Array destinationArray, int destinationIndex, int length);
    [SecuritySafeCriticalAttribute]
public static void Copy(Array sourceArray, Array destinationArray, int length);
    [SecuritySafeCriticalAttribute]
public static void Copy(Array sourceArray, int sourceIndex, Array destinationArray, int destinationIndex, int length);
    public sealed virtual void CopyTo(Array array, int index);
    [SecuritySafeCriticalAttribute]
public static Array CreateInstance(Type elementType, Int32[] lengths);
    [SecuritySafeCriticalAttribute]
public static Array CreateInstance(Type elementType, Int32[] lengths, Int32[] lowerBounds);
    public static bool Exists(T[] array, Predicate`1<T> match);
    public static T Find(T[] array, Predicate`1<T> match);
    public static T[] FindAll(T[] array, Predicate`1<T> match);
    public static int FindIndex(T[] array, int startIndex, int count, Predicate`1<T> match);
    public static int FindIndex(T[] array, int startIndex, Predicate`1<T> match);
    public static int FindIndex(T[] array, Predicate`1<T> match);
    public static T FindLast(T[] array, Predicate`1<T> match);
    public static int FindLastIndex(T[] array, int startIndex, int count, Predicate`1<T> match);
    public static int FindLastIndex(T[] array, int startIndex, Predicate`1<T> match);
    public static int FindLastIndex(T[] array, Predicate`1<T> match);
    public sealed virtual IEnumerator GetEnumerator();
    [SecuritySafeCriticalAttribute]
public int GetLength(int dimension);
    [SecuritySafeCriticalAttribute]
public int GetLowerBound(int dimension);
    [SecuritySafeCriticalAttribute]
public int GetUpperBound(int dimension);
    [SecuritySafeCriticalAttribute]
public object GetValue(Int32[] indices);
    public static int IndexOf(Array array, object value);
    public static int IndexOf(Array array, object value, int startIndex);
    [SecuritySafeCriticalAttribute]
public static int IndexOf(Array array, object value, int startIndex, int count);
    public static int IndexOf(T[] array, T value);
    public static int IndexOf(T[] array, T value, int startIndex);
    public static int IndexOf(T[] array, T value, int startIndex, int count);
    [SecuritySafeCriticalAttribute]
public void Initialize();
    public static int LastIndexOf(Array array, object value);
    public static int LastIndexOf(Array array, object value, int startIndex);
    [SecuritySafeCriticalAttribute]
public static int LastIndexOf(Array array, object value, int startIndex, int count);
    public static int LastIndexOf(T[] array, T value);
    public static int LastIndexOf(T[] array, T value, int startIndex);
    public static int LastIndexOf(T[] array, T value, int startIndex, int count);
    public static void Resize(T[]& array, int newSize);
    public static void Reverse(Array array);
    [SecuritySafeCriticalAttribute]
public static void Reverse(Array array, int index, int length);
    [SecuritySafeCriticalAttribute]
public void SetValue(object value, Int32[] indices);
    public static void Sort(Array array);
    public static void Sort(Array array, IComparer comparer);
    public static void Sort(Array array, int index, int length);
    public static void Sort(Array array, int index, int length, IComparer comparer);
    public static void Sort(T[] array);
    public static void Sort(T[] array, IComparer`1<T> comparer);
    public static void Sort(T[] array, Comparison`1<T> comparison);
    public static void Sort(T[] array, int index, int length);
    [SecuritySafeCriticalAttribute]
public static void Sort(T[] array, int index, int length, IComparer`1<T> comparer);
    private sealed virtual override int System.Collections.IList.Add(object value);
    private sealed virtual override void System.Collections.IList.Clear();
    private sealed virtual override bool System.Collections.IList.Contains(object value);
    private sealed virtual override int System.Collections.IList.IndexOf(object value);
    private sealed virtual override void System.Collections.IList.Insert(int index, object value);
    private sealed virtual override void System.Collections.IList.Remove(object value);
    private sealed virtual override void System.Collections.IList.RemoveAt(int index);
    private sealed virtual override int System.Collections.IStructuralComparable.CompareTo(object other, IComparer comparer);
    private sealed virtual override bool System.Collections.IStructuralEquatable.Equals(object other, IEqualityComparer comparer);
    private sealed virtual override int System.Collections.IStructuralEquatable.GetHashCode(IEqualityComparer comparer);
    public static bool TrueForAll(T[] array, Predicate`1<T> match);
}
public class System.ArraySegment`1 : ValueType {
    public T[] Array { get; }
    public int Count { get; }
    public int Offset { get; }
    private bool System.Collections.Generic.ICollection<T>.IsReadOnly { get; }
    private T System.Collections.Generic.IList<T>.Item { get; private set; }
    private T System.Collections.Generic.IReadOnlyList<T>.Item { get; }
    public ArraySegment`1(T[] array);
    public ArraySegment`1(T[] array, int offset, int count);
    public T[] get_Array();
    public sealed virtual int get_Count();
    public int get_Offset();
    private sealed virtual override bool System.Collections.Generic.ICollection<T>.get_IsReadOnly();
    private sealed virtual override T System.Collections.Generic.IList<T>.get_Item(int index);
    private sealed virtual override void System.Collections.Generic.IList<T>.set_Item(int index, T value);
    private sealed virtual override T System.Collections.Generic.IReadOnlyList<T>.get_Item(int index);
    public bool Equals(ArraySegment`1<T> obj);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    public static bool op_Equality(ArraySegment`1<T> a, ArraySegment`1<T> b);
    public static bool op_Inequality(ArraySegment`1<T> a, ArraySegment`1<T> b);
    private sealed virtual override void System.Collections.Generic.ICollection<T>.Add(T item);
    private sealed virtual override void System.Collections.Generic.ICollection<T>.Clear();
    private sealed virtual override bool System.Collections.Generic.ICollection<T>.Contains(T item);
    private sealed virtual override void System.Collections.Generic.ICollection<T>.CopyTo(T[] array, int arrayIndex);
    private sealed virtual override bool System.Collections.Generic.ICollection<T>.Remove(T item);
    private sealed virtual override IEnumerator`1<T> System.Collections.Generic.IEnumerable<T>.GetEnumerator();
    private sealed virtual override int System.Collections.Generic.IList<T>.IndexOf(T item);
    private sealed virtual override void System.Collections.Generic.IList<T>.Insert(int index, T item);
    private sealed virtual override void System.Collections.Generic.IList<T>.RemoveAt(int index);
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
}
public class System.ArrayTypeMismatchException : Exception {
    public ArrayTypeMismatchException(string message);
    public ArrayTypeMismatchException(string message, Exception innerException);
}
public class System.AsyncCallback : MulticastDelegate {
    public AsyncCallback(object object, IntPtr method);
    public virtual void Invoke(IAsyncResult ar);
    public virtual IAsyncResult BeginInvoke(IAsyncResult ar, AsyncCallback callback, object object);
    public virtual void EndInvoke(IAsyncResult result);
}
[AttributeUsageAttribute("32767")]
public abstract class System.Attribute : object {
    [SecuritySafeCriticalAttribute]
public virtual bool Equals(object obj);
    [SecuritySafeCriticalAttribute]
public virtual int GetHashCode();
}
[FlagsAttribute]
public enum System.AttributeTargets : Enum {
    public int value__;
    public static AttributeTargets All;
    public static AttributeTargets Assembly;
    public static AttributeTargets Class;
    public static AttributeTargets Constructor;
    public static AttributeTargets Delegate;
    public static AttributeTargets Enum;
    public static AttributeTargets Event;
    public static AttributeTargets Field;
    public static AttributeTargets GenericParameter;
    public static AttributeTargets Interface;
    public static AttributeTargets Method;
    public static AttributeTargets Module;
    public static AttributeTargets Parameter;
    public static AttributeTargets Property;
    public static AttributeTargets ReturnValue;
    public static AttributeTargets Struct;
}
[AttributeUsageAttribute("4")]
public class System.AttributeUsageAttribute : Attribute {
    public bool AllowMultiple { get; public set; }
    public bool Inherited { get; public set; }
    public AttributeTargets ValidOn { get; }
    public AttributeUsageAttribute(AttributeTargets validOn);
    public bool get_AllowMultiple();
    public void set_AllowMultiple(bool value);
    public bool get_Inherited();
    public void set_Inherited(bool value);
    public AttributeTargets get_ValidOn();
}
public class System.BadImageFormatException : Exception {
    public string FileName { get; }
    public string Message { get; }
    public BadImageFormatException(string message);
    public BadImageFormatException(string message, Exception inner);
    public BadImageFormatException(string message, string fileName);
    public BadImageFormatException(string message, string fileName, Exception inner);
    public string get_FileName();
    public virtual string get_Message();
    public virtual string ToString();
}
public class System.Boolean : ValueType {
    public static string FalseString;
    public static string TrueString;
    public sealed virtual int CompareTo(bool value);
    public sealed virtual bool Equals(bool obj);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    public static bool Parse(string value);
    private sealed virtual override int System.IComparable.CompareTo(object obj);
    public virtual string ToString();
    public static bool TryParse(string value, Boolean& result);
}
public static class System.Buffer : object {
    [SecuritySafeCriticalAttribute]
public static void BlockCopy(Array src, int srcOffset, Array dst, int dstOffset, int count);
    [SecuritySafeCriticalAttribute]
public static int ByteLength(Array array);
    [SecuritySafeCriticalAttribute]
public static byte GetByte(Array array, int index);
    [SecuritySafeCriticalAttribute]
public static void SetByte(Array array, int index, byte value);
}
public class System.Byte : ValueType {
    public static byte MaxValue;
    public static byte MinValue;
    public sealed virtual int CompareTo(byte value);
    public sealed virtual bool Equals(byte obj);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    public static byte Parse(string s);
    public static byte Parse(string s, NumberStyles style);
    public static byte Parse(string s, NumberStyles style, IFormatProvider provider);
    public static byte Parse(string s, IFormatProvider provider);
    private sealed virtual override int System.IComparable.CompareTo(object value);
    [SecuritySafeCriticalAttribute]
public virtual string ToString();
    [SecuritySafeCriticalAttribute]
public string ToString(IFormatProvider provider);
    [SecuritySafeCriticalAttribute]
public string ToString(string format);
    [SecuritySafeCriticalAttribute]
public sealed virtual string ToString(string format, IFormatProvider provider);
    public static bool TryParse(string s, Byte& result);
    public static bool TryParse(string s, NumberStyles style, IFormatProvider provider, Byte& result);
}
public class System.Char : ValueType {
    public static char MaxValue;
    public static char MinValue;
    public sealed virtual int CompareTo(char value);
    public static string ConvertFromUtf32(int utf32);
    public static int ConvertToUtf32(char highSurrogate, char lowSurrogate);
    public static int ConvertToUtf32(string s, int index);
    public sealed virtual bool Equals(char obj);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    public static double GetNumericValue(char c);
    public static double GetNumericValue(string s, int index);
    public static bool IsControl(char c);
    public static bool IsControl(string s, int index);
    public static bool IsDigit(char c);
    public static bool IsDigit(string s, int index);
    public static bool IsHighSurrogate(char c);
    public static bool IsHighSurrogate(string s, int index);
    public static bool IsLetter(char c);
    public static bool IsLetter(string s, int index);
    public static bool IsLetterOrDigit(char c);
    public static bool IsLetterOrDigit(string s, int index);
    public static bool IsLower(char c);
    public static bool IsLower(string s, int index);
    public static bool IsLowSurrogate(char c);
    public static bool IsLowSurrogate(string s, int index);
    public static bool IsNumber(char c);
    public static bool IsNumber(string s, int index);
    public static bool IsPunctuation(char c);
    public static bool IsPunctuation(string s, int index);
    public static bool IsSeparator(char c);
    public static bool IsSeparator(string s, int index);
    public static bool IsSurrogate(char c);
    public static bool IsSurrogate(string s, int index);
    public static bool IsSurrogatePair(char highSurrogate, char lowSurrogate);
    public static bool IsSurrogatePair(string s, int index);
    public static bool IsSymbol(char c);
    public static bool IsSymbol(string s, int index);
    public static bool IsUpper(char c);
    public static bool IsUpper(string s, int index);
    public static bool IsWhiteSpace(char c);
    public static bool IsWhiteSpace(string s, int index);
    private sealed virtual override int System.IComparable.CompareTo(object value);
    public static char ToLower(char c);
    public static char ToLowerInvariant(char c);
    public virtual string ToString();
    public static string ToString(char c);
    public static char ToUpper(char c);
    public static char ToUpperInvariant(char c);
    public static bool TryParse(string s, Char& result);
}
[AttributeUsageAttribute("32767")]
public class System.CLSCompliantAttribute : Attribute {
    public bool IsCompliant { get; }
    public CLSCompliantAttribute(bool isCompliant);
    public bool get_IsCompliant();
}
public class System.Collections.DictionaryEntry : ValueType {
    public object Key { get; public set; }
    public object Value { get; public set; }
    public DictionaryEntry(object key, object value);
    public object get_Key();
    public void set_Key(object value);
    public object get_Value();
    public void set_Value(object value);
}
public interface System.Collections.Generic.ICollection`1 {
    public int Count { get; }
    public bool IsReadOnly { get; }
    public abstract virtual int get_Count();
    public abstract virtual bool get_IsReadOnly();
    public abstract virtual void Add(T item);
    public abstract virtual void Clear();
    public abstract virtual bool Contains(T item);
    public abstract virtual void CopyTo(T[] array, int arrayIndex);
    public abstract virtual bool Remove(T item);
}
public interface System.Collections.Generic.IComparer`1 {
    public abstract virtual int Compare(T x, T y);
}
[DefaultMemberAttribute("Item")]
public interface System.Collections.Generic.IDictionary`2 {
    public TValue Item { get; public set; }
    public ICollection`1<TKey> Keys { get; }
    public ICollection`1<TValue> Values { get; }
    public abstract virtual TValue get_Item(TKey key);
    public abstract virtual void set_Item(TKey key, TValue value);
    public abstract virtual ICollection`1<TKey> get_Keys();
    public abstract virtual ICollection`1<TValue> get_Values();
    public abstract virtual void Add(TKey key, TValue value);
    public abstract virtual bool ContainsKey(TKey key);
    public abstract virtual bool Remove(TKey key);
    public abstract virtual bool TryGetValue(TKey key, TValue& value);
}
public interface System.Collections.Generic.IEnumerable`1 {
    public abstract virtual IEnumerator`1<T> GetEnumerator();
}
public interface System.Collections.Generic.IEnumerator`1 {
    public T Current { get; }
    public abstract virtual T get_Current();
}
public interface System.Collections.Generic.IEqualityComparer`1 {
    public abstract virtual bool Equals(T x, T y);
    public abstract virtual int GetHashCode(T obj);
}
[DefaultMemberAttribute("Item")]
public interface System.Collections.Generic.IList`1 {
    public T Item { get; public set; }
    public abstract virtual T get_Item(int index);
    public abstract virtual void set_Item(int index, T value);
    public abstract virtual int IndexOf(T item);
    public abstract virtual void Insert(int index, T item);
    public abstract virtual void RemoveAt(int index);
}
public interface System.Collections.Generic.IReadOnlyCollection`1 {
    public int Count { get; }
    public abstract virtual int get_Count();
}
[DefaultMemberAttribute("Item")]
public interface System.Collections.Generic.IReadOnlyDictionary`2 {
    public TValue Item { get; }
    public IEnumerable`1<TKey> Keys { get; }
    public IEnumerable`1<TValue> Values { get; }
    public abstract virtual TValue get_Item(TKey key);
    public abstract virtual IEnumerable`1<TKey> get_Keys();
    public abstract virtual IEnumerable`1<TValue> get_Values();
    public abstract virtual bool ContainsKey(TKey key);
    public abstract virtual bool TryGetValue(TKey key, TValue& value);
}
[DefaultMemberAttribute("Item")]
public interface System.Collections.Generic.IReadOnlyList`1 {
    public T Item { get; }
    public abstract virtual T get_Item(int index);
}
public interface System.Collections.Generic.ISet`1 {
    public abstract virtual bool Add(T item);
    public abstract virtual void ExceptWith(IEnumerable`1<T> other);
    public abstract virtual void IntersectWith(IEnumerable`1<T> other);
    public abstract virtual bool IsProperSubsetOf(IEnumerable`1<T> other);
    public abstract virtual bool IsProperSupersetOf(IEnumerable`1<T> other);
    public abstract virtual bool IsSubsetOf(IEnumerable`1<T> other);
    public abstract virtual bool IsSupersetOf(IEnumerable`1<T> other);
    public abstract virtual bool Overlaps(IEnumerable`1<T> other);
    public abstract virtual bool SetEquals(IEnumerable`1<T> other);
    public abstract virtual void SymmetricExceptWith(IEnumerable`1<T> other);
    public abstract virtual void UnionWith(IEnumerable`1<T> other);
}
public class System.Collections.Generic.KeyNotFoundException : Exception {
    public KeyNotFoundException(string message);
    public KeyNotFoundException(string message, Exception innerException);
}
public class System.Collections.Generic.KeyValuePair`2 : ValueType {
    public TKey Key { get; }
    public TValue Value { get; }
    public KeyValuePair`2(TKey key, TValue value);
    public TKey get_Key();
    public TValue get_Value();
    public virtual string ToString();
}
public interface System.Collections.ICollection {
    public int Count { get; }
    public bool IsSynchronized { get; }
    public object SyncRoot { get; }
    public abstract virtual int get_Count();
    public abstract virtual bool get_IsSynchronized();
    public abstract virtual object get_SyncRoot();
    public abstract virtual void CopyTo(Array array, int index);
}
public interface System.Collections.IComparer {
    public abstract virtual int Compare(object x, object y);
}
[DefaultMemberAttribute("Item")]
public interface System.Collections.IDictionary {
    public bool IsFixedSize { get; }
    public bool IsReadOnly { get; }
    public object Item { get; public set; }
    public ICollection Keys { get; }
    public ICollection Values { get; }
    public abstract virtual bool get_IsFixedSize();
    public abstract virtual bool get_IsReadOnly();
    public abstract virtual object get_Item(object key);
    public abstract virtual void set_Item(object key, object value);
    public abstract virtual ICollection get_Keys();
    public abstract virtual ICollection get_Values();
    public abstract virtual void Add(object key, object value);
    public abstract virtual void Clear();
    public abstract virtual bool Contains(object key);
    public abstract virtual IDictionaryEnumerator GetEnumerator();
    public abstract virtual void Remove(object key);
}
public interface System.Collections.IDictionaryEnumerator {
    public DictionaryEntry Entry { get; }
    public object Key { get; }
    public object Value { get; }
    public abstract virtual DictionaryEntry get_Entry();
    public abstract virtual object get_Key();
    public abstract virtual object get_Value();
}
public interface System.Collections.IEnumerable {
    public abstract virtual IEnumerator GetEnumerator();
}
public interface System.Collections.IEnumerator {
    public object Current { get; }
    public abstract virtual object get_Current();
    public abstract virtual bool MoveNext();
    public abstract virtual void Reset();
}
public interface System.Collections.IEqualityComparer {
    public abstract virtual bool Equals(object x, object y);
    public abstract virtual int GetHashCode(object obj);
}
[DefaultMemberAttribute("Item")]
public interface System.Collections.IList {
    public bool IsFixedSize { get; }
    public bool IsReadOnly { get; }
    public object Item { get; public set; }
    public abstract virtual bool get_IsFixedSize();
    public abstract virtual bool get_IsReadOnly();
    public abstract virtual object get_Item(int index);
    public abstract virtual void set_Item(int index, object value);
    public abstract virtual int Add(object value);
    public abstract virtual void Clear();
    public abstract virtual bool Contains(object value);
    public abstract virtual int IndexOf(object value);
    public abstract virtual void Insert(int index, object value);
    public abstract virtual void Remove(object value);
    public abstract virtual void RemoveAt(int index);
}
public interface System.Collections.IStructuralComparable {
    public abstract virtual int CompareTo(object other, IComparer comparer);
}
public interface System.Collections.IStructuralEquatable {
    public abstract virtual bool Equals(object other, IEqualityComparer comparer);
    public abstract virtual int GetHashCode(IEqualityComparer comparer);
}
[DefaultMemberAttribute("Item")]
public class System.Collections.ObjectModel.Collection`1 : object {
    public int Count { get; }
    public T Item { get; public set; }
    protected IList`1<T> Items { get; }
    private bool System.Collections.Generic.ICollection<T>.IsReadOnly { get; }
    private bool System.Collections.ICollection.IsSynchronized { get; }
    private object System.Collections.ICollection.SyncRoot { get; }
    private bool System.Collections.IList.IsFixedSize { get; }
    private bool System.Collections.IList.IsReadOnly { get; }
    private object System.Collections.IList.Item { get; private set; }
    public Collection`1(IList`1<T> list);
    public sealed virtual int get_Count();
    public sealed virtual T get_Item(int index);
    public sealed virtual void set_Item(int index, T value);
    protected IList`1<T> get_Items();
    private sealed virtual override bool System.Collections.Generic.ICollection<T>.get_IsReadOnly();
    private sealed virtual override bool System.Collections.ICollection.get_IsSynchronized();
    private sealed virtual override object System.Collections.ICollection.get_SyncRoot();
    private sealed virtual override bool System.Collections.IList.get_IsFixedSize();
    private sealed virtual override bool System.Collections.IList.get_IsReadOnly();
    private sealed virtual override object System.Collections.IList.get_Item(int index);
    private sealed virtual override void System.Collections.IList.set_Item(int index, object value);
    public sealed virtual void Add(T item);
    public sealed virtual void Clear();
    protected virtual void ClearItems();
    public sealed virtual bool Contains(T item);
    public sealed virtual void CopyTo(T[] array, int index);
    public sealed virtual IEnumerator`1<T> GetEnumerator();
    public sealed virtual int IndexOf(T item);
    public sealed virtual void Insert(int index, T item);
    protected virtual void InsertItem(int index, T item);
    public sealed virtual bool Remove(T item);
    public sealed virtual void RemoveAt(int index);
    protected virtual void RemoveItem(int index);
    protected virtual void SetItem(int index, T item);
    private sealed virtual override void System.Collections.ICollection.CopyTo(Array array, int index);
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
    private sealed virtual override int System.Collections.IList.Add(object value);
    private sealed virtual override bool System.Collections.IList.Contains(object value);
    private sealed virtual override int System.Collections.IList.IndexOf(object value);
    private sealed virtual override void System.Collections.IList.Insert(int index, object value);
    private sealed virtual override void System.Collections.IList.Remove(object value);
}
[DefaultMemberAttribute("Item")]
public class System.Collections.ObjectModel.ReadOnlyCollection`1 : object {
    public int Count { get; }
    public T Item { get; }
    protected IList`1<T> Items { get; }
    private bool System.Collections.Generic.ICollection<T>.IsReadOnly { get; }
    private T System.Collections.Generic.IList<T>.Item { get; private set; }
    private bool System.Collections.ICollection.IsSynchronized { get; }
    private object System.Collections.ICollection.SyncRoot { get; }
    private bool System.Collections.IList.IsFixedSize { get; }
    private bool System.Collections.IList.IsReadOnly { get; }
    private object System.Collections.IList.Item { get; private set; }
    public ReadOnlyCollection`1(IList`1<T> list);
    public sealed virtual int get_Count();
    public sealed virtual T get_Item(int index);
    protected IList`1<T> get_Items();
    private sealed virtual override bool System.Collections.Generic.ICollection<T>.get_IsReadOnly();
    private sealed virtual override T System.Collections.Generic.IList<T>.get_Item(int index);
    private sealed virtual override void System.Collections.Generic.IList<T>.set_Item(int index, T value);
    private sealed virtual override bool System.Collections.ICollection.get_IsSynchronized();
    private sealed virtual override object System.Collections.ICollection.get_SyncRoot();
    private sealed virtual override bool System.Collections.IList.get_IsFixedSize();
    private sealed virtual override bool System.Collections.IList.get_IsReadOnly();
    private sealed virtual override object System.Collections.IList.get_Item(int index);
    private sealed virtual override void System.Collections.IList.set_Item(int index, object value);
    public sealed virtual bool Contains(T value);
    public sealed virtual void CopyTo(T[] array, int index);
    public sealed virtual IEnumerator`1<T> GetEnumerator();
    public sealed virtual int IndexOf(T value);
    private sealed virtual override void System.Collections.Generic.ICollection<T>.Add(T value);
    private sealed virtual override void System.Collections.Generic.ICollection<T>.Clear();
    private sealed virtual override bool System.Collections.Generic.ICollection<T>.Remove(T value);
    private sealed virtual override void System.Collections.Generic.IList<T>.Insert(int index, T value);
    private sealed virtual override void System.Collections.Generic.IList<T>.RemoveAt(int index);
    private sealed virtual override void System.Collections.ICollection.CopyTo(Array array, int index);
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
    private sealed virtual override int System.Collections.IList.Add(object value);
    private sealed virtual override void System.Collections.IList.Clear();
    private sealed virtual override bool System.Collections.IList.Contains(object value);
    private sealed virtual override int System.Collections.IList.IndexOf(object value);
    private sealed virtual override void System.Collections.IList.Insert(int index, object value);
    private sealed virtual override void System.Collections.IList.Remove(object value);
    private sealed virtual override void System.Collections.IList.RemoveAt(int index);
}
public class System.Comparison`1 : MulticastDelegate {
    public Comparison`1(object object, IntPtr method);
    public virtual int Invoke(T x, T y);
    public virtual IAsyncResult BeginInvoke(T x, T y, AsyncCallback callback, object object);
    public virtual int EndInvoke(IAsyncResult result);
}
[AttributeUsageAttribute("32767")]
public class System.ComponentModel.DefaultValueAttribute : Attribute {
    public object Value { get; }
    public DefaultValueAttribute(bool value);
    public DefaultValueAttribute(byte value);
    public DefaultValueAttribute(char value);
    public DefaultValueAttribute(double value);
    public DefaultValueAttribute(short value);
    public DefaultValueAttribute(int value);
    public DefaultValueAttribute(long value);
    public DefaultValueAttribute(object value);
    public DefaultValueAttribute(float value);
    public DefaultValueAttribute(string value);
    public DefaultValueAttribute(Type type, string value);
    public virtual object get_Value();
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
}
[AttributeUsageAttribute("6140")]
public class System.ComponentModel.EditorBrowsableAttribute : Attribute {
    public EditorBrowsableState State { get; }
    public EditorBrowsableAttribute(EditorBrowsableState state);
    public EditorBrowsableState get_State();
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
}
public enum System.ComponentModel.EditorBrowsableState : Enum {
    public int value__;
    public static EditorBrowsableState Advanced;
    public static EditorBrowsableState Always;
    public static EditorBrowsableState Never;
}
public class System.DateTime : ValueType {
    public static DateTime MaxValue;
    public static DateTime MinValue;
    public DateTime Date { get; }
    public int Day { get; }
    public DayOfWeek DayOfWeek { get; }
    public int DayOfYear { get; }
    public int Hour { get; }
    public DateTimeKind Kind { get; }
    public int Millisecond { get; }
    public int Minute { get; }
    public int Month { get; }
    public static DateTime Now { get; }
    public int Second { get; }
    public long Ticks { get; }
    public TimeSpan TimeOfDay { get; }
    public static DateTime Today { get; }
    public static DateTime UtcNow { get; }
    public int Year { get; }
    public DateTime(int year, int month, int day);
    public DateTime(int year, int month, int day, int hour, int minute, int second);
    public DateTime(int year, int month, int day, int hour, int minute, int second, DateTimeKind kind);
    public DateTime(int year, int month, int day, int hour, int minute, int second, int millisecond);
    public DateTime(int year, int month, int day, int hour, int minute, int second, int millisecond, DateTimeKind kind);
    public DateTime(long ticks);
    public DateTime(long ticks, DateTimeKind kind);
    public DateTime get_Date();
    public int get_Day();
    public DayOfWeek get_DayOfWeek();
    public int get_DayOfYear();
    public int get_Hour();
    public DateTimeKind get_Kind();
    public int get_Millisecond();
    public int get_Minute();
    public int get_Month();
    public static DateTime get_Now();
    public int get_Second();
    public long get_Ticks();
    public TimeSpan get_TimeOfDay();
    public static DateTime get_Today();
    [SecuritySafeCriticalAttribute]
public static DateTime get_UtcNow();
    public int get_Year();
    public DateTime Add(TimeSpan value);
    public DateTime AddDays(double value);
    public DateTime AddHours(double value);
    public DateTime AddMilliseconds(double value);
    public DateTime AddMinutes(double value);
    public DateTime AddMonths(int months);
    public DateTime AddSeconds(double value);
    public DateTime AddTicks(long value);
    public DateTime AddYears(int value);
    public static int Compare(DateTime t1, DateTime t2);
    public sealed virtual int CompareTo(DateTime value);
    public static int DaysInMonth(int year, int month);
    public sealed virtual bool Equals(DateTime value);
    public static bool Equals(DateTime t1, DateTime t2);
    public virtual bool Equals(object value);
    public static DateTime FromBinary(long dateData);
    public static DateTime FromFileTime(long fileTime);
    public static DateTime FromFileTimeUtc(long fileTime);
    public String[] GetDateTimeFormats();
    public String[] GetDateTimeFormats(char format);
    public String[] GetDateTimeFormats(char format, IFormatProvider provider);
    public String[] GetDateTimeFormats(IFormatProvider provider);
    public virtual int GetHashCode();
    public bool IsDaylightSavingTime();
    public static bool IsLeapYear(int year);
    public static DateTime op_Addition(DateTime d, TimeSpan t);
    public static bool op_Equality(DateTime d1, DateTime d2);
    public static bool op_GreaterThan(DateTime t1, DateTime t2);
    public static bool op_GreaterThanOrEqual(DateTime t1, DateTime t2);
    public static bool op_Inequality(DateTime d1, DateTime d2);
    public static bool op_LessThan(DateTime t1, DateTime t2);
    public static bool op_LessThanOrEqual(DateTime t1, DateTime t2);
    public static TimeSpan op_Subtraction(DateTime d1, DateTime d2);
    public static DateTime op_Subtraction(DateTime d, TimeSpan t);
    public static DateTime Parse(string s);
    public static DateTime Parse(string s, IFormatProvider provider);
    public static DateTime Parse(string s, IFormatProvider provider, DateTimeStyles styles);
    public static DateTime ParseExact(string s, string format, IFormatProvider provider);
    public static DateTime ParseExact(string s, string format, IFormatProvider provider, DateTimeStyles style);
    public static DateTime ParseExact(string s, String[] formats, IFormatProvider provider, DateTimeStyles style);
    public static DateTime SpecifyKind(DateTime value, DateTimeKind kind);
    public TimeSpan Subtract(DateTime value);
    public DateTime Subtract(TimeSpan value);
    private sealed virtual override int System.IComparable.CompareTo(object value);
    public long ToBinary();
    public long ToFileTime();
    public long ToFileTimeUtc();
    public DateTime ToLocalTime();
    public virtual string ToString();
    public string ToString(IFormatProvider provider);
    public string ToString(string format);
    public sealed virtual string ToString(string format, IFormatProvider provider);
    public DateTime ToUniversalTime();
    public static bool TryParse(string s, DateTime& result);
    public static bool TryParse(string s, IFormatProvider provider, DateTimeStyles styles, DateTime& result);
    public static bool TryParseExact(string s, string format, IFormatProvider provider, DateTimeStyles style, DateTime& result);
    public static bool TryParseExact(string s, String[] formats, IFormatProvider provider, DateTimeStyles style, DateTime& result);
}
public enum System.DateTimeKind : Enum {
    public int value__;
    public static DateTimeKind Local;
    public static DateTimeKind Unspecified;
    public static DateTimeKind Utc;
}
public class System.DateTimeOffset : ValueType {
    public static DateTimeOffset MaxValue;
    public static DateTimeOffset MinValue;
    public DateTime Date { get; }
    public DateTime DateTime { get; }
    public int Day { get; }
    public DayOfWeek DayOfWeek { get; }
    public int DayOfYear { get; }
    public int Hour { get; }
    public DateTime LocalDateTime { get; }
    public int Millisecond { get; }
    public int Minute { get; }
    public int Month { get; }
    public static DateTimeOffset Now { get; }
    public TimeSpan Offset { get; }
    public int Second { get; }
    public long Ticks { get; }
    public TimeSpan TimeOfDay { get; }
    public DateTime UtcDateTime { get; }
    public static DateTimeOffset UtcNow { get; }
    public long UtcTicks { get; }
    public int Year { get; }
    public DateTimeOffset(DateTime dateTime);
    public DateTimeOffset(DateTime dateTime, TimeSpan offset);
    public DateTimeOffset(int year, int month, int day, int hour, int minute, int second, int millisecond, TimeSpan offset);
    public DateTimeOffset(int year, int month, int day, int hour, int minute, int second, TimeSpan offset);
    public DateTimeOffset(long ticks, TimeSpan offset);
    public DateTime get_Date();
    public DateTime get_DateTime();
    public int get_Day();
    public DayOfWeek get_DayOfWeek();
    public int get_DayOfYear();
    public int get_Hour();
    public DateTime get_LocalDateTime();
    public int get_Millisecond();
    public int get_Minute();
    public int get_Month();
    public static DateTimeOffset get_Now();
    public TimeSpan get_Offset();
    public int get_Second();
    public long get_Ticks();
    public TimeSpan get_TimeOfDay();
    public DateTime get_UtcDateTime();
    public static DateTimeOffset get_UtcNow();
    public long get_UtcTicks();
    public int get_Year();
    public DateTimeOffset Add(TimeSpan timeSpan);
    public DateTimeOffset AddDays(double days);
    public DateTimeOffset AddHours(double hours);
    public DateTimeOffset AddMilliseconds(double milliseconds);
    public DateTimeOffset AddMinutes(double minutes);
    public DateTimeOffset AddMonths(int months);
    public DateTimeOffset AddSeconds(double seconds);
    public DateTimeOffset AddTicks(long ticks);
    public DateTimeOffset AddYears(int years);
    public static int Compare(DateTimeOffset first, DateTimeOffset second);
    public sealed virtual int CompareTo(DateTimeOffset other);
    public sealed virtual bool Equals(DateTimeOffset other);
    public static bool Equals(DateTimeOffset first, DateTimeOffset second);
    public virtual bool Equals(object obj);
    public bool EqualsExact(DateTimeOffset other);
    public static DateTimeOffset FromFileTime(long fileTime);
    public virtual int GetHashCode();
    public static DateTimeOffset op_Addition(DateTimeOffset dateTimeOffset, TimeSpan timeSpan);
    public static bool op_Equality(DateTimeOffset left, DateTimeOffset right);
    public static bool op_GreaterThan(DateTimeOffset left, DateTimeOffset right);
    public static bool op_GreaterThanOrEqual(DateTimeOffset left, DateTimeOffset right);
    public static DateTimeOffset op_Implicit(DateTime dateTime);
    public static bool op_Inequality(DateTimeOffset left, DateTimeOffset right);
    public static bool op_LessThan(DateTimeOffset left, DateTimeOffset right);
    public static bool op_LessThanOrEqual(DateTimeOffset left, DateTimeOffset right);
    public static TimeSpan op_Subtraction(DateTimeOffset left, DateTimeOffset right);
    public static DateTimeOffset op_Subtraction(DateTimeOffset dateTimeOffset, TimeSpan timeSpan);
    public static DateTimeOffset Parse(string input);
    public static DateTimeOffset Parse(string input, IFormatProvider formatProvider);
    public static DateTimeOffset Parse(string input, IFormatProvider formatProvider, DateTimeStyles styles);
    public static DateTimeOffset ParseExact(string input, string format, IFormatProvider formatProvider);
    public static DateTimeOffset ParseExact(string input, string format, IFormatProvider formatProvider, DateTimeStyles styles);
    public static DateTimeOffset ParseExact(string input, String[] formats, IFormatProvider formatProvider, DateTimeStyles styles);
    public TimeSpan Subtract(DateTimeOffset value);
    public DateTimeOffset Subtract(TimeSpan value);
    private sealed virtual override int System.IComparable.CompareTo(object obj);
    public long ToFileTime();
    public DateTimeOffset ToLocalTime();
    public DateTimeOffset ToOffset(TimeSpan offset);
    public virtual string ToString();
    public string ToString(IFormatProvider formatProvider);
    public string ToString(string format);
    public sealed virtual string ToString(string format, IFormatProvider formatProvider);
    public DateTimeOffset ToUniversalTime();
    public static bool TryParse(string input, DateTimeOffset& result);
    public static bool TryParse(string input, IFormatProvider formatProvider, DateTimeStyles styles, DateTimeOffset& result);
    public static bool TryParseExact(string input, string format, IFormatProvider formatProvider, DateTimeStyles styles, DateTimeOffset& result);
    public static bool TryParseExact(string input, String[] formats, IFormatProvider formatProvider, DateTimeStyles styles, DateTimeOffset& result);
}
public enum System.DayOfWeek : Enum {
    public int value__;
    public static DayOfWeek Friday;
    public static DayOfWeek Monday;
    public static DayOfWeek Saturday;
    public static DayOfWeek Sunday;
    public static DayOfWeek Thursday;
    public static DayOfWeek Tuesday;
    public static DayOfWeek Wednesday;
}
public class System.Decimal : ValueType {
    [DecimalConstantAttribute("0", "0", "4294967295", "4294967295", "4294967295")]
public static decimal MaxValue;
    [DecimalConstantAttribute("0", "128", "0", "0", "1")]
public static decimal MinusOne;
    [DecimalConstantAttribute("0", "128", "4294967295", "4294967295", "4294967295")]
public static decimal MinValue;
    [DecimalConstantAttribute("0", "0", "0", "0", "1")]
public static decimal One;
    [DecimalConstantAttribute("0", "0", "0", "0", "0")]
public static decimal Zero;
    [SecuritySafeCriticalAttribute]
public Decimal(double value);
    public Decimal(int value);
    public Decimal(int lo, int mid, int hi, bool isNegative, byte scale);
    public Decimal(Int32[] bits);
    public Decimal(long value);
    [SecuritySafeCriticalAttribute]
public Decimal(float value);
    [CLSCompliantAttribute("False")]
public Decimal(UInt32 value);
    [CLSCompliantAttribute("False")]
public Decimal(ulong value);
    [SecuritySafeCriticalAttribute]
public static decimal Add(decimal d1, decimal d2);
    public static decimal Ceiling(decimal d);
    [SecuritySafeCriticalAttribute]
public static int Compare(decimal d1, decimal d2);
    [SecuritySafeCriticalAttribute]
public sealed virtual int CompareTo(decimal value);
    [SecuritySafeCriticalAttribute]
public static decimal Divide(decimal d1, decimal d2);
    [SecuritySafeCriticalAttribute]
public sealed virtual bool Equals(decimal value);
    [SecuritySafeCriticalAttribute]
public static bool Equals(decimal d1, decimal d2);
    [SecuritySafeCriticalAttribute]
public virtual bool Equals(object value);
    [SecuritySafeCriticalAttribute]
public static decimal Floor(decimal d);
    public static Int32[] GetBits(decimal d);
    [SecuritySafeCriticalAttribute]
public virtual int GetHashCode();
    [SecuritySafeCriticalAttribute]
public static decimal Multiply(decimal d1, decimal d2);
    public static decimal Negate(decimal d);
    [SecuritySafeCriticalAttribute]
public static decimal op_Addition(decimal d1, decimal d2);
    public static decimal op_Decrement(decimal d);
    [SecuritySafeCriticalAttribute]
public static decimal op_Division(decimal d1, decimal d2);
    [SecuritySafeCriticalAttribute]
public static bool op_Equality(decimal d1, decimal d2);
    public static byte op_Explicit(decimal value);
    public static char op_Explicit(decimal value);
    public static double op_Explicit(decimal value);
    public static short op_Explicit(decimal value);
    public static int op_Explicit(decimal value);
    public static long op_Explicit(decimal value);
    [CLSCompliantAttribute("False")]
public static sbyte op_Explicit(decimal value);
    public static float op_Explicit(decimal value);
    [CLSCompliantAttribute("False")]
public static ushort op_Explicit(decimal value);
    [CLSCompliantAttribute("False")]
public static UInt32 op_Explicit(decimal value);
    [CLSCompliantAttribute("False")]
public static ulong op_Explicit(decimal value);
    public static decimal op_Explicit(double value);
    public static decimal op_Explicit(float value);
    [SecuritySafeCriticalAttribute]
public static bool op_GreaterThan(decimal d1, decimal d2);
    [SecuritySafeCriticalAttribute]
public static bool op_GreaterThanOrEqual(decimal d1, decimal d2);
    public static decimal op_Implicit(byte value);
    public static decimal op_Implicit(char value);
    public static decimal op_Implicit(short value);
    public static decimal op_Implicit(int value);
    public static decimal op_Implicit(long value);
    [CLSCompliantAttribute("False")]
public static decimal op_Implicit(sbyte value);
    [CLSCompliantAttribute("False")]
public static decimal op_Implicit(ushort value);
    [CLSCompliantAttribute("False")]
public static decimal op_Implicit(UInt32 value);
    [CLSCompliantAttribute("False")]
public static decimal op_Implicit(ulong value);
    public static decimal op_Increment(decimal d);
    [SecuritySafeCriticalAttribute]
public static bool op_Inequality(decimal d1, decimal d2);
    [SecuritySafeCriticalAttribute]
public static bool op_LessThan(decimal d1, decimal d2);
    [SecuritySafeCriticalAttribute]
public static bool op_LessThanOrEqual(decimal d1, decimal d2);
    public static decimal op_Modulus(decimal d1, decimal d2);
    [SecuritySafeCriticalAttribute]
public static decimal op_Multiply(decimal d1, decimal d2);
    [SecuritySafeCriticalAttribute]
public static decimal op_Subtraction(decimal d1, decimal d2);
    public static decimal op_UnaryNegation(decimal d);
    public static decimal op_UnaryPlus(decimal d);
    public static decimal Parse(string s);
    public static decimal Parse(string s, NumberStyles style);
    public static decimal Parse(string s, NumberStyles style, IFormatProvider provider);
    public static decimal Parse(string s, IFormatProvider provider);
    public static decimal Remainder(decimal d1, decimal d2);
    [SecuritySafeCriticalAttribute]
public static decimal Subtract(decimal d1, decimal d2);
    [SecuritySafeCriticalAttribute]
private sealed virtual override int System.IComparable.CompareTo(object value);
    public static byte ToByte(decimal value);
    [SecuritySafeCriticalAttribute]
public static double ToDouble(decimal d);
    public static short ToInt16(decimal value);
    [SecuritySafeCriticalAttribute]
public static int ToInt32(decimal d);
    [SecuritySafeCriticalAttribute]
public static long ToInt64(decimal d);
    [CLSCompliantAttribute("False")]
public static sbyte ToSByte(decimal value);
    [SecuritySafeCriticalAttribute]
public static float ToSingle(decimal d);
    [SecuritySafeCriticalAttribute]
public virtual string ToString();
    [SecuritySafeCriticalAttribute]
public string ToString(IFormatProvider provider);
    [SecuritySafeCriticalAttribute]
public string ToString(string format);
    [SecuritySafeCriticalAttribute]
public sealed virtual string ToString(string format, IFormatProvider provider);
    [CLSCompliantAttribute("False")]
public static ushort ToUInt16(decimal value);
    [CLSCompliantAttribute("False")]
[SecuritySafeCriticalAttribute]
public static UInt32 ToUInt32(decimal d);
    [SecuritySafeCriticalAttribute]
[CLSCompliantAttribute("False")]
public static ulong ToUInt64(decimal d);
    [SecuritySafeCriticalAttribute]
public static decimal Truncate(decimal d);
    public static bool TryParse(string s, Decimal& result);
    public static bool TryParse(string s, NumberStyles style, IFormatProvider provider, Decimal& result);
}
public abstract class System.Delegate : object {
    public object Target { get; }
    public object get_Target();
    public static Delegate Combine(Delegate a, Delegate b);
    public static Delegate Combine(Delegate[] delegates);
    public object DynamicInvoke(Object[] args);
    [SecuritySafeCriticalAttribute]
public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    public virtual Delegate[] GetInvocationList();
    public static bool op_Equality(Delegate d1, Delegate d2);
    public static bool op_Inequality(Delegate d1, Delegate d2);
    [SecuritySafeCriticalAttribute]
public static Delegate Remove(Delegate source, Delegate value);
    public static Delegate RemoveAll(Delegate source, Delegate value);
}
[AttributeUsageAttribute("68")]
public class System.Diagnostics.ConditionalAttribute : Attribute {
    public string ConditionString { get; }
    public ConditionalAttribute(string conditionString);
    public string get_ConditionString();
}
[AttributeUsageAttribute("3")]
public class System.Diagnostics.DebuggableAttribute : Attribute {
    public DebuggableAttribute(DebuggingModes modes);
}
public class System.DivideByZeroException : ArithmeticException {
    public DivideByZeroException(string message);
    public DivideByZeroException(string message, Exception innerException);
}
public class System.Double : ValueType {
    public static double MinValue;
    public static double MaxValue;
    public static double Epsilon;
    public static double NegativeInfinity;
    public static double PositiveInfinity;
    public static double NaN;
    public sealed virtual int CompareTo(double value);
    public sealed virtual bool Equals(double obj);
    public virtual bool Equals(object obj);
    [SecuritySafeCriticalAttribute]
public virtual int GetHashCode();
    [SecuritySafeCriticalAttribute]
public static bool IsInfinity(double d);
    [SecuritySafeCriticalAttribute]
public static bool IsNaN(double d);
    public static bool IsNegativeInfinity(double d);
    public static bool IsPositiveInfinity(double d);
    public static bool op_Equality(double left, double right);
    public static bool op_GreaterThan(double left, double right);
    public static bool op_GreaterThanOrEqual(double left, double right);
    public static bool op_Inequality(double left, double right);
    public static bool op_LessThan(double left, double right);
    public static bool op_LessThanOrEqual(double left, double right);
    public static double Parse(string s);
    public static double Parse(string s, NumberStyles style);
    public static double Parse(string s, NumberStyles style, IFormatProvider provider);
    public static double Parse(string s, IFormatProvider provider);
    private sealed virtual override int System.IComparable.CompareTo(object value);
    [SecuritySafeCriticalAttribute]
public virtual string ToString();
    [SecuritySafeCriticalAttribute]
public string ToString(IFormatProvider provider);
    [SecuritySafeCriticalAttribute]
public string ToString(string format);
    [SecuritySafeCriticalAttribute]
public sealed virtual string ToString(string format, IFormatProvider provider);
    public static bool TryParse(string s, Double& result);
    public static bool TryParse(string s, NumberStyles style, IFormatProvider provider, Double& result);
}
public abstract class System.Enum : ValueType {
    [SecuritySafeCriticalAttribute]
public sealed virtual int CompareTo(object target);
    [SecuritySafeCriticalAttribute]
public virtual bool Equals(object obj);
    public static string Format(Type enumType, object value, string format);
    public virtual int GetHashCode();
    public static string GetName(Type enumType, object value);
    public static String[] GetNames(Type enumType);
    public static Type GetUnderlyingType(Type enumType);
    public static Array GetValues(Type enumType);
    [SecuritySafeCriticalAttribute]
public bool HasFlag(Enum flag);
    public static bool IsDefined(Type enumType, object value);
    public static object Parse(Type enumType, string value);
    public static object Parse(Type enumType, string value, bool ignoreCase);
    [ObsoleteAttribute("The provider argument is not used. Please use ToString(String).")]
private sealed virtual override string System.IFormattable.ToString(string format, IFormatProvider provider);
    public static object ToObject(Type enumType, object value);
    public virtual string ToString();
    public string ToString(string format);
    public static bool TryParse(string value, TEnum& result);
    public static bool TryParse(string value, bool ignoreCase, TEnum& result);
}
public class System.EventArgs : object {
    public static EventArgs Empty;
}
public class System.EventHandler : MulticastDelegate {
    public EventHandler(object object, IntPtr method);
    public virtual void Invoke(object sender, EventArgs e);
    public virtual IAsyncResult BeginInvoke(object sender, EventArgs e, AsyncCallback callback, object object);
    public virtual void EndInvoke(IAsyncResult result);
}
public class System.EventHandler`1 : MulticastDelegate {
    public EventHandler`1(object object, IntPtr method);
    public virtual void Invoke(object sender, TEventArgs e);
    public virtual IAsyncResult BeginInvoke(object sender, TEventArgs e, AsyncCallback callback, object object);
    public virtual void EndInvoke(IAsyncResult result);
}
public class System.Exception : object {
    public IDictionary Data { get; }
    public string HelpLink { get; public set; }
    public int HResult { get; protected set; }
    public Exception InnerException { get; }
    public string Message { get; }
    public string Source { get; public set; }
    public string StackTrace { get; }
    public Exception(string message);
    public Exception(string message, Exception innerException);
    [SecuritySafeCriticalAttribute]
public virtual IDictionary get_Data();
    public virtual string get_HelpLink();
    public virtual void set_HelpLink(string value);
    public int get_HResult();
    protected void set_HResult(int value);
    public Exception get_InnerException();
    public virtual string get_Message();
    public virtual string get_Source();
    public virtual void set_Source(string value);
    public virtual string get_StackTrace();
    public virtual Exception GetBaseException();
    public virtual string ToString();
}
[AttributeUsageAttribute("16")]
public class System.FlagsAttribute : Attribute {
}
public class System.FormatException : Exception {
    public FormatException(string message);
    public FormatException(string message, Exception innerException);
}
public class System.Func`1 : MulticastDelegate {
    public Func`1(object object, IntPtr method);
    public virtual TResult Invoke();
    public virtual IAsyncResult BeginInvoke(AsyncCallback callback, object object);
    public virtual TResult EndInvoke(IAsyncResult result);
}
public class System.Func`10 : MulticastDelegate {
    public Func`10(object object, IntPtr method);
    public virtual TResult Invoke(T1 arg1, T2 arg2, T3 arg3, T4 arg4, T5 arg5, T6 arg6, T7 arg7, T8 arg8, T9 arg9);
    public virtual IAsyncResult BeginInvoke(T1 arg1, T2 arg2, T3 arg3, T4 arg4, T5 arg5, T6 arg6, T7 arg7, T8 arg8, T9 arg9, AsyncCallback callback, object object);
    public virtual TResult EndInvoke(IAsyncResult result);
}
public class System.Func`11 : MulticastDelegate {
    public Func`11(object object, IntPtr method);
    public virtual TResult Invoke(T1 arg1, T2 arg2, T3 arg3, T4 arg4, T5 arg5, T6 arg6, T7 arg7, T8 arg8, T9 arg9, T10 arg10);
    public virtual IAsyncResult BeginInvoke(T1 arg1, T2 arg2, T3 arg3, T4 arg4, T5 arg5, T6 arg6, T7 arg7, T8 arg8, T9 arg9, T10 arg10, AsyncCallback callback, object object);
    public virtual TResult EndInvoke(IAsyncResult result);
}
public class System.Func`12 : MulticastDelegate {
    public Func`12(object object, IntPtr method);
    public virtual TResult Invoke(T1 arg1, T2 arg2, T3 arg3, T4 arg4, T5 arg5, T6 arg6, T7 arg7, T8 arg8, T9 arg9, T10 arg10, T11 arg11);
    public virtual IAsyncResult BeginInvoke(T1 arg1, T2 arg2, T3 arg3, T4 arg4, T5 arg5, T6 arg6, T7 arg7, T8 arg8, T9 arg9, T10 arg10, T11 arg11, AsyncCallback callback, object object);
    public virtual TResult EndInvoke(IAsyncResult result);
}
public class System.Func`13 : MulticastDelegate {
    public Func`13(object object, IntPtr method);
    public virtual TResult Invoke(T1 arg1, T2 arg2, T3 arg3, T4 arg4, T5 arg5, T6 arg6, T7 arg7, T8 arg8, T9 arg9, T10 arg10, T11 arg11, T12 arg12);
    public virtual IAsyncResult BeginInvoke(T1 arg1, T2 arg2, T3 arg3, T4 arg4, T5 arg5, T6 arg6, T7 arg7, T8 arg8, T9 arg9, T10 arg10, T11 arg11, T12 arg12, AsyncCallback callback, object object);
    public virtual TResult EndInvoke(IAsyncResult result);
}
public class System.Func`14 : MulticastDelegate {
    public Func`14(object object, IntPtr method);
    public virtual TResult Invoke(T1 arg1, T2 arg2, T3 arg3, T4 arg4, T5 arg5, T6 arg6, T7 arg7, T8 arg8, T9 arg9, T10 arg10, T11 arg11, T12 arg12, T13 arg13);
    public virtual IAsyncResult BeginInvoke(T1 arg1, T2 arg2, T3 arg3, T4 arg4, T5 arg5, T6 arg6, T7 arg7, T8 arg8, T9 arg9, T10 arg10, T11 arg11, T12 arg12, T13 arg13, AsyncCallback callback, object object);
    public virtual TResult EndInvoke(IAsyncResult result);
}
public class System.Func`15 : MulticastDelegate {
    public Func`15(object object, IntPtr method);
    public virtual TResult Invoke(T1 arg1, T2 arg2, T3 arg3, T4 arg4, T5 arg5, T6 arg6, T7 arg7, T8 arg8, T9 arg9, T10 arg10, T11 arg11, T12 arg12, T13 arg13, T14 arg14);
    public virtual IAsyncResult BeginInvoke(T1 arg1, T2 arg2, T3 arg3, T4 arg4, T5 arg5, T6 arg6, T7 arg7, T8 arg8, T9 arg9, T10 arg10, T11 arg11, T12 arg12, T13 arg13, T14 arg14, AsyncCallback callback, object object);
    public virtual TResult EndInvoke(IAsyncResult result);
}
public class System.Func`16 : MulticastDelegate {
    public Func`16(object object, IntPtr method);
    public virtual TResult Invoke(T1 arg1, T2 arg2, T3 arg3, T4 arg4, T5 arg5, T6 arg6, T7 arg7, T8 arg8, T9 arg9, T10 arg10, T11 arg11, T12 arg12, T13 arg13, T14 arg14, T15 arg15);
    public virtual IAsyncResult BeginInvoke(T1 arg1, T2 arg2, T3 arg3, T4 arg4, T5 arg5, T6 arg6, T7 arg7, T8 arg8, T9 arg9, T10 arg10, T11 arg11, T12 arg12, T13 arg13, T14 arg14, T15 arg15, AsyncCallback callback, object object);
    public virtual TResult EndInvoke(IAsyncResult result);
}
public class System.Func`17 : MulticastDelegate {
    public Func`17(object object, IntPtr method);
    public virtual TResult Invoke(T1 arg1, T2 arg2, T3 arg3, T4 arg4, T5 arg5, T6 arg6, T7 arg7, T8 arg8, T9 arg9, T10 arg10, T11 arg11, T12 arg12, T13 arg13, T14 arg14, T15 arg15, T16 arg16);
    public virtual IAsyncResult BeginInvoke(T1 arg1, T2 arg2, T3 arg3, T4 arg4, T5 arg5, T6 arg6, T7 arg7, T8 arg8, T9 arg9, T10 arg10, T11 arg11, T12 arg12, T13 arg13, T14 arg14, T15 arg15, T16 arg16, AsyncCallback callback, object object);
    public virtual TResult EndInvoke(IAsyncResult result);
}
public class System.Func`2 : MulticastDelegate {
    public Func`2(object object, IntPtr method);
    public virtual TResult Invoke(T arg);
    public virtual IAsyncResult BeginInvoke(T arg, AsyncCallback callback, object object);
    public virtual TResult EndInvoke(IAsyncResult result);
}
public class System.Func`3 : MulticastDelegate {
    public Func`3(object object, IntPtr method);
    public virtual TResult Invoke(T1 arg1, T2 arg2);
    public virtual IAsyncResult BeginInvoke(T1 arg1, T2 arg2, AsyncCallback callback, object object);
    public virtual TResult EndInvoke(IAsyncResult result);
}
public class System.Func`4 : MulticastDelegate {
    public Func`4(object object, IntPtr method);
    public virtual TResult Invoke(T1 arg1, T2 arg2, T3 arg3);
    public virtual IAsyncResult BeginInvoke(T1 arg1, T2 arg2, T3 arg3, AsyncCallback callback, object object);
    public virtual TResult EndInvoke(IAsyncResult result);
}
public class System.Func`5 : MulticastDelegate {
    public Func`5(object object, IntPtr method);
    public virtual TResult Invoke(T1 arg1, T2 arg2, T3 arg3, T4 arg4);
    public virtual IAsyncResult BeginInvoke(T1 arg1, T2 arg2, T3 arg3, T4 arg4, AsyncCallback callback, object object);
    public virtual TResult EndInvoke(IAsyncResult result);
}
public class System.Func`6 : MulticastDelegate {
    public Func`6(object object, IntPtr method);
    public virtual TResult Invoke(T1 arg1, T2 arg2, T3 arg3, T4 arg4, T5 arg5);
    public virtual IAsyncResult BeginInvoke(T1 arg1, T2 arg2, T3 arg3, T4 arg4, T5 arg5, AsyncCallback callback, object object);
    public virtual TResult EndInvoke(IAsyncResult result);
}
public class System.Func`7 : MulticastDelegate {
    public Func`7(object object, IntPtr method);
    public virtual TResult Invoke(T1 arg1, T2 arg2, T3 arg3, T4 arg4, T5 arg5, T6 arg6);
    public virtual IAsyncResult BeginInvoke(T1 arg1, T2 arg2, T3 arg3, T4 arg4, T5 arg5, T6 arg6, AsyncCallback callback, object object);
    public virtual TResult EndInvoke(IAsyncResult result);
}
public class System.Func`8 : MulticastDelegate {
    public Func`8(object object, IntPtr method);
    public virtual TResult Invoke(T1 arg1, T2 arg2, T3 arg3, T4 arg4, T5 arg5, T6 arg6, T7 arg7);
    public virtual IAsyncResult BeginInvoke(T1 arg1, T2 arg2, T3 arg3, T4 arg4, T5 arg5, T6 arg6, T7 arg7, AsyncCallback callback, object object);
    public virtual TResult EndInvoke(IAsyncResult result);
}
public class System.Func`9 : MulticastDelegate {
    public Func`9(object object, IntPtr method);
    public virtual TResult Invoke(T1 arg1, T2 arg2, T3 arg3, T4 arg4, T5 arg5, T6 arg6, T7 arg7, T8 arg8);
    public virtual IAsyncResult BeginInvoke(T1 arg1, T2 arg2, T3 arg3, T4 arg4, T5 arg5, T6 arg6, T7 arg7, T8 arg8, AsyncCallback callback, object object);
    public virtual TResult EndInvoke(IAsyncResult result);
}
public static class System.GC : object {
    public static int MaxGeneration { get; }
    [SecuritySafeCriticalAttribute]
public static int get_MaxGeneration();
    [SecurityCriticalAttribute]
public static void AddMemoryPressure(long bytesAllocated);
    [SecuritySafeCriticalAttribute]
public static void Collect();
    public static void Collect(int generation);
    [SecuritySafeCriticalAttribute]
public static void Collect(int generation, GCCollectionMode mode);
    [SecuritySafeCriticalAttribute]
public static void Collect(int generation, GCCollectionMode mode, bool blocking);
    [SecuritySafeCriticalAttribute]
public static int CollectionCount(int generation);
    [SecuritySafeCriticalAttribute]
public static long GetTotalMemory(bool forceFullCollection);
    public static void KeepAlive(object obj);
    [SecurityCriticalAttribute]
public static void RemoveMemoryPressure(long bytesAllocated);
    [SecuritySafeCriticalAttribute]
public static void ReRegisterForFinalize(object obj);
    [SecuritySafeCriticalAttribute]
public static void SuppressFinalize(object obj);
    [SecuritySafeCriticalAttribute]
public static void WaitForPendingFinalizers();
}
public enum System.GCCollectionMode : Enum {
    public int value__;
    public static GCCollectionMode Default;
    public static GCCollectionMode Forced;
    public static GCCollectionMode Optimized;
}
[FlagsAttribute]
public enum System.Globalization.DateTimeStyles : Enum {
    public int value__;
    public static DateTimeStyles AdjustToUniversal;
    public static DateTimeStyles AllowInnerWhite;
    public static DateTimeStyles AllowLeadingWhite;
    public static DateTimeStyles AllowTrailingWhite;
    public static DateTimeStyles AllowWhiteSpaces;
    public static DateTimeStyles AssumeLocal;
    public static DateTimeStyles AssumeUniversal;
    public static DateTimeStyles NoCurrentDateDefault;
    public static DateTimeStyles None;
    public static DateTimeStyles RoundtripKind;
}
[FlagsAttribute]
public enum System.Globalization.NumberStyles : Enum {
    public int value__;
    public static NumberStyles AllowCurrencySymbol;
    public static NumberStyles AllowDecimalPoint;
    public static NumberStyles AllowExponent;
    public static NumberStyles AllowHexSpecifier;
    public static NumberStyles AllowLeadingSign;
    public static NumberStyles AllowLeadingWhite;
    public static NumberStyles AllowParentheses;
    public static NumberStyles AllowThousands;
    public static NumberStyles AllowTrailingSign;
    public static NumberStyles AllowTrailingWhite;
    public static NumberStyles Any;
    public static NumberStyles Currency;
    public static NumberStyles Float;
    public static NumberStyles HexNumber;
    public static NumberStyles Integer;
    public static NumberStyles None;
    public static NumberStyles Number;
}
[FlagsAttribute]
public enum System.Globalization.TimeSpanStyles : Enum {
    public int value__;
    public static TimeSpanStyles AssumeNegative;
    public static TimeSpanStyles None;
}
public class System.Guid : ValueType {
    public static Guid Empty;
    public Guid(Byte[] b);
    public Guid(int a, short b, short c, byte d, byte e, byte f, byte g, byte h, byte i, byte j, byte k);
    public Guid(int a, short b, short c, Byte[] d);
    public Guid(string g);
    public sealed virtual int CompareTo(Guid value);
    public sealed virtual bool Equals(Guid g);
    public virtual bool Equals(object o);
    public virtual int GetHashCode();
    [SecuritySafeCriticalAttribute]
public static Guid NewGuid();
    public static bool op_Equality(Guid a, Guid b);
    public static bool op_Inequality(Guid a, Guid b);
    public static Guid Parse(string input);
    public static Guid ParseExact(string input, string format);
    private sealed virtual override int System.IComparable.CompareTo(object value);
    private sealed virtual override string System.IFormattable.ToString(string format, IFormatProvider provider);
    public Byte[] ToByteArray();
    public virtual string ToString();
    public string ToString(string format);
    public static bool TryParse(string input, Guid& result);
    public static bool TryParseExact(string input, string format, Guid& result);
}
public interface System.IAsyncResult {
    public object AsyncState { get; }
    public WaitHandle AsyncWaitHandle { get; }
    public bool CompletedSynchronously { get; }
    public bool IsCompleted { get; }
    public abstract virtual object get_AsyncState();
    public abstract virtual WaitHandle get_AsyncWaitHandle();
    public abstract virtual bool get_CompletedSynchronously();
    public abstract virtual bool get_IsCompleted();
}
public interface System.IComparable {
    public abstract virtual int CompareTo(object obj);
}
public interface System.IComparable`1 {
    public abstract virtual int CompareTo(T other);
}
public interface System.ICustomFormatter {
    public abstract virtual string Format(string format, object arg, IFormatProvider formatProvider);
}
public interface System.IDisposable {
    public abstract virtual void Dispose();
}
public interface System.IEquatable`1 {
    public abstract virtual bool Equals(T other);
}
public interface System.IFormatProvider {
    public abstract virtual object GetFormat(Type formatType);
}
public interface System.IFormattable {
    public abstract virtual string ToString(string format, IFormatProvider formatProvider);
}
public class System.IndexOutOfRangeException : Exception {
    public IndexOutOfRangeException(string message);
    public IndexOutOfRangeException(string message, Exception innerException);
}
public class System.Int16 : ValueType {
    public static short MaxValue;
    public static short MinValue;
    public sealed virtual int CompareTo(short value);
    public sealed virtual bool Equals(short obj);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    public static short Parse(string s);
    public static short Parse(string s, NumberStyles style);
    public static short Parse(string s, NumberStyles style, IFormatProvider provider);
    public static short Parse(string s, IFormatProvider provider);
    private sealed virtual override int System.IComparable.CompareTo(object value);
    [SecuritySafeCriticalAttribute]
public virtual string ToString();
    [SecuritySafeCriticalAttribute]
public string ToString(IFormatProvider provider);
    public string ToString(string format);
    public sealed virtual string ToString(string format, IFormatProvider provider);
    public static bool TryParse(string s, NumberStyles style, IFormatProvider provider, Int16& result);
    public static bool TryParse(string s, Int16& result);
}
public class System.Int32 : ValueType {
    public static int MaxValue;
    public static int MinValue;
    public sealed virtual int CompareTo(int value);
    public sealed virtual bool Equals(int obj);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    public static int Parse(string s);
    public static int Parse(string s, NumberStyles style);
    public static int Parse(string s, NumberStyles style, IFormatProvider provider);
    public static int Parse(string s, IFormatProvider provider);
    private sealed virtual override int System.IComparable.CompareTo(object value);
    [SecuritySafeCriticalAttribute]
public virtual string ToString();
    [SecuritySafeCriticalAttribute]
public string ToString(IFormatProvider provider);
    [SecuritySafeCriticalAttribute]
public string ToString(string format);
    [SecuritySafeCriticalAttribute]
public sealed virtual string ToString(string format, IFormatProvider provider);
    public static bool TryParse(string s, NumberStyles style, IFormatProvider provider, Int32& result);
    public static bool TryParse(string s, Int32& result);
}
public class System.Int64 : ValueType {
    public static long MaxValue;
    public static long MinValue;
    public sealed virtual int CompareTo(long value);
    public sealed virtual bool Equals(long obj);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    public static long Parse(string s);
    public static long Parse(string s, NumberStyles style);
    public static long Parse(string s, NumberStyles style, IFormatProvider provider);
    public static long Parse(string s, IFormatProvider provider);
    private sealed virtual override int System.IComparable.CompareTo(object value);
    [SecuritySafeCriticalAttribute]
public virtual string ToString();
    [SecuritySafeCriticalAttribute]
public string ToString(IFormatProvider provider);
    [SecuritySafeCriticalAttribute]
public string ToString(string format);
    [SecuritySafeCriticalAttribute]
public sealed virtual string ToString(string format, IFormatProvider provider);
    public static bool TryParse(string s, NumberStyles style, IFormatProvider provider, Int64& result);
    public static bool TryParse(string s, Int64& result);
}
public class System.IntPtr : ValueType {
    public static IntPtr Zero;
    public static int Size { get; }
    [SecuritySafeCriticalAttribute]
public IntPtr(int value);
    [SecuritySafeCriticalAttribute]
public IntPtr(long value);
    [SecurityCriticalAttribute]
[CLSCompliantAttribute("False")]
public IntPtr(Void* value);
    public static int get_Size();
    public static IntPtr Add(IntPtr pointer, int offset);
    [SecuritySafeCriticalAttribute]
public virtual bool Equals(object obj);
    [SecuritySafeCriticalAttribute]
public virtual int GetHashCode();
    public static IntPtr op_Addition(IntPtr pointer, int offset);
    [SecuritySafeCriticalAttribute]
public static bool op_Equality(IntPtr value1, IntPtr value2);
    public static IntPtr op_Explicit(int value);
    public static IntPtr op_Explicit(long value);
    [SecuritySafeCriticalAttribute]
public static int op_Explicit(IntPtr value);
    [SecuritySafeCriticalAttribute]
public static long op_Explicit(IntPtr value);
    [SecuritySafeCriticalAttribute]
[CLSCompliantAttribute("False")]
public static Void* op_Explicit(IntPtr value);
    [CLSCompliantAttribute("False")]
[SecurityCriticalAttribute]
public static IntPtr op_Explicit(Void* value);
    [SecuritySafeCriticalAttribute]
public static bool op_Inequality(IntPtr value1, IntPtr value2);
    public static IntPtr op_Subtraction(IntPtr pointer, int offset);
    public static IntPtr Subtract(IntPtr pointer, int offset);
    [SecuritySafeCriticalAttribute]
public int ToInt32();
    [SecuritySafeCriticalAttribute]
public long ToInt64();
    [CLSCompliantAttribute("False")]
[SecuritySafeCriticalAttribute]
public Void* ToPointer();
    [SecuritySafeCriticalAttribute]
public virtual string ToString();
    [SecuritySafeCriticalAttribute]
public string ToString(string format);
}
public class System.InvalidCastException : Exception {
    public InvalidCastException(string message);
    public InvalidCastException(string message, Exception innerException);
    public InvalidCastException(string message, int errorCode);
}
public class System.InvalidOperationException : Exception {
    public InvalidOperationException(string message);
    public InvalidOperationException(string message, Exception innerException);
}
public class System.InvalidTimeZoneException : Exception {
    public InvalidTimeZoneException(string message);
    public InvalidTimeZoneException(string message, Exception innerException);
}
public interface System.IObservable`1 {
    public abstract virtual IDisposable Subscribe(IObserver`1<T> observer);
}
public interface System.IObserver`1 {
    public abstract virtual void OnCompleted();
    public abstract virtual void OnError(Exception error);
    public abstract virtual void OnNext(T value);
}
public interface System.IProgress`1 {
    public abstract virtual void Report(T value);
}
public class System.Lazy`1 : object {
    public bool IsValueCreated { get; }
    public T Value { get; }
    public Lazy`1(bool isThreadSafe);
    public Lazy`1(Func`1<T> valueFactory);
    public Lazy`1(Func`1<T> valueFactory, bool isThreadSafe);
    public Lazy`1(Func`1<T> valueFactory, LazyThreadSafetyMode mode);
    public Lazy`1(LazyThreadSafetyMode mode);
    public bool get_IsValueCreated();
    public T get_Value();
    public virtual string ToString();
}
public class System.Lazy`2 : Lazy`1<T> {
    public TMetadata Metadata { get; }
    public Lazy`2(TMetadata metadata);
    public Lazy`2(TMetadata metadata, bool isThreadSafe);
    public Lazy`2(TMetadata metadata, LazyThreadSafetyMode mode);
    public Lazy`2(Func`1<T> valueFactory, TMetadata metadata);
    public Lazy`2(Func`1<T> valueFactory, TMetadata metadata, bool isThreadSafe);
    public Lazy`2(Func`1<T> valueFactory, TMetadata metadata, LazyThreadSafetyMode mode);
    public TMetadata get_Metadata();
}
public class System.MemberAccessException : Exception {
    public MemberAccessException(string message);
    public MemberAccessException(string message, Exception inner);
}
public class System.MissingMemberException : MemberAccessException {
    public string Message { get; }
    public MissingMemberException(string message);
    public MissingMemberException(string message, Exception inner);
    [SecuritySafeCriticalAttribute]
public virtual string get_Message();
}
[AttributeUsageAttribute("64")]
public class System.MTAThreadAttribute : Attribute {
}
public abstract class System.MulticastDelegate : Delegate {
    [SecuritySafeCriticalAttribute]
public sealed virtual bool Equals(object obj);
    [SecuritySafeCriticalAttribute]
public sealed virtual int GetHashCode();
    [SecuritySafeCriticalAttribute]
public sealed virtual Delegate[] GetInvocationList();
    public static bool op_Equality(MulticastDelegate d1, MulticastDelegate d2);
    public static bool op_Inequality(MulticastDelegate d1, MulticastDelegate d2);
}
public class System.NotImplementedException : Exception {
    public NotImplementedException(string message);
    public NotImplementedException(string message, Exception inner);
}
public class System.NotSupportedException : Exception {
    public NotSupportedException(string message);
    public NotSupportedException(string message, Exception innerException);
}
public static class System.Nullable : object {
    public static int Compare(Nullable`1<T> n1, Nullable`1<T> n2);
    public static bool Equals(Nullable`1<T> n1, Nullable`1<T> n2);
    public static Type GetUnderlyingType(Type nullableType);
}
public class System.Nullable`1 : ValueType {
    public bool HasValue { get; }
    public T Value { get; }
    public Nullable`1(T value);
    public bool get_HasValue();
    public T get_Value();
    public virtual bool Equals(object other);
    public virtual int GetHashCode();
    public T GetValueOrDefault();
    public T GetValueOrDefault(T defaultValue);
    public static T op_Explicit(Nullable`1<T> value);
    public static Nullable`1<T> op_Implicit(T value);
    public virtual string ToString();
}
public class System.NullReferenceException : Exception {
    public NullReferenceException(string message);
    public NullReferenceException(string message, Exception innerException);
}
public class System.Object {
    public virtual bool Equals(object obj);
    public static bool Equals(object objA, object objB);
    protected virtual void Finalize();
    public virtual int GetHashCode();
    [SecuritySafeCriticalAttribute]
public Type GetType();
    [SecuritySafeCriticalAttribute]
protected object MemberwiseClone();
    public static bool ReferenceEquals(object objA, object objB);
    public virtual string ToString();
}
public class System.ObjectDisposedException : InvalidOperationException {
    public string Message { get; }
    public string ObjectName { get; }
    public ObjectDisposedException(string objectName);
    public ObjectDisposedException(string message, Exception innerException);
    public ObjectDisposedException(string objectName, string message);
    public virtual string get_Message();
    public string get_ObjectName();
}
[AttributeUsageAttribute("6140")]
public class System.ObsoleteAttribute : Attribute {
    public bool IsError { get; }
    public string Message { get; }
    public ObsoleteAttribute(string message);
    public ObsoleteAttribute(string message, bool error);
    public bool get_IsError();
    public string get_Message();
}
public class System.OutOfMemoryException : Exception {
    public OutOfMemoryException(string message);
    public OutOfMemoryException(string message, Exception innerException);
}
public class System.OverflowException : ArithmeticException {
    public OverflowException(string message);
    public OverflowException(string message, Exception innerException);
}
[AttributeUsageAttribute("2048")]
public class System.ParamArrayAttribute : Attribute {
}
public class System.PlatformNotSupportedException : NotSupportedException {
    public PlatformNotSupportedException(string message);
    public PlatformNotSupportedException(string message, Exception inner);
}
public class System.Predicate`1 : MulticastDelegate {
    public Predicate`1(object object, IntPtr method);
    public virtual bool Invoke(T obj);
    public virtual IAsyncResult BeginInvoke(T obj, AsyncCallback callback, object object);
    public virtual bool EndInvoke(IAsyncResult result);
}
public class System.RankException : Exception {
    public RankException(string message);
    public RankException(string message, Exception innerException);
}
[AttributeUsageAttribute("1")]
public class System.Reflection.AssemblyCompanyAttribute : Attribute {
    public string Company { get; }
    public AssemblyCompanyAttribute(string company);
    public string get_Company();
}
[AttributeUsageAttribute("1")]
public class System.Reflection.AssemblyConfigurationAttribute : Attribute {
    public string Configuration { get; }
    public AssemblyConfigurationAttribute(string configuration);
    public string get_Configuration();
}
[AttributeUsageAttribute("1")]
public class System.Reflection.AssemblyCopyrightAttribute : Attribute {
    public string Copyright { get; }
    public AssemblyCopyrightAttribute(string copyright);
    public string get_Copyright();
}
[AttributeUsageAttribute("1")]
public class System.Reflection.AssemblyCultureAttribute : Attribute {
    public string Culture { get; }
    public AssemblyCultureAttribute(string culture);
    public string get_Culture();
}
[AttributeUsageAttribute("1")]
public class System.Reflection.AssemblyDefaultAliasAttribute : Attribute {
    public string DefaultAlias { get; }
    public AssemblyDefaultAliasAttribute(string defaultAlias);
    public string get_DefaultAlias();
}
[AttributeUsageAttribute("1")]
public class System.Reflection.AssemblyDelaySignAttribute : Attribute {
    public bool DelaySign { get; }
    public AssemblyDelaySignAttribute(bool delaySign);
    public bool get_DelaySign();
}
[AttributeUsageAttribute("1")]
public class System.Reflection.AssemblyDescriptionAttribute : Attribute {
    public string Description { get; }
    public AssemblyDescriptionAttribute(string description);
    public string get_Description();
}
[AttributeUsageAttribute("1")]
public class System.Reflection.AssemblyFileVersionAttribute : Attribute {
    public string Version { get; }
    public AssemblyFileVersionAttribute(string version);
    public string get_Version();
}
[AttributeUsageAttribute("1")]
public class System.Reflection.AssemblyFlagsAttribute : Attribute {
    public int AssemblyFlags { get; }
    public AssemblyFlagsAttribute(AssemblyNameFlags assemblyFlags);
    public int get_AssemblyFlags();
}
[AttributeUsageAttribute("1")]
public class System.Reflection.AssemblyInformationalVersionAttribute : Attribute {
    public string InformationalVersion { get; }
    public AssemblyInformationalVersionAttribute(string informationalVersion);
    public string get_InformationalVersion();
}
[AttributeUsageAttribute("1")]
public class System.Reflection.AssemblyKeyFileAttribute : Attribute {
    public string KeyFile { get; }
    public AssemblyKeyFileAttribute(string keyFile);
    public string get_KeyFile();
}
[AttributeUsageAttribute("1")]
public class System.Reflection.AssemblyKeyNameAttribute : Attribute {
    public string KeyName { get; }
    public AssemblyKeyNameAttribute(string keyName);
    public string get_KeyName();
}
[AttributeUsageAttribute("1")]
public class System.Reflection.AssemblyMetadataAttribute : Attribute {
    public string Key { get; }
    public string Value { get; }
    public AssemblyMetadataAttribute(string key, string value);
    public string get_Key();
    public string get_Value();
}
[FlagsAttribute]
public enum System.Reflection.AssemblyNameFlags : Enum {
    public int value__;
    public static AssemblyNameFlags None;
    public static AssemblyNameFlags PublicKey;
    public static AssemblyNameFlags Retargetable;
}
[AttributeUsageAttribute("1")]
public class System.Reflection.AssemblyProductAttribute : Attribute {
    public string Product { get; }
    public AssemblyProductAttribute(string product);
    public string get_Product();
}
[AttributeUsageAttribute("1")]
public class System.Reflection.AssemblySignatureKeyAttribute : Attribute {
    public string Countersignature { get; }
    public string PublicKey { get; }
    public AssemblySignatureKeyAttribute(string publicKey, string countersignature);
    public string get_Countersignature();
    public string get_PublicKey();
}
[AttributeUsageAttribute("1")]
public class System.Reflection.AssemblyTitleAttribute : Attribute {
    public string Title { get; }
    public AssemblyTitleAttribute(string title);
    public string get_Title();
}
[AttributeUsageAttribute("1")]
public class System.Reflection.AssemblyTrademarkAttribute : Attribute {
    public string Trademark { get; }
    public AssemblyTrademarkAttribute(string trademark);
    public string get_Trademark();
}
[AttributeUsageAttribute("1")]
public class System.Reflection.AssemblyVersionAttribute : Attribute {
    public string Version { get; }
    public AssemblyVersionAttribute(string version);
    public string get_Version();
}
[AttributeUsageAttribute("1036")]
public class System.Reflection.DefaultMemberAttribute : Attribute {
    public string MemberName { get; }
    public DefaultMemberAttribute(string memberName);
    public string get_MemberName();
}
[AttributeUsageAttribute("256")]
public class System.Runtime.CompilerServices.AccessedThroughPropertyAttribute : Attribute {
    public string PropertyName { get; }
    public AccessedThroughPropertyAttribute(string propertyName);
    public string get_PropertyName();
}
[AttributeUsageAttribute("64")]
public class System.Runtime.CompilerServices.AsyncStateMachineAttribute : StateMachineAttribute {
    public AsyncStateMachineAttribute(Type stateMachineType);
}
[AttributeUsageAttribute("2048")]
public class System.Runtime.CompilerServices.CallerFilePathAttribute : Attribute {
}
[AttributeUsageAttribute("2048")]
public class System.Runtime.CompilerServices.CallerLineNumberAttribute : Attribute {
}
[AttributeUsageAttribute("2048")]
public class System.Runtime.CompilerServices.CallerMemberNameAttribute : Attribute {
}
[AttributeUsageAttribute("71")]
public class System.Runtime.CompilerServices.CompilationRelaxationsAttribute : Attribute {
    public int CompilationRelaxations { get; }
    public CompilationRelaxationsAttribute(int relaxations);
    public int get_CompilationRelaxations();
}
[AttributeUsageAttribute("32767")]
public class System.Runtime.CompilerServices.CompilerGeneratedAttribute : Attribute {
}
[AttributeUsageAttribute("2304")]
public abstract class System.Runtime.CompilerServices.CustomConstantAttribute : Attribute {
    public object Value { get; }
    public abstract virtual object get_Value();
}
[AttributeUsageAttribute("2304")]
public class System.Runtime.CompilerServices.DateTimeConstantAttribute : CustomConstantAttribute {
    public object Value { get; }
    public DateTimeConstantAttribute(long ticks);
    public virtual object get_Value();
}
[AttributeUsageAttribute("2304")]
public class System.Runtime.CompilerServices.DecimalConstantAttribute : Attribute {
    public decimal Value { get; }
    public DecimalConstantAttribute(byte scale, byte sign, int hi, int mid, int low);
    [CLSCompliantAttribute("False")]
public DecimalConstantAttribute(byte scale, byte sign, UInt32 hi, UInt32 mid, UInt32 low);
    public decimal get_Value();
}
[AttributeUsageAttribute("69")]
public class System.Runtime.CompilerServices.ExtensionAttribute : Attribute {
}
[AttributeUsageAttribute("256")]
public class System.Runtime.CompilerServices.FixedBufferAttribute : Attribute {
    public Type ElementType { get; }
    public int Length { get; }
    public FixedBufferAttribute(Type elementType, int length);
    public Type get_ElementType();
    public int get_Length();
}
[AttributeUsageAttribute("128")]
public class System.Runtime.CompilerServices.IndexerNameAttribute : Attribute {
    public IndexerNameAttribute(string indexerName);
}
[AttributeUsageAttribute("1")]
public class System.Runtime.CompilerServices.InternalsVisibleToAttribute : Attribute {
    public string AssemblyName { get; }
    public InternalsVisibleToAttribute(string assemblyName);
    public string get_AssemblyName();
}
public interface System.Runtime.CompilerServices.IStrongBox {
    public object Value { get; public set; }
    public abstract virtual object get_Value();
    public abstract virtual void set_Value(object value);
}
public static class System.Runtime.CompilerServices.IsVolatile : object {
}
[AttributeUsageAttribute("64")]
public class System.Runtime.CompilerServices.IteratorStateMachineAttribute : StateMachineAttribute {
    public IteratorStateMachineAttribute(Type stateMachineType);
}
[AttributeUsageAttribute("96")]
public class System.Runtime.CompilerServices.MethodImplAttribute : Attribute {
    public MethodImplOptions Value { get; }
    public MethodImplAttribute(MethodImplOptions methodImplOptions);
    public MethodImplOptions get_Value();
}
[FlagsAttribute]
public enum System.Runtime.CompilerServices.MethodImplOptions : Enum {
    public int value__;
    public static MethodImplOptions AggressiveInlining;
    public static MethodImplOptions NoInlining;
    public static MethodImplOptions NoOptimization;
    public static MethodImplOptions PreserveSig;
}
[AttributeUsageAttribute("1")]
public class System.Runtime.CompilerServices.ReferenceAssemblyAttribute : Attribute {
    public string Description { get; }
    public ReferenceAssemblyAttribute(string description);
    public string get_Description();
}
[AttributeUsageAttribute("1")]
public class System.Runtime.CompilerServices.RuntimeCompatibilityAttribute : Attribute {
    public bool WrapNonExceptionThrows { get; public set; }
    public bool get_WrapNonExceptionThrows();
    public void set_WrapNonExceptionThrows(bool value);
}
public static class System.Runtime.CompilerServices.RuntimeHelpers : object {
    public static int OffsetToStringData { get; }
    public static int get_OffsetToStringData();
    [SecuritySafeCriticalAttribute]
public static int GetHashCode(object o);
    [SecuritySafeCriticalAttribute]
public static object GetObjectValue(object obj);
    [SecuritySafeCriticalAttribute]
public static void InitializeArray(Array array, RuntimeFieldHandle fldHandle);
    public static void RunClassConstructor(RuntimeTypeHandle type);
}
[AttributeUsageAttribute("64")]
public class System.Runtime.CompilerServices.StateMachineAttribute : Attribute {
    public Type StateMachineType { get; }
    public StateMachineAttribute(Type stateMachineType);
    public Type get_StateMachineType();
}
public class System.Runtime.CompilerServices.StrongBox`1 : object {
    public T Value;
    private object System.Runtime.CompilerServices.IStrongBox.Value { get; private set; }
    public StrongBox`1(T value);
    private sealed virtual override object System.Runtime.CompilerServices.IStrongBox.get_Value();
    private sealed virtual override void System.Runtime.CompilerServices.IStrongBox.set_Value(object value);
}
[AttributeUsageAttribute("5148")]
public class System.Runtime.CompilerServices.TypeForwardedFromAttribute : Attribute {
    public string AssemblyFullName { get; }
    public TypeForwardedFromAttribute(string assemblyFullName);
    public string get_AssemblyFullName();
}
[AttributeUsageAttribute("1")]
public class System.Runtime.CompilerServices.TypeForwardedToAttribute : Attribute {
    public Type Destination { get; }
    public TypeForwardedToAttribute(Type destination);
    public Type get_Destination();
}
[AttributeUsageAttribute("8")]
public class System.Runtime.CompilerServices.UnsafeValueTypeAttribute : Attribute {
}
public class System.Runtime.ExceptionServices.ExceptionDispatchInfo : object {
    public Exception SourceException { get; }
    public Exception get_SourceException();
    public static ExceptionDispatchInfo Capture(Exception source);
    public void Throw();
}
public enum System.Runtime.GCLargeObjectHeapCompactionMode : Enum {
    public int value__;
    public static GCLargeObjectHeapCompactionMode Default;
    public static GCLargeObjectHeapCompactionMode CompactOnce;
}
public enum System.Runtime.GCLatencyMode : Enum {
    public int value__;
    public static GCLatencyMode Batch;
    public static GCLatencyMode Interactive;
    public static GCLatencyMode LowLatency;
    public static GCLatencyMode SustainedLowLatency;
}
public static class System.Runtime.GCSettings : object {
    public static bool IsServerGC { get; }
    public static GCLatencyMode LatencyMode { get; public set; }
    public static GCLargeObjectHeapCompactionMode LargeObjectHeapCompactionMode { get; public set; }
    [SecuritySafeCriticalAttribute]
public static bool get_IsServerGC();
    [SecuritySafeCriticalAttribute]
public static GCLatencyMode get_LatencyMode();
    [SecurityCriticalAttribute]
public static void set_LatencyMode(GCLatencyMode value);
    [SecuritySafeCriticalAttribute]
public static GCLargeObjectHeapCompactionMode get_LargeObjectHeapCompactionMode();
    [SecurityCriticalAttribute]
public static void set_LargeObjectHeapCompactionMode(GCLargeObjectHeapCompactionMode value);
}
public enum System.Runtime.InteropServices.CharSet : Enum {
    public int value__;
    public static CharSet Ansi;
    public static CharSet Unicode;
}
[AttributeUsageAttribute("5597")]
public class System.Runtime.InteropServices.ComVisibleAttribute : Attribute {
    public bool Value { get; }
    public ComVisibleAttribute(bool visibility);
    public bool get_Value();
}
[AttributeUsageAttribute("256")]
public class System.Runtime.InteropServices.FieldOffsetAttribute : Attribute {
    public int Value { get; }
    public FieldOffsetAttribute(int offset);
    public int get_Value();
}
public enum System.Runtime.InteropServices.LayoutKind : Enum {
    public int value__;
    public static LayoutKind Auto;
    public static LayoutKind Explicit;
    public static LayoutKind Sequential;
}
[AttributeUsageAttribute("2048")]
public class System.Runtime.InteropServices.OutAttribute : Attribute {
}
[AttributeUsageAttribute("12")]
public class System.Runtime.InteropServices.StructLayoutAttribute : Attribute {
    public CharSet CharSet;
    public int Pack;
    public int Size;
    public LayoutKind Value { get; }
    public StructLayoutAttribute(LayoutKind layoutKind);
    public LayoutKind get_Value();
}
[AttributeUsageAttribute("1")]
public class System.Runtime.Versioning.TargetFrameworkAttribute : Attribute {
    public string FrameworkDisplayName { get; public set; }
    public string FrameworkName { get; }
    public TargetFrameworkAttribute(string frameworkName);
    public string get_FrameworkDisplayName();
    public void set_FrameworkDisplayName(string value);
    public string get_FrameworkName();
}
public class System.RuntimeFieldHandle : ValueType {
    [SecuritySafeCriticalAttribute]
public virtual bool Equals(object obj);
    [SecuritySafeCriticalAttribute]
public bool Equals(RuntimeFieldHandle handle);
    [SecuritySafeCriticalAttribute]
public virtual int GetHashCode();
    public static bool op_Equality(RuntimeFieldHandle left, RuntimeFieldHandle right);
    public static bool op_Inequality(RuntimeFieldHandle left, RuntimeFieldHandle right);
}
public class System.RuntimeMethodHandle : ValueType {
    [SecuritySafeCriticalAttribute]
public virtual bool Equals(object obj);
    [SecuritySafeCriticalAttribute]
public bool Equals(RuntimeMethodHandle handle);
    [SecuritySafeCriticalAttribute]
public virtual int GetHashCode();
    public static bool op_Equality(RuntimeMethodHandle left, RuntimeMethodHandle right);
    public static bool op_Inequality(RuntimeMethodHandle left, RuntimeMethodHandle right);
}
public class System.RuntimeTypeHandle : ValueType {
    public virtual bool Equals(object obj);
    public bool Equals(RuntimeTypeHandle handle);
    public virtual int GetHashCode();
    public static bool op_Equality(object left, RuntimeTypeHandle right);
    public static bool op_Equality(RuntimeTypeHandle left, object right);
    public static bool op_Inequality(object left, RuntimeTypeHandle right);
    public static bool op_Inequality(RuntimeTypeHandle left, object right);
}
[CLSCompliantAttribute("False")]
public class System.SByte : ValueType {
    public static sbyte MaxValue;
    public static sbyte MinValue;
    public sealed virtual int CompareTo(sbyte value);
    public virtual bool Equals(object obj);
    public sealed virtual bool Equals(sbyte obj);
    public virtual int GetHashCode();
    [CLSCompliantAttribute("False")]
public static sbyte Parse(string s);
    [CLSCompliantAttribute("False")]
public static sbyte Parse(string s, NumberStyles style);
    [CLSCompliantAttribute("False")]
public static sbyte Parse(string s, NumberStyles style, IFormatProvider provider);
    [CLSCompliantAttribute("False")]
public static sbyte Parse(string s, IFormatProvider provider);
    private sealed virtual override int System.IComparable.CompareTo(object obj);
    [SecuritySafeCriticalAttribute]
public virtual string ToString();
    [SecuritySafeCriticalAttribute]
public string ToString(IFormatProvider provider);
    public string ToString(string format);
    public sealed virtual string ToString(string format, IFormatProvider provider);
    [CLSCompliantAttribute("False")]
public static bool TryParse(string s, NumberStyles style, IFormatProvider provider, SByte& result);
    [CLSCompliantAttribute("False")]
public static bool TryParse(string s, SByte& result);
}
[AttributeUsageAttribute("1")]
public class System.Security.AllowPartiallyTrustedCallersAttribute : Attribute {
}
[AttributeUsageAttribute("5501")]
public class System.Security.SecurityCriticalAttribute : Attribute {
}
public class System.Security.SecurityException : Exception {
    public SecurityException(string message);
    public SecurityException(string message, Exception inner);
    public virtual string ToString();
}
[AttributeUsageAttribute("5500")]
public class System.Security.SecuritySafeCriticalAttribute : Attribute {
}
[AttributeUsageAttribute("1")]
public class System.Security.SecurityTransparentAttribute : Attribute {
}
public class System.Security.VerificationException : Exception {
    public VerificationException(string message);
    public VerificationException(string message, Exception innerException);
}
public class System.Single : ValueType {
    public static float MinValue;
    public static float Epsilon;
    public static float MaxValue;
    public static float PositiveInfinity;
    public static float NegativeInfinity;
    public static float NaN;
    public sealed virtual int CompareTo(float value);
    public virtual bool Equals(object obj);
    public sealed virtual bool Equals(float obj);
    [SecuritySafeCriticalAttribute]
public virtual int GetHashCode();
    [SecuritySafeCriticalAttribute]
public static bool IsInfinity(float f);
    [SecuritySafeCriticalAttribute]
public static bool IsNaN(float f);
    [SecuritySafeCriticalAttribute]
public static bool IsNegativeInfinity(float f);
    [SecuritySafeCriticalAttribute]
public static bool IsPositiveInfinity(float f);
    public static bool op_Equality(float left, float right);
    public static bool op_GreaterThan(float left, float right);
    public static bool op_GreaterThanOrEqual(float left, float right);
    public static bool op_Inequality(float left, float right);
    public static bool op_LessThan(float left, float right);
    public static bool op_LessThanOrEqual(float left, float right);
    public static float Parse(string s);
    public static float Parse(string s, NumberStyles style);
    public static float Parse(string s, NumberStyles style, IFormatProvider provider);
    public static float Parse(string s, IFormatProvider provider);
    private sealed virtual override int System.IComparable.CompareTo(object value);
    [SecuritySafeCriticalAttribute]
public virtual string ToString();
    [SecuritySafeCriticalAttribute]
public string ToString(IFormatProvider provider);
    [SecuritySafeCriticalAttribute]
public string ToString(string format);
    [SecuritySafeCriticalAttribute]
public sealed virtual string ToString(string format, IFormatProvider provider);
    public static bool TryParse(string s, NumberStyles style, IFormatProvider provider, Single& result);
    public static bool TryParse(string s, Single& result);
}
[AttributeUsageAttribute("64")]
public class System.STAThreadAttribute : Attribute {
}
[DefaultMemberAttribute("Chars")]
public class System.String : object {
    public static string Empty;
    public char Chars { get; }
    public int Length { get; }
    [CLSCompliantAttribute("False")]
[SecurityCriticalAttribute]
public String(Char* value);
    [CLSCompliantAttribute("False")]
[SecurityCriticalAttribute]
public String(Char* value, int startIndex, int length);
    [SecuritySafeCriticalAttribute]
public String(char c, int count);
    [SecuritySafeCriticalAttribute]
public String(Char[] value);
    [SecuritySafeCriticalAttribute]
public String(Char[] value, int startIndex, int length);
    [SecuritySafeCriticalAttribute]
public char get_Chars(int index);
    [SecuritySafeCriticalAttribute]
public int get_Length();
    public static int Compare(string strA, int indexA, string strB, int indexB, int length);
    [SecuritySafeCriticalAttribute]
public static int Compare(string strA, int indexA, string strB, int indexB, int length, StringComparison comparisonType);
    public static int Compare(string strA, string strB);
    [SecuritySafeCriticalAttribute]
public static int Compare(string strA, string strB, StringComparison comparisonType);
    [SecuritySafeCriticalAttribute]
public static int CompareOrdinal(string strA, int indexA, string strB, int indexB, int length);
    public static int CompareOrdinal(string strA, string strB);
    public sealed virtual int CompareTo(string strB);
    public static string Concat(IEnumerable`1<string> values);
    public static string Concat(object arg0);
    public static string Concat(object arg0, object arg1);
    public static string Concat(object arg0, object arg1, object arg2);
    public static string Concat(Object[] args);
    [SecuritySafeCriticalAttribute]
public static string Concat(string str0, string str1);
    [SecuritySafeCriticalAttribute]
public static string Concat(string str0, string str1, string str2);
    [SecuritySafeCriticalAttribute]
public static string Concat(string str0, string str1, string str2, string str3);
    public static string Concat(String[] values);
    public static string Concat(IEnumerable`1<T> values);
    public bool Contains(string value);
    [SecuritySafeCriticalAttribute]
public void CopyTo(int sourceIndex, Char[] destination, int destinationIndex, int count);
    public bool EndsWith(string value);
    [SecuritySafeCriticalAttribute]
public bool EndsWith(string value, StringComparison comparisonType);
    public virtual bool Equals(object obj);
    public sealed virtual bool Equals(string value);
    public static bool Equals(string a, string b);
    [SecuritySafeCriticalAttribute]
public static bool Equals(string a, string b, StringComparison comparisonType);
    [SecuritySafeCriticalAttribute]
public bool Equals(string value, StringComparison comparisonType);
    public static string Format(IFormatProvider provider, string format, Object[] args);
    public static string Format(string format, Object[] args);
    [SecuritySafeCriticalAttribute]
public virtual int GetHashCode();
    public int IndexOf(char value);
    public int IndexOf(char value, int startIndex);
    [SecuritySafeCriticalAttribute]
public int IndexOf(char value, int startIndex, int count);
    public int IndexOf(string value);
    public int IndexOf(string value, int startIndex);
    public int IndexOf(string value, int startIndex, int count);
    [SecuritySafeCriticalAttribute]
public int IndexOf(string value, int startIndex, int count, StringComparison comparisonType);
    public int IndexOf(string value, int startIndex, StringComparison comparisonType);
    public int IndexOf(string value, StringComparison comparisonType);
    public int IndexOfAny(Char[] anyOf);
    public int IndexOfAny(Char[] anyOf, int startIndex);
    [SecuritySafeCriticalAttribute]
public int IndexOfAny(Char[] anyOf, int startIndex, int count);
    [SecuritySafeCriticalAttribute]
public string Insert(int startIndex, string value);
    public static bool IsNullOrEmpty(string value);
    public static bool IsNullOrWhiteSpace(string value);
    public static string Join(string separator, IEnumerable`1<string> values);
    public static string Join(string separator, Object[] values);
    public static string Join(string separator, String[] value);
    [SecuritySafeCriticalAttribute]
public static string Join(string separator, String[] value, int startIndex, int count);
    public static string Join(string separator, IEnumerable`1<T> values);
    public int LastIndexOf(char value);
    public int LastIndexOf(char value, int startIndex);
    [SecuritySafeCriticalAttribute]
public int LastIndexOf(char value, int startIndex, int count);
    public int LastIndexOf(string value);
    public int LastIndexOf(string value, int startIndex);
    public int LastIndexOf(string value, int startIndex, int count);
    [SecuritySafeCriticalAttribute]
public int LastIndexOf(string value, int startIndex, int count, StringComparison comparisonType);
    public int LastIndexOf(string value, int startIndex, StringComparison comparisonType);
    public int LastIndexOf(string value, StringComparison comparisonType);
    public int LastIndexOfAny(Char[] anyOf);
    public int LastIndexOfAny(Char[] anyOf, int startIndex);
    [SecuritySafeCriticalAttribute]
public int LastIndexOfAny(Char[] anyOf, int startIndex, int count);
    public static bool op_Equality(string a, string b);
    public static bool op_Inequality(string a, string b);
    public string PadLeft(int totalWidth);
    public string PadLeft(int totalWidth, char paddingChar);
    public string PadRight(int totalWidth);
    public string PadRight(int totalWidth, char paddingChar);
    public string Remove(int startIndex);
    [SecuritySafeCriticalAttribute]
public string Remove(int startIndex, int count);
    public string Replace(char oldChar, char newChar);
    public string Replace(string oldValue, string newValue);
    public String[] Split(Char[] separator);
    public String[] Split(Char[] separator, int count);
    public String[] Split(Char[] separator, int count, StringSplitOptions options);
    public String[] Split(Char[] separator, StringSplitOptions options);
    public String[] Split(String[] separator, int count, StringSplitOptions options);
    public String[] Split(String[] separator, StringSplitOptions options);
    public bool StartsWith(string value);
    [SecuritySafeCriticalAttribute]
public bool StartsWith(string value, StringComparison comparisonType);
    public string Substring(int startIndex);
    [SecuritySafeCriticalAttribute]
public string Substring(int startIndex, int length);
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
    private sealed virtual override int System.IComparable.CompareTo(object value);
    [SecuritySafeCriticalAttribute]
public Char[] ToCharArray();
    [SecuritySafeCriticalAttribute]
public Char[] ToCharArray(int startIndex, int length);
    public string ToLower();
    public string ToLowerInvariant();
    public virtual string ToString();
    public string ToUpper();
    public string ToUpperInvariant();
    public string Trim();
    public string Trim(Char[] trimChars);
    public string TrimEnd(Char[] trimChars);
    public string TrimStart(Char[] trimChars);
    private sealed virtual override IEnumerator`1<char> System.Collections.Generic.IEnumerable<System.Char>.GetEnumerator();
}
public enum System.StringComparison : Enum {
    public int value__;
    public static StringComparison CurrentCulture;
    public static StringComparison CurrentCultureIgnoreCase;
    public static StringComparison Ordinal;
    public static StringComparison OrdinalIgnoreCase;
}
[FlagsAttribute]
public enum System.StringSplitOptions : Enum {
    public int value__;
    public static StringSplitOptions None;
    public static StringSplitOptions RemoveEmptyEntries;
}
[DefaultMemberAttribute("Chars")]
public class System.Text.StringBuilder : object {
    public int Capacity { get; public set; }
    public char Chars { get; public set; }
    public int Length { get; public set; }
    public int MaxCapacity { get; }
    public StringBuilder(int capacity);
    public StringBuilder(int capacity, int maxCapacity);
    public StringBuilder(string value);
    public StringBuilder(string value, int capacity);
    [SecuritySafeCriticalAttribute]
public StringBuilder(string value, int startIndex, int length, int capacity);
    public int get_Capacity();
    public void set_Capacity(int value);
    public char get_Chars(int index);
    public void set_Chars(int index, char value);
    public int get_Length();
    public void set_Length(int value);
    public int get_MaxCapacity();
    public StringBuilder Append(bool value);
    public StringBuilder Append(byte value);
    public StringBuilder Append(char value);
    public StringBuilder Append(char value, int repeatCount);
    [SecuritySafeCriticalAttribute]
public StringBuilder Append(Char[] value);
    [SecuritySafeCriticalAttribute]
public StringBuilder Append(Char[] value, int startIndex, int charCount);
    public StringBuilder Append(decimal value);
    public StringBuilder Append(double value);
    public StringBuilder Append(short value);
    public StringBuilder Append(int value);
    public StringBuilder Append(long value);
    public StringBuilder Append(object value);
    [CLSCompliantAttribute("False")]
public StringBuilder Append(sbyte value);
    public StringBuilder Append(float value);
    [SecuritySafeCriticalAttribute]
public StringBuilder Append(string value);
    [SecuritySafeCriticalAttribute]
public StringBuilder Append(string value, int startIndex, int count);
    [CLSCompliantAttribute("False")]
public StringBuilder Append(ushort value);
    [CLSCompliantAttribute("False")]
public StringBuilder Append(UInt32 value);
    [CLSCompliantAttribute("False")]
public StringBuilder Append(ulong value);
    public StringBuilder AppendFormat(IFormatProvider provider, string format, Object[] args);
    public StringBuilder AppendFormat(string format, Object[] args);
    public StringBuilder AppendLine();
    public StringBuilder AppendLine(string value);
    public StringBuilder Clear();
    [SecuritySafeCriticalAttribute]
public void CopyTo(int sourceIndex, Char[] destination, int destinationIndex, int count);
    public int EnsureCapacity(int capacity);
    public bool Equals(StringBuilder sb);
    public StringBuilder Insert(int index, bool value);
    public StringBuilder Insert(int index, byte value);
    [SecuritySafeCriticalAttribute]
public StringBuilder Insert(int index, char value);
    public StringBuilder Insert(int index, Char[] value);
    [SecuritySafeCriticalAttribute]
public StringBuilder Insert(int index, Char[] value, int startIndex, int charCount);
    public StringBuilder Insert(int index, decimal value);
    public StringBuilder Insert(int index, double value);
    public StringBuilder Insert(int index, short value);
    public StringBuilder Insert(int index, int value);
    public StringBuilder Insert(int index, long value);
    public StringBuilder Insert(int index, object value);
    [CLSCompliantAttribute("False")]
public StringBuilder Insert(int index, sbyte value);
    public StringBuilder Insert(int index, float value);
    [SecuritySafeCriticalAttribute]
public StringBuilder Insert(int index, string value);
    [SecuritySafeCriticalAttribute]
public StringBuilder Insert(int index, string value, int count);
    [CLSCompliantAttribute("False")]
public StringBuilder Insert(int index, ushort value);
    [CLSCompliantAttribute("False")]
public StringBuilder Insert(int index, UInt32 value);
    [CLSCompliantAttribute("False")]
public StringBuilder Insert(int index, ulong value);
    public StringBuilder Remove(int startIndex, int length);
    public StringBuilder Replace(char oldChar, char newChar);
    public StringBuilder Replace(char oldChar, char newChar, int startIndex, int count);
    public StringBuilder Replace(string oldValue, string newValue);
    public StringBuilder Replace(string oldValue, string newValue, int startIndex, int count);
    [SecuritySafeCriticalAttribute]
public virtual string ToString();
    [SecuritySafeCriticalAttribute]
public string ToString(int startIndex, int length);
}
public enum System.Threading.LazyThreadSafetyMode : Enum {
    public int value__;
    public static LazyThreadSafetyMode ExecutionAndPublication;
    public static LazyThreadSafetyMode None;
    public static LazyThreadSafetyMode PublicationOnly;
}
public static class System.Threading.Timeout : object {
    public static int Infinite;
    public static TimeSpan InfiniteTimeSpan;
}
public abstract class System.Threading.WaitHandle : object {
    public static int WaitTimeout;
    protected static IntPtr InvalidHandle;
    public sealed virtual void Dispose();
    [SecuritySafeCriticalAttribute]
protected virtual void Dispose(bool explicitDisposing);
    public static bool WaitAll(WaitHandle[] waitHandles);
    public static bool WaitAll(WaitHandle[] waitHandles, int millisecondsTimeout);
    public static bool WaitAll(WaitHandle[] waitHandles, TimeSpan timeout);
    public static int WaitAny(WaitHandle[] waitHandles);
    public static int WaitAny(WaitHandle[] waitHandles, int millisecondsTimeout);
    public static int WaitAny(WaitHandle[] waitHandles, TimeSpan timeout);
    public virtual bool WaitOne();
    public virtual bool WaitOne(int millisecondsTimeout);
    public virtual bool WaitOne(TimeSpan timeout);
}
[AttributeUsageAttribute("256")]
public class System.ThreadStaticAttribute : Attribute {
}
public class System.TimeoutException : Exception {
    public TimeoutException(string message);
    public TimeoutException(string message, Exception innerException);
}
public class System.TimeSpan : ValueType {
    public static long TicksPerDay;
    public static long TicksPerHour;
    public static long TicksPerMillisecond;
    public static long TicksPerMinute;
    public static long TicksPerSecond;
    public static TimeSpan MaxValue;
    public static TimeSpan MinValue;
    public static TimeSpan Zero;
    public int Days { get; }
    public int Hours { get; }
    public int Milliseconds { get; }
    public int Minutes { get; }
    public int Seconds { get; }
    public long Ticks { get; }
    public double TotalDays { get; }
    public double TotalHours { get; }
    public double TotalMilliseconds { get; }
    public double TotalMinutes { get; }
    public double TotalSeconds { get; }
    public TimeSpan(int hours, int minutes, int seconds);
    public TimeSpan(int days, int hours, int minutes, int seconds);
    public TimeSpan(int days, int hours, int minutes, int seconds, int milliseconds);
    public TimeSpan(long ticks);
    public int get_Days();
    public int get_Hours();
    public int get_Milliseconds();
    public int get_Minutes();
    public int get_Seconds();
    public long get_Ticks();
    public double get_TotalDays();
    public double get_TotalHours();
    public double get_TotalMilliseconds();
    public double get_TotalMinutes();
    public double get_TotalSeconds();
    public TimeSpan Add(TimeSpan ts);
    public static int Compare(TimeSpan t1, TimeSpan t2);
    public sealed virtual int CompareTo(TimeSpan value);
    public TimeSpan Duration();
    public virtual bool Equals(object value);
    public sealed virtual bool Equals(TimeSpan obj);
    public static bool Equals(TimeSpan t1, TimeSpan t2);
    public static TimeSpan FromDays(double value);
    public static TimeSpan FromHours(double value);
    public static TimeSpan FromMilliseconds(double value);
    public static TimeSpan FromMinutes(double value);
    public static TimeSpan FromSeconds(double value);
    public static TimeSpan FromTicks(long value);
    public virtual int GetHashCode();
    public TimeSpan Negate();
    public static TimeSpan op_Addition(TimeSpan t1, TimeSpan t2);
    public static bool op_Equality(TimeSpan t1, TimeSpan t2);
    public static bool op_GreaterThan(TimeSpan t1, TimeSpan t2);
    public static bool op_GreaterThanOrEqual(TimeSpan t1, TimeSpan t2);
    public static bool op_Inequality(TimeSpan t1, TimeSpan t2);
    public static bool op_LessThan(TimeSpan t1, TimeSpan t2);
    public static bool op_LessThanOrEqual(TimeSpan t1, TimeSpan t2);
    public static TimeSpan op_Subtraction(TimeSpan t1, TimeSpan t2);
    public static TimeSpan op_UnaryNegation(TimeSpan t);
    public static TimeSpan op_UnaryPlus(TimeSpan t);
    public static TimeSpan Parse(string s);
    public static TimeSpan Parse(string input, IFormatProvider formatProvider);
    public static TimeSpan ParseExact(string input, string format, IFormatProvider formatProvider);
    public static TimeSpan ParseExact(string input, string format, IFormatProvider formatProvider, TimeSpanStyles styles);
    public static TimeSpan ParseExact(string input, String[] formats, IFormatProvider formatProvider);
    public static TimeSpan ParseExact(string input, String[] formats, IFormatProvider formatProvider, TimeSpanStyles styles);
    public TimeSpan Subtract(TimeSpan ts);
    private sealed virtual override int System.IComparable.CompareTo(object value);
    public virtual string ToString();
    public string ToString(string format);
    public sealed virtual string ToString(string format, IFormatProvider formatProvider);
    public static bool TryParse(string input, IFormatProvider formatProvider, TimeSpan& result);
    public static bool TryParse(string s, TimeSpan& result);
    public static bool TryParseExact(string input, string format, IFormatProvider formatProvider, TimeSpanStyles styles, TimeSpan& result);
    public static bool TryParseExact(string input, string format, IFormatProvider formatProvider, TimeSpan& result);
    public static bool TryParseExact(string input, String[] formats, IFormatProvider formatProvider, TimeSpanStyles styles, TimeSpan& result);
    public static bool TryParseExact(string input, String[] formats, IFormatProvider formatProvider, TimeSpan& result);
}
public class System.TimeZoneInfo : object {
    public TimeSpan BaseUtcOffset { get; }
    public string DaylightName { get; }
    public string DisplayName { get; }
    public static TimeZoneInfo Local { get; }
    public string StandardName { get; }
    public bool SupportsDaylightSavingTime { get; }
    public static TimeZoneInfo Utc { get; }
    public TimeSpan get_BaseUtcOffset();
    public string get_DaylightName();
    public string get_DisplayName();
    public static TimeZoneInfo get_Local();
    public string get_StandardName();
    public bool get_SupportsDaylightSavingTime();
    public static TimeZoneInfo get_Utc();
    public static DateTime ConvertTime(DateTime dateTime, TimeZoneInfo destinationTimeZone);
    public static DateTimeOffset ConvertTime(DateTimeOffset dateTimeOffset, TimeZoneInfo destinationTimeZone);
    public sealed virtual bool Equals(TimeZoneInfo other);
    public TimeSpan[] GetAmbiguousTimeOffsets(DateTime dateTime);
    public TimeSpan[] GetAmbiguousTimeOffsets(DateTimeOffset dateTimeOffset);
    public virtual int GetHashCode();
    public TimeSpan GetUtcOffset(DateTime dateTime);
    public TimeSpan GetUtcOffset(DateTimeOffset dateTimeOffset);
    public bool IsAmbiguousTime(DateTime dateTime);
    public bool IsAmbiguousTime(DateTimeOffset dateTimeOffset);
    public bool IsDaylightSavingTime(DateTime dateTime);
    public bool IsDaylightSavingTime(DateTimeOffset dateTimeOffset);
    public bool IsInvalidTime(DateTime dateTime);
    public virtual string ToString();
}
public static class System.Tuple : object {
    public static Tuple`1<T1> Create(T1 item1);
    public static Tuple`2<T1, T2> Create(T1 item1, T2 item2);
    public static Tuple`3<T1, T2, T3> Create(T1 item1, T2 item2, T3 item3);
    public static Tuple`4<T1, T2, T3, T4> Create(T1 item1, T2 item2, T3 item3, T4 item4);
    public static Tuple`5<T1, T2, T3, T4, T5> Create(T1 item1, T2 item2, T3 item3, T4 item4, T5 item5);
    public static Tuple`6<T1, T2, T3, T4, T5, T6> Create(T1 item1, T2 item2, T3 item3, T4 item4, T5 item5, T6 item6);
    public static Tuple`7<T1, T2, T3, T4, T5, T6, T7> Create(T1 item1, T2 item2, T3 item3, T4 item4, T5 item5, T6 item6, T7 item7);
    public static Tuple`8<T1, T2, T3, T4, T5, T6, T7, Tuple`1<T8>> Create(T1 item1, T2 item2, T3 item3, T4 item4, T5 item5, T6 item6, T7 item7, T8 item8);
}
public class System.Tuple`1 : object {
    public T1 Item1 { get; }
    public Tuple`1(T1 item1);
    public T1 get_Item1();
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    private sealed virtual override int System.Collections.IStructuralComparable.CompareTo(object other, IComparer comparer);
    private sealed virtual override bool System.Collections.IStructuralEquatable.Equals(object other, IEqualityComparer comparer);
    private sealed virtual override int System.Collections.IStructuralEquatable.GetHashCode(IEqualityComparer comparer);
    private sealed virtual override int System.IComparable.CompareTo(object obj);
    public virtual string ToString();
}
public class System.Tuple`2 : object {
    public T1 Item1 { get; }
    public T2 Item2 { get; }
    public Tuple`2(T1 item1, T2 item2);
    public T1 get_Item1();
    public T2 get_Item2();
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    private sealed virtual override int System.Collections.IStructuralComparable.CompareTo(object other, IComparer comparer);
    private sealed virtual override bool System.Collections.IStructuralEquatable.Equals(object other, IEqualityComparer comparer);
    private sealed virtual override int System.Collections.IStructuralEquatable.GetHashCode(IEqualityComparer comparer);
    private sealed virtual override int System.IComparable.CompareTo(object obj);
    public virtual string ToString();
}
public class System.Tuple`3 : object {
    public T1 Item1 { get; }
    public T2 Item2 { get; }
    public T3 Item3 { get; }
    public Tuple`3(T1 item1, T2 item2, T3 item3);
    public T1 get_Item1();
    public T2 get_Item2();
    public T3 get_Item3();
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    private sealed virtual override int System.Collections.IStructuralComparable.CompareTo(object other, IComparer comparer);
    private sealed virtual override bool System.Collections.IStructuralEquatable.Equals(object other, IEqualityComparer comparer);
    private sealed virtual override int System.Collections.IStructuralEquatable.GetHashCode(IEqualityComparer comparer);
    private sealed virtual override int System.IComparable.CompareTo(object obj);
    public virtual string ToString();
}
public class System.Tuple`4 : object {
    public T1 Item1 { get; }
    public T2 Item2 { get; }
    public T3 Item3 { get; }
    public T4 Item4 { get; }
    public Tuple`4(T1 item1, T2 item2, T3 item3, T4 item4);
    public T1 get_Item1();
    public T2 get_Item2();
    public T3 get_Item3();
    public T4 get_Item4();
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    private sealed virtual override int System.Collections.IStructuralComparable.CompareTo(object other, IComparer comparer);
    private sealed virtual override bool System.Collections.IStructuralEquatable.Equals(object other, IEqualityComparer comparer);
    private sealed virtual override int System.Collections.IStructuralEquatable.GetHashCode(IEqualityComparer comparer);
    private sealed virtual override int System.IComparable.CompareTo(object obj);
    public virtual string ToString();
}
public class System.Tuple`5 : object {
    public T1 Item1 { get; }
    public T2 Item2 { get; }
    public T3 Item3 { get; }
    public T4 Item4 { get; }
    public T5 Item5 { get; }
    public Tuple`5(T1 item1, T2 item2, T3 item3, T4 item4, T5 item5);
    public T1 get_Item1();
    public T2 get_Item2();
    public T3 get_Item3();
    public T4 get_Item4();
    public T5 get_Item5();
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    private sealed virtual override int System.Collections.IStructuralComparable.CompareTo(object other, IComparer comparer);
    private sealed virtual override bool System.Collections.IStructuralEquatable.Equals(object other, IEqualityComparer comparer);
    private sealed virtual override int System.Collections.IStructuralEquatable.GetHashCode(IEqualityComparer comparer);
    private sealed virtual override int System.IComparable.CompareTo(object obj);
    public virtual string ToString();
}
public class System.Tuple`6 : object {
    public T1 Item1 { get; }
    public T2 Item2 { get; }
    public T3 Item3 { get; }
    public T4 Item4 { get; }
    public T5 Item5 { get; }
    public T6 Item6 { get; }
    public Tuple`6(T1 item1, T2 item2, T3 item3, T4 item4, T5 item5, T6 item6);
    public T1 get_Item1();
    public T2 get_Item2();
    public T3 get_Item3();
    public T4 get_Item4();
    public T5 get_Item5();
    public T6 get_Item6();
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    private sealed virtual override int System.Collections.IStructuralComparable.CompareTo(object other, IComparer comparer);
    private sealed virtual override bool System.Collections.IStructuralEquatable.Equals(object other, IEqualityComparer comparer);
    private sealed virtual override int System.Collections.IStructuralEquatable.GetHashCode(IEqualityComparer comparer);
    private sealed virtual override int System.IComparable.CompareTo(object obj);
    public virtual string ToString();
}
public class System.Tuple`7 : object {
    public T1 Item1 { get; }
    public T2 Item2 { get; }
    public T3 Item3 { get; }
    public T4 Item4 { get; }
    public T5 Item5 { get; }
    public T6 Item6 { get; }
    public T7 Item7 { get; }
    public Tuple`7(T1 item1, T2 item2, T3 item3, T4 item4, T5 item5, T6 item6, T7 item7);
    public T1 get_Item1();
    public T2 get_Item2();
    public T3 get_Item3();
    public T4 get_Item4();
    public T5 get_Item5();
    public T6 get_Item6();
    public T7 get_Item7();
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    private sealed virtual override int System.Collections.IStructuralComparable.CompareTo(object other, IComparer comparer);
    private sealed virtual override bool System.Collections.IStructuralEquatable.Equals(object other, IEqualityComparer comparer);
    private sealed virtual override int System.Collections.IStructuralEquatable.GetHashCode(IEqualityComparer comparer);
    private sealed virtual override int System.IComparable.CompareTo(object obj);
    public virtual string ToString();
}
public class System.Tuple`8 : object {
    public T1 Item1 { get; }
    public T2 Item2 { get; }
    public T3 Item3 { get; }
    public T4 Item4 { get; }
    public T5 Item5 { get; }
    public T6 Item6 { get; }
    public T7 Item7 { get; }
    public TRest Rest { get; }
    public Tuple`8(T1 item1, T2 item2, T3 item3, T4 item4, T5 item5, T6 item6, T7 item7, TRest rest);
    public T1 get_Item1();
    public T2 get_Item2();
    public T3 get_Item3();
    public T4 get_Item4();
    public T5 get_Item5();
    public T6 get_Item6();
    public T7 get_Item7();
    public TRest get_Rest();
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    private sealed virtual override int System.Collections.IStructuralComparable.CompareTo(object other, IComparer comparer);
    private sealed virtual override bool System.Collections.IStructuralEquatable.Equals(object other, IEqualityComparer comparer);
    private sealed virtual override int System.Collections.IStructuralEquatable.GetHashCode(IEqualityComparer comparer);
    private sealed virtual override int System.IComparable.CompareTo(object obj);
    public virtual string ToString();
}
public abstract class System.Type : object {
    public static object Missing;
    public string AssemblyQualifiedName { get; }
    public string FullName { get; }
    public int GenericParameterPosition { get; }
    public Type[] GenericTypeArguments { get; }
    public bool HasElementType { get; }
    public bool IsArray { get; }
    public bool IsByRef { get; }
    public bool IsConstructedGenericType { get; }
    public bool IsGenericParameter { get; }
    public bool IsNested { get; }
    public bool IsPointer { get; }
    public string Namespace { get; }
    public RuntimeTypeHandle TypeHandle { get; }
    public Type DeclaringType { get; }
    public string Name { get; }
    public abstract virtual string get_AssemblyQualifiedName();
    public abstract virtual string get_FullName();
    public abstract virtual int get_GenericParameterPosition();
    public abstract virtual Type[] get_GenericTypeArguments();
    public bool get_HasElementType();
    public bool get_IsArray();
    public bool get_IsByRef();
    public abstract virtual bool get_IsConstructedGenericType();
    public abstract virtual bool get_IsGenericParameter();
    public bool get_IsNested();
    public bool get_IsPointer();
    public abstract virtual string get_Namespace();
    public virtual RuntimeTypeHandle get_TypeHandle();
    public virtual bool Equals(object o);
    public bool Equals(Type o);
    public abstract virtual int GetArrayRank();
    public abstract virtual Type GetElementType();
    public abstract virtual Type GetGenericTypeDefinition();
    public virtual int GetHashCode();
    public static Type GetType(string typeName);
    public static Type GetType(string typeName, bool throwOnError);
    [SecuritySafeCriticalAttribute]
public static Type GetTypeFromHandle(RuntimeTypeHandle handle);
    public abstract virtual Type MakeArrayType();
    public abstract virtual Type MakeArrayType(int rank);
    public abstract virtual Type MakeByRefType();
    public abstract virtual Type MakeGenericType(Type[] typeArguments);
    public abstract virtual Type MakePointerType();
    public virtual string ToString();
    public abstract virtual Type get_DeclaringType();
    public abstract virtual string get_Name();
}
public class System.TypeAccessException : TypeLoadException {
    public TypeAccessException(string message);
    public TypeAccessException(string message, Exception inner);
}
public class System.TypeInitializationException : Exception {
    public string TypeName { get; }
    public TypeInitializationException(string fullTypeName, Exception innerException);
    public string get_TypeName();
}
public class System.TypeLoadException : Exception {
    public string Message { get; }
    public string TypeName { get; }
    public TypeLoadException(string message);
    public TypeLoadException(string message, Exception inner);
    [SecuritySafeCriticalAttribute]
public virtual string get_Message();
    public string get_TypeName();
}
[CLSCompliantAttribute("False")]
public class System.UInt16 : ValueType {
    public static ushort MaxValue;
    public static ushort MinValue;
    public sealed virtual int CompareTo(ushort value);
    public virtual bool Equals(object obj);
    public sealed virtual bool Equals(ushort obj);
    public virtual int GetHashCode();
    [CLSCompliantAttribute("False")]
public static ushort Parse(string s);
    [CLSCompliantAttribute("False")]
public static ushort Parse(string s, NumberStyles style);
    [CLSCompliantAttribute("False")]
public static ushort Parse(string s, NumberStyles style, IFormatProvider provider);
    [CLSCompliantAttribute("False")]
public static ushort Parse(string s, IFormatProvider provider);
    private sealed virtual override int System.IComparable.CompareTo(object value);
    [SecuritySafeCriticalAttribute]
public virtual string ToString();
    [SecuritySafeCriticalAttribute]
public string ToString(IFormatProvider provider);
    [SecuritySafeCriticalAttribute]
public string ToString(string format);
    [SecuritySafeCriticalAttribute]
public sealed virtual string ToString(string format, IFormatProvider provider);
    [CLSCompliantAttribute("False")]
public static bool TryParse(string s, NumberStyles style, IFormatProvider provider, UInt16& result);
    [CLSCompliantAttribute("False")]
public static bool TryParse(string s, UInt16& result);
}
[CLSCompliantAttribute("False")]
public class System.UInt32 : ValueType {
    public static UInt32 MaxValue;
    public static UInt32 MinValue;
    public sealed virtual int CompareTo(UInt32 value);
    public virtual bool Equals(object obj);
    public sealed virtual bool Equals(UInt32 obj);
    public virtual int GetHashCode();
    [CLSCompliantAttribute("False")]
public static UInt32 Parse(string s);
    [CLSCompliantAttribute("False")]
public static UInt32 Parse(string s, NumberStyles style);
    [CLSCompliantAttribute("False")]
public static UInt32 Parse(string s, NumberStyles style, IFormatProvider provider);
    [CLSCompliantAttribute("False")]
public static UInt32 Parse(string s, IFormatProvider provider);
    private sealed virtual override int System.IComparable.CompareTo(object value);
    [SecuritySafeCriticalAttribute]
public virtual string ToString();
    [SecuritySafeCriticalAttribute]
public string ToString(IFormatProvider provider);
    [SecuritySafeCriticalAttribute]
public string ToString(string format);
    [SecuritySafeCriticalAttribute]
public sealed virtual string ToString(string format, IFormatProvider provider);
    [CLSCompliantAttribute("False")]
public static bool TryParse(string s, NumberStyles style, IFormatProvider provider, UInt32& result);
    [CLSCompliantAttribute("False")]
public static bool TryParse(string s, UInt32& result);
}
[CLSCompliantAttribute("False")]
public class System.UInt64 : ValueType {
    public static ulong MaxValue;
    public static ulong MinValue;
    public sealed virtual int CompareTo(ulong value);
    public virtual bool Equals(object obj);
    public sealed virtual bool Equals(ulong obj);
    public virtual int GetHashCode();
    [CLSCompliantAttribute("False")]
public static ulong Parse(string s);
    [CLSCompliantAttribute("False")]
public static ulong Parse(string s, NumberStyles style);
    [CLSCompliantAttribute("False")]
public static ulong Parse(string s, NumberStyles style, IFormatProvider provider);
    [CLSCompliantAttribute("False")]
public static ulong Parse(string s, IFormatProvider provider);
    private sealed virtual override int System.IComparable.CompareTo(object value);
    [SecuritySafeCriticalAttribute]
public virtual string ToString();
    [SecuritySafeCriticalAttribute]
public string ToString(IFormatProvider provider);
    [SecuritySafeCriticalAttribute]
public string ToString(string format);
    [SecuritySafeCriticalAttribute]
public sealed virtual string ToString(string format, IFormatProvider provider);
    [CLSCompliantAttribute("False")]
public static bool TryParse(string s, NumberStyles style, IFormatProvider provider, UInt64& result);
    [CLSCompliantAttribute("False")]
public static bool TryParse(string s, UInt64& result);
}
[CLSCompliantAttribute("False")]
public class System.UIntPtr : ValueType {
    public static UIntPtr Zero;
    public static int Size { get; }
    [SecuritySafeCriticalAttribute]
public UIntPtr(UInt32 value);
    [SecuritySafeCriticalAttribute]
public UIntPtr(ulong value);
    [SecurityCriticalAttribute]
[CLSCompliantAttribute("False")]
public UIntPtr(Void* value);
    public static int get_Size();
    public static UIntPtr Add(UIntPtr pointer, int offset);
    [SecuritySafeCriticalAttribute]
public virtual bool Equals(object obj);
    [SecuritySafeCriticalAttribute]
public virtual int GetHashCode();
    public static UIntPtr op_Addition(UIntPtr pointer, int offset);
    [SecuritySafeCriticalAttribute]
public static bool op_Equality(UIntPtr value1, UIntPtr value2);
    public static UIntPtr op_Explicit(UInt32 value);
    public static UIntPtr op_Explicit(ulong value);
    [SecuritySafeCriticalAttribute]
public static UInt32 op_Explicit(UIntPtr value);
    [SecuritySafeCriticalAttribute]
public static ulong op_Explicit(UIntPtr value);
    [CLSCompliantAttribute("False")]
[SecurityCriticalAttribute]
public static Void* op_Explicit(UIntPtr value);
    [SecurityCriticalAttribute]
[CLSCompliantAttribute("False")]
public static UIntPtr op_Explicit(Void* value);
    [SecuritySafeCriticalAttribute]
public static bool op_Inequality(UIntPtr value1, UIntPtr value2);
    public static UIntPtr op_Subtraction(UIntPtr pointer, int offset);
    public static UIntPtr Subtract(UIntPtr pointer, int offset);
    [CLSCompliantAttribute("False")]
[SecuritySafeCriticalAttribute]
public Void* ToPointer();
    [SecuritySafeCriticalAttribute]
public virtual string ToString();
    [SecuritySafeCriticalAttribute]
public UInt32 ToUInt32();
    [SecuritySafeCriticalAttribute]
public ulong ToUInt64();
}
public class System.UnauthorizedAccessException : Exception {
    public UnauthorizedAccessException(string message);
    public UnauthorizedAccessException(string message, Exception inner);
}
public class System.Uri : object {
    public string AbsolutePath { get; }
    public string AbsoluteUri { get; }
    public string Authority { get; }
    public string DnsSafeHost { get; }
    public string Fragment { get; }
    public string Host { get; }
    public UriHostNameType HostNameType { get; }
    public bool IsAbsoluteUri { get; }
    public bool IsDefaultPort { get; }
    public bool IsFile { get; }
    public bool IsLoopback { get; }
    public bool IsUnc { get; }
    public string LocalPath { get; }
    public string OriginalString { get; }
    public string PathAndQuery { get; }
    public int Port { get; }
    public string Query { get; }
    public string Scheme { get; }
    public String[] Segments { get; }
    public bool UserEscaped { get; }
    public string UserInfo { get; }
    public Uri(string uriString);
    public Uri(string uriString, UriKind uriKind);
    public Uri(Uri baseUri, string relativeUri);
    public Uri(Uri baseUri, Uri relativeUri);
    public string get_AbsolutePath();
    public string get_AbsoluteUri();
    public string get_Authority();
    public string get_DnsSafeHost();
    public string get_Fragment();
    public string get_Host();
    public UriHostNameType get_HostNameType();
    public bool get_IsAbsoluteUri();
    public bool get_IsDefaultPort();
    public bool get_IsFile();
    public bool get_IsLoopback();
    public bool get_IsUnc();
    public string get_LocalPath();
    public string get_OriginalString();
    public string get_PathAndQuery();
    public int get_Port();
    public string get_Query();
    public string get_Scheme();
    public String[] get_Segments();
    public bool get_UserEscaped();
    public string get_UserInfo();
    public static UriHostNameType CheckHostName(string name);
    public static bool CheckSchemeName(string schemeName);
    public static int Compare(Uri uri1, Uri uri2, UriComponents partsToCompare, UriFormat compareFormat, StringComparison comparisonType);
    public virtual bool Equals(object comparand);
    public static string EscapeDataString(string stringToEscape);
    public static string EscapeUriString(string stringToEscape);
    public string GetComponents(UriComponents components, UriFormat format);
    public virtual int GetHashCode();
    public bool IsBaseOf(Uri uri);
    public bool IsWellFormedOriginalString();
    public static bool IsWellFormedUriString(string uriString, UriKind uriKind);
    public Uri MakeRelativeUri(Uri uri);
    public static bool op_Equality(Uri uri1, Uri uri2);
    public static bool op_Inequality(Uri uri1, Uri uri2);
    public virtual string ToString();
    public static bool TryCreate(string uriString, UriKind uriKind, Uri& result);
    public static bool TryCreate(Uri baseUri, string relativeUri, Uri& result);
    public static bool TryCreate(Uri baseUri, Uri relativeUri, Uri& result);
    public static string UnescapeDataString(string stringToUnescape);
}
[FlagsAttribute]
public enum System.UriComponents : Enum {
    public int value__;
    public static UriComponents AbsoluteUri;
    public static UriComponents Fragment;
    public static UriComponents Host;
    public static UriComponents HostAndPort;
    public static UriComponents HttpRequestUrl;
    public static UriComponents KeepDelimiter;
    public static UriComponents NormalizedHost;
    public static UriComponents Path;
    public static UriComponents PathAndQuery;
    public static UriComponents Port;
    public static UriComponents Query;
    public static UriComponents Scheme;
    public static UriComponents SchemeAndServer;
    public static UriComponents SerializationInfoString;
    public static UriComponents StrongAuthority;
    public static UriComponents StrongPort;
    public static UriComponents UserInfo;
}
public enum System.UriFormat : Enum {
    public int value__;
    public static UriFormat SafeUnescaped;
    public static UriFormat Unescaped;
    public static UriFormat UriEscaped;
}
public enum System.UriHostNameType : Enum {
    public int value__;
    public static UriHostNameType Basic;
    public static UriHostNameType Dns;
    public static UriHostNameType IPv4;
    public static UriHostNameType IPv6;
    public static UriHostNameType Unknown;
}
public enum System.UriKind : Enum {
    public int value__;
    public static UriKind Absolute;
    public static UriKind Relative;
    public static UriKind RelativeOrAbsolute;
}
public abstract class System.ValueType : object {
    [SecuritySafeCriticalAttribute]
public virtual bool Equals(object obj);
    [SecuritySafeCriticalAttribute]
public virtual int GetHashCode();
    public virtual string ToString();
}
public class System.Version : object {
    public int Build { get; }
    public int Major { get; }
    public short MajorRevision { get; }
    public int Minor { get; }
    public short MinorRevision { get; }
    public int Revision { get; }
    public Version(int major, int minor);
    public Version(int major, int minor, int build);
    public Version(int major, int minor, int build, int revision);
    public Version(string version);
    public int get_Build();
    public int get_Major();
    public short get_MajorRevision();
    public int get_Minor();
    public short get_MinorRevision();
    public int get_Revision();
    public sealed virtual int CompareTo(Version value);
    public virtual bool Equals(object obj);
    public sealed virtual bool Equals(Version obj);
    public virtual int GetHashCode();
    public static bool op_Equality(Version v1, Version v2);
    public static bool op_GreaterThan(Version v1, Version v2);
    public static bool op_GreaterThanOrEqual(Version v1, Version v2);
    public static bool op_Inequality(Version v1, Version v2);
    public static bool op_LessThan(Version v1, Version v2);
    public static bool op_LessThanOrEqual(Version v1, Version v2);
    public static Version Parse(string input);
    private sealed virtual override int System.IComparable.CompareTo(object version);
    public virtual string ToString();
    public string ToString(int fieldCount);
    public static bool TryParse(string input, Version& result);
}
public class System.Void : ValueType {
}
public class System.WeakReference : object {
    public bool IsAlive { get; }
    public object Target { get; public set; }
    public bool TrackResurrection { get; }
    public WeakReference(object target);
    public WeakReference(object target, bool trackResurrection);
    [SecuritySafeCriticalAttribute]
public virtual bool get_IsAlive();
    [SecuritySafeCriticalAttribute]
public virtual object get_Target();
    [SecuritySafeCriticalAttribute]
public virtual void set_Target(object value);
    public virtual bool get_TrackResurrection();
    protected virtual void Finalize();
}
public class System.WeakReference`1 : object {
    public WeakReference`1(T target);
    public WeakReference`1(T target, bool trackResurrection);
    protected virtual void Finalize();
    public void SetTarget(T target);
    public bool TryGetTarget(T& target);
}
