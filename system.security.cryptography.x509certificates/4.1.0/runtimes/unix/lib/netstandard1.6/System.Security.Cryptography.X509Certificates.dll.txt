internal static class FxResources.System.Security.Cryptography.X509Certificates.SR : object {
}
internal static class Internal.Cryptography.ErrorCode : object {
    public static int CERT_E_CHAINING;
    public static int CERT_E_CRITICAL;
    public static int CERT_E_EXPIRED;
    public static int CERT_E_INVALID_NAME;
    public static int CERT_E_INVALID_POLICY;
    public static int CERT_E_UNTRUSTEDROOT;
    public static int CERT_E_VALIDITYPERIODNESTING;
    public static int CERT_E_WRONG_USAGE;
    public static int CERTSRV_E_WEAK_SIGNATURE_OR_KEY;
    public static int CRYPT_E_NO_REVOCATION_CHECK;
    public static int CRYPT_E_NOT_FOUND;
    public static int CRYPT_E_REVOCATION_OFFLINE;
    public static int CRYPT_E_REVOKED;
    public static int CRYPT_E_SIGNER_NOT_FOUND;
    public static int E_POINTER;
    public static int ERROR_INVALID_PARAMETER;
    public static int HRESULT_INVALID_HANDLE;
    public static int NTE_BAD_PUBLIC_KEY;
    public static int TRUST_E_BASIC_CONSTRAINTS;
    public static int TRUST_E_CERT_SIGNATURE;
    public static int TRUST_E_EXPLICIT_DISTRUST;
}
[ExtensionAttribute]
internal static class Internal.Cryptography.Helpers : object {
    [ExtensionAttribute]
public static Byte[] CloneByteArray(Byte[] src);
    [ExtensionAttribute]
public static Char[] ToHexArrayUpper(Byte[] bytes);
    [ExtensionAttribute]
public static string ToHexStringUpper(Byte[] bytes);
    [ExtensionAttribute]
public static Byte[] DecodeHexString(string s);
    private static byte HexToByte(char val);
    private static char NibbleToHex(byte b);
    [ExtensionAttribute]
public static bool ContentsEqual(Byte[] a1, Byte[] a2);
    [ExtensionAttribute]
public static bool IsValidDay(Calendar calendar, int year, int month, int day, int era);
    [ExtensionAttribute]
private static bool IsValidMonth(Calendar calendar, int year, int month, int era);
    [ExtensionAttribute]
private static bool IsValidYear(Calendar calendar, int year, int era);
}
internal interface Internal.Cryptography.ICertificatePal {
    public bool HasPrivateKey { get; }
    public IntPtr Handle { get; }
    public string Issuer { get; }
    public string Subject { get; }
    public Byte[] Thumbprint { get; }
    public string KeyAlgorithm { get; }
    public Byte[] KeyAlgorithmParameters { get; }
    public Byte[] PublicKeyValue { get; }
    public Byte[] SerialNumber { get; }
    public string SignatureAlgorithm { get; }
    public DateTime NotAfter { get; }
    public DateTime NotBefore { get; }
    public Byte[] RawData { get; }
    public int Version { get; }
    public bool Archived { get; public set; }
    public string FriendlyName { get; public set; }
    public X500DistinguishedName SubjectName { get; }
    public X500DistinguishedName IssuerName { get; }
    public IEnumerable`1<X509Extension> Extensions { get; }
    public abstract virtual bool get_HasPrivateKey();
    public abstract virtual IntPtr get_Handle();
    public abstract virtual string get_Issuer();
    public abstract virtual string get_Subject();
    public abstract virtual Byte[] get_Thumbprint();
    public abstract virtual string get_KeyAlgorithm();
    public abstract virtual Byte[] get_KeyAlgorithmParameters();
    public abstract virtual Byte[] get_PublicKeyValue();
    public abstract virtual Byte[] get_SerialNumber();
    public abstract virtual string get_SignatureAlgorithm();
    public abstract virtual DateTime get_NotAfter();
    public abstract virtual DateTime get_NotBefore();
    public abstract virtual Byte[] get_RawData();
    public abstract virtual int get_Version();
    public abstract virtual bool get_Archived();
    public abstract virtual void set_Archived(bool value);
    public abstract virtual string get_FriendlyName();
    public abstract virtual void set_FriendlyName(string value);
    public abstract virtual X500DistinguishedName get_SubjectName();
    public abstract virtual X500DistinguishedName get_IssuerName();
    public abstract virtual IEnumerable`1<X509Extension> get_Extensions();
    public abstract virtual RSA GetRSAPrivateKey();
    public abstract virtual ECDsa GetECDsaPrivateKey();
    public abstract virtual string GetNameInfo(X509NameType nameType, bool forIssuer);
    public abstract virtual void AppendPrivateKeyInfo(StringBuilder sb);
}
internal static class Internal.Cryptography.Oids : object {
    public static string BasicConstraints;
    public static string SubjectKeyIdentifier;
    public static string KeyUsage;
    public static string BasicConstraints2;
    public static string CrlDistributionPoints;
    public static string CertPolicies;
    public static string AnyCertPolicy;
    public static string CertPolicyMappings;
    public static string CertPolicyConstraints;
    public static string EnhancedKeyUsage;
    public static string InhibitAnyPolicyExtension;
    public static string Ecc;
    public static string RsaRsa;
    public static string EmailAddress;
    public static string EnrollCertTypeExtension;
    public static string CertificateTemplate;
    public static string ApplicationCertPolicies;
    public static string AuthorityInformationAccess;
    public static string CertificateAuthorityIssuers;
}
internal static class Internal.Cryptography.Pal.CertificateAssetDownloader : object {
    private static ReadWriteCallback s_writeCallback;
    private static CertificateAssetDownloader();
    internal static X509Certificate2 DownloadCertificate(string uri, TimeSpan& remainingDownloadTime);
    internal static SafeX509CrlHandle DownloadCrl(string uri, TimeSpan& remainingDownloadTime);
    private static Byte[] DownloadAsset(string uri, TimeSpan& remainingDownloadTime);
    private static ulong CurlWriteCallback(IntPtr buffer, ulong size, ulong nitems, IntPtr context);
}
[ExtensionAttribute]
internal static class Internal.Cryptography.Pal.CertificateExtensionsCommon : object {
    [ExtensionAttribute]
public static T GetPublicKey(X509Certificate2 certificate, Predicate`1<X509Certificate2> matchesConstraints);
    [ExtensionAttribute]
public static T GetPrivateKey(X509Certificate2 certificate, Predicate`1<X509Certificate2> matchesConstraints);
    private static string GetExpectedOidValue();
}
internal class Internal.Cryptography.Pal.CertificatePal : object {
    public static ICertificatePal FromHandle(IntPtr handle);
    public static ICertificatePal FromBlob(Byte[] rawData, string password, X509KeyStorageFlags keyStorageFlags);
    public static ICertificatePal FromFile(string fileName, string password, X509KeyStorageFlags keyStorageFlags);
    private static ICertificatePal FromBio(SafeBioHandle bio, string password);
    internal static void RewindBio(SafeBioHandle bio, int bioPosition);
    internal static bool TryReadX509Der(Byte[] rawData, ICertificatePal& certPal);
    internal static bool TryReadX509Pem(SafeBioHandle bio, ICertificatePal& certPal);
    internal static bool TryReadX509Pem(Byte[] rawData, ICertificatePal& certPal);
    internal static bool TryReadX509Der(SafeBioHandle bio, ICertificatePal& fromBio);
}
internal class Internal.Cryptography.Pal.CertificatePolicy : object {
    [CompilerGeneratedAttribute]
private bool <ImplicitAnyCertificatePolicy>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <SpecifiedAnyCertificatePolicy>k__BackingField;
    [CompilerGeneratedAttribute]
private ISet`1<string> <DeclaredCertificatePolicies>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <ImplicitAnyApplicationPolicy>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <SpecifiedAnyApplicationPolicy>k__BackingField;
    [CompilerGeneratedAttribute]
private ISet`1<string> <DeclaredApplicationPolicies>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<int> <InhibitAnyDepth>k__BackingField;
    [CompilerGeneratedAttribute]
private List`1<CertificatePolicyMapping> <PolicyMapping>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<int> <InhibitMappingDepth>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<int> <RequireExplicitPolicyDepth>k__BackingField;
    public bool ImplicitAnyCertificatePolicy { get; public set; }
    public bool SpecifiedAnyCertificatePolicy { get; public set; }
    public ISet`1<string> DeclaredCertificatePolicies { get; public set; }
    public bool ImplicitAnyApplicationPolicy { get; public set; }
    public bool SpecifiedAnyApplicationPolicy { get; public set; }
    public ISet`1<string> DeclaredApplicationPolicies { get; public set; }
    public Nullable`1<int> InhibitAnyDepth { get; public set; }
    public List`1<CertificatePolicyMapping> PolicyMapping { get; public set; }
    public Nullable`1<int> InhibitMappingDepth { get; public set; }
    public Nullable`1<int> RequireExplicitPolicyDepth { get; public set; }
    public bool AllowsAnyCertificatePolicy { get; }
    public bool AllowsAnyApplicationPolicy { get; }
    [CompilerGeneratedAttribute]
public bool get_ImplicitAnyCertificatePolicy();
    [CompilerGeneratedAttribute]
public void set_ImplicitAnyCertificatePolicy(bool value);
    [CompilerGeneratedAttribute]
public bool get_SpecifiedAnyCertificatePolicy();
    [CompilerGeneratedAttribute]
public void set_SpecifiedAnyCertificatePolicy(bool value);
    [CompilerGeneratedAttribute]
public ISet`1<string> get_DeclaredCertificatePolicies();
    [CompilerGeneratedAttribute]
public void set_DeclaredCertificatePolicies(ISet`1<string> value);
    [CompilerGeneratedAttribute]
public bool get_ImplicitAnyApplicationPolicy();
    [CompilerGeneratedAttribute]
public void set_ImplicitAnyApplicationPolicy(bool value);
    [CompilerGeneratedAttribute]
public bool get_SpecifiedAnyApplicationPolicy();
    [CompilerGeneratedAttribute]
public void set_SpecifiedAnyApplicationPolicy(bool value);
    [CompilerGeneratedAttribute]
public ISet`1<string> get_DeclaredApplicationPolicies();
    [CompilerGeneratedAttribute]
public void set_DeclaredApplicationPolicies(ISet`1<string> value);
    [CompilerGeneratedAttribute]
public Nullable`1<int> get_InhibitAnyDepth();
    [CompilerGeneratedAttribute]
public void set_InhibitAnyDepth(Nullable`1<int> value);
    [CompilerGeneratedAttribute]
public List`1<CertificatePolicyMapping> get_PolicyMapping();
    [CompilerGeneratedAttribute]
public void set_PolicyMapping(List`1<CertificatePolicyMapping> value);
    [CompilerGeneratedAttribute]
public Nullable`1<int> get_InhibitMappingDepth();
    [CompilerGeneratedAttribute]
public void set_InhibitMappingDepth(Nullable`1<int> value);
    [CompilerGeneratedAttribute]
public Nullable`1<int> get_RequireExplicitPolicyDepth();
    [CompilerGeneratedAttribute]
public void set_RequireExplicitPolicyDepth(Nullable`1<int> value);
    public bool get_AllowsAnyCertificatePolicy();
    public bool get_AllowsAnyApplicationPolicy();
}
internal class Internal.Cryptography.Pal.CertificatePolicyChain : object {
    private CertificatePolicy[] _policies;
    private bool _failAllCertificatePolicies;
    public CertificatePolicyChain(List`1<X509Certificate2> chain);
    internal bool MatchesCertificatePolicies(OidCollection policyOids);
    internal bool MatchesCertificatePolicies(Oid policyOid);
    internal bool MatchesApplicationPolicies(OidCollection policyOids);
    internal bool MatchesApplicationPolicies(Oid policyOid);
    private void ReadPolicies(List`1<X509Certificate2> chain);
    private static void ApplyRestriction(Int32& restriction, Nullable`1<int> policyRestriction);
    private static CertificatePolicy ReadPolicy(X509Certificate2 cert);
    private static bool CheckExplicitAnyPolicy(ISet`1<string> declaredPolicies);
    private static int ReadInhibitAnyPolicyExtension(X509Extension extension);
    private static void ReadCertPolicyConstraintsExtension(X509Extension extension, CertificatePolicy policy);
    private static ISet`1<string> ReadExtendedKeyUsageExtension(X509Extension extension);
    internal static ISet`1<string> ReadCertPolicyExtension(X509Extension extension);
    private static List`1<CertificatePolicyMapping> ReadCertPolicyMappingsExtension(X509Extension extension);
}
internal class Internal.Cryptography.Pal.CertificatePolicyMapping : ValueType {
    public string IssuerDomainPolicy;
    public string SubjectDomainPolicy;
}
internal class Internal.Cryptography.Pal.ChainPal : object {
    public static bool ReleaseSafeX509ChainHandle(IntPtr handle);
    public static IChainPal BuildChain(bool useMachineContext, ICertificatePal cert, X509Certificate2Collection extraStore, OidCollection applicationPolicy, OidCollection certificatePolicy, X509RevocationMode revocationMode, X509RevocationFlag revocationFlag, DateTime verificationTime, TimeSpan timeout);
    private static void SaveIntermediateCertificates(X509ChainElement[] chainElements, HashSet`1<X509Certificate2> downloaded);
}
internal class Internal.Cryptography.Pal.CollectionBackedStoreProvider : object {
    private X509Certificate2[] _certs;
    private static SafeEvpPKeyHandle InvalidPKeyHandle;
    internal CollectionBackedStoreProvider(X509Certificate2 cert);
    internal CollectionBackedStoreProvider(X509Certificate2Collection certs);
    private static CollectionBackedStoreProvider();
    public sealed virtual void Dispose();
    public sealed virtual Byte[] Export(X509ContentType contentType, string password);
    private Byte[] ExportX509Der();
    private Byte[] ExportPfx(string password);
    private Byte[] ExportPkcs7();
    public sealed virtual void CopyTo(X509Certificate2Collection collection);
    public sealed virtual void Add(ICertificatePal cert);
    public sealed virtual void Remove(ICertificatePal cert);
}
internal static class Internal.Cryptography.Pal.CrlCache : object {
    public static void AddCrlForCertificate(X509Certificate2 cert, SafeX509StoreHandle store, X509RevocationMode revocationMode, DateTime verificationTime, TimeSpan& remainingDownloadTime);
    private static bool AddCachedCrl(X509Certificate2 cert, SafeX509StoreHandle store, DateTime verificationTime);
    private static void DownloadAndAddCrl(X509Certificate2 cert, SafeX509StoreHandle store, TimeSpan& remainingDownloadTime);
    private static string GetCachedCrlPath(X509Certificate2 cert, bool mkDir);
    private static string GetCdpUrl(X509Certificate2 cert);
}
internal class Internal.Cryptography.Pal.DirectoryBasedStoreProvider : object {
    private static int MaxSaveAttempts;
    private static string PfxExtension;
    private static string PfxWildcard;
    private static string PfxOrdinalWildcard;
    private static string s_userStoreRoot;
    private string _storePath;
    private bool _readOnly;
    internal DirectoryBasedStoreProvider(string storeName, OpenFlags openFlags);
    public sealed virtual void Dispose();
    public sealed virtual Byte[] Export(X509ContentType contentType, string password);
    public sealed virtual void CopyTo(X509Certificate2Collection collection);
    public sealed virtual void Add(ICertificatePal certPal);
    public sealed virtual void Remove(ICertificatePal certPal);
    private static string FindExistingFilename(X509Certificate2 cert, string storePath, Boolean& hadCandidates);
    private string FindOpenSlot(string thumbprint);
    private static string GetDirectoryName(string storeName);
    private static void EnsureDirectoryPermissions(string path, UInt32 userId);
    private static void EnsureFilePermissions(FileStream stream, UInt32 userId);
}
internal class Internal.Cryptography.Pal.FindPal : object {
    private static int NamedKeyUsageFlagsCount;
    private static Dictionary`2<string, X509KeyUsageFlags> s_keyUsages;
    private static FindPal();
    public static X509Certificate2Collection FindFromCollection(X509Certificate2Collection coll, X509FindType findType, object findValue, bool validOnly);
    private static T ConfirmedCast(object findValue);
    private static string ConfirmedOidValue(IFindPal findPal, object findValue, OidGroup oidGroup);
    private static X509KeyUsageFlags ConfirmedX509KeyUsage(object findValue);
    internal static void ValidateOidValue(string keyValue);
    internal static BigInteger PositiveBigIntegerFromByteArray(Byte[] bytes);
    private static BigInteger LaxParseDecimalBigInteger(string decimalString);
    internal static IFindPal OpenPal(X509Certificate2Collection findFrom, X509Certificate2Collection copyTo, bool validOnly);
}
internal interface Internal.Cryptography.Pal.IChainPal {
    public X509ChainElement[] ChainElements { get; }
    public X509ChainStatus[] ChainStatus { get; }
    public SafeX509ChainHandle SafeHandle { get; }
    public abstract virtual Nullable`1<bool> Verify(X509VerificationFlags flags, Exception& exception);
    public abstract virtual X509ChainElement[] get_ChainElements();
    public abstract virtual X509ChainStatus[] get_ChainStatus();
    public abstract virtual SafeX509ChainHandle get_SafeHandle();
}
internal interface Internal.Cryptography.Pal.IFindPal {
    public abstract virtual string NormalizeOid(string maybeOid, OidGroup expectedGroup);
    public abstract virtual void FindByThumbprint(Byte[] thumbprint);
    public abstract virtual void FindBySubjectName(string subjectName);
    public abstract virtual void FindBySubjectDistinguishedName(string subjectDistinguishedName);
    public abstract virtual void FindByIssuerName(string issuerName);
    public abstract virtual void FindByIssuerDistinguishedName(string issuerDistinguishedName);
    public abstract virtual void FindBySerialNumber(BigInteger hexValue, BigInteger decimalValue);
    public abstract virtual void FindByTimeValid(DateTime dateTime);
    public abstract virtual void FindByTimeNotYetValid(DateTime dateTime);
    public abstract virtual void FindByTimeExpired(DateTime dateTime);
    public abstract virtual void FindByTemplateName(string templateName);
    public abstract virtual void FindByApplicationPolicy(string oidValue);
    public abstract virtual void FindByCertificatePolicy(string oidValue);
    public abstract virtual void FindByExtension(string oidValue);
    public abstract virtual void FindByKeyUsage(X509KeyUsageFlags keyUsage);
    public abstract virtual void FindBySubjectKeyIdentifier(Byte[] keyIdentifier);
}
internal interface Internal.Cryptography.Pal.IStorePal {
    public abstract virtual Byte[] Export(X509ContentType contentType, string password);
    public abstract virtual void CopyTo(X509Certificate2Collection collection);
    public abstract virtual void Add(ICertificatePal cert);
    public abstract virtual void Remove(ICertificatePal cert);
}
internal interface Internal.Cryptography.Pal.IX509Pal {
    public bool SupportsLegacyBasicConstraintsExtension { get; }
    public abstract virtual AsymmetricAlgorithm DecodePublicKey(Oid oid, Byte[] encodedKeyValue, Byte[] encodedParameters, ICertificatePal certificatePal);
    public abstract virtual string X500DistinguishedNameDecode(Byte[] encodedDistinguishedName, X500DistinguishedNameFlags flag);
    public abstract virtual Byte[] X500DistinguishedNameEncode(string distinguishedName, X500DistinguishedNameFlags flag);
    public abstract virtual string X500DistinguishedNameFormat(Byte[] encodedDistinguishedName, bool multiLine);
    public abstract virtual X509ContentType GetCertContentType(Byte[] rawData);
    public abstract virtual X509ContentType GetCertContentType(string fileName);
    public abstract virtual Byte[] EncodeX509KeyUsageExtension(X509KeyUsageFlags keyUsages);
    public abstract virtual void DecodeX509KeyUsageExtension(Byte[] encoded, X509KeyUsageFlags& keyUsages);
    public abstract virtual bool get_SupportsLegacyBasicConstraintsExtension();
    public abstract virtual Byte[] EncodeX509BasicConstraints2Extension(bool certificateAuthority, bool hasPathLengthConstraint, int pathLengthConstraint);
    public abstract virtual void DecodeX509BasicConstraintsExtension(Byte[] encoded, Boolean& certificateAuthority, Boolean& hasPathLengthConstraint, Int32& pathLengthConstraint);
    public abstract virtual void DecodeX509BasicConstraints2Extension(Byte[] encoded, Boolean& certificateAuthority, Boolean& hasPathLengthConstraint, Int32& pathLengthConstraint);
    public abstract virtual Byte[] EncodeX509EnhancedKeyUsageExtension(OidCollection usages);
    public abstract virtual void DecodeX509EnhancedKeyUsageExtension(Byte[] encoded, OidCollection& usages);
    public abstract virtual Byte[] EncodeX509SubjectKeyIdentifierExtension(Byte[] subjectKeyIdentifier);
    public abstract virtual void DecodeX509SubjectKeyIdentifierExtension(Byte[] encoded, Byte[]& subjectKeyIdentifier);
    public abstract virtual Byte[] ComputeCapiSha1OfPublicKey(PublicKey key);
}
internal class Internal.Cryptography.Pal.OpenSslCertificateFinder : object {
    private X509Certificate2Collection _findFrom;
    private X509Certificate2Collection _copyTo;
    private bool _validOnly;
    internal OpenSslCertificateFinder(X509Certificate2Collection findFrom, X509Certificate2Collection copyTo, bool validOnly);
    public sealed virtual string NormalizeOid(string maybeOid, OidGroup expectedGroup);
    public sealed virtual void FindByThumbprint(Byte[] thumbprint);
    public sealed virtual void FindBySubjectName(string subjectName);
    public sealed virtual void FindBySubjectDistinguishedName(string subjectDistinguishedName);
    public sealed virtual void FindByIssuerName(string issuerName);
    public sealed virtual void FindByIssuerDistinguishedName(string issuerDistinguishedName);
    public sealed virtual void FindBySerialNumber(BigInteger hexValue, BigInteger decimalValue);
    private static DateTime NormalizeDateTime(DateTime dateTime);
    public sealed virtual void FindByTimeValid(DateTime dateTime);
    public sealed virtual void FindByTimeNotYetValid(DateTime dateTime);
    public sealed virtual void FindByTimeExpired(DateTime dateTime);
    public sealed virtual void FindByTemplateName(string templateName);
    public sealed virtual void FindByApplicationPolicy(string oidValue);
    public sealed virtual void FindByCertificatePolicy(string oidValue);
    public sealed virtual void FindByExtension(string oidValue);
    public sealed virtual void FindByKeyUsage(X509KeyUsageFlags keyUsage);
    public sealed virtual void FindBySubjectKeyIdentifier(Byte[] keyIdentifier);
    public sealed virtual void Dispose();
    private static X509Extension FindExtension(X509Certificate2 cert, string extensionOid);
    private void FindCore(Predicate`1<X509Certificate2> predicate);
    private static bool IsCertValid(X509Certificate2 cert);
}
internal class Internal.Cryptography.Pal.OpenSslPkcs12Reader : object {
    private SafePkcs12Handle _pkcs12Handle;
    private SafeEvpPKeyHandle _evpPkeyHandle;
    private SafeX509Handle _x509Handle;
    private SafeX509StackHandle _caStackHandle;
    private OpenSslPkcs12Reader(SafePkcs12Handle pkcs12Handle);
    public static bool TryRead(Byte[] data, OpenSslPkcs12Reader& pkcs12Reader);
    public static bool TryRead(SafeBioHandle fileBio, OpenSslPkcs12Reader& pkcs12Reader);
    public sealed virtual void Dispose();
    public void Decrypt(string password);
    public List`1<OpenSslX509CertificateReader> ReadCertificates();
}
internal class Internal.Cryptography.Pal.OpenSslX509CertificateReader : object {
    private static DateTimeFormatInfo s_validityDateTimeFormatInfo;
    private SafeX509Handle _cert;
    private SafeEvpPKeyHandle _privateKey;
    private X500DistinguishedName _subjectName;
    private X500DistinguishedName _issuerName;
    public bool HasPrivateKey { get; }
    public IntPtr Handle { get; }
    internal SafeX509Handle SafeHandle { get; }
    public string Issuer { get; }
    public string Subject { get; }
    public Byte[] Thumbprint { get; }
    public string KeyAlgorithm { get; }
    public Byte[] KeyAlgorithmParameters { get; }
    public Byte[] PublicKeyValue { get; }
    public Byte[] SerialNumber { get; }
    public string SignatureAlgorithm { get; }
    public DateTime NotAfter { get; }
    public DateTime NotBefore { get; }
    public Byte[] RawData { get; }
    public int Version { get; }
    public bool Archived { get; public set; }
    public string FriendlyName { get; public set; }
    public X500DistinguishedName SubjectName { get; }
    public X500DistinguishedName IssuerName { get; }
    public IEnumerable`1<X509Extension> Extensions { get; }
    internal SafeEvpPKeyHandle PrivateKeyHandle { get; }
    internal OpenSslX509CertificateReader(SafeX509Handle handle);
    public sealed virtual bool get_HasPrivateKey();
    public sealed virtual IntPtr get_Handle();
    internal SafeX509Handle get_SafeHandle();
    public sealed virtual string get_Issuer();
    public sealed virtual string get_Subject();
    public sealed virtual Byte[] get_Thumbprint();
    public sealed virtual string get_KeyAlgorithm();
    public sealed virtual Byte[] get_KeyAlgorithmParameters();
    public sealed virtual Byte[] get_PublicKeyValue();
    public sealed virtual Byte[] get_SerialNumber();
    public sealed virtual string get_SignatureAlgorithm();
    public sealed virtual DateTime get_NotAfter();
    public sealed virtual DateTime get_NotBefore();
    public sealed virtual Byte[] get_RawData();
    public sealed virtual int get_Version();
    public sealed virtual bool get_Archived();
    public sealed virtual void set_Archived(bool value);
    public sealed virtual string get_FriendlyName();
    public sealed virtual void set_FriendlyName(string value);
    public sealed virtual X500DistinguishedName get_SubjectName();
    public sealed virtual X500DistinguishedName get_IssuerName();
    public sealed virtual IEnumerable`1<X509Extension> get_Extensions();
    internal void SetPrivateKey(SafeEvpPKeyHandle privateKey);
    internal SafeEvpPKeyHandle get_PrivateKeyHandle();
    public sealed virtual RSA GetRSAPrivateKey();
    public ECDsa GetECDsaPublicKey();
    public sealed virtual ECDsa GetECDsaPrivateKey();
    public sealed virtual string GetNameInfo(X509NameType nameType, bool forIssuer);
    public sealed virtual void AppendPrivateKeyInfo(StringBuilder sb);
    public sealed virtual void Dispose();
    internal OpenSslX509CertificateReader DuplicateHandles();
    internal static DateTime ExtractValidityDateTime(IntPtr validityDatePtr);
}
internal class Internal.Cryptography.Pal.OpenSslX509ChainProcessor : object {
    private static UInt32 ConstructedSequenceTagId;
    [CompilerGeneratedAttribute]
private X509ChainElement[] <ChainElements>k__BackingField;
    [CompilerGeneratedAttribute]
private X509ChainStatus[] <ChainStatus>k__BackingField;
    public X509ChainElement[] ChainElements { get; private set; }
    public X509ChainStatus[] ChainStatus { get; private set; }
    public SafeX509ChainHandle SafeHandle { get; }
    public sealed virtual void Dispose();
    public sealed virtual Nullable`1<bool> Verify(X509VerificationFlags flags, Exception& exception);
    private static bool HasUnsuppressedError(X509VerificationFlags flags, X509ChainElement element, bool isEndEntity);
    [CompilerGeneratedAttribute]
public sealed virtual X509ChainElement[] get_ChainElements();
    [CompilerGeneratedAttribute]
private void set_ChainElements(X509ChainElement[] value);
    [CompilerGeneratedAttribute]
public sealed virtual X509ChainStatus[] get_ChainStatus();
    [CompilerGeneratedAttribute]
private void set_ChainStatus(X509ChainStatus[] value);
    public sealed virtual SafeX509ChainHandle get_SafeHandle();
    public static IChainPal BuildChain(X509Certificate2 leaf, HashSet`1<X509Certificate2> candidates, HashSet`1<X509Certificate2> downloaded, HashSet`1<X509Certificate2> systemTrusted, OidCollection applicationPolicy, OidCollection certificatePolicy, X509RevocationMode revocationMode, X509RevocationFlag revocationFlag, DateTime verificationTime, TimeSpan& remainingDownloadTime);
    private static void AddElementStatus(List`1<X509VerifyStatusCode> errorCodes, List`1<X509ChainStatus> elementStatus, List`1<X509ChainStatus> overallStatus);
    private static void AddElementStatus(X509VerifyStatusCode errorCode, List`1<X509ChainStatus> elementStatus, List`1<X509ChainStatus> overallStatus);
    private static void AddUniqueStatus(IList`1<X509ChainStatus> list, X509ChainStatus& status);
    private static Nullable`1<X509VerificationFlags> GetSuppressionFlag(X509ChainStatusFlags status);
    private static X509ChainStatusFlags MapVerifyErrorToChainStatus(X509VerifyStatusCode code);
    internal static HashSet`1<X509Certificate2> FindCandidates(X509Certificate2 leaf, X509Certificate2Collection extraStore, HashSet`1<X509Certificate2> downloaded, HashSet`1<X509Certificate2> systemTrusted, TimeSpan& remainingDownloadTime);
    private static HashSet`1<X509Certificate2> FindIssuer(X509Certificate2 cert, X509Certificate2Collection[] stores, HashSet`1<X509Certificate2> downloadedCerts, TimeSpan& remainingDownloadTime);
    private static bool IsSelfSigned(X509Certificate2 cert);
    private static X509Certificate2 DownloadCertificate(Byte[] authorityInformationAccess, TimeSpan& remainingDownloadTime);
    internal static string FindHttpAiaRecord(Byte[] authorityInformationAccess, string recordTypeOid);
}
internal class Internal.Cryptography.Pal.OpenSslX509Encoder : object {
    public bool SupportsLegacyBasicConstraintsExtension { get; }
    public sealed virtual AsymmetricAlgorithm DecodePublicKey(Oid oid, Byte[] encodedKeyValue, Byte[] encodedParameters, ICertificatePal certificatePal);
    public sealed virtual string X500DistinguishedNameDecode(Byte[] encodedDistinguishedName, X500DistinguishedNameFlags flags);
    public sealed virtual Byte[] X500DistinguishedNameEncode(string distinguishedName, X500DistinguishedNameFlags flag);
    public sealed virtual string X500DistinguishedNameFormat(Byte[] encodedDistinguishedName, bool multiLine);
    public sealed virtual X509ContentType GetCertContentType(Byte[] rawData);
    public sealed virtual X509ContentType GetCertContentType(string fileName);
    public sealed virtual Byte[] EncodeX509KeyUsageExtension(X509KeyUsageFlags keyUsages);
    public sealed virtual void DecodeX509KeyUsageExtension(Byte[] encoded, X509KeyUsageFlags& keyUsages);
    public sealed virtual bool get_SupportsLegacyBasicConstraintsExtension();
    public sealed virtual Byte[] EncodeX509BasicConstraints2Extension(bool certificateAuthority, bool hasPathLengthConstraint, int pathLengthConstraint);
    public sealed virtual void DecodeX509BasicConstraintsExtension(Byte[] encoded, Boolean& certificateAuthority, Boolean& hasPathLengthConstraint, Int32& pathLengthConstraint);
    public sealed virtual void DecodeX509BasicConstraints2Extension(Byte[] encoded, Boolean& certificateAuthority, Boolean& hasPathLengthConstraint, Int32& pathLengthConstraint);
    public sealed virtual Byte[] EncodeX509EnhancedKeyUsageExtension(OidCollection usages);
    public sealed virtual void DecodeX509EnhancedKeyUsageExtension(Byte[] encoded, OidCollection& usages);
    public sealed virtual Byte[] EncodeX509SubjectKeyIdentifierExtension(Byte[] subjectKeyIdentifier);
    public sealed virtual void DecodeX509SubjectKeyIdentifierExtension(Byte[] encoded, Byte[]& subjectKeyIdentifier);
    internal static Byte[] DecodeX509SubjectKeyIdentifierExtension(Byte[] encoded);
    public sealed virtual Byte[] ComputeCapiSha1OfPublicKey(PublicKey key);
    private static RSA BuildRsaPublicKey(Byte[] encodedData);
    private static Byte[] ConcatenateArrays(Byte[][] segments);
}
internal static class Internal.Cryptography.Pal.PkcsFormatReader : object {
    internal static bool IsPkcs7(Byte[] rawData);
    internal static bool IsPkcs7Der(SafeBioHandle fileBio);
    internal static bool IsPkcs7Pem(SafeBioHandle fileBio);
    internal static bool TryReadPkcs7Der(Byte[] rawData, ICertificatePal& certPal);
    internal static bool TryReadPkcs7Der(SafeBioHandle bio, ICertificatePal& certPal);
    internal static bool TryReadPkcs7Der(Byte[] rawData, List`1& certPals);
    internal static bool TryReadPkcs7Der(SafeBioHandle bio, List`1& certPals);
    private static bool TryReadPkcs7Der(Byte[] rawData, bool single, ICertificatePal& certPal, List`1& certPals);
    private static bool TryReadPkcs7Der(SafeBioHandle bio, bool single, ICertificatePal& certPal, List`1& certPals);
    internal static bool TryReadPkcs7Pem(Byte[] rawData, ICertificatePal& certPal);
    internal static bool TryReadPkcs7Pem(SafeBioHandle bio, ICertificatePal& certPal);
    internal static bool TryReadPkcs7Pem(Byte[] rawData, List`1& certPals);
    internal static bool TryReadPkcs7Pem(SafeBioHandle bio, List`1& certPals);
    private static bool TryReadPkcs7Pem(Byte[] rawData, bool single, ICertificatePal& certPal, List`1& certPals);
    private static bool TryReadPkcs7Pem(SafeBioHandle bio, bool single, ICertificatePal& certPal, List`1& certPals);
    private static bool TryReadPkcs7(SafePkcs7Handle pkcs7, bool single, ICertificatePal& certPal, List`1& certPals);
    internal static bool TryReadPkcs12(Byte[] rawData, string password, ICertificatePal& certPal);
    internal static bool TryReadPkcs12(SafeBioHandle bio, string password, ICertificatePal& certPal);
    internal static bool TryReadPkcs12(Byte[] rawData, string password, List`1& certPals);
    internal static bool TryReadPkcs12(SafeBioHandle bio, string password, List`1& certPals);
    private static bool TryReadPkcs12(Byte[] rawData, string password, bool single, ICertificatePal& readPal, List`1& readCerts);
    private static bool TryReadPkcs12(SafeBioHandle bio, string password, bool single, ICertificatePal& readPal, List`1& readCerts);
    private static bool TryReadPkcs12(OpenSslPkcs12Reader pfx, string password, bool single, ICertificatePal& readPal, List`1& readCerts);
}
internal class Internal.Cryptography.Pal.StorePal : object {
    private static X509Certificate2Collection s_machineRootStore;
    private static X509Certificate2Collection s_machineIntermediateStore;
    private static StorePal();
    public static IStorePal FromBlob(Byte[] rawData, string password, X509KeyStorageFlags keyStorageFlags);
    public static IStorePal FromFile(string fileName, string password, X509KeyStorageFlags keyStorageFlags);
    private static IStorePal FromBio(SafeBioHandle bio, string password);
    public static IStorePal FromCertificate(ICertificatePal cert);
    public static IStorePal LinkFromCertificateCollection(X509Certificate2Collection certificates);
    public static IStorePal FromSystemStore(string storeName, StoreLocation storeLocation, OpenFlags openFlags);
    private static IStorePal SingleCertToStorePal(ICertificatePal singleCert);
    private static IStorePal ListToStorePal(List`1<ICertificatePal> certPals);
    private static IStorePal CloneStore(X509Certificate2Collection seed);
    private static void LoadMachineStores();
    [IteratorStateMachineAttribute("Internal.Cryptography.Pal.StorePal/<Append>d__12`1")]
private static IEnumerable`1<T> Append(IEnumerable`1<T> current, T addition);
}
internal static class Internal.Cryptography.Pal.X500NameEncoder : object {
    private static string OidTagPrefix;
    private static Char[] s_quoteNeedingChars;
    private static List`1<char> s_useSemicolonSeparators;
    private static List`1<char> s_useCommaSeparators;
    private static List`1<char> s_useNewlineSeparators;
    private static List`1<char> s_defaultSeparators;
    private static X500NameEncoder();
    internal static string X500DistinguishedNameDecode(Byte[] encodedName, bool printOid, X500DistinguishedNameFlags flags, bool addTrailingDelimieter);
    internal static Byte[] X500DistinguishedNameEncode(string stringForm, X500DistinguishedNameFlags flags);
    private static bool NeedsQuoting(string rdnValue);
    private static bool IsQuotableWhitespace(char c);
    private static void AppendOid(StringBuilder decodedName, string oidValue);
    private static List`1<Byte[][]> ParseDistinguishedName(string stringForm, List`1<char> dnSeparators, bool noQuotes);
    private static Oid ParseOid(string stringForm, int tagStart, int tagEnd);
    private static Byte[][] ParseRdn(Oid tagOid, Char[] chars, int valueStart, int valueEnd, bool hadEscapedQuote);
    private static Byte[][] ParseRdn(Byte[][] encodedOid, Char[] chars, int valueStart, int valueEnd, bool ia5String);
    private static Byte[][] ParseRdn(Byte[][] encodedOid, Char[] value, bool ia5String);
    private static Char[] ExtractValue(Char[] chars, int valueStart, int valueEnd);
}
internal class Internal.Cryptography.Pal.X509Pal : object {
    public static IX509Pal Instance;
    private static X509Pal();
}
internal static class Internal.Cryptography.Pal.X509Persistence : object {
    internal static string CryptographyFeatureName;
    internal static string X509StoresSubFeatureName;
    internal static string CrlsSubFeatureName;
}
internal static class Interop : object {
}
[ExtensionAttribute]
internal static class InteropErrorExtensions : object {
    [ExtensionAttribute]
public static ErrorInfo Info(Error error);
}
[SecurityCriticalAttribute]
internal class Microsoft.Win32.SafeHandles.SafeAsn1BitStringHandle : SafeHandle {
    public bool IsInvalid { get; }
    protected virtual bool ReleaseHandle();
    public virtual bool get_IsInvalid();
}
[SecurityCriticalAttribute]
internal class Microsoft.Win32.SafeHandles.SafeAsn1ObjectHandle : SafeHandle {
    public bool IsInvalid { get; }
    protected virtual bool ReleaseHandle();
    public virtual bool get_IsInvalid();
}
[SecurityCriticalAttribute]
internal class Microsoft.Win32.SafeHandles.SafeAsn1OctetStringHandle : SafeHandle {
    public bool IsInvalid { get; }
    protected virtual bool ReleaseHandle();
    public virtual bool get_IsInvalid();
}
[SecurityCriticalAttribute]
internal class Microsoft.Win32.SafeHandles.SafeAsn1StringHandle : SafeHandle {
    public bool IsInvalid { get; }
    protected virtual bool ReleaseHandle();
    public virtual bool get_IsInvalid();
}
[SecurityCriticalAttribute]
internal class Microsoft.Win32.SafeHandles.SafeBignumHandle : SafeHandle {
    public bool IsInvalid { get; }
    internal SafeBignumHandle(IntPtr handle, bool ownsHandle);
    protected virtual bool ReleaseHandle();
    public virtual bool get_IsInvalid();
}
[SecurityCriticalAttribute]
internal class Microsoft.Win32.SafeHandles.SafeBioHandle : SafeHandle {
    public bool IsInvalid { get; }
    protected virtual bool ReleaseHandle();
    public virtual bool get_IsInvalid();
}
[SecurityCriticalAttribute]
internal class Microsoft.Win32.SafeHandles.SafeEkuExtensionHandle : SafeHandle {
    public bool IsInvalid { get; }
    protected virtual bool ReleaseHandle();
    public virtual bool get_IsInvalid();
}
internal static class Microsoft.Win32.SafeHandles.SafeHandleCache`1 : object {
    private static T s_invalidHandle;
    internal static T GetInvalidHandle(Func`1<T> invalidHandleFactory);
    internal static bool IsCachedInvalidHandle(SafeHandle handle);
}
internal abstract class Microsoft.Win32.SafeHandles.SafeInteriorHandle : SafeHandle {
    private SafeHandle _parent;
    public bool IsInvalid { get; }
    protected SafeInteriorHandle(IntPtr invalidHandleValue, bool ownsHandle);
    protected virtual bool ReleaseHandle();
    public virtual bool get_IsInvalid();
    internal void SetParent(SafeHandle parent);
    internal static TInteriorHandle OpenInteriorHandle(Func`2<TExteriorHandle, TInteriorHandle> accessor, TExteriorHandle exteriorHandle);
    internal static TInteriorHandle OpenInteriorHandle(Func`3<TExteriorHandle, TArg1, TInteriorHandle> accessor, TExteriorHandle exteriorHandle, TArg1 arg1);
}
internal class Microsoft.Win32.SafeHandles.SafePkcs12Handle : SafeHandle {
    public bool IsInvalid { get; }
    protected virtual bool ReleaseHandle();
    public virtual bool get_IsInvalid();
}
internal class Microsoft.Win32.SafeHandles.SafePkcs7Handle : SafeHandle {
    public bool IsInvalid { get; }
    protected virtual bool ReleaseHandle();
    public virtual bool get_IsInvalid();
}
[SecurityCriticalAttribute]
internal class Microsoft.Win32.SafeHandles.SafeRsaHandle : SafeHandle {
    public bool IsInvalid { get; }
    protected virtual bool ReleaseHandle();
    public virtual bool get_IsInvalid();
    internal static SafeRsaHandle DuplicateHandle(IntPtr handle);
}
internal class Microsoft.Win32.SafeHandles.SafeSharedAsn1IntegerHandle : SafeInteriorHandle {
}
internal class Microsoft.Win32.SafeHandles.SafeSharedAsn1ObjectHandle : SafeInteriorHandle {
}
internal class Microsoft.Win32.SafeHandles.SafeSharedAsn1StringHandle : SafeInteriorHandle {
}
internal class Microsoft.Win32.SafeHandles.SafeSharedX509NameEntryHandle : SafeInteriorHandle {
}
internal class Microsoft.Win32.SafeHandles.SafeSharedX509NameHandle : SafeInteriorHandle {
}
internal class Microsoft.Win32.SafeHandles.SafeSharedX509NameStackHandle : SafeInteriorHandle {
}
internal class Microsoft.Win32.SafeHandles.SafeSharedX509StackHandle : SafeInteriorHandle {
    internal static SafeSharedX509StackHandle InvalidHandle;
    private static SafeSharedX509StackHandle();
}
public class Microsoft.Win32.SafeHandles.SafeX509ChainHandle : SafeHandle {
    public bool IsInvalid { get; }
    internal static SafeX509ChainHandle InvalidHandle { get; }
    public virtual bool get_IsInvalid();
    internal static SafeX509ChainHandle get_InvalidHandle();
    protected virtual bool ReleaseHandle();
    protected virtual void Dispose(bool disposing);
}
internal class Microsoft.Win32.SafeHandles.SafeX509CrlHandle : SafeHandle {
    public bool IsInvalid { get; }
    protected virtual bool ReleaseHandle();
    public virtual bool get_IsInvalid();
}
[SecurityCriticalAttribute]
internal class Microsoft.Win32.SafeHandles.SafeX509ExtensionHandle : SafeHandle {
    public bool IsInvalid { get; }
    protected virtual bool ReleaseHandle();
    public virtual bool get_IsInvalid();
}
[SecurityCriticalAttribute]
internal class Microsoft.Win32.SafeHandles.SafeX509Handle : SafeHandle {
    internal static SafeX509Handle InvalidHandle;
    public bool IsInvalid { get; }
    private static SafeX509Handle();
    [SecurityCriticalAttribute]
protected virtual bool ReleaseHandle();
    [SecurityCriticalAttribute]
public virtual bool get_IsInvalid();
}
[SecurityCriticalAttribute]
internal class Microsoft.Win32.SafeHandles.SafeX509NameHandle : SafeHandle {
    public bool IsInvalid { get; }
    protected virtual bool ReleaseHandle();
    public virtual bool get_IsInvalid();
}
[SecurityCriticalAttribute]
internal class Microsoft.Win32.SafeHandles.SafeX509NameStackHandle : SafeHandle {
    public bool IsInvalid { get; }
    protected virtual bool ReleaseHandle();
    public virtual bool get_IsInvalid();
}
internal class Microsoft.Win32.SafeHandles.SafeX509StackHandle : SafeHandle {
    public bool IsInvalid { get; }
    protected virtual bool ReleaseHandle();
    public virtual bool get_IsInvalid();
}
internal class Microsoft.Win32.SafeHandles.SafeX509StoreCtxHandle : SafeHandle {
    public bool IsInvalid { get; }
    internal SafeX509StoreCtxHandle(IntPtr handle, bool ownsHandle);
    protected virtual bool ReleaseHandle();
    public virtual bool get_IsInvalid();
}
[SecurityCriticalAttribute]
internal class Microsoft.Win32.SafeHandles.SafeX509StoreHandle : SafeHandle {
    public bool IsInvalid { get; }
    protected virtual bool ReleaseHandle();
    public virtual bool get_IsInvalid();
}
internal static class System.IO.PersistedFiles : object {
    private static string s_userProductDirectory;
    internal static string TopLevelDirectory;
    internal static string TopLevelHiddenDirectory;
    internal static string SecondLevelDirectory;
    internal static string GetUserFeatureDirectory(string featureName);
    internal static string GetUserFeatureDirectory(string featureName, string subFeatureName);
    internal static string GetUserFeatureDirectory(String[] featurePathParts);
    private static void EnsureUserDirectories();
    internal static string GetHomeDirectory();
    private static bool TryGetHomeDirectoryFromPasswd(Byte* buf, int bufLen, String& path);
}
internal static class System.Security.Cryptography.DerEncoder : object {
    private static byte ConstructedFlag;
    private static byte ConstructedSequenceTag;
    private static byte ConstructedSetTag;
    private static Byte[] EncodeLength(int length);
    internal static Byte[][] SegmentedEncodeBoolean(bool value);
    internal static Byte[][] SegmentedEncodeUnsignedInteger(Byte[] bigEndianBytes);
    internal static Byte[][] SegmentedEncodeUnsignedInteger(Byte[] bigEndianBytes, int offset, int count);
    internal static Byte[][] SegmentedEncodeBitString(Byte[] data);
    internal static Byte[][] SegmentedEncodeBitString(int unusedBits, Byte[] data);
    internal static Byte[][] SegmentedEncodeNamedBitList(Byte[] bigEndianBytes, int namedBitsCount);
    internal static Byte[][] SegmentedEncodeOctetString(Byte[] data);
    internal static Byte[][] SegmentedEncodeOid(Oid oid);
    internal static Byte[][] SegmentedEncodeUtf8String(Char[] chars);
    internal static Byte[][] SegmentedEncodeUtf8String(Char[] chars, int offset, int count);
    internal static Byte[][] ConstructSegmentedSequence(Byte[][][] items);
    internal static Byte[][] ConstructSegmentedSet(Byte[][][] items);
    internal static bool IsValidPrintableString(Char[] chars);
    internal static bool IsValidPrintableString(Char[] chars, int offset, int count);
    internal static Byte[][] SegmentedEncodePrintableString(Char[] chars);
    internal static Byte[][] SegmentedEncodePrintableString(Char[] chars, int offset, int count);
    internal static Byte[][] SegmentedEncodeIA5String(Char[] chars);
    internal static Byte[][] SegmentedEncodeIA5String(Char[] chars, int offset, int count);
    internal static Byte[] ConstructSequence(Byte[][][] items);
    internal static Byte[] ConstructSequence(IEnumerable`1<Byte[][]> items);
    private static BigInteger ParseOidRid(string oidValue, Int32& startIndex);
    private static int AtoI(char c);
    private static void EncodeRid(List`1<byte> encodedData, BigInteger& rid);
    private static bool IsPrintableStringCharacter(char c);
    private static Byte[] ConcatenateArrays(Byte[][][] segments);
}
internal class System.Security.Cryptography.DerSequenceReader : object {
    internal static byte ContextSpecificTagFlag;
    private Byte[] _data;
    private int _end;
    private int _position;
    [CompilerGeneratedAttribute]
private int <ContentLength>k__BackingField;
    internal int ContentLength { get; private set; }
    internal bool HasData { get; }
    private DerSequenceReader(bool startAtPayload, Byte[] data);
    internal DerSequenceReader(Byte[] data);
    internal DerSequenceReader(Byte[] data, int offset, int length);
    [CompilerGeneratedAttribute]
internal int get_ContentLength();
    [CompilerGeneratedAttribute]
private void set_ContentLength(int value);
    internal static DerSequenceReader CreateForPayload(Byte[] payload);
    internal bool get_HasData();
    internal byte PeekTag();
    internal void SkipValue();
    internal int ReadInteger();
    internal Byte[] ReadIntegerBytes();
    internal Byte[] ReadOctetString();
    internal string ReadOidAsString();
    internal Oid ReadOid();
    internal DerSequenceReader ReadSequence();
    internal string ReadIA5String();
    private Byte[] ReadContentAsBytes();
    private void EatTag(DerTag expected);
    private static void CheckTag(DerTag expected, Byte[] data, int position);
    private int EatLength();
    private static int ScanContentLength(Byte[] data, int offset, Int32& bytesConsumed);
}
[ExtensionAttribute]
public static class System.Security.Cryptography.X509Certificates.ECDsaCertificateExtensions : object {
    [ExtensionAttribute]
[SecuritySafeCriticalAttribute]
public static ECDsa GetECDsaPublicKey(X509Certificate2 certificate);
    [ExtensionAttribute]
[SecuritySafeCriticalAttribute]
public static ECDsa GetECDsaPrivateKey(X509Certificate2 certificate);
    private static bool HasECDsaKeyUsage(X509Certificate2 certificate);
}
internal static class System.Security.Cryptography.X509Certificates.EnumeratorHelper : object {
    internal static object GetCurrent(TEnumerator& enumerator);
    internal static void Reset(TEnumerator& enumerator);
}
[FlagsAttribute]
public enum System.Security.Cryptography.X509Certificates.OpenFlags : Enum {
    public int value__;
    public static OpenFlags ReadOnly;
    public static OpenFlags ReadWrite;
    public static OpenFlags MaxAllowed;
    public static OpenFlags OpenExistingOnly;
    public static OpenFlags IncludeArchived;
}
public class System.Security.Cryptography.X509Certificates.PublicKey : object {
    [CompilerGeneratedAttribute]
private AsnEncodedData <EncodedKeyValue>k__BackingField;
    [CompilerGeneratedAttribute]
private AsnEncodedData <EncodedParameters>k__BackingField;
    private Oid _oid;
    public AsnEncodedData EncodedKeyValue { get; private set; }
    public AsnEncodedData EncodedParameters { get; private set; }
    public Oid Oid { get; }
    public PublicKey(Oid oid, AsnEncodedData parameters, AsnEncodedData keyValue);
    [CompilerGeneratedAttribute]
public AsnEncodedData get_EncodedKeyValue();
    [CompilerGeneratedAttribute]
private void set_EncodedKeyValue(AsnEncodedData value);
    [CompilerGeneratedAttribute]
public AsnEncodedData get_EncodedParameters();
    [CompilerGeneratedAttribute]
private void set_EncodedParameters(AsnEncodedData value);
    public Oid get_Oid();
}
[ExtensionAttribute]
public static class System.Security.Cryptography.X509Certificates.RSACertificateExtensions : object {
    [ExtensionAttribute]
[SecuritySafeCriticalAttribute]
public static RSA GetRSAPublicKey(X509Certificate2 certificate);
    [ExtensionAttribute]
[SecuritySafeCriticalAttribute]
public static RSA GetRSAPrivateKey(X509Certificate2 certificate);
}
public enum System.Security.Cryptography.X509Certificates.StoreLocation : Enum {
    public int value__;
    public static StoreLocation CurrentUser;
    public static StoreLocation LocalMachine;
}
public enum System.Security.Cryptography.X509Certificates.StoreName : Enum {
    public int value__;
    public static StoreName AddressBook;
    public static StoreName AuthRoot;
    public static StoreName CertificateAuthority;
    public static StoreName Disallowed;
    public static StoreName My;
    public static StoreName Root;
    public static StoreName TrustedPeople;
    public static StoreName TrustedPublisher;
}
public class System.Security.Cryptography.X509Certificates.X500DistinguishedName : AsnEncodedData {
    private String modreq(System.Runtime.CompilerServices.IsVolatile) _lazyDistinguishedName;
    public string Name { get; }
    public X500DistinguishedName(Byte[] encodedDistinguishedName);
    public X500DistinguishedName(AsnEncodedData encodedDistinguishedName);
    public X500DistinguishedName(X500DistinguishedName distinguishedName);
    public X500DistinguishedName(string distinguishedName);
    public X500DistinguishedName(string distinguishedName, X500DistinguishedNameFlags flag);
    public string get_Name();
    public string Decode(X500DistinguishedNameFlags flag);
    public virtual string Format(bool multiLine);
    private static Byte[] Encode(string distinguishedName, X500DistinguishedNameFlags flags);
    private static void ThrowIfInvalid(X500DistinguishedNameFlags flags);
}
[FlagsAttribute]
public enum System.Security.Cryptography.X509Certificates.X500DistinguishedNameFlags : Enum {
    public int value__;
    public static X500DistinguishedNameFlags None;
    public static X500DistinguishedNameFlags Reversed;
    public static X500DistinguishedNameFlags UseSemicolons;
    public static X500DistinguishedNameFlags DoNotUsePlusSign;
    public static X500DistinguishedNameFlags DoNotUseQuotes;
    public static X500DistinguishedNameFlags UseCommas;
    public static X500DistinguishedNameFlags UseNewLines;
    public static X500DistinguishedNameFlags UseUTF8Encoding;
    public static X500DistinguishedNameFlags UseT61Encoding;
    public static X500DistinguishedNameFlags ForceUTF8Encoding;
}
public class System.Security.Cryptography.X509Certificates.X509BasicConstraintsExtension : X509Extension {
    private bool _certificateAuthority;
    private bool _hasPathLenConstraint;
    private int _pathLenConstraint;
    private bool _decoded;
    public bool CertificateAuthority { get; }
    public bool HasPathLengthConstraint { get; }
    public int PathLengthConstraint { get; }
    public X509BasicConstraintsExtension(bool certificateAuthority, bool hasPathLengthConstraint, int pathLengthConstraint, bool critical);
    public X509BasicConstraintsExtension(AsnEncodedData encodedBasicConstraints, bool critical);
    public bool get_CertificateAuthority();
    public bool get_HasPathLengthConstraint();
    public int get_PathLengthConstraint();
    public virtual void CopyFrom(AsnEncodedData asnEncodedData);
    private static Byte[] EncodeExtension(bool certificateAuthority, bool hasPathLengthConstraint, int pathLengthConstraint);
    private void DecodeExtension();
}
public class System.Security.Cryptography.X509Certificates.X509Certificate : object {
    [CompilerGeneratedAttribute]
private ICertificatePal <Pal>k__BackingField;
    private Byte[] modreq(System.Runtime.CompilerServices.IsVolatile) _lazyCertHash;
    private String modreq(System.Runtime.CompilerServices.IsVolatile) _lazyIssuer;
    private String modreq(System.Runtime.CompilerServices.IsVolatile) _lazySubject;
    private Byte[] modreq(System.Runtime.CompilerServices.IsVolatile) _lazySerialNumber;
    private String modreq(System.Runtime.CompilerServices.IsVolatile) _lazyKeyAlgorithm;
    private Byte[] modreq(System.Runtime.CompilerServices.IsVolatile) _lazyKeyAlgorithmParameters;
    private Byte[] modreq(System.Runtime.CompilerServices.IsVolatile) _lazyPublicKey;
    private DateTime _lazyNotBefore;
    private DateTime _lazyNotAfter;
    private static X509KeyStorageFlags KeyStorageFlagsAll;
    public IntPtr Handle { get; }
    public string Issuer { get; }
    public string Subject { get; }
    internal ICertificatePal Pal { get; private set; }
    public X509Certificate(Byte[] data);
    public X509Certificate(Byte[] rawData, string password);
    public X509Certificate(Byte[] rawData, string password, X509KeyStorageFlags keyStorageFlags);
    public X509Certificate(IntPtr handle);
    internal X509Certificate(ICertificatePal pal);
    public X509Certificate(string fileName);
    public X509Certificate(string fileName, string password);
    public X509Certificate(string fileName, string password, X509KeyStorageFlags keyStorageFlags);
    public IntPtr get_Handle();
    public string get_Issuer();
    public string get_Subject();
    public sealed virtual void Dispose();
    protected virtual void Dispose(bool disposing);
    public virtual bool Equals(object obj);
    public virtual bool Equals(X509Certificate other);
    public virtual Byte[] Export(X509ContentType contentType);
    public virtual Byte[] Export(X509ContentType contentType, string password);
    public virtual Byte[] GetCertHash();
    private Byte[] GetRawCertHash();
    public virtual string GetFormat();
    public virtual int GetHashCode();
    public virtual string GetKeyAlgorithm();
    public virtual Byte[] GetKeyAlgorithmParameters();
    public virtual string GetKeyAlgorithmParametersString();
    public virtual Byte[] GetPublicKey();
    public virtual Byte[] GetSerialNumber();
    private Byte[] GetRawSerialNumber();
    public virtual string ToString();
    public virtual string ToString(bool fVerbose);
    [CompilerGeneratedAttribute]
internal ICertificatePal get_Pal();
    [CompilerGeneratedAttribute]
private void set_Pal(ICertificatePal value);
    internal DateTime GetNotAfter();
    internal DateTime GetNotBefore();
    internal void ThrowIfInvalid();
    internal static string FormatDate(DateTime date);
}
public class System.Security.Cryptography.X509Certificates.X509Certificate2 : X509Certificate {
    private Byte[] modreq(System.Runtime.CompilerServices.IsVolatile) _lazyRawData;
    private Oid modreq(System.Runtime.CompilerServices.IsVolatile) _lazySignatureAlgorithm;
    private Int32 modreq(System.Runtime.CompilerServices.IsVolatile) _lazyVersion;
    private X500DistinguishedName modreq(System.Runtime.CompilerServices.IsVolatile) _lazySubjectName;
    private X500DistinguishedName modreq(System.Runtime.CompilerServices.IsVolatile) _lazyIssuer;
    private PublicKey modreq(System.Runtime.CompilerServices.IsVolatile) _lazyPublicKey;
    private X509ExtensionCollection modreq(System.Runtime.CompilerServices.IsVolatile) _lazyExtensions;
    public bool Archived { get; public set; }
    public X509ExtensionCollection Extensions { get; }
    public string FriendlyName { get; public set; }
    public bool HasPrivateKey { get; }
    public X500DistinguishedName IssuerName { get; }
    public DateTime NotAfter { get; }
    public DateTime NotBefore { get; }
    public PublicKey PublicKey { get; }
    public Byte[] RawData { get; }
    public string SerialNumber { get; }
    public Oid SignatureAlgorithm { get; }
    public X500DistinguishedName SubjectName { get; }
    public string Thumbprint { get; }
    public int Version { get; }
    public X509Certificate2(Byte[] rawData);
    public X509Certificate2(Byte[] rawData, string password);
    public X509Certificate2(Byte[] rawData, string password, X509KeyStorageFlags keyStorageFlags);
    public X509Certificate2(IntPtr handle);
    internal X509Certificate2(ICertificatePal pal);
    public X509Certificate2(string fileName);
    public X509Certificate2(string fileName, string password);
    public X509Certificate2(string fileName, string password, X509KeyStorageFlags keyStorageFlags);
    public bool get_Archived();
    public void set_Archived(bool value);
    public X509ExtensionCollection get_Extensions();
    public string get_FriendlyName();
    public void set_FriendlyName(string value);
    public bool get_HasPrivateKey();
    public X500DistinguishedName get_IssuerName();
    public DateTime get_NotAfter();
    public DateTime get_NotBefore();
    public PublicKey get_PublicKey();
    public Byte[] get_RawData();
    public string get_SerialNumber();
    public Oid get_SignatureAlgorithm();
    public X500DistinguishedName get_SubjectName();
    public string get_Thumbprint();
    public int get_Version();
    public static X509ContentType GetCertContentType(Byte[] rawData);
    public static X509ContentType GetCertContentType(string fileName);
    public string GetNameInfo(X509NameType nameType, bool forIssuer);
    public virtual string ToString();
    public virtual string ToString(bool verbose);
    private static X509Extension CreateCustomExtensionIfAny(Oid oid);
}
[DefaultMemberAttribute("Item")]
public class System.Security.Cryptography.X509Certificates.X509Certificate2Collection : X509CertificateCollection {
    public X509Certificate2 Item { get; public set; }
    public X509Certificate2Collection(X509Certificate2 certificate);
    public X509Certificate2Collection(X509Certificate2[] certificates);
    public X509Certificate2Collection(X509Certificate2Collection certificates);
    public X509Certificate2 get_Item(int index);
    public void set_Item(int index, X509Certificate2 value);
    public int Add(X509Certificate2 certificate);
    public void AddRange(X509Certificate2[] certificates);
    public void AddRange(X509Certificate2Collection certificates);
    public bool Contains(X509Certificate2 certificate);
    public Byte[] Export(X509ContentType contentType);
    public Byte[] Export(X509ContentType contentType, string password);
    public X509Certificate2Collection Find(X509FindType findType, object findValue, bool validOnly);
    public X509Certificate2Enumerator GetEnumerator();
    public void Import(Byte[] rawData);
    public void Import(Byte[] rawData, string password, X509KeyStorageFlags keyStorageFlags);
    public void Import(string fileName);
    public void Import(string fileName, string password, X509KeyStorageFlags keyStorageFlags);
    public void Insert(int index, X509Certificate2 certificate);
    public void Remove(X509Certificate2 certificate);
    public void RemoveRange(X509Certificate2[] certificates);
    public void RemoveRange(X509Certificate2Collection certificates);
}
public class System.Security.Cryptography.X509Certificates.X509Certificate2Enumerator : object {
    private Enumerator<X509Certificate> _enumerator;
    public X509Certificate2 Current { get; }
    private object System.Collections.IEnumerator.Current { get; }
    internal X509Certificate2Enumerator(X509Certificate2Collection collection);
    public X509Certificate2 get_Current();
    private sealed virtual override object System.Collections.IEnumerator.get_Current();
    public bool MoveNext();
    private sealed virtual override bool System.Collections.IEnumerator.MoveNext();
    public void Reset();
    private sealed virtual override void System.Collections.IEnumerator.Reset();
}
[DefaultMemberAttribute("Item")]
public class System.Security.Cryptography.X509Certificates.X509CertificateCollection : object {
    private List`1<X509Certificate> _list;
    public int Count { get; }
    private bool System.Collections.ICollection.IsSynchronized { get; }
    private object System.Collections.ICollection.SyncRoot { get; }
    private bool System.Collections.IList.IsFixedSize { get; }
    private bool System.Collections.IList.IsReadOnly { get; }
    private object System.Collections.IList.Item { get; private set; }
    public X509Certificate Item { get; public set; }
    private IList NonGenericList { get; }
    public X509CertificateCollection(X509Certificate[] value);
    public X509CertificateCollection(X509CertificateCollection value);
    public sealed virtual int get_Count();
    private sealed virtual override bool System.Collections.ICollection.get_IsSynchronized();
    private sealed virtual override object System.Collections.ICollection.get_SyncRoot();
    private sealed virtual override bool System.Collections.IList.get_IsFixedSize();
    private sealed virtual override bool System.Collections.IList.get_IsReadOnly();
    private sealed virtual override object System.Collections.IList.get_Item(int index);
    private sealed virtual override void System.Collections.IList.set_Item(int index, object value);
    public X509Certificate get_Item(int index);
    public void set_Item(int index, X509Certificate value);
    public int Add(X509Certificate value);
    public void AddRange(X509Certificate[] value);
    public void AddRange(X509CertificateCollection value);
    public sealed virtual void Clear();
    public bool Contains(X509Certificate value);
    public void CopyTo(X509Certificate[] array, int index);
    public X509CertificateEnumerator GetEnumerator();
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
    public virtual int GetHashCode();
    public int IndexOf(X509Certificate value);
    public void Insert(int index, X509Certificate value);
    public void Remove(X509Certificate value);
    public sealed virtual void RemoveAt(int index);
    private sealed virtual override void System.Collections.ICollection.CopyTo(Array array, int index);
    private sealed virtual override int System.Collections.IList.Add(object value);
    private sealed virtual override bool System.Collections.IList.Contains(object value);
    private sealed virtual override int System.Collections.IList.IndexOf(object value);
    private sealed virtual override void System.Collections.IList.Insert(int index, object value);
    private sealed virtual override void System.Collections.IList.Remove(object value);
    private IList get_NonGenericList();
    internal void GetEnumerator(Enumerator& enumerator);
}
public class System.Security.Cryptography.X509Certificates.X509Chain : object {
    private X509ChainPolicy _chainPolicy;
    private X509ChainStatus[] modreq(System.Runtime.CompilerServices.IsVolatile) _lazyChainStatus;
    private X509ChainElementCollection _chainElements;
    private IChainPal _pal;
    private object _syncRoot;
    public X509ChainElementCollection ChainElements { get; }
    public X509ChainPolicy ChainPolicy { get; public set; }
    public X509ChainStatus[] ChainStatus { get; }
    public SafeX509ChainHandle SafeHandle { get; }
    public X509ChainElementCollection get_ChainElements();
    public X509ChainPolicy get_ChainPolicy();
    public void set_ChainPolicy(X509ChainPolicy value);
    public X509ChainStatus[] get_ChainStatus();
    public SafeX509ChainHandle get_SafeHandle();
    public bool Build(X509Certificate2 certificate);
    public sealed virtual void Dispose();
    protected virtual void Dispose(bool disposing);
    private void Reset();
}
public class System.Security.Cryptography.X509Certificates.X509ChainElement : object {
    [CompilerGeneratedAttribute]
private X509Certificate2 <Certificate>k__BackingField;
    [CompilerGeneratedAttribute]
private X509ChainStatus[] <ChainElementStatus>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Information>k__BackingField;
    public X509Certificate2 Certificate { get; private set; }
    public X509ChainStatus[] ChainElementStatus { get; private set; }
    public string Information { get; private set; }
    internal X509ChainElement(X509Certificate2 certificate, X509ChainStatus[] chainElementStatus, string information);
    [CompilerGeneratedAttribute]
public X509Certificate2 get_Certificate();
    [CompilerGeneratedAttribute]
private void set_Certificate(X509Certificate2 value);
    [CompilerGeneratedAttribute]
public X509ChainStatus[] get_ChainElementStatus();
    [CompilerGeneratedAttribute]
private void set_ChainElementStatus(X509ChainStatus[] value);
    [CompilerGeneratedAttribute]
public string get_Information();
    [CompilerGeneratedAttribute]
private void set_Information(string value);
}
[DefaultMemberAttribute("Item")]
public class System.Security.Cryptography.X509Certificates.X509ChainElementCollection : object {
    private X509ChainElement[] _elements;
    public int Count { get; }
    private bool System.Collections.ICollection.IsSynchronized { get; }
    private object System.Collections.ICollection.SyncRoot { get; }
    public X509ChainElement Item { get; }
    internal X509ChainElementCollection(X509ChainElement[] chainElements);
    public sealed virtual int get_Count();
    private sealed virtual override bool System.Collections.ICollection.get_IsSynchronized();
    private sealed virtual override object System.Collections.ICollection.get_SyncRoot();
    public X509ChainElement get_Item(int index);
    public void CopyTo(X509ChainElement[] array, int index);
    private sealed virtual override void System.Collections.ICollection.CopyTo(Array array, int index);
    public X509ChainElementEnumerator GetEnumerator();
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
}
public class System.Security.Cryptography.X509Certificates.X509ChainElementEnumerator : object {
    private X509ChainElementCollection _chainElements;
    private int _current;
    public X509ChainElement Current { get; }
    private object System.Collections.IEnumerator.Current { get; }
    internal X509ChainElementEnumerator(X509ChainElementCollection chainElements);
    public X509ChainElement get_Current();
    private sealed virtual override object System.Collections.IEnumerator.get_Current();
    public sealed virtual bool MoveNext();
    public sealed virtual void Reset();
}
public class System.Security.Cryptography.X509Certificates.X509ChainPolicy : object {
    [CompilerGeneratedAttribute]
private OidCollection <ApplicationPolicy>k__BackingField;
    [CompilerGeneratedAttribute]
private OidCollection <CertificatePolicy>k__BackingField;
    [CompilerGeneratedAttribute]
private DateTime <VerificationTime>k__BackingField;
    [CompilerGeneratedAttribute]
private TimeSpan <UrlRetrievalTimeout>k__BackingField;
    [CompilerGeneratedAttribute]
private X509Certificate2Collection <ExtraStore>k__BackingField;
    private X509RevocationMode _revocationMode;
    private X509RevocationFlag _revocationFlag;
    private X509VerificationFlags _verificationFlags;
    public OidCollection ApplicationPolicy { get; private set; }
    public OidCollection CertificatePolicy { get; private set; }
    public X509RevocationMode RevocationMode { get; public set; }
    public X509RevocationFlag RevocationFlag { get; public set; }
    public X509VerificationFlags VerificationFlags { get; public set; }
    public DateTime VerificationTime { get; public set; }
    public TimeSpan UrlRetrievalTimeout { get; public set; }
    public X509Certificate2Collection ExtraStore { get; private set; }
    [CompilerGeneratedAttribute]
public OidCollection get_ApplicationPolicy();
    [CompilerGeneratedAttribute]
private void set_ApplicationPolicy(OidCollection value);
    [CompilerGeneratedAttribute]
public OidCollection get_CertificatePolicy();
    [CompilerGeneratedAttribute]
private void set_CertificatePolicy(OidCollection value);
    public X509RevocationMode get_RevocationMode();
    public void set_RevocationMode(X509RevocationMode value);
    public X509RevocationFlag get_RevocationFlag();
    public void set_RevocationFlag(X509RevocationFlag value);
    public X509VerificationFlags get_VerificationFlags();
    public void set_VerificationFlags(X509VerificationFlags value);
    [CompilerGeneratedAttribute]
public DateTime get_VerificationTime();
    [CompilerGeneratedAttribute]
public void set_VerificationTime(DateTime value);
    [CompilerGeneratedAttribute]
public TimeSpan get_UrlRetrievalTimeout();
    [CompilerGeneratedAttribute]
public void set_UrlRetrievalTimeout(TimeSpan value);
    [CompilerGeneratedAttribute]
public X509Certificate2Collection get_ExtraStore();
    [CompilerGeneratedAttribute]
private void set_ExtraStore(X509Certificate2Collection value);
    public void Reset();
}
public class System.Security.Cryptography.X509Certificates.X509ChainStatus : ValueType {
    [CompilerGeneratedAttribute]
private X509ChainStatusFlags <Status>k__BackingField;
    private string _statusInformation;
    public X509ChainStatusFlags Status { get; public set; }
    public string StatusInformation { get; public set; }
    [CompilerGeneratedAttribute]
public X509ChainStatusFlags get_Status();
    [CompilerGeneratedAttribute]
public void set_Status(X509ChainStatusFlags value);
    public string get_StatusInformation();
    public void set_StatusInformation(string value);
}
[FlagsAttribute]
public enum System.Security.Cryptography.X509Certificates.X509ChainStatusFlags : Enum {
    public int value__;
    public static X509ChainStatusFlags NoError;
    public static X509ChainStatusFlags NotTimeValid;
    public static X509ChainStatusFlags NotTimeNested;
    public static X509ChainStatusFlags Revoked;
    public static X509ChainStatusFlags NotSignatureValid;
    public static X509ChainStatusFlags NotValidForUsage;
    public static X509ChainStatusFlags UntrustedRoot;
    public static X509ChainStatusFlags RevocationStatusUnknown;
    public static X509ChainStatusFlags Cyclic;
    public static X509ChainStatusFlags InvalidExtension;
    public static X509ChainStatusFlags InvalidPolicyConstraints;
    public static X509ChainStatusFlags InvalidBasicConstraints;
    public static X509ChainStatusFlags InvalidNameConstraints;
    public static X509ChainStatusFlags HasNotSupportedNameConstraint;
    public static X509ChainStatusFlags HasNotDefinedNameConstraint;
    public static X509ChainStatusFlags HasNotPermittedNameConstraint;
    public static X509ChainStatusFlags HasExcludedNameConstraint;
    public static X509ChainStatusFlags PartialChain;
    public static X509ChainStatusFlags CtlNotTimeValid;
    public static X509ChainStatusFlags CtlNotSignatureValid;
    public static X509ChainStatusFlags CtlNotValidForUsage;
    public static X509ChainStatusFlags OfflineRevocation;
    public static X509ChainStatusFlags NoIssuanceChainPolicy;
    public static X509ChainStatusFlags ExplicitDistrust;
    public static X509ChainStatusFlags HasNotSupportedCriticalExtension;
    public static X509ChainStatusFlags HasWeakSignature;
}
public enum System.Security.Cryptography.X509Certificates.X509ContentType : Enum {
    public int value__;
    public static X509ContentType Unknown;
    public static X509ContentType Cert;
    public static X509ContentType SerializedCert;
    public static X509ContentType Pfx;
    public static X509ContentType Pkcs12;
    public static X509ContentType SerializedStore;
    public static X509ContentType Pkcs7;
    public static X509ContentType Authenticode;
}
public class System.Security.Cryptography.X509Certificates.X509EnhancedKeyUsageExtension : X509Extension {
    private OidCollection _enhancedKeyUsages;
    private bool _decoded;
    public OidCollection EnhancedKeyUsages { get; }
    public X509EnhancedKeyUsageExtension(AsnEncodedData encodedEnhancedKeyUsages, bool critical);
    public X509EnhancedKeyUsageExtension(OidCollection enhancedKeyUsages, bool critical);
    public OidCollection get_EnhancedKeyUsages();
    public virtual void CopyFrom(AsnEncodedData asnEncodedData);
    private static Byte[] EncodeExtension(OidCollection enhancedKeyUsages);
}
public class System.Security.Cryptography.X509Certificates.X509Extension : AsnEncodedData {
    [CompilerGeneratedAttribute]
private bool <Critical>k__BackingField;
    public bool Critical { get; public set; }
    public X509Extension(AsnEncodedData encodedExtension, bool critical);
    public X509Extension(Oid oid, Byte[] rawData, bool critical);
    public X509Extension(string oid, Byte[] rawData, bool critical);
    internal X509Extension(string oidValue);
    [CompilerGeneratedAttribute]
public bool get_Critical();
    [CompilerGeneratedAttribute]
public void set_Critical(bool value);
    public virtual void CopyFrom(AsnEncodedData asnEncodedData);
}
[DefaultMemberAttribute("Item")]
public class System.Security.Cryptography.X509Certificates.X509ExtensionCollection : object {
    private List`1<X509Extension> _list;
    public int Count { get; }
    private bool System.Collections.ICollection.IsSynchronized { get; }
    private object System.Collections.ICollection.SyncRoot { get; }
    public X509Extension Item { get; }
    public X509Extension Item { get; }
    public sealed virtual int get_Count();
    private sealed virtual override bool System.Collections.ICollection.get_IsSynchronized();
    private sealed virtual override object System.Collections.ICollection.get_SyncRoot();
    public X509Extension get_Item(int index);
    public X509Extension get_Item(string oid);
    public int Add(X509Extension extension);
    public void CopyTo(X509Extension[] array, int index);
    private sealed virtual override void System.Collections.ICollection.CopyTo(Array array, int index);
    public X509ExtensionEnumerator GetEnumerator();
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
}
public class System.Security.Cryptography.X509Certificates.X509ExtensionEnumerator : object {
    private X509ExtensionCollection _extensions;
    private int _current;
    public X509Extension Current { get; }
    private object System.Collections.IEnumerator.Current { get; }
    internal X509ExtensionEnumerator(X509ExtensionCollection extensions);
    public X509Extension get_Current();
    private sealed virtual override object System.Collections.IEnumerator.get_Current();
    public sealed virtual bool MoveNext();
    public sealed virtual void Reset();
}
public enum System.Security.Cryptography.X509Certificates.X509FindType : Enum {
    public int value__;
    public static X509FindType FindByThumbprint;
    public static X509FindType FindBySubjectName;
    public static X509FindType FindBySubjectDistinguishedName;
    public static X509FindType FindByIssuerName;
    public static X509FindType FindByIssuerDistinguishedName;
    public static X509FindType FindBySerialNumber;
    public static X509FindType FindByTimeValid;
    public static X509FindType FindByTimeNotYetValid;
    public static X509FindType FindByTimeExpired;
    public static X509FindType FindByTemplateName;
    public static X509FindType FindByApplicationPolicy;
    public static X509FindType FindByCertificatePolicy;
    public static X509FindType FindByExtension;
    public static X509FindType FindByKeyUsage;
    public static X509FindType FindBySubjectKeyIdentifier;
}
[FlagsAttribute]
public enum System.Security.Cryptography.X509Certificates.X509KeyStorageFlags : Enum {
    public int value__;
    public static X509KeyStorageFlags DefaultKeySet;
    public static X509KeyStorageFlags UserKeySet;
    public static X509KeyStorageFlags MachineKeySet;
    public static X509KeyStorageFlags Exportable;
    public static X509KeyStorageFlags UserProtected;
    public static X509KeyStorageFlags PersistKeySet;
}
public class System.Security.Cryptography.X509Certificates.X509KeyUsageExtension : X509Extension {
    private bool _decoded;
    private X509KeyUsageFlags _keyUsages;
    public X509KeyUsageFlags KeyUsages { get; }
    public X509KeyUsageExtension(AsnEncodedData encodedKeyUsage, bool critical);
    public X509KeyUsageExtension(X509KeyUsageFlags keyUsages, bool critical);
    public X509KeyUsageFlags get_KeyUsages();
    public virtual void CopyFrom(AsnEncodedData asnEncodedData);
}
[FlagsAttribute]
public enum System.Security.Cryptography.X509Certificates.X509KeyUsageFlags : Enum {
    public int value__;
    public static X509KeyUsageFlags None;
    public static X509KeyUsageFlags EncipherOnly;
    public static X509KeyUsageFlags CrlSign;
    public static X509KeyUsageFlags KeyCertSign;
    public static X509KeyUsageFlags KeyAgreement;
    public static X509KeyUsageFlags DataEncipherment;
    public static X509KeyUsageFlags KeyEncipherment;
    public static X509KeyUsageFlags NonRepudiation;
    public static X509KeyUsageFlags DigitalSignature;
    public static X509KeyUsageFlags DecipherOnly;
}
public enum System.Security.Cryptography.X509Certificates.X509NameType : Enum {
    public int value__;
    public static X509NameType SimpleName;
    public static X509NameType EmailName;
    public static X509NameType UpnName;
    public static X509NameType DnsName;
    public static X509NameType DnsFromAlternativeName;
    public static X509NameType UrlName;
}
public enum System.Security.Cryptography.X509Certificates.X509RevocationFlag : Enum {
    public int value__;
    public static X509RevocationFlag EndCertificateOnly;
    public static X509RevocationFlag EntireChain;
    public static X509RevocationFlag ExcludeRoot;
}
public enum System.Security.Cryptography.X509Certificates.X509RevocationMode : Enum {
    public int value__;
    public static X509RevocationMode NoCheck;
    public static X509RevocationMode Online;
    public static X509RevocationMode Offline;
}
public class System.Security.Cryptography.X509Certificates.X509Store : object {
    [CompilerGeneratedAttribute]
private StoreLocation <Location>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Name>k__BackingField;
    private IStorePal _storePal;
    public StoreLocation Location { get; private set; }
    public string Name { get; private set; }
    public X509Certificate2Collection Certificates { get; }
    public X509Store(StoreName storeName, StoreLocation storeLocation);
    public X509Store(string storeName, StoreLocation storeLocation);
    [CompilerGeneratedAttribute]
public StoreLocation get_Location();
    [CompilerGeneratedAttribute]
private void set_Location(StoreLocation value);
    [CompilerGeneratedAttribute]
public string get_Name();
    [CompilerGeneratedAttribute]
private void set_Name(string value);
    public void Open(OpenFlags flags);
    public X509Certificate2Collection get_Certificates();
    public void Add(X509Certificate2 certificate);
    public void Remove(X509Certificate2 certificate);
    public sealed virtual void Dispose();
    private void Close();
}
public class System.Security.Cryptography.X509Certificates.X509SubjectKeyIdentifierExtension : X509Extension {
    private string _subjectKeyIdentifier;
    private bool _decoded;
    public string SubjectKeyIdentifier { get; }
    public X509SubjectKeyIdentifierExtension(AsnEncodedData encodedSubjectKeyIdentifier, bool critical);
    public X509SubjectKeyIdentifierExtension(Byte[] subjectKeyIdentifier, bool critical);
    public X509SubjectKeyIdentifierExtension(PublicKey key, bool critical);
    public X509SubjectKeyIdentifierExtension(PublicKey key, X509SubjectKeyIdentifierHashAlgorithm algorithm, bool critical);
    public X509SubjectKeyIdentifierExtension(string subjectKeyIdentifier, bool critical);
    public string get_SubjectKeyIdentifier();
    public virtual void CopyFrom(AsnEncodedData asnEncodedData);
    private static Byte[] EncodeExtension(Byte[] subjectKeyIdentifier);
    private static Byte[] EncodeExtension(string subjectKeyIdentifier);
    private static Byte[] EncodeExtension(PublicKey key, X509SubjectKeyIdentifierHashAlgorithm algorithm);
    private static Byte[] GenerateSubjectKeyIdentifierFromPublicKey(PublicKey key, X509SubjectKeyIdentifierHashAlgorithm algorithm);
    private static Byte[] ComputeSha1(Byte[] data);
}
public enum System.Security.Cryptography.X509Certificates.X509SubjectKeyIdentifierHashAlgorithm : Enum {
    public int value__;
    public static X509SubjectKeyIdentifierHashAlgorithm Sha1;
    public static X509SubjectKeyIdentifierHashAlgorithm ShortSha1;
    public static X509SubjectKeyIdentifierHashAlgorithm CapiSha1;
}
[FlagsAttribute]
public enum System.Security.Cryptography.X509Certificates.X509VerificationFlags : Enum {
    public int value__;
    public static X509VerificationFlags NoFlag;
    public static X509VerificationFlags IgnoreNotTimeValid;
    public static X509VerificationFlags IgnoreCtlNotTimeValid;
    public static X509VerificationFlags IgnoreNotTimeNested;
    public static X509VerificationFlags IgnoreInvalidBasicConstraints;
    public static X509VerificationFlags AllowUnknownCertificateAuthority;
    public static X509VerificationFlags IgnoreWrongUsage;
    public static X509VerificationFlags IgnoreInvalidName;
    public static X509VerificationFlags IgnoreInvalidPolicy;
    public static X509VerificationFlags IgnoreEndRevocationUnknown;
    public static X509VerificationFlags IgnoreCtlSignerRevocationUnknown;
    public static X509VerificationFlags IgnoreCertificateAuthorityRevocationUnknown;
    public static X509VerificationFlags IgnoreRootRevocationUnknown;
    public static X509VerificationFlags AllFlags;
}
internal static class System.SR : object {
    private static ResourceManager s_resourceManager;
    private static string s_resourcesName;
    private static ResourceManager ResourceManager { get; }
    internal static string Arg_EmptyOrNullArray { get; }
    internal static string Arg_EmptyOrNullString { get; }
    internal static string Arg_EnumIllegalVal { get; }
    internal static string Arg_InvalidHandle { get; }
    internal static string Arg_OutOfRange_NeedNonNegNum { get; }
    internal static string Arg_RankMultiDimNotSupported { get; }
    internal static string Arg_RemoveArgNotFound { get; }
    internal static string Argument_InvalidFlag { get; }
    internal static string Argument_InvalidNameType { get; }
    internal static string Argument_InvalidOffLen { get; }
    internal static string Argument_InvalidOidValue { get; }
    internal static string ArgumentOutOfRange_Index { get; }
    internal static string Chain_NoPolicyMatch { get; }
    internal static string Cryptography_InvalidContextHandle { get; }
    internal static string Cryptography_InvalidHandle { get; }
    internal static string Cryptography_InvalidOID { get; }
    internal static string Cryptography_InvalidStoreHandle { get; }
    internal static string Cryptography_Unix_X509_MachineStoresReadOnly { get; }
    internal static string Cryptography_Unix_X509_MachineStoresRootOnly { get; }
    internal static string Cryptography_Unix_X509_PropertyNotSettable { get; }
    internal static string Cryptography_Unix_X509_SerializedExport { get; }
    internal static string Cryptography_X509_ExportFailed { get; }
    internal static string Cryptography_X509_ExtensionMismatch { get; }
    internal static string Cryptography_X509_InvalidContentType { get; }
    internal static string Cryptography_X509_InvalidFindType { get; }
    internal static string Cryptography_X509_InvalidFindValue { get; }
    internal static string Cryptography_X509_KeyMismatch { get; }
    internal static string Cryptography_X509_PKCS7_NoSigner { get; }
    internal static string Cryptography_X509_StoreNoFileAvailable { get; }
    internal static string Cryptography_X509_StoreNotFound { get; }
    internal static string Cryptography_X509_StoreNotOpen { get; }
    internal static string Cryptography_X509_StoreReadOnly { get; }
    internal static string InvalidOperation_EnumNotStarted { get; }
    internal static string InvalidPublicKeyInX509 { get; }
    internal static string NotSupported_ECDsa_Csp { get; }
    internal static string NotSupported_Export_MultiplePrivateCerts { get; }
    internal static string NotSupported_InvalidKeyImpl { get; }
    internal static string NotSupported_KeyAlgorithm { get; }
    internal static string NotSupported_LegacyBasicConstraints { get; }
    internal static string PersistedFiles_NoHomeDirectory { get; }
    internal static string Security_InvalidValue { get; }
    internal static string Unknown_Error { get; }
    internal static string Cryptography_FileStatusError { get; }
    internal static string Cryptography_InvalidDirectoryPermissions { get; }
    internal static string Cryptography_OwnerNotCurrentUser { get; }
    internal static string Cryptography_InvalidFilePermissions { get; }
    internal static string Cryptography_Invalid_X500Name { get; }
    internal static string Cryptography_Invalid_IA5String { get; }
    internal static Type ResourceType { get; }
    private static ResourceManager get_ResourceManager();
    private static bool UsingResourceKeys();
    internal static string GetResourceString(string resourceKey, string defaultString);
    internal static string Format(string resourceFormat, Object[] args);
    internal static string Format(string resourceFormat, object p1);
    internal static string Format(string resourceFormat, object p1, object p2);
    internal static string Format(string resourceFormat, object p1, object p2, object p3);
    internal static string get_Arg_EmptyOrNullArray();
    internal static string get_Arg_EmptyOrNullString();
    internal static string get_Arg_EnumIllegalVal();
    internal static string get_Arg_InvalidHandle();
    internal static string get_Arg_OutOfRange_NeedNonNegNum();
    internal static string get_Arg_RankMultiDimNotSupported();
    internal static string get_Arg_RemoveArgNotFound();
    internal static string get_Argument_InvalidFlag();
    internal static string get_Argument_InvalidNameType();
    internal static string get_Argument_InvalidOffLen();
    internal static string get_Argument_InvalidOidValue();
    internal static string get_ArgumentOutOfRange_Index();
    internal static string get_Chain_NoPolicyMatch();
    internal static string get_Cryptography_InvalidContextHandle();
    internal static string get_Cryptography_InvalidHandle();
    internal static string get_Cryptography_InvalidOID();
    internal static string get_Cryptography_InvalidStoreHandle();
    internal static string get_Cryptography_Unix_X509_MachineStoresReadOnly();
    internal static string get_Cryptography_Unix_X509_MachineStoresRootOnly();
    internal static string get_Cryptography_Unix_X509_PropertyNotSettable();
    internal static string get_Cryptography_Unix_X509_SerializedExport();
    internal static string get_Cryptography_X509_ExportFailed();
    internal static string get_Cryptography_X509_ExtensionMismatch();
    internal static string get_Cryptography_X509_InvalidContentType();
    internal static string get_Cryptography_X509_InvalidFindType();
    internal static string get_Cryptography_X509_InvalidFindValue();
    internal static string get_Cryptography_X509_KeyMismatch();
    internal static string get_Cryptography_X509_PKCS7_NoSigner();
    internal static string get_Cryptography_X509_StoreNoFileAvailable();
    internal static string get_Cryptography_X509_StoreNotFound();
    internal static string get_Cryptography_X509_StoreNotOpen();
    internal static string get_Cryptography_X509_StoreReadOnly();
    internal static string get_InvalidOperation_EnumNotStarted();
    internal static string get_InvalidPublicKeyInX509();
    internal static string get_NotSupported_ECDsa_Csp();
    internal static string get_NotSupported_Export_MultiplePrivateCerts();
    internal static string get_NotSupported_InvalidKeyImpl();
    internal static string get_NotSupported_KeyAlgorithm();
    internal static string get_NotSupported_LegacyBasicConstraints();
    internal static string get_PersistedFiles_NoHomeDirectory();
    internal static string get_Security_InvalidValue();
    internal static string get_Unknown_Error();
    internal static string get_Cryptography_FileStatusError();
    internal static string get_Cryptography_InvalidDirectoryPermissions();
    internal static string get_Cryptography_OwnerNotCurrentUser();
    internal static string get_Cryptography_InvalidFilePermissions();
    internal static string get_Cryptography_Invalid_X500Name();
    internal static string get_Cryptography_Invalid_IA5String();
    internal static Type get_ResourceType();
}
