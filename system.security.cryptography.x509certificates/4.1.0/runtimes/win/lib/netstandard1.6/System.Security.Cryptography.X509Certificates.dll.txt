internal static class FxResources.System.Security.Cryptography.X509Certificates.SR : object {
}
[ExtensionAttribute]
internal static class Internal.Cryptography.CryptoThrowHelper : object {
    [ExtensionAttribute]
public static CryptographicException ToCryptographicException(int hr);
}
internal static class Internal.Cryptography.ErrorCode : object {
    public static int CERT_E_CHAINING;
    public static int CERT_E_CRITICAL;
    public static int CERT_E_EXPIRED;
    public static int CERT_E_INVALID_NAME;
    public static int CERT_E_INVALID_POLICY;
    public static int CERT_E_UNTRUSTEDROOT;
    public static int CERT_E_VALIDITYPERIODNESTING;
    public static int CERT_E_WRONG_USAGE;
    public static int CERTSRV_E_WEAK_SIGNATURE_OR_KEY;
    public static int CRYPT_E_NO_REVOCATION_CHECK;
    public static int CRYPT_E_NOT_FOUND;
    public static int CRYPT_E_REVOCATION_OFFLINE;
    public static int CRYPT_E_REVOKED;
    public static int CRYPT_E_SIGNER_NOT_FOUND;
    public static int E_POINTER;
    public static int ERROR_INVALID_PARAMETER;
    public static int HRESULT_INVALID_HANDLE;
    public static int NTE_BAD_PUBLIC_KEY;
    public static int TRUST_E_BASIC_CONSTRAINTS;
    public static int TRUST_E_CERT_SIGNATURE;
    public static int TRUST_E_EXPLICIT_DISTRUST;
}
[ExtensionAttribute]
internal static class Internal.Cryptography.Helpers : object {
    [ExtensionAttribute]
public static Byte[] CloneByteArray(Byte[] src);
    [ExtensionAttribute]
public static Char[] ToHexArrayUpper(Byte[] bytes);
    [ExtensionAttribute]
public static string ToHexStringUpper(Byte[] bytes);
    [ExtensionAttribute]
public static Byte[] DecodeHexString(string s);
    private static byte HexToByte(char val);
    private static char NibbleToHex(byte b);
    [ExtensionAttribute]
public static bool ContentsEqual(Byte[] a1, Byte[] a2);
    [ExtensionAttribute]
public static bool IsValidDay(Calendar calendar, int year, int month, int day, int era);
    [ExtensionAttribute]
private static bool IsValidMonth(Calendar calendar, int year, int month, int era);
    [ExtensionAttribute]
private static bool IsValidYear(Calendar calendar, int year, int era);
}
internal interface Internal.Cryptography.ICertificatePal {
    public bool HasPrivateKey { get; }
    public IntPtr Handle { get; }
    public string Issuer { get; }
    public string Subject { get; }
    public Byte[] Thumbprint { get; }
    public string KeyAlgorithm { get; }
    public Byte[] KeyAlgorithmParameters { get; }
    public Byte[] PublicKeyValue { get; }
    public Byte[] SerialNumber { get; }
    public string SignatureAlgorithm { get; }
    public DateTime NotAfter { get; }
    public DateTime NotBefore { get; }
    public Byte[] RawData { get; }
    public int Version { get; }
    public bool Archived { get; public set; }
    public string FriendlyName { get; public set; }
    public X500DistinguishedName SubjectName { get; }
    public X500DistinguishedName IssuerName { get; }
    public IEnumerable`1<X509Extension> Extensions { get; }
    public abstract virtual bool get_HasPrivateKey();
    public abstract virtual IntPtr get_Handle();
    public abstract virtual string get_Issuer();
    public abstract virtual string get_Subject();
    public abstract virtual Byte[] get_Thumbprint();
    public abstract virtual string get_KeyAlgorithm();
    public abstract virtual Byte[] get_KeyAlgorithmParameters();
    public abstract virtual Byte[] get_PublicKeyValue();
    public abstract virtual Byte[] get_SerialNumber();
    public abstract virtual string get_SignatureAlgorithm();
    public abstract virtual DateTime get_NotAfter();
    public abstract virtual DateTime get_NotBefore();
    public abstract virtual Byte[] get_RawData();
    public abstract virtual int get_Version();
    public abstract virtual bool get_Archived();
    public abstract virtual void set_Archived(bool value);
    public abstract virtual string get_FriendlyName();
    public abstract virtual void set_FriendlyName(string value);
    public abstract virtual X500DistinguishedName get_SubjectName();
    public abstract virtual X500DistinguishedName get_IssuerName();
    public abstract virtual IEnumerable`1<X509Extension> get_Extensions();
    public abstract virtual RSA GetRSAPrivateKey();
    public abstract virtual ECDsa GetECDsaPrivateKey();
    public abstract virtual string GetNameInfo(X509NameType nameType, bool forIssuer);
    public abstract virtual void AppendPrivateKeyInfo(StringBuilder sb);
}
internal static class Internal.Cryptography.Oids : object {
    public static string BasicConstraints;
    public static string SubjectKeyIdentifier;
    public static string KeyUsage;
    public static string BasicConstraints2;
    public static string CrlDistributionPoints;
    public static string CertPolicies;
    public static string AnyCertPolicy;
    public static string CertPolicyMappings;
    public static string CertPolicyConstraints;
    public static string EnhancedKeyUsage;
    public static string InhibitAnyPolicyExtension;
    public static string Ecc;
    public static string RsaRsa;
    public static string EmailAddress;
    public static string EnrollCertTypeExtension;
    public static string CertificateTemplate;
    public static string ApplicationCertPolicies;
    public static string AuthorityInformationAccess;
    public static string CertificateAuthorityIssuers;
}
[ExtensionAttribute]
internal static class Internal.Cryptography.Pal.CertificateExtensionsCommon : object {
    [ExtensionAttribute]
public static T GetPublicKey(X509Certificate2 certificate, Predicate`1<X509Certificate2> matchesConstraints);
    [ExtensionAttribute]
public static T GetPrivateKey(X509Certificate2 certificate, Predicate`1<X509Certificate2> matchesConstraints);
    private static string GetExpectedOidValue();
}
internal class Internal.Cryptography.Pal.CertificatePal : object {
    private SafeCertContextHandle _certContext;
    private static ExpectedContentTypeFlags X509ExpectedContentTypeFlags;
    private static ExpectedFormatTypeFlags X509ExpectedFormatTypeFlags;
    public IntPtr Handle { get; }
    public string Issuer { get; }
    public string Subject { get; }
    public Byte[] Thumbprint { get; }
    public string KeyAlgorithm { get; }
    public Byte[] KeyAlgorithmParameters { get; }
    public Byte[] PublicKeyValue { get; }
    public Byte[] SerialNumber { get; }
    public string SignatureAlgorithm { get; }
    public DateTime NotAfter { get; }
    public DateTime NotBefore { get; }
    public Byte[] RawData { get; }
    public int Version { get; }
    public bool Archived { get; public set; }
    public string FriendlyName { get; public set; }
    public X500DistinguishedName SubjectName { get; }
    public X500DistinguishedName IssuerName { get; }
    public IEnumerable`1<X509Extension> Extensions { get; }
    internal SafeCertContextHandle CertContext { get; }
    public bool HasPrivateKey { get; }
    private CertificatePal(SafeCertContextHandle certContext, bool deleteKeyContainer);
    public static ICertificatePal FromHandle(IntPtr handle);
    public sealed virtual IntPtr get_Handle();
    public sealed virtual string get_Issuer();
    public sealed virtual string get_Subject();
    public sealed virtual Byte[] get_Thumbprint();
    public sealed virtual string get_KeyAlgorithm();
    public sealed virtual Byte[] get_KeyAlgorithmParameters();
    private Byte[] PropagateKeyAlgorithmParametersFromChain();
    public sealed virtual Byte[] get_PublicKeyValue();
    public sealed virtual Byte[] get_SerialNumber();
    public sealed virtual string get_SignatureAlgorithm();
    public sealed virtual DateTime get_NotAfter();
    public sealed virtual DateTime get_NotBefore();
    public sealed virtual Byte[] get_RawData();
    public sealed virtual int get_Version();
    public sealed virtual bool get_Archived();
    public sealed virtual void set_Archived(bool value);
    public sealed virtual string get_FriendlyName();
    public sealed virtual void set_FriendlyName(string value);
    public sealed virtual X500DistinguishedName get_SubjectName();
    public sealed virtual X500DistinguishedName get_IssuerName();
    public sealed virtual IEnumerable`1<X509Extension> get_Extensions();
    public sealed virtual string GetNameInfo(X509NameType nameType, bool forIssuer);
    public sealed virtual void AppendPrivateKeyInfo(StringBuilder sb);
    public sealed virtual void Dispose();
    internal SafeCertContextHandle get_CertContext();
    private static CertNameType MapNameType(X509NameType nameType);
    private string GetIssuerOrSubject(bool issuer);
    public static ICertificatePal FromBlob(Byte[] rawData, string password, X509KeyStorageFlags keyStorageFlags);
    public static ICertificatePal FromFile(string fileName, string password, X509KeyStorageFlags keyStorageFlags);
    private static ICertificatePal FromBlobOrFile(Byte[] rawData, string fileName, string password, X509KeyStorageFlags keyStorageFlags);
    private static SafeCertContextHandle GetSignerInPKCS7Store(SafeCertStoreHandle hCertStore, SafeCryptMsgHandle hCryptMsg);
    private static SafeCertContextHandle FilterPFXStore(Byte[] rawData, string password, PfxCertStoreFlags pfxCertStoreFlags);
    private static PfxCertStoreFlags MapKeyStorageFlags(X509KeyStorageFlags keyStorageFlags);
    public sealed virtual bool get_HasPrivateKey();
    public sealed virtual RSA GetRSAPrivateKey();
    public sealed virtual ECDsa GetECDsaPrivateKey();
    private T GetPrivateKey(Func`2<CspParameters, T> createCsp, Func`2<CngKey, T> createCng);
    private static SafeNCryptKeyHandle TryAcquireCngPrivateKey(SafeCertContextHandle certificateContext);
    private CspParameters GetPrivateKey();
}
internal class Internal.Cryptography.Pal.ChainPal : object {
    private SafeX509ChainHandle _chain;
    private static X509ChainErrorMapping[] s_x509ChainErrorMappings;
    public X509ChainElement[] ChainElements { get; }
    public X509ChainStatus[] ChainStatus { get; }
    public SafeX509ChainHandle SafeHandle { get; }
    private ChainPal(SafeX509ChainHandle chain);
    private static ChainPal();
    public static ChainPal BuildChain(bool useMachineContext, ICertificatePal cert, X509Certificate2Collection extraStore, OidCollection applicationPolicy, OidCollection certificatePolicy, X509RevocationMode revocationMode, X509RevocationFlag revocationFlag, DateTime verificationTime, TimeSpan timeout);
    private static SafeCertStoreHandle ConvertExtraStoreToSafeHandle(X509Certificate2Collection extraStore);
    private static CertChainFlags MapRevocationFlags(X509RevocationMode revocationMode, X509RevocationFlag revocationFlag);
    public sealed virtual Nullable`1<bool> Verify(X509VerificationFlags flags, Exception& exception);
    public sealed virtual X509ChainElement[] get_ChainElements();
    public sealed virtual X509ChainStatus[] get_ChainStatus();
    public sealed virtual SafeX509ChainHandle get_SafeHandle();
    public static bool ReleaseSafeX509ChainHandle(IntPtr handle);
    public sealed virtual void Dispose();
    private static X509ChainStatus[] GetChainStatusInformation(CertTrustErrorStatus dwStatus);
    private static string GetSystemErrorString(int errorCode);
}
internal class Internal.Cryptography.Pal.FindPal : object {
    private static int NamedKeyUsageFlagsCount;
    private static Dictionary`2<string, X509KeyUsageFlags> s_keyUsages;
    private StorePal _storePal;
    private X509Certificate2Collection _copyTo;
    private bool _validOnly;
    internal FindPal(X509Certificate2Collection findFrom, X509Certificate2Collection copyTo, bool validOnly);
    private static FindPal();
    public static X509Certificate2Collection FindFromCollection(X509Certificate2Collection coll, X509FindType findType, object findValue, bool validOnly);
    private static T ConfirmedCast(object findValue);
    private static string ConfirmedOidValue(IFindPal findPal, object findValue, OidGroup oidGroup);
    private static X509KeyUsageFlags ConfirmedX509KeyUsage(object findValue);
    internal static void ValidateOidValue(string keyValue);
    internal static BigInteger PositiveBigIntegerFromByteArray(Byte[] bytes);
    private static BigInteger LaxParseDecimalBigInteger(string decimalString);
    internal static IFindPal OpenPal(X509Certificate2Collection findFrom, X509Certificate2Collection copyTo, bool validOnly);
    public sealed virtual string NormalizeOid(string maybeOid, OidGroup expectedGroup);
    public sealed virtual void FindByThumbprint(Byte[] thumbPrint);
    public sealed virtual void FindBySubjectName(string subjectName);
    public sealed virtual void FindBySubjectDistinguishedName(string subjectDistinguishedName);
    public sealed virtual void FindByIssuerName(string issuerName);
    public sealed virtual void FindByIssuerDistinguishedName(string issuerDistinguishedName);
    public sealed virtual void FindBySerialNumber(BigInteger hexValue, BigInteger decimalValue);
    public sealed virtual void FindByTimeValid(DateTime dateTime);
    public sealed virtual void FindByTimeNotYetValid(DateTime dateTime);
    public sealed virtual void FindByTimeExpired(DateTime dateTime);
    private void FindByTime(DateTime dateTime, int compareResult);
    public sealed virtual void FindByTemplateName(string templateName);
    public sealed virtual void FindByApplicationPolicy(string oidValue);
    public sealed virtual void FindByCertificatePolicy(string oidValue);
    public sealed virtual void FindByExtension(string oidValue);
    public sealed virtual void FindByKeyUsage(X509KeyUsageFlags keyUsage);
    public sealed virtual void FindBySubjectKeyIdentifier(Byte[] keyIdentifier);
    public sealed virtual void Dispose();
    private void FindCore(Func`2<SafeCertContextHandle, bool> filter);
    private void FindCore(CertFindType dwFindType, Void* pvFindPara, Func`2<SafeCertContextHandle, bool> filter);
    private static bool VerifyCertificateIgnoringErrors(SafeCertContextHandle pCertContext);
    private static string GetCertNameInfo(SafeCertContextHandle pCertContext, CertNameType dwNameType, CertNameFlags dwNameFlags);
}
internal interface Internal.Cryptography.Pal.IChainPal {
    public X509ChainElement[] ChainElements { get; }
    public X509ChainStatus[] ChainStatus { get; }
    public SafeX509ChainHandle SafeHandle { get; }
    public abstract virtual Nullable`1<bool> Verify(X509VerificationFlags flags, Exception& exception);
    public abstract virtual X509ChainElement[] get_ChainElements();
    public abstract virtual X509ChainStatus[] get_ChainStatus();
    public abstract virtual SafeX509ChainHandle get_SafeHandle();
}
internal interface Internal.Cryptography.Pal.IFindPal {
    public abstract virtual string NormalizeOid(string maybeOid, OidGroup expectedGroup);
    public abstract virtual void FindByThumbprint(Byte[] thumbprint);
    public abstract virtual void FindBySubjectName(string subjectName);
    public abstract virtual void FindBySubjectDistinguishedName(string subjectDistinguishedName);
    public abstract virtual void FindByIssuerName(string issuerName);
    public abstract virtual void FindByIssuerDistinguishedName(string issuerDistinguishedName);
    public abstract virtual void FindBySerialNumber(BigInteger hexValue, BigInteger decimalValue);
    public abstract virtual void FindByTimeValid(DateTime dateTime);
    public abstract virtual void FindByTimeNotYetValid(DateTime dateTime);
    public abstract virtual void FindByTimeExpired(DateTime dateTime);
    public abstract virtual void FindByTemplateName(string templateName);
    public abstract virtual void FindByApplicationPolicy(string oidValue);
    public abstract virtual void FindByCertificatePolicy(string oidValue);
    public abstract virtual void FindByExtension(string oidValue);
    public abstract virtual void FindByKeyUsage(X509KeyUsageFlags keyUsage);
    public abstract virtual void FindBySubjectKeyIdentifier(Byte[] keyIdentifier);
}
internal interface Internal.Cryptography.Pal.IStorePal {
    public abstract virtual Byte[] Export(X509ContentType contentType, string password);
    public abstract virtual void CopyTo(X509Certificate2Collection collection);
    public abstract virtual void Add(ICertificatePal cert);
    public abstract virtual void Remove(ICertificatePal cert);
}
internal interface Internal.Cryptography.Pal.IX509Pal {
    public bool SupportsLegacyBasicConstraintsExtension { get; }
    public abstract virtual AsymmetricAlgorithm DecodePublicKey(Oid oid, Byte[] encodedKeyValue, Byte[] encodedParameters, ICertificatePal certificatePal);
    public abstract virtual string X500DistinguishedNameDecode(Byte[] encodedDistinguishedName, X500DistinguishedNameFlags flag);
    public abstract virtual Byte[] X500DistinguishedNameEncode(string distinguishedName, X500DistinguishedNameFlags flag);
    public abstract virtual string X500DistinguishedNameFormat(Byte[] encodedDistinguishedName, bool multiLine);
    public abstract virtual X509ContentType GetCertContentType(Byte[] rawData);
    public abstract virtual X509ContentType GetCertContentType(string fileName);
    public abstract virtual Byte[] EncodeX509KeyUsageExtension(X509KeyUsageFlags keyUsages);
    public abstract virtual void DecodeX509KeyUsageExtension(Byte[] encoded, X509KeyUsageFlags& keyUsages);
    public abstract virtual bool get_SupportsLegacyBasicConstraintsExtension();
    public abstract virtual Byte[] EncodeX509BasicConstraints2Extension(bool certificateAuthority, bool hasPathLengthConstraint, int pathLengthConstraint);
    public abstract virtual void DecodeX509BasicConstraintsExtension(Byte[] encoded, Boolean& certificateAuthority, Boolean& hasPathLengthConstraint, Int32& pathLengthConstraint);
    public abstract virtual void DecodeX509BasicConstraints2Extension(Byte[] encoded, Boolean& certificateAuthority, Boolean& hasPathLengthConstraint, Int32& pathLengthConstraint);
    public abstract virtual Byte[] EncodeX509EnhancedKeyUsageExtension(OidCollection usages);
    public abstract virtual void DecodeX509EnhancedKeyUsageExtension(Byte[] encoded, OidCollection& usages);
    public abstract virtual Byte[] EncodeX509SubjectKeyIdentifierExtension(Byte[] subjectKeyIdentifier);
    public abstract virtual void DecodeX509SubjectKeyIdentifierExtension(Byte[] encoded, Byte[]& subjectKeyIdentifier);
    public abstract virtual Byte[] ComputeCapiSha1OfPublicKey(PublicKey key);
}
internal static class Internal.Cryptography.Pal.Native.AlgId : object {
    public static int CALG_RSA_KEYX;
    public static int CALG_RSA_SIGN;
    public static int CALG_DSS_SIGN;
    public static int CALG_SHA1;
}
internal class Internal.Cryptography.Pal.Native.BLOBHEADER : ValueType {
    public byte bType;
    public byte bVersion;
    public short reserved;
    public UInt32 aiKeyAlg;
}
internal class Internal.Cryptography.Pal.Native.CERT_BASIC_CONSTRAINTS_INFO : ValueType {
    public CRYPT_BIT_BLOB SubjectType;
    public int fPathLenConstraint;
    public int dwPathLenConstraint;
    public int cSubtreesConstraint;
    public CRYPTOAPI_BLOB* rgSubtreesConstraint;
    public static byte CERT_CA_SUBJECT_FLAG;
}
internal class Internal.Cryptography.Pal.Native.CERT_BASIC_CONSTRAINTS2_INFO : ValueType {
    public int fCA;
    public int fPathLenConstraint;
    public int dwPathLenConstraint;
}
internal class Internal.Cryptography.Pal.Native.CERT_CHAIN_CONTEXT : ValueType {
    public int cbSize;
    public CERT_TRUST_STATUS TrustStatus;
    public int cChain;
    public CERT_SIMPLE_CHAIN** rgpChain;
    public int cLowerQualityChainContext;
    public CERT_CHAIN_CONTEXT** rgpLowerQualityChainContext;
    public int fHasRevocationFreshnessTime;
    public int dwRevocationFreshnessTime;
    public int dwCreateFlags;
    public Guid ChainId;
}
internal class Internal.Cryptography.Pal.Native.CERT_CHAIN_ELEMENT : ValueType {
    public int cbSize;
    public CERT_CONTEXT* pCertContext;
    public CERT_TRUST_STATUS TrustStatus;
    public IntPtr pRevocationInfo;
    public IntPtr pIssuanceUsage;
    public IntPtr pApplicationUsage;
    public IntPtr pwszExtendedErrorInfo;
}
internal class Internal.Cryptography.Pal.Native.CERT_CHAIN_PARA : ValueType {
    public int cbSize;
    public CERT_USAGE_MATCH RequestedUsage;
    public CERT_USAGE_MATCH RequestedIssuancePolicy;
    public int dwUrlRetrievalTimeout;
    public int fCheckRevocationFreshnessTime;
    public int dwRevocationFreshnessTime;
    public FILETIME* pftCacheResync;
    public int pStrongSignPara;
    public int dwStrongSignFlags;
}
internal class Internal.Cryptography.Pal.Native.CERT_CHAIN_POLICY_PARA : ValueType {
    public int cbSize;
    public int dwFlags;
    public IntPtr pvExtraPolicyPara;
}
internal class Internal.Cryptography.Pal.Native.CERT_CHAIN_POLICY_STATUS : ValueType {
    public int cbSize;
    public int dwError;
    public IntPtr lChainIndex;
    public IntPtr lElementIndex;
    public IntPtr pvExtraPolicyStatus;
}
internal class Internal.Cryptography.Pal.Native.CERT_CONTEXT : ValueType {
    public CertEncodingType dwCertEncodingType;
    public Byte* pbCertEncoded;
    public int cbCertEncoded;
    public CERT_INFO* pCertInfo;
    public IntPtr hCertStore;
}
internal class Internal.Cryptography.Pal.Native.CERT_DSS_PARAMETERS : ValueType {
    public CRYPTOAPI_BLOB p;
    public CRYPTOAPI_BLOB q;
    public CRYPTOAPI_BLOB g;
}
internal class Internal.Cryptography.Pal.Native.CERT_ENHKEY_USAGE : ValueType {
    public int cUsageIdentifier;
    public IntPtr* rgpszUsageIdentifier;
}
internal class Internal.Cryptography.Pal.Native.CERT_EXTENSION : ValueType {
    public IntPtr pszObjId;
    public int fCritical;
    public CRYPTOAPI_BLOB Value;
}
internal class Internal.Cryptography.Pal.Native.CERT_INFO : ValueType {
    public int dwVersion;
    public CRYPTOAPI_BLOB SerialNumber;
    public CRYPT_ALGORITHM_IDENTIFIER SignatureAlgorithm;
    public CRYPTOAPI_BLOB Issuer;
    public FILETIME NotBefore;
    public FILETIME NotAfter;
    public CRYPTOAPI_BLOB Subject;
    public CERT_PUBLIC_KEY_INFO SubjectPublicKeyInfo;
    public CRYPT_BIT_BLOB IssuerUniqueId;
    public CRYPT_BIT_BLOB SubjectUniqueId;
    public int cExtension;
    public CERT_EXTENSION* rgExtension;
}
internal class Internal.Cryptography.Pal.Native.CERT_NAME_VALUE : ValueType {
    public int dwValueType;
    public CRYPTOAPI_BLOB Value;
}
internal class Internal.Cryptography.Pal.Native.CERT_POLICIES_INFO : ValueType {
    public int cPolicyInfo;
    public CERT_POLICY_INFO* rgPolicyInfo;
}
internal class Internal.Cryptography.Pal.Native.CERT_POLICY_INFO : ValueType {
    public IntPtr pszPolicyIdentifier;
    public int cPolicyQualifier;
    public IntPtr rgPolicyQualifier;
}
internal class Internal.Cryptography.Pal.Native.CERT_PUBLIC_KEY_INFO : ValueType {
    public CRYPT_ALGORITHM_IDENTIFIER Algorithm;
    public CRYPT_BIT_BLOB PublicKey;
}
internal class Internal.Cryptography.Pal.Native.CERT_SIMPLE_CHAIN : ValueType {
    public int cbSize;
    public CERT_TRUST_STATUS TrustStatus;
    public int cElement;
    public CERT_CHAIN_ELEMENT** rgpElement;
    public IntPtr pTrustListInfo;
    public int fHasRevocationFreshnessTime;
    public int dwRevocationFreshnessTime;
}
internal class Internal.Cryptography.Pal.Native.CERT_TEMPLATE_EXT : ValueType {
    public IntPtr pszObjId;
    public int dwMajorVersion;
    public int fMinorVersion;
    public int dwMinorVersion;
}
internal class Internal.Cryptography.Pal.Native.CERT_TRUST_STATUS : ValueType {
    public CertTrustErrorStatus dwErrorStatus;
    public CertTrustInfoStatus dwInfoStatus;
}
internal class Internal.Cryptography.Pal.Native.CERT_USAGE_MATCH : ValueType {
    public CertUsageMatchType dwType;
    public CTL_USAGE Usage;
}
[FlagsAttribute]
internal enum Internal.Cryptography.Pal.Native.CertChainFlags : Enum {
    public int value__;
    public static CertChainFlags None;
    public static CertChainFlags CERT_CHAIN_REVOCATION_CHECK_END_CERT;
    public static CertChainFlags CERT_CHAIN_REVOCATION_CHECK_CHAIN;
    public static CertChainFlags CERT_CHAIN_REVOCATION_CHECK_CHAIN_EXCLUDE_ROOT;
    public static CertChainFlags CERT_CHAIN_REVOCATION_CHECK_CACHE_ONLY;
}
internal enum Internal.Cryptography.Pal.Native.CertContextPropId : Enum {
    public int value__;
    public static CertContextPropId CERT_KEY_PROV_INFO_PROP_ID;
    public static CertContextPropId CERT_SHA1_HASH_PROP_ID;
    public static CertContextPropId CERT_FRIENDLY_NAME_PROP_ID;
    public static CertContextPropId CERT_ARCHIVED_PROP_ID;
    public static CertContextPropId CERT_KEY_IDENTIFIER_PROP_ID;
    public static CertContextPropId CERT_PUBKEY_ALG_PARA_PROP_ID;
    public static CertContextPropId CERT_DELETE_KEYSET_PROP_ID;
}
[FlagsAttribute]
internal enum Internal.Cryptography.Pal.Native.CertControlStoreFlags : Enum {
    public int value__;
    public static CertControlStoreFlags None;
}
internal enum Internal.Cryptography.Pal.Native.CertControlStoreType : Enum {
    public int value__;
    public static CertControlStoreType CERT_STORE_CTRL_AUTO_RESYNC;
}
internal enum Internal.Cryptography.Pal.Native.CertEncodingType : Enum {
    public int value__;
    public static CertEncodingType PKCS_7_ASN_ENCODING;
    public static CertEncodingType X509_ASN_ENCODING;
    public static CertEncodingType All;
}
[FlagsAttribute]
internal enum Internal.Cryptography.Pal.Native.CertFindFlags : Enum {
    public int value__;
    public static CertFindFlags None;
}
internal enum Internal.Cryptography.Pal.Native.CertFindType : Enum {
    public int value__;
    public static CertFindType CERT_FIND_SUBJECT_CERT;
    public static CertFindType CERT_FIND_HASH;
    public static CertFindType CERT_FIND_SUBJECT_STR;
    public static CertFindType CERT_FIND_ISSUER_STR;
    public static CertFindType CERT_FIND_EXISTING;
    public static CertFindType CERT_FIND_ANY;
}
[FlagsAttribute]
internal enum Internal.Cryptography.Pal.Native.CertNameFlags : Enum {
    public int value__;
    public static CertNameFlags None;
    public static CertNameFlags CERT_NAME_ISSUER_FLAG;
}
internal enum Internal.Cryptography.Pal.Native.CertNameStringType : Enum {
    public int value__;
    public static CertNameStringType CERT_X500_NAME_STR;
    public static CertNameStringType CERT_NAME_STR_REVERSE_FLAG;
}
[FlagsAttribute]
internal enum Internal.Cryptography.Pal.Native.CertNameStrTypeAndFlags : Enum {
    public int value__;
    public static CertNameStrTypeAndFlags CERT_SIMPLE_NAME_STR;
    public static CertNameStrTypeAndFlags CERT_OID_NAME_STR;
    public static CertNameStrTypeAndFlags CERT_X500_NAME_STR;
    public static CertNameStrTypeAndFlags CERT_NAME_STR_SEMICOLON_FLAG;
    public static CertNameStrTypeAndFlags CERT_NAME_STR_NO_PLUS_FLAG;
    public static CertNameStrTypeAndFlags CERT_NAME_STR_NO_QUOTING_FLAG;
    public static CertNameStrTypeAndFlags CERT_NAME_STR_CRLF_FLAG;
    public static CertNameStrTypeAndFlags CERT_NAME_STR_COMMA_FLAG;
    public static CertNameStrTypeAndFlags CERT_NAME_STR_REVERSE_FLAG;
    public static CertNameStrTypeAndFlags CERT_NAME_STR_DISABLE_IE4_UTF8_FLAG;
    public static CertNameStrTypeAndFlags CERT_NAME_STR_ENABLE_T61_UNICODE_FLAG;
    public static CertNameStrTypeAndFlags CERT_NAME_STR_ENABLE_UTF8_UNICODE_FLAG;
    public static CertNameStrTypeAndFlags CERT_NAME_STR_FORCE_UTF8_DIR_STR_FLAG;
}
internal enum Internal.Cryptography.Pal.Native.CertNameType : Enum {
    public int value__;
    public static CertNameType CERT_NAME_EMAIL_TYPE;
    public static CertNameType CERT_NAME_RDN_TYPE;
    public static CertNameType CERT_NAME_ATTR_TYPE;
    public static CertNameType CERT_NAME_SIMPLE_DISPLAY_TYPE;
    public static CertNameType CERT_NAME_FRIENDLY_DISPLAY_TYPE;
    public static CertNameType CERT_NAME_DNS_TYPE;
    public static CertNameType CERT_NAME_URL_TYPE;
    public static CertNameType CERT_NAME_UPN_TYPE;
}
internal enum Internal.Cryptography.Pal.Native.CertQueryObjectType : Enum {
    public int value__;
    public static CertQueryObjectType CERT_QUERY_OBJECT_FILE;
    public static CertQueryObjectType CERT_QUERY_OBJECT_BLOB;
}
[FlagsAttribute]
internal enum Internal.Cryptography.Pal.Native.CertSetPropertyFlags : Enum {
    public int value__;
    public static CertSetPropertyFlags CERT_SET_PROPERTY_INHIBIT_PERSIST_FLAG;
    public static CertSetPropertyFlags None;
}
internal enum Internal.Cryptography.Pal.Native.CertStoreAddDisposition : Enum {
    public int value__;
    public static CertStoreAddDisposition CERT_STORE_ADD_NEW;
    public static CertStoreAddDisposition CERT_STORE_ADD_USE_EXISTING;
    public static CertStoreAddDisposition CERT_STORE_ADD_REPLACE_EXISTING;
    public static CertStoreAddDisposition CERT_STORE_ADD_ALWAYS;
    public static CertStoreAddDisposition CERT_STORE_ADD_REPLACE_EXISTING_INHERIT_PROPERTIES;
    public static CertStoreAddDisposition CERT_STORE_ADD_NEWER;
    public static CertStoreAddDisposition CERT_STORE_ADD_NEWER_INHERIT_PROPERTIES;
}
[FlagsAttribute]
internal enum Internal.Cryptography.Pal.Native.CertStoreFlags : Enum {
    public int value__;
    public static CertStoreFlags CERT_STORE_NO_CRYPT_RELEASE_FLAG;
    public static CertStoreFlags CERT_STORE_SET_LOCALIZED_NAME_FLAG;
    public static CertStoreFlags CERT_STORE_DEFER_CLOSE_UNTIL_LAST_FREE_FLAG;
    public static CertStoreFlags CERT_STORE_DELETE_FLAG;
    public static CertStoreFlags CERT_STORE_UNSAFE_PHYSICAL_FLAG;
    public static CertStoreFlags CERT_STORE_SHARE_STORE_FLAG;
    public static CertStoreFlags CERT_STORE_SHARE_CONTEXT_FLAG;
    public static CertStoreFlags CERT_STORE_MANIFOLD_FLAG;
    public static CertStoreFlags CERT_STORE_ENUM_ARCHIVED_FLAG;
    public static CertStoreFlags CERT_STORE_UPDATE_KEYID_FLAG;
    public static CertStoreFlags CERT_STORE_BACKUP_RESTORE_FLAG;
    public static CertStoreFlags CERT_STORE_READONLY_FLAG;
    public static CertStoreFlags CERT_STORE_OPEN_EXISTING_FLAG;
    public static CertStoreFlags CERT_STORE_CREATE_NEW_FLAG;
    public static CertStoreFlags CERT_STORE_MAXIMUM_ALLOWED_FLAG;
    public static CertStoreFlags CERT_SYSTEM_STORE_CURRENT_USER;
    public static CertStoreFlags CERT_SYSTEM_STORE_LOCAL_MACHINE;
    public static CertStoreFlags None;
}
internal enum Internal.Cryptography.Pal.Native.CertStoreProvider : Enum {
    public int value__;
    public static CertStoreProvider CERT_STORE_PROV_MEMORY;
    public static CertStoreProvider CERT_STORE_PROV_SYSTEM_W;
}
internal enum Internal.Cryptography.Pal.Native.CertStoreSaveAs : Enum {
    public int value__;
    public static CertStoreSaveAs CERT_STORE_SAVE_AS_STORE;
    public static CertStoreSaveAs CERT_STORE_SAVE_AS_PKCS7;
}
internal enum Internal.Cryptography.Pal.Native.CertStoreSaveTo : Enum {
    public int value__;
    public static CertStoreSaveTo CERT_STORE_SAVE_TO_MEMORY;
}
[FlagsAttribute]
internal enum Internal.Cryptography.Pal.Native.CertTrustErrorStatus : Enum {
    public int value__;
    public static CertTrustErrorStatus CERT_TRUST_NO_ERROR;
    public static CertTrustErrorStatus CERT_TRUST_IS_NOT_TIME_VALID;
    public static CertTrustErrorStatus CERT_TRUST_IS_NOT_TIME_NESTED;
    public static CertTrustErrorStatus CERT_TRUST_IS_REVOKED;
    public static CertTrustErrorStatus CERT_TRUST_IS_NOT_SIGNATURE_VALID;
    public static CertTrustErrorStatus CERT_TRUST_IS_NOT_VALID_FOR_USAGE;
    public static CertTrustErrorStatus CERT_TRUST_IS_UNTRUSTED_ROOT;
    public static CertTrustErrorStatus CERT_TRUST_REVOCATION_STATUS_UNKNOWN;
    public static CertTrustErrorStatus CERT_TRUST_IS_CYCLIC;
    public static CertTrustErrorStatus CERT_TRUST_INVALID_EXTENSION;
    public static CertTrustErrorStatus CERT_TRUST_INVALID_POLICY_CONSTRAINTS;
    public static CertTrustErrorStatus CERT_TRUST_INVALID_BASIC_CONSTRAINTS;
    public static CertTrustErrorStatus CERT_TRUST_INVALID_NAME_CONSTRAINTS;
    public static CertTrustErrorStatus CERT_TRUST_HAS_NOT_SUPPORTED_NAME_CONSTRAINT;
    public static CertTrustErrorStatus CERT_TRUST_HAS_NOT_DEFINED_NAME_CONSTRAINT;
    public static CertTrustErrorStatus CERT_TRUST_HAS_NOT_PERMITTED_NAME_CONSTRAINT;
    public static CertTrustErrorStatus CERT_TRUST_HAS_EXCLUDED_NAME_CONSTRAINT;
    public static CertTrustErrorStatus CERT_TRUST_IS_OFFLINE_REVOCATION;
    public static CertTrustErrorStatus CERT_TRUST_NO_ISSUANCE_CHAIN_POLICY;
    public static CertTrustErrorStatus CERT_TRUST_IS_EXPLICIT_DISTRUST;
    public static CertTrustErrorStatus CERT_TRUST_HAS_NOT_SUPPORTED_CRITICAL_EXT;
    public static CertTrustErrorStatus CERT_TRUST_HAS_WEAK_SIGNATURE;
    public static CertTrustErrorStatus CERT_TRUST_IS_PARTIAL_CHAIN;
    public static CertTrustErrorStatus CERT_TRUST_CTL_IS_NOT_TIME_VALID;
    public static CertTrustErrorStatus CERT_TRUST_CTL_IS_NOT_SIGNATURE_VALID;
    public static CertTrustErrorStatus CERT_TRUST_CTL_IS_NOT_VALID_FOR_USAGE;
}
[FlagsAttribute]
internal enum Internal.Cryptography.Pal.Native.CertTrustInfoStatus : Enum {
    public int value__;
    public static CertTrustInfoStatus CERT_TRUST_HAS_EXACT_MATCH_ISSUER;
    public static CertTrustInfoStatus CERT_TRUST_HAS_KEY_MATCH_ISSUER;
    public static CertTrustInfoStatus CERT_TRUST_HAS_NAME_MATCH_ISSUER;
    public static CertTrustInfoStatus CERT_TRUST_IS_SELF_SIGNED;
    public static CertTrustInfoStatus CERT_TRUST_HAS_PREFERRED_ISSUER;
    public static CertTrustInfoStatus CERT_TRUST_HAS_ISSUANCE_CHAIN_POLICY;
    public static CertTrustInfoStatus CERT_TRUST_HAS_VALID_NAME_CONSTRAINTS;
    public static CertTrustInfoStatus CERT_TRUST_IS_COMPLEX_CHAIN;
}
internal enum Internal.Cryptography.Pal.Native.CertUsageMatchType : Enum {
    public int value__;
    public static CertUsageMatchType USAGE_MATCH_TYPE_AND;
    public static CertUsageMatchType USAGE_MATCH_TYPE_OR;
}
internal enum Internal.Cryptography.Pal.Native.ChainEngine : Enum {
    public int value__;
    public static ChainEngine HCCE_CURRENT_USER;
    public static ChainEngine HCCE_LOCAL_MACHINE;
}
internal enum Internal.Cryptography.Pal.Native.ChainPolicy : Enum {
    public int value__;
    public static ChainPolicy CERT_CHAIN_POLICY_BASE;
}
internal class Internal.Cryptography.Pal.Native.CMSG_SIGNER_INFO_Partial : ValueType {
    public int dwVersion;
    public CRYPTOAPI_BLOB Issuer;
    public CRYPTOAPI_BLOB SerialNumber;
}
internal enum Internal.Cryptography.Pal.Native.ContentType : Enum {
    public int value__;
    public static ContentType CERT_QUERY_CONTENT_CERT;
    public static ContentType CERT_QUERY_CONTENT_CTL;
    public static ContentType CERT_QUERY_CONTENT_CRL;
    public static ContentType CERT_QUERY_CONTENT_SERIALIZED_STORE;
    public static ContentType CERT_QUERY_CONTENT_SERIALIZED_CERT;
    public static ContentType CERT_QUERY_CONTENT_SERIALIZED_CTL;
    public static ContentType CERT_QUERY_CONTENT_SERIALIZED_CRL;
    public static ContentType CERT_QUERY_CONTENT_PKCS7_SIGNED;
    public static ContentType CERT_QUERY_CONTENT_PKCS7_UNSIGNED;
    public static ContentType CERT_QUERY_CONTENT_PKCS7_SIGNED_EMBED;
    public static ContentType CERT_QUERY_CONTENT_PKCS10;
    public static ContentType CERT_QUERY_CONTENT_PFX;
    public static ContentType CERT_QUERY_CONTENT_CERT_PAIR;
    public static ContentType CERT_QUERY_CONTENT_PFX_AND_LOAD;
}
internal class Internal.Cryptography.Pal.Native.CRYPT_ALGORITHM_IDENTIFIER : ValueType {
    public IntPtr pszObjId;
    public CRYPTOAPI_BLOB Parameters;
}
internal class Internal.Cryptography.Pal.Native.CRYPT_BIT_BLOB : ValueType {
    public int cbData;
    public Byte* pbData;
    public int cUnusedBits;
    public Byte[] ToByteArray();
}
internal class Internal.Cryptography.Pal.Native.CRYPT_KEY_PROV_INFO : ValueType {
    public Char* pwszContainerName;
    public Char* pwszProvName;
    public int dwProvType;
    public CryptAcquireContextFlags dwFlags;
    public int cProvParam;
    public IntPtr rgProvParam;
    public int dwKeySpec;
}
[FlagsAttribute]
internal enum Internal.Cryptography.Pal.Native.CryptAcquireContextFlags : Enum {
    public int value__;
    public static CryptAcquireContextFlags CRYPT_DELETEKEYSET;
    public static CryptAcquireContextFlags CRYPT_MACHINE_KEYSET;
    public static CryptAcquireContextFlags None;
}
internal enum Internal.Cryptography.Pal.Native.CryptAcquireFlags : Enum {
    public int value__;
    public static CryptAcquireFlags CRYPT_ACQUIRE_ONLY_NCRYPT_KEY_FLAG;
}
[FlagsAttribute]
internal enum Internal.Cryptography.Pal.Native.CryptDecodeObjectFlags : Enum {
    public int value__;
    public static CryptDecodeObjectFlags None;
}
internal enum Internal.Cryptography.Pal.Native.CryptDecodeObjectStructType : Enum {
    public int value__;
    public static CryptDecodeObjectStructType CNG_RSA_PUBLIC_KEY_BLOB;
    public static CryptDecodeObjectStructType X509_DSS_PUBLICKEY;
    public static CryptDecodeObjectStructType X509_DSS_PARAMETERS;
    public static CryptDecodeObjectStructType X509_KEY_USAGE;
    public static CryptDecodeObjectStructType X509_BASIC_CONSTRAINTS;
    public static CryptDecodeObjectStructType X509_BASIC_CONSTRAINTS2;
    public static CryptDecodeObjectStructType X509_ENHANCED_KEY_USAGE;
    public static CryptDecodeObjectStructType X509_CERT_POLICIES;
    public static CryptDecodeObjectStructType X509_UNICODE_ANY_STRING;
    public static CryptDecodeObjectStructType X509_CERTIFICATE_TEMPLATE;
}
internal enum Internal.Cryptography.Pal.Native.CryptMessageParameterType : Enum {
    public int value__;
    public static CryptMessageParameterType CMSG_SIGNER_COUNT_PARAM;
    public static CryptMessageParameterType CMSG_SIGNER_INFO_PARAM;
}
internal class Internal.Cryptography.Pal.Native.CRYPTOAPI_BLOB : ValueType {
    public int cbData;
    public Byte* pbData;
    public CRYPTOAPI_BLOB(int cbData, Byte* pbData);
    public Byte[] ToByteArray();
}
internal class Internal.Cryptography.Pal.Native.CTL_USAGE : ValueType {
    public int cUsageIdentifier;
    public IntPtr rgpszUsageIdentifier;
}
[FlagsAttribute]
internal enum Internal.Cryptography.Pal.Native.ExpectedContentTypeFlags : Enum {
    public int value__;
    public static ExpectedContentTypeFlags CERT_QUERY_CONTENT_FLAG_CERT;
    public static ExpectedContentTypeFlags CERT_QUERY_CONTENT_FLAG_CTL;
    public static ExpectedContentTypeFlags CERT_QUERY_CONTENT_FLAG_CRL;
    public static ExpectedContentTypeFlags CERT_QUERY_CONTENT_FLAG_SERIALIZED_STORE;
    public static ExpectedContentTypeFlags CERT_QUERY_CONTENT_FLAG_SERIALIZED_CERT;
    public static ExpectedContentTypeFlags CERT_QUERY_CONTENT_FLAG_SERIALIZED_CTL;
    public static ExpectedContentTypeFlags CERT_QUERY_CONTENT_FLAG_SERIALIZED_CRL;
    public static ExpectedContentTypeFlags CERT_QUERY_CONTENT_FLAG_PKCS7_SIGNED;
    public static ExpectedContentTypeFlags CERT_QUERY_CONTENT_FLAG_PKCS7_UNSIGNED;
    public static ExpectedContentTypeFlags CERT_QUERY_CONTENT_FLAG_PKCS7_SIGNED_EMBED;
    public static ExpectedContentTypeFlags CERT_QUERY_CONTENT_FLAG_PKCS10;
    public static ExpectedContentTypeFlags CERT_QUERY_CONTENT_FLAG_PFX;
    public static ExpectedContentTypeFlags CERT_QUERY_CONTENT_FLAG_CERT_PAIR;
    public static ExpectedContentTypeFlags CERT_QUERY_CONTENT_FLAG_PFX_AND_LOAD;
    public static ExpectedContentTypeFlags CERT_QUERY_CONTENT_FLAG_ALL;
}
[FlagsAttribute]
internal enum Internal.Cryptography.Pal.Native.ExpectedFormatTypeFlags : Enum {
    public int value__;
    public static ExpectedFormatTypeFlags CERT_QUERY_FORMAT_FLAG_BINARY;
    public static ExpectedFormatTypeFlags CERT_QUERY_FORMAT_FLAG_BASE64_ENCODED;
    public static ExpectedFormatTypeFlags CERT_QUERY_FORMAT_FLAG_ASN_ASCII_HEX_ENCODED;
    public static ExpectedFormatTypeFlags CERT_QUERY_FORMAT_FLAG_ALL;
}
internal class Internal.Cryptography.Pal.Native.FILETIME : ValueType {
    private UInt32 ftTimeLow;
    private UInt32 ftTimeHigh;
    public DateTime ToDateTime();
    public static FILETIME FromDateTime(DateTime dt);
}
[FlagsAttribute]
internal enum Internal.Cryptography.Pal.Native.FormatMessageFlags : Enum {
    public int value__;
    public static FormatMessageFlags FORMAT_MESSAGE_FROM_SYSTEM;
    public static FormatMessageFlags FORMAT_MESSAGE_IGNORE_INSERTS;
}
[FlagsAttribute]
internal enum Internal.Cryptography.Pal.Native.FormatObjectStringType : Enum {
    public int value__;
    public static FormatObjectStringType CRYPT_FORMAT_STR_MULTI_LINE;
    public static FormatObjectStringType CRYPT_FORMAT_STR_NO_HEX;
    public static FormatObjectStringType None;
}
internal enum Internal.Cryptography.Pal.Native.FormatObjectStructType : Enum {
    public int value__;
    public static FormatObjectStructType X509_NAME;
}
internal enum Internal.Cryptography.Pal.Native.FormatObjectType : Enum {
    public int value__;
    public static FormatObjectType None;
}
internal enum Internal.Cryptography.Pal.Native.FormatType : Enum {
    public int value__;
    public static FormatType CERT_QUERY_FORMAT_BINARY;
    public static FormatType CERT_QUERY_FORMAT_BASE64_ENCODED;
    public static FormatType CERT_QUERY_FORMAT_ASN_ASCII_HEX_ENCODED;
}
[ExtensionAttribute]
internal static class Internal.Cryptography.Pal.Native.Helpers : object {
    [ExtensionAttribute]
public static SafeHandle ToLpstrArray(OidCollection oids, Int32& numOids);
    [ExtensionAttribute]
public static Byte[] ValueAsAscii(Oid oid);
    [ExtensionAttribute]
public static void DecodeObject(Byte[] encoded, CryptDecodeObjectStructType lpszStructType, DecodedObjectReceiver receiver);
    [ExtensionAttribute]
public static void DecodeObject(Byte[] encoded, string lpszStructType, DecodedObjectReceiver receiver);
    [ExtensionAttribute]
public static bool DecodeObjectNoThrow(Byte[] encoded, CryptDecodeObjectStructType lpszStructType, DecodedObjectReceiver receiver);
}
[FlagsAttribute]
internal enum Internal.Cryptography.Pal.Native.PfxCertStoreFlags : Enum {
    public int value__;
    public static PfxCertStoreFlags CRYPT_EXPORTABLE;
    public static PfxCertStoreFlags CRYPT_USER_PROTECTED;
    public static PfxCertStoreFlags CRYPT_MACHINE_KEYSET;
    public static PfxCertStoreFlags CRYPT_USER_KEYSET;
    public static PfxCertStoreFlags PKCS12_PREFER_CNG_KSP;
    public static PfxCertStoreFlags PKCS12_ALWAYS_CNG_KSP;
    public static PfxCertStoreFlags PKCS12_ALLOW_OVERWRITE_KEY;
    public static PfxCertStoreFlags PKCS12_NO_PERSIST_KEY;
    public static PfxCertStoreFlags PKCS12_INCLUDE_EXTENDED_PROPERTIES;
    public static PfxCertStoreFlags None;
}
[FlagsAttribute]
internal enum Internal.Cryptography.Pal.Native.PFXExportFlags : Enum {
    public int value__;
    public static PFXExportFlags REPORT_NO_PRIVATE_KEY;
    public static PFXExportFlags REPORT_NOT_ABLE_TO_EXPORT_PRIVATE_KEY;
    public static PFXExportFlags EXPORT_PRIVATE_KEYS;
    public static PFXExportFlags None;
}
internal enum Internal.Cryptography.Pal.Native.PubKeyMagic : Enum {
    public int value__;
    public static PubKeyMagic DSS_MAGIC;
}
internal class Internal.Cryptography.Pal.Native.SafeCertContextHandle : SafePointerHandle`1<SafeCertContextHandle> {
    public CERT_CONTEXT* CertContext { get; }
    public bool ContainsPrivateKey { get; }
    protected virtual bool ReleaseHandle();
    public CERT_CONTEXT* get_CertContext();
    public CERT_CONTEXT* Disconnect();
    public bool get_ContainsPrivateKey();
    public SafeCertContextHandle Duplicate();
}
internal class Internal.Cryptography.Pal.Native.SafeCertContextHandleWithKeyContainerDeletion : SafeCertContextHandle {
    protected sealed virtual bool ReleaseHandle();
    public static void DeleteKeyContainer(SafeCertContextHandle pCertContext);
}
internal class Internal.Cryptography.Pal.Native.SafeCertStoreHandle : SafePointerHandle`1<SafeCertStoreHandle> {
    protected sealed virtual bool ReleaseHandle();
}
internal class Internal.Cryptography.Pal.Native.SafeCryptMsgHandle : SafePointerHandle`1<SafeCryptMsgHandle> {
    protected sealed virtual bool ReleaseHandle();
}
internal class Internal.Cryptography.Pal.Native.SafeLocalAllocHandle : SafePointerHandle`1<SafeLocalAllocHandle> {
    public static SafeLocalAllocHandle Create(int cb);
    protected sealed virtual bool ReleaseHandle();
}
internal abstract class Internal.Cryptography.Pal.Native.SafePointerHandle`1 : SafeHandle {
    public bool IsInvalid { get; }
    public static T InvalidHandle { get; }
    public sealed virtual bool get_IsInvalid();
    public static T get_InvalidHandle();
    protected virtual void Dispose(bool disposing);
}
internal class Internal.Cryptography.Pal.StorePal : object {
    private SafeCertStoreHandle _certStore;
    private static ExpectedContentTypeFlags StoreExpectedContentFlags;
    internal SafeCertStoreHandle SafeCertStoreHandle { get; }
    internal StorePal(SafeCertStoreHandle certStore);
    public sealed virtual void CopyTo(X509Certificate2Collection collection);
    public sealed virtual void Add(ICertificatePal certificate);
    public sealed virtual void Remove(ICertificatePal certificate);
    public sealed virtual void Dispose();
    internal SafeCertStoreHandle get_SafeCertStoreHandle();
    public sealed virtual Byte[] Export(X509ContentType contentType, string password);
    private Byte[] SaveToMemoryStore(CertStoreSaveAs dwSaveAs);
    public static IStorePal FromBlob(Byte[] rawData, string password, X509KeyStorageFlags keyStorageFlags);
    public static IStorePal FromFile(string fileName, string password, X509KeyStorageFlags keyStorageFlags);
    private static StorePal FromBlobOrFile(Byte[] rawData, string fileName, string password, X509KeyStorageFlags keyStorageFlags);
    public static IStorePal FromCertificate(ICertificatePal cert);
    public static IStorePal LinkFromCertificateCollection(X509Certificate2Collection certificates);
    public static IStorePal FromSystemStore(string storeName, StoreLocation storeLocation, OpenFlags openFlags);
    private static PfxCertStoreFlags MapKeyStorageFlags(X509KeyStorageFlags keyStorageFlags);
    private static CertStoreFlags MapX509StoreFlags(StoreLocation storeLocation, OpenFlags flags);
}
internal class Internal.Cryptography.Pal.X509Pal : object {
    public static IX509Pal Instance;
    public bool SupportsLegacyBasicConstraintsExtension { get; }
    private static X509Pal();
    public sealed virtual Byte[] EncodeX509KeyUsageExtension(X509KeyUsageFlags keyUsages);
    public sealed virtual void DecodeX509KeyUsageExtension(Byte[] encoded, X509KeyUsageFlags& keyUsages);
    public sealed virtual bool get_SupportsLegacyBasicConstraintsExtension();
    public sealed virtual Byte[] EncodeX509BasicConstraints2Extension(bool certificateAuthority, bool hasPathLengthConstraint, int pathLengthConstraint);
    public sealed virtual void DecodeX509BasicConstraintsExtension(Byte[] encoded, Boolean& certificateAuthority, Boolean& hasPathLengthConstraint, Int32& pathLengthConstraint);
    public sealed virtual void DecodeX509BasicConstraints2Extension(Byte[] encoded, Boolean& certificateAuthority, Boolean& hasPathLengthConstraint, Int32& pathLengthConstraint);
    public sealed virtual Byte[] EncodeX509EnhancedKeyUsageExtension(OidCollection usages);
    public sealed virtual void DecodeX509EnhancedKeyUsageExtension(Byte[] encoded, OidCollection& usages);
    public sealed virtual Byte[] EncodeX509SubjectKeyIdentifierExtension(Byte[] subjectKeyIdentifier);
    public sealed virtual void DecodeX509SubjectKeyIdentifierExtension(Byte[] encoded, Byte[]& subjectKeyIdentifier);
    public sealed virtual Byte[] ComputeCapiSha1OfPublicKey(PublicKey key);
    public sealed virtual X509ContentType GetCertContentType(Byte[] rawData);
    public sealed virtual X509ContentType GetCertContentType(string fileName);
    private static X509ContentType MapContentType(ContentType contentType);
    public sealed virtual AsymmetricAlgorithm DecodePublicKey(Oid oid, Byte[] encodedKeyValue, Byte[] encodedParameters, ICertificatePal certificatePal);
    private static ECDsa DecodeECDsaPublicKey(CertificatePal certificatePal);
    private static SafeBCryptKeyHandle ImportPublicKeyInfo(SafeCertContextHandle certContext);
    private static Byte[] ExportKeyBlob(SafeBCryptKeyHandle bCryptKeyHandle, CngKeyBlobFormat blobFormat);
    private static Byte[] DecodeKeyBlob(CryptDecodeObjectStructType lpszStructType, Byte[] encodedKeyValue);
    private static Byte[] ConstructDSSPublicKeyCspBlob(Byte[] encodedKeyValue, Byte[] encodedParameters);
    private static Byte[] DecodeDssKeyValue(Byte[] encodedKeyValue);
    private static void DecodeDssParameters(Byte[] encodedParameters, Byte[]& p, Byte[]& q, Byte[]& g);
    public sealed virtual string X500DistinguishedNameDecode(Byte[] encodedDistinguishedName, X500DistinguishedNameFlags flag);
    public sealed virtual Byte[] X500DistinguishedNameEncode(string distinguishedName, X500DistinguishedNameFlags flag);
    public sealed virtual string X500DistinguishedNameFormat(Byte[] encodedDistinguishedName, bool multiLine);
    private static CertNameStrTypeAndFlags MapNameToStrFlag(X500DistinguishedNameFlags flag);
}
internal class Internal.NativeCrypto.CRYPT_OID_INFO : ValueType {
    public int cbSize;
    public IntPtr pszOID;
    public IntPtr pwszName;
    public OidGroup dwGroupId;
    public int AlgId;
    public int cbData;
    public IntPtr pbData;
    public string OID { get; }
    public string Name { get; }
    public string get_OID();
    public string get_Name();
}
internal enum Internal.NativeCrypto.CryptOidInfoKeyType : Enum {
    public int value__;
    public static CryptOidInfoKeyType CRYPT_OID_INFO_OID_KEY;
    public static CryptOidInfoKeyType CRYPT_OID_INFO_NAME_KEY;
    public static CryptOidInfoKeyType CRYPT_OID_INFO_ALGID_KEY;
    public static CryptOidInfoKeyType CRYPT_OID_INFO_SIGN_KEY;
    public static CryptOidInfoKeyType CRYPT_OID_INFO_CNG_ALGID_KEY;
    public static CryptOidInfoKeyType CRYPT_OID_INFO_CNG_SIGN_KEY;
}
internal static class Internal.NativeCrypto.OidInfo : object {
    private static string Capi2Dll;
    public static CRYPT_OID_INFO FindOidInfo(CryptOidInfoKeyType keyType, string key, OidGroup group, bool fallBackToAllGroups);
    private static bool OidGroupWillNotUseActiveDirectory(OidGroup group);
    private static IntPtr CryptFindOIDInfo(CryptOidInfoKeyType dwKeyType, IntPtr pvKey, OidGroup group);
}
internal static class Interop : object {
}
internal abstract class Microsoft.Win32.SafeHandles.SafeBCryptHandle : SafeHandle {
    public bool IsInvalid { get; }
    public sealed virtual bool get_IsInvalid();
    protected abstract virtual bool ReleaseHandle();
}
internal class Microsoft.Win32.SafeHandles.SafeBCryptKeyHandle : SafeBCryptHandle {
    protected sealed virtual bool ReleaseHandle();
}
internal static class Microsoft.Win32.SafeHandles.SafeHandleCache`1 : object {
    private static T s_invalidHandle;
    internal static T GetInvalidHandle(Func`1<T> invalidHandleFactory);
    internal static bool IsCachedInvalidHandle(SafeHandle handle);
}
public class Microsoft.Win32.SafeHandles.SafeX509ChainHandle : SafeHandle {
    public bool IsInvalid { get; }
    internal static SafeX509ChainHandle InvalidHandle { get; }
    public virtual bool get_IsInvalid();
    internal static SafeX509ChainHandle get_InvalidHandle();
    protected virtual bool ReleaseHandle();
    protected virtual void Dispose(bool disposing);
}
internal class System.Security.Cryptography.DSACryptoServiceProvider : AsymmetricAlgorithm {
    private Byte[] _cspBlob;
    public CspKeyContainerInfo CspKeyContainerInfo { get; }
    public DSACryptoServiceProvider(CspParameters cspParameters);
    public sealed virtual void ImportCspBlob(Byte[] cspBlob);
    public sealed virtual CspKeyContainerInfo get_CspKeyContainerInfo();
    public sealed virtual Byte[] ExportCspBlob(bool includePrivateParameters);
}
[ExtensionAttribute]
public static class System.Security.Cryptography.X509Certificates.ECDsaCertificateExtensions : object {
    [ExtensionAttribute]
[SecuritySafeCriticalAttribute]
public static ECDsa GetECDsaPublicKey(X509Certificate2 certificate);
    [ExtensionAttribute]
[SecuritySafeCriticalAttribute]
public static ECDsa GetECDsaPrivateKey(X509Certificate2 certificate);
    private static bool HasECDsaKeyUsage(X509Certificate2 certificate);
}
internal static class System.Security.Cryptography.X509Certificates.EnumeratorHelper : object {
    internal static object GetCurrent(TEnumerator& enumerator);
    internal static void Reset(TEnumerator& enumerator);
}
[FlagsAttribute]
public enum System.Security.Cryptography.X509Certificates.OpenFlags : Enum {
    public int value__;
    public static OpenFlags ReadOnly;
    public static OpenFlags ReadWrite;
    public static OpenFlags MaxAllowed;
    public static OpenFlags OpenExistingOnly;
    public static OpenFlags IncludeArchived;
}
public class System.Security.Cryptography.X509Certificates.PublicKey : object {
    [CompilerGeneratedAttribute]
private AsnEncodedData <EncodedKeyValue>k__BackingField;
    [CompilerGeneratedAttribute]
private AsnEncodedData <EncodedParameters>k__BackingField;
    private Oid _oid;
    public AsnEncodedData EncodedKeyValue { get; private set; }
    public AsnEncodedData EncodedParameters { get; private set; }
    public Oid Oid { get; }
    public PublicKey(Oid oid, AsnEncodedData parameters, AsnEncodedData keyValue);
    [CompilerGeneratedAttribute]
public AsnEncodedData get_EncodedKeyValue();
    [CompilerGeneratedAttribute]
private void set_EncodedKeyValue(AsnEncodedData value);
    [CompilerGeneratedAttribute]
public AsnEncodedData get_EncodedParameters();
    [CompilerGeneratedAttribute]
private void set_EncodedParameters(AsnEncodedData value);
    public Oid get_Oid();
}
[ExtensionAttribute]
public static class System.Security.Cryptography.X509Certificates.RSACertificateExtensions : object {
    [ExtensionAttribute]
[SecuritySafeCriticalAttribute]
public static RSA GetRSAPublicKey(X509Certificate2 certificate);
    [ExtensionAttribute]
[SecuritySafeCriticalAttribute]
public static RSA GetRSAPrivateKey(X509Certificate2 certificate);
}
public enum System.Security.Cryptography.X509Certificates.StoreLocation : Enum {
    public int value__;
    public static StoreLocation CurrentUser;
    public static StoreLocation LocalMachine;
}
public enum System.Security.Cryptography.X509Certificates.StoreName : Enum {
    public int value__;
    public static StoreName AddressBook;
    public static StoreName AuthRoot;
    public static StoreName CertificateAuthority;
    public static StoreName Disallowed;
    public static StoreName My;
    public static StoreName Root;
    public static StoreName TrustedPeople;
    public static StoreName TrustedPublisher;
}
public class System.Security.Cryptography.X509Certificates.X500DistinguishedName : AsnEncodedData {
    private String modreq(System.Runtime.CompilerServices.IsVolatile) _lazyDistinguishedName;
    public string Name { get; }
    public X500DistinguishedName(Byte[] encodedDistinguishedName);
    public X500DistinguishedName(AsnEncodedData encodedDistinguishedName);
    public X500DistinguishedName(X500DistinguishedName distinguishedName);
    public X500DistinguishedName(string distinguishedName);
    public X500DistinguishedName(string distinguishedName, X500DistinguishedNameFlags flag);
    public string get_Name();
    public string Decode(X500DistinguishedNameFlags flag);
    public virtual string Format(bool multiLine);
    private static Byte[] Encode(string distinguishedName, X500DistinguishedNameFlags flags);
    private static void ThrowIfInvalid(X500DistinguishedNameFlags flags);
}
[FlagsAttribute]
public enum System.Security.Cryptography.X509Certificates.X500DistinguishedNameFlags : Enum {
    public int value__;
    public static X500DistinguishedNameFlags None;
    public static X500DistinguishedNameFlags Reversed;
    public static X500DistinguishedNameFlags UseSemicolons;
    public static X500DistinguishedNameFlags DoNotUsePlusSign;
    public static X500DistinguishedNameFlags DoNotUseQuotes;
    public static X500DistinguishedNameFlags UseCommas;
    public static X500DistinguishedNameFlags UseNewLines;
    public static X500DistinguishedNameFlags UseUTF8Encoding;
    public static X500DistinguishedNameFlags UseT61Encoding;
    public static X500DistinguishedNameFlags ForceUTF8Encoding;
}
public class System.Security.Cryptography.X509Certificates.X509BasicConstraintsExtension : X509Extension {
    private bool _certificateAuthority;
    private bool _hasPathLenConstraint;
    private int _pathLenConstraint;
    private bool _decoded;
    public bool CertificateAuthority { get; }
    public bool HasPathLengthConstraint { get; }
    public int PathLengthConstraint { get; }
    public X509BasicConstraintsExtension(bool certificateAuthority, bool hasPathLengthConstraint, int pathLengthConstraint, bool critical);
    public X509BasicConstraintsExtension(AsnEncodedData encodedBasicConstraints, bool critical);
    public bool get_CertificateAuthority();
    public bool get_HasPathLengthConstraint();
    public int get_PathLengthConstraint();
    public virtual void CopyFrom(AsnEncodedData asnEncodedData);
    private static Byte[] EncodeExtension(bool certificateAuthority, bool hasPathLengthConstraint, int pathLengthConstraint);
    private void DecodeExtension();
}
public class System.Security.Cryptography.X509Certificates.X509Certificate : object {
    [CompilerGeneratedAttribute]
private ICertificatePal <Pal>k__BackingField;
    private Byte[] modreq(System.Runtime.CompilerServices.IsVolatile) _lazyCertHash;
    private String modreq(System.Runtime.CompilerServices.IsVolatile) _lazyIssuer;
    private String modreq(System.Runtime.CompilerServices.IsVolatile) _lazySubject;
    private Byte[] modreq(System.Runtime.CompilerServices.IsVolatile) _lazySerialNumber;
    private String modreq(System.Runtime.CompilerServices.IsVolatile) _lazyKeyAlgorithm;
    private Byte[] modreq(System.Runtime.CompilerServices.IsVolatile) _lazyKeyAlgorithmParameters;
    private Byte[] modreq(System.Runtime.CompilerServices.IsVolatile) _lazyPublicKey;
    private DateTime _lazyNotBefore;
    private DateTime _lazyNotAfter;
    private static X509KeyStorageFlags KeyStorageFlagsAll;
    public IntPtr Handle { get; }
    public string Issuer { get; }
    public string Subject { get; }
    internal ICertificatePal Pal { get; private set; }
    public X509Certificate(Byte[] data);
    public X509Certificate(Byte[] rawData, string password);
    public X509Certificate(Byte[] rawData, string password, X509KeyStorageFlags keyStorageFlags);
    public X509Certificate(IntPtr handle);
    internal X509Certificate(ICertificatePal pal);
    public X509Certificate(string fileName);
    public X509Certificate(string fileName, string password);
    public X509Certificate(string fileName, string password, X509KeyStorageFlags keyStorageFlags);
    public IntPtr get_Handle();
    public string get_Issuer();
    public string get_Subject();
    public sealed virtual void Dispose();
    protected virtual void Dispose(bool disposing);
    public virtual bool Equals(object obj);
    public virtual bool Equals(X509Certificate other);
    public virtual Byte[] Export(X509ContentType contentType);
    public virtual Byte[] Export(X509ContentType contentType, string password);
    public virtual Byte[] GetCertHash();
    private Byte[] GetRawCertHash();
    public virtual string GetFormat();
    public virtual int GetHashCode();
    public virtual string GetKeyAlgorithm();
    public virtual Byte[] GetKeyAlgorithmParameters();
    public virtual string GetKeyAlgorithmParametersString();
    public virtual Byte[] GetPublicKey();
    public virtual Byte[] GetSerialNumber();
    private Byte[] GetRawSerialNumber();
    public virtual string ToString();
    public virtual string ToString(bool fVerbose);
    [CompilerGeneratedAttribute]
internal ICertificatePal get_Pal();
    [CompilerGeneratedAttribute]
private void set_Pal(ICertificatePal value);
    internal DateTime GetNotAfter();
    internal DateTime GetNotBefore();
    internal void ThrowIfInvalid();
    internal static string FormatDate(DateTime date);
}
public class System.Security.Cryptography.X509Certificates.X509Certificate2 : X509Certificate {
    private Byte[] modreq(System.Runtime.CompilerServices.IsVolatile) _lazyRawData;
    private Oid modreq(System.Runtime.CompilerServices.IsVolatile) _lazySignatureAlgorithm;
    private Int32 modreq(System.Runtime.CompilerServices.IsVolatile) _lazyVersion;
    private X500DistinguishedName modreq(System.Runtime.CompilerServices.IsVolatile) _lazySubjectName;
    private X500DistinguishedName modreq(System.Runtime.CompilerServices.IsVolatile) _lazyIssuer;
    private PublicKey modreq(System.Runtime.CompilerServices.IsVolatile) _lazyPublicKey;
    private X509ExtensionCollection modreq(System.Runtime.CompilerServices.IsVolatile) _lazyExtensions;
    public bool Archived { get; public set; }
    public X509ExtensionCollection Extensions { get; }
    public string FriendlyName { get; public set; }
    public bool HasPrivateKey { get; }
    public X500DistinguishedName IssuerName { get; }
    public DateTime NotAfter { get; }
    public DateTime NotBefore { get; }
    public PublicKey PublicKey { get; }
    public Byte[] RawData { get; }
    public string SerialNumber { get; }
    public Oid SignatureAlgorithm { get; }
    public X500DistinguishedName SubjectName { get; }
    public string Thumbprint { get; }
    public int Version { get; }
    public X509Certificate2(Byte[] rawData);
    public X509Certificate2(Byte[] rawData, string password);
    public X509Certificate2(Byte[] rawData, string password, X509KeyStorageFlags keyStorageFlags);
    public X509Certificate2(IntPtr handle);
    internal X509Certificate2(ICertificatePal pal);
    public X509Certificate2(string fileName);
    public X509Certificate2(string fileName, string password);
    public X509Certificate2(string fileName, string password, X509KeyStorageFlags keyStorageFlags);
    public bool get_Archived();
    public void set_Archived(bool value);
    public X509ExtensionCollection get_Extensions();
    public string get_FriendlyName();
    public void set_FriendlyName(string value);
    public bool get_HasPrivateKey();
    public X500DistinguishedName get_IssuerName();
    public DateTime get_NotAfter();
    public DateTime get_NotBefore();
    public PublicKey get_PublicKey();
    public Byte[] get_RawData();
    public string get_SerialNumber();
    public Oid get_SignatureAlgorithm();
    public X500DistinguishedName get_SubjectName();
    public string get_Thumbprint();
    public int get_Version();
    public static X509ContentType GetCertContentType(Byte[] rawData);
    public static X509ContentType GetCertContentType(string fileName);
    public string GetNameInfo(X509NameType nameType, bool forIssuer);
    public virtual string ToString();
    public virtual string ToString(bool verbose);
    private static X509Extension CreateCustomExtensionIfAny(Oid oid);
}
[DefaultMemberAttribute("Item")]
public class System.Security.Cryptography.X509Certificates.X509Certificate2Collection : X509CertificateCollection {
    public X509Certificate2 Item { get; public set; }
    public X509Certificate2Collection(X509Certificate2 certificate);
    public X509Certificate2Collection(X509Certificate2[] certificates);
    public X509Certificate2Collection(X509Certificate2Collection certificates);
    public X509Certificate2 get_Item(int index);
    public void set_Item(int index, X509Certificate2 value);
    public int Add(X509Certificate2 certificate);
    public void AddRange(X509Certificate2[] certificates);
    public void AddRange(X509Certificate2Collection certificates);
    public bool Contains(X509Certificate2 certificate);
    public Byte[] Export(X509ContentType contentType);
    public Byte[] Export(X509ContentType contentType, string password);
    public X509Certificate2Collection Find(X509FindType findType, object findValue, bool validOnly);
    public X509Certificate2Enumerator GetEnumerator();
    public void Import(Byte[] rawData);
    public void Import(Byte[] rawData, string password, X509KeyStorageFlags keyStorageFlags);
    public void Import(string fileName);
    public void Import(string fileName, string password, X509KeyStorageFlags keyStorageFlags);
    public void Insert(int index, X509Certificate2 certificate);
    public void Remove(X509Certificate2 certificate);
    public void RemoveRange(X509Certificate2[] certificates);
    public void RemoveRange(X509Certificate2Collection certificates);
}
public class System.Security.Cryptography.X509Certificates.X509Certificate2Enumerator : object {
    private Enumerator<X509Certificate> _enumerator;
    public X509Certificate2 Current { get; }
    private object System.Collections.IEnumerator.Current { get; }
    internal X509Certificate2Enumerator(X509Certificate2Collection collection);
    public X509Certificate2 get_Current();
    private sealed virtual override object System.Collections.IEnumerator.get_Current();
    public bool MoveNext();
    private sealed virtual override bool System.Collections.IEnumerator.MoveNext();
    public void Reset();
    private sealed virtual override void System.Collections.IEnumerator.Reset();
}
[DefaultMemberAttribute("Item")]
public class System.Security.Cryptography.X509Certificates.X509CertificateCollection : object {
    private List`1<X509Certificate> _list;
    public int Count { get; }
    private bool System.Collections.ICollection.IsSynchronized { get; }
    private object System.Collections.ICollection.SyncRoot { get; }
    private bool System.Collections.IList.IsFixedSize { get; }
    private bool System.Collections.IList.IsReadOnly { get; }
    private object System.Collections.IList.Item { get; private set; }
    public X509Certificate Item { get; public set; }
    private IList NonGenericList { get; }
    public X509CertificateCollection(X509Certificate[] value);
    public X509CertificateCollection(X509CertificateCollection value);
    public sealed virtual int get_Count();
    private sealed virtual override bool System.Collections.ICollection.get_IsSynchronized();
    private sealed virtual override object System.Collections.ICollection.get_SyncRoot();
    private sealed virtual override bool System.Collections.IList.get_IsFixedSize();
    private sealed virtual override bool System.Collections.IList.get_IsReadOnly();
    private sealed virtual override object System.Collections.IList.get_Item(int index);
    private sealed virtual override void System.Collections.IList.set_Item(int index, object value);
    public X509Certificate get_Item(int index);
    public void set_Item(int index, X509Certificate value);
    public int Add(X509Certificate value);
    public void AddRange(X509Certificate[] value);
    public void AddRange(X509CertificateCollection value);
    public sealed virtual void Clear();
    public bool Contains(X509Certificate value);
    public void CopyTo(X509Certificate[] array, int index);
    public X509CertificateEnumerator GetEnumerator();
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
    public virtual int GetHashCode();
    public int IndexOf(X509Certificate value);
    public void Insert(int index, X509Certificate value);
    public void Remove(X509Certificate value);
    public sealed virtual void RemoveAt(int index);
    private sealed virtual override void System.Collections.ICollection.CopyTo(Array array, int index);
    private sealed virtual override int System.Collections.IList.Add(object value);
    private sealed virtual override bool System.Collections.IList.Contains(object value);
    private sealed virtual override int System.Collections.IList.IndexOf(object value);
    private sealed virtual override void System.Collections.IList.Insert(int index, object value);
    private sealed virtual override void System.Collections.IList.Remove(object value);
    private IList get_NonGenericList();
    internal void GetEnumerator(Enumerator& enumerator);
}
public class System.Security.Cryptography.X509Certificates.X509Chain : object {
    private X509ChainPolicy _chainPolicy;
    private X509ChainStatus[] modreq(System.Runtime.CompilerServices.IsVolatile) _lazyChainStatus;
    private X509ChainElementCollection _chainElements;
    private IChainPal _pal;
    private object _syncRoot;
    public X509ChainElementCollection ChainElements { get; }
    public X509ChainPolicy ChainPolicy { get; public set; }
    public X509ChainStatus[] ChainStatus { get; }
    public SafeX509ChainHandle SafeHandle { get; }
    public X509ChainElementCollection get_ChainElements();
    public X509ChainPolicy get_ChainPolicy();
    public void set_ChainPolicy(X509ChainPolicy value);
    public X509ChainStatus[] get_ChainStatus();
    public SafeX509ChainHandle get_SafeHandle();
    public bool Build(X509Certificate2 certificate);
    public sealed virtual void Dispose();
    protected virtual void Dispose(bool disposing);
    private void Reset();
}
public class System.Security.Cryptography.X509Certificates.X509ChainElement : object {
    [CompilerGeneratedAttribute]
private X509Certificate2 <Certificate>k__BackingField;
    [CompilerGeneratedAttribute]
private X509ChainStatus[] <ChainElementStatus>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Information>k__BackingField;
    public X509Certificate2 Certificate { get; private set; }
    public X509ChainStatus[] ChainElementStatus { get; private set; }
    public string Information { get; private set; }
    internal X509ChainElement(X509Certificate2 certificate, X509ChainStatus[] chainElementStatus, string information);
    [CompilerGeneratedAttribute]
public X509Certificate2 get_Certificate();
    [CompilerGeneratedAttribute]
private void set_Certificate(X509Certificate2 value);
    [CompilerGeneratedAttribute]
public X509ChainStatus[] get_ChainElementStatus();
    [CompilerGeneratedAttribute]
private void set_ChainElementStatus(X509ChainStatus[] value);
    [CompilerGeneratedAttribute]
public string get_Information();
    [CompilerGeneratedAttribute]
private void set_Information(string value);
}
[DefaultMemberAttribute("Item")]
public class System.Security.Cryptography.X509Certificates.X509ChainElementCollection : object {
    private X509ChainElement[] _elements;
    public int Count { get; }
    private bool System.Collections.ICollection.IsSynchronized { get; }
    private object System.Collections.ICollection.SyncRoot { get; }
    public X509ChainElement Item { get; }
    internal X509ChainElementCollection(X509ChainElement[] chainElements);
    public sealed virtual int get_Count();
    private sealed virtual override bool System.Collections.ICollection.get_IsSynchronized();
    private sealed virtual override object System.Collections.ICollection.get_SyncRoot();
    public X509ChainElement get_Item(int index);
    public void CopyTo(X509ChainElement[] array, int index);
    private sealed virtual override void System.Collections.ICollection.CopyTo(Array array, int index);
    public X509ChainElementEnumerator GetEnumerator();
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
}
public class System.Security.Cryptography.X509Certificates.X509ChainElementEnumerator : object {
    private X509ChainElementCollection _chainElements;
    private int _current;
    public X509ChainElement Current { get; }
    private object System.Collections.IEnumerator.Current { get; }
    internal X509ChainElementEnumerator(X509ChainElementCollection chainElements);
    public X509ChainElement get_Current();
    private sealed virtual override object System.Collections.IEnumerator.get_Current();
    public sealed virtual bool MoveNext();
    public sealed virtual void Reset();
}
public class System.Security.Cryptography.X509Certificates.X509ChainPolicy : object {
    [CompilerGeneratedAttribute]
private OidCollection <ApplicationPolicy>k__BackingField;
    [CompilerGeneratedAttribute]
private OidCollection <CertificatePolicy>k__BackingField;
    [CompilerGeneratedAttribute]
private DateTime <VerificationTime>k__BackingField;
    [CompilerGeneratedAttribute]
private TimeSpan <UrlRetrievalTimeout>k__BackingField;
    [CompilerGeneratedAttribute]
private X509Certificate2Collection <ExtraStore>k__BackingField;
    private X509RevocationMode _revocationMode;
    private X509RevocationFlag _revocationFlag;
    private X509VerificationFlags _verificationFlags;
    public OidCollection ApplicationPolicy { get; private set; }
    public OidCollection CertificatePolicy { get; private set; }
    public X509RevocationMode RevocationMode { get; public set; }
    public X509RevocationFlag RevocationFlag { get; public set; }
    public X509VerificationFlags VerificationFlags { get; public set; }
    public DateTime VerificationTime { get; public set; }
    public TimeSpan UrlRetrievalTimeout { get; public set; }
    public X509Certificate2Collection ExtraStore { get; private set; }
    [CompilerGeneratedAttribute]
public OidCollection get_ApplicationPolicy();
    [CompilerGeneratedAttribute]
private void set_ApplicationPolicy(OidCollection value);
    [CompilerGeneratedAttribute]
public OidCollection get_CertificatePolicy();
    [CompilerGeneratedAttribute]
private void set_CertificatePolicy(OidCollection value);
    public X509RevocationMode get_RevocationMode();
    public void set_RevocationMode(X509RevocationMode value);
    public X509RevocationFlag get_RevocationFlag();
    public void set_RevocationFlag(X509RevocationFlag value);
    public X509VerificationFlags get_VerificationFlags();
    public void set_VerificationFlags(X509VerificationFlags value);
    [CompilerGeneratedAttribute]
public DateTime get_VerificationTime();
    [CompilerGeneratedAttribute]
public void set_VerificationTime(DateTime value);
    [CompilerGeneratedAttribute]
public TimeSpan get_UrlRetrievalTimeout();
    [CompilerGeneratedAttribute]
public void set_UrlRetrievalTimeout(TimeSpan value);
    [CompilerGeneratedAttribute]
public X509Certificate2Collection get_ExtraStore();
    [CompilerGeneratedAttribute]
private void set_ExtraStore(X509Certificate2Collection value);
    public void Reset();
}
public class System.Security.Cryptography.X509Certificates.X509ChainStatus : ValueType {
    [CompilerGeneratedAttribute]
private X509ChainStatusFlags <Status>k__BackingField;
    private string _statusInformation;
    public X509ChainStatusFlags Status { get; public set; }
    public string StatusInformation { get; public set; }
    [CompilerGeneratedAttribute]
public X509ChainStatusFlags get_Status();
    [CompilerGeneratedAttribute]
public void set_Status(X509ChainStatusFlags value);
    public string get_StatusInformation();
    public void set_StatusInformation(string value);
}
[FlagsAttribute]
public enum System.Security.Cryptography.X509Certificates.X509ChainStatusFlags : Enum {
    public int value__;
    public static X509ChainStatusFlags NoError;
    public static X509ChainStatusFlags NotTimeValid;
    public static X509ChainStatusFlags NotTimeNested;
    public static X509ChainStatusFlags Revoked;
    public static X509ChainStatusFlags NotSignatureValid;
    public static X509ChainStatusFlags NotValidForUsage;
    public static X509ChainStatusFlags UntrustedRoot;
    public static X509ChainStatusFlags RevocationStatusUnknown;
    public static X509ChainStatusFlags Cyclic;
    public static X509ChainStatusFlags InvalidExtension;
    public static X509ChainStatusFlags InvalidPolicyConstraints;
    public static X509ChainStatusFlags InvalidBasicConstraints;
    public static X509ChainStatusFlags InvalidNameConstraints;
    public static X509ChainStatusFlags HasNotSupportedNameConstraint;
    public static X509ChainStatusFlags HasNotDefinedNameConstraint;
    public static X509ChainStatusFlags HasNotPermittedNameConstraint;
    public static X509ChainStatusFlags HasExcludedNameConstraint;
    public static X509ChainStatusFlags PartialChain;
    public static X509ChainStatusFlags CtlNotTimeValid;
    public static X509ChainStatusFlags CtlNotSignatureValid;
    public static X509ChainStatusFlags CtlNotValidForUsage;
    public static X509ChainStatusFlags OfflineRevocation;
    public static X509ChainStatusFlags NoIssuanceChainPolicy;
    public static X509ChainStatusFlags ExplicitDistrust;
    public static X509ChainStatusFlags HasNotSupportedCriticalExtension;
    public static X509ChainStatusFlags HasWeakSignature;
}
public enum System.Security.Cryptography.X509Certificates.X509ContentType : Enum {
    public int value__;
    public static X509ContentType Unknown;
    public static X509ContentType Cert;
    public static X509ContentType SerializedCert;
    public static X509ContentType Pfx;
    public static X509ContentType Pkcs12;
    public static X509ContentType SerializedStore;
    public static X509ContentType Pkcs7;
    public static X509ContentType Authenticode;
}
public class System.Security.Cryptography.X509Certificates.X509EnhancedKeyUsageExtension : X509Extension {
    private OidCollection _enhancedKeyUsages;
    private bool _decoded;
    public OidCollection EnhancedKeyUsages { get; }
    public X509EnhancedKeyUsageExtension(AsnEncodedData encodedEnhancedKeyUsages, bool critical);
    public X509EnhancedKeyUsageExtension(OidCollection enhancedKeyUsages, bool critical);
    public OidCollection get_EnhancedKeyUsages();
    public virtual void CopyFrom(AsnEncodedData asnEncodedData);
    private static Byte[] EncodeExtension(OidCollection enhancedKeyUsages);
}
public class System.Security.Cryptography.X509Certificates.X509Extension : AsnEncodedData {
    [CompilerGeneratedAttribute]
private bool <Critical>k__BackingField;
    public bool Critical { get; public set; }
    public X509Extension(AsnEncodedData encodedExtension, bool critical);
    public X509Extension(Oid oid, Byte[] rawData, bool critical);
    public X509Extension(string oid, Byte[] rawData, bool critical);
    internal X509Extension(string oidValue);
    [CompilerGeneratedAttribute]
public bool get_Critical();
    [CompilerGeneratedAttribute]
public void set_Critical(bool value);
    public virtual void CopyFrom(AsnEncodedData asnEncodedData);
}
[DefaultMemberAttribute("Item")]
public class System.Security.Cryptography.X509Certificates.X509ExtensionCollection : object {
    private List`1<X509Extension> _list;
    public int Count { get; }
    private bool System.Collections.ICollection.IsSynchronized { get; }
    private object System.Collections.ICollection.SyncRoot { get; }
    public X509Extension Item { get; }
    public X509Extension Item { get; }
    public sealed virtual int get_Count();
    private sealed virtual override bool System.Collections.ICollection.get_IsSynchronized();
    private sealed virtual override object System.Collections.ICollection.get_SyncRoot();
    public X509Extension get_Item(int index);
    public X509Extension get_Item(string oid);
    public int Add(X509Extension extension);
    public void CopyTo(X509Extension[] array, int index);
    private sealed virtual override void System.Collections.ICollection.CopyTo(Array array, int index);
    public X509ExtensionEnumerator GetEnumerator();
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
}
public class System.Security.Cryptography.X509Certificates.X509ExtensionEnumerator : object {
    private X509ExtensionCollection _extensions;
    private int _current;
    public X509Extension Current { get; }
    private object System.Collections.IEnumerator.Current { get; }
    internal X509ExtensionEnumerator(X509ExtensionCollection extensions);
    public X509Extension get_Current();
    private sealed virtual override object System.Collections.IEnumerator.get_Current();
    public sealed virtual bool MoveNext();
    public sealed virtual void Reset();
}
public enum System.Security.Cryptography.X509Certificates.X509FindType : Enum {
    public int value__;
    public static X509FindType FindByThumbprint;
    public static X509FindType FindBySubjectName;
    public static X509FindType FindBySubjectDistinguishedName;
    public static X509FindType FindByIssuerName;
    public static X509FindType FindByIssuerDistinguishedName;
    public static X509FindType FindBySerialNumber;
    public static X509FindType FindByTimeValid;
    public static X509FindType FindByTimeNotYetValid;
    public static X509FindType FindByTimeExpired;
    public static X509FindType FindByTemplateName;
    public static X509FindType FindByApplicationPolicy;
    public static X509FindType FindByCertificatePolicy;
    public static X509FindType FindByExtension;
    public static X509FindType FindByKeyUsage;
    public static X509FindType FindBySubjectKeyIdentifier;
}
[FlagsAttribute]
public enum System.Security.Cryptography.X509Certificates.X509KeyStorageFlags : Enum {
    public int value__;
    public static X509KeyStorageFlags DefaultKeySet;
    public static X509KeyStorageFlags UserKeySet;
    public static X509KeyStorageFlags MachineKeySet;
    public static X509KeyStorageFlags Exportable;
    public static X509KeyStorageFlags UserProtected;
    public static X509KeyStorageFlags PersistKeySet;
}
public class System.Security.Cryptography.X509Certificates.X509KeyUsageExtension : X509Extension {
    private bool _decoded;
    private X509KeyUsageFlags _keyUsages;
    public X509KeyUsageFlags KeyUsages { get; }
    public X509KeyUsageExtension(AsnEncodedData encodedKeyUsage, bool critical);
    public X509KeyUsageExtension(X509KeyUsageFlags keyUsages, bool critical);
    public X509KeyUsageFlags get_KeyUsages();
    public virtual void CopyFrom(AsnEncodedData asnEncodedData);
}
[FlagsAttribute]
public enum System.Security.Cryptography.X509Certificates.X509KeyUsageFlags : Enum {
    public int value__;
    public static X509KeyUsageFlags None;
    public static X509KeyUsageFlags EncipherOnly;
    public static X509KeyUsageFlags CrlSign;
    public static X509KeyUsageFlags KeyCertSign;
    public static X509KeyUsageFlags KeyAgreement;
    public static X509KeyUsageFlags DataEncipherment;
    public static X509KeyUsageFlags KeyEncipherment;
    public static X509KeyUsageFlags NonRepudiation;
    public static X509KeyUsageFlags DigitalSignature;
    public static X509KeyUsageFlags DecipherOnly;
}
public enum System.Security.Cryptography.X509Certificates.X509NameType : Enum {
    public int value__;
    public static X509NameType SimpleName;
    public static X509NameType EmailName;
    public static X509NameType UpnName;
    public static X509NameType DnsName;
    public static X509NameType DnsFromAlternativeName;
    public static X509NameType UrlName;
}
public enum System.Security.Cryptography.X509Certificates.X509RevocationFlag : Enum {
    public int value__;
    public static X509RevocationFlag EndCertificateOnly;
    public static X509RevocationFlag EntireChain;
    public static X509RevocationFlag ExcludeRoot;
}
public enum System.Security.Cryptography.X509Certificates.X509RevocationMode : Enum {
    public int value__;
    public static X509RevocationMode NoCheck;
    public static X509RevocationMode Online;
    public static X509RevocationMode Offline;
}
public class System.Security.Cryptography.X509Certificates.X509Store : object {
    [CompilerGeneratedAttribute]
private StoreLocation <Location>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Name>k__BackingField;
    private IStorePal _storePal;
    public StoreLocation Location { get; private set; }
    public string Name { get; private set; }
    public X509Certificate2Collection Certificates { get; }
    public X509Store(StoreName storeName, StoreLocation storeLocation);
    public X509Store(string storeName, StoreLocation storeLocation);
    [CompilerGeneratedAttribute]
public StoreLocation get_Location();
    [CompilerGeneratedAttribute]
private void set_Location(StoreLocation value);
    [CompilerGeneratedAttribute]
public string get_Name();
    [CompilerGeneratedAttribute]
private void set_Name(string value);
    public void Open(OpenFlags flags);
    public X509Certificate2Collection get_Certificates();
    public void Add(X509Certificate2 certificate);
    public void Remove(X509Certificate2 certificate);
    public sealed virtual void Dispose();
    private void Close();
}
public class System.Security.Cryptography.X509Certificates.X509SubjectKeyIdentifierExtension : X509Extension {
    private string _subjectKeyIdentifier;
    private bool _decoded;
    public string SubjectKeyIdentifier { get; }
    public X509SubjectKeyIdentifierExtension(AsnEncodedData encodedSubjectKeyIdentifier, bool critical);
    public X509SubjectKeyIdentifierExtension(Byte[] subjectKeyIdentifier, bool critical);
    public X509SubjectKeyIdentifierExtension(PublicKey key, bool critical);
    public X509SubjectKeyIdentifierExtension(PublicKey key, X509SubjectKeyIdentifierHashAlgorithm algorithm, bool critical);
    public X509SubjectKeyIdentifierExtension(string subjectKeyIdentifier, bool critical);
    public string get_SubjectKeyIdentifier();
    public virtual void CopyFrom(AsnEncodedData asnEncodedData);
    private static Byte[] EncodeExtension(Byte[] subjectKeyIdentifier);
    private static Byte[] EncodeExtension(string subjectKeyIdentifier);
    private static Byte[] EncodeExtension(PublicKey key, X509SubjectKeyIdentifierHashAlgorithm algorithm);
    private static Byte[] GenerateSubjectKeyIdentifierFromPublicKey(PublicKey key, X509SubjectKeyIdentifierHashAlgorithm algorithm);
    private static Byte[] ComputeSha1(Byte[] data);
}
public enum System.Security.Cryptography.X509Certificates.X509SubjectKeyIdentifierHashAlgorithm : Enum {
    public int value__;
    public static X509SubjectKeyIdentifierHashAlgorithm Sha1;
    public static X509SubjectKeyIdentifierHashAlgorithm ShortSha1;
    public static X509SubjectKeyIdentifierHashAlgorithm CapiSha1;
}
[FlagsAttribute]
public enum System.Security.Cryptography.X509Certificates.X509VerificationFlags : Enum {
    public int value__;
    public static X509VerificationFlags NoFlag;
    public static X509VerificationFlags IgnoreNotTimeValid;
    public static X509VerificationFlags IgnoreCtlNotTimeValid;
    public static X509VerificationFlags IgnoreNotTimeNested;
    public static X509VerificationFlags IgnoreInvalidBasicConstraints;
    public static X509VerificationFlags AllowUnknownCertificateAuthority;
    public static X509VerificationFlags IgnoreWrongUsage;
    public static X509VerificationFlags IgnoreInvalidName;
    public static X509VerificationFlags IgnoreInvalidPolicy;
    public static X509VerificationFlags IgnoreEndRevocationUnknown;
    public static X509VerificationFlags IgnoreCtlSignerRevocationUnknown;
    public static X509VerificationFlags IgnoreCertificateAuthorityRevocationUnknown;
    public static X509VerificationFlags IgnoreRootRevocationUnknown;
    public static X509VerificationFlags AllFlags;
}
internal static class System.SR : object {
    private static ResourceManager s_resourceManager;
    private static string s_resourcesName;
    private static ResourceManager ResourceManager { get; }
    internal static string Arg_EmptyOrNullArray { get; }
    internal static string Arg_EmptyOrNullString { get; }
    internal static string Arg_EnumIllegalVal { get; }
    internal static string Arg_InvalidHandle { get; }
    internal static string Arg_OutOfRange_NeedNonNegNum { get; }
    internal static string Arg_RankMultiDimNotSupported { get; }
    internal static string Arg_RemoveArgNotFound { get; }
    internal static string Argument_InvalidFlag { get; }
    internal static string Argument_InvalidNameType { get; }
    internal static string Argument_InvalidOffLen { get; }
    internal static string Argument_InvalidOidValue { get; }
    internal static string ArgumentOutOfRange_Index { get; }
    internal static string Chain_NoPolicyMatch { get; }
    internal static string Cryptography_InvalidContextHandle { get; }
    internal static string Cryptography_InvalidHandle { get; }
    internal static string Cryptography_InvalidOID { get; }
    internal static string Cryptography_InvalidStoreHandle { get; }
    internal static string Cryptography_Unix_X509_MachineStoresReadOnly { get; }
    internal static string Cryptography_Unix_X509_MachineStoresRootOnly { get; }
    internal static string Cryptography_Unix_X509_PropertyNotSettable { get; }
    internal static string Cryptography_Unix_X509_SerializedExport { get; }
    internal static string Cryptography_X509_ExportFailed { get; }
    internal static string Cryptography_X509_ExtensionMismatch { get; }
    internal static string Cryptography_X509_InvalidContentType { get; }
    internal static string Cryptography_X509_InvalidFindType { get; }
    internal static string Cryptography_X509_InvalidFindValue { get; }
    internal static string Cryptography_X509_KeyMismatch { get; }
    internal static string Cryptography_X509_PKCS7_NoSigner { get; }
    internal static string Cryptography_X509_StoreNoFileAvailable { get; }
    internal static string Cryptography_X509_StoreNotFound { get; }
    internal static string Cryptography_X509_StoreNotOpen { get; }
    internal static string Cryptography_X509_StoreReadOnly { get; }
    internal static string InvalidOperation_EnumNotStarted { get; }
    internal static string InvalidPublicKeyInX509 { get; }
    internal static string NotSupported_ECDsa_Csp { get; }
    internal static string NotSupported_Export_MultiplePrivateCerts { get; }
    internal static string NotSupported_InvalidKeyImpl { get; }
    internal static string NotSupported_KeyAlgorithm { get; }
    internal static string NotSupported_LegacyBasicConstraints { get; }
    internal static string PersistedFiles_NoHomeDirectory { get; }
    internal static string Security_InvalidValue { get; }
    internal static string Unknown_Error { get; }
    internal static string Cryptography_FileStatusError { get; }
    internal static string Cryptography_InvalidDirectoryPermissions { get; }
    internal static string Cryptography_OwnerNotCurrentUser { get; }
    internal static string Cryptography_InvalidFilePermissions { get; }
    internal static string Cryptography_Invalid_X500Name { get; }
    internal static string Cryptography_Invalid_IA5String { get; }
    internal static Type ResourceType { get; }
    private static ResourceManager get_ResourceManager();
    private static bool UsingResourceKeys();
    internal static string GetResourceString(string resourceKey, string defaultString);
    internal static string Format(string resourceFormat, Object[] args);
    internal static string Format(string resourceFormat, object p1);
    internal static string Format(string resourceFormat, object p1, object p2);
    internal static string Format(string resourceFormat, object p1, object p2, object p3);
    internal static string get_Arg_EmptyOrNullArray();
    internal static string get_Arg_EmptyOrNullString();
    internal static string get_Arg_EnumIllegalVal();
    internal static string get_Arg_InvalidHandle();
    internal static string get_Arg_OutOfRange_NeedNonNegNum();
    internal static string get_Arg_RankMultiDimNotSupported();
    internal static string get_Arg_RemoveArgNotFound();
    internal static string get_Argument_InvalidFlag();
    internal static string get_Argument_InvalidNameType();
    internal static string get_Argument_InvalidOffLen();
    internal static string get_Argument_InvalidOidValue();
    internal static string get_ArgumentOutOfRange_Index();
    internal static string get_Chain_NoPolicyMatch();
    internal static string get_Cryptography_InvalidContextHandle();
    internal static string get_Cryptography_InvalidHandle();
    internal static string get_Cryptography_InvalidOID();
    internal static string get_Cryptography_InvalidStoreHandle();
    internal static string get_Cryptography_Unix_X509_MachineStoresReadOnly();
    internal static string get_Cryptography_Unix_X509_MachineStoresRootOnly();
    internal static string get_Cryptography_Unix_X509_PropertyNotSettable();
    internal static string get_Cryptography_Unix_X509_SerializedExport();
    internal static string get_Cryptography_X509_ExportFailed();
    internal static string get_Cryptography_X509_ExtensionMismatch();
    internal static string get_Cryptography_X509_InvalidContentType();
    internal static string get_Cryptography_X509_InvalidFindType();
    internal static string get_Cryptography_X509_InvalidFindValue();
    internal static string get_Cryptography_X509_KeyMismatch();
    internal static string get_Cryptography_X509_PKCS7_NoSigner();
    internal static string get_Cryptography_X509_StoreNoFileAvailable();
    internal static string get_Cryptography_X509_StoreNotFound();
    internal static string get_Cryptography_X509_StoreNotOpen();
    internal static string get_Cryptography_X509_StoreReadOnly();
    internal static string get_InvalidOperation_EnumNotStarted();
    internal static string get_InvalidPublicKeyInX509();
    internal static string get_NotSupported_ECDsa_Csp();
    internal static string get_NotSupported_Export_MultiplePrivateCerts();
    internal static string get_NotSupported_InvalidKeyImpl();
    internal static string get_NotSupported_KeyAlgorithm();
    internal static string get_NotSupported_LegacyBasicConstraints();
    internal static string get_PersistedFiles_NoHomeDirectory();
    internal static string get_Security_InvalidValue();
    internal static string get_Unknown_Error();
    internal static string get_Cryptography_FileStatusError();
    internal static string get_Cryptography_InvalidDirectoryPermissions();
    internal static string get_Cryptography_OwnerNotCurrentUser();
    internal static string get_Cryptography_InvalidFilePermissions();
    internal static string get_Cryptography_Invalid_X500Name();
    internal static string get_Cryptography_Invalid_IA5String();
    internal static Type get_ResourceType();
}
