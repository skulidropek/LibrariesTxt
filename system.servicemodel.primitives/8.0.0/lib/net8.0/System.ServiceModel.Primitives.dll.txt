internal static class FxResources.System.ServiceModel.Primitives.SR : object {
}
internal static class System.__HResults : object {
    internal static int APPMODEL_ERROR_NO_PACKAGE;
    internal static int CLDB_E_FILE_CORRUPT;
    internal static int CLDB_E_FILE_OLDVER;
    internal static int CLDB_E_INDEX_NOTFOUND;
    internal static int CLR_E_BIND_ASSEMBLY_NOT_FOUND;
    internal static int CLR_E_BIND_ASSEMBLY_PUBLIC_KEY_MISMATCH;
    internal static int CLR_E_BIND_ASSEMBLY_VERSION_TOO_LOW;
    internal static int CLR_E_BIND_TYPE_NOT_FOUND;
    internal static int CLR_E_BIND_UNRECOGNIZED_IDENTITY_FORMAT;
    internal static int COR_E_ABANDONEDMUTEX;
    internal static int COR_E_AMBIGUOUSMATCH;
    internal static int COR_E_APPDOMAINUNLOADED;
    internal static int COR_E_APPLICATION;
    internal static int COR_E_ARGUMENT;
    internal static int COR_E_ARGUMENTOUTOFRANGE;
    internal static int COR_E_ARITHMETIC;
    internal static int COR_E_ARRAYTYPEMISMATCH;
    internal static int COR_E_ASSEMBLYEXPECTED;
    internal static int COR_E_BADIMAGEFORMAT;
    internal static int COR_E_CANNOTUNLOADAPPDOMAIN;
    internal static int COR_E_CODECONTRACTFAILED;
    internal static int COR_E_CONTEXTMARSHAL;
    internal static int COR_E_CUSTOMATTRIBUTEFORMAT;
    internal static int COR_E_DATAMISALIGNED;
    internal static int COR_E_DIVIDEBYZERO;
    internal static int COR_E_DLLNOTFOUND;
    internal static int COR_E_DUPLICATEWAITOBJECT;
    internal static int COR_E_ENTRYPOINTNOTFOUND;
    internal static int COR_E_EXCEPTION;
    internal static int COR_E_EXECUTIONENGINE;
    internal static int COR_E_FIELDACCESS;
    internal static int COR_E_FIXUPSINEXE;
    internal static int COR_E_FORMAT;
    internal static int COR_E_INDEXOUTOFRANGE;
    internal static int COR_E_INSUFFICIENTEXECUTIONSTACK;
    internal static int COR_E_INVALIDCAST;
    internal static int COR_E_INVALIDCOMOBJECT;
    internal static int COR_E_INVALIDFILTERCRITERIA;
    internal static int COR_E_INVALIDOLEVARIANTTYPE;
    internal static int COR_E_INVALIDOPERATION;
    internal static int COR_E_INVALIDPROGRAM;
    internal static int COR_E_KEYNOTFOUND;
    internal static int COR_E_LOADING_REFERENCE_ASSEMBLY;
    internal static int COR_E_MARSHALDIRECTIVE;
    internal static int COR_E_MEMBERACCESS;
    internal static int COR_E_METHODACCESS;
    internal static int COR_E_MISSINGFIELD;
    internal static int COR_E_MISSINGMANIFESTRESOURCE;
    internal static int COR_E_MISSINGMEMBER;
    internal static int COR_E_MISSINGMETHOD;
    internal static int COR_E_MISSINGSATELLITEASSEMBLY;
    internal static int COR_E_MODULE_HASH_CHECK_FAILED;
    internal static int COR_E_MULTICASTNOTSUPPORTED;
    internal static int COR_E_NEWER_RUNTIME;
    internal static int COR_E_NOTFINITENUMBER;
    internal static int COR_E_NOTSUPPORTED;
    internal static int COR_E_NULLREFERENCE;
    internal static int COR_E_OBJECTDISPOSED;
    internal static int COR_E_OPERATIONCANCELED;
    internal static int COR_E_OUTOFMEMORY;
    internal static int COR_E_OVERFLOW;
    internal static int COR_E_PLATFORMNOTSUPPORTED;
    internal static int COR_E_RANK;
    internal static int COR_E_REFLECTIONTYPELOAD;
    internal static int COR_E_REMOTING;
    internal static int COR_E_RUNTIMEWRAPPED;
    internal static int COR_E_SAFEARRAYRANKMISMATCH;
    internal static int COR_E_SAFEARRAYTYPEMISMATCH;
    internal static int COR_E_SECURITY;
    internal static int COR_E_SERIALIZATION;
    internal static int COR_E_SERVER;
    internal static int COR_E_STACKOVERFLOW;
    internal static int COR_E_SYNCHRONIZATIONLOCK;
    internal static int COR_E_SYSTEM;
    internal static int COR_E_TARGET;
    internal static int COR_E_TARGETINVOCATION;
    internal static int COR_E_TARGETPARAMCOUNT;
    internal static int COR_E_THREADABORTED;
    internal static int COR_E_THREADINTERRUPTED;
    internal static int COR_E_THREADSTART;
    internal static int COR_E_THREADSTATE;
    internal static int COR_E_TIMEOUT;
    internal static int COR_E_TYPEACCESS;
    internal static int COR_E_TYPEINITIALIZATION;
    internal static int COR_E_TYPELOAD;
    internal static int COR_E_TYPEUNLOADED;
    internal static int COR_E_UNAUTHORIZEDACCESS;
    internal static int COR_E_VERIFICATION;
    internal static int COR_E_WAITHANDLECANNOTBEOPENED;
    internal static int CORSEC_E_CRYPTO;
    internal static int CORSEC_E_CRYPTO_UNEX_OPER;
    internal static int CORSEC_E_INVALID_IMAGE_FORMAT;
    internal static int CORSEC_E_INVALID_PUBLICKEY;
    internal static int CORSEC_E_INVALID_STRONGNAME;
    internal static int CORSEC_E_MIN_GRANT_FAIL;
    internal static int CORSEC_E_MISSING_STRONGNAME;
    internal static int CORSEC_E_NO_EXEC_PERM;
    internal static int CORSEC_E_POLICY_EXCEPTION;
    internal static int CORSEC_E_SIGNATURE_MISMATCH;
    internal static int CORSEC_E_XMLSYNTAX;
    internal static int CTL_E_DEVICEIOERROR;
    internal static int CTL_E_DIVISIONBYZERO;
    internal static int CTL_E_FILENOTFOUND;
    internal static int CTL_E_OUTOFMEMORY;
    internal static int CTL_E_OUTOFSTACKSPACE;
    internal static int CTL_E_OVERFLOW;
    internal static int CTL_E_PATHFILEACCESSERROR;
    internal static int CTL_E_PATHNOTFOUND;
    internal static int CTL_E_PERMISSIONDENIED;
    internal static int E_ELEMENTNOTAVAILABLE;
    internal static int E_ELEMENTNOTENABLED;
    internal static int E_FAIL;
    internal static int E_ILLEGAL_DELEGATE_ASSIGNMENT;
    internal static int E_ILLEGAL_METHOD_CALL;
    internal static int E_ILLEGAL_STATE_CHANGE;
    internal static int E_LAYOUTCYCLE;
    internal static int E_NOTIMPL;
    internal static int E_OUTOFMEMORY;
    internal static int E_POINTER;
    internal static int E_XAMLPARSEFAILED;
    internal static int ERROR_BAD_EXE_FORMAT;
    internal static int ERROR_BAD_NET_NAME;
    internal static int ERROR_BAD_NETPATH;
    internal static int ERROR_DISK_CORRUPT;
    internal static int ERROR_DLL_INIT_FAILED;
    internal static int ERROR_DLL_NOT_FOUND;
    internal static int ERROR_EXE_MARKED_INVALID;
    internal static int ERROR_FILE_CORRUPT;
    internal static int ERROR_FILE_INVALID;
    internal static int ERROR_FILE_NOT_FOUND;
    internal static int ERROR_INVALID_DLL;
    internal static int ERROR_INVALID_NAME;
    internal static int ERROR_INVALID_ORDINAL;
    internal static int ERROR_INVALID_PARAMETER;
    internal static int ERROR_LOCK_VIOLATION;
    internal static int ERROR_MOD_NOT_FOUND;
    internal static int ERROR_NO_UNICODE_TRANSLATION;
    internal static int ERROR_NOACCESS;
    internal static int ERROR_NOT_READY;
    internal static int ERROR_OPEN_FAILED;
    internal static int ERROR_PATH_NOT_FOUND;
    internal static int ERROR_SHARING_VIOLATION;
    internal static int ERROR_TOO_MANY_OPEN_FILES;
    internal static int ERROR_UNRECOGNIZED_VOLUME;
    internal static int ERROR_WRONG_TARGET_NAME;
    internal static int FUSION_E_ASM_MODULE_MISSING;
    internal static int FUSION_E_CACHEFILE_FAILED;
    internal static int FUSION_E_CODE_DOWNLOAD_DISABLED;
    internal static int FUSION_E_HOST_GAC_ASM_MISMATCH;
    internal static int FUSION_E_INVALID_NAME;
    internal static int FUSION_E_INVALID_PRIVATE_ASM_LOCATION;
    internal static int FUSION_E_LOADFROM_BLOCKED;
    internal static int FUSION_E_PRIVATE_ASM_DISALLOWED;
    internal static int FUSION_E_REF_DEF_MISMATCH;
    internal static int FUSION_E_SIGNATURE_CHECK_FAILED;
    internal static int INET_E_CANNOT_CONNECT;
    internal static int INET_E_CONNECTION_TIMEOUT;
    internal static int INET_E_DATA_NOT_AVAILABLE;
    internal static int INET_E_DOWNLOAD_FAILURE;
    internal static int INET_E_OBJECT_NOT_FOUND;
    internal static int INET_E_RESOURCE_NOT_FOUND;
    internal static int INET_E_UNKNOWN_PROTOCOL;
    internal static int ISS_E_ALLOC_TOO_LARGE;
    internal static int ISS_E_BLOCK_SIZE_TOO_SMALL;
    internal static int ISS_E_CALLER;
    internal static int ISS_E_CORRUPTED_STORE_FILE;
    internal static int ISS_E_CREATE_DIR;
    internal static int ISS_E_CREATE_MUTEX;
    internal static int ISS_E_DEPRECATE;
    internal static int ISS_E_FILE_NOT_MAPPED;
    internal static int ISS_E_FILE_WRITE;
    internal static int ISS_E_GET_FILE_SIZE;
    internal static int ISS_E_ISOSTORE;
    internal static int ISS_E_LOCK_FAILED;
    internal static int ISS_E_MACHINE;
    internal static int ISS_E_MACHINE_DACL;
    internal static int ISS_E_MAP_VIEW_OF_FILE;
    internal static int ISS_E_OPEN_FILE_MAPPING;
    internal static int ISS_E_OPEN_STORE_FILE;
    internal static int ISS_E_PATH_LENGTH;
    internal static int ISS_E_SET_FILE_POINTER;
    internal static int ISS_E_STORE_NOT_OPEN;
    internal static int ISS_E_STORE_VERSION;
    internal static int ISS_E_TABLE_ROW_NOT_FOUND;
    internal static int ISS_E_USAGE_WILL_EXCEED_QUOTA;
    internal static int META_E_BAD_SIGNATURE;
    internal static int META_E_CA_FRIENDS_SN_REQUIRED;
    internal static int MSEE_E_ASSEMBLYLOADINPROGRESS;
    internal static int RO_E_CLOSED;
    internal static int E_BOUNDS;
    internal static int RO_E_METADATA_NAME_NOT_FOUND;
    internal static int SECURITY_E_INCOMPATIBLE_EVIDENCE;
    internal static int SECURITY_E_INCOMPATIBLE_SHARE;
    internal static int SECURITY_E_UNVERIFIABLE;
    internal static int STG_E_PATHNOTFOUND;
    public static int COR_E_DIRECTORYNOTFOUND;
    public static int COR_E_ENDOFSTREAM;
    public static int COR_E_FILELOAD;
    public static int COR_E_FILENOTFOUND;
    public static int COR_E_IO;
    public static int COR_E_PATHTOOLONG;
}
public class System.Collections.Generic.KeyedByTypeCollection`1 : KeyedCollection`2<Type, TItem> {
    public KeyedByTypeCollection`1(IEnumerable`1<TItem> items);
    public T Find();
    public T Remove();
    private T Find(bool remove);
    public Collection`1<T> FindAll();
    public Collection`1<T> RemoveAll();
    private Collection`1<T> FindAll(bool remove);
    protected virtual Type GetKeyForItem(TItem item);
    protected virtual void InsertItem(int index, TItem item);
    protected virtual void SetItem(int index, TItem item);
}
[DefaultMemberAttribute("Item")]
[ComVisibleAttribute("False")]
public class System.Collections.Generic.SynchronizedCollection`1 : object {
    private object _sync;
    [CompilerGeneratedAttribute]
private List`1<T> <Items>k__BackingField;
    public int Count { get; }
    protected List`1<T> Items { get; }
    public object SyncRoot { get; }
    public T Item { get; public set; }
    private bool System.Collections.Generic.ICollection<T>.IsReadOnly { get; }
    private bool System.Collections.ICollection.IsSynchronized { get; }
    private object System.Collections.ICollection.SyncRoot { get; }
    private object System.Collections.IList.Item { get; private set; }
    private bool System.Collections.IList.IsReadOnly { get; }
    private bool System.Collections.IList.IsFixedSize { get; }
    public SynchronizedCollection`1(object syncRoot);
    public SynchronizedCollection`1(object syncRoot, IEnumerable`1<T> list);
    public SynchronizedCollection`1(object syncRoot, T[] list);
    public sealed virtual int get_Count();
    [CompilerGeneratedAttribute]
protected List`1<T> get_Items();
    public object get_SyncRoot();
    public sealed virtual T get_Item(int index);
    public sealed virtual void set_Item(int index, T value);
    public sealed virtual void Add(T item);
    public sealed virtual void Clear();
    public sealed virtual void CopyTo(T[] array, int index);
    public sealed virtual bool Contains(T item);
    public sealed virtual IEnumerator`1<T> GetEnumerator();
    public sealed virtual int IndexOf(T item);
    public sealed virtual void Insert(int index, T item);
    private int InternalIndexOf(T item);
    public sealed virtual bool Remove(T item);
    public sealed virtual void RemoveAt(int index);
    protected virtual void ClearItems();
    protected virtual void InsertItem(int index, T item);
    protected virtual void RemoveItem(int index);
    protected virtual void SetItem(int index, T item);
    private sealed virtual override bool System.Collections.Generic.ICollection<T>.get_IsReadOnly();
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
    private sealed virtual override bool System.Collections.ICollection.get_IsSynchronized();
    private sealed virtual override object System.Collections.ICollection.get_SyncRoot();
    private sealed virtual override void System.Collections.ICollection.CopyTo(Array array, int index);
    private sealed virtual override object System.Collections.IList.get_Item(int index);
    private sealed virtual override void System.Collections.IList.set_Item(int index, object value);
    private sealed virtual override bool System.Collections.IList.get_IsReadOnly();
    private sealed virtual override bool System.Collections.IList.get_IsFixedSize();
    private sealed virtual override int System.Collections.IList.Add(object value);
    private sealed virtual override bool System.Collections.IList.Contains(object value);
    private sealed virtual override int System.Collections.IList.IndexOf(object value);
    private sealed virtual override void System.Collections.IList.Insert(int index, object value);
    private sealed virtual override void System.Collections.IList.Remove(object value);
    private static void VerifyValueType(object value);
}
[DefaultMemberAttribute("Item")]
[ComVisibleAttribute("False")]
public abstract class System.Collections.Generic.SynchronizedKeyedCollection`2 : SynchronizedCollection`1<T> {
    private static int defaultThreshold;
    private IEqualityComparer`1<K> _comparer;
    private Dictionary`2<K, T> _dictionary;
    private int _keyCount;
    private int _threshold;
    public T Item { get; }
    protected IDictionary`2<K, T> Dictionary { get; }
    protected SynchronizedKeyedCollection`2(object syncRoot);
    protected SynchronizedKeyedCollection`2(object syncRoot, IEqualityComparer`1<K> comparer);
    protected SynchronizedKeyedCollection`2(object syncRoot, IEqualityComparer`1<K> comparer, int dictionaryCreationThreshold);
    public T get_Item(K key);
    protected IDictionary`2<K, T> get_Dictionary();
    private void AddKey(K key, T item);
    protected void ChangeItemKey(T item, K newKey);
    protected virtual void ClearItems();
    public bool Contains(K key);
    private bool ContainsItem(T item);
    private void CreateDictionary();
    protected abstract virtual K GetKeyForItem(T item);
    protected virtual void InsertItem(int index, T item);
    public bool Remove(K key);
    protected virtual void RemoveItem(int index);
    private void RemoveKey(K key);
    protected virtual void SetItem(int index, T item);
}
[DefaultMemberAttribute("Item")]
[ComVisibleAttribute("False")]
public class System.Collections.Generic.SynchronizedReadOnlyCollection`1 : object {
    private object _sync;
    [CompilerGeneratedAttribute]
private IList`1<T> <Items>k__BackingField;
    public int Count { get; }
    protected IList`1<T> Items { get; }
    public T Item { get; }
    private bool System.Collections.Generic.ICollection<T>.IsReadOnly { get; }
    private T System.Collections.Generic.IList<T>.Item { get; private set; }
    private bool System.Collections.ICollection.IsSynchronized { get; }
    private object System.Collections.ICollection.SyncRoot { get; }
    private bool System.Collections.IList.IsFixedSize { get; }
    private bool System.Collections.IList.IsReadOnly { get; }
    private object System.Collections.IList.Item { get; private set; }
    public SynchronizedReadOnlyCollection`1(object syncRoot);
    public SynchronizedReadOnlyCollection`1(object syncRoot, IEnumerable`1<T> list);
    public SynchronizedReadOnlyCollection`1(object syncRoot, T[] list);
    internal SynchronizedReadOnlyCollection`1(object syncRoot, List`1<T> list, bool makeCopy);
    public sealed virtual int get_Count();
    [CompilerGeneratedAttribute]
protected IList`1<T> get_Items();
    public T get_Item(int index);
    public sealed virtual bool Contains(T value);
    public sealed virtual void CopyTo(T[] array, int index);
    public sealed virtual IEnumerator`1<T> GetEnumerator();
    public sealed virtual int IndexOf(T value);
    private void ThrowReadOnly();
    private sealed virtual override bool System.Collections.Generic.ICollection<T>.get_IsReadOnly();
    private sealed virtual override T System.Collections.Generic.IList<T>.get_Item(int index);
    private sealed virtual override void System.Collections.Generic.IList<T>.set_Item(int index, T value);
    private sealed virtual override void System.Collections.Generic.ICollection<T>.Add(T value);
    private sealed virtual override void System.Collections.Generic.ICollection<T>.Clear();
    private sealed virtual override bool System.Collections.Generic.ICollection<T>.Remove(T value);
    private sealed virtual override void System.Collections.Generic.IList<T>.Insert(int index, T value);
    private sealed virtual override void System.Collections.Generic.IList<T>.RemoveAt(int index);
    private sealed virtual override bool System.Collections.ICollection.get_IsSynchronized();
    private sealed virtual override object System.Collections.ICollection.get_SyncRoot();
    private sealed virtual override void System.Collections.ICollection.CopyTo(Array array, int index);
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
    private sealed virtual override bool System.Collections.IList.get_IsFixedSize();
    private sealed virtual override bool System.Collections.IList.get_IsReadOnly();
    private sealed virtual override object System.Collections.IList.get_Item(int index);
    private sealed virtual override void System.Collections.IList.set_Item(int index, object value);
    private sealed virtual override int System.Collections.IList.Add(object value);
    private sealed virtual override void System.Collections.IList.Clear();
    private sealed virtual override bool System.Collections.IList.Contains(object value);
    private sealed virtual override int System.Collections.IList.IndexOf(object value);
    private sealed virtual override void System.Collections.IList.Insert(int index, object value);
    private sealed virtual override void System.Collections.IList.Remove(object value);
    private sealed virtual override void System.Collections.IList.RemoveAt(int index);
    private static void VerifyValueType(object value);
}
internal static class System.FxTrace : object {
    private static ExceptionTrace s_exceptionTrace;
    private static string baseEventSourceName;
    private static string EventSourceVersion;
    private static string s_eventSourceName;
    private static EtwDiagnosticTrace s_diagnosticTrace;
    private static object s_lockObject;
    public static ExceptionTrace Exception { get; }
    private static string EventSourceName { get; }
    public static EtwDiagnosticTrace Trace { get; }
    private static FxTrace();
    public static ExceptionTrace get_Exception();
    private static string get_EventSourceName();
    public static EtwDiagnosticTrace get_Trace();
    private static void EnsureEtwProviderInitialized();
    private static EtwDiagnosticTrace InitializeTracing();
}
internal abstract class System.IdentityModel.CanonicalFormWriter : object {
    internal static Encoding Utf8WithoutPreamble;
    private static CanonicalFormWriter();
    protected static void EncodeAndWrite(Stream stream, Byte[] workBuffer, string s);
    protected static void EncodeAndWrite(Stream stream, Byte[] workBuffer, Char[] chars);
    protected static void EncodeAndWrite(Stream stream, Byte[] workBuffer, Char[] chars, int count);
    private static void EncodeAndWrite(Stream stream, string s);
    private static void EncodeAndWrite(Stream stream, Char[] chars, int count);
}
[DataContractAttribute]
public class System.IdentityModel.Claims.Claim : object {
    private static Claim s_system;
    [DataMemberAttribute]
private string _claimType;
    [DataMemberAttribute]
private object _resource;
    [DataMemberAttribute]
private string _right;
    private IEqualityComparer`1<Claim> _comparer;
    public static IEqualityComparer`1<Claim> DefaultComparer { get; }
    public static Claim System { get; }
    public object Resource { get; }
    public string ClaimType { get; }
    public string Right { get; }
    private Claim(string claimType, object resource, string right, IEqualityComparer`1<Claim> comparer);
    public Claim(string claimType, object resource, string right);
    public static IEqualityComparer`1<Claim> get_DefaultComparer();
    public static Claim get_System();
    public object get_Resource();
    public string get_ClaimType();
    public string get_Right();
    public static Claim CreateDnsClaim(string dns);
    public static Claim CreateHashClaim(Byte[] hash);
    public static Claim CreateNameClaim(string name);
    public static Claim CreateRsaClaim(RSA rsa);
    public static Claim CreateSpnClaim(string spn);
    public static Claim CreateThumbprintClaim(Byte[] thumbprint);
    public static Claim CreateUpnClaim(string upn);
    public static Claim CreateUriClaim(Uri uri);
    public static Claim CreateWindowsSidClaim(SecurityIdentifier sid);
    public static Claim CreateX500DistinguishedNameClaim(X500DistinguishedName x500DistinguishedName);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    public virtual string ToString();
}
internal class System.IdentityModel.Claims.ClaimComparer : object {
    private static IEqualityComparer`1<Claim> s_defaultComparer;
    private static IEqualityComparer`1<Claim> s_hashComparer;
    private static IEqualityComparer`1<Claim> s_dnsComparer;
    private static IEqualityComparer`1<Claim> s_rsaComparer;
    private static IEqualityComparer`1<Claim> s_thumbprintComparer;
    private static IEqualityComparer`1<Claim> s_upnComparer;
    private static IEqualityComparer`1<Claim> s_x500DistinguishedNameComparer;
    private IEqualityComparer _resourceComparer;
    public static IEqualityComparer`1<Claim> Default { get; }
    public static IEqualityComparer`1<Claim> Dns { get; }
    public static IEqualityComparer`1<Claim> Hash { get; }
    public static IEqualityComparer`1<Claim> Rsa { get; }
    public static IEqualityComparer`1<Claim> Thumbprint { get; }
    public static IEqualityComparer`1<Claim> Upn { get; }
    public static IEqualityComparer`1<Claim> X500DistinguishedName { get; }
    private ClaimComparer(IEqualityComparer resourceComparer);
    public static IEqualityComparer`1<Claim> GetComparer(string claimType);
    public static IEqualityComparer`1<Claim> get_Default();
    public static IEqualityComparer`1<Claim> get_Dns();
    public static IEqualityComparer`1<Claim> get_Hash();
    public static IEqualityComparer`1<Claim> get_Rsa();
    public static IEqualityComparer`1<Claim> get_Thumbprint();
    public static IEqualityComparer`1<Claim> get_Upn();
    public static IEqualityComparer`1<Claim> get_X500DistinguishedName();
    public sealed virtual bool Equals(Claim claim1, Claim claim2);
    public sealed virtual int GetHashCode(Claim claim);
}
[DefaultMemberAttribute("Item")]
[DataContractAttribute]
public abstract class System.IdentityModel.Claims.ClaimSet : object {
    private static ClaimSet s_system;
    private static ClaimSet s_anonymous;
    public static ClaimSet System { get; }
    internal static ClaimSet Anonymous { get; }
    public Claim Item { get; }
    public int Count { get; }
    public ClaimSet Issuer { get; }
    public static ClaimSet get_System();
    internal static ClaimSet get_Anonymous();
    internal static bool SupportedRight(string right);
    public virtual bool ContainsClaim(Claim claim, IEqualityComparer`1<Claim> comparer);
    public virtual bool ContainsClaim(Claim claim);
    public abstract virtual Claim get_Item(int index);
    public abstract virtual int get_Count();
    public abstract virtual ClaimSet get_Issuer();
    public abstract virtual IEnumerable`1<Claim> FindClaims(string claimType, string right);
    public abstract virtual IEnumerator`1<Claim> GetEnumerator();
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
}
public static class System.IdentityModel.Claims.ClaimTypes : object {
    private static string claimTypeNamespace;
    private static string anonymous;
    private static string dns;
    private static string email;
    private static string hash;
    private static string name;
    private static string rsa;
    private static string sid;
    private static string denyOnlySid;
    private static string spn;
    private static string system;
    private static string thumbprint;
    private static string upn;
    private static string uri;
    private static string x500DistinguishedName;
    private static string givenname;
    private static string surname;
    private static string streetaddress;
    private static string locality;
    private static string stateorprovince;
    private static string postalcode;
    private static string country;
    private static string homephone;
    private static string otherphone;
    private static string mobilephone;
    private static string dateofbirth;
    private static string gender;
    private static string ppid;
    private static string webpage;
    private static string nameidentifier;
    private static string authentication;
    private static string authorizationdecision;
    public static string Anonymous { get; }
    public static string DenyOnlySid { get; }
    public static string Dns { get; }
    public static string Email { get; }
    public static string Hash { get; }
    public static string Name { get; }
    public static string Rsa { get; }
    public static string Sid { get; }
    public static string Spn { get; }
    public static string System { get; }
    public static string Thumbprint { get; }
    public static string Upn { get; }
    public static string Uri { get; }
    public static string X500DistinguishedName { get; }
    public static string NameIdentifier { get; }
    public static string Authentication { get; }
    public static string AuthorizationDecision { get; }
    public static string GivenName { get; }
    public static string Surname { get; }
    public static string StreetAddress { get; }
    public static string Locality { get; }
    public static string StateOrProvince { get; }
    public static string PostalCode { get; }
    public static string Country { get; }
    public static string HomePhone { get; }
    public static string OtherPhone { get; }
    public static string MobilePhone { get; }
    public static string DateOfBirth { get; }
    public static string Gender { get; }
    public static string PPID { get; }
    public static string Webpage { get; }
    public static string get_Anonymous();
    public static string get_DenyOnlySid();
    public static string get_Dns();
    public static string get_Email();
    public static string get_Hash();
    public static string get_Name();
    public static string get_Rsa();
    public static string get_Sid();
    public static string get_Spn();
    public static string get_System();
    public static string get_Thumbprint();
    public static string get_Upn();
    public static string get_Uri();
    public static string get_X500DistinguishedName();
    public static string get_NameIdentifier();
    public static string get_Authentication();
    public static string get_AuthorizationDecision();
    public static string get_GivenName();
    public static string get_Surname();
    public static string get_StreetAddress();
    public static string get_Locality();
    public static string get_StateOrProvince();
    public static string get_PostalCode();
    public static string get_Country();
    public static string get_HomePhone();
    public static string get_OtherPhone();
    public static string get_MobilePhone();
    public static string get_DateOfBirth();
    public static string get_Gender();
    public static string get_PPID();
    public static string get_Webpage();
}
[DefaultMemberAttribute("Item")]
[DataContractAttribute]
public class System.IdentityModel.Claims.DefaultClaimSet : ClaimSet {
    [DataMemberAttribute]
private ClaimSet _issuer;
    [DataMemberAttribute]
private IList`1<Claim> _claims;
    public Claim Item { get; }
    public int Count { get; }
    public ClaimSet Issuer { get; }
    public DefaultClaimSet(Claim[] claims);
    public DefaultClaimSet(IList`1<Claim> claims);
    public DefaultClaimSet(ClaimSet issuer, Claim[] claims);
    public DefaultClaimSet(ClaimSet issuer, IList`1<Claim> claims);
    public virtual Claim get_Item(int index);
    public virtual int get_Count();
    public virtual ClaimSet get_Issuer();
    public virtual bool ContainsClaim(Claim claim);
    [IteratorStateMachineAttribute("System.IdentityModel.Claims.DefaultClaimSet/<FindClaims>d__13")]
public virtual IEnumerable`1<Claim> FindClaims(string claimType, string right);
    public virtual IEnumerator`1<Claim> GetEnumerator();
    protected void Initialize(ClaimSet issuer, IList`1<Claim> claims);
    public virtual string ToString();
}
internal static class System.IdentityModel.Claims.Rights : object {
    private static string rightNamespace;
    private static string identity;
    private static string possessProperty;
    public static string Identity { get; }
    public static string PossessProperty { get; }
    public static string get_Identity();
    public static string get_PossessProperty();
}
[DefaultMemberAttribute("Item")]
public class System.IdentityModel.Claims.X509CertificateClaimSet : ClaimSet {
    private X509Certificate2 _certificate;
    private DateTime _expirationTime;
    private ClaimSet _issuer;
    private X509Identity _identity;
    private X509ChainElementCollection _elements;
    private IList`1<Claim> _claims;
    private int _index;
    private bool _disposed;
    public Claim Item { get; }
    public int Count { get; }
    private IIdentity System.IdentityModel.Policy.IIdentityInfo.Identity { get; }
    public DateTime ExpirationTime { get; }
    public ClaimSet Issuer { get; }
    public X509Certificate2 X509Certificate { get; }
    private IIdentity System.Security.Principal.IPrincipal.Identity { get; }
    public X509CertificateClaimSet(X509Certificate2 certificate);
    internal X509CertificateClaimSet(X509Certificate2 certificate, bool clone);
    private X509CertificateClaimSet(X509CertificateClaimSet from);
    private X509CertificateClaimSet(X509ChainElementCollection elements, int index);
    public virtual Claim get_Item(int index);
    public virtual int get_Count();
    private sealed virtual override IIdentity System.IdentityModel.Policy.IIdentityInfo.get_Identity();
    public DateTime get_ExpirationTime();
    public virtual ClaimSet get_Issuer();
    public X509Certificate2 get_X509Certificate();
    internal X509CertificateClaimSet Clone();
    public sealed virtual void Dispose();
    private IList`1<Claim> InitializeClaimsCore();
    private void EnsureClaims();
    private static bool SupportedClaimType(string claimType);
    [IteratorStateMachineAttribute("System.IdentityModel.Claims.X509CertificateClaimSet/<FindClaims>d__29")]
public virtual IEnumerable`1<Claim> FindClaims(string claimType, string right);
    private static String[] GetDnsFromExtensions(X509Certificate2 cert);
    public virtual IEnumerator`1<Claim> GetEnumerator();
    public virtual string ToString();
    private void ThrowIfDisposed();
    private sealed virtual override IIdentity System.Security.Principal.IPrincipal.get_Identity();
    private sealed virtual override bool System.Security.Principal.IPrincipal.IsInRole(string role);
}
internal class System.IdentityModel.Claims.X509Identity : GenericIdentity {
    private static string X509;
    private static string Thumbprint;
    private X500DistinguishedName _x500DistinguishedName;
    private X509Certificate2 _certificate;
    private string _name;
    private bool _disposed;
    private bool _disposable;
    public string Name { get; }
    public X509Identity(X509Certificate2 certificate);
    public X509Identity(X500DistinguishedName x500DistinguishedName);
    internal X509Identity(X509Certificate2 certificate, bool clone, bool disposable);
    public virtual string get_Name();
    private string GetName();
    public virtual ClaimsIdentity Clone();
    public sealed virtual void Dispose();
    private void ThrowIfDisposed();
}
internal static class System.IdentityModel.Claims.XsiConstants : object {
    public static string Namespace;
    public static string System;
}
internal static class System.IdentityModel.CryptoHelper : object {
    private static RandomNumberGenerator s_random;
    private static string SHAString;
    private static string SHA1String;
    private static string SHA256String;
    private static string SystemSecurityCryptographySha1String;
    private static Dictionary`2<string, Func`1<object>> s_algorithmDelegateDictionary;
    private static object s_algorithmDictionaryLock;
    internal static RandomNumberGenerator RandomNumberGenerator { get; }
    private static CryptoHelper();
    internal static bool IsSymmetricAlgorithm(string algorithm);
    internal static Byte[] UnwrapKey(Byte[] wrappingKey, Byte[] wrappedKey, string algorithm);
    internal static Byte[] WrapKey(Byte[] wrappingKey, Byte[] keyToBeWrapped, string algorithm);
    internal static Byte[] GenerateDerivedKey(Byte[] key, string algorithm, Byte[] label, Byte[] nonce, int derivedKeySize, int position);
    internal static int GetIVSize(string algorithm);
    internal static ICryptoTransform CreateDecryptor(Byte[] key, Byte[] iv, string algorithm);
    internal static ICryptoTransform CreateEncryptor(Byte[] key, Byte[] iv, string algorithm);
    internal static KeyedHashAlgorithm CreateKeyedHashAlgorithm(Byte[] key, string algorithm);
    internal static SymmetricAlgorithm GetSymmetricAlgorithm(Byte[] key, string algorithm);
    internal static bool IsAsymmetricAlgorithm(string algorithm);
    internal static bool IsSymmetricSupportedAlgorithm(string algorithm, int keySize);
    internal static void FillRandomBytes(Byte[] buffer);
    internal static RandomNumberGenerator get_RandomNumberGenerator();
    internal static HashAlgorithm CreateHashAlgorithm(string algorithm);
    private static object GetDefaultAlgorithm(string algorithm);
    internal static object GetAlgorithmFromConfig(string algorithm);
    internal static HashAlgorithm NewSha1HashAlgorithm();
    internal static HashAlgorithm NewSha256HashAlgorithm();
    internal static KeyedHashAlgorithm NewHmacSha1KeyedHashAlgorithm(Byte[] key);
}
internal class System.IdentityModel.DictionaryManager : object {
    private IXmlDictionary _parentDictionary;
    [CompilerGeneratedAttribute]
private SamlDictionary <SamlDictionary>k__BackingField;
    [CompilerGeneratedAttribute]
private XmlSignatureDictionary <XmlSignatureDictionary>k__BackingField;
    [CompilerGeneratedAttribute]
private UtilityDictionary <UtilityDictionary>k__BackingField;
    [CompilerGeneratedAttribute]
private ExclusiveC14NDictionary <ExclusiveC14NDictionary>k__BackingField;
    [CompilerGeneratedAttribute]
private SecurityAlgorithmDec2005Dictionary <SecurityAlgorithmDec2005Dictionary>k__BackingField;
    [CompilerGeneratedAttribute]
private SecurityAlgorithmDictionary <SecurityAlgorithmDictionary>k__BackingField;
    [CompilerGeneratedAttribute]
private SecurityJan2004Dictionary <SecurityJan2004Dictionary>k__BackingField;
    [CompilerGeneratedAttribute]
private SecurityXXX2005Dictionary <SecurityJanXXX2005Dictionary>k__BackingField;
    [CompilerGeneratedAttribute]
private SecureConversationDec2005Dictionary <SecureConversationDec2005Dictionary>k__BackingField;
    [CompilerGeneratedAttribute]
private SecureConversationFeb2005Dictionary <SecureConversationFeb2005Dictionary>k__BackingField;
    [CompilerGeneratedAttribute]
private TrustDec2005Dictionary <TrustDec2005Dictionary>k__BackingField;
    [CompilerGeneratedAttribute]
private TrustFeb2005Dictionary <TrustFeb2005Dictionary>k__BackingField;
    [CompilerGeneratedAttribute]
private XmlEncryptionDictionary <XmlEncryptionDictionary>k__BackingField;
    public SamlDictionary SamlDictionary { get; public set; }
    public XmlSignatureDictionary XmlSignatureDictionary { get; public set; }
    public UtilityDictionary UtilityDictionary { get; public set; }
    public ExclusiveC14NDictionary ExclusiveC14NDictionary { get; public set; }
    public SecurityAlgorithmDec2005Dictionary SecurityAlgorithmDec2005Dictionary { get; public set; }
    public SecurityAlgorithmDictionary SecurityAlgorithmDictionary { get; public set; }
    public SecurityJan2004Dictionary SecurityJan2004Dictionary { get; public set; }
    public SecurityXXX2005Dictionary SecurityJanXXX2005Dictionary { get; public set; }
    public SecureConversationDec2005Dictionary SecureConversationDec2005Dictionary { get; public set; }
    public SecureConversationFeb2005Dictionary SecureConversationFeb2005Dictionary { get; public set; }
    public TrustDec2005Dictionary TrustDec2005Dictionary { get; public set; }
    public TrustFeb2005Dictionary TrustFeb2005Dictionary { get; public set; }
    public XmlEncryptionDictionary XmlEncryptionDictionary { get; public set; }
    public IXmlDictionary ParentDictionary { get; public set; }
    public DictionaryManager(IXmlDictionary parentDictionary);
    [CompilerGeneratedAttribute]
public SamlDictionary get_SamlDictionary();
    [CompilerGeneratedAttribute]
public void set_SamlDictionary(SamlDictionary value);
    [CompilerGeneratedAttribute]
public XmlSignatureDictionary get_XmlSignatureDictionary();
    [CompilerGeneratedAttribute]
public void set_XmlSignatureDictionary(XmlSignatureDictionary value);
    [CompilerGeneratedAttribute]
public UtilityDictionary get_UtilityDictionary();
    [CompilerGeneratedAttribute]
public void set_UtilityDictionary(UtilityDictionary value);
    [CompilerGeneratedAttribute]
public ExclusiveC14NDictionary get_ExclusiveC14NDictionary();
    [CompilerGeneratedAttribute]
public void set_ExclusiveC14NDictionary(ExclusiveC14NDictionary value);
    [CompilerGeneratedAttribute]
public SecurityAlgorithmDec2005Dictionary get_SecurityAlgorithmDec2005Dictionary();
    [CompilerGeneratedAttribute]
public void set_SecurityAlgorithmDec2005Dictionary(SecurityAlgorithmDec2005Dictionary value);
    [CompilerGeneratedAttribute]
public SecurityAlgorithmDictionary get_SecurityAlgorithmDictionary();
    [CompilerGeneratedAttribute]
public void set_SecurityAlgorithmDictionary(SecurityAlgorithmDictionary value);
    [CompilerGeneratedAttribute]
public SecurityJan2004Dictionary get_SecurityJan2004Dictionary();
    [CompilerGeneratedAttribute]
public void set_SecurityJan2004Dictionary(SecurityJan2004Dictionary value);
    [CompilerGeneratedAttribute]
public SecurityXXX2005Dictionary get_SecurityJanXXX2005Dictionary();
    [CompilerGeneratedAttribute]
public void set_SecurityJanXXX2005Dictionary(SecurityXXX2005Dictionary value);
    [CompilerGeneratedAttribute]
public SecureConversationDec2005Dictionary get_SecureConversationDec2005Dictionary();
    [CompilerGeneratedAttribute]
public void set_SecureConversationDec2005Dictionary(SecureConversationDec2005Dictionary value);
    [CompilerGeneratedAttribute]
public SecureConversationFeb2005Dictionary get_SecureConversationFeb2005Dictionary();
    [CompilerGeneratedAttribute]
public void set_SecureConversationFeb2005Dictionary(SecureConversationFeb2005Dictionary value);
    [CompilerGeneratedAttribute]
public TrustDec2005Dictionary get_TrustDec2005Dictionary();
    [CompilerGeneratedAttribute]
public void set_TrustDec2005Dictionary(TrustDec2005Dictionary value);
    [CompilerGeneratedAttribute]
public TrustFeb2005Dictionary get_TrustFeb2005Dictionary();
    [CompilerGeneratedAttribute]
public void set_TrustFeb2005Dictionary(TrustFeb2005Dictionary value);
    [CompilerGeneratedAttribute]
public XmlEncryptionDictionary get_XmlEncryptionDictionary();
    [CompilerGeneratedAttribute]
public void set_XmlEncryptionDictionary(XmlEncryptionDictionary value);
    public IXmlDictionary get_ParentDictionary();
    public void set_ParentDictionary(IXmlDictionary value);
}
internal static class System.IdentityModel.EmptyReadOnlyCollection`1 : object {
    public static ReadOnlyCollection`1<T> Instance;
    private static EmptyReadOnlyCollection`1();
}
internal class System.IdentityModel.ExclusiveC14NDictionary : object {
    public XmlDictionaryString Namespace;
    public XmlDictionaryString PrefixList;
    public XmlDictionaryString InclusiveNamespaces;
    public XmlDictionaryString Prefix;
    public ExclusiveC14NDictionary(IdentityModelDictionary dictionary);
    public ExclusiveC14NDictionary(IXmlDictionary dictionary);
    private XmlDictionaryString LookupDictionaryString(IXmlDictionary dictionary, string value);
}
internal static class System.IdentityModel.ExclusiveC14NStrings : object {
    public static string Namespace;
    public static string PrefixList;
    public static string InclusiveNamespaces;
    public static string Prefix;
}
internal class System.IdentityModel.HashStream : Stream {
    private bool _disposed;
    private MemoryStream _logStream;
    public bool CanRead { get; }
    public bool CanWrite { get; }
    public bool CanSeek { get; }
    public long Length { get; }
    public long Position { get; public set; }
    public HashStream(HashAlgorithm hash);
    public virtual bool get_CanRead();
    public virtual bool get_CanWrite();
    public virtual bool get_CanSeek();
    public virtual long get_Length();
    public virtual long get_Position();
    public virtual void set_Position(long value);
    public virtual void Flush();
    public void FlushHash();
    public void FlushHash(MemoryStream preCanonicalBytes);
    public Byte[] FlushHashAndGetValue();
    public Byte[] FlushHashAndGetValue(MemoryStream preCanonicalBytes);
    public virtual int Read(Byte[] buffer, int offset, int count);
    public void Reset();
    public void Reset(HashAlgorithm hash);
    public virtual void Write(Byte[] buffer, int offset, int count);
    public virtual long Seek(long offset, SeekOrigin origin);
    public virtual void SetLength(long length);
    protected virtual void Dispose(bool disposing);
}
internal class System.IdentityModel.IdentityModelDictionary : object {
    public static IdentityModelDictionary Version1;
    private IdentityModelStrings _strings;
    private int _count;
    private XmlDictionaryString[] _dictionaryStrings;
    private Dictionary`2<string, int> _dictionary;
    private XmlDictionaryString[] _versionedDictionaryStrings;
    public static IdentityModelDictionary CurrentVersion { get; }
    public IdentityModelDictionary(IdentityModelStrings strings);
    private static IdentityModelDictionary();
    public static IdentityModelDictionary get_CurrentVersion();
    public XmlDictionaryString CreateString(string value, int key);
    public sealed virtual bool TryLookup(string key, XmlDictionaryString& value);
    public sealed virtual bool TryLookup(int key, XmlDictionaryString& value);
    public sealed virtual bool TryLookup(XmlDictionaryString key, XmlDictionaryString& value);
}
[DefaultMemberAttribute("Item")]
internal abstract class System.IdentityModel.IdentityModelStrings : object {
    public int Count { get; }
    public string Item { get; }
    public abstract virtual int get_Count();
    public abstract virtual string get_Item(int index);
}
[DefaultMemberAttribute("Item")]
internal class System.IdentityModel.IdentityModelStringsVersion1 : IdentityModelStrings {
    public static string String0;
    public static string String1;
    public static string String2;
    public static string String3;
    public static string String4;
    public static string String5;
    public static string String6;
    public static string String7;
    public static string String8;
    public static string String9;
    public static string String10;
    public static string String11;
    public static string String12;
    public static string String13;
    public static string String14;
    public static string String15;
    public static string String16;
    public static string String17;
    public static string String18;
    public static string String19;
    public static string String20;
    public static string String21;
    public static string String22;
    public static string String23;
    public static string String24;
    public static string String25;
    public static string String26;
    public static string String27;
    public static string String28;
    public static string String29;
    public static string String30;
    public static string String31;
    public static string String32;
    public static string String33;
    public static string String34;
    public static string String35;
    public static string String36;
    public static string String37;
    public static string String38;
    public static string String39;
    public static string String40;
    public static string String41;
    public static string String42;
    public static string String43;
    public static string String44;
    public static string String45;
    public static string String46;
    public static string String47;
    public static string String48;
    public static string String49;
    public static string String50;
    public static string String51;
    public static string String52;
    public static string String53;
    public static string String54;
    public static string String55;
    public static string String56;
    public static string String57;
    public static string String58;
    public static string String59;
    public static string String60;
    public static string String61;
    public static string String62;
    public static string String63;
    public static string String64;
    public static string String65;
    public static string String66;
    public static string String67;
    public static string String68;
    public static string String69;
    public static string String70;
    public static string String71;
    public static string String72;
    public static string String73;
    public static string String74;
    public static string String75;
    public static string String76;
    public static string String77;
    public static string String78;
    public static string String79;
    public static string String80;
    public static string String81;
    public static string String82;
    public static string String83;
    public static string String84;
    public static string String85;
    public static string String86;
    public static string String87;
    public static string String88;
    public static string String89;
    public static string String90;
    public static string String91;
    public static string String92;
    public static string String93;
    public static string String94;
    public static string String95;
    public static string String96;
    public static string String97;
    public static string String98;
    public static string String99;
    public static string String100;
    public static string String101;
    public static string String102;
    public static string String103;
    public static string String104;
    public static string String105;
    public static string String106;
    public static string String107;
    public static string String108;
    public static string String109;
    public static string String110;
    public static string String111;
    public static string String112;
    public static string String113;
    public static string String114;
    public static string String115;
    public static string String116;
    public static string String117;
    public static string String118;
    public static string String119;
    public static string String120;
    public static string String121;
    public static string String122;
    public static string String123;
    public static string String124;
    public static string String125;
    public static string String126;
    public static string String127;
    public static string String128;
    public static string String129;
    public static string String130;
    public static string String131;
    public static string String132;
    public static string String133;
    public static string String134;
    public static string String135;
    public static string String136;
    public static string String137;
    public static string String138;
    public static string String139;
    public static string String140;
    public static string String141;
    public static string String142;
    public static string String143;
    public static string String144;
    public static string String145;
    public static string String146;
    public static string String147;
    public static string String148;
    public static string String149;
    public static string String150;
    public static string String151;
    public static string String152;
    public static string String153;
    public static string String154;
    public static string String155;
    public static string String156;
    public static string String157;
    public static string String158;
    public static string String159;
    public static string String160;
    public static string String161;
    public static string String162;
    public static string String163;
    public static string String164;
    public static string String165;
    public static string String166;
    public static string String167;
    public static string String168;
    public static string String169;
    public static string String170;
    public static string String171;
    public static string String172;
    public static string String173;
    public static string String174;
    public static string String175;
    public static string String176;
    public static string String177;
    public static string String178;
    public static string String179;
    public static string String180;
    public static string String181;
    public static string String182;
    public static string String183;
    public static string String184;
    public static string String185;
    public static string String186;
    public static string String187;
    public static string String188;
    public static string String189;
    public static string String190;
    public static string String191;
    public static string String192;
    public static string String193;
    public static string String194;
    public static string String195;
    public static string String196;
    public static string String197;
    public static string String198;
    public static string String199;
    public static string String200;
    public static string String201;
    public static string String202;
    public static string String203;
    public static string String204;
    public static string String205;
    public static string String206;
    public static string String207;
    public static string String208;
    public static string String209;
    public static string String210;
    public static string String211;
    public static string String212;
    public static string String213;
    public static string String214;
    public static string String215;
    public static string String216;
    public static string String217;
    public static string String218;
    public static string String219;
    public static string String220;
    public static string String221;
    public static string String222;
    public static string String223;
    public static string String224;
    public static string String225;
    public static string String226;
    public static string String227;
    public static string String228;
    public static string String229;
    public static string String230;
    public static string String231;
    public static string String232;
    public static string String233;
    public static string String234;
    public static string String235;
    public static string String236;
    public static string String237;
    public static string String238;
    public static string String239;
    public static string String240;
    public static string String241;
    public static string String242;
    public static string String243;
    public static string String244;
    public static string String245;
    public static string String246;
    public static string String247;
    public static string String248;
    public static string String249;
    public static string String250;
    public static string String251;
    public static string String252;
    public static string String253;
    public static string String254;
    public static string String255;
    public static string String256;
    public static string String257;
    public static string String258;
    public static string String259;
    public static string String260;
    public static string String261;
    public static string String262;
    public static string String263;
    public static string String264;
    public static string String265;
    public static string String266;
    public static string String267;
    public static string String268;
    public static string String269;
    public static string String270;
    public static string String271;
    public static string String272;
    public static string String273;
    public static string String274;
    public static string String275;
    public static string String276;
    public static string String277;
    public static string String278;
    public int Count { get; }
    public string Item { get; }
    public virtual int get_Count();
    public virtual string get_Item(int index);
}
internal interface System.IdentityModel.IPrefixGenerator {
    public abstract virtual string GetPrefix(string namespaceUri, int depth, bool isForAttribute);
}
internal interface System.IdentityModel.ISecurityElement {
    public bool HasId { get; }
    public string Id { get; }
    public abstract virtual bool get_HasId();
    public abstract virtual string get_Id();
    public abstract virtual void WriteTo(XmlDictionaryWriter writer, DictionaryManager dictionaryManager);
}
internal interface System.IdentityModel.ISignatureValueSecurityElement {
    public abstract virtual Byte[] GetSignatureValue();
}
internal interface System.IdentityModel.IWrappedTokenKeyResolver {
    public SecurityToken ExpectedWrapper { get; public set; }
    public abstract virtual SecurityToken get_ExpectedWrapper();
    public abstract virtual void set_ExpectedWrapper(SecurityToken value);
    public abstract virtual bool CheckExternalWrapperMatch(SecurityKeyIdentifier keyIdentifier);
}
public abstract class System.IdentityModel.Policy.AuthorizationContext : object {
    public string Id { get; }
    public ReadOnlyCollection`1<ClaimSet> ClaimSets { get; }
    public DateTime ExpirationTime { get; }
    public IDictionary`2<string, object> Properties { get; }
    public abstract virtual string get_Id();
    public abstract virtual ReadOnlyCollection`1<ClaimSet> get_ClaimSets();
    public abstract virtual DateTime get_ExpirationTime();
    public abstract virtual IDictionary`2<string, object> get_Properties();
    public static AuthorizationContext CreateDefaultAuthorizationContext(IList`1<IAuthorizationPolicy> authorizationPolicies);
}
internal class System.IdentityModel.Policy.DefaultAuthorizationContext : AuthorizationContext {
    private static DefaultAuthorizationContext s_empty;
    private SecurityUniqueId _id;
    private ReadOnlyCollection`1<ClaimSet> _claimSets;
    private DateTime _expirationTime;
    private IDictionary`2<string, object> _properties;
    public static DefaultAuthorizationContext Empty { get; }
    public string Id { get; }
    public ReadOnlyCollection`1<ClaimSet> ClaimSets { get; }
    public DateTime ExpirationTime { get; }
    public IDictionary`2<string, object> Properties { get; }
    public DefaultAuthorizationContext(DefaultEvaluationContext evaluationContext);
    public static DefaultAuthorizationContext get_Empty();
    public virtual string get_Id();
    public virtual ReadOnlyCollection`1<ClaimSet> get_ClaimSets();
    public virtual DateTime get_ExpirationTime();
    public virtual IDictionary`2<string, object> get_Properties();
}
internal class System.IdentityModel.Policy.DefaultEvaluationContext : EvaluationContext {
    private List`1<ClaimSet> _claimSets;
    private Dictionary`2<string, object> _properties;
    private int _generation;
    private ReadOnlyCollection`1<ClaimSet> _readOnlyClaimSets;
    [CompilerGeneratedAttribute]
private DateTime <ExpirationTime>k__BackingField;
    public int Generation { get; }
    public ReadOnlyCollection`1<ClaimSet> ClaimSets { get; }
    public IDictionary`2<string, object> Properties { get; }
    public DateTime ExpirationTime { get; private set; }
    public virtual int get_Generation();
    public virtual ReadOnlyCollection`1<ClaimSet> get_ClaimSets();
    public virtual IDictionary`2<string, object> get_Properties();
    [CompilerGeneratedAttribute]
public DateTime get_ExpirationTime();
    [CompilerGeneratedAttribute]
private void set_ExpirationTime(DateTime value);
    public virtual void AddClaimSet(IAuthorizationPolicy policy, ClaimSet claimSet);
    public virtual void RecordExpirationTime(DateTime expirationTime);
}
public abstract class System.IdentityModel.Policy.EvaluationContext : object {
    public ReadOnlyCollection`1<ClaimSet> ClaimSets { get; }
    public IDictionary`2<string, object> Properties { get; }
    public int Generation { get; }
    public abstract virtual ReadOnlyCollection`1<ClaimSet> get_ClaimSets();
    public abstract virtual IDictionary`2<string, object> get_Properties();
    public abstract virtual int get_Generation();
    public abstract virtual void AddClaimSet(IAuthorizationPolicy policy, ClaimSet claimSet);
    public abstract virtual void RecordExpirationTime(DateTime expirationTime);
}
public interface System.IdentityModel.Policy.IAuthorizationComponent {
    public string Id { get; }
    public abstract virtual string get_Id();
}
public interface System.IdentityModel.Policy.IAuthorizationPolicy {
    public ClaimSet Issuer { get; }
    public abstract virtual ClaimSet get_Issuer();
    public abstract virtual bool Evaluate(EvaluationContext evaluationContext, Object& state);
}
internal interface System.IdentityModel.Policy.IIdentityInfo {
    public IIdentity Identity { get; }
    public abstract virtual IIdentity get_Identity();
}
internal class System.IdentityModel.Policy.UnconditionalPolicy : object {
    private SecurityUniqueId _id;
    private ClaimSet _issuance;
    private ReadOnlyCollection`1<ClaimSet> _issuances;
    private IIdentity _primaryIdentity;
    private bool _disposed;
    [CompilerGeneratedAttribute]
private ClaimSet <Issuer>k__BackingField;
    [CompilerGeneratedAttribute]
private DateTime <ExpirationTime>k__BackingField;
    public string Id { get; }
    public ClaimSet Issuer { get; private set; }
    internal IIdentity PrimaryIdentity { get; }
    internal ReadOnlyCollection`1<ClaimSet> Issuances { get; }
    public DateTime ExpirationTime { get; private set; }
    public UnconditionalPolicy(ClaimSet issuance);
    public UnconditionalPolicy(ClaimSet issuance, DateTime expirationTime);
    public UnconditionalPolicy(ReadOnlyCollection`1<ClaimSet> issuances, DateTime expirationTime);
    internal UnconditionalPolicy(IIdentity primaryIdentity, ClaimSet issuance);
    internal UnconditionalPolicy(IIdentity primaryIdentity, ClaimSet issuance, DateTime expirationTime);
    internal UnconditionalPolicy(IIdentity primaryIdentity, ReadOnlyCollection`1<ClaimSet> issuances, DateTime expirationTime);
    private UnconditionalPolicy(UnconditionalPolicy from);
    private void Initialize(ClaimSet issuer, ClaimSet issuance, ReadOnlyCollection`1<ClaimSet> issuances, DateTime expirationTime);
    public sealed virtual string get_Id();
    [CompilerGeneratedAttribute]
public sealed virtual ClaimSet get_Issuer();
    [CompilerGeneratedAttribute]
private void set_Issuer(ClaimSet value);
    internal IIdentity get_PrimaryIdentity();
    internal ReadOnlyCollection`1<ClaimSet> get_Issuances();
    [CompilerGeneratedAttribute]
public DateTime get_ExpirationTime();
    [CompilerGeneratedAttribute]
private void set_ExpirationTime(DateTime value);
    internal UnconditionalPolicy Clone();
    private sealed virtual override object System.ICloneable.Clone();
    public virtual void Dispose();
    private void ThrowIfDisposed();
    public virtual bool Evaluate(EvaluationContext evaluationContext, Object& state);
}
internal class System.IdentityModel.Psha1DerivedKeyGenerator : object {
    private Byte[] _key;
    public Psha1DerivedKeyGenerator(Byte[] key);
    public Byte[] GenerateDerivedKey(Byte[] label, Byte[] nonce, int derivedKeySize, int position);
}
internal class System.IdentityModel.SamlDictionary : object {
    public XmlDictionaryString Access;
    public XmlDictionaryString AccessDecision;
    public XmlDictionaryString Action;
    public XmlDictionaryString Advice;
    public XmlDictionaryString Assertion;
    public XmlDictionaryString AssertionId;
    public XmlDictionaryString AssertionIdReference;
    public XmlDictionaryString Attribute;
    public XmlDictionaryString AttributeName;
    public XmlDictionaryString AttributeNamespace;
    public XmlDictionaryString AttributeStatement;
    public XmlDictionaryString AttributeValue;
    public XmlDictionaryString Audience;
    public XmlDictionaryString AudienceRestrictionCondition;
    public XmlDictionaryString AuthenticationInstant;
    public XmlDictionaryString AuthenticationMethod;
    public XmlDictionaryString AuthenticationStatement;
    public XmlDictionaryString AuthorityBinding;
    public XmlDictionaryString AuthorityKind;
    public XmlDictionaryString AuthorizationDecisionStatement;
    public XmlDictionaryString Binding;
    public XmlDictionaryString Condition;
    public XmlDictionaryString Conditions;
    public XmlDictionaryString Decision;
    public XmlDictionaryString DoNotCacheCondition;
    public XmlDictionaryString Evidence;
    public XmlDictionaryString IssueInstant;
    public XmlDictionaryString Issuer;
    public XmlDictionaryString Location;
    public XmlDictionaryString MajorVersion;
    public XmlDictionaryString MinorVersion;
    public XmlDictionaryString Namespace;
    public XmlDictionaryString NameIdentifier;
    public XmlDictionaryString NameIdentifierFormat;
    public XmlDictionaryString NameIdentifierNameQualifier;
    public XmlDictionaryString ActionNamespaceAttribute;
    public XmlDictionaryString NotBefore;
    public XmlDictionaryString NotOnOrAfter;
    public XmlDictionaryString PreferredPrefix;
    public XmlDictionaryString Statement;
    public XmlDictionaryString Subject;
    public XmlDictionaryString SubjectConfirmation;
    public XmlDictionaryString SubjectConfirmationData;
    public XmlDictionaryString SubjectConfirmationMethod;
    public XmlDictionaryString HolderOfKey;
    public XmlDictionaryString SenderVouches;
    public XmlDictionaryString SubjectLocality;
    public XmlDictionaryString SubjectLocalityDNSAddress;
    public XmlDictionaryString SubjectLocalityIPAddress;
    public XmlDictionaryString SubjectStatement;
    public XmlDictionaryString UnspecifiedAuthenticationMethod;
    public XmlDictionaryString NamespaceAttributePrefix;
    public XmlDictionaryString Resource;
    public XmlDictionaryString UserName;
    public XmlDictionaryString UserNameNamespace;
    public XmlDictionaryString EmailName;
    public XmlDictionaryString EmailNamespace;
    public SamlDictionary(IdentityModelDictionary dictionary);
    public SamlDictionary(IXmlDictionary dictionary);
    private XmlDictionaryString LookupDictionaryString(IXmlDictionary dictionary, string value);
}
internal static class System.IdentityModel.SamlStrings : object {
    public static string Access;
    public static string AccessDecision;
    public static string Action;
    public static string Advice;
    public static string Assertion;
    public static string AssertionId;
    public static string AssertionIdReference;
    public static string Attribute;
    public static string AttributeName;
    public static string AttributeNamespace;
    public static string AttributeStatement;
    public static string AttributeValue;
    public static string Audience;
    public static string AudienceRestrictionCondition;
    public static string AuthenticationInstant;
    public static string AuthenticationMethod;
    public static string AuthenticationStatement;
    public static string AuthorityBinding;
    public static string AuthorityKind;
    public static string AuthorizationDecisionStatement;
    public static string Binding;
    public static string Condition;
    public static string Conditions;
    public static string Decision;
    public static string DoNotCacheCondition;
    public static string Evidence;
    public static string IssueInstant;
    public static string Issuer;
    public static string Location;
    public static string MajorVersion;
    public static string MinorVersion;
    public static string Namespace;
    public static string NameIdentifier;
    public static string NameIdentifierFormat;
    public static string NameIdentifierNameQualifier;
    public static string ActionNamespaceAttribute;
    public static string NotBefore;
    public static string NotOnOrAfter;
    public static string PreferredPrefix;
    public static string Statement;
    public static string Subject;
    public static string SubjectConfirmation;
    public static string SubjectConfirmationData;
    public static string SubjectConfirmationMethod;
    public static string HolderOfKey;
    public static string SenderVouches;
    public static string SubjectLocality;
    public static string SubjectLocalityDNSAddress;
    public static string SubjectLocalityIPAddress;
    public static string SubjectStatement;
    public static string UnspecifiedAuthenticationMethod;
    public static string NamespaceAttributePrefix;
    public static string Resource;
    public static string UserName;
    public static string UserNameNamespace;
    public static string EmailName;
    public static string EmailNamespace;
}
internal class System.IdentityModel.SecureConversationDec2005Dictionary : SecureConversationDictionary {
    public SecureConversationDec2005Dictionary(IdentityModelDictionary dictionary);
    public SecureConversationDec2005Dictionary(IXmlDictionary dictionary);
    private XmlDictionaryString LookupDictionaryString(IXmlDictionary dictionary, string value);
}
internal static class System.IdentityModel.SecureConversationDec2005Strings : object {
    public static string SecurityContextToken;
    public static string AlgorithmAttribute;
    public static string Generation;
    public static string Label;
    public static string Offset;
    public static string Properties;
    public static string Identifier;
    public static string Cookie;
    public static string RenewNeededFaultCode;
    public static string BadContextTokenFaultCode;
    public static string Prefix;
    public static string DerivedKeyTokenType;
    public static string SecurityContextTokenType;
    public static string SecurityContextTokenReferenceValueType;
    public static string RequestSecurityContextIssuance;
    public static string RequestSecurityContextIssuanceResponse;
    public static string RequestSecurityContextRenew;
    public static string RequestSecurityContextRenewResponse;
    public static string RequestSecurityContextClose;
    public static string RequestSecurityContextCloseResponse;
    public static string Namespace;
    public static string DerivedKeyToken;
    public static string Nonce;
    public static string Length;
    public static string Instance;
}
internal class System.IdentityModel.SecureConversationDictionary : object {
    public XmlDictionaryString Namespace;
    public XmlDictionaryString DerivedKeyToken;
    public XmlDictionaryString Nonce;
    public XmlDictionaryString Length;
    public XmlDictionaryString SecurityContextToken;
    public XmlDictionaryString AlgorithmAttribute;
    public XmlDictionaryString Generation;
    public XmlDictionaryString Label;
    public XmlDictionaryString Offset;
    public XmlDictionaryString Properties;
    public XmlDictionaryString Identifier;
    public XmlDictionaryString Cookie;
    public XmlDictionaryString RenewNeededFaultCode;
    public XmlDictionaryString BadContextTokenFaultCode;
    public XmlDictionaryString Prefix;
    public XmlDictionaryString DerivedKeyTokenType;
    public XmlDictionaryString SecurityContextTokenType;
    public XmlDictionaryString SecurityContextTokenReferenceValueType;
    public XmlDictionaryString RequestSecurityContextIssuance;
    public XmlDictionaryString RequestSecurityContextIssuanceResponse;
    public XmlDictionaryString RequestSecurityContextRenew;
    public XmlDictionaryString RequestSecurityContextRenewResponse;
    public XmlDictionaryString RequestSecurityContextClose;
    public XmlDictionaryString RequestSecurityContextCloseResponse;
    public XmlDictionaryString Instance;
    public SecureConversationDictionary(IdentityModelDictionary dictionary);
    public SecureConversationDictionary(IXmlDictionary dictionary);
    private XmlDictionaryString LookupDictionaryString(IXmlDictionary dictionary, string value);
}
internal class System.IdentityModel.SecureConversationFeb2005Dictionary : SecureConversationDictionary {
    public SecureConversationFeb2005Dictionary(IdentityModelDictionary dictionary);
    public SecureConversationFeb2005Dictionary(IXmlDictionary dictionary);
    private XmlDictionaryString LookupDictionaryString(IXmlDictionary dictionary, string value);
}
internal static class System.IdentityModel.SecureConversationFeb2005Strings : object {
    public static string Namespace;
    public static string DerivedKeyToken;
    public static string Nonce;
    public static string Length;
    public static string SecurityContextToken;
    public static string AlgorithmAttribute;
    public static string Generation;
    public static string Label;
    public static string Offset;
    public static string Properties;
    public static string Identifier;
    public static string Cookie;
    public static string RenewNeededFaultCode;
    public static string BadContextTokenFaultCode;
    public static string Prefix;
    public static string DerivedKeyTokenType;
    public static string SecurityContextTokenType;
    public static string SecurityContextTokenReferenceValueType;
    public static string RequestSecurityContextIssuance;
    public static string RequestSecurityContextIssuanceResponse;
    public static string RequestSecurityContextRenew;
    public static string RequestSecurityContextRenewResponse;
    public static string RequestSecurityContextClose;
    public static string RequestSecurityContextCloseResponse;
}
internal static class System.IdentityModel.SecureConversationStrings : object {
}
internal class System.IdentityModel.Security.WSTrust : SerializerEntries {
    private KeyInfoSerializer _securityTokenSerializer;
    [CompilerGeneratedAttribute]
private TrustDictionary <SerializerDictionary>k__BackingField;
    public TrustDictionary SerializerDictionary { get; }
    public WSTrust(KeyInfoSerializer securityTokenSerializer, TrustDictionary serializerDictionary);
    [CompilerGeneratedAttribute]
public TrustDictionary get_SerializerDictionary();
    public virtual void PopulateTokenEntries(IList`1<TokenEntry> tokenEntryList);
    public virtual void PopulateKeyIdentifierClauseEntries(IList`1<KeyIdentifierClauseEntry> keyIdentifierClauseEntries);
    protected static bool CheckElement(XmlElement element, string name, string ns, String& value);
}
internal class System.IdentityModel.SecurityAlgorithmDec2005Dictionary : object {
    public XmlDictionaryString Psha1KeyDerivationDec2005;
    public SecurityAlgorithmDec2005Dictionary(IdentityModelDictionary dictionary);
    public SecurityAlgorithmDec2005Dictionary(IXmlDictionary dictionary);
    private XmlDictionaryString LookupDictionaryString(IXmlDictionary dictionary, string value);
}
internal static class System.IdentityModel.SecurityAlgorithmDec2005Strings : object {
    public static string Psha1KeyDerivationDec2005;
}
internal class System.IdentityModel.SecurityAlgorithmDictionary : object {
    public XmlDictionaryString Aes128Encryption;
    public XmlDictionaryString Aes128KeyWrap;
    public XmlDictionaryString Aes192Encryption;
    public XmlDictionaryString Aes192KeyWrap;
    public XmlDictionaryString Aes256Encryption;
    public XmlDictionaryString Aes256KeyWrap;
    public XmlDictionaryString DesEncryption;
    public XmlDictionaryString DsaSha1Signature;
    public XmlDictionaryString ExclusiveC14n;
    public XmlDictionaryString ExclusiveC14nWithComments;
    public XmlDictionaryString HmacSha1Signature;
    public XmlDictionaryString HmacSha256Signature;
    public XmlDictionaryString Psha1KeyDerivation;
    public XmlDictionaryString Ripemd160Digest;
    public XmlDictionaryString RsaOaepKeyWrap;
    public XmlDictionaryString RsaSha1Signature;
    public XmlDictionaryString RsaSha256Signature;
    public XmlDictionaryString RsaV15KeyWrap;
    public XmlDictionaryString Sha1Digest;
    public XmlDictionaryString Sha256Digest;
    public XmlDictionaryString Sha512Digest;
    public XmlDictionaryString TripleDesEncryption;
    public XmlDictionaryString TripleDesKeyWrap;
    public XmlDictionaryString TlsSspiKeyWrap;
    public XmlDictionaryString WindowsSspiKeyWrap;
    public SecurityAlgorithmDictionary(IdentityModelDictionary dictionary);
    public SecurityAlgorithmDictionary(IXmlDictionary dictionary);
    private XmlDictionaryString LookupDictionaryString(IXmlDictionary dictionary, string value);
}
internal static class System.IdentityModel.SecurityAlgorithmStrings : object {
    public static string Aes128Encryption;
    public static string Aes128KeyWrap;
    public static string Aes192Encryption;
    public static string Aes192KeyWrap;
    public static string Aes256Encryption;
    public static string Aes256KeyWrap;
    public static string DesEncryption;
    public static string DsaSha1Signature;
    public static string ExclusiveC14n;
    public static string ExclusiveC14nWithComments;
    public static string HmacSha1Signature;
    public static string HmacSha256Signature;
    public static string Psha1KeyDerivation;
    public static string Ripemd160Digest;
    public static string RsaOaepKeyWrap;
    public static string RsaSha1Signature;
    public static string RsaSha256Signature;
    public static string RsaV15KeyWrap;
    public static string Sha1Digest;
    public static string Sha256Digest;
    public static string Sha512Digest;
    public static string TripleDesEncryption;
    public static string TripleDesKeyWrap;
    public static string TlsSspiKeyWrap;
    public static string WindowsSspiKeyWrap;
    public static string StrTransform;
}
internal class System.IdentityModel.SecurityJan2004Dictionary : object {
    public XmlDictionaryString Prefix;
    public XmlDictionaryString NonceElement;
    public XmlDictionaryString PasswordElement;
    public XmlDictionaryString PasswordTextName;
    public XmlDictionaryString UserNameElement;
    public XmlDictionaryString UserNameTokenElement;
    public XmlDictionaryString BinarySecurityToken;
    public XmlDictionaryString EncodingType;
    public XmlDictionaryString Reference;
    public XmlDictionaryString URI;
    public XmlDictionaryString KeyIdentifier;
    public XmlDictionaryString EncodingTypeValueBase64Binary;
    public XmlDictionaryString EncodingTypeValueHexBinary;
    public XmlDictionaryString EncodingTypeValueText;
    public XmlDictionaryString X509SKIValueType;
    public XmlDictionaryString KerberosTokenTypeGSS;
    public XmlDictionaryString KerberosTokenType1510;
    public XmlDictionaryString SamlAssertionIdValueType;
    public XmlDictionaryString SamlAssertion;
    public XmlDictionaryString SamlUri;
    public XmlDictionaryString RelAssertionValueType;
    public XmlDictionaryString FailedAuthenticationFaultCode;
    public XmlDictionaryString InvalidSecurityTokenFaultCode;
    public XmlDictionaryString InvalidSecurityFaultCode;
    public XmlDictionaryString SecurityTokenReference;
    public XmlDictionaryString Namespace;
    public XmlDictionaryString Security;
    public XmlDictionaryString ValueType;
    public XmlDictionaryString TypeAttribute;
    public XmlDictionaryString KerberosHashValueType;
    public SecurityJan2004Dictionary(IdentityModelDictionary dictionary);
    public SecurityJan2004Dictionary(IXmlDictionary dictionary);
    private XmlDictionaryString LookupDictionaryString(IXmlDictionary dictionary, string value);
}
internal static class System.IdentityModel.SecurityJan2004Strings : object {
    public static string Prefix;
    public static string NonceElement;
    public static string PasswordElement;
    public static string PasswordTextName;
    public static string UserNameElement;
    public static string UserNameTokenElement;
    public static string BinarySecurityToken;
    public static string EncodingType;
    public static string Reference;
    public static string URI;
    public static string KeyIdentifier;
    public static string EncodingTypeValueBase64Binary;
    public static string EncodingTypeValueHexBinary;
    public static string EncodingTypeValueText;
    public static string X509SKIValueType;
    public static string KerberosTokenTypeGSS;
    public static string KerberosTokenType1510;
    public static string SamlAssertionIdValueType;
    public static string SamlAssertion;
    public static string SamlUri;
    public static string RelAssertionValueType;
    public static string FailedAuthenticationFaultCode;
    public static string InvalidSecurityTokenFaultCode;
    public static string InvalidSecurityFaultCode;
    public static string SecurityTokenReference;
    public static string Namespace;
    public static string Security;
    public static string ValueType;
    public static string TypeAttribute;
    public static string KerberosHashValueType;
    public static string SecurityProfileNamespace;
    public static string X509TokenProfileNamespace;
    public static string UPTokenProfileNamespace;
    public static string SamlTokenProfileNamespace;
    public static string KerberosTokenProfileNamespace;
    public static string UPTokenType;
    public static string X509TokenType;
    public static string UPTokenPasswordTextValue;
}
public class System.IdentityModel.SecurityMessageSerializationException : Exception {
    public SecurityMessageSerializationException(string message);
    public SecurityMessageSerializationException(string message, Exception innerException);
    protected SecurityMessageSerializationException(SerializationInfo info, StreamingContext context);
}
internal class System.IdentityModel.SecurityUniqueId : object {
    private static long s_nextId;
    private static string s_commonPrefix;
    private long _id;
    private string _prefix;
    private string _val;
    public string Value { get; }
    private SecurityUniqueId(string prefix, long id);
    private static SecurityUniqueId();
    public static SecurityUniqueId Create();
    public static SecurityUniqueId Create(string prefix);
    public string get_Value();
}
internal static class System.IdentityModel.SecurityUtils : object {
    public static string AuthTypeNTLM;
    public static string AuthTypeNegotiate;
    public static string AuthTypeKerberos;
    public static string AuthTypeAnonymous;
    public static string AuthTypeCertMap;
    public static string AuthTypeBasic;
    public static string Identities;
    private static IIdentity s_anonymousIdentity;
    internal static IIdentity AnonymousIdentity { get; }
    public static DateTime MinUtcDateTime { get; }
    public static DateTime MaxUtcDateTime { get; }
    internal static IIdentity get_AnonymousIdentity();
    public static DateTime get_MinUtcDateTime();
    public static DateTime get_MaxUtcDateTime();
    internal static IIdentity CreateIdentity(string name, string authenticationType);
    internal static IIdentity CreateIdentity(string name);
    internal static Byte[] CloneBuffer(Byte[] buffer);
    internal static Byte[] CloneBuffer(Byte[] buffer, int offset, int len);
    internal static bool MatchesBuffer(Byte[] src, Byte[] dst);
    internal static bool MatchesBuffer(Byte[] src, int srcOffset, Byte[] dst, int dstOffset);
    internal static ReadOnlyCollection`1<IAuthorizationPolicy> CreateAuthorizationPolicies(ClaimSet claimSet, DateTime expirationTime);
    internal static AuthorizationContext CreateDefaultAuthorizationContext(IList`1<IAuthorizationPolicy> authorizationPolicies);
    internal static string ClaimSetToString(ClaimSet claimSet);
    internal static string GetCertificateId(X509Certificate2 certificate);
    internal static void AppendCertificateIdentityName(StringBuilder str, X509Certificate2 certificate);
    internal static bool TryCreateX509CertificateFromRawData(Byte[] rawData, X509Certificate2& certificate);
    internal static ReadOnlyCollection`1<IAuthorizationPolicy> CloneAuthorizationPoliciesIfNecessary(ReadOnlyCollection`1<IAuthorizationPolicy> authorizationPolicies);
    public static void DisposeAuthorizationPoliciesIfNecessary(ReadOnlyCollection`1<IAuthorizationPolicy> authorizationPolicies);
    internal static void ResetAllCertificates(X509Certificate2Collection certificates);
    internal static void ResetCertificate(X509Certificate2 certificate);
    public static void DisposeIfNecessary(IDisposable obj);
}
internal class System.IdentityModel.SecurityXXX2005Dictionary : object {
    public XmlDictionaryString Prefix;
    public XmlDictionaryString SignatureConfirmation;
    public XmlDictionaryString ValueAttribute;
    public XmlDictionaryString TokenTypeAttribute;
    public XmlDictionaryString ThumbprintSha1ValueType;
    public XmlDictionaryString EncryptedKeyTokenType;
    public XmlDictionaryString EncryptedKeyHashValueType;
    public XmlDictionaryString SamlTokenType;
    public XmlDictionaryString Saml20TokenType;
    public XmlDictionaryString Saml11AssertionValueType;
    public XmlDictionaryString EncryptedHeader;
    public XmlDictionaryString Namespace;
    public SecurityXXX2005Dictionary(IdentityModelDictionary dictionary);
    public SecurityXXX2005Dictionary(IXmlDictionary dictionary);
    private XmlDictionaryString LookupDictionaryString(IXmlDictionary dictionary, string value);
}
internal static class System.IdentityModel.SecurityXXX2005Strings : object {
    public static string Prefix;
    public static string SignatureConfirmation;
    public static string ValueAttribute;
    public static string TokenTypeAttribute;
    public static string ThumbprintSha1ValueType;
    public static string EncryptedKeyTokenType;
    public static string EncryptedKeyHashValueType;
    public static string SamlTokenType;
    public static string Saml20TokenType;
    public static string Saml11AssertionValueType;
    public static string EncryptedHeader;
    public static string Namespace;
    public static string SecurityProfileNamespace;
    public static string SamlTokenProfileNamespace;
    public static string X509TokenProfileNamespace;
}
internal static class System.IdentityModel.Selectors.EmptySecurityTokenResolver : object {
    [CompilerGeneratedAttribute]
private static SecurityTokenResolver <Instance>k__BackingField;
    public static SecurityTokenResolver Instance { get; }
    private static EmptySecurityTokenResolver();
    [CompilerGeneratedAttribute]
public static SecurityTokenResolver get_Instance();
}
public class System.IdentityModel.Selectors.KerberosSecurityTokenProvider : SecurityTokenProvider {
    private NetworkCredential _networkCredential;
    [CompilerGeneratedAttribute]
private string <ServicePrincipalName>k__BackingField;
    [CompilerGeneratedAttribute]
private TokenImpersonationLevel <TokenImpersonationLevel>k__BackingField;
    public string ServicePrincipalName { get; }
    public TokenImpersonationLevel TokenImpersonationLevel { get; }
    public NetworkCredential NetworkCredential { get; }
    public KerberosSecurityTokenProvider(string servicePrincipalName);
    public KerberosSecurityTokenProvider(string servicePrincipalName, TokenImpersonationLevel tokenImpersonationLevel);
    public KerberosSecurityTokenProvider(string servicePrincipalName, TokenImpersonationLevel tokenImpersonationLevel, NetworkCredential networkCredential);
    [CompilerGeneratedAttribute]
public string get_ServicePrincipalName();
    [CompilerGeneratedAttribute]
public TokenImpersonationLevel get_TokenImpersonationLevel();
    public NetworkCredential get_NetworkCredential();
    internal SecurityToken GetToken(TimeSpan timeout, ChannelBinding channelbinding);
    protected virtual SecurityToken GetTokenCore(TimeSpan timeout);
    internal virtual Task`1<SecurityToken> GetTokenCoreInternalAsync(TimeSpan timeout);
}
public abstract class System.IdentityModel.Selectors.SecurityTokenAuthenticator : object {
    public bool CanValidateToken(SecurityToken token);
    public ReadOnlyCollection`1<IAuthorizationPolicy> ValidateToken(SecurityToken token);
    protected abstract virtual bool CanValidateTokenCore(SecurityToken token);
    protected abstract virtual ReadOnlyCollection`1<IAuthorizationPolicy> ValidateTokenCore(SecurityToken token);
}
public abstract class System.IdentityModel.Selectors.SecurityTokenManager : object {
    public abstract virtual SecurityTokenProvider CreateSecurityTokenProvider(SecurityTokenRequirement tokenRequirement);
    public abstract virtual SecurityTokenSerializer CreateSecurityTokenSerializer(SecurityTokenVersion version);
    public abstract virtual SecurityTokenAuthenticator CreateSecurityTokenAuthenticator(SecurityTokenRequirement tokenRequirement, SecurityTokenResolver& outOfBandTokenResolver);
}
public abstract class System.IdentityModel.Selectors.SecurityTokenProvider : object {
    public bool SupportsTokenRenewal { get; }
    public bool SupportsTokenCancellation { get; }
    public virtual bool get_SupportsTokenRenewal();
    public virtual bool get_SupportsTokenCancellation();
    public SecurityToken GetToken(TimeSpan timeout);
    public IAsyncResult BeginGetToken(TimeSpan timeout, AsyncCallback callback, object state);
    public SecurityToken EndGetToken(IAsyncResult result);
    [AsyncStateMachineAttribute("System.IdentityModel.Selectors.SecurityTokenProvider/<GetTokenAsync>d__8")]
public Task`1<SecurityToken> GetTokenAsync(TimeSpan timeout);
    protected abstract virtual SecurityToken GetTokenCore(TimeSpan timeout);
    protected virtual IAsyncResult BeginGetTokenCore(TimeSpan timeout, AsyncCallback callback, object state);
    protected virtual SecurityToken EndGetTokenCore(IAsyncResult result);
    protected virtual Task`1<SecurityToken> GetTokenCoreAsync(TimeSpan timeout);
    internal virtual Task`1<SecurityToken> GetTokenCoreInternalAsync(TimeSpan timeout);
    public SecurityToken RenewToken(TimeSpan timeout, SecurityToken tokenToBeRenewed);
    public IAsyncResult BeginRenewToken(TimeSpan timeout, SecurityToken tokenToBeRenewed, AsyncCallback callback, object state);
    public SecurityToken EndRenewToken(IAsyncResult result);
    [AsyncStateMachineAttribute("System.IdentityModel.Selectors.SecurityTokenProvider/<RenewTokenAsync>d__17")]
public Task`1<SecurityToken> RenewTokenAsync(TimeSpan timeout, SecurityToken tokenToBeRenewed);
    protected virtual SecurityToken RenewTokenCore(TimeSpan timeout, SecurityToken tokenToBeRenewed);
    protected virtual IAsyncResult BeginRenewTokenCore(TimeSpan timeout, SecurityToken tokenToBeRenewed, AsyncCallback callback, object state);
    protected virtual SecurityToken EndRenewTokenCore(IAsyncResult result);
    protected virtual Task`1<SecurityToken> RenewTokenCoreAsync(TimeSpan timeout, SecurityToken tokenToBeRenewed);
    internal virtual Task`1<SecurityToken> RenewTokenCoreInternalAsync(TimeSpan timeout, SecurityToken tokenToBeRenewed);
    public void CancelToken(TimeSpan timeout, SecurityToken token);
    public IAsyncResult BeginCancelToken(TimeSpan timeout, SecurityToken token, AsyncCallback callback, object state);
    public void EndCancelToken(IAsyncResult result);
    [AsyncStateMachineAttribute("System.IdentityModel.Selectors.SecurityTokenProvider/<CancelTokenAsync>d__26")]
public Task CancelTokenAsync(TimeSpan timeout, SecurityToken token);
    protected virtual void CancelTokenCore(TimeSpan timeout, SecurityToken token);
    protected virtual IAsyncResult BeginCancelTokenCore(TimeSpan timeout, SecurityToken token, AsyncCallback callback, object state);
    protected virtual void EndCancelTokenCore(IAsyncResult result);
    protected virtual Task CancelTokenCoreAsync(TimeSpan timeout, SecurityToken token);
    internal virtual Task CancelTokenCoreInternalAsync(TimeSpan timeout, SecurityToken token);
}
public class System.IdentityModel.Selectors.SecurityTokenRequirement : object {
    private static string Namespace;
    private static string tokenTypeProperty;
    private static string keyUsageProperty;
    private static string keyTypeProperty;
    private static string keySizeProperty;
    private static string requireCryptographicTokenProperty;
    private static string peerAuthenticationMode;
    private static string isOptionalTokenProperty;
    private static bool defaultRequireCryptographicToken;
    private static SecurityKeyUsage defaultKeyUsage;
    private static SecurityKeyType defaultKeyType;
    private static int defaultKeySize;
    private static bool defaultIsOptionalToken;
    private Dictionary`2<string, object> _properties;
    public static string TokenTypeProperty { get; }
    public static string KeyUsageProperty { get; }
    public static string KeyTypeProperty { get; }
    public static string KeySizeProperty { get; }
    public static string RequireCryptographicTokenProperty { get; }
    public static string PeerAuthenticationMode { get; }
    public static string IsOptionalTokenProperty { get; }
    public string TokenType { get; public set; }
    internal bool IsOptionalToken { get; internal set; }
    public bool RequireCryptographicToken { get; public set; }
    public SecurityKeyUsage KeyUsage { get; public set; }
    public SecurityKeyType KeyType { get; public set; }
    public int KeySize { get; public set; }
    public IDictionary`2<string, object> Properties { get; }
    public static string get_TokenTypeProperty();
    public static string get_KeyUsageProperty();
    public static string get_KeyTypeProperty();
    public static string get_KeySizeProperty();
    public static string get_RequireCryptographicTokenProperty();
    public static string get_PeerAuthenticationMode();
    public static string get_IsOptionalTokenProperty();
    public string get_TokenType();
    public void set_TokenType(string value);
    internal bool get_IsOptionalToken();
    internal void set_IsOptionalToken(bool value);
    public bool get_RequireCryptographicToken();
    public void set_RequireCryptographicToken(bool value);
    public SecurityKeyUsage get_KeyUsage();
    public void set_KeyUsage(SecurityKeyUsage value);
    public SecurityKeyType get_KeyType();
    public void set_KeyType(SecurityKeyType value);
    public int get_KeySize();
    public void set_KeySize(int value);
    public IDictionary`2<string, object> get_Properties();
    private void Initialize();
    public TValue GetProperty(string propertyName);
    public bool TryGetProperty(string propertyName, TValue& result);
}
public abstract class System.IdentityModel.Selectors.SecurityTokenResolver : object {
    public SecurityToken ResolveToken(SecurityKeyIdentifier keyIdentifier);
    public bool TryResolveToken(SecurityKeyIdentifier keyIdentifier, SecurityToken& token);
    public SecurityToken ResolveToken(SecurityKeyIdentifierClause keyIdentifierClause);
    public bool TryResolveToken(SecurityKeyIdentifierClause keyIdentifierClause, SecurityToken& token);
    public SecurityKey ResolveSecurityKey(SecurityKeyIdentifierClause keyIdentifierClause);
    public bool TryResolveSecurityKey(SecurityKeyIdentifierClause keyIdentifierClause, SecurityKey& key);
    protected abstract virtual bool TryResolveTokenCore(SecurityKeyIdentifier keyIdentifier, SecurityToken& token);
    protected abstract virtual bool TryResolveTokenCore(SecurityKeyIdentifierClause keyIdentifierClause, SecurityToken& token);
    protected abstract virtual bool TryResolveSecurityKeyCore(SecurityKeyIdentifierClause keyIdentifierClause, SecurityKey& key);
    public static SecurityTokenResolver CreateDefaultSecurityTokenResolver(ReadOnlyCollection`1<SecurityToken> tokens, bool canMatchLocalId);
}
public abstract class System.IdentityModel.Selectors.SecurityTokenSerializer : object {
    public bool CanReadToken(XmlReader reader);
    public bool CanWriteToken(SecurityToken token);
    public bool CanReadKeyIdentifier(XmlReader reader);
    public bool CanWriteKeyIdentifier(SecurityKeyIdentifier keyIdentifier);
    public bool CanReadKeyIdentifierClause(XmlReader reader);
    public bool CanWriteKeyIdentifierClause(SecurityKeyIdentifierClause keyIdentifierClause);
    public SecurityToken ReadToken(XmlReader reader, SecurityTokenResolver tokenResolver);
    public void WriteToken(XmlWriter writer, SecurityToken token);
    public SecurityKeyIdentifier ReadKeyIdentifier(XmlReader reader);
    public void WriteKeyIdentifier(XmlWriter writer, SecurityKeyIdentifier keyIdentifier);
    public SecurityKeyIdentifierClause ReadKeyIdentifierClause(XmlReader reader);
    public void WriteKeyIdentifierClause(XmlWriter writer, SecurityKeyIdentifierClause keyIdentifierClause);
    protected abstract virtual bool CanReadTokenCore(XmlReader reader);
    protected abstract virtual bool CanWriteTokenCore(SecurityToken token);
    protected abstract virtual bool CanReadKeyIdentifierCore(XmlReader reader);
    protected abstract virtual bool CanWriteKeyIdentifierCore(SecurityKeyIdentifier keyIdentifier);
    protected abstract virtual bool CanReadKeyIdentifierClauseCore(XmlReader reader);
    protected abstract virtual bool CanWriteKeyIdentifierClauseCore(SecurityKeyIdentifierClause keyIdentifierClause);
    protected abstract virtual SecurityToken ReadTokenCore(XmlReader reader, SecurityTokenResolver tokenResolver);
    protected abstract virtual void WriteTokenCore(XmlWriter writer, SecurityToken token);
    protected abstract virtual SecurityKeyIdentifier ReadKeyIdentifierCore(XmlReader reader);
    protected abstract virtual void WriteKeyIdentifierCore(XmlWriter writer, SecurityKeyIdentifier keyIdentifier);
    protected abstract virtual SecurityKeyIdentifierClause ReadKeyIdentifierClauseCore(XmlReader reader);
    protected abstract virtual void WriteKeyIdentifierClauseCore(XmlWriter writer, SecurityKeyIdentifierClause keyIdentifierClause);
}
public abstract class System.IdentityModel.Selectors.SecurityTokenVersion : object {
    public abstract virtual ReadOnlyCollection`1<string> GetSecuritySpecifications();
}
public class System.IdentityModel.Selectors.UserNameSecurityTokenProvider : SecurityTokenProvider {
    private UserNameSecurityToken _userNameToken;
    public UserNameSecurityTokenProvider(string userName, string password);
    protected virtual SecurityToken GetTokenCore(TimeSpan timeout);
    internal virtual Task`1<SecurityToken> GetTokenCoreInternalAsync(TimeSpan timeout);
}
internal class System.IdentityModel.Selectors.X509CertificateChain : object {
    public static UInt32 DefaultChainPolicyOID;
}
public abstract class System.IdentityModel.Selectors.X509CertificateValidator : object {
    private static X509CertificateValidator s_peerTrust;
    private static X509CertificateValidator s_chainTrust;
    private static X509CertificateValidator s_peerOrChainTrust;
    private static X509CertificateValidator s_none;
    public static X509CertificateValidator None { get; }
    public static X509CertificateValidator PeerTrust { get; }
    public static X509CertificateValidator ChainTrust { get; }
    public static X509CertificateValidator PeerOrChainTrust { get; }
    public static X509CertificateValidator get_None();
    public static X509CertificateValidator get_PeerTrust();
    public static X509CertificateValidator get_ChainTrust();
    public static X509CertificateValidator get_PeerOrChainTrust();
    public static X509CertificateValidator CreateChainTrustValidator(bool useMachineContext, X509ChainPolicy chainPolicy);
    public static X509CertificateValidator CreatePeerOrChainTrustValidator(bool useMachineContext, X509ChainPolicy chainPolicy);
    public abstract virtual void Validate(X509Certificate2 certificate);
}
public class System.IdentityModel.Selectors.X509SecurityTokenAuthenticator : SecurityTokenAuthenticator {
    private X509CertificateValidator _validator;
    private bool _cloneHandle;
    public X509SecurityTokenAuthenticator(X509CertificateValidator validator);
    protected virtual bool CanValidateTokenCore(SecurityToken token);
    protected virtual ReadOnlyCollection`1<IAuthorizationPolicy> ValidateTokenCore(SecurityToken token);
}
public class System.IdentityModel.Selectors.X509SecurityTokenProvider : SecurityTokenProvider {
    private X509Certificate2 _certificate;
    private bool _clone;
    public X509SecurityTokenProvider(X509Certificate2 certificate);
    internal X509SecurityTokenProvider(X509Certificate2 certificate, bool clone);
    protected virtual SecurityToken GetTokenCore(TimeSpan timeout);
    internal virtual Task`1<SecurityToken> GetTokenCoreInternalAsync(TimeSpan timeout);
    public sealed virtual void Dispose();
}
internal class System.IdentityModel.SignatureResourcePool : object {
    private HashStream _hashStream;
    private HashAlgorithm _hashAlgorithm;
    private HashAlgorithm TakeHashAlgorithm(string algorithm);
    private HashStream TakeHashStream(HashAlgorithm hash);
    public HashStream TakeHashStream(string algorithm);
}
internal class System.IdentityModel.SimpleAuthorizationContext : AuthorizationContext {
    private SecurityUniqueId _id;
    private UnconditionalPolicy _policy;
    private IDictionary`2<string, object> _properties;
    public string Id { get; }
    public ReadOnlyCollection`1<ClaimSet> ClaimSets { get; }
    public DateTime ExpirationTime { get; }
    public IDictionary`2<string, object> Properties { get; }
    public SimpleAuthorizationContext(IList`1<IAuthorizationPolicy> authorizationPolicies);
    public virtual string get_Id();
    public virtual ReadOnlyCollection`1<ClaimSet> get_ClaimSets();
    public virtual DateTime get_ExpirationTime();
    public virtual IDictionary`2<string, object> get_Properties();
}
public class System.IdentityModel.Tokens.AggregateTokenResolver : SecurityTokenResolver {
    private List`1<SecurityTokenResolver> _tokenResolvers;
    public ReadOnlyCollection`1<SecurityTokenResolver> TokenResolvers { get; }
    public AggregateTokenResolver(IEnumerable`1<SecurityTokenResolver> tokenResolvers);
    public ReadOnlyCollection`1<SecurityTokenResolver> get_TokenResolvers();
    protected virtual bool TryResolveSecurityKeyCore(SecurityKeyIdentifierClause keyIdentifierClause, SecurityKey& key);
    protected virtual bool TryResolveTokenCore(SecurityKeyIdentifier keyIdentifier, SecurityToken& token);
    protected virtual bool TryResolveTokenCore(SecurityKeyIdentifierClause keyIdentifierClause, SecurityToken& token);
    private void AddNonEmptyResolvers(IEnumerable`1<SecurityTokenResolver> resolvers);
}
public abstract class System.IdentityModel.Tokens.AsymmetricSecurityKey : SecurityKey {
    public abstract virtual AsymmetricAlgorithm GetAsymmetricAlgorithm(string algorithm, bool privateKey);
    public abstract virtual HashAlgorithm GetHashAlgorithmForSignature(string algorithm);
    public abstract virtual AsymmetricSignatureDeformatter GetSignatureDeformatter(string algorithm);
    public abstract virtual AsymmetricSignatureFormatter GetSignatureFormatter(string algorithm);
    public abstract virtual bool HasPrivateKey();
}
public abstract class System.IdentityModel.Tokens.BinaryKeyIdentifierClause : SecurityKeyIdentifierClause {
    private Byte[] _identificationData;
    protected BinaryKeyIdentifierClause(string clauseType, Byte[] identificationData, bool cloneBuffer);
    protected BinaryKeyIdentifierClause(string clauseType, Byte[] identificationData, bool cloneBuffer, Byte[] derivationNonce, int derivationLength);
    public Byte[] GetBuffer();
    protected Byte[] GetRawBuffer();
    public virtual bool Matches(SecurityKeyIdentifierClause keyIdentifierClause);
    public bool Matches(Byte[] data);
    public bool Matches(Byte[] data, int offset);
    internal string ToBase64String();
    internal string ToHexString();
}
public class System.IdentityModel.Tokens.EncryptedKeyIdentifierClause : BinaryKeyIdentifierClause {
    private string _encryptionMethod;
    [CompilerGeneratedAttribute]
private string <CarriedKeyName>k__BackingField;
    [CompilerGeneratedAttribute]
private SecurityKeyIdentifier <EncryptingKeyIdentifier>k__BackingField;
    public string CarriedKeyName { get; }
    public SecurityKeyIdentifier EncryptingKeyIdentifier { get; }
    public string EncryptionMethod { get; }
    public EncryptedKeyIdentifierClause(Byte[] encryptedKey, string encryptionMethod);
    public EncryptedKeyIdentifierClause(Byte[] encryptedKey, string encryptionMethod, SecurityKeyIdentifier encryptingKeyIdentifier);
    public EncryptedKeyIdentifierClause(Byte[] encryptedKey, string encryptionMethod, SecurityKeyIdentifier encryptingKeyIdentifier, string carriedKeyName);
    public EncryptedKeyIdentifierClause(Byte[] encryptedKey, string encryptionMethod, SecurityKeyIdentifier encryptingKeyIdentifier, string carriedKeyName, Byte[] derivationNonce, int derivationLength);
    internal EncryptedKeyIdentifierClause(Byte[] encryptedKey, string encryptionMethod, SecurityKeyIdentifier encryptingKeyIdentifier, string carriedKeyName, bool cloneBuffer, Byte[] derivationNonce, int derivationLength);
    [CompilerGeneratedAttribute]
public string get_CarriedKeyName();
    [CompilerGeneratedAttribute]
public SecurityKeyIdentifier get_EncryptingKeyIdentifier();
    public string get_EncryptionMethod();
    public virtual bool Matches(SecurityKeyIdentifierClause keyIdentifierClause);
    public bool Matches(Byte[] encryptedKey, string encryptionMethod, string carriedKeyName);
    public Byte[] GetEncryptedKey();
    public virtual string ToString();
}
public class System.IdentityModel.Tokens.GenericXmlSecurityKeyIdentifierClause : SecurityKeyIdentifierClause {
    [CompilerGeneratedAttribute]
private XmlElement <ReferenceXml>k__BackingField;
    public XmlElement ReferenceXml { get; }
    public GenericXmlSecurityKeyIdentifierClause(XmlElement referenceXml);
    public GenericXmlSecurityKeyIdentifierClause(XmlElement referenceXml, Byte[] derivationNonce, int derivationLength);
    [CompilerGeneratedAttribute]
public XmlElement get_ReferenceXml();
    public virtual bool Matches(SecurityKeyIdentifierClause keyIdentifierClause);
    private bool Matches(XmlElement xmlElement);
    private bool CompareNodes(XmlNode originalNode, XmlNode newNode);
}
public class System.IdentityModel.Tokens.GenericXmlSecurityToken : SecurityToken {
    private static int SupportedPersistanceVersion;
    private string _id;
    private DateTime _effectiveTime;
    private DateTime _expirationTime;
    [CompilerGeneratedAttribute]
private SecurityKeyIdentifierClause <InternalTokenReference>k__BackingField;
    [CompilerGeneratedAttribute]
private SecurityKeyIdentifierClause <ExternalTokenReference>k__BackingField;
    [CompilerGeneratedAttribute]
private XmlElement <TokenXml>k__BackingField;
    [CompilerGeneratedAttribute]
private SecurityToken <ProofToken>k__BackingField;
    [CompilerGeneratedAttribute]
private ReadOnlyCollection`1<IAuthorizationPolicy> <AuthorizationPolicies>k__BackingField;
    public string Id { get; }
    public DateTime ValidFrom { get; }
    public DateTime ValidTo { get; }
    public SecurityKeyIdentifierClause InternalTokenReference { get; }
    public SecurityKeyIdentifierClause ExternalTokenReference { get; }
    public XmlElement TokenXml { get; }
    public SecurityToken ProofToken { get; }
    public ReadOnlyCollection`1<IAuthorizationPolicy> AuthorizationPolicies { get; }
    public ReadOnlyCollection`1<SecurityKey> SecurityKeys { get; }
    public GenericXmlSecurityToken(XmlElement tokenXml, SecurityToken proofToken, DateTime effectiveTime, DateTime expirationTime, SecurityKeyIdentifierClause internalTokenReference, SecurityKeyIdentifierClause externalTokenReference, ReadOnlyCollection`1<IAuthorizationPolicy> authorizationPolicies);
    public virtual string get_Id();
    public virtual DateTime get_ValidFrom();
    public virtual DateTime get_ValidTo();
    [CompilerGeneratedAttribute]
public SecurityKeyIdentifierClause get_InternalTokenReference();
    [CompilerGeneratedAttribute]
public SecurityKeyIdentifierClause get_ExternalTokenReference();
    [CompilerGeneratedAttribute]
public XmlElement get_TokenXml();
    [CompilerGeneratedAttribute]
public SecurityToken get_ProofToken();
    [CompilerGeneratedAttribute]
public ReadOnlyCollection`1<IAuthorizationPolicy> get_AuthorizationPolicies();
    public virtual ReadOnlyCollection`1<SecurityKey> get_SecurityKeys();
    public virtual string ToString();
    private static string GetId(XmlElement tokenXml);
    public virtual bool CanCreateKeyIdentifierClause();
    public virtual T CreateKeyIdentifierClause();
    public virtual bool MatchesKeyIdentifierClause(SecurityKeyIdentifierClause keyIdentifierClause);
}
internal class System.IdentityModel.Tokens.InMemorySymmetricSecurityKey : SymmetricSecurityKey {
    private int _keySize;
    private Byte[] _symmetricKey;
    public int KeySize { get; }
    public InMemorySymmetricSecurityKey(Byte[] symmetricKey);
    public InMemorySymmetricSecurityKey(Byte[] symmetricKey, bool cloneBuffer);
    public virtual int get_KeySize();
    public virtual Byte[] DecryptKey(string algorithm, Byte[] keyData);
    public virtual Byte[] EncryptKey(string algorithm, Byte[] keyData);
    public virtual Byte[] GenerateDerivedKey(string algorithm, Byte[] label, Byte[] nonce, int derivedKeyLength, int offset);
    public virtual ICryptoTransform GetDecryptionTransform(string algorithm, Byte[] iv);
    public virtual ICryptoTransform GetEncryptionTransform(string algorithm, Byte[] iv);
    public virtual int GetIVSize(string algorithm);
    public virtual KeyedHashAlgorithm GetKeyedHashAlgorithm(string algorithm);
    public virtual SymmetricAlgorithm GetSymmetricAlgorithm(string algorithm);
    public virtual Byte[] GetSymmetricKey();
    public virtual bool IsAsymmetricAlgorithm(string algorithm);
    public virtual bool IsSupportedAlgorithm(string algorithm);
    public virtual bool IsSymmetricAlgorithm(string algorithm);
}
public class System.IdentityModel.Tokens.KerberosRequestorSecurityToken : SecurityToken {
    private string _id;
    private DateTime _effectiveTime;
    private DateTime _expirationTime;
    [CompilerGeneratedAttribute]
private string <ServicePrincipalName>k__BackingField;
    public string Id { get; }
    public ReadOnlyCollection`1<SecurityKey> SecurityKeys { get; }
    public DateTime ValidFrom { get; }
    public DateTime ValidTo { get; }
    public string ServicePrincipalName { get; }
    internal KerberosRequestorSecurityToken(string servicePrincipalName, TokenImpersonationLevel tokenImpersonationLevel, NetworkCredential networkCredential, string id);
    public virtual string get_Id();
    public virtual ReadOnlyCollection`1<SecurityKey> get_SecurityKeys();
    public virtual DateTime get_ValidFrom();
    public virtual DateTime get_ValidTo();
    [CompilerGeneratedAttribute]
public string get_ServicePrincipalName();
}
internal class System.IdentityModel.Tokens.KeyInfoSerializer : SecurityTokenSerializer {
    private List`1<KeyIdentifierEntry> _keyIdentifierEntries;
    private List`1<KeyIdentifierClauseEntry> _keyIdentifierClauseEntries;
    private List`1<SerializerEntries> _serializerEntries;
    private List`1<TokenEntry> _tokenEntries;
    private SecurityTokenSerializer _innerSecurityTokenSerializer;
    [CompilerGeneratedAttribute]
private DictionaryManager <DictionaryManager>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <EmitBspRequiredAttributes>k__BackingField;
    public DictionaryManager DictionaryManager { get; }
    public bool EmitBspRequiredAttributes { get; }
    public SecurityTokenSerializer InnerSecurityTokenSerializer { get; public set; }
    public KeyInfoSerializer(bool emitBspRequiredAttributes);
    public KeyInfoSerializer(bool emitBspRequiredAttributes, DictionaryManager dictionaryManager, TrustDictionary trustDictionary, SecurityTokenSerializer innerSecurityTokenSerializer);
    public KeyInfoSerializer(bool emitBspRequiredAttributes, DictionaryManager dictionaryManager, TrustDictionary trustDictionary, SecurityTokenSerializer innerSecurityTokenSerializer, Func`2<KeyInfoSerializer, IEnumerable`1<SerializerEntries>> additionalEntries);
    [CompilerGeneratedAttribute]
public DictionaryManager get_DictionaryManager();
    [CompilerGeneratedAttribute]
public bool get_EmitBspRequiredAttributes();
    public SecurityTokenSerializer get_InnerSecurityTokenSerializer();
    public void set_InnerSecurityTokenSerializer(SecurityTokenSerializer value);
    protected virtual bool CanReadTokenCore(XmlReader reader);
    protected virtual SecurityToken ReadTokenCore(XmlReader reader, SecurityTokenResolver tokenResolver);
    protected virtual bool CanWriteTokenCore(SecurityToken token);
    protected virtual void WriteTokenCore(XmlWriter writer, SecurityToken token);
    protected virtual bool CanReadKeyIdentifierCore(XmlReader reader);
    protected virtual SecurityKeyIdentifier ReadKeyIdentifierCore(XmlReader reader);
    protected virtual bool CanWriteKeyIdentifierCore(SecurityKeyIdentifier keyIdentifier);
    protected virtual void WriteKeyIdentifierCore(XmlWriter writer, SecurityKeyIdentifier keyIdentifier);
    protected virtual bool CanReadKeyIdentifierClauseCore(XmlReader reader);
    protected virtual SecurityKeyIdentifierClause ReadKeyIdentifierClauseCore(XmlReader reader);
    protected virtual bool CanWriteKeyIdentifierClauseCore(SecurityKeyIdentifierClause keyIdentifierClause);
    protected virtual void WriteKeyIdentifierClauseCore(XmlWriter writer, SecurityKeyIdentifierClause keyIdentifierClause);
    internal void PopulateStrEntries(IList`1<StrEntry> strEntries);
    private bool ShouldWrapException(Exception e);
    internal Type[] GetTokenTypes(string tokenTypeUri);
    protected internal virtual string GetTokenTypeUri(Type tokenType);
}
public class System.IdentityModel.Tokens.LocalIdKeyIdentifierClause : SecurityKeyIdentifierClause {
    private Type[] _ownerTypes;
    [CompilerGeneratedAttribute]
private string <LocalId>k__BackingField;
    public string LocalId { get; }
    public Type OwnerType { get; }
    public LocalIdKeyIdentifierClause(string localId);
    public LocalIdKeyIdentifierClause(string localId, Type ownerType);
    public LocalIdKeyIdentifierClause(string localId, Byte[] derivationNonce, int derivationLength, Type ownerType);
    internal LocalIdKeyIdentifierClause(string localId, Type[] ownerTypes);
    internal LocalIdKeyIdentifierClause(string localId, Byte[] derivationNonce, int derivationLength, Type[] ownerTypes);
    [CompilerGeneratedAttribute]
public string get_LocalId();
    public Type get_OwnerType();
    public virtual bool Matches(SecurityKeyIdentifierClause keyIdentifierClause);
    public bool Matches(string localId, Type ownerType);
    public virtual string ToString();
}
public class System.IdentityModel.Tokens.SamlSerializer : object {
}
public static class System.IdentityModel.Tokens.SecurityAlgorithms : object {
    public static string Aes128Encryption;
    public static string Aes128KeyWrap;
    public static string Aes192Encryption;
    public static string Aes192KeyWrap;
    public static string Aes256Encryption;
    public static string Aes256KeyWrap;
    public static string DesEncryption;
    public static string DsaSha1Signature;
    public static string ExclusiveC14n;
    public static string ExclusiveC14nWithComments;
    public static string HmacSha1Signature;
    public static string HmacSha256Signature;
    public static string Psha1KeyDerivation;
    public static string Psha1KeyDerivationDec2005;
    public static string Ripemd160Digest;
    public static string RsaOaepKeyWrap;
    public static string RsaSha1Signature;
    public static string RsaV15KeyWrap;
    public static string RsaSha256Signature;
    public static string Sha1Digest;
    public static string Sha256Digest;
    public static string Sha512Digest;
    public static string TripleDesEncryption;
    public static string TripleDesKeyWrap;
}
public abstract class System.IdentityModel.Tokens.SecurityKey : object {
    public int KeySize { get; }
    public abstract virtual int get_KeySize();
    public abstract virtual Byte[] DecryptKey(string algorithm, Byte[] keyData);
    public abstract virtual Byte[] EncryptKey(string algorithm, Byte[] keyData);
    public abstract virtual bool IsAsymmetricAlgorithm(string algorithm);
    public abstract virtual bool IsSupportedAlgorithm(string algorithm);
    public abstract virtual bool IsSymmetricAlgorithm(string algorithm);
}
[DefaultMemberAttribute("Item")]
public class System.IdentityModel.Tokens.SecurityKeyIdentifier : object {
    private static int InitialSize;
    private List`1<SecurityKeyIdentifierClause> _clauses;
    [CompilerGeneratedAttribute]
private bool <IsReadOnly>k__BackingField;
    public SecurityKeyIdentifierClause Item { get; }
    public bool CanCreateKey { get; }
    public int Count { get; }
    public bool IsReadOnly { get; private set; }
    public SecurityKeyIdentifier(SecurityKeyIdentifierClause[] clauses);
    public SecurityKeyIdentifierClause get_Item(int index);
    public bool get_CanCreateKey();
    public int get_Count();
    [CompilerGeneratedAttribute]
public bool get_IsReadOnly();
    [CompilerGeneratedAttribute]
private void set_IsReadOnly(bool value);
    public void Add(SecurityKeyIdentifierClause clause);
    public SecurityKey CreateKey();
    public TClause Find();
    public sealed virtual IEnumerator`1<SecurityKeyIdentifierClause> GetEnumerator();
    public void MakeReadOnly();
    public virtual string ToString();
    public bool TryFind(TClause& clause);
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
}
public abstract class System.IdentityModel.Tokens.SecurityKeyIdentifierClause : object {
    private Byte[] _derivationNonce;
    private string _id;
    [CompilerGeneratedAttribute]
private string <ClauseType>k__BackingField;
    [CompilerGeneratedAttribute]
private int <DerivationLength>k__BackingField;
    public bool CanCreateKey { get; }
    public string ClauseType { get; }
    public string Id { get; public set; }
    public int DerivationLength { get; }
    protected SecurityKeyIdentifierClause(string clauseType);
    protected SecurityKeyIdentifierClause(string clauseType, Byte[] nonce, int length);
    public virtual bool get_CanCreateKey();
    [CompilerGeneratedAttribute]
public string get_ClauseType();
    public string get_Id();
    public void set_Id(string value);
    public virtual SecurityKey CreateKey();
    public virtual bool Matches(SecurityKeyIdentifierClause keyIdentifierClause);
    public Byte[] GetDerivationNonce();
    [CompilerGeneratedAttribute]
public int get_DerivationLength();
}
public enum System.IdentityModel.Tokens.SecurityKeyType : Enum {
    public int value__;
    public static SecurityKeyType SymmetricKey;
    public static SecurityKeyType AsymmetricKey;
    public static SecurityKeyType BearerKey;
}
internal static class System.IdentityModel.Tokens.SecurityKeyTypeHelper : object {
    internal static bool IsDefined(SecurityKeyType value);
    internal static void Validate(SecurityKeyType value);
}
public enum System.IdentityModel.Tokens.SecurityKeyUsage : Enum {
    public int value__;
    public static SecurityKeyUsage Exchange;
    public static SecurityKeyUsage Signature;
}
internal static class System.IdentityModel.Tokens.SecurityKeyUsageHelper : object {
    internal static bool IsDefined(SecurityKeyUsage value);
    internal static void Validate(SecurityKeyUsage value);
}
public abstract class System.IdentityModel.Tokens.SecurityToken : object {
    public string Id { get; }
    public ReadOnlyCollection`1<SecurityKey> SecurityKeys { get; }
    public DateTime ValidFrom { get; }
    public DateTime ValidTo { get; }
    public abstract virtual string get_Id();
    public abstract virtual ReadOnlyCollection`1<SecurityKey> get_SecurityKeys();
    public abstract virtual DateTime get_ValidFrom();
    public abstract virtual DateTime get_ValidTo();
    public virtual bool CanCreateKeyIdentifierClause();
    public virtual T CreateKeyIdentifierClause();
    public virtual bool MatchesKeyIdentifierClause(SecurityKeyIdentifierClause keyIdentifierClause);
    public virtual SecurityKey ResolveKeyIdentifierClause(SecurityKeyIdentifierClause keyIdentifierClause);
    private bool CanCreateLocalKeyIdentifierClause();
}
public class System.IdentityModel.Tokens.SecurityTokenException : Exception {
    public SecurityTokenException(string message);
    public SecurityTokenException(string message, Exception innerException);
    protected SecurityTokenException(SerializationInfo info, StreamingContext context);
}
public static class System.IdentityModel.Tokens.SecurityTokenTypes : object {
    private static string Namespace;
    private static string userName;
    private static string x509Certificate;
    private static string kerberos;
    private static string saml;
    private static string rsa;
    internal static string SamlTokenProfile11;
    internal static string Saml2TokenProfile11;
    internal static string OasisWssSamlTokenProfile11;
    internal static string OasisWssSaml2TokenProfile11;
    public static string UserName { get; }
    public static string X509Certificate { get; }
    public static string Kerberos { get; }
    public static string Saml { get; }
    public static string Rsa { get; }
    public static string get_UserName();
    public static string get_X509Certificate();
    public static string get_Kerberos();
    public static string get_Saml();
    public static string get_Rsa();
}
public class System.IdentityModel.Tokens.SecurityTokenValidationException : SecurityTokenException {
    public SecurityTokenValidationException(string message);
    public SecurityTokenValidationException(string message, Exception innerException);
    protected SecurityTokenValidationException(SerializationInfo info, StreamingContext context);
}
public abstract class System.IdentityModel.Tokens.SymmetricSecurityKey : SecurityKey {
    public abstract virtual Byte[] GenerateDerivedKey(string algorithm, Byte[] label, Byte[] nonce, int derivedKeyLength, int offset);
    public abstract virtual ICryptoTransform GetDecryptionTransform(string algorithm, Byte[] iv);
    public abstract virtual ICryptoTransform GetEncryptionTransform(string algorithm, Byte[] iv);
    public abstract virtual int GetIVSize(string algorithm);
    public abstract virtual KeyedHashAlgorithm GetKeyedHashAlgorithm(string algorithm);
    public abstract virtual SymmetricAlgorithm GetSymmetricAlgorithm(string algorithm);
    public abstract virtual Byte[] GetSymmetricKey();
}
public class System.IdentityModel.Tokens.UserNameSecurityToken : SecurityToken {
    private string _id;
    private string _userName;
    private DateTime _effectiveTime;
    [CompilerGeneratedAttribute]
private string <Password>k__BackingField;
    public string Id { get; }
    public ReadOnlyCollection`1<SecurityKey> SecurityKeys { get; }
    public DateTime ValidFrom { get; }
    public DateTime ValidTo { get; }
    public string UserName { get; }
    public string Password { get; }
    public UserNameSecurityToken(string userName, string password);
    public UserNameSecurityToken(string userName, string password, string id);
    public virtual string get_Id();
    public virtual ReadOnlyCollection`1<SecurityKey> get_SecurityKeys();
    public virtual DateTime get_ValidFrom();
    public virtual DateTime get_ValidTo();
    public string get_UserName();
    [CompilerGeneratedAttribute]
public string get_Password();
}
internal class System.IdentityModel.Tokens.WSSecurityJan2004 : SerializerEntries {
    [CompilerGeneratedAttribute]
private KeyInfoSerializer <SecurityTokenSerializer>k__BackingField;
    public KeyInfoSerializer SecurityTokenSerializer { get; }
    public WSSecurityJan2004(KeyInfoSerializer securityTokenSerializer);
    [CompilerGeneratedAttribute]
public KeyInfoSerializer get_SecurityTokenSerializer();
    public virtual void PopulateKeyIdentifierClauseEntries(IList`1<KeyIdentifierClauseEntry> clauseEntries);
    protected void PopulateJan2004StrEntries(IList`1<StrEntry> strEntries);
    public virtual void PopulateStrEntries(IList`1<StrEntry> strEntries);
    protected void PopulateJan2004TokenEntries(IList`1<TokenEntry> tokenEntryList);
    public virtual void PopulateTokenEntries(IList`1<TokenEntry> tokenEntryList);
}
internal class System.IdentityModel.Tokens.WSSecurityXXX2005 : WSSecurityJan2004 {
    public WSSecurityXXX2005(KeyInfoSerializer securityTokenSerializer);
    public virtual void PopulateStrEntries(IList`1<StrEntry> strEntries);
    public virtual void PopulateTokenEntries(IList`1<TokenEntry> tokenEntryList);
    public virtual void PopulateKeyIdentifierClauseEntries(IList`1<KeyIdentifierClauseEntry> clauseEntries);
}
public class System.IdentityModel.Tokens.X509AsymmetricSecurityKey : AsymmetricSecurityKey {
    private X509Certificate2 _certificate;
    private AsymmetricAlgorithm _privateKey;
    private bool _privateKeyAvailabilityDetermined;
    private AsymmetricAlgorithm _publicKey;
    private bool _publicKeyAvailabilityDetermined;
    [CompilerGeneratedAttribute]
private object <ThisLock>k__BackingField;
    public int KeySize { get; }
    private AsymmetricAlgorithm PrivateKey { get; }
    private AsymmetricAlgorithm PublicKey { get; }
    private object ThisLock { get; }
    public X509AsymmetricSecurityKey(X509Certificate2 certificate);
    public virtual int get_KeySize();
    private AsymmetricAlgorithm get_PrivateKey();
    private AsymmetricAlgorithm get_PublicKey();
    [CompilerGeneratedAttribute]
private object get_ThisLock();
    public virtual Byte[] DecryptKey(string algorithm, Byte[] keyData);
    public virtual Byte[] EncryptKey(string algorithm, Byte[] keyData);
    public virtual AsymmetricAlgorithm GetAsymmetricAlgorithm(string algorithm, bool privateKey);
    public virtual HashAlgorithm GetHashAlgorithmForSignature(string algorithm);
    public virtual AsymmetricSignatureDeformatter GetSignatureDeformatter(string algorithm);
    public virtual AsymmetricSignatureFormatter GetSignatureFormatter(string algorithm);
    public virtual bool HasPrivateKey();
    public virtual bool IsAsymmetricAlgorithm(string algorithm);
    public virtual bool IsSupportedAlgorithm(string algorithm);
    public virtual bool IsSymmetricAlgorithm(string algorithm);
}
public class System.IdentityModel.Tokens.X509IssuerSerialKeyIdentifierClause : SecurityKeyIdentifierClause {
    private string _issuerSerialNumber;
    [CompilerGeneratedAttribute]
private string <IssuerName>k__BackingField;
    public string IssuerName { get; }
    public string IssuerSerialNumber { get; }
    public X509IssuerSerialKeyIdentifierClause(string issuerName, string issuerSerialNumber);
    public X509IssuerSerialKeyIdentifierClause(X509Certificate2 certificate);
    [CompilerGeneratedAttribute]
public string get_IssuerName();
    public string get_IssuerSerialNumber();
    public virtual bool Matches(SecurityKeyIdentifierClause keyIdentifierClause);
    public bool Matches(X509Certificate2 certificate);
    public bool Matches(string issuerName, string issuerSerialNumber);
    public virtual string ToString();
}
public class System.IdentityModel.Tokens.X509RawDataKeyIdentifierClause : BinaryKeyIdentifierClause {
    private X509Certificate2 _certificate;
    private X509AsymmetricSecurityKey _key;
    public bool CanCreateKey { get; }
    public X509RawDataKeyIdentifierClause(X509Certificate2 certificate);
    public X509RawDataKeyIdentifierClause(Byte[] certificateRawData);
    internal X509RawDataKeyIdentifierClause(Byte[] certificateRawData, bool cloneBuffer);
    public virtual bool get_CanCreateKey();
    public virtual SecurityKey CreateKey();
    private static Byte[] GetRawData(X509Certificate certificate);
    public Byte[] GetX509RawData();
    public bool Matches(X509Certificate2 certificate);
    public virtual string ToString();
}
public class System.IdentityModel.Tokens.X509SecurityToken : SecurityToken {
    private string _id;
    private X509Certificate2 _certificate;
    private ReadOnlyCollection`1<SecurityKey> _securityKeys;
    private DateTime _effectiveTime;
    private DateTime _expirationTime;
    private bool _disposed;
    private bool _disposable;
    public string Id { get; }
    public ReadOnlyCollection`1<SecurityKey> SecurityKeys { get; }
    public DateTime ValidFrom { get; }
    public DateTime ValidTo { get; }
    public X509Certificate2 Certificate { get; }
    public X509SecurityToken(X509Certificate2 certificate);
    public X509SecurityToken(X509Certificate2 certificate, string id);
    internal X509SecurityToken(X509Certificate2 certificate, bool clone);
    internal X509SecurityToken(X509Certificate2 certificate, bool clone, bool disposable);
    internal X509SecurityToken(X509Certificate2 certificate, string id, bool clone);
    internal X509SecurityToken(X509Certificate2 certificate, string id, bool clone, bool disposable);
    public virtual string get_Id();
    public virtual ReadOnlyCollection`1<SecurityKey> get_SecurityKeys();
    public virtual DateTime get_ValidFrom();
    public virtual DateTime get_ValidTo();
    public X509Certificate2 get_Certificate();
    public virtual bool CanCreateKeyIdentifierClause();
    public virtual T CreateKeyIdentifierClause();
    public virtual bool MatchesKeyIdentifierClause(SecurityKeyIdentifierClause keyIdentifierClause);
    public virtual void Dispose();
    protected void ThrowIfDisposed();
}
public class System.IdentityModel.Tokens.X509SubjectKeyIdentifierClause : BinaryKeyIdentifierClause {
    private static string SubjectKeyIdentifierOid;
    private static int SkiDataOffset;
    public X509SubjectKeyIdentifierClause(Byte[] ski);
    internal X509SubjectKeyIdentifierClause(Byte[] ski, bool cloneBuffer);
    private static Byte[] GetSkiRawData(X509Certificate2 certificate);
    public Byte[] GetX509SubjectKeyIdentifier();
    public bool Matches(X509Certificate2 certificate);
    public static bool TryCreateFrom(X509Certificate2 certificate, X509SubjectKeyIdentifierClause& keyIdentifierClause);
    public static bool CanCreateFrom(X509Certificate2 certificate);
    public virtual string ToString();
}
public class System.IdentityModel.Tokens.X509ThumbprintKeyIdentifierClause : BinaryKeyIdentifierClause {
    public X509ThumbprintKeyIdentifierClause(X509Certificate2 certificate);
    public X509ThumbprintKeyIdentifierClause(Byte[] thumbprint);
    internal X509ThumbprintKeyIdentifierClause(Byte[] thumbprint, bool cloneBuffer);
    private static Byte[] GetHash(X509Certificate2 certificate);
    public Byte[] GetX509Thumbprint();
    public bool Matches(X509Certificate2 certificate);
    public virtual string ToString();
}
internal class System.IdentityModel.Tokens.XmlDsigSep2000 : SerializerEntries {
    private KeyInfoSerializer _securityTokenSerializer;
    public XmlDsigSep2000(KeyInfoSerializer securityTokenSerializer);
    public virtual void PopulateKeyIdentifierEntries(IList`1<KeyIdentifierEntry> keyIdentifierEntries);
    public virtual void PopulateKeyIdentifierClauseEntries(IList`1<KeyIdentifierClauseEntry> keyIdentifierClauseEntries);
}
internal class System.IdentityModel.TrustDec2005Dictionary : TrustDictionary {
    public TrustDec2005Dictionary(IdentityModelDictionary dictionary);
    public TrustDec2005Dictionary(IXmlDictionary dictionary);
    private XmlDictionaryString LookupDictionaryString(IXmlDictionary dictionary, string value);
}
internal static class System.IdentityModel.TrustDec2005Strings : object {
    public static string CombinedHashLabel;
    public static string RequestSecurityTokenResponse;
    public static string TokenType;
    public static string KeySize;
    public static string RequestedTokenReference;
    public static string AppliesTo;
    public static string Authenticator;
    public static string CombinedHash;
    public static string BinaryExchange;
    public static string Lifetime;
    public static string RequestedSecurityToken;
    public static string Entropy;
    public static string RequestedProofToken;
    public static string ComputedKey;
    public static string RequestSecurityToken;
    public static string RequestType;
    public static string Context;
    public static string BinarySecret;
    public static string Type;
    public static string SpnegoValueTypeUri;
    public static string TlsnegoValueTypeUri;
    public static string Prefix;
    public static string RequestSecurityTokenIssuance;
    public static string RequestSecurityTokenIssuanceResponse;
    public static string RequestTypeIssue;
    public static string AsymmetricKeyBinarySecret;
    public static string SymmetricKeyBinarySecret;
    public static string NonceBinarySecret;
    public static string Psha1ComputedKeyUri;
    public static string KeyType;
    public static string SymmetricKeyType;
    public static string PublicKeyType;
    public static string Claims;
    public static string InvalidRequestFaultCode;
    public static string FailedAuthenticationFaultCode;
    public static string UseKey;
    public static string SignWith;
    public static string EncryptWith;
    public static string EncryptionAlgorithm;
    public static string CanonicalizationAlgorithm;
    public static string ComputedKeyAlgorithm;
    public static string RequestSecurityTokenResponseCollection;
    public static string Namespace;
    public static string BinarySecretClauseType;
    public static string RequestSecurityTokenCollectionIssuanceFinalResponse;
    public static string RequestSecurityTokenRenewal;
    public static string RequestSecurityTokenRenewalResponse;
    public static string RequestSecurityTokenCollectionRenewalFinalResponse;
    public static string RequestSecurityTokenCancellation;
    public static string RequestSecurityTokenCancellationResponse;
    public static string RequestSecurityTokenCollectionCancellationFinalResponse;
    public static string RequestTypeRenew;
    public static string RequestTypeClose;
    public static string RenewTarget;
    public static string CloseTarget;
    public static string RequestedTokenClosed;
    public static string RequestedAttachedReference;
    public static string RequestedUnattachedReference;
    public static string IssuedTokensHeader;
    public static string KeyWrapAlgorithm;
    public static string BearerKeyType;
    public static string SecondaryParameters;
    public static string Dialect;
    public static string DialectType;
}
internal class System.IdentityModel.TrustDictionary : object {
    public XmlDictionaryString RequestSecurityTokenResponseCollection;
    public XmlDictionaryString Namespace;
    public XmlDictionaryString BinarySecretClauseType;
    public XmlDictionaryString CombinedHashLabel;
    public XmlDictionaryString RequestSecurityTokenResponse;
    public XmlDictionaryString TokenType;
    public XmlDictionaryString KeySize;
    public XmlDictionaryString RequestedTokenReference;
    public XmlDictionaryString AppliesTo;
    public XmlDictionaryString Authenticator;
    public XmlDictionaryString CombinedHash;
    public XmlDictionaryString BinaryExchange;
    public XmlDictionaryString Lifetime;
    public XmlDictionaryString RequestedSecurityToken;
    public XmlDictionaryString Entropy;
    public XmlDictionaryString RequestedProofToken;
    public XmlDictionaryString ComputedKey;
    public XmlDictionaryString RequestSecurityToken;
    public XmlDictionaryString RequestType;
    public XmlDictionaryString Context;
    public XmlDictionaryString BinarySecret;
    public XmlDictionaryString Type;
    public XmlDictionaryString SpnegoValueTypeUri;
    public XmlDictionaryString TlsnegoValueTypeUri;
    public XmlDictionaryString Prefix;
    public XmlDictionaryString RequestSecurityTokenIssuance;
    public XmlDictionaryString RequestSecurityTokenIssuanceResponse;
    public XmlDictionaryString RequestTypeIssue;
    public XmlDictionaryString SymmetricKeyBinarySecret;
    public XmlDictionaryString Psha1ComputedKeyUri;
    public XmlDictionaryString NonceBinarySecret;
    public XmlDictionaryString RenewTarget;
    public XmlDictionaryString CloseTarget;
    public XmlDictionaryString RequestedTokenClosed;
    public XmlDictionaryString RequestedAttachedReference;
    public XmlDictionaryString RequestedUnattachedReference;
    public XmlDictionaryString IssuedTokensHeader;
    public XmlDictionaryString RequestTypeRenew;
    public XmlDictionaryString RequestTypeClose;
    public XmlDictionaryString KeyType;
    public XmlDictionaryString SymmetricKeyType;
    public XmlDictionaryString PublicKeyType;
    public XmlDictionaryString Claims;
    public XmlDictionaryString InvalidRequestFaultCode;
    public XmlDictionaryString FailedAuthenticationFaultCode;
    public XmlDictionaryString UseKey;
    public XmlDictionaryString SignWith;
    public XmlDictionaryString EncryptWith;
    public XmlDictionaryString EncryptionAlgorithm;
    public XmlDictionaryString CanonicalizationAlgorithm;
    public XmlDictionaryString ComputedKeyAlgorithm;
    public XmlDictionaryString AsymmetricKeyBinarySecret;
    public XmlDictionaryString RequestSecurityTokenCollectionIssuanceFinalResponse;
    public XmlDictionaryString RequestSecurityTokenRenewal;
    public XmlDictionaryString RequestSecurityTokenRenewalResponse;
    public XmlDictionaryString RequestSecurityTokenCollectionRenewalFinalResponse;
    public XmlDictionaryString RequestSecurityTokenCancellation;
    public XmlDictionaryString RequestSecurityTokenCancellationResponse;
    public XmlDictionaryString RequestSecurityTokenCollectionCancellationFinalResponse;
    public XmlDictionaryString KeyWrapAlgorithm;
    public XmlDictionaryString BearerKeyType;
    public XmlDictionaryString SecondaryParameters;
    public XmlDictionaryString Dialect;
    public XmlDictionaryString DialectType;
    public TrustDictionary(IdentityModelDictionary dictionary);
    public TrustDictionary(IXmlDictionary dictionary);
    private XmlDictionaryString LookupDictionaryString(IXmlDictionary dictionary, string value);
}
internal class System.IdentityModel.TrustFeb2005Dictionary : TrustDictionary {
    public TrustFeb2005Dictionary(IdentityModelDictionary dictionary);
    public TrustFeb2005Dictionary(IXmlDictionary dictionary);
    private XmlDictionaryString LookupDictionaryString(IXmlDictionary dictionary, string value);
}
internal static class System.IdentityModel.TrustFeb2005Strings : object {
    public static string RequestSecurityTokenResponseCollection;
    public static string Namespace;
    public static string BinarySecretClauseType;
    public static string CombinedHashLabel;
    public static string RequestSecurityTokenResponse;
    public static string TokenType;
    public static string KeySize;
    public static string RequestedTokenReference;
    public static string AppliesTo;
    public static string Authenticator;
    public static string CombinedHash;
    public static string BinaryExchange;
    public static string Lifetime;
    public static string RequestedSecurityToken;
    public static string Entropy;
    public static string RequestedProofToken;
    public static string ComputedKey;
    public static string RequestSecurityToken;
    public static string RequestType;
    public static string Context;
    public static string BinarySecret;
    public static string Type;
    public static string SpnegoValueTypeUri;
    public static string TlsnegoValueTypeUri;
    public static string Prefix;
    public static string RequestSecurityTokenIssuance;
    public static string RequestSecurityTokenIssuanceResponse;
    public static string RequestTypeIssue;
    public static string SymmetricKeyBinarySecret;
    public static string Psha1ComputedKeyUri;
    public static string NonceBinarySecret;
    public static string RenewTarget;
    public static string CloseTarget;
    public static string RequestedTokenClosed;
    public static string RequestedAttachedReference;
    public static string RequestedUnattachedReference;
    public static string IssuedTokensHeader;
    public static string RequestTypeRenew;
    public static string RequestTypeClose;
    public static string KeyType;
    public static string SymmetricKeyType;
    public static string PublicKeyType;
    public static string Claims;
    public static string InvalidRequestFaultCode;
    public static string FailedAuthenticationFaultCode;
    public static string UseKey;
    public static string SignWith;
    public static string EncryptWith;
    public static string EncryptionAlgorithm;
    public static string CanonicalizationAlgorithm;
    public static string ComputedKeyAlgorithm;
}
internal static class System.IdentityModel.TrustStrings : object {
}
internal class System.IdentityModel.UtilityDictionary : object {
    public XmlDictionaryString IdAttribute;
    public XmlDictionaryString Namespace;
    public XmlDictionaryString Timestamp;
    public XmlDictionaryString CreatedElement;
    public XmlDictionaryString ExpiresElement;
    public XmlDictionaryString Prefix;
    public UtilityDictionary(IdentityModelDictionary dictionary);
    public UtilityDictionary(IXmlDictionary dictionary);
    private XmlDictionaryString LookupDictionaryString(IXmlDictionary dictionary, string value);
}
internal static class System.IdentityModel.UtilityStrings : object {
    public static string IdAttribute;
    public static string Namespace;
    public static string Timestamp;
    public static string CreatedElement;
    public static string ExpiresElement;
    public static string Prefix;
}
internal static class System.IdentityModel.XD : object {
    private static ExclusiveC14NDictionary s_exclusiveC14NDictionary;
    private static SamlDictionary s_samlDictionary;
    private static SecureConversationDec2005Dictionary s_secureConversationDec2005Dictionary;
    private static SecureConversationFeb2005Dictionary s_secureConversationFeb2005Dictionary;
    private static SecurityAlgorithmDictionary s_securityAlgorithmDictionary;
    private static SecurityAlgorithmDec2005Dictionary s_securityAlgorithmDec2005Dictionary;
    private static SecurityJan2004Dictionary s_securityJan2004Dictionary;
    private static SecurityXXX2005Dictionary s_securityXXX2005Dictionary;
    private static TrustDec2005Dictionary s_trustDec2005Dictionary;
    private static TrustFeb2005Dictionary s_trustFeb2005Dictionary;
    private static UtilityDictionary s_utilityDictionary;
    private static XmlEncryptionDictionary s_xmlEncryptionDictionary;
    private static XmlSignatureDictionary s_xmlSignatureDictionary;
    public static IdentityModelDictionary Dictionary { get; }
    public static ExclusiveC14NDictionary ExclusiveC14NDictionary { get; }
    public static SamlDictionary SamlDictionary { get; }
    public static SecureConversationDec2005Dictionary SecureConversationDec2005Dictionary { get; }
    public static SecureConversationFeb2005Dictionary SecureConversationFeb2005Dictionary { get; }
    public static SecurityAlgorithmDictionary SecurityAlgorithmDictionary { get; }
    public static SecurityAlgorithmDec2005Dictionary SecurityAlgorithmDec2005Dictionary { get; }
    public static SecurityJan2004Dictionary SecurityJan2004Dictionary { get; }
    public static SecurityXXX2005Dictionary SecurityXXX2005Dictionary { get; }
    public static TrustDec2005Dictionary TrustDec2005Dictionary { get; }
    public static TrustFeb2005Dictionary TrustFeb2005Dictionary { get; }
    public static UtilityDictionary UtilityDictionary { get; }
    public static XmlEncryptionDictionary XmlEncryptionDictionary { get; }
    public static XmlSignatureDictionary XmlSignatureDictionary { get; }
    public static IdentityModelDictionary get_Dictionary();
    public static ExclusiveC14NDictionary get_ExclusiveC14NDictionary();
    public static SamlDictionary get_SamlDictionary();
    public static SecureConversationDec2005Dictionary get_SecureConversationDec2005Dictionary();
    public static SecureConversationFeb2005Dictionary get_SecureConversationFeb2005Dictionary();
    public static SecurityAlgorithmDictionary get_SecurityAlgorithmDictionary();
    public static SecurityAlgorithmDec2005Dictionary get_SecurityAlgorithmDec2005Dictionary();
    public static SecurityJan2004Dictionary get_SecurityJan2004Dictionary();
    public static SecurityXXX2005Dictionary get_SecurityXXX2005Dictionary();
    public static TrustDec2005Dictionary get_TrustDec2005Dictionary();
    public static TrustFeb2005Dictionary get_TrustFeb2005Dictionary();
    public static UtilityDictionary get_UtilityDictionary();
    public static XmlEncryptionDictionary get_XmlEncryptionDictionary();
    public static XmlSignatureDictionary get_XmlSignatureDictionary();
}
internal class System.IdentityModel.XmlEncryptionDictionary : object {
    public XmlDictionaryString Namespace;
    public XmlDictionaryString DataReference;
    public XmlDictionaryString EncryptedData;
    public XmlDictionaryString EncryptionMethod;
    public XmlDictionaryString CipherData;
    public XmlDictionaryString CipherValue;
    public XmlDictionaryString ReferenceList;
    public XmlDictionaryString Encoding;
    public XmlDictionaryString MimeType;
    public XmlDictionaryString Type;
    public XmlDictionaryString Id;
    public XmlDictionaryString CarriedKeyName;
    public XmlDictionaryString Recipient;
    public XmlDictionaryString EncryptedKey;
    public XmlDictionaryString URI;
    public XmlDictionaryString KeyReference;
    public XmlDictionaryString Prefix;
    public XmlDictionaryString ElementType;
    public XmlDictionaryString ContentType;
    public XmlDictionaryString AlgorithmAttribute;
    public XmlEncryptionDictionary(IdentityModelDictionary dictionary);
    public XmlEncryptionDictionary(IXmlDictionary dictionary);
    private XmlDictionaryString LookupDictionaryString(IXmlDictionary dictionary, string value);
}
internal static class System.IdentityModel.XmlEncryptionStrings : object {
    public static string Namespace;
    public static string DataReference;
    public static string EncryptedData;
    public static string EncryptionMethod;
    public static string CipherData;
    public static string CipherValue;
    public static string ReferenceList;
    public static string Encoding;
    public static string MimeType;
    public static string Type;
    public static string Id;
    public static string CarriedKeyName;
    public static string Recipient;
    public static string EncryptedKey;
    public static string URI;
    public static string KeyReference;
    public static string Prefix;
    public static string ElementType;
    public static string ContentType;
    public static string AlgorithmAttribute;
}
internal static class System.IdentityModel.XmlSignatureConstants : object {
    public static string Namespace;
    public static string Prefix;
}
internal class System.IdentityModel.XmlSignatureDictionary : object {
    public XmlDictionaryString Algorithm;
    public XmlDictionaryString URI;
    public XmlDictionaryString Reference;
    public XmlDictionaryString Transforms;
    public XmlDictionaryString Transform;
    public XmlDictionaryString DigestMethod;
    public XmlDictionaryString DigestValue;
    public XmlDictionaryString Namespace;
    public XmlDictionaryString EnvelopedSignature;
    public XmlDictionaryString KeyInfo;
    public XmlDictionaryString Signature;
    public XmlDictionaryString SignedInfo;
    public XmlDictionaryString CanonicalizationMethod;
    public XmlDictionaryString SignatureMethod;
    public XmlDictionaryString SignatureValue;
    public XmlDictionaryString KeyName;
    public XmlDictionaryString Type;
    public XmlDictionaryString MgmtData;
    public XmlDictionaryString Prefix;
    public XmlDictionaryString KeyValue;
    public XmlDictionaryString RsaKeyValue;
    public XmlDictionaryString Modulus;
    public XmlDictionaryString Exponent;
    public XmlDictionaryString X509Data;
    public XmlDictionaryString X509IssuerSerial;
    public XmlDictionaryString X509IssuerName;
    public XmlDictionaryString X509SerialNumber;
    public XmlDictionaryString X509Certificate;
    public XmlSignatureDictionary(IdentityModelDictionary dictionary);
    public XmlSignatureDictionary(IXmlDictionary dictionary);
    private XmlDictionaryString LookupDictionaryString(IXmlDictionary dictionary, string value);
}
internal static class System.IdentityModel.XmlSignatureStrings : object {
    public static string Algorithm;
    public static string URI;
    public static string Reference;
    public static string Transforms;
    public static string Transform;
    public static string DigestMethod;
    public static string DigestValue;
    public static string Namespace;
    public static string EnvelopedSignature;
    public static string KeyInfo;
    public static string Signature;
    public static string SignedInfo;
    public static string CanonicalizationMethod;
    public static string SignatureMethod;
    public static string SignatureValue;
    public static string KeyName;
    public static string Type;
    public static string MgmtData;
    public static string Prefix;
    public static string KeyValue;
    public static string RsaKeyValue;
    public static string Modulus;
    public static string Exponent;
    public static string X509Data;
    public static string X509IssuerSerial;
    public static string X509IssuerName;
    public static string X509SerialNumber;
    public static string X509Certificate;
    public static string SecurityJan2004Namespace;
    public static string SecurityJan2004Prefix;
    public static string X509Ski;
    public static string TransformationParameters;
}
internal static class System.NotImplemented : object {
    internal static Exception ByDesign { get; }
    internal static Exception get_ByDesign();
    internal static Exception ByDesignWithMessage(string message);
}
internal abstract class System.Runtime.ActionItem : object {
    private bool _isScheduled;
    public static void Schedule(Action`1<object> callback, object state);
    public static void Schedule(Func`2<object, Task> callback, object state);
    protected abstract virtual void Invoke();
    protected abstract virtual Task InvokeAsync();
    protected void Schedule();
    protected void ScheduleAsync();
    private static void ScheduleCallback(Action`1<object> callback, object state);
    private static void ScheduleCallback(Func`2<object, Task> callback, object state);
    private void ScheduleCallback(Action`1<object> callback);
    private void ScheduleCallback(Func`2<object, Task> callback);
}
public enum System.Runtime.AsyncCompletionResult : Enum {
    public int value__;
    public static AsyncCompletionResult Queued;
    public static AsyncCompletionResult Completed;
}
internal class System.Runtime.AsyncLock : object {
    private static ObjectPool`1<SemaphoreSlim> s_semaphorePool;
    private AsyncLocal`1<SemaphoreSlim> _currentSemaphore;
    private SemaphoreSlim _topLevelSemaphore;
    private bool _isDisposed;
    private static AsyncLock();
    public Task`1<IAsyncDisposable> TakeLockAsync();
    [AsyncStateMachineAttribute("System.Runtime.AsyncLock/<TakeLockCoreAsync>d__6")]
private Task`1<IAsyncDisposable> TakeLockCoreAsync(SemaphoreSlim currentSemaphore, SafeSemaphoreRelease safeSemaphoreRelease);
    public IDisposable TakeLock();
    [AsyncStateMachineAttribute("System.Runtime.AsyncLock/<DisposeAsync>d__8")]
public sealed virtual ValueTask DisposeAsync();
}
internal abstract class System.Runtime.AsyncResult : object {
    private static AsyncCallback s_asyncCompletionWrapperCallback;
    private AsyncCallback _callback;
    private bool _endCalled;
    private Exception _exception;
    private AsyncCompletion _nextAsyncCompletion;
    private Action _beforePrepareAsyncCompletionAction;
    private Func`2<IAsyncResult, bool> _checkSyncValidationFunc;
    private ManualResetEvent _manualResetEvent;
    private object _thisLock;
    [CompilerGeneratedAttribute]
private object <AsyncState>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <CompletedSynchronously>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsCompleted>k__BackingField;
    [CompilerGeneratedAttribute]
private Action`2<AsyncResult, Exception> <OnCompleting>k__BackingField;
    [CompilerGeneratedAttribute]
private Action`2<AsyncCallback, IAsyncResult> <VirtualCallback>k__BackingField;
    public object AsyncState { get; }
    public WaitHandle AsyncWaitHandle { get; }
    public bool CompletedSynchronously { get; private set; }
    public bool HasCallback { get; }
    public bool IsCompleted { get; private set; }
    protected Action`2<AsyncResult, Exception> OnCompleting { get; protected set; }
    private object ThisLock { get; }
    protected Action`2<AsyncCallback, IAsyncResult> VirtualCallback { get; protected set; }
    protected AsyncResult(AsyncCallback callback, object state);
    [CompilerGeneratedAttribute]
public sealed virtual object get_AsyncState();
    public sealed virtual WaitHandle get_AsyncWaitHandle();
    [CompilerGeneratedAttribute]
public sealed virtual bool get_CompletedSynchronously();
    [CompilerGeneratedAttribute]
private void set_CompletedSynchronously(bool value);
    public bool get_HasCallback();
    [CompilerGeneratedAttribute]
public sealed virtual bool get_IsCompleted();
    [CompilerGeneratedAttribute]
private void set_IsCompleted(bool value);
    [CompilerGeneratedAttribute]
protected Action`2<AsyncResult, Exception> get_OnCompleting();
    [CompilerGeneratedAttribute]
protected void set_OnCompleting(Action`2<AsyncResult, Exception> value);
    private object get_ThisLock();
    [CompilerGeneratedAttribute]
protected Action`2<AsyncCallback, IAsyncResult> get_VirtualCallback();
    [CompilerGeneratedAttribute]
protected void set_VirtualCallback(Action`2<AsyncCallback, IAsyncResult> value);
    protected void Complete(bool completedSynchronously);
    protected void Complete(bool completedSynchronously, Exception exception);
    private static void AsyncCompletionWrapperCallback(IAsyncResult result);
    protected virtual bool OnContinueAsyncCompletion(IAsyncResult result);
    protected void SetBeforePrepareAsyncCompletionAction(Action beforePrepareAsyncCompletionAction);
    protected void SetCheckSyncValidationFunc(Func`2<IAsyncResult, bool> checkSyncValidationFunc);
    protected AsyncCallback PrepareAsyncCompletion(AsyncCompletion callback);
    protected bool CheckSyncContinue(IAsyncResult result);
    protected bool SyncContinue(IAsyncResult result);
    private bool TryContinueHelper(IAsyncResult result, AsyncCompletion& callback);
    private AsyncCompletion GetNextCompletion();
    protected static void ThrowInvalidAsyncResult(IAsyncResult result);
    protected static void ThrowInvalidAsyncResult(string debugText);
    protected static TAsyncResult End(IAsyncResult result);
}
internal class System.Runtime.BufferedOutputStream : Stream {
    private InternalBufferManager _bufferManager;
    private Byte[][] _chunks;
    private int _chunkCount;
    private Byte[] _currentChunk;
    private int _currentChunkSize;
    private int _maxSize;
    private int _maxSizeQuota;
    private int _totalSize;
    private bool _callerReturnsBuffer;
    private bool _bufferReturned;
    private bool _initialized;
    public bool CanRead { get; }
    public bool CanSeek { get; }
    public bool CanWrite { get; }
    public long Length { get; }
    public long Position { get; public set; }
    public BufferedOutputStream(int initialSize, int maxSize, InternalBufferManager bufferManager);
    public BufferedOutputStream(int maxSize);
    public virtual bool get_CanRead();
    public virtual bool get_CanSeek();
    public virtual bool get_CanWrite();
    public virtual long get_Length();
    public virtual long get_Position();
    public virtual void set_Position(long value);
    public void Reinitialize(int initialSize, int maxSizeQuota, InternalBufferManager bufferManager);
    public void Reinitialize(int initialSize, int maxSizeQuota, int effectiveMaxSize, InternalBufferManager bufferManager);
    private void AllocNextChunk(int minimumChunkSize);
    public virtual IAsyncResult BeginRead(Byte[] buffer, int offset, int size, AsyncCallback callback, object state);
    public virtual int EndRead(IAsyncResult result);
    public virtual IAsyncResult BeginWrite(Byte[] buffer, int offset, int size, AsyncCallback callback, object state);
    public virtual void EndWrite(IAsyncResult result);
    public void Clear();
    public virtual void Close();
    public virtual void Flush();
    public virtual int Read(Byte[] buffer, int offset, int size);
    public virtual int ReadByte();
    public virtual long Seek(long offset, SeekOrigin origin);
    public virtual void SetLength(long value);
    public MemoryStream ToMemoryStream();
    public Byte[] ToArray(Int32& bufferSize);
    public void Skip(int size);
    public virtual void Write(Byte[] buffer, int offset, int size);
    protected virtual Exception CreateQuotaExceededException(int maxSizeQuota);
    private void WriteCore(Byte[] buffer, int offset, int size);
    public virtual void WriteByte(byte value);
}
internal class System.Runtime.CallbackException : FatalException {
    public CallbackException(string message, Exception innerException);
}
internal class System.Runtime.CompletedAsyncResult : AsyncResult {
    public CompletedAsyncResult(AsyncCallback callback, object state);
    public static void End(IAsyncResult result);
}
internal class System.Runtime.CompletedAsyncResult`1 : AsyncResult {
    private T _data;
    public CompletedAsyncResult`1(T data, AsyncCallback callback, object state);
    public static T End(IAsyncResult result);
}
internal class System.Runtime.CompletedAsyncResult`2 : AsyncResult {
    private TResult _resultData;
    private TParameter _parameter;
    public CompletedAsyncResult`2(TResult resultData, TParameter parameter, AsyncCallback callback, object state);
    public static TResult End(IAsyncResult result, TParameter& parameter);
}
public class System.Runtime.DefaultTaskSchedulerAwaiter : ValueType {
    public static DefaultTaskSchedulerAwaiter Singleton;
    public bool IsCompleted { get; }
    private static DefaultTaskSchedulerAwaiter();
    public bool get_IsCompleted();
    public sealed virtual void OnCompleted(Action continuation);
    public void GetResult();
    public DefaultTaskSchedulerAwaiter GetAwaiter();
}
internal abstract class System.Runtime.Diagnostics.DiagnosticTraceBase : object {
    protected static string DefaultTraceListenerName;
    protected static string TraceRecordVersion;
    protected static string AppDomainFriendlyName;
    private static ushort TracingEventLogCategory;
    private string _eventSourceName;
    protected string EventSourceName { get; protected set; }
    public bool TracingEnabled { get; }
    protected static string ProcessName { get; }
    protected static int ProcessId { get; }
    public static Guid ActivityId { get; public set; }
    private static DiagnosticTraceBase();
    protected string get_EventSourceName();
    protected void set_EventSourceName(string value);
    public bool get_TracingEnabled();
    protected static string get_ProcessName();
    protected static int get_ProcessId();
    protected void AddDomainEventHandlersForCleanup();
    private void ExitOrUnloadEventHandler(object sender, EventArgs e);
    protected static string CreateSourceString(object source);
    internal static string CreateDefaultSourceString(object source);
    public static string XmlEncode(string text);
    protected static string StackTraceString(Exception exception);
    public static Guid get_ActivityId();
    public static void set_ActivityId(Guid value);
    public abstract virtual bool IsEnabled();
}
internal class System.Runtime.Diagnostics.DictionaryTraceRecord : TraceRecord {
    private IDictionary _dictionary;
    internal string EventId { get; }
    internal DictionaryTraceRecord(IDictionary dictionary);
    internal virtual string get_EventId();
    internal virtual void WriteTo(XmlWriter xml);
}
internal class System.Runtime.Diagnostics.EtwDiagnosticTrace : DiagnosticTraceBase {
    private static int XmlBracketsLength;
    private static int MaxExceptionDepth;
    private static int MaxExceptionStringLength;
    public bool IsEtwProviderEnabled { get; }
    public bool IsEnd2EndActivityTracingEnabled { get; }
    private bool EtwTracingEnabled { get; }
    public bool get_IsEtwProviderEnabled();
    public bool get_IsEnd2EndActivityTracingEnabled();
    internal static string ExceptionToTraceString(Exception exception, int maxTraceStringLength);
    private static void WriteExceptionToTraceString(XmlWriter xml, Exception exception, int remainingLength, int remainingAllowedRecursionDepth);
    private static bool WriteStartElement(XmlWriter xml, string localName, Int32& remainingLength);
    private static bool WriteXmlElementString(XmlWriter xml, string localName, string value, Int32& remainingLength);
    private static string GetExceptionData(Exception exception);
    private static string GetInnerException(Exception exception, int remainingLength, int remainingAllowedRecursionDepth);
    private bool get_EtwTracingEnabled();
    public void SetEnd2EndActivityTracingEnabled(bool isEnd2EndTracingEnabled);
    public void Event(EventDescriptor& eventDescriptor, string description);
    public void SetAndTraceTransfer(Guid newId, bool emitTransfer);
    public void TraceTransfer(Guid newId);
    public void WriteTraceSource(EventDescriptor& eventDescriptor, string description, TracePayload payload);
    private static string LookupChannel(TraceChannel traceChannel);
    public TracePayload GetSerializedPayload(object source, TraceRecord traceRecord, Exception exception);
    public TracePayload GetSerializedPayload(object source, TraceRecord traceRecord, Exception exception, bool getServiceReference);
    public bool IsEtwEventEnabled(EventDescriptor& eventDescriptor);
    public bool IsEtwEventEnabled(EventDescriptor& eventDescriptor, bool fullCheck);
    public virtual bool IsEnabled();
}
internal class System.Runtime.Diagnostics.EventDescriptor : ValueType {
    private ushort _id;
    private byte _version;
    private byte _channel;
    private byte _level;
    private byte _opcode;
    private ushort _task;
    private long _keywords;
    public int EventId { get; }
    public byte Version { get; }
    public byte Channel { get; }
    public byte Level { get; }
    public byte Opcode { get; }
    public int Task { get; }
    public long Keywords { get; }
    public EventDescriptor(int id, byte version, byte channel, byte level, byte opcode, int task, long keywords);
    public int get_EventId();
    public byte get_Version();
    public byte get_Channel();
    public byte get_Level();
    public byte get_Opcode();
    public int get_Task();
    public long get_Keywords();
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    public bool Equals(EventDescriptor other);
    public static bool op_Equality(EventDescriptor event1, EventDescriptor event2);
    public static bool op_Inequality(EventDescriptor event1, EventDescriptor event2);
}
internal enum System.Runtime.Diagnostics.EventFacility : Enum {
    public UInt32 value__;
    public static EventFacility Tracing;
    public static EventFacility ServiceModel;
    public static EventFacility TransactionBridge;
    public static EventFacility SMSvcHost;
    public static EventFacility InfoCards;
    public static EventFacility SecurityAudit;
}
internal enum System.Runtime.Diagnostics.EventLogCategory : Enum {
    public ushort value__;
    public static EventLogCategory ServiceAuthorization;
    public static EventLogCategory MessageAuthentication;
    public static EventLogCategory ObjectAccess;
    public static EventLogCategory Tracing;
    public static EventLogCategory WebHost;
    public static EventLogCategory FailFast;
    public static EventLogCategory MessageLogging;
    public static EventLogCategory PerformanceCounter;
    public static EventLogCategory Wmi;
    public static EventLogCategory ComPlus;
    public static EventLogCategory StateMachine;
    public static EventLogCategory Wsat;
    public static EventLogCategory SharingService;
    public static EventLogCategory ListenerAdapter;
}
internal enum System.Runtime.Diagnostics.EventLogEventId : Enum {
    public UInt32 value__;
    public static EventLogEventId FailedToSetupTracing;
    public static EventLogEventId FailedToInitializeTraceSource;
    public static EventLogEventId FailFast;
    public static EventLogEventId FailFastException;
    public static EventLogEventId FailedToTraceEvent;
    public static EventLogEventId FailedToTraceEventWithException;
    public static EventLogEventId InvariantAssertionFailed;
    public static EventLogEventId PiiLoggingOn;
    public static EventLogEventId PiiLoggingNotAllowed;
    public static EventLogEventId WebHostUnhandledException;
    public static EventLogEventId WebHostHttpError;
    public static EventLogEventId WebHostFailedToProcessRequest;
    public static EventLogEventId WebHostFailedToListen;
    public static EventLogEventId FailedToLogMessage;
    public static EventLogEventId RemovedBadFilter;
    public static EventLogEventId FailedToCreateMessageLoggingTraceSource;
    public static EventLogEventId MessageLoggingOn;
    public static EventLogEventId MessageLoggingOff;
    public static EventLogEventId FailedToLoadPerformanceCounter;
    public static EventLogEventId FailedToRemovePerformanceCounter;
    public static EventLogEventId WmiGetObjectFailed;
    public static EventLogEventId WmiPutInstanceFailed;
    public static EventLogEventId WmiDeleteInstanceFailed;
    public static EventLogEventId WmiCreateInstanceFailed;
    public static EventLogEventId WmiExecQueryFailed;
    public static EventLogEventId WmiExecMethodFailed;
    public static EventLogEventId WmiRegistrationFailed;
    public static EventLogEventId WmiUnregistrationFailed;
    public static EventLogEventId WmiAdminTypeMismatch;
    public static EventLogEventId WmiPropertyMissing;
    public static EventLogEventId ComPlusServiceHostStartingServiceError;
    public static EventLogEventId ComPlusDllHostInitializerStartingError;
    public static EventLogEventId ComPlusTLBImportError;
    public static EventLogEventId ComPlusInvokingMethodFailed;
    public static EventLogEventId ComPlusInstanceCreationError;
    public static EventLogEventId ComPlusInvokingMethodFailedMismatchedTransactions;
    public static EventLogEventId WebHostNotLoggingInsufficientMemoryExceptionsOnActivationForNextTimeInterval;
    public static EventLogEventId UnhandledStateMachineExceptionRecordDescription;
    public static EventLogEventId FatalUnexpectedStateMachineEvent;
    public static EventLogEventId ParticipantRecoveryLogEntryCorrupt;
    public static EventLogEventId CoordinatorRecoveryLogEntryCorrupt;
    public static EventLogEventId CoordinatorRecoveryLogEntryCreationFailure;
    public static EventLogEventId ParticipantRecoveryLogEntryCreationFailure;
    public static EventLogEventId ProtocolInitializationFailure;
    public static EventLogEventId ProtocolStartFailure;
    public static EventLogEventId ProtocolRecoveryBeginningFailure;
    public static EventLogEventId ProtocolRecoveryCompleteFailure;
    public static EventLogEventId TransactionBridgeRecoveryFailure;
    public static EventLogEventId ProtocolStopFailure;
    public static EventLogEventId NonFatalUnexpectedStateMachineEvent;
    public static EventLogEventId PerformanceCounterInitializationFailure;
    public static EventLogEventId ProtocolRecoveryComplete;
    public static EventLogEventId ProtocolStopped;
    public static EventLogEventId ThumbPrintNotFound;
    public static EventLogEventId ThumbPrintNotValidated;
    public static EventLogEventId SslNoPrivateKey;
    public static EventLogEventId SslNoAccessiblePrivateKey;
    public static EventLogEventId MissingNecessaryKeyUsage;
    public static EventLogEventId MissingNecessaryEnhancedKeyUsage;
    public static EventLogEventId StartErrorPublish;
    public static EventLogEventId BindingError;
    public static EventLogEventId LAFailedToListenForApp;
    public static EventLogEventId UnknownListenerAdapterError;
    public static EventLogEventId WasDisconnected;
    public static EventLogEventId WasConnectionTimedout;
    public static EventLogEventId ServiceStartFailed;
    public static EventLogEventId MessageQueueDuplicatedSocketLeak;
    public static EventLogEventId MessageQueueDuplicatedPipeLeak;
    public static EventLogEventId SharingUnhandledException;
    public static EventLogEventId ServiceAuthorizationSuccess;
    public static EventLogEventId ServiceAuthorizationFailure;
    public static EventLogEventId MessageAuthenticationSuccess;
    public static EventLogEventId MessageAuthenticationFailure;
    public static EventLogEventId SecurityNegotiationSuccess;
    public static EventLogEventId SecurityNegotiationFailure;
    public static EventLogEventId TransportAuthenticationSuccess;
    public static EventLogEventId TransportAuthenticationFailure;
    public static EventLogEventId ImpersonationSuccess;
    public static EventLogEventId ImpersonationFailure;
}
internal enum System.Runtime.Diagnostics.EventSeverity : Enum {
    public UInt32 value__;
    public static EventSeverity Success;
    public static EventSeverity Informational;
    public static EventSeverity Warning;
    public static EventSeverity Error;
}
internal class System.Runtime.Diagnostics.EventTraceActivity : object {
    public Guid ActivityId;
    private static EventTraceActivity s_empty;
    public static EventTraceActivity Empty { get; }
    public static string Name { get; }
    public EventTraceActivity(bool setOnThread);
    public EventTraceActivity(Guid guid, bool setOnThread);
    public static EventTraceActivity get_Empty();
    public static string get_Name();
    public static EventTraceActivity GetFromThreadOrCreate(bool clearIdOnThread);
    public static Guid GetActivityIdFromThread();
    private void SetActivityIdOnThread();
}
internal interface System.Runtime.Diagnostics.ITraceSourceStringProvider {
    public abstract virtual string GetSourceString();
}
internal class System.Runtime.Diagnostics.StringTraceRecord : TraceRecord {
    private string _elementName;
    private string _content;
    internal string EventId { get; }
    internal StringTraceRecord(string elementName, string content);
    internal virtual string get_EventId();
    internal virtual void WriteTo(XmlWriter writer);
}
public class System.Runtime.Diagnostics.TraceRecord : object {
    protected static string EventIdBase;
    protected static string NamespaceSuffix;
    internal string EventId { get; }
    internal virtual string get_EventId();
    internal virtual void WriteTo(XmlWriter writer);
    protected string BuildEventId(string eventId);
    protected string XmlEncode(string text);
}
internal class System.Runtime.ExceptionTrace : object {
    private static ushort FailFastEventLogCategory;
    internal static int MaxExceptionStringLength;
    private string _eventSourceName;
    private EtwDiagnosticTrace _diagnosticTrace;
    public ExceptionTrace(string eventSourceName, EtwDiagnosticTrace diagnosticTrace);
    public void TraceEtwException(Exception exception, EventLevel eventLevel);
    public void TraceEtwException(Exception exception, TraceEventType eventLevel);
    public void AsInformation(Exception exception);
    public void AsWarning(Exception exception);
    public Exception AsError(Exception exception);
    public Exception AsError(Exception exception, string eventSource);
    public Exception AsError(TargetInvocationException targetInvocationException, string eventSource);
    public Exception AsError(AggregateException aggregateException);
    public Exception AsError(AggregateException aggregateException, string eventSource);
    public ArgumentException Argument(string paramName, string message);
    public ArgumentNullException ArgumentNull(string paramName);
    public ArgumentNullException ArgumentNull(string paramName, string message);
    public ArgumentException ArgumentNullOrEmpty(string paramName);
    public ArgumentOutOfRangeException ArgumentOutOfRange(string paramName, object actualValue, string message);
    public ObjectDisposedException ObjectDisposed(string message);
    public void TraceHandledException(Exception exception, TraceEventType traceEventType);
    public void TraceUnhandledException(Exception exception);
    private TException TraceException(TException exception);
    private TException TraceException(TException exception, string eventSource);
    private void BreakOnException(Exception exception);
    internal void TraceFailFast(string message);
}
internal class System.Runtime.FatalException : Exception {
    public FatalException(string message);
    public FatalException(string message, Exception innerException);
    protected FatalException(SerializationInfo info, StreamingContext context);
}
internal static class System.Runtime.Fx : object {
    private static string DefaultEventSource;
    private static ExceptionTrace s_exceptionTrace;
    private static EtwDiagnosticTrace s_diagnosticTrace;
    private static Nullable`1<bool> s_isUap;
    private static ExceptionHandler s_asynchronousThreadExceptionHandler;
    internal static bool IsUap { get; }
    internal static ExceptionTrace Exception { get; }
    internal static EtwDiagnosticTrace Trace { get; }
    public static ExceptionHandler AsynchronousThreadExceptionHandler { get; public set; }
    internal static bool AssertsFailFast { get; }
    internal static Type[] BreakOnExceptionTypes { get; }
    internal static bool StealthDebugger { get; }
    internal static bool get_IsUap();
    internal static ExceptionTrace get_Exception();
    internal static EtwDiagnosticTrace get_Trace();
    private static EtwDiagnosticTrace InitializeTracing();
    public static ExceptionHandler get_AsynchronousThreadExceptionHandler();
    public static void set_AsynchronousThreadExceptionHandler(ExceptionHandler value);
    [ConditionalAttribute("DEBUG")]
public static void Assert(bool condition, string description);
    [ConditionalAttribute("DEBUG")]
public static void Assert(string description);
    public static void AssertAndThrow(bool condition, string description);
    public static Exception AssertAndThrow(string description);
    public static void AssertAndThrowFatal(bool condition, string description);
    public static Exception AssertAndThrowFatal(string description);
    public static void AssertAndFailFast(bool condition, string description);
    [SecuritySafeCriticalAttribute]
public static Exception AssertAndFailFast(string description);
    public static bool IsFatal(Exception exception);
    internal static bool get_AssertsFailFast();
    internal static Type[] get_BreakOnExceptionTypes();
    internal static bool get_StealthDebugger();
    public static AsyncCallback ThunkCallback(AsyncCallback callback);
    public static Action`1<T1> ThunkCallback(Action`1<T1> callback);
    [SupportedOSPlatformAttribute("windows")]
public static IOCompletionCallback ThunkCallback(IOCompletionCallback callback);
    public static Guid CreateGuid(string guidString);
    public static bool TryCreateGuid(string guidString, Guid& result);
    public static Byte[] AllocateByteArray(int size);
    public static Char[] AllocateCharArray(int size);
    private static void TraceExceptionNoThrow(Exception exception);
    private static bool HandleAtThreadBase(Exception exception);
    private static void UpdateLevel(EtwDiagnosticTrace trace);
    private static void UpdateLevel();
}
internal static class System.Runtime.FxCop : object {
}
internal class System.Runtime.InputQueue`1 : object {
    private static Action`1<object> s_completeOutstandingReadersCallback;
    private static Action`1<object> s_completeWaitersFalseCallback;
    private static Action`1<object> s_completeWaitersTrueCallback;
    private static Action`1<object> s_onDispatchCallback;
    private static Action`1<object> s_onInvokeDequeuedCallback;
    private QueueState<T> _queueState;
    private ItemQueue<T> _itemQueue;
    private Queue`1<IQueueReader<T>> _readerQueue;
    private List`1<IQueueWaiter<T>> _waiterList;
    [CompilerGeneratedAttribute]
private Action`1<T> <DisposeItemCallback>k__BackingField;
    [CompilerGeneratedAttribute]
private Func`1<Action`2<AsyncCallback, IAsyncResult>> <AsyncCallbackGenerator>k__BackingField;
    public int PendingCount { get; }
    public Action`1<T> DisposeItemCallback { get; public set; }
    private Func`1<Action`2<AsyncCallback, IAsyncResult>> AsyncCallbackGenerator { get; private set; }
    private object ThisLock { get; }
    public InputQueue`1(Func`1<Action`2<AsyncCallback, IAsyncResult>> asyncCallbackGenerator);
    public int get_PendingCount();
    [CompilerGeneratedAttribute]
public Action`1<T> get_DisposeItemCallback();
    [CompilerGeneratedAttribute]
public void set_DisposeItemCallback(Action`1<T> value);
    [CompilerGeneratedAttribute]
private Func`1<Action`2<AsyncCallback, IAsyncResult>> get_AsyncCallbackGenerator();
    [CompilerGeneratedAttribute]
private void set_AsyncCallbackGenerator(Func`1<Action`2<AsyncCallback, IAsyncResult>> value);
    private object get_ThisLock();
    public IAsyncResult BeginDequeue(TimeSpan timeout, AsyncCallback callback, object state);
    public IAsyncResult BeginWaitForItem(TimeSpan timeout, AsyncCallback callback, object state);
    public void Close();
    public T Dequeue(TimeSpan timeout);
    [AsyncStateMachineAttribute("System.Runtime.InputQueue`1/<DequeueAsync>d__27")]
public Task`1<T> DequeueAsync(TimeSpan timeout);
    [AsyncStateMachineAttribute("System.Runtime.InputQueue`1/<TryDequeueAsync>d__28")]
public Task`1<ValueTuple`2<bool, T>> TryDequeueAsync(TimeSpan timeout);
    public bool Dequeue(TimeSpan timeout, T& value);
    public void Dispatch();
    public bool EndDequeue(IAsyncResult result, T& value);
    public T EndDequeue(IAsyncResult result);
    public bool EndWaitForItem(IAsyncResult result);
    public void EnqueueAndDispatch(T item);
    public void EnqueueAndDispatch(T item, Action dequeuedCallback);
    public void EnqueueAndDispatch(Exception exception, Action dequeuedCallback, bool canDispatchOnThisThread);
    public void EnqueueAndDispatch(T item, Action dequeuedCallback, bool canDispatchOnThisThread);
    public bool EnqueueWithoutDispatch(T item, Action dequeuedCallback);
    public bool EnqueueWithoutDispatch(Exception exception, Action dequeuedCallback);
    public void Shutdown();
    public void Shutdown(Func`1<Exception> pendingExceptionGenerator);
    public bool WaitForItem(TimeSpan timeout);
    public Task`1<bool> WaitForItemAsync(TimeSpan timeout);
    public sealed virtual void Dispose();
    private void DisposeItem(Item<T> item);
    private static void CompleteOutstandingReadersCallback(object state);
    private static void CompleteWaiters(bool itemAvailable, IQueueWaiter[] waiters);
    private static void CompleteWaitersFalseCallback(object state);
    private static void CompleteWaitersLater(bool itemAvailable, IQueueWaiter[] waiters);
    private static void CompleteWaitersTrueCallback(object state);
    private static void InvokeDequeuedCallback(Action dequeuedCallback);
    private static void InvokeDequeuedCallbackLater(Action dequeuedCallback);
    private static void OnDispatchCallback(object state);
    private static void OnInvokeDequeuedCallback(object state);
    private void EnqueueAndDispatch(Item<T> item, bool canDispatchOnThisThread);
    private bool EnqueueWithoutDispatch(Item<T> item);
    private void GetWaiters(IQueueWaiter[]& waiters);
    private bool RemoveReader(IQueueReader<T> reader);
}
internal abstract class System.Runtime.InternalBufferManager : object {
    public abstract virtual Byte[] TakeBuffer(int bufferSize);
    public abstract virtual void ReturnBuffer(Byte[] buffer);
    public abstract virtual void Clear();
    public static InternalBufferManager Create(long maxBufferPoolSize, int maxBufferSize);
}
internal class System.Runtime.InternalSR : object {
    internal static string ActionItemIsAlreadyScheduled;
    internal static string AsyncCallbackThrewException;
    internal static string AsyncResultAlreadyEnded;
    internal static string BufferIsNotRightSizeForBufferManager;
    internal static string InvalidAsyncResult;
    internal static string InvalidAsyncResultImplementationGeneric;
    internal static string InvalidNullAsyncResult;
    internal static string InvalidSemaphoreExit;
    internal static string ReadNotSupported;
    internal static string SeekNotSupported;
    internal static string ValueMustBeNonNegative;
    private static InternalSR();
    internal static string ArgumentNullOrEmpty(object param0);
    internal static string AsyncResultCompletedTwice(object param0);
    internal static string BufferedOutputStreamQuotaExceeded(object param0);
    internal static string BufferAllocationFailed(int size);
    internal static string FailFastMessage(object param0);
    internal static string InvalidAsyncResultImplementation(object param0);
    internal static string ShipAssertExceptionMessage(object param0);
    internal static string TaskTimedOutError(object param0);
    internal static string TimeoutInputQueueDequeue(object param0);
    internal static string TimeoutMustBeNonNegative(object param0, object param1);
    internal static string TimeoutMustBePositive(object param0, object param1);
}
internal class System.Runtime.IOThreadScheduler : object {
    private static int MaximumCapacity;
    private static IOThreadScheduler s_current;
    private static SynchronizationContext s_syncContext;
    private static TaskScheduler s_IOTaskScheduler;
    private ScheduledOverlapped _overlapped;
    private Slot[] _slots;
    private static ThreadLocal`1<bool> s_isIoThread;
    private int _headTail;
    public static TaskScheduler IOTaskScheduler { get; }
    private int SlotMask { get; }
    public static bool IsRunningOnIOThread { get; }
    private IOThreadScheduler(int capacity);
    private static IOThreadScheduler();
    public static TaskScheduler get_IOTaskScheduler();
    public static void ScheduleCallbackNoFlow(Action`1<object> callback, object state);
    public static void ScheduleCallbackLowPriNoFlow(Action`1<object> callback, object state);
    private bool ScheduleCallbackHelper(Action`1<object> callback, object state);
    private void CompletionCallback(Action`1& callback, Object& state);
    private bool TryCoalesce(Action`1& callback, Object& state);
    private int get_SlotMask();
    public static bool get_IsRunningOnIOThread();
    protected virtual override void Finalize();
    private void Cleanup();
}
internal class System.Runtime.IOThreadTimer : object {
    private static int maxSkewInMillisecondsDefault;
    private Action`1<object> callback;
    private Func`2<object, Task> asyncCallback;
    private object callbackState;
    private long dueTime;
    private int index;
    private long maxSkew;
    private TimerGroup timerGroup;
    private bool isAsyncCallback;
    public IOThreadTimer(Func`2<object, Task> asyncCallback, object callbackState, bool isTypicallyCanceledShortlyAfterBeingSet);
    public IOThreadTimer(Action`1<object> callback, object callbackState, bool isTypicallyCanceledShortlyAfterBeingSet);
    public IOThreadTimer(Action`1<object> callback, Func`2<object, Task> asyncCallback, object callbackState, bool isTypicallyCanceledShortlyAfterBeingSet, int maxSkewInMilliseconds);
    public bool Cancel();
    public void Set(TimeSpan timeFromNow);
    public void Set(int millisecondsFromNow);
    public void SetAt(long dueTime);
    protected void Reinitialize(Action`1<object> callback, object callbackState);
    internal static void KillTimers();
}
internal class System.Runtime.MruCache`2 : object {
    private LinkedList`1<TKey> _mruList;
    private Dictionary`2<TKey, CacheEntry<TKey, TValue>> _items;
    private int _lowWatermark;
    private int _highWatermark;
    private CacheEntry<TKey, TValue> _mruEntry;
    private int _refCount;
    private object _mutex;
    [CompilerGeneratedAttribute]
private bool <IsDisposed>k__BackingField;
    public int Count { get; }
    public bool IsDisposed { get; private set; }
    public MruCache`2(int watermark);
    public MruCache`2(int lowWatermark, int highWatermark);
    public MruCache`2(int lowWatermark, int highWatermark, IEqualityComparer`1<TKey> comparer);
    public bool AddRef();
    public int get_Count();
    [CompilerGeneratedAttribute]
public bool get_IsDisposed();
    [CompilerGeneratedAttribute]
private void set_IsDisposed(bool value);
    public void Add(TKey key, TValue value);
    public void Clear();
    private void Clear(bool dispose);
    public bool Remove(TKey key);
    protected virtual void OnSingleItemRemoved(TValue item);
    protected virtual void OnItemAgedOutOfCache(TValue item);
    public bool TryGetValue(TKey key, TValue& value);
    public sealed virtual void Dispose();
    protected virtual void Dispose(bool disposing);
    private void ThrowIfDisposed();
}
public class System.Runtime.OutWrapper`1 : object {
    [CompilerGeneratedAttribute]
private T <Value>k__BackingField;
    public T Value { get; public set; }
    [CompilerGeneratedAttribute]
public T get_Value();
    [CompilerGeneratedAttribute]
public void set_Value(T value);
    public static T op_Implicit(OutWrapper`1<T> wrapper);
}
internal class System.Runtime.Remoting.Metadata.W3cXsd2001.SoapHexBinary : object {
    private StringBuilder _sb;
    [CompilerGeneratedAttribute]
private Byte[] <Value>k__BackingField;
    public Byte[] Value { get; public set; }
    public SoapHexBinary(Byte[] value);
    [CompilerGeneratedAttribute]
public Byte[] get_Value();
    [CompilerGeneratedAttribute]
public void set_Value(Byte[] value);
    public virtual string ToString();
    public static SoapHexBinary Parse(string value);
    private static Byte[] ToByteArray(string value);
    private static byte ToByte(char c, string value);
    internal static string FilterBin64(string value);
}
internal abstract class System.Runtime.ScheduleActionItemAsyncResult : AsyncResult {
    private static Action`1<object> s_doWork;
    protected ScheduleActionItemAsyncResult(AsyncCallback callback, object state);
    private static ScheduleActionItemAsyncResult();
    protected void Schedule();
    private static void DoWork(object state);
    protected abstract virtual void OnDoWork();
    public static void End(IAsyncResult result);
}
public class System.Runtime.Serialization.GeneratedXmlSerializers : object {
    private static Dictionary`2<string, Type> s_generatedSerializers;
    public static bool IsInitialized { get; }
    private static GeneratedXmlSerializers();
    public static Dictionary`2<string, Type> GetGeneratedSerializers();
    public static bool get_IsInitialized();
}
internal class System.Runtime.ServiceModelSynchronizationContext : SynchronizationContext {
    public static ServiceModelSynchronizationContext Instance;
    private static ServiceModelSynchronizationContext();
    public virtual void Post(SendOrPostCallback d, object state);
}
internal class System.Runtime.SignalGate : object {
    private int _state;
    internal bool IsLocked { get; }
    internal bool IsSignalled { get; }
    internal bool get_IsLocked();
    internal bool get_IsSignalled();
    public bool Signal();
    public bool Unlock();
    private void ThrowInvalidSignalGateState();
}
internal class System.Runtime.SignalGate`1 : SignalGate {
    private T _result;
    public bool Signal(T result);
    public bool Unlock(T& result);
}
internal class System.Runtime.SynchronizedPool`1 : object {
    private static int MaxPendingEntries;
    private static int MaxPromotionFailures;
    private static int MaxReturnsBeforePromotion;
    private static int MaxThreadItemsPerProcessor;
    private Entry[] _entries;
    private GlobalPool<T> _globalPool;
    private int _maxCount;
    private PendingEntry[] _pending;
    private int _promotionFailures;
    private object ThisLock { get; }
    public SynchronizedPool`1(int maxCount);
    private object get_ThisLock();
    public void Clear();
    private void HandlePromotionFailure(int thisThreadID);
    private bool PromoteThread(int thisThreadID);
    private void RecordReturnToGlobalPool(int thisThreadID);
    private void RecordTakeFromGlobalPool(int thisThreadID);
    public bool Return(T value);
    private bool ReturnToPerThreadPool(int thisThreadID, T value);
    private bool ReturnToGlobalPool(int thisThreadID, T value);
    public T Take();
    private T TakeFromPerThreadPool(int thisThreadID);
    private T TakeFromGlobalPool(int thisThreadID);
}
[ExtensionAttribute]
public static class System.Runtime.TaskHelpers : object {
    public static Action`1<object> OnAsyncCompletionCallback;
    private static TaskHelpers();
    [AsyncStateMachineAttribute("System.Runtime.TaskHelpers/<AsyncWait>d__0`1")]
[ExtensionAttribute]
public static Task AsyncWait(Task task);
    [ExtensionAttribute]
public static Task`1<TResult> ToApm(Task`1<TResult> task, AsyncCallback callback, object state);
    [ExtensionAttribute]
public static Task ToApm(Task task, AsyncCallback callback, object state);
    [ExtensionAttribute]
public static TResult ToApmEnd(IAsyncResult iar);
    [ExtensionAttribute]
public static void ToApmEnd(IAsyncResult iar);
    public static Task`1<ValueTuple`2<TOut1, TOut2>> FromAsync(Func`4<TIn, AsyncCallback, object, IAsyncResult> beginDelegate, EndWithOutDelegate`2<TOut2, TOut1> endDelegate, TIn arg1, object state);
    [ExtensionAttribute]
public static Task CloseHelperAsync(ICommunicationObject communicationObject, TimeSpan timeout);
    [ExtensionAttribute]
public static Task OpenHelperAsync(ICommunicationObject communicationObject, TimeSpan timeout);
    [AsyncStateMachineAttribute("System.Runtime.TaskHelpers/<AwaitWithTimeout>d__9")]
[ExtensionAttribute]
public static Task`1<bool> AwaitWithTimeout(Task task, TimeSpan timeout);
    [ExtensionAttribute]
public static void WaitForCompletion(Task task);
    [ExtensionAttribute]
public static void WaitForCompletionNoSpin(Task task);
    [ExtensionAttribute]
public static TResult WaitForCompletion(Task`1<TResult> task);
    [ExtensionAttribute]
public static TResult WaitForCompletionNoSpin(Task`1<TResult> task);
    [ExtensionAttribute]
public static bool WaitForCompletionNoSpin(Task task, TimeSpan timeout);
    [ExtensionAttribute]
public static void Wait(Task task, TimeSpan timeout, Action`3<Exception, TimeSpan, string> exceptionConverter, string operationType);
    public static Task CompletedTask();
    public static DefaultTaskSchedulerAwaiter EnsureDefaultTaskScheduler();
    private static void OnAsyncCompletion(object state);
    public static IDisposable RunTaskContinuationsOnOurThreads();
    [AsyncStateMachineAttribute("System.Runtime.TaskHelpers/<CallActionAsync>d__21`1")]
public static Task CallActionAsync(Action`1<TArg> action, TArg argument);
}
internal static class System.Runtime.Ticks : object {
    public static long Now { get; }
    [SecuritySafeCriticalAttribute]
public static long get_Now();
    public static long FromMilliseconds(int milliseconds);
    public static int ToMilliseconds(long ticks);
    public static long FromTimeSpan(TimeSpan duration);
    public static TimeSpan ToTimeSpan(long ticks);
    public static long Add(long firstTicks, long secondTicks);
}
internal class System.Runtime.TimeoutHelper : ValueType {
    public static TimeSpan MaxWait;
    private static CancellationToken s_precancelledToken;
    private bool _cancellationTokenInitialized;
    private bool _deadlineSet;
    private CancellationToken _cancellationToken;
    private DateTime _deadline;
    [CompilerGeneratedAttribute]
private TimeSpan <OriginalTimeout>k__BackingField;
    public TimeSpan OriginalTimeout { get; }
    public TimeoutHelper(TimeSpan timeout);
    private static TimeoutHelper();
    public CancellationToken GetCancellationToken();
    [AsyncStateMachineAttribute("System.Runtime.TimeoutHelper/<GetCancellationTokenAsync>d__8")]
public Task`1<CancellationToken> GetCancellationTokenAsync();
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public TimeSpan get_OriginalTimeout();
    public static bool IsTooLarge(TimeSpan timeout);
    public static TimeSpan FromMilliseconds(int milliseconds);
    public static int ToMilliseconds(TimeSpan timeout);
    public static TimeSpan Min(TimeSpan val1, TimeSpan val2);
    public static TimeSpan Add(TimeSpan timeout1, TimeSpan timeout2);
    public static DateTime Add(DateTime time, TimeSpan timeout);
    public static DateTime Subtract(DateTime time, TimeSpan timeout);
    public static TimeSpan Divide(TimeSpan timeout, int factor);
    public TimeSpan RemainingTime();
    public TimeSpan ElapsedTime();
    private void SetDeadline();
    public static void ThrowIfNegativeArgument(TimeSpan timeout);
    public static void ThrowIfNegativeArgument(TimeSpan timeout, string argumentName);
    public static void ThrowIfNonPositiveArgument(TimeSpan timeout);
    public static void ThrowIfNonPositiveArgument(TimeSpan timeout, string argumentName);
    public static bool WaitOne(WaitHandle waitHandle, TimeSpan timeout);
    public static bool Wait(ManualResetEventSlim mres, TimeSpan timeout);
    internal static TimeoutException CreateEnterTimedOutException(TimeSpan timeout);
}
internal static class System.Runtime.TimeoutTokenSource : object {
    private static int CoalescingFactor;
    private static int GranularityFactor;
    private static int SegmentationFactor;
    private static ConcurrentDictionary`2<long, Task`1<CancellationToken>> s_tokenCache;
    private static Action`1<object> s_deregisterToken;
    private static TimeoutTokenSource();
    public static CancellationToken FromTimeout(int millisecondsTimeout);
    public static Task`1<CancellationToken> FromTimeoutAsync(int millisecondsTimeout);
}
internal enum System.Runtime.TraceChannel : Enum {
    public int value__;
    public static TraceChannel Admin;
    public static TraceChannel Operational;
    public static TraceChannel Analytic;
    public static TraceChannel Debug;
    public static TraceChannel Perf;
    public static TraceChannel Application;
}
internal class System.Runtime.TraceCore : object {
    private static ResourceManager resourceManager;
    private static CultureInfo resourceCulture;
    private static int MaxExceptionStringLength;
    private static object syncLock;
    private static ResourceManager ResourceManager { get; }
    internal static CultureInfo Culture { get; internal set; }
    private static TraceCore();
    private static ResourceManager get_ResourceManager();
    internal static CultureInfo get_Culture();
    internal static void set_Culture(CultureInfo value);
    internal static bool HandledExceptionIsEnabled(EtwDiagnosticTrace trace);
    internal static void HandledException(EtwDiagnosticTrace trace, string param0, Exception exception);
    internal static bool HandledExceptionErrorIsEnabled(EtwDiagnosticTrace trace);
    internal static void HandledExceptionError(EtwDiagnosticTrace trace, string param0, Exception exception);
    internal static bool HandledExceptionVerboseIsEnabled(EtwDiagnosticTrace trace);
    internal static void HandledExceptionVerbose(EtwDiagnosticTrace trace, string param0, Exception exception);
    internal static bool HandledExceptionWarningIsEnabled(EtwDiagnosticTrace trace);
    internal static void HandledExceptionWarning(EtwDiagnosticTrace trace, string param0, Exception exception);
    internal static void ShipAssertExceptionMessage(EtwDiagnosticTrace trace, string param0);
    internal static bool ThrowingExceptionIsEnabled(EtwDiagnosticTrace trace);
    internal static void ThrowingException(EtwDiagnosticTrace trace, string param0, string param1, Exception exception);
    internal static bool UnhandledExceptionIsEnabled(EtwDiagnosticTrace trace);
    internal static void UnhandledException(EtwDiagnosticTrace trace, string param0, Exception exception);
    internal static bool TraceCodeEventLogCriticalIsEnabled(EtwDiagnosticTrace trace);
    internal static void TraceCodeEventLogCritical(EtwDiagnosticTrace trace, TraceRecord traceRecord);
    internal static bool TraceCodeEventLogErrorIsEnabled(EtwDiagnosticTrace trace);
    internal static void TraceCodeEventLogError(EtwDiagnosticTrace trace, TraceRecord traceRecord);
    internal static bool TraceCodeEventLogInfoIsEnabled(EtwDiagnosticTrace trace);
    internal static void TraceCodeEventLogInfo(EtwDiagnosticTrace trace, TraceRecord traceRecord);
    internal static bool TraceCodeEventLogVerboseIsEnabled(EtwDiagnosticTrace trace);
    internal static void TraceCodeEventLogVerbose(EtwDiagnosticTrace trace, TraceRecord traceRecord);
    internal static bool TraceCodeEventLogWarningIsEnabled(EtwDiagnosticTrace trace);
    internal static void TraceCodeEventLogWarning(EtwDiagnosticTrace trace, TraceRecord traceRecord);
    internal static bool BufferPoolAllocationIsEnabled(EtwDiagnosticTrace trace);
    internal static void BufferPoolAllocation(EtwDiagnosticTrace trace, int Size);
    internal static bool BufferPoolChangeQuotaIsEnabled(EtwDiagnosticTrace trace);
    internal static void BufferPoolChangeQuota(EtwDiagnosticTrace trace, int PoolSize, int Delta);
    internal static bool ActionItemScheduledIsEnabled(EtwDiagnosticTrace trace);
    internal static void ActionItemScheduled(EtwDiagnosticTrace trace, EventTraceActivity eventTraceActivity);
    internal static bool ActionItemCallbackInvokedIsEnabled(EtwDiagnosticTrace trace);
    internal static void ActionItemCallbackInvoked(EtwDiagnosticTrace trace, EventTraceActivity eventTraceActivity);
    internal static bool EtwUnhandledExceptionIsEnabled(EtwDiagnosticTrace trace);
    internal static void EtwUnhandledException(EtwDiagnosticTrace trace, string param0, Exception exception);
    internal static bool ThrowingEtwExceptionIsEnabled(EtwDiagnosticTrace trace);
    internal static void ThrowingEtwException(EtwDiagnosticTrace trace, string param0, string param1, Exception exception);
    internal static bool ThrowingEtwExceptionVerboseIsEnabled(EtwDiagnosticTrace trace);
    internal static void ThrowingEtwExceptionVerbose(EtwDiagnosticTrace trace, string param0, string param1, Exception exception);
    internal static bool ThrowingExceptionVerboseIsEnabled(EtwDiagnosticTrace trace);
    internal static void ThrowingExceptionVerbose(EtwDiagnosticTrace trace, string param0, string param1, Exception exception);
}
internal class System.Runtime.TracePayload : ValueType {
    private string _hostReference;
    [CompilerGeneratedAttribute]
private string <SerializedException>k__BackingField;
    [CompilerGeneratedAttribute]
private string <EventSource>k__BackingField;
    [CompilerGeneratedAttribute]
private string <AppDomainFriendlyName>k__BackingField;
    [CompilerGeneratedAttribute]
private string <ExtendedData>k__BackingField;
    public string SerializedException { get; }
    public string EventSource { get; }
    public string AppDomainFriendlyName { get; }
    public string ExtendedData { get; }
    public string HostReference { get; }
    public TracePayload(string serializedException, string eventSource, string appDomainFriendlyName, string extendedData, string hostReference);
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public string get_SerializedException();
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public string get_EventSource();
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public string get_AppDomainFriendlyName();
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public string get_ExtendedData();
    public string get_HostReference();
}
internal static class System.Runtime.UrlUtility : object {
    private static Encoding s_asciiEncoding;
    private static Encoding AsciiEncoding { get; }
    private static Encoding get_AsciiEncoding();
    public static NameValueCollection ParseQueryString(string query);
    public static NameValueCollection ParseQueryString(string query, Encoding encoding);
    public static string UrlEncode(string str);
    public static string UrlPathEncode(string str);
    public static string UrlEncode(string str, Encoding encoding);
    public static string UrlEncodeUnicode(string str);
    private static string UrlEncodeUnicodeStringToStringInternal(string s, bool ignoreAscii);
    private static string UrlEncodeNonAscii(string str, Encoding e);
    private static string UrlEncodeSpaces(string str);
    public static Byte[] UrlEncodeToBytes(string str, Encoding e);
    public static string UrlDecode(string str, Encoding e);
    private static Byte[] UrlEncodeBytesToBytesInternal(Byte[] bytes, int offset, int count, bool alwaysCreateReturnValue);
    private static bool IsNonAsciiByte(byte b);
    private static Byte[] UrlEncodeBytesToBytesInternalNonAscii(Byte[] bytes, int offset, int count, bool alwaysCreateReturnValue);
    private static string UrlDecodeStringFromStringInternal(string s, Encoding e);
    private static int HexToInt(char h);
    private static char IntToHex(int n);
    internal static bool IsSafe(char ch);
}
internal static class System.Runtime.WaitCallbackActionItem : object {
    [CompilerGeneratedAttribute]
private static bool <ShouldUseActivity>k__BackingField;
    internal static bool ShouldUseActivity { get; internal set; }
    [CompilerGeneratedAttribute]
internal static bool get_ShouldUseActivity();
    [CompilerGeneratedAttribute]
internal static void set_ShouldUseActivity(bool value);
}
[EventSourceAttribute]
internal class System.Runtime.WcfEventSource : EventSource {
    public static WcfEventSource Instance;
    private bool _canTransferActivityId;
    private static WcfEventSource();
    public bool ActionItemScheduledIsEnabled();
    [EventAttribute("133")]
public void ActionItemScheduled(string AppDomain);
    [NonEventAttribute]
public void ActionItemScheduled();
    public bool ActionItemCallbackInvokedIsEnabled();
    [EventAttribute("134")]
public void ActionItemCallbackInvoked(string AppDomain);
    [NonEventAttribute]
public void ActionItemCallbackInvoked();
    public bool BufferPoolAllocationIsEnabled();
    [EventAttribute("131")]
public void BufferPoolAllocation(int Size, string AppDomain);
    [NonEventAttribute]
public void BufferPoolAllocation(int Size);
    public bool BufferPoolChangeQuotaIsEnabled();
    [EventAttribute("132")]
public void BufferPoolChangeQuota(int PoolSize, int Delta, string AppDomain);
    [NonEventAttribute]
public void BufferPoolChangeQuota(int PoolSize, int Delta);
    public bool ClientMessageInspectorAfterReceiveInvokedIsEnabled();
    [EventAttribute("201")]
public void ClientMessageInspectorAfterReceiveInvoked(string TypeName, string HostReference, string AppDomain);
    [NonEventAttribute]
public void ClientMessageInspectorAfterReceiveInvoked(EventTraceActivity eventTraceActivity, string TypeName);
    public bool ClientMessageInspectorBeforeSendInvokedIsEnabled();
    [EventAttribute("202")]
public void ClientMessageInspectorBeforeSendInvoked(string TypeName, string HostReference, string AppDomain);
    [NonEventAttribute]
public void ClientMessageInspectorBeforeSendInvoked(EventTraceActivity eventTraceActivity, string TypeName);
    public bool ClientParameterInspectorAfterCallInvokedIsEnabled();
    [EventAttribute("203")]
public void ClientParameterInspectorAfterCallInvoked(string TypeName, string HostReference, string AppDomain);
    [NonEventAttribute]
public void ClientParameterInspectorAfterCallInvoked(EventTraceActivity eventTraceActivity, string TypeName);
    public bool ClientParameterInspectorBeforeCallInvokedIsEnabled();
    [EventAttribute("204")]
public void ClientParameterInspectorBeforeCallInvoked(string TypeName, string HostReference, string AppDomain);
    [NonEventAttribute]
public void ClientParameterInspectorBeforeCallInvoked(EventTraceActivity eventTraceActivity, string TypeName);
    public bool OperationInvokedIsEnabled();
    [EventAttribute("205")]
public void OperationInvoked(string MethodName, string CallerInfo, string HostReference, string AppDomain);
    [NonEventAttribute]
public void OperationInvoked(EventTraceActivity eventTraceActivity, string MethodName, string CallerInfo);
    public bool OutboundConnectionsPerEndpointRatioIsEnabled();
    [EventAttribute("1433")]
public void OutboundConnectionsPerEndpointRatio(int cur, int max, string AppDomain);
    [NonEventAttribute]
public void OutboundConnectionsPerEndpointRatio(int cur, int max);
    public bool ErrorHandlerInvokedIsEnabled();
    [EventAttribute("206")]
public void ErrorHandlerInvoked(string TypeName, bool Handled, string ExceptionTypeName, string HostReference, string AppDomain);
    [NonEventAttribute]
public void ErrorHandlerInvoked(string TypeName, bool Handled, string ExceptionTypeName);
    public bool FaultProviderInvokedIsEnabled();
    [EventAttribute("207")]
public void FaultProviderInvoked(string TypeName, string ExceptionTypeName, string HostReference, string AppDomain);
    [NonEventAttribute]
public void FaultProviderInvoked(string TypeName, string ExceptionTypeName);
    public bool MessageInspectorAfterReceiveInvokedIsEnabled();
    [EventAttribute("208")]
public void MessageInspectorAfterReceiveInvoked(string TypeName, string HostReference, string AppDomain);
    [NonEventAttribute]
public void MessageInspectorAfterReceiveInvoked(EventTraceActivity eventTraceActivity, string TypeName);
    public bool MessageInspectorBeforeSendInvokedIsEnabled();
    [EventAttribute("209")]
public void MessageInspectorBeforeSendInvoked(string TypeName, string HostReference, string AppDomain);
    [NonEventAttribute]
public void MessageInspectorBeforeSendInvoked(EventTraceActivity eventTraceActivity, string TypeName);
    public bool ParameterInspectorAfterCallInvokedIsEnabled();
    [EventAttribute("211")]
public void ParameterInspectorAfterCallInvoked(string TypeName, string HostReference, string AppDomain);
    [NonEventAttribute]
public void ParameterInspectorAfterCallInvoked(EventTraceActivity eventTraceActivity, string TypeName);
    public bool ParameterInspectorBeforeCallInvokedIsEnabled();
    [EventAttribute("212")]
public void ParameterInspectorBeforeCallInvoked(string TypeName, string HostReference, string AppDomain);
    [NonEventAttribute]
public void ParameterInspectorBeforeCallInvoked(EventTraceActivity eventTraceActivity, string TypeName);
    public bool OperationCompletedIsEnabled();
    [EventAttribute("214")]
public void OperationCompleted(string MethodName, long Duration, string HostReference, string AppDomain);
    [NonEventAttribute]
public void OperationCompleted(EventTraceActivity eventTraceActivity, string MethodName, long Duration);
    public bool ClientOperationPreparedIsEnabled();
    [EventAttribute("217")]
public void ClientOperationPrepared(Guid relatedActivityId, string Action, string ContractName, string Destination, string HostReference, string AppDomain);
    [NonEventAttribute]
public void ClientOperationPrepared(EventTraceActivity eventTraceActivity, string Action, string ContractName, string Destination, Guid relatedActivityId);
    public bool ServiceChannelCallStopIsEnabled();
    [EventAttribute("218")]
public void ServiceChannelCallStop(string Action, string ContractName, string Destination, string HostReference, string AppDomain);
    [NonEventAttribute]
public void ServiceChannelCallStop(EventTraceActivity eventTraceActivity, string Action, string ContractName, string Destination);
    public bool ServiceExceptionIsEnabled();
    [EventAttribute("219")]
public void ServiceException(string ExceptionToString, string ExceptionTypeName, string HostReference, string AppDomain);
    [NonEventAttribute]
public void ServiceException(string ExceptionToString, string ExceptionTypeName);
    public bool MessageSentByTransportIsEnabled();
    [EventAttribute("216")]
public void MessageSentByTransport(string DestinationAddress, string HostReference, string AppDomain);
    [NonEventAttribute]
public void MessageSentByTransport(EventTraceActivity eventTraceActivity, string DestinationAddress);
    public bool MessageSentToTransportIsEnabled();
    [EventAttribute("220")]
public void MessageSentToTransport(Guid CorrelationId, string HostReference, string AppDomain);
    [NonEventAttribute]
public void MessageSentToTransport(EventTraceActivity eventTraceActivity, Guid CorrelationId);
    public bool MessageReceivedByTransportIsEnabled();
    [EventAttribute("215")]
public void MessageReceivedByTransport(Guid relatedActivityId, string ListenAddress, string HostReference, string AppDomain);
    [NonEventAttribute]
public void MessageReceivedByTransport(EventTraceActivity eventTraceActivity, string ListenAddress, Guid relatedActivityId);
    public bool MessageReceivedFromTransportIsEnabled();
    [EventAttribute("221")]
public void MessageReceivedFromTransport(Guid CorrelationId, string HostReference, string AppDomain);
    [NonEventAttribute]
public void MessageReceivedFromTransport(EventTraceActivity eventTraceActivity, Guid CorrelationId, string HostReference);
    public bool OperationFailedIsEnabled();
    [EventAttribute("222")]
public void OperationFailed(string MethodName, long Duration, string HostReference, string AppDomain);
    [NonEventAttribute]
public void OperationFailed(EventTraceActivity eventTraceActivity, string MethodName, long Duration);
    public bool OperationFaultedIsEnabled();
    [EventAttribute("223")]
public void OperationFaulted(string MethodName, long Duration, string HostReference, string AppDomain);
    [NonEventAttribute]
public void OperationFaulted(EventTraceActivity eventTraceActivity, string MethodName, long Duration);
    public bool ServiceChannelOpenStartIsEnabled();
    [EventAttribute("701")]
public void ServiceChannelOpenStart(string AppDomain);
    [NonEventAttribute]
public void ServiceChannelOpenStart(EventTraceActivity eventTraceActivity);
    public bool ServiceChannelOpenStopIsEnabled();
    [EventAttribute("702")]
public void ServiceChannelOpenStop(string AppDomain);
    [NonEventAttribute]
public void ServiceChannelOpenStop(EventTraceActivity eventTraceActivity);
    public bool ServiceChannelCallStartIsEnabled();
    [EventAttribute("703")]
public void ServiceChannelCallStart(string AppDomain);
    [NonEventAttribute]
public void ServiceChannelCallStart(EventTraceActivity eventTraceActivity);
    [EventAttribute("704")]
public void ServiceChannelBeginCallStart(string AppDomain);
    [NonEventAttribute]
public void ServiceChannelBeginCallStart(EventTraceActivity eventTraceActivity);
    public bool DispatchMessageStartIsEnabled();
    [EventAttribute("709")]
public void DispatchMessageStart(string HostReference, string AppDomain);
    [NonEventAttribute]
public void DispatchMessageStart(EventTraceActivity eventTraceActivity);
    public bool DispatchMessageStopIsEnabled();
    [EventAttribute("712")]
public void DispatchMessageStop(string AppDomain);
    [NonEventAttribute]
public void DispatchMessageStop(EventTraceActivity eventTraceActivity);
    public bool ClientChannelOpenStartIsEnabled();
    [EventAttribute("715")]
public void ClientChannelOpenStart(string AppDomain);
    [NonEventAttribute]
public void ClientChannelOpenStart(EventTraceActivity eventTraceActivity);
    public bool ClientChannelOpenStopIsEnabled();
    [EventAttribute("716")]
public void ClientChannelOpenStop(string AppDomain);
    [NonEventAttribute]
public void ClientChannelOpenStop(EventTraceActivity eventTraceActivity);
    [EventAttribute("1032")]
public void ScheduleRuntimeWorkItem(string data1, string data2, string data3, string AppDomain);
    public bool IdleTimeoutIsEnabled();
    [EventAttribute("1402")]
public void IdleTimeout(string msg, string key, string AppDomain);
    [NonEventAttribute]
public void IdleTimeout(string msg, string key);
    public bool InactivityTimeoutIsEnabled();
    [EventAttribute("1409")]
public void InactivityTimeout(string data1, string AppDomain);
    [NonEventAttribute]
public void InactivityTimeout(string data1);
    public bool MaxOutboundConnectionsPerEndpointExceededIsEnabled();
    [EventAttribute("1418")]
public void MaxOutboundConnectionsPerEndpointExceeded(string data1, string AppDomain);
    [NonEventAttribute]
public void MaxOutboundConnectionsPerEndpointExceeded(string data1);
    public bool MaxReceivedMessageSizeExceededIsEnabled();
    [EventAttribute("1416")]
public void MaxReceivedMessageSizeExceeded(string data1, string AppDomain);
    [NonEventAttribute]
public void MaxReceivedMessageSizeExceeded(string data1);
    public bool MaxRetryCyclesExceededIsEnabled();
    [EventAttribute("1451")]
public void MaxRetryCyclesExceeded(string data1);
    public bool MaxSentMessageSizeExceededIsEnabled();
    [EventAttribute("1417")]
public void MaxSentMessageSizeExceeded(string data1, string AppDomain);
    [NonEventAttribute]
public void MaxSentMessageSizeExceeded(string data1);
    public bool MaxSessionSizeReachedIsEnabled();
    [EventAttribute("1441")]
public void MaxSessionSizeReached(string data1, string AppDomain);
    [NonEventAttribute]
public void MaxSessionSizeReached(string data1);
    public bool ReadPoolMissIsEnabled();
    [EventAttribute("1445")]
public void ReadPoolMiss(string itemTypeName, string AppDomain);
    [NonEventAttribute]
public void ReadPoolMiss(string itemTypeName);
    public bool WritePoolMissIsEnabled();
    [EventAttribute("1446")]
public void WritePoolMiss(string itemTypeName, string AppDomain);
    [NonEventAttribute]
public void WritePoolMiss(string itemTypeName);
    public bool ClientBaseCachedChannelFactoryCountIsEnabled();
    [EventAttribute("3305")]
public void ClientBaseCachedChannelFactoryCount(int Count, int MaxNum, string EventSource, string AppDomain);
    [NonEventAttribute]
public void ClientBaseCachedChannelFactoryCount(int Count, int MaxNum, object source);
    public bool ClientBaseChannelFactoryAgedOutofCacheIsEnabled();
    [EventAttribute("3306")]
public void ClientBaseChannelFactoryAgedOutofCache(int Count, string EventSource, string AppDomain);
    [NonEventAttribute]
public void ClientBaseChannelFactoryAgedOutofCache(int Count, object source);
    public bool ClientBaseChannelFactoryCacheHitIsEnabled();
    [EventAttribute("3307")]
public void ClientBaseChannelFactoryCacheHit(string EventSource, string AppDomain);
    [NonEventAttribute]
public void ClientBaseChannelFactoryCacheHit(object source);
    public bool ClientBaseUsingLocalChannelFactoryIsEnabled();
    [EventAttribute("3308")]
public void ClientBaseUsingLocalChannelFactory(string EventSource, string AppDomain);
    [NonEventAttribute]
public void ClientBaseUsingLocalChannelFactory(object source);
    public bool MessageReadByEncoderIsEnabled();
    [EventAttribute("3312")]
public void MessageReadByEncoder(int Size, string EventSource, string AppDomain);
    [NonEventAttribute]
public void MessageReadByEncoder(EventTraceActivity eventTraceActivity, int Size, object source);
    public bool MessageWrittenByEncoderIsEnabled();
    [EventAttribute("3313")]
public void MessageWrittenByEncoder(int Size, string EventSource, string AppDomain);
    [NonEventAttribute]
public void MessageWrittenByEncoder(EventTraceActivity eventTraceActivity, int Size, object source);
    public bool SessionIdleTimeoutIsEnabled();
    [EventAttribute("3314")]
public void SessionIdleTimeout(string RemoteAddress, string AppDomain);
    [NonEventAttribute]
public void SessionIdleTimeout(string RemoteAddress);
    public bool SocketReadStopIsEnabled();
    [EventAttribute("3377")]
public void SocketReadStop(int SocketId, int Size, string Endpoint, string AppDomain);
    [NonEventAttribute]
public void SocketReadStop(int SocketId, int Size, string Endpoint);
    public bool SocketAsyncReadStopIsEnabled();
    [EventAttribute("3378")]
public void SocketAsyncReadStop(int SocketId, int Size, string Endpoint, string AppDomain);
    [NonEventAttribute]
public void SocketAsyncReadStop(int SocketId, int Size, string Endpoint);
    public bool SocketWriteStartIsEnabled();
    [EventAttribute("3379")]
public void SocketWriteStart(int SocketId, int Size, string Endpoint, string AppDomain);
    [NonEventAttribute]
public void SocketWriteStart(int SocketId, int Size, string Endpoint);
    public bool SocketAsyncWriteStartIsEnabled();
    [EventAttribute("3380")]
public void SocketAsyncWriteStart(int SocketId, int Size, string Endpoint, string AppDomain);
    [NonEventAttribute]
public void SocketAsyncWriteStart(int SocketId, int Size, string Endpoint);
    public bool SslOnInitiateUpgradeIsEnabled();
    [EventAttribute("3368")]
public void SslOnInitiateUpgrade(string AppDomain);
    [NonEventAttribute]
public void SslOnInitiateUpgrade();
    public bool DispatchFormatterDeserializeRequestStartIsEnabled();
    [EventAttribute("3322")]
public void DispatchFormatterDeserializeRequestStart(string AppDomain);
    [NonEventAttribute]
public void DispatchFormatterDeserializeRequestStart(EventTraceActivity eventTraceActivity);
    public bool DispatchFormatterDeserializeRequestStopIsEnabled();
    [EventAttribute("3323")]
public void DispatchFormatterDeserializeRequestStop(string AppDomain);
    [NonEventAttribute]
public void DispatchFormatterDeserializeRequestStop(EventTraceActivity eventTraceActivity);
    public bool DispatchFormatterSerializeReplyStartIsEnabled();
    [EventAttribute("3324")]
public void DispatchFormatterSerializeReplyStart(string AppDomain);
    [NonEventAttribute]
public void DispatchFormatterSerializeReplyStart(EventTraceActivity eventTraceActivity);
    public bool DispatchFormatterSerializeReplyStopIsEnabled();
    [EventAttribute("3325")]
public void DispatchFormatterSerializeReplyStop(string AppDomain);
    [NonEventAttribute]
public void DispatchFormatterSerializeReplyStop(EventTraceActivity eventTraceActivity);
    public bool ClientFormatterSerializeRequestStartIsEnabled();
    [EventAttribute("3326")]
public void ClientFormatterSerializeRequestStart(string AppDomain);
    [NonEventAttribute]
public void ClientFormatterSerializeRequestStart(EventTraceActivity eventTraceActivity);
    public bool ClientFormatterSerializeRequestStopIsEnabled();
    [EventAttribute("3327")]
public void ClientFormatterSerializeRequestStop(string AppDomain);
    [NonEventAttribute]
public void ClientFormatterSerializeRequestStop(EventTraceActivity eventTraceActivity);
    public bool ClientFormatterDeserializeReplyStartIsEnabled();
    [EventAttribute("3328")]
public void ClientFormatterDeserializeReplyStart(string AppDomain);
    [NonEventAttribute]
public void ClientFormatterDeserializeReplyStart(EventTraceActivity eventTraceActivity);
    public bool ClientFormatterDeserializeReplyStopIsEnabled();
    [EventAttribute("3329")]
public void ClientFormatterDeserializeReplyStop(string AppDomain);
    [NonEventAttribute]
public void ClientFormatterDeserializeReplyStop(EventTraceActivity eventTraceActivity);
    public bool GetServiceInstanceStartIsEnabled();
    [EventAttribute("3335")]
public void GetServiceInstanceStart(string AppDomain);
    [NonEventAttribute]
public void GetServiceInstanceStart(EventTraceActivity eventTraceActivity);
    public bool GetServiceInstanceStopIsEnabled();
    [EventAttribute("3336")]
public void GetServiceInstanceStop(string AppDomain);
    [NonEventAttribute]
public void GetServiceInstanceStop(EventTraceActivity eventTraceActivity);
    public bool HandledExceptionIsEnabled();
    [EventAttribute("57394")]
public void HandledException(string data1, string SerializedException, string AppDomain);
    [NonEventAttribute]
public void HandledException(string data1, string SerializedException);
    public bool HandledExceptionErrorIsEnabled();
    [EventAttribute("57405")]
public void HandledExceptionError(string data1, string SerializedException, string AppDomain);
    [NonEventAttribute]
public void HandledExceptionError(string data1, string SerializedException);
    public bool HandledExceptionVerboseIsEnabled();
    [EventAttribute("57406")]
public void HandledExceptionVerbose(string data1, string SerializedException, string AppDomain);
    [NonEventAttribute]
public void HandledExceptionVerbose(string data1, string SerializedException);
    public bool HandledExceptionWarningIsEnabled();
    [EventAttribute("57404")]
public void HandledExceptionWarning(string data1, string SerializedException, string AppDomain);
    [NonEventAttribute]
public void HandledExceptionWarning(string data1, string SerializedException);
    public bool ThrowingEtwExceptionVerboseIsEnabled();
    [EventAttribute("57409")]
public void ThrowingEtwExceptionVerbose(string data1, string data2, string SerializedException, string AppDomain);
    [NonEventAttribute]
public void ThrowingEtwExceptionVerbose(string data1, string data2, string SerializedException);
    [NonEventAttribute]
public void ThrowingEtwExceptionVerbose(string data1, string data2, Exception exception);
    public bool ChannelReceiveStartIsEnabled();
    [EventAttribute("3337")]
public void ChannelReceiveStart(int ChannelId, string AppDomain);
    [NonEventAttribute]
public void ChannelReceiveStart(EventTraceActivity eventTraceActivity, int ChannelId);
    public bool ChannelReceiveStopIsEnabled();
    [EventAttribute("3338")]
public void ChannelReceiveStop(int ChannelId, string AppDomain);
    [NonEventAttribute]
public void ChannelReceiveStop(EventTraceActivity eventTraceActivity, int ChannelId);
    public bool ChannelFactoryCreatedIsEnabled();
    [EventAttribute("3339")]
public void ChannelFactoryCreated(string EventSource, string AppDomain);
    [NonEventAttribute]
public void ChannelFactoryCreated(object source);
    public bool LeaseTimeoutIsEnabled();
    [EventAttribute("1403")]
public void LeaseTimeout(string msg, string key, string AppDomain);
    [NonEventAttribute]
public void LeaseTimeout(string msg, string key);
    public bool ListenerOpenStartIsEnabled();
    [EventAttribute("3349")]
public void ListenerOpenStart(string Uri, string AppDomain);
    [NonEventAttribute]
public void ListenerOpenStart(EventTraceActivity eventTraceActivity, string Uri, Guid relatedActivityId);
    public bool ListenerOpenStopIsEnabled();
    [EventAttribute("3350")]
public void ListenerOpenStop(string AppDomain);
    [NonEventAttribute]
public void ListenerOpenStop(EventTraceActivity eventTraceActivity);
    public bool SecurityIdentityVerificationFailureIsEnabled();
    [EventAttribute("3357")]
public void SecurityIdentityVerificationFailure(string AppDomain);
    [NonEventAttribute]
public void SecurityIdentityVerificationFailure(EventTraceActivity eventTraceActivity);
    public bool SecurityIdentityVerificationSuccessIsEnabled();
    [EventAttribute("3356")]
public void SecurityIdentityVerificationSuccess(string AppDomain);
    [NonEventAttribute]
public void SecurityIdentityVerificationSuccess(EventTraceActivity eventTraceActivity);
    public bool SecurityTokenProviderOpenedIsEnabled();
    [EventAttribute("3332")]
public void SecurityTokenProviderOpened(string AppDomain);
    [NonEventAttribute]
public void SecurityTokenProviderOpened(EventTraceActivity eventTraceActivity);
    public bool BinaryMessageEncodingStartIsEnabled();
    [EventAttribute("3370")]
public void BinaryMessageEncodingStart(string AppDomain);
    [NonEventAttribute]
public void BinaryMessageEncodingStart(EventTraceActivity eventTraceActivity);
    public bool MtomMessageEncodingStartIsEnabled();
    [EventAttribute("3371")]
public void MtomMessageEncodingStart(string AppDomain);
    [NonEventAttribute]
public void MtomMessageEncodingStart(EventTraceActivity eventTraceActivity);
    public bool TextMessageEncodingStartIsEnabled();
    [EventAttribute("3372")]
public void TextMessageEncodingStart(string AppDomain);
    [NonEventAttribute]
public void TextMessageEncodingStart(EventTraceActivity eventTraceActivity);
    public bool BinaryMessageDecodingStartIsEnabled();
    [EventAttribute("3373")]
public void BinaryMessageDecodingStart(string AppDomain);
    [NonEventAttribute]
public void BinaryMessageDecodingStart();
    public bool MtomMessageDecodingStartIsEnabled();
    [EventAttribute("3374")]
public void MtomMessageDecodingStart(string AppDomain);
    [NonEventAttribute]
public void MtomMessageDecodingStart();
    public bool TextMessageDecodingStartIsEnabled();
    [EventAttribute("3375")]
public void TextMessageDecodingStart(string AppDomain);
    [NonEventAttribute]
public void TextMessageDecodingStart();
    public bool SequenceAcknowledgementSentIsEnabled();
    [EventAttribute("3381")]
public void SequenceAcknowledgementSent(string SessionId, string AppDomain);
    [NonEventAttribute]
public void SequenceAcknowledgementSent(string SessionId);
    public bool ClientReliableSessionReconnectIsEnabled();
    [EventAttribute("3382")]
public void ClientReliableSessionReconnect(string SessionId, string AppDomain);
    [NonEventAttribute]
public void ClientReliableSessionReconnect(string SessionId);
    public bool CloseTimeoutIsEnabled();
    [EventAttribute("1401")]
public void CloseTimeout(string data1, string AppDomain);
    [NonEventAttribute]
public void CloseTimeout(string data1);
    public bool ReceiveTimeoutIsEnabled();
    [EventAttribute("1406")]
public void ReceiveTimeout(string data1, string AppDomain);
    [NonEventAttribute]
public void ReceiveTimeout(string data1);
    public bool ReliableSessionChannelFaultedIsEnabled();
    [EventAttribute("3383")]
public void ReliableSessionChannelFaulted(string SessionId, string AppDomain);
    [NonEventAttribute]
public void ReliableSessionChannelFaulted(string SessionId);
    public bool ConnectionPoolMissIsEnabled();
    [EventAttribute("3321")]
public void ConnectionPoolMiss(string PoolKey, int busy, string AppDomain);
    [NonEventAttribute]
public void ConnectionPoolMiss(string PoolKey, int busy);
    public bool StreamedMessageReadByEncoderIsEnabled();
    [EventAttribute("3393")]
public void StreamedMessageReadByEncoder(string AppDomain);
    [NonEventAttribute]
public void StreamedMessageReadByEncoder(EventTraceActivity eventTraceActivity);
    public bool StreamedMessageWrittenByEncoderIsEnabled();
    [EventAttribute("3394")]
public void StreamedMessageWrittenByEncoder(string AppDomain);
    [NonEventAttribute]
public void StreamedMessageWrittenByEncoder(EventTraceActivity eventTraceActivity);
    public bool WebSocketConnectionRequestSendStartIsEnabled();
    [EventAttribute("3415")]
public void WebSocketConnectionRequestSendStart(string remoteAddress, string AppDomain);
    [NonEventAttribute]
public void WebSocketConnectionRequestSendStart(EventTraceActivity eventTraceActivity, string remoteAddress);
    public bool WebSocketConnectionRequestSendStopIsEnabled();
    [EventAttribute("3416")]
public void WebSocketConnectionRequestSendStop(int websocketId, string AppDomain);
    [NonEventAttribute]
public void WebSocketConnectionRequestSendStop(EventTraceActivity eventTraceActivity, int websocketId);
    public bool WebSocketConnectionFailedIsEnabled();
    [EventAttribute("3420")]
public void WebSocketConnectionFailed(string errorMessage, string AppDomain);
    [NonEventAttribute]
public void WebSocketConnectionFailed(EventTraceActivity eventTraceActivity, string errorMessage);
    public bool WebSocketConnectionAbortedIsEnabled();
    [EventAttribute("3421")]
public void WebSocketConnectionAborted(int websocketId, string AppDomain);
    [NonEventAttribute]
public void WebSocketConnectionAborted(EventTraceActivity eventTraceActivity, int websocketId);
    public bool WebSocketAsyncWriteStartIsEnabled();
    [EventAttribute("3422")]
public void WebSocketAsyncWriteStart(int websocketId, int byteCount, string remoteAddress, string AppDomain);
    [NonEventAttribute]
public void WebSocketAsyncWriteStart(int websocketId, int byteCount, string remoteAddress);
    public bool WebSocketAsyncWriteStopIsEnabled();
    [EventAttribute("3423")]
public void WebSocketAsyncWriteStop(int websocketId, string AppDomain);
    [NonEventAttribute]
public void WebSocketAsyncWriteStop(int websocketId);
    public bool WebSocketAsyncReadStartIsEnabled();
    [EventAttribute("3424")]
public void WebSocketAsyncReadStart(int websocketId, string AppDomain);
    [NonEventAttribute]
public void WebSocketAsyncReadStart(int websocketId);
    public bool WebSocketAsyncReadStopIsEnabled();
    [EventAttribute("3425")]
public void WebSocketAsyncReadStop(int websocketId, int byteCount, string remoteAddress, string AppDomain);
    [NonEventAttribute]
public void WebSocketAsyncReadStop(int websocketId, int byteCount, string remoteAddress);
    public bool WebSocketCloseSentIsEnabled();
    [EventAttribute("3426")]
public void WebSocketCloseSent(int websocketId, string remoteAddress, string closeStatus, string AppDomain);
    [NonEventAttribute]
public void WebSocketCloseSent(int websocketId, string remoteAddress, string closeStatus);
    public bool WebSocketCloseOutputSentIsEnabled();
    [EventAttribute("3427")]
public void WebSocketCloseOutputSent(int websocketId, string remoteAddress, string closeStatus, string AppDomain);
    [NonEventAttribute]
public void WebSocketCloseOutputSent(int websocketId, string remoteAddress, string closeStatus);
    public bool WebSocketConnectionClosedIsEnabled();
    [EventAttribute("3428")]
public void WebSocketConnectionClosed(int websocketId, string AppDomain);
    [NonEventAttribute]
public void WebSocketConnectionClosed(int websocketId);
    public bool WebSocketCloseStatusReceivedIsEnabled();
    [EventAttribute("3429")]
public void WebSocketCloseStatusReceived(int websocketId, string closeStatus, string AppDomain);
    [NonEventAttribute]
public void WebSocketCloseStatusReceived(int websocketId, string closeStatus);
    public bool WebSocketCreateClientWebSocketWithFactoryIsEnabled();
    [EventAttribute("3431")]
public void WebSocketCreateClientWebSocketWithFactory(string clientWebSocketFactoryType, string AppDomain);
    [NonEventAttribute]
public void WebSocketCreateClientWebSocketWithFactory(EventTraceActivity eventTraceActivity, string clientWebSocketFactoryType);
    public bool WindowsStreamSecurityOnInitiateUpgradeIsEnabled();
    [EventAttribute("3384")]
public void WindowsStreamSecurityOnInitiateUpgrade(string AppDomain);
    [NonEventAttribute]
public void WindowsStreamSecurityOnInitiateUpgrade();
    public bool TokenValidationStartedIsEnabled();
    [EventAttribute("5402")]
public void TokenValidationStarted(string tokenType, string tokenID, string HostReference, string AppDomain);
    [NonEventAttribute]
public void TokenValidationStarted(EventTraceActivity eventTraceActivity, string tokenType, string tokenID);
    public bool TokenValidationSuccessIsEnabled();
    [EventAttribute("5403")]
public void TokenValidationSuccess(string tokenType, string tokenID, string HostReference, string AppDomain);
    [NonEventAttribute]
public void TokenValidationSuccess(EventTraceActivity eventTraceActivity, string tokenType, string tokenID);
    public bool TokenValidationFailureIsEnabled();
    [EventAttribute("5404")]
public void TokenValidationFailure(string tokenType, string tokenID, string errorMessage, string HostReference, string AppDomain);
    [NonEventAttribute]
public void TokenValidationFailure(EventTraceActivity eventTraceActivity, string tokenType, string tokenID, string errorMessage);
    public bool ShipAssertExceptionMessageIsEnabled();
    [EventAttribute("57395")]
public void ShipAssertExceptionMessage(string data1, string AppDomain);
    [NonEventAttribute]
public void ShipAssertExceptionMessage(string data1);
    public bool UnhandledExceptionIsEnabled();
    [EventAttribute("57397")]
public void UnhandledException(string data1, string SerializedException, string AppDomain);
    [NonEventAttribute]
public void UnhandledException(string data1, string SerializedException);
    public bool TraceCodeEventLogCriticalIsEnabled();
    [EventAttribute("57399")]
public void TraceCodeEventLogCritical(string ExtendedData, string AppDomain);
    [NonEventAttribute]
public void TraceCodeEventLogCritical(string ExtendedData);
    public bool TraceCodeEventLogErrorIsEnabled();
    [EventAttribute("57400")]
public void TraceCodeEventLogError(string ExtendedData, string AppDomain);
    [NonEventAttribute]
public void TraceCodeEventLogError(string ExtendedData);
    public bool TraceCodeEventLogInfoIsEnabled();
    [EventAttribute("57401")]
public void TraceCodeEventLogInfo(string ExtendedData, string AppDomain);
    [NonEventAttribute]
public void TraceCodeEventLogInfo(string ExtendedData);
    public bool TraceCodeEventLogVerboseIsEnabled();
    [EventAttribute("57402")]
public void TraceCodeEventLogVerbose(string ExtendedData, string AppDomain);
    [NonEventAttribute]
public void TraceCodeEventLogVerbose(string ExtendedData);
    public bool TraceCodeEventLogWarningIsEnabled();
    [EventAttribute("57403")]
public void TraceCodeEventLogWarning(string ExtendedData, string AppDomain);
    [NonEventAttribute]
public void TraceCodeEventLogWarning(string ExtendedData);
    public bool ThrowingExceptionIsEnabled();
    [EventAttribute("57396")]
public void ThrowingException(string data1, string data2, string SerializedException, string AppDomain);
    [NonEventAttribute]
public void ThrowingException(string data1, string data2, string SerializedException);
    public bool ThrowingExceptionVerboseIsEnabled();
    [EventAttribute("57407")]
public void ThrowingExceptionVerbose(string data1, string data2, string SerializedException, string AppDomain);
    [NonEventAttribute]
public void ThrowingExceptionVerbose(string data1, string data2, string SerializedException);
    public bool ThrowingEtwExceptionIsEnabled();
    [EventAttribute("57410")]
public void ThrowingEtwException(string data1, string data2, string SerializedException, string AppDomain);
    [NonEventAttribute]
public void ThrowingEtwException(string data1, string data2, string SerializedException);
    public bool EtwUnhandledExceptionIsEnabled();
    [EventAttribute("57408")]
public void EtwUnhandledException(string data1, string SerializedException, string AppDomain);
    [NonEventAttribute]
public void EtwUnhandledException(string data1, string SerializedException);
    [NonEventAttribute]
private void TransferActivityId(EventTraceActivity eventTraceActivity);
    [NonEventAttribute]
private void SetActivityId(EventTraceActivity eventTraceActivity);
}
internal class System.ServiceModel.ActionMismatchAddressingException : ProtocolException {
    [CompilerGeneratedAttribute]
private string <HttpActionHeader>k__BackingField;
    [CompilerGeneratedAttribute]
private string <SoapActionHeader>k__BackingField;
    public string HttpActionHeader { get; }
    public string SoapActionHeader { get; }
    public ActionMismatchAddressingException(string message, string soapActionHeader, string httpActionHeader);
    protected ActionMismatchAddressingException(SerializationInfo info, StreamingContext context);
    [CompilerGeneratedAttribute]
public string get_HttpActionHeader();
    [CompilerGeneratedAttribute]
public string get_SoapActionHeader();
    internal Message ProvideFault(MessageVersion messageVersion);
}
public class System.ServiceModel.ActionNotSupportedException : CommunicationException {
    public ActionNotSupportedException(string message);
    public ActionNotSupportedException(string message, Exception innerException);
    protected ActionNotSupportedException(SerializationInfo info, StreamingContext context);
    internal Message ProvideFault(MessageVersion messageVersion);
}
internal class System.ServiceModel.ActivityIdFlowDictionary : object {
    public XmlDictionaryString ActivityId;
    public XmlDictionaryString ActivityIdNamespace;
    public ActivityIdFlowDictionary(ServiceModelDictionary dictionary);
}
internal static class System.ServiceModel.ActivityIdFlowStrings : object {
    public static string ActivityId;
    public static string ActivityIdNamespace;
}
internal class System.ServiceModel.Addressing10Dictionary : object {
    public XmlDictionaryString Namespace;
    public XmlDictionaryString Anonymous;
    public XmlDictionaryString FaultAction;
    public XmlDictionaryString ReplyRelationship;
    public XmlDictionaryString NoneAddress;
    public XmlDictionaryString Metadata;
    public Addressing10Dictionary(ServiceModelDictionary dictionary);
}
internal static class System.ServiceModel.Addressing10Strings : object {
    public static string Namespace;
    public static string Anonymous;
    public static string FaultAction;
    public static string ReplyRelationship;
    public static string NoneAddress;
    public static string Metadata;
    public static string MessageAddressingHeaderRequired;
    public static string InvalidAddressingHeader;
    public static string InvalidCardinality;
    public static string ActionMismatch;
    public static string ProblemHeaderQName;
    public static string FaultDetail;
    public static string DefaultFaultAction;
}
internal class System.ServiceModel.Addressing200408Dictionary : object {
    public XmlDictionaryString Namespace;
    public XmlDictionaryString Anonymous;
    public XmlDictionaryString FaultAction;
    public Addressing200408Dictionary(ServiceModelDictionary dictionary);
}
internal static class System.ServiceModel.Addressing200408Strings : object {
    public static string Namespace;
    public static string Anonymous;
    public static string FaultAction;
    public static string InvalidMessageInformationHeader;
    public static string MessageInformationHeaderRequired;
    public static string DefaultFaultAction;
}
internal class System.ServiceModel.AddressingDictionary : object {
    public XmlDictionaryString Action;
    public XmlDictionaryString To;
    public XmlDictionaryString RelatesTo;
    public XmlDictionaryString MessageId;
    public XmlDictionaryString Address;
    public XmlDictionaryString ReplyTo;
    public XmlDictionaryString Empty;
    public XmlDictionaryString From;
    public XmlDictionaryString FaultTo;
    public XmlDictionaryString EndpointReference;
    public XmlDictionaryString PortType;
    public XmlDictionaryString ServiceName;
    public XmlDictionaryString PortName;
    public XmlDictionaryString ReferenceProperties;
    public XmlDictionaryString RelationshipType;
    public XmlDictionaryString Reply;
    public XmlDictionaryString Prefix;
    public XmlDictionaryString IdentityExtensionNamespace;
    public XmlDictionaryString Identity;
    public XmlDictionaryString Spn;
    public XmlDictionaryString Upn;
    public XmlDictionaryString Rsa;
    public XmlDictionaryString Dns;
    public XmlDictionaryString X509v3Certificate;
    public XmlDictionaryString ReferenceParameters;
    public XmlDictionaryString IsReferenceParameter;
    public AddressingDictionary(ServiceModelDictionary dictionary);
}
internal class System.ServiceModel.AddressingNoneDictionary : object {
    public XmlDictionaryString Namespace;
    public AddressingNoneDictionary(ServiceModelDictionary dictionary);
}
internal static class System.ServiceModel.AddressingNoneStrings : object {
    public static string Namespace;
}
internal static class System.ServiceModel.AddressingStrings : object {
    public static string Action;
    public static string To;
    public static string RelatesTo;
    public static string MessageId;
    public static string Address;
    public static string ReplyTo;
    public static string Empty;
    public static string From;
    public static string FaultTo;
    public static string EndpointReference;
    public static string PortType;
    public static string ServiceName;
    public static string PortName;
    public static string ReferenceProperties;
    public static string RelationshipType;
    public static string Reply;
    public static string Prefix;
    public static string IdentityExtensionNamespace;
    public static string Identity;
    public static string Spn;
    public static string Upn;
    public static string Rsa;
    public static string Dns;
    public static string X509v3Certificate;
    public static string ReferenceParameters;
    public static string IsReferenceParameter;
    public static string EndpointUnavailable;
    public static string ActionNotSupported;
    public static string EndpointReferenceType;
    public static string Request;
    public static string DestinationUnreachable;
    public static string AnonymousUri;
    public static string NoneUri;
    public static string IndigoNamespace;
    public static string ChannelTerminated;
}
internal static class System.ServiceModel.AtomicTransactionExternal10Strings : object {
    public static string Namespace;
    public static string CompletionUri;
    public static string Durable2PCUri;
    public static string Volatile2PCUri;
    public static string CommitAction;
    public static string RollbackAction;
    public static string CommittedAction;
    public static string AbortedAction;
    public static string PrepareAction;
    public static string PreparedAction;
    public static string ReadOnlyAction;
    public static string ReplayAction;
    public static string FaultAction;
}
internal class System.ServiceModel.AtomicTransactionExternal11Dictionary : object {
    public XmlDictionaryString Namespace;
    public XmlDictionaryString CompletionUri;
    public XmlDictionaryString Durable2PCUri;
    public XmlDictionaryString Volatile2PCUri;
    public XmlDictionaryString CommitAction;
    public XmlDictionaryString RollbackAction;
    public XmlDictionaryString CommittedAction;
    public XmlDictionaryString AbortedAction;
    public XmlDictionaryString PrepareAction;
    public XmlDictionaryString PreparedAction;
    public XmlDictionaryString ReadOnlyAction;
    public XmlDictionaryString ReplayAction;
    public XmlDictionaryString FaultAction;
    public XmlDictionaryString UnknownTransaction;
    public AtomicTransactionExternal11Dictionary(XmlDictionary dictionary);
}
internal static class System.ServiceModel.AtomicTransactionExternal11Strings : object {
    public static string Namespace;
    public static string CompletionUri;
    public static string Durable2PCUri;
    public static string Volatile2PCUri;
    public static string CommitAction;
    public static string RollbackAction;
    public static string CommittedAction;
    public static string AbortedAction;
    public static string PrepareAction;
    public static string PreparedAction;
    public static string ReadOnlyAction;
    public static string ReplayAction;
    public static string FaultAction;
    public static string UnknownTransaction;
}
internal static class System.ServiceModel.AtomicTransactionExternalStrings : object {
    public static string Prefix;
    public static string Prepare;
    public static string Prepared;
    public static string ReadOnly;
    public static string Commit;
    public static string Rollback;
    public static string Committed;
    public static string Aborted;
    public static string Replay;
    public static string CompletionCoordinatorPortType;
    public static string CompletionParticipantPortType;
    public static string CoordinatorPortType;
    public static string ParticipantPortType;
    public static string InconsistentInternalState;
}
public enum System.ServiceModel.AuditLevel : Enum {
    public int value__;
    public static AuditLevel None;
    public static AuditLevel Success;
    public static AuditLevel Failure;
    public static AuditLevel SuccessOrFailure;
}
internal static class System.ServiceModel.AuditLevelHelper : object {
    public static bool IsDefined(AuditLevel auditLevel);
    public static void Validate(AuditLevel value);
}
public enum System.ServiceModel.AuditLogLocation : Enum {
    public int value__;
    public static AuditLogLocation Default;
    public static AuditLogLocation Application;
    public static AuditLogLocation Security;
}
internal static class System.ServiceModel.AuditLogLocationHelper : object {
    public static bool IsDefined(AuditLogLocation auditLogLocation);
    public static void Validate(AuditLogLocation value);
}
public enum System.ServiceModel.CacheSetting : Enum {
    public int value__;
    public static CacheSetting Default;
    public static CacheSetting AlwaysOn;
    public static CacheSetting AlwaysOff;
}
[AttributeUsageAttribute("4")]
public class System.ServiceModel.CallbackBehaviorAttribute : Attribute {
    private ConcurrencyMode _concurrencyMode;
    private bool _useSynchronizationContext;
    [CompilerGeneratedAttribute]
private bool <AutomaticSessionShutdown>k__BackingField;
    public bool AutomaticSessionShutdown { get; public set; }
    public ConcurrencyMode ConcurrencyMode { get; public set; }
    public bool UseSynchronizationContext { get; public set; }
    [CompilerGeneratedAttribute]
public bool get_AutomaticSessionShutdown();
    [CompilerGeneratedAttribute]
public void set_AutomaticSessionShutdown(bool value);
    public ConcurrencyMode get_ConcurrencyMode();
    public void set_ConcurrencyMode(ConcurrencyMode value);
    public bool get_UseSynchronizationContext();
    public void set_UseSynchronizationContext(bool value);
    private sealed virtual override void System.ServiceModel.Description.IEndpointBehavior.Validate(ServiceEndpoint serviceEndpoint);
    private sealed virtual override void System.ServiceModel.Description.IEndpointBehavior.AddBindingParameters(ServiceEndpoint serviceEndpoint, BindingParameterCollection parameters);
    private sealed virtual override void System.ServiceModel.Description.IEndpointBehavior.ApplyClientBehavior(ServiceEndpoint serviceEndpoint, ClientRuntime clientRuntime);
    private sealed virtual override void System.ServiceModel.Description.IEndpointBehavior.ApplyDispatchBehavior(ServiceEndpoint serviceEndpoint, EndpointDispatcher endpointDispatcher);
}
public abstract class System.ServiceModel.ChannelFactory : CommunicationObject {
    private ClientCredentials _readOnlyClientCredentials;
    private object _openLock;
    [CompilerGeneratedAttribute]
private ServiceEndpoint <Endpoint>k__BackingField;
    [CompilerGeneratedAttribute]
private IChannelFactory <InnerFactory>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <UseActiveAutoClose>k__BackingField;
    public ClientCredentials Credentials { get; }
    protected TimeSpan DefaultCloseTimeout { get; }
    protected TimeSpan DefaultOpenTimeout { get; }
    public ServiceEndpoint Endpoint { get; private set; }
    internal IChannelFactory InnerFactory { get; private set; }
    internal bool UseActiveAutoClose { get; internal set; }
    public ClientCredentials get_Credentials();
    protected virtual TimeSpan get_DefaultCloseTimeout();
    protected virtual TimeSpan get_DefaultOpenTimeout();
    [CompilerGeneratedAttribute]
public ServiceEndpoint get_Endpoint();
    [CompilerGeneratedAttribute]
private void set_Endpoint(ServiceEndpoint value);
    [CompilerGeneratedAttribute]
internal IChannelFactory get_InnerFactory();
    [CompilerGeneratedAttribute]
private void set_InnerFactory(IChannelFactory value);
    [CompilerGeneratedAttribute]
internal bool get_UseActiveAutoClose();
    [CompilerGeneratedAttribute]
internal void set_UseActiveAutoClose(bool value);
    protected internal void EnsureOpened();
    protected abstract virtual ServiceEndpoint CreateDescription();
    internal EndpointAddress CreateEndpointAddress(ServiceEndpoint endpoint);
    protected virtual IChannelFactory CreateFactory();
    private sealed virtual override void System.IDisposable.Dispose();
    [AsyncStateMachineAttribute("System.ServiceModel.ChannelFactory/<System-IAsyncDisposable-DisposeAsync>d__26")]
private sealed virtual override ValueTask System.IAsyncDisposable.DisposeAsync();
    private void EnsureSecurityCredentialsManager(ServiceEndpoint endpoint);
    private ClientCredentials EnsureCredentials(ServiceEndpoint endpoint);
    public sealed virtual T GetProperty();
    internal bool HasDuplexOperations();
    protected void InitializeEndpoint(EndpointAddress address);
    protected void InitializeEndpoint(ServiceEndpoint endpoint);
    protected void InitializeEndpoint(Binding binding, EndpointAddress address);
    protected virtual void OnOpened();
    protected virtual void OnAbort();
    protected virtual IAsyncResult OnBeginClose(TimeSpan timeout, AsyncCallback callback, object state);
    protected virtual void OnEndClose(IAsyncResult result);
    [AsyncStateMachineAttribute("System.ServiceModel.ChannelFactory/<OnCloseAsync>d__38")]
protected internal virtual Task OnCloseAsync(TimeSpan timeout);
    protected virtual IAsyncResult OnBeginOpen(TimeSpan timeout, AsyncCallback callback, object state);
    protected virtual void OnEndOpen(IAsyncResult result);
    [AsyncStateMachineAttribute("System.ServiceModel.ChannelFactory/<OnOpenAsync>d__41")]
protected internal virtual Task OnOpenAsync(TimeSpan timeout);
    protected virtual void OnClose(TimeSpan timeout);
    protected virtual void OnOpen(TimeSpan timeout);
    protected virtual void OnOpening();
}
public class System.ServiceModel.ChannelFactory`1 : ChannelFactory {
    private Type _channelType;
    private TypeLoader _typeLoader;
    [CompilerGeneratedAttribute]
private InstanceContext <CallbackInstance>k__BackingField;
    [CompilerGeneratedAttribute]
private Type <CallbackType>k__BackingField;
    internal InstanceContext CallbackInstance { get; internal set; }
    internal Type CallbackType { get; internal set; }
    internal ServiceChannelFactory ServiceChannelFactory { get; }
    internal TypeLoader TypeLoader { get; }
    protected ChannelFactory`1(Type channelType);
    public ChannelFactory`1(Binding binding);
    public ChannelFactory`1(Binding binding, string remoteAddress);
    public ChannelFactory`1(Binding binding, EndpointAddress remoteAddress);
    public ChannelFactory`1(ServiceEndpoint endpoint);
    [CompilerGeneratedAttribute]
internal InstanceContext get_CallbackInstance();
    [CompilerGeneratedAttribute]
internal void set_CallbackInstance(InstanceContext value);
    [CompilerGeneratedAttribute]
internal Type get_CallbackType();
    [CompilerGeneratedAttribute]
internal void set_CallbackType(Type value);
    internal ServiceChannelFactory get_ServiceChannelFactory();
    internal TypeLoader get_TypeLoader();
    public sealed virtual TChannel CreateChannel(EndpointAddress address);
    public virtual TChannel CreateChannel(EndpointAddress address, Uri via);
    public TChannel CreateChannel();
    internal UChannel CreateChannel(EndpointAddress address, Uri via);
    internal UChannel CreateChannel(EndpointAddress address);
    protected virtual ServiceEndpoint CreateDescription();
    private void ReflectOnCallbackInstance(ServiceEndpoint endpoint);
    public static TChannel CreateChannel(Binding binding, EndpointAddress endpointAddress);
    public static TChannel CreateChannel(Binding binding, EndpointAddress endpointAddress, Uri via);
    internal static void SetFactoryToAutoClose(TChannel channel);
}
internal class System.ServiceModel.ChannelFactoryRef`1 : object {
    private ChannelFactory`1<TChannel> _channelFactory;
    private int _refCount;
    public ChannelFactory`1<TChannel> ChannelFactory { get; }
    public ChannelFactoryRef`1(ChannelFactory`1<TChannel> channelFactory);
    public void AddRef();
    public bool Release();
    public void Close(TimeSpan timeout);
    public void Abort();
    public ChannelFactory`1<TChannel> get_ChannelFactory();
}
internal class System.ServiceModel.ChannelFactoryRefCache`1 : MruCache`2<EndpointTrait`1<TChannel>, ChannelFactoryRef`1<TChannel>> {
    private static EndpointTraitComparer<TChannel> DefaultEndpointTraitComparer;
    private int _watermark;
    public ChannelFactoryRefCache`1(int watermark);
    private static ChannelFactoryRefCache`1();
    protected virtual void OnSingleItemRemoved(ChannelFactoryRef`1<TChannel> item);
    protected virtual void OnItemAgedOutOfCache(ChannelFactoryRef`1<TChannel> item);
}
internal class System.ServiceModel.Channels.ActionHeader : AddressingHeader {
    private static bool mustUnderstandValue;
    [CompilerGeneratedAttribute]
private string <Action>k__BackingField;
    public string Action { get; }
    public bool MustUnderstand { get; }
    public XmlDictionaryString DictionaryName { get; }
    private ActionHeader(string action, AddressingVersion version);
    [CompilerGeneratedAttribute]
public string get_Action();
    public virtual bool get_MustUnderstand();
    public virtual XmlDictionaryString get_DictionaryName();
    public static ActionHeader Create(string action, AddressingVersion addressingVersion);
    public static ActionHeader Create(XmlDictionaryString dictionaryAction, AddressingVersion addressingVersion);
    protected virtual void OnWriteHeaderContents(XmlDictionaryWriter writer, MessageVersion messageVersion);
    public static string ReadHeaderValue(XmlDictionaryReader reader, AddressingVersion addressingVersion);
    public static ActionHeader ReadHeader(XmlDictionaryReader reader, AddressingVersion version, string actor, bool mustUnderstand, bool relay);
}
public abstract class System.ServiceModel.Channels.AddressHeader : object {
    private ParameterHeader _header;
    internal bool IsReferenceProperty { get; }
    public string Name { get; }
    public string Namespace { get; }
    internal bool get_IsReferenceProperty();
    public abstract virtual string get_Name();
    public abstract virtual string get_Namespace();
    public static AddressHeader CreateAddressHeader(object value);
    public static AddressHeader CreateAddressHeader(object value, XmlObjectSerializer serializer);
    public static AddressHeader CreateAddressHeader(string name, string ns, object value);
    internal static AddressHeader CreateAddressHeader(XmlDictionaryString name, XmlDictionaryString ns, object value);
    public static AddressHeader CreateAddressHeader(string name, string ns, object value, XmlObjectSerializer serializer);
    private static Type GetObjectType(object value);
    public virtual bool Equals(object obj);
    internal string GetComparableForm();
    internal string GetComparableForm(StringBuilder builder);
    public virtual int GetHashCode();
    public T GetValue();
    public T GetValue(XmlObjectSerializer serializer);
    public virtual XmlDictionaryReader GetAddressHeaderReader();
    private XmlDictionaryReader GetComparableReader();
    protected virtual void OnWriteStartAddressHeader(XmlDictionaryWriter writer);
    protected abstract virtual void OnWriteAddressHeaderContents(XmlDictionaryWriter writer);
    public MessageHeader ToMessageHeader();
    public void WriteAddressHeader(XmlWriter writer);
    public void WriteAddressHeader(XmlDictionaryWriter writer);
    public void WriteStartAddressHeader(XmlDictionaryWriter writer);
    public void WriteAddressHeaderContents(XmlDictionaryWriter writer);
}
public class System.ServiceModel.Channels.AddressHeaderCollection : ReadOnlyCollection`1<AddressHeader> {
    [CompilerGeneratedAttribute]
private static AddressHeaderCollection <EmptyHeaderCollection>k__BackingField;
    internal static AddressHeaderCollection EmptyHeaderCollection { get; }
    private int InternalCount { get; }
    internal bool HasReferenceProperties { get; }
    internal bool HasNonReferenceProperties { get; }
    public AddressHeaderCollection(IEnumerable`1<AddressHeader> addressHeaders);
    private static AddressHeaderCollection();
    [CompilerGeneratedAttribute]
internal static AddressHeaderCollection get_EmptyHeaderCollection();
    private int get_InternalCount();
    public void AddHeadersTo(Message message);
    public AddressHeader[] FindAll(string name, string ns);
    public AddressHeader FindHeader(string name, string ns);
    internal bool IsEquivalent(AddressHeaderCollection col);
    internal void PopulateHeaderDictionary(StringBuilder builder, Dictionary`2<string, int> headers);
    internal static AddressHeaderCollection ReadServiceParameters(XmlDictionaryReader reader);
    internal static AddressHeaderCollection ReadServiceParameters(XmlDictionaryReader reader, bool isReferenceProperty);
    internal bool get_HasReferenceProperties();
    internal bool get_HasNonReferenceProperties();
    internal void WriteReferencePropertyContentsTo(XmlDictionaryWriter writer);
    internal void WriteNonReferencePropertyContentsTo(XmlDictionaryWriter writer);
    internal void WriteContentsTo(XmlDictionaryWriter writer);
}
internal abstract class System.ServiceModel.Channels.AddressingHeader : DictionaryHeader {
    [CompilerGeneratedAttribute]
private AddressingVersion <Version>k__BackingField;
    internal AddressingVersion Version { get; }
    private XmlDictionaryString System.ServiceModel.Channels.IMessageHeaderWithSharedNamespace.SharedPrefix { get; }
    private XmlDictionaryString System.ServiceModel.Channels.IMessageHeaderWithSharedNamespace.SharedNamespace { get; }
    public XmlDictionaryString DictionaryNamespace { get; }
    protected AddressingHeader(AddressingVersion version);
    [CompilerGeneratedAttribute]
internal AddressingVersion get_Version();
    private sealed virtual override XmlDictionaryString System.ServiceModel.Channels.IMessageHeaderWithSharedNamespace.get_SharedPrefix();
    private sealed virtual override XmlDictionaryString System.ServiceModel.Channels.IMessageHeaderWithSharedNamespace.get_SharedNamespace();
    public virtual XmlDictionaryString get_DictionaryNamespace();
}
public class System.ServiceModel.Channels.AddressingVersion : object {
    private string _toStringFormat;
    private Uri _noneUri;
    private string _defaultFaultAction;
    private static string AddressingNoneToStringFormat;
    private static string Addressing10ToStringFormat;
    private static string Addressing200408ToStringFormat;
    private static AddressingVersion s_addressing10;
    private static MessagePartSpecification s_addressing10SignedMessageParts;
    private static MessagePartSpecification s_addressing200408SignedMessageParts;
    [CompilerGeneratedAttribute]
private static AddressingVersion <WSAddressingAugust2004>k__BackingField;
    [CompilerGeneratedAttribute]
private static AddressingVersion <None>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Namespace>k__BackingField;
    [CompilerGeneratedAttribute]
private XmlDictionaryString <DictionaryNamespace>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Anonymous>k__BackingField;
    [CompilerGeneratedAttribute]
private XmlDictionaryString <DictionaryAnonymous>k__BackingField;
    [CompilerGeneratedAttribute]
private Uri <AnonymousUri>k__BackingField;
    [CompilerGeneratedAttribute]
private string <FaultAction>k__BackingField;
    [CompilerGeneratedAttribute]
private MessagePartSpecification <SignedMessageParts>k__BackingField;
    public static AddressingVersion WSAddressingAugust2004 { get; }
    public static AddressingVersion WSAddressing10 { get; }
    public static AddressingVersion None { get; }
    internal string Namespace { get; }
    private static MessagePartSpecification Addressing10SignedMessageParts { get; }
    private static MessagePartSpecification Addressing200408SignedMessageParts { get; }
    internal XmlDictionaryString DictionaryNamespace { get; }
    internal string Anonymous { get; }
    internal XmlDictionaryString DictionaryAnonymous { get; }
    internal Uri AnonymousUri { get; }
    internal Uri NoneUri { get; }
    internal string FaultAction { get; }
    internal string DefaultFaultAction { get; }
    internal MessagePartSpecification SignedMessageParts { get; }
    private AddressingVersion(string ns, XmlDictionaryString dictionaryNs, string toStringFormat, MessagePartSpecification signedMessageParts, string anonymous, XmlDictionaryString dictionaryAnonymous, string none, string faultAction, string defaultFaultAction);
    private static AddressingVersion();
    [CompilerGeneratedAttribute]
public static AddressingVersion get_WSAddressingAugust2004();
    public static AddressingVersion get_WSAddressing10();
    [CompilerGeneratedAttribute]
public static AddressingVersion get_None();
    [CompilerGeneratedAttribute]
internal string get_Namespace();
    private static MessagePartSpecification get_Addressing10SignedMessageParts();
    private static MessagePartSpecification get_Addressing200408SignedMessageParts();
    [CompilerGeneratedAttribute]
internal XmlDictionaryString get_DictionaryNamespace();
    [CompilerGeneratedAttribute]
internal string get_Anonymous();
    [CompilerGeneratedAttribute]
internal XmlDictionaryString get_DictionaryAnonymous();
    [CompilerGeneratedAttribute]
internal Uri get_AnonymousUri();
    internal Uri get_NoneUri();
    [CompilerGeneratedAttribute]
internal string get_FaultAction();
    internal string get_DefaultFaultAction();
    [CompilerGeneratedAttribute]
internal MessagePartSpecification get_SignedMessageParts();
    public virtual string ToString();
}
internal class System.ServiceModel.Channels.AsyncCommunicationWaiter : object {
    private bool _closed;
    private CommunicationWaitResult _result;
    private TaskCompletionSource`1<bool> _tcs;
    [CompilerGeneratedAttribute]
private object <ThisLock>k__BackingField;
    private object ThisLock { get; }
    internal AsyncCommunicationWaiter(object mutex);
    [CompilerGeneratedAttribute]
private object get_ThisLock();
    public sealed virtual void Dispose();
    public sealed virtual void Signal();
    [AsyncStateMachineAttribute("System.ServiceModel.Channels.AsyncCommunicationWaiter/<WaitAsync>d__9")]
public sealed virtual Task`1<CommunicationWaitResult> WaitAsync(TimeSpan timeout, bool aborting);
    public sealed virtual CommunicationWaitResult Wait(TimeSpan timeout, bool aborting);
}
internal static class System.ServiceModel.Channels.AuthenticationLevelHelper : object {
    internal static string ToString(AuthenticationLevel authenticationLevel);
}
[ExtensionAttribute]
internal static class System.ServiceModel.Channels.AuthenticationSchemesHelper : object {
    [ExtensionAttribute]
public static bool IsSingleton(AuthenticationSchemes v);
    [ExtensionAttribute]
public static bool IsSet(AuthenticationSchemes thisPtr, AuthenticationSchemes authenticationSchemes);
    [ExtensionAttribute]
public static bool IsNotSet(AuthenticationSchemes thisPtr, AuthenticationSchemes authenticationSchemes);
    internal static string ToString(AuthenticationSchemes authScheme);
}
internal static class System.ServiceModel.Channels.BinaryEncoderDefaults : object {
    public static int MaxSessionSize;
    public static EnvelopeVersion EnvelopeVersion { get; }
    public static BinaryVersion BinaryVersion { get; }
    public static EnvelopeVersion get_EnvelopeVersion();
    public static BinaryVersion get_BinaryVersion();
}
internal static class System.ServiceModel.Channels.BinaryEncodingString : object {
    public static string Binary;
    public static string BinarySession;
    public static string ExtendedBinaryGZip;
    public static string ExtendedBinarySessionGZip;
    public static string ExtendedBinaryDeflate;
    public static string ExtendedBinarySessionDeflate;
    public static string NamespaceUri;
}
internal class System.ServiceModel.Channels.BinaryFormatBuilder : object {
    private List`1<byte> _bytes;
    public int Count { get; }
    public int get_Count();
    public void AppendPrefixDictionaryElement(char prefix, int key);
    public void AppendDictionaryXmlnsAttribute(char prefix, int key);
    public void AppendPrefixDictionaryAttribute(char prefix, int key, char value);
    public void AppendDictionaryAttribute(char prefix, int key, char value);
    public void AppendDictionaryTextWithEndElement(int key);
    public void AppendDictionaryTextWithEndElement();
    public void AppendUniqueIDWithEndElement();
    public void AppendEndElement();
    private void AppendKey(int key);
    private void AppendNode(XmlBinaryNodeType value);
    private void AppendByte(int value);
    private void AppendUtf8(char value);
    public int GetStaticKey(int value);
    public int GetSessionKey(int value);
    private int GetPrefixOffset(char prefix);
    public Byte[] ToByteArray();
}
internal static class System.ServiceModel.Channels.BinaryFormatParser : object {
    public static bool IsSessionKey(int value);
    public static int GetSessionKey(int value);
    public static int GetStaticKey(int value);
    public static int ParseInt32(Byte[] buffer, int offset, int size);
    public static int ParseKey(Byte[] buffer, int offset, int size);
    public static UniqueId ParseUniqueID(Byte[] buffer, int offset, int size);
    public static int MatchBytes(Byte[] buffer, int offset, int size, Byte[] buffer2);
    public static bool MatchAttributeNode(Byte[] buffer, int offset, int size);
    public static int MatchKey(Byte[] buffer, int offset, int size);
    public static int MatchInt32(Byte[] buffer, int offset, int size);
    public static int MatchUniqueID(Byte[] buffer, int offset, int size);
}
internal static class System.ServiceModel.Channels.BinaryIntEncoder : object {
    public static int MaxEncodedSize;
    public static int Encode(int value, Byte[] bytes, int offset);
    public static int GetEncodedSize(int value);
}
internal class System.ServiceModel.Channels.BinaryMessageEncoderFactory : MessageEncoderFactory {
    private static int MaxPooledXmlReaderPerMessage;
    private BinaryMessageEncoder _messageEncoder;
    private MessageVersion _messageVersion;
    private int _maxWritePoolSize;
    private SynchronizedPool`1 modreq(System.Runtime.CompilerServices.IsVolatile) _bufferedDataPool;
    private SynchronizedPool`1 modreq(System.Runtime.CompilerServices.IsVolatile) _bufferedWriterPool;
    private SynchronizedPool`1 modreq(System.Runtime.CompilerServices.IsVolatile) _recycledStatePool;
    private XmlDictionaryReaderQuotas _bufferedReadReaderQuotas;
    private BinaryVersion _binaryVersion;
    [CompilerGeneratedAttribute]
private XmlDictionaryReaderQuotas <ReaderQuotas>k__BackingField;
    [CompilerGeneratedAttribute]
private int <MaxReadPoolSize>k__BackingField;
    [CompilerGeneratedAttribute]
private int <MaxSessionSize>k__BackingField;
    [CompilerGeneratedAttribute]
private CompressionFormat <CompressionFormat>k__BackingField;
    [CompilerGeneratedAttribute]
private long <MaxReceivedMessageSize>k__BackingField;
    [CompilerGeneratedAttribute]
private object <ThisLock>k__BackingField;
    public static IXmlDictionary XmlDictionary { get; }
    public MessageEncoder Encoder { get; }
    public MessageVersion MessageVersion { get; }
    public int MaxWritePoolSize { get; }
    public XmlDictionaryReaderQuotas ReaderQuotas { get; }
    public int MaxReadPoolSize { get; }
    public int MaxSessionSize { get; }
    public CompressionFormat CompressionFormat { get; }
    private long MaxReceivedMessageSize { get; private set; }
    private object ThisLock { get; }
    private SynchronizedPool`1<RecycledMessageState> RecycledStatePool { get; }
    public BinaryMessageEncoderFactory(MessageVersion messageVersion, int maxReadPoolSize, int maxWritePoolSize, int maxSessionSize, XmlDictionaryReaderQuotas readerQuotas, long maxReceivedMessageSize, BinaryVersion version, CompressionFormat compressionFormat);
    public static IXmlDictionary get_XmlDictionary();
    public virtual MessageEncoder get_Encoder();
    public virtual MessageVersion get_MessageVersion();
    public int get_MaxWritePoolSize();
    [CompilerGeneratedAttribute]
public XmlDictionaryReaderQuotas get_ReaderQuotas();
    [CompilerGeneratedAttribute]
public int get_MaxReadPoolSize();
    [CompilerGeneratedAttribute]
public int get_MaxSessionSize();
    [CompilerGeneratedAttribute]
public CompressionFormat get_CompressionFormat();
    [CompilerGeneratedAttribute]
private long get_MaxReceivedMessageSize();
    [CompilerGeneratedAttribute]
private void set_MaxReceivedMessageSize(long value);
    [CompilerGeneratedAttribute]
private object get_ThisLock();
    private SynchronizedPool`1<RecycledMessageState> get_RecycledStatePool();
    public virtual MessageEncoder CreateSessionEncoder();
    private XmlDictionaryWriter TakeStreamedWriter(Stream stream);
    private void ReturnStreamedWriter(XmlDictionaryWriter xmlWriter);
    private BinaryBufferedMessageWriter TakeBufferedWriter();
    private void ReturnMessageWriter(BinaryBufferedMessageWriter messageWriter);
    private XmlDictionaryReader TakeStreamedReader(Stream stream);
    private BinaryBufferedMessageData TakeBufferedData(BinaryMessageEncoder messageEncoder);
    private void ReturnBufferedData(BinaryBufferedMessageData messageData);
}
public class System.ServiceModel.Channels.BinaryMessageEncodingBindingElement : MessageEncodingBindingElement {
    private int _maxReadPoolSize;
    private int _maxWritePoolSize;
    private XmlDictionaryReaderQuotas _readerQuotas;
    private int _maxSessionSize;
    private BinaryVersion _binaryVersion;
    private MessageVersion _messageVersion;
    private long _maxReceivedMessageSize;
    [CompilerGeneratedAttribute]
private CompressionFormat <CompressionFormat>k__BackingField;
    [DefaultValueAttribute("Mono.Cecil.CustomAttributeArgument")]
public CompressionFormat CompressionFormat { get; public set; }
    private BinaryVersion BinaryVersion { get; private set; }
    public MessageVersion MessageVersion { get; public set; }
    [DefaultValueAttribute("64")]
public int MaxReadPoolSize { get; public set; }
    [DefaultValueAttribute("16")]
public int MaxWritePoolSize { get; public set; }
    public XmlDictionaryReaderQuotas ReaderQuotas { get; public set; }
    [DefaultValueAttribute("2048")]
public int MaxSessionSize { get; public set; }
    private BinaryMessageEncodingBindingElement(BinaryMessageEncodingBindingElement elementToBeCloned);
    [CompilerGeneratedAttribute]
public CompressionFormat get_CompressionFormat();
    [CompilerGeneratedAttribute]
public void set_CompressionFormat(CompressionFormat value);
    private BinaryVersion get_BinaryVersion();
    private void set_BinaryVersion(BinaryVersion value);
    public virtual MessageVersion get_MessageVersion();
    public virtual void set_MessageVersion(MessageVersion value);
    public int get_MaxReadPoolSize();
    public void set_MaxReadPoolSize(int value);
    public int get_MaxWritePoolSize();
    public void set_MaxWritePoolSize(int value);
    public XmlDictionaryReaderQuotas get_ReaderQuotas();
    public void set_ReaderQuotas(XmlDictionaryReaderQuotas value);
    public int get_MaxSessionSize();
    public void set_MaxSessionSize(int value);
    private void VerifyCompression(BindingContext context);
    private void SetMaxReceivedMessageSizeFromTransport(BindingContext context);
    public virtual IChannelFactory`1<TChannel> BuildChannelFactory(BindingContext context);
    public virtual BindingElement Clone();
    public virtual MessageEncoderFactory CreateMessageEncoderFactory();
    public virtual T GetProperty(BindingContext context);
    internal virtual bool IsMatch(BindingElement b);
    [EditorBrowsableAttribute("1")]
public bool ShouldSerializeReaderQuotas();
    [EditorBrowsableAttribute("1")]
public bool ShouldSerializeMessageVersion();
}
public class System.ServiceModel.Channels.BinaryVersion : object {
    public static BinaryVersion Version1;
    public static BinaryVersion GZipVersion1;
    public static BinaryVersion DeflateVersion1;
    private IXmlDictionary _dictionary;
    [CompilerGeneratedAttribute]
private string <ContentType>k__BackingField;
    [CompilerGeneratedAttribute]
private string <SessionContentType>k__BackingField;
    public static BinaryVersion CurrentVersion { get; }
    public string ContentType { get; }
    public string SessionContentType { get; }
    public IXmlDictionary Dictionary { get; }
    private BinaryVersion(string contentType, string sessionContentType, IXmlDictionary dictionary);
    private static BinaryVersion();
    public static BinaryVersion get_CurrentVersion();
    [CompilerGeneratedAttribute]
public string get_ContentType();
    [CompilerGeneratedAttribute]
public string get_SessionContentType();
    public IXmlDictionary get_Dictionary();
}
internal class System.ServiceModel.Channels.BinderExceptionHandler : MulticastDelegate {
    public BinderExceptionHandler(object object, IntPtr method);
    public virtual void Invoke(IReliableChannelBinder sender, Exception exception);
    public virtual IAsyncResult BeginInvoke(IReliableChannelBinder sender, Exception exception, AsyncCallback callback, object object);
    public virtual void EndInvoke(IAsyncResult result);
}
public abstract class System.ServiceModel.Channels.Binding : object {
    private TimeSpan _closeTimeout;
    private string _name;
    private string _namespaceIdentifier;
    private TimeSpan _openTimeout;
    private TimeSpan _receiveTimeout;
    private TimeSpan _sendTimeout;
    internal static string DefaultNamespace;
    public TimeSpan CloseTimeout { get; public set; }
    public string Name { get; public set; }
    public string Namespace { get; public set; }
    public TimeSpan OpenTimeout { get; public set; }
    public TimeSpan ReceiveTimeout { get; public set; }
    public string Scheme { get; }
    public MessageVersion MessageVersion { get; }
    public TimeSpan SendTimeout { get; public set; }
    protected Binding(string name, string ns);
    public sealed virtual TimeSpan get_CloseTimeout();
    public void set_CloseTimeout(TimeSpan value);
    public string get_Name();
    public void set_Name(string value);
    public string get_Namespace();
    public void set_Namespace(string value);
    public sealed virtual TimeSpan get_OpenTimeout();
    public void set_OpenTimeout(TimeSpan value);
    public sealed virtual TimeSpan get_ReceiveTimeout();
    public void set_ReceiveTimeout(TimeSpan value);
    public abstract virtual string get_Scheme();
    public MessageVersion get_MessageVersion();
    public sealed virtual TimeSpan get_SendTimeout();
    public void set_SendTimeout(TimeSpan value);
    public IChannelFactory`1<TChannel> BuildChannelFactory(Object[] parameters);
    public virtual IChannelFactory`1<TChannel> BuildChannelFactory(BindingParameterCollection parameters);
    private void ValidateSecurityCapabilities(ISecurityCapabilities runtimeSecurityCapabilities, BindingParameterCollection parameters);
    public bool CanBuildChannelFactory(Object[] parameters);
    public virtual bool CanBuildChannelFactory(BindingParameterCollection parameters);
    public abstract virtual BindingElementCollection CreateBindingElements();
    public T GetProperty(BindingParameterCollection parameters);
    private void EnsureInvariants();
    internal void EnsureInvariants(string contractName);
    internal void CopyTimeouts(IDefaultCommunicationTimeouts source);
}
public class System.ServiceModel.Channels.BindingContext : object {
    private BindingElementCollection _remainingBindingElements;
    [CompilerGeneratedAttribute]
private CustomBinding <Binding>k__BackingField;
    [CompilerGeneratedAttribute]
private BindingParameterCollection <BindingParameters>k__BackingField;
    [CompilerGeneratedAttribute]
private Uri <ListenUriBaseAddress>k__BackingField;
    [CompilerGeneratedAttribute]
private ListenUriMode <ListenUriMode>k__BackingField;
    [CompilerGeneratedAttribute]
private string <ListenUriRelativeAddress>k__BackingField;
    public CustomBinding Binding { get; private set; }
    public BindingParameterCollection BindingParameters { get; private set; }
    public Uri ListenUriBaseAddress { get; public set; }
    public ListenUriMode ListenUriMode { get; public set; }
    public string ListenUriRelativeAddress { get; public set; }
    public BindingElementCollection RemainingBindingElements { get; }
    public BindingContext(CustomBinding binding, BindingParameterCollection parameters);
    private BindingContext(CustomBinding binding, BindingElementCollection remainingBindingElements, BindingParameterCollection parameters);
    private void Initialize(CustomBinding binding, BindingElementCollection remainingBindingElements, BindingParameterCollection parameters);
    [CompilerGeneratedAttribute]
public CustomBinding get_Binding();
    [CompilerGeneratedAttribute]
private void set_Binding(CustomBinding value);
    [CompilerGeneratedAttribute]
public BindingParameterCollection get_BindingParameters();
    [CompilerGeneratedAttribute]
private void set_BindingParameters(BindingParameterCollection value);
    [CompilerGeneratedAttribute]
public Uri get_ListenUriBaseAddress();
    [CompilerGeneratedAttribute]
public void set_ListenUriBaseAddress(Uri value);
    [CompilerGeneratedAttribute]
public ListenUriMode get_ListenUriMode();
    [CompilerGeneratedAttribute]
public void set_ListenUriMode(ListenUriMode value);
    [CompilerGeneratedAttribute]
public string get_ListenUriRelativeAddress();
    [CompilerGeneratedAttribute]
public void set_ListenUriRelativeAddress(string value);
    public BindingElementCollection get_RemainingBindingElements();
    public IChannelFactory`1<TChannel> BuildInnerChannelFactory();
    public bool CanBuildInnerChannelFactory();
    public T GetInnerProperty();
    public BindingContext Clone();
    private BindingElement RemoveNextElement();
    internal void ValidateBindingElementsConsumed();
}
public abstract class System.ServiceModel.Channels.BindingElement : object {
    protected BindingElement(BindingElement elementToBeCloned);
    public abstract virtual BindingElement Clone();
    public virtual IChannelFactory`1<TChannel> BuildChannelFactory(BindingContext context);
    public virtual bool CanBuildChannelFactory(BindingContext context);
    public abstract virtual T GetProperty(BindingContext context);
    internal T GetIndividualProperty();
    internal virtual bool IsMatch(BindingElement b);
}
public class System.ServiceModel.Channels.BindingElementCollection : Collection`1<BindingElement> {
    public BindingElementCollection(IEnumerable`1<BindingElement> elements);
    public BindingElementCollection(BindingElement[] elements);
    public BindingElementCollection Clone();
    public void AddRange(BindingElement[] elements);
    public bool Contains(Type bindingElementType);
    public T Find();
    public T Remove();
    private T Find(bool remove);
    public Collection`1<T> FindAll();
    public Collection`1<T> RemoveAll();
    private Collection`1<T> FindAll(bool remove);
    protected virtual void InsertItem(int index, BindingElement item);
    protected virtual void SetItem(int index, BindingElement item);
}
public class System.ServiceModel.Channels.BindingParameterCollection : KeyedByTypeCollection`1<object> {
    internal BindingParameterCollection(Object[] parameters);
    internal BindingParameterCollection(BindingParameterCollection parameters);
}
public abstract class System.ServiceModel.Channels.BodyWriter : object {
    private bool _canWrite;
    private object _thisLock;
    [CompilerGeneratedAttribute]
private bool <IsBuffered>k__BackingField;
    public bool IsBuffered { get; }
    internal bool IsEmpty { get; }
    internal bool IsFault { get; }
    protected BodyWriter(bool isBuffered);
    [CompilerGeneratedAttribute]
public bool get_IsBuffered();
    internal virtual bool get_IsEmpty();
    internal virtual bool get_IsFault();
    public BodyWriter CreateBufferedCopy(int maxBufferSize);
    protected virtual BodyWriter OnCreateBufferedCopy(int maxBufferSize);
    internal BodyWriter OnCreateBufferedCopy(int maxBufferSize, XmlDictionaryReaderQuotas quotas);
    protected abstract virtual void OnWriteBodyContents(XmlDictionaryWriter writer);
    protected virtual Task OnWriteBodyContentsAsync(XmlDictionaryWriter writer);
    protected virtual IAsyncResult OnBeginWriteBodyContents(XmlDictionaryWriter writer, AsyncCallback callback, object state);
    protected virtual void OnEndWriteBodyContents(IAsyncResult result);
    private void EnsureWriteBodyContentsState(XmlDictionaryWriter writer);
    public void WriteBodyContents(XmlDictionaryWriter writer);
    internal Task WriteBodyContentsAsync(XmlDictionaryWriter writer);
    public IAsyncResult BeginWriteBodyContents(XmlDictionaryWriter writer, AsyncCallback callback, object state);
    public void EndWriteBodyContents(IAsyncResult result);
}
internal class System.ServiceModel.Channels.BodyWriterMessage : Message {
    private MessageProperties _properties;
    private MessageHeaders _headers;
    [CompilerGeneratedAttribute]
private BodyWriter <BodyWriter>k__BackingField;
    public bool IsFault { get; }
    public bool IsEmpty { get; }
    public MessageHeaders Headers { get; }
    public MessageProperties Properties { get; }
    public MessageVersion Version { get; }
    protected internal BodyWriter BodyWriter { get; private set; }
    private BodyWriterMessage(BodyWriter bodyWriter);
    public BodyWriterMessage(MessageVersion version, string action, BodyWriter bodyWriter);
    public BodyWriterMessage(MessageVersion version, ActionHeader actionHeader, BodyWriter bodyWriter);
    public BodyWriterMessage(MessageHeaders headers, KeyValuePair`2[] properties, BodyWriter bodyWriter);
    public virtual bool get_IsFault();
    public virtual bool get_IsEmpty();
    public virtual MessageHeaders get_Headers();
    public virtual MessageProperties get_Properties();
    public virtual MessageVersion get_Version();
    protected virtual MessageBuffer OnCreateBufferedCopy(int maxBufferSize);
    protected virtual void OnClose();
    protected virtual void OnWriteBodyContents(XmlDictionaryWriter writer);
    protected virtual Task OnWriteBodyContentsAsync(XmlDictionaryWriter writer);
    protected virtual IAsyncResult OnBeginWriteMessage(XmlDictionaryWriter writer, AsyncCallback callback, object state);
    protected virtual void OnEndWriteMessage(IAsyncResult result);
    protected virtual IAsyncResult OnBeginWriteBodyContents(XmlDictionaryWriter writer, AsyncCallback callback, object state);
    protected virtual void OnEndWriteBodyContents(IAsyncResult result);
    protected virtual void OnBodyToString(XmlDictionaryWriter writer);
    [CompilerGeneratedAttribute]
protected internal BodyWriter get_BodyWriter();
    [CompilerGeneratedAttribute]
private void set_BodyWriter(BodyWriter value);
}
internal class System.ServiceModel.Channels.BodyWriterMessageBuffer : MessageBuffer {
    private object _thisLock;
    [CompilerGeneratedAttribute]
private BodyWriter <BodyWriter>k__BackingField;
    [CompilerGeneratedAttribute]
private MessageHeaders <Headers>k__BackingField;
    [CompilerGeneratedAttribute]
private KeyValuePair`2[] <Properties>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <Closed>k__BackingField;
    protected object ThisLock { get; }
    public int BufferSize { get; }
    protected BodyWriter BodyWriter { get; private set; }
    protected MessageHeaders Headers { get; private set; }
    protected KeyValuePair`2[] Properties { get; private set; }
    protected bool Closed { get; private set; }
    public BodyWriterMessageBuffer(MessageHeaders headers, KeyValuePair`2[] properties, BodyWriter bodyWriter);
    protected object get_ThisLock();
    public virtual int get_BufferSize();
    public virtual void Close();
    public virtual Message CreateMessage();
    [CompilerGeneratedAttribute]
protected BodyWriter get_BodyWriter();
    [CompilerGeneratedAttribute]
private void set_BodyWriter(BodyWriter value);
    [CompilerGeneratedAttribute]
protected MessageHeaders get_Headers();
    [CompilerGeneratedAttribute]
private void set_Headers(MessageHeaders value);
    [CompilerGeneratedAttribute]
protected KeyValuePair`2[] get_Properties();
    [CompilerGeneratedAttribute]
private void set_Properties(KeyValuePair`2[] value);
    [CompilerGeneratedAttribute]
protected bool get_Closed();
    [CompilerGeneratedAttribute]
private void set_Closed(bool value);
}
internal class System.ServiceModel.Channels.BufferedAddressHeader : AddressHeader {
    private string _name;
    private string _ns;
    private XmlBuffer _buffer;
    [CompilerGeneratedAttribute]
private bool <IsReferencePropertyHeader>k__BackingField;
    public bool IsReferencePropertyHeader { get; }
    public string Name { get; }
    public string Namespace { get; }
    public BufferedAddressHeader(XmlDictionaryReader reader);
    public BufferedAddressHeader(XmlDictionaryReader reader, bool isReferenceProperty);
    [CompilerGeneratedAttribute]
public bool get_IsReferencePropertyHeader();
    public virtual string get_Name();
    public virtual string get_Namespace();
    public virtual XmlDictionaryReader GetAddressHeaderReader();
    protected virtual void OnWriteStartAddressHeader(XmlDictionaryWriter writer);
    protected virtual void OnWriteAddressHeaderContents(XmlDictionaryWriter writer);
}
internal class System.ServiceModel.Channels.BufferedHeader : ReadableMessageHeader {
    private MessageVersion _version;
    private XmlBuffer _buffer;
    private int _bufferIndex;
    private string _actor;
    private bool _relay;
    private bool _mustUnderstand;
    private string _name;
    private string _ns;
    private bool _streamed;
    private bool _isRefParam;
    public string Actor { get; }
    public bool IsReferenceParameter { get; }
    public string Name { get; }
    public string Namespace { get; }
    public bool MustUnderstand { get; }
    public bool Relay { get; }
    public BufferedHeader(MessageVersion version, XmlBuffer buffer, int bufferIndex, string name, string ns, bool mustUnderstand, string actor, bool relay, bool isRefParam);
    public BufferedHeader(MessageVersion version, XmlBuffer buffer, int bufferIndex, MessageHeaderInfo headerInfo);
    public BufferedHeader(MessageVersion version, XmlBuffer buffer, XmlDictionaryReader reader, XmlAttributeHolder[] envelopeAttributes, XmlAttributeHolder[] headerAttributes);
    public virtual string get_Actor();
    public virtual bool get_IsReferenceParameter();
    public virtual string get_Name();
    public virtual string get_Namespace();
    public virtual bool get_MustUnderstand();
    public virtual bool get_Relay();
    public virtual bool IsMessageVersionSupported(MessageVersion messageVersion);
    public virtual XmlDictionaryReader GetHeaderReader();
}
internal class System.ServiceModel.Channels.BufferedMessage : ReceivedMessage {
    private MessageHeaders _headers;
    private MessageProperties _properties;
    private RecycledMessageState _recycledMessageState;
    private XmlDictionaryReader _reader;
    private XmlAttributeHolder[] _bodyAttributes;
    [CompilerGeneratedAttribute]
private IBufferedMessageData <MessageData>k__BackingField;
    public MessageHeaders Headers { get; }
    internal IBufferedMessageData MessageData { get; private set; }
    public MessageProperties Properties { get; }
    internal RecycledMessageState RecycledMessageState { get; }
    public MessageVersion Version { get; }
    public BufferedMessage(IBufferedMessageData messageData, RecycledMessageState recycledMessageState);
    public BufferedMessage(IBufferedMessageData messageData, RecycledMessageState recycledMessageState, Boolean[] understoodHeaders, bool understoodHeadersModified);
    public virtual MessageHeaders get_Headers();
    [CompilerGeneratedAttribute]
internal IBufferedMessageData get_MessageData();
    [CompilerGeneratedAttribute]
private void set_MessageData(IBufferedMessageData value);
    public virtual MessageProperties get_Properties();
    internal virtual RecycledMessageState get_RecycledMessageState();
    public virtual MessageVersion get_Version();
    protected virtual XmlDictionaryReader OnGetReaderAtBodyContents();
    internal virtual XmlDictionaryReader GetReaderAtHeader();
    public XmlDictionaryReader GetBufferedReaderAtBody();
    public XmlDictionaryReader GetMessageReader();
    protected virtual void OnBodyToString(XmlDictionaryWriter writer);
    protected virtual void OnClose();
    protected virtual void OnWriteStartEnvelope(XmlDictionaryWriter writer);
    protected virtual void OnWriteStartHeaders(XmlDictionaryWriter writer);
    protected virtual void OnWriteStartBody(XmlDictionaryWriter writer);
    protected virtual MessageBuffer OnCreateBufferedCopy(int maxBufferSize);
    protected virtual string OnGetBodyAttribute(string localName, string ns);
}
internal class System.ServiceModel.Channels.BufferedMessageBuffer : MessageBuffer {
    private IBufferedMessageData _messageData;
    private KeyValuePair`2[] _properties;
    private bool _closed;
    private Boolean[] _understoodHeaders;
    private bool _understoodHeadersModified;
    [CompilerGeneratedAttribute]
private object <ThisLock>k__BackingField;
    public int BufferSize { get; }
    public string MessageContentType { get; }
    private object ThisLock { get; }
    public BufferedMessageBuffer(IBufferedMessageData messageData, KeyValuePair`2[] properties, Boolean[] understoodHeaders, bool understoodHeadersModified);
    public virtual int get_BufferSize();
    public virtual void WriteMessage(Stream stream);
    public virtual string get_MessageContentType();
    [CompilerGeneratedAttribute]
private object get_ThisLock();
    public virtual void Close();
    public virtual Message CreateMessage();
}
internal abstract class System.ServiceModel.Channels.BufferedMessageData : object {
    private int _refCount;
    private int _outstandingReaders;
    private bool _multipleUsers;
    private RecycledMessageState _messageState;
    private SynchronizedPool`1<RecycledMessageState> _messageStatePool;
    [CompilerGeneratedAttribute]
private ArraySegment`1<byte> <Buffer>k__BackingField;
    [CompilerGeneratedAttribute]
private BufferManager <BufferManager>k__BackingField;
    public ArraySegment`1<byte> Buffer { get; private set; }
    public BufferManager BufferManager { get; private set; }
    public XmlDictionaryReaderQuotas Quotas { get; }
    public MessageEncoder MessageEncoder { get; }
    private object ThisLock { get; }
    public BufferedMessageData(SynchronizedPool`1<RecycledMessageState> messageStatePool);
    [CompilerGeneratedAttribute]
public sealed virtual ArraySegment`1<byte> get_Buffer();
    [CompilerGeneratedAttribute]
private void set_Buffer(ArraySegment`1<byte> value);
    [CompilerGeneratedAttribute]
public BufferManager get_BufferManager();
    [CompilerGeneratedAttribute]
private void set_BufferManager(BufferManager value);
    public virtual XmlDictionaryReaderQuotas get_Quotas();
    public abstract virtual MessageEncoder get_MessageEncoder();
    private object get_ThisLock();
    public sealed virtual void EnableMultipleUsers();
    public sealed virtual void Close();
    private void DoClose();
    public void DoReturnMessageState(RecycledMessageState messageState);
    private void DoReturnXmlReader(XmlDictionaryReader reader);
    public RecycledMessageState DoTakeMessageState();
    private XmlDictionaryReader DoTakeXmlReader();
    public sealed virtual XmlDictionaryReader GetMessageReader();
    public void OnXmlReaderClosed(XmlDictionaryReader reader);
    protected virtual void OnClosed();
    public sealed virtual RecycledMessageState TakeMessageState();
    protected abstract virtual XmlDictionaryReader TakeXmlReader();
    public sealed virtual void Open();
    public void Open(ArraySegment`1<byte> buffer, BufferManager bufferManager);
    protected abstract virtual void ReturnXmlReader(XmlDictionaryReader xmlReader);
    public sealed virtual void ReturnMessageState(RecycledMessageState messageState);
}
internal abstract class System.ServiceModel.Channels.BufferedMessageWriter : object {
    private Int32[] _sizeHistory;
    private int _sizeHistoryIndex;
    private static int sizeHistoryCount;
    private static int expectedSizeVariance;
    private BufferManagerOutputStream _stream;
    protected abstract virtual XmlDictionaryWriter TakeXmlWriter(Stream stream);
    protected abstract virtual void ReturnXmlWriter(XmlDictionaryWriter writer);
    public ArraySegment`1<byte> WriteMessage(Message message, BufferManager bufferManager, int initialOffset, int maxSizeQuota);
    protected virtual void OnWriteStartMessage(XmlDictionaryWriter writer);
    protected virtual void OnWriteEndMessage(XmlDictionaryWriter writer);
    private void InitMessagePredicter();
    private int PredictMessageSize();
    private void RecordActualMessageSize(int size);
}
public class System.ServiceModel.Channels.BufferedReadStream : Stream {
    private static int DefaultBufferSize;
    private Stream _stream;
    private Byte[] _buffer;
    private int _bufferSize;
    private int _readPos;
    private int _readLen;
    private Task`1<int> _lastSyncCompletedReadTask;
    private BufferManager _bufferManager;
    private SemaphoreSlim _sem;
    public static string BufferedReadStreamPropertyName;
    public bool CanRead { get; }
    public bool CanWrite { get; }
    public bool CanSeek { get; }
    public long Length { get; }
    public long Position { get; public set; }
    public bool IsBufferEmpty { get; }
    public BufferedReadStream(Stream stream);
    public BufferedReadStream(Stream stream, BufferManager bufferManager);
    public BufferedReadStream(Stream stream, BufferManager bufferManager, int bufferSize);
    private void EnsureNotClosed();
    private void EnsureCanRead();
    private void EnsureBufferAllocated();
    public virtual bool get_CanRead();
    public virtual bool get_CanWrite();
    public virtual bool get_CanSeek();
    public virtual long get_Length();
    public virtual long get_Position();
    public virtual void set_Position(long value);
    protected virtual void Dispose(bool disposing);
    public virtual void Flush();
    public virtual Task FlushAsync(CancellationToken cancellationToken);
    private int ReadFromBuffer(Byte[] array, int offset, int count);
    private int ReadFromBuffer(Byte[] array, int offset, int count, Exception& error);
    public virtual int Read(Byte[] array, int offset, int count);
    private Task`1<int> LastSyncCompletedReadTask(int val);
    [AsyncStateMachineAttribute("System.ServiceModel.Channels.BufferedReadStream/<PreReadBufferAsync>d__34")]
public Task PreReadBufferAsync(byte preBufferedByte, CancellationToken cancellationToken);
    public Task PreReadBufferAsync(CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("System.ServiceModel.Channels.BufferedReadStream/<PreReadBufferAsyncInternal>d__36")]
private Task PreReadBufferAsyncInternal(CancellationToken cancellationToken);
    public bool get_IsBufferEmpty();
    public virtual Task`1<int> ReadAsync(Byte[] buffer, int offset, int count, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("System.ServiceModel.Channels.BufferedReadStream/<ReadFromUnderlyingStreamAsync>d__40")]
private Task`1<int> ReadFromUnderlyingStreamAsync(Byte[] array, int offset, int count, CancellationToken cancellationToken, int bytesAlreadySatisfied, Task semaphoreLockTask);
    public virtual int ReadByte();
    public virtual void Write(Byte[] buffer, int offset, int count);
    public virtual Task WriteAsync(Byte[] buffer, int offset, int count, CancellationToken cancellationToken);
    public virtual void WriteByte(byte value);
    public virtual long Seek(long offset, SeekOrigin origin);
    public virtual void SetLength(long value);
}
internal class System.ServiceModel.Channels.BufferedWriteStream : Stream {
    public static int DefaultBufferSize;
    private Stream _stream;
    private BufferManager _bufferManager;
    private Byte[] _buffer;
    private int _bufferSize;
    private int _writePos;
    private SemaphoreSlim _sem;
    private static int MaxShadowBufferSize;
    public bool CanRead { get; }
    public bool CanWrite { get; }
    public bool CanSeek { get; }
    public long Length { get; }
    public long Position { get; public set; }
    public BufferedWriteStream(Stream stream);
    public BufferedWriteStream(Stream stream, BufferManager bufferManager);
    public BufferedWriteStream(Stream stream, BufferManager bufferManager, int bufferSize);
    private void EnsureNotClosed();
    private void EnsureCanWrite();
    private void EnsureShadowBufferAllocated();
    private void EnsureBufferAllocated();
    public virtual bool get_CanRead();
    public virtual bool get_CanWrite();
    public virtual bool get_CanSeek();
    public virtual long get_Length();
    public virtual long get_Position();
    public virtual void set_Position(long value);
    protected virtual void Dispose(bool disposing);
    public virtual void Flush();
    public virtual Task FlushAsync(CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("System.ServiceModel.Channels.BufferedWriteStream/<FlushAsyncInternal>d__29")]
private Task FlushAsyncInternal(CancellationToken cancellationToken);
    private void FlushWrite();
    [AsyncStateMachineAttribute("System.ServiceModel.Channels.BufferedWriteStream/<FlushWriteAsync>d__31")]
private Task FlushWriteAsync(CancellationToken cancellationToken);
    public virtual int Read(Byte[] array, int offset, int count);
    public virtual Task`1<int> ReadAsync(Byte[] buffer, int offset, int count, CancellationToken cancellationToken);
    public virtual int ReadByte();
    private void WriteToBuffer(Byte[] array, Int32& offset, Int32& count);
    private void WriteToBuffer(Byte[] array, Int32& offset, Int32& count, Exception& error);
    public virtual void Write(Byte[] array, int offset, int count);
    public virtual Task WriteAsync(Byte[] buffer, int offset, int count, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("System.ServiceModel.Channels.BufferedWriteStream/<WriteToUnderlyingStreamAsync>d__39")]
private Task WriteToUnderlyingStreamAsync(Byte[] array, int offset, int count, CancellationToken cancellationToken, Task semaphoreLockTask);
    public virtual void WriteByte(byte value);
    public virtual long Seek(long offset, SeekOrigin origin);
    public virtual void SetLength(long value);
}
public abstract class System.ServiceModel.Channels.BufferManager : object {
    public abstract virtual Byte[] TakeBuffer(int bufferSize);
    public abstract virtual void ReturnBuffer(Byte[] buffer);
    public abstract virtual void Clear();
    public static BufferManager CreateBufferManager(long maxBufferPoolSize, int maxBufferSize);
    internal static InternalBufferManager GetInternalBufferManager(BufferManager bufferManager);
}
internal class System.ServiceModel.Channels.BufferManagerOutputStream : BufferedOutputStream {
    private string _quotaExceededString;
    public BufferManagerOutputStream(string quotaExceededString);
    public BufferManagerOutputStream(string quotaExceededString, int maxSize);
    public BufferManagerOutputStream(string quotaExceededString, int initialSize, int maxSize, BufferManager bufferManager);
    public void Init(int initialSize, int maxSizeQuota, BufferManager bufferManager);
    public void Init(int initialSize, int maxSizeQuota, int effectiveMaxSize, BufferManager bufferManager);
    protected virtual Exception CreateQuotaExceededException(int maxSizeQuota);
}
public abstract class System.ServiceModel.Channels.ChannelBase : CommunicationObject {
    [CompilerGeneratedAttribute]
private ChannelManagerBase <Manager>k__BackingField;
    private TimeSpan System.ServiceModel.IDefaultCommunicationTimeouts.CloseTimeout { get; }
    private TimeSpan System.ServiceModel.IDefaultCommunicationTimeouts.OpenTimeout { get; }
    private TimeSpan System.ServiceModel.IDefaultCommunicationTimeouts.ReceiveTimeout { get; }
    private TimeSpan System.ServiceModel.IDefaultCommunicationTimeouts.SendTimeout { get; }
    protected TimeSpan DefaultCloseTimeout { get; }
    protected TimeSpan DefaultOpenTimeout { get; }
    protected TimeSpan DefaultReceiveTimeout { get; }
    protected TimeSpan DefaultSendTimeout { get; }
    protected ChannelManagerBase Manager { get; }
    protected ChannelBase(ChannelManagerBase channelManager);
    private sealed virtual override TimeSpan System.ServiceModel.IDefaultCommunicationTimeouts.get_CloseTimeout();
    private sealed virtual override TimeSpan System.ServiceModel.IDefaultCommunicationTimeouts.get_OpenTimeout();
    private sealed virtual override TimeSpan System.ServiceModel.IDefaultCommunicationTimeouts.get_ReceiveTimeout();
    private sealed virtual override TimeSpan System.ServiceModel.IDefaultCommunicationTimeouts.get_SendTimeout();
    protected virtual TimeSpan get_DefaultCloseTimeout();
    protected virtual TimeSpan get_DefaultOpenTimeout();
    protected TimeSpan get_DefaultReceiveTimeout();
    protected TimeSpan get_DefaultSendTimeout();
    [CompilerGeneratedAttribute]
protected ChannelManagerBase get_Manager();
    public virtual T GetProperty();
    protected virtual void OnClosed();
}
internal class System.ServiceModel.Channels.ChannelBindingMessageProperty : object {
    private static string propertyName;
    private ChannelBinding _channelBinding;
    private object _thisLock;
    private bool _ownsCleanup;
    private int _refCount;
    public static string Name { get; }
    private bool IsDisposed { get; }
    public ChannelBinding ChannelBinding { get; }
    public ChannelBindingMessageProperty(ChannelBinding channelBinding, bool ownsCleanup);
    public static string get_Name();
    private bool get_IsDisposed();
    public ChannelBinding get_ChannelBinding();
    public static bool TryGet(Message message, ChannelBindingMessageProperty& property);
    public static bool TryGet(MessageProperties properties, ChannelBindingMessageProperty& property);
    public void AddTo(Message message);
    public void AddTo(MessageProperties properties);
    public sealed virtual IMessageProperty CreateCopy();
    public sealed virtual void Dispose();
    private void ThrowIfDisposed();
}
internal class System.ServiceModel.Channels.ChannelBuilder : object {
    private BindingContext _context;
    [CompilerGeneratedAttribute]
private CustomBinding <Binding>k__BackingField;
    [CompilerGeneratedAttribute]
private BindingParameterCollection <BindingParameters>k__BackingField;
    public CustomBinding Binding { get; public set; }
    public BindingParameterCollection BindingParameters { get; public set; }
    public ChannelBuilder(BindingContext context, bool addChannelDemuxerIfRequired);
    public ChannelBuilder(Binding binding, BindingParameterCollection bindingParameters, bool addChannelDemuxerIfRequired);
    public ChannelBuilder(ChannelBuilder channelBuilder);
    [CompilerGeneratedAttribute]
public CustomBinding get_Binding();
    [CompilerGeneratedAttribute]
public void set_Binding(CustomBinding value);
    [CompilerGeneratedAttribute]
public BindingParameterCollection get_BindingParameters();
    [CompilerGeneratedAttribute]
public void set_BindingParameters(BindingParameterCollection value);
    private void AddDemuxerBindingElement(BindingElementCollection elements);
    public IChannelFactory`1<TChannel> BuildChannelFactory();
    public bool CanBuildChannelFactory();
}
internal class System.ServiceModel.Channels.ChannelDemuxer : object {
    public static TimeSpan UseDefaultReceiveTimeout;
    [CompilerGeneratedAttribute]
private TimeSpan <PeekTimeout>k__BackingField;
    [CompilerGeneratedAttribute]
private int <MaxPendingSessions>k__BackingField;
    public TimeSpan PeekTimeout { get; public set; }
    public int MaxPendingSessions { get; public set; }
    private static ChannelDemuxer();
    [CompilerGeneratedAttribute]
public TimeSpan get_PeekTimeout();
    [CompilerGeneratedAttribute]
public void set_PeekTimeout(TimeSpan value);
    [CompilerGeneratedAttribute]
public int get_MaxPendingSessions();
    [CompilerGeneratedAttribute]
public void set_MaxPendingSessions(int value);
}
internal class System.ServiceModel.Channels.ChannelDemuxerBindingElement : BindingElement {
    private ChannelDemuxer _demuxer;
    private CachedBindingContextState _cachedContextState;
    private bool _cacheContextState;
    public TimeSpan PeekTimeout { get; public set; }
    public int MaxPendingSessions { get; public set; }
    public ChannelDemuxerBindingElement(bool cacheContextState);
    public ChannelDemuxerBindingElement(ChannelDemuxerBindingElement element);
    public TimeSpan get_PeekTimeout();
    public void set_PeekTimeout(TimeSpan value);
    public int get_MaxPendingSessions();
    public void set_MaxPendingSessions(int value);
    private void SubstituteCachedBindingContextParametersIfNeeded(BindingContext context);
    public virtual IChannelFactory`1<TChannel> BuildChannelFactory(BindingContext context);
    public virtual bool CanBuildChannelFactory(BindingContext context);
    public virtual BindingElement Clone();
    public virtual T GetProperty(BindingContext context);
}
public abstract class System.ServiceModel.Channels.ChannelFactoryBase : ChannelManagerBase {
    private TimeSpan _closeTimeout;
    private TimeSpan _openTimeout;
    private TimeSpan _receiveTimeout;
    private TimeSpan _sendTimeout;
    protected TimeSpan DefaultCloseTimeout { get; }
    protected TimeSpan DefaultOpenTimeout { get; }
    protected TimeSpan DefaultReceiveTimeout { get; }
    protected TimeSpan DefaultSendTimeout { get; }
    protected ChannelFactoryBase(IDefaultCommunicationTimeouts timeouts);
    protected virtual TimeSpan get_DefaultCloseTimeout();
    protected virtual TimeSpan get_DefaultOpenTimeout();
    protected virtual TimeSpan get_DefaultReceiveTimeout();
    protected virtual TimeSpan get_DefaultSendTimeout();
    public virtual T GetProperty();
    protected virtual void OnAbort();
    protected virtual IAsyncResult OnBeginClose(TimeSpan timeout, AsyncCallback callback, object state);
    protected internal virtual Task OnCloseAsync(TimeSpan timeout);
    protected virtual void OnClose(TimeSpan timeout);
    protected virtual void OnEndClose(IAsyncResult result);
    private void InitializeTimeouts(IDefaultCommunicationTimeouts timeouts);
}
public abstract class System.ServiceModel.Channels.ChannelFactoryBase`1 : ChannelFactoryBase {
    private CommunicationObjectManager`1<IChannel> _channels;
    protected ChannelFactoryBase`1(IDefaultCommunicationTimeouts timeouts);
    public sealed virtual TChannel CreateChannel(EndpointAddress address);
    public sealed virtual TChannel CreateChannel(EndpointAddress address, Uri via);
    private TChannel InternalCreateChannel(EndpointAddress address, Uri via);
    protected abstract virtual TChannel OnCreateChannel(EndpointAddress address, Uri via);
    protected void ValidateCreateChannel();
    protected virtual void OnAbort();
    protected virtual void OnClose(TimeSpan timeout);
    protected internal virtual Task OnCloseAsync(TimeSpan timeout);
    protected virtual IAsyncResult OnBeginClose(TimeSpan timeout, AsyncCallback callback, object state);
    protected virtual void OnEndClose(IAsyncResult result);
    [AsyncStateMachineAttribute("System.ServiceModel.Channels.ChannelFactoryBase`1/<OnCloseAsyncInternal>d__13")]
private Task OnCloseAsyncInternal(TimeSpan timeout);
}
public abstract class System.ServiceModel.Channels.ChannelManagerBase : CommunicationObject {
    protected TimeSpan DefaultReceiveTimeout { get; }
    protected TimeSpan DefaultSendTimeout { get; }
    internal TimeSpan InternalReceiveTimeout { get; }
    internal TimeSpan InternalSendTimeout { get; }
    private TimeSpan System.ServiceModel.IDefaultCommunicationTimeouts.CloseTimeout { get; }
    private TimeSpan System.ServiceModel.IDefaultCommunicationTimeouts.OpenTimeout { get; }
    private TimeSpan System.ServiceModel.IDefaultCommunicationTimeouts.ReceiveTimeout { get; }
    private TimeSpan System.ServiceModel.IDefaultCommunicationTimeouts.SendTimeout { get; }
    protected abstract virtual TimeSpan get_DefaultReceiveTimeout();
    protected abstract virtual TimeSpan get_DefaultSendTimeout();
    internal TimeSpan get_InternalReceiveTimeout();
    internal TimeSpan get_InternalSendTimeout();
    private sealed virtual override TimeSpan System.ServiceModel.IDefaultCommunicationTimeouts.get_CloseTimeout();
    private sealed virtual override TimeSpan System.ServiceModel.IDefaultCommunicationTimeouts.get_OpenTimeout();
    private sealed virtual override TimeSpan System.ServiceModel.IDefaultCommunicationTimeouts.get_ReceiveTimeout();
    private sealed virtual override TimeSpan System.ServiceModel.IDefaultCommunicationTimeouts.get_SendTimeout();
    internal Exception CreateChannelTypeNotSupportedException(Type type);
}
public class System.ServiceModel.Channels.ChannelParameterCollection : Collection`1<object> {
    private IChannel _channel;
    protected IChannel Channel { get; }
    public ChannelParameterCollection(IChannel channel);
    protected virtual IChannel get_Channel();
    public void PropagateChannelParameters(IChannel innerChannel);
    protected virtual void ClearItems();
    protected virtual void InsertItem(int index, object item);
    protected virtual void RemoveItem(int index);
    protected virtual void SetItem(int index, object item);
    private void ThrowIfDisposedOrImmutable();
    private void ThrowIfMutable();
}
internal abstract class System.ServiceModel.Channels.ChannelReliableSession : object {
    private IReliableChannelBinder _binder;
    private bool _canSendFault;
    private SessionFaultState _faulted;
    private SequenceRangeCollection _finalRanges;
    private InterruptibleTimer _inactivityTimer;
    private bool _isSessionClosed;
    private RequestContext _replyFaultContext;
    private Message _terminatingFault;
    private UnblockChannelCloseHandler _unblockChannelCloseCallback;
    [CompilerGeneratedAttribute]
private ChannelBase <Channel>k__BackingField;
    [CompilerGeneratedAttribute]
private Guard <Guard>k__BackingField;
    [CompilerGeneratedAttribute]
private TimeSpan <InitiationTime>k__BackingField;
    [CompilerGeneratedAttribute]
private UniqueId <InputID>k__BackingField;
    [CompilerGeneratedAttribute]
private FaultHelper <FaultHelper>k__BackingField;
    [CompilerGeneratedAttribute]
private UniqueId <OutputID>k__BackingField;
    [CompilerGeneratedAttribute]
private IReliableFactorySettings <Settings>k__BackingField;
    [CompilerGeneratedAttribute]
private object <ThisLock>k__BackingField;
    protected ChannelBase Channel { get; }
    protected Guard Guard { get; }
    public string Id { get; }
    public TimeSpan InitiationTime { get; protected set; }
    public UniqueId InputID { get; protected set; }
    protected FaultHelper FaultHelper { get; }
    public UniqueId OutputID { get; protected set; }
    public UniqueId SequenceID { get; }
    public IReliableFactorySettings Settings { get; }
    protected object ThisLock { get; }
    unknown UnblockChannelCloseHandler UnblockChannelCloseCallback {public set; }
    protected ChannelReliableSession(ChannelBase channel, IReliableFactorySettings settings, IReliableChannelBinder binder, FaultHelper faultHelper);
    [CompilerGeneratedAttribute]
protected ChannelBase get_Channel();
    [CompilerGeneratedAttribute]
protected Guard get_Guard();
    public sealed virtual string get_Id();
    [CompilerGeneratedAttribute]
public TimeSpan get_InitiationTime();
    [CompilerGeneratedAttribute]
protected void set_InitiationTime(TimeSpan value);
    [CompilerGeneratedAttribute]
public UniqueId get_InputID();
    [CompilerGeneratedAttribute]
protected void set_InputID(UniqueId value);
    [CompilerGeneratedAttribute]
protected FaultHelper get_FaultHelper();
    [CompilerGeneratedAttribute]
public UniqueId get_OutputID();
    [CompilerGeneratedAttribute]
protected void set_OutputID(UniqueId value);
    public abstract virtual UniqueId get_SequenceID();
    [CompilerGeneratedAttribute]
public IReliableFactorySettings get_Settings();
    [CompilerGeneratedAttribute]
protected object get_ThisLock();
    public void set_UnblockChannelCloseCallback(UnblockChannelCloseHandler value);
    public virtual void Abort();
    private void AddFinalRanges();
    public abstract virtual Task OpenAsync(TimeSpan timeout);
    [AsyncStateMachineAttribute("System.ServiceModel.Channels.ChannelReliableSession/<CloseAsync>d__46")]
public virtual Task CloseAsync(TimeSpan timeout);
    public void CloseSession();
    protected virtual void FaultCore();
    public void OnLocalFault(Exception e, WsrmFault fault, RequestContext context);
    public void OnLocalFault(Exception e, Message faultMessage, RequestContext context);
    public void OnRemoteFault(WsrmFault fault);
    public void OnRemoteFault(Exception e);
    public virtual void OnFaulted();
    private void OnInactivityElapsed(object state);
    public abstract virtual void OnLocalActivity();
    public void OnUnknownException(Exception e);
    public virtual void OnRemoteActivity(bool fastPolling);
    public bool ProcessInfo(WsrmMessageInfo info, RequestContext context);
    public bool ProcessInfo(WsrmMessageInfo info, RequestContext context, bool throwException);
    public void SetFinalAck(SequenceRangeCollection finalRanges);
    public virtual void StartInactivityTimer();
    private void UnblockChannelIfNecessary();
    public bool VerifyDuplexProtocolElements(WsrmMessageInfo info, RequestContext context);
    public bool VerifyDuplexProtocolElements(WsrmMessageInfo info, RequestContext context, bool throwException);
    protected virtual WsrmFault VerifyDuplexProtocolElements(WsrmMessageInfo info);
    public bool VerifySimplexProtocolElements(WsrmMessageInfo info, RequestContext context);
    public bool VerifySimplexProtocolElements(WsrmMessageInfo info, RequestContext context, bool throwException);
    protected abstract virtual WsrmFault VerifySimplexProtocolElements(WsrmMessageInfo info);
}
internal class System.ServiceModel.Channels.ChannelRequirements : ValueType {
    public bool usesInput;
    public bool usesReply;
    public bool usesOutput;
    public bool usesRequest;
    public SessionMode sessionMode;
    public static void ComputeContractRequirements(ContractDescription contractDescription, ChannelRequirements& requirements);
    public static Type[] ComputeRequiredChannels(ChannelRequirements& requirements);
    public static bool IsSessionful(Type channelType);
    public static bool IsOneWay(Type channelType);
    public static bool IsRequestReply(Type channelType);
    public static bool IsDuplex(Type channelType);
    public static Exception CantCreateListenerException(IEnumerable`1<Type> supportedChannels, IEnumerable`1<Type> requiredChannels, string bindingName);
    public static Exception CantCreateChannelException(IEnumerable`1<Type> supportedChannels, IEnumerable`1<Type> requiredChannels, string bindingName);
    public static Exception BindingContractMismatchException(IEnumerable`1<Type> supportedChannels, IEnumerable`1<Type> requiredChannels, string bindingName, String& contractChannelTypesString, String& bindingChannelTypesString);
}
internal abstract class System.ServiceModel.Channels.ClientReliableChannelBinder`1 : ReliableChannelBinder`1<TChannel> {
    private ChannelParameterCollection _channelParameters;
    private IChannelFactory`1<TChannel> _factory;
    private EndpointAddress _to;
    [CompilerGeneratedAttribute]
private Uri <Via>k__BackingField;
    protected bool CanGetChannelForReceive { get; }
    public bool CanSendAsynchronously { get; }
    public ChannelParameterCollection ChannelParameters { get; }
    protected bool MustCloseChannel { get; }
    protected bool MustOpenChannel { get; }
    public Uri Via { get; }
    protected ClientReliableChannelBinder`1(EndpointAddress to, Uri via, IChannelFactory`1<TChannel> factory, MaskingMode maskingMode, TolerateFaultsMode faultMode, ChannelParameterCollection channelParameters, TimeSpan defaultCloseTimeout, TimeSpan defaultSendTimeout);
    protected virtual bool get_CanGetChannelForReceive();
    public virtual bool get_CanSendAsynchronously();
    public virtual ChannelParameterCollection get_ChannelParameters();
    protected virtual bool get_MustCloseChannel();
    protected virtual bool get_MustOpenChannel();
    [CompilerGeneratedAttribute]
public sealed virtual Uri get_Via();
    public static IClientReliableChannelBinder CreateBinder(EndpointAddress to, Uri via, IChannelFactory`1<TChannel> factory, MaskingMode maskingMode, TolerateFaultsMode faultMode, ChannelParameterCollection channelParameters, TimeSpan defaultCloseTimeout, TimeSpan defaultSendTimeout);
    public sealed virtual Task`1<bool> EnsureChannelForRequestAsync();
    protected virtual void OnAbort();
    protected virtual Task OnCloseAsync(TimeSpan timeout);
    protected virtual Task OnOpenAsync(TimeSpan timeout);
    protected virtual Task`1<Message> OnRequestAsync(TChannel channel, Message message, TimeSpan timeout, MaskingMode maskingMode);
    public sealed virtual Task`1<Message> RequestAsync(Message message, TimeSpan timeout);
    [AsyncStateMachineAttribute("System.ServiceModel.Channels.ClientReliableChannelBinder`1/<RequestAsync>d__24")]
public sealed virtual Task`1<Message> RequestAsync(Message message, TimeSpan timeout, MaskingMode maskingMode);
    protected virtual Task`1<bool> TryGetChannelAsync(TimeSpan timeout);
}
internal class System.ServiceModel.Channels.ClientReliableDuplexSessionChannel : ReliableDuplexSessionChannel {
    private ChannelParameterCollection _channelParameters;
    private DuplexClientReliableSession _clientSession;
    private TimeoutHelper _closeTimeoutHelper;
    private bool _closing;
    private static Func`2<object, Task> s_onReconnectTimerElapsed;
    public ClientReliableDuplexSessionChannel(ChannelManagerBase factory, IReliableFactorySettings settings, IReliableChannelBinder binder, FaultHelper faultHelper, LateBoundChannelParameterCollection channelParameters, UniqueId inputID);
    private static ClientReliableDuplexSessionChannel();
    public virtual T GetProperty();
    protected virtual IAsyncResult OnBeginClose(TimeSpan timeout, AsyncCallback callback, object state);
    protected virtual IAsyncResult OnBeginOpen(TimeSpan timeout, AsyncCallback callback, object state);
    protected internal virtual Task OnCloseAsync(TimeSpan timeout);
    protected virtual void OnClose(TimeSpan timeout);
    [AsyncStateMachineAttribute("System.ServiceModel.Channels.ClientReliableDuplexSessionChannel/<OnConnectionLost>d__11")]
private void OnConnectionLost(object sender, EventArgs args);
    protected virtual void OnEndOpen(IAsyncResult result);
    [AsyncStateMachineAttribute("System.ServiceModel.Channels.ClientReliableDuplexSessionChannel/<OnOpenAsync>d__13")]
protected internal virtual Task OnOpenAsync(TimeSpan timeout);
    protected virtual void OnOpen(TimeSpan timeout);
    protected virtual void OnOpened();
    [AsyncStateMachineAttribute("System.ServiceModel.Channels.ClientReliableDuplexSessionChannel/<OnReconnectTimerElapsed>d__16")]
private static Task OnReconnectTimerElapsed(object state);
    protected virtual void OnRemoteActivity();
    [AsyncStateMachineAttribute("System.ServiceModel.Channels.ClientReliableDuplexSessionChannel/<PollingAsyncCallback>d__18")]
private Task PollingAsyncCallback();
    protected virtual Task ProcessMessageAsync(WsrmMessageInfo info);
    [AsyncStateMachineAttribute("System.ServiceModel.Channels.ClientReliableDuplexSessionChannel/<ReconnectAsync>d__20")]
private Task ReconnectAsync();
    private void WaitForReconnect();
}
internal class System.ServiceModel.Channels.ClientReliableSession : ChannelReliableSession {
    private IClientReliableChannelBinder _binder;
    private PollingMode _oldPollingMode;
    private PollingHandler _pollingHandler;
    private PollingMode _pollingMode;
    private InterruptibleTimer _pollingTimer;
    private ReliableRequestor _requestor;
    unknown PollingHandler PollingCallback {public set; }
    public UniqueId SequenceID { get; }
    public ClientReliableSession(ChannelBase channel, IReliableFactorySettings factory, IClientReliableChannelBinder binder, FaultHelper faultHelper, UniqueId inputID);
    public void set_PollingCallback(PollingHandler value);
    public virtual UniqueId get_SequenceID();
    public virtual void Abort();
    [AsyncStateMachineAttribute("System.ServiceModel.Channels.ClientReliableSession/<OpenAsync>d__13")]
public virtual Task OpenAsync(TimeSpan timeout);
    private bool ChannelSupportsOneCreateSequenceAttempt();
    [AsyncStateMachineAttribute("System.ServiceModel.Channels.ClientReliableSession/<CloseAsync>d__15")]
public virtual Task CloseAsync(TimeSpan timeout);
    protected virtual void FaultCore();
    private TimeSpan GetPollingInterval();
    public virtual void OnFaulted();
    [AsyncStateMachineAttribute("System.ServiceModel.Channels.ClientReliableSession/<OnPollingTimerElapsed>d__19")]
private Task OnPollingTimerElapsed(object state);
    public virtual void OnLocalActivity();
    public virtual void OnRemoteActivity(bool fastPolling);
    private void ProcessCreateSequenceResponse(Message response, DateTime start);
    public void ResumePolling(bool fastPolling);
    public bool StopPolling();
    protected virtual WsrmFault VerifyDuplexProtocolElements(WsrmMessageInfo info);
    protected virtual WsrmFault VerifySimplexProtocolElements(WsrmMessageInfo info);
    [CompilerGeneratedAttribute]
[DebuggerHiddenAttribute]
private Task <>n__0(TimeSpan timeout);
}
internal class System.ServiceModel.Channels.CloseSequence : BodyWriter {
    private UniqueId _identifier;
    private long _lastMsgNumber;
    public CloseSequence(UniqueId identifier, long lastMsgNumber);
    public static CloseSequenceInfo Create(XmlDictionaryReader reader);
    protected virtual void OnWriteBodyContents(XmlDictionaryWriter writer);
}
internal class System.ServiceModel.Channels.CloseSequenceInfo : WsrmRequestInfo {
    [CompilerGeneratedAttribute]
private UniqueId <Identifier>k__BackingField;
    [CompilerGeneratedAttribute]
private long <LastMsgNumber>k__BackingField;
    public UniqueId Identifier { get; public set; }
    public long LastMsgNumber { get; public set; }
    public string RequestName { get; }
    [CompilerGeneratedAttribute]
public UniqueId get_Identifier();
    [CompilerGeneratedAttribute]
public void set_Identifier(UniqueId value);
    [CompilerGeneratedAttribute]
public long get_LastMsgNumber();
    [CompilerGeneratedAttribute]
public void set_LastMsgNumber(long value);
    public virtual string get_RequestName();
    public static CloseSequenceInfo ReadMessage(MessageVersion messageVersion, Message message, MessageHeaders headers);
}
internal class System.ServiceModel.Channels.CloseSequenceResponse : BodyWriter {
    private UniqueId _identifier;
    public CloseSequenceResponse(UniqueId identifier);
    public static CloseSequenceResponseInfo Create(XmlDictionaryReader reader);
    protected virtual void OnWriteBodyContents(XmlDictionaryWriter writer);
}
internal class System.ServiceModel.Channels.CloseSequenceResponseInfo : object {
    [CompilerGeneratedAttribute]
private UniqueId <Identifier>k__BackingField;
    [CompilerGeneratedAttribute]
private UniqueId <RelatesTo>k__BackingField;
    public UniqueId Identifier { get; public set; }
    public UniqueId RelatesTo { get; public set; }
    [CompilerGeneratedAttribute]
public UniqueId get_Identifier();
    [CompilerGeneratedAttribute]
public void set_Identifier(UniqueId value);
    [CompilerGeneratedAttribute]
public UniqueId get_RelatesTo();
    [CompilerGeneratedAttribute]
public void set_RelatesTo(UniqueId value);
    public static CloseSequenceResponseInfo ReadMessage(MessageVersion messageVersion, Message message, MessageHeaders headers);
}
public abstract class System.ServiceModel.Channels.CommunicationObject : object {
    private bool _closeCalled;
    private ExceptionQueue _exceptionQueue;
    private bool _onClosingCalled;
    private bool _onClosedCalled;
    private bool _onOpeningCalled;
    private bool _onOpenedCalled;
    private bool _raisedClosed;
    private bool _raisedClosing;
    private bool _raisedFaulted;
    private bool _traceOpenAndClose;
    private CommunicationState _state;
    internal bool _isSynchronousOpen;
    internal bool _isSynchronousClose;
    private bool _supportsAsyncOpenClose;
    private bool _supportsAsyncOpenCloseSet;
    private AsyncLock _asyncLock;
    private object _thisLock;
    [CompilerGeneratedAttribute]
private bool <Aborted>k__BackingField;
    [CompilerGeneratedAttribute]
private object <EventSender>k__BackingField;
    [CompilerGeneratedAttribute]
private EventHandler Closed;
    [CompilerGeneratedAttribute]
private EventHandler Closing;
    [CompilerGeneratedAttribute]
private EventHandler Faulted;
    [CompilerGeneratedAttribute]
private EventHandler Opened;
    [CompilerGeneratedAttribute]
private EventHandler Opening;
    internal bool SupportsAsyncOpenClose { get; internal set; }
    internal bool Aborted { get; private set; }
    internal object EventSender { get; internal set; }
    protected bool IsDisposed { get; }
    public CommunicationState State { get; }
    protected object ThisLock { get; }
    internal AsyncLock ThisAsyncLock { get; }
    protected TimeSpan DefaultCloseTimeout { get; }
    protected TimeSpan DefaultOpenTimeout { get; }
    internal TimeSpan InternalCloseTimeout { get; }
    internal TimeSpan InternalOpenTimeout { get; }
    internal bool TraceOpenAndClose { get; internal set; }
    protected CommunicationObject(object mutex);
    internal bool get_SupportsAsyncOpenClose();
    internal void set_SupportsAsyncOpenClose(bool value);
    [CompilerGeneratedAttribute]
internal bool get_Aborted();
    [CompilerGeneratedAttribute]
private void set_Aborted(bool value);
    [CompilerGeneratedAttribute]
internal object get_EventSender();
    [CompilerGeneratedAttribute]
internal void set_EventSender(object value);
    protected bool get_IsDisposed();
    public sealed virtual CommunicationState get_State();
    protected object get_ThisLock();
    internal AsyncLock get_ThisAsyncLock();
    protected abstract virtual TimeSpan get_DefaultCloseTimeout();
    protected abstract virtual TimeSpan get_DefaultOpenTimeout();
    internal TimeSpan get_InternalCloseTimeout();
    internal TimeSpan get_InternalOpenTimeout();
    [CompilerGeneratedAttribute]
public sealed virtual void add_Closed(EventHandler value);
    [CompilerGeneratedAttribute]
public sealed virtual void remove_Closed(EventHandler value);
    [CompilerGeneratedAttribute]
public sealed virtual void add_Closing(EventHandler value);
    [CompilerGeneratedAttribute]
public sealed virtual void remove_Closing(EventHandler value);
    [CompilerGeneratedAttribute]
public sealed virtual void add_Faulted(EventHandler value);
    [CompilerGeneratedAttribute]
public sealed virtual void remove_Faulted(EventHandler value);
    [CompilerGeneratedAttribute]
public sealed virtual void add_Opened(EventHandler value);
    [CompilerGeneratedAttribute]
public sealed virtual void remove_Opened(EventHandler value);
    [CompilerGeneratedAttribute]
public sealed virtual void add_Opening(EventHandler value);
    [CompilerGeneratedAttribute]
public sealed virtual void remove_Opening(EventHandler value);
    public sealed virtual void Abort();
    public sealed virtual IAsyncResult BeginClose(AsyncCallback callback, object state);
    public sealed virtual IAsyncResult BeginClose(TimeSpan timeout, AsyncCallback callback, object state);
    public sealed virtual IAsyncResult BeginOpen(AsyncCallback callback, object state);
    public sealed virtual IAsyncResult BeginOpen(TimeSpan timeout, AsyncCallback callback, object state);
    public sealed virtual void Close();
    public sealed virtual void Close(TimeSpan timeout);
    [AsyncStateMachineAttribute("System.ServiceModel.Channels.CommunicationObject/<CloseAsyncInternal>d__68")]
private Task CloseAsyncInternal(TimeSpan timeout);
    [AsyncStateMachineAttribute("System.ServiceModel.Channels.CommunicationObject/<System-ServiceModel-IAsyncCommunicationObject-CloseAsync>d__69")]
private sealed virtual override Task System.ServiceModel.IAsyncCommunicationObject.CloseAsync(TimeSpan timeout);
    [AsyncStateMachineAttribute("System.ServiceModel.Channels.CommunicationObject/<OnCloseAsyncInternal>d__70")]
private Task OnCloseAsyncInternal(TimeSpan timeout);
    private Exception CreateNotOpenException();
    private Exception CreateImmutableException();
    private Exception CreateBaseClassMethodNotCalledException(string method);
    internal Exception CreateClosedException();
    internal Exception CreateFaultedException();
    internal Exception CreateAbortedException();
    internal bool DoneReceivingInCurrentState();
    public sealed virtual void EndClose(IAsyncResult result);
    public sealed virtual void EndOpen(IAsyncResult result);
    protected void Fault();
    internal void Fault(Exception exception);
    internal void AddPendingException(Exception exception);
    internal Exception GetPendingException();
    internal Exception GetTerminalException();
    public sealed virtual void Open();
    public sealed virtual void Open(TimeSpan timeout);
    private Task OpenAsyncInternal(TimeSpan timeout);
    [AsyncStateMachineAttribute("System.ServiceModel.Channels.CommunicationObject/<System-ServiceModel-IAsyncCommunicationObject-OpenAsync>d__88")]
private sealed virtual override Task System.ServiceModel.IAsyncCommunicationObject.OpenAsync(TimeSpan timeout);
    [AsyncStateMachineAttribute("System.ServiceModel.Channels.CommunicationObject/<OnOpenAsyncInternal>d__89")]
private Task OnOpenAsyncInternal(TimeSpan timeout);
    protected virtual void OnClosed();
    protected virtual void OnClosing();
    protected virtual void OnFaulted();
    protected virtual void OnOpened();
    protected virtual void OnOpening();
    internal void ThrowIfFaulted();
    internal void ThrowIfAborted();
    internal bool get_TraceOpenAndClose();
    internal void set_TraceOpenAndClose(bool value);
    internal void ThrowIfClosed();
    protected virtual Type GetCommunicationObjectType();
    protected internal void ThrowIfDisposed();
    internal void ThrowIfClosedOrOpened();
    protected internal void ThrowIfDisposedOrImmutable();
    protected internal void ThrowIfDisposedOrNotOpen();
    internal void ThrowIfNotOpened();
    internal void ThrowIfClosedOrNotOpen();
    internal void ThrowPending();
    protected abstract virtual void OnAbort();
    protected abstract virtual void OnClose(TimeSpan timeout);
    protected abstract virtual IAsyncResult OnBeginClose(TimeSpan timeout, AsyncCallback callback, object state);
    protected abstract virtual void OnEndClose(IAsyncResult result);
    protected abstract virtual void OnOpen(TimeSpan timeout);
    protected abstract virtual IAsyncResult OnBeginOpen(TimeSpan timeout, AsyncCallback callback, object state);
    protected abstract virtual void OnEndOpen(IAsyncResult result);
    protected internal virtual Task OnCloseAsync(TimeSpan timeout);
    protected internal virtual Task OnOpenAsync(TimeSpan timeout);
    internal Task OpenOtherAsync(ICommunicationObject other, TimeSpan timeout);
    internal Task CloseOtherAsync(ICommunicationObject other, TimeSpan timeout);
}
[ExtensionAttribute]
public static class System.ServiceModel.Channels.CommunicationObjectInternal : object {
    public static void ThrowIfClosed(CommunicationObject communicationObject);
    public static void ThrowIfClosedOrOpened(CommunicationObject communicationObject);
    public static void ThrowIfDisposedOrNotOpen(CommunicationObject communicationObject);
    public static void ThrowIfDisposed(CommunicationObject communicationObject);
    [ExtensionAttribute]
public static TimeSpan GetInternalCloseTimeout(CommunicationObject communicationObject);
    public static void OnClose(CommunicationObject communicationObject, TimeSpan timeout);
    public static IAsyncResult OnBeginClose(CommunicationObject communicationObject, TimeSpan timeout, AsyncCallback callback, object state);
    public static void OnEnd(IAsyncResult result);
    public static void OnOpen(CommunicationObject communicationObject, TimeSpan timeout);
    public static IAsyncResult OnBeginOpen(CommunicationObject communicationObject, TimeSpan timeout, AsyncCallback callback, object state);
    [AsyncStateMachineAttribute("System.ServiceModel.Channels.CommunicationObjectInternal/<OnCloseAsyncInternal>d__10")]
public static Task OnCloseAsyncInternal(CommunicationObject communicationObject, TimeSpan timeout);
    [AsyncStateMachineAttribute("System.ServiceModel.Channels.CommunicationObjectInternal/<OnOpenAsyncInternal>d__11")]
public static Task OnOpenAsyncInternal(CommunicationObject communicationObject, TimeSpan timeout);
}
internal class System.ServiceModel.Channels.CommunicationObjectManager`1 : LifetimeManager {
    private bool _inputClosed;
    private HashSet`1<ItemType> _table;
    public CommunicationObjectManager`1(object mutex);
    public void Add(ItemType item);
    public void CloseInput();
    public void DecrementActivityCount();
    public void IncrementActivityCount();
    private void OnItemClosed(object sender, EventArgs args);
    public void Remove(ItemType item);
    public ItemType[] ToArray();
}
internal enum System.ServiceModel.Channels.CommunicationWaitResult : Enum {
    public int value__;
    public static CommunicationWaitResult Waiting;
    public static CommunicationWaitResult Succeeded;
    public static CommunicationWaitResult Expired;
    public static CommunicationWaitResult Aborted;
}
internal class System.ServiceModel.Channels.ComponentExceptionHandler : MulticastDelegate {
    public ComponentExceptionHandler(object object, IntPtr method);
    public virtual void Invoke(Exception exception);
    public virtual IAsyncResult BeginInvoke(Exception exception, AsyncCallback callback, object object);
    public virtual void EndInvoke(IAsyncResult result);
}
internal class System.ServiceModel.Channels.ComponentFaultedHandler : MulticastDelegate {
    public ComponentFaultedHandler(object object, IntPtr method);
    public virtual void Invoke(Exception faultException, WsrmFault fault);
    public virtual IAsyncResult BeginInvoke(Exception faultException, WsrmFault fault, AsyncCallback callback, object object);
    public virtual void EndInvoke(IAsyncResult result);
}
public enum System.ServiceModel.Channels.CompressionFormat : Enum {
    public int value__;
    public static CompressionFormat None;
    public static CompressionFormat GZip;
    public static CompressionFormat Deflate;
}
internal abstract class System.ServiceModel.Channels.ContentOnlyMessage : Message {
    private MessageHeaders _headers;
    private MessageProperties _properties;
    public MessageHeaders Headers { get; }
    public MessageProperties Properties { get; }
    public MessageVersion Version { get; }
    public virtual MessageHeaders get_Headers();
    public virtual MessageProperties get_Properties();
    public virtual MessageVersion get_Version();
    protected virtual void OnBodyToString(XmlDictionaryWriter writer);
}
internal class System.ServiceModel.Channels.CreateSequence : BodyWriter {
    private AddressingVersion _addressingVersion;
    private IClientReliableChannelBinder _binder;
    private UniqueId _offerIdentifier;
    private bool _ordered;
    private ReliableMessagingVersion _reliableMessagingVersion;
    public CreateSequence(AddressingVersion addressingVersion, ReliableMessagingVersion reliableMessagingVersion, bool ordered, IClientReliableChannelBinder binder, UniqueId offerIdentifier);
    public static CreateSequenceInfo Create(MessageVersion messageVersion, ReliableMessagingVersion reliableMessagingVersion, ISecureConversationSession securitySession, XmlDictionaryReader reader);
    protected virtual void OnWriteBodyContents(XmlDictionaryWriter writer);
}
internal class System.ServiceModel.Channels.CreateSequenceInfo : WsrmRequestInfo {
    [CompilerGeneratedAttribute]
private EndpointAddress <AcksTo>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<TimeSpan> <Expires>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<TimeSpan> <OfferExpires>k__BackingField;
    [CompilerGeneratedAttribute]
private UniqueId <OfferIdentifier>k__BackingField;
    [CompilerGeneratedAttribute]
private Uri <To>k__BackingField;
    public EndpointAddress AcksTo { get; public set; }
    public Nullable`1<TimeSpan> Expires { get; public set; }
    public Nullable`1<TimeSpan> OfferExpires { get; public set; }
    public UniqueId OfferIdentifier { get; public set; }
    public string RequestName { get; }
    public Uri To { get; private set; }
    [CompilerGeneratedAttribute]
public EndpointAddress get_AcksTo();
    [CompilerGeneratedAttribute]
public void set_AcksTo(EndpointAddress value);
    [CompilerGeneratedAttribute]
public Nullable`1<TimeSpan> get_Expires();
    [CompilerGeneratedAttribute]
public void set_Expires(Nullable`1<TimeSpan> value);
    [CompilerGeneratedAttribute]
public Nullable`1<TimeSpan> get_OfferExpires();
    [CompilerGeneratedAttribute]
public void set_OfferExpires(Nullable`1<TimeSpan> value);
    [CompilerGeneratedAttribute]
public UniqueId get_OfferIdentifier();
    [CompilerGeneratedAttribute]
public void set_OfferIdentifier(UniqueId value);
    public virtual string get_RequestName();
    [CompilerGeneratedAttribute]
public Uri get_To();
    [CompilerGeneratedAttribute]
private void set_To(Uri value);
    public static CreateSequenceInfo ReadMessage(MessageVersion messageVersion, ReliableMessagingVersion reliableMessagingVersion, ISecureConversationSession securitySession, Message message, MessageHeaders headers);
    public static void ValidateCreateSequenceHeaders(MessageVersion messageVersion, ISecureConversationSession securitySession, WsrmMessageInfo info);
}
internal class System.ServiceModel.Channels.CreateSequenceResponse : BodyWriter {
    private AddressingVersion _addressingVersion;
    private ReliableMessagingVersion _reliableMessagingVersion;
    [CompilerGeneratedAttribute]
private EndpointAddress <AcceptAcksTo>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<TimeSpan> <Expires>k__BackingField;
    [CompilerGeneratedAttribute]
private UniqueId <Identifier>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <Ordered>k__BackingField;
    public EndpointAddress AcceptAcksTo { get; public set; }
    public Nullable`1<TimeSpan> Expires { get; public set; }
    public UniqueId Identifier { get; public set; }
    public bool Ordered { get; public set; }
    public CreateSequenceResponse(AddressingVersion addressingVersion, ReliableMessagingVersion reliableMessagingVersion);
    [CompilerGeneratedAttribute]
public EndpointAddress get_AcceptAcksTo();
    [CompilerGeneratedAttribute]
public void set_AcceptAcksTo(EndpointAddress value);
    [CompilerGeneratedAttribute]
public Nullable`1<TimeSpan> get_Expires();
    [CompilerGeneratedAttribute]
public void set_Expires(Nullable`1<TimeSpan> value);
    [CompilerGeneratedAttribute]
public UniqueId get_Identifier();
    [CompilerGeneratedAttribute]
public void set_Identifier(UniqueId value);
    [CompilerGeneratedAttribute]
public bool get_Ordered();
    [CompilerGeneratedAttribute]
public void set_Ordered(bool value);
    public static CreateSequenceResponseInfo Create(AddressingVersion addressingVersion, ReliableMessagingVersion reliableMessagingVersion, XmlDictionaryReader reader);
    protected virtual void OnWriteBodyContents(XmlDictionaryWriter writer);
}
internal class System.ServiceModel.Channels.CreateSequenceResponseInfo : object {
    [CompilerGeneratedAttribute]
private EndpointAddress <AcceptAcksTo>k__BackingField;
    [CompilerGeneratedAttribute]
private UniqueId <Identifier>k__BackingField;
    [CompilerGeneratedAttribute]
private UniqueId <RelatesTo>k__BackingField;
    public EndpointAddress AcceptAcksTo { get; public set; }
    public UniqueId Identifier { get; public set; }
    public UniqueId RelatesTo { get; public set; }
    [CompilerGeneratedAttribute]
public EndpointAddress get_AcceptAcksTo();
    [CompilerGeneratedAttribute]
public void set_AcceptAcksTo(EndpointAddress value);
    [CompilerGeneratedAttribute]
public UniqueId get_Identifier();
    [CompilerGeneratedAttribute]
public void set_Identifier(UniqueId value);
    [CompilerGeneratedAttribute]
public UniqueId get_RelatesTo();
    [CompilerGeneratedAttribute]
public void set_RelatesTo(UniqueId value);
    public static CreateSequenceResponseInfo ReadMessage(MessageVersion messageVersion, ReliableMessagingVersion reliableMessagingVersion, Message message, MessageHeaders headers);
}
public class System.ServiceModel.Channels.CustomBinding : Binding {
    [CompilerGeneratedAttribute]
private BindingElementCollection <Elements>k__BackingField;
    public BindingElementCollection Elements { get; }
    public string Scheme { get; }
    public CustomBinding(BindingElement[] bindingElementsInTopDownChannelStackOrder);
    public CustomBinding(string name, string ns, BindingElement[] bindingElementsInTopDownChannelStackOrder);
    public CustomBinding(IEnumerable`1<BindingElement> bindingElementsInTopDownChannelStackOrder);
    internal CustomBinding(BindingElementCollection bindingElements);
    public CustomBinding(Binding binding);
    internal CustomBinding(Binding binding, BindingElementCollection elements);
    private static BindingElementCollection SafeCreateBindingElements(Binding binding);
    [CompilerGeneratedAttribute]
public BindingElementCollection get_Elements();
    public virtual BindingElementCollection CreateBindingElements();
    public virtual string get_Scheme();
}
internal class System.ServiceModel.Channels.DefaultMessageBuffer : MessageBuffer {
    private XmlBuffer _msgBuffer;
    private KeyValuePair`2[] _properties;
    private Boolean[] _understoodHeaders;
    private bool _closed;
    private MessageVersion _version;
    private Uri _to;
    private string _action;
    private bool _isNullMessage;
    private object ThisLock { get; }
    public int BufferSize { get; }
    public DefaultMessageBuffer(Message message, XmlBuffer msgBuffer);
    private object get_ThisLock();
    public virtual int get_BufferSize();
    public virtual void Close();
    public virtual Message CreateMessage();
}
internal abstract class System.ServiceModel.Channels.DelegatingMessage : Message {
    [CompilerGeneratedAttribute]
private Message <InnerMessage>k__BackingField;
    public bool IsEmpty { get; }
    public bool IsFault { get; }
    public MessageHeaders Headers { get; }
    public MessageProperties Properties { get; }
    public MessageVersion Version { get; }
    protected Message InnerMessage { get; }
    protected DelegatingMessage(Message innerMessage);
    public virtual bool get_IsEmpty();
    public virtual bool get_IsFault();
    public virtual MessageHeaders get_Headers();
    public virtual MessageProperties get_Properties();
    public virtual MessageVersion get_Version();
    [CompilerGeneratedAttribute]
protected Message get_InnerMessage();
    protected virtual void OnClose();
    protected virtual void OnWriteStartEnvelope(XmlDictionaryWriter writer);
    protected virtual void OnWriteStartHeaders(XmlDictionaryWriter writer);
    protected virtual void OnWriteStartBody(XmlDictionaryWriter writer);
    protected virtual void OnWriteBodyContents(XmlDictionaryWriter writer);
    protected virtual string OnGetBodyAttribute(string localName, string ns);
    protected virtual void OnBodyToString(XmlDictionaryWriter writer);
}
public abstract class System.ServiceModel.Channels.DelegatingStream : Stream {
    private bool _disposed;
    [CompilerGeneratedAttribute]
private Stream <BaseStream>k__BackingField;
    protected Stream BaseStream { get; }
    public bool CanRead { get; }
    public bool CanSeek { get; }
    public bool CanTimeout { get; }
    public bool CanWrite { get; }
    public long Length { get; }
    public long Position { get; public set; }
    public int ReadTimeout { get; public set; }
    public int WriteTimeout { get; public set; }
    protected DelegatingStream(Stream stream);
    [CompilerGeneratedAttribute]
protected Stream get_BaseStream();
    public virtual bool get_CanRead();
    public virtual bool get_CanSeek();
    public virtual bool get_CanTimeout();
    public virtual bool get_CanWrite();
    public virtual long get_Length();
    protected virtual void Dispose(bool disposing);
    [AsyncStateMachineAttribute("System.ServiceModel.Channels.DelegatingStream/<DisposeAsync>d__16")]
public virtual ValueTask DisposeAsync();
    public virtual long get_Position();
    public virtual void set_Position(long value);
    public virtual int get_ReadTimeout();
    public virtual void set_ReadTimeout(int value);
    public virtual int get_WriteTimeout();
    public virtual void set_WriteTimeout(int value);
    public virtual Task CopyToAsync(Stream destination, int bufferSize, CancellationToken cancellationToken);
    public virtual void Flush();
    public virtual Task FlushAsync(CancellationToken cancellationToken);
    public virtual long Seek(long offset, SeekOrigin origin);
    public virtual void SetLength(long value);
    public virtual IAsyncResult BeginRead(Byte[] buffer, int offset, int count, AsyncCallback callback, object state);
    public virtual int EndRead(IAsyncResult asyncResult);
    public virtual int Read(Byte[] buffer, int offset, int count);
    public virtual int ReadByte();
    public virtual Task`1<int> ReadAsync(Byte[] buffer, int offset, int count, CancellationToken cancellationToken);
    public virtual ValueTask`1<int> ReadAsync(Memory`1<byte> buffer, CancellationToken cancellationToken);
    public virtual IAsyncResult BeginWrite(Byte[] buffer, int offset, int count, AsyncCallback callback, object state);
    public virtual void EndWrite(IAsyncResult asyncResult);
    public virtual void Write(Byte[] buffer, int offset, int count);
    public virtual void WriteByte(byte value);
    public virtual Task WriteAsync(Byte[] buffer, int offset, int count, CancellationToken cancellationToken);
    public virtual ValueTask WriteAsync(ReadOnlyMemory`1<byte> buffer, CancellationToken cancellationToken);
    [CompilerGeneratedAttribute]
[DebuggerHiddenAttribute]
private ValueTask <>n__0();
}
internal abstract class System.ServiceModel.Channels.DeliveryStrategy`1 : object {
    [CompilerGeneratedAttribute]
private InputQueueChannel`1<ItemType> <Channel>k__BackingField;
    [CompilerGeneratedAttribute]
private Action <DequeueCallback>k__BackingField;
    [CompilerGeneratedAttribute]
private int <Quota>k__BackingField;
    protected InputQueueChannel`1<ItemType> Channel { get; }
    public Action DequeueCallback { get; public set; }
    public int EnqueuedCount { get; }
    protected int Quota { get; }
    public DeliveryStrategy`1(InputQueueChannel`1<ItemType> channel, int quota);
    [CompilerGeneratedAttribute]
protected InputQueueChannel`1<ItemType> get_Channel();
    [CompilerGeneratedAttribute]
public Action get_DequeueCallback();
    [CompilerGeneratedAttribute]
public void set_DequeueCallback(Action value);
    public abstract virtual int get_EnqueuedCount();
    [CompilerGeneratedAttribute]
protected int get_Quota();
    public abstract virtual bool CanEnqueue(long sequenceNumber);
    public virtual void Dispose();
    public abstract virtual bool Enqueue(ItemType item, long sequenceNumber);
}
internal abstract class System.ServiceModel.Channels.DetectEofStream : DelegatingStream {
    [CompilerGeneratedAttribute]
private bool <IsAtEof>k__BackingField;
    protected bool IsAtEof { get; private set; }
    protected DetectEofStream(Stream stream);
    [CompilerGeneratedAttribute]
protected bool get_IsAtEof();
    [CompilerGeneratedAttribute]
private void set_IsAtEof(bool value);
    [AsyncStateMachineAttribute("System.ServiceModel.Channels.DetectEofStream/<ReadAsync>d__5")]
public virtual Task`1<int> ReadAsync(Byte[] buffer, int offset, int count, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("System.ServiceModel.Channels.DetectEofStream/<ReadAsync>d__6")]
public virtual ValueTask`1<int> ReadAsync(Memory`1<byte> buffer, CancellationToken cancellationToken);
    public virtual int ReadByte();
    public virtual int Read(Byte[] buffer, int offset, int count);
    private void ReceivedEof();
    protected virtual void OnReceivedEof();
    [CompilerGeneratedAttribute]
[DebuggerHiddenAttribute]
private Task`1<int> <>n__0(Byte[] buffer, int offset, int count, CancellationToken cancellationToken);
    [CompilerGeneratedAttribute]
[DebuggerHiddenAttribute]
private ValueTask`1<int> <>n__1(Memory`1<byte> buffer, CancellationToken cancellationToken);
}
internal abstract class System.ServiceModel.Channels.DictionaryHeader : MessageHeader {
    public string Name { get; }
    public string Namespace { get; }
    public XmlDictionaryString DictionaryName { get; }
    public XmlDictionaryString DictionaryNamespace { get; }
    public virtual string get_Name();
    public virtual string get_Namespace();
    public abstract virtual XmlDictionaryString get_DictionaryName();
    public abstract virtual XmlDictionaryString get_DictionaryNamespace();
    protected virtual void OnWriteStartHeader(XmlDictionaryWriter writer, MessageVersion messageVersion);
}
internal abstract class System.ServiceModel.Channels.DuplexChannel : InputQueueChannel`1<Message> {
    [CompilerGeneratedAttribute]
private EndpointAddress <LocalAddress>k__BackingField;
    public EndpointAddress LocalAddress { get; }
    public EndpointAddress RemoteAddress { get; }
    public Uri Via { get; }
    protected DuplexChannel(ChannelManagerBase channelManager, EndpointAddress localAddress);
    [CompilerGeneratedAttribute]
public virtual EndpointAddress get_LocalAddress();
    public abstract virtual EndpointAddress get_RemoteAddress();
    public abstract virtual Uri get_Via();
    public sealed virtual Task SendAsync(Message message);
    public sealed virtual Task SendAsync(Message message, TimeSpan timeout);
    public sealed virtual IAsyncResult BeginSend(Message message, AsyncCallback callback, object state);
    public sealed virtual IAsyncResult BeginSend(Message message, TimeSpan timeout, AsyncCallback callback, object state);
    public sealed virtual void EndSend(IAsyncResult result);
    public virtual T GetProperty();
    protected abstract virtual Task OnSendAsync(Message message, TimeSpan timeout);
    public sealed virtual void Send(Message message);
    public sealed virtual void Send(Message message, TimeSpan timeout);
    protected virtual void AddHeadersTo(Message message);
    public sealed virtual Task`1<Message> ReceiveAsync();
    public sealed virtual Task`1<Message> ReceiveAsync(TimeSpan timeout);
    public sealed virtual Message Receive();
    public sealed virtual Message Receive(TimeSpan timeout);
    public sealed virtual IAsyncResult BeginReceive(AsyncCallback callback, object state);
    public sealed virtual IAsyncResult BeginReceive(TimeSpan timeout, AsyncCallback callback, object state);
    public sealed virtual Message EndReceive(IAsyncResult result);
    public sealed virtual Task`1<ValueTuple`2<bool, Message>> TryReceiveAsync(TimeSpan timeout);
    public sealed virtual bool TryReceive(TimeSpan timeout, Message& message);
    public sealed virtual IAsyncResult BeginTryReceive(TimeSpan timeout, AsyncCallback callback, object state);
    public sealed virtual bool EndTryReceive(IAsyncResult result, Message& message);
    public sealed virtual Task`1<bool> WaitForMessageAsync(TimeSpan timeout);
    public sealed virtual bool WaitForMessage(TimeSpan timeout);
    public sealed virtual IAsyncResult BeginWaitForMessage(TimeSpan timeout, AsyncCallback callback, object state);
    public sealed virtual bool EndWaitForMessage(IAsyncResult result);
}
internal class System.ServiceModel.Channels.EmptyBodyWriter : BodyWriter {
    private static EmptyBodyWriter s_value;
    public static EmptyBodyWriter Value { get; }
    internal bool IsEmpty { get; }
    public static EmptyBodyWriter get_Value();
    internal virtual bool get_IsEmpty();
    protected virtual void OnWriteBodyContents(XmlDictionaryWriter writer);
}
internal static class System.ServiceModel.Channels.EncoderDefaults : object {
    public static int MaxReadPoolSize;
    public static int MaxWritePoolSize;
    public static int MaxDepth;
    public static int MaxStringContentLength;
    public static int MaxArrayLength;
    public static int MaxBytesPerRead;
    public static int MaxNameTableCharCount;
    public static int BufferedReadDefaultMaxDepth;
    public static int BufferedReadDefaultMaxStringContentLength;
    public static int BufferedReadDefaultMaxArrayLength;
    public static int BufferedReadDefaultMaxBytesPerRead;
    public static int BufferedReadDefaultMaxNameTableCharCount;
    public static CompressionFormat DefaultCompressionFormat;
    public static XmlDictionaryReaderQuotas ReaderQuotas;
    private static EncoderDefaults();
    public static bool IsDefaultReaderQuotas(XmlDictionaryReaderQuotas quotas);
}
internal static class System.ServiceModel.Channels.EncoderHelpers : object {
    internal static XmlDictionaryReaderQuotas GetBufferedReadQuotas(XmlDictionaryReaderQuotas encoderQuotas);
    private static bool IsDefaultQuota(XmlDictionaryReaderQuotas quotas, XmlDictionaryReaderQuotaTypes quotaType);
}
internal static class System.ServiceModel.Channels.ExtendedProtectionPolicyHelper : object {
    private static ExtendedProtectionPolicy s_disabledPolicy;
    [CompilerGeneratedAttribute]
private static ExtendedProtectionPolicy <DefaultPolicy>k__BackingField;
    public static ExtendedProtectionPolicy DefaultPolicy { get; }
    private static ExtendedProtectionPolicyHelper();
    [CompilerGeneratedAttribute]
public static ExtendedProtectionPolicy get_DefaultPolicy();
}
internal class System.ServiceModel.Channels.FaultBodyWriter : BodyWriter {
    private MessageFault _fault;
    private EnvelopeVersion _version;
    internal bool IsFault { get; }
    public FaultBodyWriter(MessageFault fault, EnvelopeVersion version);
    internal virtual bool get_IsFault();
    protected virtual void OnWriteBodyContents(XmlDictionaryWriter writer);
}
public abstract class System.ServiceModel.Channels.FaultConverter : object {
    public static FaultConverter GetDefaultFaultConverter(MessageVersion version);
    protected abstract virtual bool OnTryCreateException(Message message, MessageFault fault, Exception& exception);
    protected abstract virtual bool OnTryCreateFaultMessage(Exception exception, Message& message);
    public bool TryCreateException(Message message, MessageFault fault, Exception& exception);
    public bool TryCreateFaultMessage(Exception exception, Message& message);
}
internal abstract class System.ServiceModel.Channels.FaultHelper : object {
    [CompilerGeneratedAttribute]
private object <ThisLock>k__BackingField;
    protected object ThisLock { get; }
    [CompilerGeneratedAttribute]
protected object get_ThisLock();
    public abstract virtual void Abort();
    public static bool AddressReply(Message message, Message faultMessage);
    public abstract virtual Task CloseAsync(TimeSpan timeout);
    public abstract virtual Task SendFaultAsync(IReliableChannelBinder binder, RequestContext requestContext, Message faultMessage);
}
internal class System.ServiceModel.Channels.FaultState : ValueType {
    [CompilerGeneratedAttribute]
private Message <FaultMessage>k__BackingField;
    [CompilerGeneratedAttribute]
private RequestContext <RequestContext>k__BackingField;
    public Message FaultMessage { get; }
    public RequestContext RequestContext { get; }
    public FaultState(RequestContext requestContext, Message faultMessage);
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public Message get_FaultMessage();
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public RequestContext get_RequestContext();
}
internal class System.ServiceModel.Channels.FaultToHeader : AddressingHeader {
    private static bool mustUnderstandValue;
    [CompilerGeneratedAttribute]
private EndpointAddress <FaultTo>k__BackingField;
    public EndpointAddress FaultTo { get; }
    public XmlDictionaryString DictionaryName { get; }
    public bool MustUnderstand { get; }
    private FaultToHeader(EndpointAddress faultTo, AddressingVersion version);
    [CompilerGeneratedAttribute]
public EndpointAddress get_FaultTo();
    public virtual XmlDictionaryString get_DictionaryName();
    public virtual bool get_MustUnderstand();
    protected virtual void OnWriteHeaderContents(XmlDictionaryWriter writer, MessageVersion messageVersion);
    public static FaultToHeader Create(EndpointAddress faultTo, AddressingVersion addressingVersion);
    public static FaultToHeader ReadHeader(XmlDictionaryReader reader, AddressingVersion version, string actor, bool mustUnderstand, bool relay);
    public static EndpointAddress ReadHeaderValue(XmlDictionaryReader reader, AddressingVersion version);
}
internal class System.ServiceModel.Channels.FromHeader : AddressingHeader {
    private static bool mustUnderstandValue;
    [CompilerGeneratedAttribute]
private EndpointAddress <From>k__BackingField;
    public EndpointAddress From { get; }
    public XmlDictionaryString DictionaryName { get; }
    public bool MustUnderstand { get; }
    private FromHeader(EndpointAddress from, AddressingVersion version);
    [CompilerGeneratedAttribute]
public EndpointAddress get_From();
    public virtual XmlDictionaryString get_DictionaryName();
    public virtual bool get_MustUnderstand();
    public static FromHeader Create(EndpointAddress from, AddressingVersion addressingVersion);
    protected virtual void OnWriteHeaderContents(XmlDictionaryWriter writer, MessageVersion messageVersion);
    public static FromHeader ReadHeader(XmlDictionaryReader reader, AddressingVersion version, string actor, bool mustUnderstand, bool relay);
    public static EndpointAddress ReadHeaderValue(XmlDictionaryReader reader, AddressingVersion addressingVersion);
}
internal class System.ServiceModel.Channels.Guard : object {
    private TaskCompletionSource`1<object> _tcs;
    private int _currentCount;
    private int _maxCount;
    private bool _closed;
    private object _thisLock;
    public Guard(int maxCount);
    public void Abort();
    [AsyncStateMachineAttribute("System.ServiceModel.Channels.Guard/<CloseAsync>d__8")]
public Task CloseAsync(TimeSpan timeout);
    public bool Enter();
    public void Exit();
}
internal class System.ServiceModel.Channels.HeaderInfoCache : object {
    private static int maxHeaderInfos;
    private HeaderInfo[] _headerInfos;
    private int _index;
    public MessageHeaderInfo TakeHeaderInfo(XmlDictionaryReader reader, string actor, bool mustUnderstand, bool relay, bool isRefParam);
    public void ReturnHeaderInfo(MessageHeaderInfo headerInfo);
}
public interface System.ServiceModel.Channels.IAsyncChannelFactory {
}
internal interface System.ServiceModel.Channels.IAsyncDuplexChannel {
}
internal interface System.ServiceModel.Channels.IAsyncDuplexSession {
    public abstract virtual Task CloseOutputSessionAsync();
    public abstract virtual Task CloseOutputSessionAsync(TimeSpan timeout);
}
internal interface System.ServiceModel.Channels.IAsyncDuplexSessionChannel {
}
public interface System.ServiceModel.Channels.IAsyncInputChannel {
    public abstract virtual Task`1<Message> ReceiveAsync();
    public abstract virtual Task`1<Message> ReceiveAsync(TimeSpan timeout);
    public abstract virtual Task`1<ValueTuple`2<bool, Message>> TryReceiveAsync(TimeSpan timeout);
    public abstract virtual Task`1<bool> WaitForMessageAsync(TimeSpan timeout);
}
public interface System.ServiceModel.Channels.IAsyncOutputChannel {
    public abstract virtual Task SendAsync(Message message);
    public abstract virtual Task SendAsync(Message message, TimeSpan timeout);
}
public interface System.ServiceModel.Channels.IAsyncOutputSessionChannel {
}
internal interface System.ServiceModel.Channels.IAsyncRequest {
    public abstract virtual Task SendRequestAsync(Message message, TimeoutHelper timeoutHelper);
    public abstract virtual Task`1<Message> ReceiveReplyAsync(TimeoutHelper timeoutHelper);
}
internal interface System.ServiceModel.Channels.IAsyncRequestChannel {
    public abstract virtual Task`1<Message> RequestAsync(Message message);
    public abstract virtual Task`1<Message> RequestAsync(Message message, TimeSpan timeout);
}
internal interface System.ServiceModel.Channels.IAsyncRequestSessionChannel {
}
public interface System.ServiceModel.Channels.IBindingDeliveryCapabilities {
    public bool AssuresOrderedDelivery { get; }
    public bool QueuedDelivery { get; }
    public abstract virtual bool get_AssuresOrderedDelivery();
    public abstract virtual bool get_QueuedDelivery();
}
public interface System.ServiceModel.Channels.IBindingMulticastCapabilities {
    public bool IsMulticast { get; }
    public abstract virtual bool get_IsMulticast();
}
public interface System.ServiceModel.Channels.IBindingRuntimePreferences {
    public bool ReceiveSynchronously { get; }
    public abstract virtual bool get_ReceiveSynchronously();
}
internal interface System.ServiceModel.Channels.IBufferedMessageData {
    public MessageEncoder MessageEncoder { get; }
    public ArraySegment`1<byte> Buffer { get; }
    public XmlDictionaryReaderQuotas Quotas { get; }
    public abstract virtual MessageEncoder get_MessageEncoder();
    public abstract virtual ArraySegment`1<byte> get_Buffer();
    public abstract virtual XmlDictionaryReaderQuotas get_Quotas();
    public abstract virtual void Close();
    public abstract virtual void EnableMultipleUsers();
    public abstract virtual XmlDictionaryReader GetMessageReader();
    public abstract virtual void Open();
    public abstract virtual void ReturnMessageState(RecycledMessageState messageState);
    public abstract virtual RecycledMessageState TakeMessageState();
}
public interface System.ServiceModel.Channels.IChannel {
    public abstract virtual T GetProperty();
}
internal interface System.ServiceModel.Channels.IChannelAcceptor`1 {
    public abstract virtual TChannel AcceptChannel(TimeSpan timeout);
    public abstract virtual IAsyncResult BeginAcceptChannel(TimeSpan timeout, AsyncCallback callback, object state);
    public abstract virtual TChannel EndAcceptChannel(IAsyncResult result);
    public abstract virtual bool WaitForChannel(TimeSpan timeout);
    public abstract virtual IAsyncResult BeginWaitForChannel(TimeSpan timeout, AsyncCallback callback, object state);
    public abstract virtual bool EndWaitForChannel(IAsyncResult result);
}
internal interface System.ServiceModel.Channels.IChannelBindingProvider {
    public bool IsChannelBindingSupportEnabled { get; }
    public abstract virtual void EnableChannelBindingSupport();
    public abstract virtual bool get_IsChannelBindingSupportEnabled();
}
public interface System.ServiceModel.Channels.IChannelFactory {
    public abstract virtual T GetProperty();
}
public interface System.ServiceModel.Channels.IChannelFactory`1 {
    public abstract virtual TChannel CreateChannel(EndpointAddress to);
    public abstract virtual TChannel CreateChannel(EndpointAddress to, Uri via);
}
public interface System.ServiceModel.Channels.IChannelListener {
    public Uri Uri { get; }
    public abstract virtual Uri get_Uri();
    public abstract virtual T GetProperty();
    public abstract virtual bool WaitForChannel(TimeSpan timeout);
    public abstract virtual IAsyncResult BeginWaitForChannel(TimeSpan timeout, AsyncCallback callback, object state);
    public abstract virtual bool EndWaitForChannel(IAsyncResult result);
}
public interface System.ServiceModel.Channels.IChannelListener`1 {
    public abstract virtual TChannel AcceptChannel();
    public abstract virtual TChannel AcceptChannel(TimeSpan timeout);
    public abstract virtual IAsyncResult BeginAcceptChannel(AsyncCallback callback, object state);
    public abstract virtual IAsyncResult BeginAcceptChannel(TimeSpan timeout, AsyncCallback callback, object state);
    public abstract virtual TChannel EndAcceptChannel(IAsyncResult result);
}
internal interface System.ServiceModel.Channels.IClientReliableChannelBinder {
    public Uri Via { get; }
    public abstract virtual Uri get_Via();
    [CompilerGeneratedAttribute]
public abstract virtual void add_ConnectionLost(EventHandler value);
    [CompilerGeneratedAttribute]
public abstract virtual void remove_ConnectionLost(EventHandler value);
    public abstract virtual Task`1<bool> EnsureChannelForRequestAsync();
    public abstract virtual Task`1<Message> RequestAsync(Message message, TimeSpan timeout);
    public abstract virtual Task`1<Message> RequestAsync(Message message, TimeSpan timeout, MaskingMode maskingMode);
}
internal interface System.ServiceModel.Channels.ICommunicationWaiter {
    public abstract virtual void Signal();
    public abstract virtual Task`1<CommunicationWaitResult> WaitAsync(TimeSpan timeout, bool aborting);
    public abstract virtual CommunicationWaitResult Wait(TimeSpan timeout, bool aborting);
}
internal interface System.ServiceModel.Channels.ICompressedMessageEncoder {
    public bool CompressionEnabled { get; }
    public abstract virtual bool get_CompressionEnabled();
    public abstract virtual void SetSessionContentType(string contentType);
    public abstract virtual void AddCompressedMessageProperties(Message message, string supportedCompressionTypes);
}
internal interface System.ServiceModel.Channels.ICorrelatorKey {
    public Key RequestCorrelatorKey { get; public set; }
    public abstract virtual Key get_RequestCorrelatorKey();
    public abstract virtual void set_RequestCorrelatorKey(Key value);
}
public interface System.ServiceModel.Channels.IDuplexChannel {
}
public interface System.ServiceModel.Channels.IDuplexSession {
    public abstract virtual void CloseOutputSession();
    public abstract virtual void CloseOutputSession(TimeSpan timeout);
    public abstract virtual IAsyncResult BeginCloseOutputSession(AsyncCallback callback, object state);
    public abstract virtual IAsyncResult BeginCloseOutputSession(TimeSpan timeout, AsyncCallback callback, object state);
    public abstract virtual void EndCloseOutputSession(IAsyncResult result);
}
public interface System.ServiceModel.Channels.IDuplexSessionChannel {
}
public interface System.ServiceModel.Channels.IInputChannel {
    public EndpointAddress LocalAddress { get; }
    public abstract virtual EndpointAddress get_LocalAddress();
    public abstract virtual Message Receive();
    public abstract virtual Message Receive(TimeSpan timeout);
    public abstract virtual IAsyncResult BeginReceive(AsyncCallback callback, object state);
    public abstract virtual IAsyncResult BeginReceive(TimeSpan timeout, AsyncCallback callback, object state);
    public abstract virtual Message EndReceive(IAsyncResult result);
    public abstract virtual bool TryReceive(TimeSpan timeout, Message& message);
    public abstract virtual IAsyncResult BeginTryReceive(TimeSpan timeout, AsyncCallback callback, object state);
    public abstract virtual bool EndTryReceive(IAsyncResult result, Message& message);
    public abstract virtual bool WaitForMessage(TimeSpan timeout);
    public abstract virtual IAsyncResult BeginWaitForMessage(TimeSpan timeout, AsyncCallback callback, object state);
    public abstract virtual bool EndWaitForMessage(IAsyncResult result);
}
public interface System.ServiceModel.Channels.IInputSession {
}
public interface System.ServiceModel.Channels.IInputSessionChannel {
}
internal interface System.ServiceModel.Channels.IMergeEnabledMessageProperty {
    public abstract virtual bool TryMergeWithProperty(object propertyToMerge);
}
internal interface System.ServiceModel.Channels.IMessageHeaderWithSharedNamespace {
    public XmlDictionaryString SharedNamespace { get; }
    public XmlDictionaryString SharedPrefix { get; }
    public abstract virtual XmlDictionaryString get_SharedNamespace();
    public abstract virtual XmlDictionaryString get_SharedPrefix();
}
public interface System.ServiceModel.Channels.IMessageProperty {
    public abstract virtual IMessageProperty CreateCopy();
}
internal class System.ServiceModel.Channels.InputChannel : object {
    [AsyncStateMachineAttribute("System.ServiceModel.Channels.InputChannel/<HelpReceiveAsync>d__0")]
internal static Task`1<Message> HelpReceiveAsync(IAsyncInputChannel channel, TimeSpan timeout);
    private static Exception CreateReceiveTimedOutException(IInputChannel channel, TimeSpan timeout);
}
internal abstract class System.ServiceModel.Channels.InputQueueChannel`1 : ChannelBase {
    private InputQueue`1<TDisposable> _inputQueue;
    public int InternalPendingItems { get; }
    public int PendingItems { get; }
    protected InputQueueChannel`1(ChannelManagerBase channelManager);
    public int get_InternalPendingItems();
    public int get_PendingItems();
    public void EnqueueAndDispatch(TDisposable item);
    public void EnqueueAndDispatch(TDisposable item, Action dequeuedCallback, bool canDispatchOnThisThread);
    public void EnqueueAndDispatch(Exception exception, Action dequeuedCallback, bool canDispatchOnThisThread);
    public void EnqueueAndDispatch(TDisposable item, Action dequeuedCallback);
    public bool EnqueueWithoutDispatch(Exception exception, Action dequeuedCallback);
    public bool EnqueueWithoutDispatch(TDisposable item, Action dequeuedCallback);
    public void Dispatch();
    public void Shutdown();
    protected virtual void OnFaulted();
    protected virtual void OnEnqueueItem(TDisposable item);
    [AsyncStateMachineAttribute("System.ServiceModel.Channels.InputQueueChannel`1/<DequeueAsync>d__16")]
protected Task`1<ValueTuple`2<bool, TDisposable>> DequeueAsync(TimeSpan timeout);
    [AsyncStateMachineAttribute("System.ServiceModel.Channels.InputQueueChannel`1/<WaitForItemAsync>d__17")]
protected Task`1<bool> WaitForItemAsync(TimeSpan timeout);
    protected virtual void OnClosing();
    protected virtual void OnAbort();
    protected virtual void OnClose(TimeSpan timeout);
    protected internal virtual Task OnCloseAsync(TimeSpan timeout);
    protected virtual IAsyncResult OnBeginClose(TimeSpan timeout, AsyncCallback callback, object state);
    protected virtual void OnEndClose(IAsyncResult result);
    [CompilerGeneratedAttribute]
private Exception <OnFaulted>b__14_0();
    [CompilerGeneratedAttribute]
private Exception <OnClosing>b__18_0();
}
internal class System.ServiceModel.Channels.IntDecoderHelper : ValueType {
    private int _value;
    private short _index;
    private static int LastIndex;
    [CompilerGeneratedAttribute]
private bool <IsValueDecoded>k__BackingField;
    public int Value { get; }
    public bool IsValueDecoded { get; private set; }
    public int get_Value();
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public bool get_IsValueDecoded();
    [CompilerGeneratedAttribute]
private void set_IsValueDecoded(bool value);
    public void Reset();
    public int Decode(Byte[] buffer, int offset, int size);
    public static void ValidateSize(int size);
}
internal class System.ServiceModel.Channels.InternalDuplexBindingElement : object {
}
internal class System.ServiceModel.Channels.InterruptibleTimer : object {
    private WaitCallback _callback;
    private AsyncWaitCallback _asyncCallback;
    private bool _aborted;
    private TimeSpan _defaultInterval;
    private static Action`1<object> s_onTimerElapsed;
    private static Func`2<object, Task> s_onTimerElapsedAsync;
    private bool _set;
    private object _state;
    private IOThreadTimer _timer;
    private bool _isAsync;
    [CompilerGeneratedAttribute]
private object <ThisLock>k__BackingField;
    private object ThisLock { get; }
    public InterruptibleTimer(TimeSpan defaultInterval, WaitCallback callback, object state);
    public InterruptibleTimer(TimeSpan defaultInterval, AsyncWaitCallback callback, object state);
    private InterruptibleTimer(TimeSpan defaultInterval, WaitCallback callback, AsyncWaitCallback asyncCallback, object state);
    private static InterruptibleTimer();
    [CompilerGeneratedAttribute]
private object get_ThisLock();
    public void Abort();
    public bool Cancel();
    private void OnTimerElapsed();
    private Task OnTimerElapsedAsync();
    private static void OnTimerElapsed(object state);
    private static Task OnTimerElapsedAsync(object state);
    public void Set();
    public void Set(TimeSpan interval);
    public void SetIfNotSet();
    private void InternalSet(TimeSpan interval, bool ifNotSet);
}
internal class System.ServiceModel.Channels.InterruptibleWaitObject : object {
    private bool _aborted;
    private CommunicationObject _communicationObject;
    private bool _set;
    private int _syncWaiters;
    private object _thisLock;
    private bool _throwTimeoutByDefault;
    private TaskCompletionSource`1<object> _tcs;
    public InterruptibleWaitObject(bool signaled);
    public InterruptibleWaitObject(bool signaled, bool throwTimeoutByDefault);
    public void Abort(CommunicationObject communicationObject);
    public void Fault(CommunicationObject communicationObject);
    private Exception GetException();
    private void InternalSet();
    public void Reset();
    public void Set();
    public Task`1<bool> WaitAsync(TimeSpan timeout);
    [AsyncStateMachineAttribute("System.ServiceModel.Channels.InterruptibleWaitObject/<WaitAsync>d__16")]
public Task`1<bool> WaitAsync(TimeSpan timeout, bool throwTimeoutException);
}
internal class System.ServiceModel.Channels.InvalidAcknowledgementFault : WsrmHeaderFault {
    private SequenceRangeCollection _ranges;
    public InvalidAcknowledgementFault(UniqueId sequenceID, SequenceRangeCollection ranges);
    public InvalidAcknowledgementFault(FaultCode code, FaultReason reason, XmlDictionaryReader detailReader, ReliableMessagingVersion reliableMessagingVersion);
    protected virtual void OnWriteDetailContents(XmlDictionaryWriter writer);
}
public interface System.ServiceModel.Channels.IOutputChannel {
    public EndpointAddress RemoteAddress { get; }
    public Uri Via { get; }
    public abstract virtual EndpointAddress get_RemoteAddress();
    public abstract virtual Uri get_Via();
    public abstract virtual void Send(Message message);
    public abstract virtual void Send(Message message, TimeSpan timeout);
    public abstract virtual IAsyncResult BeginSend(Message message, AsyncCallback callback, object state);
    public abstract virtual IAsyncResult BeginSend(Message message, TimeSpan timeout, AsyncCallback callback, object state);
    public abstract virtual void EndSend(IAsyncResult result);
}
public interface System.ServiceModel.Channels.IOutputSession {
}
public interface System.ServiceModel.Channels.IOutputSessionChannel {
}
public interface System.ServiceModel.Channels.IReceiveContextSettings {
    public bool Enabled { get; public set; }
    public TimeSpan ValidityDuration { get; }
    public abstract virtual bool get_Enabled();
    public abstract virtual void set_Enabled(bool value);
    public abstract virtual TimeSpan get_ValidityDuration();
}
internal interface System.ServiceModel.Channels.IReliableChannelBinder {
    public IChannel Channel { get; }
    public bool Connected { get; }
    public TimeSpan DefaultSendTimeout { get; }
    public bool HasSession { get; }
    public EndpointAddress LocalAddress { get; }
    public EndpointAddress RemoteAddress { get; }
    public CommunicationState State { get; }
    public abstract virtual IChannel get_Channel();
    public abstract virtual bool get_Connected();
    public abstract virtual TimeSpan get_DefaultSendTimeout();
    public abstract virtual bool get_HasSession();
    public abstract virtual EndpointAddress get_LocalAddress();
    public abstract virtual EndpointAddress get_RemoteAddress();
    public abstract virtual CommunicationState get_State();
    [CompilerGeneratedAttribute]
public abstract virtual void add_Faulted(BinderExceptionHandler value);
    [CompilerGeneratedAttribute]
public abstract virtual void remove_Faulted(BinderExceptionHandler value);
    [CompilerGeneratedAttribute]
public abstract virtual void add_OnException(BinderExceptionHandler value);
    [CompilerGeneratedAttribute]
public abstract virtual void remove_OnException(BinderExceptionHandler value);
    public abstract virtual void Abort();
    public abstract virtual Task CloseAsync(TimeSpan timeout);
    public abstract virtual Task CloseAsync(TimeSpan timeout, MaskingMode maskingMode);
    public abstract virtual Task OpenAsync(TimeSpan timeout);
    public abstract virtual Task SendAsync(Message message, TimeSpan timeout);
    public abstract virtual Task SendAsync(Message message, TimeSpan timeout, MaskingMode maskingMode);
    public abstract virtual Task`1<ValueTuple`2<bool, RequestContext>> TryReceiveAsync(TimeSpan timeout);
    public abstract virtual Task`1<ValueTuple`2<bool, RequestContext>> TryReceiveAsync(TimeSpan timeout, MaskingMode maskingMode);
    public abstract virtual ISession GetInnerSession();
    public abstract virtual void HandleException(Exception e);
    public abstract virtual bool IsHandleable(Exception e);
    public abstract virtual void SetMaskingMode(RequestContext context, MaskingMode maskingMode);
    public abstract virtual RequestContext WrapRequestContext(RequestContext context);
}
internal interface System.ServiceModel.Channels.IReliableFactorySettings {
    public TimeSpan AcknowledgementInterval { get; }
    public bool FlowControlEnabled { get; }
    public TimeSpan InactivityTimeout { get; }
    public int MaxPendingChannels { get; }
    public int MaxRetryCount { get; }
    public int MaxTransferWindowSize { get; }
    public MessageVersion MessageVersion { get; }
    public bool Ordered { get; }
    public ReliableMessagingVersion ReliableMessagingVersion { get; }
    public TimeSpan SendTimeout { get; }
    public abstract virtual TimeSpan get_AcknowledgementInterval();
    public abstract virtual bool get_FlowControlEnabled();
    public abstract virtual TimeSpan get_InactivityTimeout();
    public abstract virtual int get_MaxPendingChannels();
    public abstract virtual int get_MaxRetryCount();
    public abstract virtual int get_MaxTransferWindowSize();
    public abstract virtual MessageVersion get_MessageVersion();
    public abstract virtual bool get_Ordered();
    public abstract virtual ReliableMessagingVersion get_ReliableMessagingVersion();
    public abstract virtual TimeSpan get_SendTimeout();
}
public interface System.ServiceModel.Channels.IReplyChannel {
    public EndpointAddress LocalAddress { get; }
    public abstract virtual EndpointAddress get_LocalAddress();
    public abstract virtual RequestContext ReceiveRequest();
    public abstract virtual RequestContext ReceiveRequest(TimeSpan timeout);
    public abstract virtual IAsyncResult BeginReceiveRequest(AsyncCallback callback, object state);
    public abstract virtual IAsyncResult BeginReceiveRequest(TimeSpan timeout, AsyncCallback callback, object state);
    public abstract virtual RequestContext EndReceiveRequest(IAsyncResult result);
    public abstract virtual bool TryReceiveRequest(TimeSpan timeout, RequestContext& context);
    public abstract virtual IAsyncResult BeginTryReceiveRequest(TimeSpan timeout, AsyncCallback callback, object state);
    public abstract virtual bool EndTryReceiveRequest(IAsyncResult result, RequestContext& context);
    public abstract virtual bool WaitForRequest(TimeSpan timeout);
    public abstract virtual IAsyncResult BeginWaitForRequest(TimeSpan timeout, AsyncCallback callback, object state);
    public abstract virtual bool EndWaitForRequest(IAsyncResult result);
}
public interface System.ServiceModel.Channels.IReplySessionChannel {
}
internal interface System.ServiceModel.Channels.IRequestBase {
    public abstract virtual void Abort(RequestChannel requestChannel);
    public abstract virtual void Fault(RequestChannel requestChannel);
    public abstract virtual void OnReleaseRequest();
}
public interface System.ServiceModel.Channels.IRequestChannel {
    public EndpointAddress RemoteAddress { get; }
    public Uri Via { get; }
    public abstract virtual EndpointAddress get_RemoteAddress();
    public abstract virtual Uri get_Via();
    public abstract virtual Message Request(Message message);
    public abstract virtual Message Request(Message message, TimeSpan timeout);
    public abstract virtual IAsyncResult BeginRequest(Message message, AsyncCallback callback, object state);
    public abstract virtual IAsyncResult BeginRequest(Message message, TimeSpan timeout, AsyncCallback callback, object state);
    public abstract virtual Message EndRequest(IAsyncResult result);
}
internal interface System.ServiceModel.Channels.IRequestReplyCorrelator {
    public abstract virtual void Add(Message request, T state);
    public abstract virtual T Find(Message reply, bool remove);
}
public interface System.ServiceModel.Channels.IRequestSessionChannel {
}
public interface System.ServiceModel.Channels.ISecurityCapabilities {
    public ProtectionLevel SupportedRequestProtectionLevel { get; }
    public ProtectionLevel SupportedResponseProtectionLevel { get; }
    public bool SupportsClientAuthentication { get; }
    public bool SupportsClientWindowsIdentity { get; }
    public bool SupportsServerAuthentication { get; }
    public abstract virtual ProtectionLevel get_SupportedRequestProtectionLevel();
    public abstract virtual ProtectionLevel get_SupportedResponseProtectionLevel();
    public abstract virtual bool get_SupportsClientAuthentication();
    public abstract virtual bool get_SupportsClientWindowsIdentity();
    public abstract virtual bool get_SupportsServerAuthentication();
}
public interface System.ServiceModel.Channels.ISession {
    public string Id { get; }
    public abstract virtual string get_Id();
}
public interface System.ServiceModel.Channels.ISessionChannel`1 {
    public TSession Session { get; }
    public abstract virtual TSession get_Session();
}
internal interface System.ServiceModel.Channels.IStreamedMessageEncoder {
    public abstract virtual Stream GetResponseMessageStream(Message message);
}
public interface System.ServiceModel.Channels.ITransportCompressionSupport {
    public abstract virtual bool IsCompressionFormatSupported(CompressionFormat compressionFormat);
}
internal interface System.ServiceModel.Channels.ITransportFactorySettings {
    public bool ManualAddressing { get; }
    public BufferManager BufferManager { get; }
    public long MaxReceivedMessageSize { get; }
    public MessageEncoderFactory MessageEncoderFactory { get; }
    public MessageVersion MessageVersion { get; }
    public abstract virtual bool get_ManualAddressing();
    public abstract virtual BufferManager get_BufferManager();
    public abstract virtual long get_MaxReceivedMessageSize();
    public abstract virtual MessageEncoderFactory get_MessageEncoderFactory();
    public abstract virtual MessageVersion get_MessageVersion();
}
internal class System.ServiceModel.Channels.LastMessageNumberExceededFault : WsrmHeaderFault {
    public LastMessageNumberExceededFault(UniqueId sequenceID);
    public LastMessageNumberExceededFault(FaultCode code, FaultReason reason, XmlDictionaryReader detailReader, ReliableMessagingVersion reliableMessagingVersion);
}
internal class System.ServiceModel.Channels.LateBoundChannelParameterCollection : ChannelParameterCollection {
    private IChannel _channel;
    protected IChannel Channel { get; }
    protected virtual IChannel get_Channel();
    internal void SetChannel(IChannel channel);
}
internal abstract class System.ServiceModel.Channels.LayeredChannel`1 : ChannelBase {
    private EventHandler _onInnerChannelFaulted;
    [CompilerGeneratedAttribute]
private TInnerChannel <InnerChannel>k__BackingField;
    protected TInnerChannel InnerChannel { get; }
    protected LayeredChannel`1(ChannelManagerBase channelManager, TInnerChannel innerChannel);
    [CompilerGeneratedAttribute]
protected TInnerChannel get_InnerChannel();
    public virtual T GetProperty();
    protected virtual void OnClosing();
    protected virtual void OnAbort();
    protected internal virtual Task OnCloseAsync(TimeSpan timeout);
    protected virtual void OnClose(TimeSpan timeout);
    protected virtual IAsyncResult OnBeginClose(TimeSpan timeout, AsyncCallback callback, object state);
    protected virtual void OnEndClose(IAsyncResult result);
    protected internal virtual Task OnOpenAsync(TimeSpan timeout);
    protected virtual void OnOpen(TimeSpan timeout);
    protected virtual IAsyncResult OnBeginOpen(TimeSpan timeout, AsyncCallback callback, object state);
    protected virtual void OnEndOpen(IAsyncResult result);
    private void OnInnerChannelFaulted(object sender, EventArgs e);
}
internal abstract class System.ServiceModel.Channels.LayeredChannelFactory`1 : ChannelFactoryBase`1<TChannel> {
    [CompilerGeneratedAttribute]
private IChannelFactory <InnerChannelFactory>k__BackingField;
    protected IChannelFactory InnerChannelFactory { get; }
    public LayeredChannelFactory`1(IDefaultCommunicationTimeouts timeouts, IChannelFactory innerChannelFactory);
    [CompilerGeneratedAttribute]
protected IChannelFactory get_InnerChannelFactory();
    public virtual T GetProperty();
    protected virtual IAsyncResult OnBeginOpen(TimeSpan timeout, AsyncCallback callback, object state);
    protected virtual void OnEndOpen(IAsyncResult result);
    protected virtual IAsyncResult OnBeginClose(TimeSpan timeout, AsyncCallback callback, object state);
    protected virtual void OnEndClose(IAsyncResult result);
    [AsyncStateMachineAttribute("System.ServiceModel.Channels.LayeredChannelFactory`1/<OnCloseAsync>d__9")]
protected internal virtual Task OnCloseAsync(TimeSpan timeout);
    protected virtual void OnClose(TimeSpan timeout);
    protected internal virtual Task OnOpenAsync(TimeSpan timeout);
    protected virtual void OnOpen(TimeSpan timeout);
    protected virtual void OnAbort();
    [CompilerGeneratedAttribute]
[DebuggerHiddenAttribute]
private Task <>n__0(TimeSpan timeout);
}
internal class System.ServiceModel.Channels.LayeredDuplexChannel : LayeredInputChannel {
    private IOutputChannel _innerOutputChannel;
    private EndpointAddress _localAddress;
    private EventHandler _onInnerOutputChannelFaulted;
    public EndpointAddress LocalAddress { get; }
    public EndpointAddress RemoteAddress { get; }
    public Uri Via { get; }
    public LayeredDuplexChannel(ChannelManagerBase channelManager, IInputChannel innerInputChannel, EndpointAddress localAddress, IOutputChannel innerOutputChannel);
    public virtual EndpointAddress get_LocalAddress();
    public sealed virtual EndpointAddress get_RemoteAddress();
    public sealed virtual Uri get_Via();
    protected virtual void OnClosing();
    protected virtual void OnAbort();
    protected virtual IAsyncResult OnBeginClose(TimeSpan timeout, AsyncCallback callback, object state);
    protected virtual void OnEndClose(IAsyncResult result);
    [AsyncStateMachineAttribute("System.ServiceModel.Channels.LayeredDuplexChannel/<OnCloseAsync>d__14")]
protected internal virtual Task OnCloseAsync(TimeSpan timeout);
    protected virtual void OnClose(TimeSpan timeout);
    protected virtual IAsyncResult OnBeginOpen(TimeSpan timeout, AsyncCallback callback, object state);
    protected virtual void OnEndOpen(IAsyncResult result);
    [AsyncStateMachineAttribute("System.ServiceModel.Channels.LayeredDuplexChannel/<OnOpenAsync>d__18")]
protected internal virtual Task OnOpenAsync(TimeSpan timeout);
    protected virtual void OnOpen(TimeSpan timeout);
    public sealed virtual Task SendAsync(Message message);
    public sealed virtual Task SendAsync(Message message, TimeSpan timeout);
    public sealed virtual void Send(Message message);
    public sealed virtual void Send(Message message, TimeSpan timeout);
    public sealed virtual IAsyncResult BeginSend(Message message, AsyncCallback callback, object state);
    public sealed virtual IAsyncResult BeginSend(Message message, TimeSpan timeout, AsyncCallback callback, object state);
    public sealed virtual void EndSend(IAsyncResult result);
    private void OnInnerOutputChannelFaulted(object sender, EventArgs e);
    [CompilerGeneratedAttribute]
[DebuggerHiddenAttribute]
private Task <>n__0(TimeSpan timeout);
    [CompilerGeneratedAttribute]
[DebuggerHiddenAttribute]
private Task <>n__1(TimeSpan timeout);
}
internal class System.ServiceModel.Channels.LayeredInputChannel : LayeredChannel`1<IInputChannel> {
    public EndpointAddress LocalAddress { get; }
    public LayeredInputChannel(ChannelManagerBase channelManager, IInputChannel innerChannel);
    public virtual EndpointAddress get_LocalAddress();
    private Task InternalOnReceiveAsync(Message message);
    protected virtual Task OnReceiveAsync(Message message);
    public sealed virtual Message Receive();
    [AsyncStateMachineAttribute("System.ServiceModel.Channels.LayeredInputChannel/<ReceiveAsync>d__6")]
public sealed virtual Task`1<Message> ReceiveAsync(TimeSpan timeout);
    [AsyncStateMachineAttribute("System.ServiceModel.Channels.LayeredInputChannel/<ReceiveAsync>d__7")]
public sealed virtual Task`1<Message> ReceiveAsync();
    public sealed virtual Message Receive(TimeSpan timeout);
    public sealed virtual IAsyncResult BeginReceive(AsyncCallback callback, object state);
    public sealed virtual IAsyncResult BeginReceive(TimeSpan timeout, AsyncCallback callback, object state);
    public sealed virtual Message EndReceive(IAsyncResult result);
    public sealed virtual IAsyncResult BeginTryReceive(TimeSpan timeout, AsyncCallback callback, object state);
    public sealed virtual bool EndTryReceive(IAsyncResult result, Message& message);
    [AsyncStateMachineAttribute("System.ServiceModel.Channels.LayeredInputChannel/<TryReceiveAsync>d__14")]
public sealed virtual Task`1<ValueTuple`2<bool, Message>> TryReceiveAsync(TimeSpan timeout);
    public sealed virtual bool TryReceive(TimeSpan timeout, Message& message);
    public sealed virtual Task`1<bool> WaitForMessageAsync(TimeSpan timeout);
    public sealed virtual bool WaitForMessage(TimeSpan timeout);
    public sealed virtual IAsyncResult BeginWaitForMessage(TimeSpan timeout, AsyncCallback callback, object state);
    public sealed virtual bool EndWaitForMessage(IAsyncResult result);
}
internal class System.ServiceModel.Channels.LifetimeManager : object {
    private bool _aborted;
    private ICommunicationWaiter _busyWaiter;
    private int _busyWaiterCount;
    private LifetimeState _state;
    [CompilerGeneratedAttribute]
private int <BusyCount>k__BackingField;
    [CompilerGeneratedAttribute]
private object <ThisLock>k__BackingField;
    public int BusyCount { get; private set; }
    protected LifetimeState State { get; }
    protected object ThisLock { get; }
    public LifetimeManager(object mutex);
    [CompilerGeneratedAttribute]
public int get_BusyCount();
    [CompilerGeneratedAttribute]
private void set_BusyCount(int value);
    protected LifetimeState get_State();
    [CompilerGeneratedAttribute]
protected object get_ThisLock();
    public void Abort();
    private void ThrowIfNotOpened();
    [AsyncStateMachineAttribute("System.ServiceModel.Channels.LifetimeManager/<CloseAsync>d__16")]
public Task CloseAsync(TimeSpan timeout);
    public void Close(TimeSpan timeout);
    [AsyncStateMachineAttribute("System.ServiceModel.Channels.LifetimeManager/<CloseCoreAsync>d__18")]
private Task`1<CommunicationWaitResult> CloseCoreAsync(TimeSpan timeout, bool aborting);
    private CommunicationWaitResult CloseCore(TimeSpan timeout, bool aborting);
    protected void DecrementBusyCount();
    protected virtual void IncrementBusyCount();
    protected virtual void IncrementBusyCountWithoutLock();
    protected virtual void OnAbort();
    protected virtual IAsyncResult OnBeginClose(TimeSpan timeout, AsyncCallback callback, object state);
    protected virtual void OnClose(TimeSpan timeout);
    [AsyncStateMachineAttribute("System.ServiceModel.Channels.LifetimeManager/<OnCloseAsync>d__26")]
protected virtual Task OnCloseAsync(TimeSpan timeout);
    protected virtual void OnEmpty();
    protected virtual void OnEndClose(IAsyncResult result);
}
internal enum System.ServiceModel.Channels.LifetimeState : Enum {
    public int value__;
    public static LifetimeState Opened;
    public static LifetimeState Closing;
    public static LifetimeState Closed;
}
internal class System.ServiceModel.Channels.LocalAddressProvider : object {
    private int _priority;
    [CompilerGeneratedAttribute]
private EndpointAddress <LocalAddress>k__BackingField;
    [CompilerGeneratedAttribute]
private MessageFilter <Filter>k__BackingField;
    public EndpointAddress LocalAddress { get; }
    public MessageFilter Filter { get; }
    public int Priority { get; }
    public LocalAddressProvider(EndpointAddress localAddress, MessageFilter filter);
    [CompilerGeneratedAttribute]
public EndpointAddress get_LocalAddress();
    [CompilerGeneratedAttribute]
public MessageFilter get_Filter();
    public int get_Priority();
}
public class System.ServiceModel.Channels.LocalClientSecuritySettings : object {
    private int _replayCacheSize;
    private TimeSpan _replayWindow;
    private TimeSpan _maxClockSkew;
    private TimeSpan _maxCookieCachingTime;
    private TimeSpan _sessionKeyRenewalInterval;
    private TimeSpan _sessionKeyRolloverInterval;
    private TimeSpan _timestampValidityDuration;
    private int _cookieRenewalThresholdPercentage;
    [CompilerGeneratedAttribute]
private bool <DetectReplays>k__BackingField;
    [CompilerGeneratedAttribute]
private NonceCache <NonceCache>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <CacheCookies>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <ReconnectTransportOnFailure>k__BackingField;
    [CompilerGeneratedAttribute]
private IdentityVerifier <IdentityVerifier>k__BackingField;
    public bool DetectReplays { get; public set; }
    public int ReplayCacheSize { get; public set; }
    public TimeSpan ReplayWindow { get; public set; }
    public TimeSpan MaxClockSkew { get; public set; }
    public NonceCache NonceCache { get; public set; }
    public TimeSpan TimestampValidityDuration { get; public set; }
    public bool CacheCookies { get; public set; }
    public TimeSpan MaxCookieCachingTime { get; public set; }
    public int CookieRenewalThresholdPercentage { get; public set; }
    public TimeSpan SessionKeyRenewalInterval { get; public set; }
    public TimeSpan SessionKeyRolloverInterval { get; public set; }
    public bool ReconnectTransportOnFailure { get; public set; }
    public IdentityVerifier IdentityVerifier { get; public set; }
    private LocalClientSecuritySettings(LocalClientSecuritySettings other);
    [CompilerGeneratedAttribute]
public bool get_DetectReplays();
    [CompilerGeneratedAttribute]
public void set_DetectReplays(bool value);
    public int get_ReplayCacheSize();
    public void set_ReplayCacheSize(int value);
    public TimeSpan get_ReplayWindow();
    public void set_ReplayWindow(TimeSpan value);
    public TimeSpan get_MaxClockSkew();
    public void set_MaxClockSkew(TimeSpan value);
    [CompilerGeneratedAttribute]
public NonceCache get_NonceCache();
    [CompilerGeneratedAttribute]
public void set_NonceCache(NonceCache value);
    public TimeSpan get_TimestampValidityDuration();
    public void set_TimestampValidityDuration(TimeSpan value);
    [CompilerGeneratedAttribute]
public bool get_CacheCookies();
    [CompilerGeneratedAttribute]
public void set_CacheCookies(bool value);
    public TimeSpan get_MaxCookieCachingTime();
    public void set_MaxCookieCachingTime(TimeSpan value);
    public int get_CookieRenewalThresholdPercentage();
    public void set_CookieRenewalThresholdPercentage(int value);
    public TimeSpan get_SessionKeyRenewalInterval();
    public void set_SessionKeyRenewalInterval(TimeSpan value);
    public TimeSpan get_SessionKeyRolloverInterval();
    public void set_SessionKeyRolloverInterval(TimeSpan value);
    [CompilerGeneratedAttribute]
public bool get_ReconnectTransportOnFailure();
    [CompilerGeneratedAttribute]
public void set_ReconnectTransportOnFailure(bool value);
    [CompilerGeneratedAttribute]
public IdentityVerifier get_IdentityVerifier();
    [CompilerGeneratedAttribute]
public void set_IdentityVerifier(IdentityVerifier value);
    public LocalClientSecuritySettings Clone();
}
[FlagsAttribute]
internal enum System.ServiceModel.Channels.MaskingMode : Enum {
    public int value__;
    public static MaskingMode None;
    public static MaskingMode Handled;
    public static MaskingMode Unhandled;
    public static MaskingMode All;
}
internal class System.ServiceModel.Channels.MaxMessageSizeStream : DelegatingStream {
    private long _maxMessageSize;
    private long _totalBytesRead;
    private long _bytesWritten;
    public MaxMessageSizeStream(Stream stream, long maxMessageSize);
    [AsyncStateMachineAttribute("System.ServiceModel.Channels.MaxMessageSizeStream/<ReadAsync>d__4")]
public virtual Task`1<int> ReadAsync(Byte[] buffer, int offset, int count, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("System.ServiceModel.Channels.MaxMessageSizeStream/<ReadAsync>d__5")]
public virtual ValueTask`1<int> ReadAsync(Memory`1<byte> buffer, CancellationToken cancellationToken);
    public virtual int Read(Byte[] buffer, int offset, int count);
    public virtual int ReadByte();
    public virtual Task WriteAsync(Byte[] buffer, int offset, int count, CancellationToken cancellationToken);
    public virtual ValueTask WriteAsync(ReadOnlyMemory`1<byte> buffer, CancellationToken cancellationToken);
    public virtual void Write(Byte[] buffer, int offset, int count);
    public virtual void WriteByte(byte value);
    public static Exception CreateMaxReceivedMessageSizeExceededException(long maxMessageSize);
    internal static Exception CreateMaxSentMessageSizeExceededException(long maxMessageSize);
    private int PrepareRead(int bytesToRead);
    private int FinishRead(int bytesRead);
    private void PrepareWrite(int bytesToWrite);
    [CompilerGeneratedAttribute]
[DebuggerHiddenAttribute]
private Task`1<int> <>n__0(Byte[] buffer, int offset, int count, CancellationToken cancellationToken);
    [CompilerGeneratedAttribute]
[DebuggerHiddenAttribute]
private ValueTask`1<int> <>n__1(Memory`1<byte> buffer, CancellationToken cancellationToken);
}
public abstract class System.ServiceModel.Channels.Message : object {
    internal static int InitialBufferSize;
    [CompilerGeneratedAttribute]
private MessageState <State>k__BackingField;
    public MessageHeaders Headers { get; }
    protected bool IsDisposed { get; }
    public bool IsFault { get; }
    public bool IsEmpty { get; }
    public MessageProperties Properties { get; }
    public MessageVersion Version { get; }
    internal RecycledMessageState RecycledMessageState { get; }
    public MessageState State { get; private set; }
    public abstract virtual MessageHeaders get_Headers();
    protected bool get_IsDisposed();
    public virtual bool get_IsFault();
    public virtual bool get_IsEmpty();
    public abstract virtual MessageProperties get_Properties();
    public abstract virtual MessageVersion get_Version();
    internal virtual RecycledMessageState get_RecycledMessageState();
    [CompilerGeneratedAttribute]
public MessageState get_State();
    [CompilerGeneratedAttribute]
private void set_State(MessageState value);
    internal void BodyToString(XmlDictionaryWriter writer);
    public void Close();
    public MessageBuffer CreateBufferedCopy(int maxBufferSize);
    private static Type GetObjectType(object value);
    public static Message CreateMessage(MessageVersion version, string action, object body);
    public static Message CreateMessage(MessageVersion version, string action, object body, XmlObjectSerializer serializer);
    public static Message CreateMessage(MessageVersion version, string action, XmlReader body);
    public static Message CreateMessage(MessageVersion version, string action, XmlDictionaryReader body);
    public static Message CreateMessage(MessageVersion version, string action, BodyWriter body);
    internal static Message CreateMessage(MessageVersion version, ActionHeader actionHeader, BodyWriter body);
    public static Message CreateMessage(MessageVersion version, string action);
    internal static Message CreateMessage(MessageVersion version, ActionHeader actionHeader);
    public static Message CreateMessage(XmlReader envelopeReader, int maxSizeOfHeaders, MessageVersion version);
    public static Message CreateMessage(XmlDictionaryReader envelopeReader, int maxSizeOfHeaders, MessageVersion version);
    public static Message CreateMessage(MessageVersion version, FaultCode faultCode, string reason, string action);
    public static Message CreateMessage(MessageVersion version, FaultCode faultCode, string reason, object detail, string action);
    public static Message CreateMessage(MessageVersion version, MessageFault fault, string action);
    internal Exception CreateMessageDisposedException();
    private sealed virtual override void System.IDisposable.Dispose();
    public T GetBody();
    protected virtual T OnGetBody(XmlDictionaryReader reader);
    public T GetBody(XmlObjectSerializer serializer);
    private T GetBodyCore(XmlDictionaryReader reader, XmlObjectSerializer serializer);
    internal virtual XmlDictionaryReader GetReaderAtHeader();
    public XmlDictionaryReader GetReaderAtBodyContents();
    internal void EnsureReadMessageState();
    internal void InitializeReply(Message request);
    internal static bool IsFaultStartElement(XmlDictionaryReader reader, EnvelopeVersion version);
    protected virtual void OnBodyToString(XmlDictionaryWriter writer);
    protected virtual MessageBuffer OnCreateBufferedCopy(int maxBufferSize);
    internal MessageBuffer OnCreateBufferedCopy(int maxBufferSize, XmlDictionaryReaderQuotas quotas);
    protected virtual void OnClose();
    protected virtual XmlDictionaryReader OnGetReaderAtBodyContents();
    protected virtual void OnWriteStartBody(XmlDictionaryWriter writer);
    public void WriteBodyContents(XmlDictionaryWriter writer);
    public Task WriteBodyContentsAsync(XmlDictionaryWriter writer);
    public IAsyncResult BeginWriteBodyContents(XmlDictionaryWriter writer, AsyncCallback callback, object state);
    public void EndWriteBodyContents(IAsyncResult result);
    protected abstract virtual void OnWriteBodyContents(XmlDictionaryWriter writer);
    protected virtual Task OnWriteBodyContentsAsync(XmlDictionaryWriter writer);
    protected virtual IAsyncResult OnBeginWriteBodyContents(XmlDictionaryWriter writer, AsyncCallback callback, object state);
    protected virtual void OnEndWriteBodyContents(IAsyncResult result);
    public void WriteStartEnvelope(XmlDictionaryWriter writer);
    protected virtual void OnWriteStartEnvelope(XmlDictionaryWriter writer);
    protected virtual void OnWriteStartHeaders(XmlDictionaryWriter writer);
    public virtual string ToString();
    internal void ToString(XmlDictionaryWriter writer);
    public string GetBodyAttribute(string localName, string ns);
    protected virtual string OnGetBodyAttribute(string localName, string ns);
    internal void ReadFromBodyContentsToEnd(XmlDictionaryReader reader);
    private static void ReadFromBodyContentsToEnd(XmlDictionaryReader reader, EnvelopeVersion envelopeVersion);
    internal static bool ReadStartBody(XmlDictionaryReader reader, EnvelopeVersion envelopeVersion, Boolean& isFault, Boolean& isEmpty);
    public void WriteBody(XmlWriter writer);
    public void WriteBody(XmlDictionaryWriter writer);
    public void WriteStartBody(XmlWriter writer);
    public void WriteStartBody(XmlDictionaryWriter writer);
    internal void WriteStartHeaders(XmlDictionaryWriter writer);
    public void WriteMessage(XmlWriter writer);
    public void WriteMessage(XmlDictionaryWriter writer);
    public virtual Task WriteMessageAsync(XmlWriter writer);
    [AsyncStateMachineAttribute("System.ServiceModel.Channels.Message/<WriteMessageAsync>d__79")]
public virtual Task WriteMessageAsync(XmlDictionaryWriter writer);
    [AsyncStateMachineAttribute("System.ServiceModel.Channels.Message/<OnWriteMessageAsync>d__80")]
public virtual Task OnWriteMessageAsync(XmlDictionaryWriter writer);
    private void EnsureWriteMessageState(XmlDictionaryWriter writer);
    public IAsyncResult BeginWriteMessage(XmlDictionaryWriter writer, AsyncCallback callback, object state);
    public void EndWriteMessage(IAsyncResult result);
    protected virtual void OnWriteMessage(XmlDictionaryWriter writer);
    internal void WriteMessagePreamble(XmlDictionaryWriter writer);
    internal void WriteMessagePostamble(XmlDictionaryWriter writer);
    [AsyncStateMachineAttribute("System.ServiceModel.Channels.Message/<WriteMessagePostambleAsync>d__87")]
internal Task WriteMessagePostambleAsync(XmlDictionaryWriter writer);
    protected virtual IAsyncResult OnBeginWriteMessage(XmlDictionaryWriter writer, AsyncCallback callback, object state);
    protected virtual void OnEndWriteMessage(IAsyncResult result);
    private void WriteSharedHeaderPrefixes(XmlDictionaryWriter writer);
}
internal class System.ServiceModel.Channels.MessageAttemptInfo : ValueType {
    private long _sequenceNumber;
    [CompilerGeneratedAttribute]
private Message <Message>k__BackingField;
    [CompilerGeneratedAttribute]
private int <RetryCount>k__BackingField;
    [CompilerGeneratedAttribute]
private object <State>k__BackingField;
    public Message Message { get; }
    public int RetryCount { get; }
    public object State { get; }
    public MessageAttemptInfo(Message message, long sequenceNumber, int retryCount, object state);
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public Message get_Message();
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public int get_RetryCount();
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public object get_State();
    public long GetSequenceNumber();
}
public abstract class System.ServiceModel.Channels.MessageBuffer : object {
    public int BufferSize { get; }
    public string MessageContentType { get; }
    public abstract virtual int get_BufferSize();
    private sealed virtual override void System.IDisposable.Dispose();
    public abstract virtual void Close();
    public virtual void WriteMessage(Stream stream);
    public virtual string get_MessageContentType();
    public abstract virtual Message CreateMessage();
    internal Exception CreateBufferDisposedException();
}
public abstract class System.ServiceModel.Channels.MessageEncoder : object {
    private static int DefaultConnectionBufferSize;
    public string ContentType { get; }
    public string MediaType { get; }
    public MessageVersion MessageVersion { get; }
    public abstract virtual string get_ContentType();
    public abstract virtual string get_MediaType();
    public abstract virtual MessageVersion get_MessageVersion();
    public virtual T GetProperty();
    public Message ReadMessage(Stream stream, int maxSizeOfHeaders);
    public virtual ValueTask`1<Message> ReadMessageAsync(Stream stream, int maxSizeOfHeaders, string contentType);
    public virtual ValueTask`1<Message> ReadMessageAsync(ArraySegment`1<byte> buffer, BufferManager bufferManager, string contentType);
    public abstract virtual Message ReadMessage(Stream stream, int maxSizeOfHeaders, string contentType);
    public Message ReadMessage(ArraySegment`1<byte> buffer, BufferManager bufferManager);
    public abstract virtual Message ReadMessage(ArraySegment`1<byte> buffer, BufferManager bufferManager, string contentType);
    [AsyncStateMachineAttribute("System.ServiceModel.Channels.MessageEncoder/<BufferMessageStreamAsync>d__14")]
internal Task`1<ArraySegment`1<byte>> BufferMessageStreamAsync(Stream stream, BufferManager bufferManager, int maxBufferSize, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("System.ServiceModel.Channels.MessageEncoder/<ReadMessageAsync>d__15")]
internal virtual Task`1<Message> ReadMessageAsync(Stream stream, BufferManager bufferManager, int maxBufferSize, string contentType, CancellationToken cancellationToken);
    public virtual string ToString();
    public abstract virtual void WriteMessage(Message message, Stream stream);
    public virtual IAsyncResult BeginWriteMessage(Message message, Stream stream, AsyncCallback callback, object state);
    public virtual void EndWriteMessage(IAsyncResult result);
    public ArraySegment`1<byte> WriteMessage(Message message, int maxMessageSize, BufferManager bufferManager);
    public abstract virtual ArraySegment`1<byte> WriteMessage(Message message, int maxMessageSize, BufferManager bufferManager, int messageOffset);
    public virtual ValueTask WriteMessageAsync(Message message, Stream stream);
    public virtual ValueTask`1<ArraySegment`1<byte>> WriteMessageAsync(Message message, int maxMessageSize, BufferManager bufferManager, int messageOffset);
    public virtual bool IsContentTypeSupported(string contentType);
    internal bool IsContentTypeSupported(string contentType, string supportedContentType, string supportedMediaType);
    internal virtual bool IsCharSetSupported(string charset);
    internal void ThrowIfMismatchedMessageVersion(Message message);
}
internal static class System.ServiceModel.Channels.MessageEncoderCompressionHandler : object {
    internal static string GZipContentEncoding;
    internal static string DeflateContentEncoding;
    private static int DecompressBlockSize;
    internal static void DecompressBuffer(ArraySegment`1& buffer, BufferManager bufferManager, CompressionFormat compressionFormat, long maxReceivedMessageSize);
    internal static void CompressBuffer(ArraySegment`1& buffer, BufferManager bufferManager, CompressionFormat compressionFormat);
    internal static Stream GetDecompressStream(Stream compressedStream, CompressionFormat compressionFormat);
    internal static Stream GetCompressStream(Stream uncompressedStream, CompressionFormat compressionFormat);
}
public abstract class System.ServiceModel.Channels.MessageEncoderFactory : object {
    public MessageEncoder Encoder { get; }
    public MessageVersion MessageVersion { get; }
    public abstract virtual MessageEncoder get_Encoder();
    public abstract virtual MessageVersion get_MessageVersion();
    public virtual MessageEncoder CreateSessionEncoder();
}
public abstract class System.ServiceModel.Channels.MessageEncodingBindingElement : BindingElement {
    public MessageVersion MessageVersion { get; public set; }
    internal bool IsWsdlExportable { get; }
    protected MessageEncodingBindingElement(MessageEncodingBindingElement elementToBeCloned);
    public abstract virtual MessageVersion get_MessageVersion();
    public abstract virtual void set_MessageVersion(MessageVersion value);
    internal virtual bool get_IsWsdlExportable();
    internal IChannelFactory`1<TChannel> InternalBuildChannelFactory(BindingContext context);
    internal bool InternalCanBuildChannelFactory(BindingContext context);
    public abstract virtual MessageEncoderFactory CreateMessageEncoderFactory();
    public virtual T GetProperty(BindingContext context);
    internal virtual bool CheckEncodingVersion(EnvelopeVersion version);
    internal virtual bool IsMatch(BindingElement b);
}
public abstract class System.ServiceModel.Channels.MessageFault : object {
    private static MessageFault s_defaultMessageFault;
    internal static MessageFault Default { get; }
    public string Actor { get; }
    public FaultCode Code { get; }
    public bool IsMustUnderstandFault { get; }
    public string Node { get; }
    public bool HasDetail { get; }
    public FaultReason Reason { get; }
    public static MessageFault CreateFault(FaultCode code, string reason);
    public static MessageFault CreateFault(FaultCode code, FaultReason reason);
    public static MessageFault CreateFault(FaultCode code, FaultReason reason, object detail);
    public static MessageFault CreateFault(FaultCode code, FaultReason reason, object detail, XmlObjectSerializer serializer);
    public static MessageFault CreateFault(FaultCode code, FaultReason reason, object detail, XmlObjectSerializer serializer, string actor);
    public static MessageFault CreateFault(FaultCode code, FaultReason reason, object detail, XmlObjectSerializer serializer, string actor, string node);
    public static MessageFault CreateFault(Message message, int maxBufferSize);
    internal static MessageFault get_Default();
    public virtual string get_Actor();
    public abstract virtual FaultCode get_Code();
    public bool get_IsMustUnderstandFault();
    public virtual string get_Node();
    public abstract virtual bool get_HasDetail();
    public abstract virtual FaultReason get_Reason();
    public T GetDetail();
    public T GetDetail(XmlObjectSerializer serializer);
    public XmlDictionaryReader GetReaderAtDetailContents();
    protected virtual void OnWriteDetail(XmlDictionaryWriter writer, EnvelopeVersion version);
    protected virtual void OnWriteStartDetail(XmlDictionaryWriter writer, EnvelopeVersion version);
    protected abstract virtual void OnWriteDetailContents(XmlDictionaryWriter writer);
    protected virtual XmlDictionaryReader OnGetReaderAtDetailContents();
    public static bool WasHeaderNotUnderstood(MessageHeaders headers, string name, string ns);
    public void WriteTo(XmlWriter writer, EnvelopeVersion version);
    public void WriteTo(XmlDictionaryWriter writer, EnvelopeVersion version);
    private void WriteToNone(XmlDictionaryWriter writer);
    private void WriteTo12Driver(XmlDictionaryWriter writer, EnvelopeVersion version);
    private void WriteFaultCode12Driver(XmlDictionaryWriter writer, FaultCode faultCode, EnvelopeVersion version);
    private void WriteTo12(XmlDictionaryWriter writer);
    private void WriteTo11(XmlDictionaryWriter writer);
}
public abstract class System.ServiceModel.Channels.MessageHeader : MessageHeaderInfo {
    private static bool DefaultRelayValue;
    private static bool DefaultMustUnderstandValue;
    private static string DefaultActorValue;
    public string Actor { get; }
    public bool IsReferenceParameter { get; }
    public bool MustUnderstand { get; }
    public bool Relay { get; }
    public virtual string get_Actor();
    public virtual bool get_IsReferenceParameter();
    public virtual bool get_MustUnderstand();
    public virtual bool get_Relay();
    public virtual bool IsMessageVersionSupported(MessageVersion messageVersion);
    public virtual string ToString();
    public void WriteHeader(XmlWriter writer, MessageVersion messageVersion);
    public void WriteHeader(XmlDictionaryWriter writer, MessageVersion messageVersion);
    public void WriteStartHeader(XmlDictionaryWriter writer, MessageVersion messageVersion);
    protected virtual void OnWriteStartHeader(XmlDictionaryWriter writer, MessageVersion messageVersion);
    public void WriteHeaderContents(XmlDictionaryWriter writer, MessageVersion messageVersion);
    protected abstract virtual void OnWriteHeaderContents(XmlDictionaryWriter writer, MessageVersion messageVersion);
    protected void WriteHeaderAttributes(XmlDictionaryWriter writer, MessageVersion messageVersion);
    public static MessageHeader CreateHeader(string name, string ns, object value);
    public static MessageHeader CreateHeader(string name, string ns, object value, bool mustUnderstand);
    public static MessageHeader CreateHeader(string name, string ns, object value, bool mustUnderstand, string actor);
    public static MessageHeader CreateHeader(string name, string ns, object value, bool mustUnderstand, string actor, bool relay);
    public static MessageHeader CreateHeader(string name, string ns, object value, XmlObjectSerializer serializer);
    public static MessageHeader CreateHeader(string name, string ns, object value, XmlObjectSerializer serializer, bool mustUnderstand);
    public static MessageHeader CreateHeader(string name, string ns, object value, XmlObjectSerializer serializer, bool mustUnderstand, string actor);
    public static MessageHeader CreateHeader(string name, string ns, object value, XmlObjectSerializer serializer, bool mustUnderstand, string actor, bool relay);
    internal static void GetHeaderAttributes(XmlDictionaryReader reader, MessageVersion version, String& actor, Boolean& mustUnderstand, Boolean& relay, Boolean& isReferenceParameter);
    private static bool ToBoolean(string value);
}
public abstract class System.ServiceModel.Channels.MessageHeaderInfo : object {
    public string Actor { get; }
    public bool IsReferenceParameter { get; }
    public string Name { get; }
    public string Namespace { get; }
    public bool MustUnderstand { get; }
    public bool Relay { get; }
    public abstract virtual string get_Actor();
    public abstract virtual bool get_IsReferenceParameter();
    public abstract virtual string get_Name();
    public abstract virtual string get_Namespace();
    public abstract virtual bool get_MustUnderstand();
    public abstract virtual bool get_Relay();
}
[DefaultMemberAttribute("Item")]
public class System.ServiceModel.Channels.MessageHeaders : object {
    private int _headerCount;
    private Header[] _headers;
    private IBufferedMessageData _bufferedMessageData;
    private UnderstoodHeaders _understoodHeaders;
    private static int InitialHeaderCount;
    private static int MaxRecycledArrayLength;
    private static XmlDictionaryString[] s_localNames;
    internal static string WildcardAction;
    private static int MaxBufferedHeaderNodes;
    private static int MaxBufferedHeaderAttributes;
    private int _nodeCount;
    private int _attrCount;
    private bool _understoodHeadersModified;
    [CompilerGeneratedAttribute]
private int <CollectionVersion>k__BackingField;
    [CompilerGeneratedAttribute]
private MessageVersion <MessageVersion>k__BackingField;
    public string Action { get; public set; }
    internal bool CanRecycle { get; }
    internal bool ContainsOnlyBufferedMessageHeaders { get; }
    internal int CollectionVersion { get; private set; }
    public int Count { get; }
    public EndpointAddress FaultTo { get; public set; }
    public EndpointAddress From { get; public set; }
    internal bool HasMustUnderstandBeenModified { get; }
    public UniqueId MessageId { get; public set; }
    public MessageVersion MessageVersion { get; private set; }
    public UniqueId RelatesTo { get; public set; }
    public EndpointAddress ReplyTo { get; public set; }
    public Uri To { get; public set; }
    public UnderstoodHeaders UnderstoodHeaders { get; }
    public MessageHeaderInfo Item { get; }
    public MessageHeaders(MessageVersion version, int initialSize);
    public MessageHeaders(MessageVersion version);
    internal MessageHeaders(MessageVersion version, XmlDictionaryReader reader, XmlAttributeHolder[] envelopeAttributes, XmlAttributeHolder[] headerAttributes, Int32& maxSizeOfHeaders);
    internal MessageHeaders(MessageVersion version, XmlDictionaryReader reader, IBufferedMessageData bufferedMessageData, RecycledMessageState recycledMessageState, Boolean[] understoodHeaders, bool understoodHeadersModified);
    internal MessageHeaders(MessageVersion version, MessageHeaders headers, IBufferedMessageData bufferedMessageData);
    public MessageHeaders(MessageHeaders collection);
    public string get_Action();
    public void set_Action(string value);
    internal bool get_CanRecycle();
    internal bool get_ContainsOnlyBufferedMessageHeaders();
    [CompilerGeneratedAttribute]
internal int get_CollectionVersion();
    [CompilerGeneratedAttribute]
private void set_CollectionVersion(int value);
    public int get_Count();
    public EndpointAddress get_FaultTo();
    public void set_FaultTo(EndpointAddress value);
    public EndpointAddress get_From();
    public void set_From(EndpointAddress value);
    internal bool get_HasMustUnderstandBeenModified();
    public UniqueId get_MessageId();
    public void set_MessageId(UniqueId value);
    [CompilerGeneratedAttribute]
public MessageVersion get_MessageVersion();
    [CompilerGeneratedAttribute]
private void set_MessageVersion(MessageVersion value);
    public UniqueId get_RelatesTo();
    public void set_RelatesTo(UniqueId value);
    public EndpointAddress get_ReplyTo();
    public void set_ReplyTo(EndpointAddress value);
    public Uri get_To();
    public void set_To(Uri value);
    public UnderstoodHeaders get_UnderstoodHeaders();
    public MessageHeaderInfo get_Item(int index);
    public void Add(MessageHeader header);
    internal void AddActionHeader(ActionHeader actionHeader);
    internal void AddMessageIDHeader(MessageIDHeader messageIDHeader);
    internal void AddRelatesToHeader(RelatesToHeader relatesToHeader);
    internal void AddReplyToHeader(ReplyToHeader replyToHeader);
    internal void AddToHeader(ToHeader toHeader);
    private void Add(MessageHeader header, HeaderKind kind);
    private void AddHeader(Header header);
    internal void AddUnderstood(int i);
    internal void AddUnderstood(MessageHeaderInfo headerInfo);
    private void CaptureBufferedHeaders();
    private void CaptureBufferedHeaders(int exceptIndex);
    private BufferedHeader CaptureBufferedHeader(XmlDictionaryReader reader, MessageHeaderInfo headerInfo);
    private BufferedHeader CaptureBufferedHeader(IBufferedMessageData bufferedMessageData, MessageHeaderInfo headerInfo, int bufferedMessageHeaderIndex);
    private BufferedHeader CaptureWriteableHeader(MessageHeader writeableHeader);
    public void Clear();
    public void CopyHeaderFrom(Message message, int headerIndex);
    public void CopyHeaderFrom(MessageHeaders collection, int headerIndex);
    public void CopyHeadersFrom(Message message);
    public void CopyHeadersFrom(MessageHeaders collection);
    public void CopyTo(MessageHeaderInfo[] array, int index);
    private Exception CreateDuplicateHeaderException(HeaderKind kind);
    public int FindHeader(string name, string ns);
    private int FindAddressingHeader(string name, string ns);
    private int FindNonAddressingHeader(string name, string ns, String[] actors);
    public int FindHeader(string name, string ns, String[] actors);
    private int FindHeaderProperty(HeaderKind kind);
    private int FindRelatesTo(Uri relationshipType, UniqueId& messageId);
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
    public sealed virtual IEnumerator`1<MessageHeaderInfo> GetEnumerator();
    private IEnumerator`1<MessageHeaderInfo> GetEnumerator(MessageHeaderInfo[] headers);
    internal IEnumerator`1<MessageHeaderInfo> GetUnderstoodEnumerator();
    private static XmlDictionaryReader GetBufferedMessageHeaderReaderAtHeaderContents(IBufferedMessageData bufferedMessageData);
    private XmlDictionaryReader GetBufferedMessageHeaderReader(IBufferedMessageData bufferedMessageData, int bufferedMessageHeaderIndex);
    private void Skip(XmlDictionaryReader reader);
    public T GetHeader(string name, string ns);
    public T GetHeader(string name, string ns, String[] actors);
    public T GetHeader(string name, string ns, XmlObjectSerializer serializer);
    public T GetHeader(int index);
    public T GetHeader(int index, XmlObjectSerializer serializer);
    private HeaderKind GetHeaderKind(MessageHeaderInfo headerInfo);
    private void ValidateHeaderKind(HeaderKind headerKind);
    public XmlDictionaryReader GetReaderAtHeader(int headerIndex);
    internal UniqueId GetRelatesTo(Uri relationshipType);
    private void GetRelatesToValues(int index, Uri& relationshipType, UniqueId& messageId);
    internal String[] GetHeaderAttributes(string localName, string ns);
    internal MessageHeader GetMessageHeader(int index);
    internal Collection`1<MessageHeaderInfo> GetHeadersNotUnderstood();
    public bool HaveMandatoryHeadersBeenUnderstood();
    public bool HaveMandatoryHeadersBeenUnderstood(String[] actors);
    internal void Init(MessageVersion version, int initialSize);
    internal void Init(MessageVersion version);
    internal void Init(MessageVersion version, XmlDictionaryReader reader, IBufferedMessageData bufferedMessageData, RecycledMessageState recycledMessageState, Boolean[] understoodHeaders, bool understoodHeadersModified);
    public void Insert(int headerIndex, MessageHeader header);
    private void Insert(int headerIndex, MessageHeader header, HeaderKind kind);
    private void InsertHeader(int headerIndex, Header header);
    internal bool IsUnderstood(int i);
    internal bool IsUnderstood(MessageHeaderInfo headerInfo);
    private void ReadBufferedHeader(XmlDictionaryReader reader, RecycledMessageState recycledMessageState, XmlDictionaryString[] localNames, bool understood);
    internal void Recycle(HeaderInfoCache headerInfoCache);
    internal void RemoveUnderstood(MessageHeaderInfo headerInfo);
    public void RemoveAll(string name, string ns);
    public void RemoveAt(int headerIndex);
    internal void ReplaceAt(int headerIndex, MessageHeader header);
    private void ReplaceAt(int headerIndex, MessageHeader header, HeaderKind kind);
    public void SetAction(XmlDictionaryString action);
    internal void SetActionHeader(ActionHeader actionHeader);
    internal void SetFaultToHeader(FaultToHeader faultToHeader);
    internal void SetFromHeader(FromHeader fromHeader);
    internal void SetMessageIDHeader(MessageIDHeader messageIDHeader);
    internal void SetRelatesTo(Uri relationshipType, UniqueId messageId);
    private void SetRelatesTo(Uri relationshipType, RelatesToHeader relatesToHeader);
    internal void SetReplyToHeader(ReplyToHeader replyToHeader);
    internal void SetToHeader(ToHeader toHeader);
    private void SetHeaderProperty(HeaderKind kind, MessageHeader header);
    public void WriteHeader(int headerIndex, XmlWriter writer);
    public void WriteHeader(int headerIndex, XmlDictionaryWriter writer);
    public void WriteStartHeader(int headerIndex, XmlWriter writer);
    public void WriteStartHeader(int headerIndex, XmlDictionaryWriter writer);
    public void WriteHeaderContents(int headerIndex, XmlWriter writer);
    public void WriteHeaderContents(int headerIndex, XmlDictionaryWriter writer);
    private static void TraceUnderstood(MessageHeaderInfo info);
    private void WriteBufferedMessageHeader(IBufferedMessageData bufferedMessageData, int bufferedMessageHeaderIndex, XmlWriter writer);
    private void WriteStartBufferedMessageHeader(IBufferedMessageData bufferedMessageData, int bufferedMessageHeaderIndex, XmlWriter writer);
    private void WriteBufferedMessageHeaderContents(IBufferedMessageData bufferedMessageData, int bufferedMessageHeaderIndex, XmlWriter writer);
}
internal class System.ServiceModel.Channels.MessageIDHeader : AddressingHeader {
    private static bool mustUnderstandValue;
    [CompilerGeneratedAttribute]
private UniqueId <MessageId>k__BackingField;
    public XmlDictionaryString DictionaryName { get; }
    public UniqueId MessageId { get; }
    public bool MustUnderstand { get; }
    private MessageIDHeader(UniqueId messageId, AddressingVersion version);
    public virtual XmlDictionaryString get_DictionaryName();
    [CompilerGeneratedAttribute]
public UniqueId get_MessageId();
    public virtual bool get_MustUnderstand();
    public static MessageIDHeader Create(UniqueId messageId, AddressingVersion addressingVersion);
    protected virtual void OnWriteHeaderContents(XmlDictionaryWriter writer, MessageVersion messageVersion);
    public static UniqueId ReadHeaderValue(XmlDictionaryReader reader, AddressingVersion version);
    public static MessageIDHeader ReadHeader(XmlDictionaryReader reader, AddressingVersion version, string actor, bool mustUnderstand, bool relay);
}
internal class System.ServiceModel.Channels.MessageNumberRolloverFault : WsrmHeaderFault {
    public MessageNumberRolloverFault(UniqueId sequenceID);
    public MessageNumberRolloverFault(FaultCode code, FaultReason reason, XmlDictionaryReader detailReader, ReliableMessagingVersion reliableMessagingVersion);
    protected virtual void OnWriteDetailContents(XmlDictionaryWriter writer);
}
internal class System.ServiceModel.Channels.MessagePatterns : object {
    private static Byte[] s_commonFragment;
    private static Byte[] s_requestFragment1;
    private static Byte[] s_requestFragment2;
    private static Byte[] s_responseFragment1;
    private static Byte[] s_responseFragment2;
    private static Byte[] s_bodyFragment;
    private static int ToValueSessionKey;
    private IXmlDictionary _dictionary;
    private XmlBinaryReaderSession _readerSession;
    private ToHeader _toHeader;
    private MessageVersion _messageVersion;
    private static MessagePatterns();
    public MessagePatterns(IXmlDictionary dictionary, XmlBinaryReaderSession readerSession, MessageVersion messageVersion);
    public Message TryCreateMessage(Byte[] buffer, int offset, int size, BufferManager bufferManager, BufferedMessageData messageData);
    private bool TryLookupKey(int key, XmlDictionaryString& result);
}
[DefaultMemberAttribute("Item")]
public class System.ServiceModel.Channels.MessageProperties : object {
    private Property[] _properties;
    private int _propertyCount;
    private MessageEncoder _encoder;
    private Uri _via;
    private object _allowOutputBatching;
    private SecurityMessageProperty _security;
    private bool _disposed;
    private static int InitialPropertyCount;
    private static int MaxRecycledArrayLength;
    private static string ViaKey;
    private static string AllowOutputBatchingKey;
    private static string SecurityKey;
    private static string EncoderKey;
    private static int NotFoundIndex;
    private static int ViaIndex;
    private static int AllowOutputBatchingIndex;
    private static int SecurityIndex;
    private static int EncoderIndex;
    private static object s_trueBool;
    private static object s_falseBool;
    public object Item { get; public set; }
    internal bool CanRecycle { get; }
    public int Count { get; }
    public MessageEncoder Encoder { get; public set; }
    public bool AllowOutputBatching { get; public set; }
    public bool IsFixedSize { get; }
    public bool IsReadOnly { get; }
    public ICollection`1<string> Keys { get; }
    public SecurityMessageProperty Security { get; public set; }
    public ICollection`1<object> Values { get; }
    public Uri Via { get; public set; }
    public MessageProperties(MessageProperties properties);
    internal MessageProperties(KeyValuePair`2[] array);
    private static MessageProperties();
    private void ThrowDisposed();
    public sealed virtual object get_Item(string name);
    public sealed virtual void set_Item(string name, object value);
    internal bool get_CanRecycle();
    public sealed virtual int get_Count();
    public MessageEncoder get_Encoder();
    public void set_Encoder(MessageEncoder value);
    public bool get_AllowOutputBatching();
    public void set_AllowOutputBatching(bool value);
    public bool get_IsFixedSize();
    public sealed virtual bool get_IsReadOnly();
    public sealed virtual ICollection`1<string> get_Keys();
    public SecurityMessageProperty get_Security();
    public void set_Security(SecurityMessageProperty value);
    public sealed virtual ICollection`1<object> get_Values();
    public Uri get_Via();
    public void set_Via(Uri value);
    public sealed virtual void Add(string name, object property);
    private void AdjustPropertyCount(bool oldValueIsNull, bool newValueIsNull);
    public sealed virtual void Clear();
    public void CopyProperties(MessageProperties properties);
    internal void MergeProperties(MessageProperties properties);
    internal void CopyProperties(KeyValuePair`2[] array);
    public sealed virtual bool ContainsKey(string name);
    private object CreateCopyOfPropertyValue(object propertyValue);
    public sealed virtual void Dispose();
    private int FindProperty(string name);
    internal void Recycle();
    public sealed virtual bool Remove(string name);
    public sealed virtual bool TryGetValue(string name, Object& value);
    internal bool TryGetValue(string name, TProperty& property);
    internal TProperty GetValue(string name);
    internal TProperty GetValue(string name, bool ensureTypeMatch);
    private void UpdateProperty(string name, object value, bool mustNotExist);
    private sealed virtual override void System.Collections.Generic.ICollection<System.Collections.Generic.KeyValuePair<System.String,System.Object>>.CopyTo(KeyValuePair`2[] array, int index);
    private sealed virtual override void System.Collections.Generic.ICollection<System.Collections.Generic.KeyValuePair<System.String,System.Object>>.Add(KeyValuePair`2<string, object> pair);
    private sealed virtual override bool System.Collections.Generic.ICollection<System.Collections.Generic.KeyValuePair<System.String,System.Object>>.Contains(KeyValuePair`2<string, object> pair);
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
    private sealed virtual override IEnumerator`1<KeyValuePair`2<string, object>> System.Collections.Generic.IEnumerable<System.Collections.Generic.KeyValuePair<System.String,System.Object>>.GetEnumerator();
    private sealed virtual override bool System.Collections.Generic.ICollection<System.Collections.Generic.KeyValuePair<System.String,System.Object>>.Remove(KeyValuePair`2<string, object> pair);
}
public enum System.ServiceModel.Channels.MessageState : Enum {
    public int value__;
    public static MessageState Created;
    public static MessageState Read;
    public static MessageState Written;
    public static MessageState Copied;
    public static MessageState Closed;
}
public class System.ServiceModel.Channels.MessageVersion : object {
    private static MessageVersion s_soap12Addressing200408;
    private static string MessageVersionToStringFormat;
    [CompilerGeneratedAttribute]
private AddressingVersion <Addressing>k__BackingField;
    [CompilerGeneratedAttribute]
private EnvelopeVersion <Envelope>k__BackingField;
    [CompilerGeneratedAttribute]
private static MessageVersion <None>k__BackingField;
    [CompilerGeneratedAttribute]
private static MessageVersion <Soap12WSAddressing10>k__BackingField;
    [CompilerGeneratedAttribute]
private static MessageVersion <Soap11WSAddressing10>k__BackingField;
    [CompilerGeneratedAttribute]
private static MessageVersion <Soap11WSAddressingAugust2004>k__BackingField;
    [CompilerGeneratedAttribute]
private static MessageVersion <Soap11>k__BackingField;
    [CompilerGeneratedAttribute]
private static MessageVersion <Soap12>k__BackingField;
    public AddressingVersion Addressing { get; }
    public static MessageVersion Default { get; }
    public EnvelopeVersion Envelope { get; }
    public static MessageVersion None { get; private set; }
    public static MessageVersion Soap12WSAddressing10 { get; private set; }
    public static MessageVersion Soap11WSAddressing10 { get; private set; }
    public static MessageVersion Soap12WSAddressingAugust2004 { get; }
    public static MessageVersion Soap11WSAddressingAugust2004 { get; private set; }
    public static MessageVersion Soap11 { get; private set; }
    public static MessageVersion Soap12 { get; private set; }
    private static MessageVersion();
    private MessageVersion(EnvelopeVersion envelopeVersion, AddressingVersion addressingVersion);
    public static MessageVersion CreateVersion(EnvelopeVersion envelopeVersion);
    public static MessageVersion CreateVersion(EnvelopeVersion envelopeVersion, AddressingVersion addressingVersion);
    [CompilerGeneratedAttribute]
public AddressingVersion get_Addressing();
    public static MessageVersion get_Default();
    [CompilerGeneratedAttribute]
public EnvelopeVersion get_Envelope();
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    [CompilerGeneratedAttribute]
public static MessageVersion get_None();
    [CompilerGeneratedAttribute]
private static void set_None(MessageVersion value);
    [CompilerGeneratedAttribute]
public static MessageVersion get_Soap12WSAddressing10();
    [CompilerGeneratedAttribute]
private static void set_Soap12WSAddressing10(MessageVersion value);
    [CompilerGeneratedAttribute]
public static MessageVersion get_Soap11WSAddressing10();
    [CompilerGeneratedAttribute]
private static void set_Soap11WSAddressing10(MessageVersion value);
    public static MessageVersion get_Soap12WSAddressingAugust2004();
    [CompilerGeneratedAttribute]
public static MessageVersion get_Soap11WSAddressingAugust2004();
    [CompilerGeneratedAttribute]
private static void set_Soap11WSAddressingAugust2004(MessageVersion value);
    [CompilerGeneratedAttribute]
public static MessageVersion get_Soap11();
    [CompilerGeneratedAttribute]
private static void set_Soap11(MessageVersion value);
    [CompilerGeneratedAttribute]
public static MessageVersion get_Soap12();
    [CompilerGeneratedAttribute]
private static void set_Soap12(MessageVersion value);
    public virtual string ToString();
    internal bool IsMatch(MessageVersion messageVersion);
}
internal class System.ServiceModel.Channels.MethodCall : object {
    private Object[] _inArgs;
    [CompilerGeneratedAttribute]
private MethodBase <MethodBase>k__BackingField;
    [CompilerGeneratedAttribute]
private Object[] <Args>k__BackingField;
    public MethodBase MethodBase { get; private set; }
    public Object[] Args { get; private set; }
    public Object[] InArgs { get; }
    public MethodCall(Object[] args);
    public MethodCall(MethodBase methodBase, Object[] args);
    [CompilerGeneratedAttribute]
public MethodBase get_MethodBase();
    [CompilerGeneratedAttribute]
private void set_MethodBase(MethodBase value);
    [CompilerGeneratedAttribute]
public Object[] get_Args();
    [CompilerGeneratedAttribute]
private void set_Args(Object[] value);
    public Object[] get_InArgs();
    private void CreateInArgs();
}
internal static class System.ServiceModel.Channels.MtomEncoderDefaults : object {
    internal static int MaxBufferSize;
}
internal class System.ServiceModel.Channels.MtomMessageEncoder : MessageEncoder {
    private Encoding _writeEncoding;
    private string _contentType;
    private string _boundary;
    private MessageVersion _version;
    private static UriGenerator s_mimeBoundaryGenerator;
    private XmlDictionaryReaderQuotas _bufferedReadReaderQuotas;
    private MtomMessageEncoderFactory _factory;
    private static string MtomMediaType;
    private static string MtomContentType;
    private static string MtomStartUri;
    [CompilerGeneratedAttribute]
private int <MaxWritePoolSize>k__BackingField;
    [CompilerGeneratedAttribute]
private int <MaxReadPoolSize>k__BackingField;
    [CompilerGeneratedAttribute]
private XmlDictionaryReaderQuotas <ReaderQuotas>k__BackingField;
    [CompilerGeneratedAttribute]
private int <MaxBufferSize>k__BackingField;
    private static UriGenerator MimeBoundaryGenerator { get; }
    public string ContentType { get; }
    public int MaxWritePoolSize { get; }
    public int MaxReadPoolSize { get; }
    public XmlDictionaryReaderQuotas ReaderQuotas { get; }
    public int MaxBufferSize { get; }
    public string MediaType { get; }
    public MessageVersion MessageVersion { get; }
    public MtomMessageEncoder(MessageVersion version, Encoding writeEncoding, int maxReadPoolSize, int maxWritePoolSize, int maxBufferSize, XmlDictionaryReaderQuotas quotas, MtomMessageEncoderFactory factory);
    private static UriGenerator get_MimeBoundaryGenerator();
    public virtual string get_ContentType();
    [CompilerGeneratedAttribute]
public int get_MaxWritePoolSize();
    [CompilerGeneratedAttribute]
public int get_MaxReadPoolSize();
    [CompilerGeneratedAttribute]
public XmlDictionaryReaderQuotas get_ReaderQuotas();
    [CompilerGeneratedAttribute]
public int get_MaxBufferSize();
    public virtual string get_MediaType();
    public virtual MessageVersion get_MessageVersion();
    internal bool IsMTOMContentType(string contentType);
    internal bool IsTextContentType(string contentType);
    public virtual bool IsContentTypeSupported(string contentType);
    internal virtual bool IsCharSetSupported(string charSet);
    private string GenerateStartInfoString();
    public virtual Message ReadMessage(ArraySegment`1<byte> buffer, BufferManager bufferManager, string contentType);
    public virtual Message ReadMessage(Stream stream, int maxSizeOfHeaders, string contentType);
    public virtual ArraySegment`1<byte> WriteMessage(Message message, int maxMessageSize, BufferManager bufferManager, int messageOffset);
    public virtual ValueTask`1<ArraySegment`1<byte>> WriteMessageAsync(Message message, int maxMessageSize, BufferManager bufferManager, int messageOffset);
    private string GetContentType(String& boundary);
    internal string FormatContentType(string boundary, string startInfo);
    private ArraySegment`1<byte> WriteMessageInternal(Message message, int maxMessageSize, BufferManager bufferManager, int messageOffset, string startInfo, string boundary, string startUri);
    public virtual void WriteMessage(Message message, Stream stream);
    public virtual ValueTask WriteMessageAsync(Message message, Stream stream);
    public virtual IAsyncResult BeginWriteMessage(Message message, Stream stream, AsyncCallback callback, object state);
    public virtual void EndWriteMessage(IAsyncResult result);
    [AsyncStateMachineAttribute("System.ServiceModel.Channels.MtomMessageEncoder/<WriteMessageInternalAsync>d__47")]
private ValueTask WriteMessageInternalAsync(Message message, Stream stream, string startInfo, string boundary, string startUri);
}
internal class System.ServiceModel.Channels.MtomMessageEncoderFactory : MessageEncoderFactory {
    private MessageVersion _messageVersion;
    private Encoding _writeEncoding;
    private int _maxReadPoolSize;
    private int _maxWritePoolSize;
    private int _maxBufferSize;
    private XmlDictionaryReaderQuotas _readerQuotas;
    private static int MaxPooledXmlReadersPerMessage;
    private object _thisLock;
    private OnXmlDictionaryReaderClose _onStreamedReaderClose;
    private SynchronizedPool`1 modreq(System.Runtime.CompilerServices.IsVolatile) _streamedWriterPool;
    private SynchronizedPool`1 modreq(System.Runtime.CompilerServices.IsVolatile) _streamedReaderPool;
    private SynchronizedPool`1 modreq(System.Runtime.CompilerServices.IsVolatile) _bufferedReaderPool;
    private SynchronizedPool`1 modreq(System.Runtime.CompilerServices.IsVolatile) _bufferedWriterPool;
    private SynchronizedPool`1 modreq(System.Runtime.CompilerServices.IsVolatile) _recycledStatePool;
    [CompilerGeneratedAttribute]
private ContentEncoding[] <ContentEncodingMap>k__BackingField;
    public MessageEncoder Encoder { get; }
    public MessageVersion MessageVersion { get; }
    public int MaxWritePoolSize { get; }
    public int MaxReadPoolSize { get; }
    public XmlDictionaryReaderQuotas ReaderQuotas { get; }
    public int MaxBufferSize { get; }
    internal ContentEncoding[] ContentEncodingMap { get; }
    internal SynchronizedPool`1<RecycledMessageState> RecycledStatePool { get; }
    public MtomMessageEncoderFactory(MessageVersion version, Encoding writeEncoding, int maxReadPoolSize, int maxWritePoolSize, int maxBufferSize, XmlDictionaryReaderQuotas quotas);
    public virtual MessageEncoder get_Encoder();
    public virtual MessageVersion get_MessageVersion();
    public int get_MaxWritePoolSize();
    public int get_MaxReadPoolSize();
    public XmlDictionaryReaderQuotas get_ReaderQuotas();
    public int get_MaxBufferSize();
    [CompilerGeneratedAttribute]
internal ContentEncoding[] get_ContentEncodingMap();
    internal XmlDictionaryWriter TakeStreamedWriter(Stream stream, string startInfo, string boundary, string startUri, bool writeMessageHeaders);
    internal void ReturnStreamedWriter(XmlDictionaryWriter xmlWriter);
    internal MtomBufferedMessageWriter TakeBufferedWriter(MtomMessageEncoder messageEncoder);
    internal void ReturnMessageWriter(MtomBufferedMessageWriter messageWriter);
    internal MtomBufferedMessageData TakeBufferedReader(MtomMessageEncoder messageEncoder);
    internal void ReturnBufferedData(MtomBufferedMessageData messageData);
    internal XmlReader TakeStreamedReader(Stream stream, string contentType, bool isMtomContentType);
    internal void ReturnStreamedReader(XmlDictionaryReader xmlReader);
    internal SynchronizedPool`1<RecycledMessageState> get_RecycledStatePool();
    public static Encoding[] GetSupportedEncodings();
}
public class System.ServiceModel.Channels.MtomMessageEncodingBindingElement : MessageEncodingBindingElement {
    private int _maxReadPoolSize;
    private int _maxWritePoolSize;
    private XmlDictionaryReaderQuotas _readerQuotas;
    private int _maxBufferSize;
    private Encoding _writeEncoding;
    private MessageVersion _messageVersion;
    [DefaultValueAttribute("64")]
public int MaxReadPoolSize { get; public set; }
    [DefaultValueAttribute("16")]
public int MaxWritePoolSize { get; public set; }
    public XmlDictionaryReaderQuotas ReaderQuotas { get; }
    [DefaultValueAttribute("65536")]
public int MaxBufferSize { get; public set; }
    public Encoding WriteEncoding { get; public set; }
    public MessageVersion MessageVersion { get; public set; }
    public MtomMessageEncodingBindingElement(MessageVersion messageVersion, Encoding writeEncoding);
    private MtomMessageEncodingBindingElement(MtomMessageEncodingBindingElement elementToBeCloned);
    public int get_MaxReadPoolSize();
    public void set_MaxReadPoolSize(int value);
    public int get_MaxWritePoolSize();
    public void set_MaxWritePoolSize(int value);
    public XmlDictionaryReaderQuotas get_ReaderQuotas();
    public int get_MaxBufferSize();
    public void set_MaxBufferSize(int value);
    public Encoding get_WriteEncoding();
    public void set_WriteEncoding(Encoding value);
    public virtual MessageVersion get_MessageVersion();
    public virtual void set_MessageVersion(MessageVersion value);
    public virtual IChannelFactory`1<TChannel> BuildChannelFactory(BindingContext context);
    public virtual bool CanBuildChannelFactory(BindingContext context);
    public virtual BindingElement Clone();
    public virtual MessageEncoderFactory CreateMessageEncoderFactory();
    public virtual T GetProperty(BindingContext context);
    internal virtual bool CheckEncodingVersion(EnvelopeVersion version);
    internal virtual bool IsMatch(BindingElement b);
}
internal class System.ServiceModel.Channels.NullMessage : StringMessage {
}
internal class System.ServiceModel.Channels.OperationWithTimeoutAsyncCallback : MulticastDelegate {
    public OperationWithTimeoutAsyncCallback(object object, IntPtr method);
    public virtual Task Invoke(TimeSpan timeout);
    public virtual IAsyncResult BeginInvoke(TimeSpan timeout, AsyncCallback callback, object object);
    public virtual Task EndInvoke(IAsyncResult result);
}
internal class System.ServiceModel.Channels.OrderedDeliveryStrategy`1 : DeliveryStrategy`1<ItemType> {
    private bool isEnqueueInOrder;
    private Dictionary`2<long, ItemType> items;
    private Action`1<object> onDispatchCallback;
    private long windowStart;
    public int EnqueuedCount { get; }
    private Action`1<object> OnDispatchCallback { get; }
    public OrderedDeliveryStrategy`1(InputQueueChannel`1<ItemType> channel, int quota, bool isEnqueueInOrder);
    public virtual int get_EnqueuedCount();
    private Action`1<object> get_OnDispatchCallback();
    public virtual bool CanEnqueue(long sequenceNumber);
    public virtual bool Enqueue(ItemType item, long sequenceNumber);
    private static void DisposeItems(Enumerator<long, ItemType> items);
    public virtual void Dispose();
    private void OnDispatch(object state);
}
public abstract class System.ServiceModel.Channels.OutputChannel : ChannelBase {
    public EndpointAddress RemoteAddress { get; }
    public Uri Via { get; }
    protected OutputChannel(ChannelManagerBase manager);
    public abstract virtual EndpointAddress get_RemoteAddress();
    public abstract virtual Uri get_Via();
    public sealed virtual IAsyncResult BeginSend(Message message, AsyncCallback callback, object state);
    public sealed virtual IAsyncResult BeginSend(Message message, TimeSpan timeout, AsyncCallback callback, object state);
    public sealed virtual void EndSend(IAsyncResult result);
    public virtual T GetProperty();
    protected abstract virtual void OnSend(Message message, TimeSpan timeout);
    protected abstract virtual Task OnSendAsync(Message message, TimeSpan timeout);
    public sealed virtual void Send(Message message);
    public sealed virtual void Send(Message message, TimeSpan timeout);
    public sealed virtual Task SendAsync(Message message);
    public sealed virtual Task SendAsync(Message message, TimeSpan timeout);
    private void EmitTrace(Message message);
    protected virtual void AddHeadersTo(Message message);
}
internal static class System.ServiceModel.Channels.PeerStrings : object {
    public static string Namespace;
    public static string HopCountElementName;
    public static string HopCountElementNamespace;
}
internal class System.ServiceModel.Channels.ProducerConsumerStream : Stream {
    private TaskCompletionSource`1<WriteBufferWrapper> _buffer;
    private TaskCompletionSource`1<int> _dataAvail;
    private WriteBufferWrapper _currentBuffer;
    private bool _disposed;
    public bool CanRead { get; }
    public bool CanSeek { get; }
    public bool CanWrite { get; }
    public long Length { get; }
    public long Position { get; public set; }
    public virtual bool get_CanRead();
    public virtual bool get_CanSeek();
    public virtual bool get_CanWrite();
    public virtual void Flush();
    public virtual int Read(Byte[] buffer, int offset, int count);
    [AsyncStateMachineAttribute("System.ServiceModel.Channels.ProducerConsumerStream/<ReadAsync>d__13")]
public virtual Task`1<int> ReadAsync(Byte[] buffer, int offset, int count, CancellationToken cancellationToken);
    public virtual void Write(Byte[] buffer, int offset, int count);
    [AsyncStateMachineAttribute("System.ServiceModel.Channels.ProducerConsumerStream/<WriteAsync>d__15")]
public virtual Task WriteAsync(Byte[] buffer, int offset, int count, CancellationToken cancellationToken);
    public virtual long Seek(long offset, SeekOrigin origin);
    public virtual void SetLength(long value);
    public virtual long get_Length();
    public virtual long get_Position();
    public virtual void set_Position(long value);
    protected virtual void Dispose(bool disposing);
    private static void CancelAndDispose(object state);
}
internal abstract class System.ServiceModel.Channels.QueuedObjectPool`1 : object {
    private Queue`1<T> _objectQueue;
    private bool _isClosed;
    private int _batchAllocCount;
    private int _maxFreeCount;
    private object ThisLock { get; }
    protected void Initialize(int batchAllocCount, int maxFreeCount);
    private object get_ThisLock();
    public virtual bool Return(T value);
    public T Take();
    public void Close();
    protected virtual void CleanupItem(T item);
    protected abstract virtual T Create();
    private void AllocObjects();
}
internal abstract class System.ServiceModel.Channels.ReadableMessageHeader : MessageHeader {
    public abstract virtual XmlDictionaryReader GetHeaderReader();
    protected virtual void OnWriteStartHeader(XmlDictionaryWriter writer, MessageVersion messageVersion);
    protected virtual void OnWriteHeaderContents(XmlDictionaryWriter writer, MessageVersion messageVersion);
}
internal class System.ServiceModel.Channels.ReceivedFault : MessageFault {
    private FaultCode _code;
    private FaultReason _reason;
    private string _actor;
    private string _node;
    private XmlBuffer _detail;
    private bool _hasDetail;
    private EnvelopeVersion _receivedVersion;
    public string Actor { get; }
    public FaultCode Code { get; }
    public bool HasDetail { get; }
    public string Node { get; }
    public FaultReason Reason { get; }
    private ReceivedFault(FaultCode code, FaultReason reason, string actor, string node, XmlBuffer detail, EnvelopeVersion version);
    public virtual string get_Actor();
    public virtual FaultCode get_Code();
    public virtual bool get_HasDetail();
    public virtual string get_Node();
    public virtual FaultReason get_Reason();
    private bool InferHasDetail(XmlBuffer detail);
    protected virtual void OnWriteDetail(XmlDictionaryWriter writer, EnvelopeVersion version);
    protected virtual void OnWriteStartDetail(XmlDictionaryWriter writer, EnvelopeVersion version);
    protected virtual void OnWriteDetailContents(XmlDictionaryWriter writer);
    protected virtual XmlDictionaryReader OnGetReaderAtDetailContents();
    private bool ShouldWriteDetailAttribute(EnvelopeVersion targetVersion, string prefix, string localName, string attributeValue);
    public static ReceivedFault CreateFaultNone(XmlDictionaryReader reader, int maxBufferSize);
    private static ReceivedFault CreateFault12Driver(XmlDictionaryReader reader, int maxBufferSize, EnvelopeVersion version);
    private static FaultCode ReadFaultCode12Driver(XmlDictionaryReader reader, EnvelopeVersion version);
    public static ReceivedFault CreateFault12(XmlDictionaryReader reader, int maxBufferSize);
    private static FaultReasonText ReadTranslation12(XmlDictionaryReader reader);
    public static ReceivedFault CreateFault11(XmlDictionaryReader reader, int maxBufferSize);
}
internal abstract class System.ServiceModel.Channels.ReceivedMessage : Message {
    private bool _isFault;
    private bool _isEmpty;
    public bool IsEmpty { get; }
    public bool IsFault { get; }
    public virtual bool get_IsEmpty();
    public virtual bool get_IsFault();
    protected static bool HasHeaderElement(XmlDictionaryReader reader, EnvelopeVersion envelopeVersion);
    protected virtual void OnWriteBodyContents(XmlDictionaryWriter writer);
    protected bool ReadStartBody(XmlDictionaryReader reader);
    protected static EnvelopeVersion ReadStartEnvelope(XmlDictionaryReader reader);
    protected static void VerifyStartBody(XmlDictionaryReader reader, EnvelopeVersion version);
}
internal class System.ServiceModel.Channels.RecycledMessageState : object {
    private MessageHeaders _recycledHeaders;
    private MessageProperties _recycledProperties;
    private UriCache _uriCache;
    private HeaderInfoCache _headerInfoCache;
    public HeaderInfoCache HeaderInfoCache { get; }
    public UriCache UriCache { get; }
    public HeaderInfoCache get_HeaderInfoCache();
    public UriCache get_UriCache();
    public MessageProperties TakeProperties();
    public void ReturnProperties(MessageProperties properties);
    public MessageHeaders TakeHeaders();
    public void ReturnHeaders(MessageHeaders headers);
}
internal class System.ServiceModel.Channels.RelatesToHeader : AddressingHeader {
    private static bool mustUnderstandValue;
    internal static Uri ReplyRelationshipType;
    [CompilerGeneratedAttribute]
private UniqueId <UniqueId>k__BackingField;
    public XmlDictionaryString DictionaryName { get; }
    public UniqueId UniqueId { get; }
    public bool MustUnderstand { get; }
    public Uri RelationshipType { get; }
    private RelatesToHeader(UniqueId messageId, AddressingVersion version);
    private static RelatesToHeader();
    public virtual XmlDictionaryString get_DictionaryName();
    [CompilerGeneratedAttribute]
public UniqueId get_UniqueId();
    public virtual bool get_MustUnderstand();
    public virtual Uri get_RelationshipType();
    public static RelatesToHeader Create(UniqueId messageId, AddressingVersion addressingVersion);
    public static RelatesToHeader Create(UniqueId messageId, AddressingVersion addressingVersion, Uri relationshipType);
    protected virtual void OnWriteHeaderContents(XmlDictionaryWriter writer, MessageVersion messageVersion);
    public static void ReadHeaderValue(XmlDictionaryReader reader, AddressingVersion version, Uri& relationshipType, UniqueId& messageId);
    public static RelatesToHeader ReadHeader(XmlDictionaryReader reader, AddressingVersion version, string actor, bool mustUnderstand, bool relay);
}
internal abstract class System.ServiceModel.Channels.ReliableChannelBinder`1 : object {
    private bool _aborted;
    private TimeSpan _defaultCloseTimeout;
    private AsyncCallback _onCloseChannelComplete;
    private object _thisLock;
    [CompilerGeneratedAttribute]
private MaskingMode <DefaultMaskingMode>k__BackingField;
    [CompilerGeneratedAttribute]
private TimeSpan <DefaultSendTimeout>k__BackingField;
    [CompilerGeneratedAttribute]
private CommunicationState <State>k__BackingField;
    [CompilerGeneratedAttribute]
private ChannelSynchronizer<TChannel> <Synchronizer>k__BackingField;
    [CompilerGeneratedAttribute]
private EventHandler ConnectionLost;
    [CompilerGeneratedAttribute]
private BinderExceptionHandler Faulted;
    [CompilerGeneratedAttribute]
private BinderExceptionHandler OnException;
    protected bool CanGetChannelForReceive { get; }
    public bool CanSendAsynchronously { get; }
    public ChannelParameterCollection ChannelParameters { get; }
    public IChannel Channel { get; }
    public bool Connected { get; }
    public MaskingMode DefaultMaskingMode { get; }
    public TimeSpan DefaultSendTimeout { get; }
    public bool HasSession { get; }
    public EndpointAddress LocalAddress { get; }
    protected bool MustCloseChannel { get; }
    protected bool MustOpenChannel { get; }
    public EndpointAddress RemoteAddress { get; }
    public CommunicationState State { get; private set; }
    protected ChannelSynchronizer<TChannel> Synchronizer { get; }
    protected object ThisLock { get; }
    private bool TolerateFaults { get; }
    protected ReliableChannelBinder`1(TChannel channel, MaskingMode maskingMode, TolerateFaultsMode faultMode, TimeSpan defaultCloseTimeout, TimeSpan defaultSendTimeout);
    protected abstract virtual bool get_CanGetChannelForReceive();
    public abstract virtual bool get_CanSendAsynchronously();
    public virtual ChannelParameterCollection get_ChannelParameters();
    public sealed virtual IChannel get_Channel();
    public sealed virtual bool get_Connected();
    [CompilerGeneratedAttribute]
public MaskingMode get_DefaultMaskingMode();
    [CompilerGeneratedAttribute]
public sealed virtual TimeSpan get_DefaultSendTimeout();
    public abstract virtual bool get_HasSession();
    public abstract virtual EndpointAddress get_LocalAddress();
    protected abstract virtual bool get_MustCloseChannel();
    protected abstract virtual bool get_MustOpenChannel();
    public abstract virtual EndpointAddress get_RemoteAddress();
    [CompilerGeneratedAttribute]
public sealed virtual CommunicationState get_State();
    [CompilerGeneratedAttribute]
private void set_State(CommunicationState value);
    [CompilerGeneratedAttribute]
protected ChannelSynchronizer<TChannel> get_Synchronizer();
    protected object get_ThisLock();
    private bool get_TolerateFaults();
    [CompilerGeneratedAttribute]
public sealed virtual void add_ConnectionLost(EventHandler value);
    [CompilerGeneratedAttribute]
public sealed virtual void remove_ConnectionLost(EventHandler value);
    [CompilerGeneratedAttribute]
public sealed virtual void add_Faulted(BinderExceptionHandler value);
    [CompilerGeneratedAttribute]
public sealed virtual void remove_Faulted(BinderExceptionHandler value);
    [CompilerGeneratedAttribute]
public sealed virtual void add_OnException(BinderExceptionHandler value);
    [CompilerGeneratedAttribute]
public sealed virtual void remove_OnException(BinderExceptionHandler value);
    public sealed virtual void Abort();
    protected virtual void AddOutputHeaders(Message message);
    private bool CloseCore(TChannel& channel);
    public sealed virtual Task CloseAsync(TimeSpan timeout);
    [AsyncStateMachineAttribute("System.ServiceModel.Channels.ReliableChannelBinder`1/<CloseAsync>d__55")]
public sealed virtual Task CloseAsync(TimeSpan timeout, MaskingMode maskingMode);
    private void CloseChannel(TChannel channel);
    protected virtual Task CloseChannelAsync(TChannel channel, TimeSpan timeout);
    protected void Fault(Exception e);
    private Exception GetClosedException(MaskingMode maskingMode);
    private Exception GetClosedOrFaultedException(MaskingMode maskingMode);
    private Exception GetFaultedException(MaskingMode maskingMode);
    public abstract virtual ISession GetInnerSession();
    public sealed virtual void HandleException(Exception e);
    protected bool HandleException(Exception e, MaskingMode maskingMode);
    protected bool HandleException(Exception e, MaskingMode maskingMode, bool autoAborted);
    protected abstract virtual bool HasSecuritySession(TChannel channel);
    public sealed virtual bool IsHandleable(Exception e);
    protected abstract virtual void OnAbort();
    protected abstract virtual Task OnCloseAsync(TimeSpan timeout);
    private void OnCloseChannelComplete(IAsyncResult result);
    private void OnInnerChannelFaulted();
    protected abstract virtual Task OnOpenAsync(TimeSpan timeout);
    private void OnOpened();
    private bool OnOpening(MaskingMode maskingMode);
    protected virtual void OnShutdown();
    protected virtual Task OnSendAsync(TChannel channel, Message message, TimeSpan timeout);
    protected virtual Task`1<ValueTuple`2<bool, RequestContext>> OnTryReceiveAsync(TChannel channel, TimeSpan timeout);
    [AsyncStateMachineAttribute("System.ServiceModel.Channels.ReliableChannelBinder`1/<OpenAsync>d__78")]
public sealed virtual Task OpenAsync(TimeSpan timeout);
    private void RaiseOnException(Exception e);
    public sealed virtual Task SendAsync(Message message, TimeSpan timeout);
    [AsyncStateMachineAttribute("System.ServiceModel.Channels.ReliableChannelBinder`1/<SendAsync>d__81")]
public sealed virtual Task SendAsync(Message message, TimeSpan timeout, MaskingMode maskingMode);
    public sealed virtual void SetMaskingMode(RequestContext context, MaskingMode maskingMode);
    private bool ThrowIfNotOpenedAndNotMasking(MaskingMode maskingMode, bool throwDisposed);
    private void ThrowIfTimeoutNegative(TimeSpan timeout);
    private void TransitionToClosed();
    protected abstract virtual Task`1<bool> TryGetChannelAsync(TimeSpan timeout);
    public virtual Task`1<ValueTuple`2<bool, RequestContext>> TryReceiveAsync(TimeSpan timeout);
    [AsyncStateMachineAttribute("System.ServiceModel.Channels.ReliableChannelBinder`1/<TryReceiveAsync>d__88")]
public virtual Task`1<ValueTuple`2<bool, RequestContext>> TryReceiveAsync(TimeSpan timeout, MaskingMode maskingMode);
    protected bool ValidateInputOperation(TimeSpan timeout);
    protected bool ValidateOutputOperation(Message message, TimeSpan timeout, MaskingMode maskingMode);
    internal Task WaitForPendingOperationsAsync(TimeSpan timeout);
    protected RequestContext WrapMessage(Message message);
    public sealed virtual RequestContext WrapRequestContext(RequestContext context);
}
internal static class System.ServiceModel.Channels.ReliableChannelBinderHelper : object {
    [AsyncStateMachineAttribute("System.ServiceModel.Channels.ReliableChannelBinderHelper/<CloseDuplexSessionChannelAsync>d__0")]
internal static Task CloseDuplexSessionChannelAsync(ReliableChannelBinder`1<IDuplexSessionChannel> binder, IDuplexSessionChannel channel, TimeSpan timeout);
    [AsyncStateMachineAttribute("System.ServiceModel.Channels.ReliableChannelBinderHelper/<CloseReplySessionChannelAsync>d__1")]
internal static Task CloseReplySessionChannelAsync(ReliableChannelBinder`1<IReplySessionChannel> binder, IReplySessionChannel channel, TimeSpan timeout);
    internal static bool MaskHandled(MaskingMode maskingMode);
    internal static bool MaskUnhandled(MaskingMode maskingMode);
}
internal class System.ServiceModel.Channels.ReliableChannelFactory`2 : ChannelFactoryBase`1<TChannel> {
    [CompilerGeneratedAttribute]
private TimeSpan <AcknowledgementInterval>k__BackingField;
    [CompilerGeneratedAttribute]
private FaultHelper <FaultHelper>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <FlowControlEnabled>k__BackingField;
    [CompilerGeneratedAttribute]
private TimeSpan <InactivityTimeout>k__BackingField;
    [CompilerGeneratedAttribute]
private IChannelFactory`1<InnerChannel> <InnerChannelFactory>k__BackingField;
    [CompilerGeneratedAttribute]
private int <MaxPendingChannels>k__BackingField;
    [CompilerGeneratedAttribute]
private int <MaxRetryCount>k__BackingField;
    [CompilerGeneratedAttribute]
private MessageVersion <MessageVersion>k__BackingField;
    [CompilerGeneratedAttribute]
private int <MaxTransferWindowSize>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <Ordered>k__BackingField;
    [CompilerGeneratedAttribute]
private ReliableMessagingVersion <ReliableMessagingVersion>k__BackingField;
    public TimeSpan AcknowledgementInterval { get; }
    public FaultHelper FaultHelper { get; }
    public bool FlowControlEnabled { get; }
    public TimeSpan InactivityTimeout { get; }
    protected IChannelFactory`1<InnerChannel> InnerChannelFactory { get; }
    public int MaxPendingChannels { get; }
    public int MaxRetryCount { get; }
    public MessageVersion MessageVersion { get; }
    public int MaxTransferWindowSize { get; }
    public bool Ordered { get; }
    public ReliableMessagingVersion ReliableMessagingVersion { get; }
    public TimeSpan SendTimeout { get; }
    public ReliableChannelFactory`2(ReliableSessionBindingElement settings, IChannelFactory`1<InnerChannel> innerChannelFactory, Binding binding);
    [CompilerGeneratedAttribute]
public sealed virtual TimeSpan get_AcknowledgementInterval();
    [CompilerGeneratedAttribute]
public FaultHelper get_FaultHelper();
    [CompilerGeneratedAttribute]
public sealed virtual bool get_FlowControlEnabled();
    [CompilerGeneratedAttribute]
public sealed virtual TimeSpan get_InactivityTimeout();
    [CompilerGeneratedAttribute]
protected IChannelFactory`1<InnerChannel> get_InnerChannelFactory();
    [CompilerGeneratedAttribute]
public sealed virtual int get_MaxPendingChannels();
    [CompilerGeneratedAttribute]
public sealed virtual int get_MaxRetryCount();
    [CompilerGeneratedAttribute]
public sealed virtual MessageVersion get_MessageVersion();
    [CompilerGeneratedAttribute]
public sealed virtual int get_MaxTransferWindowSize();
    [CompilerGeneratedAttribute]
public sealed virtual bool get_Ordered();
    [CompilerGeneratedAttribute]
public sealed virtual ReliableMessagingVersion get_ReliableMessagingVersion();
    public virtual T GetProperty();
    public sealed virtual TimeSpan get_SendTimeout();
    protected virtual void OnAbort();
    protected internal virtual Task OnOpenAsync(TimeSpan timeout);
    protected virtual void OnOpen(TimeSpan timeout);
    protected virtual IAsyncResult OnBeginOpen(TimeSpan timeout, AsyncCallback callback, object state);
    protected virtual void OnEndOpen(IAsyncResult result);
    [AsyncStateMachineAttribute("System.ServiceModel.Channels.ReliableChannelFactory`2/<OnCloseAsync>d__42")]
protected internal virtual Task OnCloseAsync(TimeSpan timeout);
    protected virtual void OnClose(TimeSpan timeout);
    protected virtual IAsyncResult OnBeginClose(TimeSpan timeout, AsyncCallback callback, object state);
    protected virtual void OnEndClose(IAsyncResult result);
    protected virtual TChannel OnCreateChannel(EndpointAddress address, Uri via);
    [CompilerGeneratedAttribute]
[DebuggerHiddenAttribute]
private Task <>n__0(TimeSpan timeout);
}
internal abstract class System.ServiceModel.Channels.ReliableDuplexSessionChannel : DuplexChannel {
    private bool _acknowledgementScheduled;
    private IOThreadTimer _acknowledgementTimer;
    private ulong _ackVersion;
    private bool _advertisedZero;
    private InterruptibleWaitObject _closeOutputWaitObject;
    private SendWaitReliableRequestor _closeRequestor;
    private DeliveryStrategy`1<Message> _deliveryStrategy;
    private Guard _guard;
    private ReliableInputConnection _inputConnection;
    private Exception _maxRetryCountException;
    private int _pendingAcknowledgements;
    private SendWaitReliableRequestor _terminateRequestor;
    private static Action`1<object> s_processMessageStatic;
    protected static Func`2<object, Task> s_startReceivingAsyncStatic;
    [CompilerGeneratedAttribute]
private IReliableChannelBinder <Binder>k__BackingField;
    [CompilerGeneratedAttribute]
private ReliableOutputConnection <OutputConnection>k__BackingField;
    [CompilerGeneratedAttribute]
private ChannelReliableSession <ReliableSession>k__BackingField;
    [CompilerGeneratedAttribute]
private IReliableFactorySettings <Settings>k__BackingField;
    public IReliableChannelBinder Binder { get; }
    public EndpointAddress LocalAddress { get; }
    protected ReliableOutputConnection OutputConnection { get; private set; }
    protected UniqueId OutputID { get; }
    protected ChannelReliableSession ReliableSession { get; private set; }
    public EndpointAddress RemoteAddress { get; }
    protected IReliableFactorySettings Settings { get; }
    public Uri Via { get; }
    public IDuplexSession Session { get; }
    private IAsyncDuplexSession System.ServiceModel.Channels.ISessionChannel<System.ServiceModel.Channels.IAsyncDuplexSession>.Session { get; }
    protected ReliableDuplexSessionChannel(ChannelManagerBase manager, IReliableFactorySettings settings, IReliableChannelBinder binder);
    private static ReliableDuplexSessionChannel();
    [CompilerGeneratedAttribute]
public IReliableChannelBinder get_Binder();
    public virtual EndpointAddress get_LocalAddress();
    [CompilerGeneratedAttribute]
protected ReliableOutputConnection get_OutputConnection();
    [CompilerGeneratedAttribute]
private void set_OutputConnection(ReliableOutputConnection value);
    protected UniqueId get_OutputID();
    [CompilerGeneratedAttribute]
protected ChannelReliableSession get_ReliableSession();
    [CompilerGeneratedAttribute]
private void set_ReliableSession(ChannelReliableSession value);
    public virtual EndpointAddress get_RemoteAddress();
    [CompilerGeneratedAttribute]
protected IReliableFactorySettings get_Settings();
    public virtual Uri get_Via();
    public sealed virtual IDuplexSession get_Session();
    private sealed virtual override IAsyncDuplexSession System.ServiceModel.Channels.ISessionChannel<System.ServiceModel.Channels.IAsyncDuplexSession>.get_Session();
    private void AddPendingAcknowledgements(Message message);
    private Task CloseSequenceAsync(TimeSpan timeout);
    private void ConfigureRequestor(ReliableRequestor requestor);
    private Message CreateAcknowledgmentMessage();
    private void CreateCloseRequestor();
    private void CreateTerminateRequestor();
    private int GetBufferRemaining();
    public virtual T GetProperty();
    [AsyncStateMachineAttribute("System.ServiceModel.Channels.ReliableDuplexSessionChannel/<InternalCloseOutputSessionAsync>d__49")]
private Task InternalCloseOutputSessionAsync(TimeSpan timeout);
    protected virtual void OnRemoteActivity();
    private WsrmFault ProcessCloseOrTerminateSequenceResponse(bool close, WsrmMessageInfo info);
    [AsyncStateMachineAttribute("System.ServiceModel.Channels.ReliableDuplexSessionChannel/<ProcessDuplexMessageAsync>d__52")]
protected Task ProcessDuplexMessageAsync(WsrmMessageInfo info);
    private static void ProcessMessageStatic(object state);
    protected abstract virtual Task ProcessMessageAsync(WsrmMessageInfo info);
    protected virtual void OnAbort();
    [AsyncStateMachineAttribute("System.ServiceModel.Channels.ReliableDuplexSessionChannel/<OnAcknowledgementTimeoutElapsedAsync>d__56")]
private Task OnAcknowledgementTimeoutElapsedAsync(object state);
    protected virtual IAsyncResult OnBeginClose(TimeSpan timeout, AsyncCallback callback, object state);
    private void OnBinderException(IReliableChannelBinder sender, Exception exception);
    private void OnBinderFaulted(IReliableChannelBinder sender, Exception exception);
    [AsyncStateMachineAttribute("System.ServiceModel.Channels.ReliableDuplexSessionChannel/<OnCloseAsync>d__60")]
protected internal virtual Task OnCloseAsync(TimeSpan timeout);
    protected virtual void OnClose(TimeSpan timeout);
    [AsyncStateMachineAttribute("System.ServiceModel.Channels.ReliableDuplexSessionChannel/<OnCloseOutputSessionAsync>d__62")]
protected Task OnCloseOutputSessionAsync(TimeSpan timeout);
    protected virtual void OnClosed();
    protected virtual void OnClosing();
    private void OnComponentFaulted(Exception faultException, WsrmFault fault);
    private void OnComponentException(Exception exception);
    protected virtual void OnEndClose(IAsyncResult result);
    protected virtual void OnFaulted();
    [AsyncStateMachineAttribute("System.ServiceModel.Channels.ReliableDuplexSessionChannel/<OnSendAsync>d__69")]
protected virtual Task OnSendAsync(Message message, TimeSpan timeout);
    [AsyncStateMachineAttribute("System.ServiceModel.Channels.ReliableDuplexSessionChannel/<OnSendAsyncHandler>d__70")]
private Task OnSendAsyncHandler(MessageAttemptInfo attemptInfo, TimeSpan timeout, bool maskUnhandledException);
    [AsyncStateMachineAttribute("System.ServiceModel.Channels.ReliableDuplexSessionChannel/<OnSendAckRequestedAsyncHandler>d__71")]
private Task OnSendAckRequestedAsyncHandler(TimeSpan timeout);
    protected virtual void OnMessageDropped();
    protected void SetConnections();
    protected void SetSession(ChannelReliableSession session);
    private void OnDeliveryStrategyItemDequeued();
    private static Task StartReceivingAsyncStatic(object state);
    [AsyncStateMachineAttribute("System.ServiceModel.Channels.ReliableDuplexSessionChannel/<StartReceivingAsync>d__77")]
protected Task StartReceivingAsync();
    private void ShutdownCallback(object state);
    [AsyncStateMachineAttribute("System.ServiceModel.Channels.ReliableDuplexSessionChannel/<TerminateSequenceAsync>d__79")]
private Task TerminateSequenceAsync(TimeSpan timeout);
    private void ThrowIfCloseInvalid();
    private void ThrowInvalidAddException();
    private void UnblockClose();
    [CompilerGeneratedAttribute]
[DebuggerHiddenAttribute]
private Task <>n__0(TimeSpan timeout);
}
internal class System.ServiceModel.Channels.ReliableInputConnection : object {
    private bool _isLastKnown;
    private ReliableMessagingVersion _reliableMessagingVersion;
    private InterruptibleWaitObject _shutdownWaitObject;
    private bool _terminated;
    private InterruptibleWaitObject _terminateWaitObject;
    [CompilerGeneratedAttribute]
private bool <IsSequenceClosed>k__BackingField;
    [CompilerGeneratedAttribute]
private long <Last>k__BackingField;
    [CompilerGeneratedAttribute]
private SequenceRangeCollection <Ranges>k__BackingField;
    public bool AllAdded { get; }
    public bool IsLastKnown { get; }
    public bool IsSequenceClosed { get; private set; }
    public long Last { get; private set; }
    public SequenceRangeCollection Ranges { get; private set; }
    unknown ReliableMessagingVersion ReliableMessagingVersion {public set; }
    public bool get_AllAdded();
    public bool get_IsLastKnown();
    [CompilerGeneratedAttribute]
public bool get_IsSequenceClosed();
    [CompilerGeneratedAttribute]
private void set_IsSequenceClosed(bool value);
    [CompilerGeneratedAttribute]
public long get_Last();
    [CompilerGeneratedAttribute]
private void set_Last(long value);
    [CompilerGeneratedAttribute]
public SequenceRangeCollection get_Ranges();
    [CompilerGeneratedAttribute]
private void set_Ranges(SequenceRangeCollection value);
    public void set_ReliableMessagingVersion(ReliableMessagingVersion value);
    public void Abort(ChannelBase channel);
    public bool CanMerge(long sequenceNumber);
    public static bool CanMerge(long sequenceNumber, SequenceRangeCollection ranges);
    public void Fault(ChannelBase channel);
    public bool IsValid(long sequenceNumber, bool isLast);
    public void Merge(long sequenceNumber, bool isLast);
    public bool SetCloseSequenceLast(long last);
    private void SetLast(long last);
    public bool SetTerminateSequenceLast(long last, Boolean& isLastLargeEnough);
    public bool Terminate();
    [AsyncStateMachineAttribute("System.ServiceModel.Channels.ReliableInputConnection/<CloseAsync>d__34")]
public Task CloseAsync(TimeSpan timeout);
}
internal static class System.ServiceModel.Channels.ReliableMessagingConstants : object {
    public static TimeSpan UnknownInitiationTime;
    public static TimeSpan RequestorIterationTime;
    public static TimeSpan RequestorReceiveTime;
    public static int MaxSequenceRanges;
    private static ReliableMessagingConstants();
}
internal class System.ServiceModel.Channels.ReliableOutputConnection : object {
    private static Func`2<object, Task> s_sendRetries;
    private UniqueId _id;
    private ReliableMessagingVersion _reliableMessagingVersion;
    private Guard _sendGuard;
    private SendAsyncHandler _sendAsyncHandler;
    private OperationWithTimeoutAsyncCallback _sendAckRequestedAsyncHandler;
    private TimeSpan _sendTimeout;
    private InterruptibleWaitObject _shutdownHandle;
    private bool _terminated;
    public ComponentFaultedHandler Faulted;
    public ComponentExceptionHandler OnException;
    [CompilerGeneratedAttribute]
private MessageVersion <MessageVersion>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <Closed>k__BackingField;
    [CompilerGeneratedAttribute]
private TransmissionStrategy <Strategy>k__BackingField;
    [CompilerGeneratedAttribute]
private object <ThisLock>k__BackingField;
    private MessageVersion MessageVersion { get; }
    public bool Closed { get; private set; }
    public long Last { get; }
    unknown SendAsyncHandler SendAsyncHandler {public set; }
    unknown OperationWithTimeoutAsyncCallback SendAckRequestedAsyncHandler {public set; }
    public TransmissionStrategy Strategy { get; }
    private object ThisLock { get; }
    public ReliableOutputConnection(UniqueId id, int maxTransferWindowSize, MessageVersion messageVersion, ReliableMessagingVersion reliableMessagingVersion, TimeSpan initialRtt, bool requestAcks, TimeSpan sendTimeout);
    private static ReliableOutputConnection();
    [CompilerGeneratedAttribute]
private MessageVersion get_MessageVersion();
    [CompilerGeneratedAttribute]
public bool get_Closed();
    [CompilerGeneratedAttribute]
private void set_Closed(bool value);
    public long get_Last();
    public void set_SendAsyncHandler(SendAsyncHandler value);
    public void set_SendAckRequestedAsyncHandler(OperationWithTimeoutAsyncCallback value);
    [CompilerGeneratedAttribute]
public TransmissionStrategy get_Strategy();
    [CompilerGeneratedAttribute]
private object get_ThisLock();
    public void Abort(ChannelBase channel);
    private Task CompleteTransferAsync(TimeSpan timeout);
    public Task`1<bool> AddMessageAsync(Message message, TimeSpan timeout, object state);
    public bool CheckForTermination();
    [AsyncStateMachineAttribute("System.ServiceModel.Channels.ReliableOutputConnection/<CloseAsync>d__35")]
public Task CloseAsync(TimeSpan timeout);
    public void Fault(ChannelBase channel);
    [AsyncStateMachineAttribute("System.ServiceModel.Channels.ReliableOutputConnection/<InternalAddMessageAsync>d__37")]
private Task`1<bool> InternalAddMessageAsync(Message message, TimeSpan timeout, object state, bool isLast);
    public bool IsFinalAckConsistent(SequenceRangeCollection ranges);
    [AsyncStateMachineAttribute("System.ServiceModel.Channels.ReliableOutputConnection/<OnRetryTimeoutElapsed>d__39")]
private Task OnRetryTimeoutElapsed(MessageAttemptInfo attemptInfo);
    private void OnTransferComplete();
    public void ProcessTransferred(long transferred, SequenceRangeCollection ranges, int quotaRemaining);
    public void ProcessTransferred(SequenceRangeCollection ranges, int quotaRemaining);
    private void RaiseFault(Exception faultException, WsrmFault fault);
    private void RaiseOnException(Exception exception);
    [AsyncStateMachineAttribute("System.ServiceModel.Channels.ReliableOutputConnection/<SendRetries>d__45")]
private Task SendRetries();
    private static Task SendRetries(object state);
    public void Terminate();
}
internal abstract class System.ServiceModel.Channels.ReliableOutputSessionChannel : OutputChannel {
    private IClientReliableChannelBinder _binder;
    private ChannelParameterCollection _channelParameters;
    private ReliableRequestor _closeRequestor;
    private Exception _maxRetryCountException;
    private ClientReliableSession _session;
    private ReliableRequestor _terminateRequestor;
    [CompilerGeneratedAttribute]
private ReliableOutputConnection <Connection>k__BackingField;
    [CompilerGeneratedAttribute]
private IReliableFactorySettings <Settings>k__BackingField;
    protected IReliableChannelBinder Binder { get; }
    protected ReliableOutputConnection Connection { get; private set; }
    unknown Exception MaxRetryCountException {protected set; }
    protected ChannelReliableSession ReliableSession { get; }
    public EndpointAddress RemoteAddress { get; }
    protected bool RequestAcks { get; }
    public IOutputSession Session { get; }
    public Uri Via { get; }
    protected IReliableFactorySettings Settings { get; }
    protected ReliableOutputSessionChannel(ChannelManagerBase factory, IReliableFactorySettings settings, IClientReliableChannelBinder binder, FaultHelper faultHelper, LateBoundChannelParameterCollection channelParameters);
    protected IReliableChannelBinder get_Binder();
    [CompilerGeneratedAttribute]
protected ReliableOutputConnection get_Connection();
    [CompilerGeneratedAttribute]
private void set_Connection(ReliableOutputConnection value);
    protected void set_MaxRetryCountException(Exception value);
    protected ChannelReliableSession get_ReliableSession();
    public virtual EndpointAddress get_RemoteAddress();
    protected abstract virtual bool get_RequestAcks();
    public sealed virtual IOutputSession get_Session();
    public virtual Uri get_Via();
    [CompilerGeneratedAttribute]
protected IReliableFactorySettings get_Settings();
    [AsyncStateMachineAttribute("System.ServiceModel.Channels.ReliableOutputSessionChannel/<CloseSequenceAsync>d__28")]
private Task CloseSequenceAsync(TimeSpan timeout);
    private void ConfigureRequestor(ReliableRequestor requestor);
    private void CreateCloseRequestor();
    protected abstract virtual ReliableRequestor CreateRequestor();
    private void CreateTerminateRequestor();
    public virtual T GetProperty();
    protected virtual void OnAbort();
    protected virtual IAsyncResult OnBeginClose(TimeSpan timeout, AsyncCallback callback, object state);
    protected virtual IAsyncResult OnBeginOpen(TimeSpan timeout, AsyncCallback callback, object state);
    private void OnBinderException(IReliableChannelBinder sender, Exception exception);
    private void OnBinderFaulted(IReliableChannelBinder sender, Exception exception);
    protected virtual void OnClose(TimeSpan timeout);
    [AsyncStateMachineAttribute("System.ServiceModel.Channels.ReliableOutputSessionChannel/<OnCloseAsync>d__40")]
protected internal virtual Task OnCloseAsync(TimeSpan timeout);
    protected virtual void OnClosed();
    protected abstract virtual Task OnConnectionSendAsync(Message message, TimeSpan timeout, bool saveHandledException, bool maskUnhandledException);
    [AsyncStateMachineAttribute("System.ServiceModel.Channels.ReliableOutputSessionChannel/<OnConnectionSendAckRequestedAsyncHandler>d__43")]
private Task OnConnectionSendAckRequestedAsyncHandler(TimeSpan timeout);
    [AsyncStateMachineAttribute("System.ServiceModel.Channels.ReliableOutputSessionChannel/<OnConnectionSendAsyncHandler>d__44")]
private Task OnConnectionSendAsyncHandler(MessageAttemptInfo attemptInfo, TimeSpan timeout, bool maskUnhandledException);
    protected abstract virtual Task OnConnectionSendMessageAsync(Message message, TimeSpan timeout, MaskingMode maskingMode);
    private void OnComponentFaulted(Exception faultException, WsrmFault fault);
    private void OnComponentException(Exception exception);
    protected virtual void OnEndClose(IAsyncResult result);
    protected virtual void OnEndOpen(IAsyncResult result);
    protected virtual void OnFaulted();
    protected virtual void OnOpen(TimeSpan timeout);
    [AsyncStateMachineAttribute("System.ServiceModel.Channels.ReliableOutputSessionChannel/<OnOpenAsync>d__52")]
protected internal virtual Task OnOpenAsync(TimeSpan timeout);
    [AsyncStateMachineAttribute("System.ServiceModel.Channels.ReliableOutputSessionChannel/<OnSendAsync>d__53")]
protected virtual Task OnSendAsync(Message message, TimeSpan timeout);
    protected virtual void OnSend(Message message, TimeSpan timeout);
    protected virtual void OnOpened();
    [AsyncStateMachineAttribute("System.ServiceModel.Channels.ReliableOutputSessionChannel/<PollingAsyncCallback>d__56")]
private Task PollingAsyncCallback();
    private void ProcessCloseOrTerminateReply(bool close, Message reply);
    [AsyncStateMachineAttribute("System.ServiceModel.Channels.ReliableOutputSessionChannel/<ProcessMessageAsync>d__58")]
protected Task ProcessMessageAsync(Message message);
    protected abstract virtual WsrmFault ProcessRequestorResponse(ReliableRequestor requestor, string requestName, WsrmMessageInfo info);
    [AsyncStateMachineAttribute("System.ServiceModel.Channels.ReliableOutputSessionChannel/<TerminateSequenceAsync>d__60")]
private Task TerminateSequenceAsync(TimeSpan timeout);
    private void ThrowInvalidAddException();
    private void UnblockClose();
}
internal class System.ServiceModel.Channels.ReliableOutputSessionChannelOverDuplex : ReliableOutputSessionChannel {
    protected bool RequestAcks { get; }
    public ReliableOutputSessionChannelOverDuplex(ChannelManagerBase factory, IReliableFactorySettings settings, IClientReliableChannelBinder binder, FaultHelper faultHelper, LateBoundChannelParameterCollection channelParameters);
    protected virtual bool get_RequestAcks();
    protected virtual ReliableRequestor CreateRequestor();
    [AsyncStateMachineAttribute("System.ServiceModel.Channels.ReliableOutputSessionChannelOverDuplex/<OnConnectionSendAsync>d__4")]
protected virtual Task OnConnectionSendAsync(Message message, TimeSpan timeout, bool saveHandledException, bool maskUnhandledException);
    protected virtual Task OnConnectionSendMessageAsync(Message message, TimeSpan timeout, MaskingMode maskingMode);
    protected virtual void OnOpened();
    protected virtual WsrmFault ProcessRequestorResponse(ReliableRequestor requestor, string requestName, WsrmMessageInfo info);
    [AsyncStateMachineAttribute("System.ServiceModel.Channels.ReliableOutputSessionChannelOverDuplex/<StartReceivingAsync>d__8")]
private Task StartReceivingAsync();
    private static Task StartReceivingAsync(object state);
}
internal class System.ServiceModel.Channels.ReliableOutputSessionChannelOverRequest : ReliableOutputSessionChannel {
    private IClientReliableChannelBinder binder;
    protected bool RequestAcks { get; }
    public ReliableOutputSessionChannelOverRequest(ChannelManagerBase factory, IReliableFactorySettings settings, IClientReliableChannelBinder binder, FaultHelper faultHelper, LateBoundChannelParameterCollection channelParameters);
    protected virtual bool get_RequestAcks();
    protected virtual ReliableRequestor CreateRequestor();
    [AsyncStateMachineAttribute("System.ServiceModel.Channels.ReliableOutputSessionChannelOverRequest/<OnConnectionSendAsync>d__5")]
protected virtual Task OnConnectionSendAsync(Message message, TimeSpan timeout, bool saveHandledException, bool maskUnhandledException);
    [AsyncStateMachineAttribute("System.ServiceModel.Channels.ReliableOutputSessionChannelOverRequest/<OnConnectionSendMessageAsync>d__6")]
protected virtual Task OnConnectionSendMessageAsync(Message message, TimeSpan timeout, MaskingMode maskingMode);
    protected virtual WsrmFault ProcessRequestorResponse(ReliableRequestor requestor, string requestName, WsrmMessageInfo info);
}
internal abstract class System.ServiceModel.Channels.ReliableRequestor : object {
    private InterruptibleWaitObject abortHandle;
    private IReliableChannelBinder binder;
    private bool isCreateSequence;
    private ActionHeader messageAction;
    private BodyWriter messageBody;
    private WsrmMessageHeader messageHeader;
    private UniqueId messageId;
    private MessageVersion messageVersion;
    private TimeSpan originalTimeout;
    private string timeoutString1Index;
    protected IReliableChannelBinder Binder { get; public set; }
    protected bool IsCreateSequence { get; public set; }
    unknown ActionHeader MessageAction {public set; }
    unknown BodyWriter MessageBody {public set; }
    public UniqueId MessageId { get; }
    public WsrmMessageHeader MessageHeader { get; public set; }
    unknown MessageVersion MessageVersion {public set; }
    unknown string TimeoutString1Index {public set; }
    protected IReliableChannelBinder get_Binder();
    public void set_Binder(IReliableChannelBinder value);
    protected bool get_IsCreateSequence();
    public void set_IsCreateSequence(bool value);
    public void set_MessageAction(ActionHeader value);
    public void set_MessageBody(BodyWriter value);
    public UniqueId get_MessageId();
    public WsrmMessageHeader get_MessageHeader();
    public void set_MessageHeader(WsrmMessageHeader value);
    public void set_MessageVersion(MessageVersion value);
    public void set_TimeoutString1Index(string value);
    public void Abort(CommunicationObject communicationObject);
    private Message CreateRequestMessage();
    private Task`1<bool> EnsureChannelAsync();
    public virtual void Fault(CommunicationObject communicationObject);
    public abstract virtual WsrmMessageInfo GetInfo();
    private TimeSpan GetNextRequestTimeout(TimeSpan remainingTimeout, TimeoutHelper& iterationTimeout, Boolean& lastIteration);
    private bool HandleException(Exception exception, bool lastIteration);
    private void ThrowTimeoutException();
    protected abstract virtual Task`1<Message> OnRequestAsync(Message request, TimeSpan timeout, bool last);
    [AsyncStateMachineAttribute("System.ServiceModel.Channels.ReliableRequestor/<RequestAsync>d__38")]
public Task`1<Message> RequestAsync(TimeSpan timeout);
    public abstract virtual void SetInfo(WsrmMessageInfo info);
    public void SetRequestResponsePattern();
    private bool ValidateReply(Message response);
}
internal class System.ServiceModel.Channels.ReliableRequestSessionChannel : RequestChannel {
    private IClientReliableChannelBinder binder;
    private ChannelParameterCollection channelParameters;
    private ReliableRequestor closeRequestor;
    private ReliableOutputConnection connection;
    private bool isLastKnown;
    private Exception maxRetryCountException;
    private SequenceRangeCollection ranges;
    private Guard replyAckConsistencyGuard;
    private ClientReliableSession session;
    private IReliableFactorySettings settings;
    private InterruptibleWaitObject shutdownHandle;
    private ReliableRequestor terminateRequestor;
    public IOutputSession Session { get; }
    public ReliableRequestSessionChannel(ChannelManagerBase factory, IReliableFactorySettings settings, IClientReliableChannelBinder binder, FaultHelper faultHelper, LateBoundChannelParameterCollection channelParameters, UniqueId inputID);
    public sealed virtual IOutputSession get_Session();
    private void AddAcknowledgementHeader(Message message, bool force);
    [AsyncStateMachineAttribute("System.ServiceModel.Channels.ReliableRequestSessionChannel/<CloseSequenceAsync>d__16")]
private Task CloseSequenceAsync(TimeSpan timeout);
    private void ConfigureRequestor(ReliableRequestor requestor);
    private Message CreateAckRequestedMessage();
    protected virtual IAsyncRequest CreateAsyncRequest(Message message);
    private void CreateCloseRequestor();
    private void CreateTerminateRequestor();
    private Exception GetInvalidAddException();
    public virtual T GetProperty();
    protected virtual void OnAbort();
    protected virtual IAsyncResult OnBeginClose(TimeSpan timeout, AsyncCallback callback, object state);
    protected virtual IAsyncResult OnBeginOpen(TimeSpan timeout, AsyncCallback callback, object state);
    private void OnBinderException(IReliableChannelBinder sender, Exception exception);
    private void OnBinderFaulted(IReliableChannelBinder sender, Exception exception);
    [AsyncStateMachineAttribute("System.ServiceModel.Channels.ReliableRequestSessionChannel/<OnCloseAsync>d__29")]
protected internal virtual Task OnCloseAsync(TimeSpan timeout);
    protected virtual void OnClose(TimeSpan timeout);
    protected virtual void OnClosed();
    [AsyncStateMachineAttribute("System.ServiceModel.Channels.ReliableRequestSessionChannel/<OnConnectionSendAsync>d__32")]
private Task OnConnectionSendAsync(MessageAttemptInfo attemptInfo, TimeSpan timeout, bool maskUnhandledException);
    private Task OnConnectionSendAckAsyncRequested(TimeSpan timeout);
    private void OnComponentFaulted(Exception faultException, WsrmFault fault);
    private void OnComponentException(Exception exception);
    protected virtual void OnEndClose(IAsyncResult result);
    protected virtual void OnEndOpen(IAsyncResult result);
    protected virtual void OnFaulted();
    [AsyncStateMachineAttribute("System.ServiceModel.Channels.ReliableRequestSessionChannel/<OnOpenAsync>d__39")]
protected internal virtual Task OnOpenAsync(TimeSpan timeout);
    protected virtual void OnOpen(TimeSpan timeout);
    protected virtual void OnOpened();
    [AsyncStateMachineAttribute("System.ServiceModel.Channels.ReliableRequestSessionChannel/<PollingCallback>d__42")]
private Task PollingCallback();
    private void ProcessCloseOrTerminateReply(bool close, Message reply);
    private void ProcessReply(Message reply, IReliableRequest request, long requestSequenceNumber);
    [AsyncStateMachineAttribute("System.ServiceModel.Channels.ReliableRequestSessionChannel/<TerminateSequenceAsync>d__45")]
private Task TerminateSequenceAsync(TimeSpan timeout);
    private void UnblockClose();
    private Task WaitForShutdownAsync(TimeSpan timeout);
}
public class System.ServiceModel.Channels.ReliableSessionBindingElement : BindingElement {
    private TimeSpan _acknowledgementInterval;
    private TimeSpan _inactivityTimeout;
    private int _maxPendingChannels;
    private int _maxRetryCount;
    private int _maxTransferWindowSize;
    private ReliableMessagingVersion _reliableMessagingVersion;
    private static MessagePartSpecification s_bodyOnly;
    [CompilerGeneratedAttribute]
private bool <FlowControlEnabled>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <Ordered>k__BackingField;
    [DefaultValueAttribute("System.TimeSpan", "00:00:00.2")]
public TimeSpan AcknowledgementInterval { get; public set; }
    [DefaultValueAttribute("True")]
public bool FlowControlEnabled { get; public set; }
    [DefaultValueAttribute("System.TimeSpan", "00:10:00")]
public TimeSpan InactivityTimeout { get; public set; }
    [DefaultValueAttribute("4")]
public int MaxPendingChannels { get; public set; }
    [DefaultValueAttribute("8")]
public int MaxRetryCount { get; public set; }
    [DefaultValueAttribute("8")]
public int MaxTransferWindowSize { get; public set; }
    [DefaultValueAttribute("True")]
public bool Ordered { get; public set; }
    [DefaultValueAttribute("System.ServiceModel.ReliableMessagingVersion", "WSReliableMessagingFebruary2005")]
public ReliableMessagingVersion ReliableMessagingVersion { get; public set; }
    private static MessagePartSpecification BodyOnly { get; }
    internal ReliableSessionBindingElement(ReliableSessionBindingElement elementToBeCloned);
    public ReliableSessionBindingElement(bool ordered);
    public TimeSpan get_AcknowledgementInterval();
    public void set_AcknowledgementInterval(TimeSpan value);
    [CompilerGeneratedAttribute]
public bool get_FlowControlEnabled();
    [CompilerGeneratedAttribute]
public void set_FlowControlEnabled(bool value);
    public TimeSpan get_InactivityTimeout();
    public void set_InactivityTimeout(TimeSpan value);
    public int get_MaxPendingChannels();
    public void set_MaxPendingChannels(int value);
    public int get_MaxRetryCount();
    public void set_MaxRetryCount(int value);
    public int get_MaxTransferWindowSize();
    public void set_MaxTransferWindowSize(int value);
    [CompilerGeneratedAttribute]
public bool get_Ordered();
    [CompilerGeneratedAttribute]
public void set_Ordered(bool value);
    public ReliableMessagingVersion get_ReliableMessagingVersion();
    public void set_ReliableMessagingVersion(ReliableMessagingVersion value);
    private static MessagePartSpecification get_BodyOnly();
    public virtual BindingElement Clone();
    public virtual T GetProperty(BindingContext context);
    private ChannelProtectionRequirements GetProtectionRequirements();
    public virtual IChannelFactory`1<TChannel> BuildChannelFactory(BindingContext context);
    public virtual bool CanBuildChannelFactory(BindingContext context);
    private static void ProtectProtocolMessage(ScopedMessagePartSpecification signaturePart, ScopedMessagePartSpecification encryptionPart, string action);
    private void VerifyTransportMode(BindingContext context);
    private static XmlElement CreatePolicyElement(PolicyVersion policyVersion, XmlDocument doc);
}
internal static class System.ServiceModel.Channels.ReliableSessionDefaults : object {
    internal static string AcknowledgementIntervalString;
    internal static bool Enabled;
    internal static bool FlowControlEnabled;
    internal static string InactivityTimeoutString;
    internal static int MaxPendingChannels;
    internal static int MaxRetryCount;
    internal static int MaxTransferWindowSize;
    internal static bool Ordered;
    internal static string ReliableMessagingVersionString;
    internal static TimeSpan AcknowledgementInterval { get; }
    internal static TimeSpan InactivityTimeout { get; }
    internal static ReliableMessagingVersion ReliableMessagingVersion { get; }
    internal static TimeSpan get_AcknowledgementInterval();
    internal static TimeSpan get_InactivityTimeout();
    internal static ReliableMessagingVersion get_ReliableMessagingVersion();
}
internal class System.ServiceModel.Channels.ReplyFaultHelper : TypedFaultHelper`1<FaultState> {
    public ReplyFaultHelper(TimeSpan defaultSendTimeout, TimeSpan defaultCloseTimeout);
    protected virtual void AbortState(FaultState faultState, bool isOnAbortThread);
    [AsyncStateMachineAttribute("System.ServiceModel.Channels.ReplyFaultHelper/<SendFaultAsync>d__2")]
protected virtual Task SendFaultAsync(IReliableChannelBinder binder, FaultState faultState, TimeSpan timeout);
    protected virtual FaultState GetState(RequestContext requestContext, Message faultMessage);
}
internal class System.ServiceModel.Channels.ReplyToHeader : AddressingHeader {
    private static bool mustUnderstandValue;
    private static ReplyToHeader s_anonymousReplyToHeader10;
    [CompilerGeneratedAttribute]
private EndpointAddress <ReplyTo>k__BackingField;
    public EndpointAddress ReplyTo { get; }
    public XmlDictionaryString DictionaryName { get; }
    public bool MustUnderstand { get; }
    public static ReplyToHeader AnonymousReplyTo10 { get; }
    private ReplyToHeader(EndpointAddress replyTo, AddressingVersion version);
    [CompilerGeneratedAttribute]
public EndpointAddress get_ReplyTo();
    public virtual XmlDictionaryString get_DictionaryName();
    public virtual bool get_MustUnderstand();
    public static ReplyToHeader get_AnonymousReplyTo10();
    public static ReplyToHeader Create(EndpointAddress replyTo, AddressingVersion addressingVersion);
    protected virtual void OnWriteHeaderContents(XmlDictionaryWriter writer, MessageVersion messageVersion);
    public static ReplyToHeader ReadHeader(XmlDictionaryReader reader, AddressingVersion version, string actor, bool mustUnderstand, bool relay);
    public static EndpointAddress ReadHeaderValue(XmlDictionaryReader reader, AddressingVersion version);
}
internal abstract class System.ServiceModel.Channels.RequestChannel : ChannelBase {
    private List`1<IRequestBase> _outstandingRequests;
    private TaskCompletionSource`1<object> _closedTcs;
    private bool _closed;
    private int _outstandRequestCloseCount;
    [CompilerGeneratedAttribute]
private bool <ManualAddressing>k__BackingField;
    [CompilerGeneratedAttribute]
private EndpointAddress <RemoteAddress>k__BackingField;
    [CompilerGeneratedAttribute]
private Uri <Via>k__BackingField;
    protected bool ManualAddressing { get; }
    public EndpointAddress RemoteAddress { get; }
    public Uri Via { get; }
    protected RequestChannel(ChannelManagerBase channelFactory, EndpointAddress to, Uri via, bool manualAddressing);
    [CompilerGeneratedAttribute]
protected bool get_ManualAddressing();
    [CompilerGeneratedAttribute]
public sealed virtual EndpointAddress get_RemoteAddress();
    [CompilerGeneratedAttribute]
public sealed virtual Uri get_Via();
    protected void AbortPendingRequests();
    private void FinishClose();
    private IRequestBase[] SetupWaitForPendingRequests();
    protected void WaitForPendingRequests(TimeSpan timeout);
    [AsyncStateMachineAttribute("System.ServiceModel.Channels.RequestChannel/<WaitForPendingRequestsAsync>d__18")]
protected internal Task WaitForPendingRequestsAsync(TimeSpan timeout);
    private IRequestBase[] CopyPendingRequests(bool createTcsIfNecessary);
    protected void FaultPendingRequests();
    public virtual T GetProperty();
    protected virtual void OnAbort();
    private void ReleaseRequest(IRequestBase request);
    private void TrackRequest(IRequestBase request);
    public sealed virtual IAsyncResult BeginRequest(Message message, AsyncCallback callback, object state);
    public sealed virtual IAsyncResult BeginRequest(Message message, TimeSpan timeout, AsyncCallback callback, object state);
    protected abstract virtual IAsyncRequest CreateAsyncRequest(Message message);
    public sealed virtual Message EndRequest(IAsyncResult result);
    public sealed virtual Message Request(Message message);
    public sealed virtual Message Request(Message message, TimeSpan timeout);
    public sealed virtual Task`1<Message> RequestAsync(Message message);
    [AsyncStateMachineAttribute("System.ServiceModel.Channels.RequestChannel/<RequestAsyncInternal>d__32")]
private Task`1<Message> RequestAsyncInternal(Message message, TimeSpan timeout);
    [AsyncStateMachineAttribute("System.ServiceModel.Channels.RequestChannel/<RequestAsync>d__33")]
public sealed virtual Task`1<Message> RequestAsync(Message message, TimeSpan timeout);
    protected virtual void AddHeadersTo(Message message);
}
public abstract class System.ServiceModel.Channels.RequestContext : object {
    public Message RequestMessage { get; }
    public abstract virtual Message get_RequestMessage();
    public abstract virtual void Abort();
    public abstract virtual void Close();
    public abstract virtual void Close(TimeSpan timeout);
    public abstract virtual void Reply(Message message);
    public abstract virtual void Reply(Message message, TimeSpan timeout);
    public abstract virtual IAsyncResult BeginReply(Message message, AsyncCallback callback, object state);
    public abstract virtual IAsyncResult BeginReply(Message message, TimeSpan timeout, AsyncCallback callback, object state);
    public abstract virtual void EndReply(IAsyncResult result);
    private sealed virtual override void System.IDisposable.Dispose();
    protected virtual void Dispose(bool disposing);
}
internal abstract class System.ServiceModel.Channels.RequestContextBase : RequestContext {
    private TimeSpan _defaultCloseTimeout;
    private CommunicationState _state;
    private Message _requestMessage;
    private Exception _requestMessageException;
    private bool _replySent;
    private bool _aborted;
    [CompilerGeneratedAttribute]
private bool <ReplyInitiated>k__BackingField;
    [CompilerGeneratedAttribute]
private object <ThisLock>k__BackingField;
    [CompilerGeneratedAttribute]
private TimeSpan <DefaultSendTimeout>k__BackingField;
    public Message RequestMessage { get; }
    protected bool ReplyInitiated { get; private set; }
    protected object ThisLock { get; }
    public bool Aborted { get; }
    public TimeSpan DefaultCloseTimeout { get; }
    public TimeSpan DefaultSendTimeout { get; }
    protected RequestContextBase(Message requestMessage, TimeSpan defaultCloseTimeout, TimeSpan defaultSendTimeout);
    public void ReInitialize(Message requestMessage);
    public virtual Message get_RequestMessage();
    protected void SetRequestMessage(Message requestMessage);
    protected void SetRequestMessage(Exception requestMessageException);
    [CompilerGeneratedAttribute]
protected bool get_ReplyInitiated();
    [CompilerGeneratedAttribute]
private void set_ReplyInitiated(bool value);
    [CompilerGeneratedAttribute]
protected object get_ThisLock();
    public bool get_Aborted();
    public TimeSpan get_DefaultCloseTimeout();
    [CompilerGeneratedAttribute]
public TimeSpan get_DefaultSendTimeout();
    public virtual void Abort();
    public virtual void Close();
    public virtual void Close(TimeSpan timeout);
    protected virtual void Dispose(bool disposing);
    protected abstract virtual void OnAbort();
    protected abstract virtual void OnClose(TimeSpan timeout);
    protected abstract virtual void OnReply(Message message, TimeSpan timeout);
    protected abstract virtual IAsyncResult OnBeginReply(Message message, TimeSpan timeout, AsyncCallback callback, object state);
    protected abstract virtual void OnEndReply(IAsyncResult result);
    protected void ThrowIfInvalidReply();
    protected bool TryInitiateReply();
    public virtual IAsyncResult BeginReply(Message message, AsyncCallback callback, object state);
    public virtual IAsyncResult BeginReply(Message message, TimeSpan timeout, AsyncCallback callback, object state);
    public virtual void EndReply(IAsyncResult result);
    public virtual void Reply(Message message);
    public virtual void Reply(Message message, TimeSpan timeout);
    protected void SetReplySent();
}
internal class System.ServiceModel.Channels.RequestContextMessageProperty : object {
    private RequestContext _context;
    private object _thisLock;
    public static string Name { get; }
    public RequestContextMessageProperty(RequestContext context);
    public static string get_Name();
    private sealed virtual override void System.IDisposable.Dispose();
}
internal class System.ServiceModel.Channels.RequestReliableRequestor : ReliableRequestor {
    private bool replied;
    private WsrmMessageInfo replyInfo;
    private object thisLock;
    private IClientReliableChannelBinder ClientBinder { get; }
    private object ThisLock { get; }
    private IClientReliableChannelBinder get_ClientBinder();
    private object get_ThisLock();
    public virtual WsrmMessageInfo GetInfo();
    private Message GetReply(Message reply, bool last);
    [AsyncStateMachineAttribute("System.ServiceModel.Channels.RequestReliableRequestor/<OnRequestAsync>d__9")]
protected virtual Task`1<Message> OnRequestAsync(Message request, TimeSpan timeout, bool last);
    public virtual void SetInfo(WsrmMessageInfo info);
}
internal class System.ServiceModel.Channels.RequestReplyCorrelator : object {
    private Hashtable _states;
    private sealed virtual override void System.ServiceModel.Channels.IRequestReplyCorrelator.Add(Message request, T state);
    private sealed virtual override T System.ServiceModel.Channels.IRequestReplyCorrelator.Find(Message reply, bool remove);
    internal void RemoveRequest(ICorrelatorKey request);
    private UniqueId GetRelatesTo(Message reply);
    internal static bool AddressReply(Message reply, Message request);
    internal static bool AddressReply(Message reply, ReplyToInfo info);
    internal static ReplyToInfo ExtractReplyToInfo(Message message);
    internal static void PrepareRequest(Message request);
    internal static void PrepareReply(Message reply, UniqueId messageId);
    internal static void PrepareReply(Message reply, Message request);
}
internal class System.ServiceModel.Channels.RetryHandler : MulticastDelegate {
    public RetryHandler(object object, IntPtr method);
    public virtual Task Invoke(MessageAttemptInfo attemptInfo);
    public virtual IAsyncResult BeginInvoke(MessageAttemptInfo attemptInfo, AsyncCallback callback, object object);
    public virtual Task EndInvoke(IAsyncResult result);
}
public abstract class System.ServiceModel.Channels.SecurityBindingElement : BindingElement {
    internal static SecurityAlgorithmSuite defaultDefaultAlgorithmSuite;
    internal static bool defaultIncludeTimestamp;
    internal static bool defaultAllowInsecureTransport;
    internal static bool defaultRequireSignatureConfirmation;
    internal static bool defaultEnableUnsecuredResponse;
    internal static bool defaultProtectTokens;
    private SecurityAlgorithmSuite _defaultAlgorithmSuite;
    private SecurityKeyEntropyMode _keyEntropyMode;
    private Dictionary`2<string, SupportingTokenParameters> _operationSupportingTokenParameters;
    private Dictionary`2<string, SupportingTokenParameters> _optionalOperationSupportingTokenParameters;
    private MessageSecurityVersion _messageSecurityVersion;
    private SecurityHeaderLayout _securityHeaderLayout;
    private bool _protectTokens;
    [CompilerGeneratedAttribute]
private SupportingTokenParameters <EndpointSupportingTokenParameters>k__BackingField;
    [CompilerGeneratedAttribute]
private SupportingTokenParameters <OptionalEndpointSupportingTokenParameters>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <EnableUnsecuredResponse>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IncludeTimestamp>k__BackingField;
    [CompilerGeneratedAttribute]
private LocalClientSecuritySettings <LocalClientSettings>k__BackingField;
    [CompilerGeneratedAttribute]
private long <MaxReceivedMessageSize>k__BackingField;
    [CompilerGeneratedAttribute]
private XmlDictionaryReaderQuotas <ReaderQuotas>k__BackingField;
    public SupportingTokenParameters EndpointSupportingTokenParameters { get; }
    public SupportingTokenParameters OptionalEndpointSupportingTokenParameters { get; }
    public IDictionary`2<string, SupportingTokenParameters> OperationSupportingTokenParameters { get; }
    public IDictionary`2<string, SupportingTokenParameters> OptionalOperationSupportingTokenParameters { get; }
    public SecurityHeaderLayout SecurityHeaderLayout { get; public set; }
    public MessageSecurityVersion MessageSecurityVersion { get; public set; }
    public bool EnableUnsecuredResponse { get; public set; }
    public bool IncludeTimestamp { get; public set; }
    public SecurityAlgorithmSuite DefaultAlgorithmSuite { get; public set; }
    public LocalClientSecuritySettings LocalClientSettings { get; }
    public SecurityKeyEntropyMode KeyEntropyMode { get; public set; }
    internal bool SessionMode { get; }
    internal bool SupportsDuplex { get; }
    internal bool SupportsRequestReply { get; }
    internal long MaxReceivedMessageSize { get; internal set; }
    internal XmlDictionaryReaderQuotas ReaderQuotas { get; internal set; }
    internal SecurityBindingElement(SecurityBindingElement elementToBeCloned);
    private static SecurityBindingElement();
    [CompilerGeneratedAttribute]
public SupportingTokenParameters get_EndpointSupportingTokenParameters();
    [CompilerGeneratedAttribute]
public SupportingTokenParameters get_OptionalEndpointSupportingTokenParameters();
    public IDictionary`2<string, SupportingTokenParameters> get_OperationSupportingTokenParameters();
    public IDictionary`2<string, SupportingTokenParameters> get_OptionalOperationSupportingTokenParameters();
    public SecurityHeaderLayout get_SecurityHeaderLayout();
    public void set_SecurityHeaderLayout(SecurityHeaderLayout value);
    public MessageSecurityVersion get_MessageSecurityVersion();
    public void set_MessageSecurityVersion(MessageSecurityVersion value);
    [CompilerGeneratedAttribute]
public bool get_EnableUnsecuredResponse();
    [CompilerGeneratedAttribute]
public void set_EnableUnsecuredResponse(bool value);
    [CompilerGeneratedAttribute]
public bool get_IncludeTimestamp();
    [CompilerGeneratedAttribute]
public void set_IncludeTimestamp(bool value);
    public SecurityAlgorithmSuite get_DefaultAlgorithmSuite();
    public void set_DefaultAlgorithmSuite(SecurityAlgorithmSuite value);
    [CompilerGeneratedAttribute]
public LocalClientSecuritySettings get_LocalClientSettings();
    public SecurityKeyEntropyMode get_KeyEntropyMode();
    public void set_KeyEntropyMode(SecurityKeyEntropyMode value);
    internal virtual bool get_SessionMode();
    internal virtual bool get_SupportsDuplex();
    internal virtual bool get_SupportsRequestReply();
    [CompilerGeneratedAttribute]
internal long get_MaxReceivedMessageSize();
    [CompilerGeneratedAttribute]
internal void set_MaxReceivedMessageSize(long value);
    [CompilerGeneratedAttribute]
internal XmlDictionaryReaderQuotas get_ReaderQuotas();
    [CompilerGeneratedAttribute]
internal void set_ReaderQuotas(XmlDictionaryReaderQuotas value);
    private void GetSupportingTokensCapabilities(ICollection`1<SecurityTokenParameters> parameters, Boolean& supportsClientAuth, Boolean& supportsWindowsIdentity);
    private void GetSupportingTokensCapabilities(SupportingTokenParameters requirements, Boolean& supportsClientAuth, Boolean& supportsWindowsIdentity);
    internal void GetSupportingTokensCapabilities(Boolean& supportsClientAuth, Boolean& supportsWindowsIdentity);
    protected static void SetIssuerBindingContextIfRequired(SecurityTokenParameters parameters, BindingContext issuerBindingContext);
    private static void SetIssuerBindingContextIfRequired(SupportingTokenParameters supportingParameters, BindingContext issuerBindingContext);
    private void SetIssuerBindingContextIfRequired(BindingContext issuerBindingContext);
    internal bool RequiresChannelDemuxer(SecurityTokenParameters parameters);
    internal virtual bool RequiresChannelDemuxer();
    private void SetPrivacyNoticeUriIfRequired(SecurityProtocolFactory factory, Binding binding);
    internal void ConfigureProtocolFactory(SecurityProtocolFactory factory, SecurityCredentialsManager credentialsManager, bool isForService, BindingContext issuerBindingContext, Binding binding);
    internal abstract virtual SecurityProtocolFactory CreateSecurityProtocolFactory(BindingContext context, SecurityCredentialsManager credentialsManager, bool isForService, BindingContext issuanceBindingContext);
    public virtual IChannelFactory`1<TChannel> BuildChannelFactory(BindingContext context);
    protected abstract virtual IChannelFactory`1<TChannel> BuildChannelFactoryCore(BindingContext context);
    public virtual bool CanBuildChannelFactory(BindingContext context);
    private bool CanBuildSessionChannelFactory(BindingContext context);
    public virtual void SetKeyDerivation(bool requireDerivedKeys);
    internal virtual bool IsSetKeyDerivation(bool requireDerivedKeys);
    public virtual T GetProperty(BindingContext context);
    internal abstract virtual ISecurityCapabilities GetIndividualISecurityCapabilities();
    private ISecurityCapabilities GetSecurityCapabilities(BindingContext context);
    internal void ApplyPropertiesOnDemuxer(ChannelBuilder builder, BindingContext context);
    public static SecurityBindingElement CreateMutualCertificateBindingElement();
    public static SecurityBindingElement CreateMutualCertificateBindingElement(MessageSecurityVersion version);
    public static SecurityBindingElement CreateMutualCertificateBindingElement(MessageSecurityVersion version, bool allowSerializedSigningTokenOnReply);
    public static TransportSecurityBindingElement CreateUserNameOverTransportBindingElement();
    public static TransportSecurityBindingElement CreateCertificateOverTransportBindingElement();
    public static TransportSecurityBindingElement CreateCertificateOverTransportBindingElement(MessageSecurityVersion version);
    public static TransportSecurityBindingElement CreateIssuedTokenOverTransportBindingElement(IssuedSecurityTokenParameters issuedTokenParameters);
    public static SecurityBindingElement CreateSecureConversationBindingElement(SecurityBindingElement bootstrapSecurity);
    public static SecurityBindingElement CreateSecureConversationBindingElement(SecurityBindingElement bootstrapSecurity, bool requireCancellation);
    public static SecurityBindingElement CreateSecureConversationBindingElement(SecurityBindingElement bootstrapSecurity, bool requireCancellation, ChannelProtectionRequirements bootstrapProtectionRequirements);
    public virtual string ToString();
}
internal class System.ServiceModel.Channels.SecurityCapabilities : object {
    internal bool _supportsServerAuth;
    internal bool _supportsClientAuth;
    internal bool _supportsClientWindowsIdentity;
    internal ProtectionLevel _requestProtectionLevel;
    internal ProtectionLevel _responseProtectionLevel;
    public ProtectionLevel SupportedRequestProtectionLevel { get; }
    public ProtectionLevel SupportedResponseProtectionLevel { get; }
    public bool SupportsClientAuthentication { get; }
    public bool SupportsClientWindowsIdentity { get; }
    public bool SupportsServerAuthentication { get; }
    public static SecurityCapabilities None { get; }
    public SecurityCapabilities(bool supportsClientAuth, bool supportsServerAuth, bool supportsClientWindowsIdentity, ProtectionLevel requestProtectionLevel, ProtectionLevel responseProtectionLevel);
    public sealed virtual ProtectionLevel get_SupportedRequestProtectionLevel();
    public sealed virtual ProtectionLevel get_SupportedResponseProtectionLevel();
    public sealed virtual bool get_SupportsClientAuthentication();
    public sealed virtual bool get_SupportsClientWindowsIdentity();
    public sealed virtual bool get_SupportsServerAuthentication();
    public static SecurityCapabilities get_None();
    public static bool IsEqual(ISecurityCapabilities capabilities1, ISecurityCapabilities capabilities2);
}
internal class System.ServiceModel.Channels.SecurityChannelFactory`1 : LayeredChannelFactory`1<TChannel> {
    private SecuritySessionClientSettings`1<TChannel> _sessionClientSettings;
    private ISecurityCapabilities _securityCapabilities;
    [CompilerGeneratedAttribute]
private ChannelBuilder <ChannelBuilder>k__BackingField;
    [CompilerGeneratedAttribute]
private SecurityProtocolFactory <SecurityProtocolFactory>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <SessionMode>k__BackingField;
    [CompilerGeneratedAttribute]
private MessageVersion <MessageVersion>k__BackingField;
    public ChannelBuilder ChannelBuilder { get; }
    public SecurityProtocolFactory SecurityProtocolFactory { get; private set; }
    public SecuritySessionClientSettings`1<TChannel> SessionClientSettings { get; }
    public bool SessionMode { get; }
    private bool SupportsDuplex { get; }
    private bool SupportsRequestReply { get; }
    public MessageVersion MessageVersion { get; }
    public SecurityChannelFactory`1(ISecurityCapabilities securityCapabilities, BindingContext context, SecuritySessionClientSettings`1<TChannel> sessionClientSettings);
    public SecurityChannelFactory`1(ISecurityCapabilities securityCapabilities, BindingContext context, ChannelBuilder channelBuilder, SecurityProtocolFactory protocolFactory);
    public SecurityChannelFactory`1(ISecurityCapabilities securityCapabilities, BindingContext context, ChannelBuilder channelBuilder, SecurityProtocolFactory protocolFactory, IChannelFactory innerChannelFactory);
    private SecurityChannelFactory`1(ISecurityCapabilities securityCapabilities, BindingContext context, ChannelBuilder channelBuilder, IChannelFactory innerChannelFactory);
    [CompilerGeneratedAttribute]
public ChannelBuilder get_ChannelBuilder();
    [CompilerGeneratedAttribute]
public SecurityProtocolFactory get_SecurityProtocolFactory();
    [CompilerGeneratedAttribute]
private void set_SecurityProtocolFactory(SecurityProtocolFactory value);
    public SecuritySessionClientSettings`1<TChannel> get_SessionClientSettings();
    [CompilerGeneratedAttribute]
public bool get_SessionMode();
    private bool get_SupportsDuplex();
    private bool get_SupportsRequestReply();
    [CompilerGeneratedAttribute]
public MessageVersion get_MessageVersion();
    private Task CloseProtocolFactoryAsync(bool aborted, TimeSpan timeout);
    public virtual T GetProperty();
    protected virtual void OnAbort();
    protected virtual IAsyncResult OnBeginClose(TimeSpan timeout, AsyncCallback callback, object state);
    protected virtual void OnEndClose(IAsyncResult result);
    [AsyncStateMachineAttribute("System.ServiceModel.Channels.SecurityChannelFactory`1/<OnCloseAsync>d__30")]
protected internal virtual Task OnCloseAsync(TimeSpan timeout);
    protected virtual void OnClose(TimeSpan timeout);
    protected virtual TChannel OnCreateChannel(EndpointAddress address, Uri via);
    [AsyncStateMachineAttribute("System.ServiceModel.Channels.SecurityChannelFactory`1/<OnOpenAsync>d__33")]
protected internal virtual Task OnOpenAsync(TimeSpan timeout);
    protected virtual void OnOpen(TimeSpan timeout);
    private void SetBufferManager();
    protected virtual IAsyncResult OnBeginOpen(TimeSpan timeout, AsyncCallback callback, object state);
    protected virtual void OnEndOpen(IAsyncResult result);
    private Task OnOpenCoreAsync(TimeSpan timeout);
    private void ThrowIfProtocolFactoryNotSet();
    [CompilerGeneratedAttribute]
[DebuggerHiddenAttribute]
private Task <>n__0(TimeSpan timeout);
    [CompilerGeneratedAttribute]
[DebuggerHiddenAttribute]
private Task <>n__1(TimeSpan timeout);
}
internal class System.ServiceModel.Channels.SecurityChannelFaultConverter : FaultConverter {
    private IChannel _innerChannel;
    internal SecurityChannelFaultConverter(IChannel innerChannel);
    protected virtual bool OnTryCreateException(Message message, MessageFault fault, Exception& exception);
    protected virtual bool OnTryCreateFaultMessage(Exception exception, Message& message);
}
public enum System.ServiceModel.Channels.SecurityHeaderLayout : Enum {
    public int value__;
    public static SecurityHeaderLayout Strict;
    public static SecurityHeaderLayout Lax;
    public static SecurityHeaderLayout LaxTimestampFirst;
    public static SecurityHeaderLayout LaxTimestampLast;
}
internal static class System.ServiceModel.Channels.SecurityHeaderLayoutHelper : object {
    public static bool IsDefined(SecurityHeaderLayout value);
    public static void Validate(SecurityHeaderLayout value);
}
internal class System.ServiceModel.Channels.SendAsyncHandler : MulticastDelegate {
    public SendAsyncHandler(object object, IntPtr method);
    public virtual Task Invoke(MessageAttemptInfo attemptInfo, TimeSpan timeout, bool maskUnhandledException);
    public virtual IAsyncResult BeginInvoke(MessageAttemptInfo attemptInfo, TimeSpan timeout, bool maskUnhandledException, AsyncCallback callback, object object);
    public virtual Task EndInvoke(IAsyncResult result);
}
internal class System.ServiceModel.Channels.SendFaultHelper : TypedFaultHelper`1<Message> {
    public SendFaultHelper(TimeSpan defaultSendTimeout, TimeSpan defaultCloseTimeout);
    protected virtual void AbortState(Message message, bool isOnAbortThread);
    [AsyncStateMachineAttribute("System.ServiceModel.Channels.SendFaultHelper/<SendFaultAsync>d__2")]
protected virtual Task SendFaultAsync(IReliableChannelBinder binder, Message message, TimeSpan timeout);
    protected virtual Message GetState(RequestContext requestContext, Message faultMessage);
}
internal class System.ServiceModel.Channels.SendReceiveReliableRequestor : ReliableRequestor {
    private bool timeoutIsSafe;
    unknown bool TimeoutIsSafe {public set; }
    public void set_TimeoutIsSafe(bool value);
    public virtual WsrmMessageInfo GetInfo();
    private TimeSpan GetReceiveTimeout(TimeSpan timeoutRemaining);
    [AsyncStateMachineAttribute("System.ServiceModel.Channels.SendReceiveReliableRequestor/<OnRequestAsync>d__5")]
protected virtual Task`1<Message> OnRequestAsync(Message request, TimeSpan timeout, bool last);
    public virtual void SetInfo(WsrmMessageInfo info);
}
internal class System.ServiceModel.Channels.SendWaitReliableRequestor : ReliableRequestor {
    private bool replied;
    private InterruptibleWaitObject replyHandle;
    private WsrmMessageInfo replyInfo;
    private object thisLock;
    private object ThisLock { get; }
    private object get_ThisLock();
    public virtual void Fault(CommunicationObject communicationObject);
    public virtual WsrmMessageInfo GetInfo();
    private Message GetReply(bool last);
    private TimeSpan GetWaitTimeout(TimeSpan timeoutRemaining);
    [AsyncStateMachineAttribute("System.ServiceModel.Channels.SendWaitReliableRequestor/<OnRequestAsync>d__10")]
protected virtual Task`1<Message> OnRequestAsync(Message request, TimeSpan timeout, bool last);
    public virtual void SetInfo(WsrmMessageInfo info);
}
internal class System.ServiceModel.Channels.SequenceClosedFault : WsrmHeaderFault {
    public SequenceClosedFault(UniqueId sequenceID);
    public SequenceClosedFault(FaultCode code, FaultReason reason, XmlDictionaryReader detailReader, ReliableMessagingVersion reliableMessagingVersion);
}
internal class System.ServiceModel.Channels.SequenceRange : ValueType {
    [CompilerGeneratedAttribute]
private long <Lower>k__BackingField;
    [CompilerGeneratedAttribute]
private long <Upper>k__BackingField;
    public long Lower { get; }
    public long Upper { get; }
    public SequenceRange(long number);
    public SequenceRange(long lower, long upper);
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public long get_Lower();
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public long get_Upper();
    public static bool op_Equality(SequenceRange a, SequenceRange b);
    public static bool op_Inequality(SequenceRange a, SequenceRange b);
    public bool Contains(long number);
    public bool Contains(SequenceRange range);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    public virtual string ToString();
}
[DefaultMemberAttribute("Item")]
internal abstract class System.ServiceModel.Channels.SequenceRangeCollection : object {
    private static LowerComparer s_lowerComparer;
    private static UpperComparer s_upperComparer;
    [CompilerGeneratedAttribute]
private static SequenceRangeCollection <Empty>k__BackingField;
    public static SequenceRangeCollection Empty { get; }
    public SequenceRange Item { get; }
    public int Count { get; }
    private static SequenceRangeCollection();
    [CompilerGeneratedAttribute]
public static SequenceRangeCollection get_Empty();
    public abstract virtual SequenceRange get_Item(int index);
    public abstract virtual int get_Count();
    public abstract virtual bool Contains(long number);
    public abstract virtual SequenceRangeCollection MergeWith(long number);
    public abstract virtual SequenceRangeCollection MergeWith(SequenceRange range);
    private static SequenceRangeCollection GeneralCreate(SequenceRange[] sortedRanges);
    private static SequenceRangeCollection GeneralMerge(SequenceRange[] sortedRanges, SequenceRange range);
    public virtual string ToString();
}
internal class System.ServiceModel.Channels.SequenceTerminatedFault : WsrmHeaderFault {
    private SequenceTerminatedFault(bool isSenderFault, UniqueId sequenceID, string faultReason, string exceptionMessage);
    public SequenceTerminatedFault(FaultCode code, FaultReason reason, XmlDictionaryReader detailReader, ReliableMessagingVersion reliableMessagingVersion);
    public static WsrmFault CreateCommunicationFault(UniqueId sequenceID, string faultReason, string exceptionMessage);
    public static WsrmFault CreateMaxRetryCountExceededFault(UniqueId sequenceId);
    public static WsrmFault CreateProtocolFault(UniqueId sequenceID, string faultReason, string exceptionMessage);
    public static WsrmFault CreateQuotaExceededFault(UniqueId sequenceID);
}
internal class System.ServiceModel.Channels.ServiceChannel : CommunicationObject {
    private int _activityCount;
    private bool _allowInitializationUI;
    private bool _allowOutputBatching;
    private bool _autoClose;
    private CallOnceManager _autoDisplayUIManager;
    private CallOnceManager _autoOpenManager;
    private ChannelDispatcher _channelDispatcher;
    private bool _closeBinder;
    private bool _didInteractiveInitialization;
    private bool _doneReceiving;
    private EndpointDispatcher _endpointDispatcher;
    private bool _explicitlyOpened;
    private ExtensionCollection`1<IContextChannel> _extensions;
    private SessionIdleManager _idleManager;
    private EndpointAddress _localAddress;
    private bool _openBinder;
    private TimeSpan _operationTimeout;
    private object _proxy;
    private string _terminatingOperationName;
    private bool _hasChannelStartedAutoClosing;
    private bool _hasCleanedUpChannelCollections;
    private EventTraceActivity _eventActivity;
    private EventHandler`1<UnknownMessageReceivedEventArgs> _unknownMessageReceived;
    [CompilerGeneratedAttribute]
private bool <CloseFactory>k__BackingField;
    [CompilerGeneratedAttribute]
private MessageVersion <MessageVersion>k__BackingField;
    [CompilerGeneratedAttribute]
private IChannelBinder <Binder>k__BackingField;
    [CompilerGeneratedAttribute]
private ServiceChannelFactory <Factory>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsPending>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <HasSession>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsReplyChannel>k__BackingField;
    [CompilerGeneratedAttribute]
private ClientRuntime <ClientRuntime>k__BackingField;
    [CompilerGeneratedAttribute]
private InstanceContext <InstanceContext>k__BackingField;
    private CallOnceManager AutoOpenManager { get; }
    private CallOnceManager AutoDisplayUIManager { get; }
    internal EventTraceActivity EventActivity { get; }
    internal bool CloseFactory { get; internal set; }
    protected TimeSpan DefaultCloseTimeout { get; }
    protected TimeSpan DefaultOpenTimeout { get; }
    internal DispatchRuntime DispatchRuntime { get; }
    internal MessageVersion MessageVersion { get; }
    internal IChannelBinder Binder { get; }
    internal TimeSpan CloseTimeout { get; }
    internal ChannelDispatcher ChannelDispatcher { get; }
    internal EndpointDispatcher EndpointDispatcher { get; internal set; }
    internal ServiceChannelFactory Factory { get; }
    internal IChannel InnerChannel { get; }
    internal bool IsPending { get; internal set; }
    internal bool HasSession { get; }
    internal bool IsClient { get; }
    internal bool IsReplyChannel { get; }
    public Uri ListenUri { get; }
    public EndpointAddress LocalAddress { get; }
    internal TimeSpan OpenTimeout { get; }
    public TimeSpan OperationTimeout { get; public set; }
    internal object Proxy { get; internal set; }
    internal ClientRuntime ClientRuntime { get; private set; }
    public EndpointAddress RemoteAddress { get; }
    private ProxyOperationRuntime UnhandledProxyOperation { get; }
    public Uri Via { get; }
    internal InstanceContext InstanceContext { get; internal set; }
    private bool System.ServiceModel.IDuplexContextChannel.AutomaticInputSessionShutdown { get; private set; }
    private bool System.ServiceModel.IClientChannel.AllowInitializationUI { get; private set; }
    private bool System.ServiceModel.IContextChannel.AllowOutputBatching { get; private set; }
    private bool System.ServiceModel.IClientChannel.DidInteractiveInitialization { get; }
    private IExtensionCollection`1<IContextChannel> System.ServiceModel.IExtensibleObject<System.ServiceModel.IContextChannel>.Extensions { get; }
    private InstanceContext System.ServiceModel.IDuplexContextChannel.CallbackInstance { get; private set; }
    private IInputSession System.ServiceModel.IContextChannel.InputSession { get; }
    private IOutputSession System.ServiceModel.IContextChannel.OutputSession { get; }
    private string System.ServiceModel.IContextChannel.SessionId { get; }
    private ServiceChannel(IChannelBinder binder, MessageVersion messageVersion, IDefaultCommunicationTimeouts timeouts);
    internal ServiceChannel(ServiceChannelFactory factory, IChannelBinder binder);
    internal ServiceChannel(IChannelBinder binder, EndpointDispatcher endpointDispatcher, ChannelDispatcher channelDispatcher, SessionIdleManager idleManager);
    private CallOnceManager get_AutoOpenManager();
    private CallOnceManager get_AutoDisplayUIManager();
    internal EventTraceActivity get_EventActivity();
    [CompilerGeneratedAttribute]
internal bool get_CloseFactory();
    [CompilerGeneratedAttribute]
internal void set_CloseFactory(bool value);
    protected virtual TimeSpan get_DefaultCloseTimeout();
    protected virtual TimeSpan get_DefaultOpenTimeout();
    internal DispatchRuntime get_DispatchRuntime();
    [CompilerGeneratedAttribute]
internal MessageVersion get_MessageVersion();
    [CompilerGeneratedAttribute]
internal IChannelBinder get_Binder();
    internal TimeSpan get_CloseTimeout();
    internal ChannelDispatcher get_ChannelDispatcher();
    internal EndpointDispatcher get_EndpointDispatcher();
    internal void set_EndpointDispatcher(EndpointDispatcher value);
    [CompilerGeneratedAttribute]
internal ServiceChannelFactory get_Factory();
    internal IChannel get_InnerChannel();
    [CompilerGeneratedAttribute]
internal bool get_IsPending();
    [CompilerGeneratedAttribute]
internal void set_IsPending(bool value);
    [CompilerGeneratedAttribute]
internal bool get_HasSession();
    internal bool get_IsClient();
    [CompilerGeneratedAttribute]
internal bool get_IsReplyChannel();
    public sealed virtual Uri get_ListenUri();
    public sealed virtual EndpointAddress get_LocalAddress();
    internal TimeSpan get_OpenTimeout();
    public sealed virtual TimeSpan get_OperationTimeout();
    public sealed virtual void set_OperationTimeout(TimeSpan value);
    internal object get_Proxy();
    internal void set_Proxy(object value);
    [CompilerGeneratedAttribute]
internal ClientRuntime get_ClientRuntime();
    [CompilerGeneratedAttribute]
private void set_ClientRuntime(ClientRuntime value);
    public sealed virtual EndpointAddress get_RemoteAddress();
    private ProxyOperationRuntime get_UnhandledProxyOperation();
    public sealed virtual Uri get_Via();
    [CompilerGeneratedAttribute]
internal InstanceContext get_InstanceContext();
    [CompilerGeneratedAttribute]
internal void set_InstanceContext(InstanceContext value);
    private void SetupInnerChannelFaultHandler();
    private void BindDuplexCallbacks();
    internal bool CanCastTo(Type t);
    internal void CompletedIOOperation();
    private void EnsureAutoOpenManagers();
    private void EnsureDisplayUI();
    private IAsyncResult BeginEnsureDisplayUI(AsyncCallback callback, object state);
    private void EndEnsureDisplayUI(IAsyncResult result);
    private void EnsureOpened(TimeSpan timeout);
    private IAsyncResult BeginEnsureOpened(TimeSpan timeout, AsyncCallback callback, object state);
    private void EndEnsureOpened(IAsyncResult result);
    public sealed virtual T GetProperty();
    private void PrepareCall(ProxyOperationRuntime operation, bool oneway, ProxyRpc& rpc);
    private void TraceClientOperationPrepared(ProxyRpc& rpc);
    internal static IAsyncResult BeginCall(ServiceChannel channel, ProxyOperationRuntime operation, Object[] ins, AsyncCallback callback, object asyncState);
    internal IAsyncResult BeginCall(string action, bool oneway, ProxyOperationRuntime operation, Object[] ins, AsyncCallback callback, object asyncState);
    internal IAsyncResult BeginCall(string action, bool oneway, ProxyOperationRuntime operation, Object[] ins, TimeSpan timeout, AsyncCallback callback, object asyncState);
    internal object Call(string action, bool oneway, ProxyOperationRuntime operation, Object[] ins, Object[] outs);
    internal object Call(string action, bool oneway, ProxyOperationRuntime operation, Object[] ins, Object[] outs, TimeSpan timeout);
    internal object EndCall(string action, Object[] outs, IAsyncResult result);
    internal void DecrementActivity();
    internal void FireUnknownMessageReceived(Message message);
    private TimeoutException GetOpenTimeoutException(TimeSpan timeout);
    internal void HandleReceiveComplete(RequestContext context);
    private void HandleReply(ProxyOperationRuntime operation, ProxyRpc& rpc);
    private void TerminateIfNecessary(ProxyRpc& rpc);
    private void ThrowIfFaultUnderstood(Message reply, MessageFault fault, string action, MessageVersion version, FaultConverter faultConverter);
    private void ThrowIfIdleAborted(ProxyOperationRuntime operation);
    private void ThrowIfIsConnectionOpened(ProxyOperationRuntime operation);
    private void ThrowIfInitializationUINotCalled();
    private void ThrowIfDisallowedInitializationUI();
    private void ThrowIfDisallowedInitializationUICore();
    private void ThrowIfOpening();
    internal void IncrementActivity();
    private void OnInnerChannelFaulted(object sender, EventArgs e);
    private void AddMessageProperties(Message message, OperationContext context);
    public sealed virtual void Send(Message message);
    public sealed virtual void Send(Message message, TimeSpan timeout);
    public sealed virtual IAsyncResult BeginSend(Message message, AsyncCallback callback, object state);
    public sealed virtual IAsyncResult BeginSend(Message message, TimeSpan timeout, AsyncCallback callback, object state);
    public sealed virtual void EndSend(IAsyncResult result);
    public sealed virtual Message Request(Message message);
    public sealed virtual Message Request(Message message, TimeSpan timeout);
    public sealed virtual IAsyncResult BeginRequest(Message message, AsyncCallback callback, object state);
    public sealed virtual IAsyncResult BeginRequest(Message message, TimeSpan timeout, AsyncCallback callback, object state);
    public sealed virtual Message EndRequest(IAsyncResult result);
    protected virtual void OnAbort();
    protected virtual IAsyncResult OnBeginClose(TimeSpan timeout, AsyncCallback callback, object state);
    protected virtual void OnEndClose(IAsyncResult result);
    protected virtual void OnClose(TimeSpan timeout);
    [AsyncStateMachineAttribute("System.ServiceModel.Channels.ServiceChannel/<OnCloseAsync>d__148")]
protected internal virtual Task OnCloseAsync(TimeSpan timeout);
    protected virtual IAsyncResult OnBeginOpen(TimeSpan timeout, AsyncCallback callback, object state);
    protected virtual void OnEndOpen(IAsyncResult result);
    protected virtual void OnOpen(TimeSpan timeout);
    [AsyncStateMachineAttribute("System.ServiceModel.Channels.ServiceChannel/<OnOpenAsync>d__152")]
protected internal virtual Task OnOpenAsync(TimeSpan timeout);
    private void CleanupChannelCollections();
    private sealed virtual override bool System.ServiceModel.IDuplexContextChannel.get_AutomaticInputSessionShutdown();
    private sealed virtual override void System.ServiceModel.IDuplexContextChannel.set_AutomaticInputSessionShutdown(bool value);
    private sealed virtual override bool System.ServiceModel.IClientChannel.get_AllowInitializationUI();
    private sealed virtual override void System.ServiceModel.IClientChannel.set_AllowInitializationUI(bool value);
    private sealed virtual override bool System.ServiceModel.IContextChannel.get_AllowOutputBatching();
    private sealed virtual override void System.ServiceModel.IContextChannel.set_AllowOutputBatching(bool value);
    private sealed virtual override bool System.ServiceModel.IClientChannel.get_DidInteractiveInitialization();
    private sealed virtual override IAsyncResult System.ServiceModel.IDuplexContextChannel.BeginCloseOutputSession(TimeSpan timeout, AsyncCallback callback, object state);
    private sealed virtual override void System.ServiceModel.IDuplexContextChannel.EndCloseOutputSession(IAsyncResult result);
    private sealed virtual override void System.ServiceModel.IDuplexContextChannel.CloseOutputSession(TimeSpan timeout);
    private IDuplexSession GetDuplexSessionOrThrow();
    private sealed virtual override IExtensionCollection`1<IContextChannel> System.ServiceModel.IExtensibleObject<System.ServiceModel.IContextChannel>.get_Extensions();
    private sealed virtual override InstanceContext System.ServiceModel.IDuplexContextChannel.get_CallbackInstance();
    private sealed virtual override void System.ServiceModel.IDuplexContextChannel.set_CallbackInstance(InstanceContext value);
    private sealed virtual override IInputSession System.ServiceModel.IContextChannel.get_InputSession();
    private sealed virtual override IOutputSession System.ServiceModel.IContextChannel.get_OutputSession();
    private sealed virtual override string System.ServiceModel.IContextChannel.get_SessionId();
    private sealed virtual override void System.ServiceModel.IClientChannel.add_UnknownMessageReceived(EventHandler`1<UnknownMessageReceivedEventArgs> value);
    private sealed virtual override void System.ServiceModel.IClientChannel.remove_UnknownMessageReceived(EventHandler`1<UnknownMessageReceivedEventArgs> value);
    public sealed virtual void DisplayInitializationUI();
    public sealed virtual IAsyncResult BeginDisplayInitializationUI(AsyncCallback callback, object state);
    public sealed virtual void EndDisplayInitializationUI(IAsyncResult result);
    private sealed virtual override void System.IDisposable.Dispose();
    [AsyncStateMachineAttribute("System.ServiceModel.Channels.ServiceChannel/<System-IAsyncDisposable-DisposeAsync>d__187")]
private sealed virtual override ValueTask System.IAsyncDisposable.DisposeAsync();
    private void TraceChannelOpenStarted();
    private void TraceChannelOpenCompleted();
    private static void TraceServiceChannelCallStart(EventTraceActivity eventTraceActivity, bool isSynchronous);
}
internal abstract class System.ServiceModel.Channels.ServiceChannelFactory : ChannelFactoryBase {
    private string _bindingName;
    private List`1<IChannel> _channelsList;
    private ClientRuntime _clientRuntime;
    private RequestReplyCorrelator _requestReplyCorrelator;
    private IDefaultCommunicationTimeouts _timeouts;
    [CompilerGeneratedAttribute]
private MessageVersion <MessageVersion>k__BackingField;
    public ClientRuntime ClientRuntime { get; }
    internal RequestReplyCorrelator RequestReplyCorrelator { get; }
    protected TimeSpan DefaultCloseTimeout { get; }
    protected TimeSpan DefaultReceiveTimeout { get; }
    protected TimeSpan DefaultOpenTimeout { get; }
    protected TimeSpan DefaultSendTimeout { get; }
    public MessageVersion MessageVersion { get; }
    public ServiceChannelFactory(ClientRuntime clientRuntime, Binding binding);
    public ClientRuntime get_ClientRuntime();
    internal RequestReplyCorrelator get_RequestReplyCorrelator();
    protected virtual TimeSpan get_DefaultCloseTimeout();
    protected virtual TimeSpan get_DefaultReceiveTimeout();
    protected virtual TimeSpan get_DefaultOpenTimeout();
    protected virtual TimeSpan get_DefaultSendTimeout();
    [CompilerGeneratedAttribute]
public MessageVersion get_MessageVersion();
    public static ServiceChannelFactory BuildChannelFactory(ChannelBuilder channelBuilder, ClientRuntime clientRuntime);
    public static ServiceChannelFactory BuildChannelFactory(ServiceEndpoint serviceEndpoint);
    public static ServiceChannelFactory BuildChannelFactory(ServiceEndpoint serviceEndpoint, bool useActiveAutoClose);
    protected virtual void OnAbort();
    protected virtual void OnClose(TimeSpan timeout);
    protected virtual IAsyncResult OnBeginClose(TimeSpan timeout, AsyncCallback callback, object state);
    protected virtual void OnEndClose(IAsyncResult result);
    protected internal virtual Task OnCloseAsync(TimeSpan timeout);
    protected virtual void OnOpened();
    public void ChannelCreated(IChannel channel);
    public void ChannelDisposed(IChannel channel);
    public virtual ServiceChannel CreateServiceChannel(EndpointAddress address, Uri via);
    public TChannel CreateChannel(EndpointAddress address);
    public TChannel CreateChannel(EndpointAddress address, Uri via);
    public abstract virtual bool CanCreateChannel();
    internal static object CreateProxy(Type interfaceType, Type proxiedType, MessageDirection direction, ServiceChannel serviceChannel);
    internal static object CreateProxy(MessageDirection direction, ServiceChannel serviceChannel);
    internal static ServiceChannel GetServiceChannel(object transparentProxy);
    [AsyncStateMachineAttribute("System.ServiceModel.Channels.ServiceChannelFactory/<OnCloseAsyncInternal>d__39")]
private Task OnCloseAsyncInternal(TimeSpan timeout);
    protected abstract virtual IChannelBinder CreateInnerChannelBinder(EndpointAddress address, Uri via);
}
public class System.ServiceModel.Channels.ServiceChannelProxy : DispatchProxy {
    private static string activityIdSlotName;
    private Type _proxiedType;
    private ServiceChannel _serviceChannel;
    private ImmutableClientRuntime _proxyRuntime;
    private MethodDataCache _methodDataCache;
    private CommunicationState System.ServiceModel.ICommunicationObject.State { get; }
    private bool System.ServiceModel.IClientChannel.AllowInitializationUI { get; private set; }
    private bool System.ServiceModel.IClientChannel.DidInteractiveInitialization { get; }
    private Uri System.ServiceModel.IClientChannel.Via { get; }
    private bool System.ServiceModel.IContextChannel.AllowOutputBatching { get; private set; }
    private IInputSession System.ServiceModel.IContextChannel.InputSession { get; }
    private EndpointAddress System.ServiceModel.IContextChannel.LocalAddress { get; }
    private TimeSpan System.ServiceModel.IContextChannel.OperationTimeout { get; private set; }
    private IOutputSession System.ServiceModel.IContextChannel.OutputSession { get; }
    private EndpointAddress System.ServiceModel.Channels.IOutputChannel.RemoteAddress { get; }
    private Uri System.ServiceModel.Channels.IOutputChannel.Via { get; }
    private EndpointAddress System.ServiceModel.IContextChannel.RemoteAddress { get; }
    private string System.ServiceModel.IContextChannel.SessionId { get; }
    private IExtensionCollection`1<IContextChannel> System.ServiceModel.IExtensibleObject<System.ServiceModel.IContextChannel>.Extensions { get; }
    private EndpointAddress System.ServiceModel.Channels.IRequestChannel.RemoteAddress { get; }
    private Uri System.ServiceModel.Channels.IRequestChannel.Via { get; }
    private Uri System.ServiceModel.IServiceChannel.ListenUri { get; }
    public bool AutomaticInputSessionShutdown { get; public set; }
    public InstanceContext CallbackInstance { get; public set; }
    internal static TChannel CreateProxy(MessageDirection direction, ServiceChannel serviceChannel);
    public virtual string ToString();
    private MethodData GetMethodData(MethodCall methodCall);
    internal ServiceChannel GetServiceChannel();
    protected virtual object Invoke(MethodInfo targetMethod, Object[] args);
    private object InvokeTaskService(MethodCall methodCall, ProxyOperationRuntime operation);
    private object InvokeChannel(MethodCall methodCall);
    private object InvokeGetType(MethodCall methodCall);
    private object InvokeBeginService(MethodCall methodCall, ProxyOperationRuntime operation);
    private object InvokeEndService(MethodCall methodCall, ProxyOperationRuntime operation);
    private object InvokeService(MethodCall methodCall, ProxyOperationRuntime operation);
    private object ExecuteMessage(object target, MethodCall methodCall);
    private sealed virtual override T System.ServiceModel.Channels.IChannel.GetProperty();
    private sealed virtual override CommunicationState System.ServiceModel.ICommunicationObject.get_State();
    private sealed virtual override void System.ServiceModel.ICommunicationObject.add_Closed(EventHandler value);
    private sealed virtual override void System.ServiceModel.ICommunicationObject.remove_Closed(EventHandler value);
    private sealed virtual override void System.ServiceModel.ICommunicationObject.add_Closing(EventHandler value);
    private sealed virtual override void System.ServiceModel.ICommunicationObject.remove_Closing(EventHandler value);
    private sealed virtual override void System.ServiceModel.ICommunicationObject.add_Faulted(EventHandler value);
    private sealed virtual override void System.ServiceModel.ICommunicationObject.remove_Faulted(EventHandler value);
    private sealed virtual override void System.ServiceModel.ICommunicationObject.add_Opened(EventHandler value);
    private sealed virtual override void System.ServiceModel.ICommunicationObject.remove_Opened(EventHandler value);
    private sealed virtual override void System.ServiceModel.ICommunicationObject.add_Opening(EventHandler value);
    private sealed virtual override void System.ServiceModel.ICommunicationObject.remove_Opening(EventHandler value);
    private sealed virtual override void System.ServiceModel.ICommunicationObject.Abort();
    private sealed virtual override void System.ServiceModel.ICommunicationObject.Close();
    private sealed virtual override void System.ServiceModel.ICommunicationObject.Close(TimeSpan timeout);
    private sealed virtual override IAsyncResult System.ServiceModel.ICommunicationObject.BeginClose(AsyncCallback callback, object state);
    private sealed virtual override IAsyncResult System.ServiceModel.ICommunicationObject.BeginClose(TimeSpan timeout, AsyncCallback callback, object state);
    private sealed virtual override void System.ServiceModel.ICommunicationObject.EndClose(IAsyncResult result);
    private sealed virtual override void System.ServiceModel.ICommunicationObject.Open();
    private sealed virtual override void System.ServiceModel.ICommunicationObject.Open(TimeSpan timeout);
    private sealed virtual override IAsyncResult System.ServiceModel.ICommunicationObject.BeginOpen(AsyncCallback callback, object state);
    private sealed virtual override IAsyncResult System.ServiceModel.ICommunicationObject.BeginOpen(TimeSpan timeout, AsyncCallback callback, object state);
    private sealed virtual override void System.ServiceModel.ICommunicationObject.EndOpen(IAsyncResult result);
    private sealed virtual override bool System.ServiceModel.IClientChannel.get_AllowInitializationUI();
    private sealed virtual override void System.ServiceModel.IClientChannel.set_AllowInitializationUI(bool value);
    private sealed virtual override bool System.ServiceModel.IClientChannel.get_DidInteractiveInitialization();
    private sealed virtual override Uri System.ServiceModel.IClientChannel.get_Via();
    private sealed virtual override void System.ServiceModel.IClientChannel.add_UnknownMessageReceived(EventHandler`1<UnknownMessageReceivedEventArgs> value);
    private sealed virtual override void System.ServiceModel.IClientChannel.remove_UnknownMessageReceived(EventHandler`1<UnknownMessageReceivedEventArgs> value);
    private sealed virtual override IAsyncResult System.ServiceModel.IClientChannel.BeginDisplayInitializationUI(AsyncCallback callback, object state);
    private sealed virtual override void System.ServiceModel.IClientChannel.DisplayInitializationUI();
    private sealed virtual override void System.ServiceModel.IClientChannel.EndDisplayInitializationUI(IAsyncResult result);
    private sealed virtual override void System.IDisposable.Dispose();
    private sealed virtual override bool System.ServiceModel.IContextChannel.get_AllowOutputBatching();
    private sealed virtual override void System.ServiceModel.IContextChannel.set_AllowOutputBatching(bool value);
    private sealed virtual override IInputSession System.ServiceModel.IContextChannel.get_InputSession();
    private sealed virtual override EndpointAddress System.ServiceModel.IContextChannel.get_LocalAddress();
    private sealed virtual override TimeSpan System.ServiceModel.IContextChannel.get_OperationTimeout();
    private sealed virtual override void System.ServiceModel.IContextChannel.set_OperationTimeout(TimeSpan value);
    private sealed virtual override IOutputSession System.ServiceModel.IContextChannel.get_OutputSession();
    private sealed virtual override EndpointAddress System.ServiceModel.Channels.IOutputChannel.get_RemoteAddress();
    private sealed virtual override Uri System.ServiceModel.Channels.IOutputChannel.get_Via();
    private sealed virtual override EndpointAddress System.ServiceModel.IContextChannel.get_RemoteAddress();
    private sealed virtual override string System.ServiceModel.IContextChannel.get_SessionId();
    private sealed virtual override IExtensionCollection`1<IContextChannel> System.ServiceModel.IExtensibleObject<System.ServiceModel.IContextChannel>.get_Extensions();
    private sealed virtual override IAsyncResult System.ServiceModel.Channels.IOutputChannel.BeginSend(Message message, AsyncCallback callback, object state);
    private sealed virtual override IAsyncResult System.ServiceModel.Channels.IOutputChannel.BeginSend(Message message, TimeSpan timeout, AsyncCallback callback, object state);
    private sealed virtual override void System.ServiceModel.Channels.IOutputChannel.EndSend(IAsyncResult result);
    private sealed virtual override void System.ServiceModel.Channels.IOutputChannel.Send(Message message);
    private sealed virtual override void System.ServiceModel.Channels.IOutputChannel.Send(Message message, TimeSpan timeout);
    private sealed virtual override Message System.ServiceModel.Channels.IRequestChannel.Request(Message message);
    private sealed virtual override Message System.ServiceModel.Channels.IRequestChannel.Request(Message message, TimeSpan timeout);
    private sealed virtual override IAsyncResult System.ServiceModel.Channels.IRequestChannel.BeginRequest(Message message, AsyncCallback callback, object state);
    private sealed virtual override IAsyncResult System.ServiceModel.Channels.IRequestChannel.BeginRequest(Message message, TimeSpan timeout, AsyncCallback callback, object state);
    private sealed virtual override Message System.ServiceModel.Channels.IRequestChannel.EndRequest(IAsyncResult result);
    public sealed virtual IAsyncResult BeginCloseOutputSession(TimeSpan timeout, AsyncCallback callback, object state);
    public sealed virtual void EndCloseOutputSession(IAsyncResult result);
    public sealed virtual void CloseOutputSession(TimeSpan timeout);
    private sealed virtual override EndpointAddress System.ServiceModel.Channels.IRequestChannel.get_RemoteAddress();
    private sealed virtual override Uri System.ServiceModel.Channels.IRequestChannel.get_Via();
    private sealed virtual override Uri System.ServiceModel.IServiceChannel.get_ListenUri();
    public sealed virtual bool get_AutomaticInputSessionShutdown();
    public sealed virtual void set_AutomaticInputSessionShutdown(bool value);
    public sealed virtual InstanceContext get_CallbackInstance();
    public sealed virtual void set_CallbackInstance(InstanceContext value);
}
internal class System.ServiceModel.Channels.StreamedMessage : ReceivedMessage {
    private MessageHeaders _headers;
    private XmlAttributeHolder[] _envelopeAttributes;
    private XmlAttributeHolder[] _headerAttributes;
    private XmlAttributeHolder[] _bodyAttributes;
    private string _envelopePrefix;
    private string _headerPrefix;
    private string _bodyPrefix;
    private MessageProperties _properties;
    private XmlDictionaryReader _reader;
    private XmlDictionaryReaderQuotas _quotas;
    public MessageHeaders Headers { get; }
    public MessageVersion Version { get; }
    public MessageProperties Properties { get; }
    public StreamedMessage(XmlDictionaryReader reader, int maxSizeOfHeaders, MessageVersion desiredVersion);
    public virtual MessageHeaders get_Headers();
    public virtual MessageVersion get_Version();
    public virtual MessageProperties get_Properties();
    protected virtual void OnBodyToString(XmlDictionaryWriter writer);
    protected virtual void OnClose();
    protected virtual XmlDictionaryReader OnGetReaderAtBodyContents();
    protected virtual MessageBuffer OnCreateBufferedCopy(int maxBufferSize);
    protected virtual void OnWriteStartBody(XmlDictionaryWriter writer);
    protected virtual void OnWriteStartEnvelope(XmlDictionaryWriter writer);
    protected virtual void OnWriteStartHeaders(XmlDictionaryWriter writer);
    protected virtual string OnGetBodyAttribute(string localName, string ns);
}
internal class System.ServiceModel.Channels.StringMessage : ContentOnlyMessage {
    private string _data;
    public bool IsEmpty { get; }
    public StringMessage(string data);
    public virtual bool get_IsEmpty();
    protected virtual void OnWriteBodyContents(XmlDictionaryWriter writer);
}
public enum System.ServiceModel.Channels.SupportedAddressingMode : Enum {
    public int value__;
    public static SupportedAddressingMode Anonymous;
    public static SupportedAddressingMode NonAnonymous;
    public static SupportedAddressingMode Mixed;
}
internal static class System.ServiceModel.Channels.SupportedAddressingModeHelper : object {
    internal static bool IsDefined(SupportedAddressingMode value);
}
internal class System.ServiceModel.Channels.TerminateSequence : BodyWriter {
    private UniqueId _identifier;
    private long _lastMsgNumber;
    private ReliableMessagingVersion _reliableMessagingVersion;
    public TerminateSequence(ReliableMessagingVersion reliableMessagingVersion, UniqueId identifier, long last);
    public static TerminateSequenceInfo Create(ReliableMessagingVersion reliableMessagingVersion, XmlDictionaryReader reader);
    protected virtual void OnWriteBodyContents(XmlDictionaryWriter writer);
}
internal class System.ServiceModel.Channels.TerminateSequenceInfo : WsrmRequestInfo {
    [CompilerGeneratedAttribute]
private UniqueId <Identifier>k__BackingField;
    [CompilerGeneratedAttribute]
private long <LastMsgNumber>k__BackingField;
    public UniqueId Identifier { get; public set; }
    public long LastMsgNumber { get; public set; }
    public string RequestName { get; }
    [CompilerGeneratedAttribute]
public UniqueId get_Identifier();
    [CompilerGeneratedAttribute]
public void set_Identifier(UniqueId value);
    [CompilerGeneratedAttribute]
public long get_LastMsgNumber();
    [CompilerGeneratedAttribute]
public void set_LastMsgNumber(long value);
    public virtual string get_RequestName();
    public static TerminateSequenceInfo ReadMessage(MessageVersion messageVersion, ReliableMessagingVersion reliableMessagingVersion, Message message, MessageHeaders headers);
}
internal class System.ServiceModel.Channels.TerminateSequenceResponse : BodyWriter {
    [CompilerGeneratedAttribute]
private UniqueId <Identifier>k__BackingField;
    public UniqueId Identifier { get; public set; }
    public TerminateSequenceResponse(UniqueId identifier);
    [CompilerGeneratedAttribute]
public UniqueId get_Identifier();
    [CompilerGeneratedAttribute]
public void set_Identifier(UniqueId value);
    public static TerminateSequenceResponseInfo Create(XmlDictionaryReader reader);
    protected virtual void OnWriteBodyContents(XmlDictionaryWriter writer);
}
internal class System.ServiceModel.Channels.TerminateSequenceResponseInfo : object {
    [CompilerGeneratedAttribute]
private UniqueId <Identifier>k__BackingField;
    [CompilerGeneratedAttribute]
private UniqueId <RelatesTo>k__BackingField;
    public UniqueId Identifier { get; public set; }
    public UniqueId RelatesTo { get; public set; }
    [CompilerGeneratedAttribute]
public UniqueId get_Identifier();
    [CompilerGeneratedAttribute]
public void set_Identifier(UniqueId value);
    [CompilerGeneratedAttribute]
public UniqueId get_RelatesTo();
    [CompilerGeneratedAttribute]
public void set_RelatesTo(UniqueId value);
    public static TerminateSequenceResponseInfo ReadMessage(MessageVersion messageVersion, Message message, MessageHeaders headers);
}
internal static class System.ServiceModel.Channels.TextEncoderDefaults : object {
    public static Encoding Encoding;
    public static string EncodingString;
    public static Encoding[] SupportedEncodings;
    public static string MessageVersionString;
    public static CharSetEncoding[] CharSetEncodings;
    private static TextEncoderDefaults();
    public static void ValidateEncoding(Encoding encoding);
    public static string EncodingToCharSet(Encoding encoding);
    public static bool TryGetEncoding(string charSet, Encoding& encoding);
}
internal class System.ServiceModel.Channels.TextMessageEncoderFactory : MessageEncoderFactory {
    private TextMessageEncoder _messageEncoder;
    internal static ContentEncoding[] Soap11Content;
    internal static ContentEncoding[] Soap12Content;
    internal static ContentEncoding[] SoapNoneContent;
    internal static string Soap11MediaType;
    internal static string Soap12MediaType;
    private static string XmlMediaType;
    public MessageEncoder Encoder { get; }
    public MessageVersion MessageVersion { get; }
    public int MaxWritePoolSize { get; }
    public int MaxReadPoolSize { get; }
    public XmlDictionaryReaderQuotas ReaderQuotas { get; }
    public TextMessageEncoderFactory(MessageVersion version, Encoding writeEncoding, int maxReadPoolSize, int maxWritePoolSize, XmlDictionaryReaderQuotas quotas);
    private static TextMessageEncoderFactory();
    public virtual MessageEncoder get_Encoder();
    public virtual MessageVersion get_MessageVersion();
    public int get_MaxWritePoolSize();
    public int get_MaxReadPoolSize();
    public static Encoding[] GetSupportedEncodings();
    public XmlDictionaryReaderQuotas get_ReaderQuotas();
    internal static string GetMediaType(MessageVersion version);
    internal static string GetContentType(string mediaType, Encoding encoding);
    private static ContentEncoding[] GetContentEncodingMap(MessageVersion version);
    internal static Encoding GetEncodingFromContentType(string contentType, ContentEncoding[] contentMap);
    internal static bool TryGetEncodingFromCharSet(string charSet, Encoding& encoding);
}
public class System.ServiceModel.Channels.TextMessageEncodingBindingElement : MessageEncodingBindingElement {
    private int _maxReadPoolSize;
    private int _maxWritePoolSize;
    private XmlDictionaryReaderQuotas _readerQuotas;
    private MessageVersion _messageVersion;
    private Encoding _writeEncoding;
    [DefaultValueAttribute("64")]
public int MaxReadPoolSize { get; public set; }
    [DefaultValueAttribute("16")]
public int MaxWritePoolSize { get; public set; }
    public XmlDictionaryReaderQuotas ReaderQuotas { get; public set; }
    public MessageVersion MessageVersion { get; public set; }
    public Encoding WriteEncoding { get; public set; }
    public TextMessageEncodingBindingElement(MessageVersion messageVersion, Encoding writeEncoding);
    private TextMessageEncodingBindingElement(TextMessageEncodingBindingElement elementToBeCloned);
    public int get_MaxReadPoolSize();
    public void set_MaxReadPoolSize(int value);
    public int get_MaxWritePoolSize();
    public void set_MaxWritePoolSize(int value);
    public XmlDictionaryReaderQuotas get_ReaderQuotas();
    public void set_ReaderQuotas(XmlDictionaryReaderQuotas value);
    public virtual MessageVersion get_MessageVersion();
    public virtual void set_MessageVersion(MessageVersion value);
    public Encoding get_WriteEncoding();
    public void set_WriteEncoding(Encoding value);
    public virtual IChannelFactory`1<TChannel> BuildChannelFactory(BindingContext context);
    public virtual BindingElement Clone();
    public virtual MessageEncoderFactory CreateMessageEncoderFactory();
    public virtual T GetProperty(BindingContext context);
    internal virtual bool CheckEncodingVersion(EnvelopeVersion version);
    internal virtual bool IsMatch(BindingElement b);
}
internal class System.ServiceModel.Channels.TimeoutStream : DelegatingStream {
    private TimeoutHelper _timeoutHelper;
    private bool _disposed;
    private Byte[] _oneByteArray;
    public TimeoutStream(Stream stream, TimeSpan timeout);
    public virtual int Read(Byte[] buffer, int offset, int count);
    public virtual int ReadByte();
    [AsyncStateMachineAttribute("System.ServiceModel.Channels.TimeoutStream/<ReadAsync>d__6")]
public virtual Task`1<int> ReadAsync(Byte[] buffer, int offset, int count, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("System.ServiceModel.Channels.TimeoutStream/<ReadAsync>d__7")]
public virtual ValueTask`1<int> ReadAsync(Memory`1<byte> buffer, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("System.ServiceModel.Channels.TimeoutStream/<ReadAsyncInternal>d__8")]
private ValueTask`1<int> ReadAsyncInternal(Byte[] buffer, int offset, int count, CancellationToken cancellationToken);
    public virtual void Write(Byte[] buffer, int offset, int count);
    public virtual void WriteByte(byte value);
    [AsyncStateMachineAttribute("System.ServiceModel.Channels.TimeoutStream/<WriteAsync>d__11")]
public virtual Task WriteAsync(Byte[] buffer, int offset, int count, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("System.ServiceModel.Channels.TimeoutStream/<WriteAsync>d__12")]
public virtual ValueTask WriteAsync(ReadOnlyMemory`1<byte> buffer, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("System.ServiceModel.Channels.TimeoutStream/<WriteAsyncInternal>d__13")]
private ValueTask WriteAsyncInternal(Byte[] buffer, int offset, int count, CancellationToken cancellationToken);
    protected virtual void Dispose(bool disposing);
    public virtual ValueTask DisposeAsync();
    [CompilerGeneratedAttribute]
[DebuggerHiddenAttribute]
private Task`1<int> <>n__0(Byte[] buffer, int offset, int count, CancellationToken cancellationToken);
    [CompilerGeneratedAttribute]
[DebuggerHiddenAttribute]
private ValueTask`1<int> <>n__1(Memory`1<byte> buffer, CancellationToken cancellationToken);
    [CompilerGeneratedAttribute]
[DebuggerHiddenAttribute]
private Task <>n__2(Byte[] buffer, int offset, int count, CancellationToken cancellationToken);
    [CompilerGeneratedAttribute]
[DebuggerHiddenAttribute]
private ValueTask <>n__3(ReadOnlyMemory`1<byte> buffer, CancellationToken cancellationToken);
}
internal class System.ServiceModel.Channels.ToHeader : AddressingHeader {
    private static bool mustUnderstandValue;
    private static ToHeader s_anonymousToHeader10;
    private static ToHeader s_anonymousToHeader200408;
    [CompilerGeneratedAttribute]
private Uri <To>k__BackingField;
    private static ToHeader AnonymousTo10 { get; }
    private static ToHeader AnonymousTo200408 { get; }
    public XmlDictionaryString DictionaryName { get; }
    public bool MustUnderstand { get; }
    public Uri To { get; }
    protected ToHeader(Uri to, AddressingVersion version);
    private static ToHeader get_AnonymousTo10();
    private static ToHeader get_AnonymousTo200408();
    public virtual XmlDictionaryString get_DictionaryName();
    public virtual bool get_MustUnderstand();
    [CompilerGeneratedAttribute]
public Uri get_To();
    public static ToHeader Create(Uri toUri, XmlDictionaryString dictionaryTo, AddressingVersion addressingVersion);
    public static ToHeader Create(Uri to, AddressingVersion addressingVersion);
    protected virtual void OnWriteHeaderContents(XmlDictionaryWriter writer, MessageVersion messageVersion);
    public static Uri ReadHeaderValue(XmlDictionaryReader reader, AddressingVersion version);
    public static Uri ReadHeaderValue(XmlDictionaryReader reader, AddressingVersion version, UriCache uriCache);
    public static ToHeader ReadHeader(XmlDictionaryReader reader, AddressingVersion version, UriCache uriCache, string actor, bool mustUnderstand, bool relay);
}
internal enum System.ServiceModel.Channels.TolerateFaultsMode : Enum {
    public int value__;
    public static TolerateFaultsMode Never;
    public static TolerateFaultsMode IfNotSecuritySession;
    public static TolerateFaultsMode Always;
}
internal class System.ServiceModel.Channels.TransmissionStrategy : object {
    private bool _aborted;
    private bool _closed;
    private int _congestionControlModeAcks;
    private UniqueId _id;
    private int _lossWindowSize;
    private int _maxWindowSize;
    private long _meanRtt;
    private ComponentExceptionHandler _onException;
    private ReliableMessagingVersion _reliableMessagingVersion;
    private List`1<long> _retransmissionWindow;
    private IOThreadTimer _retryTimer;
    private RetryHandler _retryTimeoutElapsedHandler;
    private bool _requestAcks;
    private long _serrRtt;
    private int _slowStartThreshold;
    private bool _startup;
    private long _timeout;
    private Queue`1<IQueueAdder> _waitQueue;
    private SlidingWindow _window;
    private int _windowSize;
    private long _windowStart;
    [CompilerGeneratedAttribute]
private long <Last>k__BackingField;
    [CompilerGeneratedAttribute]
private int <QuotaRemaining>k__BackingField;
    [CompilerGeneratedAttribute]
private object <ThisLock>k__BackingField;
    public bool DoneTransmitting { get; }
    public bool HasPending { get; }
    public long Last { get; private set; }
    private static long Now { get; }
    unknown ComponentExceptionHandler OnException {public set; }
    unknown RetryHandler RetryTimeoutElapsed {public set; }
    public int QuotaRemaining { get; private set; }
    private object ThisLock { get; }
    public int Timeout { get; }
    public TransmissionStrategy(ReliableMessagingVersion reliableMessagingVersion, TimeSpan initRtt, int maxWindowSize, bool requestAcks, UniqueId id);
    public bool get_DoneTransmitting();
    public bool get_HasPending();
    [CompilerGeneratedAttribute]
public long get_Last();
    [CompilerGeneratedAttribute]
private void set_Last(long value);
    private static long get_Now();
    public void set_OnException(ComponentExceptionHandler value);
    public void set_RetryTimeoutElapsed(RetryHandler value);
    [CompilerGeneratedAttribute]
public int get_QuotaRemaining();
    [CompilerGeneratedAttribute]
private void set_QuotaRemaining(int value);
    [CompilerGeneratedAttribute]
private object get_ThisLock();
    public int get_Timeout();
    public void Abort(ChannelBase channel);
    public Task`1<ValueTuple`2<MessageAttemptInfo, bool>> AddAsync(Message message, TimeSpan timeout, object state);
    [AsyncStateMachineAttribute("System.ServiceModel.Channels.TransmissionStrategy/<AddLastAsync>d__47")]
public Task`1<MessageAttemptInfo> AddLastAsync(Message message, TimeSpan timeout, object state);
    private MessageAttemptInfo AddToWindow(Message message, bool isLast, object state);
    private bool CanAdd();
    public void Close();
    public void DequeuePending();
    private bool IsAddValid();
    public Task OnRetryElapsed(object state);
    public void Fault(ChannelBase channel);
    public MessageAttemptInfo GetMessageInfoForRetry(bool remove);
    public bool SetLast();
    [AsyncStateMachineAttribute("System.ServiceModel.Channels.TransmissionStrategy/<InternalAddAsync>d__57")]
private Task`1<ValueTuple`2<MessageAttemptInfo, bool>> InternalAddAsync(Message message, bool isLast, TimeSpan timeout, object state);
    public bool IsFinalAckConsistent(SequenceRangeCollection ranges);
    public void ProcessAcknowledgement(SequenceRangeCollection ranges, Boolean& invalidAck, Boolean& inconsistentAck);
    public bool ProcessTransferred(long transferred, int quotaRemaining);
    public bool ProcessTransferred(SequenceRangeCollection ranges, int quotaRemaining);
    private bool ProcessTransferred(SequenceRange range, int quotaRemaining);
    private bool RemoveAdder(IQueueAdder adder);
    private void ThrowIfRollover();
    private void UpdateStats(long now, long lastAttemptTime);
}
public abstract class System.ServiceModel.Channels.TransportBindingElement : BindingElement {
    private bool _manualAddressing;
    private long _maxBufferPoolSize;
    private long _maxReceivedMessageSize;
    [DefaultValueAttribute("False")]
public bool ManualAddressing { get; public set; }
    [DefaultValueAttribute("524288")]
public long MaxBufferPoolSize { get; public set; }
    [DefaultValueAttribute("65536")]
public long MaxReceivedMessageSize { get; public set; }
    public string Scheme { get; }
    protected TransportBindingElement(TransportBindingElement elementToBeCloned);
    public virtual bool get_ManualAddressing();
    public virtual void set_ManualAddressing(bool value);
    public virtual long get_MaxBufferPoolSize();
    public virtual void set_MaxBufferPoolSize(long value);
    public virtual long get_MaxReceivedMessageSize();
    public virtual void set_MaxReceivedMessageSize(long value);
    public abstract virtual string get_Scheme();
    internal static IChannelFactory`1<TChannel> CreateChannelFactory(TransportBindingElement transport);
    public virtual T GetProperty(BindingContext context);
    private ChannelProtectionRequirements GetProtectionRequirements(AddressingVersion addressingVersion);
    internal ChannelProtectionRequirements GetProtectionRequirements(BindingContext context);
    internal virtual bool IsMatch(BindingElement b);
}
internal abstract class System.ServiceModel.Channels.TransportChannelFactory`1 : ChannelFactoryBase`1<TChannel> {
    private long _maxReceivedMessageSize;
    private MessageVersion _messageVersion;
    [CompilerGeneratedAttribute]
private BufferManager <BufferManager>k__BackingField;
    [CompilerGeneratedAttribute]
private long <MaxBufferPoolSize>k__BackingField;
    [CompilerGeneratedAttribute]
private MessageEncoderFactory <MessageEncoderFactory>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <ManualAddressing>k__BackingField;
    public BufferManager BufferManager { get; private set; }
    public long MaxBufferPoolSize { get; }
    public long MaxReceivedMessageSize { get; }
    public MessageEncoderFactory MessageEncoderFactory { get; }
    public MessageVersion MessageVersion { get; }
    public bool ManualAddressing { get; }
    public string Scheme { get; }
    private long System.ServiceModel.Channels.ITransportFactorySettings.MaxReceivedMessageSize { get; }
    private BufferManager System.ServiceModel.Channels.ITransportFactorySettings.BufferManager { get; }
    private bool System.ServiceModel.Channels.ITransportFactorySettings.ManualAddressing { get; }
    private MessageEncoderFactory System.ServiceModel.Channels.ITransportFactorySettings.MessageEncoderFactory { get; }
    protected TransportChannelFactory`1(TransportBindingElement bindingElement, BindingContext context);
    protected TransportChannelFactory`1(TransportBindingElement bindingElement, BindingContext context, MessageEncoderFactory defaultMessageEncoderFactory);
    [CompilerGeneratedAttribute]
public BufferManager get_BufferManager();
    [CompilerGeneratedAttribute]
private void set_BufferManager(BufferManager value);
    [CompilerGeneratedAttribute]
public long get_MaxBufferPoolSize();
    public long get_MaxReceivedMessageSize();
    [CompilerGeneratedAttribute]
public MessageEncoderFactory get_MessageEncoderFactory();
    public sealed virtual MessageVersion get_MessageVersion();
    [CompilerGeneratedAttribute]
public bool get_ManualAddressing();
    public abstract virtual string get_Scheme();
    public virtual T GetProperty();
    protected virtual void OnAbort();
    protected virtual IAsyncResult OnBeginClose(TimeSpan timeout, AsyncCallback callback, object state);
    protected virtual void OnClose(TimeSpan timeout);
    protected internal virtual Task OnCloseAsync(TimeSpan timeout);
    private void OnCloseOrAbort();
    public virtual int GetMaxBufferSize();
    protected virtual void OnOpening();
    public void ValidateScheme(Uri via);
    private sealed virtual override long System.ServiceModel.Channels.ITransportFactorySettings.get_MaxReceivedMessageSize();
    private sealed virtual override BufferManager System.ServiceModel.Channels.ITransportFactorySettings.get_BufferManager();
    private sealed virtual override bool System.ServiceModel.Channels.ITransportFactorySettings.get_ManualAddressing();
    private sealed virtual override MessageEncoderFactory System.ServiceModel.Channels.ITransportFactorySettings.get_MessageEncoderFactory();
}
internal static class System.ServiceModel.Channels.TransportDefaults : object {
    public static bool ExtractGroupsForWindowsAccounts;
    public static HostNameComparisonMode HostNameComparisonMode;
    public static TokenImpersonationLevel ImpersonationLevel;
    public static bool ManualAddressing;
    public static long MaxReceivedMessageSize;
    public static int MaxDrainSize;
    public static long MaxBufferPoolSize;
    public static int MaxBufferSize;
    public static bool RequireClientCertificate;
    public static int MaxFaultSize;
    public static int MaxSecurityFaultSize;
    public static SslProtocols SslProtocols;
    public static int MaxRMFaultSize;
    public static MessageEncoderFactory GetDefaultMessageEncoderFactory();
}
internal abstract class System.ServiceModel.Channels.TransportOutputChannel : OutputChannel {
    private bool _anyHeadersToAdd;
    private EndpointAddress _to;
    private Uri _via;
    private ToHeader _toHeader;
    [CompilerGeneratedAttribute]
private bool <ManualAddressing>k__BackingField;
    [CompilerGeneratedAttribute]
private MessageVersion <MessageVersion>k__BackingField;
    [CompilerGeneratedAttribute]
private EventTraceActivity <EventTraceActivity>k__BackingField;
    protected bool ManualAddressing { get; }
    public MessageVersion MessageVersion { get; }
    public EndpointAddress RemoteAddress { get; }
    public Uri Via { get; }
    public EventTraceActivity EventTraceActivity { get; }
    protected TransportOutputChannel(ChannelManagerBase channelManager, EndpointAddress to, Uri via, bool manualAddressing, MessageVersion messageVersion);
    [CompilerGeneratedAttribute]
protected bool get_ManualAddressing();
    [CompilerGeneratedAttribute]
public MessageVersion get_MessageVersion();
    public virtual EndpointAddress get_RemoteAddress();
    public virtual Uri get_Via();
    [CompilerGeneratedAttribute]
public EventTraceActivity get_EventTraceActivity();
    protected virtual void AddHeadersTo(Message message);
}
internal static class System.ServiceModel.Channels.TransportPolicyConstants : object {
    public static string BasicHttpAuthenticationName;
    public static string CompositeDuplex;
    public static string CompositeDuplexNamespace;
    public static string CompositeDuplexPrefix;
    public static string DigestHttpAuthenticationName;
    public static string DotNetFramingNamespace;
    public static string DotNetFramingPrefix;
    public static string HttpTransportNamespace;
    public static string HttpTransportPrefix;
    public static string HttpTransportUri;
    public static string NamedPipeTransportUri;
    public static string NegotiateHttpAuthenticationName;
    public static string NtlmHttpAuthenticationName;
    public static string PeerTransportUri;
    public static string ProtectionLevelName;
    public static string RequireClientCertificateName;
    public static string SslTransportSecurityName;
    public static string StreamedName;
    public static string TcpTransportUri;
    public static string WebSocketPolicyPrefix;
    public static string WebSocketPolicyNamespace;
    public static string WebSocketTransportUri;
    public static string WebSocketEnabled;
    public static string WindowsTransportSecurityName;
}
public class System.ServiceModel.Channels.TransportSecurityBindingElement : SecurityBindingElement {
    internal bool SessionMode { get; }
    internal bool SupportsDuplex { get; }
    internal bool SupportsRequestReply { get; }
    private TransportSecurityBindingElement(TransportSecurityBindingElement elementToBeCloned);
    internal virtual ISecurityCapabilities GetIndividualISecurityCapabilities();
    internal virtual bool get_SessionMode();
    internal virtual bool get_SupportsDuplex();
    internal virtual bool get_SupportsRequestReply();
    internal virtual SecurityProtocolFactory CreateSecurityProtocolFactory(BindingContext context, SecurityCredentialsManager credentialsManager, bool isForService, BindingContext issuerBindingContext);
    protected virtual IChannelFactory`1<TChannel> BuildChannelFactoryCore(BindingContext context);
    public virtual T GetProperty(BindingContext context);
    public virtual BindingElement Clone();
}
internal static class System.ServiceModel.Channels.TransportSecurityHelpers : object {
    [AsyncStateMachineAttribute("System.ServiceModel.Channels.TransportSecurityHelpers/<GetSspiCredentialAsync>d__0")]
public static ValueTask`1<ValueTuple`3<NetworkCredential, TokenImpersonationLevel, AuthenticationLevel>> GetSspiCredentialAsync(SecurityTokenProviderContainer tokenProvider, TimeSpan timeout);
    [AsyncStateMachineAttribute("System.ServiceModel.Channels.TransportSecurityHelpers/<GetSspiCredentialCoreAsync>d__1")]
public static ValueTask`1<ValueTuple`4<NetworkCredential, bool, TokenImpersonationLevel, bool>> GetSspiCredentialCoreAsync(SspiSecurityTokenProvider tokenProvider, TimeSpan timeout);
    internal static SecurityTokenRequirement CreateSspiTokenRequirement(EndpointAddress target, Uri via, string transportScheme);
    public static SspiSecurityTokenProvider GetSspiTokenProvider(SecurityTokenManager tokenManager, EndpointAddress target, Uri via, string transportScheme, AuthenticationSchemes authenticationScheme, ChannelParameterCollection channelParameters);
    public static SecurityTokenProvider GetDigestTokenProvider(SecurityTokenManager tokenManager, EndpointAddress target, Uri via, string transportScheme, AuthenticationSchemes authenticationScheme, ChannelParameterCollection channelParameters);
    public static SecurityTokenProvider GetCertificateTokenProvider(SecurityTokenManager tokenManager, EndpointAddress target, Uri via, string transportScheme, ChannelParameterCollection channelParameters);
    [AsyncStateMachineAttribute("System.ServiceModel.Channels.TransportSecurityHelpers/<GetTokenAsync>d__6`1")]
private static Task`1<T> GetTokenAsync(SecurityTokenProvider tokenProvider, TimeSpan timeout);
    [AsyncStateMachineAttribute("System.ServiceModel.Channels.TransportSecurityHelpers/<GetUserNameCredentialAsync>d__7")]
public static Task`1<NetworkCredential> GetUserNameCredentialAsync(SecurityTokenProviderContainer tokenProvider, TimeSpan timeout);
    public static SecurityTokenProvider GetUserNameTokenProvider(SecurityTokenManager tokenManager, EndpointAddress target, Uri via, string transportScheme, AuthenticationSchemes authenticationScheme, ChannelParameterCollection channelParameters);
    private static InitiatorServiceModelSecurityTokenRequirement CreateUserNameTokenRequirement(EndpointAddress target, Uri via, string transportScheme);
}
internal abstract class System.ServiceModel.Channels.TypedFaultHelper`1 : FaultHelper {
    private InterruptibleWaitObject _closeHandle;
    private TimeSpan _defaultCloseTimeout;
    private TimeSpan _defaultSendTimeout;
    private Dictionary`2<IReliableChannelBinder, TState> _faultList;
    protected TypedFaultHelper`1(TimeSpan defaultSendTimeout, TimeSpan defaultCloseTimeout);
    public virtual void Abort();
    private void AbortBinder(IReliableChannelBinder binder);
    [AsyncStateMachineAttribute("System.ServiceModel.Channels.TypedFaultHelper`1/<AsyncCloseBinder>d__7")]
private Task AsyncCloseBinder(IReliableChannelBinder binder);
    protected abstract virtual void AbortState(TState state, bool isOnAbortThread);
    private void AfterClose();
    private bool BeforeClose();
    [AsyncStateMachineAttribute("System.ServiceModel.Channels.TypedFaultHelper`1/<CloseAsync>d__11")]
public virtual Task CloseAsync(TimeSpan timeout);
    protected abstract virtual Task SendFaultAsync(IReliableChannelBinder binder, TState state, TimeSpan timeout);
    protected abstract virtual TState GetState(RequestContext requestContext, Message faultMessage);
    protected void RemoveBinder(IReliableChannelBinder binder);
    [AsyncStateMachineAttribute("System.ServiceModel.Channels.TypedFaultHelper`1/<SendFaultAsync>d__15")]
protected Task SendFaultAsync(IReliableChannelBinder binder, TState state);
    [AsyncStateMachineAttribute("System.ServiceModel.Channels.TypedFaultHelper`1/<SendFaultAsync>d__16")]
public virtual Task SendFaultAsync(IReliableChannelBinder binder, RequestContext requestContext, Message faultMessage);
}
public class System.ServiceModel.Channels.UnderstoodHeaders : object {
    private MessageHeaders _messageHeaders;
    [CompilerGeneratedAttribute]
private bool <Modified>k__BackingField;
    internal bool Modified { get; internal set; }
    internal UnderstoodHeaders(MessageHeaders messageHeaders, bool modified);
    [CompilerGeneratedAttribute]
internal bool get_Modified();
    [CompilerGeneratedAttribute]
internal void set_Modified(bool value);
    public void Add(MessageHeaderInfo headerInfo);
    public bool Contains(MessageHeaderInfo headerInfo);
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
    public sealed virtual IEnumerator`1<MessageHeaderInfo> GetEnumerator();
    public void Remove(MessageHeaderInfo headerInfo);
}
internal class System.ServiceModel.Channels.UnknownSequenceFault : WsrmHeaderFault {
    public UnknownSequenceFault(UniqueId sequenceID);
    public UnknownSequenceFault(FaultCode code, FaultReason reason, XmlDictionaryReader detailReader, ReliableMessagingVersion reliableMessagingVersion);
    public virtual CommunicationException CreateException();
}
internal class System.ServiceModel.Channels.UnorderedDeliveryStrategy`1 : DeliveryStrategy`1<ItemType> {
    public int EnqueuedCount { get; }
    public UnorderedDeliveryStrategy`1(InputQueueChannel`1<ItemType> channel, int quota);
    public virtual int get_EnqueuedCount();
    public virtual bool CanEnqueue(long sequenceNumber);
    public virtual bool Enqueue(ItemType item, long sequenceNumber);
}
internal class System.ServiceModel.Channels.UriCache : object {
    private static int MaxKeyLength;
    private static int MaxEntries;
    private Entry[] _entries;
    private int _count;
    public Uri CreateUri(string uriString);
    private Uri Get(string key);
    private void Set(string key, Uri value);
}
internal class System.ServiceModel.Channels.UriEx : object {
    public static string UriSchemeHttp;
    public static string UriSchemeHttps;
    public static string UriSchemeNetTcp;
}
internal class System.ServiceModel.Channels.UriGenerator : object {
    private long _id;
    private string _prefix;
    public UriGenerator(string scheme);
    public UriGenerator(string scheme, string delimiter);
    public string Next();
}
internal class System.ServiceModel.Channels.Wsrm11Index : WsrmIndex {
    private static MessagePartSpecification s_signedReliabilityMessageParts;
    private ActionHeader _ackRequestedActionHeader;
    private AddressingVersion _addressingVersion;
    private ActionHeader _closeSequenceActionHeader;
    private ActionHeader _closeSequenceResponseActionHeader;
    private ActionHeader _createSequenceActionHeader;
    private ActionHeader _sequenceAcknowledgementActionHeader;
    private ActionHeader _terminateSequenceActionHeader;
    private ActionHeader _terminateSequenceResponseActionHeader;
    internal static MessagePartSpecification SignedReliabilityMessageParts { get; }
    internal Wsrm11Index(AddressingVersion addressingVersion);
    internal static MessagePartSpecification get_SignedReliabilityMessageParts();
    protected virtual ActionHeader GetActionHeader(string element);
}
internal class System.ServiceModel.Channels.WsrmAcknowledgmentHeader : WsrmMessageHeader {
    private int _bufferRemaining;
    private bool _final;
    private SequenceRangeCollection _ranges;
    private UniqueId _sequenceID;
    public XmlDictionaryString DictionaryName { get; }
    public WsrmAcknowledgmentHeader(ReliableMessagingVersion reliableMessagingVersion, UniqueId sequenceID, SequenceRangeCollection ranges, bool final, int bufferRemaining);
    public virtual XmlDictionaryString get_DictionaryName();
    protected virtual void OnWriteHeaderContents(XmlDictionaryWriter writer, MessageVersion messageVersion);
    internal static void WriteAckRanges(XmlDictionaryWriter writer, ReliableMessagingVersion reliableMessagingVersion, UniqueId sequenceId, SequenceRangeCollection ranges);
}
internal class System.ServiceModel.Channels.WsrmAcknowledgmentInfo : WsrmHeaderInfo {
    [CompilerGeneratedAttribute]
private int <BufferRemaining>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <Final>k__BackingField;
    [CompilerGeneratedAttribute]
private SequenceRangeCollection <Ranges>k__BackingField;
    [CompilerGeneratedAttribute]
private UniqueId <SequenceID>k__BackingField;
    public int BufferRemaining { get; }
    public bool Final { get; }
    public SequenceRangeCollection Ranges { get; }
    public UniqueId SequenceID { get; }
    private WsrmAcknowledgmentInfo(UniqueId sequenceID, SequenceRangeCollection ranges, bool final, int bufferRemaining, MessageHeaderInfo header);
    [CompilerGeneratedAttribute]
public int get_BufferRemaining();
    [CompilerGeneratedAttribute]
public bool get_Final();
    [CompilerGeneratedAttribute]
public SequenceRangeCollection get_Ranges();
    [CompilerGeneratedAttribute]
public UniqueId get_SequenceID();
    internal static void ReadAck(ReliableMessagingVersion reliableMessagingVersion, XmlDictionaryReader reader, UniqueId& sequenceId, SequenceRangeCollection& rangeCollection, Boolean& final);
    public static WsrmAcknowledgmentInfo ReadHeader(ReliableMessagingVersion reliableMessagingVersion, XmlDictionaryReader reader, MessageHeaderInfo header);
}
internal class System.ServiceModel.Channels.WsrmAckRequestedHeader : WsrmMessageHeader {
    private UniqueId sequenceID;
    public XmlDictionaryString DictionaryName { get; }
    public WsrmAckRequestedHeader(ReliableMessagingVersion reliableMessagingVersion, UniqueId sequenceID);
    public virtual XmlDictionaryString get_DictionaryName();
    protected virtual void OnWriteHeaderContents(XmlDictionaryWriter writer, MessageVersion messageVersion);
}
internal class System.ServiceModel.Channels.WsrmAckRequestedInfo : WsrmHeaderInfo {
    [CompilerGeneratedAttribute]
private UniqueId <SequenceID>k__BackingField;
    public UniqueId SequenceID { get; }
    public WsrmAckRequestedInfo(UniqueId sequenceID, MessageHeaderInfo header);
    [CompilerGeneratedAttribute]
public UniqueId get_SequenceID();
    public static WsrmAckRequestedInfo ReadHeader(ReliableMessagingVersion reliableMessagingVersion, XmlDictionaryReader reader, MessageHeaderInfo header);
}
internal abstract class System.ServiceModel.Channels.WsrmFault : MessageFault {
    private FaultCode code;
    private string exceptionMessage;
    private bool hasDetail;
    private bool isRemote;
    private FaultReason reason;
    private ReliableMessagingVersion reliableMessagingVersion;
    private string subcode;
    public FaultCode Code { get; }
    public bool HasDetail { get; }
    public bool IsRemote { get; }
    public FaultReason Reason { get; }
    public string Subcode { get; }
    protected WsrmFault(bool isSenderFault, string subcode, string faultReason, string exceptionMessage);
    protected WsrmFault(FaultCode code, string subcode, FaultReason reason);
    public virtual FaultCode get_Code();
    public virtual bool get_HasDetail();
    public bool get_IsRemote();
    public virtual FaultReason get_Reason();
    public string get_Subcode();
    public virtual CommunicationException CreateException();
    public static CommunicationException CreateException(WsrmFault fault);
    public Message CreateMessage(MessageVersion messageVersion, ReliableMessagingVersion reliableMessagingVersion);
    protected abstract virtual FaultCode Get11Code(FaultCode code, string subcode);
    protected abstract virtual bool Get12HasDetail();
    protected string GetExceptionMessage();
    protected ReliableMessagingVersion GetReliableMessagingVersion();
    protected abstract virtual void OnFaultMessageCreated(MessageVersion version, Message message);
    protected void SetReliableMessagingVersion(ReliableMessagingVersion reliableMessagingVersion);
    internal void WriteDetail(XmlDictionaryWriter writer);
}
internal class System.ServiceModel.Channels.WsrmFeb2005Index : WsrmIndex {
    private static MessagePartSpecification s_signedReliabilityMessageParts;
    private ActionHeader _ackRequestedActionHeader;
    private AddressingVersion _addressingVersion;
    private ActionHeader _createSequenceActionHeader;
    private ActionHeader _sequenceAcknowledgementActionHeader;
    private ActionHeader _terminateSequenceActionHeader;
    internal static MessagePartSpecification SignedReliabilityMessageParts { get; }
    internal WsrmFeb2005Index(AddressingVersion addressingVersion);
    internal static MessagePartSpecification get_SignedReliabilityMessageParts();
    protected virtual ActionHeader GetActionHeader(string element);
}
internal abstract class System.ServiceModel.Channels.WsrmHeaderFault : WsrmFault {
    private bool faultsInput;
    private bool faultsOutput;
    private UniqueId sequenceID;
    private string subcode;
    public bool FaultsInput { get; }
    public bool FaultsOutput { get; }
    public UniqueId SequenceID { get; protected set; }
    protected WsrmHeaderFault(bool isSenderFault, string subcode, string faultReason, string exceptionMessage, UniqueId sequenceID, bool faultsInput, bool faultsOutput);
    protected WsrmHeaderFault(FaultCode code, string subcode, FaultReason reason, XmlDictionaryReader detailReader, ReliableMessagingVersion reliableMessagingVersion, bool faultsInput, bool faultsOutput);
    protected WsrmHeaderFault(FaultCode code, string subcode, FaultReason reason, bool faultsInput, bool faultsOutput);
    public bool get_FaultsInput();
    public bool get_FaultsOutput();
    public UniqueId get_SequenceID();
    protected void set_SequenceID(UniqueId value);
    private static WsrmHeaderFault CreateWsrmHeaderFault(ReliableMessagingVersion reliableMessagingVersion, FaultCode code, string subcode, FaultReason reason, XmlDictionaryReader detailReader);
    protected virtual FaultCode Get11Code(FaultCode code, string subcode);
    protected virtual bool Get12HasDetail();
    private static void LookupDetailInformation(ReliableMessagingVersion reliableMessagingVersion, string subcode, String& detailName, String& detailNamespace);
    protected virtual void OnFaultMessageCreated(MessageVersion version, Message message);
    protected virtual void OnWriteDetailContents(XmlDictionaryWriter writer);
    private static UniqueId ParseDetail(XmlDictionaryReader reader, ReliableMessagingVersion reliableMessagingVersion);
    public static bool TryCreateFault11(ReliableMessagingVersion reliableMessagingVersion, Message message, MessageFault fault, int index, WsrmHeaderFault& wsrmFault);
    public static bool TryCreateFault12(ReliableMessagingVersion reliableMessagingVersion, Message message, MessageFault fault, WsrmHeaderFault& wsrmFault);
}
internal abstract class System.ServiceModel.Channels.WsrmHeaderInfo : object {
    [CompilerGeneratedAttribute]
private MessageHeaderInfo <MessageHeader>k__BackingField;
    public MessageHeaderInfo MessageHeader { get; }
    protected WsrmHeaderInfo(MessageHeaderInfo messageHeader);
    [CompilerGeneratedAttribute]
public MessageHeaderInfo get_MessageHeader();
}
internal abstract class System.ServiceModel.Channels.WsrmIndex : object {
    private static WsrmFeb2005Index s_wsAddressingAug2004WSReliableMessagingFeb2005;
    private static WsrmFeb2005Index s_wsAddressing10WSReliableMessagingFeb2005;
    private static Wsrm11Index s_wsAddressingAug2004WSReliableMessaging11;
    private static Wsrm11Index s_wsAddressing10WSReliableMessaging11;
    internal static ActionHeader GetAckRequestedActionHeader(AddressingVersion addressingVersion, ReliableMessagingVersion reliableMessagingVersion);
    protected abstract virtual ActionHeader GetActionHeader(string element);
    private static ActionHeader GetActionHeader(AddressingVersion addressingVersion, ReliableMessagingVersion reliableMessagingVersion, string element);
    internal static ActionHeader GetCloseSequenceActionHeader(AddressingVersion addressingVersion);
    internal static ActionHeader GetCloseSequenceResponseActionHeader(AddressingVersion addressingVersion);
    internal static ActionHeader GetCreateSequenceActionHeader(AddressingVersion addressingVersion, ReliableMessagingVersion reliableMessagingVersion);
    internal static string GetCreateSequenceActionString(ReliableMessagingVersion reliableMessagingVersion);
    internal static XmlDictionaryString GetCreateSequenceResponseAction(ReliableMessagingVersion reliableMessagingVersion);
    internal static string GetCreateSequenceResponseActionString(ReliableMessagingVersion reliableMessagingVersion);
    internal static string GetFaultActionString(AddressingVersion addressingVersion, ReliableMessagingVersion reliableMessagingVersion);
    internal static XmlDictionaryString GetNamespace(ReliableMessagingVersion reliableMessagingVersion);
    internal static string GetNamespaceString(ReliableMessagingVersion reliableMessagingVersion);
    internal static ActionHeader GetSequenceAcknowledgementActionHeader(AddressingVersion addressingVersion, ReliableMessagingVersion reliableMessagingVersion);
    internal static string GetSequenceAcknowledgementActionString(ReliableMessagingVersion reliableMessagingVersion);
    internal static MessagePartSpecification GetSignedReliabilityMessageParts(ReliableMessagingVersion reliableMessagingVersion);
    internal static ActionHeader GetTerminateSequenceActionHeader(AddressingVersion addressingVersion, ReliableMessagingVersion reliableMessagingVersion);
    internal static string GetTerminateSequenceActionString(ReliableMessagingVersion reliableMessagingVersion);
    internal static string GetTerminateSequenceResponseActionString(ReliableMessagingVersion reliableMessagingVersion);
    internal static ActionHeader GetTerminateSequenceResponseActionHeader(AddressingVersion addressingVersion);
}
internal abstract class System.ServiceModel.Channels.WsrmMessageHeader : DictionaryHeader {
    [CompilerGeneratedAttribute]
private ReliableMessagingVersion <ReliableMessagingVersion>k__BackingField;
    private XmlDictionaryString System.ServiceModel.Channels.IMessageHeaderWithSharedNamespace.SharedPrefix { get; }
    private XmlDictionaryString System.ServiceModel.Channels.IMessageHeaderWithSharedNamespace.SharedNamespace { get; }
    public XmlDictionaryString DictionaryNamespace { get; }
    public string Namespace { get; }
    protected ReliableMessagingVersion ReliableMessagingVersion { get; }
    protected WsrmMessageHeader(ReliableMessagingVersion reliableMessagingVersion);
    private sealed virtual override XmlDictionaryString System.ServiceModel.Channels.IMessageHeaderWithSharedNamespace.get_SharedPrefix();
    private sealed virtual override XmlDictionaryString System.ServiceModel.Channels.IMessageHeaderWithSharedNamespace.get_SharedNamespace();
    public virtual XmlDictionaryString get_DictionaryNamespace();
    public virtual string get_Namespace();
    [CompilerGeneratedAttribute]
protected ReliableMessagingVersion get_ReliableMessagingVersion();
}
internal class System.ServiceModel.Channels.WsrmMessageInfo : object {
    private Exception _faultException;
    private Message _faultReply;
    [CompilerGeneratedAttribute]
private WsrmAcknowledgmentInfo <AcknowledgementInfo>k__BackingField;
    [CompilerGeneratedAttribute]
private WsrmAckRequestedInfo <AckRequestedInfo>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Action>k__BackingField;
    [CompilerGeneratedAttribute]
private CloseSequenceInfo <CloseSequenceInfo>k__BackingField;
    [CompilerGeneratedAttribute]
private CloseSequenceResponseInfo <CloseSequenceResponseInfo>k__BackingField;
    [CompilerGeneratedAttribute]
private CreateSequenceInfo <CreateSequenceInfo>k__BackingField;
    [CompilerGeneratedAttribute]
private CreateSequenceResponseInfo <CreateSequenceResponseInfo>k__BackingField;
    [CompilerGeneratedAttribute]
private Message <Message>k__BackingField;
    [CompilerGeneratedAttribute]
private MessageFault <MessageFault>k__BackingField;
    [CompilerGeneratedAttribute]
private Exception <ParsingException>k__BackingField;
    [CompilerGeneratedAttribute]
private WsrmSequencedMessageInfo <SequencedMessageInfo>k__BackingField;
    [CompilerGeneratedAttribute]
private TerminateSequenceInfo <TerminateSequenceInfo>k__BackingField;
    [CompilerGeneratedAttribute]
private TerminateSequenceResponseInfo <TerminateSequenceResponseInfo>k__BackingField;
    [CompilerGeneratedAttribute]
private WsrmUsesSequenceSSLInfo <UsesSequenceSSLInfo>k__BackingField;
    [CompilerGeneratedAttribute]
private WsrmUsesSequenceSTRInfo <UsesSequenceSTRInfo>k__BackingField;
    public WsrmAcknowledgmentInfo AcknowledgementInfo { get; private set; }
    public WsrmAckRequestedInfo AckRequestedInfo { get; private set; }
    public string Action { get; private set; }
    public CloseSequenceInfo CloseSequenceInfo { get; private set; }
    public CloseSequenceResponseInfo CloseSequenceResponseInfo { get; private set; }
    public CreateSequenceInfo CreateSequenceInfo { get; private set; }
    public CreateSequenceResponseInfo CreateSequenceResponseInfo { get; private set; }
    public Exception FaultException { get; public set; }
    public MessageFault FaultInfo { get; }
    public Message FaultReply { get; public set; }
    public Message Message { get; private set; }
    public MessageFault MessageFault { get; private set; }
    public Exception ParsingException { get; private set; }
    public WsrmSequencedMessageInfo SequencedMessageInfo { get; private set; }
    public TerminateSequenceInfo TerminateSequenceInfo { get; private set; }
    public TerminateSequenceResponseInfo TerminateSequenceResponseInfo { get; private set; }
    public WsrmUsesSequenceSSLInfo UsesSequenceSSLInfo { get; private set; }
    public WsrmUsesSequenceSTRInfo UsesSequenceSTRInfo { get; private set; }
    public WsrmHeaderFault WsrmHeaderFault { get; }
    [CompilerGeneratedAttribute]
public WsrmAcknowledgmentInfo get_AcknowledgementInfo();
    [CompilerGeneratedAttribute]
private void set_AcknowledgementInfo(WsrmAcknowledgmentInfo value);
    [CompilerGeneratedAttribute]
public WsrmAckRequestedInfo get_AckRequestedInfo();
    [CompilerGeneratedAttribute]
private void set_AckRequestedInfo(WsrmAckRequestedInfo value);
    [CompilerGeneratedAttribute]
public string get_Action();
    [CompilerGeneratedAttribute]
private void set_Action(string value);
    [CompilerGeneratedAttribute]
public CloseSequenceInfo get_CloseSequenceInfo();
    [CompilerGeneratedAttribute]
private void set_CloseSequenceInfo(CloseSequenceInfo value);
    [CompilerGeneratedAttribute]
public CloseSequenceResponseInfo get_CloseSequenceResponseInfo();
    [CompilerGeneratedAttribute]
private void set_CloseSequenceResponseInfo(CloseSequenceResponseInfo value);
    [CompilerGeneratedAttribute]
public CreateSequenceInfo get_CreateSequenceInfo();
    [CompilerGeneratedAttribute]
private void set_CreateSequenceInfo(CreateSequenceInfo value);
    [CompilerGeneratedAttribute]
public CreateSequenceResponseInfo get_CreateSequenceResponseInfo();
    [CompilerGeneratedAttribute]
private void set_CreateSequenceResponseInfo(CreateSequenceResponseInfo value);
    public Exception get_FaultException();
    public void set_FaultException(Exception value);
    public MessageFault get_FaultInfo();
    public Message get_FaultReply();
    public void set_FaultReply(Message value);
    [CompilerGeneratedAttribute]
public Message get_Message();
    [CompilerGeneratedAttribute]
private void set_Message(Message value);
    [CompilerGeneratedAttribute]
public MessageFault get_MessageFault();
    [CompilerGeneratedAttribute]
private void set_MessageFault(MessageFault value);
    [CompilerGeneratedAttribute]
public Exception get_ParsingException();
    [CompilerGeneratedAttribute]
private void set_ParsingException(Exception value);
    [CompilerGeneratedAttribute]
public WsrmSequencedMessageInfo get_SequencedMessageInfo();
    [CompilerGeneratedAttribute]
private void set_SequencedMessageInfo(WsrmSequencedMessageInfo value);
    [CompilerGeneratedAttribute]
public TerminateSequenceInfo get_TerminateSequenceInfo();
    [CompilerGeneratedAttribute]
private void set_TerminateSequenceInfo(TerminateSequenceInfo value);
    [CompilerGeneratedAttribute]
public TerminateSequenceResponseInfo get_TerminateSequenceResponseInfo();
    [CompilerGeneratedAttribute]
private void set_TerminateSequenceResponseInfo(TerminateSequenceResponseInfo value);
    [CompilerGeneratedAttribute]
public WsrmUsesSequenceSSLInfo get_UsesSequenceSSLInfo();
    [CompilerGeneratedAttribute]
private void set_UsesSequenceSSLInfo(WsrmUsesSequenceSSLInfo value);
    [CompilerGeneratedAttribute]
public WsrmUsesSequenceSTRInfo get_UsesSequenceSTRInfo();
    [CompilerGeneratedAttribute]
private void set_UsesSequenceSTRInfo(WsrmUsesSequenceSTRInfo value);
    public WsrmHeaderFault get_WsrmHeaderFault();
    public static Exception CreateInternalFaultException(Message faultReply, string message, Exception inner);
    private static Exception CreateWsrmRequiredException(MessageVersion messageVersion);
    public static WsrmMessageInfo Get(MessageVersion messageVersion, ReliableMessagingVersion reliableMessagingVersion, IChannel channel, ISession session, Message message);
    public static WsrmMessageInfo Get(MessageVersion messageVersion, ReliableMessagingVersion reliableMessagingVersion, IChannel channel, ISession session, Message message, bool csrOnly);
    private static void ValidateMustUnderstand(MessageVersion version, Message message);
}
internal abstract class System.ServiceModel.Channels.WsrmRequestInfo : object {
    [CompilerGeneratedAttribute]
private UniqueId <MessageId>k__BackingField;
    [CompilerGeneratedAttribute]
private EndpointAddress <ReplyTo>k__BackingField;
    public UniqueId MessageId { get; private set; }
    public EndpointAddress ReplyTo { get; private set; }
    public string RequestName { get; }
    [CompilerGeneratedAttribute]
public UniqueId get_MessageId();
    [CompilerGeneratedAttribute]
private void set_MessageId(UniqueId value);
    [CompilerGeneratedAttribute]
public EndpointAddress get_ReplyTo();
    [CompilerGeneratedAttribute]
private void set_ReplyTo(EndpointAddress value);
    public abstract virtual string get_RequestName();
    protected void SetMessageId(MessageVersion messageVersion, MessageHeaders headers);
    protected void SetReplyTo(MessageVersion messageVersion, MessageHeaders headers);
}
internal class System.ServiceModel.Channels.WsrmRequiredFault : WsrmFault {
    public WsrmRequiredFault(string faultReason);
    protected virtual FaultCode Get11Code(FaultCode code, string subcode);
    protected virtual bool Get12HasDetail();
    protected virtual void OnFaultMessageCreated(MessageVersion version, Message message);
    protected virtual void OnWriteDetailContents(XmlDictionaryWriter writer);
}
internal class System.ServiceModel.Channels.WsrmSequencedMessageHeader : WsrmMessageHeader {
    private bool _lastMessage;
    private UniqueId _sequenceID;
    private long _sequenceNumber;
    public XmlDictionaryString DictionaryName { get; }
    public bool MustUnderstand { get; }
    public WsrmSequencedMessageHeader(ReliableMessagingVersion reliableMessagingVersion, UniqueId sequenceID, long sequenceNumber, bool lastMessage);
    public virtual XmlDictionaryString get_DictionaryName();
    public virtual bool get_MustUnderstand();
    protected virtual void OnWriteHeaderContents(XmlDictionaryWriter writer, MessageVersion messageVersion);
}
internal class System.ServiceModel.Channels.WsrmSequencedMessageInfo : WsrmHeaderInfo {
    [CompilerGeneratedAttribute]
private UniqueId <SequenceID>k__BackingField;
    [CompilerGeneratedAttribute]
private long <SequenceNumber>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <LastMessage>k__BackingField;
    public UniqueId SequenceID { get; }
    public long SequenceNumber { get; }
    public bool LastMessage { get; }
    private WsrmSequencedMessageInfo(UniqueId sequenceID, long sequenceNumber, bool lastMessage, MessageHeaderInfo header);
    [CompilerGeneratedAttribute]
public UniqueId get_SequenceID();
    [CompilerGeneratedAttribute]
public long get_SequenceNumber();
    [CompilerGeneratedAttribute]
public bool get_LastMessage();
    public static WsrmSequencedMessageInfo ReadHeader(ReliableMessagingVersion reliableMessagingVersion, XmlDictionaryReader reader, MessageHeaderInfo header);
}
internal class System.ServiceModel.Channels.WsrmSequenceFaultHeader : WsrmMessageHeader {
    [CompilerGeneratedAttribute]
private WsrmFault <Fault>k__BackingField;
    public WsrmFault Fault { get; }
    public XmlDictionaryString DictionaryName { get; }
    public string Subcode { get; }
    public WsrmSequenceFaultHeader(ReliableMessagingVersion reliableMessagingVersion, WsrmFault fault);
    [CompilerGeneratedAttribute]
public WsrmFault get_Fault();
    public virtual XmlDictionaryString get_DictionaryName();
    public string get_Subcode();
    public static XmlDictionaryReader GetReaderAtDetailContents(string detailName, string detailNamespace, XmlDictionaryReader headerReader, ReliableMessagingVersion reliableMessagingVersion);
    public static XmlDictionaryReader GetReaderAtDetailContents11(string detailName, string detailNamespace, XmlDictionaryReader headerReader);
    public static XmlDictionaryReader GetReaderAtDetailContentsFeb2005(string detailName, string detailNamespace, XmlDictionaryReader headerReader);
    public static string GetSubcode(XmlDictionaryReader headerReader, ReliableMessagingVersion reliableMessagingVersion);
    protected virtual void OnWriteHeaderContents(XmlDictionaryWriter writer, MessageVersion messageVersion);
}
internal class System.ServiceModel.Channels.WsrmUsesSequenceSSLInfo : WsrmHeaderInfo {
    private WsrmUsesSequenceSSLInfo(MessageHeaderInfo header);
    public static WsrmUsesSequenceSSLInfo ReadHeader(XmlDictionaryReader reader, MessageHeaderInfo header);
}
internal class System.ServiceModel.Channels.WsrmUsesSequenceSTRHeader : WsrmMessageHeader {
    public XmlDictionaryString DictionaryName { get; }
    public bool MustUnderstand { get; }
    public virtual XmlDictionaryString get_DictionaryName();
    protected virtual void OnWriteHeaderContents(XmlDictionaryWriter writer, MessageVersion messageVersion);
    public virtual bool get_MustUnderstand();
}
internal class System.ServiceModel.Channels.WsrmUsesSequenceSTRInfo : WsrmHeaderInfo {
    private WsrmUsesSequenceSTRInfo(MessageHeaderInfo header);
    public static WsrmUsesSequenceSTRInfo ReadHeader(XmlDictionaryReader reader, MessageHeaderInfo header);
}
internal static class System.ServiceModel.Channels.WsrmUtilities : object {
    public static TimeSpan CalculateKeepAliveInterval(TimeSpan inactivityTimeout, int maxRetryCount);
    internal static UniqueId NextSequenceId();
    internal static void AddAcknowledgementHeader(ReliableMessagingVersion reliableMessagingVersion, Message message, UniqueId id, SequenceRangeCollection ranges, bool final);
    internal static void AddAcknowledgementHeader(ReliableMessagingVersion reliableMessagingVersion, Message message, UniqueId id, SequenceRangeCollection ranges, bool final, int bufferRemaining);
    internal static void AddAckRequestedHeader(ReliableMessagingVersion reliableMessagingVersion, Message message, UniqueId id);
    internal static void AddSequenceHeader(ReliableMessagingVersion reliableMessagingVersion, Message message, UniqueId id, long sequenceNumber, bool isLast);
    internal static void AssertWsrm11(ReliableMessagingVersion reliableMessagingVersion);
    internal static Message CreateAcknowledgmentMessage(MessageVersion version, ReliableMessagingVersion reliableMessagingVersion, UniqueId id, SequenceRangeCollection ranges, bool final, int bufferRemaining);
    internal static Message CreateAckRequestedMessage(MessageVersion messageVersion, ReliableMessagingVersion reliableMessagingVersion, UniqueId id);
    internal static Message CreateCloseSequenceResponse(MessageVersion messageVersion, UniqueId messageId, UniqueId inputId);
    internal static Message CreateCreateSequenceResponse(MessageVersion messageVersion, ReliableMessagingVersion reliableMessagingVersion, bool duplex, CreateSequenceInfo createSequenceInfo, bool ordered, UniqueId inputId, EndpointAddress acceptAcksTo);
    internal static Message CreateCSRefusedCommunicationFault(MessageVersion messageVersion, ReliableMessagingVersion reliableMessagingVersion, string reason);
    internal static Message CreateCSRefusedProtocolFault(MessageVersion messageVersion, ReliableMessagingVersion reliableMessagingVersion, string reason);
    internal static Message CreateCSRefusedServerTooBusyFault(MessageVersion messageVersion, ReliableMessagingVersion reliableMessagingVersion, string reason);
    private static Message CreateCSRefusedFault(MessageVersion messageVersion, ReliableMessagingVersion reliableMessagingVersion, bool isSenderFault, FaultCode subCode, string reason);
    public static Exception CreateCSFaultException(MessageVersion version, ReliableMessagingVersion reliableMessagingVersion, Message message, IChannel innerChannel);
    internal static Message CreateEndpointNotFoundFault(MessageVersion version, string reason);
    internal static Message CreateTerminateMessage(MessageVersion version, ReliableMessagingVersion reliableMessagingVersion, UniqueId id);
    internal static Message CreateTerminateMessage(MessageVersion version, ReliableMessagingVersion reliableMessagingVersion, UniqueId id, long last);
    internal static Message CreateTerminateResponseMessage(MessageVersion version, UniqueId messageId, UniqueId sequenceId);
    internal static UniqueId GetInputId(WsrmMessageInfo info);
    internal static UniqueId GetOutputId(ReliableMessagingVersion reliableMessagingVersion, WsrmMessageInfo info);
    internal static bool IsWsrmAction(ReliableMessagingVersion reliableMessagingVersion, string action);
    public static void ReadEmptyElement(XmlDictionaryReader reader);
    public static UniqueId ReadIdentifier(XmlDictionaryReader reader, ReliableMessagingVersion reliableMessagingVersion);
    public static long ReadSequenceNumber(XmlDictionaryReader reader);
    public static long ReadSequenceNumber(XmlDictionaryReader reader, bool allowZero);
    public static WsrmFault ValidateCloseSequenceResponse(ChannelReliableSession session, UniqueId messageId, WsrmMessageInfo info, long last);
    public static WsrmFault ValidateFinalAck(ChannelReliableSession session, WsrmMessageInfo info, long last);
    public static WsrmFault ValidateFinalAckExists(ChannelReliableSession session, WsrmAcknowledgmentInfo ackInfo);
    public static WsrmFault ValidateTerminateSequenceResponse(ChannelReliableSession session, UniqueId messageId, WsrmMessageInfo info, long last);
    public static bool ValidateWsrmRequest(ChannelReliableSession session, WsrmRequestInfo info, IReliableChannelBinder binder, RequestContext context);
    public static void WriteIdentifier(XmlDictionaryWriter writer, ReliableMessagingVersion reliableMessagingVersion, UniqueId sequenceId);
}
internal class System.ServiceModel.Channels.XmlAttributeHolder : ValueType {
    private string _value;
    public static XmlAttributeHolder[] emptyArray;
    [CompilerGeneratedAttribute]
private string <Prefix>k__BackingField;
    [CompilerGeneratedAttribute]
private string <NamespaceUri>k__BackingField;
    [CompilerGeneratedAttribute]
private string <LocalName>k__BackingField;
    public string Prefix { get; }
    public string NamespaceUri { get; }
    public string LocalName { get; }
    public string Value { get; }
    public XmlAttributeHolder(string prefix, string localName, string ns, string value);
    private static XmlAttributeHolder();
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public string get_Prefix();
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public string get_NamespaceUri();
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public string get_LocalName();
    public string get_Value();
    public void WriteTo(XmlWriter writer);
    public static void WriteAttributes(XmlAttributeHolder[] attributes, XmlWriter writer);
    public static XmlAttributeHolder[] ReadAttributes(XmlDictionaryReader reader);
    public static XmlAttributeHolder[] ReadAttributes(XmlDictionaryReader reader, Int32& maxSizeOfHeaders);
    private static void Deduct(string s, Int32& maxSizeOfHeaders);
    public static string GetAttribute(XmlAttributeHolder[] attributes, string localName, string ns);
}
internal class System.ServiceModel.Channels.XmlObjectSerializerBodyWriter : BodyWriter {
    private object _body;
    private XmlObjectSerializer _serializer;
    private object ThisLock { get; }
    public XmlObjectSerializerBodyWriter(object body, XmlObjectSerializer serializer);
    private object get_ThisLock();
    protected virtual void OnWriteBodyContents(XmlDictionaryWriter writer);
}
public class System.ServiceModel.Channels.XmlObjectSerializerFault : MessageFault {
    private FaultCode _code;
    private FaultReason _reason;
    private string _actor;
    private string _node;
    private object _detail;
    private XmlObjectSerializer _serializer;
    public string Actor { get; }
    public FaultCode Code { get; }
    public bool HasDetail { get; }
    public string Node { get; }
    public FaultReason Reason { get; }
    private object ThisLock { get; }
    public XmlObjectSerializerFault(FaultCode code, FaultReason reason, object detail, XmlObjectSerializer serializer, string actor, string node);
    public virtual string get_Actor();
    public virtual FaultCode get_Code();
    public virtual bool get_HasDetail();
    public virtual string get_Node();
    public virtual FaultReason get_Reason();
    private object get_ThisLock();
    protected virtual void OnWriteDetailContents(XmlDictionaryWriter writer);
}
internal class System.ServiceModel.Channels.XmlObjectSerializerHeader : MessageHeader {
    private XmlObjectSerializer _serializer;
    private bool _mustUnderstand;
    private bool _relay;
    private bool _isOneTwoSupported;
    private bool _isOneOneSupported;
    private bool _isNoneSupported;
    private object _objectToSerialize;
    private string _name;
    private string _ns;
    private string _actor;
    private object _syncRoot;
    public string Name { get; }
    public string Namespace { get; }
    public bool MustUnderstand { get; }
    public bool Relay { get; }
    public string Actor { get; }
    private XmlObjectSerializerHeader(XmlObjectSerializer serializer, bool mustUnderstand, string actor, bool relay);
    public XmlObjectSerializerHeader(string name, string ns, object objectToSerialize, XmlObjectSerializer serializer, bool mustUnderstand, string actor, bool relay);
    public virtual bool IsMessageVersionSupported(MessageVersion messageVersion);
    public virtual string get_Name();
    public virtual string get_Namespace();
    public virtual bool get_MustUnderstand();
    public virtual bool get_Relay();
    public virtual string get_Actor();
    protected virtual void OnWriteHeaderContents(XmlDictionaryWriter writer, MessageVersion messageVersion);
}
internal class System.ServiceModel.Channels.XmlReaderBodyWriter : BodyWriter {
    private XmlDictionaryReader _reader;
    private bool _isFault;
    internal bool IsFault { get; }
    public XmlReaderBodyWriter(XmlDictionaryReader reader, EnvelopeVersion version);
    internal virtual bool get_IsFault();
    protected virtual BodyWriter OnCreateBufferedCopy(int maxBufferSize);
    protected virtual void OnWriteBodyContents(XmlDictionaryWriter writer);
}
public class System.ServiceModel.ChannelTerminatedException : CommunicationException {
    public ChannelTerminatedException(string message);
    public ChannelTerminatedException(string message, Exception innerException);
    protected ChannelTerminatedException(SerializationInfo info, StreamingContext context);
}
public abstract class System.ServiceModel.ClientBase`1 : object {
    private TChannel _channel;
    private ChannelFactoryRef`1<TChannel> _channelFactoryRef;
    private EndpointTrait`1<TChannel> _endpointTrait;
    private bool _canShareFactory;
    private bool _useCachedFactory;
    private bool _sharingFinalized;
    private bool _channelFactoryRefReleased;
    private bool _releasedLastRef;
    private object finalizeLock;
    private static int MaxNumChannelFactories;
    private static ChannelFactoryRefCache`1<TChannel> s_factoryRefCache;
    private static object s_staticLock;
    private static object s_cacheLock;
    private static CacheSetting s_cacheSetting;
    private static bool s_isCacheSettingReadOnly;
    private static AsyncCallback s_onAsyncCallCompleted;
    [CompilerGeneratedAttribute]
private object <ThisLock>k__BackingField;
    private object ThisLock { get; }
    protected TChannel Channel { get; }
    public static CacheSetting CacheSetting { get; public set; }
    public ChannelFactory`1<TChannel> ChannelFactory { get; }
    public ClientCredentials ClientCredentials { get; }
    public CommunicationState State { get; }
    public IClientChannel InnerChannel { get; }
    public ServiceEndpoint Endpoint { get; }
    protected ClientBase`1(Binding binding, EndpointAddress remoteAddress);
    protected ClientBase`1(ServiceEndpoint endpoint);
    protected ClientBase`1(InstanceContext callbackInstance, Binding binding, EndpointAddress remoteAddress);
    private static ClientBase`1();
    protected T GetDefaultValueForInitialization();
    [CompilerGeneratedAttribute]
private object get_ThisLock();
    protected TChannel get_Channel();
    public static CacheSetting get_CacheSetting();
    public static void set_CacheSetting(CacheSetting value);
    public ChannelFactory`1<TChannel> get_ChannelFactory();
    public ClientCredentials get_ClientCredentials();
    public sealed virtual CommunicationState get_State();
    public IClientChannel get_InnerChannel();
    public ServiceEndpoint get_Endpoint();
    public sealed virtual void Open();
    public Task OpenAsync();
    [AsyncStateMachineAttribute("System.ServiceModel.ClientBase`1/<OpenAsync>d__41")]
private Task OpenAsync(TimeSpan timeout);
    public sealed virtual void Abort();
    public sealed virtual void Close();
    public Task CloseAsync();
    [AsyncStateMachineAttribute("System.ServiceModel.ClientBase`1/<CloseAsync>d__45")]
private Task CloseAsync(TimeSpan timeout);
    private void MakeCacheSettingReadOnly();
    private void CreateChannelInternal();
    protected virtual TChannel CreateChannel();
    private sealed virtual override void System.IDisposable.Dispose();
    [AsyncStateMachineAttribute("System.ServiceModel.ClientBase`1/<System-IAsyncDisposable-DisposeAsync>d__50")]
private sealed virtual override ValueTask System.IAsyncDisposable.DisposeAsync();
    private sealed virtual override void System.ServiceModel.ICommunicationObject.Open(TimeSpan timeout);
    private sealed virtual override void System.ServiceModel.ICommunicationObject.Close(TimeSpan timeout);
    private sealed virtual override void System.ServiceModel.ICommunicationObject.add_Closed(EventHandler value);
    private sealed virtual override void System.ServiceModel.ICommunicationObject.remove_Closed(EventHandler value);
    private sealed virtual override void System.ServiceModel.ICommunicationObject.add_Closing(EventHandler value);
    private sealed virtual override void System.ServiceModel.ICommunicationObject.remove_Closing(EventHandler value);
    private sealed virtual override void System.ServiceModel.ICommunicationObject.add_Faulted(EventHandler value);
    private sealed virtual override void System.ServiceModel.ICommunicationObject.remove_Faulted(EventHandler value);
    private sealed virtual override void System.ServiceModel.ICommunicationObject.add_Opened(EventHandler value);
    private sealed virtual override void System.ServiceModel.ICommunicationObject.remove_Opened(EventHandler value);
    private sealed virtual override void System.ServiceModel.ICommunicationObject.add_Opening(EventHandler value);
    private sealed virtual override void System.ServiceModel.ICommunicationObject.remove_Opening(EventHandler value);
    private sealed virtual override IAsyncResult System.ServiceModel.ICommunicationObject.BeginClose(AsyncCallback callback, object state);
    private sealed virtual override IAsyncResult System.ServiceModel.ICommunicationObject.BeginClose(TimeSpan timeout, AsyncCallback callback, object state);
    private sealed virtual override void System.ServiceModel.ICommunicationObject.EndClose(IAsyncResult result);
    private sealed virtual override IAsyncResult System.ServiceModel.ICommunicationObject.BeginOpen(AsyncCallback callback, object state);
    private sealed virtual override IAsyncResult System.ServiceModel.ICommunicationObject.BeginOpen(TimeSpan timeout, AsyncCallback callback, object state);
    private sealed virtual override void System.ServiceModel.ICommunicationObject.EndOpen(IAsyncResult result);
    private ChannelFactory`1<TChannel> GetChannelFactory();
    private void InitializeChannelFactoryRef();
    private static ChannelFactoryRef`1<TChannel> CreateChannelFactoryRef(EndpointTrait`1<TChannel> endpointTrait);
    private void TryDisableSharing();
    private void TryAddChannelFactoryToCache();
    private void InvalidateCacheAndCreateChannel();
    private void RemoveFactoryFromCache();
    protected void InvokeAsync(BeginOperationDelegate<TChannel> beginOperationDelegate, Object[] inValues, EndOperationDelegate<TChannel> endOperationDelegate, SendOrPostCallback operationCompletedCallback, object userState);
    private static void OnAsyncCallCompleted(IAsyncResult result);
    private static void CompleteAsyncCall(AsyncOperationContext<TChannel> context, Object[] results, Exception error);
}
public class System.ServiceModel.ClientCredentialsSecurityTokenManager : SecurityTokenManager {
    [CompilerGeneratedAttribute]
private ClientCredentials <ClientCredentials>k__BackingField;
    public ClientCredentials ClientCredentials { get; }
    public ClientCredentialsSecurityTokenManager(ClientCredentials clientCredentials);
    [CompilerGeneratedAttribute]
public ClientCredentials get_ClientCredentials();
    private string GetServicePrincipalName(InitiatorServiceModelSecurityTokenRequirement initiatorRequirement);
    private bool IsDigestAuthenticationScheme(SecurityTokenRequirement requirement);
    protected internal bool IsIssuedSecurityTokenRequirement(SecurityTokenRequirement requirement);
    public virtual SecurityTokenProvider CreateSecurityTokenProvider(SecurityTokenRequirement tokenRequirement);
    public virtual SecurityTokenSerializer CreateSecurityTokenSerializer(SecurityTokenVersion version);
    private SecurityTokenProvider CreateSecureConversationSecurityTokenProvider(InitiatorServiceModelSecurityTokenRequirement initiatorRequirement);
    private X509SecurityTokenAuthenticator CreateServerX509TokenAuthenticator();
    private X509SecurityTokenAuthenticator CreateServerSslX509TokenAuthenticator();
    public virtual SecurityTokenAuthenticator CreateSecurityTokenAuthenticator(SecurityTokenRequirement tokenRequirement, SecurityTokenResolver& outOfBandTokenResolver);
}
internal class System.ServiceModel.CloseCollectionAsyncResult : AsyncResult {
    private bool _completedSynchronously;
    private Exception _exception;
    private static AsyncCallback s_nestedCallback;
    private int _count;
    public CloseCollectionAsyncResult(TimeSpan timeout, AsyncCallback otherCallback, object state, IList`1<ICommunicationObject> collection);
    private static CloseCollectionAsyncResult();
    private void CompleteClose(ICommunicationObject communicationObject, IAsyncResult result);
    private static void Callback(IAsyncResult result);
    private void Decrement(bool completedSynchronously);
    private void Decrement(bool completedSynchronously, Exception exception);
    public static void End(IAsyncResult result);
}
public class System.ServiceModel.CommunicationException : Exception {
    public CommunicationException(string message);
    public CommunicationException(string message, Exception innerException);
    protected CommunicationException(SerializationInfo info, StreamingContext context);
}
public class System.ServiceModel.CommunicationObjectAbortedException : CommunicationException {
    public CommunicationObjectAbortedException(string message);
    public CommunicationObjectAbortedException(string message, Exception innerException);
    protected CommunicationObjectAbortedException(SerializationInfo info, StreamingContext context);
}
public class System.ServiceModel.CommunicationObjectFaultedException : CommunicationException {
    public CommunicationObjectFaultedException(string message);
    public CommunicationObjectFaultedException(string message, Exception innerException);
    protected CommunicationObjectFaultedException(SerializationInfo info, StreamingContext context);
}
public enum System.ServiceModel.CommunicationState : Enum {
    public int value__;
    public static CommunicationState Created;
    public static CommunicationState Opening;
    public static CommunicationState Opened;
    public static CommunicationState Closing;
    public static CommunicationState Closed;
    public static CommunicationState Faulted;
}
public enum System.ServiceModel.ConcurrencyMode : Enum {
    public int value__;
    public static ConcurrencyMode Single;
    public static ConcurrencyMode Reentrant;
    public static ConcurrencyMode Multiple;
}
public static class System.ServiceModel.ConcurrencyModeHelper : object {
    public static bool IsDefined(ConcurrencyMode x);
}
internal static class System.ServiceModel.CoordinationExternal10Strings : object {
    public static string Namespace;
    public static string CreateCoordinationContextAction;
    public static string CreateCoordinationContextResponseAction;
    public static string RegisterAction;
    public static string RegisterResponseAction;
    public static string FaultAction;
}
internal class System.ServiceModel.CoordinationExternal11Dictionary : object {
    public XmlDictionaryString Namespace;
    public XmlDictionaryString CreateCoordinationContextAction;
    public XmlDictionaryString CreateCoordinationContextResponseAction;
    public XmlDictionaryString RegisterAction;
    public XmlDictionaryString RegisterResponseAction;
    public XmlDictionaryString FaultAction;
    public XmlDictionaryString CannotCreateContext;
    public XmlDictionaryString CannotRegisterParticipant;
    public CoordinationExternal11Dictionary(XmlDictionary dictionary);
}
internal static class System.ServiceModel.CoordinationExternal11Strings : object {
    public static string Namespace;
    public static string CreateCoordinationContextAction;
    public static string CreateCoordinationContextResponseAction;
    public static string RegisterAction;
    public static string RegisterResponseAction;
    public static string FaultAction;
    public static string CannotCreateContext;
    public static string CannotRegisterParticipant;
}
internal static class System.ServiceModel.CoordinationExternalStrings : object {
    public static string Prefix;
    public static string CreateCoordinationContext;
    public static string CreateCoordinationContextResponse;
    public static string CoordinationContext;
    public static string CurrentContext;
    public static string CoordinationType;
    public static string RegistrationService;
    public static string Register;
    public static string RegisterResponse;
    public static string Protocol;
    public static string CoordinatorProtocolService;
    public static string ParticipantProtocolService;
    public static string Expires;
    public static string Identifier;
    public static string ActivationCoordinatorPortType;
    public static string RegistrationCoordinatorPortType;
    public static string InvalidState;
    public static string InvalidProtocol;
    public static string InvalidParameters;
    public static string NoActivity;
    public static string ContextRefused;
    public static string AlreadyRegistered;
}
[AttributeUsageAttribute("1092")]
public class System.ServiceModel.DataContractFormatAttribute : Attribute {
    private OperationFormatStyle _style;
    public OperationFormatStyle Style { get; public set; }
    public OperationFormatStyle get_Style();
    public void set_Style(OperationFormatStyle value);
}
[AttributeUsageAttribute("1028")]
public class System.ServiceModel.DeliveryRequirementsAttribute : Attribute {
    private QueuedDeliveryRequirementsMode queuedDeliveryRequirements;
    [CompilerGeneratedAttribute]
private bool <RequireOrderedDelivery>k__BackingField;
    public QueuedDeliveryRequirementsMode QueuedDeliveryRequirements { get; public set; }
    public bool RequireOrderedDelivery { get; public set; }
    public QueuedDeliveryRequirementsMode get_QueuedDeliveryRequirements();
    public void set_QueuedDeliveryRequirements(QueuedDeliveryRequirementsMode value);
    [CompilerGeneratedAttribute]
public bool get_RequireOrderedDelivery();
    [CompilerGeneratedAttribute]
public void set_RequireOrderedDelivery(bool value);
    private sealed virtual override void System.ServiceModel.Description.IContractBehavior.Validate(ContractDescription description, ServiceEndpoint endpoint);
    private sealed virtual override void System.ServiceModel.Description.IContractBehavior.AddBindingParameters(ContractDescription description, ServiceEndpoint endpoint, BindingParameterCollection parameters);
    private sealed virtual override void System.ServiceModel.Description.IContractBehavior.ApplyClientBehavior(ContractDescription description, ServiceEndpoint endpoint, ClientRuntime proxy);
    private sealed virtual override void System.ServiceModel.Description.IContractBehavior.ApplyDispatchBehavior(ContractDescription description, ServiceEndpoint endpoint, DispatchRuntime dispatch);
    private void ValidateEndpoint(ServiceEndpoint endpoint);
    private void EnsureQueuedDeliveryRequirements(string name, Binding binding);
    private void EnsureOrderedDeliveryRequirements(string name, Binding binding);
}
public class System.ServiceModel.Description.CallbackDebugBehavior : object {
    [CompilerGeneratedAttribute]
private bool <IncludeExceptionDetailInFaults>k__BackingField;
    public bool IncludeExceptionDetailInFaults { get; public set; }
    public CallbackDebugBehavior(bool includeExceptionDetailInFaults);
    [CompilerGeneratedAttribute]
public bool get_IncludeExceptionDetailInFaults();
    [CompilerGeneratedAttribute]
public void set_IncludeExceptionDetailInFaults(bool value);
    private sealed virtual override void System.ServiceModel.Description.IEndpointBehavior.Validate(ServiceEndpoint serviceEndpoint);
    private sealed virtual override void System.ServiceModel.Description.IEndpointBehavior.AddBindingParameters(ServiceEndpoint serviceEndpoint, BindingParameterCollection bindingParameters);
    private sealed virtual override void System.ServiceModel.Description.IEndpointBehavior.ApplyDispatchBehavior(ServiceEndpoint serviceEndpoint, EndpointDispatcher endpointDispatcher);
    private sealed virtual override void System.ServiceModel.Description.IEndpointBehavior.ApplyClientBehavior(ServiceEndpoint serviceEndpoint, ClientRuntime behavior);
}
public class System.ServiceModel.Description.ClientCredentials : SecurityCredentialsManager {
    private UserNamePasswordClientCredential _userName;
    private X509CertificateInitiatorClientCredential _clientCertificate;
    private X509CertificateRecipientClientCredential _serviceCertificate;
    private WindowsClientCredential _windows;
    private HttpDigestClientCredential _httpDigest;
    private bool _isReadOnly;
    public UserNamePasswordClientCredential UserName { get; }
    public X509CertificateInitiatorClientCredential ClientCertificate { get; }
    public X509CertificateRecipientClientCredential ServiceCertificate { get; }
    public WindowsClientCredential Windows { get; }
    public HttpDigestClientCredential HttpDigest { get; }
    protected ClientCredentials(ClientCredentials other);
    public UserNamePasswordClientCredential get_UserName();
    public X509CertificateInitiatorClientCredential get_ClientCertificate();
    public X509CertificateRecipientClientCredential get_ServiceCertificate();
    public WindowsClientCredential get_Windows();
    public HttpDigestClientCredential get_HttpDigest();
    internal static ClientCredentials CreateDefaultCredentials();
    public virtual SecurityTokenManager CreateSecurityTokenManager();
    protected virtual ClientCredentials CloneCore();
    public ClientCredentials Clone();
    private sealed virtual override void System.ServiceModel.Description.IEndpointBehavior.Validate(ServiceEndpoint serviceEndpoint);
    private sealed virtual override void System.ServiceModel.Description.IEndpointBehavior.AddBindingParameters(ServiceEndpoint serviceEndpoint, BindingParameterCollection bindingParameters);
    private sealed virtual override void System.ServiceModel.Description.IEndpointBehavior.ApplyDispatchBehavior(ServiceEndpoint serviceEndpoint, EndpointDispatcher endpointDispatcher);
    public virtual void ApplyClientBehavior(ServiceEndpoint serviceEndpoint, ClientRuntime behavior);
    internal void MakeReadOnly();
}
[DebuggerDisplayAttribute("Name={_name}, Namespace={_ns}, ContractType={ContractType}")]
public class System.ServiceModel.Description.ContractDescription : object {
    private XmlName _name;
    private string _ns;
    private SessionMode _sessionMode;
    private ProtectionLevel _protectionLevel;
    [CompilerGeneratedAttribute]
private string <ConfigurationName>k__BackingField;
    [CompilerGeneratedAttribute]
private Type <ContractType>k__BackingField;
    [CompilerGeneratedAttribute]
private Type <CallbackContractType>k__BackingField;
    [CompilerGeneratedAttribute]
private OperationDescriptionCollection <Operations>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <HasProtectionLevel>k__BackingField;
    [CompilerGeneratedAttribute]
private KeyedByTypeCollection`1<IContractBehavior> <Behaviors>k__BackingField;
    internal string CodeName { get; }
    [DefaultValueAttribute("")]
public string ConfigurationName { get; public set; }
    public Type ContractType { get; public set; }
    public Type CallbackContractType { get; public set; }
    public string Name { get; public set; }
    public string Namespace { get; public set; }
    public OperationDescriptionCollection Operations { get; }
    public ProtectionLevel ProtectionLevel { get; public set; }
    public bool HasProtectionLevel { get; private set; }
    [DefaultValueAttribute("Mono.Cecil.CustomAttributeArgument")]
public SessionMode SessionMode { get; public set; }
    public KeyedCollection`2<Type, IContractBehavior> ContractBehaviors { get; }
    [EditorBrowsableAttribute("1")]
public KeyedByTypeCollection`1<IContractBehavior> Behaviors { get; }
    public ContractDescription(string name);
    public ContractDescription(string name, string ns);
    internal string get_CodeName();
    [CompilerGeneratedAttribute]
public string get_ConfigurationName();
    [CompilerGeneratedAttribute]
public void set_ConfigurationName(string value);
    [CompilerGeneratedAttribute]
public Type get_ContractType();
    [CompilerGeneratedAttribute]
public void set_ContractType(Type value);
    [CompilerGeneratedAttribute]
public Type get_CallbackContractType();
    [CompilerGeneratedAttribute]
public void set_CallbackContractType(Type value);
    public string get_Name();
    public void set_Name(string value);
    public string get_Namespace();
    public void set_Namespace(string value);
    [CompilerGeneratedAttribute]
public OperationDescriptionCollection get_Operations();
    public ProtectionLevel get_ProtectionLevel();
    public void set_ProtectionLevel(ProtectionLevel value);
    public bool ShouldSerializeProtectionLevel();
    [CompilerGeneratedAttribute]
public bool get_HasProtectionLevel();
    [CompilerGeneratedAttribute]
private void set_HasProtectionLevel(bool value);
    public SessionMode get_SessionMode();
    public void set_SessionMode(SessionMode value);
    public KeyedCollection`2<Type, IContractBehavior> get_ContractBehaviors();
    [CompilerGeneratedAttribute]
public KeyedByTypeCollection`1<IContractBehavior> get_Behaviors();
    public static ContractDescription GetContract(Type contractType);
    public static ContractDescription GetContract(Type contractType, Type serviceType);
    public static ContractDescription GetContract(Type contractType, object serviceImplementation);
    public Collection`1<ContractDescription> GetInheritedContracts();
    internal void EnsureInvariants();
    internal bool IsDuplex();
}
public class System.ServiceModel.Description.DataContractSerializerOperationBehavior : object {
    private OperationDescription _operation;
    internal bool ignoreExtensionDataObject;
    internal int maxItemsInObjectGraph;
    private DataContractResolver _dataContractResolver;
    [CompilerGeneratedAttribute]
private DataContractFormatAttribute <DataContractFormatAttribute>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsBuiltInOperationBehavior>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <MaxItemsInObjectGraphSetExplicit>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IgnoreExtensionDataObjectSetExplicit>k__BackingField;
    [CompilerGeneratedAttribute]
private ISerializationSurrogateProvider <SerializationSurrogateProvider>k__BackingField;
    public DataContractFormatAttribute DataContractFormatAttribute { get; }
    internal bool IsBuiltInOperationBehavior { get; }
    public int MaxItemsInObjectGraph { get; public set; }
    internal bool MaxItemsInObjectGraphSetExplicit { get; internal set; }
    public bool IgnoreExtensionDataObject { get; public set; }
    internal bool IgnoreExtensionDataObjectSetExplicit { get; internal set; }
    public ISerializationSurrogateProvider SerializationSurrogateProvider { get; public set; }
    public DataContractResolver DataContractResolver { get; public set; }
    public DataContractSerializerOperationBehavior(OperationDescription operation);
    public DataContractSerializerOperationBehavior(OperationDescription operation, DataContractFormatAttribute dataContractFormatAttribute);
    internal DataContractSerializerOperationBehavior(OperationDescription operation, DataContractFormatAttribute dataContractFormatAttribute, bool builtInOperationBehavior);
    [CompilerGeneratedAttribute]
public DataContractFormatAttribute get_DataContractFormatAttribute();
    [CompilerGeneratedAttribute]
internal bool get_IsBuiltInOperationBehavior();
    public int get_MaxItemsInObjectGraph();
    public void set_MaxItemsInObjectGraph(int value);
    [CompilerGeneratedAttribute]
internal bool get_MaxItemsInObjectGraphSetExplicit();
    [CompilerGeneratedAttribute]
internal void set_MaxItemsInObjectGraphSetExplicit(bool value);
    public bool get_IgnoreExtensionDataObject();
    public void set_IgnoreExtensionDataObject(bool value);
    [CompilerGeneratedAttribute]
internal bool get_IgnoreExtensionDataObjectSetExplicit();
    [CompilerGeneratedAttribute]
internal void set_IgnoreExtensionDataObjectSetExplicit(bool value);
    [CompilerGeneratedAttribute]
public ISerializationSurrogateProvider get_SerializationSurrogateProvider();
    [CompilerGeneratedAttribute]
public void set_SerializationSurrogateProvider(ISerializationSurrogateProvider value);
    public DataContractResolver get_DataContractResolver();
    public void set_DataContractResolver(DataContractResolver value);
    public virtual XmlObjectSerializer CreateSerializer(Type type, string name, string ns, IList`1<Type> knownTypes);
    public virtual XmlObjectSerializer CreateSerializer(Type type, XmlDictionaryString name, XmlDictionaryString ns, IList`1<Type> knownTypes);
    internal object GetFormatter(OperationDescription operation, Boolean& formatRequest, Boolean& formatReply, bool isProxy);
    private sealed virtual override void System.ServiceModel.Description.IOperationBehavior.Validate(OperationDescription description);
    private sealed virtual override void System.ServiceModel.Description.IOperationBehavior.AddBindingParameters(OperationDescription description, BindingParameterCollection parameters);
    private sealed virtual override void System.ServiceModel.Description.IOperationBehavior.ApplyDispatchBehavior(OperationDescription description, DispatchOperation dispatch);
    private sealed virtual override void System.ServiceModel.Description.IOperationBehavior.ApplyClientBehavior(OperationDescription description, ClientOperation proxy);
}
internal class System.ServiceModel.Description.DispatcherBuilder : object {
    internal static ClientRuntime BuildProxyBehavior(ServiceEndpoint serviceEndpoint, BindingParameterCollection& parameters);
    private static void AddBindingParameters(ServiceEndpoint endpoint, BindingParameterCollection parameters);
    private static void BuildProxyOperation(OperationDescription operation, ClientRuntime parent);
    private static void BuildDispatchOperation(OperationDescription operation, DispatchRuntime parent);
    private static void ApplyClientBehavior(ServiceEndpoint serviceEndpoint, ClientRuntime clientRuntime);
    private static void BindOperations(ContractDescription contract, ClientRuntime proxy, DispatchRuntime dispatch);
}
[DebuggerDisplayAttribute("Name={_name}, Action={Action}, DetailType={DetailType}")]
public class System.ServiceModel.Description.FaultDescription : object {
    private XmlName _name;
    private ProtectionLevel _protectionLevel;
    [CompilerGeneratedAttribute]
private string <Action>k__BackingField;
    [CompilerGeneratedAttribute]
private Type <DetailType>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Namespace>k__BackingField;
    [CompilerGeneratedAttribute]
private XmlName <ElementName>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <HasProtectionLevel>k__BackingField;
    public string Action { get; internal set; }
    public Type DetailType { get; public set; }
    public string Name { get; public set; }
    public string Namespace { get; public set; }
    internal XmlName ElementName { get; internal set; }
    public ProtectionLevel ProtectionLevel { get; public set; }
    public bool HasProtectionLevel { get; private set; }
    public FaultDescription(string action);
    [CompilerGeneratedAttribute]
public string get_Action();
    [CompilerGeneratedAttribute]
internal void set_Action(string value);
    [CompilerGeneratedAttribute]
public Type get_DetailType();
    [CompilerGeneratedAttribute]
public void set_DetailType(Type value);
    public string get_Name();
    public void set_Name(string value);
    [CompilerGeneratedAttribute]
public string get_Namespace();
    [CompilerGeneratedAttribute]
public void set_Namespace(string value);
    [CompilerGeneratedAttribute]
internal XmlName get_ElementName();
    [CompilerGeneratedAttribute]
internal void set_ElementName(XmlName value);
    public ProtectionLevel get_ProtectionLevel();
    public void set_ProtectionLevel(ProtectionLevel value);
    public bool ShouldSerializeProtectionLevel();
    [CompilerGeneratedAttribute]
public bool get_HasProtectionLevel();
    [CompilerGeneratedAttribute]
private void set_HasProtectionLevel(bool value);
    internal void ResetProtectionLevel();
    internal void SetNameAndElement(XmlName name);
    internal void SetNameOnly(XmlName name);
}
public class System.ServiceModel.Description.FaultDescriptionCollection : Collection`1<FaultDescription> {
    public FaultDescription Find(string action);
    public Collection`1<FaultDescription> FindAll(string action);
}
public interface System.ServiceModel.Description.IContractBehavior {
    public abstract virtual void Validate(ContractDescription contractDescription, ServiceEndpoint endpoint);
    public abstract virtual void ApplyDispatchBehavior(ContractDescription contractDescription, ServiceEndpoint endpoint, DispatchRuntime dispatchRuntime);
    public abstract virtual void ApplyClientBehavior(ContractDescription contractDescription, ServiceEndpoint endpoint, ClientRuntime clientRuntime);
    public abstract virtual void AddBindingParameters(ContractDescription contractDescription, ServiceEndpoint endpoint, BindingParameterCollection bindingParameters);
}
internal interface System.ServiceModel.Description.IContractResolver {
    public abstract virtual ContractDescription ResolveContract(string contractName);
}
public interface System.ServiceModel.Description.IEndpointBehavior {
    public abstract virtual void Validate(ServiceEndpoint endpoint);
    public abstract virtual void AddBindingParameters(ServiceEndpoint endpoint, BindingParameterCollection bindingParameters);
    public abstract virtual void ApplyDispatchBehavior(ServiceEndpoint endpoint, EndpointDispatcher endpointDispatcher);
    public abstract virtual void ApplyClientBehavior(ServiceEndpoint endpoint, ClientRuntime clientRuntime);
}
public interface System.ServiceModel.Description.IOperationBehavior {
    public abstract virtual void Validate(OperationDescription operationDescription);
    public abstract virtual void ApplyDispatchBehavior(OperationDescription operationDescription, DispatchOperation dispatchOperation);
    public abstract virtual void ApplyClientBehavior(OperationDescription operationDescription, ClientOperation clientOperation);
    public abstract virtual void AddBindingParameters(OperationDescription operationDescription, BindingParameterCollection bindingParameters);
}
public enum System.ServiceModel.Description.ListenUriMode : Enum {
    public int value__;
    public static ListenUriMode Explicit;
    public static ListenUriMode Unique;
}
internal static class System.ServiceModel.Description.ListenUriModeHelper : object {
    public static bool IsDefined(ListenUriMode mode);
}
public class System.ServiceModel.Description.MessageBodyDescription : object {
    private XmlName _wrapperName;
    private MessagePartDescription _returnValue;
    [CompilerGeneratedAttribute]
private MessagePartDescriptionCollection <Parts>k__BackingField;
    [CompilerGeneratedAttribute]
private string <WrapperNamespace>k__BackingField;
    public MessagePartDescriptionCollection Parts { get; }
    [DefaultValueAttribute("")]
public MessagePartDescription ReturnValue { get; public set; }
    [DefaultValueAttribute("")]
public string WrapperName { get; public set; }
    [DefaultValueAttribute("")]
public string WrapperNamespace { get; public set; }
    internal MessageBodyDescription(MessageBodyDescription other);
    internal MessageBodyDescription Clone();
    [CompilerGeneratedAttribute]
public MessagePartDescriptionCollection get_Parts();
    public MessagePartDescription get_ReturnValue();
    public void set_ReturnValue(MessagePartDescription value);
    public string get_WrapperName();
    public void set_WrapperName(string value);
    [CompilerGeneratedAttribute]
public string get_WrapperNamespace();
    [CompilerGeneratedAttribute]
public void set_WrapperNamespace(string value);
}
[DebuggerDisplayAttribute("Action={Action}, Direction={Direction}, MessageType={MessageType}")]
public class System.ServiceModel.Description.MessageDescription : object {
    private static Type s_typeOfUntypedMessage;
    private MessageDescriptionItems _items;
    private ProtectionLevel _protectionLevel;
    [CompilerGeneratedAttribute]
private string <Action>k__BackingField;
    [CompilerGeneratedAttribute]
private MessageDirection <Direction>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <HasProtectionLevel>k__BackingField;
    [CompilerGeneratedAttribute]
private XmlName <MessageName>k__BackingField;
    [CompilerGeneratedAttribute]
private Type <MessageType>k__BackingField;
    [CompilerGeneratedAttribute]
private XmlQualifiedName <XsdTypeName>k__BackingField;
    public string Action { get; internal set; }
    public MessageBodyDescription Body { get; }
    public MessageDirection Direction { get; }
    public MessageHeaderDescriptionCollection Headers { get; }
    public MessagePropertyDescriptionCollection Properties { get; }
    internal MessageDescriptionItems Items { get; }
    public ProtectionLevel ProtectionLevel { get; public set; }
    public bool HasProtectionLevel { get; private set; }
    internal static Type TypeOfUntypedMessage { get; }
    internal XmlName MessageName { get; internal set; }
    [DefaultValueAttribute("")]
public Type MessageType { get; public set; }
    internal bool IsTypedMessage { get; }
    internal bool IsUntypedMessage { get; }
    internal bool IsVoid { get; }
    internal XmlQualifiedName XsdTypeName { get; internal set; }
    public MessageDescription(string action, MessageDirection direction);
    internal MessageDescription(string action, MessageDirection direction, MessageDescriptionItems items);
    internal MessageDescription(MessageDescription other);
    internal MessageDescription Clone();
    [CompilerGeneratedAttribute]
public string get_Action();
    [CompilerGeneratedAttribute]
internal void set_Action(string value);
    public MessageBodyDescription get_Body();
    [CompilerGeneratedAttribute]
public MessageDirection get_Direction();
    public MessageHeaderDescriptionCollection get_Headers();
    public MessagePropertyDescriptionCollection get_Properties();
    internal MessageDescriptionItems get_Items();
    public ProtectionLevel get_ProtectionLevel();
    public void set_ProtectionLevel(ProtectionLevel value);
    public bool ShouldSerializeProtectionLevel();
    [CompilerGeneratedAttribute]
public bool get_HasProtectionLevel();
    [CompilerGeneratedAttribute]
private void set_HasProtectionLevel(bool value);
    internal static Type get_TypeOfUntypedMessage();
    [CompilerGeneratedAttribute]
internal XmlName get_MessageName();
    [CompilerGeneratedAttribute]
internal void set_MessageName(XmlName value);
    [CompilerGeneratedAttribute]
public Type get_MessageType();
    [CompilerGeneratedAttribute]
public void set_MessageType(Type value);
    internal bool get_IsTypedMessage();
    internal bool get_IsUntypedMessage();
    internal bool get_IsVoid();
    [CompilerGeneratedAttribute]
internal XmlQualifiedName get_XsdTypeName();
    [CompilerGeneratedAttribute]
internal void set_XsdTypeName(XmlQualifiedName value);
    internal void ResetProtectionLevel();
}
public class System.ServiceModel.Description.MessageDescriptionCollection : Collection`1<MessageDescription> {
    public MessageDescription Find(string action);
    public Collection`1<MessageDescription> FindAll(string action);
}
internal class System.ServiceModel.Description.MessageDescriptionItems : object {
    private MessageHeaderDescriptionCollection _headers;
    private MessageBodyDescription _body;
    private MessagePropertyDescriptionCollection _properties;
    internal MessageBodyDescription Body { get; internal set; }
    internal MessageHeaderDescriptionCollection Headers { get; }
    internal MessagePropertyDescriptionCollection Properties { get; }
    internal MessageBodyDescription get_Body();
    internal void set_Body(MessageBodyDescription value);
    internal MessageHeaderDescriptionCollection get_Headers();
    internal MessagePropertyDescriptionCollection get_Properties();
}
public enum System.ServiceModel.Description.MessageDirection : Enum {
    public int value__;
    public static MessageDirection Input;
    public static MessageDirection Output;
}
internal static class System.ServiceModel.Description.MessageDirectionHelper : object {
    internal static bool IsDefined(MessageDirection value);
    internal static MessageDirection Opposite(MessageDirection d);
}
public class System.ServiceModel.Description.MessageHeaderDescription : MessagePartDescription {
    private bool _relay;
    private bool _isUnknownHeader;
    [CompilerGeneratedAttribute]
private string <Actor>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <MustUnderstand>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <TypedHeader>k__BackingField;
    [DefaultValueAttribute("")]
public string Actor { get; public set; }
    [DefaultValueAttribute("False")]
public bool MustUnderstand { get; public set; }
    [DefaultValueAttribute("False")]
public bool Relay { get; public set; }
    [DefaultValueAttribute("False")]
public bool TypedHeader { get; public set; }
    internal bool IsUnknownHeaderCollection { get; internal set; }
    public MessageHeaderDescription(string name, string ns);
    internal MessageHeaderDescription(MessageHeaderDescription other);
    internal virtual MessagePartDescription Clone();
    [CompilerGeneratedAttribute]
public string get_Actor();
    [CompilerGeneratedAttribute]
public void set_Actor(string value);
    [CompilerGeneratedAttribute]
public bool get_MustUnderstand();
    [CompilerGeneratedAttribute]
public void set_MustUnderstand(bool value);
    public bool get_Relay();
    public void set_Relay(bool value);
    [CompilerGeneratedAttribute]
public bool get_TypedHeader();
    [CompilerGeneratedAttribute]
public void set_TypedHeader(bool value);
    internal bool get_IsUnknownHeaderCollection();
    internal void set_IsUnknownHeaderCollection(bool value);
}
public class System.ServiceModel.Description.MessageHeaderDescriptionCollection : KeyedCollection`2<XmlQualifiedName, MessageHeaderDescription> {
    protected virtual XmlQualifiedName GetKeyForItem(MessageHeaderDescription item);
}
[DebuggerDisplayAttribute("Name={XmlName}, Namespace={Namespace}, Type={Type}, Index={Index}}")]
public class System.ServiceModel.Description.MessagePartDescription : object {
    private ProtectionLevel _protectionLevel;
    private ICustomAttributeProvider _additionalAttributesProvider;
    private string _uniquePartName;
    [CompilerGeneratedAttribute]
private string <BaseType>k__BackingField;
    [CompilerGeneratedAttribute]
private XmlName <XmlName>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Namespace>k__BackingField;
    [CompilerGeneratedAttribute]
private Type <Type>k__BackingField;
    [CompilerGeneratedAttribute]
private int <Index>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <Multiple>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <HasProtectionLevel>k__BackingField;
    [CompilerGeneratedAttribute]
private MemberInfo <MemberInfo>k__BackingField;
    [CompilerGeneratedAttribute]
private int <SerializationPosition>k__BackingField;
    internal string BaseType { get; internal set; }
    internal XmlName XmlName { get; }
    internal string CodeName { get; }
    public string Name { get; }
    public string Namespace { get; }
    public Type Type { get; public set; }
    public int Index { get; public set; }
    [DefaultValueAttribute("False")]
public bool Multiple { get; public set; }
    public ProtectionLevel ProtectionLevel { get; public set; }
    public bool HasProtectionLevel { get; private set; }
    public MemberInfo MemberInfo { get; public set; }
    internal ICustomAttributeProvider AdditionalAttributesProvider { get; internal set; }
    internal string UniquePartName { get; internal set; }
    internal int SerializationPosition { get; internal set; }
    public MessagePartDescription(string name, string ns);
    internal MessagePartDescription(MessagePartDescription other);
    internal virtual MessagePartDescription Clone();
    [CompilerGeneratedAttribute]
internal string get_BaseType();
    [CompilerGeneratedAttribute]
internal void set_BaseType(string value);
    [CompilerGeneratedAttribute]
internal XmlName get_XmlName();
    internal string get_CodeName();
    public string get_Name();
    [CompilerGeneratedAttribute]
public string get_Namespace();
    [CompilerGeneratedAttribute]
public Type get_Type();
    [CompilerGeneratedAttribute]
public void set_Type(Type value);
    [CompilerGeneratedAttribute]
public int get_Index();
    [CompilerGeneratedAttribute]
public void set_Index(int value);
    [CompilerGeneratedAttribute]
public bool get_Multiple();
    [CompilerGeneratedAttribute]
public void set_Multiple(bool value);
    public ProtectionLevel get_ProtectionLevel();
    public void set_ProtectionLevel(ProtectionLevel value);
    [CompilerGeneratedAttribute]
public bool get_HasProtectionLevel();
    [CompilerGeneratedAttribute]
private void set_HasProtectionLevel(bool value);
    [CompilerGeneratedAttribute]
public MemberInfo get_MemberInfo();
    [CompilerGeneratedAttribute]
public void set_MemberInfo(MemberInfo value);
    internal ICustomAttributeProvider get_AdditionalAttributesProvider();
    internal void set_AdditionalAttributesProvider(ICustomAttributeProvider value);
    internal string get_UniquePartName();
    internal void set_UniquePartName(string value);
    [CompilerGeneratedAttribute]
internal int get_SerializationPosition();
    [CompilerGeneratedAttribute]
internal void set_SerializationPosition(int value);
    internal void ResetProtectionLevel();
}
public class System.ServiceModel.Description.MessagePartDescriptionCollection : KeyedCollection`2<XmlQualifiedName, MessagePartDescription> {
    protected virtual XmlQualifiedName GetKeyForItem(MessagePartDescription item);
}
public class System.ServiceModel.Description.MessagePropertyDescription : MessagePartDescription {
    public MessagePropertyDescription(string name);
    internal MessagePropertyDescription(MessagePropertyDescription other);
    internal virtual MessagePartDescription Clone();
}
public class System.ServiceModel.Description.MessagePropertyDescriptionCollection : KeyedCollection`2<string, MessagePropertyDescription> {
    protected virtual string GetKeyForItem(MessagePropertyDescription item);
}
public class System.ServiceModel.Description.MetadataConversionError : object {
    private bool _isWarning;
    [CompilerGeneratedAttribute]
private string <Message>k__BackingField;
    public string Message { get; }
    public bool IsWarning { get; }
    public MetadataConversionError(string message);
    public MetadataConversionError(string message, bool isWarning);
    [CompilerGeneratedAttribute]
public string get_Message();
    public bool get_IsWarning();
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
}
[XmlRootAttribute]
public class System.ServiceModel.Description.MetadataLocation : object {
    private string _location;
    [XmlTextAttribute]
public string Location { get; public set; }
    public MetadataLocation(string location);
    public string get_Location();
    public void set_Location(string value);
}
internal static class System.ServiceModel.Description.MetadataStrings : object {
}
internal static class System.ServiceModel.Description.NamingHelper : object {
    internal static string DefaultNamespace;
    internal static string DefaultServiceName;
    internal static string MSNamespace;
    internal static string CombineUriStrings(string baseUri, string path);
    internal static string TypeName(Type t);
    internal static XmlQualifiedName GetContractName(Type contractType, string name, string ns);
    internal static XmlName GetOperationName(string logicalMethodName, string name);
    internal static string GetMessageAction(OperationDescription operation, bool isResponse);
    internal static string GetMessageAction(XmlQualifiedName contractName, string opname, string action, bool isResponse);
    internal static string GetUniqueName(string baseName, DoesNameExist doesNameExist, object nameCollection);
    internal static void CheckUriProperty(string ns, string propName);
    internal static void CheckUriParameter(string ns, string paramName);
    internal static string XmlName(string name);
    internal static string CodeName(string name);
    private static bool IsAlpha(char ch);
    private static bool IsDigit(char ch);
    private static bool IsAsciiLocalName(string localName);
    internal static bool IsValidNCName(string name);
}
[DebuggerDisplayAttribute("Name={XmlName}, IsInitiating={IsInitiating}, IsTerminating={IsTerminating}")]
public class System.ServiceModel.Description.OperationDescription : object {
    internal static string SessionOpenedAction;
    private bool _isSessionOpenNotificationEnabled;
    private ContractDescription _declaringContract;
    private MethodInfo _taskMethod;
    private bool _hasNoDisposableParameters;
    [CompilerGeneratedAttribute]
private KeyedByTypeCollection`1<IOperationBehavior> <Behaviors>k__BackingField;
    [CompilerGeneratedAttribute]
private MethodInfo <SyncMethod>k__BackingField;
    [CompilerGeneratedAttribute]
private MethodInfo <BeginMethod>k__BackingField;
    [CompilerGeneratedAttribute]
private MethodInfo <EndMethod>k__BackingField;
    [CompilerGeneratedAttribute]
private FaultDescriptionCollection <Faults>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsInitiating>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsTerminating>k__BackingField;
    [CompilerGeneratedAttribute]
private Collection`1<Type> <KnownTypes>k__BackingField;
    [CompilerGeneratedAttribute]
private MessageDescriptionCollection <Messages>k__BackingField;
    [CompilerGeneratedAttribute]
private XmlName <XmlName>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsValidateRpcWrapperName>k__BackingField;
    [CompilerGeneratedAttribute]
private Type <TaskTResult>k__BackingField;
    public KeyedCollection`2<Type, IOperationBehavior> OperationBehaviors { get; }
    [EditorBrowsableAttribute("1")]
public KeyedByTypeCollection`1<IOperationBehavior> Behaviors { get; }
    public MethodInfo TaskMethod { get; public set; }
    public MethodInfo SyncMethod { get; public set; }
    public MethodInfo BeginMethod { get; public set; }
    internal MethodInfo OperationMethod { get; }
    internal bool HasNoDisposableParameters { get; internal set; }
    public MethodInfo EndMethod { get; public set; }
    public ContractDescription DeclaringContract { get; public set; }
    public FaultDescriptionCollection Faults { get; }
    public bool IsOneWay { get; }
    public bool IsInitiating { get; public set; }
    public bool IsTerminating { get; public set; }
    public Collection`1<Type> KnownTypes { get; }
    public MessageDescriptionCollection Messages { get; }
    internal XmlName XmlName { get; }
    internal string CodeName { get; }
    public string Name { get; }
    internal bool IsValidateRpcWrapperName { get; }
    internal Type TaskTResult { get; internal set; }
    internal bool HasOutputParameters { get; }
    internal bool IsSessionOpenNotificationEnabled { get; internal set; }
    public OperationDescription(string name, ContractDescription declaringContract);
    internal OperationDescription(string name, ContractDescription declaringContract, bool validateRpcWrapperName);
    public KeyedCollection`2<Type, IOperationBehavior> get_OperationBehaviors();
    [CompilerGeneratedAttribute]
public KeyedByTypeCollection`1<IOperationBehavior> get_Behaviors();
    public MethodInfo get_TaskMethod();
    public void set_TaskMethod(MethodInfo value);
    [CompilerGeneratedAttribute]
public MethodInfo get_SyncMethod();
    [CompilerGeneratedAttribute]
public void set_SyncMethod(MethodInfo value);
    [CompilerGeneratedAttribute]
public MethodInfo get_BeginMethod();
    [CompilerGeneratedAttribute]
public void set_BeginMethod(MethodInfo value);
    internal MethodInfo get_OperationMethod();
    internal bool get_HasNoDisposableParameters();
    internal void set_HasNoDisposableParameters(bool value);
    [CompilerGeneratedAttribute]
public MethodInfo get_EndMethod();
    [CompilerGeneratedAttribute]
public void set_EndMethod(MethodInfo value);
    public ContractDescription get_DeclaringContract();
    public void set_DeclaringContract(ContractDescription value);
    [CompilerGeneratedAttribute]
public FaultDescriptionCollection get_Faults();
    public bool get_IsOneWay();
    [CompilerGeneratedAttribute]
public bool get_IsInitiating();
    [CompilerGeneratedAttribute]
public void set_IsInitiating(bool value);
    internal bool IsServerInitiated();
    [CompilerGeneratedAttribute]
public bool get_IsTerminating();
    [CompilerGeneratedAttribute]
public void set_IsTerminating(bool value);
    [CompilerGeneratedAttribute]
public Collection`1<Type> get_KnownTypes();
    [CompilerGeneratedAttribute]
public MessageDescriptionCollection get_Messages();
    [CompilerGeneratedAttribute]
internal XmlName get_XmlName();
    internal string get_CodeName();
    public string get_Name();
    [CompilerGeneratedAttribute]
internal bool get_IsValidateRpcWrapperName();
    [CompilerGeneratedAttribute]
internal Type get_TaskTResult();
    [CompilerGeneratedAttribute]
internal void set_TaskTResult(Type value);
    internal bool get_HasOutputParameters();
    internal bool get_IsSessionOpenNotificationEnabled();
    internal void set_IsSessionOpenNotificationEnabled(bool value);
    internal void EnsureInvariants();
}
public class System.ServiceModel.Description.OperationDescriptionCollection : Collection`1<OperationDescription> {
    public OperationDescription Find(string name);
    public Collection`1<OperationDescription> FindAll(string name);
    protected virtual void InsertItem(int index, OperationDescription item);
    protected virtual void SetItem(int index, OperationDescription item);
}
public class System.ServiceModel.Description.PolicyVersion : object {
    private static PolicyVersion s_policyVersion12;
    [CompilerGeneratedAttribute]
private static PolicyVersion <Policy15>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Namespace>k__BackingField;
    public static PolicyVersion Policy12 { get; }
    public static PolicyVersion Policy15 { get; private set; }
    public static PolicyVersion Default { get; }
    public string Namespace { get; }
    private static PolicyVersion();
    private PolicyVersion(string policyNamespace);
    public static PolicyVersion get_Policy12();
    [CompilerGeneratedAttribute]
public static PolicyVersion get_Policy15();
    [CompilerGeneratedAttribute]
private static void set_Policy15(PolicyVersion value);
    public static PolicyVersion get_Default();
    [CompilerGeneratedAttribute]
public string get_Namespace();
    public virtual string ToString();
}
public enum System.ServiceModel.Description.PrincipalPermissionMode : Enum {
    public int value__;
    public static PrincipalPermissionMode None;
    public static PrincipalPermissionMode UseWindowsGroups;
    public static PrincipalPermissionMode UseAspNetRoles;
    public static PrincipalPermissionMode Custom;
    public static PrincipalPermissionMode Always;
}
internal static class System.ServiceModel.Description.PrincipalPermissionModeHelper : object {
    public static bool IsDefined(PrincipalPermissionMode principalPermissionMode);
}
[DebuggerDisplayAttribute("Address={Address}")]
[DebuggerDisplayAttribute("Name={_name}")]
public class System.ServiceModel.Description.ServiceEndpoint : object {
    private ContractDescription _contract;
    private Uri _listenUri;
    private ListenUriMode _listenUriMode;
    private KeyedByTypeCollection`1<IEndpointBehavior> _behaviors;
    private string _id;
    private XmlName _name;
    [CompilerGeneratedAttribute]
private EndpointAddress <Address>k__BackingField;
    [CompilerGeneratedAttribute]
private Binding <Binding>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsSystemEndpoint>k__BackingField;
    [CompilerGeneratedAttribute]
private Uri <UnresolvedAddress>k__BackingField;
    [CompilerGeneratedAttribute]
private Uri <UnresolvedListenUri>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsFullyConfigured>k__BackingField;
    public EndpointAddress Address { get; public set; }
    public KeyedCollection`2<Type, IEndpointBehavior> EndpointBehaviors { get; }
    [EditorBrowsableAttribute("1")]
public KeyedByTypeCollection`1<IEndpointBehavior> Behaviors { get; }
    public Binding Binding { get; public set; }
    public ContractDescription Contract { get; public set; }
    public bool IsSystemEndpoint { get; public set; }
    public string Name { get; public set; }
    public Uri ListenUri { get; public set; }
    public ListenUriMode ListenUriMode { get; public set; }
    internal string Id { get; }
    internal Uri UnresolvedAddress { get; internal set; }
    internal Uri UnresolvedListenUri { get; internal set; }
    internal bool IsFullyConfigured { get; internal set; }
    public ServiceEndpoint(ContractDescription contract);
    public ServiceEndpoint(ContractDescription contract, Binding binding, EndpointAddress address);
    [CompilerGeneratedAttribute]
public EndpointAddress get_Address();
    [CompilerGeneratedAttribute]
public void set_Address(EndpointAddress value);
    public KeyedCollection`2<Type, IEndpointBehavior> get_EndpointBehaviors();
    public KeyedByTypeCollection`1<IEndpointBehavior> get_Behaviors();
    [CompilerGeneratedAttribute]
public Binding get_Binding();
    [CompilerGeneratedAttribute]
public void set_Binding(Binding value);
    public ContractDescription get_Contract();
    public void set_Contract(ContractDescription value);
    [CompilerGeneratedAttribute]
public bool get_IsSystemEndpoint();
    [CompilerGeneratedAttribute]
public void set_IsSystemEndpoint(bool value);
    public string get_Name();
    public void set_Name(string value);
    public Uri get_ListenUri();
    public void set_ListenUri(Uri value);
    public ListenUriMode get_ListenUriMode();
    public void set_ListenUriMode(ListenUriMode value);
    internal string get_Id();
    [CompilerGeneratedAttribute]
internal Uri get_UnresolvedAddress();
    [CompilerGeneratedAttribute]
internal void set_UnresolvedAddress(Uri value);
    [CompilerGeneratedAttribute]
internal Uri get_UnresolvedListenUri();
    [CompilerGeneratedAttribute]
internal void set_UnresolvedListenUri(Uri value);
    internal void EnsureInvariants();
    internal void ValidateForClient();
    internal void ValidateForService(bool runOperationValidators);
    [CompilerGeneratedAttribute]
internal bool get_IsFullyConfigured();
    [CompilerGeneratedAttribute]
internal void set_IsFullyConfigured(bool value);
    private void Validate(bool runOperationValidators, bool isForService);
}
public class System.ServiceModel.Description.ServiceEndpointCollection : Collection`1<ServiceEndpoint> {
    public ServiceEndpoint Find(Type contractType);
    public ServiceEndpoint Find(XmlQualifiedName contractName);
    public ServiceEndpoint Find(Type contractType, XmlQualifiedName bindingName);
    public ServiceEndpoint Find(XmlQualifiedName contractName, XmlQualifiedName bindingName);
    public ServiceEndpoint Find(Uri address);
    public Collection`1<ServiceEndpoint> FindAll(Type contractType);
    public Collection`1<ServiceEndpoint> FindAll(XmlQualifiedName contractName);
    protected virtual void InsertItem(int index, ServiceEndpoint item);
    protected virtual void SetItem(int index, ServiceEndpoint item);
}
internal static class System.ServiceModel.Description.ServiceReflector : object {
    internal static string BeginMethodNamePrefix;
    internal static string EndMethodNamePrefix;
    internal static Type VoidType;
    internal static string AsyncMethodNameSuffix;
    internal static Type taskType;
    internal static Type taskTResultType;
    internal static Type CancellationTokenType;
    internal static Type IProgressType;
    private static Type s_asyncCallbackType;
    private static Type s_asyncResultType;
    private static Type s_objectType;
    private static Type s_OperationContractAttributeType;
    private static ServiceReflector();
    internal static Type GetOperationContractProviderType(MethodInfo method);
    internal static List`1<Type> GetInterfaces(Type service);
    private static Type GetAncestorImplicitContractClass(Type service);
    internal static List`1<Type> GetInheritedContractTypes(Type service);
    internal static Object[] GetCustomAttributes(ICustomAttributeProvider attrProvider, Type attrType);
    internal static Object[] GetCustomAttributes(ICustomAttributeProvider attrProvider, Type attrType, bool inherit);
    internal static T GetFirstAttribute(ICustomAttributeProvider attrProvider);
    internal static T GetSingleAttribute(ICustomAttributeProvider attrProvider);
    internal static T GetRequiredSingleAttribute(ICustomAttributeProvider attrProvider);
    internal static T GetSingleAttribute(ICustomAttributeProvider attrProvider, Type[] attrTypeGroup);
    internal static T GetRequiredSingleAttribute(ICustomAttributeProvider attrProvider, Type[] attrTypeGroup);
    internal static Type GetContractType(Type interfaceType);
    internal static Type GetContractTypeAndAttribute(Type interfaceType, ServiceContractAttribute& contractAttribute);
    private static List`1<MethodInfo> GetMethodsInternal(Type interfaceType);
    internal static void ValidateParameterMetadata(MethodInfo methodInfo);
    internal static bool FlowsIn(ParameterInfo paramInfo);
    internal static bool FlowsOut(ParameterInfo paramInfo);
    internal static ParameterInfo[] GetInputParameters(MethodInfo method, bool asyncPattern);
    internal static ParameterInfo[] GetOutputParameters(MethodInfo method, bool asyncPattern);
    internal static bool HasOutputParameters(MethodInfo method, bool asyncPattern);
    private static MethodInfo GetEndMethodInternal(MethodInfo beginMethod);
    internal static MethodInfo GetEndMethod(MethodInfo beginMethod);
    internal static XmlName GetOperationName(MethodInfo method);
    internal static bool HasBeginMethodShape(MethodInfo method);
    internal static bool IsBegin(OperationContractAttribute opSettings, MethodInfo method);
    internal static bool IsTask(MethodInfo method);
    internal static bool IsTask(MethodInfo method, Type& taskTResult);
    internal static bool HasEndMethodShape(MethodInfo method);
    internal static OperationContractAttribute GetOperationContractAttribute(MethodInfo method);
    internal static bool IsBegin(MethodInfo method);
    internal static string GetLogicalName(MethodInfo method);
    internal static string GetLogicalName(MethodInfo method, bool isAsync, bool isTask);
    internal static bool HasNoDisposableParameters(MethodInfo methodInfo);
    internal static bool IsParameterDisposable(Type type);
}
public abstract class System.ServiceModel.Description.TypedMessageConverter : object {
    public static TypedMessageConverter Create(Type messageContract, string action);
    public static TypedMessageConverter Create(Type messageContract, string action, string defaultNamespace);
    public static TypedMessageConverter Create(Type messageContract, string action, XmlSerializerFormatAttribute formatterAttribute);
    public static TypedMessageConverter Create(Type messageContract, string action, DataContractFormatAttribute formatterAttribute);
    public static TypedMessageConverter Create(Type messageContract, string action, string defaultNamespace, XmlSerializerFormatAttribute formatterAttribute);
    public static TypedMessageConverter Create(Type messageContract, string action, string defaultNamespace, DataContractFormatAttribute formatterAttribute);
    public abstract virtual Message ToMessage(object typedMessage);
    public abstract virtual Message ToMessage(object typedMessage, MessageVersion version);
    public abstract virtual object FromMessage(Message message);
    private static OperationFormatter GetOperationFormatter(Type t, Attribute formatAttribute, string defaultNS, string action);
}
internal class System.ServiceModel.Description.TypeLoader : object {
    private static Type[] s_messageContractMemberAttributes;
    private static Type[] s_formatterAttributes;
    private static Type[] s_knownTypesMethodParamType;
    internal static DataContractFormatAttribute DefaultDataContractFormatAttribute;
    internal static XmlSerializerFormatAttribute DefaultXmlSerializerFormatAttribute;
    private static Type s_OperationContractAttributeType;
    internal static string ReturnSuffix;
    internal static string ResponseSuffix;
    internal static string FaultSuffix;
    internal static BindingFlags DefaultBindingFlags;
    private object _thisLock;
    private Dictionary`2<Type, ContractDescription> _contracts;
    private Dictionary`2<Type, MessageDescriptionItems> _messages;
    private static TypeLoader();
    private ContractDescription LoadContractDescriptionHelper(Type contractType, Type serviceType, object serviceImplementation);
    private void EnsureNoInheritanceWithContractClasses(Type actualContractType);
    private void EnsureNoOperationContractsOnNonServiceContractTypes(Type actualContractType);
    private void EnsureNoOperationContractsOnNonServiceContractTypes_Helper(Type aParentType);
    public ContractDescription LoadContractDescription(Type contractType);
    public ContractDescription LoadContractDescription(Type contractType, Type serviceType);
    public ContractDescription LoadContractDescription(Type contractType, Type serviceType, object serviceImplementation);
    private ContractDescription LoadOutputChannelContractDescription();
    private ContractDescription LoadRequestChannelContractDescription();
    private void AddBehaviors(ContractDescription contractDesc, Type implType, bool implIsCallback, ContractReflectionInfo reflectionInfo);
    private void GetIContractBehaviorsFromInterfaceType(Type interfaceType, KeyedByTypeCollection`1<IContractBehavior> behaviors);
    private static void UpdateContractDescriptionWithAttributesFromServiceType(ContractDescription description, Type serviceType);
    private void UpdateOperationsWithInterfaceAttributes(ContractDescription contractDesc, ContractReflectionInfo reflectionInfo);
    private IEnumerable`1<Type> GetKnownTypes(Object[] knownTypeAttributes, ICustomAttributeProvider provider);
    private KeyedByTypeCollection`1<IOperationBehavior> GetIOperationBehaviorAttributesFromType(OperationDescription opDesc, Type targetIface, Type implType);
    private void ProcessOpMethod(MethodInfo opMethod, bool canHaveBehaviors, OperationDescription opDesc, KeyedByTypeCollection`1<IOperationBehavior> result, Type ifaceType, Type implType, bool useImplAttrs);
    private static MethodInfo GetCorrespondingMethodFromType(Type type, MethodInfo methodInfo);
    private static bool MethodsMatch(MethodInfo method1, MethodInfo method2);
    private static bool ParameterInfosMatch(ParameterInfo parameterInfo1, ParameterInfo parameterInfo2);
    internal void AddBehaviorsSFx(ServiceEndpoint serviceEndpoint, Type contractType);
    internal void AddBehaviorsFromImplementationType(ServiceEndpoint serviceEndpoint, Type implementationType);
    internal static int CompareMessagePartDescriptions(MessagePartDescription a, MessagePartDescription b);
    internal static XmlName GetBodyWrapperResponseName(string operationName);
    internal static XmlName GetBodyWrapperResponseName(XmlName operationName);
    private void CreateOperationDescriptions(ContractDescription contractDescription, ContractReflectionInfo reflectionInfo, Type contractToGetMethodsFrom, ContractDescription declaringContract, MessageDirection direction);
    internal static void EnsureCallbackType(Type callbackType);
    internal static void EnsureSubcontract(ServiceContractAttribute svcContractAttr, Type contractType);
    private ContractDescription CreateContractDescription(ServiceContractAttribute contractAttr, Type contractType, Type serviceType, ContractReflectionInfo& reflectionInfo, object serviceImplementation);
    internal static Attribute GetFormattingAttribute(ICustomAttributeProvider attrProvider, Attribute defaultFormatAttribute);
    private void VerifyConsistency(OperationConsistencyVerifier verifier);
    private OperationDescription CreateOperationDescription(ContractDescription contractDescription, MethodInfo methodInfo, MessageDirection direction, ContractReflectionInfo reflectionInfo, ContractDescription declaringContract);
    private void CheckDuplicateFaultContract(FaultDescriptionCollection faultDescriptionCollection, FaultDescription fault, string operationName);
    private FaultDescription CreateFaultDescription(FaultContractAttribute attr, XmlQualifiedName contractName, string contractNamespace, XmlName operationName);
    private MessageDescription CreateMessageDescription(MethodInfo methodInfo, bool isAsync, bool isTask, Type taskTResult, XmlName returnValueName, string defaultNS, string action, XmlName wrapperName, string wrapperNamespace, MessageDirection direction);
    private MessageDescription CreateParameterMessageDescription(ParameterInfo[] parameters, Type returnType, ICustomAttributeProvider returnAttrProvider, XmlName returnValueName, string methodName, string defaultNS, string action, XmlName wrapperName, string wrapperNamespace, MessageDirection direction);
    private static MessagePartDescription CreateParameterPartDescription(XmlName defaultName, string defaultNS, int index, ICustomAttributeProvider attrProvider, Type type);
    internal MessageDescription CreateTypedMessageDescription(Type typedMessageType, ICustomAttributeProvider returnAttrProvider, XmlName returnValueName, string defaultNS, string action, MessageDirection direction);
    private static bool IsMethodOverriding(MethodInfo method);
    private MessagePartDescription CreateMessagePartDescription(Type bodyType, ICustomAttributeProvider attrProvider, XmlName defaultName, string defaultNS, int parameterIndex, int serializationIndex);
    private MessageHeaderDescription CreateMessageHeaderDescription(Type headerParameterType, ICustomAttributeProvider attrProvider, XmlName defaultName, string defaultNS, int parameterIndex, int serializationPosition);
    private MessagePropertyDescription CreateMessagePropertyDescription(ICustomAttributeProvider attrProvider, XmlName defaultName, int parameterIndex);
    internal static XmlName GetReturnValueName(XmlName methodName);
    internal static XmlName GetReturnValueName(string methodName);
    internal static Type GetParameterType(ParameterInfo parameterInfo);
    internal static XmlName GetWrapperName(string wrapperName, XmlName defaultName);
    private void AddSortedParts(List`1<T> partDescriptionList, KeyedCollection`2<XmlQualifiedName, T> partDescriptionCollection);
    public static void ApplyServiceInheritance(Type serviceType, TBehaviorCollection descriptionBehaviors, ServiceInheritanceCallback`2<IBehavior, TBehaviorCollection> callback);
    private static void AddBehaviorsAtOneScope(Type type, TBehaviorCollection descriptionBehaviors, ServiceInheritanceCallback`2<IBehavior, TBehaviorCollection> callback);
}
[ExtensionAttribute]
internal static class System.ServiceModel.Description.XmlMappingExtension : object {
    private static ConcurrentDictionary`2<XmlMapping, string> s_dictionary;
    private static XmlMappingExtension();
    [ExtensionAttribute]
public static string GetKey(XmlMapping mapping);
    [ExtensionAttribute]
public static void SetKeyInternal(XmlMapping mapping, string key);
}
internal class System.ServiceModel.Description.XmlMessageConverter : TypedMessageConverter {
    private OperationFormatter formatter;
    internal string Action { get; }
    internal XmlMessageConverter(OperationFormatter formatter);
    internal string get_Action();
    public virtual Message ToMessage(object typedMessage);
    public virtual Message ToMessage(object typedMessage, MessageVersion version);
    public virtual object FromMessage(Message message);
}
internal class System.ServiceModel.Description.XmlName : object {
    private string _decoded;
    private string _encoded;
    internal string EncodedName { get; }
    internal string DecodedName { get; }
    private bool IsEmpty { get; }
    internal XmlName(string name);
    internal XmlName(string name, bool isEncoded);
    internal string get_EncodedName();
    internal string get_DecodedName();
    private static void ValidateEncodedName(string name, bool allowNull);
    private bool get_IsEmpty();
    internal static bool IsNullOrEmpty(XmlName xmlName);
    private bool Matches(XmlName xmlName);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    public virtual string ToString();
    public static bool op_Equality(XmlName a, XmlName b);
    public static bool op_Inequality(XmlName a, XmlName b);
}
internal static class System.ServiceModel.Description.XmlSerializerHelper : object {
    internal static XmlReflectionMember GetXmlReflectionMember(MessagePartDescription part, bool isRpc, bool isEncoded, bool isWrapped);
    internal static XmlReflectionMember GetXmlReflectionMember(XmlName memberName, XmlName elementName, string ns, Type type, ICustomAttributeProvider additionalAttributesProvider, bool isMultiple, bool isEncoded, bool isWrapped);
    private static bool HasNoXmlParameterAttributes(XmlAttributes xmlAttributes);
    public static XmlSerializer[] FromMappings(XmlMapping[] mappings, Type type);
    private static XmlSerializer[] FromMappingsViaReflection(XmlMapping[] mappings, Type type);
    private static XmlSerializer[] FromMappingsViaInjection(XmlMapping[] mappings, Type type);
}
public class System.ServiceModel.Description.XmlSerializerOperationBehavior : object {
    private bool _builtInOperationBehavior;
    [CompilerGeneratedAttribute]
private OperationReflector <OperationReflector>k__BackingField;
    internal OperationReflector OperationReflector { get; }
    internal bool IsBuiltInOperationBehavior { get; }
    public XmlSerializerFormatAttribute XmlSerializerFormatAttribute { get; }
    public XmlSerializerOperationBehavior(OperationDescription operation);
    public XmlSerializerOperationBehavior(OperationDescription operation, XmlSerializerFormatAttribute attribute);
    internal XmlSerializerOperationBehavior(OperationDescription operation, XmlSerializerFormatAttribute attribute, Reflector parentReflector);
    private XmlSerializerOperationBehavior(OperationReflector reflector, bool builtInOperationBehavior);
    [CompilerGeneratedAttribute]
internal OperationReflector get_OperationReflector();
    internal bool get_IsBuiltInOperationBehavior();
    public XmlSerializerFormatAttribute get_XmlSerializerFormatAttribute();
    internal static XmlSerializerOperationFormatter CreateOperationFormatter(OperationDescription operation);
    internal static XmlSerializerOperationFormatter CreateOperationFormatter(OperationDescription operation, XmlSerializerFormatAttribute attr);
    internal static void AddBehaviors(ContractDescription contract);
    internal static void AddBuiltInBehaviors(ContractDescription contract);
    private static void AddBehaviors(ContractDescription contract, bool builtInOperationBehavior);
    internal XmlSerializerOperationFormatter CreateFormatter();
    private XmlSerializerFaultFormatter CreateFaultFormatter(SynchronizedCollection`1<FaultContractInfo> faultContractInfos);
    private sealed virtual override void System.ServiceModel.Description.IOperationBehavior.Validate(OperationDescription description);
    private sealed virtual override void System.ServiceModel.Description.IOperationBehavior.AddBindingParameters(OperationDescription description, BindingParameterCollection parameters);
    private sealed virtual override void System.ServiceModel.Description.IOperationBehavior.ApplyDispatchBehavior(OperationDescription description, DispatchOperation dispatch);
    private sealed virtual override void System.ServiceModel.Description.IOperationBehavior.ApplyClientBehavior(OperationDescription description, ClientOperation proxy);
    public Collection`1<XmlMapping> GetXmlMappings();
}
internal class System.ServiceModel.Diagnostics.Activity : object {
    protected Guid parentId;
    private bool _mustDispose;
    [CompilerGeneratedAttribute]
private Guid <Id>k__BackingField;
    protected Guid Id { get; }
    protected Activity(Guid activityId, Guid parentId);
    internal static Activity CreateActivity(Guid activityId);
    public virtual void Dispose();
    [CompilerGeneratedAttribute]
protected Guid get_Id();
}
internal class System.ServiceModel.Diagnostics.ActivityIdHeader : DictionaryHeader {
    private Guid _guid;
    private Guid _headerId;
    public XmlDictionaryString DictionaryName { get; }
    public XmlDictionaryString DictionaryNamespace { get; }
    internal ActivityIdHeader(Guid activityId);
    public virtual XmlDictionaryString get_DictionaryName();
    public virtual XmlDictionaryString get_DictionaryNamespace();
    internal static Guid ExtractActivityId(Message message);
    internal static bool ExtractActivityAndCorrelationId(Message message, Guid& activityId, Guid& correlationId);
    internal void AddTo(Message message);
    protected virtual void OnWriteHeaderContents(XmlDictionaryWriter writer, MessageVersion messageVersion);
}
internal enum System.ServiceModel.Diagnostics.ActivityType : Enum {
    public int value__;
    public static ActivityType Unknown;
    public static ActivityType Close;
    public static ActivityType Construct;
    public static ActivityType ExecuteUserCode;
    public static ActivityType ListenAt;
    public static ActivityType Open;
    public static ActivityType OpenClient;
    public static ActivityType ProcessMessage;
    public static ActivityType ProcessAction;
    public static ActivityType ReceiveBytes;
    public static ActivityType SecuritySetup;
    public static ActivityType TransferToComPlus;
    public static ActivityType WmiGetObject;
    public static ActivityType WmiPutInstance;
    public static ActivityType NumItems;
}
internal static class System.ServiceModel.Diagnostics.DiagnosticStrings : object {
    internal static string DiagnosticsNamespace;
    internal static string ActivityIdName;
    internal static string ActivityId;
    internal static string AppDomain;
    internal static string ChannelTag;
    internal static string DataTag;
    internal static string DataItemsTag;
    internal static string DeflateCookieAfterDeflatingTag;
    internal static string DeflateCookieOriginalSizeTag;
    internal static string Description;
    internal static string DescriptionTag;
    internal static string EventLogTag;
    internal static string ExceptionTag;
    internal static string ExceptionTypeTag;
    internal static string ExceptionStringTag;
    internal static string ExtendedDataTag;
    internal static string HeaderTag;
    internal static string InnerExceptionTag;
    internal static string KeyTag;
    internal static string MessageTag;
    internal static string NameTag;
    internal static string NamespaceTag;
    internal static string NativeErrorCodeTag;
    internal static string ProcessId;
    internal static string ProcessName;
    internal static string RoleTag;
    internal static string Separator;
    internal static string SeverityTag;
    internal static string SourceTag;
    internal static string StackTraceTag;
    internal static string Task;
    internal static string TraceCodeTag;
    internal static string TraceRecordTag;
    internal static string ValueTag;
    [CompilerGeneratedAttribute]
private static String[][] <HeadersPaths>k__BackingField;
    [CompilerGeneratedAttribute]
private static String[] <PiiList>k__BackingField;
    internal static String[][] HeadersPaths { get; }
    internal static String[] PiiList { get; }
    private static DiagnosticStrings();
    [CompilerGeneratedAttribute]
internal static String[][] get_HeadersPaths();
    [CompilerGeneratedAttribute]
internal static String[] get_PiiList();
}
internal static class System.ServiceModel.Diagnostics.EventTraceActivityHelper : object {
    public static bool TryAttachActivity(Message message, EventTraceActivity activity);
    public static EventTraceActivity TryExtractActivity(Message message);
    public static EventTraceActivity TryExtractActivity(Message message, bool createIfNotExist);
    internal static void SetOnThread(EventTraceActivity eventTraceActivity);
    private static bool GetMessageId(Message message, Guid& guid);
}
internal class System.ServiceModel.Diagnostics.ExceptionUtility : object {
    internal static ExceptionUtility s_mainInstance;
    [ThreadStaticAttribute]
private static Guid s_activityId;
    public ArgumentException ThrowHelperArgument(string message);
    public ArgumentNullException ThrowHelperArgumentNull(string paramName, string message);
    public ArgumentException ThrowHelperArgumentNullOrEmptyString(string arg);
    public Exception ThrowHelperFatal(string message, Exception innerException);
    public Exception ThrowHelperInternal(bool fatal);
    public Exception ThrowHelperInvalidOperation(string message);
    public Exception ThrowHelperCallback(string message, Exception innerException);
    public Exception ThrowHelperCallback(Exception innerException);
    public Exception ThrowHelperCritical(Exception exception);
    internal Exception ThrowHelperXml(XmlReader reader, string message);
    internal Exception ThrowHelperXml(XmlReader reader, string message, Exception inner);
    internal static void UseActivityId(Guid activityId);
    internal static void ClearActivityId();
    public ArgumentException ThrowHelperArgument(string paramName, string message);
    internal Exception ThrowHelperError(Exception exception, Message message);
    public Exception ThrowHelperWarning(Exception exception);
    public Exception ThrowHelperError(Exception exception);
    internal Exception ThrowHelperError(Exception exception, Guid activityId, object source);
    internal Exception ThrowHelper(Exception exception, TraceEventType eventType);
    internal Exception ThrowHelper(Exception exception, EventLevel eventLevel);
    internal ArgumentNullException ThrowHelperArgumentNull(string paramName);
    internal Exception ThrowHelper(Exception exception, TraceEventType eventType, TraceRecord extendedData);
}
internal static class System.ServiceModel.Diagnostics.MessageLogger : object {
    [CompilerGeneratedAttribute]
private static bool <ShouldLogMalformed>k__BackingField;
    [CompilerGeneratedAttribute]
private static bool <LogMessagesAtTransportLevel>k__BackingField;
    [CompilerGeneratedAttribute]
private static bool <LogMessagesAtServiceLevel>k__BackingField;
    public static bool LoggingEnabled { get; }
    public static bool ShouldLogMalformed { get; public set; }
    public static bool LogMessagesAtTransportLevel { get; public set; }
    public static bool LogMessagesAtServiceLevel { get; public set; }
    public static bool get_LoggingEnabled();
    internal static void LogMessage(Message& message, int arg1);
    [CompilerGeneratedAttribute]
public static bool get_ShouldLogMalformed();
    [CompilerGeneratedAttribute]
public static void set_ShouldLogMalformed(bool value);
    internal static void LogMessage(Stream stream, MessageLoggingSource messageLoggingSource);
    [CompilerGeneratedAttribute]
public static bool get_LogMessagesAtTransportLevel();
    [CompilerGeneratedAttribute]
public static void set_LogMessagesAtTransportLevel(bool value);
    internal static void LogMessage(Message& message, MessageLoggingSource messageLoggingSource);
    [CompilerGeneratedAttribute]
public static bool get_LogMessagesAtServiceLevel();
    [CompilerGeneratedAttribute]
public static void set_LogMessagesAtServiceLevel(bool value);
    internal static void LogMessage(ArraySegment`1<byte> arraySegment, MessageLoggingSource messageLoggingSource);
    internal static void LogMessage(Message& message, XmlDictionaryReader xmlDictionaryReader, MessageLoggingSource messageLoggingSource);
}
[FlagsAttribute]
internal enum System.ServiceModel.Diagnostics.MessageLoggingSource : Enum {
    public int value__;
    public static MessageLoggingSource None;
    public static MessageLoggingSource TransportReceive;
    public static MessageLoggingSource TransportSend;
    public static MessageLoggingSource Transport;
    public static MessageLoggingSource ServiceLevelReceiveDatagram;
    public static MessageLoggingSource ServiceLevelSendDatagram;
    public static MessageLoggingSource ServiceLevelReceiveRequest;
    public static MessageLoggingSource ServiceLevelSendRequest;
    public static MessageLoggingSource ServiceLevelReceiveReply;
    public static MessageLoggingSource ServiceLevelSendReply;
    public static MessageLoggingSource ServiceLevelReceive;
    public static MessageLoggingSource ServiceLevelSend;
    public static MessageLoggingSource ServiceLevelService;
    public static MessageLoggingSource ServiceLevelProxy;
    public static MessageLoggingSource ServiceLevel;
    public static MessageLoggingSource Malformed;
    public static MessageLoggingSource LastChance;
    public static MessageLoggingSource All;
}
internal class System.ServiceModel.Diagnostics.MessageTraceRecord : TraceRecord {
}
internal class System.ServiceModel.Diagnostics.MessageTransmitTraceRecord : MessageTraceRecord {
}
internal class System.ServiceModel.Diagnostics.SecurityTraceRecord : TraceRecord {
    private string _traceName;
    internal string EventId { get; }
    internal SecurityTraceRecord(string traceName);
    internal virtual string get_EventId();
}
internal static class System.ServiceModel.Diagnostics.SecurityTraceRecordHelper : object {
    internal static void TraceIdentityVerificationSuccess(EventTraceActivity eventTraceActivity, EndpointIdentity identity, Claim claim, Type identityVerifier);
    internal static void TraceIdentityVerificationFailure(EndpointIdentity identity, AuthorizationContext authContext, Type identityVerifier);
    internal static void TraceIdentityDeterminationSuccess(EndpointAddress epr, EndpointIdentity identity, Type identityVerifier);
    internal static void TraceIdentityDeterminationFailure(EndpointAddress epr, Type identityVerifier);
    internal static void TraceTokenProviderOpened(EventTraceActivity eventTraceActivity, SecurityTokenProvider provider);
}
internal class System.ServiceModel.Diagnostics.ServiceModelActivity : object {
    [ThreadStaticAttribute]
private static ServiceModelActivity s_currentActivity;
    private static String[] s_activityTypeNames;
    private bool _autoStop;
    private bool _autoResume;
    private bool _disposed;
    private bool _isAsync;
    private int _stopCount;
    private static int AsyncStopCount;
    private TransferActivity _activity;
    [CompilerGeneratedAttribute]
private ActivityType <ActivityType>k__BackingField;
    [CompilerGeneratedAttribute]
private ServiceModelActivity <PreviousActivity>k__BackingField;
    [CompilerGeneratedAttribute]
private Guid <Id>k__BackingField;
    [CompilerGeneratedAttribute]
private ActivityState <LastState>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Name>k__BackingField;
    internal ActivityType ActivityType { get; private set; }
    internal ServiceModelActivity PreviousActivity { get; }
    internal static ServiceModelActivity Current { get; private set; }
    internal Guid Id { get; }
    private ActivityState LastState { get; private set; }
    internal string Name { get; internal set; }
    private static ServiceModelActivity();
    private ServiceModelActivity(Guid activityId);
    [CompilerGeneratedAttribute]
internal ActivityType get_ActivityType();
    [CompilerGeneratedAttribute]
private void set_ActivityType(ActivityType value);
    [CompilerGeneratedAttribute]
internal ServiceModelActivity get_PreviousActivity();
    internal static Activity BoundOperation(ServiceModelActivity activity);
    internal static Activity BoundOperation(ServiceModelActivity activity, bool addTransfer);
    private static Activity BoundOperationCore(ServiceModelActivity activity, bool addTransfer);
    internal static ServiceModelActivity CreateActivity();
    internal static ServiceModelActivity CreateActivity(bool autoStop);
    internal static ServiceModelActivity CreateActivity(bool autoStop, string activityName, ActivityType activityType);
    internal static ServiceModelActivity CreateAsyncActivity();
    internal static ServiceModelActivity CreateBoundedActivity();
    internal static ServiceModelActivity CreateBoundedActivity(bool suspendCurrent);
    internal static ServiceModelActivity CreateBoundedActivity(Guid activityId);
    internal static ServiceModelActivity CreateBoundedActivityWithTransferInOnly(Guid activityId);
    internal static ServiceModelActivity CreateLightWeightAsyncActivity(Guid activityId);
    internal static ServiceModelActivity CreateActivity(Guid activityId);
    internal static ServiceModelActivity CreateActivity(Guid activityId, bool autoStop);
    internal static ServiceModelActivity get_Current();
    private static void set_Current(ServiceModelActivity value);
    public sealed virtual void Dispose();
    [CompilerGeneratedAttribute]
internal Guid get_Id();
    [CompilerGeneratedAttribute]
private ActivityState get_LastState();
    [CompilerGeneratedAttribute]
private void set_LastState(ActivityState value);
    [CompilerGeneratedAttribute]
internal string get_Name();
    [CompilerGeneratedAttribute]
internal void set_Name(string value);
    internal void Resume();
    internal void Resume(string activityName);
    internal static void Start(ServiceModelActivity activity, string activityName, ActivityType activityType);
    internal void Stop();
    internal static void Stop(ServiceModelActivity activity);
    internal void Suspend();
    public virtual string ToString();
}
internal abstract class System.ServiceModel.Diagnostics.TraceAsyncResult : AsyncResult {
    private static Action`2<AsyncCallback, IAsyncResult> s_waitResultCallback;
    [CompilerGeneratedAttribute]
private ServiceModelActivity <CallbackActivity>k__BackingField;
    public ServiceModelActivity CallbackActivity { get; private set; }
    protected TraceAsyncResult(AsyncCallback callback, object state);
    private static TraceAsyncResult();
    [CompilerGeneratedAttribute]
public ServiceModelActivity get_CallbackActivity();
    [CompilerGeneratedAttribute]
private void set_CallbackActivity(ServiceModelActivity value);
    private static void DoCallback(AsyncCallback callback, IAsyncResult result);
}
internal static class System.ServiceModel.Diagnostics.TraceCode : object {
    public static int Administration;
    public static int WmiPut;
    public static int Diagnostics;
    public static int AppDomainUnload;
    public static int EventLog;
    public static int ThrowingException;
    public static int TraceHandledException;
    public static int UnhandledException;
    public static int FailedToAddAnActivityIdHeader;
    public static int FailedToReadAnActivityIdHeader;
    public static int FilterNotMatchedNodeQuotaExceeded;
    public static int MessageCountLimitExceeded;
    public static int DiagnosticsFailedMessageTrace;
    public static int MessageNotLoggedQuotaExceeded;
    public static int TraceTruncatedQuotaExceeded;
    public static int ActivityBoundary;
    public static int Serialization;
    public static int ElementIgnored;
    public static int Channels;
    public static int ConnectionAbandoned;
    public static int ConnectionPoolCloseException;
    public static int ConnectionPoolIdleTimeoutReached;
    public static int ConnectionPoolLeaseTimeoutReached;
    public static int ConnectionPoolMaxOutboundConnectionsPerEndpointQuotaReached;
    public static int ServerMaxPooledConnectionsQuotaReached;
    public static int EndpointListenerClose;
    public static int EndpointListenerOpen;
    public static int HttpResponseReceived;
    public static int HttpChannelConcurrentReceiveQuotaReached;
    public static int HttpChannelMessageReceiveFailed;
    public static int HttpChannelUnexpectedResponse;
    public static int HttpChannelRequestAborted;
    public static int HttpChannelResponseAborted;
    public static int HttpsClientCertificateInvalid;
    public static int HttpsClientCertificateNotPresent;
    public static int NamedPipeChannelMessageReceiveFailed;
    public static int NamedPipeChannelMessageReceived;
    public static int MessageReceived;
    public static int MessageSent;
    public static int RequestChannelReplyReceived;
    public static int TcpChannelMessageReceiveFailed;
    public static int TcpChannelMessageReceived;
    public static int ConnectToIPEndpoint;
    public static int SocketConnectionCreate;
    public static int SocketConnectionClose;
    public static int SocketConnectionAbort;
    public static int SocketConnectionAbortClose;
    public static int PipeConnectionAbort;
    public static int RequestContextAbort;
    public static int ChannelCreated;
    public static int ChannelDisposed;
    public static int ListenerCreated;
    public static int ListenerDisposed;
    public static int PrematureDatagramEof;
    public static int MaxPendingConnectionsReached;
    public static int MaxAcceptedChannelsReached;
    public static int ChannelConnectionDropped;
    public static int HttpAuthFailed;
    public static int NoExistingTransportManager;
    public static int IncompatibleExistingTransportManager;
    public static int InitiatingNamedPipeConnection;
    public static int InitiatingTcpConnection;
    public static int OpenedListener;
    public static int SslClientCertMissing;
    public static int StreamSecurityUpgradeAccepted;
    public static int TcpConnectError;
    public static int FailedAcceptFromPool;
    public static int FailedPipeConnect;
    public static int SystemTimeResolution;
    public static int PeerNeighborCloseFailed;
    public static int PeerNeighborClosingFailed;
    public static int PeerNeighborNotAccepted;
    public static int PeerNeighborNotFound;
    public static int PeerNeighborOpenFailed;
    public static int PeerNeighborStateChanged;
    public static int PeerNeighborStateChangeFailed;
    public static int PeerNeighborMessageReceived;
    public static int PeerNeighborManagerOffline;
    public static int PeerNeighborManagerOnline;
    public static int PeerChannelMessageReceived;
    public static int PeerChannelMessageSent;
    public static int PeerNodeAddressChanged;
    public static int PeerNodeOpening;
    public static int PeerNodeOpened;
    public static int PeerNodeOpenFailed;
    public static int PeerNodeClosing;
    public static int PeerNodeClosed;
    public static int PeerFloodedMessageReceived;
    public static int PeerFloodedMessageNotPropagated;
    public static int PeerFloodedMessageNotMatched;
    public static int PnrpRegisteredAddresses;
    public static int PnrpUnregisteredAddresses;
    public static int PnrpResolvedAddresses;
    public static int PnrpResolveException;
    public static int PeerReceiveMessageAuthenticationFailure;
    public static int PeerNodeAuthenticationFailure;
    public static int PeerNodeAuthenticationTimeout;
    public static int PeerFlooderReceiveMessageQuotaExceeded;
    public static int PeerServiceOpened;
    public static int PeerMaintainerActivity;
    public static int WsrmNegativeElapsedTimeDetected;
    public static int TcpTransferError;
    public static int TcpConnectionResetError;
    public static int TcpConnectionTimedOut;
    public static int ComIntegration;
    public static int ComIntegrationServiceHostStartingService;
    public static int ComIntegrationServiceHostStartedService;
    public static int ComIntegrationServiceHostCreatedServiceContract;
    public static int ComIntegrationServiceHostStartedServiceDetails;
    public static int ComIntegrationServiceHostCreatedServiceEndpoint;
    public static int ComIntegrationServiceHostStoppingService;
    public static int ComIntegrationServiceHostStoppedService;
    public static int ComIntegrationDllHostInitializerStarting;
    public static int ComIntegrationDllHostInitializerAddingHost;
    public static int ComIntegrationDllHostInitializerStarted;
    public static int ComIntegrationDllHostInitializerStopping;
    public static int ComIntegrationDllHostInitializerStopped;
    public static int ComIntegrationTLBImportStarting;
    public static int ComIntegrationTLBImportFromAssembly;
    public static int ComIntegrationTLBImportFromTypelib;
    public static int ComIntegrationTLBImportConverterEvent;
    public static int ComIntegrationTLBImportFinished;
    public static int ComIntegrationInstanceCreationRequest;
    public static int ComIntegrationInstanceCreationSuccess;
    public static int ComIntegrationInstanceReleased;
    public static int ComIntegrationEnteringActivity;
    public static int ComIntegrationExecutingCall;
    public static int ComIntegrationLeftActivity;
    public static int ComIntegrationInvokingMethod;
    public static int ComIntegrationInvokedMethod;
    public static int ComIntegrationInvokingMethodNewTransaction;
    public static int ComIntegrationInvokingMethodContextTransaction;
    public static int ComIntegrationServiceMonikerParsed;
    public static int ComIntegrationWsdlChannelBuilderLoaded;
    public static int ComIntegrationTypedChannelBuilderLoaded;
    public static int ComIntegrationChannelCreated;
    public static int ComIntegrationDispatchMethod;
    public static int ComIntegrationTxProxyTxCommitted;
    public static int ComIntegrationTxProxyTxAbortedByContext;
    public static int ComIntegrationTxProxyTxAbortedByTM;
    public static int ComIntegrationMexMonikerMetadataExchangeComplete;
    public static int ComIntegrationMexChannelBuilderLoaded;
    public static int Security;
    public static int SecurityIdentityVerificationSuccess;
    public static int SecurityIdentityVerificationFailure;
    public static int SecurityIdentityDeterminationSuccess;
    public static int SecurityIdentityDeterminationFailure;
    public static int SecurityIdentityHostNameNormalizationFailure;
    public static int SecurityImpersonationSuccess;
    public static int SecurityImpersonationFailure;
    public static int SecurityNegotiationProcessingFailure;
    public static int IssuanceTokenProviderRemovedCachedToken;
    public static int IssuanceTokenProviderUsingCachedToken;
    public static int IssuanceTokenProviderBeginSecurityNegotiation;
    public static int IssuanceTokenProviderEndSecurityNegotiation;
    public static int IssuanceTokenProviderRedirectApplied;
    public static int IssuanceTokenProviderServiceTokenCacheFull;
    public static int NegotiationTokenProviderAttached;
    public static int SpnegoClientNegotiationCompleted;
    public static int SpnegoServiceNegotiationCompleted;
    public static int SpnegoClientNegotiation;
    public static int SpnegoServiceNegotiation;
    public static int NegotiationAuthenticatorAttached;
    public static int ServiceSecurityNegotiationCompleted;
    public static int SecurityContextTokenCacheFull;
    public static int ExportSecurityChannelBindingEntry;
    public static int ExportSecurityChannelBindingExit;
    public static int ImportSecurityChannelBindingEntry;
    public static int ImportSecurityChannelBindingExit;
    public static int SecurityTokenProviderOpened;
    public static int SecurityTokenProviderClosed;
    public static int SecurityTokenAuthenticatorOpened;
    public static int SecurityTokenAuthenticatorClosed;
    public static int SecurityBindingOutgoingMessageSecured;
    public static int SecurityBindingIncomingMessageVerified;
    public static int SecurityBindingSecureOutgoingMessageFailure;
    public static int SecurityBindingVerifyIncomingMessageFailure;
    public static int SecuritySpnToSidMappingFailure;
    public static int SecuritySessionRedirectApplied;
    public static int SecurityClientSessionCloseSent;
    public static int SecurityClientSessionCloseResponseSent;
    public static int SecurityClientSessionCloseMessageReceived;
    public static int SecuritySessionKeyRenewalFaultReceived;
    public static int SecuritySessionAbortedFaultReceived;
    public static int SecuritySessionClosedResponseReceived;
    public static int SecurityClientSessionPreviousKeyDiscarded;
    public static int SecurityClientSessionKeyRenewed;
    public static int SecurityPendingServerSessionAdded;
    public static int SecurityPendingServerSessionClosed;
    public static int SecurityPendingServerSessionActivated;
    public static int SecurityActiveServerSessionRemoved;
    public static int SecurityNewServerSessionKeyIssued;
    public static int SecurityInactiveSessionFaulted;
    public static int SecurityServerSessionKeyUpdated;
    public static int SecurityServerSessionCloseReceived;
    public static int SecurityServerSessionRenewalFaultSent;
    public static int SecurityServerSessionAbortedFaultSent;
    public static int SecuritySessionCloseResponseSent;
    public static int SecuritySessionServerCloseSent;
    public static int SecurityServerSessionCloseResponseReceived;
    public static int SecuritySessionRenewFaultSendFailure;
    public static int SecuritySessionAbortedFaultSendFailure;
    public static int SecuritySessionClosedResponseSendFailure;
    public static int SecuritySessionServerCloseSendFailure;
    public static int SecuritySessionRequestorStartOperation;
    public static int SecuritySessionRequestorOperationSuccess;
    public static int SecuritySessionRequestorOperationFailure;
    public static int SecuritySessionResponderOperationFailure;
    public static int SecuritySessionDemuxFailure;
    public static int SecurityAuditWrittenSuccess;
    public static int SecurityAuditWrittenFailure;
    public static int ServiceModel;
    public static int AsyncCallbackThrewException;
    public static int CommunicationObjectAborted;
    public static int CommunicationObjectAbortFailed;
    public static int CommunicationObjectCloseFailed;
    public static int CommunicationObjectOpenFailed;
    public static int CommunicationObjectClosing;
    public static int CommunicationObjectClosed;
    public static int CommunicationObjectCreated;
    public static int CommunicationObjectDisposing;
    public static int CommunicationObjectFaultReason;
    public static int CommunicationObjectFaulted;
    public static int CommunicationObjectOpening;
    public static int CommunicationObjectOpened;
    public static int DidNotUnderstandMessageHeader;
    public static int UnderstoodMessageHeader;
    public static int MessageClosed;
    public static int MessageClosedAgain;
    public static int MessageCopied;
    public static int MessageRead;
    public static int MessageWritten;
    public static int BeginExecuteMethod;
    public static int ConfigurationIsReadOnly;
    public static int ConfiguredExtensionTypeNotFound;
    public static int EvaluationContextNotFound;
    public static int EndExecuteMethod;
    public static int ExtensionCollectionDoesNotExist;
    public static int ExtensionCollectionNameNotFound;
    public static int ExtensionCollectionIsEmpty;
    public static int ExtensionElementAlreadyExistsInCollection;
    public static int ElementTypeDoesntMatchConfiguredType;
    public static int ErrorInvokingUserCode;
    public static int GetBehaviorElement;
    public static int GetCommonBehaviors;
    public static int GetConfiguredBinding;
    public static int GetChannelEndpointElement;
    public static int GetConfigurationSection;
    public static int GetDefaultConfiguredBinding;
    public static int GetServiceElement;
    public static int MessageProcessingPaused;
    public static int ManualFlowThrottleLimitReached;
    public static int OverridingDuplicateConfigurationKey;
    public static int RemoveBehavior;
    public static int ServiceChannelLifetime;
    public static int ServiceHostCreation;
    public static int ServiceHostBaseAddresses;
    public static int ServiceHostTimeoutOnClose;
    public static int ServiceHostFaulted;
    public static int ServiceHostErrorOnReleasePerformanceCounter;
    public static int ServiceThrottleLimitReached;
    public static int ServiceOperationMissingReply;
    public static int ServiceOperationMissingReplyContext;
    public static int ServiceOperationExceptionOnReply;
    public static int SkipBehavior;
    public static int TransportListen;
    public static int UnhandledAction;
    public static int PerformanceCounterFailedToLoad;
    public static int PerformanceCountersFailed;
    public static int PerformanceCountersFailedDuringUpdate;
    public static int PerformanceCountersFailedForService;
    public static int PerformanceCountersFailedOnRelease;
    public static int WsmexNonCriticalWsdlExportError;
    public static int WsmexNonCriticalWsdlImportError;
    public static int FailedToOpenIncomingChannel;
    public static int UnhandledExceptionInUserOperation;
    public static int DroppedAMessage;
    public static int CannotBeImportedInCurrentFormat;
    public static int GetConfiguredEndpoint;
    public static int GetDefaultConfiguredEndpoint;
    public static int ExtensionTypeNotFound;
    public static int DefaultEndpointsAdded;
    public static int MetadataExchangeClientSendRequest;
    public static int MetadataExchangeClientReceiveReply;
    public static int WarnHelpPageEnabledNoBaseAddress;
    public static int PortSharing;
    public static int PortSharingClosed;
    public static int PortSharingDuplicatedPipe;
    public static int PortSharingDupHandleGranted;
    public static int PortSharingDuplicatedSocket;
    public static int PortSharingListening;
    public static int SharedManagerServiceEndpointNotExist;
    public static int ServiceModelTransaction;
    public static int TxSourceTxScopeRequiredIsTransactedTransport;
    public static int TxSourceTxScopeRequiredIsTransactionFlow;
    public static int TxSourceTxScopeRequiredIsAttachedTransaction;
    public static int TxSourceTxScopeRequiredIsCreateNewTransaction;
    public static int TxCompletionStatusCompletedForAutocomplete;
    public static int TxCompletionStatusCompletedForError;
    public static int TxCompletionStatusCompletedForSetComplete;
    public static int TxCompletionStatusCompletedForTACOSC;
    public static int TxCompletionStatusCompletedForAsyncAbort;
    public static int TxCompletionStatusRemainsAttached;
    public static int TxCompletionStatusAbortedOnSessionClose;
    public static int TxReleaseServiceInstanceOnCompletion;
    public static int TxAsyncAbort;
    public static int TxFailedToNegotiateOleTx;
    public static int TxSourceTxScopeRequiredUsingExistingTransaction;
    public static int NetFx35;
    public static int ActivatingMessageReceived;
    public static int InstanceContextBoundToDurableInstance;
    public static int InstanceContextDetachedFromDurableInstance;
    public static int ContextChannelFactoryChannelCreated;
    public static int ContextChannelListenerChannelAccepted;
    public static int ContextProtocolContextAddedToMessage;
    public static int ContextProtocolContextRetrievedFromMessage;
    public static int DICPInstanceContextCached;
    public static int DICPInstanceContextRemovedFromCache;
    public static int ServiceDurableInstanceDeleted;
    public static int ServiceDurableInstanceDisposed;
    public static int ServiceDurableInstanceLoaded;
    public static int ServiceDurableInstanceSaved;
    public static int SqlPersistenceProviderSQLCallStart;
    public static int SqlPersistenceProviderSQLCallEnd;
    public static int SqlPersistenceProviderOpenParameters;
    public static int SyncContextSchedulerServiceTimerCancelled;
    public static int SyncContextSchedulerServiceTimerCreated;
    public static int WorkflowDurableInstanceLoaded;
    public static int WorkflowDurableInstanceAborted;
    public static int WorkflowDurableInstanceActivated;
    public static int WorkflowOperationInvokerItemQueued;
    public static int WorkflowRequestContextReplySent;
    public static int WorkflowRequestContextFaultSent;
    public static int WorkflowServiceHostCreated;
    public static int SyndicationReadFeedBegin;
    public static int SyndicationReadFeedEnd;
    public static int SyndicationReadItemBegin;
    public static int SyndicationReadItemEnd;
    public static int SyndicationWriteFeedBegin;
    public static int SyndicationWriteFeedEnd;
    public static int SyndicationWriteItemBegin;
    public static int SyndicationWriteItemEnd;
    public static int SyndicationProtocolElementIgnoredOnRead;
    public static int SyndicationProtocolElementIgnoredOnWrite;
    public static int SyndicationProtocolElementInvalid;
    public static int WebUnknownQueryParameterIgnored;
    public static int WebRequestMatchesOperation;
    public static int WebRequestDoesNotMatchOperations;
    public static int WebRequestRedirect;
    public static int SyndicationReadServiceDocumentBegin;
    public static int SyndicationReadServiceDocumentEnd;
    public static int SyndicationReadCategoriesDocumentBegin;
    public static int SyndicationReadCategoriesDocumentEnd;
    public static int SyndicationWriteServiceDocumentBegin;
    public static int SyndicationWriteServiceDocumentEnd;
    public static int SyndicationWriteCategoriesDocumentBegin;
    public static int SyndicationWriteCategoriesDocumentEnd;
    public static int AutomaticFormatSelectedOperationDefault;
    public static int AutomaticFormatSelectedRequestBased;
    public static int RequestFormatSelectedFromContentTypeMapper;
    public static int RequestFormatSelectedByEncoderDefaults;
    public static int AddingResponseToOutputCache;
    public static int AddingAuthenticatedResponseToOutputCache;
    public static int JsonpCallbackNameSet;
}
internal static class System.ServiceModel.Diagnostics.TraceUtility : object {
    private static long s_messageNumber;
    private static string ActivityIdKey;
    private static string DiagnosticsNamespace;
    private static string AsyncOperationActivityKey;
    private static string AsyncOperationStartTimeKey;
    public static string E2EActivityId;
    public static string TraceApplicationReference;
    public static Func`1<Action`2<AsyncCallback, IAsyncResult>> asyncCallbackGenerator;
    public static bool PropagateUserActivity { get; }
    private static bool PropagateUserActivityCore { get; }
    internal static bool ShouldPropagateActivityGlobal { get; }
    internal static bool ActivityTracing { get; }
    internal static bool ShouldPropagateActivity { get; }
    internal static bool MessageFlowTracing { get; }
    internal static bool MessageFlowTracingOnly { get; }
    private static TraceUtility();
    internal static void AddActivityHeader(Message message);
    internal static void AddAmbientActivityToMessage(Message message);
    internal static void CopyActivity(Message source, Message destination);
    internal static void SetActivity(Message message, ServiceModelActivity activity);
    internal static long GetUtcBasedDurationForTrace(long startTicks);
    internal static ServiceModelActivity ExtractActivity(Message message);
    internal static string GetAnnotation(OperationContext context);
    internal static Guid GetReceivedActivityId(OperationContext operationContext);
    internal static ServiceModelActivity ExtractAndRemoveActivity(Message message);
    internal static void MessageFlowAtMessageSent(Message message, EventTraceActivity eventTraceActivity);
    internal static void MessageFlowAtMessageReceived(Message message, OperationContext context, EventTraceActivity eventTraceActivity, bool createNewActivityId);
    internal static void ProcessIncomingMessage(Message message, EventTraceActivity eventTraceActivity);
    internal static void ProcessOutgoingMessage(Message message, EventTraceActivity eventTraceActivity);
    public static bool get_PropagateUserActivity();
    private static bool get_PropagateUserActivityCore();
    internal static string CreateSourceString(object source);
    internal static string GetCallerInfo(OperationContext context);
    internal static void SetActivityId(MessageProperties properties);
    internal static void UpdateAsyncOperationContextWithActivity(object activity);
    internal static object ExtractAsyncOperationContextActivity();
    internal static void UpdateAsyncOperationContextWithStartTime(EventTraceActivity eventTraceActivity, long startTime);
    internal static void ExtractAsyncOperationStartTime(EventTraceActivity& eventTraceActivity, Int64& startTime);
    internal static bool get_ShouldPropagateActivityGlobal();
    internal static bool get_ActivityTracing();
    internal static void TraceDroppedMessage(Message message, EndpointDispatcher dispatcher);
    internal static Exception ThrowHelperWarning(Exception exception, Message message);
    internal static AsyncCallback WrapExecuteUserCodeAsyncCallback(AsyncCallback callback);
    public static InputQueue`1<T> CreateInputQueue();
    internal static Action`2<AsyncCallback, IAsyncResult> CallbackGenerator();
    internal static Guid ExtractActivityId(Message message);
    internal static Exception ThrowHelperError(Exception exception, Message message);
    internal static Exception ThrowHelperError(Exception exception, Guid activityId, object source);
    internal static ArgumentException ThrowHelperArgument(string paramName, string message, Message msg);
    internal static ArgumentNullException ThrowHelperArgumentNull(string paramName, Message message);
    internal static void TraceHttpConnectionInformation(string localEndpoint, string remoteEndpoint, object source);
    internal static void TraceUserCodeException(Exception e, MethodInfo method);
    private static void SetEndToEndTracingFlags();
    public static long RetrieveMessageNumber();
    internal static void SetEtwProviderId();
    internal static bool get_ShouldPropagateActivity();
    internal static bool get_MessageFlowTracing();
    internal static bool get_MessageFlowTracingOnly();
    internal static void TransferFromTransport(Message message);
    internal static void TraceEvent(TraceEventType severity, int traceCode, string traceDescription);
    internal static void TraceEvent(TraceEventType severity, int traceCode, string traceDescription, object source);
    internal static void TraceEvent(TraceEventType severity, int traceCode, string traceDescription, TraceRecord extendedData, object source, Exception exception);
}
internal static class System.ServiceModel.DiagnosticUtility : object {
    internal static string DefaultTraceListenerName;
    private static string TraceSourceName;
    internal static string EventSourceName;
    private static ExceptionUtility s_exceptionUtility;
    private static bool s_shouldUseActivity;
    private static object s_lockObject;
    internal static bool ShouldUseActivity { get; }
    public static ExceptionUtility ExceptionUtility { get; }
    internal static bool ShouldTraceCritical { get; }
    internal static bool ShouldTraceError { get; }
    internal static bool ShouldTraceWarning { get; }
    internal static bool ShouldTraceInformation { get; }
    internal static bool ShouldTraceVerbose { get; }
    internal static bool TracingEnabled { get; }
    private static DiagnosticUtility();
    internal static bool get_ShouldUseActivity();
    public static ExceptionUtility get_ExceptionUtility();
    private static ExceptionUtility GetExceptionUtility();
    internal static void TraceHandledException(Exception exception, TraceEventType traceEventType);
    internal static bool ShouldTrace(TraceEventType type);
    internal static bool get_ShouldTraceCritical();
    internal static bool get_ShouldTraceError();
    internal static bool get_ShouldTraceWarning();
    internal static bool get_ShouldTraceInformation();
    internal static bool get_ShouldTraceVerbose();
    internal static bool get_TracingEnabled();
    [ConditionalAttribute("DEBUG")]
internal static void DebugAssert(bool condition, string message);
    [ConditionalAttribute("DEBUG")]
internal static void DebugAssert(string message);
}
internal class System.ServiceModel.Dispatcher.BufferedReceiveBinder : object {
    private static Action`1<object> s_tryReceive;
    private static AsyncCallback s_tryReceiveCallback;
    private IChannelBinder _channelBinder;
    private InputQueue`1<RequestContextWrapper> _inputQueue;
    private int _pendingOperationSemaphore;
    public IChannel Channel { get; }
    public bool HasSession { get; }
    public Uri ListenUri { get; }
    public EndpointAddress LocalAddress { get; }
    public EndpointAddress RemoteAddress { get; }
    public BufferedReceiveBinder(IChannelBinder channelBinder);
    private static BufferedReceiveBinder();
    public sealed virtual IChannel get_Channel();
    public sealed virtual bool get_HasSession();
    public sealed virtual Uri get_ListenUri();
    public sealed virtual EndpointAddress get_LocalAddress();
    public sealed virtual EndpointAddress get_RemoteAddress();
    public sealed virtual void Abort();
    public sealed virtual void CloseAfterFault(TimeSpan timeout);
    public sealed virtual bool TryReceive(TimeSpan timeout, RequestContext& requestContext);
    public sealed virtual IAsyncResult BeginTryReceive(TimeSpan timeout, AsyncCallback callback, object state);
    public sealed virtual bool EndTryReceive(IAsyncResult result, RequestContext& requestContext);
    public sealed virtual RequestContext CreateRequestContext(Message message);
    public sealed virtual void Send(Message message, TimeSpan timeout);
    public sealed virtual IAsyncResult BeginSend(Message message, TimeSpan timeout, AsyncCallback callback, object state);
    public sealed virtual void EndSend(IAsyncResult result);
    public sealed virtual Message Request(Message message, TimeSpan timeout);
    public sealed virtual IAsyncResult BeginRequest(Message message, TimeSpan timeout, AsyncCallback callback, object state);
    public sealed virtual Message EndRequest(IAsyncResult result);
    public sealed virtual bool WaitForMessage(TimeSpan timeout);
    public sealed virtual IAsyncResult BeginWaitForMessage(TimeSpan timeout, AsyncCallback callback, object state);
    public sealed virtual bool EndWaitForMessage(IAsyncResult result);
    internal void InjectRequest(RequestContext requestContext);
    private static void TryReceive(object state);
    private static void TryReceiveCallback(IAsyncResult result);
    private static void HandleEndTryReceive(IAsyncResult result);
}
public class System.ServiceModel.Dispatcher.ChannelDispatcher : ChannelDispatcherBase {
    private SynchronizedCollection`1<IChannelInitializer> _channelInitializers;
    private EndpointDispatcherCollection _endpointDispatchers;
    private bool _receiveContextEnabled;
    private IChannelListener _listener;
    private ListenerHandler _listenerHandler;
    private int _maxTransactedBatchSize;
    private MessageVersion _messageVersion;
    private bool _receiveSynchronously;
    private bool _sendAsynchronously;
    private int _maxPendingReceives;
    private bool _includeExceptionDetailInFaults;
    private bool _session;
    private SharedRuntimeState _shared;
    private TimeSpan _transactionTimeout;
    private bool _performDefaultCloseInput;
    private EventTraceActivity _eventTraceActivity;
    private ErrorBehavior _errorBehavior;
    [CompilerGeneratedAttribute]
private EndpointDispatcherTable <EndpointDispatcherTable>k__BackingField;
    [CompilerGeneratedAttribute]
private CommunicationObjectManager`1<IChannel> <Channels>k__BackingField;
    [CompilerGeneratedAttribute]
private Collection`1<IErrorHandler> <ErrorHandlers>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <BufferedReceiveEnabled>k__BackingField;
    [CompilerGeneratedAttribute]
private SynchronizedChannelCollection`1<IChannel> <PendingChannels>k__BackingField;
    [CompilerGeneratedAttribute]
private IDefaultCommunicationTimeouts <DefaultCommunicationTimeouts>k__BackingField;
    protected TimeSpan DefaultCloseTimeout { get; }
    protected TimeSpan DefaultOpenTimeout { get; }
    internal EndpointDispatcherTable EndpointDispatcherTable { get; private set; }
    internal CommunicationObjectManager`1<IChannel> Channels { get; private set; }
    public SynchronizedCollection`1<EndpointDispatcher> Endpoints { get; }
    public Collection`1<IErrorHandler> ErrorHandlers { get; private set; }
    public MessageVersion MessageVersion { get; public set; }
    internal bool EnableFaults { get; internal set; }
    internal bool IsOnServer { get; }
    public bool ReceiveContextEnabled { get; public set; }
    internal bool BufferedReceiveEnabled { get; internal set; }
    public IChannelListener Listener { get; }
    public int MaxTransactedBatchSize { get; public set; }
    public bool ManualAddressing { get; public set; }
    internal SynchronizedChannelCollection`1<IChannel> PendingChannels { get; private set; }
    public bool ReceiveSynchronously { get; public set; }
    public bool SendAsynchronously { get; public set; }
    public int MaxPendingReceives { get; public set; }
    public bool IncludeExceptionDetailInFaults { get; public set; }
    internal IDefaultCommunicationTimeouts DefaultCommunicationTimeouts { get; }
    internal ChannelDispatcher(SharedRuntimeState shared);
    private void Initialize(SharedRuntimeState shared);
    protected virtual TimeSpan get_DefaultCloseTimeout();
    protected virtual TimeSpan get_DefaultOpenTimeout();
    [CompilerGeneratedAttribute]
internal EndpointDispatcherTable get_EndpointDispatcherTable();
    [CompilerGeneratedAttribute]
private void set_EndpointDispatcherTable(EndpointDispatcherTable value);
    [CompilerGeneratedAttribute]
internal CommunicationObjectManager`1<IChannel> get_Channels();
    [CompilerGeneratedAttribute]
private void set_Channels(CommunicationObjectManager`1<IChannel> value);
    public SynchronizedCollection`1<EndpointDispatcher> get_Endpoints();
    [CompilerGeneratedAttribute]
public Collection`1<IErrorHandler> get_ErrorHandlers();
    [CompilerGeneratedAttribute]
private void set_ErrorHandlers(Collection`1<IErrorHandler> value);
    public MessageVersion get_MessageVersion();
    public void set_MessageVersion(MessageVersion value);
    internal bool get_EnableFaults();
    internal void set_EnableFaults(bool value);
    internal bool get_IsOnServer();
    public bool get_ReceiveContextEnabled();
    public void set_ReceiveContextEnabled(bool value);
    [CompilerGeneratedAttribute]
internal bool get_BufferedReceiveEnabled();
    [CompilerGeneratedAttribute]
internal void set_BufferedReceiveEnabled(bool value);
    public virtual IChannelListener get_Listener();
    public int get_MaxTransactedBatchSize();
    public void set_MaxTransactedBatchSize(int value);
    public bool get_ManualAddressing();
    public void set_ManualAddressing(bool value);
    [CompilerGeneratedAttribute]
internal SynchronizedChannelCollection`1<IChannel> get_PendingChannels();
    [CompilerGeneratedAttribute]
private void set_PendingChannels(SynchronizedChannelCollection`1<IChannel> value);
    public bool get_ReceiveSynchronously();
    public void set_ReceiveSynchronously(bool value);
    public bool get_SendAsynchronously();
    public void set_SendAsynchronously(bool value);
    public int get_MaxPendingReceives();
    public void set_MaxPendingReceives(int value);
    public bool get_IncludeExceptionDetailInFaults();
    public void set_IncludeExceptionDetailInFaults(bool value);
    [CompilerGeneratedAttribute]
internal IDefaultCommunicationTimeouts get_DefaultCommunicationTimeouts();
    private void AbortPendingChannels();
    internal virtual void CloseInput(TimeSpan timeout);
    public virtual void CloseInput();
    private void OnListenerFaulted(object sender, EventArgs e);
    internal bool HandleError(Exception error);
    internal bool HandleError(Exception error, ErrorHandlerFaultInfo& faultInfo);
    internal void InitializeChannel(IClientChannel channel);
    internal SynchronizedCollection`1<T> NewBehaviorCollection();
    private void OnAddEndpoint(EndpointDispatcher endpoint);
    private void OnRemoveEndpoint(EndpointDispatcher endpoint);
    protected virtual void OnAbort();
    protected virtual void OnClose(TimeSpan timeout);
    protected virtual IAsyncResult OnBeginClose(TimeSpan timeout, AsyncCallback callback, object state);
    protected virtual void OnEndClose(IAsyncResult result);
    protected virtual void OnClosed();
    protected virtual void OnOpen(TimeSpan timeout);
    protected internal virtual Task OnCloseAsync(TimeSpan timeout);
    protected internal virtual Task OnOpenAsync(TimeSpan timeout);
    private InvalidOperationException CreateOuterExceptionWithEndpointsInformation(InvalidOperationException e);
    internal string CreateContractListString();
    protected virtual IAsyncResult OnBeginOpen(TimeSpan timeout, AsyncCallback callback, object state);
    protected virtual void OnEndOpen(IAsyncResult result);
    protected virtual void OnOpening();
    protected virtual void OnOpened();
    internal void ProvideFault(Exception e, FaultConverter faultConverter, ErrorHandlerFaultInfo& faultInfo);
    internal void ThrowIfDisposedOrImmutable();
    private void ThrowIfNoMessageVersion();
}
public abstract class System.ServiceModel.Dispatcher.ChannelDispatcherBase : CommunicationObject {
    public IChannelListener Listener { get; }
    public abstract virtual IChannelListener get_Listener();
    public virtual void CloseInput();
    internal virtual void CloseInput(TimeSpan timeout);
}
internal class System.ServiceModel.Dispatcher.ChannelHandler : object {
    public static TimeSpan CloseAfterFaultTimeout;
    public static string MessageBufferPropertyName;
    private DuplexChannelBinder _duplexBinder;
    private bool _incrementedActivityCountInConstructor;
    private bool _isCallback;
    private ListenerHandler _listener;
    private SessionIdleManager _idleManager;
    private bool _sendAsynchronously;
    private static AsyncCallback s_onAsyncReplyComplete;
    private static AsyncCallback s_onAsyncReceiveComplete;
    private static Action`1<object> s_onContinueAsyncReceive;
    private static Action`1<object> s_onStartSyncMessagePump;
    private static Action`1<object> s_onStartAsyncMessagePump;
    private static Action`1<object> s_openAndEnsurePump;
    private RequestInfo _requestInfo;
    private bool _doneReceiving;
    private bool _hasSession;
    private int _isPumpAcquired;
    private bool _isChannelTerminated;
    private bool _isConcurrent;
    private bool _isManualAddressing;
    private MessageVersion _messageVersion;
    private ErrorHandlingReceiver _receiver;
    private bool _receiveSynchronously;
    private RequestContext _replied;
    private EventTraceActivity _eventTraceActivity;
    private bool _shouldRejectMessageWithOnOpenActionHeader;
    private object _acquirePumpLock;
    [CompilerGeneratedAttribute]
private IChannelBinder <Binder>k__BackingField;
    [CompilerGeneratedAttribute]
private ServiceChannel <Channel>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <HasRegisterBeenCalled>k__BackingField;
    internal IChannelBinder Binder { get; }
    internal ServiceChannel Channel { get; private set; }
    internal bool HasRegisterBeenCalled { get; private set; }
    private bool IsOpen { get; }
    private object ThisLock { get; }
    private EventTraceActivity EventTraceActivity { get; }
    internal ChannelHandler(MessageVersion messageVersion, IChannelBinder binder, ServiceChannel channel);
    internal ChannelHandler(MessageVersion messageVersion, IChannelBinder binder, ListenerHandler listener, SessionIdleManager idleManager);
    private static ChannelHandler();
    [CompilerGeneratedAttribute]
internal IChannelBinder get_Binder();
    [CompilerGeneratedAttribute]
internal ServiceChannel get_Channel();
    [CompilerGeneratedAttribute]
private void set_Channel(ServiceChannel value);
    [CompilerGeneratedAttribute]
internal bool get_HasRegisterBeenCalled();
    [CompilerGeneratedAttribute]
private void set_HasRegisterBeenCalled(bool value);
    private bool get_IsOpen();
    private object get_ThisLock();
    private EventTraceActivity get_EventTraceActivity();
    internal static void Register(ChannelHandler handler);
    internal static void Register(ChannelHandler handler, RequestContext request);
    private void Register();
    private void AsyncMessagePump();
    private void AsyncMessagePump(IAsyncResult result);
    private IAsyncResult BeginTryReceive();
    private bool DispatchAndReleasePump(RequestContext request, bool cleanThread, OperationContext currentOperationContext);
    internal void DispatchDone();
    private bool EndTryReceive(IAsyncResult result, RequestContext& requestContext);
    private void EnsureChannelAndEndpoint(RequestContext request);
    private void EnsurePump();
    private ServiceChannel GetDatagramChannel(Message message, EndpointDispatcher& endpoint, Boolean& addressMatched);
    private EndpointDispatcher GetEndpointDispatcher(Message message, Boolean& addressMatched);
    private ServiceChannel GetSessionChannel(Message message, EndpointDispatcher& endpoint, Boolean& addressMatched);
    private void InitializeServiceChannel(ServiceChannel channel);
    private void ProvideFault(Exception e, ErrorHandlerFaultInfo& faultInfo);
    internal bool HandleError(Exception e);
    private bool HandleError(Exception e, ErrorHandlerFaultInfo& faultInfo);
    private bool HandleError(Exception e, RequestContext request, ServiceChannel channel);
    private bool HandleErrorContinuation(Exception e, RequestContext request, ServiceChannel channel, ErrorHandlerFaultInfo& faultInfo, bool replied);
    private void HandleReceiveComplete(RequestContext context);
    private bool HandleRequest(RequestContext request, OperationContext currentOperationContext);
    private bool HandleRequestAsReply(RequestContext request);
    private static void OnStartAsyncMessagePump(object state);
    private static void OnStartSyncMessagePump(object state);
    private static void OnAsyncReceiveComplete(IAsyncResult result);
    private static void OnContinueAsyncReceive(object state);
    private static void OpenAndEnsurePump(object state);
    private void OpenAndEnsurePump();
    private bool TryReceive(TimeSpan timeout, RequestContext& requestContext);
    private void ReplyAddressFilterDidNotMatch(RequestContext request);
    private void ReplyContractFilterDidNotMatch(RequestContext request);
    private void ReplyChannelTerminated(RequestContext request);
    private void ReplyFailure(RequestContext request, FaultCode code, string reason);
    private void ReplyFailure(RequestContext request, FaultCode code, string reason, string action);
    private void ReplyFailure(RequestContext request, Message fault, string action, string reason, FaultCode code);
    private void ProvideFaultAndReplyFailure(RequestContext request, Exception exception, ErrorHandlerFaultInfo& faultInfo, Boolean& replied, Boolean& replySentAsync);
    private bool PrepareReply(RequestContext request, Message reply);
    private static void AsyncReplyComplete(IAsyncResult result, ContinuationState state);
    private static void OnAsyncReplyComplete(IAsyncResult result);
    private void ReleasePump();
    private void SyncMessagePump();
    private bool TryRetrievingInstanceContext(RequestContext request);
    private bool TryAcquirePump();
    private EventTraceActivity TraceDispatchMessageStart(Message message);
}
public class System.ServiceModel.Dispatcher.ClientOperation : ClientOperationCompatBase {
    private bool _serializeRequest;
    private bool _deserializeReply;
    private IClientFaultFormatter _faultFormatter;
    private bool _isInitiating;
    private bool _isOneWay;
    private bool _isTerminating;
    private bool _isSessionOpenNotificationEnabled;
    private ClientRuntime _parent;
    private MethodInfo _beginMethod;
    private MethodInfo _endMethod;
    private MethodInfo _syncMethod;
    private MethodInfo _taskMethod;
    private Type _taskTResult;
    [CompilerGeneratedAttribute]
private string <Action>k__BackingField;
    [CompilerGeneratedAttribute]
private SynchronizedCollection`1<FaultContractInfo> <FaultContractInfos>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsFaultFormatterSetExplicit>k__BackingField;
    [CompilerGeneratedAttribute]
private IClientMessageFormatter <InternalFormatter>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Name>k__BackingField;
    [CompilerGeneratedAttribute]
private string <ReplyAction>k__BackingField;
    public string Action { get; }
    public SynchronizedCollection`1<FaultContractInfo> FaultContractInfos { get; }
    public MethodInfo BeginMethod { get; public set; }
    public MethodInfo EndMethod { get; public set; }
    public MethodInfo SyncMethod { get; public set; }
    public IClientMessageFormatter Formatter { get; public set; }
    internal IClientFaultFormatter FaultFormatter { get; internal set; }
    internal bool IsFaultFormatterSetExplicit { get; private set; }
    internal IClientMessageFormatter InternalFormatter { get; internal set; }
    public bool IsInitiating { get; public set; }
    public bool IsOneWay { get; public set; }
    public bool IsTerminating { get; public set; }
    public string Name { get; }
    public ICollection`1<IParameterInspector> ClientParameterInspectors { get; }
    [EditorBrowsableAttribute("1")]
public SynchronizedCollection`1<IParameterInspector> ParameterInspectors { get; }
    public ClientRuntime Parent { get; }
    public string ReplyAction { get; }
    public bool SerializeRequest { get; public set; }
    public bool DeserializeReply { get; public set; }
    public MethodInfo TaskMethod { get; public set; }
    public Type TaskTResult { get; public set; }
    internal bool IsSessionOpenNotificationEnabled { get; internal set; }
    public ClientOperation(ClientRuntime parent, string name, string action);
    public ClientOperation(ClientRuntime parent, string name, string action, string replyAction);
    [CompilerGeneratedAttribute]
public string get_Action();
    [CompilerGeneratedAttribute]
public SynchronizedCollection`1<FaultContractInfo> get_FaultContractInfos();
    public MethodInfo get_BeginMethod();
    public void set_BeginMethod(MethodInfo value);
    public MethodInfo get_EndMethod();
    public void set_EndMethod(MethodInfo value);
    public MethodInfo get_SyncMethod();
    public void set_SyncMethod(MethodInfo value);
    public IClientMessageFormatter get_Formatter();
    public void set_Formatter(IClientMessageFormatter value);
    internal IClientFaultFormatter get_FaultFormatter();
    internal void set_FaultFormatter(IClientFaultFormatter value);
    [CompilerGeneratedAttribute]
internal bool get_IsFaultFormatterSetExplicit();
    [CompilerGeneratedAttribute]
private void set_IsFaultFormatterSetExplicit(bool value);
    [CompilerGeneratedAttribute]
internal IClientMessageFormatter get_InternalFormatter();
    [CompilerGeneratedAttribute]
internal void set_InternalFormatter(IClientMessageFormatter value);
    public bool get_IsInitiating();
    public void set_IsInitiating(bool value);
    public bool get_IsOneWay();
    public void set_IsOneWay(bool value);
    public bool get_IsTerminating();
    public void set_IsTerminating(bool value);
    [CompilerGeneratedAttribute]
public string get_Name();
    public ICollection`1<IParameterInspector> get_ClientParameterInspectors();
    public SynchronizedCollection`1<IParameterInspector> get_ParameterInspectors();
    public ClientRuntime get_Parent();
    [CompilerGeneratedAttribute]
public string get_ReplyAction();
    public bool get_SerializeRequest();
    public void set_SerializeRequest(bool value);
    public bool get_DeserializeReply();
    public void set_DeserializeReply(bool value);
    public MethodInfo get_TaskMethod();
    public void set_TaskMethod(MethodInfo value);
    public Type get_TaskTResult();
    public void set_TaskTResult(Type value);
    internal bool get_IsSessionOpenNotificationEnabled();
    internal void set_IsSessionOpenNotificationEnabled(bool value);
}
[EditorBrowsableAttribute("1")]
public class System.ServiceModel.Dispatcher.ClientOperationCompatBase : object {
    internal SynchronizedCollection`1<IParameterInspector> parameterInspectors;
    [EditorBrowsableAttribute("1")]
[ObsoleteAttribute("This API supports the .NET Framework infrastructure and is not intended to be used directly from your code.", "True")]
public IList`1<IParameterInspector> ParameterInspectors { get; }
    public IList`1<IParameterInspector> get_ParameterInspectors();
}
public class System.ServiceModel.Dispatcher.ClientRuntime : ClientRuntimeCompatBase {
    private bool _addTransactionFlowProperties;
    private Type _callbackProxyType;
    private ProxyBehaviorCollection`1<IChannelInitializer> _channelInitializers;
    private string _contractNamespace;
    private Type _contractProxyType;
    private IdentityVerifier _identityVerifier;
    private ProxyBehaviorCollection`1<IInteractiveChannelInitializer> _interactiveChannelInitializers;
    private IClientOperationSelector _operationSelector;
    private ImmutableClientRuntime _runtime;
    private bool _useSynchronizationContext;
    private Uri _via;
    private SharedRuntimeState _shared;
    private int _maxFaultSize;
    private bool _messageVersionNoneFaultsEnabled;
    [CompilerGeneratedAttribute]
private string <ContractName>k__BackingField;
    [CompilerGeneratedAttribute]
private DispatchRuntime <DispatchRuntime>k__BackingField;
    [CompilerGeneratedAttribute]
private ClientOperation <UnhandledClientOperation>k__BackingField;
    internal bool AddTransactionFlowProperties { get; internal set; }
    public Type CallbackClientType { get; public set; }
    public SynchronizedCollection`1<IChannelInitializer> ChannelInitializers { get; }
    public string ContractName { get; }
    public string ContractNamespace { get; }
    public Type ContractClientType { get; public set; }
    internal IdentityVerifier IdentityVerifier { get; internal set; }
    public Uri Via { get; public set; }
    public bool ValidateMustUnderstand { get; public set; }
    public bool MessageVersionNoneFaultsEnabled { get; public set; }
    public DispatchRuntime DispatchRuntime { get; private set; }
    public DispatchRuntime CallbackDispatchRuntime { get; }
    internal bool EnableFaults { get; internal set; }
    public SynchronizedCollection`1<IInteractiveChannelInitializer> InteractiveChannelInitializers { get; }
    public int MaxFaultSize { get; public set; }
    internal bool IsOnServer { get; }
    public bool ManualAddressing { get; public set; }
    internal int MaxParameterInspectors { get; }
    public ICollection`1<IClientMessageInspector> ClientMessageInspectors { get; }
    [EditorBrowsableAttribute("1")]
public SynchronizedCollection`1<IClientMessageInspector> MessageInspectors { get; }
    public ICollection`1<ClientOperation> ClientOperations { get; }
    [EditorBrowsableAttribute("1")]
public SynchronizedKeyedCollection`2<string, ClientOperation> Operations { get; }
    public IClientOperationSelector OperationSelector { get; public set; }
    internal object ThisLock { get; }
    public ClientOperation UnhandledClientOperation { get; }
    internal bool UseSynchronizationContext { get; internal set; }
    internal ClientRuntime(DispatchRuntime dispatchRuntime, SharedRuntimeState shared);
    internal ClientRuntime(string contractName, string contractNamespace);
    private ClientRuntime(string contractName, string contractNamespace, SharedRuntimeState shared);
    internal bool get_AddTransactionFlowProperties();
    internal void set_AddTransactionFlowProperties(bool value);
    public Type get_CallbackClientType();
    public void set_CallbackClientType(Type value);
    public SynchronizedCollection`1<IChannelInitializer> get_ChannelInitializers();
    [CompilerGeneratedAttribute]
public string get_ContractName();
    public string get_ContractNamespace();
    public Type get_ContractClientType();
    public void set_ContractClientType(Type value);
    internal IdentityVerifier get_IdentityVerifier();
    internal void set_IdentityVerifier(IdentityVerifier value);
    public Uri get_Via();
    public void set_Via(Uri value);
    public bool get_ValidateMustUnderstand();
    public void set_ValidateMustUnderstand(bool value);
    public bool get_MessageVersionNoneFaultsEnabled();
    public void set_MessageVersionNoneFaultsEnabled(bool value);
    [CompilerGeneratedAttribute]
public DispatchRuntime get_DispatchRuntime();
    [CompilerGeneratedAttribute]
private void set_DispatchRuntime(DispatchRuntime value);
    public DispatchRuntime get_CallbackDispatchRuntime();
    internal bool get_EnableFaults();
    internal void set_EnableFaults(bool value);
    public SynchronizedCollection`1<IInteractiveChannelInitializer> get_InteractiveChannelInitializers();
    public int get_MaxFaultSize();
    public void set_MaxFaultSize(int value);
    internal bool get_IsOnServer();
    public bool get_ManualAddressing();
    public void set_ManualAddressing(bool value);
    internal int get_MaxParameterInspectors();
    public ICollection`1<IClientMessageInspector> get_ClientMessageInspectors();
    public SynchronizedCollection`1<IClientMessageInspector> get_MessageInspectors();
    public ICollection`1<ClientOperation> get_ClientOperations();
    public SynchronizedKeyedCollection`2<string, ClientOperation> get_Operations();
    public IClientOperationSelector get_OperationSelector();
    public void set_OperationSelector(IClientOperationSelector value);
    internal object get_ThisLock();
    [CompilerGeneratedAttribute]
public ClientOperation get_UnhandledClientOperation();
    internal bool get_UseSynchronizationContext();
    internal void set_UseSynchronizationContext(bool value);
    internal T[] GetArray(SynchronizedCollection`1<T> collection);
    internal ImmutableClientRuntime GetRuntime();
    internal void InvalidateRuntime();
    internal void LockDownProperties();
    internal SynchronizedCollection`1<T> NewBehaviorCollection();
    internal bool IsFault(Message& reply);
    internal static bool IsMessageVersionNoneFault(Message& message, int maxFaultSize);
}
[EditorBrowsableAttribute("1")]
public class System.ServiceModel.Dispatcher.ClientRuntimeCompatBase : object {
    internal SynchronizedCollection`1<IClientMessageInspector> _messageInspectors;
    internal SynchronizedKeyedCollection`2<string, ClientOperation> _operations;
    internal KeyedCollection`2<string, ClientOperation> _compatOperations;
    [EditorBrowsableAttribute("1")]
[ObsoleteAttribute("This API supports the .NET Framework infrastructure and is not intended to be used directly from your code.", "True")]
public IList`1<IClientMessageInspector> MessageInspectors { get; }
    [EditorBrowsableAttribute("1")]
[ObsoleteAttribute("This API supports the .NET Framework infrastructure and is not intended to be used directly from your code.", "True")]
public KeyedCollection`2<string, ClientOperation> Operations { get; }
    public IList`1<IClientMessageInspector> get_MessageInspectors();
    public KeyedCollection`2<string, ClientOperation> get_Operations();
}
internal class System.ServiceModel.Dispatcher.ConcurrencyBehavior : object {
    private ConcurrencyMode _concurrencyMode;
    private bool _enforceOrderedReceive;
    internal ConcurrencyBehavior(DispatchRuntime runtime);
    internal bool IsConcurrent(MessageRpc& rpc);
    internal static bool IsConcurrent(ConcurrencyMode concurrencyMode, bool ensureOrderedDispatch, bool hasSession);
    internal static bool IsConcurrent(ChannelDispatcher runtime, bool hasSession);
    internal void LockInstance(MessageRpc& rpc);
    internal void UnlockInstance(MessageRpc& rpc);
    internal static void UnlockInstanceBeforeCallout(OperationContext operationContext);
    private static void UnlockInstance(InstanceContext instanceContext);
    internal static void LockInstanceAfterCallout(OperationContext operationContext);
}
internal class System.ServiceModel.Dispatcher.ConcurrencyInstanceContextFacet : object {
    internal bool Locked;
    private Queue`1<IWaiter> _calloutMessageQueue;
    private Queue`1<IWaiter> _newMessageQueue;
    internal bool HasWaiters { get; }
    internal bool get_HasWaiters();
    private IWaiter DequeueFrom(Queue`1<IWaiter> queue);
    internal IWaiter DequeueWaiter();
    internal void EnqueueNewMessage(IWaiter waiter);
    internal void EnqueueCalloutMessage(IWaiter waiter);
}
internal static class System.ServiceModel.Dispatcher.DataContractSerializerDefaults : object {
    internal static bool IgnoreExtensionDataObject;
    internal static int MaxItemsInObjectGraph;
    internal static DataContractSerializer CreateSerializer(Type type, int maxItems);
    internal static DataContractSerializer CreateSerializer(Type type, IList`1<Type> knownTypes, int maxItems);
    internal static DataContractSerializer CreateSerializer(Type type, string rootName, string rootNs, int maxItems);
    internal static DataContractSerializer CreateSerializer(Type type, IList`1<Type> knownTypes, string rootName, string rootNs, int maxItems);
    internal static DataContractSerializer CreateSerializer(Type type, XmlDictionaryString rootName, XmlDictionaryString rootNs, int maxItems);
    internal static DataContractSerializer CreateSerializer(Type type, IList`1<Type> knownTypes, XmlDictionaryString rootName, XmlDictionaryString rootNs, int maxItems);
}
internal class System.ServiceModel.Dispatcher.DataContractSerializerFaultFormatter : FaultFormatter {
    internal DataContractSerializerFaultFormatter(Type[] detailTypes);
    internal DataContractSerializerFaultFormatter(SynchronizedCollection`1<FaultContractInfo> faultContractInfoCollection);
}
internal class System.ServiceModel.Dispatcher.DataContractSerializerOperationFormatter : OperationFormatter {
    private static Type s_typeOfIQueryable;
    private static Type s_typeOfIQueryableGeneric;
    private static Type s_typeOfIEnumerable;
    private static Type s_typeOfIEnumerableGeneric;
    protected MessageInfo requestMessageInfo;
    protected MessageInfo replyMessageInfo;
    private IList`1<Type> _knownTypes;
    private DataContractSerializerOperationBehavior _serializerFactory;
    public DataContractSerializerOperationFormatter(OperationDescription description, DataContractFormatAttribute dataContractFormatAttribute, DataContractSerializerOperationBehavior serializerFactory);
    private static DataContractSerializerOperationFormatter();
    private MessageInfo CreateMessageInfo(DataContractFormatAttribute dataContractFormatAttribute, MessageDescription messageDescription, DataContractSerializerOperationBehavior serializerFactory);
    private void ValidateDataContractType(Type type);
    private PartInfo CreatePartInfo(MessagePartDescription part, OperationFormatStyle style, DataContractSerializerOperationBehavior serializerFactory);
    protected virtual void AddHeadersToMessage(Message message, MessageDescription messageDescription, Object[] parameters, bool isRequest);
    private void AddMessageHeaderForParameter(MessageHeaders headers, PartInfo headerPart, MessageVersion messageVersion, object parameterValue, bool isXmlElement);
    protected virtual void SerializeBody(XmlDictionaryWriter writer, MessageVersion version, string action, MessageDescription messageDescription, object returnValue, Object[] parameters, bool isRequest);
    private void SerializeParameters(XmlDictionaryWriter writer, PartInfo[] parts, Object[] parameters);
    private void SerializeParameter(XmlDictionaryWriter writer, PartInfo part, object graph);
    private void SerializeParameterPart(XmlDictionaryWriter writer, PartInfo part, object graph);
    protected virtual void GetHeadersFromMessage(Message message, MessageDescription messageDescription, Object[] parameters, bool isRequest);
    private object DeserializeHeaderContents(XmlDictionaryReader reader, MessageDescription messageDescription, MessageHeaderDescription headerDescription);
    protected virtual object DeserializeBody(XmlDictionaryReader reader, MessageVersion version, string action, MessageDescription messageDescription, Object[] parameters, bool isRequest);
    private void DeserializeParameters(XmlDictionaryReader reader, PartInfo[] parts, Object[] parameters, bool isRequest);
    private object DeserializeParameter(XmlDictionaryReader reader, PartInfo part, bool isRequest);
    private object DeserializeParameterPart(XmlDictionaryReader reader, PartInfo part, bool isRequest);
    internal static Type GetSubstituteDataContractType(Type type, Boolean& isQueryable);
}
public class System.ServiceModel.Dispatcher.DispatchOperation : object {
    private SynchronizedCollection`1<FaultContractInfo> _faultContractInfos;
    private IDispatchFaultFormatter _faultFormatter;
    private bool _isTerminating;
    private bool _isSessionOpenNotificationEnabled;
    private string _replyAction;
    private bool _deserializeRequest;
    private bool _serializeReply;
    private bool _autoDisposeParameters;
    private bool _isFaultFormatterSetExplicit;
    [CompilerGeneratedAttribute]
private bool <IsOneWay>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Action>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <HasNoDisposableParameters>k__BackingField;
    [CompilerGeneratedAttribute]
private IDispatchMessageFormatter <InternalFormatter>k__BackingField;
    [CompilerGeneratedAttribute]
private IOperationInvoker <InternalInvoker>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Name>k__BackingField;
    [CompilerGeneratedAttribute]
private SynchronizedCollection`1<IParameterInspector> <ParameterInspectors>k__BackingField;
    [CompilerGeneratedAttribute]
private DispatchRuntime <Parent>k__BackingField;
    public bool IsOneWay { get; }
    public string Action { get; }
    public SynchronizedCollection`1<FaultContractInfo> FaultContractInfos { get; }
    public bool AutoDisposeParameters { get; public set; }
    internal IDispatchMessageFormatter Formatter { get; internal set; }
    internal IDispatchFaultFormatter FaultFormatter { get; internal set; }
    internal bool IsFaultFormatterSetExplicit { get; }
    internal bool HasNoDisposableParameters { get; internal set; }
    internal IDispatchMessageFormatter InternalFormatter { get; internal set; }
    internal IOperationInvoker InternalInvoker { get; internal set; }
    public IOperationInvoker Invoker { get; public set; }
    public bool IsTerminating { get; public set; }
    internal bool IsSessionOpenNotificationEnabled { get; internal set; }
    public string Name { get; }
    public SynchronizedCollection`1<IParameterInspector> ParameterInspectors { get; }
    public DispatchRuntime Parent { get; }
    public string ReplyAction { get; }
    public bool DeserializeRequest { get; public set; }
    public bool SerializeReply { get; public set; }
    public DispatchOperation(DispatchRuntime parent, string name, string action);
    public DispatchOperation(DispatchRuntime parent, string name, string action, string replyAction);
    [CompilerGeneratedAttribute]
public bool get_IsOneWay();
    [CompilerGeneratedAttribute]
public string get_Action();
    public SynchronizedCollection`1<FaultContractInfo> get_FaultContractInfos();
    public bool get_AutoDisposeParameters();
    public void set_AutoDisposeParameters(bool value);
    internal IDispatchMessageFormatter get_Formatter();
    internal void set_Formatter(IDispatchMessageFormatter value);
    internal IDispatchFaultFormatter get_FaultFormatter();
    internal void set_FaultFormatter(IDispatchFaultFormatter value);
    internal bool get_IsFaultFormatterSetExplicit();
    [CompilerGeneratedAttribute]
internal bool get_HasNoDisposableParameters();
    [CompilerGeneratedAttribute]
internal void set_HasNoDisposableParameters(bool value);
    [CompilerGeneratedAttribute]
internal IDispatchMessageFormatter get_InternalFormatter();
    [CompilerGeneratedAttribute]
internal void set_InternalFormatter(IDispatchMessageFormatter value);
    [CompilerGeneratedAttribute]
internal IOperationInvoker get_InternalInvoker();
    [CompilerGeneratedAttribute]
internal void set_InternalInvoker(IOperationInvoker value);
    public IOperationInvoker get_Invoker();
    public void set_Invoker(IOperationInvoker value);
    public bool get_IsTerminating();
    public void set_IsTerminating(bool value);
    internal bool get_IsSessionOpenNotificationEnabled();
    internal void set_IsSessionOpenNotificationEnabled(bool value);
    [CompilerGeneratedAttribute]
public string get_Name();
    [CompilerGeneratedAttribute]
public SynchronizedCollection`1<IParameterInspector> get_ParameterInspectors();
    [CompilerGeneratedAttribute]
public DispatchRuntime get_Parent();
    public string get_ReplyAction();
    public bool get_DeserializeRequest();
    public void set_DeserializeRequest(bool value);
    public bool get_SerializeReply();
    public void set_SerializeReply(bool value);
}
internal class System.ServiceModel.Dispatcher.DispatchOperationRuntime : object {
    private static AsyncCallback s_invokeCallback;
    private bool _isSessionOpenNotificationEnabled;
    private bool _deserializeRequest;
    private bool _serializeReply;
    private bool _disposeParameters;
    [CompilerGeneratedAttribute]
private string <Action>k__BackingField;
    [CompilerGeneratedAttribute]
private IDispatchFaultFormatter <FaultFormatter>k__BackingField;
    [CompilerGeneratedAttribute]
private IDispatchMessageFormatter <Formatter>k__BackingField;
    [CompilerGeneratedAttribute]
private IOperationInvoker <Invoker>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsOneWay>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsTerminating>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Name>k__BackingField;
    [CompilerGeneratedAttribute]
private IParameterInspector[] <ParameterInspectors>k__BackingField;
    [CompilerGeneratedAttribute]
private ImmutableDispatchRuntime <Parent>k__BackingField;
    [CompilerGeneratedAttribute]
private string <ReplyAction>k__BackingField;
    internal string Action { get; }
    internal bool DisposeParameters { get; }
    internal IDispatchFaultFormatter FaultFormatter { get; }
    internal IDispatchMessageFormatter Formatter { get; }
    internal IOperationInvoker Invoker { get; }
    internal bool IsOneWay { get; }
    internal bool IsTerminating { get; }
    internal string Name { get; }
    internal IParameterInspector[] ParameterInspectors { get; }
    internal ImmutableDispatchRuntime Parent { get; }
    internal string ReplyAction { get; }
    internal DispatchOperationRuntime(DispatchOperation operation, ImmutableDispatchRuntime parent);
    private static DispatchOperationRuntime();
    [CompilerGeneratedAttribute]
internal string get_Action();
    internal bool get_DisposeParameters();
    [CompilerGeneratedAttribute]
internal IDispatchFaultFormatter get_FaultFormatter();
    [CompilerGeneratedAttribute]
internal IDispatchMessageFormatter get_Formatter();
    [CompilerGeneratedAttribute]
internal IOperationInvoker get_Invoker();
    [CompilerGeneratedAttribute]
internal bool get_IsOneWay();
    [CompilerGeneratedAttribute]
internal bool get_IsTerminating();
    [CompilerGeneratedAttribute]
internal string get_Name();
    [CompilerGeneratedAttribute]
internal IParameterInspector[] get_ParameterInspectors();
    [CompilerGeneratedAttribute]
internal ImmutableDispatchRuntime get_Parent();
    [CompilerGeneratedAttribute]
internal string get_ReplyAction();
    private void DeserializeInputs(MessageRpc& rpc);
    private void InspectInputs(MessageRpc& rpc);
    private void InspectInputsCore(MessageRpc& rpc);
    private void InspectOutputs(MessageRpc& rpc);
    private void InspectOutputsCore(MessageRpc& rpc);
    internal void InvokeBegin(MessageRpc& rpc);
    private static void InvokeCallback(IAsyncResult result);
    internal void InvokeEnd(MessageRpc& rpc);
    private void SerializeOutputs(MessageRpc& rpc);
    private void ValidateMustUnderstand(MessageRpc& rpc);
}
public class System.ServiceModel.Dispatcher.DispatchRuntime : object {
    private ConcurrencyMode _concurrencyMode;
    private bool _ensureOrderedDispatch;
    private bool _automaticInputSessionShutdown;
    private ChannelDispatcher _channelDispatcher;
    private IInstanceProvider _instanceProvider;
    private IInstanceContextProvider _instanceContextProvider;
    private SynchronizedCollection`1<IDispatchMessageInspector> _messageInspectors;
    private OperationCollection _operations;
    private ImmutableDispatchRuntime _runtime;
    private SynchronizationContext _synchronizationContext;
    private Type _type;
    private DispatchOperation _unhandled;
    private SharedRuntimeState _shared;
    [CompilerGeneratedAttribute]
private EndpointDispatcher <EndpointDispatcher>k__BackingField;
    [CompilerGeneratedAttribute]
private ClientRuntime <ClientRuntime>k__BackingField;
    public IInstanceContextProvider InstanceContextProvider { get; public set; }
    public ConcurrencyMode ConcurrencyMode { get; public set; }
    public bool EnsureOrderedDispatch { get; public set; }
    public bool AutomaticInputSessionShutdown { get; public set; }
    public ChannelDispatcher ChannelDispatcher { get; }
    public ClientRuntime CallbackClientRuntime { get; }
    public EndpointDispatcher EndpointDispatcher { get; }
    public IInstanceProvider InstanceProvider { get; public set; }
    public SynchronizedCollection`1<IDispatchMessageInspector> MessageInspectors { get; }
    public SynchronizedKeyedCollection`2<string, DispatchOperation> Operations { get; }
    public SynchronizationContext SynchronizationContext { get; public set; }
    public Type Type { get; public set; }
    public DispatchOperation UnhandledDispatchOperation { get; public set; }
    internal bool HasMatchAllOperation { get; }
    internal bool EnableFaults { get; }
    internal bool IsOnServer { get; }
    internal bool ManualAddressing { get; }
    internal int MaxParameterInspectors { get; }
    internal ClientRuntime ClientRuntime { get; private set; }
    internal object ThisLock { get; }
    internal DispatchRuntime(ClientRuntime proxyRuntime, SharedRuntimeState shared);
    private DispatchRuntime(SharedRuntimeState shared);
    public IInstanceContextProvider get_InstanceContextProvider();
    public void set_InstanceContextProvider(IInstanceContextProvider value);
    public ConcurrencyMode get_ConcurrencyMode();
    public void set_ConcurrencyMode(ConcurrencyMode value);
    public bool get_EnsureOrderedDispatch();
    public void set_EnsureOrderedDispatch(bool value);
    public bool get_AutomaticInputSessionShutdown();
    public void set_AutomaticInputSessionShutdown(bool value);
    public ChannelDispatcher get_ChannelDispatcher();
    public ClientRuntime get_CallbackClientRuntime();
    [CompilerGeneratedAttribute]
public EndpointDispatcher get_EndpointDispatcher();
    public IInstanceProvider get_InstanceProvider();
    public void set_InstanceProvider(IInstanceProvider value);
    public SynchronizedCollection`1<IDispatchMessageInspector> get_MessageInspectors();
    public SynchronizedKeyedCollection`2<string, DispatchOperation> get_Operations();
    public SynchronizationContext get_SynchronizationContext();
    public void set_SynchronizationContext(SynchronizationContext value);
    public Type get_Type();
    public void set_Type(Type value);
    public DispatchOperation get_UnhandledDispatchOperation();
    public void set_UnhandledDispatchOperation(DispatchOperation value);
    internal bool get_HasMatchAllOperation();
    internal bool get_EnableFaults();
    internal bool get_IsOnServer();
    internal bool get_ManualAddressing();
    internal int get_MaxParameterInspectors();
    [CompilerGeneratedAttribute]
internal ClientRuntime get_ClientRuntime();
    [CompilerGeneratedAttribute]
private void set_ClientRuntime(ClientRuntime value);
    internal object get_ThisLock();
    internal DispatchOperationRuntime GetOperation(Message& message);
    internal ImmutableDispatchRuntime GetRuntime();
    private ImmutableDispatchRuntime GetRuntimeCore();
    internal void InvalidateRuntime();
    internal void LockDownProperties();
    internal SynchronizedCollection`1<T> NewBehaviorCollection();
}
internal class System.ServiceModel.Dispatcher.DuplexChannelBinder : object {
    private IDuplexChannel _channel;
    private IRequestReplyCorrelator _correlator;
    private TimeSpan _defaultSendTimeout;
    private IdentityVerifier _identityVerifier;
    private int _pending;
    private bool _syncPumpEnabled;
    private List`1<IDuplexRequest> _requests;
    private List`1<ICorrelatorKey> _timedOutRequests;
    private ChannelHandler _channelHandler;
    private Boolean modreq(System.Runtime.CompilerServices.IsVolatile) _requestAborted;
    [CompilerGeneratedAttribute]
private TimeSpan <DefaultCloseTimeout>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <HasSession>k__BackingField;
    [CompilerGeneratedAttribute]
private Uri <ListenUri>k__BackingField;
    public IChannel Channel { get; }
    public TimeSpan DefaultCloseTimeout { get; public set; }
    internal ChannelHandler ChannelHandler { get; internal set; }
    public TimeSpan DefaultSendTimeout { get; public set; }
    public bool HasSession { get; }
    internal IdentityVerifier IdentityVerifier { get; internal set; }
    public Uri ListenUri { get; }
    public EndpointAddress LocalAddress { get; }
    private bool Pumping { get; }
    public EndpointAddress RemoteAddress { get; }
    private List`1<IDuplexRequest> Requests { get; }
    private List`1<ICorrelatorKey> TimedOutRequests { get; }
    private object ThisLock { get; }
    internal DuplexChannelBinder(IDuplexChannel channel, IRequestReplyCorrelator correlator);
    internal DuplexChannelBinder(IDuplexChannel channel, IRequestReplyCorrelator correlator, Uri listenUri);
    internal DuplexChannelBinder(IDuplexSessionChannel channel, IRequestReplyCorrelator correlator, Uri listenUri);
    internal DuplexChannelBinder(IDuplexSessionChannel channel, IRequestReplyCorrelator correlator, bool useActiveAutoClose);
    public sealed virtual IChannel get_Channel();
    [CompilerGeneratedAttribute]
public TimeSpan get_DefaultCloseTimeout();
    [CompilerGeneratedAttribute]
public void set_DefaultCloseTimeout(TimeSpan value);
    internal ChannelHandler get_ChannelHandler();
    internal void set_ChannelHandler(ChannelHandler value);
    public TimeSpan get_DefaultSendTimeout();
    public void set_DefaultSendTimeout(TimeSpan value);
    [CompilerGeneratedAttribute]
public sealed virtual bool get_HasSession();
    internal IdentityVerifier get_IdentityVerifier();
    internal void set_IdentityVerifier(IdentityVerifier value);
    [CompilerGeneratedAttribute]
public sealed virtual Uri get_ListenUri();
    public sealed virtual EndpointAddress get_LocalAddress();
    private bool get_Pumping();
    public sealed virtual EndpointAddress get_RemoteAddress();
    private List`1<IDuplexRequest> get_Requests();
    private List`1<ICorrelatorKey> get_TimedOutRequests();
    private object get_ThisLock();
    private void OnFaulted(object sender, EventArgs e);
    public sealed virtual void Abort();
    public sealed virtual void CloseAfterFault(TimeSpan timeout);
    private void AbortRequests();
    private TimeoutException GetReceiveTimeoutException(TimeSpan timeout);
    internal bool HandleRequestAsReply(Message message);
    private bool HandleRequestAsReplyCore(Message message);
    public void EnsurePumping();
    public sealed virtual IAsyncResult BeginTryReceive(TimeSpan timeout, AsyncCallback callback, object state);
    public sealed virtual bool EndTryReceive(IAsyncResult result, RequestContext& requestContext);
    public sealed virtual RequestContext CreateRequestContext(Message message);
    public sealed virtual IAsyncResult BeginSend(Message message, TimeSpan timeout, AsyncCallback callback, object state);
    public sealed virtual void EndSend(IAsyncResult result);
    public sealed virtual void Send(Message message, TimeSpan timeout);
    public sealed virtual IAsyncResult BeginRequest(Message message, TimeSpan timeout, AsyncCallback callback, object state);
    public sealed virtual Message EndRequest(IAsyncResult result);
    public sealed virtual bool TryReceive(TimeSpan timeout, RequestContext& requestContext);
    public sealed virtual Message Request(Message message, TimeSpan timeout);
    private void RequestStarting(Message message, IDuplexRequest request);
    private void RequestCompleting(IDuplexRequest request);
    private void AddToTimedOutRequestList(ICorrelatorKey request);
    private void RemoveFromTimedOutRequestList(ICorrelatorKey request);
    private void DeleteTimedoutRequestsFromCorrelator();
    private void SendCallback(IAsyncResult result);
    public sealed virtual bool WaitForMessage(TimeSpan timeout);
    public sealed virtual IAsyncResult BeginWaitForMessage(TimeSpan timeout, AsyncCallback callback, object state);
    public sealed virtual bool EndWaitForMessage(IAsyncResult result);
}
internal class System.ServiceModel.Dispatcher.EndpointAddressProcessor : object {
    internal static string XsiNs;
    internal static string SerNs;
    internal static string TypeLN;
    internal static string ItemTypeLN;
    internal static string FactoryTypeLN;
    private static EndpointAddressProcessor();
    internal static string GetComparableForm(StringBuilder builder, XmlReader reader);
    private static void AppendString(StringBuilder builder, string s);
    private static void CompleteValue(StringBuilder builder, int startLength);
}
public class System.ServiceModel.Dispatcher.EndpointDispatcher : object {
    private Uri _listenUri;
    private EndpointAddress _originalAddress;
    [CompilerGeneratedAttribute]
private ChannelDispatcher <ChannelDispatcher>k__BackingField;
    [CompilerGeneratedAttribute]
private ServiceChannel <DatagramChannel>k__BackingField;
    [CompilerGeneratedAttribute]
private int <FilterPriority>k__BackingField;
    public ChannelDispatcher ChannelDispatcher { get; private set; }
    public string ContractName { get; }
    public string ContractNamespace { get; }
    internal ServiceChannel DatagramChannel { get; internal set; }
    public DispatchRuntime DispatchRuntime { get; }
    public EndpointAddress EndpointAddress { get; }
    public int FilterPriority { get; public set; }
    [CompilerGeneratedAttribute]
public ChannelDispatcher get_ChannelDispatcher();
    [CompilerGeneratedAttribute]
private void set_ChannelDispatcher(ChannelDispatcher value);
    public string get_ContractName();
    public string get_ContractNamespace();
    [CompilerGeneratedAttribute]
internal ServiceChannel get_DatagramChannel();
    [CompilerGeneratedAttribute]
internal void set_DatagramChannel(ServiceChannel value);
    public DispatchRuntime get_DispatchRuntime();
    public EndpointAddress get_EndpointAddress();
    [CompilerGeneratedAttribute]
public int get_FilterPriority();
    [CompilerGeneratedAttribute]
public void set_FilterPriority(int value);
    internal void Attach(ChannelDispatcher channelDispatcher);
    internal void Detach(ChannelDispatcher channelDispatcher);
}
internal class System.ServiceModel.Dispatcher.EndpointDispatcherTable : object {
    private static int optimizationThreshold;
    private List`1<EndpointDispatcher> _cachedEndpoints;
    [CompilerGeneratedAttribute]
private object <ThisLock>k__BackingField;
    private object ThisLock { get; }
    public EndpointDispatcherTable(object thisLock);
    [CompilerGeneratedAttribute]
private object get_ThisLock();
    public void AddEndpoint(EndpointDispatcher endpoint);
    public void RemoveEndpoint(EndpointDispatcher endpoint);
    public EndpointDispatcher Lookup(Message message, Boolean& addressMatched);
}
internal class System.ServiceModel.Dispatcher.ErrorBehavior : object {
    private IErrorHandler[] _handlers;
    private bool _debug;
    private bool _isOnServer;
    private MessageVersion _messageVersion;
    internal ErrorBehavior(ChannelDispatcher channelDispatcher);
    private void InitializeFault(MessageRpc& rpc);
    internal void ProvideMessageFault(MessageRpc& rpc);
    private void ProvideMessageFaultCore(MessageRpc& rpc);
    private void ProvideMessageFaultCoreCoda(MessageRpc& rpc);
    internal void ProvideOnlyFaultOfLastResort(MessageRpc& rpc);
    private void ProvideFaultOfLastResort(Exception error, ErrorHandlerFaultInfo& faultInfo);
    internal void ProvideFault(Exception e, FaultConverter faultConverter, ErrorHandlerFaultInfo& faultInfo);
    private void ProvideWellKnownFault(Exception e, FaultConverter faultConverter, ErrorHandlerFaultInfo& faultInfo);
    internal void HandleError(MessageRpc& rpc);
    private void HandleErrorCore(MessageRpc& rpc);
    private bool HandleErrorCommon(Exception error, ErrorHandlerFaultInfo& faultInfo);
    internal bool HandleError(Exception error);
    internal bool HandleError(Exception error, ErrorHandlerFaultInfo& faultInfo);
    internal static bool ShouldRethrowExceptionAsIs(Exception e);
    internal static bool ShouldRethrowClientSideExceptionAsIs(Exception e);
    internal static void ThrowAndCatch(Exception e, Message message);
    internal static void ThrowAndCatch(Exception e);
}
internal class System.ServiceModel.Dispatcher.ErrorHandlerFaultInfo : ValueType {
    private string _defaultFaultAction;
    [CompilerGeneratedAttribute]
private Message <Fault>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsConsideredUnhandled>k__BackingField;
    public Message Fault { get; public set; }
    public string DefaultFaultAction { get; public set; }
    public bool IsConsideredUnhandled { get; public set; }
    public ErrorHandlerFaultInfo(string defaultFaultAction);
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public Message get_Fault();
    [CompilerGeneratedAttribute]
public void set_Fault(Message value);
    public string get_DefaultFaultAction();
    public void set_DefaultFaultAction(string value);
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public bool get_IsConsideredUnhandled();
    [CompilerGeneratedAttribute]
public void set_IsConsideredUnhandled(bool value);
}
internal class System.ServiceModel.Dispatcher.ErrorHandlingReceiver : object {
    private ChannelDispatcher _dispatcher;
    private IChannelBinder _binder;
    internal ErrorHandlingReceiver(IChannelBinder binder, ChannelDispatcher dispatcher);
    internal void Close();
    private void HandleError(Exception e);
    private void HandleErrorOrAbort(Exception e);
    internal bool TryReceive(TimeSpan timeout, RequestContext& requestContext);
    internal IAsyncResult BeginTryReceive(TimeSpan timeout, AsyncCallback callback, object state);
    internal bool EndTryReceive(IAsyncResult result, RequestContext& requestContext);
}
public class System.ServiceModel.Dispatcher.FaultContractInfo : object {
    private string _ns;
    private DataContractSerializer _serializer;
    [CompilerGeneratedAttribute]
private string <Action>k__BackingField;
    [CompilerGeneratedAttribute]
private Type <Detail>k__BackingField;
    [CompilerGeneratedAttribute]
private string <ElementName>k__BackingField;
    [CompilerGeneratedAttribute]
private IList`1<Type> <KnownTypes>k__BackingField;
    public string Action { get; }
    public Type Detail { get; }
    internal string ElementName { get; }
    internal string ElementNamespace { get; }
    internal IList`1<Type> KnownTypes { get; }
    internal DataContractSerializer Serializer { get; }
    public FaultContractInfo(string action, Type detail);
    internal FaultContractInfo(string action, Type detail, XmlName elementName, string ns, IList`1<Type> knownTypes);
    [CompilerGeneratedAttribute]
public string get_Action();
    [CompilerGeneratedAttribute]
public Type get_Detail();
    [CompilerGeneratedAttribute]
internal string get_ElementName();
    internal string get_ElementNamespace();
    [CompilerGeneratedAttribute]
internal IList`1<Type> get_KnownTypes();
    internal DataContractSerializer get_Serializer();
}
public class System.ServiceModel.Dispatcher.FaultFormatter : object {
    private FaultContractInfo[] _faultContractInfos;
    internal FaultFormatter(Type[] detailTypes);
    internal FaultFormatter(SynchronizedCollection`1<FaultContractInfo> faultContractInfoCollection);
    public sealed virtual MessageFault Serialize(FaultException faultException, String& action);
    public sealed virtual FaultException Deserialize(MessageFault messageFault, string action);
    protected virtual XmlObjectSerializer GetSerializer(Type detailType, string faultExceptionAction, String& action);
    protected virtual FaultException CreateFaultException(MessageFault messageFault, string action);
    protected FaultException CreateFaultException(MessageFault messageFault, string action, object detailObj, Type detailType, XmlDictionaryReader detailReader);
    private static FaultContractInfo[] GetSortedArray(List`1<FaultContractInfo> faultContractInfoList);
    private static void AddInfrastructureFaults(List`1<FaultContractInfo> faultContractInfos);
    private static MessageFault CreateMessageFault(XmlObjectSerializer serializer, FaultException faultException, Type detailType);
}
internal abstract class System.ServiceModel.Dispatcher.HeaderFilter : MessageFilter {
    public virtual bool Match(MessageBuffer buffer);
}
internal interface System.ServiceModel.Dispatcher.IChannelBinder {
    public IChannel Channel { get; }
    public bool HasSession { get; }
    public Uri ListenUri { get; }
    public EndpointAddress LocalAddress { get; }
    public EndpointAddress RemoteAddress { get; }
    public abstract virtual IChannel get_Channel();
    public abstract virtual bool get_HasSession();
    public abstract virtual Uri get_ListenUri();
    public abstract virtual EndpointAddress get_LocalAddress();
    public abstract virtual EndpointAddress get_RemoteAddress();
    public abstract virtual void Abort();
    public abstract virtual void CloseAfterFault(TimeSpan timeout);
    public abstract virtual bool TryReceive(TimeSpan timeout, RequestContext& requestContext);
    public abstract virtual IAsyncResult BeginTryReceive(TimeSpan timeout, AsyncCallback callback, object state);
    public abstract virtual bool EndTryReceive(IAsyncResult result, RequestContext& requestContext);
    public abstract virtual void Send(Message message, TimeSpan timeout);
    public abstract virtual IAsyncResult BeginSend(Message message, TimeSpan timeout, AsyncCallback callback, object state);
    public abstract virtual void EndSend(IAsyncResult result);
    public abstract virtual Message Request(Message message, TimeSpan timeout);
    public abstract virtual IAsyncResult BeginRequest(Message message, TimeSpan timeout, AsyncCallback callback, object state);
    public abstract virtual Message EndRequest(IAsyncResult result);
    public abstract virtual bool WaitForMessage(TimeSpan timeout);
    public abstract virtual IAsyncResult BeginWaitForMessage(TimeSpan timeout, AsyncCallback callback, object state);
    public abstract virtual bool EndWaitForMessage(IAsyncResult result);
    public abstract virtual RequestContext CreateRequestContext(Message message);
}
public interface System.ServiceModel.Dispatcher.IChannelInitializer {
    public abstract virtual void Initialize(IClientChannel channel);
}
internal interface System.ServiceModel.Dispatcher.IClientFaultFormatter {
    public abstract virtual FaultException Deserialize(MessageFault messageFault, string action);
}
public interface System.ServiceModel.Dispatcher.IClientMessageFormatter {
    public abstract virtual Message SerializeRequest(MessageVersion messageVersion, Object[] parameters);
    public abstract virtual object DeserializeReply(Message message, Object[] parameters);
}
public interface System.ServiceModel.Dispatcher.IClientMessageInspector {
    public abstract virtual object BeforeSendRequest(Message& request, IClientChannel channel);
    public abstract virtual void AfterReceiveReply(Message& reply, object correlationState);
}
public interface System.ServiceModel.Dispatcher.IClientOperationSelector {
    public bool AreParametersRequiredForSelection { get; }
    public abstract virtual bool get_AreParametersRequiredForSelection();
    public abstract virtual string SelectOperation(MethodBase method, Object[] parameters);
}
internal interface System.ServiceModel.Dispatcher.IDispatchFaultFormatter {
    public abstract virtual MessageFault Serialize(FaultException faultException, String& action);
}
internal interface System.ServiceModel.Dispatcher.IDispatchMessageFormatter {
    public abstract virtual void DeserializeRequest(Message message, Object[] parameters);
    public abstract virtual Message SerializeReply(MessageVersion messageVersion, Object[] parameters, object result);
}
public interface System.ServiceModel.Dispatcher.IDispatchMessageInspector {
    public abstract virtual object AfterReceiveRequest(Message& request, IClientChannel channel, InstanceContext instanceContext);
    public abstract virtual void BeforeSendReply(Message& reply, object correlationState);
}
public interface System.ServiceModel.Dispatcher.IErrorHandler {
    public abstract virtual void ProvideFault(Exception error, MessageVersion version, Message& fault);
    public abstract virtual bool HandleError(Exception error);
}
public interface System.ServiceModel.Dispatcher.IInstanceContextProvider {
    public abstract virtual InstanceContext GetExistingInstanceContext(Message message, IContextChannel channel);
}
public interface System.ServiceModel.Dispatcher.IInstanceProvider {
    public abstract virtual object GetInstance(InstanceContext instanceContext);
    public abstract virtual object GetInstance(InstanceContext instanceContext, Message message);
    public abstract virtual void ReleaseInstance(InstanceContext instanceContext, object instance);
}
public interface System.ServiceModel.Dispatcher.IInteractiveChannelInitializer {
    public abstract virtual IAsyncResult BeginDisplayInitializationUI(IClientChannel channel, AsyncCallback callback, object state);
    public abstract virtual void EndDisplayInitializationUI(IAsyncResult result);
}
internal interface System.ServiceModel.Dispatcher.IInvokeReceivedNotification {
    public abstract virtual void NotifyInvokeReceived();
    public abstract virtual void NotifyInvokeReceived(RequestContext request);
}
internal interface System.ServiceModel.Dispatcher.IListenerBinder {
    public IChannelListener Listener { get; }
    public MessageVersion MessageVersion { get; }
    public abstract virtual IChannelListener get_Listener();
    public abstract virtual MessageVersion get_MessageVersion();
    public abstract virtual IChannelBinder Accept(TimeSpan timeout);
    public abstract virtual IAsyncResult BeginAccept(TimeSpan timeout, AsyncCallback callback, object state);
    public abstract virtual IChannelBinder EndAccept(IAsyncResult result);
}
public interface System.ServiceModel.Dispatcher.IMessageFilterTable`1 {
    public abstract virtual bool GetMatchingValue(Message message, TFilterData& value);
    public abstract virtual bool GetMatchingValue(MessageBuffer messageBuffer, TFilterData& value);
    public abstract virtual bool GetMatchingValues(Message message, ICollection`1<TFilterData> results);
    public abstract virtual bool GetMatchingValues(MessageBuffer messageBuffer, ICollection`1<TFilterData> results);
    public abstract virtual bool GetMatchingFilter(Message message, MessageFilter& filter);
    public abstract virtual bool GetMatchingFilter(MessageBuffer messageBuffer, MessageFilter& filter);
    public abstract virtual bool GetMatchingFilters(Message message, ICollection`1<MessageFilter> results);
    public abstract virtual bool GetMatchingFilters(MessageBuffer messageBuffer, ICollection`1<MessageFilter> results);
}
internal class System.ServiceModel.Dispatcher.ImmutableClientRuntime : object {
    private bool _addTransactionFlowProperties;
    private IInteractiveChannelInitializer[] _interactiveChannelInitializers;
    private IChannelInitializer[] _channelInitializers;
    private IClientMessageInspector[] _messageInspectors;
    private Dictionary`2<string, ProxyOperationRuntime> _operations;
    private bool _validateMustUnderstand;
    [CompilerGeneratedAttribute]
private int <CorrelationCount>k__BackingField;
    [CompilerGeneratedAttribute]
private IClientOperationSelector <OperationSelector>k__BackingField;
    [CompilerGeneratedAttribute]
private ProxyOperationRuntime <UnhandledProxyOperation>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <UseSynchronizationContext>k__BackingField;
    internal int MessageInspectorCorrelationOffset { get; }
    internal int ParameterInspectorCorrelationOffset { get; }
    internal int CorrelationCount { get; }
    internal IClientOperationSelector OperationSelector { get; }
    internal ProxyOperationRuntime UnhandledProxyOperation { get; }
    internal bool UseSynchronizationContext { get; }
    internal bool ValidateMustUnderstand { get; internal set; }
    internal ImmutableClientRuntime(ClientRuntime behavior);
    internal int get_MessageInspectorCorrelationOffset();
    internal int get_ParameterInspectorCorrelationOffset();
    [CompilerGeneratedAttribute]
internal int get_CorrelationCount();
    [CompilerGeneratedAttribute]
internal IClientOperationSelector get_OperationSelector();
    [CompilerGeneratedAttribute]
internal ProxyOperationRuntime get_UnhandledProxyOperation();
    [CompilerGeneratedAttribute]
internal bool get_UseSynchronizationContext();
    internal bool get_ValidateMustUnderstand();
    internal void set_ValidateMustUnderstand(bool value);
    internal void AfterReceiveReply(ProxyRpc& rpc);
    internal void BeforeSendRequest(ProxyRpc& rpc);
    internal void DisplayInitializationUI(ServiceChannel channel);
    internal IAsyncResult BeginDisplayInitializationUI(ServiceChannel channel, AsyncCallback callback, object state);
    internal void EndDisplayInitializationUI(IAsyncResult result);
    internal void InitializeChannel(IClientChannel channel);
    internal ProxyOperationRuntime GetOperation(MethodBase methodBase, Object[] args, Boolean& canCacheResult);
    internal ProxyOperationRuntime GetOperationByName(string operationName);
}
internal class System.ServiceModel.Dispatcher.ImmutableCommunicationTimeouts : object {
    private TimeSpan _close;
    private TimeSpan _open;
    private TimeSpan _receive;
    private TimeSpan _send;
    private TimeSpan System.ServiceModel.IDefaultCommunicationTimeouts.CloseTimeout { get; }
    private TimeSpan System.ServiceModel.IDefaultCommunicationTimeouts.OpenTimeout { get; }
    private TimeSpan System.ServiceModel.IDefaultCommunicationTimeouts.ReceiveTimeout { get; }
    private TimeSpan System.ServiceModel.IDefaultCommunicationTimeouts.SendTimeout { get; }
    internal ImmutableCommunicationTimeouts(IDefaultCommunicationTimeouts timeouts);
    private sealed virtual override TimeSpan System.ServiceModel.IDefaultCommunicationTimeouts.get_CloseTimeout();
    private sealed virtual override TimeSpan System.ServiceModel.IDefaultCommunicationTimeouts.get_OpenTimeout();
    private sealed virtual override TimeSpan System.ServiceModel.IDefaultCommunicationTimeouts.get_ReceiveTimeout();
    private sealed virtual override TimeSpan System.ServiceModel.IDefaultCommunicationTimeouts.get_SendTimeout();
}
internal class System.ServiceModel.Dispatcher.ImmutableDispatchRuntime : object {
    private ConcurrencyBehavior _concurrency;
    private IDemuxer _demuxer;
    private ErrorBehavior _error;
    private InstanceBehavior _instance;
    private IDispatchMessageInspector[] _messageInspectors;
    private TerminatingOperationBehavior _terminate;
    private ThreadBehavior _thread;
    private bool _sendAsynchronously;
    private MessageRpcProcessor _processMessage1;
    private MessageRpcProcessor _processMessage11;
    private MessageRpcProcessor _processMessage2;
    private MessageRpcProcessor _processMessage3;
    private MessageRpcProcessor _processMessage31;
    private MessageRpcProcessor _processMessage4;
    private MessageRpcProcessor _processMessage41;
    private MessageRpcProcessor _processMessage5;
    private MessageRpcProcessor _processMessage6;
    private MessageRpcProcessor _processMessage7;
    private MessageRpcProcessor _processMessage8;
    private MessageRpcProcessor _processMessage9;
    private MessageRpcProcessor _processMessageCleanup;
    private MessageRpcProcessor _processMessageCleanupError;
    private static AsyncCallback s_onReplyCompleted;
    [CompilerGeneratedAttribute]
private int <CorrelationCount>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <EnableFaults>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <ManualAddressing>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <ValidateMustUnderstand>k__BackingField;
    internal int CorrelationCount { get; }
    internal bool EnableFaults { get; }
    internal bool ManualAddressing { get; }
    internal bool ValidateMustUnderstand { get; }
    internal int MessageInspectorCorrelationOffset { get; }
    internal ImmutableDispatchRuntime(DispatchRuntime dispatch);
    private static ImmutableDispatchRuntime();
    [CompilerGeneratedAttribute]
internal int get_CorrelationCount();
    [CompilerGeneratedAttribute]
internal bool get_EnableFaults();
    [CompilerGeneratedAttribute]
internal bool get_ManualAddressing();
    [CompilerGeneratedAttribute]
internal bool get_ValidateMustUnderstand();
    internal int get_MessageInspectorCorrelationOffset();
    internal void AfterReceiveRequest(MessageRpc& rpc);
    internal void AfterReceiveRequestCore(MessageRpc& rpc);
    private void BeforeSendReply(MessageRpc& rpc, Exception& exception, Boolean& thereIsAnUnhandledException);
    internal void BeforeSendReplyCore(MessageRpc& rpc, Exception& exception, Boolean& thereIsAnUnhandledException);
    private void Reply(MessageRpc& rpc);
    private void BeginReply(MessageRpc& rpc);
    internal bool Dispatch(MessageRpc& rpc, bool isOperationContextSet);
    private bool EndReply(MessageRpc& rpc);
    private void SetActivityIdOnThread(MessageRpc& rpc);
    private void TransferChannelFromPendingList(MessageRpc& rpc);
    private void AddMessageProperties(Message message, OperationContext context, ServiceChannel replyChannel);
    private static void OnReplyCompletedCallback(IAsyncResult result);
    private void PrepareReply(MessageRpc& rpc);
    private bool PrepareAndAddressReply(MessageRpc& rpc);
    internal DispatchOperationRuntime GetOperation(Message& message);
    internal bool IsConcurrent(MessageRpc& rpc);
    internal void ProcessMessage1(MessageRpc& rpc);
    internal void ProcessMessage11(MessageRpc& rpc);
    private void ProcessMessage2(MessageRpc& rpc);
    private void ProcessMessage3(MessageRpc& rpc);
    private void ProcessMessage31(MessageRpc& rpc);
    private void ProcessMessage4(MessageRpc& rpc);
    private void ProcessMessage41(MessageRpc& rpc);
    private void ProcessMessage5(MessageRpc& rpc);
    private void ProcessMessage6(MessageRpc& rpc);
    private void ProcessMessage7(MessageRpc& rpc);
    private void ProcessMessage8(MessageRpc& rpc);
    private void ProcessMessage9(MessageRpc& rpc);
    private void ProcessMessageCleanup(MessageRpc& rpc);
    private void ProcessMessageCleanupError(MessageRpc& rpc);
}
internal class System.ServiceModel.Dispatcher.InputChannelBinder : object {
    private IInputChannel _channel;
    [CompilerGeneratedAttribute]
private Uri <ListenUri>k__BackingField;
    public IChannel Channel { get; }
    public bool HasSession { get; }
    public Uri ListenUri { get; }
    public EndpointAddress LocalAddress { get; }
    public EndpointAddress RemoteAddress { get; }
    internal InputChannelBinder(IInputChannel channel, Uri listenUri);
    public sealed virtual IChannel get_Channel();
    public sealed virtual bool get_HasSession();
    [CompilerGeneratedAttribute]
public sealed virtual Uri get_ListenUri();
    public sealed virtual EndpointAddress get_LocalAddress();
    public sealed virtual EndpointAddress get_RemoteAddress();
    public sealed virtual void Abort();
    public sealed virtual void CloseAfterFault(TimeSpan timeout);
    public sealed virtual IAsyncResult BeginTryReceive(TimeSpan timeout, AsyncCallback callback, object state);
    public sealed virtual bool EndTryReceive(IAsyncResult result, RequestContext& requestContext);
    public sealed virtual RequestContext CreateRequestContext(Message message);
    public sealed virtual IAsyncResult BeginSend(Message message, TimeSpan timeout, AsyncCallback callback, object state);
    public sealed virtual void EndSend(IAsyncResult result);
    public sealed virtual void Send(Message message, TimeSpan timeout);
    public sealed virtual bool TryReceive(TimeSpan timeout, RequestContext& requestContext);
    public sealed virtual IAsyncResult BeginRequest(Message message, TimeSpan timeout, AsyncCallback callback, object state);
    public sealed virtual Message EndRequest(IAsyncResult result);
    public sealed virtual Message Request(Message message, TimeSpan timeout);
    public sealed virtual bool WaitForMessage(TimeSpan timeout);
    public sealed virtual IAsyncResult BeginWaitForMessage(TimeSpan timeout, AsyncCallback callback, object state);
    public sealed virtual bool EndWaitForMessage(IAsyncResult result);
    private RequestContext WrapMessage(Message message);
}
public class System.ServiceModel.Dispatcher.InstanceBehavior : object {
    private IInstanceProvider _provider;
    [CompilerGeneratedAttribute]
private IInstanceContextProvider <InstanceContextProvider>k__BackingField;
    internal IInstanceContextProvider InstanceContextProvider { get; }
    internal InstanceBehavior(DispatchRuntime dispatch, ImmutableDispatchRuntime immutableRuntime);
    [CompilerGeneratedAttribute]
internal IInstanceContextProvider get_InstanceContextProvider();
    internal void AfterReply(MessageRpc& rpc, ErrorBehavior error);
    internal void EnsureInstanceContext(MessageRpc& rpc);
    internal object GetInstance(InstanceContext instanceContext);
    internal object GetInstance(InstanceContext instanceContext, Message request);
    internal void EnsureServiceInstance(MessageRpc& rpc);
}
internal abstract class System.ServiceModel.Dispatcher.InstanceContextProviderBase : object {
    private DispatchRuntime _dispatchRuntime;
    internal InstanceContextProviderBase(DispatchRuntime dispatchRuntime);
    internal static bool IsProviderSingleton(IInstanceContextProvider provider);
    internal static bool IsProviderSessionful(IInstanceContextProvider provider);
    internal static IInstanceContextProvider GetProviderForMode(InstanceContextMode instanceMode, DispatchRuntime runtime);
    public abstract virtual InstanceContext GetExistingInstanceContext(Message message, IContextChannel channel);
    internal ServiceChannel GetServiceChannelFromProxy(IContextChannel channel);
}
internal abstract class System.ServiceModel.Dispatcher.InvalidBodyAccessException : Exception {
    protected InvalidBodyAccessException(string message);
    protected InvalidBodyAccessException(string message, Exception innerException);
    protected InvalidBodyAccessException(SerializationInfo info, StreamingContext context);
}
internal class System.ServiceModel.Dispatcher.InvokeDelegate : MulticastDelegate {
    public InvokeDelegate(object object, IntPtr method);
    public virtual object Invoke(object target, Object[] inputs, Object[] outputs);
    public virtual IAsyncResult BeginInvoke(object target, Object[] inputs, Object[] outputs, AsyncCallback callback, object object);
    public virtual object EndInvoke(IAsyncResult result);
}
internal class System.ServiceModel.Dispatcher.InvokerUtil : object {
    private static string s_useLegacyInvokeDelegateAppContextSwitchKey;
    private static Lazy`1<bool> s_useLegacyInvokeDelegate;
    private CriticalHelper _helper;
    private static InvokerUtil();
    internal InvokeDelegate GenerateInvokeDelegate(MethodInfo method, Int32& inputParameterCount, Int32& outputParameterCount);
}
public interface System.ServiceModel.Dispatcher.IOperationInvoker {
    public abstract virtual Object[] AllocateInputs();
    public abstract virtual IAsyncResult InvokeBegin(object instance, Object[] inputs, AsyncCallback callback, object state);
    public abstract virtual object InvokeEnd(object instance, Object[]& outputs, IAsyncResult result);
}
public interface System.ServiceModel.Dispatcher.IParameterInspector {
    public abstract virtual object BeforeCall(string operationName, Object[] inputs);
    public abstract virtual void AfterCall(string operationName, Object[] outputs, object returnValue, object correlationState);
}
internal interface System.ServiceModel.Dispatcher.IResumeMessageRpc {
    public abstract virtual InstanceContext GetMessageInstanceContext();
    public abstract virtual void Resume();
    public abstract virtual void Resume(Boolean& alreadyResumedNoLock);
    public abstract virtual void Resume(IAsyncResult result);
    public abstract virtual void Resume(object instance);
    public abstract virtual void SignalConditionalResume(IAsyncResult result);
}
internal static class System.ServiceModel.Dispatcher.ListenerBinder : object {
    internal static IListenerBinder GetBinder(IChannelListener listener, MessageVersion messageVersion);
}
internal class System.ServiceModel.Dispatcher.ListenerChannel : object {
    [CompilerGeneratedAttribute]
private IChannelBinder <Binder>k__BackingField;
    public IChannelBinder Binder { get; }
    public ListenerChannel(IChannelBinder binder);
    [CompilerGeneratedAttribute]
public IChannelBinder get_Binder();
}
internal class System.ServiceModel.Dispatcher.ListenerHandler : CommunicationObject {
    private static Action`1<object> s_initiateChannelPump;
    private SessionIdleManager _idleManager;
    private bool _acceptedNull;
    private bool _doneAccepting;
    private IListenerBinder _listenerBinder;
    private IDefaultCommunicationTimeouts _timeouts;
    [CompilerGeneratedAttribute]
private ChannelDispatcher <ChannelDispatcher>k__BackingField;
    [CompilerGeneratedAttribute]
private ListenerChannel <Channel>k__BackingField;
    [CompilerGeneratedAttribute]
private EndpointDispatcherTable <Endpoints>k__BackingField;
    internal ChannelDispatcher ChannelDispatcher { get; }
    internal ListenerChannel Channel { get; private set; }
    protected TimeSpan DefaultCloseTimeout { get; }
    protected TimeSpan DefaultOpenTimeout { get; }
    internal EndpointDispatcherTable Endpoints { get; internal set; }
    internal object ThisLock { get; }
    internal ListenerHandler(IListenerBinder listenerBinder, ChannelDispatcher channelDispatcher, IDefaultCommunicationTimeouts timeouts);
    private static ListenerHandler();
    [CompilerGeneratedAttribute]
internal ChannelDispatcher get_ChannelDispatcher();
    [CompilerGeneratedAttribute]
internal ListenerChannel get_Channel();
    [CompilerGeneratedAttribute]
private void set_Channel(ListenerChannel value);
    protected virtual TimeSpan get_DefaultCloseTimeout();
    protected virtual TimeSpan get_DefaultOpenTimeout();
    [CompilerGeneratedAttribute]
internal EndpointDispatcherTable get_Endpoints();
    [CompilerGeneratedAttribute]
internal void set_Endpoints(EndpointDispatcherTable value);
    internal object get_ThisLock();
    [AsyncStateMachineAttribute("System.ServiceModel.Dispatcher.ListenerHandler/<OnCloseAsync>d__24")]
protected internal virtual Task OnCloseAsync(TimeSpan timeout);
    protected internal virtual Task OnOpenAsync(TimeSpan timeout);
    protected virtual void OnOpen(TimeSpan timeout);
    protected virtual IAsyncResult OnBeginOpen(TimeSpan timeout, AsyncCallback callback, object state);
    protected virtual void OnEndOpen(IAsyncResult result);
    protected virtual void OnOpened();
    internal void NewChannelPump();
    private static void InitiateChannelPump(object state);
    private void ChannelPump();
    private void AbortChannels();
    [AsyncStateMachineAttribute("System.ServiceModel.Dispatcher.ListenerHandler/<CloseChannelAsync>d__34")]
private Task CloseChannelAsync(IChannel channel, TimeSpan timeout);
    public void CloseInput(TimeSpan timeout);
    [AsyncStateMachineAttribute("System.ServiceModel.Dispatcher.ListenerHandler/<CloseChannelsAsync>d__36")]
private Task CloseChannelsAsync(TimeSpan timeout);
    private void Dispatch();
    private void AcceptedNull();
    private void DoneAccepting();
    private bool IsSessionChannel(IChannel channel);
    private void CancelPendingIdleManager();
    protected virtual void OnAbort();
    protected virtual IAsyncResult OnBeginClose(TimeSpan timeout, AsyncCallback callback, object state);
    protected virtual void OnClose(TimeSpan timeout);
    protected virtual void OnEndClose(IAsyncResult result);
    private bool HandleError(Exception e);
}
[DataContractAttribute]
public abstract class System.ServiceModel.Dispatcher.MessageFilter : object {
    protected internal virtual IMessageFilterTable`1<FilterData> CreateFilterTable();
    public abstract virtual bool Match(MessageBuffer buffer);
    public abstract virtual bool Match(Message message);
}
internal class System.ServiceModel.Dispatcher.MessageOperationFormatter : object {
    private static MessageOperationFormatter s_instance;
    internal static MessageOperationFormatter Instance { get; }
    internal static MessageOperationFormatter get_Instance();
    public sealed virtual object DeserializeReply(Message message, Object[] parameters);
    public sealed virtual void DeserializeRequest(Message message, Object[] parameters);
    public sealed virtual Message SerializeReply(MessageVersion messageVersion, Object[] parameters, object result);
    public sealed virtual Message SerializeRequest(MessageVersion messageVersion, Object[] parameters);
}
internal class System.ServiceModel.Dispatcher.MessageRpc : ValueType {
    internal ServiceChannel Channel;
    internal ChannelHandler channelHandler;
    internal Object[] Correlation;
    internal OperationContext OperationContext;
    internal ServiceModelActivity Activity;
    internal Guid ResponseActivityId;
    internal IAsyncResult AsyncResult;
    internal bool CanSendReply;
    internal bool SuccessfullySendReply;
    internal Object[] InputParameters;
    internal Object[] OutputParameters;
    internal object ReturnParameter;
    internal bool ParametersDisposed;
    internal bool DidDeserializeRequestBody;
    internal Exception Error;
    internal MessageRpcProcessor ErrorProcessor;
    internal ErrorHandlerFaultInfo FaultInfo;
    internal bool HasSecurityContext;
    internal object Instance;
    internal bool MessageRpcOwnsInstanceContextThrottle;
    internal MessageRpcProcessor NextProcessor;
    internal Collection`1<MessageHeaderInfo> NotUnderstoodHeaders;
    internal DispatchOperationRuntime Operation;
    internal Message Request;
    internal RequestContext RequestContext;
    internal bool RequestContextThrewOnReply;
    internal UniqueId RequestID;
    internal Message Reply;
    internal TimeoutHelper ReplyTimeoutHelper;
    internal ReplyToInfo ReplyToInfo;
    internal MessageVersion RequestVersion;
    internal ServiceSecurityContext SecurityContext;
    internal InstanceContext InstanceContext;
    internal bool SuccessfullyBoundInstance;
    internal bool SuccessfullyIncrementedActivity;
    internal bool SuccessfullyLockedInstance;
    internal MessageRpcInvokeNotification InvokeNotification;
    internal EventTraceActivity EventTraceActivity;
    private bool _isInstanceContextSingleton;
    private SignalGate`1<IAsyncResult> _invokeContinueGate;
    [CompilerGeneratedAttribute]
private bool <IsPaused>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <SwitchedThreads>k__BackingField;
    internal bool IsPaused { get; private set; }
    internal bool SwitchedThreads { get; private set; }
    internal MessageRpc(RequestContext requestContext, Message request, DispatchOperationRuntime operation, ServiceChannel channel, ChannelHandler channelHandler, bool cleanThread, OperationContext operationContext, InstanceContext instanceContext, EventTraceActivity eventTraceActivity);
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
internal bool get_IsPaused();
    [CompilerGeneratedAttribute]
private void set_IsPaused(bool value);
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
internal bool get_SwitchedThreads();
    [CompilerGeneratedAttribute]
private void set_SwitchedThreads(bool value);
    internal void Abort();
    private void AbortRequestContext(RequestContext requestContext);
    internal void AbortRequestContext();
    private void TraceCallDurationInDispatcherIfNecessary(bool requestContextWasClosedSuccessfully);
    internal void CloseRequestContext();
    private void DisposeRequestContext(RequestContext context);
    internal void AbortChannel();
    internal void CloseChannel();
    internal void AbortInstanceContext();
    internal void EnsureReceive();
    private bool ProcessError(Exception e);
    internal void DisposeParameters(bool excludeInput);
    internal void DisposeParametersCore(bool excludeInput);
    private void DisposeParameterList(Object[] parameters);
    internal IResumeMessageRpc Pause();
    internal bool Process(bool isOperationContextSet);
    internal void UnPause();
    internal bool UnlockInvokeContinueGate(IAsyncResult& result);
    internal void PrepareInvokeContinueGate();
    private void IncrementBusyCount();
    private void DecrementBusyCount();
}
internal class System.ServiceModel.Dispatcher.MessageRpcInvokeNotification : object {
    private ServiceModelActivity _activity;
    private ChannelHandler _handler;
    [CompilerGeneratedAttribute]
private bool <DidInvokerEnsurePump>k__BackingField;
    public bool DidInvokerEnsurePump { get; public set; }
    public MessageRpcInvokeNotification(ServiceModelActivity activity, ChannelHandler handler);
    [CompilerGeneratedAttribute]
public bool get_DidInvokerEnsurePump();
    [CompilerGeneratedAttribute]
public void set_DidInvokerEnsurePump(bool value);
    public sealed virtual void NotifyInvokeReceived();
    public sealed virtual void NotifyInvokeReceived(RequestContext request);
}
internal class System.ServiceModel.Dispatcher.MessageRpcProcessor : MulticastDelegate {
    public MessageRpcProcessor(object object, IntPtr method);
    public virtual void Invoke(MessageRpc& rpc);
    public virtual IAsyncResult BeginInvoke(MessageRpc& rpc, AsyncCallback callback, object object);
    public virtual void EndInvoke(MessageRpc& rpc, IAsyncResult result);
}
internal class System.ServiceModel.Dispatcher.NetDispatcherFaultException : FaultException {
    public NetDispatcherFaultException(string reason, FaultCode code, Exception innerException);
    public NetDispatcherFaultException(FaultReason reason, FaultCode code, Exception innerException);
}
internal abstract class System.ServiceModel.Dispatcher.OperationFormatter : object {
    private MessageDescription _requestDescription;
    private XmlDictionaryString _action;
    private XmlDictionaryString _replyAction;
    protected StreamFormatter requestStreamFormatter;
    protected StreamFormatter replyStreamFormatter;
    private string _operationName;
    [CompilerGeneratedAttribute]
private XmlDictionary <Dictionary>k__BackingField;
    [CompilerGeneratedAttribute]
private MessageDescription <ReplyDescription>k__BackingField;
    internal string RequestAction { get; }
    internal string ReplyAction { get; }
    protected XmlDictionary Dictionary { get; }
    protected string OperationName { get; }
    protected MessageDescription ReplyDescription { get; }
    protected MessageDescription RequestDescription { get; }
    public OperationFormatter(OperationDescription description, bool isRpc, bool isEncoded);
    protected abstract virtual void AddHeadersToMessage(Message message, MessageDescription messageDescription, Object[] parameters, bool isRequest);
    protected abstract virtual void SerializeBody(XmlDictionaryWriter writer, MessageVersion version, string action, MessageDescription messageDescription, object returnValue, Object[] parameters, bool isRequest);
    protected virtual Task SerializeBodyAsync(XmlDictionaryWriter writer, MessageVersion version, string action, MessageDescription messageDescription, object returnValue, Object[] parameters, bool isRequest);
    protected abstract virtual void GetHeadersFromMessage(Message message, MessageDescription messageDescription, Object[] parameters, bool isRequest);
    protected abstract virtual object DeserializeBody(XmlDictionaryReader reader, MessageVersion version, string action, MessageDescription messageDescription, Object[] parameters, bool isRequest);
    protected virtual void WriteBodyAttributes(XmlDictionaryWriter writer, MessageVersion messageVersion);
    internal string get_RequestAction();
    internal string get_ReplyAction();
    [CompilerGeneratedAttribute]
protected XmlDictionary get_Dictionary();
    protected string get_OperationName();
    [CompilerGeneratedAttribute]
protected MessageDescription get_ReplyDescription();
    protected MessageDescription get_RequestDescription();
    protected XmlDictionaryString AddToDictionary(string s);
    public sealed virtual object DeserializeReply(Message message, Object[] parameters);
    private static object CreateTypedMessageInstance(Type messageContractType);
    public sealed virtual void DeserializeRequest(Message message, Object[] parameters);
    private object DeserializeBodyContents(Message message, Object[] parameters, bool isRequest);
    public sealed virtual Message SerializeRequest(MessageVersion messageVersion, Object[] parameters);
    public sealed virtual Message SerializeReply(MessageVersion messageVersion, Object[] parameters, object result);
    private void SetupStreamAndMessageDescription(bool isRequest, StreamFormatter& streamFormatter, MessageDescription& messageDescription);
    private void SerializeBodyContents(XmlDictionaryWriter writer, MessageVersion version, Object[] parameters, object returnValue, bool isRequest);
    [AsyncStateMachineAttribute("System.ServiceModel.Dispatcher.OperationFormatter/<SerializeBodyContentsAsync>d__36")]
private Task SerializeBodyContentsAsync(XmlDictionaryWriter writer, MessageVersion version, Object[] parameters, object returnValue, bool isRequest);
    private IAsyncResult BeginSerializeBodyContents(XmlDictionaryWriter writer, MessageVersion version, Object[] parameters, object returnValue, bool isRequest, AsyncCallback callback, object state);
    private void EndSerializeBodyContents(IAsyncResult result);
    private void AddPropertiesToMessage(Message message, MessageDescription messageDescription, Object[] parameters);
    private void AddPropertiesToMessageCore(Message message, MessageDescription messageDescription, Object[] parameters);
    private void GetPropertiesFromMessage(Message message, MessageDescription messageDescription, Object[] parameters);
    private void GetPropertiesFromMessageCore(Message message, MessageDescription messageDescription, Object[] parameters);
    internal static object GetContentOfMessageHeaderOfT(MessageHeaderDescription headerDescription, object parameterValue, Boolean& mustUnderstand, Boolean& relay, String& actor);
    internal static bool IsValidReturnValue(MessagePartDescription returnValue);
    internal static XmlDictionaryString AddToDictionary(XmlDictionary dictionary, string s);
    internal static void Validate(OperationDescription operation, bool isRpc, bool isEncoded);
    internal static void GetActions(OperationDescription description, XmlDictionary dictionary, XmlDictionaryString& action, XmlDictionaryString& replyAction);
    internal static NetDispatcherFaultException CreateDeserializationFailedFault(string reason, Exception innerException);
    internal static void TraceAndSkipElement(XmlReader xmlReader);
}
public class System.ServiceModel.Dispatcher.OperationInvokerBehavior : object {
    private sealed virtual override void System.ServiceModel.Description.IOperationBehavior.Validate(OperationDescription description);
    private sealed virtual override void System.ServiceModel.Description.IOperationBehavior.AddBindingParameters(OperationDescription description, BindingParameterCollection parameters);
    private sealed virtual override void System.ServiceModel.Description.IOperationBehavior.ApplyDispatchBehavior(OperationDescription description, DispatchOperation dispatch);
    private sealed virtual override void System.ServiceModel.Description.IOperationBehavior.ApplyClientBehavior(OperationDescription description, ClientOperation proxy);
}
internal class System.ServiceModel.Dispatcher.OperationSelectorBehavior : object {
    private sealed virtual override void System.ServiceModel.Description.IContractBehavior.Validate(ContractDescription description, ServiceEndpoint endpoint);
    private sealed virtual override void System.ServiceModel.Description.IContractBehavior.AddBindingParameters(ContractDescription description, ServiceEndpoint endpoint, BindingParameterCollection parameters);
    private sealed virtual override void System.ServiceModel.Description.IContractBehavior.ApplyDispatchBehavior(ContractDescription description, ServiceEndpoint endpoint, DispatchRuntime dispatch);
    private sealed virtual override void System.ServiceModel.Description.IContractBehavior.ApplyClientBehavior(ContractDescription description, ServiceEndpoint endpoint, ClientRuntime proxy);
}
internal class System.ServiceModel.Dispatcher.OutputChannelBinder : object {
    private IOutputChannel _channel;
    public IChannel Channel { get; }
    public bool HasSession { get; }
    public Uri ListenUri { get; }
    public EndpointAddress LocalAddress { get; }
    public EndpointAddress RemoteAddress { get; }
    internal OutputChannelBinder(IOutputChannel channel);
    public sealed virtual IChannel get_Channel();
    public sealed virtual bool get_HasSession();
    public sealed virtual Uri get_ListenUri();
    public sealed virtual EndpointAddress get_LocalAddress();
    public sealed virtual EndpointAddress get_RemoteAddress();
    public sealed virtual void Abort();
    public sealed virtual void CloseAfterFault(TimeSpan timeout);
    public sealed virtual IAsyncResult BeginTryReceive(TimeSpan timeout, AsyncCallback callback, object state);
    public sealed virtual bool EndTryReceive(IAsyncResult result, RequestContext& requestContext);
    public sealed virtual RequestContext CreateRequestContext(Message message);
    public sealed virtual IAsyncResult BeginSend(Message message, TimeSpan timeout, AsyncCallback callback, object state);
    public sealed virtual void EndSend(IAsyncResult result);
    public sealed virtual void Send(Message message, TimeSpan timeout);
    public sealed virtual IAsyncResult BeginRequest(Message message, TimeSpan timeout, AsyncCallback callback, object state);
    public sealed virtual Message EndRequest(IAsyncResult result);
    public sealed virtual bool TryReceive(TimeSpan timeout, RequestContext& requestContext);
    public sealed virtual Message Request(Message message, TimeSpan timeout);
    public sealed virtual bool WaitForMessage(TimeSpan timeout);
    public sealed virtual IAsyncResult BeginWaitForMessage(TimeSpan timeout, AsyncCallback callback, object state);
    public sealed virtual bool EndWaitForMessage(IAsyncResult result);
}
internal class System.ServiceModel.Dispatcher.PerSessionInstanceContextProvider : InstanceContextProviderBase {
    internal PerSessionInstanceContextProvider(DispatchRuntime dispatchRuntime);
    public virtual InstanceContext GetExistingInstanceContext(Message message, IContextChannel channel);
}
internal class System.ServiceModel.Dispatcher.PrimitiveOperationFormatter : object {
    private OperationDescription _operation;
    private MessageDescription _responseMessage;
    private MessageDescription _requestMessage;
    private XmlDictionaryString _action;
    private XmlDictionaryString _replyAction;
    private ActionHeader _actionHeaderNone;
    private ActionHeader _actionHeader10;
    private ActionHeader _actionHeaderAugust2004;
    private ActionHeader _replyActionHeaderNone;
    private ActionHeader _replyActionHeader10;
    private ActionHeader _replyActionHeaderAugust2004;
    private XmlDictionaryString _requestWrapperName;
    private XmlDictionaryString _requestWrapperNamespace;
    private XmlDictionaryString _responseWrapperName;
    private XmlDictionaryString _responseWrapperNamespace;
    private PartInfo[] _requestParts;
    private PartInfo[] _responseParts;
    private PartInfo _returnPart;
    private XmlDictionaryString _xsiNilLocalName;
    private XmlDictionaryString _xsiNilNamespace;
    private ActionHeader ActionHeaderNone { get; }
    private ActionHeader ActionHeader10 { get; }
    private ActionHeader ActionHeaderAugust2004 { get; }
    private ActionHeader ReplyActionHeaderNone { get; }
    private ActionHeader ReplyActionHeader10 { get; }
    private ActionHeader ReplyActionHeaderAugust2004 { get; }
    public PrimitiveOperationFormatter(OperationDescription description, bool isRpc);
    private ActionHeader get_ActionHeaderNone();
    private ActionHeader get_ActionHeader10();
    private ActionHeader get_ActionHeaderAugust2004();
    private ActionHeader get_ReplyActionHeaderNone();
    private ActionHeader get_ReplyActionHeader10();
    private ActionHeader get_ReplyActionHeaderAugust2004();
    private static XmlDictionaryString AddToDictionary(XmlDictionary dictionary, string s);
    private static PartInfo[] AddToDictionary(XmlDictionary dictionary, MessagePartDescriptionCollection parts, bool isRpc);
    private ActionHeader GetActionHeader(AddressingVersion addressing);
    private ActionHeader GetReplyActionHeader(AddressingVersion addressing);
    private static string GetArrayItemName(Type type);
    private static PartInfo AddToDictionary(XmlDictionary dictionary, MessagePartDescription part, bool isRpc);
    public static bool IsContractSupported(OperationDescription description);
    private static bool AreTypesSupported(MessagePartDescriptionCollection bodyDescriptions);
    private static bool IsTypeSupported(MessagePartDescription bodyDescription);
    private static bool IsArrayTypeSupported(Type type);
    public sealed virtual Message SerializeRequest(MessageVersion messageVersion, Object[] parameters);
    public sealed virtual Message SerializeReply(MessageVersion messageVersion, Object[] parameters, object result);
    public sealed virtual object DeserializeReply(Message message, Object[] parameters);
    public sealed virtual void DeserializeRequest(Message message, Object[] parameters);
    private void DeserializeRequest(XmlDictionaryReader reader, Object[] parameters);
    private object DeserializeResponse(XmlDictionaryReader reader, Object[] parameters);
    private void DeserializeParameters(XmlDictionaryReader reader, PartInfo[] parts, Object[] parameters);
    private bool IsPartElements(XmlDictionaryReader reader, PartInfo[] parts);
    private bool IsPartElement(XmlDictionaryReader reader, PartInfo part);
    private object DeserializeParameter(XmlDictionaryReader reader, PartInfo part);
    private void SerializeParameter(XmlDictionaryWriter writer, PartInfo part, object graph);
    private void SerializeParameters(XmlDictionaryWriter writer, PartInfo[] parts, Object[] parameters);
    private void SerializeRequest(XmlDictionaryWriter writer, Object[] parameters);
    private void SerializeResponse(XmlDictionaryWriter writer, object returnValue, Object[] parameters);
}
internal class System.ServiceModel.Dispatcher.ProxyOperationRuntime : object {
    private IClientMessageFormatter _formatter;
    private bool _isSessionOpenNotificationEnabled;
    private IParameterInspector[] _parameterInspectors;
    private ImmutableClientRuntime _parent;
    private bool _deserializeReply;
    private string _replyAction;
    private MethodInfo _beginMethod;
    private MethodInfo _syncMethod;
    private MethodInfo _taskMethod;
    private ParameterInfo[] _inParams;
    private ParameterInfo[] _outParams;
    private ParameterInfo[] _endOutParams;
    private ParameterInfo _returnParam;
    [CompilerGeneratedAttribute]
private string <Action>k__BackingField;
    [CompilerGeneratedAttribute]
private IClientFaultFormatter <FaultFormatter>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsInitiating>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsOneWay>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsTerminating>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Name>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <SerializeRequest>k__BackingField;
    [CompilerGeneratedAttribute]
private Type <TaskTResult>k__BackingField;
    internal string Action { get; }
    internal IClientFaultFormatter FaultFormatter { get; }
    internal bool IsInitiating { get; }
    internal bool IsOneWay { get; }
    internal bool IsTerminating { get; }
    internal bool IsSessionOpenNotificationEnabled { get; }
    internal string Name { get; }
    internal ImmutableClientRuntime Parent { get; }
    internal string ReplyAction { get; }
    internal bool DeserializeReply { get; }
    internal bool SerializeRequest { get; }
    internal Type TaskTResult { get; internal set; }
    internal ProxyOperationRuntime(ClientOperation operation, ImmutableClientRuntime parent);
    [CompilerGeneratedAttribute]
internal string get_Action();
    [CompilerGeneratedAttribute]
internal IClientFaultFormatter get_FaultFormatter();
    [CompilerGeneratedAttribute]
internal bool get_IsInitiating();
    [CompilerGeneratedAttribute]
internal bool get_IsOneWay();
    [CompilerGeneratedAttribute]
internal bool get_IsTerminating();
    internal bool get_IsSessionOpenNotificationEnabled();
    [CompilerGeneratedAttribute]
internal string get_Name();
    internal ImmutableClientRuntime get_Parent();
    internal string get_ReplyAction();
    internal bool get_DeserializeReply();
    [CompilerGeneratedAttribute]
internal bool get_SerializeRequest();
    [CompilerGeneratedAttribute]
internal Type get_TaskTResult();
    [CompilerGeneratedAttribute]
internal void set_TaskTResult(Type value);
    internal void AfterReply(ProxyRpc& rpc);
    internal void BeforeRequest(ProxyRpc& rpc);
    internal static object GetDefaultParameterValue(Type parameterType);
    internal bool IsSyncCall(MethodCall methodCall);
    internal bool IsBeginCall(MethodCall methodCall);
    internal bool IsTaskCall(MethodCall methodCall);
    internal Object[] MapSyncInputs(MethodCall methodCall, Object[]& outs);
    internal Object[] MapAsyncBeginInputs(MethodCall methodCall, AsyncCallback& callback, Object& asyncState);
    internal void MapAsyncEndInputs(MethodCall methodCall, IAsyncResult& result, Object[]& outs);
    internal Object[] MapSyncOutputs(MethodCall methodCall, Object[] outs, Object& ret);
    internal Object[] MapAsyncOutputs(MethodCall methodCall, Object[] outs, Object& ret);
    private Object[] MapOutputs(ParameterInfo[] parameters, MethodCall methodCall, Object[] outs, Object& ret);
    internal static bool IsValidAction(Message message, string action);
}
internal class System.ServiceModel.Dispatcher.ProxyRpc : ValueType {
    internal string Action;
    internal ServiceModelActivity Activity;
    internal Guid ActivityId;
    internal ServiceChannel Channel;
    internal Object[] Correlation;
    internal Object[] InputParameters;
    internal ProxyOperationRuntime Operation;
    internal Object[] OutputParameters;
    internal Message Request;
    internal Message Reply;
    internal object ReturnValue;
    internal MessageVersion MessageVersion;
    internal TimeoutHelper TimeoutHelper;
    private EventTraceActivity _eventTraceActivity;
    internal EventTraceActivity EventTraceActivity { get; internal set; }
    internal ProxyRpc(ServiceChannel channel, ProxyOperationRuntime operation, string action, Object[] inputs, TimeSpan timeout);
    internal EventTraceActivity get_EventTraceActivity();
    internal void set_EventTraceActivity(EventTraceActivity value);
}
internal class System.ServiceModel.Dispatcher.ReplyChannelBinder : object {
    private IReplyChannel _channel;
    [CompilerGeneratedAttribute]
private Uri <ListenUri>k__BackingField;
    public IChannel Channel { get; }
    public bool HasSession { get; }
    public Uri ListenUri { get; }
    public EndpointAddress LocalAddress { get; }
    public EndpointAddress RemoteAddress { get; }
    internal ReplyChannelBinder(IReplyChannel channel, Uri listenUri);
    public sealed virtual IChannel get_Channel();
    public sealed virtual bool get_HasSession();
    [CompilerGeneratedAttribute]
public sealed virtual Uri get_ListenUri();
    public sealed virtual EndpointAddress get_LocalAddress();
    public sealed virtual EndpointAddress get_RemoteAddress();
    public sealed virtual void Abort();
    public sealed virtual void CloseAfterFault(TimeSpan timeout);
    public sealed virtual IAsyncResult BeginTryReceive(TimeSpan timeout, AsyncCallback callback, object state);
    public sealed virtual bool EndTryReceive(IAsyncResult result, RequestContext& requestContext);
    public sealed virtual RequestContext CreateRequestContext(Message message);
    public sealed virtual IAsyncResult BeginSend(Message message, TimeSpan timeout, AsyncCallback callback, object state);
    public sealed virtual void EndSend(IAsyncResult result);
    public sealed virtual void Send(Message message, TimeSpan timeout);
    public sealed virtual IAsyncResult BeginRequest(Message message, TimeSpan timeout, AsyncCallback callback, object state);
    public sealed virtual Message EndRequest(IAsyncResult result);
    public sealed virtual bool TryReceive(TimeSpan timeout, RequestContext& requestContext);
    public sealed virtual Message Request(Message message, TimeSpan timeout);
    public sealed virtual bool WaitForMessage(TimeSpan timeout);
    public sealed virtual IAsyncResult BeginWaitForMessage(TimeSpan timeout, AsyncCallback callback, object state);
    public sealed virtual bool EndWaitForMessage(IAsyncResult result);
}
internal class System.ServiceModel.Dispatcher.RequestChannelBinder : object {
    private IRequestChannel _channel;
    public IChannel Channel { get; }
    public bool HasSession { get; }
    public Uri ListenUri { get; }
    public EndpointAddress LocalAddress { get; }
    public EndpointAddress RemoteAddress { get; }
    internal RequestChannelBinder(IRequestChannel channel);
    public sealed virtual IChannel get_Channel();
    public sealed virtual bool get_HasSession();
    public sealed virtual Uri get_ListenUri();
    public sealed virtual EndpointAddress get_LocalAddress();
    public sealed virtual EndpointAddress get_RemoteAddress();
    public sealed virtual void Abort();
    public sealed virtual void CloseAfterFault(TimeSpan timeout);
    public sealed virtual IAsyncResult BeginTryReceive(TimeSpan timeout, AsyncCallback callback, object state);
    public sealed virtual bool EndTryReceive(IAsyncResult result, RequestContext& requestContext);
    public sealed virtual RequestContext CreateRequestContext(Message message);
    public sealed virtual IAsyncResult BeginSend(Message message, TimeSpan timeout, AsyncCallback callback, object state);
    public sealed virtual void EndSend(IAsyncResult result);
    public sealed virtual void Send(Message message, TimeSpan timeout);
    public sealed virtual IAsyncResult BeginRequest(Message message, TimeSpan timeout, AsyncCallback callback, object state);
    public sealed virtual Message EndRequest(IAsyncResult result);
    public sealed virtual bool TryReceive(TimeSpan timeout, RequestContext& requestContext);
    public sealed virtual Message Request(Message message, TimeSpan timeout);
    private void ValidateNullReply(Message message);
    public sealed virtual bool WaitForMessage(TimeSpan timeout);
    public sealed virtual IAsyncResult BeginWaitForMessage(TimeSpan timeout, AsyncCallback callback, object state);
    public sealed virtual bool EndWaitForMessage(IAsyncResult result);
}
internal class System.ServiceModel.Dispatcher.SharedRuntimeState : object {
    private bool _isImmutable;
    private bool _validateMustUnderstand;
    [CompilerGeneratedAttribute]
private bool <EnableFaults>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsOnServer>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <ManualAddressing>k__BackingField;
    internal bool EnableFaults { get; internal set; }
    internal bool IsOnServer { get; }
    internal bool ManualAddressing { get; internal set; }
    internal bool ValidateMustUnderstand { get; internal set; }
    internal SharedRuntimeState(bool isOnServer);
    [CompilerGeneratedAttribute]
internal bool get_EnableFaults();
    [CompilerGeneratedAttribute]
internal void set_EnableFaults(bool value);
    [CompilerGeneratedAttribute]
internal bool get_IsOnServer();
    [CompilerGeneratedAttribute]
internal bool get_ManualAddressing();
    [CompilerGeneratedAttribute]
internal void set_ManualAddressing(bool value);
    internal bool get_ValidateMustUnderstand();
    internal void set_ValidateMustUnderstand(bool value);
    internal void LockDownProperties();
    internal void ThrowIfImmutable();
}
internal class System.ServiceModel.Dispatcher.StreamFormatter : object {
    private string _partNS;
    private int _streamIndex;
    private bool _isRequest;
    private string _operationName;
    private static int returnValueIndex;
    [CompilerGeneratedAttribute]
private string <WrapperName>k__BackingField;
    [CompilerGeneratedAttribute]
private string <WrapperNamespace>k__BackingField;
    [CompilerGeneratedAttribute]
private string <PartName>k__BackingField;
    internal string WrapperName { get; internal set; }
    internal string WrapperNamespace { get; internal set; }
    internal string PartName { get; }
    internal string PartNamespace { get; }
    private StreamFormatter(MessageDescription messageDescription, MessagePartDescription streamPart, string operationName, bool isRequest);
    internal static StreamFormatter Create(MessageDescription messageDescription, string operationName, bool isRequest);
    internal void Serialize(XmlDictionaryWriter writer, Object[] parameters, object returnValue);
    [AsyncStateMachineAttribute("System.ServiceModel.Dispatcher.StreamFormatter/<SerializeAsync>d__8")]
internal Task SerializeAsync(XmlDictionaryWriter writer, Object[] parameters, object returnValue);
    private Stream GetStreamAndWriteStartWrapperIfNecessary(XmlDictionaryWriter writer, Object[] parameters, object returnValue);
    [AsyncStateMachineAttribute("System.ServiceModel.Dispatcher.StreamFormatter/<GetStreamAndWriteStartWrapperIfNecessaryAsync>d__10")]
private Task`1<Stream> GetStreamAndWriteStartWrapperIfNecessaryAsync(XmlDictionaryWriter writer, Object[] parameters, object returnValue);
    private void WriteEndWrapperIfNecessary(XmlDictionaryWriter writer);
    [AsyncStateMachineAttribute("System.ServiceModel.Dispatcher.StreamFormatter/<WriteEndWrapperIfNecessaryAsync>d__12")]
private Task WriteEndWrapperIfNecessaryAsync(XmlDictionaryWriter writer);
    internal IAsyncResult BeginSerialize(XmlDictionaryWriter writer, Object[] parameters, object returnValue, AsyncCallback callback, object state);
    public void EndSerialize(IAsyncResult result);
    internal void Deserialize(Object[] parameters, Object& retVal, Message message);
    [CompilerGeneratedAttribute]
internal string get_WrapperName();
    [CompilerGeneratedAttribute]
internal void set_WrapperName(string value);
    [CompilerGeneratedAttribute]
internal string get_WrapperNamespace();
    [CompilerGeneratedAttribute]
internal void set_WrapperNamespace(string value);
    [CompilerGeneratedAttribute]
internal string get_PartName();
    internal string get_PartNamespace();
    private Stream GetStreamValue(Object[] parameters, object returnValue);
    private void SetStreamValue(Object[] parameters, Object& returnValue, Stream streamValue);
    private static MessagePartDescription ValidateAndGetStreamPart(MessageDescription messageDescription, bool isRequest, string operationName);
    private static bool HasStream(MessageDescription messageDescription);
    private static MessagePartDescription GetStreamPart(MessageDescription messageDescription);
    internal static bool IsStream(MessageDescription messageDescription);
}
internal class System.ServiceModel.Dispatcher.SynchronizedChannelCollection`1 : SynchronizedCollection`1<TChannel> {
    private EventHandler _onChannelClosed;
    private EventHandler _onChannelFaulted;
    internal SynchronizedChannelCollection`1(object syncRoot);
    private void AddingChannel(TChannel channel);
    private void RemovingChannel(TChannel channel);
    private void OnChannelClosed(object sender, EventArgs args);
    private void OnChannelFaulted(object sender, EventArgs args);
    protected virtual void ClearItems();
    protected virtual void InsertItem(int index, TChannel item);
    protected virtual void RemoveItem(int index);
    protected virtual void SetItem(int index, TChannel item);
}
public class System.ServiceModel.Dispatcher.SyncMethodInvoker : object {
    private InvokeDelegate _invokeDelegate;
    private int _inputParameterCount;
    private int _outputParameterCount;
    private string _methodName;
    [CompilerGeneratedAttribute]
private MethodInfo <Method>k__BackingField;
    public MethodInfo Method { get; }
    public string MethodName { get; }
    public SyncMethodInvoker(MethodInfo method);
    [CompilerGeneratedAttribute]
public MethodInfo get_Method();
    public string get_MethodName();
    public sealed virtual Object[] AllocateInputs();
    public sealed virtual IAsyncResult InvokeBegin(object instance, Object[] inputs, AsyncCallback callback, object state);
    public sealed virtual object InvokeEnd(object instance, Object[]& outputs, IAsyncResult result);
    private Task`1<Tuple`2<object, Object[]>> InvokeAsync(object instance, Object[] inputs);
    private void EnsureIsInitialized();
    private void EnsureIsInitializedCore();
}
public class System.ServiceModel.Dispatcher.TaskMethodInvoker : object {
    private static string ResultMethodName;
    private InvokeDelegate _invokeDelegate;
    private int _inputParameterCount;
    private int _outputParameterCount;
    private string _methodName;
    private MethodInfo _taskTResultGetMethod;
    private bool _isGenericTask;
    [CompilerGeneratedAttribute]
private MethodInfo <Method>k__BackingField;
    public MethodInfo Method { get; }
    public string MethodName { get; }
    public TaskMethodInvoker(MethodInfo taskMethod, Type taskType);
    [CompilerGeneratedAttribute]
public MethodInfo get_Method();
    public string get_MethodName();
    public sealed virtual Object[] AllocateInputs();
    public sealed virtual IAsyncResult InvokeBegin(object instance, Object[] inputs, AsyncCallback callback, object state);
    public sealed virtual object InvokeEnd(object instance, Object[]& outputs, IAsyncResult result);
    [AsyncStateMachineAttribute("System.ServiceModel.Dispatcher.TaskMethodInvoker/<InvokeAsync>d__16")]
private Task`1<Tuple`2<object, Object[]>> InvokeAsync(object instance, Object[] inputs);
    private void EnsureIsInitialized();
    private void EnsureIsInitializedCore();
}
internal class System.ServiceModel.Dispatcher.TerminatingOperationBehavior : object {
    private static TimerCallback s_abortChannelTimerCallback;
    private static TerminatingOperationBehavior();
    private static void AbortChannel(object state);
    public static TerminatingOperationBehavior CreateIfNecessary(DispatchRuntime dispatch);
    private static bool IsTerminatingOperationBehaviorNeeded(DispatchRuntime dispatch);
    internal void AfterReply(MessageRpc& rpc);
    internal static void AfterReply(ProxyRpc& rpc);
}
internal class System.ServiceModel.Dispatcher.ThreadBehavior : object {
    private SendOrPostCallback _threadAffinityStartCallback;
    private SendOrPostCallback _threadAffinityEndCallback;
    private static Action`1<object> s_cleanThreadCallback;
    private SynchronizationContext _context;
    private SendOrPostCallback ThreadAffinityStartCallbackDelegate { get; }
    private SendOrPostCallback ThreadAffinityEndCallbackDelegate { get; }
    private static Action`1<object> CleanThreadCallbackDelegate { get; }
    internal ThreadBehavior(DispatchRuntime dispatch);
    private SendOrPostCallback get_ThreadAffinityStartCallbackDelegate();
    private SendOrPostCallback get_ThreadAffinityEndCallbackDelegate();
    private static Action`1<object> get_CleanThreadCallbackDelegate();
    internal void BindThread(MessageRpc& rpc);
    internal void BindEndThread(MessageRpc& rpc);
    private void BindCore(MessageRpc& rpc, bool startOperation);
    private SynchronizationContext GetSyncContext(InstanceContext instanceContext);
    private void SynchronizationContextStartCallback(object state);
    private void SynchronizationContextEndCallback(object state);
    private void ResumeProcessing(IResumeMessageRpc resume);
    private static void CleanThreadCallback(object state);
    internal static SynchronizationContext GetCurrentSynchronizationContext();
}
internal class System.ServiceModel.Dispatcher.XmlSerializerFaultFormatter : FaultFormatter {
    private SynchronizedCollection`1<XmlSerializerFaultContractInfo> _xmlSerializerFaultContractInfos;
    internal XmlSerializerFaultFormatter(Type[] detailTypes, SynchronizedCollection`1<XmlSerializerFaultContractInfo> xmlSerializerFaultContractInfos);
    internal XmlSerializerFaultFormatter(SynchronizedCollection`1<FaultContractInfo> faultContractInfoCollection, SynchronizedCollection`1<XmlSerializerFaultContractInfo> xmlSerializerFaultContractInfos);
    private void Initialize(SynchronizedCollection`1<XmlSerializerFaultContractInfo> xmlSerializerFaultContractInfos);
    protected virtual XmlObjectSerializer GetSerializer(Type detailType, string faultExceptionAction, String& action);
    protected virtual FaultException CreateFaultException(MessageFault messageFault, string action);
}
internal class System.ServiceModel.Dispatcher.XmlSerializerObjectSerializer : XmlObjectSerializer {
    private XmlSerializer _serializer;
    private Type _rootType;
    private string _rootName;
    private string _rootNamespace;
    private bool _isSerializerSetExplicit;
    internal XmlSerializerObjectSerializer(Type type);
    internal XmlSerializerObjectSerializer(Type type, XmlQualifiedName qualifiedName, XmlSerializer xmlSerializer);
    private void Initialize(Type type, string rootName, string rootNamespace, XmlSerializer xmlSerializer);
    public virtual void WriteObject(XmlDictionaryWriter writer, object graph);
    public virtual void WriteStartObject(XmlDictionaryWriter writer, object graph);
    public virtual void WriteObjectContent(XmlDictionaryWriter writer, object graph);
    public virtual void WriteEndObject(XmlDictionaryWriter writer);
    public virtual object ReadObject(XmlDictionaryReader reader, bool verifyObjectName);
    public virtual bool IsStartObject(XmlDictionaryReader reader);
}
internal class System.ServiceModel.Dispatcher.XmlSerializerOperationFormatter : OperationFormatter {
    private static string soap11Encoding;
    private static string soap12Encoding;
    private bool _isEncoded;
    private MessageInfo _requestMessageInfo;
    private MessageInfo _replyMessageInfo;
    public XmlSerializerOperationFormatter(OperationDescription description, XmlSerializerFormatAttribute xmlSerializerFormatAttribute, MessageInfo requestMessageInfo, MessageInfo replyMessageInfo);
    protected virtual void AddHeadersToMessage(Message message, MessageDescription messageDescription, Object[] parameters, bool isRequest);
    protected virtual void GetHeadersFromMessage(Message message, MessageDescription messageDescription, Object[] parameters, bool isRequest);
    private static void AddUnknownHeader(MessageHeaderDescription unknownHeaderDescription, ArrayList unknownHeaders, XmlDocument xmlDoc, XmlDictionaryWriter bufferWriter, MessageHeaderInfo header, XmlDictionaryReader headerReader);
    protected virtual void WriteBodyAttributes(XmlDictionaryWriter writer, MessageVersion version);
    protected virtual void SerializeBody(XmlDictionaryWriter writer, MessageVersion version, string action, MessageDescription messageDescription, object returnValue, Object[] parameters, bool isRequest);
    private void SerializeBody(XmlDictionaryWriter writer, MessageVersion version, XmlSerializer serializer, MessagePartDescription returnPart, MessagePartDescriptionCollection bodyParts, object returnValue, Object[] parameters);
    protected virtual object DeserializeBody(XmlDictionaryReader reader, MessageVersion version, string action, MessageDescription messageDescription, Object[] parameters, bool isRequest);
    private object DeserializeBody(XmlDictionaryReader reader, MessageVersion version, XmlSerializer serializer, MessagePartDescription returnPart, MessagePartDescriptionCollection bodyParts, Object[] parameters, bool isRequest);
    internal static string GetEncoding(EnvelopeVersion version);
}
public class System.ServiceModel.DnsEndpointIdentity : EndpointIdentity {
    public DnsEndpointIdentity(string dnsName);
    public DnsEndpointIdentity(Claim identity);
    internal virtual void WriteContentsTo(XmlDictionaryWriter writer);
}
internal static class System.ServiceModel.DotNetAddressingStrings : object {
    public static string Namespace;
    public static string RedirectTo;
    public static string Via;
}
internal static class System.ServiceModel.DotNetAtomicTransactionExternalStrings : object {
    public static string Namespace;
    public static string Prefix;
    public static string Enlistment;
    public static string Protocol;
    public static string LocalTransactionId;
    public static string IsolationLevel;
    public static string IsolationFlags;
    public static string Description;
    public static string Loopback;
    public static string RegisterInfo;
    public static string ContextId;
    public static string TokenId;
    public static string AccessDenied;
    public static string InvalidPolicy;
    public static string CoordinatorRegistrationFailed;
    public static string TooManyEnlistments;
    public static string Disabled;
}
internal static class System.ServiceModel.DotNetOneWayStrings : object {
    public static string Namespace;
    public static string HeaderName;
}
internal class System.ServiceModel.DotNetSecurityDictionary : object {
    public XmlDictionaryString Namespace;
    public XmlDictionaryString Prefix;
    public DotNetSecurityDictionary(ServiceModelDictionary dictionary);
}
internal static class System.ServiceModel.DotNetSecurityStrings : object {
    public static string Namespace;
    public static string Prefix;
    public static string KeyRenewalNeededFault;
    public static string SecuritySessionAbortedFault;
    public static string SecurityServerTooBusyFault;
    public static string SecuritySessionFaultAction;
    public static string SecureConversationCancelNotAllowedFault;
}
public class System.ServiceModel.DuplexChannelFactory`1 : ChannelFactory`1<TChannel> {
    public DuplexChannelFactory`1(Type callbackInstanceType);
    public DuplexChannelFactory`1(Type callbackInstanceType, Binding binding, string remoteAddress);
    public DuplexChannelFactory`1(Type callbackInstanceType, Binding binding, EndpointAddress remoteAddress);
    public DuplexChannelFactory`1(Type callbackInstanceType, Binding binding);
    public DuplexChannelFactory`1(Type callbackInstanceType, ServiceEndpoint endpoint);
    public DuplexChannelFactory`1(InstanceContext callbackInstance);
    public DuplexChannelFactory`1(InstanceContext callbackInstance, Binding binding, string remoteAddress);
    public DuplexChannelFactory`1(InstanceContext callbackInstance, Binding binding, EndpointAddress remoteAddress);
    public DuplexChannelFactory`1(InstanceContext callbackInstance, Binding binding);
    public DuplexChannelFactory`1(InstanceContext callbackInstance, ServiceEndpoint endpoint);
    public DuplexChannelFactory`1(object callbackObject);
    public DuplexChannelFactory`1(object callbackObject, Binding binding);
    public DuplexChannelFactory`1(object callbackObject, Binding binding, string remoteAddress);
    public DuplexChannelFactory`1(object callbackObject, Binding binding, EndpointAddress remoteAddress);
    public DuplexChannelFactory`1(object callbackObject, ServiceEndpoint endpoint);
    internal void CheckAndAssignCallbackInstance(object callbackInstance);
    public TChannel CreateChannel(InstanceContext callbackInstance);
    public TChannel CreateChannel(InstanceContext callbackInstance, EndpointAddress address);
    public virtual TChannel CreateChannel(EndpointAddress address, Uri via);
    public virtual TChannel CreateChannel(InstanceContext callbackInstance, EndpointAddress address, Uri via);
    private static InstanceContext GetInstanceContextForObject(object callbackObject);
    public static TChannel CreateChannel(object callbackObject, Binding binding, EndpointAddress endpointAddress);
    public static TChannel CreateChannel(object callbackObject, Binding binding, EndpointAddress endpointAddress, Uri via);
    public static TChannel CreateChannel(InstanceContext callbackInstance, Binding binding, EndpointAddress endpointAddress);
    public static TChannel CreateChannel(InstanceContext callbackInstance, Binding binding, EndpointAddress endpointAddress, Uri via);
}
public abstract class System.ServiceModel.DuplexClientBase`1 : ClientBase`1<TChannel> {
    public IDuplexContextChannel InnerDuplexChannel { get; }
    protected DuplexClientBase`1(InstanceContext callbackInstance, Binding binding, EndpointAddress remoteAddress);
    public IDuplexContextChannel get_InnerDuplexChannel();
}
internal static class System.ServiceModel.DXD : object {
    private static Wsrm11Dictionary s_wsrm11Dictionary;
    [CompilerGeneratedAttribute]
private static AtomicTransactionExternal11Dictionary <AtomicTransactionExternal11Dictionary>k__BackingField;
    [CompilerGeneratedAttribute]
private static CoordinationExternal11Dictionary <CoordinationExternal11Dictionary>k__BackingField;
    [CompilerGeneratedAttribute]
private static SecureConversationDec2005Dictionary <SecureConversationDec2005Dictionary>k__BackingField;
    [CompilerGeneratedAttribute]
private static SecurityAlgorithmDec2005Dictionary <SecurityAlgorithmDec2005Dictionary>k__BackingField;
    [CompilerGeneratedAttribute]
private static TrustDec2005Dictionary <TrustDec2005Dictionary>k__BackingField;
    public static AtomicTransactionExternal11Dictionary AtomicTransactionExternal11Dictionary { get; private set; }
    public static CoordinationExternal11Dictionary CoordinationExternal11Dictionary { get; private set; }
    public static SecureConversationDec2005Dictionary SecureConversationDec2005Dictionary { get; private set; }
    public static SecurityAlgorithmDec2005Dictionary SecurityAlgorithmDec2005Dictionary { get; private set; }
    public static TrustDec2005Dictionary TrustDec2005Dictionary { get; private set; }
    public static Wsrm11Dictionary Wsrm11Dictionary { get; }
    private static DXD();
    [CompilerGeneratedAttribute]
public static AtomicTransactionExternal11Dictionary get_AtomicTransactionExternal11Dictionary();
    [CompilerGeneratedAttribute]
private static void set_AtomicTransactionExternal11Dictionary(AtomicTransactionExternal11Dictionary value);
    [CompilerGeneratedAttribute]
public static CoordinationExternal11Dictionary get_CoordinationExternal11Dictionary();
    [CompilerGeneratedAttribute]
private static void set_CoordinationExternal11Dictionary(CoordinationExternal11Dictionary value);
    [CompilerGeneratedAttribute]
public static SecureConversationDec2005Dictionary get_SecureConversationDec2005Dictionary();
    [CompilerGeneratedAttribute]
private static void set_SecureConversationDec2005Dictionary(SecureConversationDec2005Dictionary value);
    [CompilerGeneratedAttribute]
public static SecurityAlgorithmDec2005Dictionary get_SecurityAlgorithmDec2005Dictionary();
    [CompilerGeneratedAttribute]
private static void set_SecurityAlgorithmDec2005Dictionary(SecurityAlgorithmDec2005Dictionary value);
    [CompilerGeneratedAttribute]
public static TrustDec2005Dictionary get_TrustDec2005Dictionary();
    [CompilerGeneratedAttribute]
private static void set_TrustDec2005Dictionary(TrustDec2005Dictionary value);
    public static Wsrm11Dictionary get_Wsrm11Dictionary();
}
internal static class System.ServiceModel.EmptyArray`1 : object {
    internal static T[] Allocate(int n);
    internal static T[] ToArray(IList`1<T> collection);
    internal static T[] ToArray(SynchronizedCollection`1<T> collection);
}
public class System.ServiceModel.EndpointAddress : object {
    private static Uri s_anonymousUri;
    private static Uri s_noneUri;
    private static EndpointAddress s_anonymousAddress;
    private AddressingVersion _addressingVersion;
    private AddressHeaderCollection _headers;
    private int _extensionSection;
    private int _metadataSection;
    private int _pspSection;
    private bool _isNone;
    internal static string DummyName;
    internal static string DummyNamespace;
    [CompilerGeneratedAttribute]
private XmlBuffer <Buffer>k__BackingField;
    [CompilerGeneratedAttribute]
private EndpointIdentity <Identity>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsAnonymous>k__BackingField;
    [CompilerGeneratedAttribute]
private Uri <Uri>k__BackingField;
    internal static EndpointAddress AnonymousAddress { get; }
    public static Uri AnonymousUri { get; }
    public static Uri NoneUri { get; }
    internal XmlBuffer Buffer { get; private set; }
    public AddressHeaderCollection Headers { get; }
    public EndpointIdentity Identity { get; private set; }
    public bool IsAnonymous { get; private set; }
    public bool IsNone { get; }
    public Uri Uri { get; private set; }
    private EndpointAddress(AddressingVersion version, Uri uri, EndpointIdentity identity, AddressHeaderCollection headers, XmlBuffer buffer, int metadataSection, int extensionSection, int pspSection);
    public EndpointAddress(string uri);
    public EndpointAddress(Uri uri, AddressHeader[] addressHeaders);
    public EndpointAddress(Uri uri, EndpointIdentity identity, AddressHeader[] addressHeaders);
    internal EndpointAddress(Uri newUri, EndpointAddress oldEndpointAddress);
    internal EndpointAddress(Uri uri, EndpointIdentity identity, AddressHeaderCollection headers, XmlDictionaryReader metadataReader, XmlDictionaryReader extensionReader, XmlDictionaryReader pspReader);
    private void Init(Uri uri, EndpointIdentity identity, AddressHeader[] headers);
    private void Init(Uri uri, EndpointIdentity identity, AddressHeaderCollection headers, XmlBuffer buffer, int metadataSection, int extensionSection, int pspSection);
    private void Init(AddressingVersion version, Uri uri, EndpointIdentity identity, AddressHeaderCollection headers, XmlBuffer buffer, int metadataSection, int extensionSection, int pspSection);
    internal static EndpointAddress get_AnonymousAddress();
    public static Uri get_AnonymousUri();
    public static Uri get_NoneUri();
    [CompilerGeneratedAttribute]
internal XmlBuffer get_Buffer();
    [CompilerGeneratedAttribute]
private void set_Buffer(XmlBuffer value);
    public AddressHeaderCollection get_Headers();
    [CompilerGeneratedAttribute]
public EndpointIdentity get_Identity();
    [CompilerGeneratedAttribute]
private void set_Identity(EndpointIdentity value);
    [CompilerGeneratedAttribute]
public bool get_IsAnonymous();
    [CompilerGeneratedAttribute]
private void set_IsAnonymous(bool value);
    public bool get_IsNone();
    [CompilerGeneratedAttribute]
public Uri get_Uri();
    [CompilerGeneratedAttribute]
private void set_Uri(Uri value);
    public void ApplyTo(Message message);
    internal static bool UriEquals(Uri u1, Uri u2, bool ignoreCase, bool includeHostInComparison);
    internal static bool UriEquals(Uri u1, Uri u2, bool ignoreCase, bool includeHostInComparison, bool includePortInComparison);
    internal static int UriGetHashCode(Uri uri, bool includeHostInComparison);
    internal static int UriGetHashCode(Uri uri, bool includeHostInComparison, bool includePortInComparison);
    internal bool EndpointEquals(EndpointAddress endpointAddress);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    internal XmlDictionaryReader GetReaderAtPsp();
    public XmlDictionaryReader GetReaderAtMetadata();
    public XmlDictionaryReader GetReaderAtExtensions();
    private static XmlDictionaryReader GetReaderAtSection(XmlBuffer buffer, int section);
    private void PossiblyPopulateBuffer(XmlDictionaryReader reader, XmlBuffer& buffer, Int32& section);
    public static EndpointAddress ReadFrom(XmlDictionaryReader reader);
    internal static EndpointAddress ReadFrom(XmlDictionaryReader reader, AddressingVersion& version);
    public static EndpointAddress ReadFrom(AddressingVersion addressingVersion, XmlDictionaryReader reader);
    public static EndpointAddress ReadFrom(AddressingVersion addressingVersion, XmlDictionaryReader reader, XmlDictionaryString localName, XmlDictionaryString ns);
    private static EndpointAddress ReadFromDriver(AddressingVersion addressingVersion, XmlDictionaryReader reader);
    internal static XmlBuffer ReadExtensions(XmlDictionaryReader reader, AddressingVersion version, XmlBuffer buffer, EndpointIdentity& identity, Int32& section);
    private static bool ReadContentsFrom200408(XmlDictionaryReader reader, Uri& uri, AddressHeaderCollection& headers, EndpointIdentity& identity, XmlBuffer& buffer, Int32& metadataSection, Int32& extensionSection, Int32& pspSection);
    private static bool ReadContentsFrom10(XmlDictionaryReader reader, Uri& uri, AddressHeaderCollection& headers, EndpointIdentity& identity, XmlBuffer& buffer, Int32& metadataSection, Int32& extensionSection);
    private static XmlException CreateXmlException(XmlDictionaryReader reader, string message);
    private static bool Done(XmlDictionaryReader reader);
    internal static void Copy(XmlDictionaryWriter writer, XmlDictionaryReader reader);
    public virtual string ToString();
    public void WriteContentsTo(AddressingVersion addressingVersion, XmlDictionaryWriter writer);
    private void WriteContentsToNone(XmlDictionaryWriter writer);
    private void WriteContentsTo200408(XmlDictionaryWriter writer);
    private void WriteContentsTo10(XmlDictionaryWriter writer);
    public void WriteContentsTo(AddressingVersion addressingVersion, XmlWriter writer);
    public void WriteTo(AddressingVersion addressingVersion, XmlDictionaryWriter writer);
    public void WriteTo(AddressingVersion addressingVersion, XmlDictionaryWriter writer, XmlDictionaryString localName, XmlDictionaryString ns);
    public void WriteTo(AddressingVersion addressingVersion, XmlWriter writer);
    public void WriteTo(AddressingVersion addressingVersion, XmlWriter writer, string localName, string ns);
    public static bool op_Equality(EndpointAddress address1, EndpointAddress address2);
    public static bool op_Inequality(EndpointAddress address1, EndpointAddress address2);
}
public class System.ServiceModel.EndpointAddressBuilder : object {
    private XmlBuffer _extensionBuffer;
    private XmlBuffer _metadataBuffer;
    private bool _hasExtension;
    private bool _hasMetadata;
    private EndpointAddress _epr;
    [CompilerGeneratedAttribute]
private Uri <Uri>k__BackingField;
    [CompilerGeneratedAttribute]
private EndpointIdentity <Identity>k__BackingField;
    [CompilerGeneratedAttribute]
private Collection`1<AddressHeader> <Headers>k__BackingField;
    public Uri Uri { get; public set; }
    public EndpointIdentity Identity { get; public set; }
    public Collection`1<AddressHeader> Headers { get; }
    public EndpointAddressBuilder(EndpointAddress address);
    [CompilerGeneratedAttribute]
public Uri get_Uri();
    [CompilerGeneratedAttribute]
public void set_Uri(Uri value);
    [CompilerGeneratedAttribute]
public EndpointIdentity get_Identity();
    [CompilerGeneratedAttribute]
public void set_Identity(EndpointIdentity value);
    [CompilerGeneratedAttribute]
public Collection`1<AddressHeader> get_Headers();
    public XmlDictionaryReader GetReaderAtMetadata();
    public void SetMetadataReader(XmlDictionaryReader reader);
    public XmlDictionaryReader GetReaderAtExtensions();
    public void SetExtensionReader(XmlDictionaryReader reader);
    public EndpointAddress ToEndpointAddress();
}
public abstract class System.ServiceModel.EndpointIdentity : object {
    private Claim _identityClaim;
    private IEqualityComparer`1<Claim> _claimComparer;
    public Claim IdentityClaim { get; }
    protected void Initialize(Claim identityClaim);
    protected void Initialize(Claim identityClaim, IEqualityComparer`1<Claim> claimComparer);
    public Claim get_IdentityClaim();
    public static EndpointIdentity CreateIdentity(Claim identity);
    public static EndpointIdentity CreateDnsIdentity(string dnsName);
    public static EndpointIdentity CreateSpnIdentity(string spnName);
    public static EndpointIdentity CreateUpnIdentity(string upnName);
    internal virtual void EnsureIdentityClaim();
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    internal bool Matches(Claim claim);
    private IEqualityComparer`1<Claim> GetClaimComparer();
    internal static EndpointIdentity ReadIdentity(XmlDictionaryReader reader);
    internal void WriteTo(XmlDictionaryWriter writer);
    internal virtual void WriteContentsTo(XmlDictionaryWriter writer);
}
public class System.ServiceModel.EndpointNotFoundException : CommunicationException {
    public EndpointNotFoundException(string message);
    public EndpointNotFoundException(string message, Exception innerException);
    protected EndpointNotFoundException(SerializationInfo info, StreamingContext context);
}
internal abstract class System.ServiceModel.EndpointTrait`1 : object {
    public abstract virtual ChannelFactory`1<TChannel> CreateChannelFactory();
}
public class System.ServiceModel.EnvelopeVersion : object {
    private string _ns;
    private string _toStringFormat;
    private string _receiverFaultName;
    private static string Soap11ToStringFormat;
    private static string Soap12ToStringFormat;
    private static string EnvelopeNoneToStringFormat;
    private static EnvelopeVersion s_soap12;
    [CompilerGeneratedAttribute]
private string <Actor>k__BackingField;
    [CompilerGeneratedAttribute]
private XmlDictionaryString <DictionaryActor>k__BackingField;
    [CompilerGeneratedAttribute]
private XmlDictionaryString <DictionaryNamespace>k__BackingField;
    [CompilerGeneratedAttribute]
private string <NextDestinationActorValue>k__BackingField;
    [CompilerGeneratedAttribute]
private static EnvelopeVersion <None>k__BackingField;
    [CompilerGeneratedAttribute]
private static EnvelopeVersion <Soap11>k__BackingField;
    [CompilerGeneratedAttribute]
private string <SenderFaultName>k__BackingField;
    [CompilerGeneratedAttribute]
private String[] <MustUnderstandActorValues>k__BackingField;
    [CompilerGeneratedAttribute]
private string <UltimateDestinationActor>k__BackingField;
    [CompilerGeneratedAttribute]
private String[] <UltimateDestinationActorValues>k__BackingField;
    internal string Actor { get; }
    internal XmlDictionaryString DictionaryActor { get; }
    internal string Namespace { get; }
    internal XmlDictionaryString DictionaryNamespace { get; }
    public string NextDestinationActorValue { get; }
    public static EnvelopeVersion None { get; }
    public static EnvelopeVersion Soap11 { get; }
    public static EnvelopeVersion Soap12 { get; }
    internal string ReceiverFaultName { get; }
    internal string SenderFaultName { get; }
    internal String[] MustUnderstandActorValues { get; }
    internal string UltimateDestinationActor { get; }
    internal String[] UltimateDestinationActorValues { get; }
    private EnvelopeVersion(string ultimateReceiverActor, string nextDestinationActorValue, string ns, XmlDictionaryString dictionaryNs, string actor, XmlDictionaryString dictionaryActor, string toStringFormat, string senderFaultName, string receiverFaultName);
    private static EnvelopeVersion();
    [CompilerGeneratedAttribute]
internal string get_Actor();
    [CompilerGeneratedAttribute]
internal XmlDictionaryString get_DictionaryActor();
    internal string get_Namespace();
    [CompilerGeneratedAttribute]
internal XmlDictionaryString get_DictionaryNamespace();
    [CompilerGeneratedAttribute]
public string get_NextDestinationActorValue();
    [CompilerGeneratedAttribute]
public static EnvelopeVersion get_None();
    [CompilerGeneratedAttribute]
public static EnvelopeVersion get_Soap11();
    public static EnvelopeVersion get_Soap12();
    internal string get_ReceiverFaultName();
    [CompilerGeneratedAttribute]
internal string get_SenderFaultName();
    [CompilerGeneratedAttribute]
internal String[] get_MustUnderstandActorValues();
    [CompilerGeneratedAttribute]
internal string get_UltimateDestinationActor();
    public String[] GetUltimateDestinationActorValues();
    [CompilerGeneratedAttribute]
internal String[] get_UltimateDestinationActorValues();
    internal bool IsUltimateDestinationActor(string actor);
    public virtual string ToString();
}
[DataContractAttribute]
public class System.ServiceModel.ExceptionDetail : object {
    private string _type;
    [CompilerGeneratedAttribute]
private string <HelpLink>k__BackingField;
    [CompilerGeneratedAttribute]
private ExceptionDetail <InnerException>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Message>k__BackingField;
    [CompilerGeneratedAttribute]
private string <StackTrace>k__BackingField;
    [DataMemberAttribute]
public string HelpLink { get; public set; }
    [DataMemberAttribute]
public ExceptionDetail InnerException { get; public set; }
    [DataMemberAttribute]
public string Message { get; public set; }
    [DataMemberAttribute]
public string StackTrace { get; public set; }
    [DataMemberAttribute]
public string Type { get; public set; }
    public ExceptionDetail(Exception exception);
    [CompilerGeneratedAttribute]
public string get_HelpLink();
    [CompilerGeneratedAttribute]
public void set_HelpLink(string value);
    [CompilerGeneratedAttribute]
public ExceptionDetail get_InnerException();
    [CompilerGeneratedAttribute]
public void set_InnerException(ExceptionDetail value);
    [CompilerGeneratedAttribute]
public string get_Message();
    [CompilerGeneratedAttribute]
public void set_Message(string value);
    [CompilerGeneratedAttribute]
public string get_StackTrace();
    [CompilerGeneratedAttribute]
public void set_StackTrace(string value);
    public string get_Type();
    public void set_Type(string value);
    public virtual string ToString();
    private string ToStringHelper(bool isInner);
}
internal class System.ServiceModel.ExceptionHelper : object {
    public static Exception AsError(Exception exception);
    public static PlatformNotSupportedException PlatformNotSupported();
    public static PlatformNotSupportedException PlatformNotSupported(string message);
    public static Exception CreateMaxReceivedMessageSizeExceededException(long maxMessageSize);
}
internal static class System.ServiceModel.ExclusiveC14NStrings : object {
    public static string Namespace;
    public static string PrefixList;
    public static string InclusiveNamespaces;
    public static string Prefix;
}
public class System.ServiceModel.ExtensionCollection`1 : SynchronizedCollection`1<IExtension`1<T>> {
    private T _owner;
    private bool System.Collections.Generic.ICollection<System.ServiceModel.IExtension<T>>.IsReadOnly { get; }
    public ExtensionCollection`1(T owner);
    public ExtensionCollection`1(T owner, object syncRoot);
    private sealed virtual override bool System.Collections.Generic.ICollection<System.ServiceModel.IExtension<T>>.get_IsReadOnly();
    protected virtual void ClearItems();
    public sealed virtual E Find();
    public sealed virtual Collection`1<E> FindAll();
    protected virtual void InsertItem(int index, IExtension`1<T> item);
    protected virtual void RemoveItem(int index);
    protected virtual void SetItem(int index, IExtension`1<T> item);
}
public class System.ServiceModel.FaultCode : object {
    private string _ns;
    private EnvelopeVersion _version;
    [CompilerGeneratedAttribute]
private string <Name>k__BackingField;
    [CompilerGeneratedAttribute]
private FaultCode <SubCode>k__BackingField;
    public bool IsPredefinedFault { get; }
    public bool IsSenderFault { get; }
    public bool IsReceiverFault { get; }
    public string Namespace { get; }
    public string Name { get; }
    public FaultCode SubCode { get; }
    public FaultCode(string name);
    public FaultCode(string name, FaultCode subCode);
    public FaultCode(string name, string ns);
    public FaultCode(string name, string ns, FaultCode subCode);
    public bool get_IsPredefinedFault();
    public bool get_IsSenderFault();
    public bool get_IsReceiverFault();
    public string get_Namespace();
    [CompilerGeneratedAttribute]
public string get_Name();
    [CompilerGeneratedAttribute]
public FaultCode get_SubCode();
    public static FaultCode CreateSenderFaultCode(FaultCode subCode);
    public static FaultCode CreateSenderFaultCode(string name, string ns);
    public static FaultCode CreateReceiverFaultCode(FaultCode subCode);
    public static FaultCode CreateReceiverFaultCode(string name, string ns);
}
internal class System.ServiceModel.FaultCodeConstants : object {
}
[AttributeUsageAttribute("64")]
public class System.ServiceModel.FaultContractAttribute : Attribute {
    private string _action;
    private string _name;
    private string _ns;
    private ProtectionLevel _protectionLevel;
    [CompilerGeneratedAttribute]
private Type <DetailType>k__BackingField;
    internal static string ProtectionLevelPropertyName;
    [CompilerGeneratedAttribute]
private bool <HasProtectionLevel>k__BackingField;
    public Type DetailType { get; }
    public string Action { get; public set; }
    public string Name { get; public set; }
    public string Namespace { get; public set; }
    public ProtectionLevel ProtectionLevel { get; public set; }
    public bool HasProtectionLevel { get; private set; }
    public FaultContractAttribute(Type detailType);
    [CompilerGeneratedAttribute]
public Type get_DetailType();
    public string get_Action();
    public void set_Action(string value);
    public string get_Name();
    public void set_Name(string value);
    public string get_Namespace();
    public void set_Namespace(string value);
    public ProtectionLevel get_ProtectionLevel();
    public void set_ProtectionLevel(ProtectionLevel value);
    [CompilerGeneratedAttribute]
public bool get_HasProtectionLevel();
    [CompilerGeneratedAttribute]
private void set_HasProtectionLevel(bool value);
}
[KnownTypeAttribute("System.ServiceModel.FaultException/FaultCodeData")]
[KnownTypeAttribute("System.ServiceModel.FaultException/FaultCodeData[]")]
[KnownTypeAttribute("System.ServiceModel.FaultException/FaultReasonData")]
[KnownTypeAttribute("System.ServiceModel.FaultException/FaultReasonData[]")]
public class System.ServiceModel.FaultException : CommunicationException {
    internal static string Namespace;
    [CompilerGeneratedAttribute]
private string <Action>k__BackingField;
    [CompilerGeneratedAttribute]
private FaultCode <Code>k__BackingField;
    [CompilerGeneratedAttribute]
private FaultReason <Reason>k__BackingField;
    [CompilerGeneratedAttribute]
private MessageFault <Fault>k__BackingField;
    public string Action { get; }
    public FaultCode Code { get; }
    private static FaultReason DefaultReason { get; }
    private static FaultCode DefaultCode { get; }
    public string Message { get; }
    public FaultReason Reason { get; }
    internal MessageFault Fault { get; }
    public FaultException(string reason);
    public FaultException(FaultReason reason);
    public FaultException(string reason, FaultCode code);
    public FaultException(FaultReason reason, FaultCode code);
    public FaultException(string reason, FaultCode code, string action);
    internal FaultException(string reason, FaultCode code, string action, Exception innerException);
    public FaultException(FaultReason reason, FaultCode code, string action);
    internal FaultException(FaultReason reason, FaultCode code, string action, Exception innerException);
    public FaultException(MessageFault fault);
    public FaultException(MessageFault fault, string action);
    protected FaultException(SerializationInfo info, StreamingContext context);
    [CompilerGeneratedAttribute]
public string get_Action();
    [CompilerGeneratedAttribute]
public FaultCode get_Code();
    private static FaultReason get_DefaultReason();
    private static FaultCode get_DefaultCode();
    public virtual string get_Message();
    [CompilerGeneratedAttribute]
public FaultReason get_Reason();
    [CompilerGeneratedAttribute]
internal MessageFault get_Fault();
    internal void AddFaultCodeObjectData(SerializationInfo info, string key, FaultCode code);
    internal void AddFaultReasonObjectData(SerializationInfo info, string key, FaultReason reason);
    public static FaultException CreateFault(MessageFault messageFault, Type[] faultDetailTypes);
    public static FaultException CreateFault(MessageFault messageFault, string action, Type[] faultDetailTypes);
    public virtual MessageFault CreateMessageFault();
    private static FaultReason CreateReason(string reason);
    [ObsoleteAttribute]
public virtual void GetObjectData(SerializationInfo info, StreamingContext context);
    private static FaultReason GetReason(MessageFault fault);
    internal static string GetSafeReasonText(MessageFault messageFault);
    internal static string GetSafeReasonText(FaultReason reason);
    private static FaultCode EnsureCode(FaultCode code);
    private static FaultReason EnsureReason(FaultReason reason);
    internal FaultCode ReconstructFaultCode(SerializationInfo info, string key);
    internal FaultReason ReconstructFaultReason(SerializationInfo info, string key);
}
[KnownTypeAttribute("GetKnownTypes")]
public class System.ServiceModel.FaultException`1 : FaultException {
    [CompilerGeneratedAttribute]
private TDetail <Detail>k__BackingField;
    private static Type[] s_knownTypes;
    public TDetail Detail { get; }
    public FaultException`1(TDetail detail);
    public FaultException`1(TDetail detail, string reason);
    public FaultException`1(TDetail detail, FaultReason reason);
    public FaultException`1(TDetail detail, string reason, FaultCode code);
    public FaultException`1(TDetail detail, FaultReason reason, FaultCode code);
    public FaultException`1(TDetail detail, string reason, FaultCode code, string action);
    public FaultException`1(TDetail detail, FaultReason reason, FaultCode code, string action);
    protected FaultException`1(SerializationInfo info, StreamingContext context);
    private static FaultException`1();
    [CompilerGeneratedAttribute]
public TDetail get_Detail();
    public virtual MessageFault CreateMessageFault();
    [ObsoleteAttribute]
public virtual void GetObjectData(SerializationInfo info, StreamingContext context);
    public virtual string ToString();
    internal static IEnumerable`1<Type> GetKnownTypes();
}
public class System.ServiceModel.FaultReason : object {
    [CompilerGeneratedAttribute]
private SynchronizedReadOnlyCollection`1<FaultReasonText> <Translations>k__BackingField;
    public SynchronizedReadOnlyCollection`1<FaultReasonText> Translations { get; private set; }
    public FaultReason(FaultReasonText translation);
    public FaultReason(string text);
    internal FaultReason(string text, string xmlLang);
    internal FaultReason(string text, CultureInfo cultureInfo);
    public FaultReason(IEnumerable`1<FaultReasonText> translations);
    private void Init(FaultReasonText translation);
    private void Init(FaultReasonText[] translations);
    public FaultReasonText GetMatchingTranslation();
    public FaultReasonText GetMatchingTranslation(CultureInfo cultureInfo);
    [CompilerGeneratedAttribute]
public SynchronizedReadOnlyCollection`1<FaultReasonText> get_Translations();
    [CompilerGeneratedAttribute]
private void set_Translations(SynchronizedReadOnlyCollection`1<FaultReasonText> value);
    public virtual string ToString();
}
public class System.ServiceModel.FaultReasonText : object {
    private string _text;
    [CompilerGeneratedAttribute]
private string <XmlLang>k__BackingField;
    public string XmlLang { get; }
    public string Text { get; }
    public FaultReasonText(string text);
    public FaultReasonText(string text, string xmlLang);
    public FaultReasonText(string text, CultureInfo cultureInfo);
    public bool Matches(CultureInfo cultureInfo);
    [CompilerGeneratedAttribute]
public string get_XmlLang();
    public string get_Text();
}
internal class System.ServiceModel.GeneralEndpointIdentity : EndpointIdentity {
    public GeneralEndpointIdentity(Claim identityClaim);
}
public enum System.ServiceModel.HostNameComparisonMode : Enum {
    public int value__;
    public static HostNameComparisonMode StrongWildcard;
    public static HostNameComparisonMode Exact;
    public static HostNameComparisonMode WeakWildcard;
}
public static class System.ServiceModel.HostNameComparisonModeHelper : object {
    public static bool IsDefined(HostNameComparisonMode value);
    public static void Validate(HostNameComparisonMode value);
}
public interface System.ServiceModel.IAsyncCommunicationObject {
    public abstract virtual Task CloseAsync(TimeSpan timeout);
    public abstract virtual Task OpenAsync(TimeSpan timeout);
}
internal interface System.ServiceModel.IChannelBaseProxy {
    public abstract virtual ServiceChannel GetServiceChannel();
}
public interface System.ServiceModel.IClientChannel {
    public bool AllowInitializationUI { get; public set; }
    public bool DidInteractiveInitialization { get; }
    public Uri Via { get; }
    public abstract virtual bool get_AllowInitializationUI();
    public abstract virtual void set_AllowInitializationUI(bool value);
    public abstract virtual bool get_DidInteractiveInitialization();
    public abstract virtual Uri get_Via();
    [CompilerGeneratedAttribute]
public abstract virtual void add_UnknownMessageReceived(EventHandler`1<UnknownMessageReceivedEventArgs> value);
    [CompilerGeneratedAttribute]
public abstract virtual void remove_UnknownMessageReceived(EventHandler`1<UnknownMessageReceivedEventArgs> value);
    public abstract virtual void DisplayInitializationUI();
    public abstract virtual IAsyncResult BeginDisplayInitializationUI(AsyncCallback callback, object state);
    public abstract virtual void EndDisplayInitializationUI(IAsyncResult result);
}
public interface System.ServiceModel.ICommunicationObject {
    public CommunicationState State { get; }
    public abstract virtual CommunicationState get_State();
    [CompilerGeneratedAttribute]
public abstract virtual void add_Closed(EventHandler value);
    [CompilerGeneratedAttribute]
public abstract virtual void remove_Closed(EventHandler value);
    [CompilerGeneratedAttribute]
public abstract virtual void add_Closing(EventHandler value);
    [CompilerGeneratedAttribute]
public abstract virtual void remove_Closing(EventHandler value);
    [CompilerGeneratedAttribute]
public abstract virtual void add_Faulted(EventHandler value);
    [CompilerGeneratedAttribute]
public abstract virtual void remove_Faulted(EventHandler value);
    [CompilerGeneratedAttribute]
public abstract virtual void add_Opened(EventHandler value);
    [CompilerGeneratedAttribute]
public abstract virtual void remove_Opened(EventHandler value);
    [CompilerGeneratedAttribute]
public abstract virtual void add_Opening(EventHandler value);
    [CompilerGeneratedAttribute]
public abstract virtual void remove_Opening(EventHandler value);
    public abstract virtual void Abort();
    public abstract virtual void Close();
    public abstract virtual void Close(TimeSpan timeout);
    public abstract virtual IAsyncResult BeginClose(AsyncCallback callback, object state);
    public abstract virtual IAsyncResult BeginClose(TimeSpan timeout, AsyncCallback callback, object state);
    public abstract virtual void EndClose(IAsyncResult result);
    public abstract virtual void Open();
    public abstract virtual void Open(TimeSpan timeout);
    public abstract virtual IAsyncResult BeginOpen(AsyncCallback callback, object state);
    public abstract virtual IAsyncResult BeginOpen(TimeSpan timeout, AsyncCallback callback, object state);
    public abstract virtual void EndOpen(IAsyncResult result);
}
public interface System.ServiceModel.IContextChannel {
    public bool AllowOutputBatching { get; public set; }
    public IInputSession InputSession { get; }
    public EndpointAddress LocalAddress { get; }
    public TimeSpan OperationTimeout { get; public set; }
    public IOutputSession OutputSession { get; }
    public EndpointAddress RemoteAddress { get; }
    public string SessionId { get; }
    public abstract virtual bool get_AllowOutputBatching();
    public abstract virtual void set_AllowOutputBatching(bool value);
    public abstract virtual IInputSession get_InputSession();
    public abstract virtual EndpointAddress get_LocalAddress();
    public abstract virtual TimeSpan get_OperationTimeout();
    public abstract virtual void set_OperationTimeout(TimeSpan value);
    public abstract virtual IOutputSession get_OutputSession();
    public abstract virtual EndpointAddress get_RemoteAddress();
    public abstract virtual string get_SessionId();
}
internal interface System.ServiceModel.IContextSessionProvider {
}
public interface System.ServiceModel.IDefaultCommunicationTimeouts {
    public TimeSpan CloseTimeout { get; }
    public TimeSpan OpenTimeout { get; }
    public TimeSpan ReceiveTimeout { get; }
    public TimeSpan SendTimeout { get; }
    public abstract virtual TimeSpan get_CloseTimeout();
    public abstract virtual TimeSpan get_OpenTimeout();
    public abstract virtual TimeSpan get_ReceiveTimeout();
    public abstract virtual TimeSpan get_SendTimeout();
}
public interface System.ServiceModel.IDuplexContextChannel {
    public bool AutomaticInputSessionShutdown { get; public set; }
    public InstanceContext CallbackInstance { get; public set; }
    public abstract virtual bool get_AutomaticInputSessionShutdown();
    public abstract virtual void set_AutomaticInputSessionShutdown(bool value);
    public abstract virtual InstanceContext get_CallbackInstance();
    public abstract virtual void set_CallbackInstance(InstanceContext value);
    public abstract virtual IAsyncResult BeginCloseOutputSession(TimeSpan timeout, AsyncCallback callback, object state);
    public abstract virtual void EndCloseOutputSession(IAsyncResult result);
    public abstract virtual void CloseOutputSession(TimeSpan timeout);
}
public interface System.ServiceModel.IExtensibleObject`1 {
    public IExtensionCollection`1<T> Extensions { get; }
    public abstract virtual IExtensionCollection`1<T> get_Extensions();
}
public interface System.ServiceModel.IExtension`1 {
    public abstract virtual void Attach(T owner);
    public abstract virtual void Detach(T owner);
}
public interface System.ServiceModel.IExtensionCollection`1 {
    public abstract virtual E Find();
    public abstract virtual Collection`1<E> FindAll();
}
public enum System.ServiceModel.ImpersonationOption : Enum {
    public int value__;
    public static ImpersonationOption NotAllowed;
    public static ImpersonationOption Allowed;
    public static ImpersonationOption Required;
}
internal static class System.ServiceModel.ImpersonationOptionHelper : object {
    public static bool IsDefined(ImpersonationOption option);
    internal static bool AllowedOrRequired(ImpersonationOption option);
}
public class System.ServiceModel.InstanceContext : CommunicationObject {
    private InstanceBehavior _behavior;
    private ConcurrencyInstanceContextFacet _concurrency;
    private ServiceChannelManager _channels;
    private ExtensionCollection`1<InstanceContext> _extensions;
    private object _serviceInstanceLock;
    private SynchronizationContext _synchronizationContext;
    private object _userObject;
    private bool _wellKnown;
    private bool _isUserCreated;
    internal InstanceBehavior Behavior { get; internal set; }
    internal ConcurrencyInstanceContextFacet Concurrency { get; }
    protected TimeSpan DefaultCloseTimeout { get; }
    protected TimeSpan DefaultOpenTimeout { get; }
    public IExtensionCollection`1<InstanceContext> Extensions { get; }
    public ICollection`1<IChannel> IncomingChannels { get; }
    public ICollection`1<IChannel> OutgoingChannels { get; }
    public SynchronizationContext SynchronizationContext { get; public set; }
    internal object ThisLock { get; }
    internal object UserObject { get; }
    public InstanceContext(object implementation);
    internal InstanceContext(object implementation, bool isUserCreated);
    internal InstanceContext(object implementation, bool wellKnown, bool isUserCreated);
    internal InstanceBehavior get_Behavior();
    internal void set_Behavior(InstanceBehavior value);
    internal ConcurrencyInstanceContextFacet get_Concurrency();
    protected virtual TimeSpan get_DefaultCloseTimeout();
    protected virtual TimeSpan get_DefaultOpenTimeout();
    public sealed virtual IExtensionCollection`1<InstanceContext> get_Extensions();
    public ICollection`1<IChannel> get_IncomingChannels();
    public ICollection`1<IChannel> get_OutgoingChannels();
    public SynchronizationContext get_SynchronizationContext();
    public void set_SynchronizationContext(SynchronizationContext value);
    internal object get_ThisLock();
    internal object get_UserObject();
    protected virtual void OnAbort();
    internal void BindRpc(MessageRpc& rpc);
    internal void FaultInternal();
    public object GetServiceInstance(Message message);
    protected virtual IAsyncResult OnBeginClose(TimeSpan timeout, AsyncCallback callback, object state);
    protected virtual void OnEndClose(IAsyncResult result);
    protected virtual IAsyncResult OnBeginOpen(TimeSpan timeout, AsyncCallback callback, object state);
    protected virtual void OnEndOpen(IAsyncResult result);
    protected virtual void OnClose(TimeSpan timeout);
    protected virtual void OnOpen(TimeSpan timeout);
    protected virtual void OnOpened();
    protected virtual void OnOpening();
    protected internal virtual Task OnCloseAsync(TimeSpan timeout);
    protected internal virtual Task OnOpenAsync(TimeSpan timeout);
    private void SetUserObject(object newUserObject);
    internal void UnbindRpc(MessageRpc& rpc);
}
internal class System.ServiceModel.InstanceContextEmptyCallback : MulticastDelegate {
    public InstanceContextEmptyCallback(object object, IntPtr method);
    public virtual void Invoke(InstanceContext instanceContext);
    public virtual IAsyncResult BeginInvoke(InstanceContext instanceContext, AsyncCallback callback, object object);
    public virtual void EndInvoke(IAsyncResult result);
}
public enum System.ServiceModel.InstanceContextMode : Enum {
    public int value__;
    public static InstanceContextMode PerSession;
    public static InstanceContextMode PerCall;
    public static InstanceContextMode Single;
}
internal static class System.ServiceModel.InstanceContextModeHelper : object {
    public static bool IsDefined(InstanceContextMode x);
}
public class System.ServiceModel.InvalidMessageContractException : Exception {
    public InvalidMessageContractException(string message);
    public InvalidMessageContractException(string message, Exception innerException);
    protected InvalidMessageContractException(SerializationInfo info, StreamingContext context);
}
internal interface System.ServiceModel.IOperationContractAttributeProvider {
    public abstract virtual OperationContractAttribute GetOperationContractAttribute();
}
public interface System.ServiceModel.IServiceChannel {
    public Uri ListenUri { get; }
    public abstract virtual Uri get_ListenUri();
}
internal class System.ServiceModel.KerberosSecurityTokenProviderWrapper : CommunicationObjectSecurityTokenProvider {
    private KerberosSecurityTokenProvider _innerProvider;
    public KerberosSecurityTokenProviderWrapper(KerberosSecurityTokenProvider innerProvider);
    protected virtual SecurityToken GetTokenCore(TimeSpan timeout);
    internal Task`1<SecurityToken> GetTokenAsync(TimeSpan timeout, ChannelBinding channelbinding);
    internal virtual Task`1<SecurityToken> GetTokenCoreInternalAsync(TimeSpan timeout);
}
internal class System.ServiceModel.Message11Dictionary : object {
    public XmlDictionaryString Namespace;
    public XmlDictionaryString Actor;
    public XmlDictionaryString FaultCode;
    public XmlDictionaryString FaultString;
    public XmlDictionaryString FaultActor;
    public XmlDictionaryString FaultDetail;
    public XmlDictionaryString FaultNamespace;
    public Message11Dictionary(ServiceModelDictionary dictionary);
}
internal static class System.ServiceModel.Message11Strings : object {
    public static string Namespace;
    public static string Actor;
    public static string FaultCode;
    public static string FaultString;
    public static string FaultActor;
    public static string FaultDetail;
    public static string FaultNamespace;
}
internal class System.ServiceModel.Message12Dictionary : object {
    public XmlDictionaryString Namespace;
    public XmlDictionaryString Role;
    public XmlDictionaryString Relay;
    public XmlDictionaryString FaultCode;
    public XmlDictionaryString FaultReason;
    public XmlDictionaryString FaultText;
    public XmlDictionaryString FaultNode;
    public XmlDictionaryString FaultRole;
    public XmlDictionaryString FaultDetail;
    public XmlDictionaryString FaultValue;
    public XmlDictionaryString FaultSubcode;
    public XmlDictionaryString NotUnderstood;
    public XmlDictionaryString QName;
    public Message12Dictionary(ServiceModelDictionary dictionary);
}
internal static class System.ServiceModel.Message12Strings : object {
    public static string Namespace;
    public static string Role;
    public static string Relay;
    public static string FaultCode;
    public static string FaultReason;
    public static string FaultText;
    public static string FaultNode;
    public static string FaultRole;
    public static string FaultDetail;
    public static string FaultValue;
    public static string FaultSubcode;
    public static string NotUnderstood;
    public static string QName;
}
[AttributeUsageAttribute("384")]
public class System.ServiceModel.MessageBodyMemberAttribute : MessageContractMemberAttribute {
    private int _order;
    internal static string OrderPropertyName;
    public int Order { get; public set; }
    public int get_Order();
    public void set_Order(int value);
}
[AttributeUsageAttribute("12")]
public class System.ServiceModel.MessageContractAttribute : Attribute {
    private string _wrappedName;
    private string _wrappedNs;
    private ProtectionLevel _protectionLevel;
    internal static string ProtectionLevelPropertyName;
    [CompilerGeneratedAttribute]
private bool <HasProtectionLevel>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsWrapped>k__BackingField;
    public ProtectionLevel ProtectionLevel { get; public set; }
    public bool HasProtectionLevel { get; private set; }
    public bool IsWrapped { get; public set; }
    public string WrapperName { get; public set; }
    public string WrapperNamespace { get; public set; }
    public ProtectionLevel get_ProtectionLevel();
    public void set_ProtectionLevel(ProtectionLevel value);
    [CompilerGeneratedAttribute]
public bool get_HasProtectionLevel();
    [CompilerGeneratedAttribute]
private void set_HasProtectionLevel(bool value);
    [CompilerGeneratedAttribute]
public bool get_IsWrapped();
    [CompilerGeneratedAttribute]
public void set_IsWrapped(bool value);
    public string get_WrapperName();
    public void set_WrapperName(string value);
    public string get_WrapperNamespace();
    public void set_WrapperNamespace(string value);
}
public abstract class System.ServiceModel.MessageContractMemberAttribute : Attribute {
    private string _name;
    private string _ns;
    private bool _isNamespaceSetExplicit;
    private ProtectionLevel _protectionLevel;
    internal static string NamespacePropertyName;
    internal static string NamePropertyName;
    [CompilerGeneratedAttribute]
private bool <IsNameSetExplicit>k__BackingField;
    internal static string ProtectionLevelPropertyName;
    [CompilerGeneratedAttribute]
private bool <HasProtectionLevel>k__BackingField;
    public string Namespace { get; public set; }
    internal bool IsNamespaceSetExplicit { get; }
    public string Name { get; public set; }
    internal bool IsNameSetExplicit { get; private set; }
    public ProtectionLevel ProtectionLevel { get; public set; }
    public bool HasProtectionLevel { get; private set; }
    public string get_Namespace();
    public void set_Namespace(string value);
    internal bool get_IsNamespaceSetExplicit();
    public string get_Name();
    public void set_Name(string value);
    [CompilerGeneratedAttribute]
internal bool get_IsNameSetExplicit();
    [CompilerGeneratedAttribute]
private void set_IsNameSetExplicit(bool value);
    public ProtectionLevel get_ProtectionLevel();
    public void set_ProtectionLevel(ProtectionLevel value);
    [CompilerGeneratedAttribute]
public bool get_HasProtectionLevel();
    [CompilerGeneratedAttribute]
private void set_HasProtectionLevel(bool value);
}
public enum System.ServiceModel.MessageCredentialType : Enum {
    public int value__;
    public static MessageCredentialType None;
    public static MessageCredentialType Windows;
    public static MessageCredentialType UserName;
    public static MessageCredentialType Certificate;
    public static MessageCredentialType IssuedToken;
}
internal static class System.ServiceModel.MessageCredentialTypeHelper : object {
    internal static bool IsDefined(MessageCredentialType value);
}
internal class System.ServiceModel.MessageDictionary : object {
    public XmlDictionaryString MustUnderstand;
    public XmlDictionaryString Envelope;
    public XmlDictionaryString Header;
    public XmlDictionaryString Body;
    public XmlDictionaryString Prefix;
    public XmlDictionaryString Fault;
    public XmlDictionaryString MustUnderstandFault;
    public XmlDictionaryString Namespace;
    public MessageDictionary(ServiceModelDictionary dictionary);
}
public class System.ServiceModel.MessageHeader`1 : object {
    private bool _relay;
    [CompilerGeneratedAttribute]
private string <Actor>k__BackingField;
    [CompilerGeneratedAttribute]
private T <Content>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <MustUnderstand>k__BackingField;
    public string Actor { get; public set; }
    public T Content { get; public set; }
    public bool MustUnderstand { get; public set; }
    public bool Relay { get; public set; }
    public MessageHeader`1(T content);
    public MessageHeader`1(T content, bool mustUnderstand, string actor, bool relay);
    [CompilerGeneratedAttribute]
public string get_Actor();
    [CompilerGeneratedAttribute]
public void set_Actor(string value);
    [CompilerGeneratedAttribute]
public T get_Content();
    [CompilerGeneratedAttribute]
public void set_Content(T value);
    [CompilerGeneratedAttribute]
public bool get_MustUnderstand();
    [CompilerGeneratedAttribute]
public void set_MustUnderstand(bool value);
    public bool get_Relay();
    public void set_Relay(bool value);
    internal Type GetGenericArgument();
    public MessageHeader GetUntypedHeader(string name, string ns);
}
[AttributeUsageAttribute("384")]
public class System.ServiceModel.MessageHeaderArrayAttribute : MessageHeaderAttribute {
}
[AttributeUsageAttribute("384")]
public class System.ServiceModel.MessageHeaderAttribute : MessageContractMemberAttribute {
    private bool _mustUnderstand;
    private bool _relay;
    private string _actor;
    [CompilerGeneratedAttribute]
private bool <IsMustUnderstandSet>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsRelaySet>k__BackingField;
    public bool MustUnderstand { get; public set; }
    public bool Relay { get; public set; }
    public string Actor { get; public set; }
    internal bool IsMustUnderstandSet { get; private set; }
    internal bool IsRelaySet { get; private set; }
    public bool get_MustUnderstand();
    public void set_MustUnderstand(bool value);
    public bool get_Relay();
    public void set_Relay(bool value);
    public string get_Actor();
    public void set_Actor(string value);
    [CompilerGeneratedAttribute]
internal bool get_IsMustUnderstandSet();
    [CompilerGeneratedAttribute]
private void set_IsMustUnderstandSet(bool value);
    [CompilerGeneratedAttribute]
internal bool get_IsRelaySet();
    [CompilerGeneratedAttribute]
private void set_IsRelaySet(bool value);
}
public class System.ServiceModel.MessageHeaderException : ProtocolException {
    [CompilerGeneratedAttribute]
private string <HeaderName>k__BackingField;
    [CompilerGeneratedAttribute]
private string <HeaderNamespace>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsDuplicate>k__BackingField;
    public string HeaderName { get; }
    public string HeaderNamespace { get; }
    public bool IsDuplicate { get; }
    public MessageHeaderException(string message);
    public MessageHeaderException(string message, bool isDuplicate);
    public MessageHeaderException(string message, Exception innerException);
    public MessageHeaderException(string message, string headerName, string ns);
    public MessageHeaderException(string message, string headerName, string ns, bool isDuplicate);
    public MessageHeaderException(string message, string headerName, string ns, Exception innerException);
    public MessageHeaderException(string message, string headerName, string ns, bool isDuplicate, Exception innerException);
    protected MessageHeaderException(SerializationInfo info, StreamingContext context);
    [CompilerGeneratedAttribute]
public string get_HeaderName();
    [CompilerGeneratedAttribute]
public string get_HeaderNamespace();
    [CompilerGeneratedAttribute]
public bool get_IsDuplicate();
    internal Message ProvideFault(MessageVersion messageVersion);
}
[AttributeUsageAttribute("10240")]
public class System.ServiceModel.MessageParameterAttribute : Attribute {
    private string _name;
    internal static string NamePropertyName;
    [CompilerGeneratedAttribute]
private bool <IsNameSetExplicit>k__BackingField;
    public string Name { get; public set; }
    internal bool IsNameSetExplicit { get; private set; }
    public string get_Name();
    public void set_Name(string value);
    [CompilerGeneratedAttribute]
internal bool get_IsNameSetExplicit();
    [CompilerGeneratedAttribute]
private void set_IsNameSetExplicit(bool value);
}
[AttributeUsageAttribute("384")]
public class System.ServiceModel.MessagePropertyAttribute : Attribute {
    private string _name;
    [CompilerGeneratedAttribute]
private bool <IsNameSetExplicit>k__BackingField;
    public string Name { get; public set; }
    internal bool IsNameSetExplicit { get; private set; }
    public string get_Name();
    public void set_Name(string value);
    [CompilerGeneratedAttribute]
internal bool get_IsNameSetExplicit();
    [CompilerGeneratedAttribute]
private void set_IsNameSetExplicit(bool value);
}
public abstract class System.ServiceModel.MessageSecurityVersion : object {
    public static MessageSecurityVersion WSSecurity11WSTrustFebruary2005WSSecureConversationFebruary2005WSSecurityPolicy11 { get; }
    public static MessageSecurityVersion WSSecurity10WSTrustFebruary2005WSSecureConversationFebruary2005WSSecurityPolicy11BasicSecurityProfile10 { get; }
    public static MessageSecurityVersion WSSecurity11WSTrustFebruary2005WSSecureConversationFebruary2005WSSecurityPolicy11BasicSecurityProfile10 { get; }
    public static MessageSecurityVersion WSSecurity11WSTrust13WSSecureConversation13WSSecurityPolicy12 { get; }
    public static MessageSecurityVersion WSSecurity10WSTrust13WSSecureConversation13WSSecurityPolicy12BasicSecurityProfile10 { get; }
    public static MessageSecurityVersion WSSecurity11WSTrust13WSSecureConversation13WSSecurityPolicy12BasicSecurityProfile10 { get; }
    public static MessageSecurityVersion Default { get; }
    internal static MessageSecurityVersion WSSXDefault { get; }
    public SecurityVersion SecurityVersion { get; }
    public TrustVersion TrustVersion { get; }
    public SecureConversationVersion SecureConversationVersion { get; }
    public SecurityTokenVersion SecurityTokenVersion { get; }
    public SecurityPolicyVersion SecurityPolicyVersion { get; }
    public BasicSecurityProfileVersion BasicSecurityProfileVersion { get; }
    internal MessageSecurityTokenVersion MessageSecurityTokenVersion { get; }
    public static MessageSecurityVersion get_WSSecurity11WSTrustFebruary2005WSSecureConversationFebruary2005WSSecurityPolicy11();
    public static MessageSecurityVersion get_WSSecurity10WSTrustFebruary2005WSSecureConversationFebruary2005WSSecurityPolicy11BasicSecurityProfile10();
    public static MessageSecurityVersion get_WSSecurity11WSTrustFebruary2005WSSecureConversationFebruary2005WSSecurityPolicy11BasicSecurityProfile10();
    public static MessageSecurityVersion get_WSSecurity11WSTrust13WSSecureConversation13WSSecurityPolicy12();
    public static MessageSecurityVersion get_WSSecurity10WSTrust13WSSecureConversation13WSSecurityPolicy12BasicSecurityProfile10();
    public static MessageSecurityVersion get_WSSecurity11WSTrust13WSSecureConversation13WSSecurityPolicy12BasicSecurityProfile10();
    public static MessageSecurityVersion get_Default();
    internal static MessageSecurityVersion get_WSSXDefault();
    public SecurityVersion get_SecurityVersion();
    public TrustVersion get_TrustVersion();
    public SecureConversationVersion get_SecureConversationVersion();
    public SecurityTokenVersion get_SecurityTokenVersion();
    public abstract virtual SecurityPolicyVersion get_SecurityPolicyVersion();
    public abstract virtual BasicSecurityProfileVersion get_BasicSecurityProfileVersion();
    internal abstract virtual MessageSecurityTokenVersion get_MessageSecurityTokenVersion();
}
internal static class System.ServiceModel.MessageStrings : object {
    public static string MustUnderstand;
    public static string Envelope;
    public static string Header;
    public static string Body;
    public static string Prefix;
    public static string Fault;
    public static string MustUnderstandFault;
    public static string Namespace;
}
internal class System.ServiceModel.MustUnderstandSoapException : CommunicationException {
    private EnvelopeVersion _envelopeVersion;
    [CompilerGeneratedAttribute]
private Collection`1<MessageHeaderInfo> <NotUnderstoodHeaders>k__BackingField;
    public Collection`1<MessageHeaderInfo> NotUnderstoodHeaders { get; }
    public EnvelopeVersion EnvelopeVersion { get; }
    protected MustUnderstandSoapException(SerializationInfo info, StreamingContext context);
    public MustUnderstandSoapException(Collection`1<MessageHeaderInfo> notUnderstoodHeaders, EnvelopeVersion envelopeVersion);
    [CompilerGeneratedAttribute]
public Collection`1<MessageHeaderInfo> get_NotUnderstoodHeaders();
    public EnvelopeVersion get_EnvelopeVersion();
    internal Message ProvideFault(MessageVersion messageVersion);
    private void AddNotUnderstoodHeaders(MessageHeaders headers);
}
internal class System.ServiceModel.NullCreatingPooledObjectPolicy`1 : PooledObjectPolicy`1<T> {
    public static ObjectPool`1<T> CreatePool(int maximumRetained);
    public virtual T Create();
    public virtual bool Return(T obj);
}
internal static class System.ServiceModel.OleTxTransactionExternalStrings : object {
    public static string Namespace;
    public static string Prefix;
    public static string OleTxTransaction;
    public static string PropagationToken;
}
internal class System.ServiceModel.OpenCollectionAsyncResult : AsyncResult {
    private bool _completedSynchronously;
    private Exception _exception;
    private static AsyncCallback s_nestedCallback;
    private int _count;
    private TimeoutHelper _timeoutHelper;
    public OpenCollectionAsyncResult(TimeSpan timeout, AsyncCallback otherCallback, object state, IList`1<ICommunicationObject> collection);
    private static OpenCollectionAsyncResult();
    private static void Callback(IAsyncResult result);
    private void Decrement(bool completedSynchronously);
    private void Decrement(bool completedSynchronously, Exception exception);
    public static void End(IAsyncResult result);
}
public class System.ServiceModel.OperationContext : object {
    [ThreadStaticAttribute]
private static Holder s_currentContext;
    private static AsyncLocal`1<OperationContext> s_asyncContext;
    private Message _clientReply;
    private bool _closeClientReply;
    private ExtensionCollection`1<OperationContext> _extensions;
    private Message _request;
    private bool _isServiceReentrant;
    internal IPrincipal threadPrincipal;
    private MessageProperties _outgoingMessageProperties;
    private MessageHeaders _outgoingMessageHeaders;
    private EndpointDispatcher _endpointDispatcher;
    [CompilerGeneratedAttribute]
private EventHandler OperationCompleted;
    [CompilerGeneratedAttribute]
private static bool <DisableAsyncFlow>k__BackingField;
    [CompilerGeneratedAttribute]
private ServiceChannel <InternalServiceChannel>k__BackingField;
    [CompilerGeneratedAttribute]
private MessageVersion <OutgoingMessageVersion>k__BackingField;
    [CompilerGeneratedAttribute]
private InstanceContext <InstanceContext>k__BackingField;
    [CompilerGeneratedAttribute]
private RequestContext <RequestContext>k__BackingField;
    [CompilerGeneratedAttribute]
private ClaimsPrincipal <ClaimsPrincipal>k__BackingField;
    public IContextChannel Channel { get; }
    public static OperationContext Current { get; public set; }
    internal static Holder CurrentHolder { get; }
    internal static bool DisableAsyncFlow { get; }
    public EndpointDispatcher EndpointDispatcher { get; public set; }
    public bool IsUserContext { get; }
    public IExtensionCollection`1<OperationContext> Extensions { get; }
    internal bool IsServiceReentrant { get; internal set; }
    internal Message IncomingMessage { get; }
    internal ServiceChannel InternalServiceChannel { get; internal set; }
    internal bool HasOutgoingMessageHeaders { get; }
    public MessageHeaders OutgoingMessageHeaders { get; }
    internal bool HasOutgoingMessageProperties { get; }
    public MessageProperties OutgoingMessageProperties { get; }
    internal MessageVersion OutgoingMessageVersion { get; }
    public MessageHeaders IncomingMessageHeaders { get; }
    public MessageProperties IncomingMessageProperties { get; }
    public MessageVersion IncomingMessageVersion { get; }
    public InstanceContext InstanceContext { get; private set; }
    public RequestContext RequestContext { get; public set; }
    public string SessionId { get; }
    internal IPrincipal ThreadPrincipal { get; internal set; }
    public ClaimsPrincipal ClaimsPrincipal { get; internal set; }
    private static OperationContext();
    public OperationContext(IContextChannel channel);
    internal OperationContext(MessageVersion outgoingMessageVersion);
    internal OperationContext(RequestContext requestContext, Message request, ServiceChannel channel);
    [CompilerGeneratedAttribute]
public void add_OperationCompleted(EventHandler value);
    [CompilerGeneratedAttribute]
public void remove_OperationCompleted(EventHandler value);
    public IContextChannel get_Channel();
    public static OperationContext get_Current();
    public static void set_Current(OperationContext value);
    internal static Holder get_CurrentHolder();
    [CompilerGeneratedAttribute]
internal static bool get_DisableAsyncFlow();
    public EndpointDispatcher get_EndpointDispatcher();
    public void set_EndpointDispatcher(EndpointDispatcher value);
    public bool get_IsUserContext();
    public sealed virtual IExtensionCollection`1<OperationContext> get_Extensions();
    internal bool get_IsServiceReentrant();
    internal void set_IsServiceReentrant(bool value);
    internal Message get_IncomingMessage();
    [CompilerGeneratedAttribute]
internal ServiceChannel get_InternalServiceChannel();
    [CompilerGeneratedAttribute]
internal void set_InternalServiceChannel(ServiceChannel value);
    internal bool get_HasOutgoingMessageHeaders();
    public MessageHeaders get_OutgoingMessageHeaders();
    internal bool get_HasOutgoingMessageProperties();
    public MessageProperties get_OutgoingMessageProperties();
    [CompilerGeneratedAttribute]
internal MessageVersion get_OutgoingMessageVersion();
    public MessageHeaders get_IncomingMessageHeaders();
    public MessageProperties get_IncomingMessageProperties();
    public MessageVersion get_IncomingMessageVersion();
    [CompilerGeneratedAttribute]
public InstanceContext get_InstanceContext();
    [CompilerGeneratedAttribute]
private void set_InstanceContext(InstanceContext value);
    [CompilerGeneratedAttribute]
public RequestContext get_RequestContext();
    [CompilerGeneratedAttribute]
public void set_RequestContext(RequestContext value);
    public string get_SessionId();
    internal IPrincipal get_ThreadPrincipal();
    internal void set_ThreadPrincipal(IPrincipal value);
    [CompilerGeneratedAttribute]
public ClaimsPrincipal get_ClaimsPrincipal();
    [CompilerGeneratedAttribute]
internal void set_ClaimsPrincipal(ClaimsPrincipal value);
    internal void ClearClientReplyNoThrow();
    internal void FireOperationCompleted();
    public T GetCallbackChannel();
    internal void ReInit(RequestContext requestContext, Message request, ServiceChannel channel);
    internal void Recycle();
    internal void SetClientReply(Message message, bool closeMessage);
    internal void SetInstanceContext(InstanceContext instanceContext);
}
public class System.ServiceModel.OperationContextScope : object {
    [ThreadStaticAttribute]
private static OperationContextScope s_currentScope;
    private static AsyncLocal`1<OperationContextScope> s_asyncCurrentScope;
    private OperationContext _currentContext;
    private bool _disposed;
    private OperationContext _originalContext;
    private OperationContextScope _originalScope;
    private static OperationContextScope();
    public OperationContextScope(IContextChannel channel);
    public OperationContextScope(OperationContext context);
    public sealed virtual void Dispose();
    private void PushContext(OperationContext context);
    private void PopContext();
}
[AttributeUsageAttribute("64")]
public class System.ServiceModel.OperationContractAttribute : Attribute {
    private string _name;
    private string _action;
    private string _replyAction;
    private bool _isOneWay;
    private ProtectionLevel _protectionLevel;
    internal static string ActionPropertyName;
    internal static string ProtectionLevelPropertyName;
    [CompilerGeneratedAttribute]
private bool <HasProtectionLevel>k__BackingField;
    internal static string ReplyActionPropertyName;
    [CompilerGeneratedAttribute]
private bool <AsyncPattern>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsInitiating>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsTerminating>k__BackingField;
    public string Name { get; public set; }
    public string Action { get; public set; }
    public ProtectionLevel ProtectionLevel { get; public set; }
    public bool HasProtectionLevel { get; private set; }
    public string ReplyAction { get; public set; }
    public bool AsyncPattern { get; public set; }
    public bool IsOneWay { get; public set; }
    public bool IsInitiating { get; public set; }
    public bool IsTerminating { get; public set; }
    internal bool IsSessionOpenNotificationEnabled { get; }
    public string get_Name();
    public void set_Name(string value);
    public string get_Action();
    public void set_Action(string value);
    public ProtectionLevel get_ProtectionLevel();
    public void set_ProtectionLevel(ProtectionLevel value);
    [CompilerGeneratedAttribute]
public bool get_HasProtectionLevel();
    [CompilerGeneratedAttribute]
private void set_HasProtectionLevel(bool value);
    public string get_ReplyAction();
    public void set_ReplyAction(string value);
    [CompilerGeneratedAttribute]
public bool get_AsyncPattern();
    [CompilerGeneratedAttribute]
public void set_AsyncPattern(bool value);
    public bool get_IsOneWay();
    public void set_IsOneWay(bool value);
    [CompilerGeneratedAttribute]
public bool get_IsInitiating();
    [CompilerGeneratedAttribute]
public void set_IsInitiating(bool value);
    [CompilerGeneratedAttribute]
public bool get_IsTerminating();
    [CompilerGeneratedAttribute]
public void set_IsTerminating(bool value);
    internal bool get_IsSessionOpenNotificationEnabled();
    internal void EnsureInvariants(MethodInfo methodInfo, string operationName);
}
public enum System.ServiceModel.OperationFormatStyle : Enum {
    public int value__;
    public static OperationFormatStyle Document;
    public static OperationFormatStyle Rpc;
}
internal static class System.ServiceModel.OperationFormatStyleHelper : object {
    public static bool IsDefined(OperationFormatStyle x);
}
public enum System.ServiceModel.OperationFormatUse : Enum {
    public int value__;
    public static OperationFormatUse Literal;
    public static OperationFormatUse Encoded;
}
internal static class System.ServiceModel.OperationFormatUseHelper : object {
    public static bool IsDefined(OperationFormatUse x);
}
public class System.ServiceModel.OptionalReliableSession : ReliableSession {
    [CompilerGeneratedAttribute]
private bool <Enabled>k__BackingField;
    public bool Enabled { get; public set; }
    public OptionalReliableSession(ReliableSessionBindingElement reliableSessionBindingElement);
    [CompilerGeneratedAttribute]
public bool get_Enabled();
    [CompilerGeneratedAttribute]
public void set_Enabled(bool value);
    internal void CopySettings(OptionalReliableSession copyFrom);
}
[AttributeUsageAttribute("384")]
public class System.ServiceModel.PeerHopCountAttribute : MessageHeaderAttribute {
    public bool MustUnderstand { get; }
    public bool Relay { get; }
    public string Actor { get; }
    public string Namespace { get; }
    public string Name { get; }
    public ProtectionLevel ProtectionLevel { get; }
    public bool get_MustUnderstand();
    public bool get_Relay();
    public string get_Actor();
    public string get_Namespace();
    public string get_Name();
    public ProtectionLevel get_ProtectionLevel();
}
internal static class System.ServiceModel.PeerWireStringsStrings : object {
    public static string FloodAction;
    public static string LinkUtilityAction;
    public static string HopCount;
    public static string HopCountNamespace;
    public static string PeerVia;
    public static string Namespace;
    public static string Demuxer;
    public static string PeerTo;
}
internal static class System.ServiceModel.PolicyStrings : object {
    public static string Namespace;
}
internal class System.ServiceModel.ProgrammaticEndpointTrait`1 : EndpointTrait`1<TChannel> {
    private EndpointAddress _remoteAddress;
    private Binding _binding;
    private InstanceContext _callbackInstance;
    public ProgrammaticEndpointTrait`1(Binding binding, EndpointAddress remoteAddress, InstanceContext callbackInstance);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    public virtual ChannelFactory`1<TChannel> CreateChannelFactory();
    private DuplexChannelFactory`1<TChannel> CreateDuplexFactory();
    private ChannelFactory`1<TChannel> CreateSimplexFactory();
}
public class System.ServiceModel.ProtocolException : CommunicationException {
    public ProtocolException(string message);
    public ProtocolException(string message, Exception innerException);
    protected ProtocolException(SerializationInfo info, StreamingContext context);
    internal static ProtocolException ReceiveShutdownReturnedNonNull(Message message);
    internal static ProtocolException OneWayOperationReturnedNonNull(Message message);
}
public enum System.ServiceModel.QueuedDeliveryRequirementsMode : Enum {
    public int value__;
    public static QueuedDeliveryRequirementsMode Allowed;
    public static QueuedDeliveryRequirementsMode Required;
    public static QueuedDeliveryRequirementsMode NotAllowed;
}
internal static class System.ServiceModel.QueuedDeliveryRequirementsModeHelper : object {
    public static bool IsDefined(QueuedDeliveryRequirementsMode x);
}
public class System.ServiceModel.QuotaExceededException : Exception {
    public QuotaExceededException(string message);
    public QuotaExceededException(string message, Exception innerException);
    protected QuotaExceededException(SerializationInfo info, StreamingContext context);
}
public enum System.ServiceModel.ReceiveErrorHandling : Enum {
    public int value__;
    public static ReceiveErrorHandling Fault;
    public static ReceiveErrorHandling Drop;
    public static ReceiveErrorHandling Reject;
    public static ReceiveErrorHandling Move;
}
internal static class System.ServiceModel.ReceiveErrorHandlingHelper : object {
    internal static bool IsDefined(ReceiveErrorHandling value);
}
[ExtensionAttribute]
internal static class System.ServiceModel.ReflectionExtensions : object {
    [ExtensionAttribute]
public static Assembly Assembly(Type type);
    [ExtensionAttribute]
public static Type BaseType(Type type);
    [ExtensionAttribute]
public static bool ContainsGenericParameters(Type type);
    [ExtensionAttribute]
public static ConstructorInfo GetConstructor(Type type, Type[] types);
    [ExtensionAttribute]
public static ConstructorInfo GetConstructor(Type type, BindingFlags bindingAttr, object binder, Type[] types, Object[] modifiers);
    [ExtensionAttribute]
public static PropertyInfo GetProperty(Type type, string name, BindingFlags bindingAttr);
    [ExtensionAttribute]
public static Type[] GetGenericArguments(Type type);
    [ExtensionAttribute]
public static Type[] GetInterfaces(Type type);
    [ExtensionAttribute]
public static bool IsAbstract(Type type);
    [ExtensionAttribute]
public static bool IsAssignableFrom(Type type, Type otherType);
    [ExtensionAttribute]
public static bool IsClass(Type type);
    [ExtensionAttribute]
public static bool IsDefined(Type type, Type attributeType, bool inherit);
    [ExtensionAttribute]
public static bool IsEnum(Type type);
    [ExtensionAttribute]
public static bool IsGenericType(Type type);
    [ExtensionAttribute]
public static bool IsInterface(Type type);
    [ExtensionAttribute]
public static bool IsInstanceOfType(Type type, object o);
    [ExtensionAttribute]
public static bool IsMarshalByRef(Type type);
    [ExtensionAttribute]
public static bool IsNotPublic(Type type);
    [ExtensionAttribute]
public static bool IsSealed(Type type);
    [ExtensionAttribute]
public static bool IsValueType(Type type);
    [ExtensionAttribute]
public static InterfaceMapping GetInterfaceMap(Type type, Type interfaceType);
    [ExtensionAttribute]
public static MemberInfo[] GetMember(Type type, string name, BindingFlags bindingAttr);
    [ExtensionAttribute]
public static MemberInfo[] GetMembers(Type type, BindingFlags bindingAttr);
    [ExtensionAttribute]
public static MethodInfo GetMethod(Type type, string name);
    [ExtensionAttribute]
public static MethodInfo GetMethod(Type type, string name, Type[] types);
    [ExtensionAttribute]
public static TypeCode GetTypeCode(Type type);
    [ExtensionAttribute]
public static bool IsPublic(ConstructorInfo ci);
    [ExtensionAttribute]
public static object Invoke(ConstructorInfo ci, BindingFlags invokeAttr, object binder, Object[] parameters, CultureInfo culture);
    [ExtensionAttribute]
public static RuntimeMethodHandle MethodHandle(MethodBase mb);
    [ExtensionAttribute]
public static RuntimeMethodHandle MethodHandle(MethodInfo mi);
    [ExtensionAttribute]
public static Type ReflectedType(MethodInfo mi);
}
public abstract class System.ServiceModel.ReliableMessagingVersion : object {
    [CompilerGeneratedAttribute]
private XmlDictionaryString <DictionaryNamespace>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Namespace>k__BackingField;
    public static ReliableMessagingVersion Default { get; }
    public static ReliableMessagingVersion WSReliableMessaging11 { get; }
    public static ReliableMessagingVersion WSReliableMessagingFebruary2005 { get; }
    internal XmlDictionaryString DictionaryNamespace { get; }
    internal string Namespace { get; }
    internal ReliableMessagingVersion(string ns, XmlDictionaryString dictionaryNs);
    public static ReliableMessagingVersion get_Default();
    public static ReliableMessagingVersion get_WSReliableMessaging11();
    public static ReliableMessagingVersion get_WSReliableMessagingFebruary2005();
    [CompilerGeneratedAttribute]
internal XmlDictionaryString get_DictionaryNamespace();
    [CompilerGeneratedAttribute]
internal string get_Namespace();
    internal static bool IsDefined(ReliableMessagingVersion reliableMessagingVersion);
}
public class System.ServiceModel.ReliableSession : object {
    private ReliableSessionBindingElement _element;
    [DefaultValueAttribute("True")]
public bool Ordered { get; public set; }
    public TimeSpan InactivityTimeout { get; public set; }
    public ReliableSession(ReliableSessionBindingElement reliableSessionBindingElement);
    public bool get_Ordered();
    public void set_Ordered(bool value);
    public TimeSpan get_InactivityTimeout();
    public void set_InactivityTimeout(TimeSpan value);
    internal void CopySettings(ReliableSession copyFrom);
}
public class System.ServiceModel.RsaEndpointIdentity : EndpointIdentity {
    public RsaEndpointIdentity(string publicKey);
    public RsaEndpointIdentity(X509Certificate2 certificate);
    public RsaEndpointIdentity(Claim identity);
    internal RsaEndpointIdentity(XmlDictionaryReader reader);
    internal virtual void WriteContentsTo(XmlDictionaryWriter writer);
    private static RSA ToRsa(string keyString);
}
internal static class System.ServiceModel.SamlStrings : object {
    public static string Access;
    public static string AccessDecision;
    public static string Action;
    public static string Advice;
    public static string Assertion;
    public static string AssertionId;
    public static string AssertionIdReference;
    public static string Attribute;
    public static string AttributeName;
    public static string AttributeNamespace;
    public static string AttributeStatement;
    public static string AttributeValue;
    public static string Audience;
    public static string AudienceRestrictionCondition;
    public static string AuthenticationInstant;
    public static string AuthenticationMethod;
    public static string AuthenticationStatement;
    public static string AuthorityBinding;
    public static string AuthorityKind;
    public static string AuthorizationDecisionStatement;
    public static string Binding;
    public static string Condition;
    public static string Conditions;
    public static string Decision;
    public static string DoNotCacheCondition;
    public static string Evidence;
    public static string IssueInstant;
    public static string Issuer;
    public static string Location;
    public static string MajorVersion;
    public static string MinorVersion;
    public static string Namespace;
    public static string NameIdentifier;
    public static string NameIdentifierFormat;
    public static string NameIdentifierNameQualifier;
    public static string ActionNamespaceAttribute;
    public static string NotBefore;
    public static string NotOnOrAfter;
    public static string PreferredPrefix;
    public static string Statement;
    public static string Subject;
    public static string SubjectConfirmation;
    public static string SubjectConfirmationData;
    public static string SubjectConfirmationMethod;
    public static string HolderOfKey;
    public static string SenderVouches;
    public static string SubjectLocality;
    public static string SubjectLocalityDNSAddress;
    public static string SubjectLocalityIPAddress;
    public static string SubjectStatement;
    public static string UnspecifiedAuthenticationMethod;
    public static string NamespaceAttributePrefix;
    public static string Resource;
    public static string UserName;
    public static string UserNameNamespace;
    public static string EmailName;
    public static string EmailNamespace;
}
internal static class System.ServiceModel.SecureConversationApr2004Strings : object {
    public static string SecurityContextToken;
    public static string DerivedKeyToken;
    public static string AlgorithmAttribute;
    public static string Generation;
    public static string Label;
    public static string Length;
    public static string Nonce;
    public static string Offset;
    public static string Properties;
    public static string Identifier;
    public static string Cookie;
    public static string Prefix;
    public static string Namespace;
    public static string DerivedKeyTokenType;
    public static string SecurityContextTokenType;
    public static string SecurityContextTokenReferenceValueType;
    public static string RequestSecurityContextIssuance;
    public static string RequestSecurityContextIssuanceResponse;
    public static string RenewNeededFaultCode;
    public static string BadContextTokenFaultCode;
}
internal class System.ServiceModel.SecureConversationDec2005Dictionary : SecureConversationDictionary {
    public XmlDictionaryString RequestSecurityContextRenew;
    public XmlDictionaryString RequestSecurityContextRenewResponse;
    public XmlDictionaryString RequestSecurityContextClose;
    public XmlDictionaryString RequestSecurityContextCloseResponse;
    public XmlDictionaryString Instance;
    public List`1<XmlDictionaryString> SecureConversationDictionaryStrings;
    public SecureConversationDec2005Dictionary(XmlDictionary dictionary);
    public void PopulateSecureConversationDec2005();
}
internal static class System.ServiceModel.SecureConversationDec2005Strings : object {
    public static string SecurityContextToken;
    public static string AlgorithmAttribute;
    public static string Generation;
    public static string Label;
    public static string Offset;
    public static string Properties;
    public static string Identifier;
    public static string Cookie;
    public static string RenewNeededFaultCode;
    public static string BadContextTokenFaultCode;
    public static string Prefix;
    public static string DerivedKeyTokenType;
    public static string SecurityContextTokenType;
    public static string SecurityContextTokenReferenceValueType;
    public static string RequestSecurityContextIssuance;
    public static string RequestSecurityContextIssuanceResponse;
    public static string RequestSecurityContextRenew;
    public static string RequestSecurityContextRenewResponse;
    public static string RequestSecurityContextClose;
    public static string RequestSecurityContextCloseResponse;
    public static string Namespace;
    public static string DerivedKeyToken;
    public static string Nonce;
    public static string Length;
    public static string Instance;
}
internal class System.ServiceModel.SecureConversationDictionary : object {
    public XmlDictionaryString Namespace;
    public XmlDictionaryString DerivedKeyToken;
    public XmlDictionaryString Nonce;
    public XmlDictionaryString Length;
    public XmlDictionaryString SecurityContextToken;
    public XmlDictionaryString AlgorithmAttribute;
    public XmlDictionaryString Generation;
    public XmlDictionaryString Label;
    public XmlDictionaryString Offset;
    public XmlDictionaryString Properties;
    public XmlDictionaryString Identifier;
    public XmlDictionaryString Cookie;
    public XmlDictionaryString Prefix;
    public XmlDictionaryString DerivedKeyTokenType;
    public XmlDictionaryString SecurityContextTokenType;
    public XmlDictionaryString SecurityContextTokenReferenceValueType;
    public XmlDictionaryString RequestSecurityContextIssuance;
    public XmlDictionaryString RequestSecurityContextIssuanceResponse;
    public XmlDictionaryString RenewNeededFaultCode;
    public XmlDictionaryString BadContextTokenFaultCode;
    public SecureConversationDictionary(ServiceModelDictionary dictionary);
}
internal class System.ServiceModel.SecureConversationFeb2005Dictionary : SecureConversationDictionary {
    public XmlDictionaryString RequestSecurityContextRenew;
    public XmlDictionaryString RequestSecurityContextRenewResponse;
    public XmlDictionaryString RequestSecurityContextClose;
    public XmlDictionaryString RequestSecurityContextCloseResponse;
    public SecureConversationFeb2005Dictionary(ServiceModelDictionary dictionary);
}
internal static class System.ServiceModel.SecureConversationFeb2005Strings : object {
    public static string Namespace;
    public static string DerivedKeyToken;
    public static string Nonce;
    public static string Length;
    public static string SecurityContextToken;
    public static string AlgorithmAttribute;
    public static string Generation;
    public static string Label;
    public static string Offset;
    public static string Properties;
    public static string Identifier;
    public static string Cookie;
    public static string RenewNeededFaultCode;
    public static string BadContextTokenFaultCode;
    public static string Prefix;
    public static string DerivedKeyTokenType;
    public static string SecurityContextTokenType;
    public static string SecurityContextTokenReferenceValueType;
    public static string RequestSecurityContextIssuance;
    public static string RequestSecurityContextIssuanceResponse;
    public static string RequestSecurityContextRenew;
    public static string RequestSecurityContextRenewResponse;
    public static string RequestSecurityContextClose;
    public static string RequestSecurityContextCloseResponse;
}
internal static class System.ServiceModel.SecureConversationStrings : object {
}
internal class System.ServiceModel.Security.AcceleratedTokenProvider : NegotiationTokenProvider`1<AcceleratedTokenProviderState> {
    internal static SecurityKeyEntropyMode defaultKeyEntropyMode;
    private SecurityKeyEntropyMode _keyEntropyMode;
    private SecurityBindingElement _bootstrapSecurityBindingElement;
    private ChannelParameterCollection _channelParameters;
    public SecurityKeyEntropyMode KeyEntropyMode { get; public set; }
    public SecurityBindingElement BootstrapSecurityBindingElement { get; public set; }
    public ChannelParameterCollection ChannelParameters { get; public set; }
    protected bool IsMultiLegNegotiation { get; }
    public XmlDictionaryString RequestSecurityTokenAction { get; }
    public XmlDictionaryString RequestSecurityTokenResponseAction { get; }
    public SecurityKeyEntropyMode get_KeyEntropyMode();
    public void set_KeyEntropyMode(SecurityKeyEntropyMode value);
    public SecurityBindingElement get_BootstrapSecurityBindingElement();
    public void set_BootstrapSecurityBindingElement(SecurityBindingElement value);
    public ChannelParameterCollection get_ChannelParameters();
    public void set_ChannelParameters(ChannelParameterCollection value);
    protected virtual bool get_IsMultiLegNegotiation();
    public virtual XmlDictionaryString get_RequestSecurityTokenAction();
    public virtual XmlDictionaryString get_RequestSecurityTokenResponseAction();
    public virtual Task OnOpenAsync(TimeSpan timeout);
    public virtual void OnOpening();
    public virtual Task OnCloseAsync(TimeSpan timeout);
    public virtual void OnAbort();
    protected virtual IChannelFactory`1<IAsyncRequestChannel> GetNegotiationChannelFactory(IChannelFactory`1<IAsyncRequestChannel> transportChannelFactory, ChannelBuilder channelBuilder);
    protected virtual IAsyncRequestChannel CreateClientChannel(EndpointAddress target, Uri via);
    protected virtual Task`1<AcceleratedTokenProviderState> CreateNegotiationStateAsync(EndpointAddress target, Uri via, TimeSpan timeout);
    protected virtual BodyWriter GetFirstOutgoingMessageBody(AcceleratedTokenProviderState negotiationState, MessageProperties& messageProperties);
    protected virtual BodyWriter GetNextOutgoingMessageBody(Message incomingMessage, AcceleratedTokenProviderState negotiationState);
}
internal class System.ServiceModel.Security.AcceleratedTokenProviderState : IssuanceTokenProviderState {
    private Byte[] _entropy;
    public AcceleratedTokenProviderState(Byte[] value);
    public Byte[] GetRequestorEntropy();
}
internal class System.ServiceModel.Security.AggregateSecurityHeaderTokenResolver : AggregateTokenResolver {
    private SecurityHeaderTokenResolver _tokenResolver;
    public AggregateSecurityHeaderTokenResolver(SecurityHeaderTokenResolver tokenResolver, ReadOnlyCollection`1<SecurityTokenResolver> outOfBandTokenResolvers);
    protected virtual bool TryResolveSecurityKeyCore(SecurityKeyIdentifierClause keyIdentifierClause, SecurityKey& key);
    protected virtual bool TryResolveTokenCore(SecurityKeyIdentifier keyIdentifier, SecurityToken& token);
    private bool TryResolveTokenFromIntrinsicKeyClause(SecurityKeyIdentifierClause keyIdentifierClause, SecurityToken& token);
    protected virtual bool TryResolveTokenCore(SecurityKeyIdentifierClause keyIdentifierClause, SecurityToken& token);
}
public class System.ServiceModel.Security.Basic256SecurityAlgorithmSuite : SecurityAlgorithmSuite {
    public string DefaultCanonicalizationAlgorithm { get; }
    public string DefaultDigestAlgorithm { get; }
    public string DefaultEncryptionAlgorithm { get; }
    public int DefaultEncryptionKeyDerivationLength { get; }
    public string DefaultSymmetricKeyWrapAlgorithm { get; }
    public string DefaultAsymmetricKeyWrapAlgorithm { get; }
    public string DefaultSymmetricSignatureAlgorithm { get; }
    public string DefaultAsymmetricSignatureAlgorithm { get; }
    public int DefaultSignatureKeyDerivationLength { get; }
    public int DefaultSymmetricKeyLength { get; }
    internal XmlDictionaryString DefaultCanonicalizationAlgorithmDictionaryString { get; }
    internal XmlDictionaryString DefaultDigestAlgorithmDictionaryString { get; }
    internal XmlDictionaryString DefaultEncryptionAlgorithmDictionaryString { get; }
    internal XmlDictionaryString DefaultSymmetricKeyWrapAlgorithmDictionaryString { get; }
    internal XmlDictionaryString DefaultAsymmetricKeyWrapAlgorithmDictionaryString { get; }
    internal XmlDictionaryString DefaultSymmetricSignatureAlgorithmDictionaryString { get; }
    internal XmlDictionaryString DefaultAsymmetricSignatureAlgorithmDictionaryString { get; }
    public virtual string get_DefaultCanonicalizationAlgorithm();
    public virtual string get_DefaultDigestAlgorithm();
    public virtual string get_DefaultEncryptionAlgorithm();
    public virtual int get_DefaultEncryptionKeyDerivationLength();
    public virtual string get_DefaultSymmetricKeyWrapAlgorithm();
    public virtual string get_DefaultAsymmetricKeyWrapAlgorithm();
    public virtual string get_DefaultSymmetricSignatureAlgorithm();
    public virtual string get_DefaultAsymmetricSignatureAlgorithm();
    public virtual int get_DefaultSignatureKeyDerivationLength();
    public virtual int get_DefaultSymmetricKeyLength();
    public virtual bool IsSymmetricKeyLengthSupported(int length);
    public virtual bool IsAsymmetricKeyLengthSupported(int length);
    internal virtual XmlDictionaryString get_DefaultCanonicalizationAlgorithmDictionaryString();
    internal virtual XmlDictionaryString get_DefaultDigestAlgorithmDictionaryString();
    internal virtual XmlDictionaryString get_DefaultEncryptionAlgorithmDictionaryString();
    internal virtual XmlDictionaryString get_DefaultSymmetricKeyWrapAlgorithmDictionaryString();
    internal virtual XmlDictionaryString get_DefaultAsymmetricKeyWrapAlgorithmDictionaryString();
    internal virtual XmlDictionaryString get_DefaultSymmetricSignatureAlgorithmDictionaryString();
    internal virtual XmlDictionaryString get_DefaultAsymmetricSignatureAlgorithmDictionaryString();
    public virtual string ToString();
}
public class System.ServiceModel.Security.Basic256Sha256SecurityAlgorithmSuite : Basic256SecurityAlgorithmSuite {
    internal XmlDictionaryString DefaultDigestAlgorithmDictionaryString { get; }
    internal XmlDictionaryString DefaultSymmetricSignatureAlgorithmDictionaryString { get; }
    internal XmlDictionaryString DefaultAsymmetricSignatureAlgorithmDictionaryString { get; }
    internal virtual XmlDictionaryString get_DefaultDigestAlgorithmDictionaryString();
    internal virtual XmlDictionaryString get_DefaultSymmetricSignatureAlgorithmDictionaryString();
    internal virtual XmlDictionaryString get_DefaultAsymmetricSignatureAlgorithmDictionaryString();
    public virtual string ToString();
}
public abstract class System.ServiceModel.Security.BasicSecurityProfileVersion : object {
    public static BasicSecurityProfileVersion BasicSecurityProfile10 { get; }
    public static BasicSecurityProfileVersion get_BasicSecurityProfile10();
}
internal class System.ServiceModel.Security.BinaryNegotiation : object {
    private Byte[] _negotiationData;
    private XmlDictionaryString _valueTypeUriDictionaryString;
    [CompilerGeneratedAttribute]
private string <ValueTypeUri>k__BackingField;
    public string ValueTypeUri { get; }
    public BinaryNegotiation(string valueTypeUri, Byte[] negotiationData);
    public BinaryNegotiation(XmlDictionaryString valueTypeDictionaryString, Byte[] negotiationData);
    public void Validate(XmlDictionaryString valueTypeUriDictionaryString);
    public void WriteTo(XmlDictionaryWriter writer, string prefix, XmlDictionaryString localName, XmlDictionaryString ns, XmlDictionaryString valueTypeLocalName, XmlDictionaryString valueTypeNs);
    [CompilerGeneratedAttribute]
public string get_ValueTypeUri();
    public Byte[] GetNegotiationData();
}
public class System.ServiceModel.Security.BinarySecretKeyIdentifierClause : BinaryKeyIdentifierClause {
    private InMemorySymmetricSecurityKey _symmetricKey;
    public bool CanCreateKey { get; }
    public BinarySecretKeyIdentifierClause(Byte[] key);
    public BinarySecretKeyIdentifierClause(Byte[] key, bool cloneBuffer);
    public BinarySecretKeyIdentifierClause(Byte[] key, bool cloneBuffer, Byte[] derivationNonce, int derivationLength);
    public Byte[] GetKeyBytes();
    public virtual bool get_CanCreateKey();
    public virtual SecurityKey CreateKey();
    public virtual bool Matches(SecurityKeyIdentifierClause keyIdentifierClause);
}
public class System.ServiceModel.Security.ChannelProtectionRequirements : object {
    private ScopedMessagePartSpecification _outgoingEncryptionParts;
    [CompilerGeneratedAttribute]
private bool <IsReadOnly>k__BackingField;
    [CompilerGeneratedAttribute]
private ScopedMessagePartSpecification <IncomingSignatureParts>k__BackingField;
    [CompilerGeneratedAttribute]
private ScopedMessagePartSpecification <IncomingEncryptionParts>k__BackingField;
    [CompilerGeneratedAttribute]
private ScopedMessagePartSpecification <OutgoingSignatureParts>k__BackingField;
    public bool IsReadOnly { get; private set; }
    public ScopedMessagePartSpecification IncomingSignatureParts { get; private set; }
    public ScopedMessagePartSpecification IncomingEncryptionParts { get; private set; }
    public ScopedMessagePartSpecification OutgoingSignatureParts { get; private set; }
    public ScopedMessagePartSpecification OutgoingEncryptionParts { get; }
    public ChannelProtectionRequirements(ChannelProtectionRequirements other);
    internal ChannelProtectionRequirements(ChannelProtectionRequirements other, ProtectionLevel newBodyProtectionLevel);
    [CompilerGeneratedAttribute]
public bool get_IsReadOnly();
    [CompilerGeneratedAttribute]
private void set_IsReadOnly(bool value);
    [CompilerGeneratedAttribute]
public ScopedMessagePartSpecification get_IncomingSignatureParts();
    [CompilerGeneratedAttribute]
private void set_IncomingSignatureParts(ScopedMessagePartSpecification value);
    [CompilerGeneratedAttribute]
public ScopedMessagePartSpecification get_IncomingEncryptionParts();
    [CompilerGeneratedAttribute]
private void set_IncomingEncryptionParts(ScopedMessagePartSpecification value);
    [CompilerGeneratedAttribute]
public ScopedMessagePartSpecification get_OutgoingSignatureParts();
    [CompilerGeneratedAttribute]
private void set_OutgoingSignatureParts(ScopedMessagePartSpecification value);
    public ScopedMessagePartSpecification get_OutgoingEncryptionParts();
    public void Add(ChannelProtectionRequirements protectionRequirements);
    public void Add(ChannelProtectionRequirements protectionRequirements, bool channelScopeOnly);
    private static void AddActionParts(ScopedMessagePartSpecification to, ScopedMessagePartSpecification from);
    public void MakeReadOnly();
    public ChannelProtectionRequirements CreateInverse();
    internal static ChannelProtectionRequirements CreateFromContract(ContractDescription contract, ISecurityCapabilities bindingElement, bool isForClient);
    private static MessagePartSpecification UnionMessagePartSpecifications(ScopedMessagePartSpecification actionParts);
    internal static ChannelProtectionRequirements CreateFromContractAndUnionResponseProtectionRequirements(ContractDescription contract, ISecurityCapabilities bindingElement, bool isForClient);
    internal static ChannelProtectionRequirements CreateFromContract(ContractDescription contract, ProtectionLevel defaultRequestProtectionLevel, ProtectionLevel defaultResponseProtectionLevel, bool isForClient);
    private static void AddHeaderProtectionRequirements(MessageHeaderDescription header, MessagePartSpecification signedParts, MessagePartSpecification encryptedParts, ProtectionLevel defaultProtectionLevel);
    private static void AddFaultProtectionRequirements(FaultDescriptionCollection faults, ChannelProtectionRequirements requirements, ProtectionLevel defaultProtectionLevel, bool addToIncoming);
}
internal abstract class System.ServiceModel.Security.CommunicationObjectSecurityTokenAuthenticator : SecurityTokenAuthenticator {
    [CompilerGeneratedAttribute]
private WrapperSecurityCommunicationObject <CommunicationObject>k__BackingField;
    protected WrapperSecurityCommunicationObject CommunicationObject { get; }
    public CommunicationState State { get; }
    public TimeSpan DefaultOpenTimeout { get; }
    public TimeSpan DefaultCloseTimeout { get; }
    [CompilerGeneratedAttribute]
protected WrapperSecurityCommunicationObject get_CommunicationObject();
    public sealed virtual void add_Closed(EventHandler value);
    public sealed virtual void remove_Closed(EventHandler value);
    public sealed virtual void add_Closing(EventHandler value);
    public sealed virtual void remove_Closing(EventHandler value);
    public sealed virtual void add_Faulted(EventHandler value);
    public sealed virtual void remove_Faulted(EventHandler value);
    public sealed virtual void add_Opened(EventHandler value);
    public sealed virtual void remove_Opened(EventHandler value);
    public sealed virtual void add_Opening(EventHandler value);
    public sealed virtual void remove_Opening(EventHandler value);
    public sealed virtual CommunicationState get_State();
    public virtual TimeSpan get_DefaultOpenTimeout();
    public virtual TimeSpan get_DefaultCloseTimeout();
    public sealed virtual void Abort();
    public sealed virtual void Close();
    public sealed virtual void Close(TimeSpan timeout);
    public sealed virtual IAsyncResult BeginClose(AsyncCallback callback, object state);
    public sealed virtual IAsyncResult BeginClose(TimeSpan timeout, AsyncCallback callback, object state);
    public sealed virtual void EndClose(IAsyncResult result);
    public sealed virtual void Open();
    public sealed virtual void Open(TimeSpan timeout);
    public sealed virtual IAsyncResult BeginOpen(AsyncCallback callback, object state);
    public sealed virtual IAsyncResult BeginOpen(TimeSpan timeout, AsyncCallback callback, object state);
    public sealed virtual void EndOpen(IAsyncResult result);
    public void Dispose();
    public virtual void OnAbort();
    public IAsyncResult OnBeginClose(TimeSpan timeout, AsyncCallback callback, object state);
    public IAsyncResult OnBeginOpen(TimeSpan timeout, AsyncCallback callback, object state);
    public virtual void OnClose(TimeSpan timeout);
    public sealed virtual Task OnCloseAsync(TimeSpan timeout);
    public virtual void OnClosed();
    public virtual void OnClosing();
    public void OnEndClose(IAsyncResult result);
    public void OnEndOpen(IAsyncResult result);
    public virtual void OnFaulted();
    public virtual void OnOpen(TimeSpan timeout);
    public sealed virtual Task OnOpenAsync(TimeSpan timeout);
    public virtual void OnOpened();
    public virtual void OnOpening();
}
internal abstract class System.ServiceModel.Security.CommunicationObjectSecurityTokenProvider : SecurityTokenProvider {
    private EventTraceActivity _eventTraceActivity;
    [CompilerGeneratedAttribute]
private WrapperSecurityCommunicationObject <CommunicationObject>k__BackingField;
    internal EventTraceActivity EventTraceActivity { get; }
    protected WrapperSecurityCommunicationObject CommunicationObject { get; }
    public CommunicationState State { get; }
    public TimeSpan DefaultOpenTimeout { get; }
    public TimeSpan DefaultCloseTimeout { get; }
    internal EventTraceActivity get_EventTraceActivity();
    [CompilerGeneratedAttribute]
protected WrapperSecurityCommunicationObject get_CommunicationObject();
    public sealed virtual void add_Closed(EventHandler value);
    public sealed virtual void remove_Closed(EventHandler value);
    public sealed virtual void add_Closing(EventHandler value);
    public sealed virtual void remove_Closing(EventHandler value);
    public sealed virtual void add_Faulted(EventHandler value);
    public sealed virtual void remove_Faulted(EventHandler value);
    public sealed virtual void add_Opened(EventHandler value);
    public sealed virtual void remove_Opened(EventHandler value);
    public sealed virtual void add_Opening(EventHandler value);
    public sealed virtual void remove_Opening(EventHandler value);
    public sealed virtual CommunicationState get_State();
    public virtual TimeSpan get_DefaultOpenTimeout();
    public virtual TimeSpan get_DefaultCloseTimeout();
    public sealed virtual void Abort();
    public sealed virtual void Close();
    public sealed virtual Task CloseAsync(TimeSpan timeout);
    public sealed virtual void Close(TimeSpan timeout);
    public sealed virtual IAsyncResult BeginClose(AsyncCallback callback, object state);
    public sealed virtual IAsyncResult BeginClose(TimeSpan timeout, AsyncCallback callback, object state);
    public sealed virtual void EndClose(IAsyncResult result);
    public sealed virtual void Open();
    public sealed virtual Task OpenAsync(TimeSpan timeout);
    public sealed virtual void Open(TimeSpan timeout);
    public sealed virtual IAsyncResult BeginOpen(AsyncCallback callback, object state);
    public sealed virtual IAsyncResult BeginOpen(TimeSpan timeout, AsyncCallback callback, object state);
    public sealed virtual void EndOpen(IAsyncResult result);
    public void Dispose();
    public virtual void OnAbort();
    public virtual Task OnCloseAsync(TimeSpan timeout);
    public virtual void OnClosed();
    public virtual void OnClosing();
    public virtual void OnFaulted();
    public virtual Task OnOpenAsync(TimeSpan timeout);
    public virtual void OnOpened();
    public virtual void OnOpening();
}
internal static class System.ServiceModel.Security.ContextImportHelper : object {
    internal static XmlDictionaryReader CreateSplicedReader(Byte[] decryptedBuffer, XmlAttributeHolder[] outerContext1, XmlAttributeHolder[] outerContext2, XmlAttributeHolder[] outerContext3, XmlDictionaryReaderQuotas quotas);
    internal static string GetPrefixIfNamespaceDeclaration(string prefix, string localName);
    private static bool IsNamespaceDeclaration(string prefix, string localName);
    internal static Byte[] SpliceBuffers(Byte[] middle, Byte[] wrapper, int wrapperLength, int wrappingDepth);
    private static void WriteNamespaceDeclarations(XmlAttributeHolder[] attributes, XmlWriter writer);
}
internal static class System.ServiceModel.Security.EmptyReadOnlyCollection`1 : object {
    public static ReadOnlyCollection`1<T> Instance;
    private static EmptyReadOnlyCollection`1();
}
public class System.ServiceModel.Security.HttpDigestClientCredential : object {
    private NetworkCredential _digestCredentials;
    private bool _isReadOnly;
    public NetworkCredential ClientCredential { get; public set; }
    internal HttpDigestClientCredential(HttpDigestClientCredential other);
    public NetworkCredential get_ClientCredential();
    public void set_ClientCredential(NetworkCredential value);
    internal void MakeReadOnly();
    private void ThrowIfImmutable();
}
internal interface System.ServiceModel.Security.IChannelSecureConversationSessionSettings {
    public TimeSpan KeyRenewalInterval { get; public set; }
    public TimeSpan KeyRolloverInterval { get; public set; }
    public bool TolerateTransportFailures { get; public set; }
    public abstract virtual TimeSpan get_KeyRenewalInterval();
    public abstract virtual void set_KeyRenewalInterval(TimeSpan value);
    public abstract virtual TimeSpan get_KeyRolloverInterval();
    public abstract virtual void set_KeyRolloverInterval(TimeSpan value);
    public abstract virtual bool get_TolerateTransportFailures();
    public abstract virtual void set_TolerateTransportFailures(bool value);
}
public abstract class System.ServiceModel.Security.IdentityVerifier : object {
    public static IdentityVerifier CreateDefault();
    public abstract virtual bool CheckAccess(EndpointIdentity identity, AuthorizationContext authContext);
    public abstract virtual bool TryGetIdentity(EndpointAddress reference, EndpointIdentity& identity);
    private static void AdjustAddress(EndpointAddress& reference, Uri via);
    internal bool TryGetIdentity(EndpointAddress reference, Uri via, EndpointIdentity& identity);
    internal void EnsureOutgoingIdentity(EndpointAddress serviceReference, Uri via, AuthorizationContext authorizationContext);
    internal void EnsureOutgoingIdentity(EndpointAddress serviceReference, ReadOnlyCollection`1<IAuthorizationPolicy> authorizationPolicies);
    private void EnsureIdentity(EndpointAddress serviceReference, AuthorizationContext authorizationContext, string errorString);
    private Exception CreateIdentityCheckException(EndpointIdentity identity, AuthorizationContext authorizationContext, string errorString, EndpointAddress serviceReference);
}
internal interface System.ServiceModel.Security.IInitiatorSecuritySessionProtocol {
    public bool ReturnCorrelationState { get; public set; }
    public abstract virtual bool get_ReturnCorrelationState();
    public abstract virtual void set_ReturnCorrelationState(bool value);
    public abstract virtual SecurityToken GetOutgoingSessionToken();
    public abstract virtual void SetIdentityCheckAuthenticator(SecurityTokenAuthenticator tokenAuthenticator);
    public abstract virtual void SetOutgoingSessionToken(SecurityToken token);
    public abstract virtual List`1<SecurityToken> GetIncomingSessionTokens();
    public abstract virtual void SetIncomingSessionTokens(List`1<SecurityToken> tokens);
}
internal class System.ServiceModel.Security.InitiatorSessionSymmetricTransportSecurityProtocol : TransportSecurityProtocol {
    private SecurityToken _outgoingSessionToken;
    private List`1<SecurityToken> _incomingSessionTokens;
    private bool _requireDerivedKeys;
    [CompilerGeneratedAttribute]
private object <ThisLock>k__BackingField;
    private SessionSymmetricTransportSecurityProtocolFactory Factory { get; }
    private object ThisLock { get; }
    public bool ReturnCorrelationState { get; public set; }
    public InitiatorSessionSymmetricTransportSecurityProtocol(SessionSymmetricTransportSecurityProtocolFactory factory, EndpointAddress target, Uri via);
    private SessionSymmetricTransportSecurityProtocolFactory get_Factory();
    [CompilerGeneratedAttribute]
private object get_ThisLock();
    public sealed virtual bool get_ReturnCorrelationState();
    public sealed virtual void set_ReturnCorrelationState(bool value);
    public sealed virtual SecurityToken GetOutgoingSessionToken();
    public sealed virtual void SetIdentityCheckAuthenticator(SecurityTokenAuthenticator authenticator);
    public sealed virtual void SetOutgoingSessionToken(SecurityToken token);
    public sealed virtual List`1<SecurityToken> GetIncomingSessionTokens();
    public sealed virtual void SetIncomingSessionTokens(List`1<SecurityToken> tokens);
    private void GetTokensForOutgoingMessages(SecurityToken& signingToken, SecurityToken& sourceToken, SecurityTokenParameters& tokenParameters);
    internal void SetupDelayedSecurityExecution(string actor, Message& message, SecurityToken signingToken, SecurityToken sourceToken, SecurityTokenParameters tokenParameters, IList`1<SupportingTokenSpecification> supportingTokens);
    [AsyncStateMachineAttribute("System.ServiceModel.Security.InitiatorSessionSymmetricTransportSecurityProtocol/<SecureOutgoingMessageAtInitiatorAsync>d__19")]
protected virtual Task`1<Message> SecureOutgoingMessageAtInitiatorAsync(Message message, string actor, TimeSpan timeout);
}
internal class System.ServiceModel.Security.InMemoryNonceCache : NonceCache {
    private NonceCacheImpl _cacheImpl;
    public InMemoryNonceCache(TimeSpan cachingTime, int maxCachedNonces);
    public virtual bool CheckNonce(Byte[] nonce);
    public virtual bool TryAddNonce(Byte[] nonce);
    public virtual string ToString();
}
public interface System.ServiceModel.Security.ISecureConversationSession {
    public abstract virtual void WriteSessionTokenIdentifier(XmlDictionaryWriter writer);
    public abstract virtual bool TryReadSessionTokenIdentifier(XmlReader reader);
}
internal interface System.ServiceModel.Security.ISecurityCommunicationObject {
    public TimeSpan DefaultOpenTimeout { get; }
    public TimeSpan DefaultCloseTimeout { get; }
    public abstract virtual TimeSpan get_DefaultOpenTimeout();
    public abstract virtual TimeSpan get_DefaultCloseTimeout();
    public abstract virtual void OnAbort();
    public abstract virtual Task OnCloseAsync(TimeSpan timeout);
    public abstract virtual void OnClosed();
    public abstract virtual void OnClosing();
    public abstract virtual void OnFaulted();
    public abstract virtual Task OnOpenAsync(TimeSpan timeout);
    public abstract virtual void OnOpened();
    public abstract virtual void OnOpening();
}
public interface System.ServiceModel.Security.ISecuritySession {
    public EndpointIdentity RemoteIdentity { get; }
    public abstract virtual EndpointIdentity get_RemoteIdentity();
}
internal abstract class System.ServiceModel.Security.IssuanceTokenProviderBase`1 : CommunicationObjectSecurityTokenProvider {
    internal static string defaultClientMaxTokenCachingTimeString;
    internal static bool defaultClientCacheTokens;
    internal static int defaultServiceTokenValidityThresholdPercentage;
    private EndpointAddress _issuerAddress;
    private EndpointAddress _targetAddress;
    private Uri _via;
    private bool _cacheServiceTokens;
    private int _serviceTokenValidityThresholdPercentage;
    private TimeSpan _maxServiceTokenCachingTime;
    private SecurityStandardsManager _standardsManager;
    private SecurityAlgorithmSuite _algorithmSuite;
    private ChannelProtectionRequirements _applicationProtectionRequirements;
    private SecurityToken _cachedToken;
    private string _sctUri;
    [CompilerGeneratedAttribute]
private object <ThisLock>k__BackingField;
    public EndpointAddress IssuerAddress { get; public set; }
    public EndpointAddress TargetAddress { get; public set; }
    public bool CacheServiceTokens { get; public set; }
    internal static TimeSpan DefaultClientMaxTokenCachingTime { get; }
    public int ServiceTokenValidityThresholdPercentage { get; public set; }
    public SecurityAlgorithmSuite SecurityAlgorithmSuite { get; public set; }
    public TimeSpan MaxServiceTokenCachingTime { get; public set; }
    public SecurityStandardsManager StandardsManager { get; public set; }
    public ChannelProtectionRequirements ApplicationProtectionRequirements { get; public set; }
    public Uri Via { get; public set; }
    public bool SupportsTokenCancellation { get; }
    protected object ThisLock { get; }
    protected bool IsMultiLegNegotiation { get; }
    protected MessageVersion MessageVersion { get; }
    protected bool RequiresManualReplyAddressing { get; }
    public XmlDictionaryString RequestSecurityTokenAction { get; }
    public XmlDictionaryString RequestSecurityTokenResponseAction { get; }
    protected string SecurityContextTokenUri { get; }
    public EndpointAddress get_IssuerAddress();
    public void set_IssuerAddress(EndpointAddress value);
    public EndpointAddress get_TargetAddress();
    public void set_TargetAddress(EndpointAddress value);
    public bool get_CacheServiceTokens();
    public void set_CacheServiceTokens(bool value);
    internal static TimeSpan get_DefaultClientMaxTokenCachingTime();
    public int get_ServiceTokenValidityThresholdPercentage();
    public void set_ServiceTokenValidityThresholdPercentage(int value);
    public SecurityAlgorithmSuite get_SecurityAlgorithmSuite();
    public void set_SecurityAlgorithmSuite(SecurityAlgorithmSuite value);
    public TimeSpan get_MaxServiceTokenCachingTime();
    public void set_MaxServiceTokenCachingTime(TimeSpan value);
    public SecurityStandardsManager get_StandardsManager();
    public void set_StandardsManager(SecurityStandardsManager value);
    public ChannelProtectionRequirements get_ApplicationProtectionRequirements();
    public void set_ApplicationProtectionRequirements(ChannelProtectionRequirements value);
    public Uri get_Via();
    public void set_Via(Uri value);
    public virtual bool get_SupportsTokenCancellation();
    [CompilerGeneratedAttribute]
protected object get_ThisLock();
    protected virtual bool get_IsMultiLegNegotiation();
    protected abstract virtual MessageVersion get_MessageVersion();
    protected abstract virtual bool get_RequiresManualReplyAddressing();
    public abstract virtual XmlDictionaryString get_RequestSecurityTokenAction();
    public abstract virtual XmlDictionaryString get_RequestSecurityTokenResponseAction();
    protected string get_SecurityContextTokenUri();
    protected void ThrowIfCreated();
    protected void ThrowIfClosedOrCreated();
    public virtual Task OnOpenAsync(TimeSpan timeout);
    protected void EnsureEndpointAddressDoesNotRequireEncryption(EndpointAddress target);
    private DateTime GetServiceTokenEffectiveExpirationTime(SecurityToken serviceToken);
    private bool IsServiceTokenTimeValid(SecurityToken serviceToken);
    private SecurityToken GetCurrentServiceToken();
    protected static void ThrowIfFault(Message message, EndpointAddress target);
    protected virtual SecurityToken GetTokenCore(TimeSpan timeout);
    internal virtual Task`1<SecurityToken> GetTokenCoreInternalAsync(TimeSpan timeout);
    internal virtual Task CancelTokenCoreInternalAsync(TimeSpan timeout, SecurityToken token);
    protected abstract virtual Task`1<T> CreateNegotiationStateAsync(EndpointAddress target, Uri via, TimeSpan timeout);
    protected abstract virtual BodyWriter GetFirstOutgoingMessageBody(T negotiationState, MessageProperties& properties);
    protected abstract virtual BodyWriter GetNextOutgoingMessageBody(Message incomingMessage, T negotiationState);
    protected abstract virtual Task InitializeChannelFactoriesAsync(EndpointAddress target, TimeSpan timeout);
    protected abstract virtual IAsyncRequestChannel CreateClientChannel(EndpointAddress target, Uri via);
    private void PrepareRequest(Message nextMessage);
    private void PrepareRequest(Message nextMessage, RequestSecurityToken rst);
    [AsyncStateMachineAttribute("System.ServiceModel.Security.IssuanceTokenProviderBase`1/<DoNegotiationAsync>d__79")]
protected Task`1<SecurityToken> DoNegotiationAsync(TimeSpan timeout);
    private void InitializeNegotiationState(T negotiationState);
    private Message GetNextOutgoingMessage(Message incomingMessage, T negotiationState);
    private void Cleanup(IChannel rstChannel, T negotiationState);
    protected virtual void ValidateKeySize(GenericXmlSecurityToken issuedToken);
    private static bool ShouldWrapException(Exception e);
    private static Exception WrapExceptionIfRequired(Exception e, EndpointAddress targetAddress, EndpointAddress issuerAddress);
    private void ValidateAndCacheServiceToken(T negotiationState);
}
internal class System.ServiceModel.Security.IssuanceTokenProviderState : object {
    private GenericXmlSecurityToken _serviceToken;
    [CompilerGeneratedAttribute]
private bool <IsNegotiationCompleted>k__BackingField;
    [CompilerGeneratedAttribute]
private EndpointAddress <TargetAddress>k__BackingField;
    [CompilerGeneratedAttribute]
private EndpointAddress <RemoteAddress>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Context>k__BackingField;
    public bool IsNegotiationCompleted { get; private set; }
    public GenericXmlSecurityToken ServiceToken { get; }
    public EndpointAddress TargetAddress { get; public set; }
    public EndpointAddress RemoteAddress { get; public set; }
    public string Context { get; public set; }
    [CompilerGeneratedAttribute]
public bool get_IsNegotiationCompleted();
    [CompilerGeneratedAttribute]
private void set_IsNegotiationCompleted(bool value);
    public GenericXmlSecurityToken get_ServiceToken();
    [CompilerGeneratedAttribute]
public EndpointAddress get_TargetAddress();
    [CompilerGeneratedAttribute]
public void set_TargetAddress(EndpointAddress value);
    [CompilerGeneratedAttribute]
public EndpointAddress get_RemoteAddress();
    [CompilerGeneratedAttribute]
public void set_RemoteAddress(EndpointAddress value);
    [CompilerGeneratedAttribute]
public string get_Context();
    [CompilerGeneratedAttribute]
public void set_Context(string value);
    public virtual void Dispose();
    public void SetServiceToken(GenericXmlSecurityToken serviceToken);
    private void CheckCompleted();
}
internal enum System.ServiceModel.Security.MessagePartProtectionMode : Enum {
    public int value__;
    public static MessagePartProtectionMode None;
    public static MessagePartProtectionMode Sign;
    public static MessagePartProtectionMode Encrypt;
    public static MessagePartProtectionMode SignThenEncrypt;
    public static MessagePartProtectionMode EncryptThenSign;
}
internal static class System.ServiceModel.Security.MessagePartProtectionModeHelper : object {
    public static MessagePartProtectionMode GetProtectionMode(bool sign, bool encrypt, bool signThenEncrypt);
}
public class System.ServiceModel.Security.MessagePartSpecification : object {
    private List`1<XmlQualifiedName> _headerTypes;
    private bool _isBodyIncluded;
    private static MessagePartSpecification s_noParts;
    [CompilerGeneratedAttribute]
private bool <IsReadOnly>k__BackingField;
    public ICollection`1<XmlQualifiedName> HeaderTypes { get; }
    internal bool HasHeaders { get; }
    public bool IsBodyIncluded { get; public set; }
    public bool IsReadOnly { get; private set; }
    public static MessagePartSpecification NoParts { get; }
    public MessagePartSpecification(bool isBodyIncluded);
    public MessagePartSpecification(XmlQualifiedName[] headerTypes);
    public MessagePartSpecification(bool isBodyIncluded, XmlQualifiedName[] headerTypes);
    public ICollection`1<XmlQualifiedName> get_HeaderTypes();
    internal bool get_HasHeaders();
    public bool get_IsBodyIncluded();
    public void set_IsBodyIncluded(bool value);
    [CompilerGeneratedAttribute]
public bool get_IsReadOnly();
    [CompilerGeneratedAttribute]
private void set_IsReadOnly(bool value);
    public static MessagePartSpecification get_NoParts();
    public void Clear();
    public void Union(MessagePartSpecification specification);
    public void MakeReadOnly();
    internal bool IsHeaderIncluded(MessageHeader header);
    internal bool IsHeaderIncluded(string name, string ns);
    internal bool IsEmpty();
}
public enum System.ServiceModel.Security.MessageProtectionOrder : Enum {
    public int value__;
    public static MessageProtectionOrder SignBeforeEncrypt;
    public static MessageProtectionOrder SignBeforeEncryptAndEncryptSignature;
    public static MessageProtectionOrder EncryptBeforeSign;
}
internal static class System.ServiceModel.Security.MessageProtectionOrderHelper : object {
    internal static bool IsDefined(MessageProtectionOrder value);
}
public class System.ServiceModel.Security.MessageSecurityException : CommunicationException {
    public MessageSecurityException(string message);
    public MessageSecurityException(string message, Exception innerException);
    protected MessageSecurityException(SerializationInfo info, StreamingContext context);
}
public class System.ServiceModel.Security.MessageSecurityTokenVersion : SecurityTokenVersion {
    private string _toString;
    private ReadOnlyCollection`1<string> _supportedSpecs;
    private static string bsp10ns;
    private static MessageSecurityTokenVersion s_wss10bsp10;
    private static MessageSecurityTokenVersion s_wss11bsp10;
    private static MessageSecurityTokenVersion s_wss10oasisdec2005bsp10;
    private static MessageSecurityTokenVersion s_wss11oasisdec2005;
    private static MessageSecurityTokenVersion s_wss11oasisdec2005bsp10;
    [CompilerGeneratedAttribute]
private static MessageSecurityTokenVersion <WSSecurity11WSTrustFebruary2005WSSecureConversationFebruary2005>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <EmitBspRequiredAttributes>k__BackingField;
    [CompilerGeneratedAttribute]
private SecurityVersion <SecurityVersion>k__BackingField;
    [CompilerGeneratedAttribute]
private TrustVersion <TrustVersion>k__BackingField;
    [CompilerGeneratedAttribute]
private SecureConversationVersion <SecureConversationVersion>k__BackingField;
    public static MessageSecurityTokenVersion WSSecurity11WSTrustFebruary2005WSSecureConversationFebruary2005 { get; }
    public static MessageSecurityTokenVersion WSSecurity11WSTrustFebruary2005WSSecureConversationFebruary2005BasicSecurityProfile10 { get; }
    public static MessageSecurityTokenVersion WSSecurity10WSTrustFebruary2005WSSecureConversationFebruary2005BasicSecurityProfile10 { get; }
    public static MessageSecurityTokenVersion WSSecurity10WSTrust13WSSecureConversation13BasicSecurityProfile10 { get; }
    public static MessageSecurityTokenVersion WSSecurity11WSTrust13WSSecureConversation13 { get; }
    public static MessageSecurityTokenVersion WSSecurity11WSTrust13WSSecureConversation13BasicSecurityProfile10 { get; }
    public bool EmitBspRequiredAttributes { get; }
    public SecurityVersion SecurityVersion { get; }
    public TrustVersion TrustVersion { get; }
    public SecureConversationVersion SecureConversationVersion { get; }
    private MessageSecurityTokenVersion(SecurityVersion securityVersion, TrustVersion trustVersion, SecureConversationVersion secureConversationVersion, string toString, bool emitBspRequiredAttributes, String[] supportedSpecs);
    private static MessageSecurityTokenVersion();
    [CompilerGeneratedAttribute]
public static MessageSecurityTokenVersion get_WSSecurity11WSTrustFebruary2005WSSecureConversationFebruary2005();
    public static MessageSecurityTokenVersion get_WSSecurity11WSTrustFebruary2005WSSecureConversationFebruary2005BasicSecurityProfile10();
    public static MessageSecurityTokenVersion get_WSSecurity10WSTrustFebruary2005WSSecureConversationFebruary2005BasicSecurityProfile10();
    public static MessageSecurityTokenVersion get_WSSecurity10WSTrust13WSSecureConversation13BasicSecurityProfile10();
    public static MessageSecurityTokenVersion get_WSSecurity11WSTrust13WSSecureConversation13();
    public static MessageSecurityTokenVersion get_WSSecurity11WSTrust13WSSecureConversation13BasicSecurityProfile10();
    public static MessageSecurityTokenVersion GetSecurityTokenVersion(SecurityVersion version, bool emitBspAttributes);
    [CompilerGeneratedAttribute]
public bool get_EmitBspRequiredAttributes();
    [CompilerGeneratedAttribute]
public SecurityVersion get_SecurityVersion();
    [CompilerGeneratedAttribute]
public TrustVersion get_TrustVersion();
    [CompilerGeneratedAttribute]
public SecureConversationVersion get_SecureConversationVersion();
    public virtual ReadOnlyCollection`1<string> GetSecuritySpecifications();
    public virtual string ToString();
}
internal static class System.ServiceModel.Security.Namespaces : object {
    internal static string WSPolicy;
    internal static string WSPolicyPrefix;
    internal static string XmlSchema;
    internal static string XmlSchemaPrefix;
}
internal abstract class System.ServiceModel.Security.NegotiationTokenProvider`1 : IssuanceTokenProviderBase`1<T> {
    private IChannelFactory`1<IAsyncRequestChannel> _rstChannelFactory;
    private bool _requiresManualReplyAddressing;
    private BindingContext _issuanceBindingContext;
    private MessageVersion _messageVersion;
    public BindingContext IssuerBindingContext { get; public set; }
    public XmlDictionaryString RequestSecurityTokenAction { get; }
    public XmlDictionaryString RequestSecurityTokenResponseAction { get; }
    protected MessageVersion MessageVersion { get; }
    protected bool RequiresManualReplyAddressing { get; }
    public BindingContext get_IssuerBindingContext();
    public void set_IssuerBindingContext(BindingContext value);
    public virtual XmlDictionaryString get_RequestSecurityTokenAction();
    public virtual XmlDictionaryString get_RequestSecurityTokenResponseAction();
    protected virtual MessageVersion get_MessageVersion();
    protected virtual bool get_RequiresManualReplyAddressing();
    [AsyncStateMachineAttribute("System.ServiceModel.Security.NegotiationTokenProvider`1/<OnCloseAsync>d__16")]
public virtual Task OnCloseAsync(TimeSpan timeout);
    public virtual void OnAbort();
    [AsyncStateMachineAttribute("System.ServiceModel.Security.NegotiationTokenProvider`1/<OnOpenAsync>d__18")]
public virtual Task OnOpenAsync(TimeSpan timeout);
    protected abstract virtual IChannelFactory`1<IAsyncRequestChannel> GetNegotiationChannelFactory(IChannelFactory`1<IAsyncRequestChannel> transportChannelFactory, ChannelBuilder channelBuilder);
    private void SetupRstChannelFactory();
    protected virtual Task InitializeChannelFactoriesAsync(EndpointAddress target, TimeSpan timeout);
    protected virtual IAsyncRequestChannel CreateClientChannel(EndpointAddress target, Uri via);
    [CompilerGeneratedAttribute]
[DebuggerHiddenAttribute]
private Task <>n__0(TimeSpan timeout);
    [CompilerGeneratedAttribute]
[DebuggerHiddenAttribute]
private Task <>n__1(TimeSpan timeout);
}
public abstract class System.ServiceModel.Security.NonceCache : object {
    private TimeSpan _cachingTime;
    private int _maxCachedNonces;
    public TimeSpan CachingTimeSpan { get; public set; }
    public int CacheSize { get; public set; }
    public TimeSpan get_CachingTimeSpan();
    public void set_CachingTimeSpan(TimeSpan value);
    public int get_CacheSize();
    public void set_CacheSize(int value);
    public abstract virtual bool TryAddNonce(Byte[] nonce);
    public abstract virtual bool CheckNonce(Byte[] nonce);
}
internal class System.ServiceModel.Security.NonceToken : BinarySecretSecurityToken {
    public NonceToken(Byte[] key);
    public NonceToken(string id, Byte[] key);
    public NonceToken(int keySizeInBits);
}
internal class System.ServiceModel.Security.OperationWithTimeoutAsyncResult : TraceAsyncResult {
    private static Action`1<object> s_scheduledCallback;
    private TimeoutHelper _timeoutHelper;
    private Action`1<TimeSpan> _operationWithTimeout;
    public OperationWithTimeoutAsyncResult(Action`1<TimeSpan> operationWithTimeout, TimeSpan timeout, AsyncCallback callback, object state);
    private static OperationWithTimeoutAsyncResult();
    private static void OnScheduled(object state);
    public static void End(IAsyncResult result);
}
internal static class System.ServiceModel.Security.ProtectionLevelHelper : object {
    public static bool IsDefined(ProtectionLevel value);
    public static void Validate(ProtectionLevel value);
    public static bool IsStronger(ProtectionLevel v1, ProtectionLevel v2);
    public static bool IsStrongerOrEqual(ProtectionLevel v1, ProtectionLevel v2);
    public static ProtectionLevel Max(ProtectionLevel v1, ProtectionLevel v2);
}
internal enum System.ServiceModel.Security.PurgingMode : Enum {
    public int value__;
    public static PurgingMode TimerBasedPurge;
    public static PurgingMode AccessBasedPurge;
}
internal abstract class System.ServiceModel.Security.ReceiveSecurityHeader : SecurityHeader {
    private SecurityTokenAuthenticator _primaryTokenAuthenticator;
    private bool _allowFirstTokenMismatch;
    private SecurityToken _outOfBandPrimaryToken;
    private IList`1<SecurityToken> _outOfBandPrimaryTokenCollection;
    private SecurityTokenParameters _primaryTokenParameters;
    private TokenTracker _primaryTokenTracker;
    private SecurityToken _wrappingToken;
    private SecurityTokenParameters _wrappingTokenParameters;
    private SecurityTokenAuthenticator _derivedTokenAuthenticator;
    private IList`1<SupportingTokenAuthenticatorSpecification> _supportingTokenAuthenticators;
    private ChannelBinding _channelBinding;
    private ExtendedProtectionPolicy _extendedProtectionPolicy;
    private bool _expectBasicTokens;
    private bool _expectSignedTokens;
    private bool _expectEndorsingTokens;
    private bool _expectSignatureConfirmation;
    private List`1<TokenTracker> _supportingTokenTrackers;
    private List`1<SecurityTokenAuthenticator> _allowedAuthenticators;
    private SecurityTokenAuthenticator _pendingSupportingTokenAuthenticator;
    private Collection`1<SecurityToken> _signedEndorsingTokens;
    private Dictionary`2<SecurityToken, ReadOnlyCollection`1<IAuthorizationPolicy>> _tokenPoliciesMapping;
    private SecurityTimestamp _timestamp;
    private SecurityHeaderTokenResolver _universalTokenResolver;
    private SecurityHeaderTokenResolver _primaryTokenResolver;
    private ReadOnlyCollection`1<SecurityTokenResolver> _outOfBandTokenResolver;
    private SecurityTokenResolver _combinedPrimaryTokenResolver;
    private XmlAttributeHolder[] _securityElementAttributes;
    private OrderTracker _orderTracker;
    private OperationTracker _signatureTracker;
    private OperationTracker _encryptionTracker;
    private int _maxDerivedKeys;
    private int _numDerivedKeys;
    private bool _enforceDerivedKeyRequirement;
    private NonceCache _nonceCache;
    private TimeSpan _replayWindow;
    private TimeSpan _clockSkew;
    private TimeoutHelper _timeoutHelper;
    private long _maxReceivedMessageSize;
    private XmlDictionaryReaderQuotas _readerQuotas;
    private MessageProtectionOrder _protectionOrder;
    private bool _hasEndorsingOrSignedEndorsingSupportingTokens;
    private SignatureResourcePool _resourcePool;
    private bool _replayDetectionEnabled;
    private static int AppendPosition;
    [CompilerGeneratedAttribute]
private Collection`1<SecurityToken> <BasicSupportingTokens>k__BackingField;
    [CompilerGeneratedAttribute]
private Collection`1<SecurityToken> <SignedSupportingTokens>k__BackingField;
    [CompilerGeneratedAttribute]
private Collection`1<SecurityToken> <EndorsingSupportingTokens>k__BackingField;
    [CompilerGeneratedAttribute]
private Byte[] <PrimarySignatureValue>k__BackingField;
    [CompilerGeneratedAttribute]
private ReceiveSecurityHeaderElementManager <ElementManager>k__BackingField;
    [CompilerGeneratedAttribute]
private SecurityTokenResolver <CombinedUniversalTokenResolver>k__BackingField;
    [CompilerGeneratedAttribute]
private int <HeaderIndex>k__BackingField;
    [CompilerGeneratedAttribute]
private SecurityVerifiedMessage <SecurityVerifiedMessage>k__BackingField;
    [CompilerGeneratedAttribute]
private int <MaxDerivedKeyLength>k__BackingField;
    public Collection`1<SecurityToken> BasicSupportingTokens { get; }
    public Collection`1<SecurityToken> SignedSupportingTokens { get; }
    public Collection`1<SecurityToken> EndorsingSupportingTokens { get; }
    public Collection`1<SecurityToken> SignedEndorsingSupportingTokens { get; }
    public bool EnforceDerivedKeyRequirement { get; public set; }
    public Byte[] PrimarySignatureValue { get; }
    public SecurityToken EncryptionToken { get; }
    public bool ExpectBasicTokens { get; public set; }
    public ReceiveSecurityHeaderElementManager ElementManager { get; }
    public SecurityTokenAuthenticator DerivedTokenAuthenticator { get; public set; }
    public bool ReplayDetectionEnabled { get; public set; }
    public bool ExpectSignatureConfirmation { get; public set; }
    public bool ExpectSignedTokens { get; public set; }
    public bool ExpectEndorsingTokens { get; public set; }
    public SecurityTokenResolver CombinedUniversalTokenResolver { get; private set; }
    internal int HeaderIndex { get; }
    internal long MaxReceivedMessageSize { get; internal set; }
    internal XmlDictionaryReaderQuotas ReaderQuotas { get; internal set; }
    public string Name { get; }
    public string Namespace { get; }
    public Message ProcessedMessage { get; }
    protected SignatureResourcePool ResourcePool { get; }
    internal SecurityVerifiedMessage SecurityVerifiedMessage { get; private set; }
    public SecurityToken SignatureToken { get; }
    public Dictionary`2<SecurityToken, ReadOnlyCollection`1<IAuthorizationPolicy>> SecurityTokenAuthorizationPoliciesMapping { get; }
    public int MaxDerivedKeyLength { get; private set; }
    protected ReceiveSecurityHeader(Message message, string actor, bool mustUnderstand, bool relay, SecurityStandardsManager standardsManager, SecurityAlgorithmSuite algorithmSuite, int headerIndex, MessageDirection direction);
    [CompilerGeneratedAttribute]
public Collection`1<SecurityToken> get_BasicSupportingTokens();
    [CompilerGeneratedAttribute]
public Collection`1<SecurityToken> get_SignedSupportingTokens();
    [CompilerGeneratedAttribute]
public Collection`1<SecurityToken> get_EndorsingSupportingTokens();
    public Collection`1<SecurityToken> get_SignedEndorsingSupportingTokens();
    public bool get_EnforceDerivedKeyRequirement();
    public void set_EnforceDerivedKeyRequirement(bool value);
    [CompilerGeneratedAttribute]
public Byte[] get_PrimarySignatureValue();
    public SecurityToken get_EncryptionToken();
    public bool get_ExpectBasicTokens();
    public void set_ExpectBasicTokens(bool value);
    [CompilerGeneratedAttribute]
public ReceiveSecurityHeaderElementManager get_ElementManager();
    public SecurityTokenAuthenticator get_DerivedTokenAuthenticator();
    public void set_DerivedTokenAuthenticator(SecurityTokenAuthenticator value);
    public bool get_ReplayDetectionEnabled();
    public void set_ReplayDetectionEnabled(bool value);
    public bool get_ExpectSignatureConfirmation();
    public void set_ExpectSignatureConfirmation(bool value);
    public bool get_ExpectSignedTokens();
    public void set_ExpectSignedTokens(bool value);
    public bool get_ExpectEndorsingTokens();
    public void set_ExpectEndorsingTokens(bool value);
    [CompilerGeneratedAttribute]
public SecurityTokenResolver get_CombinedUniversalTokenResolver();
    [CompilerGeneratedAttribute]
private void set_CombinedUniversalTokenResolver(SecurityTokenResolver value);
    [CompilerGeneratedAttribute]
internal int get_HeaderIndex();
    internal long get_MaxReceivedMessageSize();
    internal void set_MaxReceivedMessageSize(long value);
    internal XmlDictionaryReaderQuotas get_ReaderQuotas();
    internal void set_ReaderQuotas(XmlDictionaryReaderQuotas value);
    public virtual string get_Name();
    public virtual string get_Namespace();
    public Message get_ProcessedMessage();
    protected SignatureResourcePool get_ResourcePool();
    [CompilerGeneratedAttribute]
internal SecurityVerifiedMessage get_SecurityVerifiedMessage();
    [CompilerGeneratedAttribute]
private void set_SecurityVerifiedMessage(SecurityVerifiedMessage value);
    public SecurityToken get_SignatureToken();
    public Dictionary`2<SecurityToken, ReadOnlyCollection`1<IAuthorizationPolicy>> get_SecurityTokenAuthorizationPoliciesMapping();
    [CompilerGeneratedAttribute]
public int get_MaxDerivedKeyLength();
    [CompilerGeneratedAttribute]
private void set_MaxDerivedKeyLength(int value);
    internal XmlDictionaryReader CreateSecurityHeaderReader();
    protected virtual void OnWriteHeaderContents(XmlDictionaryWriter writer, MessageVersion messageVersion);
    private XmlDictionaryReader GetReaderAtSecurityHeader();
    public void SetTimeParameters(NonceCache nonceCache, TimeSpan replayWindow, TimeSpan clockSkew);
    public void Process(TimeSpan timeout, ChannelBinding channelBinding, ExtendedProtectionPolicy extendedProtectionPolicy);
    protected abstract virtual void EnsureDecryptionComplete();
    internal void ExecuteFullPass(XmlDictionaryReader reader);
    internal void EnsureDerivedKeyLimitNotReached();
    protected TokenTracker GetSupportingTokenTracker(SecurityTokenAuthenticator tokenAuthenticator, SupportingTokenAuthenticatorSpecification& spec);
    private void ReadTimestamp(XmlDictionaryReader reader);
    private bool IsPrimaryToken(SecurityToken token);
    private void ReadToken(XmlDictionaryReader reader, int position, Byte[] decryptedBuffer, SecurityToken encryptionToken, string idInEncryptedForm, TimeSpan timeout);
    private SecurityToken GetRootToken(SecurityToken token);
    private SecurityToken ReadToken(XmlReader reader, SecurityTokenResolver tokenResolver, IList`1<SecurityTokenAuthenticator> allowedTokenAuthenticators, SecurityTokenAuthenticator& usedTokenAuthenticator);
    private void AddDerivedKeyTokenToResolvers(SecurityToken token);
    protected abstract virtual bool IsReaderAtEncryptedKey(XmlDictionaryReader reader);
    protected abstract virtual bool IsReaderAtEncryptedData(XmlDictionaryReader reader);
    protected abstract virtual bool IsReaderAtReferenceList(XmlDictionaryReader reader);
    protected abstract virtual bool IsReaderAtSignature(XmlDictionaryReader reader);
    protected abstract virtual bool IsReaderAtSecurityTokenReference(XmlDictionaryReader reader);
    private void MarkHeaderAsUnderstood();
}
[FlagsAttribute]
internal enum System.ServiceModel.Security.ReceiveSecurityHeaderBindingModes : Enum {
    public int value__;
    public static ReceiveSecurityHeaderBindingModes Unknown;
    public static ReceiveSecurityHeaderBindingModes Primary;
    public static ReceiveSecurityHeaderBindingModes Endorsing;
    public static ReceiveSecurityHeaderBindingModes Signed;
    public static ReceiveSecurityHeaderBindingModes SignedEndorsing;
    public static ReceiveSecurityHeaderBindingModes Basic;
}
internal enum System.ServiceModel.Security.ReceiveSecurityHeaderElementCategory : Enum {
    public int value__;
    public static ReceiveSecurityHeaderElementCategory Signature;
    public static ReceiveSecurityHeaderElementCategory EncryptedData;
    public static ReceiveSecurityHeaderElementCategory EncryptedKey;
    public static ReceiveSecurityHeaderElementCategory SignatureConfirmation;
    public static ReceiveSecurityHeaderElementCategory ReferenceList;
    public static ReceiveSecurityHeaderElementCategory SecurityTokenReference;
    public static ReceiveSecurityHeaderElementCategory Timestamp;
    public static ReceiveSecurityHeaderElementCategory Token;
}
internal class System.ServiceModel.Security.ReceiveSecurityHeaderElementManager : object {
    private static int InitialCapacity;
    private ReceiveSecurityHeader _securityHeader;
    private ReceiveSecurityHeaderEntry[] _elements;
    private String[] _headerIds;
    [CompilerGeneratedAttribute]
private int <Count>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsPrimaryTokenSigned>k__BackingField;
    public int Count { get; private set; }
    public bool IsPrimaryTokenSigned { get; public set; }
    public ReceiveSecurityHeaderElementManager(ReceiveSecurityHeader securityHeader);
    [CompilerGeneratedAttribute]
public int get_Count();
    [CompilerGeneratedAttribute]
private void set_Count(int value);
    [CompilerGeneratedAttribute]
public bool get_IsPrimaryTokenSigned();
    [CompilerGeneratedAttribute]
public void set_IsPrimaryTokenSigned(bool value);
    public void AppendElement(ReceiveSecurityHeaderElementCategory elementCategory, object element, ReceiveSecurityHeaderBindingModes bindingMode, string id, TokenTracker supportingTokenTracker);
    public void AppendTimestamp(SecurityTimestamp timestamp);
    public void AppendToken(SecurityToken token, ReceiveSecurityHeaderBindingModes mode, TokenTracker supportingTokenTracker);
    private void EnsureCapacityToAdd();
    public object GetElement(int index);
    public void GetElementEntry(int index, ReceiveSecurityHeaderEntry& element);
    public ReceiveSecurityHeaderElementCategory GetElementCategory(int index);
    internal XmlDictionaryReader GetReader(int index, bool requiresEncryptedFormReader);
    private void OnDuplicateId(string id);
    public void SetBindingMode(int index, ReceiveSecurityHeaderBindingModes bindingMode);
    public void SetElementAfterDecryption(int index, ReceiveSecurityHeaderElementCategory elementCategory, object element, ReceiveSecurityHeaderBindingModes bindingMode, string id, Byte[] decryptedBuffer, TokenTracker supportingTokenTracker);
    public void SetTokenAfterDecryption(int index, SecurityToken token, ReceiveSecurityHeaderBindingModes mode, Byte[] decryptedBuffer, TokenTracker supportingTokenTracker);
    private void VerifyIdUniquenessInSecurityHeader(string id);
}
internal class System.ServiceModel.Security.ReceiveSecurityHeaderEntry : ValueType {
    internal ReceiveSecurityHeaderElementCategory _elementCategory;
    internal object _element;
    internal ReceiveSecurityHeaderBindingModes _bindingMode;
    internal string _id;
    internal string _encryptedFormId;
    internal bool _encrypted;
    internal Byte[] _decryptedBuffer;
    internal TokenTracker _supportingTokenTracker;
    public void PreserveIdBeforeDecryption();
    public void SetElement(ReceiveSecurityHeaderElementCategory elementCategory, object element, ReceiveSecurityHeaderBindingModes bindingMode, string id, bool encrypted, Byte[] decryptedBuffer, TokenTracker supportingTokenTracker);
}
internal class System.ServiceModel.Security.ReferenceList : object {
    internal static XmlDictionaryString ElementName;
    internal static XmlDictionaryString NamespaceUri;
    private static ReferenceList();
}
internal class System.ServiceModel.Security.RequestSecurityToken : BodyWriter {
    private string _context;
    private string _tokenType;
    private string _requestType;
    private SecurityToken _entropyToken;
    private BinaryNegotiation _negotiationData;
    private XmlElement _rstXml;
    private IList`1<XmlElement> _requestProperties;
    private ArraySegment`1<byte> _cachedWriteBuffer;
    private int _cachedWriteBufferLength;
    private int _keySize;
    private SecurityKeyIdentifierClause _renewTarget;
    private SecurityKeyIdentifierClause _closeTarget;
    private SecurityStandardsManager _standardsManager;
    private bool _isReadOnly;
    private object _appliesTo;
    private DataContractSerializer _appliesToSerializer;
    private Type _appliesToType;
    private object _thisLock;
    [CompilerGeneratedAttribute]
private Message <Message>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsReceiver>k__BackingField;
    public Message Message { get; public set; }
    public string Context { get; public set; }
    public string TokenType { get; public set; }
    public int KeySize { get; public set; }
    public bool IsReadOnly { get; }
    public IEnumerable`1<XmlElement> RequestProperties { get; public set; }
    public string RequestType { get; public set; }
    public SecurityKeyIdentifierClause RenewTarget { get; public set; }
    public SecurityKeyIdentifierClause CloseTarget { get; public set; }
    public XmlElement RequestSecurityTokenXml { get; }
    internal bool IsReceiver { get; }
    internal object AppliesTo { get; }
    internal DataContractSerializer AppliesToSerializer { get; }
    internal Type AppliesToType { get; }
    public RequestSecurityToken(MessageSecurityVersion messageSecurityVersion, SecurityTokenSerializer securityTokenSerializer);
    public RequestSecurityToken(MessageSecurityVersion messageSecurityVersion, SecurityTokenSerializer securityTokenSerializer, XmlElement requestSecurityTokenXml, string context, string tokenType, string requestType, int keySize, SecurityKeyIdentifierClause renewTarget, SecurityKeyIdentifierClause closeTarget);
    public RequestSecurityToken(XmlElement requestSecurityTokenXml, string context, string tokenType, string requestType, int keySize, SecurityKeyIdentifierClause renewTarget, SecurityKeyIdentifierClause closeTarget);
    internal RequestSecurityToken(SecurityStandardsManager standardsManager, XmlElement rstXml, string context, string tokenType, string requestType, int keySize, SecurityKeyIdentifierClause renewTarget, SecurityKeyIdentifierClause closeTarget);
    internal RequestSecurityToken(SecurityStandardsManager standardsManager);
    internal RequestSecurityToken(SecurityStandardsManager standardsManager, bool isBuffered);
    public ChannelBinding GetChannelBinding();
    [CompilerGeneratedAttribute]
public Message get_Message();
    [CompilerGeneratedAttribute]
public void set_Message(Message value);
    public string get_Context();
    public void set_Context(string value);
    public string get_TokenType();
    public void set_TokenType(string value);
    public int get_KeySize();
    public void set_KeySize(int value);
    public bool get_IsReadOnly();
    public IEnumerable`1<XmlElement> get_RequestProperties();
    public void set_RequestProperties(IEnumerable`1<XmlElement> value);
    public string get_RequestType();
    public void set_RequestType(string value);
    public SecurityKeyIdentifierClause get_RenewTarget();
    public void set_RenewTarget(SecurityKeyIdentifierClause value);
    public SecurityKeyIdentifierClause get_CloseTarget();
    public void set_CloseTarget(SecurityKeyIdentifierClause value);
    public XmlElement get_RequestSecurityTokenXml();
    [CompilerGeneratedAttribute]
internal bool get_IsReceiver();
    internal object get_AppliesTo();
    internal DataContractSerializer get_AppliesToSerializer();
    internal Type get_AppliesToType();
    internal BinaryNegotiation GetBinaryNegotiation();
    public SecurityToken GetRequestorEntropy();
    internal SecurityToken GetRequestorEntropy(SecurityTokenResolver resolver);
    public void SetRequestorEntropy(Byte[] entropy);
    public T GetAppliesTo(XmlObjectSerializer serializer);
    private void OnWriteTo(XmlWriter writer);
    public void WriteTo(XmlWriter writer);
    internal static RequestSecurityToken CreateFrom(SecurityStandardsManager standardsManager, XmlReader reader);
    public void MakeReadOnly();
    protected internal virtual void OnWriteCustomAttributes(XmlWriter writer);
    protected internal virtual void OnWriteCustomElements(XmlWriter writer);
    protected internal virtual void OnMakeReadOnly();
    protected virtual void OnWriteBodyContents(XmlDictionaryWriter writer);
}
internal class System.ServiceModel.Security.RequestSecurityTokenResponse : BodyWriter {
    private static int s_minSaneKeySizeInBits;
    private static int s_maxSaneKeySizeInBits;
    private SecurityStandardsManager _standardsManager;
    private string _context;
    private int _keySize;
    private bool _computeKey;
    private string _tokenType;
    private SecurityKeyIdentifierClause _requestedAttachedReference;
    private SecurityKeyIdentifierClause _requestedUnattachedReference;
    private SecurityToken _issuedToken;
    private SecurityToken _proofToken;
    private BinaryNegotiation _negotiationData;
    private XmlElement _rstrXml;
    private DateTime _expirationTime;
    private bool _isLifetimeSet;
    private Byte[] _authenticator;
    private bool _isReadOnly;
    private ArraySegment`1<byte> _cachedWriteBuffer;
    private int _cachedWriteBufferLength;
    private bool _isRequestedTokenClosed;
    private object _appliesTo;
    private XmlObjectSerializer _appliesToSerializer;
    private Type _appliesToType;
    private XmlBuffer _issuedTokenBuffer;
    [CompilerGeneratedAttribute]
private DateTime <ValidFrom>k__BackingField;
    [CompilerGeneratedAttribute]
private object <ThisLock>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsReceiver>k__BackingField;
    public string Context { get; public set; }
    public string TokenType { get; public set; }
    public SecurityKeyIdentifierClause RequestedAttachedReference { get; public set; }
    public SecurityKeyIdentifierClause RequestedUnattachedReference { get; public set; }
    public DateTime ValidFrom { get; private set; }
    public DateTime ValidTo { get; }
    public bool ComputeKey { get; public set; }
    public int KeySize { get; public set; }
    public bool IsRequestedTokenClosed { get; public set; }
    public bool IsReadOnly { get; }
    protected object ThisLock { get; }
    internal bool IsReceiver { get; }
    internal SecurityStandardsManager StandardsManager { get; internal set; }
    public SecurityToken EntropyToken { get; }
    public SecurityToken RequestedSecurityToken { get; public set; }
    public SecurityToken RequestedProofToken { get; public set; }
    public XmlElement RequestSecurityTokenResponseXml { get; }
    internal object AppliesTo { get; }
    internal XmlObjectSerializer AppliesToSerializer { get; }
    internal Type AppliesToType { get; }
    internal bool IsLifetimeSet { get; }
    internal XmlBuffer IssuedTokenBuffer { get; }
    public RequestSecurityTokenResponse(MessageSecurityVersion messageSecurityVersion, SecurityTokenSerializer securityTokenSerializer);
    public RequestSecurityTokenResponse(XmlElement requestSecurityTokenResponseXml, string context, string tokenType, int keySize, SecurityKeyIdentifierClause requestedAttachedReference, SecurityKeyIdentifierClause requestedUnattachedReference, bool computeKey, DateTime validFrom, DateTime validTo, bool isRequestedTokenClosed);
    public RequestSecurityTokenResponse(MessageSecurityVersion messageSecurityVersion, SecurityTokenSerializer securityTokenSerializer, XmlElement requestSecurityTokenResponseXml, string context, string tokenType, int keySize, SecurityKeyIdentifierClause requestedAttachedReference, SecurityKeyIdentifierClause requestedUnattachedReference, bool computeKey, DateTime validFrom, DateTime validTo, bool isRequestedTokenClosed);
    internal RequestSecurityTokenResponse(SecurityStandardsManager standardsManager);
    internal RequestSecurityTokenResponse(SecurityStandardsManager standardsManager, XmlElement rstrXml, string context, string tokenType, int keySize, SecurityKeyIdentifierClause requestedAttachedReference, SecurityKeyIdentifierClause requestedUnattachedReference, bool computeKey, DateTime validFrom, DateTime validTo, bool isRequestedTokenClosed, XmlBuffer issuedTokenBuffer);
    private static RequestSecurityTokenResponse();
    public string get_Context();
    public void set_Context(string value);
    public string get_TokenType();
    public void set_TokenType(string value);
    public SecurityKeyIdentifierClause get_RequestedAttachedReference();
    public void set_RequestedAttachedReference(SecurityKeyIdentifierClause value);
    public SecurityKeyIdentifierClause get_RequestedUnattachedReference();
    public void set_RequestedUnattachedReference(SecurityKeyIdentifierClause value);
    [CompilerGeneratedAttribute]
public DateTime get_ValidFrom();
    [CompilerGeneratedAttribute]
private void set_ValidFrom(DateTime value);
    public DateTime get_ValidTo();
    public bool get_ComputeKey();
    public void set_ComputeKey(bool value);
    public int get_KeySize();
    public void set_KeySize(int value);
    public bool get_IsRequestedTokenClosed();
    public void set_IsRequestedTokenClosed(bool value);
    public bool get_IsReadOnly();
    [CompilerGeneratedAttribute]
protected object get_ThisLock();
    [CompilerGeneratedAttribute]
internal bool get_IsReceiver();
    internal SecurityStandardsManager get_StandardsManager();
    internal void set_StandardsManager(SecurityStandardsManager value);
    public SecurityToken get_EntropyToken();
    public SecurityToken get_RequestedSecurityToken();
    public void set_RequestedSecurityToken(SecurityToken value);
    public SecurityToken get_RequestedProofToken();
    public void set_RequestedProofToken(SecurityToken value);
    public XmlElement get_RequestSecurityTokenResponseXml();
    internal object get_AppliesTo();
    internal XmlObjectSerializer get_AppliesToSerializer();
    internal Type get_AppliesToType();
    internal bool get_IsLifetimeSet();
    internal XmlBuffer get_IssuedTokenBuffer();
    public SecurityToken GetIssuerEntropy();
    internal SecurityToken GetIssuerEntropy(SecurityTokenResolver resolver);
    public void SetLifetime(DateTime validFrom, DateTime validTo);
    public void SetAppliesTo(T appliesTo, XmlObjectSerializer serializer);
    public void GetAppliesToQName(String& localName, String& namespaceUri);
    public T GetAppliesTo();
    public T GetAppliesTo(XmlObjectSerializer serializer);
    internal BinaryNegotiation GetBinaryNegotiation();
    internal Byte[] GetAuthenticator();
    private void OnWriteTo(XmlWriter w);
    public void WriteTo(XmlWriter writer);
    public static RequestSecurityTokenResponse CreateFrom(XmlReader reader);
    public static RequestSecurityTokenResponse CreateFrom(XmlReader reader, MessageSecurityVersion messageSecurityVersion, SecurityTokenSerializer securityTokenSerializer);
    internal static RequestSecurityTokenResponse CreateFrom(SecurityStandardsManager standardsManager, XmlReader reader);
    protected virtual void OnWriteBodyContents(XmlDictionaryWriter writer);
    public void MakeReadOnly();
    public virtual GenericXmlSecurityToken GetIssuedToken(SecurityTokenResolver resolver, IList`1<SecurityTokenAuthenticator> allowedAuthenticators, SecurityKeyEntropyMode keyEntropyMode, Byte[] requestorEntropy, string expectedTokenType, ReadOnlyCollection`1<IAuthorizationPolicy> authorizationPolicies, int defaultKeySize, bool isBearerKeyType);
    protected internal virtual void OnWriteCustomAttributes(XmlWriter writer);
    protected internal virtual void OnWriteCustomElements(XmlWriter writer);
    protected virtual void OnMakeReadOnly();
    public static Byte[] ComputeCombinedKey(Byte[] requestorEntropy, Byte[] issuerEntropy, int keySizeInBits);
}
internal class System.ServiceModel.Security.RequestSecurityTokenResponseCollection : BodyWriter {
    private SecurityStandardsManager _standardsManager;
    [CompilerGeneratedAttribute]
private IEnumerable`1<RequestSecurityTokenResponse> <RstrCollection>k__BackingField;
    public IEnumerable`1<RequestSecurityTokenResponse> RstrCollection { get; }
    public RequestSecurityTokenResponseCollection(IEnumerable`1<RequestSecurityTokenResponse> rstrCollection);
    public RequestSecurityTokenResponseCollection(IEnumerable`1<RequestSecurityTokenResponse> rstrCollection, SecurityStandardsManager standardsManager);
    [CompilerGeneratedAttribute]
public IEnumerable`1<RequestSecurityTokenResponse> get_RstrCollection();
    public void WriteTo(XmlWriter writer);
    protected virtual void OnWriteBodyContents(XmlDictionaryWriter writer);
}
public class System.ServiceModel.Security.ScopedMessagePartSpecification : object {
    private Dictionary`2<string, MessagePartSpecification> _actionParts;
    private Dictionary`2<string, MessagePartSpecification> _readOnlyNormalizedActionParts;
    [CompilerGeneratedAttribute]
private MessagePartSpecification <ChannelParts>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsReadOnly>k__BackingField;
    public ICollection`1<string> Actions { get; }
    public MessagePartSpecification ChannelParts { get; }
    public bool IsReadOnly { get; private set; }
    public ScopedMessagePartSpecification(ScopedMessagePartSpecification other);
    internal ScopedMessagePartSpecification(ScopedMessagePartSpecification other, bool newIncludeBody);
    public ICollection`1<string> get_Actions();
    [CompilerGeneratedAttribute]
public MessagePartSpecification get_ChannelParts();
    [CompilerGeneratedAttribute]
public bool get_IsReadOnly();
    [CompilerGeneratedAttribute]
private void set_IsReadOnly(bool value);
    public void AddParts(MessagePartSpecification parts);
    public void AddParts(MessagePartSpecification parts, string action);
    internal void AddParts(MessagePartSpecification parts, XmlDictionaryString action);
    internal bool IsEmpty();
    public bool TryGetParts(string action, bool excludeChannelScope, MessagePartSpecification& parts);
    internal void CopyTo(ScopedMessagePartSpecification target);
    public bool TryGetParts(string action, MessagePartSpecification& parts);
    public void MakeReadOnly();
    private void ThrowIfReadOnly();
}
internal class System.ServiceModel.Security.SctClaimDictionary : XmlDictionary {
    [CompilerGeneratedAttribute]
private static SctClaimDictionary <Instance>k__BackingField;
    [CompilerGeneratedAttribute]
private XmlDictionaryString <Claim>k__BackingField;
    [CompilerGeneratedAttribute]
private XmlDictionaryString <ClaimSets>k__BackingField;
    [CompilerGeneratedAttribute]
private XmlDictionaryString <ClaimSet>k__BackingField;
    [CompilerGeneratedAttribute]
private XmlDictionaryString <PrimaryIssuer>k__BackingField;
    [CompilerGeneratedAttribute]
private XmlDictionaryString <Identities>k__BackingField;
    [CompilerGeneratedAttribute]
private XmlDictionaryString <PrimaryIdentity>k__BackingField;
    [CompilerGeneratedAttribute]
private XmlDictionaryString <X509CertificateClaimSet>k__BackingField;
    [CompilerGeneratedAttribute]
private XmlDictionaryString <SystemClaimSet>k__BackingField;
    [CompilerGeneratedAttribute]
private XmlDictionaryString <WindowsClaimSet>k__BackingField;
    [CompilerGeneratedAttribute]
private XmlDictionaryString <AnonymousClaimSet>k__BackingField;
    [CompilerGeneratedAttribute]
private XmlDictionaryString <ContextId>k__BackingField;
    [CompilerGeneratedAttribute]
private XmlDictionaryString <BinaryClaim>k__BackingField;
    [CompilerGeneratedAttribute]
private XmlDictionaryString <DnsClaim>k__BackingField;
    [CompilerGeneratedAttribute]
private XmlDictionaryString <GenericIdentity>k__BackingField;
    [CompilerGeneratedAttribute]
private XmlDictionaryString <AuthenticationType>k__BackingField;
    [CompilerGeneratedAttribute]
private XmlDictionaryString <Right>k__BackingField;
    [CompilerGeneratedAttribute]
private XmlDictionaryString <HashClaim>k__BackingField;
    [CompilerGeneratedAttribute]
private XmlDictionaryString <MailAddressClaim>k__BackingField;
    [CompilerGeneratedAttribute]
private XmlDictionaryString <NameClaim>k__BackingField;
    [CompilerGeneratedAttribute]
private XmlDictionaryString <RsaClaim>k__BackingField;
    [CompilerGeneratedAttribute]
private XmlDictionaryString <SpnClaim>k__BackingField;
    [CompilerGeneratedAttribute]
private XmlDictionaryString <SystemClaim>k__BackingField;
    [CompilerGeneratedAttribute]
private XmlDictionaryString <UpnClaim>k__BackingField;
    [CompilerGeneratedAttribute]
private XmlDictionaryString <UrlClaim>k__BackingField;
    [CompilerGeneratedAttribute]
private XmlDictionaryString <WindowsSidClaim>k__BackingField;
    [CompilerGeneratedAttribute]
private XmlDictionaryString <DenyOnlySidClaim>k__BackingField;
    [CompilerGeneratedAttribute]
private XmlDictionaryString <WindowsSidIdentity>k__BackingField;
    [CompilerGeneratedAttribute]
private XmlDictionaryString <X500DistinguishedNameClaim>k__BackingField;
    [CompilerGeneratedAttribute]
private XmlDictionaryString <X509ThumbprintClaim>k__BackingField;
    [CompilerGeneratedAttribute]
private XmlDictionaryString <EffectiveTime>k__BackingField;
    [CompilerGeneratedAttribute]
private XmlDictionaryString <ExpiryTime>k__BackingField;
    [CompilerGeneratedAttribute]
private XmlDictionaryString <Id>k__BackingField;
    [CompilerGeneratedAttribute]
private XmlDictionaryString <IsCookieMode>k__BackingField;
    [CompilerGeneratedAttribute]
private XmlDictionaryString <Key>k__BackingField;
    [CompilerGeneratedAttribute]
private XmlDictionaryString <Sid>k__BackingField;
    [CompilerGeneratedAttribute]
private XmlDictionaryString <Name>k__BackingField;
    [CompilerGeneratedAttribute]
private XmlDictionaryString <NullValue>k__BackingField;
    [CompilerGeneratedAttribute]
private XmlDictionaryString <SecurityContextSecurityToken>k__BackingField;
    [CompilerGeneratedAttribute]
private XmlDictionaryString <ServiceContractId>k__BackingField;
    [CompilerGeneratedAttribute]
private XmlDictionaryString <Value>k__BackingField;
    [CompilerGeneratedAttribute]
private XmlDictionaryString <Version>k__BackingField;
    [CompilerGeneratedAttribute]
private XmlDictionaryString <GenericXmlSecurityToken>k__BackingField;
    [CompilerGeneratedAttribute]
private XmlDictionaryString <TokenType>k__BackingField;
    [CompilerGeneratedAttribute]
private XmlDictionaryString <TokenXml>k__BackingField;
    [CompilerGeneratedAttribute]
private XmlDictionaryString <InternalTokenReference>k__BackingField;
    [CompilerGeneratedAttribute]
private XmlDictionaryString <ExternalTokenReference>k__BackingField;
    [CompilerGeneratedAttribute]
private XmlDictionaryString <EmptyString>k__BackingField;
    [CompilerGeneratedAttribute]
private XmlDictionaryString <KeyGeneration>k__BackingField;
    [CompilerGeneratedAttribute]
private XmlDictionaryString <KeyEffectiveTime>k__BackingField;
    [CompilerGeneratedAttribute]
private XmlDictionaryString <KeyExpiryTime>k__BackingField;
    public static SctClaimDictionary Instance { get; }
    public XmlDictionaryString Claim { get; }
    public XmlDictionaryString ClaimSets { get; }
    public XmlDictionaryString ClaimSet { get; }
    public XmlDictionaryString PrimaryIssuer { get; }
    public XmlDictionaryString Identities { get; }
    public XmlDictionaryString PrimaryIdentity { get; }
    public XmlDictionaryString X509CertificateClaimSet { get; }
    public XmlDictionaryString SystemClaimSet { get; }
    public XmlDictionaryString WindowsClaimSet { get; }
    public XmlDictionaryString AnonymousClaimSet { get; }
    public XmlDictionaryString ContextId { get; }
    public XmlDictionaryString BinaryClaim { get; }
    public XmlDictionaryString DnsClaim { get; }
    public XmlDictionaryString GenericIdentity { get; }
    public XmlDictionaryString AuthenticationType { get; }
    public XmlDictionaryString Right { get; }
    public XmlDictionaryString HashClaim { get; }
    public XmlDictionaryString MailAddressClaim { get; }
    public XmlDictionaryString NameClaim { get; }
    public XmlDictionaryString RsaClaim { get; }
    public XmlDictionaryString SpnClaim { get; }
    public XmlDictionaryString SystemClaim { get; }
    public XmlDictionaryString UpnClaim { get; }
    public XmlDictionaryString UrlClaim { get; }
    public XmlDictionaryString WindowsSidClaim { get; }
    public XmlDictionaryString DenyOnlySidClaim { get; }
    public XmlDictionaryString WindowsSidIdentity { get; }
    public XmlDictionaryString X500DistinguishedNameClaim { get; }
    public XmlDictionaryString X509ThumbprintClaim { get; }
    public XmlDictionaryString EffectiveTime { get; }
    public XmlDictionaryString ExpiryTime { get; }
    public XmlDictionaryString Id { get; }
    public XmlDictionaryString IsCookieMode { get; }
    public XmlDictionaryString Key { get; }
    public XmlDictionaryString Sid { get; }
    public XmlDictionaryString Name { get; }
    public XmlDictionaryString NullValue { get; }
    public XmlDictionaryString SecurityContextSecurityToken { get; }
    public XmlDictionaryString ServiceContractId { get; }
    public XmlDictionaryString Value { get; }
    public XmlDictionaryString Version { get; }
    public XmlDictionaryString GenericXmlSecurityToken { get; }
    public XmlDictionaryString TokenType { get; }
    public XmlDictionaryString TokenXml { get; }
    public XmlDictionaryString InternalTokenReference { get; }
    public XmlDictionaryString ExternalTokenReference { get; }
    public XmlDictionaryString EmptyString { get; }
    public XmlDictionaryString KeyGeneration { get; }
    public XmlDictionaryString KeyEffectiveTime { get; }
    public XmlDictionaryString KeyExpiryTime { get; }
    private static SctClaimDictionary();
    [CompilerGeneratedAttribute]
public static SctClaimDictionary get_Instance();
    [CompilerGeneratedAttribute]
public XmlDictionaryString get_Claim();
    [CompilerGeneratedAttribute]
public XmlDictionaryString get_ClaimSets();
    [CompilerGeneratedAttribute]
public XmlDictionaryString get_ClaimSet();
    [CompilerGeneratedAttribute]
public XmlDictionaryString get_PrimaryIssuer();
    [CompilerGeneratedAttribute]
public XmlDictionaryString get_Identities();
    [CompilerGeneratedAttribute]
public XmlDictionaryString get_PrimaryIdentity();
    [CompilerGeneratedAttribute]
public XmlDictionaryString get_X509CertificateClaimSet();
    [CompilerGeneratedAttribute]
public XmlDictionaryString get_SystemClaimSet();
    [CompilerGeneratedAttribute]
public XmlDictionaryString get_WindowsClaimSet();
    [CompilerGeneratedAttribute]
public XmlDictionaryString get_AnonymousClaimSet();
    [CompilerGeneratedAttribute]
public XmlDictionaryString get_ContextId();
    [CompilerGeneratedAttribute]
public XmlDictionaryString get_BinaryClaim();
    [CompilerGeneratedAttribute]
public XmlDictionaryString get_DnsClaim();
    [CompilerGeneratedAttribute]
public XmlDictionaryString get_GenericIdentity();
    [CompilerGeneratedAttribute]
public XmlDictionaryString get_AuthenticationType();
    [CompilerGeneratedAttribute]
public XmlDictionaryString get_Right();
    [CompilerGeneratedAttribute]
public XmlDictionaryString get_HashClaim();
    [CompilerGeneratedAttribute]
public XmlDictionaryString get_MailAddressClaim();
    [CompilerGeneratedAttribute]
public XmlDictionaryString get_NameClaim();
    [CompilerGeneratedAttribute]
public XmlDictionaryString get_RsaClaim();
    [CompilerGeneratedAttribute]
public XmlDictionaryString get_SpnClaim();
    [CompilerGeneratedAttribute]
public XmlDictionaryString get_SystemClaim();
    [CompilerGeneratedAttribute]
public XmlDictionaryString get_UpnClaim();
    [CompilerGeneratedAttribute]
public XmlDictionaryString get_UrlClaim();
    [CompilerGeneratedAttribute]
public XmlDictionaryString get_WindowsSidClaim();
    [CompilerGeneratedAttribute]
public XmlDictionaryString get_DenyOnlySidClaim();
    [CompilerGeneratedAttribute]
public XmlDictionaryString get_WindowsSidIdentity();
    [CompilerGeneratedAttribute]
public XmlDictionaryString get_X500DistinguishedNameClaim();
    [CompilerGeneratedAttribute]
public XmlDictionaryString get_X509ThumbprintClaim();
    [CompilerGeneratedAttribute]
public XmlDictionaryString get_EffectiveTime();
    [CompilerGeneratedAttribute]
public XmlDictionaryString get_ExpiryTime();
    [CompilerGeneratedAttribute]
public XmlDictionaryString get_Id();
    [CompilerGeneratedAttribute]
public XmlDictionaryString get_IsCookieMode();
    [CompilerGeneratedAttribute]
public XmlDictionaryString get_Key();
    [CompilerGeneratedAttribute]
public XmlDictionaryString get_Sid();
    [CompilerGeneratedAttribute]
public XmlDictionaryString get_Name();
    [CompilerGeneratedAttribute]
public XmlDictionaryString get_NullValue();
    [CompilerGeneratedAttribute]
public XmlDictionaryString get_SecurityContextSecurityToken();
    [CompilerGeneratedAttribute]
public XmlDictionaryString get_ServiceContractId();
    [CompilerGeneratedAttribute]
public XmlDictionaryString get_Value();
    [CompilerGeneratedAttribute]
public XmlDictionaryString get_Version();
    [CompilerGeneratedAttribute]
public XmlDictionaryString get_GenericXmlSecurityToken();
    [CompilerGeneratedAttribute]
public XmlDictionaryString get_TokenType();
    [CompilerGeneratedAttribute]
public XmlDictionaryString get_TokenXml();
    [CompilerGeneratedAttribute]
public XmlDictionaryString get_InternalTokenReference();
    [CompilerGeneratedAttribute]
public XmlDictionaryString get_ExternalTokenReference();
    [CompilerGeneratedAttribute]
public XmlDictionaryString get_EmptyString();
    [CompilerGeneratedAttribute]
public XmlDictionaryString get_KeyGeneration();
    [CompilerGeneratedAttribute]
public XmlDictionaryString get_KeyEffectiveTime();
    [CompilerGeneratedAttribute]
public XmlDictionaryString get_KeyExpiryTime();
}
internal abstract class System.ServiceModel.Security.SecureConversationDriver : object {
    public XmlDictionaryString CloseAction { get; }
    public XmlDictionaryString CloseResponseAction { get; }
    public bool IsSessionSupported { get; }
    public XmlDictionaryString IssueAction { get; }
    public XmlDictionaryString IssueResponseAction { get; }
    public XmlDictionaryString RenewAction { get; }
    public XmlDictionaryString RenewResponseAction { get; }
    public XmlDictionaryString Namespace { get; }
    public XmlDictionaryString RenewNeededFaultCode { get; }
    public XmlDictionaryString BadContextTokenFaultCode { get; }
    public string TokenTypeUri { get; }
    public virtual XmlDictionaryString get_CloseAction();
    public virtual XmlDictionaryString get_CloseResponseAction();
    public virtual bool get_IsSessionSupported();
    public abstract virtual XmlDictionaryString get_IssueAction();
    public abstract virtual XmlDictionaryString get_IssueResponseAction();
    public virtual XmlDictionaryString get_RenewAction();
    public virtual XmlDictionaryString get_RenewResponseAction();
    public abstract virtual XmlDictionaryString get_Namespace();
    public abstract virtual XmlDictionaryString get_RenewNeededFaultCode();
    public abstract virtual XmlDictionaryString get_BadContextTokenFaultCode();
    public abstract virtual string get_TokenTypeUri();
    public abstract virtual UniqueId GetSecurityContextTokenId(XmlDictionaryReader reader);
    public abstract virtual bool IsAtSecurityContextToken(XmlDictionaryReader reader);
}
public abstract class System.ServiceModel.Security.SecureConversationVersion : object {
    private XmlDictionaryString _prefix;
    [CompilerGeneratedAttribute]
private XmlDictionaryString <Namespace>k__BackingField;
    public XmlDictionaryString Namespace { get; }
    public XmlDictionaryString Prefix { get; }
    public static SecureConversationVersion Default { get; }
    public static SecureConversationVersion WSSecureConversationFeb2005 { get; }
    public static SecureConversationVersion WSSecureConversation13 { get; }
    internal SecureConversationVersion(XmlDictionaryString ns, XmlDictionaryString prefix);
    [CompilerGeneratedAttribute]
public XmlDictionaryString get_Namespace();
    public XmlDictionaryString get_Prefix();
    public static SecureConversationVersion get_Default();
    public static SecureConversationVersion get_WSSecureConversationFeb2005();
    public static SecureConversationVersion get_WSSecureConversation13();
}
public class System.ServiceModel.Security.SecurityAccessDeniedException : CommunicationException {
    public SecurityAccessDeniedException(string message);
    public SecurityAccessDeniedException(string message, Exception innerException);
    protected SecurityAccessDeniedException(SerializationInfo info, StreamingContext context);
}
public abstract class System.ServiceModel.Security.SecurityAlgorithmSuite : object {
    private static SecurityAlgorithmSuite s_basic256;
    private static SecurityAlgorithmSuite s_tripleDes;
    private static SecurityAlgorithmSuite s_basic256Sha256;
    public static SecurityAlgorithmSuite Default { get; }
    public static SecurityAlgorithmSuite Basic256 { get; }
    public static SecurityAlgorithmSuite TripleDes { get; }
    public static SecurityAlgorithmSuite Basic256Sha256 { get; }
    public string DefaultCanonicalizationAlgorithm { get; }
    public string DefaultDigestAlgorithm { get; }
    public string DefaultEncryptionAlgorithm { get; }
    public int DefaultEncryptionKeyDerivationLength { get; }
    public string DefaultSymmetricKeyWrapAlgorithm { get; }
    public string DefaultAsymmetricKeyWrapAlgorithm { get; }
    public string DefaultSymmetricSignatureAlgorithm { get; }
    public string DefaultAsymmetricSignatureAlgorithm { get; }
    public int DefaultSignatureKeyDerivationLength { get; }
    public int DefaultSymmetricKeyLength { get; }
    internal XmlDictionaryString DefaultCanonicalizationAlgorithmDictionaryString { get; }
    internal XmlDictionaryString DefaultDigestAlgorithmDictionaryString { get; }
    internal XmlDictionaryString DefaultEncryptionAlgorithmDictionaryString { get; }
    internal XmlDictionaryString DefaultSymmetricKeyWrapAlgorithmDictionaryString { get; }
    internal XmlDictionaryString DefaultAsymmetricKeyWrapAlgorithmDictionaryString { get; }
    internal XmlDictionaryString DefaultSymmetricSignatureAlgorithmDictionaryString { get; }
    internal XmlDictionaryString DefaultAsymmetricSignatureAlgorithmDictionaryString { get; }
    public static SecurityAlgorithmSuite get_Default();
    public static SecurityAlgorithmSuite get_Basic256();
    public static SecurityAlgorithmSuite get_TripleDes();
    public static SecurityAlgorithmSuite get_Basic256Sha256();
    public abstract virtual string get_DefaultCanonicalizationAlgorithm();
    public abstract virtual string get_DefaultDigestAlgorithm();
    public abstract virtual string get_DefaultEncryptionAlgorithm();
    public abstract virtual int get_DefaultEncryptionKeyDerivationLength();
    public abstract virtual string get_DefaultSymmetricKeyWrapAlgorithm();
    public abstract virtual string get_DefaultAsymmetricKeyWrapAlgorithm();
    public abstract virtual string get_DefaultSymmetricSignatureAlgorithm();
    public abstract virtual string get_DefaultAsymmetricSignatureAlgorithm();
    public abstract virtual int get_DefaultSignatureKeyDerivationLength();
    public abstract virtual int get_DefaultSymmetricKeyLength();
    internal virtual XmlDictionaryString get_DefaultCanonicalizationAlgorithmDictionaryString();
    internal virtual XmlDictionaryString get_DefaultDigestAlgorithmDictionaryString();
    internal virtual XmlDictionaryString get_DefaultEncryptionAlgorithmDictionaryString();
    internal virtual XmlDictionaryString get_DefaultSymmetricKeyWrapAlgorithmDictionaryString();
    internal virtual XmlDictionaryString get_DefaultAsymmetricKeyWrapAlgorithmDictionaryString();
    internal virtual XmlDictionaryString get_DefaultSymmetricSignatureAlgorithmDictionaryString();
    internal virtual XmlDictionaryString get_DefaultAsymmetricSignatureAlgorithmDictionaryString();
    public virtual bool IsCanonicalizationAlgorithmSupported(string algorithm);
    public virtual bool IsDigestAlgorithmSupported(string algorithm);
    public virtual bool IsEncryptionAlgorithmSupported(string algorithm);
    public virtual bool IsEncryptionKeyDerivationAlgorithmSupported(string algorithm);
    public virtual bool IsSymmetricKeyWrapAlgorithmSupported(string algorithm);
    public virtual bool IsAsymmetricKeyWrapAlgorithmSupported(string algorithm);
    public virtual bool IsSymmetricSignatureAlgorithmSupported(string algorithm);
    public virtual bool IsAsymmetricSignatureAlgorithmSupported(string algorithm);
    public virtual bool IsSignatureKeyDerivationAlgorithmSupported(string algorithm);
    public abstract virtual bool IsSymmetricKeyLengthSupported(int length);
    public abstract virtual bool IsAsymmetricKeyLengthSupported(int length);
    internal void GetSignatureAlgorithmAndKey(SecurityToken token, String& signatureAlgorithm, SecurityKey& key, XmlDictionaryString& signatureAlgorithmDictionaryString);
}
internal class System.ServiceModel.Security.SecurityAppliedMessage : DelegatingMessage {
    private bool _bodyIdInserted;
    private string _bodyPrefix;
    private XmlBuffer _fullBodyBuffer;
    private XmlAttributeHolder[] _bodyAttributes;
    private bool _delayedApplicationHandled;
    private BodyState _state;
    private SendSecurityHeader _securityHeader;
    private MemoryStream _startBodyFragment;
    private MemoryStream _endBodyFragment;
    private Byte[] _fullBodyFragment;
    private int _fullBodyFragmentLength;
    [CompilerGeneratedAttribute]
private string <BodyId>k__BackingField;
    [CompilerGeneratedAttribute]
private MessagePartProtectionMode <BodyProtectionMode>k__BackingField;
    public string BodyId { get; private set; }
    public MessagePartProtectionMode BodyProtectionMode { get; }
    public SecurityAppliedMessage(Message messageToProcess, SendSecurityHeader securityHeader, bool signBody, bool encryptBody);
    [CompilerGeneratedAttribute]
public string get_BodyId();
    [CompilerGeneratedAttribute]
private void set_BodyId(string value);
    [CompilerGeneratedAttribute]
public MessagePartProtectionMode get_BodyProtectionMode();
    private Exception CreateBadStateException(string operation);
    private void EnsureUniqueSecurityApplication();
    protected virtual void OnBodyToString(XmlDictionaryWriter writer);
    protected virtual void OnClose();
    protected virtual void OnWriteStartBody(XmlDictionaryWriter writer);
    protected virtual void OnWriteBodyContents(XmlDictionaryWriter writer);
    [AsyncStateMachineAttribute("System.ServiceModel.Security.SecurityAppliedMessage/<OnWriteBodyContentsAsync>d__25")]
protected virtual Task OnWriteBodyContentsAsync(XmlDictionaryWriter writer);
    protected virtual void OnWriteMessage(XmlDictionaryWriter writer);
    [AsyncStateMachineAttribute("System.ServiceModel.Security.SecurityAppliedMessage/<OnWriteMessageAsync>d__27")]
public virtual Task OnWriteMessageAsync(XmlDictionaryWriter writer);
    private void AttachChannelBindingTokenIfFound();
    private void SetBodyId();
    public void WriteBodyToSign(Stream canonicalStream);
    public void WriteBodyToSignWithFragments(Stream stream, bool includeComments, String[] inclusivePrefixes, XmlDictionaryWriter writer);
    private void WriteInnerMessageWithId(XmlDictionaryWriter writer);
    private void WriteStartInnerMessageWithId(XmlDictionaryWriter writer);
}
internal static class System.ServiceModel.Security.SecurityAuditHelper : object {
    public static bool IsSecurityAuditSupported { get; }
    public static bool get_IsSecurityAuditSupported();
}
internal abstract class System.ServiceModel.Security.SecurityChannel`1 : LayeredChannel`1<TChannel> {
    private SecurityProtocol _securityProtocol;
    public SecurityProtocol SecurityProtocol { get; protected set; }
    protected SecurityChannel`1(ChannelManagerBase channelManager, TChannel innerChannel);
    protected SecurityChannel`1(ChannelManagerBase channelManager, TChannel innerChannel, SecurityProtocol securityProtocol);
    public virtual T GetProperty();
    public SecurityProtocol get_SecurityProtocol();
    protected void set_SecurityProtocol(SecurityProtocol value);
    protected virtual void OnAbort();
    [AsyncStateMachineAttribute("System.ServiceModel.Security.SecurityChannel`1/<OnCloseAsync>d__8")]
protected internal virtual Task OnCloseAsync(TimeSpan timeout);
    protected void ThrowIfDisposedOrNotOpen(Message message);
    [CompilerGeneratedAttribute]
[DebuggerHiddenAttribute]
private Task <>n__0(TimeSpan timeout);
}
[TypeForwardedFromAttribute("System.ServiceModel, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089")]
public class System.ServiceModel.Security.SecurityContextKeyIdentifierClause : SecurityKeyIdentifierClause {
    private UniqueId _generation;
    [CompilerGeneratedAttribute]
private UniqueId <ContextId>k__BackingField;
    public UniqueId ContextId { get; }
    public UniqueId Generation { get; }
    public SecurityContextKeyIdentifierClause(UniqueId contextId);
    public SecurityContextKeyIdentifierClause(UniqueId contextId, UniqueId generation);
    public SecurityContextKeyIdentifierClause(UniqueId contextId, UniqueId generation, Byte[] derivationNonce, int derivationLength);
    [CompilerGeneratedAttribute]
public UniqueId get_ContextId();
    public UniqueId get_Generation();
    public virtual bool Matches(SecurityKeyIdentifierClause keyIdentifierClause);
    public bool Matches(UniqueId contextId, UniqueId generation);
    public virtual string ToString();
}
public abstract class System.ServiceModel.Security.SecurityCredentialsManager : object {
    public abstract virtual SecurityTokenManager CreateSecurityTokenManager();
}
internal abstract class System.ServiceModel.Security.SecurityHeader : MessageHeader {
    private string _actor;
    private bool _encryptedKeyContainsReferenceList;
    private bool _mustUnderstand;
    private bool _relay;
    private bool _requireMessageProtection;
    private bool _processingStarted;
    private bool _maintainSignatureConfirmationState;
    private SecurityHeaderLayout _layout;
    [CompilerGeneratedAttribute]
private SecurityAlgorithmSuite <AlgorithmSuite>k__BackingField;
    [CompilerGeneratedAttribute]
private Message <Message>k__BackingField;
    [CompilerGeneratedAttribute]
private SecurityStandardsManager <StandardsManager>k__BackingField;
    [CompilerGeneratedAttribute]
private MessageDirection <MessageDirection>k__BackingField;
    public string Actor { get; }
    public SecurityAlgorithmSuite AlgorithmSuite { get; }
    public bool EncryptedKeyContainsReferenceList { get; public set; }
    public bool RequireMessageProtection { get; public set; }
    public bool MaintainSignatureConfirmationState { get; public set; }
    protected Message Message { get; protected set; }
    public bool MustUnderstand { get; }
    public bool Relay { get; }
    public SecurityHeaderLayout Layout { get; public set; }
    public SecurityStandardsManager StandardsManager { get; }
    public MessageDirection MessageDirection { get; }
    protected MessageVersion Version { get; }
    public SecurityHeader(Message message, string actor, bool mustUnderstand, bool relay, SecurityStandardsManager standardsManager, SecurityAlgorithmSuite algorithmSuite, MessageDirection transferDirection);
    public virtual string get_Actor();
    [CompilerGeneratedAttribute]
public SecurityAlgorithmSuite get_AlgorithmSuite();
    public bool get_EncryptedKeyContainsReferenceList();
    public void set_EncryptedKeyContainsReferenceList(bool value);
    public bool get_RequireMessageProtection();
    public void set_RequireMessageProtection(bool value);
    public bool get_MaintainSignatureConfirmationState();
    public void set_MaintainSignatureConfirmationState(bool value);
    [CompilerGeneratedAttribute]
protected Message get_Message();
    [CompilerGeneratedAttribute]
protected void set_Message(Message value);
    public virtual bool get_MustUnderstand();
    public virtual bool get_Relay();
    public SecurityHeaderLayout get_Layout();
    public void set_Layout(SecurityHeaderLayout value);
    [CompilerGeneratedAttribute]
public SecurityStandardsManager get_StandardsManager();
    [CompilerGeneratedAttribute]
public MessageDirection get_MessageDirection();
    protected MessageVersion get_Version();
    protected void SetProcessingStarted();
    protected void ThrowIfProcessingStarted();
    public virtual string ToString();
}
internal abstract class System.ServiceModel.Security.SecurityHeaderElementInferenceEngine : object {
    public abstract virtual void ExecuteProcessingPasses(ReceiveSecurityHeader securityHeader, XmlDictionaryReader reader);
    public abstract virtual void MarkElements(ReceiveSecurityHeaderElementManager elementManager, bool messageSecurityMode);
    public static SecurityHeaderElementInferenceEngine GetInferenceEngine(SecurityHeaderLayout layout);
}
internal class System.ServiceModel.Security.SecurityHeaderTokenResolver : SecurityTokenResolver {
    private static int InitialTokenArraySize;
    private int _tokenCount;
    private SecurityTokenEntry[] _tokens;
    private ReceiveSecurityHeader _securityHeader;
    [CompilerGeneratedAttribute]
private SecurityToken <ExpectedWrapper>k__BackingField;
    [CompilerGeneratedAttribute]
private SecurityTokenParameters <ExpectedWrapperTokenParameters>k__BackingField;
    public SecurityToken ExpectedWrapper { get; public set; }
    public SecurityTokenParameters ExpectedWrapperTokenParameters { get; public set; }
    public SecurityHeaderTokenResolver(ReceiveSecurityHeader securityHeader);
    [CompilerGeneratedAttribute]
public sealed virtual SecurityToken get_ExpectedWrapper();
    [CompilerGeneratedAttribute]
public sealed virtual void set_ExpectedWrapper(SecurityToken value);
    [CompilerGeneratedAttribute]
public SecurityTokenParameters get_ExpectedWrapperTokenParameters();
    [CompilerGeneratedAttribute]
public void set_ExpectedWrapperTokenParameters(SecurityTokenParameters value);
    public void Add(SecurityToken token);
    public void Add(SecurityToken token, SecurityTokenReferenceStyle allowedReferenceStyle, SecurityTokenParameters tokenParameters);
    private void EnsureCapacityToAddToken();
    public sealed virtual bool CheckExternalWrapperMatch(SecurityKeyIdentifier keyIdentifier);
    internal SecurityToken ResolveToken(SecurityKeyIdentifier keyIdentifier, bool matchOnlyExternalTokens, bool resolveIntrinsicKeyClause);
    private SecurityKey ResolveSecurityKeyCore(SecurityKeyIdentifierClause keyIdentifierClause, bool createIntrinsicKeys);
    private bool MatchDirectReference(SecurityToken token, SecurityKeyIdentifierClause keyClause);
    internal SecurityToken ResolveToken(SecurityKeyIdentifierClause keyIdentifierClause, bool matchOnlyExternal, bool resolveIntrinsicKeyClause);
    public virtual string ToString();
    protected virtual bool TryResolveTokenCore(SecurityKeyIdentifier keyIdentifier, SecurityToken& token);
    internal bool TryResolveToken(SecurityKeyIdentifier keyIdentifier, bool matchOnlyExternalTokens, bool resolveIntrinsicKeyClause, SecurityToken& token);
    protected virtual bool TryResolveTokenCore(SecurityKeyIdentifierClause keyIdentifierClause, SecurityToken& token);
    internal bool TryResolveToken(SecurityKeyIdentifierClause keyIdentifierClause, bool matchOnlyExternalTokens, bool resolveIntrinsicKeyClause, SecurityToken& token);
    internal bool TryResolveSecurityKey(SecurityKeyIdentifierClause keyIdentifierClause, bool createIntrinsicKeys, SecurityKey& key);
    protected virtual bool TryResolveSecurityKeyCore(SecurityKeyIdentifierClause keyIdentifierClause, SecurityKey& key);
}
public enum System.ServiceModel.Security.SecurityKeyEntropyMode : Enum {
    public int value__;
    public static SecurityKeyEntropyMode ClientEntropy;
    public static SecurityKeyEntropyMode ServerEntropy;
    public static SecurityKeyEntropyMode CombinedEntropy;
}
internal class System.ServiceModel.Security.SecurityKeyEntropyModeHelper : object {
    internal static bool IsDefined(SecurityKeyEntropyMode value);
    internal static void Validate(SecurityKeyEntropyMode value);
}
public class System.ServiceModel.Security.SecurityMessageProperty : object {
    private Collection`1<SupportingTokenSpecification> _outgoingSupportingTokens;
    private Collection`1<SupportingTokenSpecification> _incomingSupportingTokens;
    private SecurityTokenSpecification _transportToken;
    private SecurityTokenSpecification _protectionToken;
    private SecurityTokenSpecification _initiatorToken;
    private SecurityTokenSpecification _recipientToken;
    private ServiceSecurityContext _securityContext;
    private string _senderIdPrefix;
    private bool _disposed;
    [CompilerGeneratedAttribute]
private ReadOnlyCollection`1<IAuthorizationPolicy> <ExternalAuthorizationPolicies>k__BackingField;
    public ServiceSecurityContext ServiceSecurityContext { get; public set; }
    public ReadOnlyCollection`1<IAuthorizationPolicy> ExternalAuthorizationPolicies { get; public set; }
    public SecurityTokenSpecification ProtectionToken { get; public set; }
    public SecurityTokenSpecification InitiatorToken { get; public set; }
    public SecurityTokenSpecification RecipientToken { get; public set; }
    public SecurityTokenSpecification TransportToken { get; public set; }
    public string SenderIdPrefix { get; public set; }
    public bool HasIncomingSupportingTokens { get; }
    public Collection`1<SupportingTokenSpecification> IncomingSupportingTokens { get; }
    public Collection`1<SupportingTokenSpecification> OutgoingSupportingTokens { get; }
    internal bool HasOutgoingSupportingTokens { get; }
    public ServiceSecurityContext get_ServiceSecurityContext();
    public void set_ServiceSecurityContext(ServiceSecurityContext value);
    [CompilerGeneratedAttribute]
public ReadOnlyCollection`1<IAuthorizationPolicy> get_ExternalAuthorizationPolicies();
    [CompilerGeneratedAttribute]
public void set_ExternalAuthorizationPolicies(ReadOnlyCollection`1<IAuthorizationPolicy> value);
    public SecurityTokenSpecification get_ProtectionToken();
    public void set_ProtectionToken(SecurityTokenSpecification value);
    public SecurityTokenSpecification get_InitiatorToken();
    public void set_InitiatorToken(SecurityTokenSpecification value);
    public SecurityTokenSpecification get_RecipientToken();
    public void set_RecipientToken(SecurityTokenSpecification value);
    public SecurityTokenSpecification get_TransportToken();
    public void set_TransportToken(SecurityTokenSpecification value);
    public string get_SenderIdPrefix();
    public void set_SenderIdPrefix(string value);
    public bool get_HasIncomingSupportingTokens();
    public Collection`1<SupportingTokenSpecification> get_IncomingSupportingTokens();
    public Collection`1<SupportingTokenSpecification> get_OutgoingSupportingTokens();
    internal bool get_HasOutgoingSupportingTokens();
    public sealed virtual IMessageProperty CreateCopy();
    public static SecurityMessageProperty GetOrCreate(Message message);
    private void AddAuthorizationPolicies(SecurityTokenSpecification spec, Collection`1<IAuthorizationPolicy> policies);
    internal ReadOnlyCollection`1<IAuthorizationPolicy> GetInitiatorTokenAuthorizationPolicies();
    internal ReadOnlyCollection`1<IAuthorizationPolicy> GetInitiatorTokenAuthorizationPolicies(bool includeTransportToken);
    internal ReadOnlyCollection`1<IAuthorizationPolicy> GetInitiatorTokenAuthorizationPolicies(bool includeTransportToken, SecurityContextSecurityToken supportingSessionTokenToExclude);
    public sealed virtual void Dispose();
    private void ThrowIfDisposed();
}
public class System.ServiceModel.Security.SecurityNegotiationException : CommunicationException {
    public SecurityNegotiationException(string message);
    public SecurityNegotiationException(string message, Exception innerException);
    protected SecurityNegotiationException(SerializationInfo info, StreamingContext context);
}
internal static class System.ServiceModel.Security.SecurityPolicyStrings : object {
    public static string SecureConversationBootstrapBindingElementsBelowSecurityKey;
}
public abstract class System.ServiceModel.Security.SecurityPolicyVersion : object {
    private string _prefix;
    [CompilerGeneratedAttribute]
private string <Namespace>k__BackingField;
    public string Namespace { get; }
    public string Prefix { get; }
    public static SecurityPolicyVersion WSSecurityPolicy11 { get; }
    public static SecurityPolicyVersion WSSecurityPolicy12 { get; }
    internal SecurityPolicyVersion(string ns, string prefix);
    [CompilerGeneratedAttribute]
public string get_Namespace();
    public string get_Prefix();
    public static SecurityPolicyVersion get_WSSecurityPolicy11();
    public static SecurityPolicyVersion get_WSSecurityPolicy12();
}
internal abstract class System.ServiceModel.Security.SecurityProtocol : object {
    private static ReadOnlyCollection`1<SupportingTokenProviderSpecification> s_emptyTokenProviders;
    private Dictionary`2<string, Collection`1<SupportingTokenProviderSpecification>> _mergedSupportingTokenProvidersMap;
    private ChannelParameterCollection _channelParameters;
    [CompilerGeneratedAttribute]
private WrapperSecurityCommunicationObject <CommunicationObject>k__BackingField;
    [CompilerGeneratedAttribute]
private SecurityProtocolFactory <SecurityProtocolFactory>k__BackingField;
    [CompilerGeneratedAttribute]
private EndpointAddress <Target>k__BackingField;
    [CompilerGeneratedAttribute]
private Uri <Via>k__BackingField;
    [CompilerGeneratedAttribute]
private ICollection`1<SupportingTokenProviderSpecification> <ChannelSupportingTokenProviderSpecification>k__BackingField;
    [CompilerGeneratedAttribute]
private Dictionary`2<string, ICollection`1<SupportingTokenProviderSpecification>> <ScopedSupportingTokenProviderSpecification>k__BackingField;
    protected WrapperSecurityCommunicationObject CommunicationObject { get; }
    public SecurityProtocolFactory SecurityProtocolFactory { get; }
    public EndpointAddress Target { get; }
    public Uri Via { get; }
    public ICollection`1<SupportingTokenProviderSpecification> ChannelSupportingTokenProviderSpecification { get; private set; }
    public Dictionary`2<string, ICollection`1<SupportingTokenProviderSpecification>> ScopedSupportingTokenProviderSpecification { get; private set; }
    private static ReadOnlyCollection`1<SupportingTokenProviderSpecification> EmptyTokenProviders { get; }
    public ChannelParameterCollection ChannelParameters { get; public set; }
    public TimeSpan DefaultOpenTimeout { get; }
    public TimeSpan DefaultCloseTimeout { get; }
    protected SecurityProtocol(SecurityProtocolFactory factory, EndpointAddress target, Uri via);
    [CompilerGeneratedAttribute]
protected WrapperSecurityCommunicationObject get_CommunicationObject();
    [CompilerGeneratedAttribute]
public SecurityProtocolFactory get_SecurityProtocolFactory();
    [CompilerGeneratedAttribute]
public EndpointAddress get_Target();
    [CompilerGeneratedAttribute]
public Uri get_Via();
    [CompilerGeneratedAttribute]
public ICollection`1<SupportingTokenProviderSpecification> get_ChannelSupportingTokenProviderSpecification();
    [CompilerGeneratedAttribute]
private void set_ChannelSupportingTokenProviderSpecification(ICollection`1<SupportingTokenProviderSpecification> value);
    [CompilerGeneratedAttribute]
public Dictionary`2<string, ICollection`1<SupportingTokenProviderSpecification>> get_ScopedSupportingTokenProviderSpecification();
    [CompilerGeneratedAttribute]
private void set_ScopedSupportingTokenProviderSpecification(Dictionary`2<string, ICollection`1<SupportingTokenProviderSpecification>> value);
    private static ReadOnlyCollection`1<SupportingTokenProviderSpecification> get_EmptyTokenProviders();
    public ChannelParameterCollection get_ChannelParameters();
    public void set_ChannelParameters(ChannelParameterCollection value);
    public sealed virtual TimeSpan get_DefaultOpenTimeout();
    public sealed virtual TimeSpan get_DefaultCloseTimeout();
    public sealed virtual void OnClosed();
    public sealed virtual void OnClosing();
    public sealed virtual void OnFaulted();
    public sealed virtual void OnOpened();
    public sealed virtual void OnOpening();
    internal IList`1<SupportingTokenProviderSpecification> GetSupportingTokenProviders(string action);
    protected InitiatorServiceModelSecurityTokenRequirement CreateInitiatorSecurityTokenRequirement();
    private InitiatorServiceModelSecurityTokenRequirement CreateInitiatorSecurityTokenRequirement(SecurityTokenParameters parameters, SecurityTokenAttachmentMode attachmentMode);
    private void AddSupportingTokenProviders(SupportingTokenParameters supportingTokenParameters, bool isOptional, IList`1<SupportingTokenProviderSpecification> providerSpecList);
    [AsyncStateMachineAttribute("System.ServiceModel.Security.SecurityProtocol/<MergeSupportingTokenProvidersAsync>d__42")]
private Task MergeSupportingTokenProvidersAsync(TimeSpan timeout);
    public Task OpenAsync(TimeSpan timeout);
    [AsyncStateMachineAttribute("System.ServiceModel.Security.SecurityProtocol/<OnOpenAsync>d__44")]
public virtual Task OnOpenAsync(TimeSpan timeout);
    public Task CloseAsync(bool aborted, TimeSpan timeout);
    public virtual void OnAbort();
    [AsyncStateMachineAttribute("System.ServiceModel.Security.SecurityProtocol/<OnCloseAsync>d__47")]
public virtual Task OnCloseAsync(TimeSpan timeout);
    private static void SetSecurityHeaderId(SendSecurityHeader securityHeader, Message message);
    private void AddSupportingTokenSpecification(SecurityMessageProperty security, IList`1<SecurityToken> tokens, SecurityTokenAttachmentMode attachmentMode, IDictionary`2<SecurityToken, ReadOnlyCollection`1<IAuthorizationPolicy>> tokenPoliciesMapping);
    protected void AddSupportingTokenSpecification(SecurityMessageProperty security, IList`1<SecurityToken> basicTokens, IList`1<SecurityToken> endorsingTokens, IList`1<SecurityToken> signedEndorsingTokens, IList`1<SecurityToken> signedTokens, IDictionary`2<SecurityToken, ReadOnlyCollection`1<IAuthorizationPolicy>> tokenPoliciesMapping);
    protected SendSecurityHeader CreateSendSecurityHeader(Message message, string actor, SecurityProtocolFactory factory);
    protected SendSecurityHeader CreateSendSecurityHeaderForTransportProtocol(Message message, string actor, SecurityProtocolFactory factory);
    private SendSecurityHeader CreateSendSecurityHeader(Message message, string actor, SecurityProtocolFactory factory, bool requireMessageProtection);
    internal void AddMessageSupportingTokens(Message message, IList`1& supportingTokens);
    [AsyncStateMachineAttribute("System.ServiceModel.Security.SecurityProtocol/<TryGetSupportingTokensAsync>d__55")]
internal Task`1<IList`1<SupportingTokenSpecification>> TryGetSupportingTokensAsync(SecurityProtocolFactory factory, EndpointAddress target, Uri via, Message message, TimeSpan timeout);
    protected ReadOnlyCollection`1<SecurityTokenResolver> MergeOutOfBandResolvers(IList`1<SupportingTokenAuthenticatorSpecification> supportingAuthenticators, ReadOnlyCollection`1<SecurityTokenResolver> primaryResolvers);
    protected void AddSupportingTokens(SendSecurityHeader securityHeader, IList`1<SupportingTokenSpecification> supportingTokens);
    [AsyncStateMachineAttribute("System.ServiceModel.Security.SecurityProtocol/<GetTokenAsync>d__58")]
internal static Task`1<SecurityToken> GetTokenAsync(SecurityTokenProvider provider, EndpointAddress target, TimeSpan timeout);
    public abstract virtual Task`1<Message> SecureOutgoingMessageAsync(Message message, TimeSpan timeout);
    [AsyncStateMachineAttribute("System.ServiceModel.Security.SecurityProtocol/<SecureOutgoingMessageAsync>d__60")]
public virtual Task`1<ValueTuple`2<SecurityProtocolCorrelationState, Message>> SecureOutgoingMessageAsync(Message message, TimeSpan timeout, SecurityProtocolCorrelationState correlationState);
    protected virtual void OnOutgoingMessageSecured(Message securedMessage);
    protected virtual void OnSecureOutgoingMessageFailure(Message message);
    public abstract virtual void VerifyIncomingMessage(Message& message, TimeSpan timeout);
    public virtual SecurityProtocolCorrelationState VerifyIncomingMessage(Message& message, TimeSpan timeout, SecurityProtocolCorrelationState[] correlationStates);
    protected virtual void OnIncomingMessageVerified(Message verifiedMessage);
    protected virtual void OnVerifyIncomingMessageFailure(Message message, Exception exception);
}
internal class System.ServiceModel.Security.SecurityProtocolCorrelationState : object {
    [CompilerGeneratedAttribute]
private SecurityToken <Token>k__BackingField;
    [CompilerGeneratedAttribute]
private SignatureConfirmations <SignatureConfirmations>k__BackingField;
    [CompilerGeneratedAttribute]
private ServiceModelActivity <Activity>k__BackingField;
    public SecurityToken Token { get; }
    internal SignatureConfirmations SignatureConfirmations { get; internal set; }
    internal ServiceModelActivity Activity { get; }
    public SecurityProtocolCorrelationState(SecurityToken token);
    [CompilerGeneratedAttribute]
public SecurityToken get_Token();
    [CompilerGeneratedAttribute]
internal SignatureConfirmations get_SignatureConfirmations();
    [CompilerGeneratedAttribute]
internal void set_SignatureConfirmations(SignatureConfirmations value);
    [CompilerGeneratedAttribute]
internal ServiceModelActivity get_Activity();
}
internal abstract class System.ServiceModel.Security.SecurityProtocolFactory : object {
    internal static bool defaultAddTimestamp;
    internal static bool defaultDeriveKeys;
    internal static bool defaultDetectReplays;
    internal static string defaultMaxClockSkewString;
    internal static string defaultReplayWindowString;
    internal static TimeSpan defaultMaxClockSkew;
    internal static TimeSpan defaultReplayWindow;
    internal static int defaultMaxCachedNonces;
    internal static string defaultTimestampValidityDurationString;
    internal static TimeSpan defaultTimestampValidityDuration;
    internal static SecurityHeaderLayout defaultSecurityHeaderLayout;
    private static ReadOnlyCollection`1<SupportingTokenAuthenticatorSpecification> s_emptyTokenAuthenticators;
    private bool _addTimestamp;
    private bool _detectReplays;
    private bool _expectIncomingMessages;
    private bool _expectOutgoingMessages;
    private SecurityAlgorithmSuite _incomingAlgorithmSuite;
    private ICollection`1<SupportingTokenAuthenticatorSpecification> _channelSupportingTokenAuthenticatorSpecification;
    private int _maxCachedNonces;
    private TimeSpan _maxClockSkew;
    private NonceCache _nonceCache;
    private SecurityAlgorithmSuite _outgoingAlgorithmSuite;
    private TimeSpan _replayWindow;
    private SecurityStandardsManager _standardsManager;
    private SecurityTokenManager _securityTokenManager;
    private SecurityBindingElement _securityBindingElement;
    private string _requestReplyErrorPropertyName;
    private TimeSpan _timestampValidityDuration;
    private SecurityHeaderLayout _securityHeaderLayout;
    private bool _expectChannelBasicTokens;
    private bool _expectChannelSignedTokens;
    private bool _expectChannelEndorsingTokens;
    private BufferManager _streamBufferManager;
    [CompilerGeneratedAttribute]
private WrapperSecurityCommunicationObject <CommunicationObject>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <ActAsInitiator>k__BackingField;
    [CompilerGeneratedAttribute]
private ExtendedProtectionPolicy <ExtendedProtectionPolicy>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <ExpectKeyDerivation>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <ExpectSupportingTokens>k__BackingField;
    [CompilerGeneratedAttribute]
private MessageSecurityVersion <MessageSecurityVersion>k__BackingField;
    protected WrapperSecurityCommunicationObject CommunicationObject { get; }
    public bool ActAsInitiator { get; private set; }
    public BufferManager StreamBufferManager { get; public set; }
    public ExtendedProtectionPolicy ExtendedProtectionPolicy { get; public set; }
    public bool AddTimestamp { get; public set; }
    public bool DetectReplays { get; public set; }
    private static ReadOnlyCollection`1<SupportingTokenAuthenticatorSpecification> EmptyTokenAuthenticators { get; }
    internal bool ExpectKeyDerivation { get; internal set; }
    internal bool ExpectSupportingTokens { get; internal set; }
    public SecurityAlgorithmSuite IncomingAlgorithmSuite { get; public set; }
    public int MaxCachedNonces { get; public set; }
    public TimeSpan MaxClockSkew { get; public set; }
    public NonceCache NonceCache { get; public set; }
    public SecurityAlgorithmSuite OutgoingAlgorithmSuite { get; public set; }
    public TimeSpan ReplayWindow { get; public set; }
    public SecurityBindingElement SecurityBindingElement { get; public set; }
    public SecurityTokenManager SecurityTokenManager { get; public set; }
    public bool SupportsDuplex { get; }
    public SecurityHeaderLayout SecurityHeaderLayout { get; public set; }
    public bool SupportsReplayDetection { get; }
    public bool SupportsRequestReply { get; }
    public SecurityStandardsManager StandardsManager { get; public set; }
    public TimeSpan TimestampValidityDuration { get; public set; }
    internal MessageSecurityVersion MessageSecurityVersion { get; private set; }
    public TimeSpan DefaultOpenTimeout { get; }
    public TimeSpan DefaultCloseTimeout { get; }
    internal SecurityProtocolFactory(SecurityProtocolFactory factory);
    private static SecurityProtocolFactory();
    [CompilerGeneratedAttribute]
protected WrapperSecurityCommunicationObject get_CommunicationObject();
    [CompilerGeneratedAttribute]
public bool get_ActAsInitiator();
    [CompilerGeneratedAttribute]
private void set_ActAsInitiator(bool value);
    public BufferManager get_StreamBufferManager();
    public void set_StreamBufferManager(BufferManager value);
    [CompilerGeneratedAttribute]
public ExtendedProtectionPolicy get_ExtendedProtectionPolicy();
    [CompilerGeneratedAttribute]
public void set_ExtendedProtectionPolicy(ExtendedProtectionPolicy value);
    public bool get_AddTimestamp();
    public void set_AddTimestamp(bool value);
    public bool get_DetectReplays();
    public void set_DetectReplays(bool value);
    private static ReadOnlyCollection`1<SupportingTokenAuthenticatorSpecification> get_EmptyTokenAuthenticators();
    [CompilerGeneratedAttribute]
internal bool get_ExpectKeyDerivation();
    [CompilerGeneratedAttribute]
internal void set_ExpectKeyDerivation(bool value);
    [CompilerGeneratedAttribute]
internal bool get_ExpectSupportingTokens();
    [CompilerGeneratedAttribute]
internal void set_ExpectSupportingTokens(bool value);
    public SecurityAlgorithmSuite get_IncomingAlgorithmSuite();
    public void set_IncomingAlgorithmSuite(SecurityAlgorithmSuite value);
    public int get_MaxCachedNonces();
    public void set_MaxCachedNonces(int value);
    public TimeSpan get_MaxClockSkew();
    public void set_MaxClockSkew(TimeSpan value);
    public NonceCache get_NonceCache();
    public void set_NonceCache(NonceCache value);
    public SecurityAlgorithmSuite get_OutgoingAlgorithmSuite();
    public void set_OutgoingAlgorithmSuite(SecurityAlgorithmSuite value);
    public TimeSpan get_ReplayWindow();
    public void set_ReplayWindow(TimeSpan value);
    public SecurityBindingElement get_SecurityBindingElement();
    public void set_SecurityBindingElement(SecurityBindingElement value);
    public SecurityTokenManager get_SecurityTokenManager();
    public void set_SecurityTokenManager(SecurityTokenManager value);
    public virtual bool get_SupportsDuplex();
    public SecurityHeaderLayout get_SecurityHeaderLayout();
    public void set_SecurityHeaderLayout(SecurityHeaderLayout value);
    public virtual bool get_SupportsReplayDetection();
    public virtual bool get_SupportsRequestReply();
    public SecurityStandardsManager get_StandardsManager();
    public void set_StandardsManager(SecurityStandardsManager value);
    public TimeSpan get_TimestampValidityDuration();
    public void set_TimestampValidityDuration(TimeSpan value);
    [CompilerGeneratedAttribute]
internal MessageSecurityVersion get_MessageSecurityVersion();
    [CompilerGeneratedAttribute]
private void set_MessageSecurityVersion(MessageSecurityVersion value);
    public sealed virtual TimeSpan get_DefaultOpenTimeout();
    public sealed virtual TimeSpan get_DefaultCloseTimeout();
    public sealed virtual void OnClosed();
    public sealed virtual void OnClosing();
    public sealed virtual void OnFaulted();
    public sealed virtual void OnOpened();
    public sealed virtual void OnOpening();
    public virtual void OnAbort();
    public virtual Task OnCloseAsync(TimeSpan timeout);
    public SecurityProtocol CreateSecurityProtocol(EndpointAddress target, Uri via, object listenerSecurityState, bool isReturnLegSecurityRequired, TimeSpan timeout);
    public virtual T GetProperty();
    protected abstract virtual SecurityProtocol OnCreateSecurityProtocol(EndpointAddress target, Uri via, object listenerSecurityState, TimeSpan timeout);
    internal IList`1<SupportingTokenAuthenticatorSpecification> GetSupportingTokenAuthenticators(string action, Boolean& expectSignedTokens, Boolean& expectBasicTokens, Boolean& expectEndorsingTokens);
    public virtual Task OnOpenAsync(TimeSpan timeout);
    public Task OpenAsync(bool actAsInitiator, TimeSpan timeout);
    public Task CloseAsync(bool aborted, TimeSpan timeout);
    internal void OnPropertySettingsError(string propertyName, bool requiredForForwardDirection);
    internal void ThrowIfImmutable();
    private void ThrowIfNotOpen();
}
internal static class System.ServiceModel.Security.SecuritySessionClientSettings : object {
    internal static string DefaultKeyRenewalIntervalString;
    internal static string DefaultKeyRolloverIntervalString;
    internal static TimeSpan s_defaultKeyRenewalInterval;
    internal static TimeSpan s_defaultKeyRolloverInterval;
    internal static bool DefaultTolerateTransportFailures;
    private static SecuritySessionClientSettings();
}
internal class System.ServiceModel.Security.SecuritySessionClientSettings`1 : object {
    private SecurityProtocolFactory _sessionProtocolFactory;
    private TimeSpan _keyRenewalInterval;
    private TimeSpan _keyRolloverInterval;
    private bool _tolerateTransportFailures;
    private WrapperSecurityCommunicationObject _communicationObject;
    private SecurityStandardsManager _standardsManager;
    private SecurityTokenParameters _issuedTokenParameters;
    private int _issuedTokenRenewalThreshold;
    private object _thisLock;
    [CompilerGeneratedAttribute]
private IChannelFactory <InnerChannelFactory>k__BackingField;
    [CompilerGeneratedAttribute]
private ChannelBuilder <ChannelBuilder>k__BackingField;
    [CompilerGeneratedAttribute]
private SecurityChannelFactory`1<TChannel> <SecurityChannelFactory>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <CanRenewSession>k__BackingField;
    private IChannelFactory InnerChannelFactory { get; private set; }
    internal ChannelBuilder ChannelBuilder { get; internal set; }
    private SecurityChannelFactory`1<TChannel> SecurityChannelFactory { get; private set; }
    public SecurityProtocolFactory SessionProtocolFactory { get; public set; }
    public TimeSpan KeyRenewalInterval { get; public set; }
    public TimeSpan KeyRolloverInterval { get; public set; }
    public bool TolerateTransportFailures { get; public set; }
    public bool CanRenewSession { get; public set; }
    public SecurityTokenParameters IssuedSecurityTokenParameters { get; public set; }
    public SecurityStandardsManager SecurityStandardsManager { get; public set; }
    public TimeSpan DefaultOpenTimeout { get; }
    public TimeSpan DefaultCloseTimeout { get; }
    [CompilerGeneratedAttribute]
private IChannelFactory get_InnerChannelFactory();
    [CompilerGeneratedAttribute]
private void set_InnerChannelFactory(IChannelFactory value);
    [CompilerGeneratedAttribute]
internal ChannelBuilder get_ChannelBuilder();
    [CompilerGeneratedAttribute]
internal void set_ChannelBuilder(ChannelBuilder value);
    [CompilerGeneratedAttribute]
private SecurityChannelFactory`1<TChannel> get_SecurityChannelFactory();
    [CompilerGeneratedAttribute]
private void set_SecurityChannelFactory(SecurityChannelFactory`1<TChannel> value);
    public SecurityProtocolFactory get_SessionProtocolFactory();
    public void set_SessionProtocolFactory(SecurityProtocolFactory value);
    public sealed virtual TimeSpan get_KeyRenewalInterval();
    public sealed virtual void set_KeyRenewalInterval(TimeSpan value);
    public sealed virtual TimeSpan get_KeyRolloverInterval();
    public sealed virtual void set_KeyRolloverInterval(TimeSpan value);
    public sealed virtual bool get_TolerateTransportFailures();
    public sealed virtual void set_TolerateTransportFailures(bool value);
    [CompilerGeneratedAttribute]
public bool get_CanRenewSession();
    [CompilerGeneratedAttribute]
public void set_CanRenewSession(bool value);
    public SecurityTokenParameters get_IssuedSecurityTokenParameters();
    public void set_IssuedSecurityTokenParameters(SecurityTokenParameters value);
    public SecurityStandardsManager get_SecurityStandardsManager();
    public void set_SecurityStandardsManager(SecurityStandardsManager value);
    public sealed virtual TimeSpan get_DefaultOpenTimeout();
    public sealed virtual TimeSpan get_DefaultCloseTimeout();
    internal IChannelFactory CreateInnerChannelFactory();
    public sealed virtual void OnClosed();
    public sealed virtual void OnClosing();
    public sealed virtual void OnFaulted();
    public sealed virtual void OnOpened();
    public sealed virtual void OnOpening();
    public sealed virtual Task OnCloseAsync(TimeSpan timeout);
    public sealed virtual void OnAbort();
    public sealed virtual Task OnOpenAsync(TimeSpan timeout);
    internal Task CloseAsync(TimeSpan timeout);
    internal void Abort();
    internal Task OpenAsync(SecurityChannelFactory`1<TChannel> securityChannelFactory, IChannelFactory innerChannelFactory, ChannelBuilder channelBuilder, TimeSpan timeout);
    internal TChannel OnCreateChannel(EndpointAddress remoteAddress, Uri via);
    private void ConfigureSessionProtocolFactory();
}
internal enum System.ServiceModel.Security.SecuritySessionOperation : Enum {
    public int value__;
    public static SecuritySessionOperation None;
    public static SecuritySessionOperation Issue;
    public static SecuritySessionOperation Renew;
    public static SecuritySessionOperation Close;
}
internal class System.ServiceModel.Security.SecuritySessionSecurityTokenAuthenticator : object {
}
internal class System.ServiceModel.Security.SecuritySessionSecurityTokenProvider : CommunicationObjectSecurityTokenProvider {
    private static MessageOperationFormatter s_operationFormatter;
    private BindingContext _issuerBindingContext;
    private SecurityChannelFactory`1<IAsyncRequestChannel> _rstChannelFactory;
    private SecurityAlgorithmSuite _securityAlgorithmSuite;
    private SecurityStandardsManager _standardsManager;
    private object _thisLock;
    private SecurityKeyEntropyMode _keyEntropyMode;
    private SecurityTokenParameters _issuedTokenParameters;
    private bool _requiresManualReplyAddressing;
    private EndpointAddress _targetAddress;
    private SecurityBindingElement _bootstrapSecurityBindingElement;
    private Uri _via;
    private string _sctUri;
    private Uri _privacyNoticeUri;
    private int _privacyNoticeVersion;
    private EndpointAddress _localAddress;
    private ChannelParameterCollection _channelParameters;
    [CompilerGeneratedAttribute]
private MessageVersion <MessageVersion>k__BackingField;
    public SecurityAlgorithmSuite SecurityAlgorithmSuite { get; public set; }
    public SecurityKeyEntropyMode KeyEntropyMode { get; public set; }
    private MessageVersion MessageVersion { get; private set; }
    public EndpointAddress TargetAddress { get; public set; }
    public EndpointAddress LocalAddress { get; public set; }
    public Uri Via { get; public set; }
    public BindingContext IssuerBindingContext { get; public set; }
    public SecurityBindingElement BootstrapSecurityBindingElement { get; public set; }
    public SecurityStandardsManager StandardsManager { get; public set; }
    public SecurityTokenParameters IssuedSecurityTokenParameters { get; public set; }
    public Uri PrivacyNoticeUri { get; public set; }
    public ChannelParameterCollection ChannelParameters { get; public set; }
    public int PrivacyNoticeVersion { get; public set; }
    public XmlDictionaryString IssueAction { get; }
    public XmlDictionaryString IssueResponseAction { get; }
    public XmlDictionaryString RenewAction { get; }
    public XmlDictionaryString RenewResponseAction { get; }
    public XmlDictionaryString CloseAction { get; }
    public XmlDictionaryString CloseResponseAction { get; }
    private static SecuritySessionSecurityTokenProvider();
    public SecurityAlgorithmSuite get_SecurityAlgorithmSuite();
    public void set_SecurityAlgorithmSuite(SecurityAlgorithmSuite value);
    public SecurityKeyEntropyMode get_KeyEntropyMode();
    public void set_KeyEntropyMode(SecurityKeyEntropyMode value);
    [CompilerGeneratedAttribute]
private MessageVersion get_MessageVersion();
    [CompilerGeneratedAttribute]
private void set_MessageVersion(MessageVersion value);
    public EndpointAddress get_TargetAddress();
    public void set_TargetAddress(EndpointAddress value);
    public EndpointAddress get_LocalAddress();
    public void set_LocalAddress(EndpointAddress value);
    public Uri get_Via();
    public void set_Via(Uri value);
    public BindingContext get_IssuerBindingContext();
    public void set_IssuerBindingContext(BindingContext value);
    public SecurityBindingElement get_BootstrapSecurityBindingElement();
    public void set_BootstrapSecurityBindingElement(SecurityBindingElement value);
    public SecurityStandardsManager get_StandardsManager();
    public void set_StandardsManager(SecurityStandardsManager value);
    public SecurityTokenParameters get_IssuedSecurityTokenParameters();
    public void set_IssuedSecurityTokenParameters(SecurityTokenParameters value);
    public Uri get_PrivacyNoticeUri();
    public void set_PrivacyNoticeUri(Uri value);
    public ChannelParameterCollection get_ChannelParameters();
    public void set_ChannelParameters(ChannelParameterCollection value);
    public int get_PrivacyNoticeVersion();
    public void set_PrivacyNoticeVersion(int value);
    public virtual XmlDictionaryString get_IssueAction();
    public virtual XmlDictionaryString get_IssueResponseAction();
    public virtual XmlDictionaryString get_RenewAction();
    public virtual XmlDictionaryString get_RenewResponseAction();
    public virtual XmlDictionaryString get_CloseAction();
    public virtual XmlDictionaryString get_CloseResponseAction();
    public virtual void OnAbort();
    [AsyncStateMachineAttribute("System.ServiceModel.Security.SecuritySessionSecurityTokenProvider/<OnOpenAsync>d__71")]
public virtual Task OnOpenAsync(TimeSpan timeout);
    public virtual void OnOpening();
    [AsyncStateMachineAttribute("System.ServiceModel.Security.SecuritySessionSecurityTokenProvider/<OnCloseAsync>d__73")]
public virtual Task OnCloseAsync(TimeSpan timeout);
    private void FreeCredentialsHandle();
    private void InitializeFactories();
    protected virtual SecurityToken GetTokenCore(TimeSpan timeout);
    internal virtual Task`1<SecurityToken> GetTokenCoreInternalAsync(TimeSpan timeout);
    internal virtual Task`1<SecurityToken> RenewTokenCoreInternalAsync(TimeSpan timeout, SecurityToken tokenToBeRenewed);
    private IAsyncRequestChannel CreateChannel(SecuritySessionOperation operation, EndpointAddress target, Uri via);
    private Message CreateRequest(SecuritySessionOperation operation, EndpointAddress target, SecurityToken currentToken, Object& requestState);
    private GenericXmlSecurityToken ProcessReply(Message reply, SecuritySessionOperation operation, object requestState);
    private void OnOperationSuccess(SecuritySessionOperation operation, EndpointAddress target, SecurityToken issuedToken, SecurityToken currentToken);
    private void OnOperationFailure(SecuritySessionOperation operation, EndpointAddress target, SecurityToken currentToken, Exception e, IChannel channel);
    [AsyncStateMachineAttribute("System.ServiceModel.Security.SecuritySessionSecurityTokenProvider/<DoOperationAsync>d__84")]
private Task`1<SecurityToken> DoOperationAsync(SecuritySessionOperation operation, EndpointAddress target, Uri via, SecurityToken currentToken, TimeSpan timeout);
    private Byte[] GenerateEntropy(int entropySize);
    private RequestSecurityToken CreateRst(EndpointAddress target, Object& requestState);
    private void PrepareRequest(Message message);
    protected virtual Message CreateIssueRequest(EndpointAddress target, Object& requestState);
    private GenericXmlSecurityToken ExtractToken(Message response, object requestState);
    protected virtual GenericXmlSecurityToken ProcessIssueResponse(Message response, object requestState);
    protected virtual Message CreateRenewRequest(EndpointAddress target, SecurityToken currentSessionToken, Object& requestState);
    protected virtual GenericXmlSecurityToken ProcessRenewResponse(Message response, object requestState);
    protected static void ThrowIfFault(Message message, EndpointAddress target);
    protected void ValidateKeySize(GenericXmlSecurityToken issuedToken);
}
internal class System.ServiceModel.Security.SecurityStandardsManager : object {
    private static SecurityStandardsManager s_instance;
    private SecurityTokenSerializer _tokenSerializer;
    private WSSecurityTokenSerializer _wsSecurityTokenSerializer;
    [CompilerGeneratedAttribute]
private MessageSecurityVersion <MessageSecurityVersion>k__BackingField;
    [CompilerGeneratedAttribute]
private WSUtilitySpecificationVersion <WSUtilitySpecificationVersion>k__BackingField;
    [CompilerGeneratedAttribute]
private SignatureTargetIdManager <IdManager>k__BackingField;
    [CompilerGeneratedAttribute]
private SecureConversationDriver <SecureConversationDriver>k__BackingField;
    [CompilerGeneratedAttribute]
private TrustDriver <TrustDriver>k__BackingField;
    public static SecurityStandardsManager DefaultInstance { get; }
    public SecurityVersion SecurityVersion { get; }
    public MessageSecurityVersion MessageSecurityVersion { get; }
    internal SecurityTokenSerializer SecurityTokenSerializer { get; }
    internal WSUtilitySpecificationVersion WSUtilitySpecificationVersion { get; }
    internal SignatureTargetIdManager IdManager { get; }
    internal SecureConversationDriver SecureConversationDriver { get; }
    internal TrustDriver TrustDriver { get; }
    private WSSecurityTokenSerializer WSSecurityTokenSerializer { get; }
    public SecurityStandardsManager(SecurityTokenSerializer tokenSerializer);
    public SecurityStandardsManager(MessageSecurityVersion messageSecurityVersion, SecurityTokenSerializer tokenSerializer);
    public static SecurityStandardsManager get_DefaultInstance();
    public SecurityVersion get_SecurityVersion();
    [CompilerGeneratedAttribute]
public MessageSecurityVersion get_MessageSecurityVersion();
    internal SecurityTokenSerializer get_SecurityTokenSerializer();
    [CompilerGeneratedAttribute]
internal WSUtilitySpecificationVersion get_WSUtilitySpecificationVersion();
    [CompilerGeneratedAttribute]
internal SignatureTargetIdManager get_IdManager();
    [CompilerGeneratedAttribute]
internal SecureConversationDriver get_SecureConversationDriver();
    [CompilerGeneratedAttribute]
internal TrustDriver get_TrustDriver();
    private WSSecurityTokenSerializer get_WSSecurityTokenSerializer();
    internal bool TryCreateKeyIdentifierClauseFromTokenXml(XmlElement element, SecurityTokenReferenceStyle tokenReferenceStyle, SecurityKeyIdentifierClause& securityKeyIdentifierClause);
    internal SecurityKeyIdentifierClause CreateKeyIdentifierClauseFromTokenXml(XmlElement element, SecurityTokenReferenceStyle tokenReferenceStyle);
    internal SendSecurityHeader CreateSendSecurityHeader(Message message, string actor, bool mustUnderstand, bool relay, SecurityAlgorithmSuite algorithmSuite, MessageDirection direction);
    internal ReceiveSecurityHeader TryCreateReceiveSecurityHeader(Message message, string actor, SecurityAlgorithmSuite algorithmSuite, MessageDirection direction);
    internal bool DoesMessageContainSecurityHeader(Message message);
}
public abstract class System.ServiceModel.Security.SecurityStateEncoder : object {
    protected internal abstract virtual Byte[] DecodeSecurityState(Byte[] data);
    protected internal abstract virtual Byte[] EncodeSecurityState(Byte[] data);
}
internal class System.ServiceModel.Security.SecurityTimestamp : object {
    private static string DefaultFormat;
    internal static TimeSpan defaultTimeToLive;
    private Char[] _computedCreationTimeUtc;
    private Char[] _computedExpiryTimeUtc;
    private DateTime _creationTimeUtc;
    private DateTime _expiryTimeUtc;
    private string _digestAlgorithm;
    private Byte[] _digest;
    [CompilerGeneratedAttribute]
private string <Id>k__BackingField;
    public DateTime CreationTimeUtc { get; }
    public DateTime ExpiryTimeUtc { get; }
    public string Id { get; }
    public string DigestAlgorithm { get; }
    public SecurityTimestamp(DateTime creationTimeUtc, DateTime expiryTimeUtc, string id);
    internal SecurityTimestamp(DateTime creationTimeUtc, DateTime expiryTimeUtc, string id, string digestAlgorithm, Byte[] digest);
    private static SecurityTimestamp();
    public DateTime get_CreationTimeUtc();
    public DateTime get_ExpiryTimeUtc();
    [CompilerGeneratedAttribute]
public string get_Id();
    public string get_DigestAlgorithm();
    internal Byte[] GetDigest();
    internal Char[] GetCreationTimeChars();
    internal Char[] GetExpiryTimeChars();
    private static Char[] ToChars(DateTime& utcTime);
    private static void ToChars(int n, Char[] buffer, Int32& offset, int count);
    public virtual string ToString();
    internal void ValidateRangeAndFreshness(TimeSpan timeToLive, TimeSpan allowedClockSkew);
    internal void ValidateFreshness(TimeSpan timeToLive, TimeSpan allowedClockSkew);
}
public enum System.ServiceModel.Security.SecurityTokenAttachmentMode : Enum {
    public int value__;
    public static SecurityTokenAttachmentMode Signed;
    public static SecurityTokenAttachmentMode Endorsing;
    public static SecurityTokenAttachmentMode SignedEndorsing;
    public static SecurityTokenAttachmentMode SignedEncrypted;
}
internal static class System.ServiceModel.Security.SecurityTokenAttachmentModeHelper : object {
    internal static bool IsDefined(SecurityTokenAttachmentMode value);
    internal static void Validate(SecurityTokenAttachmentMode value);
    internal static void Categorize(SecurityTokenAttachmentMode value, Boolean& isBasic, Boolean& isSignedButNotBasic, ReceiveSecurityHeaderBindingModes& mode);
}
public class System.ServiceModel.Security.SecurityTokenSpecification : object {
    private ReadOnlyCollection`1<IAuthorizationPolicy> _tokenPolicies;
    [CompilerGeneratedAttribute]
private SecurityToken <SecurityToken>k__BackingField;
    public SecurityToken SecurityToken { get; }
    public ReadOnlyCollection`1<IAuthorizationPolicy> SecurityTokenPolicies { get; }
    public SecurityTokenSpecification(SecurityToken token, ReadOnlyCollection`1<IAuthorizationPolicy> tokenPolicies);
    [CompilerGeneratedAttribute]
public SecurityToken get_SecurityToken();
    public ReadOnlyCollection`1<IAuthorizationPolicy> get_SecurityTokenPolicies();
}
internal class System.ServiceModel.Security.SecurityUniqueId : ValueType {
    private static long s_nextId;
    private static string s_commonPrefix;
    private long _id;
    private string _prefix;
    private string _val;
    public string Value { get; }
    private SecurityUniqueId(string prefix, long id);
    private static SecurityUniqueId();
    public static SecurityUniqueId Create();
    public static SecurityUniqueId Create(string prefix);
    public string get_Value();
}
internal static class System.ServiceModel.Security.SecurityUtils : object {
    public static string Identities;
    public static string Principal;
    private static IIdentity s_anonymousIdentity;
    private static X509SecurityTokenAuthenticator s_nonValidatingX509Authenticator;
    internal static X509SecurityTokenAuthenticator NonValidatingX509Authenticator { get; }
    internal static IIdentity AnonymousIdentity { get; }
    public static DateTime MaxUtcDateTime { get; }
    public static DateTime MinUtcDateTime { get; }
    internal static bool IsChannelBindingDisabled { get; }
    internal static string GetSpnFromIdentity(EndpointIdentity identity, EndpointAddress target);
    internal static string GetSpnFromTarget(EndpointAddress target);
    public static ChannelBinding GetChannelBindingFromMessage(Message message);
    internal static X509SecurityTokenAuthenticator get_NonValidatingX509Authenticator();
    internal static IIdentity get_AnonymousIdentity();
    public static DateTime get_MaxUtcDateTime();
    public static DateTime get_MinUtcDateTime();
    internal static IIdentity CreateIdentity(string name);
    internal static T GetSecurityKey(SecurityToken token);
    internal static Byte[] GenerateDerivedKey(SecurityToken tokenToDerive, string derivationAlgorithm, Byte[] label, Byte[] nonce, int keySize, int offset);
    internal static bool IsEqual(Byte[] a, Byte[] b);
    internal static bool IsSupportedAlgorithm(string algorithm, SecurityToken token);
    internal static Claim GetPrimaryIdentityClaim(ReadOnlyCollection`1<IAuthorizationPolicy> authorizationPolicies);
    internal static Claim GetPrimaryIdentityClaim(AuthorizationContext authContext);
    internal static string GenerateId();
    internal static ReadOnlyCollection`1<IAuthorizationPolicy> CreatePrincipalNameAuthorizationPolicies(string principalName);
    internal static bool get_IsChannelBindingDisabled();
    internal static bool IsSecurityBindingSuitableForChannelBinding(TransportSecurityBindingElement securityBindingElement);
    internal static bool AreSecurityTokenParametersSuitableForChannelBinding(Collection`1<SecurityTokenParameters> tokenParameters);
    internal static Task OpenTokenProviderIfRequiredAsync(SecurityTokenProvider tokenProvider, TimeSpan timeout);
    internal static void CloseTokenProviderIfRequired(SecurityTokenProvider tokenProvider, TimeSpan timeout);
    internal static Task CloseTokenProviderIfRequiredAsync(SecurityTokenProvider tokenProvider, TimeSpan timeout);
    internal static void AbortTokenProviderIfRequired(SecurityTokenProvider tokenProvider);
    internal static void CloseTokenAuthenticatorIfRequired(SecurityTokenAuthenticator tokenAuthenticator, TimeSpan timeout);
    internal static void CloseTokenAuthenticatorIfRequired(SecurityTokenAuthenticator tokenAuthenticator, bool aborted, TimeSpan timeout);
    internal static void AbortTokenAuthenticatorIfRequired(SecurityTokenAuthenticator tokenAuthenticator);
    private static Task OpenCommunicationObjectAsync(IAsyncCommunicationObject obj, TimeSpan timeout);
    private static Task CloseCommunicationObjectAsync(IAsyncCommunicationObject obj, bool aborted, TimeSpan timeout);
    private static void CloseCommunicationObject(object obj, bool aborted, TimeSpan timeout);
    internal static SecurityStandardsManager CreateSecurityStandardsManager(MessageSecurityVersion securityVersion, SecurityTokenManager tokenManager);
    internal static SecurityStandardsManager CreateSecurityStandardsManager(SecurityTokenRequirement requirement, SecurityTokenManager tokenManager);
    internal static SecurityStandardsManager CreateSecurityStandardsManager(MessageSecurityVersion securityVersion, SecurityTokenSerializer securityTokenSerializer);
    internal static NetworkCredential GetNetworkCredentialsCopy(NetworkCredential networkCredential);
    internal static NetworkCredential GetNetworkCredentialOrDefault(NetworkCredential credential);
    public static bool TryCreateKeyFromIntrinsicKeyClause(SecurityKeyIdentifierClause keyIdentifierClause, SecurityTokenResolver resolver, SecurityKey& key);
    internal static string AppendWindowsAuthenticationInfo(string inputString, NetworkCredential credential, AuthenticationLevel authenticationLevel, TokenImpersonationLevel impersonationLevel);
    internal static SecurityToken CreateTokenFromEncryptedKeyClause(EncryptedKeyIdentifierClause keyClause, SecurityToken unwrappingToken);
    internal static Byte[] CloneBuffer(Byte[] buffer);
    internal static ReadOnlyCollection`1<SecurityKey> CreateSymmetricSecurityKeys(Byte[] key);
    internal static string GetKeyDerivationAlgorithm(SecureConversationVersion version);
    internal static X509Certificate2 GetCertificateFromStore(StoreName storeName, StoreLocation storeLocation, X509FindType findType, object findValue, EndpointAddress target);
    internal static bool TryGetCertificateFromStore(StoreName storeName, StoreLocation storeLocation, X509FindType findType, object findValue, EndpointAddress target, X509Certificate2& certificate);
    private static X509Certificate2 GetCertificateFromStoreCore(StoreName storeName, StoreLocation storeLocation, X509FindType findType, object findValue, EndpointAddress target, bool throwIfMultipleOrNoMatch);
    internal static Exception CreateCertificateLoadException(StoreName storeName, StoreLocation storeLocation, X509FindType findType, object findValue, EndpointAddress target, int certCount);
    public static SecurityBindingElement GetIssuerSecurityBindingElement(ServiceModelSecurityTokenRequirement requirement);
    internal static void FixNetworkCredential(NetworkCredential& credential);
    internal static void ThrowIfNegotiationFault(Message message, EndpointAddress target);
    internal static bool IsSecurityFault(MessageFault fault, SecurityStandardsManager standardsManager);
    internal static Exception CreateSecurityFaultException(MessageFault fault);
    public static bool TryCreateX509CertificateFromRawData(Byte[] rawData, X509Certificate2& certificate);
    internal static void ResetAllCertificates(X509Certificate2Collection certificates);
    internal static void ResetCertificate(X509Certificate2 certificate);
}
internal class System.ServiceModel.Security.SecurityVerifiedMessage : DelegatingMessage {
    private Byte[] _decryptedBuffer;
    private XmlDictionaryReader _cachedDecryptedBodyContentReader;
    private XmlAttributeHolder[] _envelopeAttributes;
    private XmlAttributeHolder[] _headerAttributes;
    private XmlAttributeHolder[] _bodyAttributes;
    private string _envelopePrefix;
    private bool _bodyDecrypted;
    private BodyState _state;
    private string _bodyPrefix;
    private bool _isDecryptedBodyStatusDetermined;
    private bool _isDecryptedBodyFault;
    private bool _isDecryptedBodyEmpty;
    private XmlDictionaryReader _cachedReaderAtSecurityHeader;
    private XmlBuffer _messageBuffer;
    private bool _canDelegateCreateBufferedCopyToInnerMessage;
    [CompilerGeneratedAttribute]
private ReceiveSecurityHeader <ReceivedSecurityHeader>k__BackingField;
    public bool IsEmpty { get; }
    public bool IsFault { get; }
    internal Byte[] PrimarySignatureValue { get; }
    internal ReceiveSecurityHeader ReceivedSecurityHeader { get; }
    public SecurityVerifiedMessage(Message messageToProcess, ReceiveSecurityHeader securityHeader);
    public virtual bool get_IsEmpty();
    public virtual bool get_IsFault();
    internal Byte[] get_PrimarySignatureValue();
    [CompilerGeneratedAttribute]
internal ReceiveSecurityHeader get_ReceivedSecurityHeader();
    private Exception CreateBadStateException(string operation);
    public XmlDictionaryReader CreateFullBodyReader();
    private XmlDictionaryReader CreateFullBodyReaderFromBufferedState();
    private XmlDictionaryReader CreateFullBodyReaderFromDecryptedState();
    private void EnsureDecryptedBodyStatusDetermined();
    public XmlAttributeHolder[] GetEnvelopeAttributes();
    public XmlAttributeHolder[] GetHeaderAttributes();
    private XmlDictionaryReader GetReaderAtEnvelope();
    public XmlDictionaryReader GetReaderAtFirstHeader();
    public XmlDictionaryReader GetReaderAtSecurityHeader();
    private void MoveToBody(XmlDictionaryReader reader);
    private void MoveToHeaderBlock(XmlDictionaryReader reader, bool captureAttributes);
    private void MoveToSecurityHeader(XmlDictionaryReader reader, int headerIndex, bool captureAttributes);
    protected virtual void OnBodyToString(XmlDictionaryWriter writer);
    protected virtual void OnClose();
    protected virtual XmlDictionaryReader OnGetReaderAtBodyContents();
    protected virtual MessageBuffer OnCreateBufferedCopy(int maxBufferSize);
    internal void OnMessageProtectionPassComplete(bool atLeastOneHeaderOrBodyEncrypted);
    protected virtual void OnWriteStartBody(XmlDictionaryWriter writer);
    protected virtual void OnWriteBodyContents(XmlDictionaryWriter writer);
    public void SetBodyPrefixAndAttributes(XmlDictionaryReader bodyReader);
    public void SetDecryptedBody(Byte[] decryptedBodyContent);
}
public abstract class System.ServiceModel.Security.SecurityVersion : object {
    private XmlDictionaryString _headerPrefix;
    [CompilerGeneratedAttribute]
private XmlDictionaryString <HeaderName>k__BackingField;
    [CompilerGeneratedAttribute]
private XmlDictionaryString <HeaderNamespace>k__BackingField;
    internal XmlDictionaryString HeaderName { get; }
    internal XmlDictionaryString HeaderNamespace { get; }
    internal XmlDictionaryString HeaderPrefix { get; }
    internal XmlDictionaryString FailedAuthenticationFaultCode { get; }
    internal XmlDictionaryString InvalidSecurityTokenFaultCode { get; }
    internal XmlDictionaryString InvalidSecurityFaultCode { get; }
    internal bool SupportsSignatureConfirmation { get; }
    public static SecurityVersion WSSecurity10 { get; }
    public static SecurityVersion WSSecurity11 { get; }
    internal static SecurityVersion Default { get; }
    internal SecurityVersion(XmlDictionaryString headerName, XmlDictionaryString headerNamespace, XmlDictionaryString headerPrefix);
    [CompilerGeneratedAttribute]
internal XmlDictionaryString get_HeaderName();
    [CompilerGeneratedAttribute]
internal XmlDictionaryString get_HeaderNamespace();
    internal XmlDictionaryString get_HeaderPrefix();
    internal abstract virtual XmlDictionaryString get_FailedAuthenticationFaultCode();
    internal abstract virtual XmlDictionaryString get_InvalidSecurityTokenFaultCode();
    internal abstract virtual XmlDictionaryString get_InvalidSecurityFaultCode();
    internal virtual bool get_SupportsSignatureConfirmation();
    public static SecurityVersion get_WSSecurity10();
    public static SecurityVersion get_WSSecurity11();
    internal static SecurityVersion get_Default();
    internal abstract virtual ReceiveSecurityHeader CreateReceiveSecurityHeader(Message message, string actor, bool mustUnderstand, bool relay, SecurityStandardsManager standardsManager, SecurityAlgorithmSuite algorithmSuite, MessageDirection direction, int headerIndex);
    internal abstract virtual SendSecurityHeader CreateSendSecurityHeader(Message message, string actor, bool mustUnderstand, bool relay, SecurityStandardsManager standardsManager, SecurityAlgorithmSuite algorithmSuite, MessageDirection direction);
    internal bool DoesMessageContainSecurityHeader(Message message);
    internal int FindIndexOfSecurityHeader(Message message, String[] actors);
    internal virtual bool IsReaderAtSignatureConfirmation(XmlDictionaryReader reader);
    internal virtual ISignatureValueSecurityElement ReadSignatureConfirmation(XmlDictionaryReader reader);
    internal ReceiveSecurityHeader TryCreateReceiveSecurityHeader(Message message, string actor, SecurityStandardsManager standardsManager, SecurityAlgorithmSuite algorithmSuite, MessageDirection direction);
    internal virtual void WriteSignatureConfirmation(XmlDictionaryWriter writer, string id, Byte[] signatureConfirmation);
    internal void WriteStartHeader(XmlDictionaryWriter writer);
}
internal abstract class System.ServiceModel.Security.SendSecurityHeader : SecurityHeader {
    private bool _encryptSignature;
    private bool _primarySignatureDone;
    private SignatureConfirmations _signatureValuesGenerated;
    private SignatureConfirmations _signatureConfirmationsToSend;
    private int _idCounter;
    private string _idPrefix;
    private MessagePartSpecification _signatureParts;
    private List`1<SecurityTokenParameters> _basicSupportingTokenParameters;
    private List`1<SecurityTokenParameters> _endorsingTokenParameters;
    private List`1<SecurityTokenParameters> _signedEndorsingTokenParameters;
    private List`1<SecurityTokenParameters> _signedTokenParameters;
    private Byte[] _primarySignatureValue;
    private bool _shouldProtectTokens;
    private BufferManager _bufferManager;
    private SecurityProtocolCorrelationState _correlationState;
    private bool _signThenEncrypt;
    private static String[] s_ids;
    [CompilerGeneratedAttribute]
private SendSecurityHeaderElementContainer <ElementContainer>k__BackingField;
    [CompilerGeneratedAttribute]
private SecurityTokenParameters <SigningTokenParameters>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <ShouldSignToHeader>k__BackingField;
    public SendSecurityHeaderElementContainer ElementContainer { get; }
    public BufferManager StreamBufferManager { get; public set; }
    protected SecurityAppliedMessage SecurityAppliedMessage { get; }
    public bool SignThenEncrypt { get; public set; }
    public bool ShouldProtectTokens { get; public set; }
    public bool EncryptPrimarySignature { get; public set; }
    private XmlDictionaryString System.ServiceModel.Channels.IMessageHeaderWithSharedNamespace.SharedNamespace { get; }
    private XmlDictionaryString System.ServiceModel.Channels.IMessageHeaderWithSharedNamespace.SharedPrefix { get; }
    public string IdPrefix { get; public set; }
    protected internal SecurityTokenParameters SigningTokenParameters { get; }
    protected bool ShouldSignToHeader { get; private set; }
    public string Name { get; }
    public string Namespace { get; }
    public SecurityTimestamp Timestamp { get; }
    protected SendSecurityHeader(Message message, string actor, bool mustUnderstand, bool relay, SecurityStandardsManager standardsManager, SecurityAlgorithmSuite algorithmSuite, MessageDirection transferDirection);
    private static SendSecurityHeader();
    [CompilerGeneratedAttribute]
public SendSecurityHeaderElementContainer get_ElementContainer();
    public BufferManager get_StreamBufferManager();
    public void set_StreamBufferManager(BufferManager value);
    protected SecurityAppliedMessage get_SecurityAppliedMessage();
    public bool get_SignThenEncrypt();
    public void set_SignThenEncrypt(bool value);
    public bool get_ShouldProtectTokens();
    public void set_ShouldProtectTokens(bool value);
    public void AddBasicSupportingToken(SecurityToken token, SecurityTokenParameters parameters);
    public void AddEndorsingSupportingToken(SecurityToken token, SecurityTokenParameters parameters);
    public void AddSignedEndorsingSupportingToken(SecurityToken token, SecurityTokenParameters parameters);
    public void AddSignedSupportingToken(SecurityToken token, SecurityTokenParameters parameters);
    public bool get_EncryptPrimarySignature();
    public void set_EncryptPrimarySignature(bool value);
    protected bool ShouldUseStrTransformForToken(SecurityToken securityToken, int position, SecurityTokenAttachmentMode mode, SecurityKeyIdentifierClause& keyIdentifierClause);
    private sealed virtual override XmlDictionaryString System.ServiceModel.Channels.IMessageHeaderWithSharedNamespace.get_SharedNamespace();
    private sealed virtual override XmlDictionaryString System.ServiceModel.Channels.IMessageHeaderWithSharedNamespace.get_SharedPrefix();
    public string get_IdPrefix();
    public void set_IdPrefix(string value);
    [CompilerGeneratedAttribute]
protected internal SecurityTokenParameters get_SigningTokenParameters();
    [CompilerGeneratedAttribute]
protected bool get_ShouldSignToHeader();
    [CompilerGeneratedAttribute]
private void set_ShouldSignToHeader(bool value);
    public virtual string get_Name();
    public virtual string get_Namespace();
    public SecurityTimestamp get_Timestamp();
    private void AddParameters(List`1& list, SecurityTokenParameters item);
    public abstract virtual void ApplyBodySecurity(XmlDictionaryWriter writer, IPrefixGenerator prefixGenerator);
    public abstract virtual void ApplySecurityAndWriteHeaders(MessageHeaders headers, XmlDictionaryWriter writer, IPrefixGenerator prefixGenerator);
    protected virtual void OnWriteStartHeader(XmlDictionaryWriter writer, MessageVersion messageVersion);
    protected virtual void OnWriteHeaderContents(XmlDictionaryWriter writer, MessageVersion messageVersion);
    public void AddTimestamp(TimeSpan timestampValidityDuration);
    public void AddTimestamp(SecurityTimestamp timestamp);
    protected abstract virtual void WriteSecurityTokenReferencyEntry(XmlDictionaryWriter writer, SecurityToken securityToken, SecurityTokenParameters securityTokenParameters);
    public Message SetupExecution();
    protected virtual ISignatureValueSecurityElement[] CreateSignatureConfirmationElements(SignatureConfirmations signatureConfirmations);
    private void StartEncryption();
    private void CompleteEncryption();
    internal void StartSecurityApplication();
    internal void CompleteSecurityApplication();
    public void RemoveSignatureEncryptionIfAppropriate();
    public string GenerateId();
    private SignatureConfirmations GetSignatureValues();
    internal static bool ShouldSerializeToken(SecurityTokenParameters parameters, MessageDirection transferDirection);
    protected internal SecurityTokenReferenceStyle GetTokenReferenceStyle(SecurityTokenParameters parameters);
    private void StartSignature();
    private void CompleteSignature();
    protected abstract virtual void StartPrimarySignatureCore(SecurityToken token, SecurityKeyIdentifier identifier, MessagePartSpecification signatureParts, bool generateTargettablePrimarySignature);
    protected abstract virtual ISignatureValueSecurityElement CompletePrimarySignatureCore(SendSecurityHeaderElement[] signatureConfirmations, SecurityToken[] signedEndorsingTokens, SecurityToken[] signedTokens, SendSecurityHeaderElement[] basicTokens, bool isPrimarySignature);
    protected abstract virtual ISignatureValueSecurityElement CreateSupportingSignature(SecurityToken token, SecurityKeyIdentifier identifier);
    protected abstract virtual ISignatureValueSecurityElement CreateSupportingSignature(SecurityToken token, SecurityKeyIdentifier identifier, ISecurityElement primarySignature);
    private void SignWithSupportingToken(SecurityToken token, SecurityKeyIdentifierClause identifierClause);
    private void SignWithSupportingTokens();
    private void AddGeneratedSignatureValue(Byte[] signatureValue, bool wasEncrypted);
}
internal class System.ServiceModel.Security.SendSecurityHeaderElement : object {
    [CompilerGeneratedAttribute]
private string <Id>k__BackingField;
    [CompilerGeneratedAttribute]
private ISecurityElement <Item>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <MarkedForEncryption>k__BackingField;
    public string Id { get; private set; }
    public ISecurityElement Item { get; private set; }
    public bool MarkedForEncryption { get; public set; }
    public SendSecurityHeaderElement(string id, ISecurityElement item);
    [CompilerGeneratedAttribute]
public string get_Id();
    [CompilerGeneratedAttribute]
private void set_Id(string value);
    [CompilerGeneratedAttribute]
public ISecurityElement get_Item();
    [CompilerGeneratedAttribute]
private void set_Item(ISecurityElement value);
    [CompilerGeneratedAttribute]
public bool get_MarkedForEncryption();
    [CompilerGeneratedAttribute]
public void set_MarkedForEncryption(bool value);
    public bool IsSameItem(ISecurityElement item);
    public void Replace(string id, ISecurityElement item);
}
internal class System.ServiceModel.Security.SendSecurityHeaderElementContainer : object {
    private List`1<SecurityToken> _signedSupportingTokens;
    private List`1<SendSecurityHeaderElement> _basicSupportingTokens;
    private List`1<SecurityToken> _endorsingSupportingTokens;
    private List`1<SecurityToken> _endorsingDerivedSupportingTokens;
    private List`1<SecurityToken> _signedEndorsingSupportingTokens;
    private List`1<SecurityToken> _signedEndorsingDerivedSupportingTokens;
    private List`1<SendSecurityHeaderElement> _signatureConfirmations;
    private List`1<SendSecurityHeaderElement> _endorsingSignatures;
    private Dictionary`2<SecurityToken, SecurityKeyIdentifierClause> _securityTokenMappedToIdentifierClause;
    public SecurityTimestamp Timestamp;
    public SecurityToken PrerequisiteToken;
    public SecurityToken SourceSigningToken;
    public SecurityToken DerivedSigningToken;
    public SecurityToken SourceEncryptionToken;
    public SecurityToken WrappedEncryptionToken;
    public SecurityToken DerivedEncryptionToken;
    public ISecurityElement ReferenceList;
    public SendSecurityHeaderElement PrimarySignature;
    public List`1<SecurityToken> EndorsingSupportingTokens { get; }
    private void Add(List`1& list, T item);
    public SecurityToken[] GetSignedSupportingTokens();
    public void AddSignedSupportingToken(SecurityToken token);
    public List`1<SecurityToken> get_EndorsingSupportingTokens();
    public SendSecurityHeaderElement[] GetBasicSupportingTokens();
    public void AddBasicSupportingToken(SendSecurityHeaderElement tokenElement);
    public SecurityToken[] GetSignedEndorsingSupportingTokens();
    public void AddSignedEndorsingSupportingToken(SecurityToken token);
    public SecurityToken[] GetSignedEndorsingDerivedSupportingTokens();
    public void AddSignedEndorsingDerivedSupportingToken(SecurityToken token);
    public SecurityToken[] GetEndorsingSupportingTokens();
    public void AddEndorsingSupportingToken(SecurityToken token);
    public SecurityToken[] GetEndorsingDerivedSupportingTokens();
    public void AddEndorsingDerivedSupportingToken(SecurityToken token);
    public SendSecurityHeaderElement[] GetSignatureConfirmations();
    public void AddSignatureConfirmation(SendSecurityHeaderElement confirmation);
    public SendSecurityHeaderElement[] GetEndorsingSignatures();
    public void AddEndorsingSignature(SendSecurityHeaderElement signature);
    public void MapSecurityTokenToStrClause(SecurityToken securityToken, SecurityKeyIdentifierClause keyIdentifierClause);
    public bool TryGetIdentifierClauseFromSecurityToken(SecurityToken securityToken, SecurityKeyIdentifierClause& keyIdentifierClause);
}
internal class System.ServiceModel.Security.ServiceModelDictionaryManager : object {
    private static DictionaryManager s_dictionaryManager;
    public static DictionaryManager Instance { get; }
    public static DictionaryManager get_Instance();
}
internal class System.ServiceModel.Security.SessionActionFilter : HeaderFilter {
    private SecurityStandardsManager _standardsManager;
    private String[] _actions;
    public SessionActionFilter(SecurityStandardsManager standardsManager, String[] actions);
    public virtual bool Match(Message message);
}
internal class System.ServiceModel.Security.SessionKeyExpiredException : MessageSecurityException {
    public SessionKeyExpiredException(string message);
    public SessionKeyExpiredException(string message, Exception innerException);
    protected SessionKeyExpiredException(SerializationInfo info, StreamingContext context);
}
internal class System.ServiceModel.Security.SessionSymmetricTransportSecurityProtocolFactory : TransportSecurityProtocolFactory {
    private SecurityTokenParameters _securityTokenParameters;
    public bool SupportsReplayDetection { get; }
    public SecurityTokenParameters SecurityTokenParameters { get; public set; }
    public virtual bool get_SupportsReplayDetection();
    public SecurityTokenParameters get_SecurityTokenParameters();
    public void set_SecurityTokenParameters(SecurityTokenParameters value);
    protected virtual SecurityProtocol OnCreateSecurityProtocol(EndpointAddress target, Uri via, object listenerSecurityState, TimeSpan timeout);
    [AsyncStateMachineAttribute("System.ServiceModel.Security.SessionSymmetricTransportSecurityProtocolFactory/<OnOpenAsync>d__8")]
public virtual Task OnOpenAsync(TimeSpan timeout);
    internal SecurityTokenParameters GetTokenParameters();
    [CompilerGeneratedAttribute]
[DebuggerHiddenAttribute]
private Task <>n__0(TimeSpan timeout);
}
internal class System.ServiceModel.Security.SignatureConfirmationElement : object {
    private SecurityVersion _version;
    private Byte[] _signatureValue;
    [CompilerGeneratedAttribute]
private string <Id>k__BackingField;
    public bool HasId { get; }
    public string Id { get; }
    public SignatureConfirmationElement(string id, Byte[] signatureValue, SecurityVersion version);
    public sealed virtual bool get_HasId();
    [CompilerGeneratedAttribute]
public sealed virtual string get_Id();
    public sealed virtual Byte[] GetSignatureValue();
    public sealed virtual void WriteTo(XmlDictionaryWriter writer, DictionaryManager dictionaryManager);
}
internal class System.ServiceModel.Security.SignatureConfirmations : object {
    private SignatureConfirmation[] _confirmations;
    [CompilerGeneratedAttribute]
private int <Count>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsMarkedForEncryption>k__BackingField;
    public int Count { get; private set; }
    public bool IsMarkedForEncryption { get; private set; }
    [CompilerGeneratedAttribute]
public int get_Count();
    [CompilerGeneratedAttribute]
private void set_Count(int value);
    public void AddConfirmation(Byte[] value, bool encrypted);
    [CompilerGeneratedAttribute]
public bool get_IsMarkedForEncryption();
    [CompilerGeneratedAttribute]
private void set_IsMarkedForEncryption(bool value);
}
internal abstract class System.ServiceModel.Security.SignatureTargetIdManager : object {
    public string DefaultIdNamespacePrefix { get; }
    public string DefaultIdNamespaceUri { get; }
    public abstract virtual string get_DefaultIdNamespacePrefix();
    public abstract virtual string get_DefaultIdNamespaceUri();
    public abstract virtual string ExtractId(XmlDictionaryReader reader);
    public abstract virtual void WriteIdAttribute(XmlDictionaryWriter writer, string id);
}
public class System.ServiceModel.Security.SspiSecurityTokenProvider : SecurityTokenProvider {
    internal static bool DefaultAllowNtlm;
    internal static bool DefaultExtractWindowsGroupClaims;
    internal static bool DefaultAllowUnauthenticatedCallers;
    private SspiSecurityToken _token;
    public SspiSecurityTokenProvider(NetworkCredential credential, bool allowNtlm, TokenImpersonationLevel impersonationLevel);
    public SspiSecurityTokenProvider(NetworkCredential credential, bool extractGroupsForWindowsAccounts, bool allowUnauthenticatedCallers);
    protected virtual SecurityToken GetTokenCore(TimeSpan timeout);
    protected virtual IAsyncResult BeginGetTokenCore(TimeSpan timeout, AsyncCallback callback, object state);
    protected virtual SecurityToken EndGetTokenCore(IAsyncResult result);
}
internal class System.ServiceModel.Security.StrictModeSecurityHeaderElementInferenceEngine : SecurityHeaderElementInferenceEngine {
    [CompilerGeneratedAttribute]
private static StrictModeSecurityHeaderElementInferenceEngine <Instance>k__BackingField;
    internal static StrictModeSecurityHeaderElementInferenceEngine Instance { get; }
    private static StrictModeSecurityHeaderElementInferenceEngine();
    [CompilerGeneratedAttribute]
internal static StrictModeSecurityHeaderElementInferenceEngine get_Instance();
    public virtual void ExecuteProcessingPasses(ReceiveSecurityHeader securityHeader, XmlDictionaryReader reader);
    public virtual void MarkElements(ReceiveSecurityHeaderElementManager elementManager, bool messageSecurityMode);
}
internal class System.ServiceModel.Security.SupportingTokenAuthenticatorSpecification : object {
    private bool _isTokenOptional;
    [CompilerGeneratedAttribute]
private SecurityTokenAuthenticator <TokenAuthenticator>k__BackingField;
    [CompilerGeneratedAttribute]
private SecurityTokenResolver <TokenResolver>k__BackingField;
    [CompilerGeneratedAttribute]
private SecurityTokenAttachmentMode <SecurityTokenAttachmentMode>k__BackingField;
    [CompilerGeneratedAttribute]
private SecurityTokenParameters <TokenParameters>k__BackingField;
    public SecurityTokenAuthenticator TokenAuthenticator { get; }
    public SecurityTokenResolver TokenResolver { get; }
    public SecurityTokenAttachmentMode SecurityTokenAttachmentMode { get; }
    public SecurityTokenParameters TokenParameters { get; }
    internal bool IsTokenOptional { get; internal set; }
    public SupportingTokenAuthenticatorSpecification(SecurityTokenAuthenticator tokenAuthenticator, SecurityTokenResolver securityTokenResolver, SecurityTokenAttachmentMode attachmentMode, SecurityTokenParameters tokenParameters);
    internal SupportingTokenAuthenticatorSpecification(SecurityTokenAuthenticator tokenAuthenticator, SecurityTokenResolver securityTokenResolver, SecurityTokenAttachmentMode attachmentMode, SecurityTokenParameters tokenParameters, bool isTokenOptional);
    [CompilerGeneratedAttribute]
public SecurityTokenAuthenticator get_TokenAuthenticator();
    [CompilerGeneratedAttribute]
public SecurityTokenResolver get_TokenResolver();
    [CompilerGeneratedAttribute]
public SecurityTokenAttachmentMode get_SecurityTokenAttachmentMode();
    [CompilerGeneratedAttribute]
public SecurityTokenParameters get_TokenParameters();
    internal bool get_IsTokenOptional();
    internal void set_IsTokenOptional(bool value);
}
internal class System.ServiceModel.Security.SupportingTokenProviderSpecification : object {
    private SecurityTokenParameters _tokenParameters;
    [CompilerGeneratedAttribute]
private SecurityTokenProvider <TokenProvider>k__BackingField;
    [CompilerGeneratedAttribute]
private SecurityTokenAttachmentMode <SecurityTokenAttachmentMode>k__BackingField;
    public SecurityTokenProvider TokenProvider { get; }
    public SecurityTokenAttachmentMode SecurityTokenAttachmentMode { get; }
    public SecurityTokenParameters TokenParameters { get; }
    public SupportingTokenProviderSpecification(SecurityTokenProvider tokenProvider, SecurityTokenAttachmentMode attachmentMode, SecurityTokenParameters tokenParameters);
    [CompilerGeneratedAttribute]
public SecurityTokenProvider get_TokenProvider();
    [CompilerGeneratedAttribute]
public SecurityTokenAttachmentMode get_SecurityTokenAttachmentMode();
    public SecurityTokenParameters get_TokenParameters();
}
public class System.ServiceModel.Security.SupportingTokenSpecification : SecurityTokenSpecification {
    private SecurityTokenParameters _tokenParameters;
    [CompilerGeneratedAttribute]
private SecurityTokenAttachmentMode <SecurityTokenAttachmentMode>k__BackingField;
    public SecurityTokenAttachmentMode SecurityTokenAttachmentMode { get; }
    internal SecurityTokenParameters SecurityTokenParameters { get; }
    public SupportingTokenSpecification(SecurityToken token, ReadOnlyCollection`1<IAuthorizationPolicy> tokenPolicies, SecurityTokenAttachmentMode attachmentMode);
    public SupportingTokenSpecification(SecurityToken token, ReadOnlyCollection`1<IAuthorizationPolicy> tokenPolicies, SecurityTokenAttachmentMode attachmentMode, SecurityTokenParameters tokenParameters);
    [CompilerGeneratedAttribute]
public SecurityTokenAttachmentMode get_SecurityTokenAttachmentMode();
    internal SecurityTokenParameters get_SecurityTokenParameters();
}
internal class System.ServiceModel.Security.TimeBoundedCache : object {
    private static Action`1<object> s_purgeCallback;
    private Hashtable _entries;
    private int _lowWaterMark;
    private DateTime _nextPurgeTimeUtc;
    private TimeSpan _purgeInterval;
    private PurgingMode _purgingMode;
    private Timer _purgingTimer;
    private bool _doRemoveNotification;
    [CompilerGeneratedAttribute]
private int <Capacity>k__BackingField;
    [CompilerGeneratedAttribute]
private ReaderWriterLockSlim <CacheLock>k__BackingField;
    public int Count { get; }
    private static Action`1<object> PurgeCallback { get; }
    protected int Capacity { get; }
    protected Hashtable Entries { get; }
    protected ReaderWriterLockSlim CacheLock { get; }
    protected TimeBoundedCache(int lowWaterMark, int maxCacheItems, IEqualityComparer keyComparer, PurgingMode purgingMode, TimeSpan purgeInterval, bool doRemoveNotification);
    public int get_Count();
    private static Action`1<object> get_PurgeCallback();
    [CompilerGeneratedAttribute]
protected int get_Capacity();
    protected Hashtable get_Entries();
    [CompilerGeneratedAttribute]
protected ReaderWriterLockSlim get_CacheLock();
    protected bool TryAddItem(object key, object item, DateTime expirationTime, bool replaceExistingEntry);
    private void CancelTimerIfNeeded();
    private void StartTimerIfNeeded();
    protected bool TryAddItem(object key, IExpirableItem item, bool replaceExistingEntry);
    protected bool TryReplaceItem(object key, object item, DateTime expirationTime);
    protected void ClearItems();
    protected object GetItem(object key);
    protected virtual ArrayList OnQuotaReached(Hashtable cacheTable);
    protected virtual void OnRemove(object item);
    protected bool TryRemoveItem(object key);
    private void EnforceQuota();
    protected object ExtractItem(IExpirableItem val);
    private bool IsExpired(IExpirableItem item);
    private bool ShouldPurge();
    private void PurgeIfNeeded();
    private void PurgeStaleItems();
    private void ThrowQuotaReachedException();
    private static void PurgeCallbackStatic(object state);
}
internal class System.ServiceModel.Security.TokenElement : object {
    private SecurityStandardsManager _standardsManager;
    [CompilerGeneratedAttribute]
private SecurityToken <Token>k__BackingField;
    public bool HasId { get; }
    public string Id { get; }
    public SecurityToken Token { get; }
    public TokenElement(SecurityToken token, SecurityStandardsManager standardsManager);
    public virtual bool Equals(object item);
    public virtual int GetHashCode();
    public sealed virtual bool get_HasId();
    public sealed virtual string get_Id();
    [CompilerGeneratedAttribute]
public SecurityToken get_Token();
    public sealed virtual void WriteTo(XmlDictionaryWriter writer, DictionaryManager dictionaryManager);
}
internal static class System.ServiceModel.Security.TokenImpersonationLevelHelper : object {
    private static TokenImpersonationLevel[] s_tokenImpersonationLevelOrder;
    private static TokenImpersonationLevelHelper();
    internal static bool IsDefined(TokenImpersonationLevel value);
    internal static void Validate(TokenImpersonationLevel value);
    internal static string ToString(TokenImpersonationLevel impersonationLevel);
    internal static bool IsGreaterOrEqual(TokenImpersonationLevel x, TokenImpersonationLevel y);
    internal static int Compare(TokenImpersonationLevel x, TokenImpersonationLevel y);
}
public class System.ServiceModel.Security.Tokens.BinarySecretSecurityToken : SecurityToken {
    private string _id;
    private DateTime _effectiveTime;
    private Byte[] _key;
    private ReadOnlyCollection`1<SecurityKey> _securityKeys;
    public string Id { get; }
    public DateTime ValidFrom { get; }
    public DateTime ValidTo { get; }
    public int KeySize { get; }
    public ReadOnlyCollection`1<SecurityKey> SecurityKeys { get; }
    public BinarySecretSecurityToken(string id, Byte[] key);
    public BinarySecretSecurityToken(Byte[] key);
    protected BinarySecretSecurityToken(string id, int keySizeInBits, bool allowCrypto);
    protected BinarySecretSecurityToken(string id, Byte[] key, bool allowCrypto);
    public virtual string get_Id();
    public virtual DateTime get_ValidFrom();
    public virtual DateTime get_ValidTo();
    public int get_KeySize();
    public virtual ReadOnlyCollection`1<SecurityKey> get_SecurityKeys();
    public Byte[] GetKeyBytes();
}
internal class System.ServiceModel.Security.Tokens.BufferedGenericXmlSecurityToken : GenericXmlSecurityToken {
    [CompilerGeneratedAttribute]
private XmlBuffer <TokenXmlBuffer>k__BackingField;
    public XmlBuffer TokenXmlBuffer { get; }
    public BufferedGenericXmlSecurityToken(XmlElement tokenXml, SecurityToken proofToken, DateTime effectiveTime, DateTime expirationTime, SecurityKeyIdentifierClause internalTokenReference, SecurityKeyIdentifierClause externalTokenReference, ReadOnlyCollection`1<IAuthorizationPolicy> authorizationPolicies, XmlBuffer tokenXmlBuffer);
    [CompilerGeneratedAttribute]
public XmlBuffer get_TokenXmlBuffer();
}
public class System.ServiceModel.Security.Tokens.ClaimTypeRequirement : object {
    internal static bool DefaultIsOptional;
    private bool _isOptional;
    [CompilerGeneratedAttribute]
private string <ClaimType>k__BackingField;
    public string ClaimType { get; }
    public bool IsOptional { get; }
    public ClaimTypeRequirement(string claimType);
    public ClaimTypeRequirement(string claimType, bool isOptional);
    [CompilerGeneratedAttribute]
public string get_ClaimType();
    public bool get_IsOptional();
}
internal class System.ServiceModel.Security.Tokens.DerivedKeySecurityToken : SecurityToken {
    private static Byte[] s_DefaultLabel;
    public static int DefaultNonceLength;
    public static int DefaultDerivedKeyLength;
    private string _id;
    private Byte[] _key;
    private string _label;
    private Byte[] _nonce;
    private ReadOnlyCollection`1<SecurityKey> _securityKeys;
    [CompilerGeneratedAttribute]
private string <KeyDerivationAlgorithm>k__BackingField;
    [CompilerGeneratedAttribute]
private int <Generation>k__BackingField;
    [CompilerGeneratedAttribute]
private int <Length>k__BackingField;
    [CompilerGeneratedAttribute]
private int <Offset>k__BackingField;
    [CompilerGeneratedAttribute]
private SecurityToken <TokenToDerive>k__BackingField;
    [CompilerGeneratedAttribute]
private SecurityKeyIdentifierClause <TokenToDeriveIdentifier>k__BackingField;
    public string Id { get; }
    public DateTime ValidFrom { get; }
    public DateTime ValidTo { get; }
    public string KeyDerivationAlgorithm { get; private set; }
    public int Generation { get; private set; }
    public string Label { get; }
    public int Length { get; private set; }
    internal Byte[] Nonce { get; }
    public int Offset { get; private set; }
    internal SecurityToken TokenToDerive { get; private set; }
    internal SecurityKeyIdentifierClause TokenToDeriveIdentifier { get; private set; }
    public ReadOnlyCollection`1<SecurityKey> SecurityKeys { get; }
    internal DerivedKeySecurityToken(int generation, int offset, int length, string label, int minNonceLength, SecurityToken tokenToDerive, SecurityKeyIdentifierClause tokenToDeriveIdentifier, string derivationAlgorithm, string id);
    internal DerivedKeySecurityToken(int generation, int offset, int length, string label, Byte[] nonce, SecurityToken tokenToDerive, SecurityKeyIdentifierClause tokenToDeriveIdentifier, string derivationAlgorithm, string id);
    private static DerivedKeySecurityToken();
    public virtual string get_Id();
    public virtual DateTime get_ValidFrom();
    public virtual DateTime get_ValidTo();
    [CompilerGeneratedAttribute]
public string get_KeyDerivationAlgorithm();
    [CompilerGeneratedAttribute]
private void set_KeyDerivationAlgorithm(string value);
    [CompilerGeneratedAttribute]
public int get_Generation();
    [CompilerGeneratedAttribute]
private void set_Generation(int value);
    public string get_Label();
    [CompilerGeneratedAttribute]
public int get_Length();
    [CompilerGeneratedAttribute]
private void set_Length(int value);
    internal Byte[] get_Nonce();
    [CompilerGeneratedAttribute]
public int get_Offset();
    [CompilerGeneratedAttribute]
private void set_Offset(int value);
    [CompilerGeneratedAttribute]
internal SecurityToken get_TokenToDerive();
    [CompilerGeneratedAttribute]
private void set_TokenToDerive(SecurityToken value);
    [CompilerGeneratedAttribute]
internal SecurityKeyIdentifierClause get_TokenToDeriveIdentifier();
    [CompilerGeneratedAttribute]
private void set_TokenToDeriveIdentifier(SecurityKeyIdentifierClause value);
    public virtual ReadOnlyCollection`1<SecurityKey> get_SecurityKeys();
    public Byte[] GetKeyBytes();
    public Byte[] GetNonce();
    internal bool TryGetSecurityKeys(ReadOnlyCollection`1& keys);
    public virtual string ToString();
    private void Initialize(string id, int generation, int offset, int length, string label, Byte[] nonce, SecurityToken tokenToDerive, SecurityKeyIdentifierClause tokenToDeriveIdentifier, string derivationAlgorithm);
    private void Initialize(string id, int generation, int offset, int length, string label, Byte[] nonce, SecurityToken tokenToDerive, SecurityKeyIdentifierClause tokenToDeriveIdentifier, string derivationAlgorithm, bool initializeDerivedKey);
    internal void InitializeDerivedKey(int maxKeyLength);
    internal static void EnsureAcceptableOffset(int offset, int generation, int length, int maxOffset);
}
internal class System.ServiceModel.Security.Tokens.DerivedKeySecurityTokenStub : SecurityToken {
    private string _id;
    private string _derivationAlgorithm;
    private string _label;
    private int _length;
    private Byte[] _nonce;
    private int _offset;
    private int _generation;
    [CompilerGeneratedAttribute]
private SecurityKeyIdentifierClause <TokenToDeriveIdentifier>k__BackingField;
    public string Id { get; }
    public DateTime ValidFrom { get; }
    public DateTime ValidTo { get; }
    public ReadOnlyCollection`1<SecurityKey> SecurityKeys { get; }
    public SecurityKeyIdentifierClause TokenToDeriveIdentifier { get; }
    public DerivedKeySecurityTokenStub(int generation, int offset, int length, string label, Byte[] nonce, SecurityKeyIdentifierClause tokenToDeriveIdentifier, string derivationAlgorithm, string id);
    public virtual string get_Id();
    public virtual DateTime get_ValidFrom();
    public virtual DateTime get_ValidTo();
    public virtual ReadOnlyCollection`1<SecurityKey> get_SecurityKeys();
    [CompilerGeneratedAttribute]
public SecurityKeyIdentifierClause get_TokenToDeriveIdentifier();
    public DerivedKeySecurityToken CreateToken(SecurityToken tokenToDerive, int maxKeyLength);
}
internal class System.ServiceModel.Security.Tokens.GenericXmlSecurityTokenAuthenticator : SecurityTokenAuthenticator {
    protected virtual bool CanValidateTokenCore(SecurityToken token);
    protected virtual ReadOnlyCollection`1<IAuthorizationPolicy> ValidateTokenCore(SecurityToken token);
}
public class System.ServiceModel.Security.Tokens.InitiatorServiceModelSecurityTokenRequirement : ServiceModelSecurityTokenRequirement {
    public EndpointAddress TargetAddress { get; public set; }
    public Uri Via { get; public set; }
    internal bool IsOutOfBandToken { get; internal set; }
    internal bool PreferSslCertificateAuthenticator { get; internal set; }
    public EndpointAddress get_TargetAddress();
    public void set_TargetAddress(EndpointAddress value);
    public Uri get_Via();
    public void set_Via(Uri value);
    internal bool get_IsOutOfBandToken();
    internal void set_IsOutOfBandToken(bool value);
    internal bool get_PreferSslCertificateAuthenticator();
    internal void set_PreferSslCertificateAuthenticator(bool value);
    public virtual string ToString();
}
internal interface System.ServiceModel.Security.Tokens.ISecurityContextSecurityTokenCache {
    public abstract virtual void AddContext(SecurityContextSecurityToken token);
    public abstract virtual bool TryAddContext(SecurityContextSecurityToken token);
    public abstract virtual void ClearContexts();
    public abstract virtual void RemoveContext(UniqueId contextId, UniqueId generation);
    public abstract virtual void RemoveAllContexts(UniqueId contextId);
    public abstract virtual SecurityContextSecurityToken GetContext(UniqueId contextId, UniqueId generation);
    public abstract virtual Collection`1<SecurityContextSecurityToken> GetAllContexts(UniqueId contextId);
    public abstract virtual void UpdateContextCachingTime(SecurityContextSecurityToken context, DateTime expirationTime);
}
internal interface System.ServiceModel.Security.Tokens.ISecurityContextSecurityTokenCacheProvider {
    public ISecurityContextSecurityTokenCache TokenCache { get; }
    public abstract virtual ISecurityContextSecurityTokenCache get_TokenCache();
}
public class System.ServiceModel.Security.Tokens.IssuedSecurityTokenParameters : SecurityTokenParameters {
    internal static SecurityKeyType DefaultKeyType;
    internal static bool DefaultUseStrTransform;
    private int _keySize;
    private SecurityKeyType _keyType;
    [CompilerGeneratedAttribute]
private Collection`1<XmlElement> <AdditionalRequestParameters>k__BackingField;
    [CompilerGeneratedAttribute]
private MessageSecurityVersion <DefaultMessageSecurityVersion>k__BackingField;
    [CompilerGeneratedAttribute]
private Collection`1<AlternativeIssuerEndpoint> <AlternativeIssuerEndpoints>k__BackingField;
    [CompilerGeneratedAttribute]
private EndpointAddress <IssuerAddress>k__BackingField;
    [CompilerGeneratedAttribute]
private EndpointAddress <IssuerMetadataAddress>k__BackingField;
    [CompilerGeneratedAttribute]
private Binding <IssuerBinding>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <UseStrTransform>k__BackingField;
    [CompilerGeneratedAttribute]
private Collection`1<ClaimTypeRequirement> <ClaimTypeRequirements>k__BackingField;
    [CompilerGeneratedAttribute]
private string <TokenType>k__BackingField;
    protected internal bool HasAsymmetricKey { get; }
    public Collection`1<XmlElement> AdditionalRequestParameters { get; }
    public MessageSecurityVersion DefaultMessageSecurityVersion { get; public set; }
    internal Collection`1<AlternativeIssuerEndpoint> AlternativeIssuerEndpoints { get; }
    public EndpointAddress IssuerAddress { get; public set; }
    public EndpointAddress IssuerMetadataAddress { get; public set; }
    public Binding IssuerBinding { get; public set; }
    public SecurityKeyType KeyType { get; public set; }
    public int KeySize { get; public set; }
    public bool UseStrTransform { get; public set; }
    public Collection`1<ClaimTypeRequirement> ClaimTypeRequirements { get; }
    public string TokenType { get; public set; }
    protected internal bool SupportsClientAuthentication { get; }
    protected internal bool SupportsServerAuthentication { get; }
    protected internal bool SupportsClientWindowsIdentity { get; }
    protected IssuedSecurityTokenParameters(IssuedSecurityTokenParameters other);
    public IssuedSecurityTokenParameters(string tokenType);
    public IssuedSecurityTokenParameters(string tokenType, EndpointAddress issuerAddress);
    public IssuedSecurityTokenParameters(string tokenType, EndpointAddress issuerAddress, Binding issuerBinding);
    protected internal virtual bool get_HasAsymmetricKey();
    [CompilerGeneratedAttribute]
public Collection`1<XmlElement> get_AdditionalRequestParameters();
    [CompilerGeneratedAttribute]
public MessageSecurityVersion get_DefaultMessageSecurityVersion();
    [CompilerGeneratedAttribute]
public void set_DefaultMessageSecurityVersion(MessageSecurityVersion value);
    [CompilerGeneratedAttribute]
internal Collection`1<AlternativeIssuerEndpoint> get_AlternativeIssuerEndpoints();
    [CompilerGeneratedAttribute]
public EndpointAddress get_IssuerAddress();
    [CompilerGeneratedAttribute]
public void set_IssuerAddress(EndpointAddress value);
    [CompilerGeneratedAttribute]
public EndpointAddress get_IssuerMetadataAddress();
    [CompilerGeneratedAttribute]
public void set_IssuerMetadataAddress(EndpointAddress value);
    [CompilerGeneratedAttribute]
public Binding get_IssuerBinding();
    [CompilerGeneratedAttribute]
public void set_IssuerBinding(Binding value);
    public SecurityKeyType get_KeyType();
    public void set_KeyType(SecurityKeyType value);
    public int get_KeySize();
    public void set_KeySize(int value);
    [CompilerGeneratedAttribute]
public bool get_UseStrTransform();
    [CompilerGeneratedAttribute]
public void set_UseStrTransform(bool value);
    [CompilerGeneratedAttribute]
public Collection`1<ClaimTypeRequirement> get_ClaimTypeRequirements();
    [CompilerGeneratedAttribute]
public string get_TokenType();
    [CompilerGeneratedAttribute]
public void set_TokenType(string value);
    protected internal virtual bool get_SupportsClientAuthentication();
    protected internal virtual bool get_SupportsServerAuthentication();
    protected internal virtual bool get_SupportsClientWindowsIdentity();
    protected virtual SecurityTokenParameters CloneCore();
    protected internal virtual SecurityKeyIdentifierClause CreateKeyIdentifierClause(SecurityToken token, SecurityTokenReferenceStyle referenceStyle);
    public virtual string ToString();
    protected internal virtual void InitializeSecurityTokenRequirement(SecurityTokenRequirement requirement);
}
internal class System.ServiceModel.Security.Tokens.NonValidatingSecurityTokenAuthenticator`1 : SecurityTokenAuthenticator {
    protected virtual bool CanValidateTokenCore(SecurityToken token);
    protected virtual ReadOnlyCollection`1<IAuthorizationPolicy> ValidateTokenCore(SecurityToken token);
}
public class System.ServiceModel.Security.Tokens.RecipientServiceModelSecurityTokenRequirement : ServiceModelSecurityTokenRequirement {
    public Uri ListenUri { get; public set; }
    public Uri get_ListenUri();
    public void set_ListenUri(Uri value);
    public virtual string ToString();
}
public class System.ServiceModel.Security.Tokens.SecureConversationSecurityTokenParameters : SecurityTokenParameters {
    internal static bool defaultRequireCancellation;
    internal static bool defaultCanRenewSession;
    private BindingContext _issuerBindingContext;
    private ChannelProtectionRequirements _bootstrapProtectionRequirements;
    [CompilerGeneratedAttribute]
private SecurityBindingElement <BootstrapSecurityBindingElement>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <RequireCancellation>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <CanRenewSession>k__BackingField;
    protected internal bool HasAsymmetricKey { get; }
    public SecurityBindingElement BootstrapSecurityBindingElement { get; public set; }
    internal BindingContext IssuerBindingContext { get; internal set; }
    private ISecurityCapabilities BootstrapSecurityCapabilities { get; }
    public bool RequireCancellation { get; public set; }
    public bool CanRenewSession { get; public set; }
    protected internal bool SupportsClientAuthentication { get; }
    protected internal bool SupportsServerAuthentication { get; }
    protected internal bool SupportsClientWindowsIdentity { get; }
    protected SecureConversationSecurityTokenParameters(SecureConversationSecurityTokenParameters other);
    public SecureConversationSecurityTokenParameters(SecurityBindingElement bootstrapSecurityBindingElement);
    public SecureConversationSecurityTokenParameters(SecurityBindingElement bootstrapSecurityBindingElement, bool requireCancellation, ChannelProtectionRequirements bootstrapProtectionRequirements);
    public SecureConversationSecurityTokenParameters(SecurityBindingElement bootstrapSecurityBindingElement, bool requireCancellation, bool canRenewSession, ChannelProtectionRequirements bootstrapProtectionRequirements);
    protected internal virtual bool get_HasAsymmetricKey();
    [CompilerGeneratedAttribute]
public SecurityBindingElement get_BootstrapSecurityBindingElement();
    [CompilerGeneratedAttribute]
public void set_BootstrapSecurityBindingElement(SecurityBindingElement value);
    internal BindingContext get_IssuerBindingContext();
    internal void set_IssuerBindingContext(BindingContext value);
    private ISecurityCapabilities get_BootstrapSecurityCapabilities();
    [CompilerGeneratedAttribute]
public bool get_RequireCancellation();
    [CompilerGeneratedAttribute]
public void set_RequireCancellation(bool value);
    [CompilerGeneratedAttribute]
public bool get_CanRenewSession();
    [CompilerGeneratedAttribute]
public void set_CanRenewSession(bool value);
    protected internal virtual bool get_SupportsClientAuthentication();
    protected internal virtual bool get_SupportsServerAuthentication();
    protected internal virtual bool get_SupportsClientWindowsIdentity();
    protected virtual SecurityTokenParameters CloneCore();
    protected internal virtual SecurityKeyIdentifierClause CreateKeyIdentifierClause(SecurityToken token, SecurityTokenReferenceStyle referenceStyle);
    protected internal virtual void InitializeSecurityTokenRequirement(SecurityTokenRequirement requirement);
    public virtual string ToString();
}
internal class System.ServiceModel.Security.Tokens.SecurityContextSecurityToken : SecurityToken {
    private UniqueId _keyGeneration;
    private DateTime _tokenEffectiveTime;
    private DateTime _tokenExpirationTime;
    private Byte[] _key;
    private ReadOnlyCollection`1<IAuthorizationPolicy> _authorizationPolicies;
    private ReadOnlyCollection`1<SecurityKey> _securityKeys;
    private string _id;
    private bool _disposed;
    [CompilerGeneratedAttribute]
private SecurityMessageProperty <BootstrapMessageProperty>k__BackingField;
    [CompilerGeneratedAttribute]
private UniqueId <ContextId>k__BackingField;
    [CompilerGeneratedAttribute]
private DateTime <KeyEffectiveTime>k__BackingField;
    [CompilerGeneratedAttribute]
private DateTime <KeyExpirationTime>k__BackingField;
    [CompilerGeneratedAttribute]
private Byte[] <CookieBlob>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsCookieMode>k__BackingField;
    public SecurityMessageProperty BootstrapMessageProperty { get; public set; }
    public string Id { get; }
    public UniqueId ContextId { get; private set; }
    public UniqueId KeyGeneration { get; }
    public DateTime KeyEffectiveTime { get; private set; }
    public DateTime KeyExpirationTime { get; private set; }
    public ReadOnlyCollection`1<IAuthorizationPolicy> AuthorizationPolicies { get; internal set; }
    public ReadOnlyCollection`1<SecurityKey> SecurityKeys { get; }
    public DateTime ValidFrom { get; }
    public DateTime ValidTo { get; }
    internal Byte[] CookieBlob { get; }
    public bool IsCookieMode { get; private set; }
    private DateTime System.ServiceModel.Security.TimeBoundedCache.IExpirableItem.ExpirationTime { get; }
    internal SecurityContextSecurityToken(SecurityContextSecurityToken sourceToken, string id);
    internal SecurityContextSecurityToken(SecurityContextSecurityToken sourceToken, string id, Byte[] key, UniqueId keyGeneration, DateTime keyEffectiveTime, DateTime keyExpirationTime, ReadOnlyCollection`1<IAuthorizationPolicy> authorizationPolicies);
    [CompilerGeneratedAttribute]
public SecurityMessageProperty get_BootstrapMessageProperty();
    [CompilerGeneratedAttribute]
public void set_BootstrapMessageProperty(SecurityMessageProperty value);
    public virtual string get_Id();
    [CompilerGeneratedAttribute]
public UniqueId get_ContextId();
    [CompilerGeneratedAttribute]
private void set_ContextId(UniqueId value);
    public UniqueId get_KeyGeneration();
    [CompilerGeneratedAttribute]
public DateTime get_KeyEffectiveTime();
    [CompilerGeneratedAttribute]
private void set_KeyEffectiveTime(DateTime value);
    [CompilerGeneratedAttribute]
public DateTime get_KeyExpirationTime();
    [CompilerGeneratedAttribute]
private void set_KeyExpirationTime(DateTime value);
    public ReadOnlyCollection`1<IAuthorizationPolicy> get_AuthorizationPolicies();
    internal void set_AuthorizationPolicies(ReadOnlyCollection`1<IAuthorizationPolicy> value);
    public virtual ReadOnlyCollection`1<SecurityKey> get_SecurityKeys();
    public virtual DateTime get_ValidFrom();
    public virtual DateTime get_ValidTo();
    [CompilerGeneratedAttribute]
internal Byte[] get_CookieBlob();
    [CompilerGeneratedAttribute]
public bool get_IsCookieMode();
    [CompilerGeneratedAttribute]
private void set_IsCookieMode(bool value);
    private sealed virtual override DateTime System.ServiceModel.Security.TimeBoundedCache.IExpirableItem.get_ExpirationTime();
    public virtual string ToString();
    private void Initialize(UniqueId contextId, Byte[] key, DateTime validFrom, DateTime validTo, ReadOnlyCollection`1<IAuthorizationPolicy> authorizationPolicies, bool isCookieMode, UniqueId keyGeneration, DateTime keyEffectiveTime, DateTime keyExpirationTime);
    public sealed virtual void Dispose();
    private void ThrowIfDisposed();
}
internal class System.ServiceModel.Security.Tokens.SecurityContextTokenValidationException : SecurityTokenValidationException {
    public SecurityContextTokenValidationException(string message);
    public SecurityContextTokenValidationException(string message, Exception innerException);
    protected SecurityContextTokenValidationException(SerializationInfo info, StreamingContext context);
}
internal class System.ServiceModel.Security.Tokens.SecurityTokenContainer : object {
    [CompilerGeneratedAttribute]
private SecurityToken <Token>k__BackingField;
    public SecurityToken Token { get; }
    public SecurityTokenContainer(SecurityToken token);
    [CompilerGeneratedAttribute]
public SecurityToken get_Token();
}
public enum System.ServiceModel.Security.Tokens.SecurityTokenInclusionMode : Enum {
    public int value__;
    public static SecurityTokenInclusionMode AlwaysToRecipient;
    public static SecurityTokenInclusionMode Never;
    public static SecurityTokenInclusionMode Once;
    public static SecurityTokenInclusionMode AlwaysToInitiator;
}
internal static class System.ServiceModel.Security.Tokens.SecurityTokenInclusionModeHelper : object {
    public static bool IsDefined(SecurityTokenInclusionMode value);
    public static void Validate(SecurityTokenInclusionMode value);
}
public abstract class System.ServiceModel.Security.Tokens.SecurityTokenParameters : object {
    internal static SecurityTokenInclusionMode defaultInclusionMode;
    internal static bool defaultRequireDerivedKeys;
    private SecurityTokenInclusionMode _inclusionMode;
    [CompilerGeneratedAttribute]
private bool <RequireDerivedKeys>k__BackingField;
    protected internal bool HasAsymmetricKey { get; }
    public SecurityTokenInclusionMode InclusionMode { get; public set; }
    public bool RequireDerivedKeys { get; public set; }
    protected internal bool SupportsClientAuthentication { get; }
    protected internal bool SupportsServerAuthentication { get; }
    protected internal bool SupportsClientWindowsIdentity { get; }
    protected SecurityTokenParameters(SecurityTokenParameters other);
    protected internal abstract virtual bool get_HasAsymmetricKey();
    public SecurityTokenInclusionMode get_InclusionMode();
    public void set_InclusionMode(SecurityTokenInclusionMode value);
    [CompilerGeneratedAttribute]
public bool get_RequireDerivedKeys();
    [CompilerGeneratedAttribute]
public void set_RequireDerivedKeys(bool value);
    protected internal abstract virtual bool get_SupportsClientAuthentication();
    protected internal abstract virtual bool get_SupportsServerAuthentication();
    protected internal abstract virtual bool get_SupportsClientWindowsIdentity();
    public SecurityTokenParameters Clone();
    protected abstract virtual SecurityTokenParameters CloneCore();
    protected internal abstract virtual SecurityKeyIdentifierClause CreateKeyIdentifierClause(SecurityToken token, SecurityTokenReferenceStyle referenceStyle);
    internal SecurityKeyIdentifierClause CreateKeyIdentifierClause(SecurityToken token, SecurityTokenReferenceStyle referenceStyle);
    internal SecurityKeyIdentifierClause CreateGenericXmlTokenKeyIdentifierClause(SecurityToken token, SecurityTokenReferenceStyle referenceStyle);
    protected internal virtual bool MatchesKeyIdentifierClause(SecurityToken token, SecurityKeyIdentifierClause keyIdentifierClause, SecurityTokenReferenceStyle referenceStyle);
    protected internal abstract virtual void InitializeSecurityTokenRequirement(SecurityTokenRequirement requirement);
    internal bool MatchesGenericXmlTokenKeyIdentifierClause(SecurityToken token, SecurityKeyIdentifierClause keyIdentifierClause, SecurityTokenReferenceStyle referenceStyle);
    public virtual string ToString();
}
internal class System.ServiceModel.Security.Tokens.SecurityTokenProviderContainer : object {
    [CompilerGeneratedAttribute]
private SecurityTokenProvider <TokenProvider>k__BackingField;
    public SecurityTokenProvider TokenProvider { get; }
    public SecurityTokenProviderContainer(SecurityTokenProvider tokenProvider);
    [CompilerGeneratedAttribute]
public SecurityTokenProvider get_TokenProvider();
    public void Close(TimeSpan timeout);
    public Task OpenAsync(TimeSpan timeout);
    public void Abort();
}
public enum System.ServiceModel.Security.Tokens.SecurityTokenReferenceStyle : Enum {
    public int value__;
    public static SecurityTokenReferenceStyle Internal;
    public static SecurityTokenReferenceStyle External;
}
public abstract class System.ServiceModel.Security.Tokens.ServiceModelSecurityTokenRequirement : SecurityTokenRequirement {
    protected static string Namespace;
    private static string securityAlgorithmSuiteProperty;
    private static string securityBindingElementProperty;
    private static string issuerAddressProperty;
    private static string issuerBindingProperty;
    private static string secureConversationSecurityBindingElementProperty;
    private static string supportSecurityContextCancellationProperty;
    private static string messageSecurityVersionProperty;
    private static string defaultMessageSecurityVersionProperty;
    private static string issuerBindingContextProperty;
    private static string transportSchemeProperty;
    private static string isInitiatorProperty;
    private static string targetAddressProperty;
    private static string viaProperty;
    private static string listenUriProperty;
    private static string auditLogLocationProperty;
    private static string suppressAuditFailureProperty;
    private static string messageAuthenticationAuditLevelProperty;
    private static string isOutOfBandTokenProperty;
    private static string preferSslCertificateAuthenticatorProperty;
    private static string supportingTokenAttachmentModeProperty;
    private static string messageDirectionProperty;
    private static string httpAuthenticationSchemeProperty;
    private static string issuedSecurityTokenParametersProperty;
    private static string privacyNoticeUriProperty;
    private static string privacyNoticeVersionProperty;
    private static string duplexClientLocalAddressProperty;
    private static string endpointFilterTableProperty;
    private static string channelParametersCollectionProperty;
    private static string extendedProtectionPolicy;
    private static bool defaultSupportSecurityContextCancellation;
    public static string SecurityAlgorithmSuiteProperty { get; }
    public static string SecurityBindingElementProperty { get; }
    public static string IssuerAddressProperty { get; }
    public static string IssuerBindingProperty { get; }
    public static string SecureConversationSecurityBindingElementProperty { get; }
    public static string SupportSecurityContextCancellationProperty { get; }
    public static string MessageSecurityVersionProperty { get; }
    internal static string DefaultMessageSecurityVersionProperty { get; }
    public static string IssuerBindingContextProperty { get; }
    public static string TransportSchemeProperty { get; }
    public static string IsInitiatorProperty { get; }
    public static string TargetAddressProperty { get; }
    public static string ViaProperty { get; }
    public static string ListenUriProperty { get; }
    public static string AuditLogLocationProperty { get; }
    public static string SuppressAuditFailureProperty { get; }
    public static string MessageAuthenticationAuditLevelProperty { get; }
    public static string IsOutOfBandTokenProperty { get; }
    public static string PreferSslCertificateAuthenticatorProperty { get; }
    public static string SupportingTokenAttachmentModeProperty { get; }
    public static string MessageDirectionProperty { get; }
    public static string HttpAuthenticationSchemeProperty { get; }
    public static string IssuedSecurityTokenParametersProperty { get; }
    public static string PrivacyNoticeUriProperty { get; }
    public static string PrivacyNoticeVersionProperty { get; }
    public static string DuplexClientLocalAddressProperty { get; }
    public static string EndpointFilterTableProperty { get; }
    public static string ChannelParametersCollectionProperty { get; }
    public static string ExtendedProtectionPolicy { get; }
    public bool IsInitiator { get; }
    public SecurityAlgorithmSuite SecurityAlgorithmSuite { get; public set; }
    public SecurityBindingElement SecurityBindingElement { get; public set; }
    public EndpointAddress IssuerAddress { get; public set; }
    public Binding IssuerBinding { get; public set; }
    public SecurityBindingElement SecureConversationSecurityBindingElement { get; public set; }
    public SecurityTokenVersion MessageSecurityVersion { get; public set; }
    internal MessageSecurityVersion DefaultMessageSecurityVersion { get; internal set; }
    public string TransportScheme { get; public set; }
    internal bool SupportSecurityContextCancellation { get; internal set; }
    internal EndpointAddress DuplexClientLocalAddress { get; internal set; }
    public static string get_SecurityAlgorithmSuiteProperty();
    public static string get_SecurityBindingElementProperty();
    public static string get_IssuerAddressProperty();
    public static string get_IssuerBindingProperty();
    public static string get_SecureConversationSecurityBindingElementProperty();
    public static string get_SupportSecurityContextCancellationProperty();
    public static string get_MessageSecurityVersionProperty();
    internal static string get_DefaultMessageSecurityVersionProperty();
    public static string get_IssuerBindingContextProperty();
    public static string get_TransportSchemeProperty();
    public static string get_IsInitiatorProperty();
    public static string get_TargetAddressProperty();
    public static string get_ViaProperty();
    public static string get_ListenUriProperty();
    public static string get_AuditLogLocationProperty();
    public static string get_SuppressAuditFailureProperty();
    public static string get_MessageAuthenticationAuditLevelProperty();
    public static string get_IsOutOfBandTokenProperty();
    public static string get_PreferSslCertificateAuthenticatorProperty();
    public static string get_SupportingTokenAttachmentModeProperty();
    public static string get_MessageDirectionProperty();
    public static string get_HttpAuthenticationSchemeProperty();
    public static string get_IssuedSecurityTokenParametersProperty();
    public static string get_PrivacyNoticeUriProperty();
    public static string get_PrivacyNoticeVersionProperty();
    public static string get_DuplexClientLocalAddressProperty();
    public static string get_EndpointFilterTableProperty();
    public static string get_ChannelParametersCollectionProperty();
    public static string get_ExtendedProtectionPolicy();
    public bool get_IsInitiator();
    public SecurityAlgorithmSuite get_SecurityAlgorithmSuite();
    public void set_SecurityAlgorithmSuite(SecurityAlgorithmSuite value);
    public SecurityBindingElement get_SecurityBindingElement();
    public void set_SecurityBindingElement(SecurityBindingElement value);
    public EndpointAddress get_IssuerAddress();
    public void set_IssuerAddress(EndpointAddress value);
    public Binding get_IssuerBinding();
    public void set_IssuerBinding(Binding value);
    public SecurityBindingElement get_SecureConversationSecurityBindingElement();
    public void set_SecureConversationSecurityBindingElement(SecurityBindingElement value);
    public SecurityTokenVersion get_MessageSecurityVersion();
    public void set_MessageSecurityVersion(SecurityTokenVersion value);
    internal MessageSecurityVersion get_DefaultMessageSecurityVersion();
    internal void set_DefaultMessageSecurityVersion(MessageSecurityVersion value);
    public string get_TransportScheme();
    public void set_TransportScheme(string value);
    internal bool get_SupportSecurityContextCancellation();
    internal void set_SupportSecurityContextCancellation(bool value);
    internal EndpointAddress get_DuplexClientLocalAddress();
    internal void set_DuplexClientLocalAddress(EndpointAddress value);
    internal TValue GetPropertyOrDefault(string propertyName, TValue defaultValue);
    internal string InternalToString();
}
public static class System.ServiceModel.Security.Tokens.ServiceModelSecurityTokenTypes : object {
    private static string Namespace;
    public static string Spnego { get; }
    public static string MutualSslnego { get; }
    public static string AnonymousSslnego { get; }
    public static string SecurityContext { get; }
    public static string SecureConversation { get; }
    public static string SspiCredential { get; }
    public static string get_Spnego();
    public static string get_MutualSslnego();
    public static string get_AnonymousSslnego();
    public static string get_SecurityContext();
    public static string get_SecureConversation();
    public static string get_SspiCredential();
}
public class System.ServiceModel.Security.Tokens.SspiSecurityToken : SecurityToken {
    private string _id;
    private bool _allowUnauthenticatedCallers;
    private DateTime _effectiveTime;
    private DateTime _expirationTime;
    [CompilerGeneratedAttribute]
private TokenImpersonationLevel <ImpersonationLevel>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <AllowNtlm>k__BackingField;
    [CompilerGeneratedAttribute]
private NetworkCredential <NetworkCredential>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <ExtractGroupsForWindowsAccounts>k__BackingField;
    public string Id { get; }
    public DateTime ValidFrom { get; }
    public DateTime ValidTo { get; }
    public bool AllowUnauthenticatedCallers { get; }
    public TokenImpersonationLevel ImpersonationLevel { get; }
    public bool AllowNtlm { get; }
    public NetworkCredential NetworkCredential { get; }
    public bool ExtractGroupsForWindowsAccounts { get; }
    public ReadOnlyCollection`1<SecurityKey> SecurityKeys { get; }
    public SspiSecurityToken(TokenImpersonationLevel impersonationLevel, bool allowNtlm, NetworkCredential networkCredential);
    public SspiSecurityToken(NetworkCredential networkCredential, bool extractGroupsForWindowsAccounts, bool allowUnauthenticatedCallers);
    public virtual string get_Id();
    public virtual DateTime get_ValidFrom();
    public virtual DateTime get_ValidTo();
    public bool get_AllowUnauthenticatedCallers();
    [CompilerGeneratedAttribute]
public TokenImpersonationLevel get_ImpersonationLevel();
    [CompilerGeneratedAttribute]
public bool get_AllowNtlm();
    [CompilerGeneratedAttribute]
public NetworkCredential get_NetworkCredential();
    [CompilerGeneratedAttribute]
public bool get_ExtractGroupsForWindowsAccounts();
    public virtual ReadOnlyCollection`1<SecurityKey> get_SecurityKeys();
}
public class System.ServiceModel.Security.Tokens.SupportingTokenParameters : object {
    private Collection`1<SecurityTokenParameters> _signedEndorsing;
    [CompilerGeneratedAttribute]
private Collection`1<SecurityTokenParameters> <Endorsing>k__BackingField;
    [CompilerGeneratedAttribute]
private Collection`1<SecurityTokenParameters> <Signed>k__BackingField;
    [CompilerGeneratedAttribute]
private Collection`1<SecurityTokenParameters> <SignedEncrypted>k__BackingField;
    public Collection`1<SecurityTokenParameters> Endorsing { get; }
    public Collection`1<SecurityTokenParameters> SignedEndorsing { get; }
    public Collection`1<SecurityTokenParameters> Signed { get; }
    public Collection`1<SecurityTokenParameters> SignedEncrypted { get; }
    private SupportingTokenParameters(SupportingTokenParameters other);
    [CompilerGeneratedAttribute]
public Collection`1<SecurityTokenParameters> get_Endorsing();
    public Collection`1<SecurityTokenParameters> get_SignedEndorsing();
    [CompilerGeneratedAttribute]
public Collection`1<SecurityTokenParameters> get_Signed();
    [CompilerGeneratedAttribute]
public Collection`1<SecurityTokenParameters> get_SignedEncrypted();
    public void SetKeyDerivation(bool requireDerivedKeys);
    internal bool IsSetKeyDerivation(bool requireDerivedKeys);
    public virtual string ToString();
    public SupportingTokenParameters Clone();
    protected virtual SupportingTokenParameters CloneCore();
    internal bool IsEmpty();
}
internal static class System.ServiceModel.Security.Tokens.TokenReferenceStyleHelper : object {
    public static bool IsDefined(SecurityTokenReferenceStyle value);
    public static void Validate(SecurityTokenReferenceStyle value);
}
public class System.ServiceModel.Security.Tokens.UserNameSecurityTokenParameters : SecurityTokenParameters {
    protected internal bool HasAsymmetricKey { get; }
    protected internal bool SupportsClientAuthentication { get; }
    protected internal bool SupportsServerAuthentication { get; }
    protected internal bool SupportsClientWindowsIdentity { get; }
    protected UserNameSecurityTokenParameters(UserNameSecurityTokenParameters other);
    protected internal virtual bool get_HasAsymmetricKey();
    protected internal virtual bool get_SupportsClientAuthentication();
    protected internal virtual bool get_SupportsServerAuthentication();
    protected internal virtual bool get_SupportsClientWindowsIdentity();
    protected virtual SecurityTokenParameters CloneCore();
    protected internal virtual SecurityKeyIdentifierClause CreateKeyIdentifierClause(SecurityToken token, SecurityTokenReferenceStyle referenceStyle);
    protected internal virtual void InitializeSecurityTokenRequirement(SecurityTokenRequirement requirement);
}
public enum System.ServiceModel.Security.Tokens.X509KeyIdentifierClauseType : Enum {
    public int value__;
    public static X509KeyIdentifierClauseType Any;
    public static X509KeyIdentifierClauseType Thumbprint;
    public static X509KeyIdentifierClauseType IssuerSerial;
    public static X509KeyIdentifierClauseType SubjectKeyIdentifier;
    public static X509KeyIdentifierClauseType RawDataKeyIdentifier;
}
public class System.ServiceModel.Security.Tokens.X509SecurityTokenParameters : SecurityTokenParameters {
    internal static X509KeyIdentifierClauseType defaultX509ReferenceStyle;
    private X509KeyIdentifierClauseType _x509ReferenceStyle;
    protected internal bool HasAsymmetricKey { get; }
    public X509KeyIdentifierClauseType X509ReferenceStyle { get; public set; }
    protected internal bool SupportsClientAuthentication { get; }
    protected internal bool SupportsServerAuthentication { get; }
    protected internal bool SupportsClientWindowsIdentity { get; }
    protected X509SecurityTokenParameters(X509SecurityTokenParameters other);
    public X509SecurityTokenParameters(X509KeyIdentifierClauseType x509ReferenceStyle);
    public X509SecurityTokenParameters(X509KeyIdentifierClauseType x509ReferenceStyle, SecurityTokenInclusionMode inclusionMode);
    internal X509SecurityTokenParameters(X509KeyIdentifierClauseType x509ReferenceStyle, SecurityTokenInclusionMode inclusionMode, bool requireDerivedKeys);
    protected internal virtual bool get_HasAsymmetricKey();
    public X509KeyIdentifierClauseType get_X509ReferenceStyle();
    public void set_X509ReferenceStyle(X509KeyIdentifierClauseType value);
    protected internal virtual bool get_SupportsClientAuthentication();
    protected internal virtual bool get_SupportsServerAuthentication();
    protected internal virtual bool get_SupportsClientWindowsIdentity();
    protected virtual SecurityTokenParameters CloneCore();
    protected internal virtual SecurityKeyIdentifierClause CreateKeyIdentifierClause(SecurityToken token, SecurityTokenReferenceStyle referenceStyle);
    protected internal virtual void InitializeSecurityTokenRequirement(SecurityTokenRequirement requirement);
    public virtual string ToString();
}
internal static class System.ServiceModel.Security.Tokens.X509SecurityTokenReferenceStyleHelper : object {
    public static bool IsDefined(X509KeyIdentifierClauseType value);
    public static void Validate(X509KeyIdentifierClauseType value);
}
internal class System.ServiceModel.Security.TokenTracker : object {
    private bool _allowFirstTokenMismatch;
    public SupportingTokenAuthenticatorSpecification spec;
    [CompilerGeneratedAttribute]
private SecurityToken <Token>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsDerivedFrom>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsSigned>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsEncrypted>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsEndorsing>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <AlreadyReadEndorsingSignature>k__BackingField;
    public SecurityToken Token { get; public set; }
    public bool IsDerivedFrom { get; public set; }
    public bool IsSigned { get; public set; }
    public bool IsEncrypted { get; public set; }
    public bool IsEndorsing { get; public set; }
    public bool AlreadyReadEndorsingSignature { get; public set; }
    public TokenTracker(SupportingTokenAuthenticatorSpecification spec);
    public TokenTracker(SupportingTokenAuthenticatorSpecification spec, SecurityToken token, bool allowFirstTokenMismatch);
    [CompilerGeneratedAttribute]
public SecurityToken get_Token();
    [CompilerGeneratedAttribute]
public void set_Token(SecurityToken value);
    [CompilerGeneratedAttribute]
public bool get_IsDerivedFrom();
    [CompilerGeneratedAttribute]
public void set_IsDerivedFrom(bool value);
    [CompilerGeneratedAttribute]
public bool get_IsSigned();
    [CompilerGeneratedAttribute]
public void set_IsSigned(bool value);
    [CompilerGeneratedAttribute]
public bool get_IsEncrypted();
    [CompilerGeneratedAttribute]
public void set_IsEncrypted(bool value);
    [CompilerGeneratedAttribute]
public bool get_IsEndorsing();
    [CompilerGeneratedAttribute]
public void set_IsEndorsing(bool value);
    [CompilerGeneratedAttribute]
public bool get_AlreadyReadEndorsingSignature();
    [CompilerGeneratedAttribute]
public void set_AlreadyReadEndorsingSignature(bool value);
    public void RecordToken(SecurityToken token);
    private static bool AreTokensEqual(SecurityToken outOfBandToken, SecurityToken replyToken);
}
internal class System.ServiceModel.Security.TransportSecurityProtocol : SecurityProtocol {
    public TransportSecurityProtocol(TransportSecurityProtocolFactory factory, EndpointAddress target, Uri via);
    [AsyncStateMachineAttribute("System.ServiceModel.Security.TransportSecurityProtocol/<SecureOutgoingMessageAsync>d__1")]
public virtual Task`1<Message> SecureOutgoingMessageAsync(Message message, TimeSpan timeout);
    [AsyncStateMachineAttribute("System.ServiceModel.Security.TransportSecurityProtocol/<SecureOutgoingMessageAtInitiatorAsync>d__2")]
protected virtual Task`1<Message> SecureOutgoingMessageAtInitiatorAsync(Message message, string actor, TimeSpan timeout);
    internal void SetUpDelayedSecurityExecution(Message& message, string actor, IList`1<SupportingTokenSpecification> supportingTokens);
    public sealed virtual void VerifyIncomingMessage(Message& message, TimeSpan timeout);
    protected void AttachRecipientSecurityProperty(Message message, IList`1<SecurityToken> basicTokens, IList`1<SecurityToken> endorsingTokens, IList`1<SecurityToken> signedEndorsingTokens, IList`1<SecurityToken> signedTokens, Dictionary`2<SecurityToken, ReadOnlyCollection`1<IAuthorizationPolicy>> tokenPoliciesMapping);
    protected virtual void VerifyIncomingMessageCore(Message& message, TimeSpan timeout);
    [CompilerGeneratedAttribute]
[DebuggerHiddenAttribute]
private void <>n__0(Message securedMessage);
    [CompilerGeneratedAttribute]
[DebuggerHiddenAttribute]
private void <>n__1(Message message);
}
internal class System.ServiceModel.Security.TransportSecurityProtocolFactory : SecurityProtocolFactory {
    public bool SupportsDuplex { get; }
    public bool SupportsReplayDetection { get; }
    internal TransportSecurityProtocolFactory(TransportSecurityProtocolFactory factory);
    public virtual bool get_SupportsDuplex();
    public virtual bool get_SupportsReplayDetection();
    protected virtual SecurityProtocol OnCreateSecurityProtocol(EndpointAddress target, Uri via, object listenerSecurityState, TimeSpan timeout);
}
public class System.ServiceModel.Security.TripleDesSecurityAlgorithmSuite : SecurityAlgorithmSuite {
    public string DefaultCanonicalizationAlgorithm { get; }
    public string DefaultDigestAlgorithm { get; }
    public string DefaultEncryptionAlgorithm { get; }
    public int DefaultEncryptionKeyDerivationLength { get; }
    public string DefaultSymmetricKeyWrapAlgorithm { get; }
    public string DefaultAsymmetricKeyWrapAlgorithm { get; }
    public string DefaultSymmetricSignatureAlgorithm { get; }
    public string DefaultAsymmetricSignatureAlgorithm { get; }
    public int DefaultSignatureKeyDerivationLength { get; }
    public int DefaultSymmetricKeyLength { get; }
    internal XmlDictionaryString DefaultCanonicalizationAlgorithmDictionaryString { get; }
    internal XmlDictionaryString DefaultDigestAlgorithmDictionaryString { get; }
    internal XmlDictionaryString DefaultEncryptionAlgorithmDictionaryString { get; }
    internal XmlDictionaryString DefaultSymmetricKeyWrapAlgorithmDictionaryString { get; }
    internal XmlDictionaryString DefaultAsymmetricKeyWrapAlgorithmDictionaryString { get; }
    internal XmlDictionaryString DefaultSymmetricSignatureAlgorithmDictionaryString { get; }
    internal XmlDictionaryString DefaultAsymmetricSignatureAlgorithmDictionaryString { get; }
    public virtual string get_DefaultCanonicalizationAlgorithm();
    public virtual string get_DefaultDigestAlgorithm();
    public virtual string get_DefaultEncryptionAlgorithm();
    public virtual int get_DefaultEncryptionKeyDerivationLength();
    public virtual string get_DefaultSymmetricKeyWrapAlgorithm();
    public virtual string get_DefaultAsymmetricKeyWrapAlgorithm();
    public virtual string get_DefaultSymmetricSignatureAlgorithm();
    public virtual string get_DefaultAsymmetricSignatureAlgorithm();
    public virtual int get_DefaultSignatureKeyDerivationLength();
    public virtual int get_DefaultSymmetricKeyLength();
    public virtual bool IsSymmetricKeyLengthSupported(int length);
    public virtual bool IsAsymmetricKeyLengthSupported(int length);
    internal virtual XmlDictionaryString get_DefaultCanonicalizationAlgorithmDictionaryString();
    internal virtual XmlDictionaryString get_DefaultDigestAlgorithmDictionaryString();
    internal virtual XmlDictionaryString get_DefaultEncryptionAlgorithmDictionaryString();
    internal virtual XmlDictionaryString get_DefaultSymmetricKeyWrapAlgorithmDictionaryString();
    internal virtual XmlDictionaryString get_DefaultAsymmetricKeyWrapAlgorithmDictionaryString();
    internal virtual XmlDictionaryString get_DefaultSymmetricSignatureAlgorithmDictionaryString();
    internal virtual XmlDictionaryString get_DefaultAsymmetricSignatureAlgorithmDictionaryString();
    public virtual string ToString();
}
internal abstract class System.ServiceModel.Security.TrustDriver : object {
    public bool IsIssuedTokensSupported { get; }
    public string IssuedTokensHeaderName { get; }
    public string IssuedTokensHeaderNamespace { get; }
    public bool IsSessionSupported { get; }
    public XmlDictionaryString RequestSecurityTokenAction { get; }
    public XmlDictionaryString RequestSecurityTokenResponseAction { get; }
    public XmlDictionaryString RequestSecurityTokenResponseFinalAction { get; }
    public string RequestTypeClose { get; }
    public string RequestTypeIssue { get; }
    public string RequestTypeRenew { get; }
    public string ComputedKeyAlgorithm { get; }
    public SecurityStandardsManager StandardsManager { get; }
    public XmlDictionaryString Namespace { get; }
    public virtual bool get_IsIssuedTokensSupported();
    public virtual string get_IssuedTokensHeaderName();
    public virtual string get_IssuedTokensHeaderNamespace();
    public virtual bool get_IsSessionSupported();
    public abstract virtual XmlDictionaryString get_RequestSecurityTokenAction();
    public abstract virtual XmlDictionaryString get_RequestSecurityTokenResponseAction();
    public abstract virtual XmlDictionaryString get_RequestSecurityTokenResponseFinalAction();
    public virtual string get_RequestTypeClose();
    public abstract virtual string get_RequestTypeIssue();
    public virtual string get_RequestTypeRenew();
    public abstract virtual string get_ComputedKeyAlgorithm();
    public abstract virtual SecurityStandardsManager get_StandardsManager();
    public abstract virtual XmlDictionaryString get_Namespace();
    public abstract virtual RequestSecurityToken CreateRequestSecurityToken(XmlReader reader);
    public abstract virtual RequestSecurityTokenResponse CreateRequestSecurityTokenResponse(XmlReader reader);
    public abstract virtual RequestSecurityTokenResponseCollection CreateRequestSecurityTokenResponseCollection(XmlReader xmlReader);
    public abstract virtual bool IsAtRequestSecurityTokenResponse(XmlReader reader);
    public abstract virtual bool IsAtRequestSecurityTokenResponseCollection(XmlReader reader);
    public abstract virtual bool IsRequestedSecurityTokenElement(string name, string nameSpace);
    public abstract virtual bool IsRequestedProofTokenElement(string name, string nameSpace);
    public abstract virtual T GetAppliesTo(RequestSecurityToken rst, XmlObjectSerializer serializer);
    public abstract virtual T GetAppliesTo(RequestSecurityTokenResponse rstr, XmlObjectSerializer serializer);
    public abstract virtual void GetAppliesToQName(RequestSecurityToken rst, String& localName, String& namespaceUri);
    public abstract virtual void GetAppliesToQName(RequestSecurityTokenResponse rstr, String& localName, String& namespaceUri);
    public abstract virtual bool IsAppliesTo(string localName, string namespaceUri);
    public abstract virtual Byte[] GetAuthenticator(RequestSecurityTokenResponse rstr);
    public abstract virtual BinaryNegotiation GetBinaryNegotiation(RequestSecurityToken rst);
    public abstract virtual BinaryNegotiation GetBinaryNegotiation(RequestSecurityTokenResponse rstr);
    public abstract virtual SecurityToken GetEntropy(RequestSecurityToken rst, SecurityTokenResolver resolver);
    public abstract virtual SecurityToken GetEntropy(RequestSecurityTokenResponse rstr, SecurityTokenResolver resolver);
    public abstract virtual GenericXmlSecurityToken GetIssuedToken(RequestSecurityTokenResponse rstr, SecurityTokenResolver resolver, IList`1<SecurityTokenAuthenticator> allowedAuthenticators, SecurityKeyEntropyMode keyEntropyMode, Byte[] requestorEntropy, string expectedTokenType, ReadOnlyCollection`1<IAuthorizationPolicy> authorizationPolicies, int defaultKeySize, bool isBearerKeyType);
    public abstract virtual void WriteRequestSecurityToken(RequestSecurityToken rst, XmlWriter w);
    public abstract virtual void WriteRequestSecurityTokenResponse(RequestSecurityTokenResponse rstr, XmlWriter w);
    public abstract virtual void WriteRequestSecurityTokenResponseCollection(RequestSecurityTokenResponseCollection rstrCollection, XmlWriter writer);
}
public abstract class System.ServiceModel.Security.TrustVersion : object {
    private XmlDictionaryString _prefix;
    [CompilerGeneratedAttribute]
private XmlDictionaryString <Namespace>k__BackingField;
    public XmlDictionaryString Namespace { get; }
    public XmlDictionaryString Prefix { get; }
    public static TrustVersion Default { get; }
    public static TrustVersion WSTrustFeb2005 { get; }
    public static TrustVersion WSTrust13 { get; }
    internal TrustVersion(XmlDictionaryString ns, XmlDictionaryString prefix);
    [CompilerGeneratedAttribute]
public XmlDictionaryString get_Namespace();
    public XmlDictionaryString get_Prefix();
    public static TrustVersion get_Default();
    public static TrustVersion get_WSTrustFeb2005();
    public static TrustVersion get_WSTrust13();
}
public class System.ServiceModel.Security.UserNamePasswordClientCredential : object {
    private string _userName;
    private string _password;
    private bool _isReadOnly;
    public string UserName { get; public set; }
    public string Password { get; public set; }
    internal UserNamePasswordClientCredential(UserNamePasswordClientCredential other);
    public string get_UserName();
    public void set_UserName(string value);
    public string get_Password();
    public void set_Password(string value);
    internal void MakeReadOnly();
    private void ThrowIfImmutable();
}
public class System.ServiceModel.Security.WindowsClientCredential : object {
    internal static TokenImpersonationLevel DefaultImpersonationLevel;
    private TokenImpersonationLevel _allowedImpersonationLevel;
    private NetworkCredential _windowsCredentials;
    private bool _allowNtlm;
    private bool _isReadOnly;
    public TokenImpersonationLevel AllowedImpersonationLevel { get; public set; }
    public NetworkCredential ClientCredential { get; public set; }
    [ObsoleteAttribute("This property is deprecated and is maintained for backward compatibility only. The local machine policy will be used to determine if NTLM should be used.")]
public bool AllowNtlm { get; public set; }
    internal WindowsClientCredential(WindowsClientCredential other);
    public TokenImpersonationLevel get_AllowedImpersonationLevel();
    public void set_AllowedImpersonationLevel(TokenImpersonationLevel value);
    public NetworkCredential get_ClientCredential();
    public void set_ClientCredential(NetworkCredential value);
    public bool get_AllowNtlm();
    public void set_AllowNtlm(bool value);
    internal void MakeReadOnly();
    private void ThrowIfImmutable();
}
internal class System.ServiceModel.Security.WrappedXmlDictionaryWriter : XmlDictionaryWriter {
    private XmlDictionaryWriter _innerWriter;
    private int _index;
    private bool _insertId;
    private bool _isStrReferenceElement;
    private string _id;
    public WriteState WriteState { get; }
    public WrappedXmlDictionaryWriter(XmlDictionaryWriter writer, string id);
    public virtual void WriteStartAttribute(string prefix, string localName, string namespaceUri);
    public virtual void WriteStartElement(string prefix, string localName, string namespaceUri);
    public virtual void Close();
    public virtual void Flush();
    public virtual string LookupPrefix(string ns);
    public virtual void WriteBase64(Byte[] buffer, int index, int count);
    public virtual void WriteCData(string text);
    public virtual void WriteCharEntity(char ch);
    public virtual void WriteChars(Char[] buffer, int index, int count);
    public virtual void WriteComment(string text);
    public virtual void WriteDocType(string name, string pubid, string sysid, string subset);
    public virtual void WriteEndAttribute();
    public virtual void WriteEndDocument();
    public virtual void WriteEndElement();
    public virtual void WriteEntityRef(string name);
    public virtual void WriteFullEndElement();
    public virtual void WriteProcessingInstruction(string name, string text);
    public virtual void WriteRaw(string data);
    public virtual void WriteRaw(Char[] buffer, int index, int count);
    public virtual void WriteStartDocument(bool standalone);
    public virtual void WriteStartDocument();
    public virtual WriteState get_WriteState();
    public virtual void WriteString(string text);
    public virtual void WriteSurrogateCharEntity(char lowChar, char highChar);
    public virtual void WriteWhitespace(string ws);
}
internal class System.ServiceModel.Security.WrapperSecurityCommunicationObject : CommunicationObject {
    private ISecurityCommunicationObject _innerCommunicationObject;
    protected TimeSpan DefaultCloseTimeout { get; }
    protected TimeSpan DefaultOpenTimeout { get; }
    public WrapperSecurityCommunicationObject(ISecurityCommunicationObject innerCommunicationObject);
    protected virtual Type GetCommunicationObjectType();
    protected virtual TimeSpan get_DefaultCloseTimeout();
    protected virtual TimeSpan get_DefaultOpenTimeout();
    protected virtual void OnAbort();
    protected virtual IAsyncResult OnBeginClose(TimeSpan timeout, AsyncCallback callback, object state);
    protected virtual IAsyncResult OnBeginOpen(TimeSpan timeout, AsyncCallback callback, object state);
    protected virtual void OnClose(TimeSpan timeout);
    protected virtual void OnClosed();
    protected virtual void OnClosing();
    protected virtual void OnEndClose(IAsyncResult result);
    protected virtual void OnEndOpen(IAsyncResult result);
    protected virtual void OnFaulted();
    protected virtual void OnOpen(TimeSpan timeout);
    protected virtual void OnOpened();
    protected virtual void OnOpening();
    internal void ThrowIfDisposedOrImmutable();
    protected internal virtual Task OnCloseAsync(TimeSpan timeout);
    protected internal virtual Task OnOpenAsync(TimeSpan timeout);
}
internal class System.ServiceModel.Security.WSKeyInfoSerializer : KeyInfoSerializer {
    public WSKeyInfoSerializer(bool emitBspRequiredAttributes, DictionaryManager dictionaryManager, TrustDictionary trustDictionary, SecurityTokenSerializer innerSecurityTokenSerializer, SecurityVersion securityVersion, SecureConversationVersion secureConversationVersion);
    private static Func`2<KeyInfoSerializer, IEnumerable`1<SerializerEntries>> CreateAdditionalEntries(SecurityVersion securityVersion, SecureConversationVersion secureConversationVersion);
}
internal abstract class System.ServiceModel.Security.WSSecureConversation : SerializerEntries {
    private DerivedKeyTokenEntry _derivedKeyEntry;
    [CompilerGeneratedAttribute]
private WSSecurityTokenSerializer <WSSecurityTokenSerializer>k__BackingField;
    public SecureConversationDictionary SerializerDictionary { get; }
    public WSSecurityTokenSerializer WSSecurityTokenSerializer { get; }
    public string DerivationAlgorithm { get; }
    protected WSSecureConversation(WSSecurityTokenSerializer tokenSerializer, int maxKeyDerivationOffset, int maxKeyDerivationLabelLength, int maxKeyDerivationNonceLength);
    public abstract virtual SecureConversationDictionary get_SerializerDictionary();
    [CompilerGeneratedAttribute]
public WSSecurityTokenSerializer get_WSSecurityTokenSerializer();
    public virtual void PopulateTokenEntries(IList`1<TokenEntry> tokenEntryList);
    public virtual bool IsAtDerivedKeyToken(XmlDictionaryReader reader);
    public virtual void ReadDerivedKeyTokenParameters(XmlDictionaryReader reader, SecurityTokenResolver tokenResolver, String& id, String& derivationAlgorithm, String& label, Int32& length, Byte[]& nonce, Int32& offset, Int32& generation, SecurityKeyIdentifierClause& tokenToDeriveIdentifier, SecurityToken& tokenToDerive);
    public virtual SecurityToken CreateDerivedKeyToken(string id, string derivationAlgorithm, string label, int length, Byte[] nonce, int offset, int generation, SecurityKeyIdentifierClause tokenToDeriveIdentifier, SecurityToken tokenToDerive);
    public virtual string get_DerivationAlgorithm();
}
internal class System.ServiceModel.Security.WSSecureConversationDec2005 : WSSecureConversation {
    private SecurityStateEncoder _securityStateEncoder;
    private IList`1<Type> _knownClaimTypes;
    public SecureConversationDictionary SerializerDictionary { get; }
    public string DerivationAlgorithm { get; }
    public WSSecureConversationDec2005(WSSecurityTokenSerializer tokenSerializer, SecurityStateEncoder securityStateEncoder, IEnumerable`1<Type> knownTypes, int maxKeyDerivationOffset, int maxKeyDerivationLabelLength, int maxKeyDerivationNonceLength);
    public virtual SecureConversationDictionary get_SerializerDictionary();
    public virtual void PopulateTokenEntries(IList`1<TokenEntry> tokenEntryList);
    public virtual string get_DerivationAlgorithm();
}
internal class System.ServiceModel.Security.WSSecureConversationFeb2005 : WSSecureConversation {
    private SecurityStateEncoder _securityStateEncoder;
    private IList`1<Type> _knownClaimTypes;
    public SecureConversationDictionary SerializerDictionary { get; }
    public WSSecureConversationFeb2005(WSSecurityTokenSerializer tokenSerializer, SecurityStateEncoder securityStateEncoder, IEnumerable`1<Type> knownTypes, int maxKeyDerivationOffset, int maxKeyDerivationLabelLength, int maxKeyDerivationNonceLength);
    public virtual SecureConversationDictionary get_SerializerDictionary();
    public virtual void PopulateTokenEntries(IList`1<TokenEntry> tokenEntryList);
}
internal class System.ServiceModel.Security.WSSecurityJan2004 : SerializerEntries {
    private SamlSerializer _samlSerializer;
    [CompilerGeneratedAttribute]
private WSSecurityTokenSerializer <WSSecurityTokenSerializer>k__BackingField;
    public WSSecurityTokenSerializer WSSecurityTokenSerializer { get; }
    public SamlSerializer SamlSerializer { get; }
    public WSSecurityJan2004(WSSecurityTokenSerializer tokenSerializer, SamlSerializer samlSerializer);
    [CompilerGeneratedAttribute]
public WSSecurityTokenSerializer get_WSSecurityTokenSerializer();
    public SamlSerializer get_SamlSerializer();
    protected void PopulateJan2004TokenEntries(IList`1<TokenEntry> tokenEntryList);
    public virtual void PopulateTokenEntries(IList`1<TokenEntry> tokenEntryList);
}
internal class System.ServiceModel.Security.WSSecurityOneDotOneReceiveSecurityHeader : WSSecurityOneDotZeroReceiveSecurityHeader {
    public WSSecurityOneDotOneReceiveSecurityHeader(Message message, string actor, bool mustUnderstand, bool relay, SecurityStandardsManager standardsManager, SecurityAlgorithmSuite algorithmSuite, int headerIndex, MessageDirection direction);
}
internal class System.ServiceModel.Security.WSSecurityOneDotOneSendSecurityHeader : WSSecurityOneDotZeroSendSecurityHeader {
    public WSSecurityOneDotOneSendSecurityHeader(Message message, string actor, bool mustUnderstand, bool relay, SecurityStandardsManager standardsManager, SecurityAlgorithmSuite algorithmSuite, MessageDirection direction);
}
internal class System.ServiceModel.Security.WSSecurityOneDotZeroReceiveSecurityHeader : ReceiveSecurityHeader {
    public WSSecurityOneDotZeroReceiveSecurityHeader(Message message, string actor, bool mustUnderstand, bool relay, SecurityStandardsManager standardsManager, SecurityAlgorithmSuite algorithmSuite, int headerIndex, MessageDirection transferDirection);
    protected virtual bool IsReaderAtReferenceList(XmlDictionaryReader reader);
    protected virtual bool IsReaderAtSignature(XmlDictionaryReader reader);
    protected virtual void EnsureDecryptionComplete();
    protected virtual bool IsReaderAtEncryptedKey(XmlDictionaryReader reader);
    protected virtual bool IsReaderAtEncryptedData(XmlDictionaryReader reader);
    protected virtual bool IsReaderAtSecurityTokenReference(XmlDictionaryReader reader);
}
internal class System.ServiceModel.Security.WSSecurityOneDotZeroSendSecurityHeader : SendSecurityHeader {
    private HashStream _hashStream;
    private SignedXml _signedXml;
    private KeyedHashAlgorithm _signingKey;
    private MessagePartSpecification _effectiveSignatureParts;
    private Stream _toHeaderStream;
    private string _toHeaderId;
    protected string EncryptionAlgorithm { get; }
    protected XmlDictionaryString EncryptionAlgorithmDictionaryString { get; }
    public WSSecurityOneDotZeroSendSecurityHeader(Message message, string actor, bool mustUnderstand, bool relay, SecurityStandardsManager standardsManager, SecurityAlgorithmSuite algorithmSuite, MessageDirection direction);
    protected string get_EncryptionAlgorithm();
    protected XmlDictionaryString get_EncryptionAlgorithmDictionaryString();
    private void AddEncryptionReference(MessageHeader header, string headerId, IPrefixGenerator prefixGenerator, bool sign, MemoryStream& plainTextStream, String& encryptedDataId);
    private void AddSignatureReference(SecurityToken token, int position, SecurityTokenAttachmentMode mode);
    private void AddPrimaryTokenSignatureReference(SecurityToken token, SecurityTokenParameters securityTokenParameters);
    private void AddTokenSignatureReference(SecurityToken token, SecurityKeyIdentifierClause keyIdentifierClause, bool strTransformEnabled);
    private void AddSignatureReference(SendSecurityHeaderElement[] elements);
    private void AddSignatureReference(SecurityToken[] tokens, SecurityTokenAttachmentMode mode);
    private string GetSignatureHash(MessageHeader header, string headerId, IPrefixGenerator prefixGenerator, XmlDictionaryWriter writer, Byte[]& hash);
    private string GetSignatureStream(MessageHeader header, string headerId, IPrefixGenerator prefixGenerator, XmlDictionaryWriter writer, Stream& stream);
    private void AddReference(string id, Stream contents);
    private void AddSignatureReference(MessageHeader header, string headerId, IPrefixGenerator prefixGenerator, XmlDictionaryWriter writer);
    private void ApplySecurityAndWriteHeader(MessageHeader header, string headerId, XmlDictionaryWriter writer, IPrefixGenerator prefixGenerator);
    public virtual void ApplySecurityAndWriteHeaders(MessageHeaders headers, XmlDictionaryWriter writer, IPrefixGenerator prefixGenerator);
    private static bool CanCanonicalizeAndFragment(XmlDictionaryWriter writer);
    public virtual void ApplyBodySecurity(XmlDictionaryWriter writer, IPrefixGenerator prefixGenerator);
    protected virtual ISignatureValueSecurityElement CompletePrimarySignatureCore(SendSecurityHeaderElement[] signatureConfirmations, SecurityToken[] signedEndorsingTokens, SecurityToken[] signedTokens, SendSecurityHeaderElement[] basicTokens, bool isPrimarySignature);
    private HashStream TakeHashStream();
    private XmlDictionaryWriter TakeUtf8Writer();
    private MessagePartProtectionMode GetProtectionMode(MessageHeader header);
    protected virtual void StartPrimarySignatureCore(SecurityToken token, SecurityKeyIdentifier keyIdentifier, MessagePartSpecification signatureParts, bool generateTargettableSignature);
    private void GetSigningAlgorithm(SecurityKey signatureKey, string algorithmName, KeyedHashAlgorithm& symmetricAlgorithm, AsymmetricAlgorithm& asymmetricAlgorithm);
    protected virtual ISignatureValueSecurityElement CreateSupportingSignature(SecurityToken token, SecurityKeyIdentifier identifier);
    protected virtual ISignatureValueSecurityElement CreateSupportingSignature(SecurityToken token, SecurityKeyIdentifier identifier, ISecurityElement elementToSign);
    private void SetKeyInfo(SignedXml signedXml, SecurityKeyIdentifier identifier);
    protected virtual void WriteSecurityTokenReferencyEntry(XmlDictionaryWriter writer, SecurityToken securityToken, SecurityTokenParameters securityTokenParameters);
}
internal abstract class System.ServiceModel.Security.WSSecurityPolicy : object {
    public static ContractDescription NullContract;
    public static ServiceEndpoint NullServiceEndpoint;
    public static XmlDocument doc;
    public static string WsspPrefix;
    public static string WspNamespace;
    public static string Wsp15Namespace;
    public static string WspPrefix;
    public static string MsspNamespace;
    public static string MsspPrefix;
    public static string PolicyName;
    public static string OptionalName;
    public static string TrueName;
    public static string FalseName;
    public static string SymmetricBindingName;
    public static string AsymmetricBindingName;
    public static string TransportBindingName;
    public static string OnlySignEntireHeadersAndBodyName;
    public static string ProtectionTokenName;
    public static string InitiatorTokenName;
    public static string RecipientTokenName;
    public static string TransportTokenName;
    public static string AlgorithmSuiteName;
    public static string LaxName;
    public static string LaxTsLastName;
    public static string LaxTsFirstName;
    public static string StrictName;
    public static string IncludeTimestampName;
    public static string EncryptBeforeSigningName;
    public static string ProtectTokens;
    public static string EncryptSignatureName;
    public static string SignedSupportingTokensName;
    public static string EndorsingSupportingTokensName;
    public static string SignedEndorsingSupportingTokensName;
    public static string Wss10Name;
    public static string MustSupportRefKeyIdentifierName;
    public static string MustSupportRefIssuerSerialName;
    public static string MustSupportRefThumbprintName;
    public static string MustSupportRefEncryptedKeyName;
    public static string RequireSignatureConfirmationName;
    public static string MustSupportIssuedTokensName;
    public static string RequireClientEntropyName;
    public static string RequireServerEntropyName;
    public static string Wss11Name;
    public static string Trust10Name;
    public static string Trust13Name;
    public static string RequireAppliesTo;
    public static string SignedPartsName;
    public static string EncryptedPartsName;
    public static string BodyName;
    public static string HeaderName;
    public static string NameName;
    public static string NamespaceName;
    public static string Basic128Name;
    public static string Basic192Name;
    public static string Basic256Name;
    public static string TripleDesName;
    public static string Basic128Rsa15Name;
    public static string Basic192Rsa15Name;
    public static string Basic256Rsa15Name;
    public static string TripleDesRsa15Name;
    public static string Basic128Sha256Name;
    public static string Basic192Sha256Name;
    public static string Basic256Sha256Name;
    public static string TripleDesSha256Name;
    public static string Basic128Sha256Rsa15Name;
    public static string Basic192Sha256Rsa15Name;
    public static string Basic256Sha256Rsa15Name;
    public static string TripleDesSha256Rsa15Name;
    public static string IncludeTokenName;
    public static string KerberosTokenName;
    public static string X509TokenName;
    public static string IssuedTokenName;
    public static string UsernameTokenName;
    public static string RsaTokenName;
    public static string KeyValueTokenName;
    public static string SpnegoContextTokenName;
    public static string SslContextTokenName;
    public static string SecureConversationTokenName;
    public static string WssGssKerberosV5ApReqToken11Name;
    public static string RequireDerivedKeysName;
    public static string RequireIssuerSerialReferenceName;
    public static string RequireKeyIdentifierReferenceName;
    public static string RequireThumbprintReferenceName;
    public static string WssX509V3Token10Name;
    public static string WssUsernameToken10Name;
    public static string RequestSecurityTokenTemplateName;
    public static string RequireExternalReferenceName;
    public static string RequireInternalReferenceName;
    public static string IssuerName;
    public static string RequireClientCertificateName;
    public static string MustNotSendCancelName;
    public static string MustNotSendAmendName;
    public static string MustNotSendRenewName;
    public static string LayoutName;
    public static string BootstrapPolicyName;
    public static string HttpsTokenName;
    public static string HttpBasicAuthenticationName;
    public static string HttpDigestAuthenticationName;
    private static WSSecurityPolicy();
}
public class System.ServiceModel.Security.WSSecurityTokenSerializer : SecurityTokenSerializer {
    private static int DefaultMaximumKeyDerivationOffset;
    private static int DefaultMaximumKeyDerivationLabelLength;
    private static int DefaultMaximumKeyDerivationNonceLength;
    private static WSSecurityTokenSerializer s_instance;
    private List`1<SerializerEntries> _serializerEntries;
    private WSSecureConversation _secureConversation;
    private List`1<TokenEntry> _tokenEntries;
    private int _maximumKeyDerivationNonceLength;
    private KeyInfoSerializer _keyInfoSerializer;
    [CompilerGeneratedAttribute]
private bool <EmitBspRequiredAttributes>k__BackingField;
    [CompilerGeneratedAttribute]
private SecurityVersion <SecurityVersion>k__BackingField;
    [CompilerGeneratedAttribute]
private int <MaximumKeyDerivationOffset>k__BackingField;
    [CompilerGeneratedAttribute]
private int <MaximumKeyDerivationLabelLength>k__BackingField;
    public static WSSecurityTokenSerializer DefaultInstance { get; }
    public bool EmitBspRequiredAttributes { get; }
    public SecurityVersion SecurityVersion { get; }
    public int MaximumKeyDerivationOffset { get; }
    public int MaximumKeyDerivationLabelLength { get; }
    public int MaximumKeyDerivationNonceLength { get; }
    public WSSecurityTokenSerializer(bool emitBspRequiredAttributes);
    public WSSecurityTokenSerializer(SecurityVersion securityVersion);
    public WSSecurityTokenSerializer(SecurityVersion securityVersion, bool emitBspRequiredAttributes);
    public WSSecurityTokenSerializer(SecurityVersion securityVersion, bool emitBspRequiredAttributes, SamlSerializer samlSerializer);
    public WSSecurityTokenSerializer(SecurityVersion securityVersion, bool emitBspRequiredAttributes, SamlSerializer samlSerializer, SecurityStateEncoder securityStateEncoder, IEnumerable`1<Type> knownTypes);
    public WSSecurityTokenSerializer(SecurityVersion securityVersion, TrustVersion trustVersion, SecureConversationVersion secureConversationVersion, bool emitBspRequiredAttributes, SamlSerializer samlSerializer, SecurityStateEncoder securityStateEncoder, IEnumerable`1<Type> knownTypes);
    public WSSecurityTokenSerializer(SecurityVersion securityVersion, bool emitBspRequiredAttributes, SamlSerializer samlSerializer, SecurityStateEncoder securityStateEncoder, IEnumerable`1<Type> knownTypes, int maximumKeyDerivationOffset, int maximumKeyDerivationLabelLength, int maximumKeyDerivationNonceLength);
    public WSSecurityTokenSerializer(SecurityVersion securityVersion, TrustVersion trustVersion, SecureConversationVersion secureConversationVersion, bool emitBspRequiredAttributes, SamlSerializer samlSerializer, SecurityStateEncoder securityStateEncoder, IEnumerable`1<Type> knownTypes, int maximumKeyDerivationOffset, int maximumKeyDerivationLabelLength, int maximumKeyDerivationNonceLength);
    public static WSSecurityTokenSerializer get_DefaultInstance();
    [CompilerGeneratedAttribute]
public bool get_EmitBspRequiredAttributes();
    [CompilerGeneratedAttribute]
public SecurityVersion get_SecurityVersion();
    [CompilerGeneratedAttribute]
public int get_MaximumKeyDerivationOffset();
    [CompilerGeneratedAttribute]
public int get_MaximumKeyDerivationLabelLength();
    public int get_MaximumKeyDerivationNonceLength();
    private bool ShouldWrapException(Exception e);
    protected virtual bool CanReadTokenCore(XmlReader reader);
    protected virtual SecurityToken ReadTokenCore(XmlReader reader, SecurityTokenResolver tokenResolver);
    protected virtual bool CanWriteTokenCore(SecurityToken token);
    protected virtual void WriteTokenCore(XmlWriter writer, SecurityToken token);
    protected virtual bool CanReadKeyIdentifierCore(XmlReader reader);
    protected virtual SecurityKeyIdentifier ReadKeyIdentifierCore(XmlReader reader);
    protected virtual bool CanWriteKeyIdentifierCore(SecurityKeyIdentifier keyIdentifier);
    protected virtual void WriteKeyIdentifierCore(XmlWriter writer, SecurityKeyIdentifier keyIdentifier);
    protected virtual bool CanReadKeyIdentifierClauseCore(XmlReader reader);
    protected virtual SecurityKeyIdentifierClause ReadKeyIdentifierClauseCore(XmlReader reader);
    protected virtual bool CanWriteKeyIdentifierClauseCore(SecurityKeyIdentifierClause keyIdentifierClause);
    protected virtual void WriteKeyIdentifierClauseCore(XmlWriter writer, SecurityKeyIdentifierClause keyIdentifierClause);
    internal Type[] GetTokenTypes(string tokenTypeUri);
    protected internal virtual string GetTokenTypeUri(Type tokenType);
    public virtual bool TryCreateKeyIdentifierClauseFromTokenXml(XmlElement element, SecurityTokenReferenceStyle tokenReferenceStyle, SecurityKeyIdentifierClause& securityKeyIdentifierClause);
    public virtual SecurityKeyIdentifierClause CreateKeyIdentifierClauseFromTokenXml(XmlElement element, SecurityTokenReferenceStyle tokenReferenceStyle);
}
internal class System.ServiceModel.Security.WSSecurityXXX2005 : WSSecurityJan2004 {
    public WSSecurityXXX2005(WSSecurityTokenSerializer tokenSerializer, SamlSerializer samlSerializer);
    public virtual void PopulateTokenEntries(IList`1<TokenEntry> tokenEntryList);
}
internal abstract class System.ServiceModel.Security.WSTrust : SerializerEntries {
    [CompilerGeneratedAttribute]
private WSSecurityTokenSerializer <WSSecurityTokenSerializer>k__BackingField;
    public WSSecurityTokenSerializer WSSecurityTokenSerializer { get; }
    public TrustDictionary SerializerDictionary { get; }
    public WSTrust(WSSecurityTokenSerializer tokenSerializer);
    [CompilerGeneratedAttribute]
public WSSecurityTokenSerializer get_WSSecurityTokenSerializer();
    public abstract virtual TrustDictionary get_SerializerDictionary();
    public virtual void PopulateTokenEntries(IList`1<TokenEntry> tokenEntryList);
}
internal class System.ServiceModel.Security.WSTrustDec2005 : WSTrustFeb2005 {
    public TrustDictionary SerializerDictionary { get; }
    public WSTrustDec2005(WSSecurityTokenSerializer tokenSerializer);
    public virtual TrustDictionary get_SerializerDictionary();
}
internal class System.ServiceModel.Security.WSTrustFeb2005 : WSTrust {
    public TrustDictionary SerializerDictionary { get; }
    public WSTrustFeb2005(WSSecurityTokenSerializer tokenSerializer);
    public virtual TrustDictionary get_SerializerDictionary();
}
internal abstract class System.ServiceModel.Security.WSUtilitySpecificationVersion : object {
    [CompilerGeneratedAttribute]
private static String[] <AcceptedDateTimeFormats>k__BackingField;
    [CompilerGeneratedAttribute]
private XmlDictionaryString <NamespaceUri>k__BackingField;
    internal static String[] AcceptedDateTimeFormats { get; }
    public static WSUtilitySpecificationVersion Default { get; }
    internal XmlDictionaryString NamespaceUri { get; }
    public static WSUtilitySpecificationVersion OneDotZero { get; }
    internal WSUtilitySpecificationVersion(XmlDictionaryString namespaceUri);
    private static WSUtilitySpecificationVersion();
    [CompilerGeneratedAttribute]
internal static String[] get_AcceptedDateTimeFormats();
    public static WSUtilitySpecificationVersion get_Default();
    [CompilerGeneratedAttribute]
internal XmlDictionaryString get_NamespaceUri();
    public static WSUtilitySpecificationVersion get_OneDotZero();
    internal abstract virtual bool IsReaderAtTimestamp(XmlDictionaryReader reader);
    internal abstract virtual SecurityTimestamp ReadTimestamp(XmlDictionaryReader reader, string digestAlgorithm, SignatureResourcePool resourcePool);
    internal abstract virtual void WriteTimestamp(XmlDictionaryWriter writer, SecurityTimestamp timestamp);
    internal abstract virtual void WriteTimestampCanonicalForm(Stream stream, SecurityTimestamp timestamp, Byte[] buffer);
}
public class System.ServiceModel.Security.X509CertificateInitiatorClientCredential : object {
    internal static StoreLocation DefaultStoreLocation;
    internal static StoreName DefaultStoreName;
    internal static X509FindType DefaultFindType;
    private X509Certificate2 _certificate;
    private bool _isReadOnly;
    internal bool CloneCertificate { get; }
    public X509Certificate2 Certificate { get; public set; }
    internal X509CertificateInitiatorClientCredential(X509CertificateInitiatorClientCredential other);
    internal bool get_CloneCertificate();
    public X509Certificate2 get_Certificate();
    public void set_Certificate(X509Certificate2 value);
    public void SetCertificate(string subjectName, StoreLocation storeLocation, StoreName storeName);
    public void SetCertificate(StoreLocation storeLocation, StoreName storeName, X509FindType findType, object findValue);
    internal void MakeReadOnly();
    private void ThrowIfImmutable();
}
public class System.ServiceModel.Security.X509CertificateRecipientClientCredential : object {
    private X509ServiceCertificateAuthentication _sslCertificateAuthentication;
    internal static StoreLocation DefaultStoreLocation;
    internal static StoreName DefaultStoreName;
    internal static X509FindType DefaultFindType;
    private X509Certificate2 _defaultCertificate;
    private bool _isReadOnly;
    [CompilerGeneratedAttribute]
private Dictionary`2<Uri, X509Certificate2> <ScopedCertificates>k__BackingField;
    [CompilerGeneratedAttribute]
private X509ServiceCertificateAuthentication <Authentication>k__BackingField;
    public X509Certificate2 DefaultCertificate { get; public set; }
    public Dictionary`2<Uri, X509Certificate2> ScopedCertificates { get; }
    public X509ServiceCertificateAuthentication Authentication { get; }
    public X509ServiceCertificateAuthentication SslCertificateAuthentication { get; public set; }
    internal X509CertificateRecipientClientCredential(X509CertificateRecipientClientCredential other);
    public X509Certificate2 get_DefaultCertificate();
    public void set_DefaultCertificate(X509Certificate2 value);
    [CompilerGeneratedAttribute]
public Dictionary`2<Uri, X509Certificate2> get_ScopedCertificates();
    [CompilerGeneratedAttribute]
public X509ServiceCertificateAuthentication get_Authentication();
    public X509ServiceCertificateAuthentication get_SslCertificateAuthentication();
    public void set_SslCertificateAuthentication(X509ServiceCertificateAuthentication value);
    public void SetDefaultCertificate(string subjectName, StoreLocation storeLocation, StoreName storeName);
    public void SetDefaultCertificate(StoreLocation storeLocation, StoreName storeName, X509FindType findType, object findValue);
    public void SetScopedCertificate(string subjectName, StoreLocation storeLocation, StoreName storeName, Uri targetService);
    public void SetScopedCertificate(StoreLocation storeLocation, StoreName storeName, X509FindType findType, object findValue, Uri targetService);
    internal void MakeReadOnly();
    private void ThrowIfImmutable();
}
public enum System.ServiceModel.Security.X509CertificateValidationMode : Enum {
    public int value__;
    public static X509CertificateValidationMode None;
    public static X509CertificateValidationMode PeerTrust;
    public static X509CertificateValidationMode ChainTrust;
    public static X509CertificateValidationMode PeerOrChainTrust;
    public static X509CertificateValidationMode Custom;
}
internal static class System.ServiceModel.Security.X509CertificateValidationModeHelper : object {
    public static bool IsDefined(X509CertificateValidationMode validationMode);
    internal static void Validate(X509CertificateValidationMode value);
}
public class System.ServiceModel.Security.X509ClientCertificateAuthentication : object {
    internal static X509CertificateValidationMode DefaultCertificateValidationMode;
    internal static X509RevocationMode DefaultRevocationMode;
    internal static StoreLocation DefaultTrustedStoreLocation;
    private static X509CertificateValidator s_defaultCertificateValidator;
    internal static X509CertificateValidator DefaultCertificateValidator { get; }
    internal static X509CertificateValidator get_DefaultCertificateValidator();
}
public class System.ServiceModel.Security.X509ServiceCertificateAuthentication : object {
    internal static X509CertificateValidationMode DefaultCertificateValidationMode;
    internal static X509RevocationMode DefaultRevocationMode;
    internal static StoreLocation DefaultTrustedStoreLocation;
    private static X509CertificateValidator s_defaultCertificateValidator;
    private static Oid s_serverAuthOid;
    private X509CertificateValidationMode _certificateValidationMode;
    private X509RevocationMode _revocationMode;
    private StoreLocation _trustedStoreLocation;
    private X509CertificateValidator _customCertificateValidator;
    private bool _isReadOnly;
    internal static X509CertificateValidator DefaultCertificateValidator { get; }
    public X509CertificateValidationMode CertificateValidationMode { get; public set; }
    public X509RevocationMode RevocationMode { get; public set; }
    public StoreLocation TrustedStoreLocation { get; public set; }
    public X509CertificateValidator CustomCertificateValidator { get; public set; }
    internal X509ServiceCertificateAuthentication(X509ServiceCertificateAuthentication other);
    private static X509ServiceCertificateAuthentication();
    internal static X509CertificateValidator get_DefaultCertificateValidator();
    public X509CertificateValidationMode get_CertificateValidationMode();
    public void set_CertificateValidationMode(X509CertificateValidationMode value);
    public X509RevocationMode get_RevocationMode();
    public void set_RevocationMode(X509RevocationMode value);
    public StoreLocation get_TrustedStoreLocation();
    public void set_TrustedStoreLocation(StoreLocation value);
    public X509CertificateValidator get_CustomCertificateValidator();
    public void set_CustomCertificateValidator(X509CertificateValidator value);
    internal bool TryGetCertificateValidator(X509CertificateValidator& validator);
    internal X509CertificateValidator GetCertificateValidator();
    internal void MakeReadOnly();
    private void ThrowIfImmutable();
}
internal static class System.ServiceModel.Security.XmlHelper : object {
    internal static void AddNamespaceDeclaration(XmlDictionaryWriter writer, string prefix, XmlDictionaryString ns);
    internal static string EnsureNamespaceDefined(XmlDictionaryWriter writer, XmlDictionaryString ns, string defaultPrefix);
    internal static XmlQualifiedName GetAttributeValueAsQName(XmlReader reader, string attributeName);
    internal static XmlElement GetChildElement(XmlElement parent);
    internal static XmlElement GetChildElement(XmlElement parent, string childLocalName, string childNamespace);
    internal static XmlQualifiedName GetValueAsQName(XmlReader reader, string value);
    internal static string GetWhiteSpace(XmlReader reader);
    internal static bool IsWhitespaceOrComment(XmlReader reader);
    internal static void OnChildNodeTypeMissing(string parentName, XmlNodeType expectedNodeType);
    internal static void OnChildNodeTypeMissing(XmlElement parent, XmlNodeType expectedNodeType);
    internal static void OnEmptyElementError(XmlReader r);
    internal static void OnEmptyElementError(XmlElement e);
    internal static void OnEOF();
    internal static void OnNamespaceMissing(string prefix);
    internal static void OnRequiredAttributeMissing(string attrName, string elementName);
    internal static void OnRequiredElementMissing(string elementName, string elementNamespace);
    internal static void OnUnexpectedChildNodeError(string parentName, XmlReader r);
    internal static void OnUnexpectedChildNodeError(XmlElement parent, XmlNode n);
    internal static string ReadEmptyElementAndRequiredAttribute(XmlDictionaryReader reader, XmlDictionaryString name, XmlDictionaryString namespaceUri, XmlDictionaryString attributeName, String& prefix);
    internal static string GetRequiredNonEmptyAttribute(XmlDictionaryReader reader, XmlDictionaryString name, XmlDictionaryString ns);
    internal static Byte[] GetRequiredBase64Attribute(XmlDictionaryReader reader, XmlDictionaryString name, XmlDictionaryString ns);
    internal static string ReadTextElementAsTrimmedString(XmlElement element);
    internal static void SplitIntoPrefixAndName(string qName, String& prefix, String& name);
    internal static void ValidateIdPrefix(string idPrefix);
    internal static UniqueId GetAttributeAsUniqueId(XmlDictionaryReader reader, XmlDictionaryString localName, XmlDictionaryString ns);
    private static UniqueId GetAttributeAsUniqueId(XmlDictionaryReader reader, string name, string ns);
    public static void WriteAttributeStringAsUniqueId(XmlDictionaryWriter writer, string prefix, XmlDictionaryString localName, XmlDictionaryString ns, UniqueId id);
    public static void WriteElementStringAsUniqueId(XmlWriter writer, string localName, UniqueId id);
    public static void WriteElementStringAsUniqueId(XmlDictionaryWriter writer, XmlDictionaryString localName, XmlDictionaryString ns, UniqueId id);
    public static void WriteElementContentAsInt64(XmlDictionaryWriter writer, XmlDictionaryString localName, XmlDictionaryString ns, long value);
    public static long ReadElementContentAsInt64(XmlDictionaryReader reader);
    public static void WriteStringAsUniqueId(XmlDictionaryWriter writer, UniqueId id);
    public static UniqueId ReadElementStringAsUniqueId(XmlDictionaryReader reader, XmlDictionaryString localName, XmlDictionaryString ns);
    public static UniqueId ReadElementStringAsUniqueId(XmlDictionaryReader reader);
    public static UniqueId ReadTextElementAsUniqueId(XmlElement element);
}
internal class System.ServiceModel.SecurityAlgorithmDec2005Dictionary : object {
    public XmlDictionaryString Psha1KeyDerivationDec2005;
    public List`1<XmlDictionaryString> SecurityAlgorithmDictionaryStrings;
    public SecurityAlgorithmDec2005Dictionary(XmlDictionary dictionary);
    public void PopulateSecurityAlgorithmDictionaryString();
}
internal static class System.ServiceModel.SecurityAlgorithmDec2005Strings : object {
    public static string Psha1KeyDerivationDec2005;
}
internal class System.ServiceModel.SecurityAlgorithmDictionary : object {
    public XmlDictionaryString Aes128Encryption;
    public XmlDictionaryString Aes128KeyWrap;
    public XmlDictionaryString Aes192Encryption;
    public XmlDictionaryString Aes192KeyWrap;
    public XmlDictionaryString Aes256Encryption;
    public XmlDictionaryString Aes256KeyWrap;
    public XmlDictionaryString DesEncryption;
    public XmlDictionaryString DsaSha1Signature;
    public XmlDictionaryString ExclusiveC14n;
    public XmlDictionaryString ExclusiveC14nWithComments;
    public XmlDictionaryString HmacSha1Signature;
    public XmlDictionaryString HmacSha256Signature;
    public XmlDictionaryString Psha1KeyDerivation;
    public XmlDictionaryString Ripemd160Digest;
    public XmlDictionaryString RsaOaepKeyWrap;
    public XmlDictionaryString RsaSha1Signature;
    public XmlDictionaryString RsaSha256Signature;
    public XmlDictionaryString RsaV15KeyWrap;
    public XmlDictionaryString Sha1Digest;
    public XmlDictionaryString Sha256Digest;
    public XmlDictionaryString Sha512Digest;
    public XmlDictionaryString TripleDesEncryption;
    public XmlDictionaryString TripleDesKeyWrap;
    public XmlDictionaryString TlsSspiKeyWrap;
    public XmlDictionaryString WindowsSspiKeyWrap;
    public SecurityAlgorithmDictionary(ServiceModelDictionary dictionary);
}
internal static class System.ServiceModel.SecurityAlgorithmStrings : object {
    public static string Aes128Encryption;
    public static string Aes128KeyWrap;
    public static string Aes192Encryption;
    public static string Aes192KeyWrap;
    public static string Aes256Encryption;
    public static string Aes256KeyWrap;
    public static string DesEncryption;
    public static string DsaSha1Signature;
    public static string ExclusiveC14n;
    public static string ExclusiveC14nWithComments;
    public static string HmacSha1Signature;
    public static string HmacSha256Signature;
    public static string Psha1KeyDerivation;
    public static string Ripemd160Digest;
    public static string RsaOaepKeyWrap;
    public static string RsaSha1Signature;
    public static string RsaSha256Signature;
    public static string RsaV15KeyWrap;
    public static string Sha1Digest;
    public static string Sha256Digest;
    public static string Sha512Digest;
    public static string TripleDesEncryption;
    public static string TripleDesKeyWrap;
    public static string TlsSspiKeyWrap;
    public static string WindowsSspiKeyWrap;
    public static string StrTransform;
}
internal class System.ServiceModel.SecurityJan2004Dictionary : object {
    public XmlDictionaryString SecurityTokenReference;
    public XmlDictionaryString Namespace;
    public XmlDictionaryString Security;
    public XmlDictionaryString ValueType;
    public XmlDictionaryString TypeAttribute;
    public XmlDictionaryString Prefix;
    public XmlDictionaryString NonceElement;
    public XmlDictionaryString PasswordElement;
    public XmlDictionaryString PasswordTextName;
    public XmlDictionaryString UserNameElement;
    public XmlDictionaryString UserNameTokenElement;
    public XmlDictionaryString BinarySecurityToken;
    public XmlDictionaryString EncodingType;
    public XmlDictionaryString Reference;
    public XmlDictionaryString URI;
    public XmlDictionaryString KeyIdentifier;
    public XmlDictionaryString EncodingTypeValueBase64Binary;
    public XmlDictionaryString EncodingTypeValueHexBinary;
    public XmlDictionaryString EncodingTypeValueText;
    public XmlDictionaryString X509SKIValueType;
    public XmlDictionaryString KerberosTokenTypeGSS;
    public XmlDictionaryString KerberosTokenType1510;
    public XmlDictionaryString SamlAssertionIdValueType;
    public XmlDictionaryString SamlAssertion;
    public XmlDictionaryString SamlUri;
    public XmlDictionaryString RelAssertionValueType;
    public XmlDictionaryString FailedAuthenticationFaultCode;
    public XmlDictionaryString InvalidSecurityTokenFaultCode;
    public XmlDictionaryString InvalidSecurityFaultCode;
    public XmlDictionaryString KerberosHashValueType;
    public SecurityJan2004Dictionary(ServiceModelDictionary dictionary);
}
internal static class System.ServiceModel.SecurityJan2004Strings : object {
    public static string SecurityTokenReference;
    public static string Namespace;
    public static string Security;
    public static string ValueType;
    public static string TypeAttribute;
    public static string Prefix;
    public static string NonceElement;
    public static string PasswordElement;
    public static string PasswordTextName;
    public static string UserNameElement;
    public static string UserNameTokenElement;
    public static string BinarySecurityToken;
    public static string EncodingType;
    public static string Reference;
    public static string URI;
    public static string KeyIdentifier;
    public static string EncodingTypeValueBase64Binary;
    public static string EncodingTypeValueHexBinary;
    public static string EncodingTypeValueText;
    public static string X509SKIValueType;
    public static string KerberosTokenTypeGSS;
    public static string KerberosTokenType1510;
    public static string SamlAssertionIdValueType;
    public static string SamlAssertion;
    public static string SamlUri;
    public static string RelAssertionValueType;
    public static string FailedAuthenticationFaultCode;
    public static string InvalidSecurityTokenFaultCode;
    public static string InvalidSecurityFaultCode;
    public static string KerberosHashValueType;
    public static string SecurityProfileNamespace;
    public static string X509TokenProfileNamespace;
    public static string UPTokenProfileNamespace;
    public static string SamlTokenProfileNamespace;
    public static string KerberosTokenProfileNamespace;
    public static string UPTokenType;
    public static string X509TokenType;
    public static string UPTokenPasswordTextValue;
}
public enum System.ServiceModel.SecurityMode : Enum {
    public int value__;
    public static SecurityMode None;
    public static SecurityMode Transport;
    public static SecurityMode Message;
    public static SecurityMode TransportWithMessageCredential;
}
internal static class System.ServiceModel.SecurityModeHelper : object {
    public static bool IsDefined(SecurityMode value);
    public static SecurityMode ToSecurityMode(UnifiedSecurityMode value);
}
internal class System.ServiceModel.SecurityXXX2005Dictionary : object {
    public XmlDictionaryString EncryptedHeader;
    public XmlDictionaryString Namespace;
    public XmlDictionaryString Prefix;
    public XmlDictionaryString SignatureConfirmation;
    public XmlDictionaryString ValueAttribute;
    public XmlDictionaryString TokenTypeAttribute;
    public XmlDictionaryString ThumbprintSha1ValueType;
    public XmlDictionaryString EncryptedKeyTokenType;
    public XmlDictionaryString EncryptedKeyHashValueType;
    public XmlDictionaryString SamlTokenType;
    public XmlDictionaryString Saml20TokenType;
    public XmlDictionaryString Saml11AssertionValueType;
    public SecurityXXX2005Dictionary(ServiceModelDictionary dictionary);
}
internal static class System.ServiceModel.SecurityXXX2005Strings : object {
    public static string EncryptedHeader;
    public static string Namespace;
    public static string Prefix;
    public static string SignatureConfirmation;
    public static string ValueAttribute;
    public static string TokenTypeAttribute;
    public static string ThumbprintSha1ValueType;
    public static string EncryptedKeyTokenType;
    public static string EncryptedKeyHashValueType;
    public static string SamlTokenType;
    public static string Saml20TokenType;
    public static string Saml11AssertionValueType;
    public static string SecurityProfileNamespace;
    public static string SamlTokenProfileNamespace;
    public static string X509TokenProfileNamespace;
}
internal static class System.ServiceModel.SerializationStrings : object {
    public static string XmlSchemaInstanceNamespace;
    public static string XmlSchemaNamespace;
    public static string Nil;
    public static string Type;
    public static string Char;
    public static string Boolean;
    public static string Byte;
    public static string UnsignedByte;
    public static string Short;
    public static string UnsignedShort;
    public static string Int;
    public static string UnsignedInt;
    public static string Long;
    public static string UnsignedLong;
    public static string Float;
    public static string Double;
    public static string Decimal;
    public static string DateTime;
    public static string String;
    public static string Base64Binary;
    public static string AnyType;
    public static string Duration;
    public static string Guid;
    public static string AnyURI;
    public static string QName;
    public static string Time;
    public static string Date;
    public static string HexBinary;
    public static string GYearMonth;
    public static string GYear;
    public static string GMonthDay;
    public static string GDay;
    public static string GMonth;
    public static string Integer;
    public static string PositiveInteger;
    public static string NegativeInteger;
    public static string NonPositiveInteger;
    public static string NonNegativeInteger;
    public static string NormalizedString;
}
public class System.ServiceModel.ServerTooBusyException : CommunicationException {
    public ServerTooBusyException(string message);
    public ServerTooBusyException(string message, Exception innerException);
    protected ServerTooBusyException(SerializationInfo info, StreamingContext context);
}
public class System.ServiceModel.ServiceActivationException : CommunicationException {
    public ServiceActivationException(string message);
    public ServiceActivationException(string message, Exception innerException);
    protected ServiceActivationException(SerializationInfo info, StreamingContext context);
}
internal class System.ServiceModel.ServiceChannelManager : LifetimeManager {
    private ICommunicationWaiter _activityWaiter;
    private int _activityWaiterCount;
    private IChannel _firstIncomingChannel;
    private ChannelCollection _incomingChannels;
    private ChannelCollection _outgoingChannels;
    [CompilerGeneratedAttribute]
private int <ActivityCount>k__BackingField;
    public int ActivityCount { get; private set; }
    public ICollection`1<IChannel> IncomingChannels { get; }
    public ICollection`1<IChannel> OutgoingChannels { get; }
    public ServiceChannelManager(InstanceContext instanceContext);
    [CompilerGeneratedAttribute]
public int get_ActivityCount();
    [CompilerGeneratedAttribute]
private void set_ActivityCount(int value);
    public ICollection`1<IChannel> get_IncomingChannels();
    public ICollection`1<IChannel> get_OutgoingChannels();
    private void ChannelAdded(IChannel channel);
    private void ChannelRemoved(IChannel channel);
    public void CloseInput(TimeSpan timeout);
    [AsyncStateMachineAttribute("System.ServiceModel.ServiceChannelManager/<CloseInputAsync>d__17")]
public Task CloseInputAsync(TimeSpan timeout);
    public void DecrementActivityCount();
    private void EnsureIncomingChannelCollection();
    public void IncrementActivityCount();
    protected virtual void IncrementBusyCount();
    protected virtual void OnAbort();
    protected virtual IAsyncResult OnBeginClose(TimeSpan timeout, AsyncCallback callback, object state);
    protected virtual void OnClose(TimeSpan timeout);
    [AsyncStateMachineAttribute("System.ServiceModel.ServiceChannelManager/<OnCloseAsync>d__25")]
protected virtual Task OnCloseAsync(TimeSpan timeout);
    protected virtual void OnEndClose(IAsyncResult result);
    private void OnChannelClosed(object sender, EventArgs args);
    public bool RemoveChannel(IChannel channel);
    public IChannel[] SnapshotChannels();
    [CompilerGeneratedAttribute]
[DebuggerHiddenAttribute]
private Task <>n__0(TimeSpan timeout);
}
[AttributeUsageAttribute("1028")]
public class System.ServiceModel.ServiceContractAttribute : Attribute {
    private string _configurationName;
    private string _name;
    private string _ns;
    private SessionMode _sessionMode;
    private ProtectionLevel _protectionLevel;
    [CompilerGeneratedAttribute]
private bool <HasProtectionLevel>k__BackingField;
    [CompilerGeneratedAttribute]
private Type <CallbackContract>k__BackingField;
    public string ConfigurationName { get; public set; }
    public string Name { get; public set; }
    public string Namespace { get; public set; }
    public ProtectionLevel ProtectionLevel { get; public set; }
    public bool HasProtectionLevel { get; private set; }
    public SessionMode SessionMode { get; public set; }
    public Type CallbackContract { get; public set; }
    public string get_ConfigurationName();
    public void set_ConfigurationName(string value);
    public string get_Name();
    public void set_Name(string value);
    public string get_Namespace();
    public void set_Namespace(string value);
    public ProtectionLevel get_ProtectionLevel();
    public void set_ProtectionLevel(ProtectionLevel value);
    [CompilerGeneratedAttribute]
public bool get_HasProtectionLevel();
    [CompilerGeneratedAttribute]
private void set_HasProtectionLevel(bool value);
    public SessionMode get_SessionMode();
    public void set_SessionMode(SessionMode value);
    [CompilerGeneratedAttribute]
public Type get_CallbackContract();
    [CompilerGeneratedAttribute]
public void set_CallbackContract(Type value);
}
internal static class System.ServiceModel.ServiceDefaults : object {
    public static TimeSpan CloseTimeout { get; }
    public static TimeSpan OpenTimeout { get; }
    public static TimeSpan ReceiveTimeout { get; }
    public static TimeSpan SendTimeout { get; }
    public static TimeSpan get_CloseTimeout();
    public static TimeSpan get_OpenTimeout();
    public static TimeSpan get_ReceiveTimeout();
    public static TimeSpan get_SendTimeout();
}
internal class System.ServiceModel.ServiceEndpointTrait`1 : EndpointTrait`1<TChannel> {
    private InstanceContext _callbackInstance;
    private ServiceEndpoint _serviceEndpoint;
    public ServiceEndpointTrait`1(ServiceEndpoint endpoint, InstanceContext callbackInstance);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    public virtual ChannelFactory`1<TChannel> CreateChannelFactory();
    private DuplexChannelFactory`1<TChannel> CreateDuplexFactory();
    private ChannelFactory`1<TChannel> CreateSimplexFactory();
}
[AttributeUsageAttribute("1092")]
public class System.ServiceModel.ServiceKnownTypeAttribute : Attribute {
    private Type _type;
    [CompilerGeneratedAttribute]
private Type <DeclaringType>k__BackingField;
    [CompilerGeneratedAttribute]
private string <MethodName>k__BackingField;
    public Type DeclaringType { get; }
    public string MethodName { get; }
    public Type Type { get; }
    public ServiceKnownTypeAttribute(Type type);
    public ServiceKnownTypeAttribute(string methodName);
    public ServiceKnownTypeAttribute(string methodName, Type declaringType);
    [CompilerGeneratedAttribute]
public Type get_DeclaringType();
    [CompilerGeneratedAttribute]
public string get_MethodName();
    public Type get_Type();
}
internal static class System.ServiceModel.ServiceModelAttributeTargets : object {
    public static AttributeTargets ServiceContract;
    public static AttributeTargets OperationContract;
    public static AttributeTargets MessageContract;
    public static AttributeTargets MessageMember;
    public static AttributeTargets Parameter;
    public static AttributeTargets ServiceBehavior;
    public static AttributeTargets CallbackBehavior;
    public static AttributeTargets ClientBehavior;
    public static AttributeTargets ContractBehavior;
    public static AttributeTargets OperationBehavior;
}
internal class System.ServiceModel.ServiceModelDictionary : object {
    public static ServiceModelDictionary Version1;
    private ServiceModelStrings _strings;
    private int _count;
    private XmlDictionaryString[] _dictionaryStrings1;
    private XmlDictionaryString[] _dictionaryStrings2;
    private Dictionary`2<string, int> _dictionary;
    private XmlDictionaryString[] _versionedDictionaryStrings;
    public static ServiceModelDictionary CurrentVersion { get; }
    public ServiceModelDictionary(ServiceModelStrings strings);
    private static ServiceModelDictionary();
    public static ServiceModelDictionary get_CurrentVersion();
    public XmlDictionaryString CreateString(string value, int key);
    public sealed virtual bool TryLookup(string key, XmlDictionaryString& value);
    public sealed virtual bool TryLookup(int key, XmlDictionaryString& value);
    public sealed virtual bool TryLookup(XmlDictionaryString key, XmlDictionaryString& value);
}
[DefaultMemberAttribute("Item")]
internal abstract class System.ServiceModel.ServiceModelStrings : object {
    public int Count { get; }
    public string Item { get; }
    public abstract virtual int get_Count();
    public abstract virtual string get_Item(int index);
}
[DefaultMemberAttribute("Item")]
internal class System.ServiceModel.ServiceModelStringsVersion1 : ServiceModelStrings {
    public static string String0;
    public static string String1;
    public static string String2;
    public static string String3;
    public static string String4;
    public static string String5;
    public static string String6;
    public static string String7;
    public static string String8;
    public static string String9;
    public static string String10;
    public static string String11;
    public static string String12;
    public static string String13;
    public static string String14;
    public static string String15;
    public static string String16;
    public static string String17;
    public static string String18;
    public static string String19;
    public static string String20;
    public static string String21;
    public static string String22;
    public static string String23;
    public static string String24;
    public static string String25;
    public static string String26;
    public static string String27;
    public static string String28;
    public static string String29;
    public static string String30;
    public static string String31;
    public static string String32;
    public static string String33;
    public static string String34;
    public static string String35;
    public static string String36;
    public static string String37;
    public static string String38;
    public static string String39;
    public static string String40;
    public static string String41;
    public static string String42;
    public static string String43;
    public static string String44;
    public static string String45;
    public static string String46;
    public static string String47;
    public static string String48;
    public static string String49;
    public static string String50;
    public static string String51;
    public static string String52;
    public static string String53;
    public static string String54;
    public static string String55;
    public static string String56;
    public static string String57;
    public static string String58;
    public static string String59;
    public static string String60;
    public static string String61;
    public static string String62;
    public static string String63;
    public static string String64;
    public static string String65;
    public static string String66;
    public static string String67;
    public static string String68;
    public static string String69;
    public static string String70;
    public static string String71;
    public static string String72;
    public static string String73;
    public static string String74;
    public static string String75;
    public static string String76;
    public static string String77;
    public static string String78;
    public static string String79;
    public static string String80;
    public static string String81;
    public static string String82;
    public static string String83;
    public static string String84;
    public static string String85;
    public static string String86;
    public static string String87;
    public static string String88;
    public static string String89;
    public static string String90;
    public static string String91;
    public static string String92;
    public static string String93;
    public static string String94;
    public static string String95;
    public static string String96;
    public static string String97;
    public static string String98;
    public static string String99;
    public static string String100;
    public static string String101;
    public static string String102;
    public static string String103;
    public static string String104;
    public static string String105;
    public static string String106;
    public static string String107;
    public static string String108;
    public static string String109;
    public static string String110;
    public static string String111;
    public static string String112;
    public static string String113;
    public static string String114;
    public static string String115;
    public static string String116;
    public static string String117;
    public static string String118;
    public static string String119;
    public static string String120;
    public static string String121;
    public static string String122;
    public static string String123;
    public static string String124;
    public static string String125;
    public static string String126;
    public static string String127;
    public static string String128;
    public static string String129;
    public static string String130;
    public static string String131;
    public static string String132;
    public static string String133;
    public static string String134;
    public static string String135;
    public static string String136;
    public static string String137;
    public static string String138;
    public static string String139;
    public static string String140;
    public static string String141;
    public static string String142;
    public static string String143;
    public static string String144;
    public static string String145;
    public static string String146;
    public static string String147;
    public static string String148;
    public static string String149;
    public static string String150;
    public static string String151;
    public static string String152;
    public static string String153;
    public static string String154;
    public static string String155;
    public static string String156;
    public static string String157;
    public static string String158;
    public static string String159;
    public static string String160;
    public static string String161;
    public static string String162;
    public static string String163;
    public static string String164;
    public static string String165;
    public static string String166;
    public static string String167;
    public static string String168;
    public static string String169;
    public static string String170;
    public static string String171;
    public static string String172;
    public static string String173;
    public static string String174;
    public static string String175;
    public static string String176;
    public static string String177;
    public static string String178;
    public static string String179;
    public static string String180;
    public static string String181;
    public static string String182;
    public static string String183;
    public static string String184;
    public static string String185;
    public static string String186;
    public static string String187;
    public static string String188;
    public static string String189;
    public static string String190;
    public static string String191;
    public static string String192;
    public static string String193;
    public static string String194;
    public static string String195;
    public static string String196;
    public static string String197;
    public static string String198;
    public static string String199;
    public static string String200;
    public static string String201;
    public static string String202;
    public static string String203;
    public static string String204;
    public static string String205;
    public static string String206;
    public static string String207;
    public static string String208;
    public static string String209;
    public static string String210;
    public static string String211;
    public static string String212;
    public static string String213;
    public static string String214;
    public static string String215;
    public static string String216;
    public static string String217;
    public static string String218;
    public static string String219;
    public static string String220;
    public static string String221;
    public static string String222;
    public static string String223;
    public static string String224;
    public static string String225;
    public static string String226;
    public static string String227;
    public static string String228;
    public static string String229;
    public static string String230;
    public static string String231;
    public static string String232;
    public static string String233;
    public static string String234;
    public static string String235;
    public static string String236;
    public static string String237;
    public static string String238;
    public static string String239;
    public static string String240;
    public static string String241;
    public static string String242;
    public static string String243;
    public static string String244;
    public static string String245;
    public static string String246;
    public static string String247;
    public static string String248;
    public static string String249;
    public static string String250;
    public static string String251;
    public static string String252;
    public static string String253;
    public static string String254;
    public static string String255;
    public static string String256;
    public static string String257;
    public static string String258;
    public static string String259;
    public static string String260;
    public static string String261;
    public static string String262;
    public static string String263;
    public static string String264;
    public static string String265;
    public static string String266;
    public static string String267;
    public static string String268;
    public static string String269;
    public static string String270;
    public static string String271;
    public static string String272;
    public static string String273;
    public static string String274;
    public static string String275;
    public static string String276;
    public static string String277;
    public static string String278;
    public static string String279;
    public static string String280;
    public static string String281;
    public static string String282;
    public static string String283;
    public static string String284;
    public static string String285;
    public static string String286;
    public static string String287;
    public static string String288;
    public static string String289;
    public static string String290;
    public static string String291;
    public static string String292;
    public static string String293;
    public static string String294;
    public static string String295;
    public static string String296;
    public static string String297;
    public static string String298;
    public static string String299;
    public static string String300;
    public static string String301;
    public static string String302;
    public static string String303;
    public static string String304;
    public static string String305;
    public static string String306;
    public static string String307;
    public static string String308;
    public static string String309;
    public static string String310;
    public static string String311;
    public static string String312;
    public static string String313;
    public static string String314;
    public static string String315;
    public static string String316;
    public static string String317;
    public static string String318;
    public static string String319;
    public static string String320;
    public static string String321;
    public static string String322;
    public static string String323;
    public static string String324;
    public static string String325;
    public static string String326;
    public static string String327;
    public static string String328;
    public static string String329;
    public static string String330;
    public static string String331;
    public static string String332;
    public static string String333;
    public static string String334;
    public static string String335;
    public static string String336;
    public static string String337;
    public static string String338;
    public static string String339;
    public static string String340;
    public static string String341;
    public static string String342;
    public static string String343;
    public static string String344;
    public static string String345;
    public static string String346;
    public static string String347;
    public static string String348;
    public static string String349;
    public static string String350;
    public static string String351;
    public static string String352;
    public static string String353;
    public static string String354;
    public static string String355;
    public static string String356;
    public static string String357;
    public static string String358;
    public static string String359;
    public static string String360;
    public static string String361;
    public static string String362;
    public static string String363;
    public static string String364;
    public static string String365;
    public static string String366;
    public static string String367;
    public static string String368;
    public static string String369;
    public static string String370;
    public static string String371;
    public static string String372;
    public static string String373;
    public static string String374;
    public static string String375;
    public static string String376;
    public static string String377;
    public static string String378;
    public static string String379;
    public static string String380;
    public static string String381;
    public static string String382;
    public static string String383;
    public static string String384;
    public static string String385;
    public static string String386;
    public static string String387;
    public static string String388;
    public static string String389;
    public static string String390;
    public static string String391;
    public static string String392;
    public static string String393;
    public static string String394;
    public static string String395;
    public static string String396;
    public static string String397;
    public static string String398;
    public static string String399;
    public static string String400;
    public static string String401;
    public static string String402;
    public static string String403;
    public static string String404;
    public static string String405;
    public static string String406;
    public static string String407;
    public static string String408;
    public static string String409;
    public static string String410;
    public static string String411;
    public static string String412;
    public static string String413;
    public static string String414;
    public static string String415;
    public static string String416;
    public static string String417;
    public static string String418;
    public static string String419;
    public static string String420;
    public static string String421;
    public static string String422;
    public static string String423;
    public static string String424;
    public static string String425;
    public static string String426;
    public static string String427;
    public static string String428;
    public static string String429;
    public static string String430;
    public static string String431;
    public static string String432;
    public static string String433;
    public static string String434;
    public static string String435;
    public static string String436;
    public static string String437;
    public static string String438;
    public static string String439;
    public static string String440;
    public static string String441;
    public static string String442;
    public static string String443;
    public static string String444;
    public static string String445;
    public static string String446;
    public static string String447;
    public static string String448;
    public static string String449;
    public static string String450;
    public static string String451;
    public static string String452;
    public static string String453;
    public static string String454;
    public static string String455;
    public static string String456;
    public static string String457;
    public static string String458;
    public static string String459;
    public static string String460;
    public static string String461;
    public static string String462;
    public static string String463;
    public static string String464;
    public static string String465;
    public static string String466;
    public static string String467;
    public static string String468;
    public static string String469;
    public static string String470;
    public static string String471;
    public static string String472;
    public static string String473;
    public static string String474;
    public static string String475;
    public static string String476;
    public static string String477;
    public static string String478;
    public static string String479;
    public static string String480;
    public static string String481;
    public static string String482;
    public static string String483;
    public static string String484;
    public static string String485;
    public static string String486;
    public int Count { get; }
    public string Item { get; }
    public virtual int get_Count();
    public virtual string get_Item(int index);
}
public class System.ServiceModel.ServiceSecurityContext : object {
    private static ServiceSecurityContext s_anonymous;
    private AuthorizationContext _authorizationContext;
    private IIdentity _primaryIdentity;
    private Claim _identityClaim;
    [CompilerGeneratedAttribute]
private ReadOnlyCollection`1<IAuthorizationPolicy> <AuthorizationPolicies>k__BackingField;
    public static ServiceSecurityContext Anonymous { get; }
    public bool IsAnonymous { get; }
    internal Claim IdentityClaim { get; }
    public IIdentity PrimaryIdentity { get; }
    public ReadOnlyCollection`1<IAuthorizationPolicy> AuthorizationPolicies { get; public set; }
    public AuthorizationContext AuthorizationContext { get; }
    public ServiceSecurityContext(ReadOnlyCollection`1<IAuthorizationPolicy> authorizationPolicies);
    public ServiceSecurityContext(AuthorizationContext authorizationContext);
    public ServiceSecurityContext(AuthorizationContext authorizationContext, ReadOnlyCollection`1<IAuthorizationPolicy> authorizationPolicies);
    public static ServiceSecurityContext get_Anonymous();
    public bool get_IsAnonymous();
    internal Claim get_IdentityClaim();
    public IIdentity get_PrimaryIdentity();
    [CompilerGeneratedAttribute]
public ReadOnlyCollection`1<IAuthorizationPolicy> get_AuthorizationPolicies();
    [CompilerGeneratedAttribute]
public void set_AuthorizationPolicies(ReadOnlyCollection`1<IAuthorizationPolicy> value);
    public AuthorizationContext get_AuthorizationContext();
    private IList`1<IIdentity> GetIdentities();
}
public enum System.ServiceModel.SessionMode : Enum {
    public int value__;
    public static SessionMode Allowed;
    public static SessionMode Required;
    public static SessionMode NotAllowed;
}
internal static class System.ServiceModel.SessionModeHelper : object {
    public static bool IsDefined(SessionMode sessionMode);
}
public class System.ServiceModel.SpnEndpointIdentity : EndpointIdentity {
    private static TimeSpan s_spnLookupTime;
    public static TimeSpan SpnLookupTime { get; public set; }
    public SpnEndpointIdentity(string spnName);
    public SpnEndpointIdentity(Claim identity);
    private static SpnEndpointIdentity();
    public static TimeSpan get_SpnLookupTime();
    public static void set_SpnLookupTime(TimeSpan value);
}
public static class System.ServiceModel.TimeSpanHelper : object {
    public static TimeSpan FromMinutes(int minutes, string text);
    public static TimeSpan FromSeconds(int seconds, string text);
    public static TimeSpan FromMilliseconds(int ms, string text);
}
public enum System.ServiceModel.TransferMode : Enum {
    public int value__;
    public static TransferMode Buffered;
    public static TransferMode Streamed;
    public static TransferMode StreamedRequest;
    public static TransferMode StreamedResponse;
}
internal static class System.ServiceModel.TransferModeHelper : object {
    public static bool IsDefined(TransferMode v);
    public static bool IsRequestStreamed(TransferMode v);
    public static bool IsResponseStreamed(TransferMode v);
    public static void Validate(TransferMode value);
}
internal static class System.ServiceModel.TrustApr2004Strings : object {
    public static string CombinedHashLabel;
    public static string RequestSecurityTokenResponse;
    public static string TokenType;
    public static string KeySize;
    public static string RequestedTokenReference;
    public static string AppliesTo;
    public static string Authenticator;
    public static string CombinedHash;
    public static string BinaryExchange;
    public static string Lifetime;
    public static string RequestedSecurityToken;
    public static string Entropy;
    public static string RequestedProofToken;
    public static string ComputedKey;
    public static string RequestSecurityToken;
    public static string RequestType;
    public static string RequestSecurityTokenResponseCollection;
    public static string Context;
    public static string BinarySecret;
    public static string Type;
    public static string SpnegoValueTypeUri;
    public static string TlsnegoValueTypeUri;
    public static string Prefix;
    public static string Namespace;
    public static string RequestSecurityTokenIssuance;
    public static string RequestSecurityTokenIssuanceResponse;
    public static string RequestTypeIssue;
    public static string Psha1ComputedKeyUri;
    public static string SymmetricKeyBinarySecret;
    public static string NonceBinarySecret;
    public static string KeyType;
    public static string SymmetricKeyType;
    public static string PublicKeyType;
    public static string Claims;
    public static string InvalidRequestFaultCode;
    public static string FailedAuthenticationFaultCode;
    public static string RequestFailedFaultCode;
    public static string SignWith;
    public static string EncryptWith;
    public static string EncryptionAlgorithm;
    public static string CanonicalizationAlgorithm;
    public static string ComputedKeyAlgorithm;
    public static string UseKey;
}
internal class System.ServiceModel.TrustDec2005Dictionary : TrustDictionary {
    public XmlDictionaryString AsymmetricKeyBinarySecret;
    public XmlDictionaryString RequestSecurityTokenCollectionIssuanceFinalResponse;
    public XmlDictionaryString RequestSecurityTokenRenewal;
    public XmlDictionaryString RequestSecurityTokenRenewalResponse;
    public XmlDictionaryString RequestSecurityTokenCollectionRenewalFinalResponse;
    public XmlDictionaryString RequestSecurityTokenCancellation;
    public XmlDictionaryString RequestSecurityTokenCancellationResponse;
    public XmlDictionaryString RequestSecurityTokenCollectionCancellationFinalResponse;
    public XmlDictionaryString KeyWrapAlgorithm;
    public XmlDictionaryString BearerKeyType;
    public XmlDictionaryString SecondaryParameters;
    public XmlDictionaryString Dialect;
    public XmlDictionaryString DialectType;
    public List`1<XmlDictionaryString> Feb2005DictionaryStrings;
    public List`1<XmlDictionaryString> Dec2005DictionaryString;
    public TrustDec2005Dictionary(XmlDictionary dictionary);
    public void PopulateFeb2005DictionaryString();
    public void PopulateDec2005DictionaryStrings();
}
internal static class System.ServiceModel.TrustDec2005Strings : object {
    public static string CombinedHashLabel;
    public static string RequestSecurityTokenResponse;
    public static string TokenType;
    public static string KeySize;
    public static string RequestedTokenReference;
    public static string AppliesTo;
    public static string Authenticator;
    public static string CombinedHash;
    public static string BinaryExchange;
    public static string Lifetime;
    public static string RequestedSecurityToken;
    public static string Entropy;
    public static string RequestedProofToken;
    public static string ComputedKey;
    public static string RequestSecurityToken;
    public static string RequestType;
    public static string Context;
    public static string BinarySecret;
    public static string Type;
    public static string SpnegoValueTypeUri;
    public static string TlsnegoValueTypeUri;
    public static string Prefix;
    public static string RequestSecurityTokenIssuance;
    public static string RequestSecurityTokenIssuanceResponse;
    public static string RequestTypeIssue;
    public static string AsymmetricKeyBinarySecret;
    public static string SymmetricKeyBinarySecret;
    public static string NonceBinarySecret;
    public static string Psha1ComputedKeyUri;
    public static string KeyType;
    public static string SymmetricKeyType;
    public static string PublicKeyType;
    public static string Claims;
    public static string InvalidRequestFaultCode;
    public static string FailedAuthenticationFaultCode;
    public static string UseKey;
    public static string SignWith;
    public static string EncryptWith;
    public static string EncryptionAlgorithm;
    public static string CanonicalizationAlgorithm;
    public static string ComputedKeyAlgorithm;
    public static string RequestSecurityTokenResponseCollection;
    public static string Namespace;
    public static string BinarySecretClauseType;
    public static string RequestSecurityTokenCollectionIssuanceFinalResponse;
    public static string RequestSecurityTokenRenewal;
    public static string RequestSecurityTokenRenewalResponse;
    public static string RequestSecurityTokenCollectionRenewalFinalResponse;
    public static string RequestSecurityTokenCancellation;
    public static string RequestSecurityTokenCancellationResponse;
    public static string RequestSecurityTokenCollectionCancellationFinalResponse;
    public static string RequestTypeRenew;
    public static string RequestTypeClose;
    public static string RenewTarget;
    public static string CloseTarget;
    public static string RequestedTokenClosed;
    public static string RequestedAttachedReference;
    public static string RequestedUnattachedReference;
    public static string IssuedTokensHeader;
    public static string KeyWrapAlgorithm;
    public static string BearerKeyType;
    public static string SecondaryParameters;
    public static string Dialect;
    public static string DialectType;
}
internal class System.ServiceModel.TrustDictionary : object {
    public XmlDictionaryString RequestSecurityTokenResponseCollection;
    public XmlDictionaryString Namespace;
    public XmlDictionaryString BinarySecretClauseType;
    public XmlDictionaryString CombinedHashLabel;
    public XmlDictionaryString RequestSecurityTokenResponse;
    public XmlDictionaryString TokenType;
    public XmlDictionaryString KeySize;
    public XmlDictionaryString RequestedTokenReference;
    public XmlDictionaryString AppliesTo;
    public XmlDictionaryString Authenticator;
    public XmlDictionaryString CombinedHash;
    public XmlDictionaryString BinaryExchange;
    public XmlDictionaryString Lifetime;
    public XmlDictionaryString RequestedSecurityToken;
    public XmlDictionaryString Entropy;
    public XmlDictionaryString RequestedProofToken;
    public XmlDictionaryString ComputedKey;
    public XmlDictionaryString RequestSecurityToken;
    public XmlDictionaryString RequestType;
    public XmlDictionaryString Context;
    public XmlDictionaryString BinarySecret;
    public XmlDictionaryString Type;
    public XmlDictionaryString SpnegoValueTypeUri;
    public XmlDictionaryString TlsnegoValueTypeUri;
    public XmlDictionaryString Prefix;
    public XmlDictionaryString RequestSecurityTokenIssuance;
    public XmlDictionaryString RequestSecurityTokenIssuanceResponse;
    public XmlDictionaryString RequestTypeIssue;
    public XmlDictionaryString Psha1ComputedKeyUri;
    public XmlDictionaryString SymmetricKeyBinarySecret;
    public XmlDictionaryString NonceBinarySecret;
    public XmlDictionaryString KeyType;
    public XmlDictionaryString SymmetricKeyType;
    public XmlDictionaryString PublicKeyType;
    public XmlDictionaryString Claims;
    public XmlDictionaryString InvalidRequestFaultCode;
    public XmlDictionaryString FailedAuthenticationFaultCode;
    public XmlDictionaryString RequestFailedFaultCode;
    public XmlDictionaryString SignWith;
    public XmlDictionaryString EncryptWith;
    public XmlDictionaryString EncryptionAlgorithm;
    public XmlDictionaryString CanonicalizationAlgorithm;
    public XmlDictionaryString ComputedKeyAlgorithm;
    public XmlDictionaryString UseKey;
    public XmlDictionaryString RenewTarget;
    public XmlDictionaryString CloseTarget;
    public XmlDictionaryString RequestedTokenClosed;
    public XmlDictionaryString RequestedAttachedReference;
    public XmlDictionaryString RequestedUnattachedReference;
    public XmlDictionaryString IssuedTokensHeader;
    public XmlDictionaryString RequestTypeRenew;
    public XmlDictionaryString RequestTypeClose;
    public TrustDictionary(ServiceModelDictionary dictionary);
}
internal class System.ServiceModel.TrustFeb2005Dictionary : TrustDictionary {
    public TrustFeb2005Dictionary(ServiceModelDictionary dictionary);
}
internal static class System.ServiceModel.TrustFeb2005Strings : object {
    public static string RequestSecurityTokenResponseCollection;
    public static string Namespace;
    public static string BinarySecretClauseType;
    public static string CombinedHashLabel;
    public static string RequestSecurityTokenResponse;
    public static string TokenType;
    public static string KeySize;
    public static string RequestedTokenReference;
    public static string AppliesTo;
    public static string Authenticator;
    public static string CombinedHash;
    public static string BinaryExchange;
    public static string Lifetime;
    public static string RequestedSecurityToken;
    public static string Entropy;
    public static string RequestedProofToken;
    public static string ComputedKey;
    public static string RequestSecurityToken;
    public static string RequestType;
    public static string Context;
    public static string BinarySecret;
    public static string Type;
    public static string SpnegoValueTypeUri;
    public static string TlsnegoValueTypeUri;
    public static string Prefix;
    public static string RequestSecurityTokenIssuance;
    public static string RequestSecurityTokenIssuanceResponse;
    public static string RequestTypeIssue;
    public static string SymmetricKeyBinarySecret;
    public static string Psha1ComputedKeyUri;
    public static string NonceBinarySecret;
    public static string RenewTarget;
    public static string CloseTarget;
    public static string RequestedTokenClosed;
    public static string RequestedAttachedReference;
    public static string RequestedUnattachedReference;
    public static string IssuedTokensHeader;
    public static string RequestTypeRenew;
    public static string RequestTypeClose;
    public static string KeyType;
    public static string SymmetricKeyType;
    public static string PublicKeyType;
    public static string Claims;
    public static string InvalidRequestFaultCode;
    public static string FailedAuthenticationFaultCode;
    public static string UseKey;
    public static string SignWith;
    public static string EncryptWith;
    public static string EncryptionAlgorithm;
    public static string CanonicalizationAlgorithm;
    public static string ComputedKeyAlgorithm;
}
internal static class System.ServiceModel.TrustStrings : object {
}
internal abstract class System.ServiceModel.TypedHeaderManager : object {
    private static Dictionary`2<Type, TypedHeaderManager> s_cache;
    private static ReaderWriterLockSlim s_cacheLock;
    private static Type s_GenericAdapterType;
    private static TypedHeaderManager();
    internal static object Create(Type t, object content, bool mustUnderstand, bool relay, string actor);
    internal static object GetContent(Type t, object typedHeaderInstance, Boolean& mustUnderstand, Boolean& relay, String& actor);
    internal static Type GetMessageHeaderType(Type contentType);
    internal static Type GetHeaderType(Type headerParameterType);
    private static TypedHeaderManager GetTypedHeaderManager(Type t);
    protected abstract virtual object Create(object content, bool mustUnderstand, bool relay, string actor);
    protected abstract virtual object GetContent(object typedHeaderInstance, Boolean& mustUnderstand, Boolean& relay, String& actor);
    protected abstract virtual Type GetMessageHeaderType();
}
[FlagsAttribute]
internal enum System.ServiceModel.UnifiedSecurityMode : Enum {
    public int value__;
    public static UnifiedSecurityMode None;
    public static UnifiedSecurityMode Transport;
    public static UnifiedSecurityMode Message;
    public static UnifiedSecurityMode Both;
    public static UnifiedSecurityMode TransportWithMessageCredential;
    public static UnifiedSecurityMode TransportCredentialOnly;
}
public class System.ServiceModel.UnknownMessageReceivedEventArgs : EventArgs {
    [CompilerGeneratedAttribute]
private Message <Message>k__BackingField;
    public Message Message { get; }
    internal UnknownMessageReceivedEventArgs(Message message);
    [CompilerGeneratedAttribute]
public Message get_Message();
}
public class System.ServiceModel.UpnEndpointIdentity : EndpointIdentity {
    public UpnEndpointIdentity(string upnName);
    internal UpnEndpointIdentity(Claim identity);
    internal virtual void WriteContentsTo(XmlDictionaryWriter writer);
}
public class System.ServiceModel.UriSchemeKeyedCollection : SynchronizedKeyedCollection`2<string, Uri> {
    internal UriSchemeKeyedCollection(object syncRoot);
    public UriSchemeKeyedCollection(Uri[] addresses);
    protected virtual string GetKeyForItem(Uri item);
    protected virtual void InsertItem(int index, Uri item);
    protected virtual void SetItem(int index, Uri item);
    internal static void ValidateBaseAddress(Uri uri, string argumentName);
}
internal class System.ServiceModel.UtilityDictionary : object {
    public XmlDictionaryString IdAttribute;
    public XmlDictionaryString Namespace;
    public XmlDictionaryString Timestamp;
    public XmlDictionaryString CreatedElement;
    public XmlDictionaryString ExpiresElement;
    public XmlDictionaryString Prefix;
    public XmlDictionaryString UniqueEndpointHeaderName;
    public XmlDictionaryString UniqueEndpointHeaderNamespace;
    public UtilityDictionary(ServiceModelDictionary dictionary);
}
internal static class System.ServiceModel.UtilityStrings : object {
    public static string IdAttribute;
    public static string Namespace;
    public static string Timestamp;
    public static string CreatedElement;
    public static string ExpiresElement;
    public static string Prefix;
    public static string UniqueEndpointHeaderName;
    public static string UniqueEndpointHeaderNamespace;
}
internal class System.ServiceModel.WSAddressing10ProblemHeaderQNameFault : MessageFault {
    private FaultCode _code;
    private FaultReason _reason;
    private string _actor;
    private string _node;
    private string _invalidHeaderName;
    public string Actor { get; }
    public FaultCode Code { get; }
    public bool HasDetail { get; }
    public string Node { get; }
    public FaultReason Reason { get; }
    public WSAddressing10ProblemHeaderQNameFault(MessageHeaderException e);
    public WSAddressing10ProblemHeaderQNameFault(ActionMismatchAddressingException e);
    public virtual string get_Actor();
    public virtual FaultCode get_Code();
    public virtual bool get_HasDetail();
    public virtual string get_Node();
    public virtual FaultReason get_Reason();
    protected virtual void OnWriteDetail(XmlDictionaryWriter writer, EnvelopeVersion version);
    protected virtual void OnWriteDetailContents(XmlDictionaryWriter writer);
    public void AddHeaders(MessageHeaders headers);
}
internal class System.ServiceModel.WSReliableMessaging11Version : ReliableMessagingVersion {
    [CompilerGeneratedAttribute]
private static ReliableMessagingVersion <Instance>k__BackingField;
    internal static ReliableMessagingVersion Instance { get; }
    private static WSReliableMessaging11Version();
    [CompilerGeneratedAttribute]
internal static ReliableMessagingVersion get_Instance();
    public virtual string ToString();
}
internal class System.ServiceModel.WSReliableMessagingFebruary2005Version : ReliableMessagingVersion {
    [CompilerGeneratedAttribute]
private static ReliableMessagingVersion <Instance>k__BackingField;
    internal static ReliableMessagingVersion Instance { get; }
    private static WSReliableMessagingFebruary2005Version();
    [CompilerGeneratedAttribute]
internal static ReliableMessagingVersion get_Instance();
    public virtual string ToString();
}
internal class System.ServiceModel.Wsrm11Dictionary : object {
    public XmlDictionaryString AckRequestedAction;
    public XmlDictionaryString CloseSequence;
    public XmlDictionaryString CloseSequenceAction;
    public XmlDictionaryString CloseSequenceResponse;
    public XmlDictionaryString CloseSequenceResponseAction;
    public XmlDictionaryString CreateSequenceAction;
    public XmlDictionaryString CreateSequenceResponseAction;
    public XmlDictionaryString DiscardFollowingFirstGap;
    public XmlDictionaryString Endpoint;
    public XmlDictionaryString FaultAction;
    public XmlDictionaryString Final;
    public XmlDictionaryString IncompleteSequenceBehavior;
    public XmlDictionaryString LastMsgNumber;
    public XmlDictionaryString MaxMessageNumber;
    public XmlDictionaryString Namespace;
    public XmlDictionaryString NoDiscard;
    public XmlDictionaryString None;
    public XmlDictionaryString SequenceAcknowledgementAction;
    public XmlDictionaryString SequenceClosed;
    public XmlDictionaryString TerminateSequenceAction;
    public XmlDictionaryString TerminateSequenceResponse;
    public XmlDictionaryString TerminateSequenceResponseAction;
    public XmlDictionaryString UsesSequenceSSL;
    public XmlDictionaryString UsesSequenceSTR;
    public XmlDictionaryString WsrmRequired;
    public Wsrm11Dictionary(XmlDictionary dictionary);
}
internal static class System.ServiceModel.Wsrm11Strings : object {
    public static string AckRequestedAction;
    public static string CloseSequence;
    public static string CloseSequenceAction;
    public static string CloseSequenceResponse;
    public static string CloseSequenceResponseAction;
    public static string CreateSequenceAction;
    public static string CreateSequenceResponseAction;
    public static string DiscardFollowingFirstGap;
    public static string Endpoint;
    public static string FaultAction;
    public static string Final;
    public static string IncompleteSequenceBehavior;
    public static string LastMsgNumber;
    public static string MaxMessageNumber;
    public static string Namespace;
    public static string NoDiscard;
    public static string None;
    public static string SequenceAcknowledgementAction;
    public static string SequenceClosed;
    public static string TerminateSequenceAction;
    public static string TerminateSequenceResponse;
    public static string TerminateSequenceResponseAction;
    public static string UsesSequenceSSL;
    public static string UsesSequenceSTR;
    public static string WsrmRequired;
    public static string DiscardEntireSequence;
}
internal class System.ServiceModel.WsrmFeb2005Dictionary : object {
    public XmlDictionaryString Identifier;
    public XmlDictionaryString Namespace;
    public XmlDictionaryString SequenceAcknowledgement;
    public XmlDictionaryString AcknowledgementRange;
    public XmlDictionaryString Upper;
    public XmlDictionaryString Lower;
    public XmlDictionaryString BufferRemaining;
    public XmlDictionaryString NETNamespace;
    public XmlDictionaryString SequenceAcknowledgementAction;
    public XmlDictionaryString Sequence;
    public XmlDictionaryString MessageNumber;
    public XmlDictionaryString AckRequested;
    public XmlDictionaryString AckRequestedAction;
    public XmlDictionaryString AcksTo;
    public XmlDictionaryString Accept;
    public XmlDictionaryString CreateSequence;
    public XmlDictionaryString CreateSequenceAction;
    public XmlDictionaryString CreateSequenceRefused;
    public XmlDictionaryString CreateSequenceResponse;
    public XmlDictionaryString CreateSequenceResponseAction;
    public XmlDictionaryString Expires;
    public XmlDictionaryString FaultCode;
    public XmlDictionaryString InvalidAcknowledgement;
    public XmlDictionaryString LastMessage;
    public XmlDictionaryString LastMessageAction;
    public XmlDictionaryString LastMessageNumberExceeded;
    public XmlDictionaryString MessageNumberRollover;
    public XmlDictionaryString Nack;
    public XmlDictionaryString NETPrefix;
    public XmlDictionaryString Offer;
    public XmlDictionaryString Prefix;
    public XmlDictionaryString SequenceFault;
    public XmlDictionaryString SequenceTerminated;
    public XmlDictionaryString TerminateSequence;
    public XmlDictionaryString TerminateSequenceAction;
    public XmlDictionaryString UnknownSequence;
    public XmlDictionaryString ConnectionLimitReached;
    public WsrmFeb2005Dictionary(ServiceModelDictionary dictionary);
}
internal static class System.ServiceModel.WsrmFeb2005Strings : object {
    public static string Identifier;
    public static string Namespace;
    public static string SequenceAcknowledgement;
    public static string AcknowledgementRange;
    public static string Upper;
    public static string Lower;
    public static string BufferRemaining;
    public static string NETNamespace;
    public static string SequenceAcknowledgementAction;
    public static string Sequence;
    public static string MessageNumber;
    public static string AckRequested;
    public static string AckRequestedAction;
    public static string AcksTo;
    public static string Accept;
    public static string CreateSequence;
    public static string CreateSequenceAction;
    public static string CreateSequenceRefused;
    public static string CreateSequenceResponse;
    public static string CreateSequenceResponseAction;
    public static string Expires;
    public static string FaultCode;
    public static string InvalidAcknowledgement;
    public static string LastMessage;
    public static string LastMessageAction;
    public static string LastMessageNumberExceeded;
    public static string MessageNumberRollover;
    public static string Nack;
    public static string NETPrefix;
    public static string Offer;
    public static string Prefix;
    public static string SequenceFault;
    public static string SequenceTerminated;
    public static string TerminateSequence;
    public static string TerminateSequenceAction;
    public static string UnknownSequence;
    public static string ConnectionLimitReached;
}
public class System.ServiceModel.X509CertificateEndpointIdentity : EndpointIdentity {
    [CompilerGeneratedAttribute]
private X509Certificate2Collection <Certificates>k__BackingField;
    public X509Certificate2Collection Certificates { get; }
    public X509CertificateEndpointIdentity(X509Certificate2 certificate);
    public X509CertificateEndpointIdentity(X509Certificate2 primaryCertificate, X509Certificate2Collection supportingCertificates);
    internal X509CertificateEndpointIdentity(XmlDictionaryReader reader);
    [CompilerGeneratedAttribute]
public X509Certificate2Collection get_Certificates();
    internal virtual void WriteContentsTo(XmlDictionaryWriter writer);
}
internal static class System.ServiceModel.XD : object {
    private static ActivityIdFlowDictionary s_activityIdFlowDictionary;
    private static AddressingDictionary s_addressingDictionary;
    private static Addressing10Dictionary s_addressing10Dictionary;
    private static Addressing200408Dictionary s_addressing200408Dictionary;
    private static AddressingNoneDictionary s_addressingNoneDictionary;
    private static DotNetSecurityDictionary s_dotNetSecurityDictionary;
    private static MessageDictionary s_messageDictionary;
    private static Message11Dictionary s_message11Dictionary;
    private static Message12Dictionary s_message12Dictionary;
    private static SecureConversationFeb2005Dictionary s_secureConversationFeb2005Dictionary;
    private static SecurityAlgorithmDictionary s_securityAlgorithmDictionary;
    private static SecurityJan2004Dictionary s_securityJan2004Dictionary;
    private static SecurityXXX2005Dictionary s_securityXXX2005Dictionary;
    private static TrustFeb2005Dictionary s_trustFeb2005Dictionary;
    private static UtilityDictionary s_utilityDictionary;
    private static WsrmFeb2005Dictionary s_wsrmFeb2005Dictionary;
    private static XmlSignatureDictionary s_xmlSignatureDictionary;
    public static ServiceModelDictionary Dictionary { get; }
    public static ActivityIdFlowDictionary ActivityIdFlowDictionary { get; }
    public static AddressingDictionary AddressingDictionary { get; }
    public static Addressing10Dictionary Addressing10Dictionary { get; }
    public static Addressing200408Dictionary Addressing200408Dictionary { get; }
    public static AddressingNoneDictionary AddressingNoneDictionary { get; }
    public static DotNetSecurityDictionary DotNetSecurityDictionary { get; }
    public static MessageDictionary MessageDictionary { get; }
    public static Message11Dictionary Message11Dictionary { get; }
    public static Message12Dictionary Message12Dictionary { get; }
    public static SecureConversationFeb2005Dictionary SecureConversationFeb2005Dictionary { get; }
    public static SecurityAlgorithmDictionary SecurityAlgorithmDictionary { get; }
    public static SecurityJan2004Dictionary SecurityJan2004Dictionary { get; }
    public static SecurityXXX2005Dictionary SecurityXXX2005Dictionary { get; }
    public static TrustFeb2005Dictionary TrustFeb2005Dictionary { get; }
    public static UtilityDictionary UtilityDictionary { get; }
    public static WsrmFeb2005Dictionary WsrmFeb2005Dictionary { get; }
    public static XmlSignatureDictionary XmlSignatureDictionary { get; }
    public static ServiceModelDictionary get_Dictionary();
    public static ActivityIdFlowDictionary get_ActivityIdFlowDictionary();
    public static AddressingDictionary get_AddressingDictionary();
    public static Addressing10Dictionary get_Addressing10Dictionary();
    public static Addressing200408Dictionary get_Addressing200408Dictionary();
    public static AddressingNoneDictionary get_AddressingNoneDictionary();
    public static DotNetSecurityDictionary get_DotNetSecurityDictionary();
    public static MessageDictionary get_MessageDictionary();
    public static Message11Dictionary get_Message11Dictionary();
    public static Message12Dictionary get_Message12Dictionary();
    public static SecureConversationFeb2005Dictionary get_SecureConversationFeb2005Dictionary();
    public static SecurityAlgorithmDictionary get_SecurityAlgorithmDictionary();
    public static SecurityJan2004Dictionary get_SecurityJan2004Dictionary();
    public static SecurityXXX2005Dictionary get_SecurityXXX2005Dictionary();
    public static TrustFeb2005Dictionary get_TrustFeb2005Dictionary();
    public static UtilityDictionary get_UtilityDictionary();
    public static WsrmFeb2005Dictionary get_WsrmFeb2005Dictionary();
    public static XmlSignatureDictionary get_XmlSignatureDictionary();
}
internal class System.ServiceModel.XmlBuffer : object {
    private List`1<Section> _sections;
    private Byte[] _buffer;
    private int _offset;
    private BufferedOutputStream _stream;
    private BufferState _bufferState;
    private XmlDictionaryWriter _writer;
    private XmlDictionaryReaderQuotas _quotas;
    public int BufferSize { get; }
    public int SectionCount { get; }
    public XmlBuffer(int maxBufferSize);
    public int get_BufferSize();
    public int get_SectionCount();
    public XmlDictionaryWriter OpenSection(XmlDictionaryReaderQuotas quotas);
    public void CloseSection();
    public void Close();
    private Exception CreateInvalidStateException();
    public XmlDictionaryReader GetReader(int sectionIndex);
    public void WriteTo(int sectionIndex, XmlWriter writer);
}
internal static class System.ServiceModel.XmlEncryptionStrings : object {
    public static string Namespace;
    public static string DataReference;
    public static string EncryptedData;
    public static string EncryptionMethod;
    public static string CipherData;
    public static string CipherValue;
    public static string ReferenceList;
    public static string Encoding;
    public static string MimeType;
    public static string Type;
    public static string Id;
    public static string CarriedKeyName;
    public static string Recipient;
    public static string EncryptedKey;
    public static string URI;
    public static string KeyReference;
    public static string Prefix;
    public static string ElementType;
    public static string ContentType;
    public static string AlgorithmAttribute;
}
[ExtensionAttribute]
internal static class System.ServiceModel.XmlReaderExtensions : object {
    [ExtensionAttribute]
internal static string ReadElementString(XmlReader reader);
    [ExtensionAttribute]
internal static string ReadElementString(XmlReader reader, string localname, string ns);
}
[AttributeUsageAttribute("1092")]
public class System.ServiceModel.XmlSerializerFormatAttribute : Attribute {
    private OperationFormatStyle _style;
    private bool _isStyleSet;
    private OperationFormatUse _use;
    [CompilerGeneratedAttribute]
private bool <SupportFaults>k__BackingField;
    public bool SupportFaults { get; public set; }
    public OperationFormatStyle Style { get; public set; }
    public OperationFormatUse Use { get; public set; }
    internal bool IsEncoded { get; internal set; }
    [CompilerGeneratedAttribute]
public bool get_SupportFaults();
    [CompilerGeneratedAttribute]
public void set_SupportFaults(bool value);
    public OperationFormatStyle get_Style();
    public void set_Style(OperationFormatStyle value);
    public OperationFormatUse get_Use();
    public void set_Use(OperationFormatUse value);
    internal bool get_IsEncoded();
    internal void set_IsEncoded(bool value);
    internal static void ValidateOperationFormatStyle(OperationFormatStyle value);
    internal static void ValidateOperationFormatUse(OperationFormatUse value);
}
internal class System.ServiceModel.XmlSignatureDictionary : object {
    public XmlDictionaryString Algorithm;
    public XmlDictionaryString URI;
    public XmlDictionaryString Reference;
    public XmlDictionaryString Transforms;
    public XmlDictionaryString Transform;
    public XmlDictionaryString DigestMethod;
    public XmlDictionaryString DigestValue;
    public XmlDictionaryString Namespace;
    public XmlDictionaryString EnvelopedSignature;
    public XmlDictionaryString KeyInfo;
    public XmlDictionaryString Signature;
    public XmlDictionaryString SignedInfo;
    public XmlDictionaryString CanonicalizationMethod;
    public XmlDictionaryString SignatureMethod;
    public XmlDictionaryString SignatureValue;
    public XmlDictionaryString KeyName;
    public XmlDictionaryString Type;
    public XmlDictionaryString MgmtData;
    public XmlDictionaryString Prefix;
    public XmlDictionaryString KeyValue;
    public XmlDictionaryString RsaKeyValue;
    public XmlDictionaryString Modulus;
    public XmlDictionaryString Exponent;
    public XmlDictionaryString X509Data;
    public XmlDictionaryString X509IssuerSerial;
    public XmlDictionaryString X509IssuerName;
    public XmlDictionaryString X509SerialNumber;
    public XmlDictionaryString X509Certificate;
    public XmlSignatureDictionary(ServiceModelDictionary dictionary);
}
internal static class System.ServiceModel.XmlSignatureStrings : object {
    public static string Algorithm;
    public static string URI;
    public static string Reference;
    public static string Transforms;
    public static string Transform;
    public static string DigestMethod;
    public static string DigestValue;
    public static string Namespace;
    public static string EnvelopedSignature;
    public static string KeyInfo;
    public static string Signature;
    public static string SignedInfo;
    public static string CanonicalizationMethod;
    public static string SignatureMethod;
    public static string SignatureValue;
    public static string KeyName;
    public static string Type;
    public static string MgmtData;
    public static string Prefix;
    public static string KeyValue;
    public static string RsaKeyValue;
    public static string Modulus;
    public static string Exponent;
    public static string X509Data;
    public static string X509IssuerSerial;
    public static string X509IssuerName;
    public static string X509SerialNumber;
    public static string X509Certificate;
    public static string X509Ski;
    public static string TransformationParameters;
}
[ExtensionAttribute]
internal static class System.ServiceModel.XmlUtil : object {
    public static string XmlNs;
    public static string XmlNsNs;
    public static string XmlSerializerSchemaInstanceNamespace;
    public static string XmlSerializerSchemaNamespace;
    public static string GetXmlLangAttribute(XmlReader reader);
    public static bool IsTrue(string booleanValue);
    public static void ReadContentAsQName(XmlReader reader, String& localName, String& ns);
    public static bool IsWhitespace(char ch);
    public static string TrimEnd(string s);
    public static string TrimStart(string s);
    public static string Trim(string s);
    public static void ParseQName(XmlReader reader, string qname, String& localName, String& ns);
    [ExtensionAttribute]
public static DateTime ReadElementContentAsDateTime(XmlDictionaryReader reader);
}
internal static class System.SRP : object {
    private static ResourceManager s_resourceManager;
    [CompilerGeneratedAttribute]
private static CultureInfo <Culture>k__BackingField;
    internal static ResourceManager ResourceManager { get; }
    internal static CultureInfo Culture { get; internal set; }
    internal static string RequiredAttributeMissing { get; }
    internal static string SecurityTokenManagerCannotCreateProviderForRequirement { get; }
    internal static string SecurityTokenManagerCannotCreateAuthenticatorForRequirement { get; }
    internal static string EncodingBindingElementDoesNotHandleReaderQuotas { get; }
    internal static string ErrorDeserializingKeyIdentifierClauseFromTokenXml { get; }
    internal static string ErrorDeserializingTokenXml { get; }
    internal static string TokenRequirementDoesNotSpecifyTargetAddress { get; }
    internal static string DerivedKeyNotInitialized { get; }
    internal static string MultipleSecurityCredentialsManagersInChannelBindingParameters { get; }
    internal static string DerivedKeyTokenOffsetTooHigh { get; }
    internal static string DerivedKeyTokenGenerationAndLengthTooHigh { get; }
    internal static string Psha1KeyLengthInvalid { get; }
    internal static string CloneNotImplementedCorrectly { get; }
    internal static string NegotiationFailedIO { get; }
    internal static string AnonymousLogonsAreNotAllowed { get; }
    internal static string MultipleSupportingAuthenticatorsOfSameType { get; }
    internal static string SecurityTokenParametersCloneInvalidResult { get; }
    internal static string CertificateUnsupportedForHttpTransportCredentialOnly { get; }
    internal static string NoncesCachedInfinitely { get; }
    internal static string TrustDriverVersionDoesNotSupportSession { get; }
    internal static string TrustDriverVersionDoesNotSupportIssuedTokens { get; }
    internal static string SignatureConfirmationNotSupported { get; }
    internal static string SecureConversationDriverVersionDoesNotSupportSession { get; }
    internal static string OneWayOperationReturnedFault { get; }
    internal static string OneWayOperationReturnedLargeFault { get; }
    internal static string OneWayOperationReturnedMessage { get; }
    internal static string KeyLifetimeNotWithinTokenLifetime { get; }
    internal static string EffectiveGreaterThanExpiration { get; }
    internal static string LengthMustBeGreaterThanZero { get; }
    internal static string OperationCannotBeDoneAfterProcessingIsStarted { get; }
    internal static string ClientCredentialsUnableToCreateLocalTokenProvider { get; }
    internal static string SecurityProtocolCannotDoReplayDetection { get; }
    internal static string CannotReadToken { get; }
    internal static string ExpectedElementMissing { get; }
    internal static string MissingMessageID { get; }
    internal static string OnlyBodyReturnValuesSupported { get; }
    internal static string UnexpectedEndOfFile { get; }
    internal static string TimeStampHasCreationAheadOfExpiry { get; }
    internal static string TimeStampHasExpiryTimeInPast { get; }
    internal static string TimeStampHasCreationTimeInFuture { get; }
    internal static string TimeStampWasCreatedTooLongAgo { get; }
    internal static string ItemNotAvailableInDeserializedRST { get; }
    internal static string ItemAvailableInDeserializedRSTOnly { get; }
    internal static string ItemNotAvailableInDeserializedRSTR { get; }
    internal static string ItemAvailableInDeserializedRSTROnly { get; }
    internal static string Hosting_ServiceActivationFailed { get; }
    internal static string Sharing_ConnectionDispatchFailed { get; }
    internal static string Sharing_EndpointUnavailable { get; }
    internal static string UnexpectedEmptyElementExpectingClaim { get; }
    internal static string UnexpectedElementExpectingElement { get; }
    internal static string UnexpectedDuplicateElement { get; }
    internal static string MultipleIdentities { get; }
    internal static string InvalidUriValue { get; }
    internal static string UnrecognizedIdentityType { get; }
    internal static string InvalidIdentityElement { get; }
    internal static string UnrecognizedClaimTypeForIdentity { get; }
    internal static string SendCannotBeCalledAfterCloseOutputSession { get; }
    internal static string CommunicationObjectCannotBeModifiedInState { get; }
    internal static string CommunicationObjectCannotBeUsed { get; }
    internal static string CommunicationObjectFaulted1 { get; }
    internal static string CommunicationObjectAborted1 { get; }
    internal static string CommunicationObjectBaseClassMethodNotCalled { get; }
    internal static string CommunicationObjectInInvalidState { get; }
    internal static string ChannelFactoryCannotBeUsedToCreateChannels { get; }
    internal static string ChannelParametersCannotBeModified { get; }
    internal static string ChannelParametersCannotBePropagated { get; }
    internal static string ChannelTypeNotSupported { get; }
    internal static string InvalidEnumValue { get; }
    internal static string InvalidDecoderStateMachine { get; }
    internal static string ObjectDisposed { get; }
    internal static string InvalidReaderPositionOnCreateMessage { get; }
    internal static string DuplicateMessageProperty { get; }
    internal static string MessagePropertyNotFound { get; }
    internal static string HeaderAlreadyUnderstood { get; }
    internal static string HeaderAlreadyNotUnderstood { get; }
    internal static string MultipleMessageHeaders { get; }
    internal static string MultipleMessageHeadersWithActor { get; }
    internal static string MultipleRelatesToHeaders { get; }
    internal static string ExtraContentIsPresentInFaultDetail { get; }
    internal static string MessageIsEmpty { get; }
    internal static string MessageClosed { get; }
    internal static string BodyWriterReturnedIsNotBuffered { get; }
    internal static string BodyWriterCanOnlyBeWrittenOnce { get; }
    internal static string RequestMessageDoesNotHaveAMessageID { get; }
    internal static string HeaderNotFound { get; }
    internal static string MessageBufferIsClosed { get; }
    internal static string MessageTextEncodingNotSupported { get; }
    internal static string AtLeastOneFaultReasonMustBeSpecified { get; }
    internal static string NoNullTranslations { get; }
    internal static string FaultDoesNotHaveAnyDetail { get; }
    internal static string InvalidXmlQualifiedName { get; }
    internal static string UnboundPrefixInQName { get; }
    internal static string MessageBodyIsUnknown { get; }
    internal static string MessageBodyIsStream { get; }
    internal static string MessageBodyToStringError { get; }
    internal static string NoMatchingTranslationFoundForFaultText { get; }
    internal static string CannotDetermineSPNBasedOnAddress { get; }
    internal static string XmlLangAttributeMissing { get; }
    internal static string EncoderUnrecognizedCharSet { get; }
    internal static string EncoderUnrecognizedContentType { get; }
    internal static string EncoderBadContentType { get; }
    internal static string EncoderEnvelopeVersionMismatch { get; }
    internal static string EncoderMessageVersionMismatch { get; }
    internal static string SPS_SeekNotSupported { get; }
    internal static string SessionValueInvalid { get; }
    internal static string OperationInvalidBeforeSecurityNegotiation { get; }
    internal static string FramingError { get; }
    internal static string FramingPrematureEOF { get; }
    internal static string FramingRecordTypeMismatch { get; }
    internal static string FramingVersionNotSupported { get; }
    internal static string FramingModeNotSupported { get; }
    internal static string FramingSizeTooLarge { get; }
    internal static string FramingViaTooLong { get; }
    internal static string FramingViaNotUri { get; }
    internal static string FramingFaultTooLong { get; }
    internal static string FramingContentTypeTooLong { get; }
    internal static string FramingValueNotAvailable { get; }
    internal static string FramingAtEnd { get; }
    internal static string BinaryEncoderSessionTooLarge { get; }
    internal static string BinaryEncoderSessionInvalid { get; }
    internal static string BinaryEncoderSessionMalformed { get; }
    internal static string ReceiveShutdownReturnedFault { get; }
    internal static string ReceiveShutdownReturnedLargeFault { get; }
    internal static string ReceiveShutdownReturnedMessage { get; }
    internal static string MaxReceivedMessageSizeExceeded { get; }
    internal static string MaxSentMessageSizeExceeded { get; }
    internal static string FramingMaxMessageSizeExceeded { get; }
    internal static string StreamDoesNotSupportTimeout { get; }
    internal static string AddressingVersionNotSupported { get; }
    internal static string MessagePropertyReturnedNullCopy { get; }
    internal static string MessageVersionUnknown { get; }
    internal static string EnvelopeVersionUnknown { get; }
    internal static string EnvelopeVersionNotSupported { get; }
    internal static string CannotDetectAddressingVersion { get; }
    internal static string HeadersCannotBeAddedToEnvelopeVersion { get; }
    internal static string AddressingHeadersCannotBeAddedToAddressingVersion { get; }
    internal static string AddressingExtensionInBadNS { get; }
    internal static string MessageHeaderVersionNotSupported { get; }
    internal static string MessageHasBeenCopied { get; }
    internal static string MessageHasBeenWritten { get; }
    internal static string MessageHasBeenRead { get; }
    internal static string InvalidMessageState { get; }
    internal static string MessageBodyReaderInvalidReadState { get; }
    internal static string XmlBufferQuotaExceeded { get; }
    internal static string XmlBufferInInvalidState { get; }
    internal static string MessageBodyMissing { get; }
    internal static string MessageHeaderVersionMismatch { get; }
    internal static string ManualAddressingRequiresAddressedMessages { get; }
    internal static string ReceiveTimedOut2 { get; }
    internal static string WaitForMessageTimedOut { get; }
    internal static string SendToViaTimedOut { get; }
    internal static string CloseTimedOut { get; }
    internal static string OpenTimedOutEstablishingTransportSession { get; }
    internal static string RequestTimedOutEstablishingTransportSession { get; }
    internal static string RequestChannelSendTimedOut { get; }
    internal static string RequestChannelWaitForReplyTimedOut { get; }
    internal static string HttpProxyRequiresSingleAuthScheme { get; }
    internal static string UseDefaultWebProxyCantBeUsedWithExplicitProxyAddress { get; }
    internal static string ProxyImpersonationLevelMismatch { get; }
    internal static string ProxyAuthenticationLevelMismatch { get; }
    internal static string HttpIfModifiedSinceParseError { get; }
    internal static string HttpSoapActionMismatch { get; }
    internal static string HttpSoapActionMismatchContentType { get; }
    internal static string HttpContentTypeFormatException { get; }
    internal static string HttpServerTooBusy { get; }
    internal static string HttpRequestTimedOut { get; }
    internal static string HttpResponseTimedOut { get; }
    internal static string HttpReceiveFailure { get; }
    internal static string HttpAuthDoesNotSupportRequestStreaming { get; }
    internal static string ReplyAlreadySent { get; }
    internal static string RequestContextAborted { get; }
    internal static string InnerChannelFactoryWasNotSet { get; }
    internal static string PropertySettingErrorOnProtocolFactory { get; }
    internal static string ProtocolFactoryCouldNotCreateProtocol { get; }
    internal static string IdentityCheckFailedForOutgoingMessage { get; }
    internal static string IdentityCheckFailedForIncomingMessage { get; }
    internal static string DnsIdentityCheckFailedForIncomingMessageLackOfDnsClaim { get; }
    internal static string DnsIdentityCheckFailedForOutgoingMessageLackOfDnsClaim { get; }
    internal static string DnsIdentityCheckFailedForIncomingMessage { get; }
    internal static string DnsIdentityCheckFailedForOutgoingMessage { get; }
    internal static string ClientCertificateNotProvidedOnClientCredentials { get; }
    internal static string UserNamePasswordNotProvidedOnClientCredentials { get; }
    internal static string ObjectIsReadOnly { get; }
    internal static string EmptyXmlElementError { get; }
    internal static string UnexpectedXmlChildNode { get; }
    internal static string InvalidQName { get; }
    internal static string SuiteDoesNotAcceptAlgorithm { get; }
    internal static string CannotFindCert { get; }
    internal static string CannotFindCertForTarget { get; }
    internal static string FoundMultipleCerts { get; }
    internal static string FoundMultipleCertsForTarget { get; }
    internal static string SigningTokenHasNoKeys { get; }
    internal static string SigningTokenHasNoKeysSupportingTheAlgorithmSuite { get; }
    internal static string EmptyBase64Attribute { get; }
    internal static string CouldNotFindNamespaceForPrefix { get; }
    internal static string ChildNodeTypeMissing { get; }
    internal static string SPS_InvalidAsyncResult { get; }
    internal static string NonceLengthTooShort { get; }
    internal static string IncorrectBinaryNegotiationValueType { get; }
    internal static string CreationTimeUtcIsAfterExpiryTime { get; }
    internal static string CacheQuotaReached { get; }
    internal static string UnrecognizedIdentityPropertyType { get; }
    internal static string EndpointNotFound { get; }
    internal static string MaxReceivedMessageSizeMustBeInIntegerRange { get; }
    internal static string MaxBufferSizeMustMatchMaxReceivedMessageSize { get; }
    internal static string MaxBufferSizeMustNotExceedMaxReceivedMessageSize { get; }
    internal static string InValidateIdPrefix { get; }
    internal static string InValidateId { get; }
    internal static string UnexpectedHttpResponseCode { get; }
    internal static string HttpContentLengthIncorrect { get; }
    internal static string MissingContentType { get; }
    internal static string DuplexChannelAbortedDuringOpen { get; }
    internal static string OperationAbortedDuringConnectionEstablishment { get; }
    internal static string HttpAddressingNoneHeaderOnWire { get; }
    internal static string MessageXmlProtocolError { get; }
    internal static string InsufficentMemory { get; }
    internal static string HttpContentTypeHeaderRequired { get; }
    internal static string ResponseContentTypeMismatch { get; }
    internal static string HttpToMustEqualVia { get; }
    internal static string FramingContentTypeMismatch { get; }
    internal static string FramingFaultUnrecognized { get; }
    internal static string FramingContentTypeTooLongFault { get; }
    internal static string FramingViaTooLongFault { get; }
    internal static string FramingModeNotSupportedFault { get; }
    internal static string FramingVersionNotSupportedFault { get; }
    internal static string FramingUpgradeInvalid { get; }
    internal static string ServerTooBusy { get; }
    internal static string PreambleAckIncorrect { get; }
    internal static string PreambleAckIncorrectMaybeHttp { get; }
    internal static string StreamError { get; }
    internal static string ServerRejectedUpgradeRequest { get; }
    internal static string ServerRejectedSessionPreamble { get; }
    internal static string HttpRequiresSingleAuthScheme { get; }
    internal static string HttpAuthSchemeCannotBeNone { get; }
    internal static string HttpAuthorizationFailed { get; }
    internal static string HttpAuthorizationForbidden { get; }
    internal static string InvalidUriScheme { get; }
    internal static string HttpsServerCertThumbprintMismatch { get; }
    internal static string TrustFailure { get; }
    internal static string StreamMutualAuthNotSatisfied { get; }
    internal static string InvalidTokenProvided { get; }
    internal static string NoUserNameTokenProvided { get; }
    internal static string RemoteIdentityFailedVerification { get; }
    internal static string CredentialDisallowsNtlm { get; }
    internal static string UriGeneratorSchemeMustNotBeEmpty { get; }
    internal static string UnsupportedSslProtectionLevel { get; }
    internal static string TimeoutServiceChannelConcurrentOpen1 { get; }
    internal static string TimeoutServiceChannelConcurrentOpen2 { get; }
    internal static string TimeSpanMustbeGreaterThanTimeSpanZero { get; }
    internal static string AsyncResultCompletedTwice { get; }
    internal static string ValueMustBeNonNegative { get; }
    internal static string ValueMustBePositive { get; }
    internal static string ValueMustBeGreaterThanZero { get; }
    internal static string ValueMustBeInRange { get; }
    internal static string OffsetExceedsBufferSize { get; }
    internal static string SizeExceedsRemainingBufferSpace { get; }
    internal static string SpaceNeededExceedsMessageFrameOffset { get; }
    internal static string FaultConverterDidNotCreateFaultMessage { get; }
    internal static string FaultConverterCreatedFaultMessage { get; }
    internal static string FaultConverterDidNotCreateException { get; }
    internal static string FaultConverterCreatedException { get; }
    internal static string UnsupportedUpgradeInitiator { get; }
    internal static string StreamUpgradeUnsupportedChannelBindingKind { get; }
    internal static string ExtendedProtectionNotSupported { get; }
    internal static string HttpClientCredentialTypeInvalid { get; }
    internal static string TransportDoesNotSupportCompression { get; }
    internal static string UnsupportedSecuritySetting { get; }
    internal static string UnsupportedBindingProperty { get; }
    internal static string HttpMaxPendingAcceptsTooLargeError { get; }
    internal static string UnsupportedTokenImpersonationLevel { get; }
    internal static string TimeoutOnOpen { get; }
    internal static string TimeoutOnRequest { get; }
    internal static string SFxActionDemuxerDuplicate { get; }
    internal static string SFXBindingNameCannotBeNullOrEmpty { get; }
    internal static string SFXUnvalidNamespaceValue { get; }
    internal static string SFXUnvalidNamespaceParam { get; }
    internal static string SFXHeaderNameCannotBeNullOrEmpty { get; }
    internal static string SFxBadByReferenceParameterMetadata { get; }
    internal static string SFxBadByValueParameterMetadata { get; }
    internal static string SFxBindingMustContainTransport2 { get; }
    internal static string SFxBodyCannotBeNull { get; }
    internal static string SFxCallbackBehaviorAttributeOnlyOnDuplex { get; }
    internal static string SFxCallbackRequestReplyInOrder1 { get; }
    internal static string SfxCallbackTypeCannotBeNull { get; }
    internal static string SFxCannotActivateCallbackInstace { get; }
    internal static string SFxCannotCallAutoOpenWhenExplicitOpenCalled { get; }
    internal static string SFxCannotSetExtensionsByIndex { get; }
    internal static string SFxChannelDispatcherNoMessageVersion { get; }
    internal static string SFxChannelDispatcherUnableToOpen1 { get; }
    internal static string SFxChannelDispatcherUnableToOpen2 { get; }
    internal static string SFxChannelFactoryTypeMustBeInterface { get; }
    internal static string SFxChannelFactoryCannotCreateFactoryWithoutDescription { get; }
    internal static string SFxClientOutputSessionAutoClosed { get; }
    internal static string SFxCollectionDoesNotSupportSet0 { get; }
    internal static string SFxCollectionReadOnly { get; }
    internal static string SFxCollectionWrongType2 { get; }
    internal static string SFxContextModifiedInsideScope0 { get; }
    internal static string SFxContractDescriptionNameCannotBeEmpty { get; }
    internal static string SFxContractHasZeroOperations { get; }
    internal static string SFxContractHasZeroInitiatingOperations { get; }
    internal static string SFxContractInheritanceRequiresInterfaces { get; }
    internal static string SFxContractInheritanceRequiresInterfaces2 { get; }
    internal static string SFxCopyToRequiresICollection { get; }
    internal static string SFxCreateDuplexChannel1 { get; }
    internal static string SFxCreateDuplexChannelNoCallback { get; }
    internal static string SFxCreateDuplexChannelNoCallback1 { get; }
    internal static string SFxCreateDuplexChannelNoCallbackUserObject { get; }
    internal static string SFxCreateDuplexChannelBadCallbackUserObject { get; }
    internal static string SFxCreateNonDuplexChannel1 { get; }
    internal static string SFxCustomBindingNeedsTransport1 { get; }
    internal static string SFxDeserializationFailed1 { get; }
    internal static string SFxDisallowedAttributeCombination { get; }
    internal static string SFxInitializationUINotCalled { get; }
    internal static string SFxInitializationUIDisallowed { get; }
    internal static string SFxDocEncodedNotSupported { get; }
    internal static string SFxDuplicateMessageParts { get; }
    internal static string SFXEndpointBehaviorUsedOnWrongSide { get; }
    internal static string SFxEndpointDispatcherMultipleChannelDispatcher0 { get; }
    internal static string SFxEndpointDispatcherDifferentChannelDispatcher0 { get; }
    internal static string SFxErrorDeserializingRequestBody { get; }
    internal static string SFxErrorDeserializingRequestBodyMore { get; }
    internal static string SFxErrorDeserializingReplyBody { get; }
    internal static string SFxErrorDeserializingReplyBodyMore { get; }
    internal static string SFxErrorSerializingBody { get; }
    internal static string SFxErrorDeserializingHeader { get; }
    internal static string SFxErrorSerializingHeader { get; }
    internal static string SFxErrorDeserializingFault { get; }
    internal static string SFxErrorReflectingOnType2 { get; }
    internal static string SFxErrorReflectingOnMethod3 { get; }
    internal static string SFxErrorReflectingOnParameter4 { get; }
    internal static string SFxErrorReflectionOnUnknown1 { get; }
    internal static string SFxExceptionDetailEndOfInner { get; }
    internal static string SFxExceptionDetailFormat { get; }
    internal static string SFxFaultContractDuplicateDetailType { get; }
    internal static string SFxFaultContractDuplicateElement { get; }
    internal static string SFxFaultExceptionToString3 { get; }
    internal static string SFxFaultReason { get; }
    internal static string SFxFaultTypeAnonymous { get; }
    internal static string SFxHeaderNameMismatchInMessageContract { get; }
    internal static string SFxHeaderNameMismatchInOperation { get; }
    internal static string SFxHeaderNamespaceMismatchInMessageContract { get; }
    internal static string SFxHeaderNamespaceMismatchInOperation { get; }
    internal static string SFxHeaderNotUnderstood { get; }
    internal static string SFxImmutableServiceHostBehavior0 { get; }
    internal static string SFxImmutableChannelFactoryBehavior0 { get; }
    internal static string SFxInputParametersToServiceInvalid { get; }
    internal static string SFxInputParametersToServiceNull { get; }
    internal static string SFxInstanceNotInitialized { get; }
    internal static string SFxInterleavedContextScopes0 { get; }
    internal static string SFxInternalServerError { get; }
    internal static string SFxInternalCallbackError { get; }
    internal static string SFxInvalidAsyncResultState0 { get; }
    internal static string SFxInvalidCallbackIAsyncResult { get; }
    internal static string SFxInvalidCallbackContractType { get; }
    internal static string SFxInvalidChannelToOperationContext { get; }
    internal static string SFxInvalidMessageBody { get; }
    internal static string SFxInvalidMessageBodyEmptyMessage { get; }
    internal static string SFxInvalidMessageBodyErrorSerializingParameter { get; }
    internal static string SFxInvalidMessageBodyErrorDeserializingParameter { get; }
    internal static string SFxInvalidMessageBodyErrorDeserializingParameterMore { get; }
    internal static string SFxInvalidMessageContractSignature { get; }
    internal static string SFxInvalidMessageHeaderArrayType { get; }
    internal static string SFxInvalidRequestAction { get; }
    internal static string SFxInvalidReplyAction { get; }
    internal static string SFxInvalidStreamInTypedMessage { get; }
    internal static string SFxInvalidStreamInRequest { get; }
    internal static string SFxInvalidStreamInResponse { get; }
    internal static string SFxInvalidStreamOffsetLength { get; }
    internal static string SFxInvalidUseOfPrimitiveOperationFormatter { get; }
    internal static string SFxInvalidStaticOverloadCalledForDuplexChannelFactory1 { get; }
    internal static string SFxInvalidXmlAttributeInBare { get; }
    internal static string SFxInvalidXmlAttributeInWrapped { get; }
    internal static string SFxKnownTypeAttributeInvalid1 { get; }
    internal static string SFxKnownTypeAttributeReturnType3 { get; }
    internal static string SFxKnownTypeAttributeUnknownMethod3 { get; }
    internal static string SFxKnownTypeNull { get; }
    internal static string SFxMessageContractBaseTypeNotValid { get; }
    internal static string SFxMessageContractRequiresDefaultConstructor { get; }
    internal static string SFxMetadataReferenceInvalidLocation { get; }
    internal static string SFxMethodNotSupported1 { get; }
    internal static string SFxMethodNotSupportedOnCallback1 { get; }
    internal static string SFxMismatchedOperationParent { get; }
    internal static string SFxMissingActionHeader { get; }
    internal static string SFxMultipleCallbackFromSynchronizationContext { get; }
    internal static string SFxMultipleCallbackFromAsyncOperation { get; }
    internal static string SFxMultipleUnknownHeaders { get; }
    internal static string SFxMultipleContractStarOperations0 { get; }
    internal static string SFxNameCannotBeEmpty { get; }
    internal static string SFxConfigurationNameCannotBeEmpty { get; }
    internal static string SFxNeedProxyBehaviorOperationSelector2 { get; }
    internal static string SFxNoDefaultConstructor { get; }
    internal static string SFxNoMostDerivedContract { get; }
    internal static string SFxNullReplyFromFormatter2 { get; }
    internal static string SFxServiceChannelIdleAborted { get; }
    internal static string SFxSetEnableFaultsOnChannelDispatcher0 { get; }
    internal static string SFxSetManualAddressingOnChannelDispatcher0 { get; }
    internal static string SFxNoServiceObject { get; }
    internal static string SFxNonExceptionThrown { get; }
    internal static string SFxNonInitiatingOperation1 { get; }
    internal static string SFxOneWayMessageToTwoWayMethod0 { get; }
    internal static string SFxOperationContractOnNonServiceContract { get; }
    internal static string SFxOperationContractProviderOnNonServiceContract { get; }
    internal static string SFxOperationDescriptionNameCannotBeEmpty { get; }
    internal static string SFxParameterNameCannotBeNull { get; }
    internal static string SFxOperationMustHaveOneOrTwoMessages { get; }
    internal static string SFxParameterCountMismatch { get; }
    internal static string SFxParameterMustBeMessage { get; }
    internal static string SFxParametersMustBeEmpty { get; }
    internal static string SFxParameterMustBeArrayOfOneElement { get; }
    internal static string SFxRequestHasInvalidReplyToOnClient { get; }
    internal static string SFxRequestHasInvalidFaultToOnClient { get; }
    internal static string SFxRequestReplyNone { get; }
    internal static string SFxRequestTimedOut1 { get; }
    internal static string SFxRequestTimedOut2 { get; }
    internal static string SFxReplyActionMismatch3 { get; }
    internal static string SFxResultMustBeMessage { get; }
    internal static string SFxRpcMessageBodyPartNameInvalid { get; }
    internal static string SFxServerDidNotReply { get; }
    internal static string SFxStaticMessageHeaderPropertiesNotAllowed { get; }
    internal static string SFxStreamIOException { get; }
    internal static string SFxStreamRequestMessageClosed { get; }
    internal static string SFxStreamResponseMessageClosed { get; }
    internal static string SFxTimeoutOutOfRange0 { get; }
    internal static string SFxTimeoutOutOfRangeTooBig { get; }
    internal static string SFxTypedMessageCannotBeNull { get; }
    internal static string SFxTypedMessageCannotBeRpcLiteral { get; }
    internal static string SFxTypedOrUntypedMessageCannotBeMixedWithParameters { get; }
    internal static string SFxTypedOrUntypedMessageCannotBeMixedWithVoidInRpc { get; }
    internal static string SFxUnknownFaultNoMatchingTranslation1 { get; }
    internal static string SFxUnknownFaultNullReason0 { get; }
    internal static string SFxUnknownFaultZeroReasons0 { get; }
    internal static string SFxVersionMismatchInOperationContextAndMessage2 { get; }
    internal static string SFxWrapperNameCannotBeEmpty { get; }
    internal static string SFxXmlArrayNotAllowedForMultiple { get; }
    internal static string SFxXmlSerializerIsNotFound { get; }
    internal static string SFxChannelFactoryEndpointAddressUri { get; }
    internal static string SFxCloseTimedOut1 { get; }
    internal static string SfxCloseTimedOutWaitingForDispatchToComplete { get; }
    internal static string SFxChannelFactoryNoBindingFoundInConfig1 { get; }
    internal static string SFxChannelFactoryNoBindingFoundInConfigOrCode { get; }
    internal static string SFxProxyRuntimeMessageCannotBeNull { get; }
    internal static string SFxDispatchRuntimeMessageCannotBeNull { get; }
    internal static string SFxMessagePartDescriptionMissingType { get; }
    internal static string AChannelServiceEndpointSBindingIsNull0 { get; }
    internal static string AChannelServiceEndpointSContractIsNull0 { get; }
    internal static string AChannelServiceEndpointSContractSNameIsNull0 { get; }
    internal static string AChannelServiceEndpointSContractSNamespace0 { get; }
    internal static string SFxNoEndpointMatchingContract { get; }
    internal static string SFxNoEndpointMatchingAddress { get; }
    internal static string SFxNoEndpointMatchingAddressForConnectionOpeningMessage { get; }
    internal static string SFxServiceChannelCannotBeCalledBecauseIsSessionOpenNotificationEnabled { get; }
    internal static string EndMethodsCannotBeDecoratedWithOperationContractAttribute { get; }
    internal static string DispatchRuntimeRequiresFormatter0 { get; }
    internal static string ClientRuntimeRequiresFormatter0 { get; }
    internal static string RuntimeRequiresInvoker0 { get; }
    internal static string CouldnTCreateChannelForType2 { get; }
    internal static string CouldnTCreateChannelForChannelType2 { get; }
    internal static string EndpointListenerRequirementsCannotBeMetBy3 { get; }
    internal static string UnknownListenerType1 { get; }
    internal static string BindingDoesnTSupportSessionButContractRequires1 { get; }
    internal static string BindingDoesntSupportDatagramButContractRequires { get; }
    internal static string BindingDoesnTSupportOneWayButContractRequires1 { get; }
    internal static string BindingDoesnTSupportTwoWayButContractRequires1 { get; }
    internal static string BindingDoesnTSupportRequestReplyButContract1 { get; }
    internal static string BindingDoesnTSupportDuplexButContractRequires1 { get; }
    internal static string BindingDoesnTSupportAnyChannelTypes1 { get; }
    internal static string ContractIsNotSelfConsistentItHasOneOrMore2 { get; }
    internal static string ContractIsNotSelfConsistentWhenIsSessionOpenNotificationEnabled { get; }
    internal static string SynchronizedCollectionWrongType1 { get; }
    internal static string SynchronizedCollectionWrongTypeNull { get; }
    internal static string CannotAddTwoItemsWithTheSameKeyToSynchronizedKeyedCollection0 { get; }
    internal static string ItemDoesNotExistInSynchronizedKeyedCollection0 { get; }
    internal static string SuppliedMessageIsNotAReplyItHasNoRelatesTo0 { get; }
    internal static string channelIsNotAvailable0 { get; }
    internal static string channelDoesNotHaveADuplexSession0 { get; }
    internal static string UnsupportedEnvelopeVersion { get; }
    internal static string ServicesWithoutAServiceContractAttributeCan2 { get; }
    internal static string tooManyAttributesOfTypeOn2 { get; }
    internal static string couldnTFindRequiredAttributeOfTypeOn2 { get; }
    internal static string AttemptedToGetContractTypeForButThatTypeIs1 { get; }
    internal static string NoEndMethodFoundForAsyncBeginMethod3 { get; }
    internal static string MoreThanOneEndMethodFoundForAsyncBeginMethod3 { get; }
    internal static string InvalidAsyncEndMethodSignatureForMethod2 { get; }
    internal static string InvalidAsyncBeginMethodSignatureForMethod2 { get; }
    internal static string InAContractInheritanceHierarchyIfParentHasCallbackChildMustToo { get; }
    internal static string InAContractInheritanceHierarchyTheServiceContract3_2 { get; }
    internal static string CannotHaveTwoOperationsWithTheSameName3 { get; }
    internal static string CannotInheritTwoOperationsWithTheSameName3 { get; }
    internal static string SyncAsyncMatchConsistency_Parameters5 { get; }
    internal static string SyncTaskMatchConsistency_Parameters5 { get; }
    internal static string TaskAsyncMatchConsistency_Parameters5 { get; }
    internal static string SyncAsyncMatchConsistency_ReturnType5 { get; }
    internal static string SyncTaskMatchConsistency_ReturnType5 { get; }
    internal static string TaskAsyncMatchConsistency_ReturnType5 { get; }
    internal static string SyncAsyncMatchConsistency_Attributes6 { get; }
    internal static string SyncTaskMatchConsistency_Attributes6 { get; }
    internal static string TaskAsyncMatchConsistency_Attributes6 { get; }
    internal static string SyncAsyncMatchConsistency_Property6 { get; }
    internal static string SyncTaskMatchConsistency_Property6 { get; }
    internal static string TaskAsyncMatchConsistency_Property6 { get; }
    internal static string ServiceOperationsMarkedWithIsOneWayTrueMust0 { get; }
    internal static string OneWayOperationShouldNotSpecifyAReplyAction1 { get; }
    internal static string OneWayAndFaultsIncompatible2 { get; }
    internal static string AsyncEndCalledOnWrongChannel { get; }
    internal static string AsyncEndCalledWithAnIAsyncResult { get; }
    internal static string MessageHeaderIsNull0 { get; }
    internal static string MessagePropertiesArraySize0 { get; }
    internal static string DuplicateBehavior1 { get; }
    internal static string CantCreateChannelWithManualAddressing { get; }
    internal static string XDCannotFindValueInDictionaryString { get; }
    internal static string NoChannelBuilderAvailable { get; }
    internal static string InvalidBindingScheme { get; }
    internal static string CustomBindingRequiresTransport { get; }
    internal static string TransportBindingElementMustBeLast { get; }
    internal static string MessageVersionMissingFromBinding { get; }
    internal static string NotAllBindingElementsBuilt { get; }
    internal static string MultipleMebesInParameters { get; }
    internal static string MultipleStreamUpgradeProvidersInParameters { get; }
    internal static string SecurityCapabilitiesMismatched { get; }
    internal static string BaseAddressMustBeAbsolute { get; }
    internal static string BaseAddressDuplicateScheme { get; }
    internal static string BaseAddressCannotHaveUserInfo { get; }
    internal static string BaseAddressCannotHaveQuery { get; }
    internal static string BaseAddressCannotHaveFragment { get; }
    internal static string UriMustBeAbsolute { get; }
    internal static string ClaimTypeCannotBeEmpty { get; }
    internal static string MissingCustomCertificateValidator { get; }
    internal static string SecurityAuditPlatformNotSupported { get; }
    internal static string ActivityCallback { get; }
    internal static string ActivityClose { get; }
    internal static string ActivityConstructChannelFactory { get; }
    internal static string ActivityExecuteMethod { get; }
    internal static string ActivityCloseClientBase { get; }
    internal static string ActivityOpenClientBase { get; }
    internal static string ActivityProcessAction { get; }
    internal static string ActivityProcessingMessage { get; }
    internal static string InputTypeListEmptyError { get; }
    internal static string DelegatingHandlerArrayHasNonNullInnerHandler { get; }
    internal static string DelegatingHandlerArrayFromFuncContainsNullItem { get; }
    internal static string HttpMessageHandlerTypeNotSupported { get; }
    internal static string HttpPipelineNotSupportedOnClientSide { get; }
    internal static string WebSocketInvalidProtocolInvalidCharInProtocolString { get; }
    internal static string WebSocketInvalidProtocolContainsMultipleSubProtocolString { get; }
    internal static string WebSocketInvalidProtocolEmptySubprotocolString { get; }
    internal static string WebSocketUnexpectedCloseMessageError { get; }
    internal static string WebSocketStreamWriteCalledAfterEOMSent { get; }
    internal static string WebSocketCannotCreateRequestClientChannelWithCertainWebSocketTransportUsage { get; }
    internal static string ClientWebSocketFactory_CreateWebSocketFailed { get; }
    internal static string ClientWebSocketFactory_InvalidWebSocket { get; }
    internal static string ClientWebSocketFactory_InvalidSubProtocol { get; }
    internal static string WebSocketSendTimedOut { get; }
    internal static string WebSocketReceiveTimedOut { get; }
    internal static string WebSocketOperationTimedOut { get; }
    internal static string WebSocketVersionMismatchFromServer { get; }
    internal static string WebSocketSubProtocolMismatchFromServer { get; }
    internal static string CopyHttpHeaderFailed { get; }
    internal static string XmlInvalidConversion { get; }
    internal static string XmlInvalidStream { get; }
    internal static string LockTimeoutExceptionMessage { get; }
    internal static string InvalidEnumArgument { get; }
    internal static string InvalidTypedProxyMethodHandle { get; }
    internal static string FailedToCreateTypedProxy { get; }
    internal static string SecurityTokenRequirementDoesNotContainProperty { get; }
    internal static string SecurityTokenRequirementHasInvalidTypeForProperty { get; }
    internal static string TokenCancellationNotSupported { get; }
    internal static string TokenProviderUnableToGetToken { get; }
    internal static string TokenProviderUnableToRenewToken { get; }
    internal static string TokenRenewalNotSupported { get; }
    internal static string UserNameCannotBeEmpty { get; }
    internal static string ActivityBoundary { get; }
    internal static string StringNullOrEmpty { get; }
    internal static string GenericCallbackException { get; }
    internal static string ArgumentCannotBeEmptyString { get; }
    internal static string KeyIdentifierClauseDoesNotSupportKeyCreation { get; }
    internal static string SymmetricKeyLengthTooShort { get; }
    internal static string KeyIdentifierCannotCreateKey { get; }
    internal static string NoKeyIdentifierClauseFound { get; }
    internal static string LocalIdCannotBeEmpty { get; }
    internal static string CannotValidateSecurityTokenType { get; }
    internal static string UnauthorizedAccess_MemStreamBuffer { get; }
    internal static string ConfigurationFilesNotSupported { get; }
    internal static string X509ChainBuildFail { get; }
    internal static string ImpersonationLevelNotSupported { get; }
    internal static string ProvidedNetworkCredentialsForKerberosHasInvalidUserName { get; }
    internal static string SSLProtocolNegotiationFailed { get; }
    internal static string ssl_io_cert_validation { get; }
    internal static string X509InvalidUsageTime { get; }
    internal static string X509IsInUntrustedStore { get; }
    internal static string X509IsNotInTrustedStore { get; }
    internal static string Xml_InvalidNodeType { get; }
    internal static string SFxRpcMessageMustHaveASingleBody { get; }
    internal static string SFxBodyObjectTypeCannotBeInherited { get; }
    internal static string SFxBodyObjectTypeCannotBeInterface { get; }
    internal static string SFxHeadersAreNotSupportedInEncoded { get; }
    internal static string SFxMultiplePartsNotAllowedInEncoded { get; }
    internal static string SFxInvalidSoapAttribute { get; }
    internal static string SFxTerminatingOperationAlreadyCalled1 { get; }
    internal static string SFxChannelTerminated0 { get; }
    internal static string PeerTrustNotSupportedOnOSX { get; }
    internal static string SFxNone2004 { get; }
    internal static string SFxRequestHasInvalidFromOnClient { get; }
    internal static string ClientCredentialTypeMustBeSpecifiedForMixedMode { get; }
    internal static string SecureConversationSecurityTokenParametersRequireBootstrapBinding { get; }
    internal static string ProtocolMustBeInitiator { get; }
    internal static string SecurityProtocolFactoryShouldBeSetBeforeThisOperation { get; }
    internal static string IssuedSecurityTokenParametersNotSet { get; }
    internal static string KeyRolloverGreaterThanKeyRenewal { get; }
    internal static string SecuritySessionProtocolFactoryShouldBeSetBeforeThisOperation { get; }
    internal static string SecurityStandardsManagerNotSet { get; }
    internal static string ActivitySecurityClose { get; }
    internal static string ClientSecurityCloseTimeout { get; }
    internal static string ClientSecurityOutputSessionCloseTimeout { get; }
    internal static string DelayedSecurityApplicationAlreadyCompleted { get; }
    internal static string MessageBodyOperationNotValidInBodyState { get; }
    internal static string MessageSecurityVerificationFailed { get; }
    internal static string OutputNotExpected { get; }
    internal static string PrimarySignatureMustBeComputedBeforeSupportingTokenSignatures { get; }
    internal static string ProtocolMisMatch { get; }
    internal static string SenderSideSupportingTokensMustSpecifySecurityTokenParameters { get; }
    internal static string SigningWithoutPrimarySignatureRequiresTimestamp { get; }
    internal static string SupportingTokenSignaturesNotExpected { get; }
    internal static string TimestampAlreadySetForSecurityHeader { get; }
    internal static string TokenDoesNotSupportKeyIdentifierClauseCreation { get; }
    internal static string TokenManagerCannotCreateTokenReference { get; }
    internal static string TokenMustBeNullWhenTokenParametersAre { get; }
    internal static string TokenProviderCannotGetTokensForTarget { get; }
    internal static string UnableToCreateTokenReference { get; }
    internal static string UnableToFindSecurityHeaderInMessage { get; }
    internal static string UnableToFindSecurityHeaderInMessageNoActor { get; }
    internal static string UnknownTokenAttachmentMode { get; }
    internal static string UnsupportedTokenInclusionMode { get; }
    internal static string MismatchInSecurityOperationToken { get; }
    internal static string ResolvingExternalTokensRequireSecurityTokenParameters { get; }
    internal static string SecurityHeaderIsEmpty { get; }
    internal static string AlgorithmAndPrivateKeyMisMatch { get; }
    internal static string DuplicateTimestampInSecurityHeader { get; }
    internal static string EmptyOrNullArgumentString { get; }
    internal static string ErrorDeserializingKeyIdentifierClause { get; }
    internal static string InvalidX509RawData { get; }
    internal static string MissingPrivateKey { get; }
    internal static string NoKeyInfoClausesToWrite { get; }
    internal static string PrivateKeyNotSupported { get; }
    internal static string UnableToResolveKeyReference { get; }
    internal static string UnableToResolveTokenReference { get; }
    internal static string UnsupportedCryptoAlgorithm { get; }
    internal static string AlgorithmAndPublicKeyMisMatch { get; }
    internal static string PublicKeyNotSupported { get; }
    internal static string AtMostOneReferenceListIsSupportedWithDefaultPolicyCheck { get; }
    internal static string CustomCryptoAlgorithmIsNotValidHashAlgorithm { get; }
    internal static string DuplicateIdInMessageToBeVerified { get; }
    internal static string ID6002 { get; }
    internal static string ID6033 { get; }
    internal static string MessageProtectionOrderMismatch { get; }
    internal static string PrimarySignatureWasNotSignedByDerivedKey { get; }
    internal static string PrimarySignatureWasNotSignedByDerivedWrappedKey { get; }
    internal static string RequiredSecurityHeaderElementNotSigned { get; }
    internal static string RequiredSecurityTokenNotEncrypted { get; }
    internal static string RequiredSecurityTokenNotSigned { get; }
    internal static string BadCloseTarget { get; }
    internal static string ChannelMustBeOpenedToGetSessionId { get; }
    internal static string CommunicationObjectCloseInterrupted1 { get; }
    internal static string ElementToSignMustHaveId { get; }
    internal static string InvalidCloseResponseAction { get; }
    internal static string InvalidRstRequestType { get; }
    internal static string MoreThanOneRSTRInRSTRC { get; }
    internal static string NoCloseTargetSpecified { get; }
    internal static string NoPartsOfMessageMatchedPartsToSign { get; }
    internal static string SecuritySessionFaultReplyWasSent { get; }
    internal static string SessionKeyRenewalNotSupported { get; }
    internal static string SessionTokenIsNotGenericXmlToken { get; }
    internal static string SessionTokenWasNotClosed { get; }
    internal static string TimeoutOnOperation { get; }
    internal static string TimestampToSignHasNoId { get; }
    internal static string TransportSecuredMessageHasMoreThanOneToHeader { get; }
    internal static string TransportSecurityRequireToHeader { get; }
    internal static string UnableToCreateHashAlgorithmFromAsymmetricCrypto { get; }
    internal static string UnableToCreateKeyedHashAlgorithm { get; }
    internal static string UnableToRenewSessionKey { get; }
    internal static string UnexpectedSecuritySessionClose { get; }
    internal static string UnexpectedSecuritySessionCloseResponse { get; }
    internal static string UnknownICryptoType { get; }
    internal static string UnsecuredMessageFaultReceived { get; }
    internal static string UnsupportedCanonicalizationAlgorithm { get; }
    internal static string ChannelNotOpen { get; }
    internal static string ReceiveTimedOut { get; }
    internal static string ReceiveTimedOutNoLocalAddress { get; }
    internal static string TimeoutOnSend { get; }
    internal static string CannotReadKeyIdentifierClause { get; }
    internal static string ErrorSerializingKeyIdentifier { get; }
    internal static string ErrorSerializingKeyIdentifierClause { get; }
    internal static string MessageSecurityVersionOutOfRange { get; }
    internal static string PrivateKeyNotDSA { get; }
    internal static string PrivateKeyNotRSA { get; }
    internal static string PublicKeyNotDSA { get; }
    internal static string PublicKeyNotRSA { get; }
    internal static string StandardsManagerCannotWriteObject { get; }
    internal static string UnsupportedAlgorithmForCryptoOperation { get; }
    internal static string DerivedKeyLengthSpecifiedInImplicitDerivedKeyClauseTooLong { get; }
    internal static string MultipleMatchingCryptosFound { get; }
    internal static string UnableToDeriveKeyFromKeyInfoClause { get; }
    internal static string CannotFindMatchingCrypto { get; }
    internal static string DerivedKeyCannotDeriveFromSecret { get; }
    internal static string DerivedKeyLengthTooLong { get; }
    internal static string DerivedKeyLimitExceeded { get; }
    internal static string DerivedKeyPosAndGenBothSpecified { get; }
    internal static string DerivedKeyPosAndGenNotSpecified { get; }
    internal static string ExtendedProtectionPolicyCustomChannelBindingNotSupported { get; }
    internal static string CantInferReferenceForToken { get; }
    internal static string Remoting_SOAPInteropxsdInvalid { get; }
    internal static string SecurityTokenManagerCannotCreateSerializerForVersion { get; }
    internal static string TransportBindingElementNotFound { get; }
    internal static string UnknownEncodingInBinarySecurityToken { get; }
    internal static string UnsupportedPasswordType { get; }
    internal static string BootstrapSecurityBindingElementNotSet { get; }
    internal static string IssuerBuildContextNotSet { get; }
    internal static string SecurityAlgorithmSuiteNotSet { get; }
    internal static string TargetAddressIsNotSet { get; }
    internal static string TokenProviderRequiresSecurityBindingElement { get; }
    internal static string BadSecurityNegotiationContext { get; }
    internal static string CannotObtainIssuedTokenKeySize { get; }
    internal static string ClientSecurityNegotiationTimeout { get; }
    internal static string ClientSecuritySessionRequestTimeout { get; }
    internal static string FailToReceiveReplyFromNegotiation { get; }
    internal static string InvalidActionForNegotiationMessage { get; }
    internal static string InvalidIssuedTokenKeySize { get; }
    internal static string InvalidRenewResponseAction { get; }
    internal static string IssuerBindingNotPresentInTokenRequirement { get; }
    internal static string KeyLengthMustBeMultipleOfEight { get; }
    internal static string NegotiationIsCompleted { get; }
    internal static string NegotiationIsNotCompleted { get; }
    internal static string NoNegotiationMessageToSend { get; }
    internal static string SecurityEndpointNotFound { get; }
    internal static string SecurityNegotiationCannotProtectConfidentialEndpointHeader { get; }
    internal static string SecurityServerTooBusy { get; }
    internal static string SoapSecurityNegotiationFailed { get; }
    internal static string SoapSecurityNegotiationFailedForIssuerAndTarget { get; }
    internal static string BadIssuedTokenType { get; }
    internal static string BearerKeyTypeCannotHaveProofKey { get; }
    internal static string DerivedKeyInvalidGenerationSpecified { get; }
    internal static string DerivedKeyInvalidOffsetSpecified { get; }
    internal static string DerivedKeyTokenLabelTooLong { get; }
    internal static string DerivedKeyTokenNonceTooLong { get; }
    internal static string DerivedKeyTokenRequiresTokenReference { get; }
    internal static string EntropyModeCannotHaveComputedKey { get; }
    internal static string EntropyModeCannotHaveProofTokenOrIssuerEntropy { get; }
    internal static string EntropyModeCannotHaveRequestorEntropy { get; }
    internal static string EntropyModeRequiresComputedKey { get; }
    internal static string EntropyModeRequiresIssuerEntropy { get; }
    internal static string EntropyModeRequiresProofToken { get; }
    internal static string EntropyModeRequiresRequestorEntropy { get; }
    internal static string ErrorSerializingSecurityToken { get; }
    internal static string InvalidKeyLengthRequested { get; }
    internal static string InvalidKeySizeSpecifiedInNegotiation { get; }
    internal static string NoLicenseXml { get; }
    internal static string NoRequestSecurityTokenResponseElements { get; }
    internal static string RstrHasMultipleIssuedTokens { get; }
    internal static string RstrHasMultipleProofTokens { get; }
    internal static string RstrKeySizeNotProvided { get; }
    internal static string TokenCannotCreateSymmetricCrypto { get; }
    internal static string TrustDriverIsUnableToCreatedNecessaryAttachedOrUnattachedReferences { get; }
    internal static string UnexpectedBinarySecretType { get; }
    internal static string UnknownComputedKeyAlgorithm { get; }
    internal static string UnknownEncodingInKeyIdentifier { get; }
    internal static string UnsupportedBinaryEncoding { get; }
    internal static string UnsupportedIssuerEntropyType { get; }
    internal static string UnsupportedKeyDerivationAlgorithm { get; }
    internal static string BasicTokenNotExpected { get; }
    internal static string CustomCryptoAlgorithmIsNotValidKeyedHashAlgorithm { get; }
    internal static string SignedSupportingTokenNotExpected { get; }
    internal static string TokenManagerCouldNotReadToken { get; }
    internal static string UnableToFindTokenAuthenticator { get; }
    internal static string UnableToResolveKeyInfoClauseInDerivedKeyToken { get; }
    internal static string UnknownTokenAuthenticatorUsedInTokenProcessing { get; }
    internal static string BasicHttpMessageSecurityRequiresCertificate { get; }
    internal static string NoCookieInSct { get; }
    internal static string NoSecurityContextIdentifier { get; }
    internal static string SecurityContextNotRegistered { get; }
    internal static string AcksToMustBeSameAsRemoteAddress { get; }
    internal static string AcksToMustBeSameAsRemoteAddressReason { get; }
    internal static string CloseOutputSessionErrorReason { get; }
    internal static string CouldNotParseWithAction { get; }
    internal static string CSRefused { get; }
    internal static string CSRefusedAcksToMustEqualEndpoint { get; }
    internal static string CSRefusedAcksToMustEqualReplyTo { get; }
    internal static string CSRefusedInvalidIncompleteSequenceBehavior { get; }
    internal static string CSRefusedNoSTRWSSecurity { get; }
    internal static string CSRefusedRequiredSecurityElementMissing { get; }
    internal static string CSRefusedSSLNotSupported { get; }
    internal static string CSRefusedSTRNoWSSecurity { get; }
    internal static string CSRefusedUnexpectedElementAtEndOfCSMessage { get; }
    internal static string CSResponseOfferRejected { get; }
    internal static string CSResponseOfferRejectedReason { get; }
    internal static string CSResponseWithInvalidIncompleteSequenceBehavior { get; }
    internal static string CSResponseWithOffer { get; }
    internal static string CSResponseWithOfferReason { get; }
    internal static string CSResponseWithoutOffer { get; }
    internal static string CSResponseWithoutOfferReason { get; }
    internal static string EarlySecurityClose { get; }
    internal static string EarlySecurityFaulted { get; }
    internal static string EarlyTerminateSequence { get; }
    internal static string InconsistentLastMsgNumberExceptionString { get; }
    internal static string InvalidAcknowledgementFaultReason { get; }
    internal static string InvalidAcknowledgementReceived { get; }
    internal static string InvalidBufferRemaining { get; }
    internal static string InvalidSequenceNumber { get; }
    internal static string InvalidSequenceRange { get; }
    internal static string InvalidWsrmResponseChannelNotOpened { get; }
    internal static string InvalidWsrmResponseSessionFaultedExceptionString { get; }
    internal static string InvalidWsrmResponseSessionFaultedFaultString { get; }
    internal static string LastMessageNumberExceeded { get; }
    internal static string LastMessageNumberExceededFaultReason { get; }
    internal static string ManualAddressingNotSupported { get; }
    internal static string MaximumRetryCountExceeded { get; }
    internal static string MessageExceptionOccurred { get; }
    internal static string MessageNumberRollover { get; }
    internal static string MessageNumberRolloverFaultReason { get; }
    internal static string MissingFinalAckExceptionString { get; }
    internal static string MissingMessageIdOnWsrmRequest { get; }
    internal static string MissingRelatesToOnWsrmResponseReason { get; }
    internal static string MissingReplyToOnWsrmRequest { get; }
    internal static string NoActionNoSequenceHeaderReason { get; }
    internal static string NonEmptyWsrmMessageIsEmpty { get; }
    internal static string NonWsrmFeb2005ActionNotSupported { get; }
    internal static string ReceivedResponseBeforeRequestExceptionString { get; }
    internal static string ReceivedResponseBeforeRequestFaultString { get; }
    internal static string ReplyMissingAcknowledgement { get; }
    internal static string SecureConversationRequiredByReliableSession { get; }
    internal static string SequenceClosedFaultString { get; }
    internal static string SequenceTerminatedAddLastToWindowTimedOut { get; }
    internal static string SequenceTerminatedEarlyTerminateSequence { get; }
    internal static string SequenceTerminatedInactivityTimeoutExceeded { get; }
    internal static string SequenceTerminatedInconsistentLastMsgNumber { get; }
    internal static string SequenceTerminatedMaximumRetryCountExceeded { get; }
    internal static string SequenceTerminatedMissingFinalAck { get; }
    internal static string SequenceTerminatedOnAbort { get; }
    internal static string SequenceTerminatedQuotaExceededException { get; }
    internal static string SequenceTerminatedReliableRequestThrew { get; }
    internal static string SequenceTerminatedReplyMissingAcknowledgement { get; }
    internal static string SequenceTerminatedSessionClosedBeforeDone { get; }
    internal static string SequenceTerminatedSmallLastMsgNumber { get; }
    internal static string SequenceTerminatedUnexpectedAckRequested { get; }
    internal static string SequenceTerminatedUnexpectedCloseSequenceResponse { get; }
    internal static string SequenceTerminatedUnexpectedCS { get; }
    internal static string SequenceTerminatedUnexpectedCSROfferId { get; }
    internal static string SequenceTerminatedUnexpectedTerminateSequence { get; }
    internal static string SequenceTerminatedUnknownAddToWindowError { get; }
    internal static string SequenceTerminatedUnsupportedClose { get; }
    internal static string SequenceTerminatedUnsupportedTerminateSequence { get; }
    internal static string SessionClosedBeforeDone { get; }
    internal static string SmallLastMsgNumberExceptionString { get; }
    internal static string TimeoutOnAddToWindow { get; }
    internal static string TimeoutOnClose { get; }
    internal static string TraceCodeWsrmNegativeElapsedTimeDetected { get; }
    internal static string TransferModeNotSupported { get; }
    internal static string UnexpectedAckRequested { get; }
    internal static string UnexpectedCloseSequenceResponse { get; }
    internal static string UnexpectedCS { get; }
    internal static string UnexpectedCSROfferId { get; }
    internal static string UnexpectedTerminateSequence { get; }
    internal static string UnknownSequenceFaultReason { get; }
    internal static string UnknownSequenceFaultReceived { get; }
    internal static string UnknownSequenceMessageReceived { get; }
    internal static string UnparsableCSResponse { get; }
    internal static string UnrecognizedFaultReceived { get; }
    internal static string UnrecognizedFaultReceivedOnOpen { get; }
    internal static string UnsupportedCloseExceptionString { get; }
    internal static string UnsupportedTerminateSequenceExceptionString { get; }
    internal static string WrongIdentifierFault { get; }
    internal static string WsrmFaultReceived { get; }
    internal static string WsrmMessageProcessingError { get; }
    internal static string WsrmMessageWithWrongRelatesToExceptionString { get; }
    internal static string WsrmMessageWithWrongRelatesToFaultString { get; }
    internal static string WsrmRequestIncorrectReplyToExceptionString { get; }
    internal static string WsrmRequestIncorrectReplyToFaultString { get; }
    internal static string WsrmRequiredExceptionString { get; }
    internal static string WsrmRequiredFaultString { get; }
    internal static string BindingRequirementsAttributeDisallowsQueuedDelivery1 { get; }
    internal static string BindingRequirementsAttributeRequiresQueuedDelivery1 { get; }
    internal static string SinceTheBindingForDoesnTSupportIBindingCapabilities1_1 { get; }
    internal static string SinceTheBindingForDoesnTSupportIBindingCapabilities2_1 { get; }
    internal static string TheBindingForDoesnTSupportOrderedDelivery1 { get; }
    internal static string HttpsExplicitIdentity { get; }
    internal static string HttpsIdentityMultipleCerts { get; }
    internal static string OnlyDefaultSpnServiceSupported { get; }
    internal static string MtomBoundaryInvalid { get; }
    internal static string MtomBufferQuotaExceeded { get; }
    internal static string MtomContentTransferEncodingNotPresent { get; }
    internal static string MtomContentTransferEncodingNotSupported { get; }
    internal static string MtomContentTypeInvalid { get; }
    internal static string MtomDataMustNotContainXopInclude { get; }
    internal static string MtomExceededMaxSizeInBytes { get; }
    internal static string MtomInvalidCIDUri { get; }
    internal static string MtomInvalidEmptyURI { get; }
    internal static string MtomInvalidStartUri { get; }
    internal static string MtomInvalidTransferEncodingForMimePart { get; }
    internal static string MtomMessageContentTypeNotFound { get; }
    internal static string MtomMessageInvalidContent { get; }
    internal static string MtomMessageInvalidContentInMimePart { get; }
    internal static string MtomMessageInvalidMimeVersion { get; }
    internal static string MtomMessageNotApplicationXopXml { get; }
    internal static string MtomMessageNotMultipart { get; }
    internal static string MtomMessageRequiredParamNotSpecified { get; }
    internal static string MtomMimePartReferencedMoreThanOnce { get; }
    internal static string MtomPartNotFound { get; }
    internal static string MtomRootContentTypeNotFound { get; }
    internal static string MtomRootNotApplicationXopXml { get; }
    internal static string MtomRootPartNotFound { get; }
    internal static string MtomRootRequiredParamNotSpecified { get; }
    internal static string MtomRootUnexpectedCharset { get; }
    internal static string MtomRootUnexpectedType { get; }
    internal static string MtomXopIncludeHrefNotSpecified { get; }
    internal static string MtomXopIncludeInvalidXopAttributes { get; }
    internal static string MtomXopIncludeInvalidXopElement { get; }
    internal static string XmlInvalidBinHexSequence { get; }
    internal static string XmlInvalidBinHexLength { get; }
    internal static string XmlArrayTooSmall { get; }
    internal static string XmlMaxStringContentLengthExceeded { get; }
    internal static string XmlLineInfo { get; }
    internal static string MimeContentTypeHeaderInvalid { get; }
    internal static string MimeHeaderInvalidCharacter { get; }
    internal static string MimeMessageGetContentStreamCalledAlready { get; }
    internal static string MaxMimePartsExceeded { get; }
    internal static string MimeReaderHeaderAlreadyExists { get; }
    internal static string MimeReaderMalformedHeader { get; }
    internal static string MimeReaderResetCalledBeforeEOF { get; }
    internal static string MimeReaderTruncated { get; }
    internal static string MimeVersionHeaderInvalid { get; }
    internal static string MimeWriterInvalidStateForClose { get; }
    internal static string MimeWriterInvalidStateForHeader { get; }
    internal static string MimeWriterInvalidStateForContent { get; }
    internal static string MimeWriterInvalidStateForStartPart { get; }
    internal static string MimeWriterInvalidStateForStartPreface { get; }
    internal static string ReadNotSupportedOnStream { get; }
    internal static string SeekNotSupportedOnStream { get; }
    internal static string WriteBufferOverflow { get; }
    internal static string WriteNotSupportedOnStream { get; }
    internal static string XmlWriterClosed { get; }
    internal static string MtomEncoderBadMessageVersion { get; }
    internal static string SFxErrorCreatingMtomReader { get; }
    internal static string SFxImmutableClientBaseCacheSetting { get; }
    internal static string SFxMessageContractAttributeRequired { get; }
    internal static string SFxActionMismatch { get; }
    internal static string SFxNullReplyFromExtension2 { get; }
    private static bool UsingResourceKeys();
    internal static string Format(string resourceFormat, Object[] args);
    internal static string Format(string resourceFormat, object p1);
    internal static string Format(string resourceFormat, object p1, object p2);
    internal static string Format(string resourceFormat, object p1, object p2, object p3);
    internal static ResourceManager get_ResourceManager();
    [CompilerGeneratedAttribute]
internal static CultureInfo get_Culture();
    [CompilerGeneratedAttribute]
internal static void set_Culture(CultureInfo value);
    internal static string GetResourceString(string resourceKey, string defaultValue);
    internal static string get_RequiredAttributeMissing();
    internal static string get_SecurityTokenManagerCannotCreateProviderForRequirement();
    internal static string get_SecurityTokenManagerCannotCreateAuthenticatorForRequirement();
    internal static string get_EncodingBindingElementDoesNotHandleReaderQuotas();
    internal static string get_ErrorDeserializingKeyIdentifierClauseFromTokenXml();
    internal static string get_ErrorDeserializingTokenXml();
    internal static string get_TokenRequirementDoesNotSpecifyTargetAddress();
    internal static string get_DerivedKeyNotInitialized();
    internal static string get_MultipleSecurityCredentialsManagersInChannelBindingParameters();
    internal static string get_DerivedKeyTokenOffsetTooHigh();
    internal static string get_DerivedKeyTokenGenerationAndLengthTooHigh();
    internal static string get_Psha1KeyLengthInvalid();
    internal static string get_CloneNotImplementedCorrectly();
    internal static string get_NegotiationFailedIO();
    internal static string get_AnonymousLogonsAreNotAllowed();
    internal static string get_MultipleSupportingAuthenticatorsOfSameType();
    internal static string get_SecurityTokenParametersCloneInvalidResult();
    internal static string get_CertificateUnsupportedForHttpTransportCredentialOnly();
    internal static string get_NoncesCachedInfinitely();
    internal static string get_TrustDriverVersionDoesNotSupportSession();
    internal static string get_TrustDriverVersionDoesNotSupportIssuedTokens();
    internal static string get_SignatureConfirmationNotSupported();
    internal static string get_SecureConversationDriverVersionDoesNotSupportSession();
    internal static string get_OneWayOperationReturnedFault();
    internal static string get_OneWayOperationReturnedLargeFault();
    internal static string get_OneWayOperationReturnedMessage();
    internal static string get_KeyLifetimeNotWithinTokenLifetime();
    internal static string get_EffectiveGreaterThanExpiration();
    internal static string get_LengthMustBeGreaterThanZero();
    internal static string get_OperationCannotBeDoneAfterProcessingIsStarted();
    internal static string get_ClientCredentialsUnableToCreateLocalTokenProvider();
    internal static string get_SecurityProtocolCannotDoReplayDetection();
    internal static string get_CannotReadToken();
    internal static string get_ExpectedElementMissing();
    internal static string get_MissingMessageID();
    internal static string get_OnlyBodyReturnValuesSupported();
    internal static string get_UnexpectedEndOfFile();
    internal static string get_TimeStampHasCreationAheadOfExpiry();
    internal static string get_TimeStampHasExpiryTimeInPast();
    internal static string get_TimeStampHasCreationTimeInFuture();
    internal static string get_TimeStampWasCreatedTooLongAgo();
    internal static string get_ItemNotAvailableInDeserializedRST();
    internal static string get_ItemAvailableInDeserializedRSTOnly();
    internal static string get_ItemNotAvailableInDeserializedRSTR();
    internal static string get_ItemAvailableInDeserializedRSTROnly();
    internal static string get_Hosting_ServiceActivationFailed();
    internal static string get_Sharing_ConnectionDispatchFailed();
    internal static string get_Sharing_EndpointUnavailable();
    internal static string get_UnexpectedEmptyElementExpectingClaim();
    internal static string get_UnexpectedElementExpectingElement();
    internal static string get_UnexpectedDuplicateElement();
    internal static string get_MultipleIdentities();
    internal static string get_InvalidUriValue();
    internal static string get_UnrecognizedIdentityType();
    internal static string get_InvalidIdentityElement();
    internal static string get_UnrecognizedClaimTypeForIdentity();
    internal static string get_SendCannotBeCalledAfterCloseOutputSession();
    internal static string get_CommunicationObjectCannotBeModifiedInState();
    internal static string get_CommunicationObjectCannotBeUsed();
    internal static string get_CommunicationObjectFaulted1();
    internal static string get_CommunicationObjectAborted1();
    internal static string get_CommunicationObjectBaseClassMethodNotCalled();
    internal static string get_CommunicationObjectInInvalidState();
    internal static string get_ChannelFactoryCannotBeUsedToCreateChannels();
    internal static string get_ChannelParametersCannotBeModified();
    internal static string get_ChannelParametersCannotBePropagated();
    internal static string get_ChannelTypeNotSupported();
    internal static string get_InvalidEnumValue();
    internal static string get_InvalidDecoderStateMachine();
    internal static string get_ObjectDisposed();
    internal static string get_InvalidReaderPositionOnCreateMessage();
    internal static string get_DuplicateMessageProperty();
    internal static string get_MessagePropertyNotFound();
    internal static string get_HeaderAlreadyUnderstood();
    internal static string get_HeaderAlreadyNotUnderstood();
    internal static string get_MultipleMessageHeaders();
    internal static string get_MultipleMessageHeadersWithActor();
    internal static string get_MultipleRelatesToHeaders();
    internal static string get_ExtraContentIsPresentInFaultDetail();
    internal static string get_MessageIsEmpty();
    internal static string get_MessageClosed();
    internal static string get_BodyWriterReturnedIsNotBuffered();
    internal static string get_BodyWriterCanOnlyBeWrittenOnce();
    internal static string get_RequestMessageDoesNotHaveAMessageID();
    internal static string get_HeaderNotFound();
    internal static string get_MessageBufferIsClosed();
    internal static string get_MessageTextEncodingNotSupported();
    internal static string get_AtLeastOneFaultReasonMustBeSpecified();
    internal static string get_NoNullTranslations();
    internal static string get_FaultDoesNotHaveAnyDetail();
    internal static string get_InvalidXmlQualifiedName();
    internal static string get_UnboundPrefixInQName();
    internal static string get_MessageBodyIsUnknown();
    internal static string get_MessageBodyIsStream();
    internal static string get_MessageBodyToStringError();
    internal static string get_NoMatchingTranslationFoundForFaultText();
    internal static string get_CannotDetermineSPNBasedOnAddress();
    internal static string get_XmlLangAttributeMissing();
    internal static string get_EncoderUnrecognizedCharSet();
    internal static string get_EncoderUnrecognizedContentType();
    internal static string get_EncoderBadContentType();
    internal static string get_EncoderEnvelopeVersionMismatch();
    internal static string get_EncoderMessageVersionMismatch();
    internal static string get_SPS_SeekNotSupported();
    internal static string get_SessionValueInvalid();
    internal static string get_OperationInvalidBeforeSecurityNegotiation();
    internal static string get_FramingError();
    internal static string get_FramingPrematureEOF();
    internal static string get_FramingRecordTypeMismatch();
    internal static string get_FramingVersionNotSupported();
    internal static string get_FramingModeNotSupported();
    internal static string get_FramingSizeTooLarge();
    internal static string get_FramingViaTooLong();
    internal static string get_FramingViaNotUri();
    internal static string get_FramingFaultTooLong();
    internal static string get_FramingContentTypeTooLong();
    internal static string get_FramingValueNotAvailable();
    internal static string get_FramingAtEnd();
    internal static string get_BinaryEncoderSessionTooLarge();
    internal static string get_BinaryEncoderSessionInvalid();
    internal static string get_BinaryEncoderSessionMalformed();
    internal static string get_ReceiveShutdownReturnedFault();
    internal static string get_ReceiveShutdownReturnedLargeFault();
    internal static string get_ReceiveShutdownReturnedMessage();
    internal static string get_MaxReceivedMessageSizeExceeded();
    internal static string get_MaxSentMessageSizeExceeded();
    internal static string get_FramingMaxMessageSizeExceeded();
    internal static string get_StreamDoesNotSupportTimeout();
    internal static string get_AddressingVersionNotSupported();
    internal static string get_MessagePropertyReturnedNullCopy();
    internal static string get_MessageVersionUnknown();
    internal static string get_EnvelopeVersionUnknown();
    internal static string get_EnvelopeVersionNotSupported();
    internal static string get_CannotDetectAddressingVersion();
    internal static string get_HeadersCannotBeAddedToEnvelopeVersion();
    internal static string get_AddressingHeadersCannotBeAddedToAddressingVersion();
    internal static string get_AddressingExtensionInBadNS();
    internal static string get_MessageHeaderVersionNotSupported();
    internal static string get_MessageHasBeenCopied();
    internal static string get_MessageHasBeenWritten();
    internal static string get_MessageHasBeenRead();
    internal static string get_InvalidMessageState();
    internal static string get_MessageBodyReaderInvalidReadState();
    internal static string get_XmlBufferQuotaExceeded();
    internal static string get_XmlBufferInInvalidState();
    internal static string get_MessageBodyMissing();
    internal static string get_MessageHeaderVersionMismatch();
    internal static string get_ManualAddressingRequiresAddressedMessages();
    internal static string get_ReceiveTimedOut2();
    internal static string get_WaitForMessageTimedOut();
    internal static string get_SendToViaTimedOut();
    internal static string get_CloseTimedOut();
    internal static string get_OpenTimedOutEstablishingTransportSession();
    internal static string get_RequestTimedOutEstablishingTransportSession();
    internal static string get_RequestChannelSendTimedOut();
    internal static string get_RequestChannelWaitForReplyTimedOut();
    internal static string get_HttpProxyRequiresSingleAuthScheme();
    internal static string get_UseDefaultWebProxyCantBeUsedWithExplicitProxyAddress();
    internal static string get_ProxyImpersonationLevelMismatch();
    internal static string get_ProxyAuthenticationLevelMismatch();
    internal static string get_HttpIfModifiedSinceParseError();
    internal static string get_HttpSoapActionMismatch();
    internal static string get_HttpSoapActionMismatchContentType();
    internal static string get_HttpContentTypeFormatException();
    internal static string get_HttpServerTooBusy();
    internal static string get_HttpRequestTimedOut();
    internal static string get_HttpResponseTimedOut();
    internal static string get_HttpReceiveFailure();
    internal static string get_HttpAuthDoesNotSupportRequestStreaming();
    internal static string get_ReplyAlreadySent();
    internal static string get_RequestContextAborted();
    internal static string get_InnerChannelFactoryWasNotSet();
    internal static string get_PropertySettingErrorOnProtocolFactory();
    internal static string get_ProtocolFactoryCouldNotCreateProtocol();
    internal static string get_IdentityCheckFailedForOutgoingMessage();
    internal static string get_IdentityCheckFailedForIncomingMessage();
    internal static string get_DnsIdentityCheckFailedForIncomingMessageLackOfDnsClaim();
    internal static string get_DnsIdentityCheckFailedForOutgoingMessageLackOfDnsClaim();
    internal static string get_DnsIdentityCheckFailedForIncomingMessage();
    internal static string get_DnsIdentityCheckFailedForOutgoingMessage();
    internal static string get_ClientCertificateNotProvidedOnClientCredentials();
    internal static string get_UserNamePasswordNotProvidedOnClientCredentials();
    internal static string get_ObjectIsReadOnly();
    internal static string get_EmptyXmlElementError();
    internal static string get_UnexpectedXmlChildNode();
    internal static string get_InvalidQName();
    internal static string get_SuiteDoesNotAcceptAlgorithm();
    internal static string get_CannotFindCert();
    internal static string get_CannotFindCertForTarget();
    internal static string get_FoundMultipleCerts();
    internal static string get_FoundMultipleCertsForTarget();
    internal static string get_SigningTokenHasNoKeys();
    internal static string get_SigningTokenHasNoKeysSupportingTheAlgorithmSuite();
    internal static string get_EmptyBase64Attribute();
    internal static string get_CouldNotFindNamespaceForPrefix();
    internal static string get_ChildNodeTypeMissing();
    internal static string get_SPS_InvalidAsyncResult();
    internal static string get_NonceLengthTooShort();
    internal static string get_IncorrectBinaryNegotiationValueType();
    internal static string get_CreationTimeUtcIsAfterExpiryTime();
    internal static string get_CacheQuotaReached();
    internal static string get_UnrecognizedIdentityPropertyType();
    internal static string get_EndpointNotFound();
    internal static string get_MaxReceivedMessageSizeMustBeInIntegerRange();
    internal static string get_MaxBufferSizeMustMatchMaxReceivedMessageSize();
    internal static string get_MaxBufferSizeMustNotExceedMaxReceivedMessageSize();
    internal static string get_InValidateIdPrefix();
    internal static string get_InValidateId();
    internal static string get_UnexpectedHttpResponseCode();
    internal static string get_HttpContentLengthIncorrect();
    internal static string get_MissingContentType();
    internal static string get_DuplexChannelAbortedDuringOpen();
    internal static string get_OperationAbortedDuringConnectionEstablishment();
    internal static string get_HttpAddressingNoneHeaderOnWire();
    internal static string get_MessageXmlProtocolError();
    internal static string get_InsufficentMemory();
    internal static string get_HttpContentTypeHeaderRequired();
    internal static string get_ResponseContentTypeMismatch();
    internal static string get_HttpToMustEqualVia();
    internal static string get_FramingContentTypeMismatch();
    internal static string get_FramingFaultUnrecognized();
    internal static string get_FramingContentTypeTooLongFault();
    internal static string get_FramingViaTooLongFault();
    internal static string get_FramingModeNotSupportedFault();
    internal static string get_FramingVersionNotSupportedFault();
    internal static string get_FramingUpgradeInvalid();
    internal static string get_ServerTooBusy();
    internal static string get_PreambleAckIncorrect();
    internal static string get_PreambleAckIncorrectMaybeHttp();
    internal static string get_StreamError();
    internal static string get_ServerRejectedUpgradeRequest();
    internal static string get_ServerRejectedSessionPreamble();
    internal static string get_HttpRequiresSingleAuthScheme();
    internal static string get_HttpAuthSchemeCannotBeNone();
    internal static string get_HttpAuthorizationFailed();
    internal static string get_HttpAuthorizationForbidden();
    internal static string get_InvalidUriScheme();
    internal static string get_HttpsServerCertThumbprintMismatch();
    internal static string get_TrustFailure();
    internal static string get_StreamMutualAuthNotSatisfied();
    internal static string get_InvalidTokenProvided();
    internal static string get_NoUserNameTokenProvided();
    internal static string get_RemoteIdentityFailedVerification();
    internal static string get_CredentialDisallowsNtlm();
    internal static string get_UriGeneratorSchemeMustNotBeEmpty();
    internal static string get_UnsupportedSslProtectionLevel();
    internal static string get_TimeoutServiceChannelConcurrentOpen1();
    internal static string get_TimeoutServiceChannelConcurrentOpen2();
    internal static string get_TimeSpanMustbeGreaterThanTimeSpanZero();
    internal static string get_AsyncResultCompletedTwice();
    internal static string get_ValueMustBeNonNegative();
    internal static string get_ValueMustBePositive();
    internal static string get_ValueMustBeGreaterThanZero();
    internal static string get_ValueMustBeInRange();
    internal static string get_OffsetExceedsBufferSize();
    internal static string get_SizeExceedsRemainingBufferSpace();
    internal static string get_SpaceNeededExceedsMessageFrameOffset();
    internal static string get_FaultConverterDidNotCreateFaultMessage();
    internal static string get_FaultConverterCreatedFaultMessage();
    internal static string get_FaultConverterDidNotCreateException();
    internal static string get_FaultConverterCreatedException();
    internal static string get_UnsupportedUpgradeInitiator();
    internal static string get_StreamUpgradeUnsupportedChannelBindingKind();
    internal static string get_ExtendedProtectionNotSupported();
    internal static string get_HttpClientCredentialTypeInvalid();
    internal static string get_TransportDoesNotSupportCompression();
    internal static string get_UnsupportedSecuritySetting();
    internal static string get_UnsupportedBindingProperty();
    internal static string get_HttpMaxPendingAcceptsTooLargeError();
    internal static string get_UnsupportedTokenImpersonationLevel();
    internal static string get_TimeoutOnOpen();
    internal static string get_TimeoutOnRequest();
    internal static string get_SFxActionDemuxerDuplicate();
    internal static string get_SFXBindingNameCannotBeNullOrEmpty();
    internal static string get_SFXUnvalidNamespaceValue();
    internal static string get_SFXUnvalidNamespaceParam();
    internal static string get_SFXHeaderNameCannotBeNullOrEmpty();
    internal static string get_SFxBadByReferenceParameterMetadata();
    internal static string get_SFxBadByValueParameterMetadata();
    internal static string get_SFxBindingMustContainTransport2();
    internal static string get_SFxBodyCannotBeNull();
    internal static string get_SFxCallbackBehaviorAttributeOnlyOnDuplex();
    internal static string get_SFxCallbackRequestReplyInOrder1();
    internal static string get_SfxCallbackTypeCannotBeNull();
    internal static string get_SFxCannotActivateCallbackInstace();
    internal static string get_SFxCannotCallAutoOpenWhenExplicitOpenCalled();
    internal static string get_SFxCannotSetExtensionsByIndex();
    internal static string get_SFxChannelDispatcherNoMessageVersion();
    internal static string get_SFxChannelDispatcherUnableToOpen1();
    internal static string get_SFxChannelDispatcherUnableToOpen2();
    internal static string get_SFxChannelFactoryTypeMustBeInterface();
    internal static string get_SFxChannelFactoryCannotCreateFactoryWithoutDescription();
    internal static string get_SFxClientOutputSessionAutoClosed();
    internal static string get_SFxCollectionDoesNotSupportSet0();
    internal static string get_SFxCollectionReadOnly();
    internal static string get_SFxCollectionWrongType2();
    internal static string get_SFxContextModifiedInsideScope0();
    internal static string get_SFxContractDescriptionNameCannotBeEmpty();
    internal static string get_SFxContractHasZeroOperations();
    internal static string get_SFxContractHasZeroInitiatingOperations();
    internal static string get_SFxContractInheritanceRequiresInterfaces();
    internal static string get_SFxContractInheritanceRequiresInterfaces2();
    internal static string get_SFxCopyToRequiresICollection();
    internal static string get_SFxCreateDuplexChannel1();
    internal static string get_SFxCreateDuplexChannelNoCallback();
    internal static string get_SFxCreateDuplexChannelNoCallback1();
    internal static string get_SFxCreateDuplexChannelNoCallbackUserObject();
    internal static string get_SFxCreateDuplexChannelBadCallbackUserObject();
    internal static string get_SFxCreateNonDuplexChannel1();
    internal static string get_SFxCustomBindingNeedsTransport1();
    internal static string get_SFxDeserializationFailed1();
    internal static string get_SFxDisallowedAttributeCombination();
    internal static string get_SFxInitializationUINotCalled();
    internal static string get_SFxInitializationUIDisallowed();
    internal static string get_SFxDocEncodedNotSupported();
    internal static string get_SFxDuplicateMessageParts();
    internal static string get_SFXEndpointBehaviorUsedOnWrongSide();
    internal static string get_SFxEndpointDispatcherMultipleChannelDispatcher0();
    internal static string get_SFxEndpointDispatcherDifferentChannelDispatcher0();
    internal static string get_SFxErrorDeserializingRequestBody();
    internal static string get_SFxErrorDeserializingRequestBodyMore();
    internal static string get_SFxErrorDeserializingReplyBody();
    internal static string get_SFxErrorDeserializingReplyBodyMore();
    internal static string get_SFxErrorSerializingBody();
    internal static string get_SFxErrorDeserializingHeader();
    internal static string get_SFxErrorSerializingHeader();
    internal static string get_SFxErrorDeserializingFault();
    internal static string get_SFxErrorReflectingOnType2();
    internal static string get_SFxErrorReflectingOnMethod3();
    internal static string get_SFxErrorReflectingOnParameter4();
    internal static string get_SFxErrorReflectionOnUnknown1();
    internal static string get_SFxExceptionDetailEndOfInner();
    internal static string get_SFxExceptionDetailFormat();
    internal static string get_SFxFaultContractDuplicateDetailType();
    internal static string get_SFxFaultContractDuplicateElement();
    internal static string get_SFxFaultExceptionToString3();
    internal static string get_SFxFaultReason();
    internal static string get_SFxFaultTypeAnonymous();
    internal static string get_SFxHeaderNameMismatchInMessageContract();
    internal static string get_SFxHeaderNameMismatchInOperation();
    internal static string get_SFxHeaderNamespaceMismatchInMessageContract();
    internal static string get_SFxHeaderNamespaceMismatchInOperation();
    internal static string get_SFxHeaderNotUnderstood();
    internal static string get_SFxImmutableServiceHostBehavior0();
    internal static string get_SFxImmutableChannelFactoryBehavior0();
    internal static string get_SFxInputParametersToServiceInvalid();
    internal static string get_SFxInputParametersToServiceNull();
    internal static string get_SFxInstanceNotInitialized();
    internal static string get_SFxInterleavedContextScopes0();
    internal static string get_SFxInternalServerError();
    internal static string get_SFxInternalCallbackError();
    internal static string get_SFxInvalidAsyncResultState0();
    internal static string get_SFxInvalidCallbackIAsyncResult();
    internal static string get_SFxInvalidCallbackContractType();
    internal static string get_SFxInvalidChannelToOperationContext();
    internal static string get_SFxInvalidMessageBody();
    internal static string get_SFxInvalidMessageBodyEmptyMessage();
    internal static string get_SFxInvalidMessageBodyErrorSerializingParameter();
    internal static string get_SFxInvalidMessageBodyErrorDeserializingParameter();
    internal static string get_SFxInvalidMessageBodyErrorDeserializingParameterMore();
    internal static string get_SFxInvalidMessageContractSignature();
    internal static string get_SFxInvalidMessageHeaderArrayType();
    internal static string get_SFxInvalidRequestAction();
    internal static string get_SFxInvalidReplyAction();
    internal static string get_SFxInvalidStreamInTypedMessage();
    internal static string get_SFxInvalidStreamInRequest();
    internal static string get_SFxInvalidStreamInResponse();
    internal static string get_SFxInvalidStreamOffsetLength();
    internal static string get_SFxInvalidUseOfPrimitiveOperationFormatter();
    internal static string get_SFxInvalidStaticOverloadCalledForDuplexChannelFactory1();
    internal static string get_SFxInvalidXmlAttributeInBare();
    internal static string get_SFxInvalidXmlAttributeInWrapped();
    internal static string get_SFxKnownTypeAttributeInvalid1();
    internal static string get_SFxKnownTypeAttributeReturnType3();
    internal static string get_SFxKnownTypeAttributeUnknownMethod3();
    internal static string get_SFxKnownTypeNull();
    internal static string get_SFxMessageContractBaseTypeNotValid();
    internal static string get_SFxMessageContractRequiresDefaultConstructor();
    internal static string get_SFxMetadataReferenceInvalidLocation();
    internal static string get_SFxMethodNotSupported1();
    internal static string get_SFxMethodNotSupportedOnCallback1();
    internal static string get_SFxMismatchedOperationParent();
    internal static string get_SFxMissingActionHeader();
    internal static string get_SFxMultipleCallbackFromSynchronizationContext();
    internal static string get_SFxMultipleCallbackFromAsyncOperation();
    internal static string get_SFxMultipleUnknownHeaders();
    internal static string get_SFxMultipleContractStarOperations0();
    internal static string get_SFxNameCannotBeEmpty();
    internal static string get_SFxConfigurationNameCannotBeEmpty();
    internal static string get_SFxNeedProxyBehaviorOperationSelector2();
    internal static string get_SFxNoDefaultConstructor();
    internal static string get_SFxNoMostDerivedContract();
    internal static string get_SFxNullReplyFromFormatter2();
    internal static string get_SFxServiceChannelIdleAborted();
    internal static string get_SFxSetEnableFaultsOnChannelDispatcher0();
    internal static string get_SFxSetManualAddressingOnChannelDispatcher0();
    internal static string get_SFxNoServiceObject();
    internal static string get_SFxNonExceptionThrown();
    internal static string get_SFxNonInitiatingOperation1();
    internal static string get_SFxOneWayMessageToTwoWayMethod0();
    internal static string get_SFxOperationContractOnNonServiceContract();
    internal static string get_SFxOperationContractProviderOnNonServiceContract();
    internal static string get_SFxOperationDescriptionNameCannotBeEmpty();
    internal static string get_SFxParameterNameCannotBeNull();
    internal static string get_SFxOperationMustHaveOneOrTwoMessages();
    internal static string get_SFxParameterCountMismatch();
    internal static string get_SFxParameterMustBeMessage();
    internal static string get_SFxParametersMustBeEmpty();
    internal static string get_SFxParameterMustBeArrayOfOneElement();
    internal static string get_SFxRequestHasInvalidReplyToOnClient();
    internal static string get_SFxRequestHasInvalidFaultToOnClient();
    internal static string get_SFxRequestReplyNone();
    internal static string get_SFxRequestTimedOut1();
    internal static string get_SFxRequestTimedOut2();
    internal static string get_SFxReplyActionMismatch3();
    internal static string get_SFxResultMustBeMessage();
    internal static string get_SFxRpcMessageBodyPartNameInvalid();
    internal static string get_SFxServerDidNotReply();
    internal static string get_SFxStaticMessageHeaderPropertiesNotAllowed();
    internal static string get_SFxStreamIOException();
    internal static string get_SFxStreamRequestMessageClosed();
    internal static string get_SFxStreamResponseMessageClosed();
    internal static string get_SFxTimeoutOutOfRange0();
    internal static string get_SFxTimeoutOutOfRangeTooBig();
    internal static string get_SFxTypedMessageCannotBeNull();
    internal static string get_SFxTypedMessageCannotBeRpcLiteral();
    internal static string get_SFxTypedOrUntypedMessageCannotBeMixedWithParameters();
    internal static string get_SFxTypedOrUntypedMessageCannotBeMixedWithVoidInRpc();
    internal static string get_SFxUnknownFaultNoMatchingTranslation1();
    internal static string get_SFxUnknownFaultNullReason0();
    internal static string get_SFxUnknownFaultZeroReasons0();
    internal static string get_SFxVersionMismatchInOperationContextAndMessage2();
    internal static string get_SFxWrapperNameCannotBeEmpty();
    internal static string get_SFxXmlArrayNotAllowedForMultiple();
    internal static string get_SFxXmlSerializerIsNotFound();
    internal static string get_SFxChannelFactoryEndpointAddressUri();
    internal static string get_SFxCloseTimedOut1();
    internal static string get_SfxCloseTimedOutWaitingForDispatchToComplete();
    internal static string get_SFxChannelFactoryNoBindingFoundInConfig1();
    internal static string get_SFxChannelFactoryNoBindingFoundInConfigOrCode();
    internal static string get_SFxProxyRuntimeMessageCannotBeNull();
    internal static string get_SFxDispatchRuntimeMessageCannotBeNull();
    internal static string get_SFxMessagePartDescriptionMissingType();
    internal static string get_AChannelServiceEndpointSBindingIsNull0();
    internal static string get_AChannelServiceEndpointSContractIsNull0();
    internal static string get_AChannelServiceEndpointSContractSNameIsNull0();
    internal static string get_AChannelServiceEndpointSContractSNamespace0();
    internal static string get_SFxNoEndpointMatchingContract();
    internal static string get_SFxNoEndpointMatchingAddress();
    internal static string get_SFxNoEndpointMatchingAddressForConnectionOpeningMessage();
    internal static string get_SFxServiceChannelCannotBeCalledBecauseIsSessionOpenNotificationEnabled();
    internal static string get_EndMethodsCannotBeDecoratedWithOperationContractAttribute();
    internal static string get_DispatchRuntimeRequiresFormatter0();
    internal static string get_ClientRuntimeRequiresFormatter0();
    internal static string get_RuntimeRequiresInvoker0();
    internal static string get_CouldnTCreateChannelForType2();
    internal static string get_CouldnTCreateChannelForChannelType2();
    internal static string get_EndpointListenerRequirementsCannotBeMetBy3();
    internal static string get_UnknownListenerType1();
    internal static string get_BindingDoesnTSupportSessionButContractRequires1();
    internal static string get_BindingDoesntSupportDatagramButContractRequires();
    internal static string get_BindingDoesnTSupportOneWayButContractRequires1();
    internal static string get_BindingDoesnTSupportTwoWayButContractRequires1();
    internal static string get_BindingDoesnTSupportRequestReplyButContract1();
    internal static string get_BindingDoesnTSupportDuplexButContractRequires1();
    internal static string get_BindingDoesnTSupportAnyChannelTypes1();
    internal static string get_ContractIsNotSelfConsistentItHasOneOrMore2();
    internal static string get_ContractIsNotSelfConsistentWhenIsSessionOpenNotificationEnabled();
    internal static string get_SynchronizedCollectionWrongType1();
    internal static string get_SynchronizedCollectionWrongTypeNull();
    internal static string get_CannotAddTwoItemsWithTheSameKeyToSynchronizedKeyedCollection0();
    internal static string get_ItemDoesNotExistInSynchronizedKeyedCollection0();
    internal static string get_SuppliedMessageIsNotAReplyItHasNoRelatesTo0();
    internal static string get_channelIsNotAvailable0();
    internal static string get_channelDoesNotHaveADuplexSession0();
    internal static string get_UnsupportedEnvelopeVersion();
    internal static string get_ServicesWithoutAServiceContractAttributeCan2();
    internal static string get_tooManyAttributesOfTypeOn2();
    internal static string get_couldnTFindRequiredAttributeOfTypeOn2();
    internal static string get_AttemptedToGetContractTypeForButThatTypeIs1();
    internal static string get_NoEndMethodFoundForAsyncBeginMethod3();
    internal static string get_MoreThanOneEndMethodFoundForAsyncBeginMethod3();
    internal static string get_InvalidAsyncEndMethodSignatureForMethod2();
    internal static string get_InvalidAsyncBeginMethodSignatureForMethod2();
    internal static string get_InAContractInheritanceHierarchyIfParentHasCallbackChildMustToo();
    internal static string get_InAContractInheritanceHierarchyTheServiceContract3_2();
    internal static string get_CannotHaveTwoOperationsWithTheSameName3();
    internal static string get_CannotInheritTwoOperationsWithTheSameName3();
    internal static string get_SyncAsyncMatchConsistency_Parameters5();
    internal static string get_SyncTaskMatchConsistency_Parameters5();
    internal static string get_TaskAsyncMatchConsistency_Parameters5();
    internal static string get_SyncAsyncMatchConsistency_ReturnType5();
    internal static string get_SyncTaskMatchConsistency_ReturnType5();
    internal static string get_TaskAsyncMatchConsistency_ReturnType5();
    internal static string get_SyncAsyncMatchConsistency_Attributes6();
    internal static string get_SyncTaskMatchConsistency_Attributes6();
    internal static string get_TaskAsyncMatchConsistency_Attributes6();
    internal static string get_SyncAsyncMatchConsistency_Property6();
    internal static string get_SyncTaskMatchConsistency_Property6();
    internal static string get_TaskAsyncMatchConsistency_Property6();
    internal static string get_ServiceOperationsMarkedWithIsOneWayTrueMust0();
    internal static string get_OneWayOperationShouldNotSpecifyAReplyAction1();
    internal static string get_OneWayAndFaultsIncompatible2();
    internal static string get_AsyncEndCalledOnWrongChannel();
    internal static string get_AsyncEndCalledWithAnIAsyncResult();
    internal static string get_MessageHeaderIsNull0();
    internal static string get_MessagePropertiesArraySize0();
    internal static string get_DuplicateBehavior1();
    internal static string get_CantCreateChannelWithManualAddressing();
    internal static string get_XDCannotFindValueInDictionaryString();
    internal static string get_NoChannelBuilderAvailable();
    internal static string get_InvalidBindingScheme();
    internal static string get_CustomBindingRequiresTransport();
    internal static string get_TransportBindingElementMustBeLast();
    internal static string get_MessageVersionMissingFromBinding();
    internal static string get_NotAllBindingElementsBuilt();
    internal static string get_MultipleMebesInParameters();
    internal static string get_MultipleStreamUpgradeProvidersInParameters();
    internal static string get_SecurityCapabilitiesMismatched();
    internal static string get_BaseAddressMustBeAbsolute();
    internal static string get_BaseAddressDuplicateScheme();
    internal static string get_BaseAddressCannotHaveUserInfo();
    internal static string get_BaseAddressCannotHaveQuery();
    internal static string get_BaseAddressCannotHaveFragment();
    internal static string get_UriMustBeAbsolute();
    internal static string get_ClaimTypeCannotBeEmpty();
    internal static string get_MissingCustomCertificateValidator();
    internal static string get_SecurityAuditPlatformNotSupported();
    internal static string get_ActivityCallback();
    internal static string get_ActivityClose();
    internal static string get_ActivityConstructChannelFactory();
    internal static string get_ActivityExecuteMethod();
    internal static string get_ActivityCloseClientBase();
    internal static string get_ActivityOpenClientBase();
    internal static string get_ActivityProcessAction();
    internal static string get_ActivityProcessingMessage();
    internal static string get_InputTypeListEmptyError();
    internal static string get_DelegatingHandlerArrayHasNonNullInnerHandler();
    internal static string get_DelegatingHandlerArrayFromFuncContainsNullItem();
    internal static string get_HttpMessageHandlerTypeNotSupported();
    internal static string get_HttpPipelineNotSupportedOnClientSide();
    internal static string get_WebSocketInvalidProtocolInvalidCharInProtocolString();
    internal static string get_WebSocketInvalidProtocolContainsMultipleSubProtocolString();
    internal static string get_WebSocketInvalidProtocolEmptySubprotocolString();
    internal static string get_WebSocketUnexpectedCloseMessageError();
    internal static string get_WebSocketStreamWriteCalledAfterEOMSent();
    internal static string get_WebSocketCannotCreateRequestClientChannelWithCertainWebSocketTransportUsage();
    internal static string get_ClientWebSocketFactory_CreateWebSocketFailed();
    internal static string get_ClientWebSocketFactory_InvalidWebSocket();
    internal static string get_ClientWebSocketFactory_InvalidSubProtocol();
    internal static string get_WebSocketSendTimedOut();
    internal static string get_WebSocketReceiveTimedOut();
    internal static string get_WebSocketOperationTimedOut();
    internal static string get_WebSocketVersionMismatchFromServer();
    internal static string get_WebSocketSubProtocolMismatchFromServer();
    internal static string get_CopyHttpHeaderFailed();
    internal static string get_XmlInvalidConversion();
    internal static string get_XmlInvalidStream();
    internal static string get_LockTimeoutExceptionMessage();
    internal static string get_InvalidEnumArgument();
    internal static string get_InvalidTypedProxyMethodHandle();
    internal static string get_FailedToCreateTypedProxy();
    internal static string get_SecurityTokenRequirementDoesNotContainProperty();
    internal static string get_SecurityTokenRequirementHasInvalidTypeForProperty();
    internal static string get_TokenCancellationNotSupported();
    internal static string get_TokenProviderUnableToGetToken();
    internal static string get_TokenProviderUnableToRenewToken();
    internal static string get_TokenRenewalNotSupported();
    internal static string get_UserNameCannotBeEmpty();
    internal static string get_ActivityBoundary();
    internal static string get_StringNullOrEmpty();
    internal static string get_GenericCallbackException();
    internal static string get_ArgumentCannotBeEmptyString();
    internal static string get_KeyIdentifierClauseDoesNotSupportKeyCreation();
    internal static string get_SymmetricKeyLengthTooShort();
    internal static string get_KeyIdentifierCannotCreateKey();
    internal static string get_NoKeyIdentifierClauseFound();
    internal static string get_LocalIdCannotBeEmpty();
    internal static string get_CannotValidateSecurityTokenType();
    internal static string get_UnauthorizedAccess_MemStreamBuffer();
    internal static string get_ConfigurationFilesNotSupported();
    internal static string get_X509ChainBuildFail();
    internal static string get_ImpersonationLevelNotSupported();
    internal static string get_ProvidedNetworkCredentialsForKerberosHasInvalidUserName();
    internal static string get_SSLProtocolNegotiationFailed();
    internal static string get_ssl_io_cert_validation();
    internal static string get_X509InvalidUsageTime();
    internal static string get_X509IsInUntrustedStore();
    internal static string get_X509IsNotInTrustedStore();
    internal static string get_Xml_InvalidNodeType();
    internal static string get_SFxRpcMessageMustHaveASingleBody();
    internal static string get_SFxBodyObjectTypeCannotBeInherited();
    internal static string get_SFxBodyObjectTypeCannotBeInterface();
    internal static string get_SFxHeadersAreNotSupportedInEncoded();
    internal static string get_SFxMultiplePartsNotAllowedInEncoded();
    internal static string get_SFxInvalidSoapAttribute();
    internal static string get_SFxTerminatingOperationAlreadyCalled1();
    internal static string get_SFxChannelTerminated0();
    internal static string get_PeerTrustNotSupportedOnOSX();
    internal static string get_SFxNone2004();
    internal static string get_SFxRequestHasInvalidFromOnClient();
    internal static string get_ClientCredentialTypeMustBeSpecifiedForMixedMode();
    internal static string get_SecureConversationSecurityTokenParametersRequireBootstrapBinding();
    internal static string get_ProtocolMustBeInitiator();
    internal static string get_SecurityProtocolFactoryShouldBeSetBeforeThisOperation();
    internal static string get_IssuedSecurityTokenParametersNotSet();
    internal static string get_KeyRolloverGreaterThanKeyRenewal();
    internal static string get_SecuritySessionProtocolFactoryShouldBeSetBeforeThisOperation();
    internal static string get_SecurityStandardsManagerNotSet();
    internal static string get_ActivitySecurityClose();
    internal static string get_ClientSecurityCloseTimeout();
    internal static string get_ClientSecurityOutputSessionCloseTimeout();
    internal static string get_DelayedSecurityApplicationAlreadyCompleted();
    internal static string get_MessageBodyOperationNotValidInBodyState();
    internal static string get_MessageSecurityVerificationFailed();
    internal static string get_OutputNotExpected();
    internal static string get_PrimarySignatureMustBeComputedBeforeSupportingTokenSignatures();
    internal static string get_ProtocolMisMatch();
    internal static string get_SenderSideSupportingTokensMustSpecifySecurityTokenParameters();
    internal static string get_SigningWithoutPrimarySignatureRequiresTimestamp();
    internal static string get_SupportingTokenSignaturesNotExpected();
    internal static string get_TimestampAlreadySetForSecurityHeader();
    internal static string get_TokenDoesNotSupportKeyIdentifierClauseCreation();
    internal static string get_TokenManagerCannotCreateTokenReference();
    internal static string get_TokenMustBeNullWhenTokenParametersAre();
    internal static string get_TokenProviderCannotGetTokensForTarget();
    internal static string get_UnableToCreateTokenReference();
    internal static string get_UnableToFindSecurityHeaderInMessage();
    internal static string get_UnableToFindSecurityHeaderInMessageNoActor();
    internal static string get_UnknownTokenAttachmentMode();
    internal static string get_UnsupportedTokenInclusionMode();
    internal static string get_MismatchInSecurityOperationToken();
    internal static string get_ResolvingExternalTokensRequireSecurityTokenParameters();
    internal static string get_SecurityHeaderIsEmpty();
    internal static string get_AlgorithmAndPrivateKeyMisMatch();
    internal static string get_DuplicateTimestampInSecurityHeader();
    internal static string get_EmptyOrNullArgumentString();
    internal static string get_ErrorDeserializingKeyIdentifierClause();
    internal static string get_InvalidX509RawData();
    internal static string get_MissingPrivateKey();
    internal static string get_NoKeyInfoClausesToWrite();
    internal static string get_PrivateKeyNotSupported();
    internal static string get_UnableToResolveKeyReference();
    internal static string get_UnableToResolveTokenReference();
    internal static string get_UnsupportedCryptoAlgorithm();
    internal static string get_AlgorithmAndPublicKeyMisMatch();
    internal static string get_PublicKeyNotSupported();
    internal static string get_AtMostOneReferenceListIsSupportedWithDefaultPolicyCheck();
    internal static string get_CustomCryptoAlgorithmIsNotValidHashAlgorithm();
    internal static string get_DuplicateIdInMessageToBeVerified();
    internal static string get_ID6002();
    internal static string get_ID6033();
    internal static string get_MessageProtectionOrderMismatch();
    internal static string get_PrimarySignatureWasNotSignedByDerivedKey();
    internal static string get_PrimarySignatureWasNotSignedByDerivedWrappedKey();
    internal static string get_RequiredSecurityHeaderElementNotSigned();
    internal static string get_RequiredSecurityTokenNotEncrypted();
    internal static string get_RequiredSecurityTokenNotSigned();
    internal static string get_BadCloseTarget();
    internal static string get_ChannelMustBeOpenedToGetSessionId();
    internal static string get_CommunicationObjectCloseInterrupted1();
    internal static string get_ElementToSignMustHaveId();
    internal static string get_InvalidCloseResponseAction();
    internal static string get_InvalidRstRequestType();
    internal static string get_MoreThanOneRSTRInRSTRC();
    internal static string get_NoCloseTargetSpecified();
    internal static string get_NoPartsOfMessageMatchedPartsToSign();
    internal static string get_SecuritySessionFaultReplyWasSent();
    internal static string get_SessionKeyRenewalNotSupported();
    internal static string get_SessionTokenIsNotGenericXmlToken();
    internal static string get_SessionTokenWasNotClosed();
    internal static string get_TimeoutOnOperation();
    internal static string get_TimestampToSignHasNoId();
    internal static string get_TransportSecuredMessageHasMoreThanOneToHeader();
    internal static string get_TransportSecurityRequireToHeader();
    internal static string get_UnableToCreateHashAlgorithmFromAsymmetricCrypto();
    internal static string get_UnableToCreateKeyedHashAlgorithm();
    internal static string get_UnableToRenewSessionKey();
    internal static string get_UnexpectedSecuritySessionClose();
    internal static string get_UnexpectedSecuritySessionCloseResponse();
    internal static string get_UnknownICryptoType();
    internal static string get_UnsecuredMessageFaultReceived();
    internal static string get_UnsupportedCanonicalizationAlgorithm();
    internal static string get_ChannelNotOpen();
    internal static string get_ReceiveTimedOut();
    internal static string get_ReceiveTimedOutNoLocalAddress();
    internal static string get_TimeoutOnSend();
    internal static string get_CannotReadKeyIdentifierClause();
    internal static string get_ErrorSerializingKeyIdentifier();
    internal static string get_ErrorSerializingKeyIdentifierClause();
    internal static string get_MessageSecurityVersionOutOfRange();
    internal static string get_PrivateKeyNotDSA();
    internal static string get_PrivateKeyNotRSA();
    internal static string get_PublicKeyNotDSA();
    internal static string get_PublicKeyNotRSA();
    internal static string get_StandardsManagerCannotWriteObject();
    internal static string get_UnsupportedAlgorithmForCryptoOperation();
    internal static string get_DerivedKeyLengthSpecifiedInImplicitDerivedKeyClauseTooLong();
    internal static string get_MultipleMatchingCryptosFound();
    internal static string get_UnableToDeriveKeyFromKeyInfoClause();
    internal static string get_CannotFindMatchingCrypto();
    internal static string get_DerivedKeyCannotDeriveFromSecret();
    internal static string get_DerivedKeyLengthTooLong();
    internal static string get_DerivedKeyLimitExceeded();
    internal static string get_DerivedKeyPosAndGenBothSpecified();
    internal static string get_DerivedKeyPosAndGenNotSpecified();
    internal static string get_ExtendedProtectionPolicyCustomChannelBindingNotSupported();
    internal static string get_CantInferReferenceForToken();
    internal static string get_Remoting_SOAPInteropxsdInvalid();
    internal static string get_SecurityTokenManagerCannotCreateSerializerForVersion();
    internal static string get_TransportBindingElementNotFound();
    internal static string get_UnknownEncodingInBinarySecurityToken();
    internal static string get_UnsupportedPasswordType();
    internal static string get_BootstrapSecurityBindingElementNotSet();
    internal static string get_IssuerBuildContextNotSet();
    internal static string get_SecurityAlgorithmSuiteNotSet();
    internal static string get_TargetAddressIsNotSet();
    internal static string get_TokenProviderRequiresSecurityBindingElement();
    internal static string get_BadSecurityNegotiationContext();
    internal static string get_CannotObtainIssuedTokenKeySize();
    internal static string get_ClientSecurityNegotiationTimeout();
    internal static string get_ClientSecuritySessionRequestTimeout();
    internal static string get_FailToReceiveReplyFromNegotiation();
    internal static string get_InvalidActionForNegotiationMessage();
    internal static string get_InvalidIssuedTokenKeySize();
    internal static string get_InvalidRenewResponseAction();
    internal static string get_IssuerBindingNotPresentInTokenRequirement();
    internal static string get_KeyLengthMustBeMultipleOfEight();
    internal static string get_NegotiationIsCompleted();
    internal static string get_NegotiationIsNotCompleted();
    internal static string get_NoNegotiationMessageToSend();
    internal static string get_SecurityEndpointNotFound();
    internal static string get_SecurityNegotiationCannotProtectConfidentialEndpointHeader();
    internal static string get_SecurityServerTooBusy();
    internal static string get_SoapSecurityNegotiationFailed();
    internal static string get_SoapSecurityNegotiationFailedForIssuerAndTarget();
    internal static string get_BadIssuedTokenType();
    internal static string get_BearerKeyTypeCannotHaveProofKey();
    internal static string get_DerivedKeyInvalidGenerationSpecified();
    internal static string get_DerivedKeyInvalidOffsetSpecified();
    internal static string get_DerivedKeyTokenLabelTooLong();
    internal static string get_DerivedKeyTokenNonceTooLong();
    internal static string get_DerivedKeyTokenRequiresTokenReference();
    internal static string get_EntropyModeCannotHaveComputedKey();
    internal static string get_EntropyModeCannotHaveProofTokenOrIssuerEntropy();
    internal static string get_EntropyModeCannotHaveRequestorEntropy();
    internal static string get_EntropyModeRequiresComputedKey();
    internal static string get_EntropyModeRequiresIssuerEntropy();
    internal static string get_EntropyModeRequiresProofToken();
    internal static string get_EntropyModeRequiresRequestorEntropy();
    internal static string get_ErrorSerializingSecurityToken();
    internal static string get_InvalidKeyLengthRequested();
    internal static string get_InvalidKeySizeSpecifiedInNegotiation();
    internal static string get_NoLicenseXml();
    internal static string get_NoRequestSecurityTokenResponseElements();
    internal static string get_RstrHasMultipleIssuedTokens();
    internal static string get_RstrHasMultipleProofTokens();
    internal static string get_RstrKeySizeNotProvided();
    internal static string get_TokenCannotCreateSymmetricCrypto();
    internal static string get_TrustDriverIsUnableToCreatedNecessaryAttachedOrUnattachedReferences();
    internal static string get_UnexpectedBinarySecretType();
    internal static string get_UnknownComputedKeyAlgorithm();
    internal static string get_UnknownEncodingInKeyIdentifier();
    internal static string get_UnsupportedBinaryEncoding();
    internal static string get_UnsupportedIssuerEntropyType();
    internal static string get_UnsupportedKeyDerivationAlgorithm();
    internal static string get_BasicTokenNotExpected();
    internal static string get_CustomCryptoAlgorithmIsNotValidKeyedHashAlgorithm();
    internal static string get_SignedSupportingTokenNotExpected();
    internal static string get_TokenManagerCouldNotReadToken();
    internal static string get_UnableToFindTokenAuthenticator();
    internal static string get_UnableToResolveKeyInfoClauseInDerivedKeyToken();
    internal static string get_UnknownTokenAuthenticatorUsedInTokenProcessing();
    internal static string get_BasicHttpMessageSecurityRequiresCertificate();
    internal static string get_NoCookieInSct();
    internal static string get_NoSecurityContextIdentifier();
    internal static string get_SecurityContextNotRegistered();
    internal static string get_AcksToMustBeSameAsRemoteAddress();
    internal static string get_AcksToMustBeSameAsRemoteAddressReason();
    internal static string get_CloseOutputSessionErrorReason();
    internal static string get_CouldNotParseWithAction();
    internal static string get_CSRefused();
    internal static string get_CSRefusedAcksToMustEqualEndpoint();
    internal static string get_CSRefusedAcksToMustEqualReplyTo();
    internal static string get_CSRefusedInvalidIncompleteSequenceBehavior();
    internal static string get_CSRefusedNoSTRWSSecurity();
    internal static string get_CSRefusedRequiredSecurityElementMissing();
    internal static string get_CSRefusedSSLNotSupported();
    internal static string get_CSRefusedSTRNoWSSecurity();
    internal static string get_CSRefusedUnexpectedElementAtEndOfCSMessage();
    internal static string get_CSResponseOfferRejected();
    internal static string get_CSResponseOfferRejectedReason();
    internal static string get_CSResponseWithInvalidIncompleteSequenceBehavior();
    internal static string get_CSResponseWithOffer();
    internal static string get_CSResponseWithOfferReason();
    internal static string get_CSResponseWithoutOffer();
    internal static string get_CSResponseWithoutOfferReason();
    internal static string get_EarlySecurityClose();
    internal static string get_EarlySecurityFaulted();
    internal static string get_EarlyTerminateSequence();
    internal static string get_InconsistentLastMsgNumberExceptionString();
    internal static string get_InvalidAcknowledgementFaultReason();
    internal static string get_InvalidAcknowledgementReceived();
    internal static string get_InvalidBufferRemaining();
    internal static string get_InvalidSequenceNumber();
    internal static string get_InvalidSequenceRange();
    internal static string get_InvalidWsrmResponseChannelNotOpened();
    internal static string get_InvalidWsrmResponseSessionFaultedExceptionString();
    internal static string get_InvalidWsrmResponseSessionFaultedFaultString();
    internal static string get_LastMessageNumberExceeded();
    internal static string get_LastMessageNumberExceededFaultReason();
    internal static string get_ManualAddressingNotSupported();
    internal static string get_MaximumRetryCountExceeded();
    internal static string get_MessageExceptionOccurred();
    internal static string get_MessageNumberRollover();
    internal static string get_MessageNumberRolloverFaultReason();
    internal static string get_MissingFinalAckExceptionString();
    internal static string get_MissingMessageIdOnWsrmRequest();
    internal static string get_MissingRelatesToOnWsrmResponseReason();
    internal static string get_MissingReplyToOnWsrmRequest();
    internal static string get_NoActionNoSequenceHeaderReason();
    internal static string get_NonEmptyWsrmMessageIsEmpty();
    internal static string get_NonWsrmFeb2005ActionNotSupported();
    internal static string get_ReceivedResponseBeforeRequestExceptionString();
    internal static string get_ReceivedResponseBeforeRequestFaultString();
    internal static string get_ReplyMissingAcknowledgement();
    internal static string get_SecureConversationRequiredByReliableSession();
    internal static string get_SequenceClosedFaultString();
    internal static string get_SequenceTerminatedAddLastToWindowTimedOut();
    internal static string get_SequenceTerminatedEarlyTerminateSequence();
    internal static string get_SequenceTerminatedInactivityTimeoutExceeded();
    internal static string get_SequenceTerminatedInconsistentLastMsgNumber();
    internal static string get_SequenceTerminatedMaximumRetryCountExceeded();
    internal static string get_SequenceTerminatedMissingFinalAck();
    internal static string get_SequenceTerminatedOnAbort();
    internal static string get_SequenceTerminatedQuotaExceededException();
    internal static string get_SequenceTerminatedReliableRequestThrew();
    internal static string get_SequenceTerminatedReplyMissingAcknowledgement();
    internal static string get_SequenceTerminatedSessionClosedBeforeDone();
    internal static string get_SequenceTerminatedSmallLastMsgNumber();
    internal static string get_SequenceTerminatedUnexpectedAckRequested();
    internal static string get_SequenceTerminatedUnexpectedCloseSequenceResponse();
    internal static string get_SequenceTerminatedUnexpectedCS();
    internal static string get_SequenceTerminatedUnexpectedCSROfferId();
    internal static string get_SequenceTerminatedUnexpectedTerminateSequence();
    internal static string get_SequenceTerminatedUnknownAddToWindowError();
    internal static string get_SequenceTerminatedUnsupportedClose();
    internal static string get_SequenceTerminatedUnsupportedTerminateSequence();
    internal static string get_SessionClosedBeforeDone();
    internal static string get_SmallLastMsgNumberExceptionString();
    internal static string get_TimeoutOnAddToWindow();
    internal static string get_TimeoutOnClose();
    internal static string get_TraceCodeWsrmNegativeElapsedTimeDetected();
    internal static string get_TransferModeNotSupported();
    internal static string get_UnexpectedAckRequested();
    internal static string get_UnexpectedCloseSequenceResponse();
    internal static string get_UnexpectedCS();
    internal static string get_UnexpectedCSROfferId();
    internal static string get_UnexpectedTerminateSequence();
    internal static string get_UnknownSequenceFaultReason();
    internal static string get_UnknownSequenceFaultReceived();
    internal static string get_UnknownSequenceMessageReceived();
    internal static string get_UnparsableCSResponse();
    internal static string get_UnrecognizedFaultReceived();
    internal static string get_UnrecognizedFaultReceivedOnOpen();
    internal static string get_UnsupportedCloseExceptionString();
    internal static string get_UnsupportedTerminateSequenceExceptionString();
    internal static string get_WrongIdentifierFault();
    internal static string get_WsrmFaultReceived();
    internal static string get_WsrmMessageProcessingError();
    internal static string get_WsrmMessageWithWrongRelatesToExceptionString();
    internal static string get_WsrmMessageWithWrongRelatesToFaultString();
    internal static string get_WsrmRequestIncorrectReplyToExceptionString();
    internal static string get_WsrmRequestIncorrectReplyToFaultString();
    internal static string get_WsrmRequiredExceptionString();
    internal static string get_WsrmRequiredFaultString();
    internal static string get_BindingRequirementsAttributeDisallowsQueuedDelivery1();
    internal static string get_BindingRequirementsAttributeRequiresQueuedDelivery1();
    internal static string get_SinceTheBindingForDoesnTSupportIBindingCapabilities1_1();
    internal static string get_SinceTheBindingForDoesnTSupportIBindingCapabilities2_1();
    internal static string get_TheBindingForDoesnTSupportOrderedDelivery1();
    internal static string get_HttpsExplicitIdentity();
    internal static string get_HttpsIdentityMultipleCerts();
    internal static string get_OnlyDefaultSpnServiceSupported();
    internal static string get_MtomBoundaryInvalid();
    internal static string get_MtomBufferQuotaExceeded();
    internal static string get_MtomContentTransferEncodingNotPresent();
    internal static string get_MtomContentTransferEncodingNotSupported();
    internal static string get_MtomContentTypeInvalid();
    internal static string get_MtomDataMustNotContainXopInclude();
    internal static string get_MtomExceededMaxSizeInBytes();
    internal static string get_MtomInvalidCIDUri();
    internal static string get_MtomInvalidEmptyURI();
    internal static string get_MtomInvalidStartUri();
    internal static string get_MtomInvalidTransferEncodingForMimePart();
    internal static string get_MtomMessageContentTypeNotFound();
    internal static string get_MtomMessageInvalidContent();
    internal static string get_MtomMessageInvalidContentInMimePart();
    internal static string get_MtomMessageInvalidMimeVersion();
    internal static string get_MtomMessageNotApplicationXopXml();
    internal static string get_MtomMessageNotMultipart();
    internal static string get_MtomMessageRequiredParamNotSpecified();
    internal static string get_MtomMimePartReferencedMoreThanOnce();
    internal static string get_MtomPartNotFound();
    internal static string get_MtomRootContentTypeNotFound();
    internal static string get_MtomRootNotApplicationXopXml();
    internal static string get_MtomRootPartNotFound();
    internal static string get_MtomRootRequiredParamNotSpecified();
    internal static string get_MtomRootUnexpectedCharset();
    internal static string get_MtomRootUnexpectedType();
    internal static string get_MtomXopIncludeHrefNotSpecified();
    internal static string get_MtomXopIncludeInvalidXopAttributes();
    internal static string get_MtomXopIncludeInvalidXopElement();
    internal static string get_XmlInvalidBinHexSequence();
    internal static string get_XmlInvalidBinHexLength();
    internal static string get_XmlArrayTooSmall();
    internal static string get_XmlMaxStringContentLengthExceeded();
    internal static string get_XmlLineInfo();
    internal static string get_MimeContentTypeHeaderInvalid();
    internal static string get_MimeHeaderInvalidCharacter();
    internal static string get_MimeMessageGetContentStreamCalledAlready();
    internal static string get_MaxMimePartsExceeded();
    internal static string get_MimeReaderHeaderAlreadyExists();
    internal static string get_MimeReaderMalformedHeader();
    internal static string get_MimeReaderResetCalledBeforeEOF();
    internal static string get_MimeReaderTruncated();
    internal static string get_MimeVersionHeaderInvalid();
    internal static string get_MimeWriterInvalidStateForClose();
    internal static string get_MimeWriterInvalidStateForHeader();
    internal static string get_MimeWriterInvalidStateForContent();
    internal static string get_MimeWriterInvalidStateForStartPart();
    internal static string get_MimeWriterInvalidStateForStartPreface();
    internal static string get_ReadNotSupportedOnStream();
    internal static string get_SeekNotSupportedOnStream();
    internal static string get_WriteBufferOverflow();
    internal static string get_WriteNotSupportedOnStream();
    internal static string get_XmlWriterClosed();
    internal static string get_MtomEncoderBadMessageVersion();
    internal static string get_SFxErrorCreatingMtomReader();
    internal static string get_SFxImmutableClientBaseCacheSetting();
    internal static string get_SFxMessageContractAttributeRequired();
    internal static string get_SFxActionMismatch();
    internal static string get_SFxNullReplyFromExtension2();
}
internal class System.Text.BinHexEncoding : Encoding {
    private static Byte[] s_char2val;
    private static string s_val2char;
    private static BinHexEncoding();
    public virtual int GetMaxByteCount(int charCount);
    public virtual int GetByteCount(Char[] chars, int index, int count);
    public virtual int GetBytes(Char[] chars, int charIndex, int charCount, Byte[] bytes, int byteIndex);
    public virtual int GetMaxCharCount(int byteCount);
    public virtual int GetCharCount(Byte[] bytes, int index, int count);
    public virtual int GetChars(Byte[] bytes, int byteIndex, int byteCount, Char[] chars, int charIndex);
}
internal class System.Xml.BufferedReadStream : Stream {
    private Stream stream;
    private Byte[] storedBuffer;
    private int storedLength;
    private int storedOffset;
    private bool readMore;
    public bool CanWrite { get; }
    public bool CanSeek { get; }
    public bool CanRead { get; }
    public long Length { get; }
    public long Position { get; public set; }
    public BufferedReadStream(Stream stream);
    public BufferedReadStream(Stream stream, bool readMore);
    public virtual bool get_CanWrite();
    public virtual bool get_CanSeek();
    public virtual bool get_CanRead();
    public virtual long get_Length();
    public virtual long get_Position();
    public virtual void set_Position(long value);
    public virtual IAsyncResult BeginRead(Byte[] buffer, int offset, int count, AsyncCallback callback, object state);
    public virtual IAsyncResult BeginWrite(Byte[] buffer, int offset, int count, AsyncCallback callback, object state);
    public virtual void Close();
    public virtual int EndRead(IAsyncResult asyncResult);
    public virtual void EndWrite(IAsyncResult asyncResult);
    public virtual void Flush();
    public virtual int Read(Byte[] buffer, int offset, int count);
    public virtual int ReadByte();
    public int ReadBlock(Byte[] buffer, int offset, int count);
    public void Push(Byte[] buffer, int offset, int count);
    public virtual long Seek(long offset, SeekOrigin origin);
    public virtual void SetLength(long value);
    public virtual void Write(Byte[] buffer, int offset, int count);
}
internal class System.Xml.BufferedWrite : object {
    private Byte[] buffer;
    private int offset;
    internal int Length { get; }
    internal BufferedWrite(int initialSize);
    private void EnsureBuffer(int count);
    internal int get_Length();
    internal Byte[] GetBuffer();
    internal void Reset();
    internal void Write(Byte[] value);
    internal void Write(Byte[] value, int index, int count);
    internal void Write(string value);
    internal void Write(string value, int index, int count);
}
internal class System.Xml.ContentIDHeader : MimeHeader {
    public ContentIDHeader(string name, string value);
}
internal enum System.Xml.ContentTransferEncoding : Enum {
    public int value__;
    public static ContentTransferEncoding SevenBit;
    public static ContentTransferEncoding EightBit;
    public static ContentTransferEncoding Binary;
    public static ContentTransferEncoding Other;
    public static ContentTransferEncoding Unspecified;
}
internal class System.Xml.ContentTransferEncodingHeader : MimeHeader {
    private ContentTransferEncoding contentTransferEncoding;
    private string contentTransferEncodingValue;
    public static ContentTransferEncodingHeader Binary;
    public static ContentTransferEncodingHeader EightBit;
    public static ContentTransferEncodingHeader SevenBit;
    public ContentTransferEncoding ContentTransferEncoding { get; }
    public string ContentTransferEncodingValue { get; }
    public ContentTransferEncodingHeader(string value);
    public ContentTransferEncodingHeader(ContentTransferEncoding contentTransferEncoding, string value);
    private static ContentTransferEncodingHeader();
    public ContentTransferEncoding get_ContentTransferEncoding();
    public string get_ContentTransferEncodingValue();
    private void ParseValue();
}
internal class System.Xml.ContentTypeHeader : MimeHeader {
    public static ContentTypeHeader Default;
    private string mediaType;
    private string subType;
    private Dictionary`2<string, string> parameters;
    public string MediaType { get; }
    public string MediaSubtype { get; }
    public Dictionary`2<string, string> Parameters { get; }
    public ContentTypeHeader(string value);
    private static ContentTypeHeader();
    public string get_MediaType();
    public string get_MediaSubtype();
    public Dictionary`2<string, string> get_Parameters();
    private void ParseValue();
}
internal class System.Xml.DelimittedStreamReader : object {
    private bool canGetNextStream;
    private DelimittedReadStream currentStream;
    private Byte[] delimitter;
    private Byte[] matchBuffer;
    private Byte[] scratch;
    private BufferedReadStream stream;
    public DelimittedStreamReader(Stream stream);
    public void Close();
    private void Close(DelimittedReadStream caller);
    public Stream GetNextStream(Byte[] delimitter);
    private MatchState MatchDelimitter(Byte[] buffer, int start, int end);
    private int ProcessRead(Byte[] buffer, int offset, int read);
    private int Read(DelimittedReadStream caller, Byte[] buffer, int offset, int count);
    private bool MatchRemainder(int start, int count);
    internal void Push(Byte[] buffer, int offset, int count);
}
internal interface System.Xml.IXmlMtomReaderInitializer {
    public abstract virtual void SetInput(Byte[] buffer, int offset, int count, Encoding[] encodings, string contentType, XmlDictionaryReaderQuotas quotas, int maxBufferSize, OnXmlDictionaryReaderClose onClose);
    public abstract virtual void SetInput(Stream stream, Encoding[] encodings, string contentType, XmlDictionaryReaderQuotas quotas, int maxBufferSize, OnXmlDictionaryReaderClose onClose);
}
internal interface System.Xml.IXmlMtomWriterInitializer {
    public abstract virtual void SetOutput(Stream stream, Encoding encoding, int maxSizeInBytes, string startInfo, string boundary, string startUri, bool writeMessageHeaders, bool ownsStream);
}
internal static class System.Xml.MailBnfHelper : object {
    private static Boolean[] s_fqtext;
    private static Boolean[] s_ttext;
    private static Boolean[] s_digits;
    private static Boolean[] s_boundary;
    private static MailBnfHelper();
    public static bool SkipCFWS(string data, Int32& offset);
    public static string ReadQuotedString(string data, Int32& offset, StringBuilder builder);
    public static string ReadParameterAttribute(string data, Int32& offset, StringBuilder builder);
    public static string ReadParameterValue(string data, Int32& offset, StringBuilder builder);
    public static string ReadToken(string data, Int32& offset, StringBuilder builder);
    public static string ReadDigits(string data, Int32& offset, StringBuilder builder);
    public static bool IsValidMimeBoundary(string data);
}
internal static class System.Xml.MimeGlobals : object {
    internal static string MimeVersionHeader;
    internal static string DefaultVersion;
    internal static string ContentIDScheme;
    internal static string ContentIDHeader;
    internal static string ContentTypeHeader;
    internal static string ContentTransferEncodingHeader;
    internal static string EncodingBinary;
    internal static string Encoding8bit;
    internal static Byte[] COLONSPACE;
    internal static Byte[] DASHDASH;
    internal static Byte[] CRLF;
    internal static Byte[] BoundaryPrefix;
    private static MimeGlobals();
}
internal class System.Xml.MimeHeader : object {
    private string name;
    private string value;
    public string Name { get; }
    public string Value { get; }
    public MimeHeader(string name, string value);
    public string get_Name();
    public string get_Value();
}
internal class System.Xml.MimeHeaderReader : object {
    private string value;
    private Byte[] buffer;
    private int maxOffset;
    private string name;
    private int offset;
    private ReadState readState;
    private Stream stream;
    public string Value { get; }
    public string Name { get; }
    public MimeHeaderReader(Stream stream);
    public string get_Value();
    public string get_Name();
    public void Close();
    public bool Read(int maxBuffer, Int32& remaining);
    private bool ProcessBuffer(int maxBuffer, Int32& remaining);
    private bool BufferEnd();
    public void Reset(Stream stream);
    private void AppendValue(string value, int maxBuffer, Int32& remaining);
    private void AppendName(string value, int maxBuffer, Int32& remaining);
}
internal class System.Xml.MimeHeaders : object {
    private Dictionary`2<string, MimeHeader> headers;
    public ContentTypeHeader ContentType { get; }
    public ContentIDHeader ContentID { get; }
    public ContentTransferEncodingHeader ContentTransferEncoding { get; }
    public MimeVersionHeader MimeVersion { get; }
    public ContentTypeHeader get_ContentType();
    public ContentIDHeader get_ContentID();
    public ContentTransferEncodingHeader get_ContentTransferEncoding();
    public MimeVersionHeader get_MimeVersion();
    public void Add(string name, string value, Int32& remaining);
    public void Add(MimeHeader header);
    public void Release(Int32& remaining);
}
internal class System.Xml.MimeMessageReader : object {
    private static Byte[] CRLFCRLF;
    private bool getContentStreamCalled;
    private MimeHeaderReader mimeHeaderReader;
    private DelimittedStreamReader reader;
    public MimeMessageReader(Stream stream);
    private static MimeMessageReader();
    public Stream GetContentStream();
    public MimeHeaders ReadHeaders(int maxBuffer, Int32& remaining);
}
internal class System.Xml.MimeReader : object {
    private static Byte[] CRLFCRLF;
    private Byte[] boundaryBytes;
    private string content;
    private Stream currentStream;
    private MimeHeaderReader mimeHeaderReader;
    private DelimittedStreamReader reader;
    private Byte[] scratch;
    public string Preface { get; }
    public MimeReader(Stream stream, string boundary);
    private static MimeReader();
    public void Close();
    public string get_Preface();
    public Stream GetContentStream();
    public bool ReadNextPart();
    public MimeHeaders ReadHeaders(int maxBuffer, Int32& remaining);
    private int BlockRead(Stream stream, Byte[] buffer, int offset, int count);
}
internal class System.Xml.MimeVersionHeader : MimeHeader {
    public static MimeVersionHeader Default;
    private string version;
    public string Version { get; }
    public MimeVersionHeader(string value);
    private static MimeVersionHeader();
    public string get_Version();
    private void ParseValue();
}
internal class System.Xml.MimeWriter : object {
    private Stream stream;
    private Byte[] boundaryBytes;
    private MimeWriterState state;
    private BufferedWrite bufferedWrite;
    private Stream contentStream;
    internal MimeWriterState WriteState { get; }
    internal MimeWriter(Stream stream, string boundary);
    internal static int GetHeaderSize(string name, string value, int maxSizeInBytes);
    internal static Byte[] GetBoundaryBytes(string boundary);
    internal MimeWriterState get_WriteState();
    internal int GetBoundarySize();
    internal void StartPreface();
    internal void StartPart();
    [AsyncStateMachineAttribute("System.Xml.MimeWriter/<StartPartAsync>d__13")]
internal Task StartPartAsync();
    internal void Close();
    [AsyncStateMachineAttribute("System.Xml.MimeWriter/<CloseAsync>d__15")]
internal Task CloseAsync();
    private void Flush();
    [AsyncStateMachineAttribute("System.Xml.MimeWriter/<FlushAsync>d__17")]
private Task FlushAsync();
    internal void WriteHeader(string name, string value);
    internal Stream GetContentStream();
    [AsyncStateMachineAttribute("System.Xml.MimeWriter/<GetContentStreamAsync>d__20")]
internal Task`1<Stream> GetContentStreamAsync();
}
internal enum System.Xml.MimeWriterState : Enum {
    public int value__;
    public static MimeWriterState Start;
    public static MimeWriterState StartPreface;
    public static MimeWriterState StartPart;
    public static MimeWriterState Header;
    public static MimeWriterState Content;
    public static MimeWriterState Closed;
}
internal class System.Xml.MtomBinaryData : object {
    internal MtomBinaryDataType type;
    internal IStreamProvider provider;
    internal Byte[] chunk;
    internal long Length { get; }
    internal MtomBinaryData(IStreamProvider provider);
    internal MtomBinaryData(Byte[] buffer, int offset, int count);
    internal long get_Length();
}
internal enum System.Xml.MtomBinaryDataType : Enum {
    public int value__;
    public static MtomBinaryDataType Provider;
    public static MtomBinaryDataType Segment;
}
internal static class System.Xml.MtomGlobals : object {
    internal static string XopIncludeLocalName;
    internal static string XopIncludeNamespace;
    internal static string XopIncludePrefix;
    internal static string XopIncludeHrefLocalName;
    internal static string XopIncludeHrefNamespace;
    internal static string MediaType;
    internal static string MediaSubtype;
    internal static string BoundaryParam;
    internal static string TypeParam;
    internal static string XopMediaType;
    internal static string XopMediaSubtype;
    internal static string XopType;
    internal static string StartParam;
    internal static string StartInfoParam;
    internal static string ActionParam;
    internal static string CharsetParam;
    internal static string MimeContentTypeLocalName;
    internal static string MimeContentTypeNamespace200406;
    internal static string MimeContentTypeNamespace200505;
    internal static string DefaultContentTypeForBinary;
    private static MtomGlobals();
}
internal enum System.Xml.XmlBinaryNodeType : Enum {
    public int value__;
    public static XmlBinaryNodeType EndElement;
    public static XmlBinaryNodeType Comment;
    public static XmlBinaryNodeType Array;
    public static XmlBinaryNodeType MinAttribute;
    public static XmlBinaryNodeType ShortAttribute;
    public static XmlBinaryNodeType Attribute;
    public static XmlBinaryNodeType ShortDictionaryAttribute;
    public static XmlBinaryNodeType DictionaryAttribute;
    public static XmlBinaryNodeType ShortXmlnsAttribute;
    public static XmlBinaryNodeType XmlnsAttribute;
    public static XmlBinaryNodeType ShortDictionaryXmlnsAttribute;
    public static XmlBinaryNodeType DictionaryXmlnsAttribute;
    public static XmlBinaryNodeType PrefixDictionaryAttributeA;
    public static XmlBinaryNodeType PrefixDictionaryAttributeB;
    public static XmlBinaryNodeType PrefixDictionaryAttributeC;
    public static XmlBinaryNodeType PrefixDictionaryAttributeD;
    public static XmlBinaryNodeType PrefixDictionaryAttributeE;
    public static XmlBinaryNodeType PrefixDictionaryAttributeF;
    public static XmlBinaryNodeType PrefixDictionaryAttributeG;
    public static XmlBinaryNodeType PrefixDictionaryAttributeH;
    public static XmlBinaryNodeType PrefixDictionaryAttributeI;
    public static XmlBinaryNodeType PrefixDictionaryAttributeJ;
    public static XmlBinaryNodeType PrefixDictionaryAttributeK;
    public static XmlBinaryNodeType PrefixDictionaryAttributeL;
    public static XmlBinaryNodeType PrefixDictionaryAttributeM;
    public static XmlBinaryNodeType PrefixDictionaryAttributeN;
    public static XmlBinaryNodeType PrefixDictionaryAttributeO;
    public static XmlBinaryNodeType PrefixDictionaryAttributeP;
    public static XmlBinaryNodeType PrefixDictionaryAttributeQ;
    public static XmlBinaryNodeType PrefixDictionaryAttributeR;
    public static XmlBinaryNodeType PrefixDictionaryAttributeS;
    public static XmlBinaryNodeType PrefixDictionaryAttributeT;
    public static XmlBinaryNodeType PrefixDictionaryAttributeU;
    public static XmlBinaryNodeType PrefixDictionaryAttributeV;
    public static XmlBinaryNodeType PrefixDictionaryAttributeW;
    public static XmlBinaryNodeType PrefixDictionaryAttributeX;
    public static XmlBinaryNodeType PrefixDictionaryAttributeY;
    public static XmlBinaryNodeType PrefixDictionaryAttributeZ;
    public static XmlBinaryNodeType PrefixAttributeA;
    public static XmlBinaryNodeType PrefixAttributeB;
    public static XmlBinaryNodeType PrefixAttributeC;
    public static XmlBinaryNodeType PrefixAttributeD;
    public static XmlBinaryNodeType PrefixAttributeE;
    public static XmlBinaryNodeType PrefixAttributeF;
    public static XmlBinaryNodeType PrefixAttributeG;
    public static XmlBinaryNodeType PrefixAttributeH;
    public static XmlBinaryNodeType PrefixAttributeI;
    public static XmlBinaryNodeType PrefixAttributeJ;
    public static XmlBinaryNodeType PrefixAttributeK;
    public static XmlBinaryNodeType PrefixAttributeL;
    public static XmlBinaryNodeType PrefixAttributeM;
    public static XmlBinaryNodeType PrefixAttributeN;
    public static XmlBinaryNodeType PrefixAttributeO;
    public static XmlBinaryNodeType PrefixAttributeP;
    public static XmlBinaryNodeType PrefixAttributeQ;
    public static XmlBinaryNodeType PrefixAttributeR;
    public static XmlBinaryNodeType PrefixAttributeS;
    public static XmlBinaryNodeType PrefixAttributeT;
    public static XmlBinaryNodeType PrefixAttributeU;
    public static XmlBinaryNodeType PrefixAttributeV;
    public static XmlBinaryNodeType PrefixAttributeW;
    public static XmlBinaryNodeType PrefixAttributeX;
    public static XmlBinaryNodeType PrefixAttributeY;
    public static XmlBinaryNodeType PrefixAttributeZ;
    public static XmlBinaryNodeType MaxAttribute;
    public static XmlBinaryNodeType MinElement;
    public static XmlBinaryNodeType ShortElement;
    public static XmlBinaryNodeType Element;
    public static XmlBinaryNodeType ShortDictionaryElement;
    public static XmlBinaryNodeType DictionaryElement;
    public static XmlBinaryNodeType PrefixDictionaryElementA;
    public static XmlBinaryNodeType PrefixDictionaryElementB;
    public static XmlBinaryNodeType PrefixDictionaryElementC;
    public static XmlBinaryNodeType PrefixDictionaryElementD;
    public static XmlBinaryNodeType PrefixDictionaryElementE;
    public static XmlBinaryNodeType PrefixDictionaryElementF;
    public static XmlBinaryNodeType PrefixDictionaryElementG;
    public static XmlBinaryNodeType PrefixDictionaryElementH;
    public static XmlBinaryNodeType PrefixDictionaryElementI;
    public static XmlBinaryNodeType PrefixDictionaryElementJ;
    public static XmlBinaryNodeType PrefixDictionaryElementK;
    public static XmlBinaryNodeType PrefixDictionaryElementL;
    public static XmlBinaryNodeType PrefixDictionaryElementM;
    public static XmlBinaryNodeType PrefixDictionaryElementN;
    public static XmlBinaryNodeType PrefixDictionaryElementO;
    public static XmlBinaryNodeType PrefixDictionaryElementP;
    public static XmlBinaryNodeType PrefixDictionaryElementQ;
    public static XmlBinaryNodeType PrefixDictionaryElementR;
    public static XmlBinaryNodeType PrefixDictionaryElementS;
    public static XmlBinaryNodeType PrefixDictionaryElementT;
    public static XmlBinaryNodeType PrefixDictionaryElementU;
    public static XmlBinaryNodeType PrefixDictionaryElementV;
    public static XmlBinaryNodeType PrefixDictionaryElementW;
    public static XmlBinaryNodeType PrefixDictionaryElementX;
    public static XmlBinaryNodeType PrefixDictionaryElementY;
    public static XmlBinaryNodeType PrefixDictionaryElementZ;
    public static XmlBinaryNodeType PrefixElementA;
    public static XmlBinaryNodeType PrefixElementB;
    public static XmlBinaryNodeType PrefixElementC;
    public static XmlBinaryNodeType PrefixElementD;
    public static XmlBinaryNodeType PrefixElementE;
    public static XmlBinaryNodeType PrefixElementF;
    public static XmlBinaryNodeType PrefixElementG;
    public static XmlBinaryNodeType PrefixElementH;
    public static XmlBinaryNodeType PrefixElementI;
    public static XmlBinaryNodeType PrefixElementJ;
    public static XmlBinaryNodeType PrefixElementK;
    public static XmlBinaryNodeType PrefixElementL;
    public static XmlBinaryNodeType PrefixElementM;
    public static XmlBinaryNodeType PrefixElementN;
    public static XmlBinaryNodeType PrefixElementO;
    public static XmlBinaryNodeType PrefixElementP;
    public static XmlBinaryNodeType PrefixElementQ;
    public static XmlBinaryNodeType PrefixElementR;
    public static XmlBinaryNodeType PrefixElementS;
    public static XmlBinaryNodeType PrefixElementT;
    public static XmlBinaryNodeType PrefixElementU;
    public static XmlBinaryNodeType PrefixElementV;
    public static XmlBinaryNodeType PrefixElementW;
    public static XmlBinaryNodeType PrefixElementX;
    public static XmlBinaryNodeType PrefixElementY;
    public static XmlBinaryNodeType PrefixElementZ;
    public static XmlBinaryNodeType MaxElement;
    public static XmlBinaryNodeType MinText;
    public static XmlBinaryNodeType ZeroText;
    public static XmlBinaryNodeType OneText;
    public static XmlBinaryNodeType FalseText;
    public static XmlBinaryNodeType TrueText;
    public static XmlBinaryNodeType Int8Text;
    public static XmlBinaryNodeType Int16Text;
    public static XmlBinaryNodeType Int32Text;
    public static XmlBinaryNodeType Int64Text;
    public static XmlBinaryNodeType FloatText;
    public static XmlBinaryNodeType DoubleText;
    public static XmlBinaryNodeType DecimalText;
    public static XmlBinaryNodeType DateTimeText;
    public static XmlBinaryNodeType Chars8Text;
    public static XmlBinaryNodeType Chars16Text;
    public static XmlBinaryNodeType Chars32Text;
    public static XmlBinaryNodeType Bytes8Text;
    public static XmlBinaryNodeType Bytes16Text;
    public static XmlBinaryNodeType Bytes32Text;
    public static XmlBinaryNodeType StartListText;
    public static XmlBinaryNodeType EndListText;
    public static XmlBinaryNodeType EmptyText;
    public static XmlBinaryNodeType DictionaryText;
    public static XmlBinaryNodeType UniqueIdText;
    public static XmlBinaryNodeType TimeSpanText;
    public static XmlBinaryNodeType GuidText;
    public static XmlBinaryNodeType UInt64Text;
    public static XmlBinaryNodeType BoolText;
    public static XmlBinaryNodeType UnicodeChars8Text;
    public static XmlBinaryNodeType UnicodeChars16Text;
    public static XmlBinaryNodeType UnicodeChars32Text;
    public static XmlBinaryNodeType QNameDictionaryText;
    public static XmlBinaryNodeType ZeroTextWithEndElement;
    public static XmlBinaryNodeType OneTextWithEndElement;
    public static XmlBinaryNodeType FalseTextWithEndElement;
    public static XmlBinaryNodeType TrueTextWithEndElement;
    public static XmlBinaryNodeType Int8TextWithEndElement;
    public static XmlBinaryNodeType Int16TextWithEndElement;
    public static XmlBinaryNodeType Int32TextWithEndElement;
    public static XmlBinaryNodeType Int64TextWithEndElement;
    public static XmlBinaryNodeType FloatTextWithEndElement;
    public static XmlBinaryNodeType DoubleTextWithEndElement;
    public static XmlBinaryNodeType DecimalTextWithEndElement;
    public static XmlBinaryNodeType DateTimeTextWithEndElement;
    public static XmlBinaryNodeType Chars8TextWithEndElement;
    public static XmlBinaryNodeType Chars16TextWithEndElement;
    public static XmlBinaryNodeType Chars32TextWithEndElement;
    public static XmlBinaryNodeType Bytes8TextWithEndElement;
    public static XmlBinaryNodeType Bytes16TextWithEndElement;
    public static XmlBinaryNodeType Bytes32TextWithEndElement;
    public static XmlBinaryNodeType StartListTextWithEndElement;
    public static XmlBinaryNodeType EndListTextWithEndElement;
    public static XmlBinaryNodeType EmptyTextWithEndElement;
    public static XmlBinaryNodeType DictionaryTextWithEndElement;
    public static XmlBinaryNodeType UniqueIdTextWithEndElement;
    public static XmlBinaryNodeType TimeSpanTextWithEndElement;
    public static XmlBinaryNodeType GuidTextWithEndElement;
    public static XmlBinaryNodeType UInt64TextWithEndElement;
    public static XmlBinaryNodeType BoolTextWithEndElement;
    public static XmlBinaryNodeType UnicodeChars8TextWithEndElement;
    public static XmlBinaryNodeType UnicodeChars16TextWithEndElement;
    public static XmlBinaryNodeType UnicodeChars32TextWithEndElement;
    public static XmlBinaryNodeType QNameDictionaryTextWithEndElement;
    public static XmlBinaryNodeType MaxText;
}
internal static class System.Xml.XmlConverter : object {
    public static bool IsWhitespace(char ch);
    public static bool IsWhitespace(string s);
}
internal static class System.Xml.XmlExceptionHelper : object {
    private static void ThrowXmlException(XmlDictionaryReader reader, string res, string arg1);
    private static void ThrowXmlException(XmlDictionaryReader reader, string res, string arg1, string arg2);
    private static void ThrowXmlException(XmlDictionaryReader reader, string res, string arg1, string arg2, string arg3);
    public static void ThrowMaxStringContentLengthExceeded(XmlDictionaryReader reader, int maxStringContentLength);
}
[DefaultMemberAttribute("Item")]
internal class System.Xml.XmlMtomReader : XmlDictionaryReader {
    private Encoding[] _encodings;
    private XmlDictionaryReader _xmlReader;
    private XmlDictionaryReader _infosetReader;
    private MimeReader _mimeReader;
    private Dictionary`2<string, MimePart> _mimeParts;
    private OnXmlDictionaryReaderClose _onClose;
    private bool _readingBinaryElement;
    private int _maxBufferSize;
    private int _bufferRemaining;
    private MimePart _part;
    public XmlDictionaryReaderQuotas Quotas { get; }
    public int AttributeCount { get; }
    public string BaseURI { get; }
    public bool CanReadBinaryContent { get; }
    public bool CanReadValueChunk { get; }
    public bool CanResolveEntity { get; }
    public int Depth { get; }
    public bool EOF { get; }
    public bool HasAttributes { get; }
    public bool HasValue { get; }
    public bool IsDefault { get; }
    public bool IsEmptyElement { get; }
    public string LocalName { get; }
    public string Name { get; }
    public string NamespaceURI { get; }
    public XmlNameTable NameTable { get; }
    public XmlNodeType NodeType { get; }
    public string Prefix { get; }
    public char QuoteChar { get; }
    public ReadState ReadState { get; }
    public XmlReaderSettings Settings { get; }
    public string Item { get; }
    public string Item { get; }
    public string Item { get; }
    public string Value { get; }
    public Type ValueType { get; }
    public string XmlLang { get; }
    public XmlSpace XmlSpace { get; }
    public int LineNumber { get; }
    public int LinePosition { get; }
    public static XmlDictionaryReader Create(Stream stream, Encoding encoding, XmlDictionaryReaderQuotas quotas);
    public static XmlDictionaryReader Create(Stream stream, Encoding[] encodings, XmlDictionaryReaderQuotas quotas);
    public static XmlDictionaryReader Create(Stream stream, Encoding[] encodings, string contentType, XmlDictionaryReaderQuotas quotas);
    public static XmlDictionaryReader Create(Stream stream, Encoding[] encodings, string contentType, XmlDictionaryReaderQuotas quotas, int maxBufferSize, OnXmlDictionaryReaderClose onClose);
    public static XmlDictionaryReader Create(Byte[] buffer, int offset, int count, Encoding encoding, XmlDictionaryReaderQuotas quotas);
    public static XmlDictionaryReader Create(Byte[] buffer, int offset, int count, Encoding[] encodings, XmlDictionaryReaderQuotas quotas);
    public static XmlDictionaryReader Create(Byte[] buffer, int offset, int count, Encoding[] encodings, string contentType, XmlDictionaryReaderQuotas quotas);
    public static XmlDictionaryReader Create(Byte[] buffer, int offset, int count, Encoding[] encodings, string contentType, XmlDictionaryReaderQuotas quotas, int maxBufferSize, OnXmlDictionaryReaderClose onClose);
    internal static void DecrementBufferQuota(int maxBuffer, Int32& remaining, int size);
    private void SetReadEncodings(Encoding[] encodings);
    private void CheckContentType(string contentType);
    public sealed virtual void SetInput(Byte[] buffer, int offset, int count, Encoding[] encodings, string contentType, XmlDictionaryReaderQuotas quotas, int maxBufferSize, OnXmlDictionaryReaderClose onClose);
    public sealed virtual void SetInput(Stream stream, Encoding[] encodings, string contentType, XmlDictionaryReaderQuotas quotas, int maxBufferSize, OnXmlDictionaryReaderClose onClose);
    private void Initialize(Stream stream, string contentType, XmlDictionaryReaderQuotas quotas, int maxBufferSize);
    public virtual XmlDictionaryReaderQuotas get_Quotas();
    private void ReadMessageMimeVersionHeader(MimeVersionHeader header);
    private void ReadMessageContentTypeHeader(ContentTypeHeader header, String& boundary, String& start, String& startInfo);
    private Encoding ReadRootContentTypeHeader(ContentTypeHeader header, Encoding[] expectedEncodings, string expectedType);
    private void CheckContentTransferEncodingOnRoot(ContentTransferEncodingHeader header);
    private void CheckContentTransferEncodingOnBinaryPart(ContentTransferEncodingHeader header);
    private string GetStartUri(string startUri);
    public virtual bool Read();
    private MimePart ReadMimePart(string uri);
    private MimePart ReadRootMimePart();
    private void AdvanceToContentOnElement();
    public virtual int get_AttributeCount();
    public virtual string get_BaseURI();
    public virtual bool get_CanReadBinaryContent();
    public virtual bool get_CanReadValueChunk();
    public virtual bool get_CanResolveEntity();
    public virtual void Close();
    public virtual int get_Depth();
    public virtual bool get_EOF();
    public virtual string GetAttribute(int index);
    public virtual string GetAttribute(string name);
    public virtual string GetAttribute(string name, string ns);
    public virtual string GetAttribute(XmlDictionaryString localName, XmlDictionaryString ns);
    public virtual bool get_HasAttributes();
    public virtual bool get_HasValue();
    public virtual bool get_IsDefault();
    public virtual bool get_IsEmptyElement();
    public virtual bool IsLocalName(string localName);
    public virtual bool IsLocalName(XmlDictionaryString localName);
    public virtual bool IsNamespaceUri(string ns);
    public virtual bool IsNamespaceUri(XmlDictionaryString ns);
    public virtual bool IsStartElement();
    public virtual bool IsStartElement(string localName);
    public virtual bool IsStartElement(string localName, string ns);
    public virtual bool IsStartElement(XmlDictionaryString localName, XmlDictionaryString ns);
    public virtual string get_LocalName();
    public virtual string LookupNamespace(string ns);
    public virtual void MoveToAttribute(int index);
    public virtual bool MoveToAttribute(string name);
    public virtual bool MoveToAttribute(string name, string ns);
    public virtual bool MoveToElement();
    public virtual bool MoveToFirstAttribute();
    public virtual bool MoveToNextAttribute();
    public virtual string get_Name();
    public virtual string get_NamespaceURI();
    public virtual XmlNameTable get_NameTable();
    public virtual XmlNodeType get_NodeType();
    public virtual string get_Prefix();
    public virtual char get_QuoteChar();
    public virtual bool ReadAttributeValue();
    public virtual object ReadContentAs(Type returnType, IXmlNamespaceResolver namespaceResolver);
    public virtual Byte[] ReadContentAsBase64();
    public virtual int ReadValueAsBase64(Byte[] buffer, int offset, int count);
    public virtual int ReadContentAsBase64(Byte[] buffer, int offset, int count);
    public virtual int ReadElementContentAsBase64(Byte[] buffer, int offset, int count);
    public virtual int ReadElementContentAsBinHex(Byte[] buffer, int offset, int count);
    public virtual int ReadContentAsBinHex(Byte[] buffer, int offset, int count);
    public virtual bool ReadContentAsBoolean();
    public virtual int ReadContentAsChars(Char[] chars, int index, int count);
    public virtual DateTime ReadContentAsDateTime();
    public virtual decimal ReadContentAsDecimal();
    public virtual double ReadContentAsDouble();
    public virtual int ReadContentAsInt();
    public virtual long ReadContentAsLong();
    public virtual object ReadContentAsObject();
    public virtual float ReadContentAsFloat();
    public virtual string ReadContentAsString();
    public virtual string ReadInnerXml();
    public virtual string ReadOuterXml();
    public virtual ReadState get_ReadState();
    public virtual int ReadValueChunk(Char[] buffer, int index, int count);
    public virtual void ResolveEntity();
    public virtual XmlReaderSettings get_Settings();
    public virtual void Skip();
    public virtual string get_Item(int index);
    public virtual string get_Item(string name);
    public virtual string get_Item(string name, string ns);
    public virtual string get_Value();
    public virtual Type get_ValueType();
    public virtual string get_XmlLang();
    public virtual XmlSpace get_XmlSpace();
    public sealed virtual bool HasLineInfo();
    public sealed virtual int get_LineNumber();
    public sealed virtual int get_LinePosition();
}
internal class System.Xml.XmlMtomWriter : XmlDictionaryWriter {
    private static int MaxInlinedBytes;
    private int _maxSizeInBytes;
    private XmlDictionaryWriter _writer;
    private XmlDictionaryWriter _infosetWriter;
    private MimeWriter _mimeWriter;
    private Encoding _encoding;
    private bool _isUTF8;
    private string _contentID;
    private string _contentType;
    private string _initialContentTypeForRootPart;
    private string _initialContentTypeForMimeMessage;
    private MemoryStream _contentTypeStream;
    private List`1<MimePart> _mimeParts;
    private IList`1<MtomBinaryData> _binaryDataChunks;
    private int _depth;
    private int _totalSizeOfMimeParts;
    private int _sizeOfBufferedBinaryData;
    private Char[] _chars;
    private Byte[] _bytes;
    private bool _isClosed;
    private bool _ownsStream;
    private XmlDictionaryWriter Writer { get; }
    private bool IsInitialized { get; }
    public XmlWriterSettings Settings { get; }
    public WriteState WriteState { get; }
    public string XmlLang { get; }
    public XmlSpace XmlSpace { get; }
    public static XmlDictionaryWriter Create(Stream stream, Encoding encoding, int maxSizeInBytes, string startInfo);
    public static XmlDictionaryWriter Create(Stream stream, Encoding encoding, int maxSizeInBytes, string startInfo, string boundary, string startUri, bool writeMessageHeaders, bool ownsStream);
    public sealed virtual void SetOutput(Stream stream, Encoding encoding, int maxSizeInBytes, string startInfo, string boundary, string startUri, bool writeMessageHeaders, bool ownsStream);
    private XmlDictionaryWriter get_Writer();
    private bool get_IsInitialized();
    private void Initialize(Stream stream, string startInfo, string boundary, string startUri, bool writeMessageHeaders, bool ownsStream);
    private void Initialize();
    private static string GetBoundaryString();
    internal static bool IsUTF8Encoding(Encoding encoding);
    private static string GetContentTypeForMimeMessage(string boundary, string startUri, string startInfo);
    private static string GetContentTypeForRootMimePart(Encoding encoding, string startInfo);
    private static string CharSet(Encoding enc);
    public virtual void WriteStartElement(string prefix, string localName, string ns);
    [AsyncStateMachineAttribute("System.Xml.XmlMtomWriter/<WriteStartElementAsync>d__37")]
public virtual Task WriteStartElementAsync(string prefix, string localName, string ns);
    public virtual void WriteStartElement(string prefix, XmlDictionaryString localName, XmlDictionaryString ns);
    private void ThrowIfElementIsXOPInclude(string prefix, string localName, string ns);
    public virtual void WriteEndElement();
    [AsyncStateMachineAttribute("System.Xml.XmlMtomWriter/<WriteEndElementAsync>d__41")]
public virtual Task WriteEndElementAsync();
    public virtual void WriteFullEndElement();
    public virtual void WriteValue(IStreamProvider value);
    public virtual Task WriteValueAsync(IStreamProvider value);
    public virtual void WriteBase64(Byte[] buffer, int index, int count);
    internal static int ValidateSizeOfMessage(int maxSize, int offset, int size);
    private void WriteBase64InlineIfPresent();
    private Task WriteBase64InlineIfPresentAsync();
    private void WriteBase64Inline();
    [AsyncStateMachineAttribute("System.Xml.XmlMtomWriter/<WriteBase64InlineAsync>d__50")]
private Task WriteBase64InlineAsync();
    private void WriteXOPInclude();
    [AsyncStateMachineAttribute("System.Xml.XmlMtomWriter/<WriteXOPIncludeAsync>d__52")]
private Task WriteXOPIncludeAsync();
    public static string GenerateUriForMimePart(int index);
    private void WriteXOPBinaryParts();
    [AsyncStateMachineAttribute("System.Xml.XmlMtomWriter/<WriteXOPBinaryPartsAsync>d__55")]
private Task WriteXOPBinaryPartsAsync();
    private void WriteMimeHeaders(string contentID, string contentType, string contentTransferEncoding);
    [AsyncStateMachineAttribute("System.Xml.XmlMtomWriter/<WriteMimeHeadersAsync>d__57")]
private Task WriteMimeHeadersAsync(string contentID, string contentType, string contentTransferEncoding);
    public virtual void Close();
    private void CheckIfStartContentTypeAttribute(string localName, string ns);
    private void CheckIfEndContentTypeAttribute();
    public virtual void Flush();
    public virtual Task FlushAsync();
    public virtual string LookupPrefix(string ns);
    public virtual XmlWriterSettings get_Settings();
    public virtual void WriteAttributes(XmlReader reader, bool defattr);
    public virtual void WriteBinHex(Byte[] buffer, int index, int count);
    public virtual void WriteCData(string text);
    public virtual void WriteCharEntity(char ch);
    public virtual void WriteChars(Char[] buffer, int index, int count);
    public virtual void WriteComment(string text);
    public virtual void WriteDocType(string name, string pubid, string sysid, string subset);
    public virtual void WriteEndAttribute();
    public virtual void WriteEndDocument();
    public virtual void WriteEntityRef(string name);
    public virtual void WriteName(string name);
    public virtual void WriteNmToken(string name);
    protected virtual void WriteTextNode(XmlDictionaryReader reader, bool attribute);
    public virtual void WriteNode(XPathNavigator navigator, bool defattr);
    public virtual void WriteProcessingInstruction(string name, string text);
    public virtual void WriteQualifiedName(string localName, string namespaceUri);
    public virtual void WriteRaw(Char[] buffer, int index, int count);
    public virtual void WriteRaw(string data);
    public virtual void WriteStartAttribute(string prefix, string localName, string ns);
    public virtual void WriteStartAttribute(string prefix, XmlDictionaryString localName, XmlDictionaryString ns);
    public virtual void WriteStartDocument();
    public virtual void WriteStartDocument(bool standalone);
    public virtual WriteState get_WriteState();
    public virtual void WriteString(string text);
    public virtual void WriteString(XmlDictionaryString value);
    public virtual void WriteSurrogateCharEntity(char lowChar, char highChar);
    public virtual void WriteWhitespace(string whitespace);
    public virtual void WriteValue(object value);
    public virtual void WriteValue(string value);
    public virtual void WriteValue(bool value);
    public virtual void WriteValue(DateTime value);
    public virtual void WriteValue(double value);
    public virtual void WriteValue(int value);
    public virtual void WriteValue(long value);
    public virtual void WriteValue(XmlDictionaryString value);
    public virtual void WriteXmlnsAttribute(string prefix, string ns);
    public virtual void WriteXmlnsAttribute(string prefix, XmlDictionaryString ns);
    public virtual string get_XmlLang();
    public virtual XmlSpace get_XmlSpace();
}
