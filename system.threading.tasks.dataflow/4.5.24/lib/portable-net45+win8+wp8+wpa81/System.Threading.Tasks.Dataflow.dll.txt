[DebuggerDisplayAttribute("{DebuggerDisplayContent,nq}")]
[DebuggerTypeProxyAttribute("System.Threading.Tasks.Dataflow.ActionBlock`1/DebugView")]
public class System.Threading.Tasks.Dataflow.ActionBlock`1 : object {
    private TargetCore`1<TInput> m_defaultTarget;
    private SpscTargetCore`1<TInput> m_spscTarget;
    [CompilerGeneratedAttribute]
private static Action`1<object> CS$<>9__CachedAnonymousMethodDelegate3;
    [CompilerGeneratedAttribute]
private static Action`2<Task, object> CS$<>9__CachedAnonymousMethodDelegatea;
    public Task Completion { get; }
    public int InputCount { get; }
    private int InputCountForDebugger { get; }
    private object DebuggerDisplayContent { get; }
    private object System.Threading.Tasks.Dataflow.Internal.IDebuggerDisplay.Content { get; }
    public ActionBlock`1(Action`1<TInput> action);
    public ActionBlock`1(Action`1<TInput> action, ExecutionDataflowBlockOptions dataflowBlockOptions);
    public ActionBlock`1(Func`2<TInput, Task> action);
    public ActionBlock`1(Func`2<TInput, Task> action, ExecutionDataflowBlockOptions dataflowBlockOptions);
    private ActionBlock`1(Delegate action, ExecutionDataflowBlockOptions dataflowBlockOptions);
    private void ProcessMessage(Action`1<TInput> action, KeyValuePair`2<TInput, long> messageWithId);
    private void ProcessMessageWithTask(Func`2<TInput, Task> action, KeyValuePair`2<TInput, long> messageWithId);
    private void AsyncCompleteProcessMessageWithTask(Task completed);
    public sealed virtual void Complete();
    private sealed virtual override void System.Threading.Tasks.Dataflow.IDataflowBlock.Fault(Exception exception);
    public sealed virtual Task get_Completion();
    public bool Post(TInput item);
    private sealed virtual override DataflowMessageStatus System.Threading.Tasks.Dataflow.ITargetBlock<TInput>.OfferMessage(DataflowMessageHeader messageHeader, TInput messageValue, ISourceBlock`1<TInput> source, bool consumeToAccept);
    public int get_InputCount();
    private int get_InputCountForDebugger();
    public virtual string ToString();
    private object get_DebuggerDisplayContent();
    private sealed virtual override object System.Threading.Tasks.Dataflow.Internal.IDebuggerDisplay.get_Content();
    [CompilerGeneratedAttribute]
private static void <.ctor>b__2(object state);
    [CompilerGeneratedAttribute]
private static void <ProcessMessageWithTask>b__9(Task completed, object state);
}
[DebuggerDisplayAttribute("{DebuggerDisplayContent,nq}")]
[DebuggerTypeProxyAttribute("System.Threading.Tasks.Dataflow.BatchBlock`1/DebugView")]
public class System.Threading.Tasks.Dataflow.BatchBlock`1 : object {
    private BatchBlockTargetCore<T> m_target;
    private SourceCore`1<T[]> m_source;
    [CompilerGeneratedAttribute]
private static Action`2<ISourceBlock`1<T[]>, int> CS$<>9__CachedAnonymousMethodDelegate7;
    [CompilerGeneratedAttribute]
private static Func`4<ISourceBlock`1<T[]>, T[], IList`1<T[]>, int> CS$<>9__CachedAnonymousMethodDelegate8;
    [CompilerGeneratedAttribute]
private static Action`1<ISourceBlock`1<T[]>> CS$<>9__CachedAnonymousMethodDelegate9;
    [CompilerGeneratedAttribute]
private static Action`2<Task, object> CS$<>9__CachedAnonymousMethodDelegatec;
    [CompilerGeneratedAttribute]
private static Action`1<object> CS$<>9__CachedAnonymousMethodDelegated;
    public int OutputCount { get; }
    public Task Completion { get; }
    public int BatchSize { get; }
    private int OutputCountForDebugger { get; }
    private object DebuggerDisplayContent { get; }
    private object System.Threading.Tasks.Dataflow.Internal.IDebuggerDisplay.Content { get; }
    public BatchBlock`1(int batchSize);
    public BatchBlock`1(int batchSize, GroupingDataflowBlockOptions dataflowBlockOptions);
    public sealed virtual void Complete();
    private sealed virtual override void System.Threading.Tasks.Dataflow.IDataflowBlock.Fault(Exception exception);
    public void TriggerBatch();
    public sealed virtual IDisposable LinkTo(ITargetBlock`1<T[]> target, DataflowLinkOptions linkOptions);
    public sealed virtual bool TryReceive(Predicate`1<T[]> filter, T[]& item);
    public sealed virtual bool TryReceiveAll(IList`1& items);
    public int get_OutputCount();
    public sealed virtual Task get_Completion();
    public int get_BatchSize();
    private sealed virtual override DataflowMessageStatus System.Threading.Tasks.Dataflow.ITargetBlock<T>.OfferMessage(DataflowMessageHeader messageHeader, T messageValue, ISourceBlock`1<T> source, bool consumeToAccept);
    private sealed virtual override T[] System.Threading.Tasks.Dataflow.ISourceBlock<T[]>.ConsumeMessage(DataflowMessageHeader messageHeader, ITargetBlock`1<T[]> target, Boolean& messageConsumed);
    private sealed virtual override bool System.Threading.Tasks.Dataflow.ISourceBlock<T[]>.ReserveMessage(DataflowMessageHeader messageHeader, ITargetBlock`1<T[]> target);
    private sealed virtual override void System.Threading.Tasks.Dataflow.ISourceBlock<T[]>.ReleaseReservation(DataflowMessageHeader messageHeader, ITargetBlock`1<T[]> target);
    private int get_OutputCountForDebugger();
    public virtual string ToString();
    private object get_DebuggerDisplayContent();
    private sealed virtual override object System.Threading.Tasks.Dataflow.Internal.IDebuggerDisplay.get_Content();
    [CompilerGeneratedAttribute]
private static void <.ctor>b__0(ISourceBlock`1<T[]> owningSource, int count);
    [CompilerGeneratedAttribute]
private static int <.ctor>b__1(ISourceBlock`1<T[]> owningSource, T[] singleOutputItem, IList`1<T[]> multipleOutputItems);
    [CompilerGeneratedAttribute]
private static void <.ctor>b__2(ISourceBlock`1<T[]> owningSource);
    [CompilerGeneratedAttribute]
private void <.ctor>b__3(T[] batch);
    [CompilerGeneratedAttribute]
private void <.ctor>b__4(Task param0);
    [CompilerGeneratedAttribute]
private static void <.ctor>b__5(Task completed, object state);
    [CompilerGeneratedAttribute]
private static void <.ctor>b__6(object state);
}
[DebuggerTypeProxyAttribute("System.Threading.Tasks.Dataflow.BatchedJoinBlock`2/DebugView")]
[DebuggerDisplayAttribute("{DebuggerDisplayContent,nq}")]
public class System.Threading.Tasks.Dataflow.BatchedJoinBlock`2 : object {
    private int m_batchSize;
    private BatchedJoinBlockTargetSharedResources m_sharedResources;
    private BatchedJoinBlockTarget`1<T1> m_target1;
    private BatchedJoinBlockTarget`1<T2> m_target2;
    private SourceCore`1<Tuple`2<IList`1<T1>, IList`1<T2>>> m_source;
    [CompilerGeneratedAttribute]
private static Action`1<ISourceBlock`1<Tuple`2<IList`1<T1>, IList`1<T2>>>> CS$<>9__CachedAnonymousMethodDelegate5;
    [CompilerGeneratedAttribute]
private static Action`2<Task, object> CS$<>9__CachedAnonymousMethodDelegate7;
    [CompilerGeneratedAttribute]
private static Action`1<object> CS$<>9__CachedAnonymousMethodDelegate8;
    public int BatchSize { get; }
    public ITargetBlock`1<T1> Target1 { get; }
    public ITargetBlock`1<T2> Target2 { get; }
    public int OutputCount { get; }
    public Task Completion { get; }
    private int OutputCountForDebugger { get; }
    private object DebuggerDisplayContent { get; }
    private object System.Threading.Tasks.Dataflow.Internal.IDebuggerDisplay.Content { get; }
    public BatchedJoinBlock`2(int batchSize);
    public BatchedJoinBlock`2(int batchSize, GroupingDataflowBlockOptions dataflowBlockOptions);
    public int get_BatchSize();
    public ITargetBlock`1<T1> get_Target1();
    public ITargetBlock`1<T2> get_Target2();
    public sealed virtual IDisposable LinkTo(ITargetBlock`1<Tuple`2<IList`1<T1>, IList`1<T2>>> target, DataflowLinkOptions linkOptions);
    public sealed virtual bool TryReceive(Predicate`1<Tuple`2<IList`1<T1>, IList`1<T2>>> filter, Tuple`2& item);
    public sealed virtual bool TryReceiveAll(IList`1& items);
    public int get_OutputCount();
    public sealed virtual Task get_Completion();
    public sealed virtual void Complete();
    private sealed virtual override void System.Threading.Tasks.Dataflow.IDataflowBlock.Fault(Exception exception);
    private sealed virtual override Tuple`2<IList`1<T1>, IList`1<T2>> System.Threading.Tasks.Dataflow.ISourceBlock<System.Tuple<System.Collections.Generic.IList<T1>,System.Collections.Generic.IList<T2>>>.ConsumeMessage(DataflowMessageHeader messageHeader, ITargetBlock`1<Tuple`2<IList`1<T1>, IList`1<T2>>> target, Boolean& messageConsumed);
    private sealed virtual override bool System.Threading.Tasks.Dataflow.ISourceBlock<System.Tuple<System.Collections.Generic.IList<T1>,System.Collections.Generic.IList<T2>>>.ReserveMessage(DataflowMessageHeader messageHeader, ITargetBlock`1<Tuple`2<IList`1<T1>, IList`1<T2>>> target);
    private sealed virtual override void System.Threading.Tasks.Dataflow.ISourceBlock<System.Tuple<System.Collections.Generic.IList<T1>,System.Collections.Generic.IList<T2>>>.ReleaseReservation(DataflowMessageHeader messageHeader, ITargetBlock`1<Tuple`2<IList`1<T1>, IList`1<T2>>> target);
    private void CompleteEachTarget();
    private int get_OutputCountForDebugger();
    public virtual string ToString();
    private object get_DebuggerDisplayContent();
    private sealed virtual override object System.Threading.Tasks.Dataflow.Internal.IDebuggerDisplay.get_Content();
    [CompilerGeneratedAttribute]
private static void <.ctor>b__0(ISourceBlock`1<Tuple`2<IList`1<T1>, IList`1<T2>>> owningSource);
    [CompilerGeneratedAttribute]
private void <.ctor>b__1();
    [CompilerGeneratedAttribute]
private static void <.ctor>b__3(Task completed, object state);
    [CompilerGeneratedAttribute]
private static void <.ctor>b__4(object state);
}
[DebuggerDisplayAttribute("{DebuggerDisplayContent,nq}")]
[DebuggerTypeProxyAttribute("System.Threading.Tasks.Dataflow.BatchedJoinBlock`3/DebugView")]
public class System.Threading.Tasks.Dataflow.BatchedJoinBlock`3 : object {
    private int m_batchSize;
    private BatchedJoinBlockTargetSharedResources m_sharedResources;
    private BatchedJoinBlockTarget`1<T1> m_target1;
    private BatchedJoinBlockTarget`1<T2> m_target2;
    private BatchedJoinBlockTarget`1<T3> m_target3;
    private SourceCore`1<Tuple`3<IList`1<T1>, IList`1<T2>, IList`1<T3>>> m_source;
    [CompilerGeneratedAttribute]
private static Action`1<ISourceBlock`1<Tuple`3<IList`1<T1>, IList`1<T2>, IList`1<T3>>>> CS$<>9__CachedAnonymousMethodDelegate5;
    [CompilerGeneratedAttribute]
private static Action`2<Task, object> CS$<>9__CachedAnonymousMethodDelegate7;
    [CompilerGeneratedAttribute]
private static Action`1<object> CS$<>9__CachedAnonymousMethodDelegate8;
    public int BatchSize { get; }
    public ITargetBlock`1<T1> Target1 { get; }
    public ITargetBlock`1<T2> Target2 { get; }
    public ITargetBlock`1<T3> Target3 { get; }
    public int OutputCount { get; }
    public Task Completion { get; }
    private int OutputCountForDebugger { get; }
    private object DebuggerDisplayContent { get; }
    private object System.Threading.Tasks.Dataflow.Internal.IDebuggerDisplay.Content { get; }
    public BatchedJoinBlock`3(int batchSize);
    public BatchedJoinBlock`3(int batchSize, GroupingDataflowBlockOptions dataflowBlockOptions);
    public int get_BatchSize();
    public ITargetBlock`1<T1> get_Target1();
    public ITargetBlock`1<T2> get_Target2();
    public ITargetBlock`1<T3> get_Target3();
    public sealed virtual IDisposable LinkTo(ITargetBlock`1<Tuple`3<IList`1<T1>, IList`1<T2>, IList`1<T3>>> target, DataflowLinkOptions linkOptions);
    public sealed virtual bool TryReceive(Predicate`1<Tuple`3<IList`1<T1>, IList`1<T2>, IList`1<T3>>> filter, Tuple`3& item);
    public sealed virtual bool TryReceiveAll(IList`1& items);
    public int get_OutputCount();
    public sealed virtual Task get_Completion();
    public sealed virtual void Complete();
    private sealed virtual override void System.Threading.Tasks.Dataflow.IDataflowBlock.Fault(Exception exception);
    private sealed virtual override Tuple`3<IList`1<T1>, IList`1<T2>, IList`1<T3>> System.Threading.Tasks.Dataflow.ISourceBlock<System.Tuple<System.Collections.Generic.IList<T1>,System.Collections.Generic.IList<T2>,System.Collections.Generic.IList<T3>>>.ConsumeMessage(DataflowMessageHeader messageHeader, ITargetBlock`1<Tuple`3<IList`1<T1>, IList`1<T2>, IList`1<T3>>> target, Boolean& messageConsumed);
    private sealed virtual override bool System.Threading.Tasks.Dataflow.ISourceBlock<System.Tuple<System.Collections.Generic.IList<T1>,System.Collections.Generic.IList<T2>,System.Collections.Generic.IList<T3>>>.ReserveMessage(DataflowMessageHeader messageHeader, ITargetBlock`1<Tuple`3<IList`1<T1>, IList`1<T2>, IList`1<T3>>> target);
    private sealed virtual override void System.Threading.Tasks.Dataflow.ISourceBlock<System.Tuple<System.Collections.Generic.IList<T1>,System.Collections.Generic.IList<T2>,System.Collections.Generic.IList<T3>>>.ReleaseReservation(DataflowMessageHeader messageHeader, ITargetBlock`1<Tuple`3<IList`1<T1>, IList`1<T2>, IList`1<T3>>> target);
    private void CompleteEachTarget();
    private int get_OutputCountForDebugger();
    public virtual string ToString();
    private object get_DebuggerDisplayContent();
    private sealed virtual override object System.Threading.Tasks.Dataflow.Internal.IDebuggerDisplay.get_Content();
    [CompilerGeneratedAttribute]
private static void <.ctor>b__0(ISourceBlock`1<Tuple`3<IList`1<T1>, IList`1<T2>, IList`1<T3>>> owningSource);
    [CompilerGeneratedAttribute]
private void <.ctor>b__1();
    [CompilerGeneratedAttribute]
private static void <.ctor>b__3(Task completed, object state);
    [CompilerGeneratedAttribute]
private static void <.ctor>b__4(object state);
}
[DebuggerTypeProxyAttribute("System.Threading.Tasks.Dataflow.BroadcastBlock`1/DebugView")]
[DebuggerDisplayAttribute("{DebuggerDisplayContent,nq}")]
public class System.Threading.Tasks.Dataflow.BroadcastBlock`1 : object {
    private BroadcastingSourceCore`1<T, T> m_source;
    private BoundingStateWithPostponedAndTask`1<T> m_boundingState;
    private bool m_decliningPermanently;
    private bool m_completionReserved;
    [CompilerGeneratedAttribute]
private static Action`2<Task, object> CS$<>9__CachedAnonymousMethodDelegate2;
    [CompilerGeneratedAttribute]
private static Action`1<object> CS$<>9__CachedAnonymousMethodDelegate3;
    [CompilerGeneratedAttribute]
private static Action`1<object> CS$<>9__CachedAnonymousMethodDelegate9;
    [CompilerGeneratedAttribute]
private static Action`1<object> CS$<>9__CachedAnonymousMethodDelegatef;
    private object IncomingLock { get; }
    public Task Completion { get; }
    private bool HasValueForDebugger { get; }
    private T ValueForDebugger { get; }
    private object DebuggerDisplayContent { get; }
    private object System.Threading.Tasks.Dataflow.Internal.IDebuggerDisplay.Content { get; }
    public BroadcastBlock`1(Func`2<T, T> cloningFunction);
    public BroadcastBlock`1(Func`2<T, T> cloningFunction, DataflowBlockOptions dataflowBlockOptions);
    private object get_IncomingLock();
    public sealed virtual void Complete();
    private sealed virtual override void System.Threading.Tasks.Dataflow.IDataflowBlock.Fault(Exception exception);
    internal void CompleteCore(Exception exception, bool storeExceptionEvenIfAlreadyCompleting, bool revertProcessingState);
    public sealed virtual IDisposable LinkTo(ITargetBlock`1<T> target, DataflowLinkOptions linkOptions);
    public sealed virtual bool TryReceive(Predicate`1<T> filter, T& item);
    private sealed virtual override bool System.Threading.Tasks.Dataflow.IReceivableSourceBlock<T>.TryReceiveAll(IList`1& items);
    public sealed virtual Task get_Completion();
    private sealed virtual override DataflowMessageStatus System.Threading.Tasks.Dataflow.ITargetBlock<T>.OfferMessage(DataflowMessageHeader messageHeader, T messageValue, ISourceBlock`1<T> source, bool consumeToAccept);
    private void OnItemsRemoved(int numItemsRemoved);
    internal void ConsumeAsyncIfNecessary(bool isReplacementReplica);
    private void ConsumeMessagesLoopCore();
    private bool ConsumeAndStoreOneMessageIfAvailable();
    private void CompleteTargetIfPossible();
    private sealed virtual override T System.Threading.Tasks.Dataflow.ISourceBlock<T>.ConsumeMessage(DataflowMessageHeader messageHeader, ITargetBlock`1<T> target, Boolean& messageConsumed);
    private sealed virtual override bool System.Threading.Tasks.Dataflow.ISourceBlock<T>.ReserveMessage(DataflowMessageHeader messageHeader, ITargetBlock`1<T> target);
    private sealed virtual override void System.Threading.Tasks.Dataflow.ISourceBlock<T>.ReleaseReservation(DataflowMessageHeader messageHeader, ITargetBlock`1<T> target);
    private bool get_HasValueForDebugger();
    private T get_ValueForDebugger();
    public virtual string ToString();
    private object get_DebuggerDisplayContent();
    private sealed virtual override object System.Threading.Tasks.Dataflow.Internal.IDebuggerDisplay.get_Content();
    [CompilerGeneratedAttribute]
private static void <.ctor>b__0(Task completed, object state);
    [CompilerGeneratedAttribute]
private static void <.ctor>b__1(object state);
    [CompilerGeneratedAttribute]
private static void <ConsumeAsyncIfNecessary>b__7(object state);
    [CompilerGeneratedAttribute]
private void <ConsumeAsyncIfNecessary>b__8(object exc);
    [CompilerGeneratedAttribute]
private static void <CompleteTargetIfPossible>b__e(object state);
}
[DebuggerDisplayAttribute("{DebuggerDisplayContent,nq}")]
[DebuggerTypeProxyAttribute("System.Threading.Tasks.Dataflow.BufferBlock`1/DebugView")]
public class System.Threading.Tasks.Dataflow.BufferBlock`1 : object {
    private SourceCore`1<T> m_source;
    private BoundingStateWithPostponedAndTask`1<T> m_boundingState;
    private bool m_targetDecliningPermanently;
    private bool m_targetCompletionReserved;
    [CompilerGeneratedAttribute]
private static Action`2<ISourceBlock`1<T>, int> CS$<>9__CachedAnonymousMethodDelegate4;
    [CompilerGeneratedAttribute]
private static Action`1<ISourceBlock`1<T>> CS$<>9__CachedAnonymousMethodDelegate5;
    [CompilerGeneratedAttribute]
private static Action`2<Task, object> CS$<>9__CachedAnonymousMethodDelegate6;
    [CompilerGeneratedAttribute]
private static Action`1<object> CS$<>9__CachedAnonymousMethodDelegate7;
    [CompilerGeneratedAttribute]
private static Action`1<object> CS$<>9__CachedAnonymousMethodDelegated;
    [CompilerGeneratedAttribute]
private static Action`1<object> CS$<>9__CachedAnonymousMethodDelegate13;
    private object IncomingLock { get; }
    public int Count { get; }
    public Task Completion { get; }
    private int CountForDebugger { get; }
    private object DebuggerDisplayContent { get; }
    private object System.Threading.Tasks.Dataflow.Internal.IDebuggerDisplay.Content { get; }
    public BufferBlock`1(DataflowBlockOptions dataflowBlockOptions);
    private object get_IncomingLock();
    private sealed virtual override DataflowMessageStatus System.Threading.Tasks.Dataflow.ITargetBlock<T>.OfferMessage(DataflowMessageHeader messageHeader, T messageValue, ISourceBlock`1<T> source, bool consumeToAccept);
    public sealed virtual void Complete();
    private sealed virtual override void System.Threading.Tasks.Dataflow.IDataflowBlock.Fault(Exception exception);
    private void CompleteCore(Exception exception, bool storeExceptionEvenIfAlreadyCompleting, bool revertProcessingState);
    public sealed virtual IDisposable LinkTo(ITargetBlock`1<T> target, DataflowLinkOptions linkOptions);
    public sealed virtual bool TryReceive(Predicate`1<T> filter, T& item);
    public sealed virtual bool TryReceiveAll(IList`1& items);
    public int get_Count();
    public sealed virtual Task get_Completion();
    private sealed virtual override T System.Threading.Tasks.Dataflow.ISourceBlock<T>.ConsumeMessage(DataflowMessageHeader messageHeader, ITargetBlock`1<T> target, Boolean& messageConsumed);
    private sealed virtual override bool System.Threading.Tasks.Dataflow.ISourceBlock<T>.ReserveMessage(DataflowMessageHeader messageHeader, ITargetBlock`1<T> target);
    private sealed virtual override void System.Threading.Tasks.Dataflow.ISourceBlock<T>.ReleaseReservation(DataflowMessageHeader messageHeader, ITargetBlock`1<T> target);
    private void OnItemsRemoved(int numItemsRemoved);
    internal void ConsumeAsyncIfNecessary(bool isReplacementReplica);
    private void ConsumeMessagesLoopCore();
    private bool ConsumeAndStoreOneMessageIfAvailable();
    private void CompleteTargetIfPossible();
    private int get_CountForDebugger();
    public virtual string ToString();
    private object get_DebuggerDisplayContent();
    private sealed virtual override object System.Threading.Tasks.Dataflow.Internal.IDebuggerDisplay.get_Content();
    [CompilerGeneratedAttribute]
private static void <.ctor>b__0(ISourceBlock`1<T> owningSource, int count);
    [CompilerGeneratedAttribute]
private static void <.ctor>b__1(ISourceBlock`1<T> owningSource);
    [CompilerGeneratedAttribute]
private static void <.ctor>b__2(Task completed, object state);
    [CompilerGeneratedAttribute]
private static void <.ctor>b__3(object owningSource);
    [CompilerGeneratedAttribute]
private static void <ConsumeAsyncIfNecessary>b__b(object state);
    [CompilerGeneratedAttribute]
private void <ConsumeAsyncIfNecessary>b__c(object exc);
    [CompilerGeneratedAttribute]
private static void <CompleteTargetIfPossible>b__12(object state);
}
[ExtensionAttribute]
public static class System.Threading.Tasks.Dataflow.DataflowBlock : object {
    private static Action`1<object> s_cancelCts;
    private static ExecutionDataflowBlockOptions s_nonGreedyExecutionOptions;
    [CompilerGeneratedAttribute]
private static Action`1<object> CS$<>9__CachedAnonymousMethodDelegate8;
    private static DataflowBlock();
    [ExtensionAttribute]
public static IDisposable LinkTo(ISourceBlock`1<TOutput> source, ITargetBlock`1<TOutput> target);
    [ExtensionAttribute]
public static IDisposable LinkTo(ISourceBlock`1<TOutput> source, ITargetBlock`1<TOutput> target, Predicate`1<TOutput> predicate);
    [ExtensionAttribute]
public static IDisposable LinkTo(ISourceBlock`1<TOutput> source, ITargetBlock`1<TOutput> target, DataflowLinkOptions linkOptions, Predicate`1<TOutput> predicate);
    [ExtensionAttribute]
public static bool Post(ITargetBlock`1<TInput> target, TInput item);
    [ExtensionAttribute]
public static Task`1<bool> SendAsync(ITargetBlock`1<TInput> target, TInput item);
    [ExtensionAttribute]
public static Task`1<bool> SendAsync(ITargetBlock`1<TInput> target, TInput item, CancellationToken cancellationToken);
    [ExtensionAttribute]
public static bool TryReceive(IReceivableSourceBlock`1<TOutput> source, TOutput& item);
    [ExtensionAttribute]
public static Task`1<TOutput> ReceiveAsync(ISourceBlock`1<TOutput> source);
    [ExtensionAttribute]
public static Task`1<TOutput> ReceiveAsync(ISourceBlock`1<TOutput> source, CancellationToken cancellationToken);
    [ExtensionAttribute]
public static Task`1<TOutput> ReceiveAsync(ISourceBlock`1<TOutput> source, TimeSpan timeout);
    [ExtensionAttribute]
public static Task`1<TOutput> ReceiveAsync(ISourceBlock`1<TOutput> source, TimeSpan timeout, CancellationToken cancellationToken);
    [ExtensionAttribute]
public static TOutput Receive(ISourceBlock`1<TOutput> source);
    [ExtensionAttribute]
public static TOutput Receive(ISourceBlock`1<TOutput> source, CancellationToken cancellationToken);
    [ExtensionAttribute]
public static TOutput Receive(ISourceBlock`1<TOutput> source, TimeSpan timeout);
    [ExtensionAttribute]
public static TOutput Receive(ISourceBlock`1<TOutput> source, TimeSpan timeout, CancellationToken cancellationToken);
    [ExtensionAttribute]
private static Task`1<TOutput> ReceiveCore(ISourceBlock`1<TOutput> source, bool attemptTryReceive, TimeSpan timeout, CancellationToken cancellationToken);
    private static Task`1<TOutput> ReceiveCoreByLinking(ISourceBlock`1<TOutput> source, int millisecondsTimeout, CancellationToken cancellationToken);
    [ExtensionAttribute]
public static Task`1<bool> OutputAvailableAsync(ISourceBlock`1<TOutput> source);
    [ExtensionAttribute]
public static Task`1<bool> OutputAvailableAsync(ISourceBlock`1<TOutput> source, CancellationToken cancellationToken);
    public static IPropagatorBlock`2<TInput, TOutput> Encapsulate(ITargetBlock`1<TInput> target, ISourceBlock`1<TOutput> source);
    public static Task`1<int> Choose(ISourceBlock`1<T1> source1, Action`1<T1> action1, ISourceBlock`1<T2> source2, Action`1<T2> action2);
    public static Task`1<int> Choose(ISourceBlock`1<T1> source1, Action`1<T1> action1, ISourceBlock`1<T2> source2, Action`1<T2> action2, DataflowBlockOptions dataflowBlockOptions);
    public static Task`1<int> Choose(ISourceBlock`1<T1> source1, Action`1<T1> action1, ISourceBlock`1<T2> source2, Action`1<T2> action2, ISourceBlock`1<T3> source3, Action`1<T3> action3);
    public static Task`1<int> Choose(ISourceBlock`1<T1> source1, Action`1<T1> action1, ISourceBlock`1<T2> source2, Action`1<T2> action2, ISourceBlock`1<T3> source3, Action`1<T3> action3, DataflowBlockOptions dataflowBlockOptions);
    private static Task`1<int> ChooseCore(ISourceBlock`1<T1> source1, Action`1<T1> action1, ISourceBlock`1<T2> source2, Action`1<T2> action2, ISourceBlock`1<T3> source3, Action`1<T3> action3, DataflowBlockOptions dataflowBlockOptions);
    private static bool TryChooseFromSource(ISourceBlock`1<T> source, Action`1<T> action, int branchId, TaskScheduler scheduler, Task`1& task);
    private static Task`1<int> ChooseCoreByLinking(ISourceBlock`1<T1> source1, Action`1<T1> action1, ISourceBlock`1<T2> source2, Action`1<T2> action2, ISourceBlock`1<T3> source3, Action`1<T3> action3, DataflowBlockOptions dataflowBlockOptions);
    private static Task`1<int> CreateChooseBranch(StrongBox`1<Task> boxedCompleted, CancellationTokenSource cts, TaskScheduler scheduler, int branchId, ISourceBlock`1<T> source, Action`1<T> action);
    [ExtensionAttribute]
public static IObservable`1<TOutput> AsObservable(ISourceBlock`1<TOutput> source);
    [ExtensionAttribute]
public static IObserver`1<TInput> AsObserver(ITargetBlock`1<TInput> target);
    public static ITargetBlock`1<TInput> NullTarget();
    [CompilerGeneratedAttribute]
private static void <.cctor>b__7(object state);
}
[DebuggerDisplayAttribute("TaskScheduler = {TaskScheduler}, MaxMessagesPerTask = {MaxMessagesPerTask}, BoundedCapacity = {BoundedCapacity}")]
public class System.Threading.Tasks.Dataflow.DataflowBlockOptions : object {
    public static int Unbounded;
    private TaskScheduler m_taskScheduler;
    private CancellationToken m_cancellationToken;
    private int m_maxMessagesPerTask;
    private int m_boundedCapacity;
    private string m_nameFormat;
    internal static DataflowBlockOptions Default;
    public TaskScheduler TaskScheduler { get; public set; }
    public CancellationToken CancellationToken { get; public set; }
    public int MaxMessagesPerTask { get; public set; }
    internal int ActualMaxMessagesPerTask { get; }
    public int BoundedCapacity { get; public set; }
    public string NameFormat { get; public set; }
    private static DataflowBlockOptions();
    internal DataflowBlockOptions DefaultOrClone();
    public TaskScheduler get_TaskScheduler();
    public void set_TaskScheduler(TaskScheduler value);
    public CancellationToken get_CancellationToken();
    public void set_CancellationToken(CancellationToken value);
    public int get_MaxMessagesPerTask();
    public void set_MaxMessagesPerTask(int value);
    internal int get_ActualMaxMessagesPerTask();
    public int get_BoundedCapacity();
    public void set_BoundedCapacity(int value);
    public string get_NameFormat();
    public void set_NameFormat(string value);
}
[DebuggerDisplayAttribute("PropagateCompletion = {PropagateCompletion}, MaxMessages = {MaxMessages}, Append = {Append}")]
public class System.Threading.Tasks.Dataflow.DataflowLinkOptions : object {
    internal static int Unbounded;
    private bool m_propagateCompletion;
    private int m_maxNumberOfMessages;
    private bool m_append;
    internal static DataflowLinkOptions Default;
    internal static DataflowLinkOptions UnlinkAfterOneAndPropagateCompletion;
    public bool PropagateCompletion { get; public set; }
    public int MaxMessages { get; public set; }
    public bool Append { get; public set; }
    private static DataflowLinkOptions();
    public bool get_PropagateCompletion();
    public void set_PropagateCompletion(bool value);
    public int get_MaxMessages();
    public void set_MaxMessages(int value);
    public bool get_Append();
    public void set_Append(bool value);
}
[DebuggerDisplayAttribute("Id = {Id}")]
public class System.Threading.Tasks.Dataflow.DataflowMessageHeader : ValueType {
    private long m_id;
    public bool IsValid { get; }
    public long Id { get; }
    public DataflowMessageHeader(long id);
    public bool get_IsValid();
    public long get_Id();
    public sealed virtual bool Equals(DataflowMessageHeader other);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    public static bool op_Equality(DataflowMessageHeader left, DataflowMessageHeader right);
    public static bool op_Inequality(DataflowMessageHeader left, DataflowMessageHeader right);
}
public enum System.Threading.Tasks.Dataflow.DataflowMessageStatus : Enum {
    public int value__;
    public static DataflowMessageStatus Accepted;
    public static DataflowMessageStatus Declined;
    public static DataflowMessageStatus Postponed;
    public static DataflowMessageStatus NotAvailable;
    public static DataflowMessageStatus DecliningPermanently;
}
[DebuggerDisplayAttribute("TaskScheduler = {TaskScheduler}, MaxMessagesPerTask = {MaxMessagesPerTask}, BoundedCapacity = {BoundedCapacity}, MaxDegreeOfParallelism = {MaxDegreeOfParallelism}")]
public class System.Threading.Tasks.Dataflow.ExecutionDataflowBlockOptions : DataflowBlockOptions {
    internal static ExecutionDataflowBlockOptions Default;
    private int m_maxDegreeOfParallelism;
    private bool m_singleProducerConstrained;
    public int MaxDegreeOfParallelism { get; public set; }
    public bool SingleProducerConstrained { get; public set; }
    internal int ActualMaxDegreeOfParallelism { get; }
    internal bool SupportsParallelExecution { get; }
    private static ExecutionDataflowBlockOptions();
    internal ExecutionDataflowBlockOptions DefaultOrClone();
    public int get_MaxDegreeOfParallelism();
    public void set_MaxDegreeOfParallelism(int value);
    public bool get_SingleProducerConstrained();
    public void set_SingleProducerConstrained(bool value);
    internal int get_ActualMaxDegreeOfParallelism();
    internal bool get_SupportsParallelExecution();
}
[DebuggerDisplayAttribute("TaskScheduler = {TaskScheduler}, MaxMessagesPerTask = {MaxMessagesPerTask}, BoundedCapacity = {BoundedCapacity}, Greedy = {Greedy}, MaxNumberOfGroups = {MaxNumberOfGroups}")]
public class System.Threading.Tasks.Dataflow.GroupingDataflowBlockOptions : DataflowBlockOptions {
    internal static GroupingDataflowBlockOptions Default;
    private bool m_greedy;
    private long m_maxNumberOfGroups;
    public bool Greedy { get; public set; }
    public long MaxNumberOfGroups { get; public set; }
    internal long ActualMaxNumberOfGroups { get; }
    private static GroupingDataflowBlockOptions();
    internal GroupingDataflowBlockOptions DefaultOrClone();
    public bool get_Greedy();
    public void set_Greedy(bool value);
    public long get_MaxNumberOfGroups();
    public void set_MaxNumberOfGroups(long value);
    internal long get_ActualMaxNumberOfGroups();
}
public interface System.Threading.Tasks.Dataflow.IDataflowBlock {
    public Task Completion { get; }
    public abstract virtual Task get_Completion();
    public abstract virtual void Complete();
    public abstract virtual void Fault(Exception exception);
}
[DebuggerTypeProxyAttribute("System.Threading.Tasks.Dataflow.Internal.BatchedJoinBlockTarget`1/DebugView")]
[DebuggerDisplayAttribute("{DebuggerDisplayContent,nq}")]
internal class System.Threading.Tasks.Dataflow.Internal.BatchedJoinBlockTarget`1 : object {
    private BatchedJoinBlockTargetSharedResources m_sharedResources;
    private bool m_decliningPermanently;
    private IList`1<T> m_messages;
    internal int Count { get; }
    private Task System.Threading.Tasks.Dataflow.IDataflowBlock.Completion { get; }
    private object DebuggerDisplayContent { get; }
    private object System.Threading.Tasks.Dataflow.Internal.IDebuggerDisplay.Content { get; }
    internal BatchedJoinBlockTarget`1(BatchedJoinBlockTargetSharedResources sharedResources);
    internal int get_Count();
    internal IList`1<T> GetAndEmptyMessages();
    public sealed virtual DataflowMessageStatus OfferMessage(DataflowMessageHeader messageHeader, T messageValue, ISourceBlock`1<T> source, bool consumeToAccept);
    public sealed virtual void Complete();
    private sealed virtual override void System.Threading.Tasks.Dataflow.IDataflowBlock.Fault(Exception exception);
    private sealed virtual override Task System.Threading.Tasks.Dataflow.IDataflowBlock.get_Completion();
    private object get_DebuggerDisplayContent();
    private sealed virtual override object System.Threading.Tasks.Dataflow.Internal.IDebuggerDisplay.get_Content();
}
internal class System.Threading.Tasks.Dataflow.Internal.BatchedJoinBlockTargetSharedResources : object {
    internal object m_incomingLock;
    internal int m_batchSize;
    internal Action m_batchSizeReachedAction;
    internal Action m_allTargetsDecliningPermanentlyAction;
    internal Action`1<Exception> m_exceptionAction;
    internal Action m_completionAction;
    internal int m_remainingItemsInBatch;
    internal int m_remainingAliveTargets;
    internal bool m_decliningPermanently;
    internal long m_batchesCreated;
    internal BatchedJoinBlockTargetSharedResources(int batchSize, GroupingDataflowBlockOptions dataflowBlockOptions, Action batchSizeReachedAction, Action allTargetsDecliningAction, Action`1<Exception> exceptionAction, Action completionAction);
}
[DebuggerDisplayAttribute("BoundedCapacity={BoundedCapacity}}")]
internal class System.Threading.Tasks.Dataflow.Internal.BoundingState : object {
    internal int BoundedCapacity;
    internal int CurrentCount;
    internal bool CountIsLessThanBound { get; }
    internal BoundingState(int boundedCapacity);
    internal bool get_CountIsLessThanBound();
}
[DebuggerDisplayAttribute("BoundedCapacity={BoundedCapacity}, PostponedMessages={PostponedMessagesCountForDebugger}")]
internal class System.Threading.Tasks.Dataflow.Internal.BoundingStateWithPostponed`1 : BoundingState {
    internal QueuedMap`2<ISourceBlock`1<TInput>, DataflowMessageHeader> PostponedMessages;
    internal int OutstandingTransfers;
    private int PostponedMessagesCountForDebugger { get; }
    internal BoundingStateWithPostponed`1(int boundedCapacity);
    private int get_PostponedMessagesCountForDebugger();
}
internal class System.Threading.Tasks.Dataflow.Internal.BoundingStateWithPostponedAndTask`1 : BoundingStateWithPostponed`1<TInput> {
    internal Task TaskForInputProcessing;
    internal BoundingStateWithPostponedAndTask`1(int boundedCapacity);
}
[DebuggerDisplayAttribute("Count = {Count}")]
[DebuggerTypeProxyAttribute("System.Threading.Tasks.Dataflow.Internal.Collections.SystemCollectionsConcurrent_ProducerConsumerCollectionDebugView`1")]
[ComVisibleAttribute("False")]
internal class System.Threading.Tasks.Dataflow.Internal.Collections.ConcurrentQueue`1 : object {
    private static int SEGMENT_SIZE;
    private Segment modreq(System.Runtime.CompilerServices.IsVolatile) m_head;
    private Segment modreq(System.Runtime.CompilerServices.IsVolatile) m_tail;
    private T[] m_serializationArray;
    internal Int32 modreq(System.Runtime.CompilerServices.IsVolatile) m_numSnapshotTakers;
    private bool System.Collections.ICollection.IsSynchronized { get; }
    private object System.Collections.ICollection.SyncRoot { get; }
    public bool IsEmpty { get; }
    public int Count { get; }
    public ConcurrentQueue`1(IEnumerable`1<T> collection);
    private void InitializeFromCollection(IEnumerable`1<T> collection);
    [OnSerializingAttribute]
private void OnSerializing(StreamingContext context);
    [OnDeserializedAttribute]
private void OnDeserialized(StreamingContext context);
    private sealed virtual override void System.Collections.ICollection.CopyTo(Array array, int index);
    private sealed virtual override bool System.Collections.ICollection.get_IsSynchronized();
    private sealed virtual override object System.Collections.ICollection.get_SyncRoot();
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
    private sealed virtual override bool System.Threading.Tasks.Dataflow.Internal.Collections.IProducerConsumerCollection<T>.TryAdd(T item);
    private sealed virtual override bool System.Threading.Tasks.Dataflow.Internal.Collections.IProducerConsumerCollection<T>.TryTake(T& item);
    public bool get_IsEmpty();
    public sealed virtual T[] ToArray();
    private List`1<T> ToList();
    private void GetHeadTailPositions(Segment& head, Segment& tail, Int32& headLow, Int32& tailHigh);
    public sealed virtual int get_Count();
    public sealed virtual void CopyTo(T[] array, int index);
    public sealed virtual IEnumerator`1<T> GetEnumerator();
    private IEnumerator`1<T> GetEnumerator(Segment<T> head, Segment<T> tail, int headLow, int tailHigh);
    public void Enqueue(T item);
    public bool TryDequeue(T& result);
    public bool TryPeek(T& result);
}
internal interface System.Threading.Tasks.Dataflow.Internal.Collections.IProducerConsumerCollection`1 {
    public abstract virtual void CopyTo(T[] array, int index);
    public abstract virtual bool TryAdd(T item);
    public abstract virtual bool TryTake(T& item);
    public abstract virtual T[] ToArray();
}
internal class System.Threading.Tasks.Dataflow.Internal.Collections.SystemCollectionsConcurrent_ProducerConsumerCollectionDebugView`1 : object {
    private IProducerConsumerCollection`1<T> m_collection;
    [DebuggerBrowsableAttribute("3")]
public T[] Items { get; }
    public SystemCollectionsConcurrent_ProducerConsumerCollectionDebugView`1(IProducerConsumerCollection`1<T> collection);
    public T[] get_Items();
}
internal class System.Threading.Tasks.Dataflow.Internal.Collections.VolatileBool : ValueType {
    public Boolean modreq(System.Runtime.CompilerServices.IsVolatile) m_value;
    public VolatileBool(bool value);
}
internal static class System.Threading.Tasks.Dataflow.Internal.Common : object {
    internal static long INVALID_REORDERING_ID;
    internal static int SINGLE_MESSAGE_ID;
    internal static int KEEP_ALIVE_NUMBER_OF_MESSAGES_THRESHOLD;
    internal static int KEEP_ALIVE_BAN_COUNT;
    internal static string EXCEPTIONDATAKEY_DATAFLOWMESSAGEVALUE;
    internal static DataflowMessageHeader SingleMessageHeader;
    internal static Task`1<bool> CompletedTaskWithTrueResult;
    internal static Task`1<bool> CompletedTaskWithFalseResult;
    internal static TaskCompletionSource`1<VoidResult> CompletedVoidResultTaskCompletionSource;
    internal static Task NeverCompletingTask;
    internal static TimeSpan InfiniteTimeSpan;
    internal static Action`1<Exception> AsyncExceptionHandler;
    [CompilerGeneratedAttribute]
private static Action`2<Task, object> CS$<>9__CachedAnonymousMethodDelegate1;
    [CompilerGeneratedAttribute]
private static WaitCallback CS$<>9__CachedAnonymousMethodDelegate3;
    [CompilerGeneratedAttribute]
private static Action`2<Task, object> CS$<>9__CachedAnonymousMethodDelegate5;
    private static Common();
    [ConditionalAttribute("DEBUG")]
internal static void ContractAssertMonitorStatus(object syncObj, bool held);
    internal static bool TryKeepAliveUntil(KeepAlivePredicate`2<TStateIn, TStateOut> predicate, TStateIn stateIn, TStateOut& stateOut);
    internal static void SafeDisposeTokenRegistration(CancellationTokenRegistration registration);
    internal static T UnwrapWeakReference(object state);
    internal static WeakReference`1<T> WrapWeakReference(T state);
    internal static int GetBlockId(IDataflowBlock block);
    internal static string GetNameForDebugger(IDataflowBlock block, DataflowBlockOptions options);
    internal static bool IsCooperativeCancellation(Exception exception);
    internal static void WireCancellationToComplete(CancellationToken cancellationToken, Task completionTask, Action`1<object> completeAction, object completeState);
    internal static Exception InitializeStackTrace(Exception exception);
    internal static void StoreDataflowMessageValueIntoExceptionData(Exception exc, T messageValue, bool targetInnerExceptions);
    private static void StoreStringIntoExceptionData(Exception exception, string key, string value);
    internal static void ThrowAsync(Exception error);
    internal static void AddException(List`1& list, Exception exception, bool unwrapInnerExceptions);
    internal static Task`1<TResult> CreateTaskFromResult(TResult result);
    private static Task`1<bool> CreateCachedBooleanTask(bool value);
    private static TaskCompletionSource`1<T> CreateCachedTaskCompletionSource();
    internal static Task`1<TResult> CreateTaskFromException(Exception exception);
    internal static Task`1<TResult> CreateTaskFromCancellation(CancellationToken cancellationToken);
    internal static Task GetPotentiallyNotSupportedCompletionTask(IDataflowBlock block);
    internal static IDisposable CreateUnlinker(object outgoingLock, TargetRegistry`1<TOutput> targetRegistry, ITargetBlock`1<TOutput> targetBlock);
    internal static bool IsValidTimeout(TimeSpan timeout);
    internal static TaskContinuationOptions GetContinuationOptions(TaskContinuationOptions toInclude);
    internal static TaskCreationOptions GetCreationOptionsForTask(bool isReplacementReplica);
    internal static Exception StartTaskSafe(Task task, TaskScheduler scheduler);
    private static Exception StartTaskSafeCore(Task task, TaskScheduler scheduler);
    internal static void ReleaseAllPostponedMessages(ITargetBlock`1<T> target, QueuedMap`2<ISourceBlock`1<T>, DataflowMessageHeader> postponedMessages, List`1& exceptions);
    internal static void PropagateCompletion(Task sourceCompletionTask, IDataflowBlock target, Action`1<Exception> exceptionHandler);
    private static void PropagateCompletionAsContinuation(Task sourceCompletionTask, IDataflowBlock target);
    internal static void PropagateCompletionOnceCompleted(Task sourceCompletionTask, IDataflowBlock target);
    [CompilerGeneratedAttribute]
private static void <WireCancellationToComplete>b__0(Task completed, object state);
    [CompilerGeneratedAttribute]
private static void <ThrowAsync>b__2(object state);
    [CompilerGeneratedAttribute]
private static void <PropagateCompletionAsContinuation>b__4(Task task, object state);
}
internal class System.Threading.Tasks.Dataflow.Internal.Disposables : object {
    internal static IDisposable Nop;
    private static Disposables();
    internal static IDisposable Create(Action`2<T1, T2> action, T1 arg1, T2 arg2);
    internal static IDisposable Create(Action`3<T1, T2, T3> action, T1 arg1, T2 arg2, T3 arg3);
}
internal class System.Threading.Tasks.Dataflow.Internal.EnumerableDebugView`1 : object {
    private IEnumerable`1<T> m_enumerable;
    [DebuggerBrowsableAttribute("3")]
public T[] Items { get; }
    public EnumerableDebugView`1(IEnumerable`1<T> enumerable);
    public T[] get_Items();
}
internal class System.Threading.Tasks.Dataflow.Internal.EnumerableDebugView`2 : object {
    private IEnumerable`1<KeyValuePair`2<TKey, TValue>> m_enumerable;
    [DebuggerBrowsableAttribute("3")]
public KeyValuePair`2[] Items { get; }
    public EnumerableDebugView`2(IEnumerable`1<KeyValuePair`2<TKey, TValue>> enumerable);
    public KeyValuePair`2[] get_Items();
}
internal interface System.Threading.Tasks.Dataflow.Internal.IDebuggerDisplay {
    public object Content { get; }
    public abstract virtual object get_Content();
}
[DebuggerDisplayAttribute("Count={Count}")]
[DebuggerTypeProxyAttribute("System.Threading.Tasks.Dataflow.Internal.EnumerableDebugView`1")]
internal class System.Threading.Tasks.Dataflow.Internal.ImmutableList`1 : object {
    private static ImmutableList`1<T> s_empty;
    private T[] m_array;
    public static ImmutableList`1<T> Empty { get; }
    public int Count { get; }
    private ImmutableList`1(T[] elements);
    private static ImmutableList`1();
    public static ImmutableList`1<T> get_Empty();
    public ImmutableList`1<T> Add(T item);
    public ImmutableList`1<T> Remove(T item);
    public int get_Count();
    public bool Contains(T item);
    public sealed virtual IEnumerator`1<T> GetEnumerator();
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
}
internal interface System.Threading.Tasks.Dataflow.Internal.IReorderingBuffer {
    public abstract virtual void IgnoreItem(long id);
}
[DebuggerTypeProxyAttribute("System.Threading.Tasks.Dataflow.Internal.JoinBlockTarget`1/DebugView")]
[DebuggerDisplayAttribute("{DebuggerDisplayContent,nq}")]
internal class System.Threading.Tasks.Dataflow.Internal.JoinBlockTarget`1 : JoinBlockTargetBase {
    private JoinBlockTargetSharedResources m_sharedResources;
    private TaskCompletionSource`1<VoidResult> m_completionTask;
    private Queue`1<T> m_messages;
    private NonGreedyState<T> m_nonGreedy;
    private bool m_decliningPermanently;
    internal bool IsDecliningPermanently { get; }
    internal bool HasAtLeastOneMessageAvailable { get; }
    internal bool HasAtLeastOnePostponedMessage { get; }
    internal int NumberOfMessagesAvailableOrPostponed { get; }
    internal bool HasTheHighestNumberOfMessagesAvailable { get; }
    public Task Completion { get; }
    internal Task CompletionTaskInternal { get; }
    private int InputCountForDebugger { get; }
    private object DebuggerDisplayContent { get; }
    private object System.Threading.Tasks.Dataflow.Internal.IDebuggerDisplay.Content { get; }
    internal JoinBlockTarget`1(JoinBlockTargetSharedResources sharedResources);
    internal T GetOneMessage();
    internal virtual bool get_IsDecliningPermanently();
    internal virtual bool get_HasAtLeastOneMessageAvailable();
    internal virtual bool get_HasAtLeastOnePostponedMessage();
    internal virtual int get_NumberOfMessagesAvailableOrPostponed();
    internal virtual bool get_HasTheHighestNumberOfMessagesAvailable();
    internal virtual bool ReserveOneMessage();
    internal virtual bool ConsumeReservedMessage();
    internal virtual bool ConsumeOnePostponedMessage();
    private void CompleteIfLastJoinIsFeasible();
    internal virtual void ReleaseReservedMessage();
    internal virtual void ClearReservation();
    internal virtual void CompleteOncePossible();
    private sealed virtual override DataflowMessageStatus System.Threading.Tasks.Dataflow.ITargetBlock<T>.OfferMessage(DataflowMessageHeader messageHeader, T messageValue, ISourceBlock`1<T> source, bool consumeToAccept);
    internal virtual void CompleteCore(Exception exception, bool dropPendingMessages, bool releaseReservedMessages);
    private sealed virtual override void System.Threading.Tasks.Dataflow.IDataflowBlock.Fault(Exception exception);
    public sealed virtual Task get_Completion();
    internal Task get_CompletionTaskInternal();
    private int get_InputCountForDebugger();
    private object get_DebuggerDisplayContent();
    private sealed virtual override object System.Threading.Tasks.Dataflow.Internal.IDebuggerDisplay.get_Content();
}
internal abstract class System.Threading.Tasks.Dataflow.Internal.JoinBlockTargetBase : object {
    internal bool IsDecliningPermanently { get; }
    internal bool HasAtLeastOneMessageAvailable { get; }
    internal bool HasAtLeastOnePostponedMessage { get; }
    internal int NumberOfMessagesAvailableOrPostponed { get; }
    internal bool HasTheHighestNumberOfMessagesAvailable { get; }
    internal abstract virtual bool get_IsDecliningPermanently();
    internal abstract virtual bool get_HasAtLeastOneMessageAvailable();
    internal abstract virtual bool get_HasAtLeastOnePostponedMessage();
    internal abstract virtual int get_NumberOfMessagesAvailableOrPostponed();
    internal abstract virtual bool get_HasTheHighestNumberOfMessagesAvailable();
    internal abstract virtual bool ReserveOneMessage();
    internal abstract virtual bool ConsumeReservedMessage();
    internal abstract virtual bool ConsumeOnePostponedMessage();
    internal abstract virtual void ReleaseReservedMessage();
    internal abstract virtual void ClearReservation();
    public sealed virtual void Complete();
    internal abstract virtual void CompleteCore(Exception exception, bool dropPendingMessages, bool releaseReservedMessages);
    internal abstract virtual void CompleteOncePossible();
}
[DebuggerDisplayAttribute("{DebuggerDisplayContent,nq}")]
internal class System.Threading.Tasks.Dataflow.Internal.JoinBlockTargetSharedResources : object {
    internal IDataflowBlock m_ownerJoin;
    internal JoinBlockTargetBase[] m_targets;
    internal Action`1<Exception> m_exceptionAction;
    internal Action m_joinFilledAction;
    internal GroupingDataflowBlockOptions m_dataflowBlockOptions;
    internal BoundingState m_boundingState;
    internal bool m_decliningPermanently;
    internal Task m_taskForInputProcessing;
    internal bool m_hasExceptions;
    internal long m_joinsCreated;
    private bool m_completionReserved;
    [CompilerGeneratedAttribute]
private static Action`1<object> CS$<>9__CachedAnonymousMethodDelegate2;
    [CompilerGeneratedAttribute]
private static Action`1<object> CS$<>9__CachedAnonymousMethodDelegate4;
    internal object IncomingLock { get; }
    internal bool AllTargetsHaveAtLeastOneMessage { get; }
    private bool TargetsHaveAtLeastOneMessageQueuedOrPostponed { get; }
    private bool CanceledOrFaulted { get; }
    internal bool JoinNeedsProcessing { get; }
    private object DebuggerDisplayContent { get; }
    internal JoinBlockTargetSharedResources(IDataflowBlock ownerJoin, JoinBlockTargetBase[] targets, Action joinFilledAction, Action`1<Exception> exceptionAction, GroupingDataflowBlockOptions dataflowBlockOptions);
    internal object get_IncomingLock();
    internal void CompleteEachTarget();
    internal bool get_AllTargetsHaveAtLeastOneMessage();
    private bool get_TargetsHaveAtLeastOneMessageQueuedOrPostponed();
    private bool RetrievePostponedItemsNonGreedy();
    private bool RetrievePostponedItemsGreedyBounded();
    private bool get_CanceledOrFaulted();
    internal bool get_JoinNeedsProcessing();
    internal void ProcessAsyncIfNecessary(bool isReplacementReplica);
    private void ProcessAsyncIfNecessary_Slow(bool isReplacementReplica);
    internal void CompleteBlockIfPossible();
    private void ProcessMessagesLoopCore();
    internal void OnItemsRemoved(int numItemsRemoved);
    private object get_DebuggerDisplayContent();
    [CompilerGeneratedAttribute]
private static void <ProcessAsyncIfNecessary_Slow>b__1(object thisSharedResources);
    [CompilerGeneratedAttribute]
private static void <CompleteBlockIfPossible>b__3(object state);
}
internal class System.Threading.Tasks.Dataflow.Internal.PaddedInt64 : ValueType {
    internal long Value;
}
internal static class System.Threading.Tasks.Dataflow.Internal.Padding : object {
    internal static int CACHE_LINE_SIZE;
}
internal class System.Threading.Tasks.Dataflow.Internal.PaddingForInt32 : ValueType {
}
[DebuggerTypeProxyAttribute("System.Threading.Tasks.Dataflow.Internal.EnumerableDebugView`2")]
[DebuggerDisplayAttribute("Count = {Count}")]
internal class System.Threading.Tasks.Dataflow.Internal.QueuedMap`2 : object {
    private ArrayBasedLinkedQueue`1<TKey, TValue, KeyValuePair`2<TKey, TValue>> m_queue;
    private Dictionary`2<TKey, int> m_mapKeyToIndex;
    internal int Count { get; }
    internal QueuedMap`2(int capacity);
    internal void Push(TKey key, TValue value);
    internal bool TryPop(KeyValuePair`2& item);
    internal int PopRange(KeyValuePair`2[] items, int arrayOffset, int count);
    internal void Clear();
    internal int get_Count();
    public sealed virtual IEnumerator`1<KeyValuePair`2<TKey, TValue>> GetEnumerator();
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
}
[DebuggerDisplayAttribute("Count={CountForDebugging}")]
[DebuggerTypeProxyAttribute("System.Threading.Tasks.Dataflow.Internal.ReorderingBuffer`1/DebugView")]
internal class System.Threading.Tasks.Dataflow.Internal.ReorderingBuffer`1 : object {
    private object m_owningSource;
    private Dictionary`2<long, KeyValuePair`2<bool, TOutput>> m_reorderingBuffer;
    private Action`2<object, TOutput> m_outputAction;
    private long m_nextReorderedIdToOutput;
    private object ValueLock { get; }
    private int CountForDebugging { get; }
    internal ReorderingBuffer`1(object owningSource, Action`2<object, TOutput> outputAction);
    private object get_ValueLock();
    internal void AddItem(long id, TOutput item, bool itemIsValid);
    internal Nullable`1<bool> AddItemIfNextAndTrusted(long id, TOutput item, bool isTrusted);
    public sealed virtual void IgnoreItem(long id);
    private void OutputNextItem(TOutput theNextItem, bool itemIsValid);
    private int get_CountForDebugging();
}
[DebuggerDisplayAttribute("{DebuggerDisplayContent,nq}")]
internal class System.Threading.Tasks.Dataflow.Internal.SourceCore`1 : object {
    private TaskCompletionSource`1<VoidResult> m_completionTask;
    private TargetRegistry`1<TOutput> m_targetRegistry;
    private SingleProducerSingleConsumerQueue`1<TOutput> m_messages;
    private ISourceBlock`1<TOutput> m_owningSource;
    private DataflowBlockOptions m_dataflowBlockOptions;
    private Action`1<ISourceBlock`1<TOutput>> m_completeAction;
    private Action`2<ISourceBlock`1<TOutput>, int> m_itemsRemovedAction;
    private Func`4<ISourceBlock`1<TOutput>, TOutput, IList`1<TOutput>, int> m_itemCountingFunc;
    private Task m_taskForOutputProcessing;
    private PaddedInt64 m_nextMessageId;
    private ITargetBlock`1<TOutput> m_nextMessageReservedFor;
    private bool m_decliningPermanently;
    private bool m_enableOffering;
    private bool m_completionReserved;
    private List`1<Exception> m_exceptions;
    [CompilerGeneratedAttribute]
private static Action`1<object> CS$<>9__CachedAnonymousMethodDelegate17;
    [CompilerGeneratedAttribute]
private static Action`1<object> CS$<>9__CachedAnonymousMethodDelegate21;
    [CompilerGeneratedAttribute]
private static Action`1<object> CS$<>9__CachedAnonymousMethodDelegate22;
    [CompilerGeneratedAttribute]
private static Action`1<object> CS$<>9__CachedAnonymousMethodDelegate27;
    private object OutgoingLock { get; }
    private object ValueLock { get; }
    internal Task Completion { get; }
    internal int OutputCount { get; }
    internal bool HasExceptions { get; }
    internal DataflowBlockOptions DataflowBlockOptions { get; }
    private bool CanceledOrFaulted { get; }
    private object DebuggerDisplayContent { get; }
    internal SourceCore`1(ISourceBlock`1<TOutput> owningSource, DataflowBlockOptions dataflowBlockOptions, Action`1<ISourceBlock`1<TOutput>> completeAction, Action`2<ISourceBlock`1<TOutput>, int> itemsRemovedAction, Func`4<ISourceBlock`1<TOutput>, TOutput, IList`1<TOutput>, int> itemCountingFunc);
    private object get_OutgoingLock();
    private object get_ValueLock();
    internal IDisposable LinkTo(ITargetBlock`1<TOutput> target, DataflowLinkOptions linkOptions);
    internal TOutput ConsumeMessage(DataflowMessageHeader messageHeader, ITargetBlock`1<TOutput> target, Boolean& messageConsumed);
    internal bool ReserveMessage(DataflowMessageHeader messageHeader, ITargetBlock`1<TOutput> target);
    internal void ReleaseReservation(DataflowMessageHeader messageHeader, ITargetBlock`1<TOutput> target);
    internal Task get_Completion();
    internal bool TryReceive(Predicate`1<TOutput> filter, TOutput& item);
    internal bool TryReceiveAll(IList`1& items);
    internal int get_OutputCount();
    internal void AddMessage(TOutput item);
    internal void AddMessages(IEnumerable`1<TOutput> items);
    internal void AddException(Exception exception);
    internal void AddExceptions(List`1<Exception> exceptions);
    internal void AddAndUnwrapAggregateException(AggregateException aggregateException);
    internal bool get_HasExceptions();
    internal void Complete();
    internal DataflowBlockOptions get_DataflowBlockOptions();
    private bool OfferToTargets(ITargetBlock`1<TOutput> linkToTarget);
    private bool OfferMessageToTarget(DataflowMessageHeader header, TOutput message, ITargetBlock`1<TOutput> target, Boolean& messageWasAccepted);
    private void OfferAsyncIfNecessaryWithValueLock();
    private void OfferAsyncIfNecessary(bool isReplacementReplica, bool outgoingLockKnownAcquired);
    private void OfferAsyncIfNecessary_Slow(bool isReplacementReplica, bool outgoingLockKnownAcquired);
    private void OfferMessagesLoopCore();
    private bool get_CanceledOrFaulted();
    private void CompleteBlockIfPossible();
    private void CompleteBlockIfPossible_Slow();
    private void CompleteBlockOncePossible();
    private object get_DebuggerDisplayContent();
    internal DebuggingInformation<TOutput> GetDebuggingInformation();
    [CompilerGeneratedAttribute]
private static void <Complete>b__16(object state);
    [CompilerGeneratedAttribute]
private static void <OfferAsyncIfNecessary_Slow>b__1f(object thisSourceCore);
    [CompilerGeneratedAttribute]
private static void <OfferAsyncIfNecessary_Slow>b__20(object state);
    [CompilerGeneratedAttribute]
private static void <CompleteBlockIfPossible_Slow>b__26(object state);
}
[DebuggerDisplayAttribute("{DebuggerDisplayContent,nq}")]
internal class System.Threading.Tasks.Dataflow.Internal.SpscTargetCore`1 : object {
    private ITargetBlock`1<TInput> m_owningTarget;
    private SingleProducerSingleConsumerQueue`1<TInput> m_messages;
    private ExecutionDataflowBlockOptions m_dataflowBlockOptions;
    private Action`1<TInput> m_action;
    private List`1 modreq(System.Runtime.CompilerServices.IsVolatile) m_exceptions;
    private Boolean modreq(System.Runtime.CompilerServices.IsVolatile) m_decliningPermanently;
    private Boolean modreq(System.Runtime.CompilerServices.IsVolatile) m_completionReserved;
    private Task modreq(System.Runtime.CompilerServices.IsVolatile) m_activeConsumer;
    private TaskCompletionSource`1<VoidResult> m_completionTask;
    [CompilerGeneratedAttribute]
private static Action`1<object> CS$<>9__CachedAnonymousMethodDelegate1;
    [CompilerGeneratedAttribute]
private static Func`1<List`1<Exception>> CS$<>9__CachedAnonymousMethodDelegate4;
    [CompilerGeneratedAttribute]
private static Func`1<TaskCompletionSource`1<VoidResult>> CS$<>9__CachedAnonymousMethodDelegate7;
    internal int InputCount { get; }
    internal Task Completion { get; }
    private TaskCompletionSource`1<VoidResult> CompletionSource { get; }
    internal ExecutionDataflowBlockOptions DataflowBlockOptions { get; }
    private object DebuggerDisplayContent { get; }
    internal SpscTargetCore`1(ITargetBlock`1<TInput> owningTarget, Action`1<TInput> action, ExecutionDataflowBlockOptions dataflowBlockOptions);
    internal DataflowMessageStatus OfferMessage(DataflowMessageHeader messageHeader, TInput messageValue, ISourceBlock`1<TInput> source, bool consumeToAccept);
    private DataflowMessageStatus OfferMessage_Slow(DataflowMessageHeader messageHeader, TInput messageValue, ISourceBlock`1<TInput> source, bool consumeToAccept);
    private void ScheduleConsumerIfNecessary(bool isReplica);
    private void ProcessMessagesLoopCore();
    internal int get_InputCount();
    internal void Complete(Exception exception);
    private void StoreException(Exception exception);
    private void CompleteBlockOncePossible();
    internal Task get_Completion();
    private TaskCompletionSource`1<VoidResult> get_CompletionSource();
    internal ExecutionDataflowBlockOptions get_DataflowBlockOptions();
    internal DebuggingInformation<TInput> GetDebuggingInformation();
    private object get_DebuggerDisplayContent();
    [CompilerGeneratedAttribute]
private static void <ScheduleConsumerIfNecessary>b__0(object state);
    [CompilerGeneratedAttribute]
private static List`1<Exception> <StoreException>b__3();
    [CompilerGeneratedAttribute]
private static TaskCompletionSource`1<VoidResult> <get_CompletionSource>b__6();
}
[DebuggerDisplayAttribute("{DebuggerDisplayContent,nq}")]
internal class System.Threading.Tasks.Dataflow.Internal.TargetCore`1 : object {
    private static KeepAlivePredicate`2<TargetCore`1<TInput>, KeyValuePair`2<TInput, long>> s_keepAlivePredicate;
    private TaskCompletionSource`1<VoidResult> m_completionSource;
    private ITargetBlock`1<TInput> m_owningTarget;
    private IProducerConsumerQueue`1<KeyValuePair`2<TInput, long>> m_messages;
    private ExecutionDataflowBlockOptions m_dataflowBlockOptions;
    private Action`1<KeyValuePair`2<TInput, long>> m_callAction;
    private TargetCoreOptions m_targetCoreOptions;
    private BoundingStateWithPostponed`1<TInput> m_boundingState;
    private IReorderingBuffer m_reorderingBuffer;
    private List`1<Exception> m_exceptions;
    private bool m_decliningPermanently;
    private int m_numberOfOutstandingOperations;
    private int m_numberOfOutstandingServiceTasks;
    private PaddedInt64 m_nextAvailableInputMessageId;
    private bool m_completionReserved;
    private int m_keepAliveBanCounter;
    [CompilerGeneratedAttribute]
private static Action`1<object> CS$<>9__CachedAnonymousMethodDelegate5;
    [CompilerGeneratedAttribute]
private static Action`1<object> CS$<>9__CachedAnonymousMethodDelegatec;
    [CompilerGeneratedAttribute]
private static KeepAlivePredicate`2<TargetCore`1<TInput>, KeyValuePair`2<TInput, long>> CS$<>9__CachedAnonymousMethodDelegatef;
    private object IncomingLock { get; }
    internal Task Completion { get; }
    internal int InputCount { get; }
    private bool UsesAsyncCompletion { get; }
    private bool HasRoomForMoreOperations { get; }
    private bool HasRoomForMoreServiceTasks { get; }
    private bool CanceledOrFaulted { get; }
    internal bool IsBounded { get; }
    private object DebuggerDisplayContent { get; }
    internal ExecutionDataflowBlockOptions DataflowBlockOptions { get; }
    internal TargetCore`1(ITargetBlock`1<TInput> owningTarget, Action`1<KeyValuePair`2<TInput, long>> callAction, IReorderingBuffer reorderingBuffer, ExecutionDataflowBlockOptions dataflowBlockOptions, TargetCoreOptions targetCoreOptions);
    private static TargetCore`1();
    private object get_IncomingLock();
    internal void Complete(Exception exception, bool dropPendingMessages, bool storeExceptionEvenIfAlreadyCompleting, bool unwrapInnerExceptions, bool revertProcessingState);
    internal DataflowMessageStatus OfferMessage(DataflowMessageHeader messageHeader, TInput messageValue, ISourceBlock`1<TInput> source, bool consumeToAccept);
    internal Task get_Completion();
    internal int get_InputCount();
    internal void SignalOneAsyncMessageCompleted();
    internal void SignalOneAsyncMessageCompleted(int boundingCountChange);
    private bool get_UsesAsyncCompletion();
    private bool get_HasRoomForMoreOperations();
    private bool get_HasRoomForMoreServiceTasks();
    private void ProcessAsyncIfNecessary(bool repeat);
    private void ProcessAsyncIfNecessary_Slow(bool repeat);
    private void ProcessMessagesLoopCore();
    private bool TryGetNextMessageForNewAsyncOperation(KeyValuePair`2& messageWithId);
    private bool TryGetNextAvailableOrPostponedMessage(KeyValuePair`2& messageWithId);
    private bool TryConsumePostponedMessage(bool forPostponementTransfer, KeyValuePair`2& result);
    private bool get_CanceledOrFaulted();
    private void CompleteBlockIfPossible();
    private void CompleteBlockIfPossible_Slow();
    private void CompleteBlockOncePossible();
    internal bool get_IsBounded();
    internal void ChangeBoundingCount(int count);
    private object get_DebuggerDisplayContent();
    internal ExecutionDataflowBlockOptions get_DataflowBlockOptions();
    internal DebuggingInformation<TInput> GetDebuggingInformation();
    [CompilerGeneratedAttribute]
private static void <ProcessAsyncIfNecessary_Slow>b__3(object thisTargetCore);
    [CompilerGeneratedAttribute]
private void <ProcessAsyncIfNecessary_Slow>b__4(object exc);
    [CompilerGeneratedAttribute]
private static void <CompleteBlockIfPossible_Slow>b__b(object state);
    [CompilerGeneratedAttribute]
private static bool <.cctor>b__e(TargetCore`1<TInput> thisTargetCore, KeyValuePair`2& messageWithId);
}
[FlagsAttribute]
internal enum System.Threading.Tasks.Dataflow.Internal.TargetCoreOptions : Enum {
    public byte value__;
    public static TargetCoreOptions None;
    public static TargetCoreOptions UsesAsyncCompletion;
    public static TargetCoreOptions RepresentsBlockCompletion;
}
[DebuggerDisplayAttribute("Count={Count}")]
[DebuggerTypeProxyAttribute("System.Threading.Tasks.Dataflow.Internal.TargetRegistry`1/DebugView")]
internal class System.Threading.Tasks.Dataflow.Internal.TargetRegistry`1 : object {
    private ISourceBlock`1<T> m_owningSource;
    private Dictionary`2<ITargetBlock`1<T>, LinkedTargetInfo<T>> m_targetInformation;
    private LinkedTargetInfo<T> m_firstTarget;
    private LinkedTargetInfo<T> m_lastTarget;
    private int m_linksWithRemainingMessages;
    internal LinkedTargetInfo<T> FirstTargetNode { get; }
    private int Count { get; }
    private ITargetBlock`1[] TargetsForDebugger { get; }
    internal TargetRegistry`1(ISourceBlock`1<T> owningSource);
    internal void Add(ITargetBlock`1& target, DataflowLinkOptions linkOptions);
    internal bool Contains(ITargetBlock`1<T> target);
    internal void Remove(ITargetBlock`1<T> target, bool onlyIfReachedMaxMessages);
    private void Remove_Slow(ITargetBlock`1<T> target, bool onlyIfReachedMaxMessages);
    internal LinkedTargetInfo<T> ClearEntryPoints();
    internal void PropagateCompletion(LinkedTargetInfo<T> firstTarget);
    internal LinkedTargetInfo<T> get_FirstTargetNode();
    internal void AddToList(LinkedTargetInfo<T> node, bool append);
    internal void RemoveFromList(LinkedTargetInfo<T> node);
    private int get_Count();
    private ITargetBlock`1[] get_TargetsForDebugger();
}
internal class System.Threading.Tasks.Dataflow.Internal.Threading.Thread : object {
    internal static bool Yield();
}
internal class System.Threading.Tasks.Dataflow.Internal.Threading.ThreadPool : object {
    private static SynchronizationContext s_ctx;
    [CompilerGeneratedAttribute]
private static SendOrPostCallback CS$<>9__CachedAnonymousMethodDelegate1;
    private static ThreadPool();
    internal static void QueueUserWorkItem(WaitCallback callback, object state);
    [CompilerGeneratedAttribute]
private static void <QueueUserWorkItem>b__0(object s);
}
internal class System.Threading.Tasks.Dataflow.Internal.Threading.Timer : CancellationTokenSource {
    [CompilerGeneratedAttribute]
private static Action`2<Task, object> CS$<>9__CachedAnonymousMethodDelegate1;
    internal Timer(TimerCallback callback, object state, int dueTime, int period);
    public sealed virtual void Dispose();
    [CompilerGeneratedAttribute]
private static void <.ctor>b__0(Task t, object s);
}
internal class System.Threading.Tasks.Dataflow.Internal.Threading.TimerCallback : MulticastDelegate {
    public TimerCallback(object object, IntPtr method);
    public virtual void Invoke(object state);
    public virtual IAsyncResult BeginInvoke(object state, AsyncCallback callback, object object);
    public virtual void EndInvoke(IAsyncResult result);
}
internal class System.Threading.Tasks.Dataflow.Internal.Threading.WaitCallback : MulticastDelegate {
    public WaitCallback(object object, IntPtr method);
    public virtual void Invoke(object state);
    public virtual IAsyncResult BeginInvoke(object state, AsyncCallback callback, object object);
    public virtual void EndInvoke(IAsyncResult result);
}
[DebuggerNonUserCodeAttribute]
internal class System.Threading.Tasks.Dataflow.Internal.VoidResult : ValueType {
}
public interface System.Threading.Tasks.Dataflow.IPropagatorBlock`2 {
}
public interface System.Threading.Tasks.Dataflow.IReceivableSourceBlock`1 {
    public abstract virtual bool TryReceive(Predicate`1<TOutput> filter, TOutput& item);
    public abstract virtual bool TryReceiveAll(IList`1& items);
}
public interface System.Threading.Tasks.Dataflow.ISourceBlock`1 {
    public abstract virtual IDisposable LinkTo(ITargetBlock`1<TOutput> target, DataflowLinkOptions linkOptions);
    public abstract virtual TOutput ConsumeMessage(DataflowMessageHeader messageHeader, ITargetBlock`1<TOutput> target, Boolean& messageConsumed);
    public abstract virtual bool ReserveMessage(DataflowMessageHeader messageHeader, ITargetBlock`1<TOutput> target);
    public abstract virtual void ReleaseReservation(DataflowMessageHeader messageHeader, ITargetBlock`1<TOutput> target);
}
public interface System.Threading.Tasks.Dataflow.ITargetBlock`1 {
    public abstract virtual DataflowMessageStatus OfferMessage(DataflowMessageHeader messageHeader, TInput messageValue, ISourceBlock`1<TInput> source, bool consumeToAccept);
}
[DebuggerTypeProxyAttribute("System.Threading.Tasks.Dataflow.JoinBlock`2/DebugView")]
[DebuggerDisplayAttribute("{DebuggerDisplayContent,nq}")]
public class System.Threading.Tasks.Dataflow.JoinBlock`2 : object {
    private JoinBlockTargetSharedResources m_sharedResources;
    private SourceCore`1<Tuple`2<T1, T2>> m_source;
    private JoinBlockTarget`1<T1> m_target1;
    private JoinBlockTarget`1<T2> m_target2;
    [CompilerGeneratedAttribute]
private static Action`2<ISourceBlock`1<Tuple`2<T1, T2>>, int> CS$<>9__CachedAnonymousMethodDelegate7;
    [CompilerGeneratedAttribute]
private static Action`1<ISourceBlock`1<Tuple`2<T1, T2>>> CS$<>9__CachedAnonymousMethodDelegate8;
    [CompilerGeneratedAttribute]
private static Action`2<Task, object> CS$<>9__CachedAnonymousMethodDelegatec;
    [CompilerGeneratedAttribute]
private static Action`1<object> CS$<>9__CachedAnonymousMethodDelegated;
    public int OutputCount { get; }
    public Task Completion { get; }
    public ITargetBlock`1<T1> Target1 { get; }
    public ITargetBlock`1<T2> Target2 { get; }
    private int OutputCountForDebugger { get; }
    private object DebuggerDisplayContent { get; }
    private object System.Threading.Tasks.Dataflow.Internal.IDebuggerDisplay.Content { get; }
    public JoinBlock`2(GroupingDataflowBlockOptions dataflowBlockOptions);
    public sealed virtual IDisposable LinkTo(ITargetBlock`1<Tuple`2<T1, T2>> target, DataflowLinkOptions linkOptions);
    public sealed virtual bool TryReceive(Predicate`1<Tuple`2<T1, T2>> filter, Tuple`2& item);
    public sealed virtual bool TryReceiveAll(IList`1& items);
    public int get_OutputCount();
    public sealed virtual Task get_Completion();
    public sealed virtual void Complete();
    private sealed virtual override void System.Threading.Tasks.Dataflow.IDataflowBlock.Fault(Exception exception);
    public ITargetBlock`1<T1> get_Target1();
    public ITargetBlock`1<T2> get_Target2();
    private sealed virtual override Tuple`2<T1, T2> System.Threading.Tasks.Dataflow.ISourceBlock<System.Tuple<T1,T2>>.ConsumeMessage(DataflowMessageHeader messageHeader, ITargetBlock`1<Tuple`2<T1, T2>> target, Boolean& messageConsumed);
    private sealed virtual override bool System.Threading.Tasks.Dataflow.ISourceBlock<System.Tuple<T1,T2>>.ReserveMessage(DataflowMessageHeader messageHeader, ITargetBlock`1<Tuple`2<T1, T2>> target);
    private sealed virtual override void System.Threading.Tasks.Dataflow.ISourceBlock<System.Tuple<T1,T2>>.ReleaseReservation(DataflowMessageHeader messageHeader, ITargetBlock`1<Tuple`2<T1, T2>> target);
    private int get_OutputCountForDebugger();
    public virtual string ToString();
    private object get_DebuggerDisplayContent();
    private sealed virtual override object System.Threading.Tasks.Dataflow.Internal.IDebuggerDisplay.get_Content();
    [CompilerGeneratedAttribute]
private static void <.ctor>b__0(ISourceBlock`1<Tuple`2<T1, T2>> owningSource, int count);
    [CompilerGeneratedAttribute]
private static void <.ctor>b__1(ISourceBlock`1<Tuple`2<T1, T2>> owningSource);
    [CompilerGeneratedAttribute]
private void <.ctor>b__2();
    [CompilerGeneratedAttribute]
private void <.ctor>b__3(Exception exception);
    [CompilerGeneratedAttribute]
private void <.ctor>b__4(Task[] _);
    [CompilerGeneratedAttribute]
private static void <.ctor>b__5(Task completed, object state);
    [CompilerGeneratedAttribute]
private static void <.ctor>b__6(object state);
}
[DebuggerTypeProxyAttribute("System.Threading.Tasks.Dataflow.JoinBlock`3/DebugView")]
[DebuggerDisplayAttribute("{DebuggerDisplayContent,nq}")]
public class System.Threading.Tasks.Dataflow.JoinBlock`3 : object {
    private JoinBlockTargetSharedResources m_sharedResources;
    private SourceCore`1<Tuple`3<T1, T2, T3>> m_source;
    private JoinBlockTarget`1<T1> m_target1;
    private JoinBlockTarget`1<T2> m_target2;
    private JoinBlockTarget`1<T3> m_target3;
    [CompilerGeneratedAttribute]
private static Action`2<ISourceBlock`1<Tuple`3<T1, T2, T3>>, int> CS$<>9__CachedAnonymousMethodDelegate7;
    [CompilerGeneratedAttribute]
private static Action`1<ISourceBlock`1<Tuple`3<T1, T2, T3>>> CS$<>9__CachedAnonymousMethodDelegate8;
    [CompilerGeneratedAttribute]
private static Action`2<Task, object> CS$<>9__CachedAnonymousMethodDelegatec;
    [CompilerGeneratedAttribute]
private static Action`1<object> CS$<>9__CachedAnonymousMethodDelegated;
    public int OutputCount { get; }
    public Task Completion { get; }
    public ITargetBlock`1<T1> Target1 { get; }
    public ITargetBlock`1<T2> Target2 { get; }
    public ITargetBlock`1<T3> Target3 { get; }
    private int OutputCountForDebugger { get; }
    private object DebuggerDisplayContent { get; }
    private object System.Threading.Tasks.Dataflow.Internal.IDebuggerDisplay.Content { get; }
    public JoinBlock`3(GroupingDataflowBlockOptions dataflowBlockOptions);
    public sealed virtual IDisposable LinkTo(ITargetBlock`1<Tuple`3<T1, T2, T3>> target, DataflowLinkOptions linkOptions);
    public sealed virtual bool TryReceive(Predicate`1<Tuple`3<T1, T2, T3>> filter, Tuple`3& item);
    public sealed virtual bool TryReceiveAll(IList`1& items);
    public int get_OutputCount();
    public sealed virtual Task get_Completion();
    public sealed virtual void Complete();
    private sealed virtual override void System.Threading.Tasks.Dataflow.IDataflowBlock.Fault(Exception exception);
    public ITargetBlock`1<T1> get_Target1();
    public ITargetBlock`1<T2> get_Target2();
    public ITargetBlock`1<T3> get_Target3();
    private sealed virtual override Tuple`3<T1, T2, T3> System.Threading.Tasks.Dataflow.ISourceBlock<System.Tuple<T1,T2,T3>>.ConsumeMessage(DataflowMessageHeader messageHeader, ITargetBlock`1<Tuple`3<T1, T2, T3>> target, Boolean& messageConsumed);
    private sealed virtual override bool System.Threading.Tasks.Dataflow.ISourceBlock<System.Tuple<T1,T2,T3>>.ReserveMessage(DataflowMessageHeader messageHeader, ITargetBlock`1<Tuple`3<T1, T2, T3>> target);
    private sealed virtual override void System.Threading.Tasks.Dataflow.ISourceBlock<System.Tuple<T1,T2,T3>>.ReleaseReservation(DataflowMessageHeader messageHeader, ITargetBlock`1<Tuple`3<T1, T2, T3>> target);
    private int get_OutputCountForDebugger();
    public virtual string ToString();
    private object get_DebuggerDisplayContent();
    private sealed virtual override object System.Threading.Tasks.Dataflow.Internal.IDebuggerDisplay.get_Content();
    [CompilerGeneratedAttribute]
private static void <.ctor>b__0(ISourceBlock`1<Tuple`3<T1, T2, T3>> owningSource, int count);
    [CompilerGeneratedAttribute]
private static void <.ctor>b__1(ISourceBlock`1<Tuple`3<T1, T2, T3>> owningSource);
    [CompilerGeneratedAttribute]
private void <.ctor>b__2();
    [CompilerGeneratedAttribute]
private void <.ctor>b__3(Exception exception);
    [CompilerGeneratedAttribute]
private void <.ctor>b__4(Task[] _);
    [CompilerGeneratedAttribute]
private static void <.ctor>b__5(Task completed, object state);
    [CompilerGeneratedAttribute]
private static void <.ctor>b__6(object state);
}
[GeneratedCodeAttribute("System.Resources.Tools.StronglyTypedResourceBuilder", "4.0.0.0")]
[CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal class System.Threading.Tasks.Dataflow.Resource : object {
    private static ResourceManager resourceMan;
    private static CultureInfo resourceCulture;
    [EditorBrowsableAttribute("2")]
internal static ResourceManager ResourceManager { get; }
    [EditorBrowsableAttribute("2")]
internal static CultureInfo Culture { get; internal set; }
    internal static string Argument_BoundedCapacityNotSupported { get; }
    internal static string Argument_CantConsumeFromANullSource { get; }
    internal static string Argument_InvalidMessageHeader { get; }
    internal static string Argument_InvalidMessageId { get; }
    internal static string Argument_InvalidSourceForFilteredLink { get; }
    internal static string Argument_NonGreedyNotSupported { get; }
    internal static string ArgumentOutOfRange_BatchSizeMustBeNoGreaterThanBoundedCapacity { get; }
    internal static string ArgumentOutOfRange_GenericPositive { get; }
    internal static string ArgumentOutOfRange_NeedNonNegOrNegative1 { get; }
    internal static string ConcurrentCollection_SyncRoot_NotSupported { get; }
    internal static string event_DataflowBlockCompleted { get; }
    internal static string event_DataflowBlockCreated { get; }
    internal static string event_DataflowBlockLinking { get; }
    internal static string event_DataflowBlockUnlinking { get; }
    internal static string event_TaskLaunchedForMessageHandling { get; }
    internal static string InvalidOperation_DataNotAvailableForReceive { get; }
    internal static string InvalidOperation_FailedToConsumeReservedMessage { get; }
    internal static string InvalidOperation_MessageNotReservedByTarget { get; }
    internal static string NotSupported_MemberNotNeeded { get; }
    internal static ResourceManager get_ResourceManager();
    internal static CultureInfo get_Culture();
    internal static void set_Culture(CultureInfo value);
    internal static string get_Argument_BoundedCapacityNotSupported();
    internal static string get_Argument_CantConsumeFromANullSource();
    internal static string get_Argument_InvalidMessageHeader();
    internal static string get_Argument_InvalidMessageId();
    internal static string get_Argument_InvalidSourceForFilteredLink();
    internal static string get_Argument_NonGreedyNotSupported();
    internal static string get_ArgumentOutOfRange_BatchSizeMustBeNoGreaterThanBoundedCapacity();
    internal static string get_ArgumentOutOfRange_GenericPositive();
    internal static string get_ArgumentOutOfRange_NeedNonNegOrNegative1();
    internal static string get_ConcurrentCollection_SyncRoot_NotSupported();
    internal static string get_event_DataflowBlockCompleted();
    internal static string get_event_DataflowBlockCreated();
    internal static string get_event_DataflowBlockLinking();
    internal static string get_event_DataflowBlockUnlinking();
    internal static string get_event_TaskLaunchedForMessageHandling();
    internal static string get_InvalidOperation_DataNotAvailableForReceive();
    internal static string get_InvalidOperation_FailedToConsumeReservedMessage();
    internal static string get_InvalidOperation_MessageNotReservedByTarget();
    internal static string get_NotSupported_MemberNotNeeded();
}
[DebuggerDisplayAttribute("{DebuggerDisplayContent,nq}")]
[DebuggerTypeProxyAttribute("System.Threading.Tasks.Dataflow.TransformBlock`2/DebugView")]
public class System.Threading.Tasks.Dataflow.TransformBlock`2 : object {
    private TargetCore`1<TInput> m_target;
    private ReorderingBuffer`1<TOutput> m_reorderingBuffer;
    private SourceCore`1<TOutput> m_source;
    [CompilerGeneratedAttribute]
private static Action`2<ISourceBlock`1<TOutput>, int> CS$<>9__CachedAnonymousMethodDelegate8;
    [CompilerGeneratedAttribute]
private static Action`1<ISourceBlock`1<TOutput>> CS$<>9__CachedAnonymousMethodDelegate9;
    [CompilerGeneratedAttribute]
private static Action`2<object, TOutput> CS$<>9__CachedAnonymousMethodDelegatea;
    [CompilerGeneratedAttribute]
private static Action`2<Task, object> CS$<>9__CachedAnonymousMethodDelegated;
    [CompilerGeneratedAttribute]
private static Action`2<Task, object> CS$<>9__CachedAnonymousMethodDelegatee;
    [CompilerGeneratedAttribute]
private static Action`1<object> CS$<>9__CachedAnonymousMethodDelegatef;
    [CompilerGeneratedAttribute]
private static Action`2<Task`1<TOutput>, object> CS$<>9__CachedAnonymousMethodDelegate13;
    public Task Completion { get; }
    public int InputCount { get; }
    public int OutputCount { get; }
    private int InputCountForDebugger { get; }
    private int OutputCountForDebugger { get; }
    private object DebuggerDisplayContent { get; }
    private object System.Threading.Tasks.Dataflow.Internal.IDebuggerDisplay.Content { get; }
    public TransformBlock`2(Func`2<TInput, TOutput> transform);
    public TransformBlock`2(Func`2<TInput, TOutput> transform, ExecutionDataflowBlockOptions dataflowBlockOptions);
    public TransformBlock`2(Func`2<TInput, Task`1<TOutput>> transform);
    public TransformBlock`2(Func`2<TInput, Task`1<TOutput>> transform, ExecutionDataflowBlockOptions dataflowBlockOptions);
    private TransformBlock`2(Func`2<TInput, TOutput> transformSync, Func`2<TInput, Task`1<TOutput>> transformAsync, ExecutionDataflowBlockOptions dataflowBlockOptions);
    private void ProcessMessage(Func`2<TInput, TOutput> transform, KeyValuePair`2<TInput, long> messageWithId);
    private void ProcessMessageWithTask(Func`2<TInput, Task`1<TOutput>> transform, KeyValuePair`2<TInput, long> messageWithId);
    private void AsyncCompleteProcessMessageWithTask(Task`1<TOutput> completed, KeyValuePair`2<TInput, long> messageWithId);
    public sealed virtual void Complete();
    private sealed virtual override void System.Threading.Tasks.Dataflow.IDataflowBlock.Fault(Exception exception);
    public sealed virtual IDisposable LinkTo(ITargetBlock`1<TOutput> target, DataflowLinkOptions linkOptions);
    public sealed virtual bool TryReceive(Predicate`1<TOutput> filter, TOutput& item);
    public sealed virtual bool TryReceiveAll(IList`1& items);
    public sealed virtual Task get_Completion();
    public int get_InputCount();
    public int get_OutputCount();
    private sealed virtual override DataflowMessageStatus System.Threading.Tasks.Dataflow.ITargetBlock<TInput>.OfferMessage(DataflowMessageHeader messageHeader, TInput messageValue, ISourceBlock`1<TInput> source, bool consumeToAccept);
    private sealed virtual override TOutput System.Threading.Tasks.Dataflow.ISourceBlock<TOutput>.ConsumeMessage(DataflowMessageHeader messageHeader, ITargetBlock`1<TOutput> target, Boolean& messageConsumed);
    private sealed virtual override bool System.Threading.Tasks.Dataflow.ISourceBlock<TOutput>.ReserveMessage(DataflowMessageHeader messageHeader, ITargetBlock`1<TOutput> target);
    private sealed virtual override void System.Threading.Tasks.Dataflow.ISourceBlock<TOutput>.ReleaseReservation(DataflowMessageHeader messageHeader, ITargetBlock`1<TOutput> target);
    private int get_InputCountForDebugger();
    private int get_OutputCountForDebugger();
    public virtual string ToString();
    private object get_DebuggerDisplayContent();
    private sealed virtual override object System.Threading.Tasks.Dataflow.Internal.IDebuggerDisplay.get_Content();
    [CompilerGeneratedAttribute]
private static void <.ctor>b__0(ISourceBlock`1<TOutput> owningSource, int count);
    [CompilerGeneratedAttribute]
private static void <.ctor>b__1(ISourceBlock`1<TOutput> owningSource);
    [CompilerGeneratedAttribute]
private static void <.ctor>b__2(object owningSource, TOutput message);
    [CompilerGeneratedAttribute]
private static void <.ctor>b__5(Task completed, object state);
    [CompilerGeneratedAttribute]
private static void <.ctor>b__6(Task completed, object state);
    [CompilerGeneratedAttribute]
private static void <.ctor>b__7(object state);
    [CompilerGeneratedAttribute]
private static void <ProcessMessageWithTask>b__12(Task`1<TOutput> completed, object state);
}
[DebuggerDisplayAttribute("{DebuggerDisplayContent,nq}")]
[DebuggerTypeProxyAttribute("System.Threading.Tasks.Dataflow.TransformManyBlock`2/DebugView")]
public class System.Threading.Tasks.Dataflow.TransformManyBlock`2 : object {
    private TargetCore`1<TInput> m_target;
    private ReorderingBuffer`1<IEnumerable`1<TOutput>> m_reorderingBuffer;
    private SourceCore`1<TOutput> m_source;
    [CompilerGeneratedAttribute]
private static Action`2<ISourceBlock`1<TOutput>, int> CS$<>9__CachedAnonymousMethodDelegate8;
    [CompilerGeneratedAttribute]
private static Action`1<ISourceBlock`1<TOutput>> CS$<>9__CachedAnonymousMethodDelegate9;
    [CompilerGeneratedAttribute]
private static Action`2<object, IEnumerable`1<TOutput>> CS$<>9__CachedAnonymousMethodDelegatea;
    [CompilerGeneratedAttribute]
private static Action`2<Task, object> CS$<>9__CachedAnonymousMethodDelegated;
    [CompilerGeneratedAttribute]
private static Action`2<Task, object> CS$<>9__CachedAnonymousMethodDelegatee;
    [CompilerGeneratedAttribute]
private static Action`1<object> CS$<>9__CachedAnonymousMethodDelegatef;
    [CompilerGeneratedAttribute]
private static Action`2<Task`1<IEnumerable`1<TOutput>>, object> CS$<>9__CachedAnonymousMethodDelegate13;
    public Task Completion { get; }
    public int InputCount { get; }
    public int OutputCount { get; }
    private int InputCountForDebugger { get; }
    private int OutputCountForDebugger { get; }
    private object DebuggerDisplayContent { get; }
    private object System.Threading.Tasks.Dataflow.Internal.IDebuggerDisplay.Content { get; }
    public TransformManyBlock`2(Func`2<TInput, IEnumerable`1<TOutput>> transform);
    public TransformManyBlock`2(Func`2<TInput, IEnumerable`1<TOutput>> transform, ExecutionDataflowBlockOptions dataflowBlockOptions);
    public TransformManyBlock`2(Func`2<TInput, Task`1<IEnumerable`1<TOutput>>> transform);
    public TransformManyBlock`2(Func`2<TInput, Task`1<IEnumerable`1<TOutput>>> transform, ExecutionDataflowBlockOptions dataflowBlockOptions);
    private TransformManyBlock`2(Func`2<TInput, IEnumerable`1<TOutput>> transformSync, Func`2<TInput, Task`1<IEnumerable`1<TOutput>>> transformAsync, ExecutionDataflowBlockOptions dataflowBlockOptions);
    private void ProcessMessage(Func`2<TInput, IEnumerable`1<TOutput>> transformFunction, KeyValuePair`2<TInput, long> messageWithId);
    private void ProcessMessageWithTask(Func`2<TInput, Task`1<IEnumerable`1<TOutput>>> function, KeyValuePair`2<TInput, long> messageWithId);
    private void AsyncCompleteProcessMessageWithTask(Task`1<IEnumerable`1<TOutput>> completed, KeyValuePair`2<TInput, long> messageWithId);
    private void StoreOutputItems(KeyValuePair`2<TInput, long> messageWithId, IEnumerable`1<TOutput> outputItems);
    private void StoreOutputItemsReordered(long id, IEnumerable`1<TOutput> item);
    private void StoreOutputItemsNonReorderedAtomic(IEnumerable`1<TOutput> outputItems);
    private void StoreOutputItemsNonReorderedWithIteration(IEnumerable`1<TOutput> outputItems);
    private void UpdateBoundingCountWithOutputCount(int count);
    public sealed virtual void Complete();
    private sealed virtual override void System.Threading.Tasks.Dataflow.IDataflowBlock.Fault(Exception exception);
    public sealed virtual IDisposable LinkTo(ITargetBlock`1<TOutput> target, DataflowLinkOptions linkOptions);
    public sealed virtual bool TryReceive(Predicate`1<TOutput> filter, TOutput& item);
    public sealed virtual bool TryReceiveAll(IList`1& items);
    public sealed virtual Task get_Completion();
    public int get_InputCount();
    public int get_OutputCount();
    private sealed virtual override DataflowMessageStatus System.Threading.Tasks.Dataflow.ITargetBlock<TInput>.OfferMessage(DataflowMessageHeader messageHeader, TInput messageValue, ISourceBlock`1<TInput> source, bool consumeToAccept);
    private sealed virtual override TOutput System.Threading.Tasks.Dataflow.ISourceBlock<TOutput>.ConsumeMessage(DataflowMessageHeader messageHeader, ITargetBlock`1<TOutput> target, Boolean& messageConsumed);
    private sealed virtual override bool System.Threading.Tasks.Dataflow.ISourceBlock<TOutput>.ReserveMessage(DataflowMessageHeader messageHeader, ITargetBlock`1<TOutput> target);
    private sealed virtual override void System.Threading.Tasks.Dataflow.ISourceBlock<TOutput>.ReleaseReservation(DataflowMessageHeader messageHeader, ITargetBlock`1<TOutput> target);
    private int get_InputCountForDebugger();
    private int get_OutputCountForDebugger();
    public virtual string ToString();
    private object get_DebuggerDisplayContent();
    private sealed virtual override object System.Threading.Tasks.Dataflow.Internal.IDebuggerDisplay.get_Content();
    [CompilerGeneratedAttribute]
private static void <.ctor>b__0(ISourceBlock`1<TOutput> owningSource, int count);
    [CompilerGeneratedAttribute]
private static void <.ctor>b__1(ISourceBlock`1<TOutput> owningSource);
    [CompilerGeneratedAttribute]
private static void <.ctor>b__2(object source, IEnumerable`1<TOutput> messages);
    [CompilerGeneratedAttribute]
private static void <.ctor>b__5(Task completed, object state);
    [CompilerGeneratedAttribute]
private static void <.ctor>b__6(Task completed, object state);
    [CompilerGeneratedAttribute]
private static void <.ctor>b__7(object state);
    [CompilerGeneratedAttribute]
private static void <ProcessMessageWithTask>b__12(Task`1<IEnumerable`1<TOutput>> completed, object state);
}
[DebuggerTypeProxyAttribute("System.Threading.Tasks.Dataflow.WriteOnceBlock`1/DebugView")]
[DebuggerDisplayAttribute("{DebuggerDisplayContent,nq}")]
public class System.Threading.Tasks.Dataflow.WriteOnceBlock`1 : object {
    private TargetRegistry`1<T> m_targetRegistry;
    private Func`2<T, T> m_cloningFunction;
    private DataflowBlockOptions m_dataflowBlockOptions;
    private TaskCompletionSource`1<VoidResult> m_lazyCompletionTaskSource;
    private bool m_decliningPermanently;
    private bool m_completionReserved;
    private DataflowMessageHeader m_header;
    private T m_value;
    [CompilerGeneratedAttribute]
private static Action`1<object> CS$<>9__CachedAnonymousMethodDelegate1;
    [CompilerGeneratedAttribute]
private static Action`1<object> CS$<>9__CachedAnonymousMethodDelegate4;
    [CompilerGeneratedAttribute]
private static Action`1<object> CS$<>9__CachedAnonymousMethodDelegate5;
    private object ValueLock { get; }
    public Task Completion { get; }
    private TaskCompletionSource`1<VoidResult> CompletionTaskSource { get; }
    private bool HasValue { get; }
    private T Value { get; }
    private object DebuggerDisplayContent { get; }
    private object System.Threading.Tasks.Dataflow.Internal.IDebuggerDisplay.Content { get; }
    public WriteOnceBlock`1(Func`2<T, T> cloningFunction);
    public WriteOnceBlock`1(Func`2<T, T> cloningFunction, DataflowBlockOptions dataflowBlockOptions);
    private object get_ValueLock();
    private void CompleteBlockAsync(IList`1<Exception> exceptions);
    private void OfferToTargetsAndCompleteBlock();
    private void CompleteBlock(IList`1<Exception> exceptions);
    private sealed virtual override void System.Threading.Tasks.Dataflow.IDataflowBlock.Fault(Exception exception);
    public sealed virtual void Complete();
    private void CompleteCore(Exception exception, bool storeExceptionEvenIfAlreadyCompleting);
    public sealed virtual bool TryReceive(Predicate`1<T> filter, T& item);
    private sealed virtual override bool System.Threading.Tasks.Dataflow.IReceivableSourceBlock<T>.TryReceiveAll(IList`1& items);
    public sealed virtual IDisposable LinkTo(ITargetBlock`1<T> target, DataflowLinkOptions linkOptions);
    public sealed virtual Task get_Completion();
    private sealed virtual override DataflowMessageStatus System.Threading.Tasks.Dataflow.ITargetBlock<T>.OfferMessage(DataflowMessageHeader messageHeader, T messageValue, ISourceBlock`1<T> source, bool consumeToAccept);
    private sealed virtual override T System.Threading.Tasks.Dataflow.ISourceBlock<T>.ConsumeMessage(DataflowMessageHeader messageHeader, ITargetBlock`1<T> target, Boolean& messageConsumed);
    private sealed virtual override bool System.Threading.Tasks.Dataflow.ISourceBlock<T>.ReserveMessage(DataflowMessageHeader messageHeader, ITargetBlock`1<T> target);
    private sealed virtual override void System.Threading.Tasks.Dataflow.ISourceBlock<T>.ReleaseReservation(DataflowMessageHeader messageHeader, ITargetBlock`1<T> target);
    private T CloneItem(T item);
    private List`1<Exception> OfferToTargets();
    private TaskCompletionSource`1<VoidResult> get_CompletionTaskSource();
    private bool get_HasValue();
    private T get_Value();
    public virtual string ToString();
    private object get_DebuggerDisplayContent();
    private sealed virtual override object System.Threading.Tasks.Dataflow.Internal.IDebuggerDisplay.get_Content();
    [CompilerGeneratedAttribute]
private static void <.ctor>b__0(object state);
    [CompilerGeneratedAttribute]
private static void <CompleteBlockAsync>b__2(object state);
    [CompilerGeneratedAttribute]
private static void <CompleteBlockAsync>b__3(object state);
}
internal interface System.Threading.Tasks.IProducerConsumerQueue`1 {
    public bool IsEmpty { get; }
    public int Count { get; }
    public abstract virtual void Enqueue(T item);
    public abstract virtual bool TryDequeue(T& result);
    public abstract virtual bool get_IsEmpty();
    public abstract virtual int get_Count();
    public abstract virtual int GetCountSafe(object syncObj);
}
[DebuggerDisplayAttribute("Count = {Count}")]
internal class System.Threading.Tasks.MultiProducerMultiConsumerQueue`1 : ConcurrentQueue`1<T> {
    private bool System.Threading.Tasks.IProducerConsumerQueue<T>.IsEmpty { get; }
    private int System.Threading.Tasks.IProducerConsumerQueue<T>.Count { get; }
    private sealed virtual override void System.Threading.Tasks.IProducerConsumerQueue<T>.Enqueue(T item);
    private sealed virtual override bool System.Threading.Tasks.IProducerConsumerQueue<T>.TryDequeue(T& result);
    private sealed virtual override bool System.Threading.Tasks.IProducerConsumerQueue<T>.get_IsEmpty();
    private sealed virtual override int System.Threading.Tasks.IProducerConsumerQueue<T>.get_Count();
    private sealed virtual override int System.Threading.Tasks.IProducerConsumerQueue<T>.GetCountSafe(object syncObj);
}
internal class System.Threading.Tasks.PaddingFor32 : ValueType {
}
internal static class System.Threading.Tasks.PaddingHelpers : object {
    internal static int CACHE_LINE_SIZE;
}
[DebuggerDisplayAttribute("Count = {Count}")]
[DebuggerTypeProxyAttribute("System.Threading.Tasks.SingleProducerSingleConsumerQueue`1/SingleProducerSingleConsumerQueue_DebugView")]
internal class System.Threading.Tasks.SingleProducerSingleConsumerQueue`1 : object {
    private static int INIT_SEGMENT_SIZE;
    private static int MAX_SEGMENT_SIZE;
    private Segment modreq(System.Runtime.CompilerServices.IsVolatile) m_head;
    private Segment modreq(System.Runtime.CompilerServices.IsVolatile) m_tail;
    public bool IsEmpty { get; }
    public int Count { get; }
    public sealed virtual void Enqueue(T item);
    private void EnqueueSlow(T item, Segment& segment);
    public sealed virtual bool TryDequeue(T& result);
    private bool TryDequeueSlow(Segment& segment, T[]& array, T& result);
    public bool TryPeek(T& result);
    private bool TryPeekSlow(Segment& segment, T[]& array, T& result);
    public bool TryDequeueIf(Predicate`1<T> predicate, T& result);
    private bool TryDequeueIfSlow(Predicate`1<T> predicate, Segment& segment, T[]& array, T& result);
    public void Clear();
    public sealed virtual bool get_IsEmpty();
    public sealed virtual IEnumerator`1<T> GetEnumerator();
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
    public sealed virtual int get_Count();
    private sealed virtual override int System.Threading.Tasks.IProducerConsumerQueue<T>.GetCountSafe(object syncObj);
}
