[AttributeUsageAttribute("4")]
internal class JetBrains.Annotations.AspChildControlTypeAttribute : Attribute {
    [CompilerGeneratedAttribute]
private string <TagName>k__BackingField;
    [CompilerGeneratedAttribute]
private Type <ControlType>k__BackingField;
    [NotNullAttribute]
public string TagName { get; private set; }
    [NotNullAttribute]
public Type ControlType { get; private set; }
    public AspChildControlTypeAttribute(string tagName, Type controlType);
    [CompilerGeneratedAttribute]
public string get_TagName();
    [CompilerGeneratedAttribute]
private void set_TagName(string value);
    [CompilerGeneratedAttribute]
public Type get_ControlType();
    [CompilerGeneratedAttribute]
private void set_ControlType(Type value);
}
[AttributeUsageAttribute("192")]
internal class JetBrains.Annotations.AspDataFieldAttribute : Attribute {
}
[AttributeUsageAttribute("192")]
internal class JetBrains.Annotations.AspDataFieldsAttribute : Attribute {
}
[AttributeUsageAttribute("128")]
internal class JetBrains.Annotations.AspMethodPropertyAttribute : Attribute {
}
[AttributeUsageAttribute("2112")]
internal class JetBrains.Annotations.AspMvcActionAttribute : Attribute {
    [CompilerGeneratedAttribute]
private string <AnonymousProperty>k__BackingField;
    [CanBeNullAttribute]
public string AnonymousProperty { get; private set; }
    public AspMvcActionAttribute(string anonymousProperty);
    [CompilerGeneratedAttribute]
public string get_AnonymousProperty();
    [CompilerGeneratedAttribute]
private void set_AnonymousProperty(string value);
}
[AttributeUsageAttribute("2176")]
internal class JetBrains.Annotations.AspMvcActionSelectorAttribute : Attribute {
}
[AttributeUsageAttribute("2048")]
internal class JetBrains.Annotations.AspMvcAreaAttribute : Attribute {
    [CompilerGeneratedAttribute]
private string <AnonymousProperty>k__BackingField;
    [CanBeNullAttribute]
public string AnonymousProperty { get; private set; }
    public AspMvcAreaAttribute(string anonymousProperty);
    [CompilerGeneratedAttribute]
public string get_AnonymousProperty();
    [CompilerGeneratedAttribute]
private void set_AnonymousProperty(string value);
}
[AttributeUsageAttribute("385")]
internal class JetBrains.Annotations.AspMvcAreaMasterLocationFormatAttribute : Attribute {
    [CompilerGeneratedAttribute]
private string <Format>k__BackingField;
    [NotNullAttribute]
public string Format { get; private set; }
    public AspMvcAreaMasterLocationFormatAttribute(string format);
    [CompilerGeneratedAttribute]
public string get_Format();
    [CompilerGeneratedAttribute]
private void set_Format(string value);
}
[AttributeUsageAttribute("385")]
internal class JetBrains.Annotations.AspMvcAreaPartialViewLocationFormatAttribute : Attribute {
    [CompilerGeneratedAttribute]
private string <Format>k__BackingField;
    [NotNullAttribute]
public string Format { get; private set; }
    public AspMvcAreaPartialViewLocationFormatAttribute(string format);
    [CompilerGeneratedAttribute]
public string get_Format();
    [CompilerGeneratedAttribute]
private void set_Format(string value);
}
[AttributeUsageAttribute("385")]
internal class JetBrains.Annotations.AspMvcAreaViewLocationFormatAttribute : Attribute {
    [CompilerGeneratedAttribute]
private string <Format>k__BackingField;
    [NotNullAttribute]
public string Format { get; private set; }
    public AspMvcAreaViewLocationFormatAttribute(string format);
    [CompilerGeneratedAttribute]
public string get_Format();
    [CompilerGeneratedAttribute]
private void set_Format(string value);
}
[AttributeUsageAttribute("2112")]
internal class JetBrains.Annotations.AspMvcControllerAttribute : Attribute {
    [CompilerGeneratedAttribute]
private string <AnonymousProperty>k__BackingField;
    [CanBeNullAttribute]
public string AnonymousProperty { get; private set; }
    public AspMvcControllerAttribute(string anonymousProperty);
    [CompilerGeneratedAttribute]
public string get_AnonymousProperty();
    [CompilerGeneratedAttribute]
private void set_AnonymousProperty(string value);
}
[AttributeUsageAttribute("2048")]
internal class JetBrains.Annotations.AspMvcDisplayTemplateAttribute : Attribute {
}
[AttributeUsageAttribute("2048")]
internal class JetBrains.Annotations.AspMvcEditorTemplateAttribute : Attribute {
}
[AttributeUsageAttribute("2048")]
internal class JetBrains.Annotations.AspMvcMasterAttribute : Attribute {
}
[AttributeUsageAttribute("385")]
internal class JetBrains.Annotations.AspMvcMasterLocationFormatAttribute : Attribute {
    [CompilerGeneratedAttribute]
private string <Format>k__BackingField;
    [NotNullAttribute]
public string Format { get; private set; }
    public AspMvcMasterLocationFormatAttribute(string format);
    [CompilerGeneratedAttribute]
public string get_Format();
    [CompilerGeneratedAttribute]
private void set_Format(string value);
}
[AttributeUsageAttribute("2048")]
internal class JetBrains.Annotations.AspMvcModelTypeAttribute : Attribute {
}
[AttributeUsageAttribute("2112")]
internal class JetBrains.Annotations.AspMvcPartialViewAttribute : Attribute {
}
[AttributeUsageAttribute("385")]
internal class JetBrains.Annotations.AspMvcPartialViewLocationFormatAttribute : Attribute {
    [CompilerGeneratedAttribute]
private string <Format>k__BackingField;
    [NotNullAttribute]
public string Format { get; private set; }
    public AspMvcPartialViewLocationFormatAttribute(string format);
    [CompilerGeneratedAttribute]
public string get_Format();
    [CompilerGeneratedAttribute]
private void set_Format(string value);
}
[AttributeUsageAttribute("68")]
internal class JetBrains.Annotations.AspMvcSuppressViewErrorAttribute : Attribute {
}
[AttributeUsageAttribute("2048")]
internal class JetBrains.Annotations.AspMvcTemplateAttribute : Attribute {
}
[AttributeUsageAttribute("2112")]
internal class JetBrains.Annotations.AspMvcViewAttribute : Attribute {
}
[AttributeUsageAttribute("2048")]
internal class JetBrains.Annotations.AspMvcViewComponentAttribute : Attribute {
}
[AttributeUsageAttribute("2112")]
internal class JetBrains.Annotations.AspMvcViewComponentViewAttribute : Attribute {
}
[AttributeUsageAttribute("385")]
internal class JetBrains.Annotations.AspMvcViewLocationFormatAttribute : Attribute {
    [CompilerGeneratedAttribute]
private string <Format>k__BackingField;
    [NotNullAttribute]
public string Format { get; private set; }
    public AspMvcViewLocationFormatAttribute(string format);
    [CompilerGeneratedAttribute]
public string get_Format();
    [CompilerGeneratedAttribute]
private void set_Format(string value);
}
[AttributeUsageAttribute("4")]
internal class JetBrains.Annotations.AspRequiredAttributeAttribute : Attribute {
    [CompilerGeneratedAttribute]
private string <Attribute>k__BackingField;
    [NotNullAttribute]
public string Attribute { get; private set; }
    public AspRequiredAttributeAttribute(string attribute);
    [CompilerGeneratedAttribute]
public string get_Attribute();
    [CompilerGeneratedAttribute]
private void set_Attribute(string value);
}
[AttributeUsageAttribute("128")]
internal class JetBrains.Annotations.AspTypePropertyAttribute : Attribute {
    [CompilerGeneratedAttribute]
private bool <CreateConstructorReferences>k__BackingField;
    public bool CreateConstructorReferences { get; private set; }
    public AspTypePropertyAttribute(bool createConstructorReferences);
    [CompilerGeneratedAttribute]
public bool get_CreateConstructorReferences();
    [CompilerGeneratedAttribute]
private void set_CreateConstructorReferences(bool value);
}
[AttributeUsageAttribute("2048")]
internal class JetBrains.Annotations.AssertionConditionAttribute : Attribute {
    [CompilerGeneratedAttribute]
private AssertionConditionType <ConditionType>k__BackingField;
    public AssertionConditionType ConditionType { get; private set; }
    public AssertionConditionAttribute(AssertionConditionType conditionType);
    [CompilerGeneratedAttribute]
public AssertionConditionType get_ConditionType();
    [CompilerGeneratedAttribute]
private void set_ConditionType(AssertionConditionType value);
}
internal enum JetBrains.Annotations.AssertionConditionType : Enum {
    public int value__;
    public static AssertionConditionType IS_TRUE;
    public static AssertionConditionType IS_FALSE;
    public static AssertionConditionType IS_NULL;
    public static AssertionConditionType IS_NOT_NULL;
}
[AttributeUsageAttribute("64")]
internal class JetBrains.Annotations.AssertionMethodAttribute : Attribute {
}
[AttributeUsageAttribute("4")]
[BaseTypeRequiredAttribute("System.Attribute")]
internal class JetBrains.Annotations.BaseTypeRequiredAttribute : Attribute {
    [CompilerGeneratedAttribute]
private Type <BaseType>k__BackingField;
    [NotNullAttribute]
public Type BaseType { get; private set; }
    public BaseTypeRequiredAttribute(Type baseType);
    [CompilerGeneratedAttribute]
public Type get_BaseType();
    [CompilerGeneratedAttribute]
private void set_BaseType(Type value);
}
[AttributeUsageAttribute("24516")]
internal class JetBrains.Annotations.CanBeNullAttribute : Attribute {
}
[AttributeUsageAttribute("1036")]
internal class JetBrains.Annotations.CannotApplyEqualityOperatorAttribute : Attribute {
}
[AttributeUsageAttribute("224")]
internal class JetBrains.Annotations.CollectionAccessAttribute : Attribute {
    [CompilerGeneratedAttribute]
private CollectionAccessType <CollectionAccessType>k__BackingField;
    public CollectionAccessType CollectionAccessType { get; private set; }
    public CollectionAccessAttribute(CollectionAccessType collectionAccessType);
    [CompilerGeneratedAttribute]
public CollectionAccessType get_CollectionAccessType();
    [CompilerGeneratedAttribute]
private void set_CollectionAccessType(CollectionAccessType value);
}
[FlagsAttribute]
internal enum JetBrains.Annotations.CollectionAccessType : Enum {
    public int value__;
    public static CollectionAccessType None;
    public static CollectionAccessType Read;
    public static CollectionAccessType ModifyExistingContent;
    public static CollectionAccessType UpdatedContent;
}
[AttributeUsageAttribute("64")]
internal class JetBrains.Annotations.ContractAnnotationAttribute : Attribute {
    [CompilerGeneratedAttribute]
private string <Contract>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <ForceFullStates>k__BackingField;
    [NotNullAttribute]
public string Contract { get; private set; }
    public bool ForceFullStates { get; private set; }
    public ContractAnnotationAttribute(string contract);
    public ContractAnnotationAttribute(string contract, bool forceFullStates);
    [CompilerGeneratedAttribute]
public string get_Contract();
    [CompilerGeneratedAttribute]
private void set_Contract(string value);
    [CompilerGeneratedAttribute]
public bool get_ForceFullStates();
    [CompilerGeneratedAttribute]
private void set_ForceFullStates(bool value);
}
[AttributeUsageAttribute("2432")]
internal class JetBrains.Annotations.HtmlAttributeValueAttribute : Attribute {
    [CompilerGeneratedAttribute]
private string <Name>k__BackingField;
    [NotNullAttribute]
public string Name { get; private set; }
    public HtmlAttributeValueAttribute(string name);
    [CompilerGeneratedAttribute]
public string get_Name();
    [CompilerGeneratedAttribute]
private void set_Name(string value);
}
[AttributeUsageAttribute("2432")]
internal class JetBrains.Annotations.HtmlElementAttributesAttribute : Attribute {
    [CompilerGeneratedAttribute]
private string <Name>k__BackingField;
    [CanBeNullAttribute]
public string Name { get; private set; }
    public HtmlElementAttributesAttribute(string name);
    [CompilerGeneratedAttribute]
public string get_Name();
    [CompilerGeneratedAttribute]
private void set_Name(string value);
}
[FlagsAttribute]
internal enum JetBrains.Annotations.ImplicitUseKindFlags : Enum {
    public int value__;
    public static ImplicitUseKindFlags Default;
    public static ImplicitUseKindFlags Access;
    public static ImplicitUseKindFlags Assign;
    public static ImplicitUseKindFlags InstantiatedWithFixedConstructorSignature;
    public static ImplicitUseKindFlags InstantiatedNoFixedConstructorSignature;
}
[FlagsAttribute]
internal enum JetBrains.Annotations.ImplicitUseTargetFlags : Enum {
    public int value__;
    public static ImplicitUseTargetFlags Default;
    public static ImplicitUseTargetFlags Itself;
    public static ImplicitUseTargetFlags Members;
    public static ImplicitUseTargetFlags WithMembers;
}
[AttributeUsageAttribute("2048")]
internal class JetBrains.Annotations.InstantHandleAttribute : Attribute {
}
[AttributeUsageAttribute("2048")]
internal class JetBrains.Annotations.InvokerParameterNameAttribute : Attribute {
}
[AttributeUsageAttribute("6592")]
internal class JetBrains.Annotations.ItemCanBeNullAttribute : Attribute {
}
[AttributeUsageAttribute("6592")]
internal class JetBrains.Annotations.ItemNotNullAttribute : Attribute {
}
[AttributeUsageAttribute("64")]
internal class JetBrains.Annotations.LinqTunnelAttribute : Attribute {
}
[AttributeUsageAttribute("32767")]
internal class JetBrains.Annotations.LocalizationRequiredAttribute : Attribute {
    [CompilerGeneratedAttribute]
private bool <Required>k__BackingField;
    public bool Required { get; private set; }
    public LocalizationRequiredAttribute(bool required);
    [CompilerGeneratedAttribute]
public bool get_Required();
    [CompilerGeneratedAttribute]
private void set_Required(bool value);
}
[AttributeUsageAttribute("2112")]
internal class JetBrains.Annotations.MacroAttribute : Attribute {
    [CompilerGeneratedAttribute]
private string <Expression>k__BackingField;
    [CompilerGeneratedAttribute]
private int <Editable>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Target>k__BackingField;
    [CanBeNullAttribute]
public string Expression { get; public set; }
    public int Editable { get; public set; }
    [CanBeNullAttribute]
public string Target { get; public set; }
    [CompilerGeneratedAttribute]
public string get_Expression();
    [CompilerGeneratedAttribute]
public void set_Expression(string value);
    [CompilerGeneratedAttribute]
public int get_Editable();
    [CompilerGeneratedAttribute]
public void set_Editable(int value);
    [CompilerGeneratedAttribute]
public string get_Target();
    [CompilerGeneratedAttribute]
public void set_Target(string value);
}
[AttributeUsageAttribute("16388")]
internal class JetBrains.Annotations.MeansImplicitUseAttribute : Attribute {
    [CompilerGeneratedAttribute]
private ImplicitUseKindFlags <UseKindFlags>k__BackingField;
    [CompilerGeneratedAttribute]
private ImplicitUseTargetFlags <TargetFlags>k__BackingField;
    [UsedImplicitlyAttribute]
public ImplicitUseKindFlags UseKindFlags { get; private set; }
    [UsedImplicitlyAttribute]
public ImplicitUseTargetFlags TargetFlags { get; private set; }
    public MeansImplicitUseAttribute(ImplicitUseKindFlags useKindFlags);
    public MeansImplicitUseAttribute(ImplicitUseTargetFlags targetFlags);
    public MeansImplicitUseAttribute(ImplicitUseKindFlags useKindFlags, ImplicitUseTargetFlags targetFlags);
    [CompilerGeneratedAttribute]
public ImplicitUseKindFlags get_UseKindFlags();
    [CompilerGeneratedAttribute]
private void set_UseKindFlags(ImplicitUseKindFlags value);
    [CompilerGeneratedAttribute]
public ImplicitUseTargetFlags get_TargetFlags();
    [CompilerGeneratedAttribute]
private void set_TargetFlags(ImplicitUseTargetFlags value);
}
[AttributeUsageAttribute("64")]
internal class JetBrains.Annotations.MustUseReturnValueAttribute : Attribute {
    [CompilerGeneratedAttribute]
private string <Justification>k__BackingField;
    [CanBeNullAttribute]
public string Justification { get; private set; }
    public MustUseReturnValueAttribute(string justification);
    [CompilerGeneratedAttribute]
public string get_Justification();
    [CompilerGeneratedAttribute]
private void set_Justification(string value);
}
[AttributeUsageAttribute("2048")]
internal class JetBrains.Annotations.NoEnumerationAttribute : Attribute {
}
[AttributeUsageAttribute("1052")]
internal class JetBrains.Annotations.NoReorderAttribute : Attribute {
}
[AttributeUsageAttribute("64")]
internal class JetBrains.Annotations.NotifyPropertyChangedInvocatorAttribute : Attribute {
    [CompilerGeneratedAttribute]
private string <ParameterName>k__BackingField;
    [CanBeNullAttribute]
public string ParameterName { get; private set; }
    public NotifyPropertyChangedInvocatorAttribute(string parameterName);
    [CompilerGeneratedAttribute]
public string get_ParameterName();
    [CompilerGeneratedAttribute]
private void set_ParameterName(string value);
}
[AttributeUsageAttribute("24516")]
internal class JetBrains.Annotations.NotNullAttribute : Attribute {
}
[AttributeUsageAttribute("2048")]
internal class JetBrains.Annotations.PathReferenceAttribute : Attribute {
    [CompilerGeneratedAttribute]
private string <BasePath>k__BackingField;
    [CanBeNullAttribute]
public string BasePath { get; private set; }
    public PathReferenceAttribute(string basePath);
    [CompilerGeneratedAttribute]
public string get_BasePath();
    [CompilerGeneratedAttribute]
private void set_BasePath(string value);
}
[AttributeUsageAttribute("19916")]
internal class JetBrains.Annotations.ProvidesContextAttribute : Attribute {
}
[MeansImplicitUseAttribute("3")]
internal class JetBrains.Annotations.PublicAPIAttribute : Attribute {
    [CompilerGeneratedAttribute]
private string <Comment>k__BackingField;
    [CanBeNullAttribute]
public string Comment { get; private set; }
    public PublicAPIAttribute(string comment);
    [CompilerGeneratedAttribute]
public string get_Comment();
    [CompilerGeneratedAttribute]
private void set_Comment(string value);
}
[AttributeUsageAttribute("64")]
internal class JetBrains.Annotations.PureAttribute : Attribute {
}
[AttributeUsageAttribute("1")]
internal class JetBrains.Annotations.RazorDirectiveAttribute : Attribute {
    [CompilerGeneratedAttribute]
private string <Directive>k__BackingField;
    [NotNullAttribute]
public string Directive { get; private set; }
    public RazorDirectiveAttribute(string directive);
    [CompilerGeneratedAttribute]
public string get_Directive();
    [CompilerGeneratedAttribute]
private void set_Directive(string value);
}
[AttributeUsageAttribute("64")]
internal class JetBrains.Annotations.RazorHelperCommonAttribute : Attribute {
}
[AttributeUsageAttribute("1")]
internal class JetBrains.Annotations.RazorImportNamespaceAttribute : Attribute {
    [CompilerGeneratedAttribute]
private string <Name>k__BackingField;
    [NotNullAttribute]
public string Name { get; private set; }
    public RazorImportNamespaceAttribute(string name);
    [CompilerGeneratedAttribute]
public string get_Name();
    [CompilerGeneratedAttribute]
private void set_Name(string value);
}
[AttributeUsageAttribute("1")]
internal class JetBrains.Annotations.RazorInjectionAttribute : Attribute {
    [CompilerGeneratedAttribute]
private string <Type>k__BackingField;
    [CompilerGeneratedAttribute]
private string <FieldName>k__BackingField;
    [NotNullAttribute]
public string Type { get; private set; }
    [NotNullAttribute]
public string FieldName { get; private set; }
    public RazorInjectionAttribute(string type, string fieldName);
    [CompilerGeneratedAttribute]
public string get_Type();
    [CompilerGeneratedAttribute]
private void set_Type(string value);
    [CompilerGeneratedAttribute]
public string get_FieldName();
    [CompilerGeneratedAttribute]
private void set_FieldName(string value);
}
[AttributeUsageAttribute("128")]
internal class JetBrains.Annotations.RazorLayoutAttribute : Attribute {
}
[AttributeUsageAttribute("1")]
internal class JetBrains.Annotations.RazorPageBaseTypeAttribute : Attribute {
    [CompilerGeneratedAttribute]
private string <BaseType>k__BackingField;
    [CompilerGeneratedAttribute]
private string <PageName>k__BackingField;
    [NotNullAttribute]
public string BaseType { get; private set; }
    [CanBeNullAttribute]
public string PageName { get; private set; }
    public RazorPageBaseTypeAttribute(string baseType);
    public RazorPageBaseTypeAttribute(string baseType, string pageName);
    [CompilerGeneratedAttribute]
public string get_BaseType();
    [CompilerGeneratedAttribute]
private void set_BaseType(string value);
    [CompilerGeneratedAttribute]
public string get_PageName();
    [CompilerGeneratedAttribute]
private void set_PageName(string value);
}
[AttributeUsageAttribute("2112")]
internal class JetBrains.Annotations.RazorSectionAttribute : Attribute {
}
[AttributeUsageAttribute("64")]
internal class JetBrains.Annotations.RazorWriteLiteralMethodAttribute : Attribute {
}
[AttributeUsageAttribute("64")]
internal class JetBrains.Annotations.RazorWriteMethodAttribute : Attribute {
}
[AttributeUsageAttribute("2048")]
internal class JetBrains.Annotations.RazorWriteMethodParameterAttribute : Attribute {
}
[AttributeUsageAttribute("2048")]
internal class JetBrains.Annotations.RegexPatternAttribute : Attribute {
}
[AttributeUsageAttribute("64")]
internal class JetBrains.Annotations.SourceTemplateAttribute : Attribute {
}
[AttributeUsageAttribute("4320")]
internal class JetBrains.Annotations.StringFormatMethodAttribute : Attribute {
    [CompilerGeneratedAttribute]
private string <FormatParameterName>k__BackingField;
    [NotNullAttribute]
public string FormatParameterName { get; private set; }
    public StringFormatMethodAttribute(string formatParameterName);
    [CompilerGeneratedAttribute]
public string get_FormatParameterName();
    [CompilerGeneratedAttribute]
private void set_FormatParameterName(string value);
}
[ObsoleteAttribute("Use [ContractAnnotation('=> halt')] instead")]
[AttributeUsageAttribute("64")]
internal class JetBrains.Annotations.TerminatesProgramAttribute : Attribute {
}
[AttributeUsageAttribute("32767")]
internal class JetBrains.Annotations.UsedImplicitlyAttribute : Attribute {
    [CompilerGeneratedAttribute]
private ImplicitUseKindFlags <UseKindFlags>k__BackingField;
    [CompilerGeneratedAttribute]
private ImplicitUseTargetFlags <TargetFlags>k__BackingField;
    public ImplicitUseKindFlags UseKindFlags { get; private set; }
    public ImplicitUseTargetFlags TargetFlags { get; private set; }
    public UsedImplicitlyAttribute(ImplicitUseKindFlags useKindFlags);
    public UsedImplicitlyAttribute(ImplicitUseTargetFlags targetFlags);
    public UsedImplicitlyAttribute(ImplicitUseKindFlags useKindFlags, ImplicitUseTargetFlags targetFlags);
    [CompilerGeneratedAttribute]
public ImplicitUseKindFlags get_UseKindFlags();
    [CompilerGeneratedAttribute]
private void set_UseKindFlags(ImplicitUseKindFlags value);
    [CompilerGeneratedAttribute]
public ImplicitUseTargetFlags get_TargetFlags();
    [CompilerGeneratedAttribute]
private void set_TargetFlags(ImplicitUseTargetFlags value);
}
[AttributeUsageAttribute("2432")]
internal class JetBrains.Annotations.ValueProviderAttribute : Attribute {
    [CompilerGeneratedAttribute]
private string <Name>k__BackingField;
    [NotNullAttribute]
public string Name { get; private set; }
    public ValueProviderAttribute(string name);
    [CompilerGeneratedAttribute]
public string get_Name();
    [CompilerGeneratedAttribute]
private void set_Name(string value);
}
[AttributeUsageAttribute("128")]
internal class JetBrains.Annotations.XamlItemBindingOfItemsControlAttribute : Attribute {
}
[AttributeUsageAttribute("4")]
internal class JetBrains.Annotations.XamlItemsControlAttribute : Attribute {
}
[CompilerGeneratedAttribute]
[EmbeddedAttribute]
internal class Microsoft.CodeAnalysis.EmbeddedAttribute : Attribute {
}
internal static class Microsoft.Win32.NativeMethods : object {
    private static string ADVAPI32;
    private static string KERNEL32;
    private static int MAX_PREFERRED_LENGTH;
    private static string NTDSAPI;
    [ReliabilityContractAttribute("3", "1")]
public static bool AdjustTokenPrivileges(SafeTokenHandle TokenHandle, bool DisableAllPrivileges, TOKEN_PRIVILEGES& NewState, UInt32 BufferLength, TOKEN_PRIVILEGES& PreviousState, UInt32& ReturnLength);
    [ReliabilityContractAttribute("3", "1")]
public static bool AdjustTokenPrivileges(SafeTokenHandle TokenHandle, bool DisableAllPrivileges, TOKEN_PRIVILEGES& NewState, UInt32 BufferLength, IntPtr PreviousState, IntPtr ReturnLength);
    public static bool ConvertStringSidToSid(string pStringSid, IntPtr& sid);
    public static bool DuplicateToken(SafeTokenHandle ExistingTokenHandle, SECURITY_IMPERSONATION_LEVEL ImpersonationLevel, SafeTokenHandle& DuplicateTokenHandle);
    [ReliabilityContractAttribute("3", "1")]
internal static bool DuplicateTokenEx(SafeTokenHandle ExistingTokenHandle, AccessTypes DesiredAccess, IntPtr TokenAttributes, SECURITY_IMPERSONATION_LEVEL ImpersonationLevel, TokenType TokenType, SafeTokenHandle& DuplicateTokenHandle);
    public static IntPtr GetSidSubAuthority(IntPtr pSid, UInt32 nSubAuthority);
    public static bool GetTokenInformation(SafeTokenHandle hToken, TOKEN_INFORMATION_CLASS tokenInfoClass, IntPtr pTokenInfo, int tokenInfoLength, Int32& returnLength);
    public static bool ImpersonateLoggedOnUser(IntPtr hToken);
    public static int LogonUser(string lpszUserName, string lpszDomain, string lpszPassword, int dwLogonType, int dwLogonProvider, SafeTokenHandle& phToken);
    public static bool LookupAccountSid(string systemName, Byte[] accountSid, StringBuilder accountName, Int32& nameLength, StringBuilder domainName, Int32& domainLength, Int32& accountType);
    public static bool LookupAccountSid(string systemName, IntPtr sid, StringBuilder name, Int32& cchName, StringBuilder referencedDomainName, Int32& cchReferencedDomainName, Int32& use);
    public static bool LookupPrivilegeValue(string systemName, string name, LUID& luid);
    public static bool OpenProcessToken(IntPtr ProcessHandle, AccessTypes DesiredAccess, SafeTokenHandle& TokenHandle);
    public static bool OpenThreadToken(IntPtr ThreadHandle, AccessTypes DesiredAccess, bool OpenAsSelf, SafeTokenHandle& TokenHandle);
    public static bool PrivilegeCheck(IntPtr ClientToken, PRIVILEGE_SET& RequiredPrivileges, Int32& result);
    public static bool RevertToSelf();
    public static bool SetThreadToken(IntPtr ThreadHandle, SafeTokenHandle TokenHandle);
    [ReliabilityContractAttribute("3", "2")]
public static bool CloseHandle(IntPtr handle);
    public static IntPtr GetCurrentProcess();
    public static IntPtr GetCurrentThread();
    public static IntPtr GlobalLock(IntPtr hMem);
    public static bool GlobalUnlock(IntPtr hMem);
    public static IntPtr LoadLibrary(string filename);
    public static bool FreeLibrary(IntPtr lib);
    private static int NetServerGetInfo(string serverName, int level, IntPtr& pSERVER_INFO_XXX);
    [SuppressUnmanagedCodeSecurityAttribute]
private static int NetServerEnum(string servernane, int level, IntPtr& bufptr, int prefmaxlen, Int32& entriesread, Int32& totalentries, ServerTypes servertype, string domain, IntPtr resume_handle);
    [SuppressUnmanagedCodeSecurityAttribute]
private static int NetApiBufferFree(IntPtr pBuf);
    public static IEnumerable`1<string> GetNetworkComputerNames(ServerTypes serverTypes, string domain);
    public static IEnumerable`1<NetworkComputerInfo> GetNetworkComputerInfo(ServerTypes serverTypes, string domain);
    public static T[] NetServerEnum(ServerTypes serverTypes, string domain, int level);
    public static T NetServerGetInfo(string serverName, int level);
    public static void DsBind(string DomainControllerName, string DnsDomainName, IntPtr& phDS);
    public static UInt32 DsCrackNames(IntPtr hDS, DS_NAME_FLAGS flags, DS_NAME_FORMAT formatOffered, DS_NAME_FORMAT formatDesired, UInt32 cNames, String[] rpNames, IntPtr& ppResult);
    public static void DsFreeNameResult(IntPtr pResult);
    public static UInt32 DsUnBind(IntPtr& phDS);
}
[PublicAPIAttribute]
public abstract class Microsoft.Win32.TaskScheduler.Action : object {
    internal IAction iAction;
    internal ITask v1Task;
    protected Dictionary`2<string, object> unboundValues;
    [CompilerGeneratedAttribute]
private PropertyChangedEventHandler PropertyChanged;
    [XmlIgnoreAttribute]
public TaskActionType ActionType { get; }
    [DefaultValueAttribute("")]
[XmlAttributeAttribute]
public string Id { get; public set; }
    internal TaskActionType InternalActionType { get; }
    internal Action(IAction action);
    internal Action(ITask iTask);
    [CompilerGeneratedAttribute]
public sealed virtual void add_PropertyChanged(PropertyChangedEventHandler value);
    [CompilerGeneratedAttribute]
public sealed virtual void remove_PropertyChanged(PropertyChangedEventHandler value);
    public TaskActionType get_ActionType();
    public virtual string get_Id();
    public virtual void set_Id(string value);
    internal abstract virtual TaskActionType get_InternalActionType();
    public static Action CreateAction(TaskActionType actionType);
    public sealed virtual object Clone();
    public sealed virtual int CompareTo(Action obj);
    public virtual void Dispose();
    public virtual bool Equals(object obj);
    public virtual bool Equals(Action other);
    public virtual int GetHashCode();
    public virtual string ToString();
    public virtual string ToString(CultureInfo culture);
    private sealed virtual override int System.IComparable.CompareTo(object obj);
    internal static Action ActionFromScript(string actionType, string script);
    internal static Action ConvertFromPowerShellAction(ExecAction execAction);
    internal static Action CreateAction(ITask iTask);
    internal static Action CreateAction(IAction iAction);
    internal static T TryParse(string val, T defaultVal);
    internal virtual void Bind(ITask iTask);
    internal virtual void Bind(ITaskDefinition iTaskDef);
    internal virtual void CopyProperties(Action sourceAction);
    internal abstract virtual void CreateV2Action(IActionCollection iActions);
    internal abstract virtual string GetPowerShellCommand();
    internal T GetProperty(string propName, T defaultValue);
    internal void OnPropertyChanged(string propName);
    internal void SetProperty(string propName, T value);
    [NotNullAttribute]
private static Type GetObjectType(TaskActionType actionType);
}
[DefaultMemberAttribute("Item")]
[XmlRootAttribute("Actions")]
[PublicAPIAttribute]
public class Microsoft.Win32.TaskScheduler.ActionCollection : object {
    internal static int MaxActions;
    private static string IndexerName;
    private static string psV2IdRegex;
    private bool inV2set;
    private PowerShellActionPlatformOption psConvert;
    private List`1<Action> v1Actions;
    private ITask v1Task;
    private IActionCollection v2Coll;
    private ITaskDefinition v2Def;
    [CompilerGeneratedAttribute]
private NotifyCollectionChangedEventHandler CollectionChanged;
    [CompilerGeneratedAttribute]
private PropertyChangedEventHandler PropertyChanged;
    [XmlAttributeAttribute]
[DefaultValueAttribute("")]
[CanBeNullAttribute]
public string Context { get; public set; }
    [DefaultValueAttribute("Microsoft.Win32.TaskScheduler.PowerShellActionPlatformOption", "Version2")]
public PowerShellActionPlatformOption PowerShellConversion { get; public set; }
    public string XmlText { get; public set; }
    public int Count { get; }
    private bool System.Collections.IList.IsFixedSize { get; }
    private bool System.Collections.Generic.ICollection<Microsoft.Win32.TaskScheduler.Action>.IsReadOnly { get; }
    private bool System.Collections.IList.IsReadOnly { get; }
    private bool System.Collections.ICollection.IsSynchronized { get; }
    private object System.Collections.ICollection.SyncRoot { get; }
    private bool SupportV1Conversion { get; }
    private bool SupportV2Conversion { get; }
    [NotNullAttribute]
public Action Item { get; public set; }
    [NotNullAttribute]
public Action Item { get; public set; }
    private object System.Collections.IList.Item { get; private set; }
    internal ActionCollection(ITask task);
    internal ActionCollection(ITaskDefinition iTaskDef);
    private static ActionCollection();
    [CompilerGeneratedAttribute]
public sealed virtual void add_CollectionChanged(NotifyCollectionChangedEventHandler value);
    [CompilerGeneratedAttribute]
public sealed virtual void remove_CollectionChanged(NotifyCollectionChangedEventHandler value);
    [CompilerGeneratedAttribute]
public sealed virtual void add_PropertyChanged(PropertyChangedEventHandler value);
    [CompilerGeneratedAttribute]
public sealed virtual void remove_PropertyChanged(PropertyChangedEventHandler value);
    public string get_Context();
    public void set_Context(string value);
    public PowerShellActionPlatformOption get_PowerShellConversion();
    public void set_PowerShellConversion(PowerShellActionPlatformOption value);
    public string get_XmlText();
    public void set_XmlText(string value);
    public sealed virtual int get_Count();
    private sealed virtual override bool System.Collections.IList.get_IsFixedSize();
    private sealed virtual override bool System.Collections.Generic.ICollection<Microsoft.Win32.TaskScheduler.Action>.get_IsReadOnly();
    private sealed virtual override bool System.Collections.IList.get_IsReadOnly();
    private sealed virtual override bool System.Collections.ICollection.get_IsSynchronized();
    private sealed virtual override object System.Collections.ICollection.get_SyncRoot();
    private bool get_SupportV1Conversion();
    private bool get_SupportV2Conversion();
    public Action get_Item(string actionId);
    public void set_Item(string actionId, Action value);
    public sealed virtual Action get_Item(int index);
    public sealed virtual void set_Item(int index, Action value);
    private sealed virtual override object System.Collections.IList.get_Item(int index);
    private sealed virtual override void System.Collections.IList.set_Item(int index, object value);
    [NotNullAttribute]
public TAction Add(TAction action);
    [NotNullAttribute]
public ExecAction Add(string path, string arguments, string workingDirectory);
    [NotNullAttribute]
public Action AddNew(TaskActionType actionType);
    public void AddRange(IEnumerable`1<Action> actions);
    public sealed virtual void Clear();
    public sealed virtual bool Contains(Action item);
    public bool ContainsType(Type actionType);
    public sealed virtual void CopyTo(Action[] array, int arrayIndex);
    public void CopyTo(int index, Action[] array, int arrayIndex, int count);
    public sealed virtual void Dispose();
    public Action Find(Predicate`1<Action> match);
    public int FindIndexOf(int startIndex, int count, Predicate`1<Action> match);
    public int FindIndexOf(Predicate`1<Action> match);
    public sealed virtual IEnumerator`1<Action> GetEnumerator();
    public sealed virtual int IndexOf(Action item);
    public int IndexOf(string actionId);
    public sealed virtual void Insert(int index, Action action);
    public sealed virtual bool Remove(Action item);
    public sealed virtual void RemoveAt(int index);
    [NotNullAttribute]
[ItemNotNullAttribute]
public Action[] ToArray();
    public virtual string ToString();
    private sealed virtual override void System.Collections.Generic.ICollection<Microsoft.Win32.TaskScheduler.Action>.Add(Action item);
    private sealed virtual override int System.Collections.IList.Add(object value);
    private sealed virtual override bool System.Collections.IList.Contains(object value);
    private sealed virtual override void System.Collections.ICollection.CopyTo(Array array, int index);
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
    private sealed virtual override XmlSchema System.Xml.Serialization.IXmlSerializable.GetSchema();
    private sealed virtual override int System.Collections.IList.IndexOf(object value);
    private sealed virtual override void System.Collections.IList.Insert(int index, object value);
    private sealed virtual override void System.Xml.Serialization.IXmlSerializable.ReadXml(XmlReader reader);
    private sealed virtual override void System.Collections.IList.Remove(object value);
    private sealed virtual override void System.Xml.Serialization.IXmlSerializable.WriteXml(XmlWriter writer);
    internal void ConvertUnsupportedActions();
    private List`1<Action> GetV1Actions();
    private void OnNotifyPropertyChanged(string propertyName);
    private void SaveV1Actions();
    private void UnconvertUnsupportedActions();
    [CompilerGeneratedAttribute]
private int <GetEnumerator>b__64_0();
    [CompilerGeneratedAttribute]
private IAction <GetEnumerator>b__64_1(int i);
}
public class Microsoft.Win32.TaskScheduler.BootTrigger : Trigger {
    [DefaultValueAttribute("System.TimeSpan", "00:00:00")]
[XmlIgnoreAttribute]
public TimeSpan Delay { get; public set; }
    internal BootTrigger(ITaskTrigger iTrigger);
    internal BootTrigger(ITrigger iTrigger);
    public sealed virtual TimeSpan get_Delay();
    public sealed virtual void set_Delay(TimeSpan value);
    protected virtual string V2GetTriggerString();
}
internal static class Microsoft.Win32.TaskScheduler.CalendarTrigger : object {
    public static void WriteXml(XmlWriter writer, Trigger t, CalendarXmlWriter calWriterProc);
    internal static Trigger GetTriggerFromXml(XmlReader reader);
    internal static void ReadXml(XmlReader reader, Trigger t, CalendarXmlReader calReaderProc);
}
[XmlTypeAttribute]
[XmlRootAttribute("ComHandler")]
public class Microsoft.Win32.TaskScheduler.ComHandlerAction : Action {
    public Guid ClassId { get; public set; }
    public string ClassName { get; }
    [DefaultValueAttribute("")]
[CanBeNullAttribute]
public string Data { get; public set; }
    internal TaskActionType InternalActionType { get; }
    public ComHandlerAction(Guid classId, string data);
    internal ComHandlerAction(ITask task);
    internal ComHandlerAction(IAction action);
    public Guid get_ClassId();
    public void set_ClassId(Guid value);
    public string get_ClassName();
    public string get_Data();
    public void set_Data(string value);
    internal virtual TaskActionType get_InternalActionType();
    public virtual bool Equals(Action other);
    public virtual string ToString();
    internal static Action FromPowerShellCommand(string p);
    internal virtual void CopyProperties(Action sourceAction);
    internal virtual void CreateV2Action(IActionCollection iActions);
    internal virtual string GetPowerShellCommand();
    [CanBeNullAttribute]
private static string GetNameForCLSID(Guid guid);
}
internal class Microsoft.Win32.TaskScheduler.CultureSwitcher : object {
    private CultureInfo cur;
    private CultureInfo curUI;
    public CultureSwitcher(CultureInfo culture);
    public sealed virtual void Dispose();
}
public class Microsoft.Win32.TaskScheduler.CustomTrigger : Trigger {
    private NamedValueCollection nvc;
    private TimeSpan delay;
    private string name;
    public TimeSpan Delay { get; public set; }
    public string Name { get; }
    [XmlArrayAttribute]
[XmlArrayItemAttribute("Property")]
public NamedValueCollection Properties { get; }
    internal CustomTrigger(ITrigger iTrigger);
    public sealed virtual TimeSpan get_Delay();
    public sealed virtual void set_Delay(TimeSpan value);
    public string get_Name();
    public NamedValueCollection get_Properties();
    public virtual object Clone();
    internal void UpdateFromXml(string xml);
    protected virtual string V2GetTriggerString();
}
[XmlRootAttribute("CalendarTrigger")]
public class Microsoft.Win32.TaskScheduler.DailyTrigger : Trigger {
    [DefaultValueAttribute("1")]
public short DaysInterval { get; public set; }
    [DefaultValueAttribute("System.TimeSpan", "00:00:00")]
[XmlIgnoreAttribute]
public TimeSpan RandomDelay { get; public set; }
    private TimeSpan Microsoft.Win32.TaskScheduler.ITriggerDelay.Delay { get; private set; }
    public DailyTrigger(short daysInterval);
    internal DailyTrigger(ITaskTrigger iTrigger);
    internal DailyTrigger(ITrigger iTrigger);
    public short get_DaysInterval();
    public void set_DaysInterval(short value);
    public TimeSpan get_RandomDelay();
    public void set_RandomDelay(TimeSpan value);
    private sealed virtual override TimeSpan Microsoft.Win32.TaskScheduler.ITriggerDelay.get_Delay();
    private sealed virtual override void Microsoft.Win32.TaskScheduler.ITriggerDelay.set_Delay(TimeSpan value);
    public virtual void CopyProperties(Trigger sourceTrigger);
    public virtual bool Equals(Trigger other);
    private sealed virtual override XmlSchema System.Xml.Serialization.IXmlSerializable.GetSchema();
    private sealed virtual override void System.Xml.Serialization.IXmlSerializable.ReadXml(XmlReader reader);
    private sealed virtual override void System.Xml.Serialization.IXmlSerializable.WriteXml(XmlWriter writer);
    protected virtual string V2GetTriggerString();
    private void ReadMyXml(XmlReader reader);
    private void WriteMyXml(XmlWriter writer);
}
[FlagsAttribute]
public enum Microsoft.Win32.TaskScheduler.DaysOfTheWeek : Enum {
    public short value__;
    public static DaysOfTheWeek Sunday;
    public static DaysOfTheWeek Monday;
    public static DaysOfTheWeek Tuesday;
    public static DaysOfTheWeek Wednesday;
    public static DaysOfTheWeek Thursday;
    public static DaysOfTheWeek Friday;
    public static DaysOfTheWeek Saturday;
    public static DaysOfTheWeek AllDays;
}
internal static class Microsoft.Win32.TaskScheduler.DebugHelper : object {
    public static string GetDebugString(object inst);
}
internal class Microsoft.Win32.TaskScheduler.DefaultValueExAttribute : DefaultValueAttribute {
    public DefaultValueExAttribute(Type type, string value);
}
[XmlTypeAttribute]
[XmlRootAttribute("SendEmail")]
public class Microsoft.Win32.TaskScheduler.EmailAction : Action {
    private static string ImportanceHeader;
    private NamedValueCollection nvc;
    private bool validateAttachments;
    [XmlArrayAttribute("Attachments")]
[XmlArrayItemAttribute("File", "System.String")]
[DefaultValueAttribute("")]
public Object[] Attachments { get; public set; }
    [DefaultValueAttribute("")]
public string Bcc { get; public set; }
    [DefaultValueAttribute("")]
public string Body { get; public set; }
    [DefaultValueAttribute("")]
public string Cc { get; public set; }
    [DefaultValueAttribute("")]
public string From { get; public set; }
    [XmlArrayAttribute]
[XmlArrayItemAttribute("HeaderField", "Microsoft.Win32.TaskScheduler.NameValuePair")]
[NotNullAttribute]
public NamedValueCollection HeaderFields { get; }
    [XmlIgnoreAttribute]
[DefaultValueAttribute("System.Net.Mail.MailPriority", "Normal")]
public MailPriority Priority { get; public set; }
    [DefaultValueAttribute("")]
public string ReplyTo { get; public set; }
    [DefaultValueAttribute("")]
public string Server { get; public set; }
    [DefaultValueAttribute("")]
public string Subject { get; public set; }
    [DefaultValueAttribute("")]
public string To { get; public set; }
    internal TaskActionType InternalActionType { get; }
    public EmailAction(string subject, string from, string to, string body, string mailServer);
    internal EmailAction(ITask task);
    internal EmailAction(IAction action);
    public Object[] get_Attachments();
    public void set_Attachments(Object[] value);
    public string get_Bcc();
    public void set_Bcc(string value);
    public string get_Body();
    public void set_Body(string value);
    public string get_Cc();
    public void set_Cc(string value);
    public string get_From();
    public void set_From(string value);
    public NamedValueCollection get_HeaderFields();
    public MailPriority get_Priority();
    public void set_Priority(MailPriority value);
    public string get_ReplyTo();
    public void set_ReplyTo(string value);
    public string get_Server();
    public void set_Server(string value);
    public string get_Subject();
    public void set_Subject(string value);
    public string get_To();
    public void set_To(string value);
    internal virtual TaskActionType get_InternalActionType();
    public virtual bool Equals(Action other);
    public virtual string ToString();
    internal static Action FromPowerShellCommand(string p);
    internal virtual void Bind(ITaskDefinition iTaskDef);
    internal virtual void CopyProperties(Action sourceAction);
    internal virtual void CreateV2Action(IActionCollection iActions);
    internal virtual string GetPowerShellCommand();
    private static String[] FromPS(string p);
    private static string FromPS(Group g, string delimeter);
    private static string FromUTF8(string s);
    private static string Prep(string s);
    private static string ToPS(string input, Char[] delimeters);
    private static string ToPS(String[] input);
    private static string ToUTF8(string s);
    private static string UnPrep(string s);
    [CompilerGeneratedAttribute]
private void <get_HeaderFields>b__23_0(object o, NotifyCollectionChangedEventArgs e);
}
[XmlTypeAttribute]
public class Microsoft.Win32.TaskScheduler.EventTrigger : Trigger {
    private NamedValueCollection nvc;
    [DefaultValueAttribute("System.TimeSpan", "00:00:00")]
public TimeSpan Delay { get; public set; }
    [DefaultValueAttribute("")]
public string Subscription { get; public set; }
    [XmlArrayAttribute]
[XmlArrayItemAttribute("Value", "Microsoft.Win32.TaskScheduler.NameValuePair")]
public NamedValueCollection ValueQueries { get; }
    public EventTrigger(string log, string source, Nullable`1<int> eventId);
    internal EventTrigger(ITrigger iTrigger);
    public sealed virtual TimeSpan get_Delay();
    public sealed virtual void set_Delay(TimeSpan value);
    public string get_Subscription();
    public void set_Subscription(string value);
    public NamedValueCollection get_ValueQueries();
    public static string BuildQuery(string log, string source, Nullable`1<int> eventId);
    public virtual void CopyProperties(Trigger sourceTrigger);
    public virtual bool Equals(Trigger other);
    public bool GetBasic(String& log, String& source, Nullable`1& eventId);
    public void SetBasic(string log, string source, Nullable`1<int> eventId);
    internal virtual void Bind(ITaskDefinition iTaskDef);
    protected virtual string V2GetTriggerString();
}
[XmlRootAttribute("Exec")]
public class Microsoft.Win32.TaskScheduler.ExecAction : Action {
    internal static string PowerShellArgFormat;
    internal static string PowerShellPath;
    internal static string ScriptIdentifer;
    [DefaultValueAttribute("")]
public string Arguments { get; public set; }
    [XmlElementAttribute("Command")]
[DefaultValueAttribute("")]
public string Path { get; public set; }
    [DefaultValueAttribute("")]
public string WorkingDirectory { get; public set; }
    internal TaskActionType InternalActionType { get; }
    public ExecAction(string path, string arguments, string workingDirectory);
    internal ExecAction(ITask task);
    internal ExecAction(IAction action);
    public string get_Arguments();
    public void set_Arguments(string value);
    public string get_Path();
    public void set_Path(string value);
    public string get_WorkingDirectory();
    public void set_WorkingDirectory(string value);
    internal virtual TaskActionType get_InternalActionType();
    public static bool IsValidPath(string path, bool checkIfExists, bool throwOnException);
    public virtual bool Equals(Action other);
    public void SetValidatedPath(string path, bool checkIfExists);
    public virtual string ToString();
    internal static string BuildPowerShellCmd(string actionType, string cmd);
    internal static ExecAction ConvertToPowerShellAction(Action action);
    internal static ExecAction CreatePowerShellAction(string actionType, string cmd);
    internal static Action FromPowerShellCommand(string p);
    internal virtual void CopyProperties(Action sourceAction);
    internal virtual void CreateV2Action(IActionCollection iActions);
    internal virtual string GetPowerShellCommand();
    internal String[] ParsePowerShellItems();
}
public class Microsoft.Win32.TaskScheduler.Fluent.ActionBuilder : BaseBuilder {
    internal ActionBuilder(BuilderInfo taskBuilder, string path);
    public TriggerBuilder AtLogon();
    public TriggerBuilder AtLogonOf(string userId);
    public TriggerBuilder AtTaskRegistration();
    public IntervalTriggerBuilder Every(short num);
    public MonthlyTriggerBuilder InTheMonthOf(MonthsOfTheYear moy);
    public ActionBuilder InWorkingDirectory(string dir);
    public MonthlyDOWTriggerBuilder OnAll(DaysOfTheWeek dow);
    public TriggerBuilder OnBoot();
    public TriggerBuilder Once();
    public TriggerBuilder OnIdle();
    public TriggerBuilder OnStateChange(TaskSessionStateChangeType changeType);
    public ActionBuilder WithArguments(string args);
}
public abstract class Microsoft.Win32.TaskScheduler.Fluent.BaseBuilder : object {
    internal BuilderInfo tb;
    public SettingsBuilder When { get; }
    internal TaskDefinition TaskDef { get; }
    internal BaseBuilder(BuilderInfo taskBuilder);
    public SettingsBuilder get_When();
    internal TaskDefinition get_TaskDef();
    public Task AsTask(string name);
    public Task AsTask(string name, TaskCreation createType, string userId, string password, TaskLogonType logonType);
}
internal class Microsoft.Win32.TaskScheduler.Fluent.BuilderInfo : object {
    public TaskDefinition td;
    public TaskService ts;
    public BuilderInfo(TaskService taskSvc);
}
public class Microsoft.Win32.TaskScheduler.Fluent.IntervalTriggerBuilder : BaseBuilder {
    internal short interval;
    internal IntervalTriggerBuilder(BuilderInfo taskBuilder, short interval);
    public TriggerBuilder Days();
    public WeeklyTriggerBuilder Weeks();
}
public class Microsoft.Win32.TaskScheduler.Fluent.MonthlyDOWTriggerBuilder : BaseBuilder {
    private TriggerBuilder trb;
    internal MonthlyDOWTriggerBuilder(BuilderInfo taskBuilder, DaysOfTheWeek dow);
    public MonthlyDOWTriggerBuilder In(WhichWeek ww);
    public TriggerBuilder Of(MonthsOfTheYear moy);
}
public class Microsoft.Win32.TaskScheduler.Fluent.MonthlyTriggerBuilder : BaseBuilder {
    private TriggerBuilder trb;
    internal MonthlyTriggerBuilder(BuilderInfo taskBuilder, MonthsOfTheYear moy);
    public TriggerBuilder OnTheDays(Int32[] days);
}
public class Microsoft.Win32.TaskScheduler.Fluent.SettingsBuilder : BaseBuilder {
    internal SettingsBuilder(BuilderInfo taskBuilder);
    public SettingsBuilder AllowingStartIfOnBatteries();
    public SettingsBuilder AllowingStartOnRemoteAppSession();
    public SettingsBuilder DataIs(string data);
    public SettingsBuilder DeletingTaskAfter(TimeSpan duration);
    public SettingsBuilder DisallowingDemandStart();
    public SettingsBuilder DisallowingHardTerminate();
    public SettingsBuilder ExecutingAtMost(TimeSpan duration);
    public SettingsBuilder InstancesAre(TaskInstancesPolicy policy);
    public SettingsBuilder NotStoppingIfGoingOnBatteries();
    public SettingsBuilder OnlyIfIdle();
    public SettingsBuilder OnlyIfNetworkAvailable();
    public SettingsBuilder PriorityIs(ProcessPriorityClass priority);
    public SettingsBuilder RestartingEvery(TimeSpan interval);
    public SettingsBuilder StartingWhenAvailable();
    public SettingsBuilder WakingToRun();
}
public class Microsoft.Win32.TaskScheduler.Fluent.TriggerBuilder : BaseBuilder {
    internal Trigger trigger;
    internal TriggerBuilder(BuilderInfo taskBuilder);
    internal TriggerBuilder(BuilderInfo taskBuilder, DaysOfTheWeek dow);
    internal TriggerBuilder(BuilderInfo taskBuilder, MonthsOfTheYear moy);
    internal TriggerBuilder(BuilderInfo taskBuilder, TaskTriggerType taskTriggerType);
    public TriggerBuilder Ending(int year, int month, int day);
    public TriggerBuilder Ending(int year, int month, int day, int hour, int min, int sec);
    public TriggerBuilder Ending(string dt);
    public TriggerBuilder Ending(DateTime dt);
    public TriggerBuilder IsDisabled();
    public TriggerBuilder RepeatingEvery(TimeSpan span);
    public TriggerBuilder RepeatingEvery(string span);
    public TriggerBuilder RunningAtMostFor(TimeSpan span);
    public TriggerBuilder RunningAtMostFor(string span);
    public TriggerBuilder Starting(int year, int month, int day);
    public TriggerBuilder Starting(int year, int month, int day, int hour, int min, int sec);
    public TriggerBuilder Starting(string dt);
    public TriggerBuilder Starting(DateTime dt);
}
public class Microsoft.Win32.TaskScheduler.Fluent.WeeklyTriggerBuilder : TriggerBuilder {
    internal WeeklyTriggerBuilder(BuilderInfo taskBuilder, short interval);
    public TriggerBuilder On(DaysOfTheWeek dow);
}
internal interface Microsoft.Win32.TaskScheduler.IBindAsExecAction {
}
public interface Microsoft.Win32.TaskScheduler.ICalendarTrigger {
}
[PublicAPIAttribute]
public class Microsoft.Win32.TaskScheduler.IdleSettings : object {
    private IIdleSettings v2Settings;
    private ITask v1Task;
    [CompilerGeneratedAttribute]
private PropertyChangedEventHandler PropertyChanged;
    [DefaultValueAttribute("System.TimeSpan", "00:10:00")]
[XmlElementAttribute("Duration")]
public TimeSpan IdleDuration { get; public set; }
    [DefaultValueAttribute("False")]
public bool RestartOnIdle { get; public set; }
    [DefaultValueAttribute("True")]
public bool StopOnIdleEnd { get; public set; }
    [DefaultValueAttribute("System.TimeSpan", "01:00:00")]
public TimeSpan WaitTimeout { get; public set; }
    internal IdleSettings(IIdleSettings iSettings);
    internal IdleSettings(ITask iTask);
    [CompilerGeneratedAttribute]
public sealed virtual void add_PropertyChanged(PropertyChangedEventHandler value);
    [CompilerGeneratedAttribute]
public sealed virtual void remove_PropertyChanged(PropertyChangedEventHandler value);
    public TimeSpan get_IdleDuration();
    public void set_IdleDuration(TimeSpan value);
    public bool get_RestartOnIdle();
    public void set_RestartOnIdle(bool value);
    public bool get_StopOnIdleEnd();
    public void set_StopOnIdleEnd(bool value);
    public TimeSpan get_WaitTimeout();
    public void set_WaitTimeout(TimeSpan value);
    public sealed virtual void Dispose();
    public virtual string ToString();
    private void OnNotifyPropertyChanged(string propertyName);
}
public class Microsoft.Win32.TaskScheduler.IdleTrigger : Trigger {
    internal IdleTrigger(ITaskTrigger iTrigger);
    internal IdleTrigger(ITrigger iTrigger);
    protected virtual string V2GetTriggerString();
}
[GuidAttribute("839D7762-5121-4009-9234-4F0D19394F04")]
[InterfaceTypeAttribute("1")]
[SuppressUnmanagedCodeSecurityAttribute]
public interface Microsoft.Win32.TaskScheduler.ITaskHandler {
    public abstract virtual void Start(object pHandlerServices, string data);
    public abstract virtual void Stop(Int32& pRetCode);
    public abstract virtual void Pause();
    public abstract virtual void Resume();
}
[GuidAttribute("EAEC7A8F-27A0-4DDC-8675-14726A01A38A")]
[InterfaceTypeAttribute("1")]
[SuppressUnmanagedCodeSecurityAttribute]
public interface Microsoft.Win32.TaskScheduler.ITaskHandlerStatus {
    public abstract virtual void UpdateStatus(short percentComplete, string statusMessage);
    public abstract virtual void TaskCompleted(int taskErrCode);
}
public interface Microsoft.Win32.TaskScheduler.ITriggerDelay {
    public TimeSpan Delay { get; public set; }
    public abstract virtual TimeSpan get_Delay();
    public abstract virtual void set_Delay(TimeSpan value);
}
public interface Microsoft.Win32.TaskScheduler.ITriggerUserId {
    public string UserId { get; public set; }
    public abstract virtual string get_UserId();
    public abstract virtual void set_UserId(string value);
}
public class Microsoft.Win32.TaskScheduler.LogonTrigger : Trigger {
    [DefaultValueAttribute("System.TimeSpan", "00:00:00")]
[XmlIgnoreAttribute]
public TimeSpan Delay { get; public set; }
    [DefaultValueAttribute("")]
[XmlIgnoreAttribute]
public string UserId { get; public set; }
    internal LogonTrigger(ITaskTrigger iTrigger);
    internal LogonTrigger(ITrigger iTrigger);
    public sealed virtual TimeSpan get_Delay();
    public sealed virtual void set_Delay(TimeSpan value);
    public sealed virtual string get_UserId();
    public sealed virtual void set_UserId(string value);
    protected virtual string V2GetTriggerString();
}
[XmlTypeAttribute]
[PublicAPIAttribute]
public class Microsoft.Win32.TaskScheduler.MaintenanceSettings : object {
    private ITaskSettings3 iSettings;
    private IMaintenanceSettings iMaintSettings;
    [CompilerGeneratedAttribute]
private PropertyChangedEventHandler PropertyChanged;
    [DefaultValueAttribute("System.TimeSpan", "00:00:00")]
public TimeSpan Deadline { get; public set; }
    [DefaultValueAttribute("False")]
public bool Exclusive { get; public set; }
    [DefaultValueAttribute("System.TimeSpan", "00:00:00")]
public TimeSpan Period { get; public set; }
    internal MaintenanceSettings(ITaskSettings3 iSettings3);
    [CompilerGeneratedAttribute]
public sealed virtual void add_PropertyChanged(PropertyChangedEventHandler value);
    [CompilerGeneratedAttribute]
public sealed virtual void remove_PropertyChanged(PropertyChangedEventHandler value);
    public TimeSpan get_Deadline();
    public void set_Deadline(TimeSpan value);
    public bool get_Exclusive();
    public void set_Exclusive(bool value);
    public TimeSpan get_Period();
    public void set_Period(TimeSpan value);
    public sealed virtual void Dispose();
    public virtual string ToString();
    internal bool IsSet();
    private void OnNotifyPropertyChanged(string propertyName);
}
[XmlRootAttribute("CalendarTrigger")]
public class Microsoft.Win32.TaskScheduler.MonthlyDOWTrigger : Trigger {
    [DefaultValueAttribute("0")]
public DaysOfTheWeek DaysOfWeek { get; public set; }
    [DefaultValueAttribute("0")]
public MonthsOfTheYear MonthsOfYear { get; public set; }
    [DefaultValueAttribute("System.TimeSpan", "00:00:00")]
[XmlIgnoreAttribute]
public TimeSpan RandomDelay { get; public set; }
    [DefaultValueAttribute("False")]
[XmlIgnoreAttribute]
public bool RunOnLastWeekOfMonth { get; public set; }
    [DefaultValueAttribute("0")]
public WhichWeek WeeksOfMonth { get; public set; }
    private TimeSpan Microsoft.Win32.TaskScheduler.ITriggerDelay.Delay { get; private set; }
    public MonthlyDOWTrigger(DaysOfTheWeek daysOfWeek, MonthsOfTheYear monthsOfYear, WhichWeek weeksOfMonth);
    internal MonthlyDOWTrigger(ITaskTrigger iTrigger);
    internal MonthlyDOWTrigger(ITrigger iTrigger);
    public DaysOfTheWeek get_DaysOfWeek();
    public void set_DaysOfWeek(DaysOfTheWeek value);
    public MonthsOfTheYear get_MonthsOfYear();
    public void set_MonthsOfYear(MonthsOfTheYear value);
    public TimeSpan get_RandomDelay();
    public void set_RandomDelay(TimeSpan value);
    public bool get_RunOnLastWeekOfMonth();
    public void set_RunOnLastWeekOfMonth(bool value);
    public WhichWeek get_WeeksOfMonth();
    public void set_WeeksOfMonth(WhichWeek value);
    private sealed virtual override TimeSpan Microsoft.Win32.TaskScheduler.ITriggerDelay.get_Delay();
    private sealed virtual override void Microsoft.Win32.TaskScheduler.ITriggerDelay.set_Delay(TimeSpan value);
    public virtual void CopyProperties(Trigger sourceTrigger);
    public virtual bool Equals(Trigger other);
    private sealed virtual override XmlSchema System.Xml.Serialization.IXmlSerializable.GetSchema();
    private sealed virtual override void System.Xml.Serialization.IXmlSerializable.ReadXml(XmlReader reader);
    private sealed virtual override void System.Xml.Serialization.IXmlSerializable.WriteXml(XmlWriter writer);
    protected virtual string V2GetTriggerString();
    private void ReadMyXml(XmlReader reader);
    private void WriteMyXml(XmlWriter writer);
}
[XmlRootAttribute("CalendarTrigger")]
public class Microsoft.Win32.TaskScheduler.MonthlyTrigger : Trigger {
    public Int32[] DaysOfMonth { get; public set; }
    [DefaultValueAttribute("0")]
public MonthsOfTheYear MonthsOfYear { get; public set; }
    [DefaultValueAttribute("System.TimeSpan", "00:00:00")]
[XmlIgnoreAttribute]
public TimeSpan RandomDelay { get; public set; }
    [DefaultValueAttribute("False")]
[XmlIgnoreAttribute]
public bool RunOnLastDayOfMonth { get; public set; }
    private TimeSpan Microsoft.Win32.TaskScheduler.ITriggerDelay.Delay { get; private set; }
    public MonthlyTrigger(int dayOfMonth, MonthsOfTheYear monthsOfYear);
    internal MonthlyTrigger(ITaskTrigger iTrigger);
    internal MonthlyTrigger(ITrigger iTrigger);
    public Int32[] get_DaysOfMonth();
    public void set_DaysOfMonth(Int32[] value);
    public MonthsOfTheYear get_MonthsOfYear();
    public void set_MonthsOfYear(MonthsOfTheYear value);
    public TimeSpan get_RandomDelay();
    public void set_RandomDelay(TimeSpan value);
    public bool get_RunOnLastDayOfMonth();
    public void set_RunOnLastDayOfMonth(bool value);
    private sealed virtual override TimeSpan Microsoft.Win32.TaskScheduler.ITriggerDelay.get_Delay();
    private sealed virtual override void Microsoft.Win32.TaskScheduler.ITriggerDelay.set_Delay(TimeSpan value);
    public virtual void CopyProperties(Trigger sourceTrigger);
    public virtual bool Equals(Trigger other);
    private sealed virtual override XmlSchema System.Xml.Serialization.IXmlSerializable.GetSchema();
    private sealed virtual override void System.Xml.Serialization.IXmlSerializable.ReadXml(XmlReader reader);
    private sealed virtual override void System.Xml.Serialization.IXmlSerializable.WriteXml(XmlWriter writer);
    protected virtual string V2GetTriggerString();
    private static int IndicesToMask(Int32[] indices);
    private static bool ListsEqual(ICollection`1<T> left, ICollection`1<T> right);
    private static Int32[] MaskToIndices(int mask);
    private void ReadMyXml(XmlReader reader);
    private void WriteMyXml(XmlWriter writer);
}
[FlagsAttribute]
public enum Microsoft.Win32.TaskScheduler.MonthsOfTheYear : Enum {
    public short value__;
    public static MonthsOfTheYear January;
    public static MonthsOfTheYear February;
    public static MonthsOfTheYear March;
    public static MonthsOfTheYear April;
    public static MonthsOfTheYear May;
    public static MonthsOfTheYear June;
    public static MonthsOfTheYear July;
    public static MonthsOfTheYear August;
    public static MonthsOfTheYear September;
    public static MonthsOfTheYear October;
    public static MonthsOfTheYear November;
    public static MonthsOfTheYear December;
    public static MonthsOfTheYear AllMonths;
}
[DefaultMemberAttribute("Item")]
[PublicAPIAttribute]
public class Microsoft.Win32.TaskScheduler.NamedValueCollection : object {
    private ITaskNamedValueCollection v2Coll;
    private List`1<NameValuePair> unboundDict;
    [CompilerGeneratedAttribute]
private NotifyCollectionChangedEventHandler CollectionChanged;
    [CompilerGeneratedAttribute]
private PropertyChangedEventHandler PropertyChanged;
    [CompilerGeneratedAttribute]
private bool <AttributedXmlFormat>k__BackingField;
    [XmlIgnoreAttribute]
internal bool AttributedXmlFormat { get; internal set; }
    public int Count { get; }
    [ItemNotNullAttribute]
[NotNullAttribute]
public ICollection`1<string> Names { get; }
    [ItemNotNullAttribute]
[NotNullAttribute]
public ICollection`1<string> Values { get; }
    [NotNullAttribute]
public string Item { get; }
    public string Item { get; public set; }
    private bool System.Collections.Generic.ICollection<Microsoft.Win32.TaskScheduler.NameValuePair>.IsReadOnly { get; }
    private ICollection`1<string> System.Collections.Generic.IDictionary<System.String,System.String>.Keys { get; }
    private bool System.Collections.Generic.ICollection<System.Collections.Generic.KeyValuePair<System.String,System.String>>.IsReadOnly { get; }
    internal NamedValueCollection(ITaskNamedValueCollection iColl);
    [CompilerGeneratedAttribute]
public sealed virtual void add_CollectionChanged(NotifyCollectionChangedEventHandler value);
    [CompilerGeneratedAttribute]
public sealed virtual void remove_CollectionChanged(NotifyCollectionChangedEventHandler value);
    [CompilerGeneratedAttribute]
public sealed virtual void add_PropertyChanged(PropertyChangedEventHandler value);
    [CompilerGeneratedAttribute]
public sealed virtual void remove_PropertyChanged(PropertyChangedEventHandler value);
    [CompilerGeneratedAttribute]
internal bool get_AttributedXmlFormat();
    [CompilerGeneratedAttribute]
internal void set_AttributedXmlFormat(bool value);
    internal void Bind(ITaskNamedValueCollection iTaskNamedValueCollection);
    public void CopyTo(NamedValueCollection destCollection);
    public sealed virtual void Dispose();
    public sealed virtual int get_Count();
    public ICollection`1<string> get_Names();
    public sealed virtual ICollection`1<string> get_Values();
    public string get_Item(int index);
    [CanBeNullAttribute]
public sealed virtual string get_Item(string name);
    [NotNullAttribute]
public sealed virtual void set_Item(string name, string value);
    public sealed virtual void Add(NameValuePair item);
    public sealed virtual void Add(string name, string value);
    public void AddRange(IEnumerable`1<NameValuePair> items);
    public sealed virtual void Clear();
    public sealed virtual IEnumerator`1<NameValuePair> GetEnumerator();
    private void OnCollectionChanged(NotifyCollectionChangedEventArgs e);
    public sealed virtual bool Remove(string name);
    public void RemoveAt(int index);
    public sealed virtual bool TryGetValue(string name, String& value);
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
    private sealed virtual override bool System.Collections.Generic.ICollection<Microsoft.Win32.TaskScheduler.NameValuePair>.Contains(NameValuePair item);
    private sealed virtual override void System.Collections.Generic.ICollection<Microsoft.Win32.TaskScheduler.NameValuePair>.CopyTo(NameValuePair[] array, int arrayIndex);
    private sealed virtual override bool System.Collections.Generic.ICollection<Microsoft.Win32.TaskScheduler.NameValuePair>.get_IsReadOnly();
    private sealed virtual override ICollection`1<string> System.Collections.Generic.IDictionary<System.String,System.String>.get_Keys();
    private sealed virtual override bool System.Collections.Generic.ICollection<System.Collections.Generic.KeyValuePair<System.String,System.String>>.get_IsReadOnly();
    private sealed virtual override bool System.Collections.Generic.ICollection<Microsoft.Win32.TaskScheduler.NameValuePair>.Remove(NameValuePair item);
    private sealed virtual override bool System.Collections.Generic.IDictionary<System.String,System.String>.ContainsKey(string key);
    private sealed virtual override void System.Collections.Generic.ICollection<System.Collections.Generic.KeyValuePair<System.String,System.String>>.Add(KeyValuePair`2<string, string> item);
    private sealed virtual override bool System.Collections.Generic.ICollection<System.Collections.Generic.KeyValuePair<System.String,System.String>>.Contains(KeyValuePair`2<string, string> item);
    private sealed virtual override void System.Collections.Generic.ICollection<System.Collections.Generic.KeyValuePair<System.String,System.String>>.CopyTo(KeyValuePair`2[] array, int arrayIndex);
    private sealed virtual override bool System.Collections.Generic.ICollection<System.Collections.Generic.KeyValuePair<System.String,System.String>>.Remove(KeyValuePair`2<string, string> item);
    [IteratorStateMachineAttribute("Microsoft.Win32.TaskScheduler.NamedValueCollection/<System-Collections-Generic-IEnumerable<System-Collections-Generic-KeyValuePair<System-String,System-String>>-GetEnumerator>d__52")]
private sealed virtual override IEnumerator`1<KeyValuePair`2<string, string>> System.Collections.Generic.IEnumerable<System.Collections.Generic.KeyValuePair<System.String,System.String>>.GetEnumerator();
    [CompilerGeneratedAttribute]
private int <GetEnumerator>b__32_0();
    [CompilerGeneratedAttribute]
private ITaskNamedValuePair <GetEnumerator>b__32_1(int i);
}
[PublicAPIAttribute]
public class Microsoft.Win32.TaskScheduler.NameValuePair : object {
    private ITaskNamedValuePair v2Pair;
    private string name;
    private string value;
    [CompilerGeneratedAttribute]
private PropertyChangedEventHandler PropertyChanged;
    [CompilerGeneratedAttribute]
private bool <AttributedXmlFormat>k__BackingField;
    [XmlIgnoreAttribute]
internal bool AttributedXmlFormat { get; internal set; }
    [NotNullAttribute]
public string Name { get; public set; }
    [NotNullAttribute]
public string Value { get; public set; }
    internal NameValuePair(ITaskNamedValuePair iPair);
    internal NameValuePair(string name, string value);
    [CompilerGeneratedAttribute]
public sealed virtual void add_PropertyChanged(PropertyChangedEventHandler value);
    [CompilerGeneratedAttribute]
public sealed virtual void remove_PropertyChanged(PropertyChangedEventHandler value);
    [CompilerGeneratedAttribute]
internal bool get_AttributedXmlFormat();
    [CompilerGeneratedAttribute]
internal void set_AttributedXmlFormat(bool value);
    public string get_Name();
    public void set_Name(string value);
    public string get_Value();
    public void set_Value(string value);
    [NotNullAttribute]
public NameValuePair Clone();
    private sealed virtual override object System.ICloneable.Clone();
    public virtual bool Equals(object obj);
    public sealed virtual bool Equals(NameValuePair other);
    private sealed virtual override bool System.IEquatable<Microsoft.Win32.TaskScheduler.V2Interop.ITaskNamedValuePair>.Equals(ITaskNamedValuePair other);
    public virtual int GetHashCode();
    public virtual string ToString();
    public static NameValuePair op_Implicit(KeyValuePair`2<string, string> kvp);
    private sealed virtual override XmlSchema System.Xml.Serialization.IXmlSerializable.GetSchema();
    private sealed virtual override void System.Xml.Serialization.IXmlSerializable.ReadXml(XmlReader reader);
    private sealed virtual override void System.Xml.Serialization.IXmlSerializable.WriteXml(XmlWriter writer);
}
[XmlTypeAttribute]
[PublicAPIAttribute]
public class Microsoft.Win32.TaskScheduler.NetworkSettings : object {
    private INetworkSettings v2Settings;
    [CompilerGeneratedAttribute]
private PropertyChangedEventHandler PropertyChanged;
    [DefaultValueAttribute("System.Guid", "00000000-0000-0000-0000-000000000000")]
public Guid Id { get; public set; }
    [DefaultValueAttribute("")]
public string Name { get; public set; }
    internal NetworkSettings(INetworkSettings iSettings);
    [CompilerGeneratedAttribute]
public sealed virtual void add_PropertyChanged(PropertyChangedEventHandler value);
    [CompilerGeneratedAttribute]
public sealed virtual void remove_PropertyChanged(PropertyChangedEventHandler value);
    public Guid get_Id();
    public void set_Id(Guid value);
    public string get_Name();
    public void set_Name(string value);
    public sealed virtual void Dispose();
    public virtual string ToString();
    internal bool IsSet();
    private void OnNotifyPropertyChanged(string propertyName);
}
[DebuggerStepThroughAttribute]
public class Microsoft.Win32.TaskScheduler.NotSupportedPriorToException : TSNotSupportedException {
    internal string LibName { get; }
    protected NotSupportedPriorToException(SerializationInfo serializationInfo, StreamingContext streamingContext);
    internal NotSupportedPriorToException(TaskCompatibility supportedVersion);
    internal virtual string get_LibName();
}
[DebuggerStepThroughAttribute]
public class Microsoft.Win32.TaskScheduler.NotV1SupportedException : TSNotSupportedException {
    internal string LibName { get; }
    protected NotV1SupportedException(SerializationInfo serializationInfo, StreamingContext streamingContext);
    public NotV1SupportedException(string message);
    internal virtual string get_LibName();
}
[DebuggerStepThroughAttribute]
public class Microsoft.Win32.TaskScheduler.NotV2SupportedException : TSNotSupportedException {
    internal string LibName { get; }
    protected NotV2SupportedException(SerializationInfo serializationInfo, StreamingContext streamingContext);
    internal NotV2SupportedException(string message);
    internal virtual string get_LibName();
}
[FlagsAttribute]
public enum Microsoft.Win32.TaskScheduler.PowerShellActionPlatformOption : Enum {
    public int value__;
    public static PowerShellActionPlatformOption Never;
    public static PowerShellActionPlatformOption Version1;
    public static PowerShellActionPlatformOption Version2;
    public static PowerShellActionPlatformOption All;
}
[GeneratedCodeAttribute("System.Resources.Tools.StronglyTypedResourceBuilder", "17.0.0.0")]
[DebuggerNonUserCodeAttribute]
[CompilerGeneratedAttribute]
internal class Microsoft.Win32.TaskScheduler.Properties.Resources : object {
    private static ResourceManager resourceMan;
    private static CultureInfo resourceCulture;
    [EditorBrowsableAttribute("2")]
internal static ResourceManager ResourceManager { get; }
    [EditorBrowsableAttribute("2")]
internal static CultureInfo Culture { get; internal set; }
    internal static string ActionTypeComHandler { get; }
    internal static string ActionTypeExecute { get; }
    internal static string ActionTypeSendEmail { get; }
    internal static string ActionTypeShowMessage { get; }
    internal static string ComHandlerAction { get; }
    internal static string DOWAllDays { get; }
    internal static string EmailAction { get; }
    internal static string EndSentence { get; }
    internal static string Error_TriggerEndBeforeStart { get; }
    internal static string ExecAction { get; }
    internal static string HyphenSeparator { get; }
    internal static string ListSeparator { get; }
    internal static string MOYAllMonths { get; }
    internal static string MultipleActions { get; }
    internal static string MultipleTriggers { get; }
    internal static string ShowMessageAction { get; }
    internal static string TaskDefaultPrincipal { get; }
    internal static string TaskStateDisabled { get; }
    internal static string TaskStateQueued { get; }
    internal static string TaskStateReady { get; }
    internal static string TaskStateRunning { get; }
    internal static string TaskStateUnknown { get; }
    internal static string TriggerAnyUser { get; }
    internal static string TriggerBoot1 { get; }
    internal static string TriggerCustom1 { get; }
    internal static string TriggerDaily1 { get; }
    internal static string TriggerDaily2 { get; }
    internal static string TriggerDuration0 { get; }
    internal static string TriggerDurationNot0 { get; }
    internal static string TriggerDurationNot0Short { get; }
    internal static string TriggerEndBoundary { get; }
    internal static string TriggerEvent1 { get; }
    internal static string TriggerEventBasic1 { get; }
    internal static string TriggerEventBasic2 { get; }
    internal static string TriggerEventBasic3 { get; }
    internal static string TriggerIdle1 { get; }
    internal static string TriggerLogon1 { get; }
    internal static string TriggerMonthly1 { get; }
    internal static string TriggerMonthlyDOW1 { get; }
    internal static string TriggerRegistration1 { get; }
    internal static string TriggerRepetition { get; }
    internal static string TriggerRepetitionShort { get; }
    internal static string TriggerSessionConsoleConnect { get; }
    internal static string TriggerSessionConsoleDisconnect { get; }
    internal static string TriggerSessionRemoteConnect { get; }
    internal static string TriggerSessionRemoteDisconnect { get; }
    internal static string TriggerSessionSessionLock { get; }
    internal static string TriggerSessionSessionUnlock { get; }
    internal static string TriggerSessionUserSession { get; }
    internal static string TriggerTime1 { get; }
    internal static string TriggerTypeBoot { get; }
    internal static string TriggerTypeCustom { get; }
    internal static string TriggerTypeDaily { get; }
    internal static string TriggerTypeEvent { get; }
    internal static string TriggerTypeIdle { get; }
    internal static string TriggerTypeLogon { get; }
    internal static string TriggerTypeMonthly { get; }
    internal static string TriggerTypeMonthlyDOW { get; }
    internal static string TriggerTypeRegistration { get; }
    internal static string TriggerTypeSessionStateChange { get; }
    internal static string TriggerTypeTime { get; }
    internal static string TriggerTypeWeekly { get; }
    internal static string TriggerWeekly1Week { get; }
    internal static string TriggerWeeklyMultWeeks { get; }
    internal static string WWAllWeeks { get; }
    internal static string WWFifthWeek { get; }
    internal static string WWFirstWeek { get; }
    internal static string WWFourthWeek { get; }
    internal static string WWLastWeek { get; }
    internal static string WWSecondWeek { get; }
    internal static string WWThirdWeek { get; }
    internal static ResourceManager get_ResourceManager();
    internal static CultureInfo get_Culture();
    internal static void set_Culture(CultureInfo value);
    internal static string get_ActionTypeComHandler();
    internal static string get_ActionTypeExecute();
    internal static string get_ActionTypeSendEmail();
    internal static string get_ActionTypeShowMessage();
    internal static string get_ComHandlerAction();
    internal static string get_DOWAllDays();
    internal static string get_EmailAction();
    internal static string get_EndSentence();
    internal static string get_Error_TriggerEndBeforeStart();
    internal static string get_ExecAction();
    internal static string get_HyphenSeparator();
    internal static string get_ListSeparator();
    internal static string get_MOYAllMonths();
    internal static string get_MultipleActions();
    internal static string get_MultipleTriggers();
    internal static string get_ShowMessageAction();
    internal static string get_TaskDefaultPrincipal();
    internal static string get_TaskStateDisabled();
    internal static string get_TaskStateQueued();
    internal static string get_TaskStateReady();
    internal static string get_TaskStateRunning();
    internal static string get_TaskStateUnknown();
    internal static string get_TriggerAnyUser();
    internal static string get_TriggerBoot1();
    internal static string get_TriggerCustom1();
    internal static string get_TriggerDaily1();
    internal static string get_TriggerDaily2();
    internal static string get_TriggerDuration0();
    internal static string get_TriggerDurationNot0();
    internal static string get_TriggerDurationNot0Short();
    internal static string get_TriggerEndBoundary();
    internal static string get_TriggerEvent1();
    internal static string get_TriggerEventBasic1();
    internal static string get_TriggerEventBasic2();
    internal static string get_TriggerEventBasic3();
    internal static string get_TriggerIdle1();
    internal static string get_TriggerLogon1();
    internal static string get_TriggerMonthly1();
    internal static string get_TriggerMonthlyDOW1();
    internal static string get_TriggerRegistration1();
    internal static string get_TriggerRepetition();
    internal static string get_TriggerRepetitionShort();
    internal static string get_TriggerSessionConsoleConnect();
    internal static string get_TriggerSessionConsoleDisconnect();
    internal static string get_TriggerSessionRemoteConnect();
    internal static string get_TriggerSessionRemoteDisconnect();
    internal static string get_TriggerSessionSessionLock();
    internal static string get_TriggerSessionSessionUnlock();
    internal static string get_TriggerSessionUserSession();
    internal static string get_TriggerTime1();
    internal static string get_TriggerTypeBoot();
    internal static string get_TriggerTypeCustom();
    internal static string get_TriggerTypeDaily();
    internal static string get_TriggerTypeEvent();
    internal static string get_TriggerTypeIdle();
    internal static string get_TriggerTypeLogon();
    internal static string get_TriggerTypeMonthly();
    internal static string get_TriggerTypeMonthlyDOW();
    internal static string get_TriggerTypeRegistration();
    internal static string get_TriggerTypeSessionStateChange();
    internal static string get_TriggerTypeTime();
    internal static string get_TriggerTypeWeekly();
    internal static string get_TriggerWeekly1Week();
    internal static string get_TriggerWeeklyMultWeeks();
    internal static string get_WWAllWeeks();
    internal static string get_WWFifthWeek();
    internal static string get_WWFirstWeek();
    internal static string get_WWFourthWeek();
    internal static string get_WWLastWeek();
    internal static string get_WWSecondWeek();
    internal static string get_WWThirdWeek();
}
public enum Microsoft.Win32.TaskScheduler.QuickTriggerType : Enum {
    public int value__;
    public static QuickTriggerType Boot;
    public static QuickTriggerType Idle;
    public static QuickTriggerType Logon;
    public static QuickTriggerType TaskRegistration;
    public static QuickTriggerType Hourly;
    public static QuickTriggerType Daily;
    public static QuickTriggerType Weekly;
    public static QuickTriggerType Monthly;
}
[XmlTypeAttribute]
public class Microsoft.Win32.TaskScheduler.RegistrationTrigger : Trigger {
    [DefaultValueAttribute("System.TimeSpan", "00:00:00")]
[XmlIgnoreAttribute]
public TimeSpan Delay { get; public set; }
    internal RegistrationTrigger(ITrigger iTrigger);
    public sealed virtual TimeSpan get_Delay();
    public sealed virtual void set_Delay(TimeSpan value);
    protected virtual string V2GetTriggerString();
}
[XmlRootAttribute("Repetition")]
[TypeConverterAttribute("Microsoft.Win32.TaskScheduler.RepetitionPatternConverter")]
public class Microsoft.Win32.TaskScheduler.RepetitionPattern : object {
    private Trigger pTrigger;
    private IRepetitionPattern v2Pattern;
    private TimeSpan unboundInterval;
    private TimeSpan unboundDuration;
    private bool unboundStopAtDurationEnd;
    [CompilerGeneratedAttribute]
private PropertyChangedEventHandler PropertyChanged;
    [DefaultValueAttribute("System.TimeSpan", "00:00:00")]
public TimeSpan Duration { get; public set; }
    [DefaultValueAttribute("System.TimeSpan", "00:00:00")]
public TimeSpan Interval { get; public set; }
    [DefaultValueAttribute("False")]
public bool StopAtDurationEnd { get; public set; }
    public RepetitionPattern(TimeSpan interval, TimeSpan duration, bool stopAtDurationEnd);
    internal RepetitionPattern(Trigger parent);
    [CompilerGeneratedAttribute]
public sealed virtual void add_PropertyChanged(PropertyChangedEventHandler value);
    [CompilerGeneratedAttribute]
public sealed virtual void remove_PropertyChanged(PropertyChangedEventHandler value);
    public TimeSpan get_Duration();
    public void set_Duration(TimeSpan value);
    public TimeSpan get_Interval();
    public void set_Interval(TimeSpan value);
    public bool get_StopAtDurationEnd();
    public void set_StopAtDurationEnd(bool value);
    public sealed virtual void Dispose();
    public virtual bool Equals(object obj);
    public sealed virtual bool Equals(RepetitionPattern other);
    public virtual int GetHashCode();
    public bool IsSet();
    private sealed virtual override XmlSchema System.Xml.Serialization.IXmlSerializable.GetSchema();
    private sealed virtual override void System.Xml.Serialization.IXmlSerializable.ReadXml(XmlReader reader);
    private sealed virtual override void System.Xml.Serialization.IXmlSerializable.WriteXml(XmlWriter writer);
    internal void Bind();
    internal void Set(RepetitionPattern value);
    private void OnNotifyPropertyChanged(string propertyName);
    private bool ReadXmlConverter(PropertyInfo pi, object obj, Object& value);
}
internal class Microsoft.Win32.TaskScheduler.RepetitionPatternConverter : TypeConverter {
    public virtual bool CanConvertTo(ITypeDescriptorContext context, Type destinationType);
    public virtual object ConvertTo(ITypeDescriptorContext context, CultureInfo culture, object value, Type destinationType);
}
[PublicAPIAttribute]
public class Microsoft.Win32.TaskScheduler.ResourceReferenceValue : object {
    [CompilerGeneratedAttribute]
private string <ResourceFilePath>k__BackingField;
    [CompilerGeneratedAttribute]
private int <ResourceIdentifier>k__BackingField;
    public string ResourceFilePath { get; public set; }
    public int ResourceIdentifier { get; public set; }
    public ResourceReferenceValue(string dllPath, int resourceId);
    [CompilerGeneratedAttribute]
public string get_ResourceFilePath();
    [CompilerGeneratedAttribute]
public void set_ResourceFilePath(string value);
    [CompilerGeneratedAttribute]
public int get_ResourceIdentifier();
    [CompilerGeneratedAttribute]
public void set_ResourceIdentifier(int value);
    public static string op_Implicit(ResourceReferenceValue value);
    [NotNullAttribute]
public static ResourceReferenceValue Parse(string value);
    public static bool TryParse(string value, ResourceReferenceValue& resourceRef);
    [NotNullAttribute]
public string GetResolvedString();
    public virtual string ToString();
    private static int LoadString(IntPtr hInstance, int wID, StringBuilder lpBuffer, int nBufferMax);
}
[XmlTypeAttribute]
[PublicAPIAttribute]
public class Microsoft.Win32.TaskScheduler.RunningTask : Task {
    private IRunningTask v2RunningTask;
    public UInt32 EnginePID { get; }
    public string CurrentAction { get; }
    public Guid InstanceGuid { get; }
    public TaskState State { get; }
    internal RunningTask(TaskService svc, IRegisteredTask iTask, IRunningTask iRunningTask);
    internal RunningTask(TaskService svc, ITask iTask);
    public UInt32 get_EnginePID();
    public string get_CurrentAction();
    public Guid get_InstanceGuid();
    public virtual TaskState get_State();
    public void Dispose();
    public void Refresh();
}
[DefaultMemberAttribute("Item")]
public class Microsoft.Win32.TaskScheduler.RunningTaskCollection : object {
    private TaskService svc;
    private IRunningTaskCollection v2Coll;
    public int Count { get; }
    public RunningTask Item { get; }
    internal RunningTaskCollection(TaskService svc);
    internal RunningTaskCollection(TaskService svc, IRunningTaskCollection iTaskColl);
    public sealed virtual int get_Count();
    public sealed virtual RunningTask get_Item(int index);
    public sealed virtual void Dispose();
    public sealed virtual IEnumerator`1<RunningTask> GetEnumerator();
    public virtual string ToString();
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
    [CompilerGeneratedAttribute]
private int <GetEnumerator>b__9_0();
    [CompilerGeneratedAttribute]
private IRunningTask <GetEnumerator>b__9_1(object o);
    [CompilerGeneratedAttribute]
private RunningTask <GetEnumerator>b__9_2(IRunningTask o);
}
[XmlTypeAttribute]
public class Microsoft.Win32.TaskScheduler.SessionStateChangeTrigger : Trigger {
    [DefaultValueAttribute("System.TimeSpan", "00:00:00")]
public TimeSpan Delay { get; public set; }
    [DefaultValueAttribute("1")]
public TaskSessionStateChangeType StateChange { get; public set; }
    [DefaultValueAttribute("")]
public string UserId { get; public set; }
    public SessionStateChangeTrigger(TaskSessionStateChangeType stateChange, string userId);
    internal SessionStateChangeTrigger(ITrigger iTrigger);
    public sealed virtual TimeSpan get_Delay();
    public sealed virtual void set_Delay(TimeSpan value);
    public TaskSessionStateChangeType get_StateChange();
    public void set_StateChange(TaskSessionStateChangeType value);
    public sealed virtual string get_UserId();
    public sealed virtual void set_UserId(string value);
    public virtual void CopyProperties(Trigger sourceTrigger);
    public virtual bool Equals(Trigger other);
    protected virtual string V2GetTriggerString();
    private bool StateChangeIsSet();
}
[XmlTypeAttribute]
[XmlRootAttribute("ShowMessage")]
public class Microsoft.Win32.TaskScheduler.ShowMessageAction : Action {
    [XmlElementAttribute("Body")]
[DefaultValueAttribute("")]
public string MessageBody { get; public set; }
    [DefaultValueAttribute("")]
public string Title { get; public set; }
    internal TaskActionType InternalActionType { get; }
    public ShowMessageAction(string messageBody, string title);
    internal ShowMessageAction(ITask task);
    internal ShowMessageAction(IAction action);
    public string get_MessageBody();
    public void set_MessageBody(string value);
    public string get_Title();
    public void set_Title(string value);
    internal virtual TaskActionType get_InternalActionType();
    public virtual bool Equals(Action other);
    public virtual string ToString();
    internal static Action FromPowerShellCommand(string p);
    internal virtual void CopyProperties(Action sourceAction);
    internal virtual void CreateV2Action(IActionCollection iActions);
    internal virtual string GetPowerShellCommand();
}
public abstract class Microsoft.Win32.TaskScheduler.SnapshotItem : object {
    [CompilerGeneratedAttribute]
private string <Path>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Sddl>k__BackingField;
    public string Path { get; private set; }
    public string Sddl { get; private set; }
    internal SnapshotItem(string path, string sddl);
    [CompilerGeneratedAttribute]
public string get_Path();
    [CompilerGeneratedAttribute]
private void set_Path(string value);
    [CompilerGeneratedAttribute]
public string get_Sddl();
    [CompilerGeneratedAttribute]
private void set_Sddl(string value);
}
public enum Microsoft.Win32.TaskScheduler.StandardTaskEventId : Enum {
    public int value__;
    public static StandardTaskEventId JobStart;
    public static StandardTaskEventId JobStartFailed;
    public static StandardTaskEventId JobSuccess;
    public static StandardTaskEventId JobFailure;
    public static StandardTaskEventId LogonFailure;
    public static StandardTaskEventId ImpersonationFailure;
    public static StandardTaskEventId JobRegistered;
    public static StandardTaskEventId TimeTrigger;
    public static StandardTaskEventId EventTrigger;
    public static StandardTaskEventId ImmediateTrigger;
    public static StandardTaskEventId Run;
    public static StandardTaskEventId JobTermination;
    public static StandardTaskEventId JobNoStartWithoutNetwork;
    public static StandardTaskEventId TaskRegisteredWithoutSomeTriggers;
    public static StandardTaskEventId MissedTaskLaunched;
    public static StandardTaskEventId TransactionRollbackFailure;
    public static StandardTaskEventId TaskRegisteredWithoutCredentials;
    public static StandardTaskEventId IdleTrigger;
    public static StandardTaskEventId BootTrigger;
    public static StandardTaskEventId LogonTrigger;
    public static StandardTaskEventId ConsoleConnectTrigger;
    public static StandardTaskEventId ConsoleDisconnectTrigger;
    public static StandardTaskEventId RemoteConnectTrigger;
    public static StandardTaskEventId RemoteDisconnectTrigger;
    public static StandardTaskEventId SessionLockTrigger;
    public static StandardTaskEventId SessionUnlockTrigger;
    public static StandardTaskEventId FailedTaskRestart;
    public static StandardTaskEventId RejectedTaskRestart;
    public static StandardTaskEventId IgnoredTaskStart;
    public static StandardTaskEventId CreatedTaskProcess;
    public static StandardTaskEventId TaskNotRunServiceBusy;
    public static StandardTaskEventId TaskNotStartedTaskQueueQuotaExceeded;
    public static StandardTaskEventId TaskQueueQuotaApproaching;
    public static StandardTaskEventId TaskNotStartedEngineQuotaExceeded;
    public static StandardTaskEventId EngineQuotaApproaching;
    public static StandardTaskEventId NotStartedWithoutIdle;
    public static StandardTaskEventId TaskUpdated;
    public static StandardTaskEventId TaskDeleted;
    public static StandardTaskEventId TaskDisabled;
    public static StandardTaskEventId TaskStartedOnComputerWakeup;
    public static StandardTaskEventId TaskEventSubscriptionFailed;
    public static StandardTaskEventId ActionStart;
    public static StandardTaskEventId ActionSuccess;
    public static StandardTaskEventId ActionFailure;
    public static StandardTaskEventId ActionLaunchFailure;
    public static StandardTaskEventId EventRenderFailed;
    public static StandardTaskEventId EventAggregateFailed;
    public static StandardTaskEventId SessionExit;
    public static StandardTaskEventId SessionError;
    public static StandardTaskEventId SessionSentJob;
    public static StandardTaskEventId SessionSentJobFailed;
    public static StandardTaskEventId SessionFailedToProcessMessage;
    public static StandardTaskEventId SessionManagerConnectFailed;
    public static StandardTaskEventId SessionConnected;
    public static StandardTaskEventId SessionJobsOrphaned;
    public static StandardTaskEventId SessionProcessStarted;
    public static StandardTaskEventId SessionProcessLaunchFailed;
    public static StandardTaskEventId SessionWin32ObjectCreated;
    public static StandardTaskEventId SessionChannelReady;
    public static StandardTaskEventId SessionIdle;
    public static StandardTaskEventId SessionProcessConnectFailed;
    public static StandardTaskEventId SessionMessageSendFailed;
    public static StandardTaskEventId SessionProcessMainStarted;
    public static StandardTaskEventId SessionProcessMainShutdown;
    public static StandardTaskEventId SessionProcessReceivedStartJob;
    public static StandardTaskEventId SessionProcessReceivedStopJob;
    public static StandardTaskEventId NewInstanceIgnored;
    public static StandardTaskEventId RunningInstanceStopped;
    public static StandardTaskEventId NewInstanceQueued;
    public static StandardTaskEventId InstanceQueued;
    public static StandardTaskEventId NoStartOnBatteries;
    public static StandardTaskEventId StoppingOnBatteries;
    public static StandardTaskEventId StoppingOffIdle;
    public static StandardTaskEventId StoppingOnTimeout;
    public static StandardTaskEventId StoppingOnRequest;
    public static StandardTaskEventId TimeoutWontWork;
    public static StandardTaskEventId NoStartUserNotLoggedOn;
    public static StandardTaskEventId ScheduleServiceStart;
    public static StandardTaskEventId ScheduleServiceStartFailed;
    public static StandardTaskEventId ScheduleServiceStop;
    public static StandardTaskEventId ScheduleServiceError;
    public static StandardTaskEventId ScheduleServiceRpcInitError;
    public static StandardTaskEventId ScheduleServiceComInitError;
    public static StandardTaskEventId ScheduleServiceCredStoreInitError;
    public static StandardTaskEventId ScheduleServiceLsaInitError;
    public static StandardTaskEventId ScheduleServiceIdleServiceInitError;
    public static StandardTaskEventId ScheduleServiceTimeChangeInitError;
    public static StandardTaskEventId ScheduleServiceTimeChangeSignaled;
    public static StandardTaskEventId ScheduleServiceRunBootJobsFailed;
    public static StandardTaskEventId CompatStart;
    public static StandardTaskEventId CompatStartFailed;
    public static StandardTaskEventId CompatStartRpcFailed;
    public static StandardTaskEventId CompatStartNetscheduleFailed;
    public static StandardTaskEventId CompatStartLsaFailed;
    public static StandardTaskEventId CompatDirectoryMonitorFailed;
    public static StandardTaskEventId CompatTaskStatusUpdateFailed;
    public static StandardTaskEventId CompatTaskDeleteFailed;
    public static StandardTaskEventId CompatTaskSetSdFailed;
    public static StandardTaskEventId CompatTaskUpdateFailed;
    public static StandardTaskEventId CompatUpgradeStartFailed;
    public static StandardTaskEventId CompatUpgradeNsAccountFailed;
    public static StandardTaskEventId CompatUpgradeStoreEnumFailed;
    public static StandardTaskEventId CompatUpgradeTaskLoadFailed;
    public static StandardTaskEventId CompatUpgradeTaskRegistrationFailed;
    public static StandardTaskEventId CompatUpgradeLsaCleanupFailed;
    public static StandardTaskEventId CompatUpgradeFailed;
    public static StandardTaskEventId CompatUpgradeNeedNotDetermined;
    public static StandardTaskEventId VistaBeta2CredstoreUpgradeFailed;
    public static StandardTaskEventId Unknown;
}
[XmlTypeAttribute]
[PublicAPIAttribute]
public class Microsoft.Win32.TaskScheduler.Task : object {
    internal static AccessControlSections defaultAccessControlSections;
    internal static SecurityInfos defaultSecurityInfosSections;
    internal ITask v1Task;
    private static int osLibMinorVer;
    private static DateTime v2InvalidDate;
    private IRegisteredTask v2Task;
    private TaskDefinition myTD;
    [CompilerGeneratedAttribute]
private PropertyChangedEventHandler PropertyChanged;
    [CompilerGeneratedAttribute]
private bool <ReadOnly>k__BackingField;
    [CompilerGeneratedAttribute]
private TaskService <TaskService>k__BackingField;
    [NotNullAttribute]
public TaskDefinition Definition { get; }
    public bool Enabled { get; public set; }
    [NotNullAttribute]
public TaskFolder Folder { get; }
    public bool IsActive { get; }
    public DateTime LastRunTime { get; }
    public int LastTaskResult { get; }
    public DateTime NextRunTime { get; }
    public bool ReadOnly { get; internal set; }
    [ObsoleteAttribute("This property will be removed in deference to the GetAccessControl, GetSecurityDescriptorSddlForm, SetAccessControl and SetSecurityDescriptorSddlForm methods.")]
public GenericSecurityDescriptor SecurityDescriptor { get; public set; }
    public TaskState State { get; }
    public TaskService TaskService { get; }
    [NotNullAttribute]
public string Name { get; }
    public int NumberOfMissedRuns { get; }
    [NotNullAttribute]
public string Path { get; }
    public string Xml { get; }
    internal Task(TaskService svc, ITask iTask);
    internal Task(TaskService svc, IRegisteredTask iTask, ITaskDefinition iDef);
    private static Task();
    [CompilerGeneratedAttribute]
public sealed virtual void add_PropertyChanged(PropertyChangedEventHandler value);
    [CompilerGeneratedAttribute]
public sealed virtual void remove_PropertyChanged(PropertyChangedEventHandler value);
    public TaskDefinition get_Definition();
    public bool get_Enabled();
    public void set_Enabled(bool value);
    public TaskFolder get_Folder();
    public bool get_IsActive();
    public DateTime get_LastRunTime();
    public int get_LastTaskResult();
    public DateTime get_NextRunTime();
    [CompilerGeneratedAttribute]
public bool get_ReadOnly();
    [CompilerGeneratedAttribute]
internal void set_ReadOnly(bool value);
    public GenericSecurityDescriptor get_SecurityDescriptor();
    public void set_SecurityDescriptor(GenericSecurityDescriptor value);
    public virtual TaskState get_State();
    [CompilerGeneratedAttribute]
public TaskService get_TaskService();
    public string get_Name();
    public int get_NumberOfMissedRuns();
    public string get_Path();
    public string get_Xml();
    public sealed virtual int CompareTo(Task other);
    public sealed virtual void Dispose();
    public void Export(string outputFileName);
    public TaskSecurity GetAccessControl();
    public TaskSecurity GetAccessControl(AccessControlSections includeSections);
    [NotNullAttribute]
[ItemNotNullAttribute]
public RunningTaskCollection GetInstances();
    public DateTime GetLastRegistrationTime();
    [NotNullAttribute]
public DateTime[] GetRunTimes(DateTime start, DateTime end, UInt32 count);
    public string GetSecurityDescriptorSddlForm(SecurityInfos includeSections);
    public void RegisterChanges();
    public RunningTask Run(String[] parameters);
    public RunningTask RunEx(TaskRunFlags flags, int sessionID, string user, String[] parameters);
    public void SetAccessControl(TaskSecurity taskSecurity);
    public void SetSecurityDescriptorSddlForm(string sddlForm, TaskSetSecurityOptions options);
    public bool ShowEditor();
    public void ShowPropertyPage();
    public void Stop();
    public virtual string ToString();
    private sealed virtual override int System.IComparable.CompareTo(object other);
    internal static Task CreateTask(TaskService svc, IRegisteredTask iTask, bool throwError);
    internal static int GetOSLibraryMinorVersion();
    [NotNullAttribute]
internal static string GetV1Path(ITask v1Task);
    internal static ITaskDefinition GetV2Definition(TaskService svc, IRegisteredTask iTask, bool throwError);
    internal static ITaskDefinition GetV2StrippedDefinition(TaskService svc, IRegisteredTask iTask);
    internal static TimeSpan StringToTimeSpan(string input);
    internal static string TimeSpanToString(TimeSpan span);
    internal void V1Reactivate();
    protected void OnNotifyPropertyChanged(string propertyName);
}
public class Microsoft.Win32.TaskScheduler.TaskAccessRule : AccessRule {
    public TaskRights TaskRights { get; }
    public TaskAccessRule(IdentityReference identity, TaskRights eventRights, AccessControlType type);
    public TaskAccessRule(string identity, TaskRights eventRights, AccessControlType type);
    private TaskAccessRule(IdentityReference identity, int accessMask, bool isInherited, InheritanceFlags inheritanceFlags, PropagationFlags propagationFlags, AccessControlType type);
    public TaskRights get_TaskRights();
}
public enum Microsoft.Win32.TaskScheduler.TaskActionType : Enum {
    public int value__;
    public static TaskActionType Execute;
    public static TaskActionType ComHandler;
    public static TaskActionType SendEmail;
    public static TaskActionType ShowMessage;
}
public class Microsoft.Win32.TaskScheduler.TaskAuditRule : AuditRule {
    public TaskRights TaskRights { get; }
    public TaskAuditRule(IdentityReference identity, TaskRights eventRights, AuditFlags flags);
    internal TaskAuditRule(IdentityReference identity, int accessMask, bool isInherited, InheritanceFlags inheritanceFlags, PropagationFlags propagationFlags, AuditFlags flags);
    public TaskRights get_TaskRights();
}
[DefaultMemberAttribute("Item")]
[PublicAPIAttribute]
public class Microsoft.Win32.TaskScheduler.TaskCollection : object {
    private TaskFolder fld;
    private TaskService svc;
    private IRegisteredTaskCollection v2Coll;
    private Regex filter;
    private ITaskScheduler v1TS;
    public int Count { get; }
    private Regex Filter { get; private set; }
    public Task Item { get; }
    public Task Item { get; }
    internal TaskCollection(TaskService svc, Regex filter);
    internal TaskCollection(TaskFolder folder, IRegisteredTaskCollection iTaskColl, Regex filter);
    public sealed virtual int get_Count();
    private Regex get_Filter();
    private void set_Filter(Regex value);
    public sealed virtual Task get_Item(int index);
    public Task get_Item(string name);
    public sealed virtual void Dispose();
    public bool Exists(string taskName);
    public sealed virtual IEnumerator`1<Task> GetEnumerator();
    public virtual string ToString();
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
}
public enum Microsoft.Win32.TaskScheduler.TaskCompatibility : Enum {
    public int value__;
    public static TaskCompatibility AT;
    public static TaskCompatibility V1;
    public static TaskCompatibility V2;
    public static TaskCompatibility V2_1;
    public static TaskCompatibility V2_2;
    public static TaskCompatibility V2_3;
}
[PublicAPIAttribute]
public class Microsoft.Win32.TaskScheduler.TaskCompatibilityEntry : object {
    [CompilerGeneratedAttribute]
private TaskCompatibility <CompatibilityLevel>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Property>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Reason>k__BackingField;
    public TaskCompatibility CompatibilityLevel { get; }
    public string Property { get; }
    public string Reason { get; }
    internal TaskCompatibilityEntry(TaskCompatibility comp, string prop, string reason);
    [CompilerGeneratedAttribute]
public TaskCompatibility get_CompatibilityLevel();
    [CompilerGeneratedAttribute]
public string get_Property();
    [CompilerGeneratedAttribute]
public string get_Reason();
}
[DefaultValueAttribute("Mono.Cecil.CustomAttributeArgument")]
public enum Microsoft.Win32.TaskScheduler.TaskCreation : Enum {
    public int value__;
    public static TaskCreation Create;
    public static TaskCreation CreateOrUpdate;
    public static TaskCreation Disable;
    public static TaskCreation DontAddPrincipalAce;
    public static TaskCreation IgnoreRegistrationTriggers;
    public static TaskCreation Update;
    public static TaskCreation ValidateOnly;
}
[XmlRootAttribute("Task")]
[XmlSchemaProviderAttribute("GetV1SchemaFile")]
[PublicAPIAttribute]
public class Microsoft.Win32.TaskScheduler.TaskDefinition : object {
    internal static string tns;
    internal string v1Name;
    internal ITask v1Task;
    internal ITaskDefinition v2Def;
    private ActionCollection actions;
    private TaskPrincipal principal;
    private TaskRegistrationInfo regInfo;
    private TaskSettings settings;
    private TriggerCollection triggers;
    [CompilerGeneratedAttribute]
private PropertyChangedEventHandler PropertyChanged;
    [XmlArrayItemAttribute]
[XmlArrayItemAttribute]
[XmlArrayItemAttribute]
[XmlArrayItemAttribute]
[XmlArrayAttribute]
[NotNullAttribute]
[ItemNotNullAttribute]
public ActionCollection Actions { get; }
    [CanBeNullAttribute]
public string Data { get; public set; }
    [XmlIgnoreAttribute]
public TaskCompatibility LowestSupportedVersion { get; }
    [XmlArrayItemAttribute]
[XmlArrayItemAttribute]
[XmlArrayItemAttribute]
[XmlArrayItemAttribute]
[XmlArrayItemAttribute]
[XmlArrayAttribute]
[NotNullAttribute]
[ItemNotNullAttribute]
public TriggerCollection Triggers { get; }
    [XmlIgnoreAttribute]
public string XmlText { get; public set; }
    [NotNullAttribute]
public TaskPrincipal Principal { get; }
    public TaskRegistrationInfo RegistrationInfo { get; }
    [NotNullAttribute]
public TaskSettings Settings { get; }
    internal TaskDefinition(ITask iTask, string name);
    internal TaskDefinition(ITaskDefinition iDef);
    [CompilerGeneratedAttribute]
public sealed virtual void add_PropertyChanged(PropertyChangedEventHandler value);
    [CompilerGeneratedAttribute]
public sealed virtual void remove_PropertyChanged(PropertyChangedEventHandler value);
    public ActionCollection get_Actions();
    public string get_Data();
    public void set_Data(string value);
    public TaskCompatibility get_LowestSupportedVersion();
    public TriggerCollection get_Triggers();
    public string get_XmlText();
    public void set_XmlText(string value);
    public TaskPrincipal get_Principal();
    public TaskRegistrationInfo get_RegistrationInfo();
    public TaskSettings get_Settings();
    public static XmlSchemaComplexType GetV1SchemaFile(XmlSchemaSet xs);
    public bool CanUseUnifiedSchedulingEngine(bool throwExceptionWithDetails, Version taskSchedulerVersion);
    public sealed virtual void Dispose();
    public bool Validate(bool throwException);
    public static TaskDefinition op_Addition(TaskDefinition definition, Trigger trigger);
    public static TaskDefinition op_Addition(TaskDefinition definition, Action action);
    private sealed virtual override XmlSchema System.Xml.Serialization.IXmlSerializable.GetSchema();
    private sealed virtual override void System.Xml.Serialization.IXmlSerializable.ReadXml(XmlReader reader);
    private sealed virtual override void System.Xml.Serialization.IXmlSerializable.WriteXml(XmlWriter writer);
    internal static Dictionary`2<string, string> GetV1TaskDataDictionary(ITask v1Task);
    internal static void SetV1TaskData(ITask v1Task, object value);
    internal void V1Save(string newName);
    private static object GetV1TaskData(ITask v1Task);
    private static void TryAdd(IDictionary d, object k, object v);
    private TaskCompatibility GetLowestSupportedVersion(IList`1<TaskCompatibilityEntry> outputList);
    private void OnNotifyPropertyChanged(string propertyName);
    [CompilerGeneratedAttribute]
private string <get_Principal>b__27_0();
}
public static class Microsoft.Win32.TaskScheduler.TaskEnumGlobalizer : object {
    public static string GetString(object enumValue);
    private static string GetCultureEquivalentString(DaysOfTheWeek val);
    private static string GetCultureEquivalentString(MonthsOfTheYear val);
    private static string BuildEnumString(string preface, object enumValue);
}
[PublicAPIAttribute]
public class Microsoft.Win32.TaskScheduler.TaskEvent : object {
    [CompilerGeneratedAttribute]
private Nullable`1<Guid> <ActivityId>k__BackingField;
    [CompilerGeneratedAttribute]
private EventDataValues <DataValues>k__BackingField;
    [CompilerGeneratedAttribute]
private int <EventId>k__BackingField;
    [CompilerGeneratedAttribute]
private EventRecord <EventRecord>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Level>k__BackingField;
    [CompilerGeneratedAttribute]
private string <OpCode>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<int> <ProcessId>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<long> <RecordId>k__BackingField;
    [CompilerGeneratedAttribute]
private string <TaskCategory>k__BackingField;
    [CompilerGeneratedAttribute]
private string <TaskPath>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<DateTime> <TimeCreated>k__BackingField;
    [CompilerGeneratedAttribute]
private SecurityIdentifier <UserId>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<byte> <Version>k__BackingField;
    public Nullable`1<Guid> ActivityId { get; internal set; }
    public EventDataValues DataValues { get; }
    public int EventId { get; internal set; }
    public EventRecord EventRecord { get; internal set; }
    public StandardTaskEventId StandardEventId { get; }
    public string Level { get; internal set; }
    public string OpCode { get; internal set; }
    public Nullable`1<int> ProcessId { get; internal set; }
    public Nullable`1<long> RecordId { get; internal set; }
    public string TaskCategory { get; internal set; }
    public string TaskPath { get; internal set; }
    public Nullable`1<DateTime> TimeCreated { get; internal set; }
    public SecurityIdentifier UserId { get; internal set; }
    public Nullable`1<byte> Version { get; internal set; }
    internal TaskEvent(EventRecord rec);
    internal TaskEvent(string taskPath, StandardTaskEventId id, DateTime time);
    [CompilerGeneratedAttribute]
public Nullable`1<Guid> get_ActivityId();
    [CompilerGeneratedAttribute]
internal void set_ActivityId(Nullable`1<Guid> value);
    [CompilerGeneratedAttribute]
public EventDataValues get_DataValues();
    [CompilerGeneratedAttribute]
public int get_EventId();
    [CompilerGeneratedAttribute]
internal void set_EventId(int value);
    [CompilerGeneratedAttribute]
public EventRecord get_EventRecord();
    [CompilerGeneratedAttribute]
internal void set_EventRecord(EventRecord value);
    public StandardTaskEventId get_StandardEventId();
    [CompilerGeneratedAttribute]
public string get_Level();
    [CompilerGeneratedAttribute]
internal void set_Level(string value);
    [CompilerGeneratedAttribute]
public string get_OpCode();
    [CompilerGeneratedAttribute]
internal void set_OpCode(string value);
    [CompilerGeneratedAttribute]
public Nullable`1<int> get_ProcessId();
    [CompilerGeneratedAttribute]
internal void set_ProcessId(Nullable`1<int> value);
    [CompilerGeneratedAttribute]
public Nullable`1<long> get_RecordId();
    [CompilerGeneratedAttribute]
internal void set_RecordId(Nullable`1<long> value);
    [CompilerGeneratedAttribute]
public string get_TaskCategory();
    [CompilerGeneratedAttribute]
internal void set_TaskCategory(string value);
    [CompilerGeneratedAttribute]
public string get_TaskPath();
    [CompilerGeneratedAttribute]
internal void set_TaskPath(string value);
    [CompilerGeneratedAttribute]
public Nullable`1<DateTime> get_TimeCreated();
    [CompilerGeneratedAttribute]
internal void set_TimeCreated(Nullable`1<DateTime> value);
    [CompilerGeneratedAttribute]
public SecurityIdentifier get_UserId();
    [CompilerGeneratedAttribute]
internal void set_UserId(SecurityIdentifier value);
    [CompilerGeneratedAttribute]
public Nullable`1<byte> get_Version();
    [CompilerGeneratedAttribute]
internal void set_Version(Nullable`1<byte> value);
    [ObsoleteAttribute("Use the DataVales property instead.")]
public string GetDataValue(string name);
    public virtual string ToString();
    public sealed virtual int CompareTo(TaskEvent other);
}
[PublicAPIAttribute]
public class Microsoft.Win32.TaskScheduler.TaskEventArgs : EventArgs {
    private TaskService taskService;
    [CompilerGeneratedAttribute]
private TaskEvent <TaskEvent>k__BackingField;
    [CompilerGeneratedAttribute]
private string <TaskPath>k__BackingField;
    public Task Task { get; }
    [NotNullAttribute]
public TaskEvent TaskEvent { get; }
    public string TaskName { get; }
    public string TaskPath { get; }
    internal TaskEventArgs(TaskEvent evt, TaskService ts);
    public Task get_Task();
    [CompilerGeneratedAttribute]
public TaskEvent get_TaskEvent();
    public string get_TaskName();
    [CompilerGeneratedAttribute]
public string get_TaskPath();
}
public class Microsoft.Win32.TaskScheduler.TaskEventEnumerator : object {
    private EventRecord curRec;
    private EventLogReader log;
    public TaskEvent Current { get; }
    private object System.Collections.IEnumerator.Current { get; }
    internal TaskEventEnumerator(EventLogReader log);
    public sealed virtual TaskEvent get_Current();
    private sealed virtual override object System.Collections.IEnumerator.get_Current();
    public sealed virtual void Dispose();
    public sealed virtual bool MoveNext();
    public sealed virtual void Reset();
    public void Seek(EventBookmark bookmark, long offset);
    public void Seek(SeekOrigin origin, long offset);
}
public class Microsoft.Win32.TaskScheduler.TaskEventLog : object {
    private static string TSEventLogPath;
    private static bool IsVistaOrLater;
    [CompilerGeneratedAttribute]
private bool <EnumerateInReverse>k__BackingField;
    [CompilerGeneratedAttribute]
private EventLogQuery <Query>k__BackingField;
    public long Count { get; }
    public bool Enabled { get; public set; }
    [DefaultValueAttribute("False")]
public bool EnumerateInReverse { get; public set; }
    internal EventLogQuery Query { get; private set; }
    public TaskEventLog(string taskPath);
    public TaskEventLog(string machineName, string taskPath, string domain, string user, string password);
    public TaskEventLog(DateTime startTime, string taskName, string machineName, string domain, string user, string password);
    public TaskEventLog(string taskName, Int32[] eventIDs, Nullable`1<DateTime> startTime, string machineName, string domain, string user, string password);
    public TaskEventLog(string taskName, Int32[] eventIDs, Int32[] levels, Nullable`1<DateTime> startTime, string machineName, string domain, string user, string password);
    private static TaskEventLog();
    internal static string BuildQuery(string taskName, Int32[] eventIDs, Nullable`1<DateTime> startTime, Int32[] levels);
    private void Initialize(string machineName, string query, bool revDir, string domain, string user, string password);
    public long get_Count();
    public bool get_Enabled();
    public void set_Enabled(bool value);
    [CompilerGeneratedAttribute]
public bool get_EnumerateInReverse();
    [CompilerGeneratedAttribute]
public void set_EnumerateInReverse(bool value);
    private sealed virtual override IEnumerator`1<TaskEvent> System.Collections.Generic.IEnumerable<Microsoft.Win32.TaskScheduler.TaskEvent>.GetEnumerator();
    [NotNullAttribute]
public TaskEventEnumerator GetEnumerator(bool reverse);
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
    [CompilerGeneratedAttribute]
internal EventLogQuery get_Query();
    [CompilerGeneratedAttribute]
private void set_Query(EventLogQuery value);
}
[DefaultEventAttribute("EventRecorded")]
[DefaultPropertyAttribute("Folder")]
[ToolboxItemAttribute("True")]
[PublicAPIAttribute]
public class Microsoft.Win32.TaskScheduler.TaskEventWatcher : Component {
    private static string root;
    private static string star;
    private static TimeSpan MaxV1EventLapse;
    private bool disposed;
    private bool enabled;
    private string folder;
    private bool includeSubfolders;
    private bool initializing;
    private StandardTaskEventId lastId;
    private DateTime lastIdTime;
    private TaskService ts;
    private FileSystemWatcher v1Watcher;
    private EventLogWatcher watcher;
    private ISynchronizeInvoke synchronizingObject;
    [CompilerGeneratedAttribute]
private EventHandler`1<TaskEventArgs> EventRecorded;
    [CompilerGeneratedAttribute]
private EventFilter <Filter>k__BackingField;
    [DefaultValueAttribute("False")]
[CategoryAttribute("Behavior")]
[DescriptionAttribute("Indicates whether the component is enabled.")]
public bool Enabled { get; public set; }
    [DesignerSerializationVisibilityAttribute("2")]
[CategoryAttribute("Behavior")]
[DescriptionAttribute("Indicates the filter for the watcher.")]
public EventFilter Filter { get; }
    [DefaultValueAttribute("\")]
[CategoryAttribute("Behavior")]
[DescriptionAttribute("Indicates the folder to watch.")]
public string Folder { get; public set; }
    [DefaultValueAttribute("False")]
[CategoryAttribute("Behavior")]
[DescriptionAttribute("Indicates whether to include events from subfolders.")]
public bool IncludeSubfolders { get; public set; }
    [BrowsableAttribute("False")]
[DefaultValueAttribute("")]
public ISynchronizeInvoke SynchronizingObject { get; public set; }
    [CategoryAttribute("Connection")]
[DescriptionAttribute("The name of the computer to connect to.")]
[DesignerSerializationVisibilityAttribute("0")]
public string TargetServer { get; public set; }
    [CategoryAttribute("Data")]
[DescriptionAttribute("The TaskService for this event watcher.")]
public TaskService TaskService { get; public set; }
    [CategoryAttribute("Connection")]
[DescriptionAttribute("The user account domain to be used when connecting.")]
[DesignerSerializationVisibilityAttribute("0")]
public string UserAccountDomain { get; public set; }
    [CategoryAttribute("Connection")]
[DescriptionAttribute("The user name to be used when connecting.")]
[DesignerSerializationVisibilityAttribute("0")]
public string UserName { get; public set; }
    [CategoryAttribute("Connection")]
[DescriptionAttribute("The user password to be used when connecting.")]
[DesignerSerializationVisibilityAttribute("0")]
public string UserPassword { get; public set; }
    [BrowsableAttribute("False")]
[DesignerSerializationVisibilityAttribute("0")]
private bool IsHandleInvalid { get; }
    private static bool IsV1 { get; }
    public TaskEventWatcher(string taskPath, TaskService taskService);
    public TaskEventWatcher(Task task);
    public TaskEventWatcher(TaskFolder taskFolder, string taskFilter, bool includeSubfolders);
    public TaskEventWatcher(string folder, string taskFilter, bool includeSubfolders, TaskService taskService);
    public TaskEventWatcher(string machineName, string taskPath, string domain, string user, string password);
    public TaskEventWatcher(string machineName, string taskPath, string domain, string user, SecureString securePassword);
    public TaskEventWatcher(string machineName, string folder, string taskFilter, bool includeSubfolders, string domain, string user, string password);
    private TaskEventWatcher(TaskService ts);
    private static TaskEventWatcher();
    [CompilerGeneratedAttribute]
public void add_EventRecorded(EventHandler`1<TaskEventArgs> value);
    [CompilerGeneratedAttribute]
public void remove_EventRecorded(EventHandler`1<TaskEventArgs> value);
    public bool get_Enabled();
    public void set_Enabled(bool value);
    [CompilerGeneratedAttribute]
public EventFilter get_Filter();
    public string get_Folder();
    public void set_Folder(string value);
    public bool get_IncludeSubfolders();
    public void set_IncludeSubfolders(bool value);
    public ISynchronizeInvoke get_SynchronizingObject();
    public void set_SynchronizingObject(ISynchronizeInvoke value);
    public string get_TargetServer();
    public void set_TargetServer(string value);
    public TaskService get_TaskService();
    public void set_TaskService(TaskService value);
    public string get_UserAccountDomain();
    public void set_UserAccountDomain(string value);
    public string get_UserName();
    public void set_UserName(string value);
    public string get_UserPassword();
    public void set_UserPassword(string value);
    private bool get_IsHandleInvalid();
    private static bool get_IsV1();
    public sealed virtual void BeginInit();
    public sealed virtual void EndInit();
    protected virtual void Dispose(bool disposing);
    protected virtual void OnEventRecorded(object sender, TaskEventArgs e);
    private void InitTask(Task task);
    private void InitTask(TaskFolder taskFolder, string taskFilter, bool includeSubfolders);
    private void InitTask(string taskFolder, string taskFilter, bool includeSubfolders);
    private void InitTask(string taskPath);
    private bool IsSuspended();
    private void ReleaseWatcher();
    private void ResetTaskService();
    private void Restart();
    private void SetupWatcher();
    private bool ShouldSerializeFilter();
    private bool ShouldSerializeTaskService();
    private void StartRaisingEvents();
    private void StopListening();
    private void StopRaisingEvents();
    private void Watcher_DirectoryChanged(object sender, FileSystemEventArgs e);
    private void Watcher_EventRecordWritten(object sender, EventRecordWrittenEventArgs e);
}
[PublicAPIAttribute]
public class Microsoft.Win32.TaskScheduler.TaskFolder : object {
    private ITaskScheduler v1List;
    private ITaskFolder v2Folder;
    internal static string rootString;
    [CompilerGeneratedAttribute]
private TaskService <TaskService>k__BackingField;
    [NotNullAttribute]
[ItemNotNullAttribute]
public IEnumerable`1<Task> AllTasks { get; }
    [NotNullAttribute]
public string Name { get; }
    public TaskFolder Parent { get; }
    [NotNullAttribute]
public string Path { get; }
    [ObsoleteAttribute("This property will be removed in deference to the GetAccessControl, GetSecurityDescriptorSddlForm, SetAccessControl and SetSecurityDescriptorSddlForm methods.")]
public GenericSecurityDescriptor SecurityDescriptor { get; public set; }
    [NotNullAttribute]
[ItemNotNullAttribute]
public TaskFolderCollection SubFolders { get; }
    [NotNullAttribute]
[ItemNotNullAttribute]
public TaskCollection Tasks { get; }
    public TaskService TaskService { get; }
    internal TaskFolder(TaskService svc);
    internal TaskFolder(TaskService svc, ITaskFolder iFldr);
    public sealed virtual void Dispose();
    public IEnumerable`1<Task> get_AllTasks();
    public string get_Name();
    public TaskFolder get_Parent();
    public string get_Path();
    [NotNullAttribute]
internal TaskFolder GetFolder(string path);
    public GenericSecurityDescriptor get_SecurityDescriptor();
    public void set_SecurityDescriptor(GenericSecurityDescriptor value);
    public TaskFolderCollection get_SubFolders();
    public TaskCollection get_Tasks();
    [CompilerGeneratedAttribute]
public TaskService get_TaskService();
    private sealed virtual override int System.IComparable<Microsoft.Win32.TaskScheduler.TaskFolder>.CompareTo(TaskFolder other);
    [ObsoleteAttribute("This method will be removed in deference to the CreateFolder(string, TaskSecurity) method.")]
public TaskFolder CreateFolder(string subFolderName, GenericSecurityDescriptor sd);
    public TaskFolder CreateFolder(string subFolderName, TaskSecurity folderSecurity);
    public TaskFolder CreateFolder(string subFolderName, string sddlForm, bool exceptionOnExists);
    public void DeleteFolder(string subFolderName, bool exceptionOnNotExists);
    public void DeleteTask(string name, bool exceptionOnNotExists);
    [IteratorStateMachineAttribute("Microsoft.Win32.TaskScheduler.TaskFolder/<EnumerateFolders>d__31")]
[NotNullAttribute]
[ItemNotNullAttribute]
public IEnumerable`1<TaskFolder> EnumerateFolders(Predicate`1<TaskFolder> filter);
    [NotNullAttribute]
[ItemNotNullAttribute]
public IEnumerable`1<Task> EnumerateTasks(Predicate`1<Task> filter, bool recurse);
    public virtual bool Equals(object obj);
    [NotNullAttribute]
public TaskSecurity GetAccessControl();
    [NotNullAttribute]
public TaskSecurity GetAccessControl(AccessControlSections includeSections);
    public virtual int GetHashCode();
    [ObsoleteAttribute("This method will be removed in deference to the GetAccessControl and GetSecurityDescriptorSddlForm methods.")]
public GenericSecurityDescriptor GetSecurityDescriptor(SecurityInfos includeSections);
    public string GetSecurityDescriptorSddlForm(SecurityInfos includeSections);
    [NotNullAttribute]
[ItemNotNullAttribute]
public TaskCollection GetTasks(Regex filter);
    public Task ImportTask(string path, string xmlFile, bool overwriteExisting);
    public Task RegisterTask(string path, string xmlText, TaskCreation createType, string userId, string password, TaskLogonType logonType, string sddl);
    public Task RegisterTaskDefinition(string path, TaskDefinition definition);
    public Task RegisterTaskDefinition(string path, TaskDefinition definition, TaskCreation createType, string userId, string password, TaskLogonType logonType, string sddl);
    public void SetAccessControl(TaskSecurity taskSecurity);
    [ObsoleteAttribute("This method will be removed in deference to the SetAccessControl and SetSecurityDescriptorSddlForm methods.")]
public void SetSecurityDescriptor(GenericSecurityDescriptor sd, SecurityInfos includeSections);
    public void SetSecurityDescriptorSddlForm(string sddlForm, TaskSetSecurityOptions options);
    public virtual string ToString();
    internal static List`1<Task> EnumerateFolderTasks(TaskFolder folder, Predicate`1<Task> filter, bool recurse);
    private static void FindTasksInFolder(TaskFolder fld, Predicate`1<Task> filter, List`1& results, bool recurse);
}
[DefaultMemberAttribute("Item")]
public class Microsoft.Win32.TaskScheduler.TaskFolderCollection : object {
    private static string IndexerName;
    private TaskFolder parent;
    private TaskFolder[] v1FolderList;
    private ITaskFolderCollection v2FolderList;
    [CompilerGeneratedAttribute]
private NotifyCollectionChangedEventHandler CollectionChanged;
    [CompilerGeneratedAttribute]
private PropertyChangedEventHandler PropertyChanged;
    public int Count { get; }
    private bool System.Collections.Generic.ICollection<Microsoft.Win32.TaskScheduler.TaskFolder>.IsReadOnly { get; }
    public TaskFolder Item { get; }
    public TaskFolder Item { get; }
    internal TaskFolderCollection(TaskFolder folder, ITaskFolderCollection iCollection);
    [CompilerGeneratedAttribute]
public sealed virtual void add_CollectionChanged(NotifyCollectionChangedEventHandler value);
    [CompilerGeneratedAttribute]
public sealed virtual void remove_CollectionChanged(NotifyCollectionChangedEventHandler value);
    [CompilerGeneratedAttribute]
public sealed virtual void add_PropertyChanged(PropertyChangedEventHandler value);
    [CompilerGeneratedAttribute]
public sealed virtual void remove_PropertyChanged(PropertyChangedEventHandler value);
    public sealed virtual int get_Count();
    private sealed virtual override bool System.Collections.Generic.ICollection<Microsoft.Win32.TaskScheduler.TaskFolder>.get_IsReadOnly();
    public TaskFolder get_Item(int index);
    public TaskFolder get_Item(string path);
    public sealed virtual void Add(TaskFolder item);
    public sealed virtual void Clear();
    public sealed virtual bool Contains(TaskFolder item);
    public sealed virtual void CopyTo(TaskFolder[] array, int arrayIndex);
    public sealed virtual void Dispose();
    public bool Exists(string path);
    public sealed virtual IEnumerator`1<TaskFolder> GetEnumerator();
    public sealed virtual bool Remove(TaskFolder item);
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
    private void OnNotifyPropertyChanged(string propertyName);
    [CompilerGeneratedAttribute]
private int <GetEnumerator>b__26_0();
    [CompilerGeneratedAttribute]
private ITaskFolder <GetEnumerator>b__26_1(object o);
    [CompilerGeneratedAttribute]
private TaskFolder <GetEnumerator>b__26_2(ITaskFolder o);
}
public class Microsoft.Win32.TaskScheduler.TaskFolderSnapshot : SnapshotItem {
    internal TaskFolderSnapshot(string path, string sddl);
}
[DefaultValueAttribute("Mono.Cecil.CustomAttributeArgument")]
public enum Microsoft.Win32.TaskScheduler.TaskInstancesPolicy : Enum {
    public int value__;
    public static TaskInstancesPolicy Parallel;
    public static TaskInstancesPolicy Queue;
    public static TaskInstancesPolicy IgnoreNew;
    public static TaskInstancesPolicy StopExisting;
}
[DefaultValueAttribute("Mono.Cecil.CustomAttributeArgument")]
public enum Microsoft.Win32.TaskScheduler.TaskLogonType : Enum {
    public int value__;
    public static TaskLogonType None;
    public static TaskLogonType Password;
    public static TaskLogonType S4U;
    public static TaskLogonType InteractiveToken;
    public static TaskLogonType Group;
    public static TaskLogonType ServiceAccount;
    public static TaskLogonType InteractiveTokenOrPassword;
}
[XmlRootAttribute("Principals")]
[PublicAPIAttribute]
public class Microsoft.Win32.TaskScheduler.TaskPrincipal : object {
    private static string localSystemAcct;
    private IPrincipal v2Principal;
    private IPrincipal2 v2Principal2;
    private Func`1<string> xmlFunc;
    private TaskPrincipalPrivileges reqPriv;
    private string v1CachedAcctInfo;
    private ITask v1Task;
    [CompilerGeneratedAttribute]
private PropertyChangedEventHandler PropertyChanged;
    [DefaultValueAttribute("")]
[BrowsableAttribute("False")]
public string Account { get; }
    [DefaultValueAttribute("")]
public string DisplayName { get; public set; }
    [DefaultValueAttribute("")]
[XmlIgnoreAttribute]
public string GroupId { get; public set; }
    [DefaultValueAttribute("")]
[XmlAttributeAttribute]
public string Id { get; public set; }
    [DefaultValueAttribute("Microsoft.Win32.TaskScheduler.TaskLogonType", "None")]
public TaskLogonType LogonType { get; public set; }
    [XmlIgnoreAttribute]
[DefaultValueAttribute("Microsoft.Win32.TaskScheduler.TaskProcessTokenSidType", "Default")]
public TaskProcessTokenSidType ProcessTokenSidType { get; public set; }
    [XmlIgnoreAttribute]
public TaskPrincipalPrivileges RequiredPrivileges { get; }
    [DefaultValueAttribute("Microsoft.Win32.TaskScheduler.TaskRunLevel", "LUA")]
[XmlIgnoreAttribute]
public TaskRunLevel RunLevel { get; public set; }
    [DefaultValueAttribute("")]
public string UserId { get; public set; }
    internal TaskPrincipal(IPrincipal iPrincipal, Func`1<string> defXml);
    internal TaskPrincipal(ITask iTask);
    [CompilerGeneratedAttribute]
public sealed virtual void add_PropertyChanged(PropertyChangedEventHandler value);
    [CompilerGeneratedAttribute]
public sealed virtual void remove_PropertyChanged(PropertyChangedEventHandler value);
    public string get_Account();
    public string get_DisplayName();
    public void set_DisplayName(string value);
    public string get_GroupId();
    public void set_GroupId(string value);
    public string get_Id();
    public void set_Id(string value);
    public TaskLogonType get_LogonType();
    public void set_LogonType(TaskLogonType value);
    public TaskProcessTokenSidType get_ProcessTokenSidType();
    public void set_ProcessTokenSidType(TaskProcessTokenSidType value);
    public TaskPrincipalPrivileges get_RequiredPrivileges();
    public TaskRunLevel get_RunLevel();
    public void set_RunLevel(TaskRunLevel value);
    public string get_UserId();
    public void set_UserId(string value);
    public static bool ValidateAccountForSidType(string acct, TaskProcessTokenSidType sidType);
    public sealed virtual void Dispose();
    public bool RequiresPassword();
    public virtual string ToString();
    private sealed virtual override XmlSchema System.Xml.Serialization.IXmlSerializable.GetSchema();
    private sealed virtual override void System.Xml.Serialization.IXmlSerializable.ReadXml(XmlReader reader);
    private sealed virtual override void System.Xml.Serialization.IXmlSerializable.WriteXml(XmlWriter writer);
    private void OnNotifyPropertyChanged(string propertyName);
}
public enum Microsoft.Win32.TaskScheduler.TaskPrincipalPrivilege : Enum {
    public int value__;
    public static TaskPrincipalPrivilege SeCreateTokenPrivilege;
    public static TaskPrincipalPrivilege SeAssignPrimaryTokenPrivilege;
    public static TaskPrincipalPrivilege SeLockMemoryPrivilege;
    public static TaskPrincipalPrivilege SeIncreaseQuotaPrivilege;
    public static TaskPrincipalPrivilege SeUnsolicitedInputPrivilege;
    public static TaskPrincipalPrivilege SeMachineAccountPrivilege;
    public static TaskPrincipalPrivilege SeTcbPrivilege;
    public static TaskPrincipalPrivilege SeSecurityPrivilege;
    public static TaskPrincipalPrivilege SeTakeOwnershipPrivilege;
    public static TaskPrincipalPrivilege SeLoadDriverPrivilege;
    public static TaskPrincipalPrivilege SeSystemProfilePrivilege;
    public static TaskPrincipalPrivilege SeSystemtimePrivilege;
    public static TaskPrincipalPrivilege SeProfileSingleProcessPrivilege;
    public static TaskPrincipalPrivilege SeIncreaseBasePriorityPrivilege;
    public static TaskPrincipalPrivilege SeCreatePagefilePrivilege;
    public static TaskPrincipalPrivilege SeCreatePermanentPrivilege;
    public static TaskPrincipalPrivilege SeBackupPrivilege;
    public static TaskPrincipalPrivilege SeRestorePrivilege;
    public static TaskPrincipalPrivilege SeShutdownPrivilege;
    public static TaskPrincipalPrivilege SeDebugPrivilege;
    public static TaskPrincipalPrivilege SeAuditPrivilege;
    public static TaskPrincipalPrivilege SeSystemEnvironmentPrivilege;
    public static TaskPrincipalPrivilege SeChangeNotifyPrivilege;
    public static TaskPrincipalPrivilege SeRemoteShutdownPrivilege;
    public static TaskPrincipalPrivilege SeUndockPrivilege;
    public static TaskPrincipalPrivilege SeSyncAgentPrivilege;
    public static TaskPrincipalPrivilege SeEnableDelegationPrivilege;
    public static TaskPrincipalPrivilege SeManageVolumePrivilege;
    public static TaskPrincipalPrivilege SeImpersonatePrivilege;
    public static TaskPrincipalPrivilege SeCreateGlobalPrivilege;
    public static TaskPrincipalPrivilege SeTrustedCredManAccessPrivilege;
    public static TaskPrincipalPrivilege SeRelabelPrivilege;
    public static TaskPrincipalPrivilege SeIncreaseWorkingSetPrivilege;
    public static TaskPrincipalPrivilege SeTimeZonePrivilege;
    public static TaskPrincipalPrivilege SeCreateSymbolicLinkPrivilege;
}
[DefaultMemberAttribute("Item")]
[PublicAPIAttribute]
public class Microsoft.Win32.TaskScheduler.TaskPrincipalPrivileges : object {
    private IPrincipal2 v2Principal2;
    public int Count { get; }
    public bool IsReadOnly { get; }
    public TaskPrincipalPrivilege Item { get; public set; }
    internal TaskPrincipalPrivileges(IPrincipal2 iPrincipal2);
    public sealed virtual int get_Count();
    public sealed virtual bool get_IsReadOnly();
    public sealed virtual TaskPrincipalPrivilege get_Item(int index);
    public sealed virtual void set_Item(int index, TaskPrincipalPrivilege value);
    public sealed virtual void Add(TaskPrincipalPrivilege item);
    public sealed virtual bool Contains(TaskPrincipalPrivilege item);
    public sealed virtual void CopyTo(TaskPrincipalPrivilege[] array, int arrayIndex);
    public sealed virtual IEnumerator`1<TaskPrincipalPrivilege> GetEnumerator();
    public sealed virtual int IndexOf(TaskPrincipalPrivilege item);
    private sealed virtual override void System.Collections.Generic.ICollection<Microsoft.Win32.TaskScheduler.TaskPrincipalPrivilege>.Clear();
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
    private sealed virtual override void System.Collections.Generic.IList<Microsoft.Win32.TaskScheduler.TaskPrincipalPrivilege>.Insert(int index, TaskPrincipalPrivilege item);
    private sealed virtual override bool System.Collections.Generic.ICollection<Microsoft.Win32.TaskScheduler.TaskPrincipalPrivilege>.Remove(TaskPrincipalPrivilege item);
    private sealed virtual override void System.Collections.Generic.IList<Microsoft.Win32.TaskScheduler.TaskPrincipalPrivilege>.RemoveAt(int index);
}
public enum Microsoft.Win32.TaskScheduler.TaskProcessTokenSidType : Enum {
    public int value__;
    public static TaskProcessTokenSidType None;
    public static TaskProcessTokenSidType Unrestricted;
    public static TaskProcessTokenSidType Default;
}
[XmlRootAttribute("RegistrationInfo")]
[PublicAPIAttribute]
public class Microsoft.Win32.TaskScheduler.TaskRegistrationInfo : object {
    private IRegistrationInfo v2RegInfo;
    private ITask v1Task;
    [CompilerGeneratedAttribute]
private PropertyChangedEventHandler PropertyChanged;
    [DefaultValueAttribute("")]
public string Author { get; public set; }
    [DefaultValueAttribute("System.DateTime", "0001-01-01T00:00:00")]
public DateTime Date { get; public set; }
    [DefaultValueAttribute("")]
public string Description { get; public set; }
    [DefaultValueAttribute("")]
public string Documentation { get; public set; }
    [XmlIgnoreAttribute]
public GenericSecurityDescriptor SecurityDescriptor { get; public set; }
    [DefaultValueAttribute("")]
[XmlIgnoreAttribute]
public string SecurityDescriptorSddlForm { get; public set; }
    [DefaultValueAttribute("")]
public string Source { get; public set; }
    [DefaultValueAttribute("")]
public string URI { get; public set; }
    [DefaultValueExAttribute("System.Version", "1.0")]
public Version Version { get; public set; }
    [XmlIgnoreAttribute]
public string XmlText { get; public set; }
    internal TaskRegistrationInfo(IRegistrationInfo iRegInfo);
    internal TaskRegistrationInfo(ITask iTask);
    [CompilerGeneratedAttribute]
public sealed virtual void add_PropertyChanged(PropertyChangedEventHandler value);
    [CompilerGeneratedAttribute]
public sealed virtual void remove_PropertyChanged(PropertyChangedEventHandler value);
    public string get_Author();
    public void set_Author(string value);
    public DateTime get_Date();
    public void set_Date(DateTime value);
    public string get_Description();
    public void set_Description(string value);
    public string get_Documentation();
    public void set_Documentation(string value);
    public GenericSecurityDescriptor get_SecurityDescriptor();
    public void set_SecurityDescriptor(GenericSecurityDescriptor value);
    public string get_SecurityDescriptorSddlForm();
    public void set_SecurityDescriptorSddlForm(string value);
    public string get_Source();
    public void set_Source(string value);
    public string get_URI();
    public void set_URI(string value);
    public Version get_Version();
    public void set_Version(Version value);
    public string get_XmlText();
    public void set_XmlText(string value);
    public sealed virtual void Dispose();
    public virtual string ToString();
    private sealed virtual override XmlSchema System.Xml.Serialization.IXmlSerializable.GetSchema();
    private sealed virtual override void System.Xml.Serialization.IXmlSerializable.ReadXml(XmlReader reader);
    private sealed virtual override void System.Xml.Serialization.IXmlSerializable.WriteXml(XmlWriter writer);
    internal static string FixCrLf(string text);
    private void OnNotifyPropertyChanged(string propertyName);
    private bool ProcessVersionXml(PropertyInfo pi, object obj, Object& value);
}
[FlagsAttribute]
public enum Microsoft.Win32.TaskScheduler.TaskRights : Enum {
    public int value__;
    public static TaskRights FullControl;
    public static TaskRights Write;
    public static TaskRights Read;
    public static TaskRights Execute;
    public static TaskRights Synchronize;
    public static TaskRights TakeOwnership;
    public static TaskRights ChangePermissions;
    public static TaskRights ReadPermissions;
    public static TaskRights Delete;
    public static TaskRights WriteAttributes;
    public static TaskRights ReadAttributes;
    public static TaskRights DeleteChild;
    public static TaskRights ExecuteFile;
    public static TaskRights WriteExtendedAttributes;
    public static TaskRights ReadExtendedAttributes;
    public static TaskRights AppendData;
    public static TaskRights WriteData;
    public static TaskRights ReadData;
}
[FlagsAttribute]
public enum Microsoft.Win32.TaskScheduler.TaskRunFlags : Enum {
    public int value__;
    public static TaskRunFlags NoFlags;
    public static TaskRunFlags AsSelf;
    public static TaskRunFlags IgnoreConstraints;
    public static TaskRunFlags UseSessionId;
    public static TaskRunFlags UserSID;
}
public enum Microsoft.Win32.TaskScheduler.TaskRunLevel : Enum {
    public int value__;
    [XmlEnumAttribute("LeastPrivilege")]
public static TaskRunLevel LUA;
    [XmlEnumAttribute("HighestAvailable")]
public static TaskRunLevel Highest;
}
public class Microsoft.Win32.TaskScheduler.TaskSchedulerSnapshot : object {
    private static string hdrfile;
    private List`1<SnapshotItem> items;
    [CompilerGeneratedAttribute]
private string <Path>k__BackingField;
    [CompilerGeneratedAttribute]
private string <TargetServer>k__BackingField;
    [CompilerGeneratedAttribute]
private DateTime <TimeStamp>k__BackingField;
    public List`1<SnapshotItem> Items { get; internal set; }
    public string Path { get; private set; }
    public string TargetServer { get; private set; }
    public DateTime TimeStamp { get; private set; }
    public TaskSchedulerSnapshot(string path);
    public List`1<SnapshotItem> get_Items();
    internal void set_Items(List`1<SnapshotItem> value);
    [CompilerGeneratedAttribute]
public string get_Path();
    [CompilerGeneratedAttribute]
private void set_Path(string value);
    [CompilerGeneratedAttribute]
public string get_TargetServer();
    [CompilerGeneratedAttribute]
private void set_TargetServer(string value);
    [CompilerGeneratedAttribute]
public DateTime get_TimeStamp();
    [CompilerGeneratedAttribute]
private void set_TimeStamp(DateTime value);
    public static TaskSchedulerSnapshot Create(TaskService ts, string path);
    [AsyncStateMachineAttribute("Microsoft.Win32.TaskScheduler.TaskSchedulerSnapshot/<Create>d__20")]
public static Task`1<TaskSchedulerSnapshot> Create(ConnectionToken tsToken, string path, CancellationToken cancelToken, IProgress`1<Tuple`2<int, string>> progress);
    public static TaskSchedulerSnapshot Open(string path);
    [AsyncStateMachineAttribute("Microsoft.Win32.TaskScheduler.TaskSchedulerSnapshot/<Restore>d__22")]
public Task Restore(ConnectionToken tsToken, IEnumerable`1<string> itemPaths, bool applyAccessRights, bool overwriteExisting, IDictionary`2<string, string> passwords, CancellationToken cancelToken, IProgress`1<Tuple`2<int, string>> progress);
    [AsyncStateMachineAttribute("Microsoft.Win32.TaskScheduler.TaskSchedulerSnapshot/<Restore>d__23")]
public Task Restore(ConnectionToken tsToken, ICollection`1<SnapshotItem> items, bool applyAccessRights, bool overwriteExisting, IDictionary`2<string, string> passwords, CancellationToken cancelToken, IProgress`1<Tuple`2<int, string>> progress);
    public void Restore(TaskService ts, ICollection`1<SnapshotItem> items, bool applyAccessRights, bool overwriteExisting, IDictionary`2<string, string> passwords);
    private sealed virtual override XmlSchema System.Xml.Serialization.IXmlSerializable.GetSchema();
    private sealed virtual override void System.Xml.Serialization.IXmlSerializable.ReadXml(XmlReader reader);
    private sealed virtual override void System.Xml.Serialization.IXmlSerializable.WriteXml(XmlWriter writer);
    private static List`1<SnapshotItem> GetArchiveItems(string archiveFile);
    private static TaskSchedulerSnapshot InternalCreate(ConnectionToken token, string path, CancellationToken cancelToken, IProgress`1<Tuple`2<int, string>> progress);
    private void InternalRestore(ConnectionToken token, ICollection`1<SnapshotItem> items, bool applyAccessRights, bool overwriteExisting, IDictionary`2<string, string> passwords, CancellationToken cancelToken, IProgress`1<Tuple`2<int, string>> progress);
    [CompilerGeneratedAttribute]
internal static void <InternalCreate>g__GetCount|29_0(TaskFolder f, <>c__DisplayClass29_0& );
    [CompilerGeneratedAttribute]
internal static void <InternalCreate>g__GetContents|29_1(TaskFolder f, List`1<SnapshotItem> list, ZipArchive zip, <>c__DisplayClass29_0& );
    [CompilerGeneratedAttribute]
private void <InternalRestore>g__CreateTask|30_0(TaskSnapshot task, TaskDefinition td, string password, <>c__DisplayClass30_0& );
    [CompilerGeneratedAttribute]
private TaskFolder <InternalRestore>g__EnsureFolder|30_1(string fpath, <>c__DisplayClass30_0& );
    [CompilerGeneratedAttribute]
private string <InternalRestore>g__GetFolderSddl|30_2(string path, <>c__DisplayClass30_0& );
}
public class Microsoft.Win32.TaskScheduler.TaskSecurity : CommonObjectSecurity {
    public Type AccessRightType { get; }
    public Type AccessRuleType { get; }
    public Type AuditRuleType { get; }
    public static TaskSecurity DefaultTaskSecurity { get; }
    public TaskSecurity(Task task, AccessControlSections sections);
    public TaskSecurity(TaskFolder folder, AccessControlSections sections);
    public virtual Type get_AccessRightType();
    public virtual Type get_AccessRuleType();
    public virtual Type get_AuditRuleType();
    public static TaskSecurity get_DefaultTaskSecurity();
    public virtual AccessRule AccessRuleFactory(IdentityReference identityReference, int accessMask, bool isInherited, InheritanceFlags inheritanceFlags, PropagationFlags propagationFlags, AccessControlType type);
    public void AddAccessRule(TaskAccessRule rule);
    public void AddAuditRule(TaskAuditRule rule);
    public virtual AuditRule AuditRuleFactory(IdentityReference identityReference, int accessMask, bool isInherited, InheritanceFlags inheritanceFlags, PropagationFlags propagationFlags, AuditFlags flags);
    public bool RemoveAccessRule(TaskAccessRule rule);
    public void RemoveAccessRuleAll(TaskAccessRule rule);
    public void RemoveAccessRuleSpecific(TaskAccessRule rule);
    public bool RemoveAuditRule(TaskAuditRule rule);
    public void RemoveAuditRuleAll(TaskAuditRule rule);
    public void RemoveAuditRuleSpecific(TaskAuditRule rule);
    public void ResetAccessRule(TaskAccessRule rule);
    public void SetAccessRule(TaskAccessRule rule);
    public void SetAuditRule(TaskAuditRule rule);
    public virtual string ToString();
    private static SecurityInfos Convert(AccessControlSections si);
    private static AccessControlSections Convert(SecurityInfos si);
    private AccessControlSections GetAccessControlSectionsFromChanges();
    [SecurityCriticalAttribute]
internal void Persist(Task task, AccessControlSections includeSections);
    [SecurityCriticalAttribute]
internal void Persist(TaskFolder folder, AccessControlSections includeSections);
    protected virtual void Persist(string name, AccessControlSections includeSections);
}
[DescriptionAttribute("Provides access to the Task Scheduler service.")]
[ToolboxItemAttribute("True")]
public class Microsoft.Win32.TaskScheduler.TaskService : Component {
    internal static bool LibraryIsV2;
    internal static Guid PowerShellActionGuid;
    private static Guid CLSID_Ctask;
    private static Guid IID_ITask;
    [ThreadStaticAttribute]
private static TaskService instance;
    private static Version osLibVer;
    internal ITaskScheduler v1TaskScheduler;
    internal ITaskService v2TaskService;
    private bool connecting;
    private bool forceV1;
    private bool initializing;
    private Version maxVer;
    private bool maxVerSet;
    private string targetServer;
    private bool targetServerSet;
    private string userDomain;
    private bool userDomainSet;
    private string userName;
    private bool userNameSet;
    private string userPassword;
    private SecureString userSecurePassword;
    private bool userPasswordSet;
    private WindowsImpersonatedIdentity v1Impersonation;
    [CompilerGeneratedAttribute]
private EventHandler ServiceConnected;
    [CompilerGeneratedAttribute]
private EventHandler ServiceDisconnected;
    [CompilerGeneratedAttribute]
private static Version <LibraryVersion>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <AllowReadOnlyTasks>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <CanRaiseEvents>k__BackingField;
    public static TaskService Instance { get; }
    [BrowsableAttribute("False")]
public static Version LibraryVersion { get; }
    [DefaultValueAttribute("False")]
[CategoryAttribute("Behavior")]
[DescriptionAttribute("Allow tasks from later OS versions with new properties to be retrieved as read only tasks.")]
public bool AllowReadOnlyTasks { get; public set; }
    [BrowsableAttribute("False")]
[DefaultValueAttribute("")]
[ObsoleteAttribute("This property has been superseded by the UserAccountDomin property and may not be available in future releases.")]
public string ConnectedDomain { get; }
    [BrowsableAttribute("False")]
[DefaultValueAttribute("")]
[ObsoleteAttribute("This property has been superseded by the UserName property and may not be available in future releases.")]
public string ConnectedUser { get; }
    [CategoryAttribute("Data")]
[TypeConverterAttribute("Microsoft.Win32.TaskScheduler.TaskService/VersionConverter")]
[DescriptionAttribute("Highest version of library that should be used.")]
public Version HighestSupportedVersion { get; public set; }
    [BrowsableAttribute("False")]
public TaskFolder RootFolder { get; }
    [CategoryAttribute("Data")]
[DefaultValueAttribute("")]
[DescriptionAttribute("The name of the computer to connect to.")]
public string TargetServer { get; public set; }
    [CategoryAttribute("Data")]
[DefaultValueAttribute("")]
[DescriptionAttribute("The user account domain to be used when connecting.")]
public string UserAccountDomain { get; public set; }
    [CategoryAttribute("Data")]
[DefaultValueAttribute("")]
[DescriptionAttribute("The user name to be used when connecting.")]
public string UserName { get; public set; }
    [CategoryAttribute("Data")]
[DefaultValueAttribute("")]
[DescriptionAttribute("The user password to be used when connecting.")]
public string UserPassword { get; public set; }
    internal string UserPasswordPlainText { get; }
    [BrowsableAttribute("False")]
public IEnumerable`1<Task> AllTasks { get; }
    [BrowsableAttribute("False")]
public bool Connected { get; }
    public ConnectionToken Token { get; }
    protected bool CanRaiseEvents { get; }
    public TaskService(string targetServer, string userName, string accountDomain, string password, bool forceV1);
    public TaskService(string targetServer, string userName, string accountDomain, SecureString userSecurePassword, bool forceV1);
    private TaskService(SerializationInfo info, StreamingContext context);
    private static TaskService();
    [CompilerGeneratedAttribute]
public void add_ServiceConnected(EventHandler value);
    [CompilerGeneratedAttribute]
public void remove_ServiceConnected(EventHandler value);
    [CompilerGeneratedAttribute]
public void add_ServiceDisconnected(EventHandler value);
    [CompilerGeneratedAttribute]
public void remove_ServiceDisconnected(EventHandler value);
    public static TaskService get_Instance();
    [CompilerGeneratedAttribute]
public static Version get_LibraryVersion();
    [CompilerGeneratedAttribute]
public bool get_AllowReadOnlyTasks();
    [CompilerGeneratedAttribute]
public void set_AllowReadOnlyTasks(bool value);
    public string get_ConnectedDomain();
    public string get_ConnectedUser();
    public Version get_HighestSupportedVersion();
    public void set_HighestSupportedVersion(Version value);
    public TaskFolder get_RootFolder();
    public string get_TargetServer();
    public void set_TargetServer(string value);
    public string get_UserAccountDomain();
    public void set_UserAccountDomain(string value);
    public string get_UserName();
    public void set_UserName(string value);
    public string get_UserPassword();
    public void set_UserPassword(string value);
    internal string get_UserPasswordPlainText();
    public IEnumerable`1<Task> get_AllTasks();
    public bool get_Connected();
    public ConnectionToken get_Token();
    [CompilerGeneratedAttribute]
protected virtual bool get_CanRaiseEvents();
    public static TaskService CreateFromToken(ConnectionToken token);
    public static string GetDllResourceString(string dllPath, int resourceId);
    public static int RunComHandlerAction(Guid clsid, string data, int millisecondsTimeout, ComHandlerUpdate onUpdate);
    public static void RunComHandlerActionAsync(Guid clsid, Action`1<int> onComplete, string data, int millisecondsTimeout, ComHandlerUpdate onUpdate);
    public Task AddAutomaticMaintenanceTask(string taskPathAndName, TimeSpan period, TimeSpan deadline, string executablePath, string arguments, string workingDirectory);
    public Task AddTask(string path, Trigger trigger, Action action, string userId, string password, TaskLogonType logonType, string description);
    public Task AddTask(string path, QuickTriggerType trigger, string exePath, string arguments, string userId, string password, TaskLogonType logonType, string description);
    public sealed virtual void BeginInit();
    public sealed virtual void EndInit();
    public virtual bool Equals(object obj);
    public Task[] FindAllTasks(Regex name, bool searchAllFolders);
    public Task[] FindAllTasks(Predicate`1<Task> filter, bool searchAllFolders);
    public Task FindTask(string name, bool searchAllFolders);
    public TaskEventLog GetEventLog(string taskPath);
    public TaskFolder GetFolder(string folderName);
    public virtual int GetHashCode();
    public RunningTaskCollection GetRunningTasks(bool includeHidden);
    public Task GetTask(string taskPath);
    public TaskDefinition NewTask();
    public TaskDefinition NewTaskFromFile(string xmlFile);
    public void SetUserSecurePassword(SecureString value);
    public void StartSystemTaskSchedulerManager();
    [SecurityCriticalAttribute]
private sealed virtual override void System.Runtime.Serialization.ISerializable.GetObjectData(SerializationInfo info, StreamingContext context);
    internal static IRegisteredTask GetTask(ITaskService iSvc, string name);
    internal static ITask GetTask(ITaskScheduler iSvc, string name);
    protected virtual void Dispose(bool disposing);
    private static Version GetLibraryVersionFromLocalOS();
    private static void Instance_ServiceDisconnected(object sender, EventArgs e);
    private void Connect();
    private static void FindTaskInFolder(TaskFolder fld, Regex taskName, List`1& results, bool recurse);
    private Version GetV2Version();
    private void ResetHighestSupportedVersion();
    private void ResetUnsetProperties();
    private bool ShouldSerializeHighestSupportedVersion();
    private bool ShouldSerializeTargetServer();
    private bool ShouldSerializeUserAccountDomain();
    private bool ShouldSerializeUserName();
    public ActionBuilder Execute(string path);
}
public static class Microsoft.Win32.TaskScheduler.TaskServiceVersion : object {
    [DescriptionAttribute("Task Scheduler 1.0 (Windows Server 2003, Windows XP, or Windows 2000).")]
public static Version V1_1;
    [DescriptionAttribute("Task Scheduler 2.0 (Windows Vista, Windows Server 2008).")]
public static Version V1_2;
    [DescriptionAttribute("Task Scheduler 2.1 (Windows 7, Windows Server 2008 R2).")]
public static Version V1_3;
    [DescriptionAttribute("Task Scheduler 2.2 (Windows 8.x, Windows Server 2012).")]
public static Version V1_4;
    [DescriptionAttribute("Task Scheduler 2.3 (Windows 10, Windows Server 2016).")]
public static Version V1_5;
    [DescriptionAttribute("Task Scheduler 2.3 (Windows 10, Windows Server 2016 post build 1703).")]
public static Version V1_6;
    private static TaskServiceVersion();
}
public enum Microsoft.Win32.TaskScheduler.TaskSessionStateChangeType : Enum {
    public int value__;
    public static TaskSessionStateChangeType ConsoleConnect;
    public static TaskSessionStateChangeType ConsoleDisconnect;
    public static TaskSessionStateChangeType RemoteConnect;
    public static TaskSessionStateChangeType RemoteDisconnect;
    public static TaskSessionStateChangeType SessionLock;
    public static TaskSessionStateChangeType SessionUnlock;
}
[FlagsAttribute]
public enum Microsoft.Win32.TaskScheduler.TaskSetSecurityOptions : Enum {
    public int value__;
    public static TaskSetSecurityOptions None;
    public static TaskSetSecurityOptions DontAddPrincipalAce;
}
[XmlRootAttribute("Settings")]
[PublicAPIAttribute]
public class Microsoft.Win32.TaskScheduler.TaskSettings : object {
    private static UInt32 InfiniteRunTimeV1;
    private ITaskSettings v2Settings;
    private ITaskSettings2 v2Settings2;
    private ITaskSettings3 v2Settings3;
    private IdleSettings idleSettings;
    private MaintenanceSettings maintenanceSettings;
    private NetworkSettings networkSettings;
    private ITask v1Task;
    [CompilerGeneratedAttribute]
private PropertyChangedEventHandler PropertyChanged;
    [DefaultValueAttribute("True")]
[XmlElementAttribute("AllowStartOnDemand")]
[XmlIgnoreAttribute]
public bool AllowDemandStart { get; public set; }
    [DefaultValueAttribute("True")]
[XmlIgnoreAttribute]
public bool AllowHardTerminate { get; public set; }
    [XmlIgnoreAttribute]
public TaskCompatibility Compatibility { get; public set; }
    [DefaultValueAttribute("System.TimeSpan", "12:00:00")]
public TimeSpan DeleteExpiredTaskAfter { get; public set; }
    [DefaultValueAttribute("True")]
public bool DisallowStartIfOnBatteries { get; public set; }
    [DefaultValueAttribute("False")]
[XmlIgnoreAttribute]
public bool DisallowStartOnRemoteAppSession { get; public set; }
    [DefaultValueAttribute("True")]
public bool Enabled { get; public set; }
    [DefaultValueAttribute("System.TimeSpan", "3")]
public TimeSpan ExecutionTimeLimit { get; public set; }
    [DefaultValueAttribute("False")]
public bool Hidden { get; public set; }
    [XmlIgnoreAttribute]
[NotNullAttribute]
public MaintenanceSettings MaintenanceSettings { get; }
    [DefaultValueAttribute("Microsoft.Win32.TaskScheduler.TaskInstancesPolicy", "IgnoreNew")]
[XmlIgnoreAttribute]
public TaskInstancesPolicy MultipleInstances { get; public set; }
    [DefaultValueAttribute("System.Diagnostics.ProcessPriorityClass", "Normal")]
public ProcessPriorityClass Priority { get; public set; }
    [DefaultValueAttribute("0")]
[XmlIgnoreAttribute]
public int RestartCount { get; public set; }
    [DefaultValueAttribute("System.TimeSpan", "00:00:00")]
[XmlIgnoreAttribute]
public TimeSpan RestartInterval { get; public set; }
    [DefaultValueAttribute("False")]
public bool RunOnlyIfIdle { get; public set; }
    [XmlIgnoreAttribute]
public bool RunOnlyIfLoggedOn { get; public set; }
    [DefaultValueAttribute("False")]
public bool RunOnlyIfNetworkAvailable { get; public set; }
    [DefaultValueAttribute("False")]
[XmlIgnoreAttribute]
public bool StartWhenAvailable { get; public set; }
    [DefaultValueAttribute("True")]
public bool StopIfGoingOnBatteries { get; public set; }
    [DefaultValueAttribute("False")]
[XmlIgnoreAttribute]
public bool UseUnifiedSchedulingEngine { get; public set; }
    [DefaultValueAttribute("False")]
[XmlIgnoreAttribute]
public bool Volatile { get; public set; }
    [DefaultValueAttribute("False")]
public bool WakeToRun { get; public set; }
    [XmlIgnoreAttribute]
public string XmlText { get; public set; }
    [NotNullAttribute]
public IdleSettings IdleSettings { get; }
    [XmlIgnoreAttribute]
[NotNullAttribute]
public NetworkSettings NetworkSettings { get; }
    internal TaskSettings(ITaskSettings iSettings);
    internal TaskSettings(ITask iTask);
    [CompilerGeneratedAttribute]
public sealed virtual void add_PropertyChanged(PropertyChangedEventHandler value);
    [CompilerGeneratedAttribute]
public sealed virtual void remove_PropertyChanged(PropertyChangedEventHandler value);
    public bool get_AllowDemandStart();
    public void set_AllowDemandStart(bool value);
    public bool get_AllowHardTerminate();
    public void set_AllowHardTerminate(bool value);
    public TaskCompatibility get_Compatibility();
    public void set_Compatibility(TaskCompatibility value);
    public TimeSpan get_DeleteExpiredTaskAfter();
    public void set_DeleteExpiredTaskAfter(TimeSpan value);
    public bool get_DisallowStartIfOnBatteries();
    public void set_DisallowStartIfOnBatteries(bool value);
    public bool get_DisallowStartOnRemoteAppSession();
    public void set_DisallowStartOnRemoteAppSession(bool value);
    public bool get_Enabled();
    public void set_Enabled(bool value);
    public TimeSpan get_ExecutionTimeLimit();
    public void set_ExecutionTimeLimit(TimeSpan value);
    public bool get_Hidden();
    public void set_Hidden(bool value);
    public MaintenanceSettings get_MaintenanceSettings();
    public TaskInstancesPolicy get_MultipleInstances();
    public void set_MultipleInstances(TaskInstancesPolicy value);
    public ProcessPriorityClass get_Priority();
    public void set_Priority(ProcessPriorityClass value);
    public int get_RestartCount();
    public void set_RestartCount(int value);
    public TimeSpan get_RestartInterval();
    public void set_RestartInterval(TimeSpan value);
    public bool get_RunOnlyIfIdle();
    public void set_RunOnlyIfIdle(bool value);
    public bool get_RunOnlyIfLoggedOn();
    public void set_RunOnlyIfLoggedOn(bool value);
    public bool get_RunOnlyIfNetworkAvailable();
    public void set_RunOnlyIfNetworkAvailable(bool value);
    public bool get_StartWhenAvailable();
    public void set_StartWhenAvailable(bool value);
    public bool get_StopIfGoingOnBatteries();
    public void set_StopIfGoingOnBatteries(bool value);
    public bool get_UseUnifiedSchedulingEngine();
    public void set_UseUnifiedSchedulingEngine(bool value);
    public bool get_Volatile();
    public void set_Volatile(bool value);
    public bool get_WakeToRun();
    public void set_WakeToRun(bool value);
    public string get_XmlText();
    public void set_XmlText(string value);
    public IdleSettings get_IdleSettings();
    public NetworkSettings get_NetworkSettings();
    public sealed virtual void Dispose();
    public virtual string ToString();
    private sealed virtual override XmlSchema System.Xml.Serialization.IXmlSerializable.GetSchema();
    private sealed virtual override void System.Xml.Serialization.IXmlSerializable.ReadXml(XmlReader reader);
    private sealed virtual override void System.Xml.Serialization.IXmlSerializable.WriteXml(XmlWriter writer);
    private bool ConvertXmlProperty(PropertyInfo pi, object obj, Object& value);
    private int GetPriorityAsInt(ProcessPriorityClass value);
    private ProcessPriorityClass GetPriorityFromInt(int value);
    private void OnNotifyPropertyChanged(string propertyName);
}
public class Microsoft.Win32.TaskScheduler.TaskSnapshot : SnapshotItem {
    [CompilerGeneratedAttribute]
private bool <Enabled>k__BackingField;
    [CompilerGeneratedAttribute]
private string <TaskDefinitionXml>k__BackingField;
    public bool Enabled { get; internal set; }
    public string TaskDefinitionXml { get; internal set; }
    internal TaskSnapshot(string path, string sddl, bool enabled, string xml);
    [CompilerGeneratedAttribute]
public bool get_Enabled();
    [CompilerGeneratedAttribute]
internal void set_Enabled(bool value);
    [CompilerGeneratedAttribute]
public string get_TaskDefinitionXml();
    [CompilerGeneratedAttribute]
internal void set_TaskDefinitionXml(string value);
}
public enum Microsoft.Win32.TaskScheduler.TaskState : Enum {
    public int value__;
    public static TaskState Unknown;
    public static TaskState Disabled;
    public static TaskState Queued;
    public static TaskState Ready;
    public static TaskState Running;
}
[DefaultValueAttribute("Mono.Cecil.CustomAttributeArgument")]
public enum Microsoft.Win32.TaskScheduler.TaskTriggerType : Enum {
    public int value__;
    public static TaskTriggerType Event;
    public static TaskTriggerType Time;
    public static TaskTriggerType Daily;
    public static TaskTriggerType Weekly;
    public static TaskTriggerType Monthly;
    public static TaskTriggerType MonthlyDOW;
    public static TaskTriggerType Idle;
    public static TaskTriggerType Registration;
    public static TaskTriggerType Boot;
    public static TaskTriggerType Logon;
    public static TaskTriggerType SessionStateChange;
    public static TaskTriggerType Custom;
}
public class Microsoft.Win32.TaskScheduler.TimeTrigger : Trigger {
    [DefaultValueAttribute("System.TimeSpan", "00:00:00")]
[XmlIgnoreAttribute]
public TimeSpan RandomDelay { get; public set; }
    private TimeSpan Microsoft.Win32.TaskScheduler.ITriggerDelay.Delay { get; private set; }
    public TimeTrigger(DateTime startBoundary);
    internal TimeTrigger(ITaskTrigger iTrigger);
    internal TimeTrigger(ITrigger iTrigger);
    public TimeSpan get_RandomDelay();
    public void set_RandomDelay(TimeSpan value);
    private sealed virtual override TimeSpan Microsoft.Win32.TaskScheduler.ITriggerDelay.get_Delay();
    private sealed virtual override void Microsoft.Win32.TaskScheduler.ITriggerDelay.set_Delay(TimeSpan value);
    protected virtual string V2GetTriggerString();
}
public abstract class Microsoft.Win32.TaskScheduler.Trigger : object {
    internal static string V2BoundaryDateFormat;
    internal static CultureInfo DefaultDateCulture;
    internal ITaskTrigger v1Trigger;
    internal TaskTrigger v1TriggerData;
    internal ITrigger v2Trigger;
    protected Dictionary`2<string, object> unboundValues;
    private static Nullable`1<bool> foundTimeSpan2;
    private static Type timeSpan2Type;
    private TaskTriggerType ttype;
    private RepetitionPattern repititionPattern;
    [CompilerGeneratedAttribute]
private PropertyChangedEventHandler PropertyChanged;
    public bool Enabled { get; public set; }
    [DefaultValueAttribute("System.DateTime", "9999-12-31T23:59:59.9999999")]
public DateTime EndBoundary { get; public set; }
    [DefaultValueAttribute("System.TimeSpan", "00:00:00")]
[XmlIgnoreAttribute]
public TimeSpan ExecutionTimeLimit { get; public set; }
    [DefaultValueAttribute("")]
[XmlIgnoreAttribute]
public string Id { get; public set; }
    public RepetitionPattern Repetition { get; public set; }
    public DateTime StartBoundary { get; public set; }
    [XmlIgnoreAttribute]
public TaskTriggerType TriggerType { get; }
    internal Trigger(ITaskTrigger trigger, TaskTriggerType type);
    internal Trigger(ITrigger iTrigger);
    internal Trigger(TaskTriggerType triggerType);
    private static Trigger();
    public static Trigger[] FromCronFormat(string cronString);
    [IteratorStateMachineAttribute("Microsoft.Win32.TaskScheduler.Trigger/<ProcessCronTimes>d__1")]
private static IEnumerable`1<Trigger> ProcessCronTimes(CronExpression cron, Trigger baseTrigger);
    [CompilerGeneratedAttribute]
public sealed virtual void add_PropertyChanged(PropertyChangedEventHandler value);
    [CompilerGeneratedAttribute]
public sealed virtual void remove_PropertyChanged(PropertyChangedEventHandler value);
    public bool get_Enabled();
    public void set_Enabled(bool value);
    public DateTime get_EndBoundary();
    public void set_EndBoundary(DateTime value);
    public TimeSpan get_ExecutionTimeLimit();
    public void set_ExecutionTimeLimit(TimeSpan value);
    public string get_Id();
    public void set_Id(string value);
    public RepetitionPattern get_Repetition();
    public void set_Repetition(RepetitionPattern value);
    public DateTime get_StartBoundary();
    public void set_StartBoundary(DateTime value);
    public TaskTriggerType get_TriggerType();
    public static Trigger CreateTrigger(TaskTriggerType triggerType);
    public virtual object Clone();
    public sealed virtual int CompareTo(Trigger other);
    public virtual void CopyProperties(Trigger sourceTrigger);
    public virtual void Dispose();
    public virtual bool Equals(object obj);
    public virtual bool Equals(Trigger other);
    public virtual int GetHashCode();
    [ObsoleteAttribute("Set the Repetition property directly with a new instance of RepetitionPattern.", "False")]
public void SetRepetition(TimeSpan interval, TimeSpan duration, bool stopAtDurationEnd);
    public virtual string ToString();
    public virtual string ToString(CultureInfo culture);
    private sealed virtual override int System.IComparable.CompareTo(object obj);
    internal static DateTime AdjustToLocal(DateTime dt);
    internal static TaskTriggerType ConvertToV1TriggerType(TaskTriggerType type);
    internal static Trigger CreateTrigger(ITaskTrigger trigger);
    internal static Trigger CreateTrigger(ITaskTrigger trigger, TaskTriggerType triggerType);
    internal static Trigger CreateTrigger(ITrigger iTrigger, ITaskDefinition iDef);
    internal static string GetBestTimeSpanString(TimeSpan span);
    internal virtual void Bind(ITask iTask);
    internal virtual void Bind(ITaskDefinition iTaskDef);
    internal void SetV1TriggerData();
    protected virtual void CheckBindValue(string key, Object& o);
    protected T GetUnboundValueOrDefault(string prop, T def);
    protected void OnNotifyPropertyChanged(string propertyName);
    protected virtual string V2GetTriggerString();
    private static TaskTriggerType ConvertFromV1TriggerType(TaskTriggerType v1Type);
    private string V2BaseTriggerString();
    [CompilerGeneratedAttribute]
internal static Trigger <ProcessCronTimes>g__MakeTrigger|1_0(TimeSpan start, TimeSpan interval, TimeSpan duration, <>c__DisplayClass1_0& );
}
[DefaultMemberAttribute("Item")]
[XmlRootAttribute("Triggers")]
public class Microsoft.Win32.TaskScheduler.TriggerCollection : object {
    private static string IndexerName;
    private ITriggerCollection v2Coll;
    private bool inV2set;
    private ITask v1Task;
    private ITaskDefinition v2Def;
    [CompilerGeneratedAttribute]
private NotifyCollectionChangedEventHandler CollectionChanged;
    [CompilerGeneratedAttribute]
private PropertyChangedEventHandler PropertyChanged;
    public int Count { get; }
    private bool System.Collections.IList.IsFixedSize { get; }
    private bool System.Collections.Generic.ICollection<Microsoft.Win32.TaskScheduler.Trigger>.IsReadOnly { get; }
    private bool System.Collections.IList.IsReadOnly { get; }
    private bool System.Collections.ICollection.IsSynchronized { get; }
    private object System.Collections.ICollection.SyncRoot { get; }
    public Trigger Item { get; public set; }
    public Trigger Item { get; public set; }
    private object System.Collections.IList.Item { get; private set; }
    internal TriggerCollection(ITask iTask);
    internal TriggerCollection(ITaskDefinition iTaskDef);
    [CompilerGeneratedAttribute]
public sealed virtual void add_CollectionChanged(NotifyCollectionChangedEventHandler value);
    [CompilerGeneratedAttribute]
public sealed virtual void remove_CollectionChanged(NotifyCollectionChangedEventHandler value);
    [CompilerGeneratedAttribute]
public sealed virtual void add_PropertyChanged(PropertyChangedEventHandler value);
    [CompilerGeneratedAttribute]
public sealed virtual void remove_PropertyChanged(PropertyChangedEventHandler value);
    public sealed virtual int get_Count();
    private sealed virtual override bool System.Collections.IList.get_IsFixedSize();
    private sealed virtual override bool System.Collections.Generic.ICollection<Microsoft.Win32.TaskScheduler.Trigger>.get_IsReadOnly();
    private sealed virtual override bool System.Collections.IList.get_IsReadOnly();
    private sealed virtual override bool System.Collections.ICollection.get_IsSynchronized();
    private sealed virtual override object System.Collections.ICollection.get_SyncRoot();
    public Trigger get_Item(string triggerId);
    public void set_Item(string triggerId, Trigger value);
    public sealed virtual Trigger get_Item(int index);
    public sealed virtual void set_Item(int index, Trigger value);
    private sealed virtual override object System.Collections.IList.get_Item(int index);
    private sealed virtual override void System.Collections.IList.set_Item(int index, object value);
    public TTrigger Add(TTrigger unboundTrigger);
    public Trigger AddNew(TaskTriggerType taskTriggerType);
    public void AddRange(IEnumerable`1<Trigger> triggers);
    public sealed virtual void Clear();
    public sealed virtual bool Contains(Trigger item);
    public bool ContainsType(Type triggerType);
    public sealed virtual void CopyTo(Trigger[] array, int arrayIndex);
    public void CopyTo(int index, Trigger[] array, int arrayIndex, int count);
    public sealed virtual void Dispose();
    public Trigger Find(Predicate`1<Trigger> match);
    public int FindIndexOf(int startIndex, int count, Predicate`1<Trigger> match);
    public int FindIndexOf(Predicate`1<Trigger> match);
    public sealed virtual IEnumerator`1<Trigger> GetEnumerator();
    public sealed virtual int IndexOf(Trigger item);
    public int IndexOf(string triggerId);
    public sealed virtual void Insert(int index, Trigger trigger);
    public sealed virtual bool Remove(Trigger item);
    public sealed virtual void RemoveAt(int index);
    public Trigger[] ToArray();
    public virtual string ToString();
    private sealed virtual override void System.Collections.Generic.ICollection<Microsoft.Win32.TaskScheduler.Trigger>.Add(Trigger item);
    private sealed virtual override int System.Collections.IList.Add(object value);
    private sealed virtual override bool System.Collections.IList.Contains(object value);
    private sealed virtual override void System.Collections.ICollection.CopyTo(Array array, int index);
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
    private sealed virtual override XmlSchema System.Xml.Serialization.IXmlSerializable.GetSchema();
    private sealed virtual override int System.Collections.IList.IndexOf(object value);
    private sealed virtual override void System.Collections.IList.Insert(int index, object value);
    private sealed virtual override void System.Xml.Serialization.IXmlSerializable.ReadXml(XmlReader reader);
    private sealed virtual override void System.Collections.IList.Remove(object value);
    private sealed virtual override void System.Xml.Serialization.IXmlSerializable.WriteXml(XmlWriter writer);
    internal void Bind();
    private void OnNotifyPropertyChanged(string propertyName);
    [CompilerGeneratedAttribute]
private int <GetEnumerator>b__46_0();
    [CompilerGeneratedAttribute]
private ITrigger <GetEnumerator>b__46_1(int i);
    [CompilerGeneratedAttribute]
private Trigger <GetEnumerator>b__46_2(ITrigger o);
}
[ExtensionAttribute]
internal static class Microsoft.Win32.TaskScheduler.TSInteropExt : object {
    [ExtensionAttribute]
public static string GetDataItem(ITask v1Task, string name);
    [ExtensionAttribute]
public static bool HasFlags(ITask v1Task, TaskFlags flags);
    [ExtensionAttribute]
public static void SetDataItem(ITask v1Task, string name, string value);
    [ExtensionAttribute]
public static void SetFlags(ITask v1Task, TaskFlags flags, bool value);
}
[DebuggerStepThroughAttribute]
[PublicAPIAttribute]
public abstract class Microsoft.Win32.TaskScheduler.TSNotSupportedException : Exception {
    protected TaskCompatibility min;
    private string myMessage;
    public string Message { get; }
    public TaskCompatibility MinimumSupportedVersion { get; }
    internal string LibName { get; }
    protected TSNotSupportedException(SerializationInfo serializationInfo, StreamingContext streamingContext);
    internal TSNotSupportedException(TaskCompatibility minComp);
    internal TSNotSupportedException(string message, TaskCompatibility minComp);
    public virtual string get_Message();
    public TaskCompatibility get_MinimumSupportedVersion();
    internal abstract virtual string get_LibName();
    [SecurityCriticalAttribute]
public virtual void GetObjectData(SerializationInfo info, StreamingContext context);
}
internal class Microsoft.Win32.TaskScheduler.User : object {
    private static WindowsIdentity cur;
    private SecurityIdentifier sid;
    [CompilerGeneratedAttribute]
private WindowsIdentity <Identity>k__BackingField;
    public static User Current { get; }
    public WindowsIdentity Identity { get; private set; }
    public bool IsAdmin { get; }
    public bool IsCurrent { get; }
    public bool IsServiceAccount { get; }
    public bool IsSystem { get; }
    public string SidString { get; }
    public string Name { get; }
    public User(string userName);
    internal User(WindowsIdentity wid);
    private static User();
    public static User get_Current();
    [CompilerGeneratedAttribute]
public WindowsIdentity get_Identity();
    [CompilerGeneratedAttribute]
private void set_Identity(WindowsIdentity value);
    public bool get_IsAdmin();
    public bool get_IsCurrent();
    public bool get_IsServiceAccount();
    public bool get_IsSystem();
    public string get_SidString();
    public string get_Name();
    public static User FromSidString(string sid);
    public sealed virtual void Dispose();
    public virtual bool Equals(object obj);
    public sealed virtual bool Equals(User other);
    public virtual int GetHashCode();
    [CompilerGeneratedAttribute]
internal static string <.ctor>g__GetUser|2_0(string domUser);
}
internal class Microsoft.Win32.TaskScheduler.V1Interop.CoTaskMemString : SafeHandle {
    public bool IsInvalid { get; }
    public CoTaskMemString(IntPtr handle);
    public CoTaskMemString(string text);
    public static string op_Implicit(CoTaskMemString cmem);
    public virtual bool get_IsInvalid();
    protected virtual bool ReleaseHandle();
    public virtual string ToString();
}
[GuidAttribute("148BD520-A2AB-11CE-B11F-00AA00530503")]
[SuppressUnmanagedCodeSecurityAttribute]
[ClassInterfaceAttribute("0")]
internal class Microsoft.Win32.TaskScheduler.V1Interop.CTask : object {
}
[GuidAttribute("148BD52A-A2AB-11CE-B11F-00AA00530503")]
[SuppressUnmanagedCodeSecurityAttribute]
[ClassInterfaceAttribute("0")]
internal class Microsoft.Win32.TaskScheduler.V1Interop.CTaskScheduler : object {
}
internal class Microsoft.Win32.TaskScheduler.V1Interop.Daily : ValueType {
    public ushort DaysInterval;
}
internal class Microsoft.Win32.TaskScheduler.V1Interop.HResult : object {
    public static int SCHED_S_TASK_READY;
    public static int SCHED_S_TASK_RUNNING;
    public static int SCHED_S_TASK_DISABLED;
    public static int SCHED_S_TASK_HAS_NOT_RUN;
    public static int SCHED_S_TASK_NO_MORE_RUNS;
    public static int SCHED_S_TASK_NOT_SCHEDULED;
    public static int SCHED_S_TASK_TERMINATED;
    public static int SCHED_S_TASK_NO_VALID_TRIGGERS;
    public static int SCHED_S_EVENT_TRIGGER;
    public static int SCHED_E_TRIGGER_NOT_FOUND;
    public static int SCHED_E_TASK_NOT_READY;
    public static int SCHED_E_TASK_NOT_RUNNING;
    public static int SCHED_E_SERVICE_NOT_INSTALLED;
    public static int SCHED_E_CANNOT_OPEN_TASK;
    public static int SCHED_E_INVALID_TASK;
    public static int SCHED_E_ACCOUNT_INFORMATION_NOT_SET;
    public static int SCHED_E_ACCOUNT_NAME_NOT_FOUND;
    public static int SCHED_E_ACCOUNT_DBASE_CORRUPT;
    public static int SCHED_E_NO_SECURITY_SERVICES;
    public static int SCHED_E_UNKNOWN_OBJECT_VERSION;
    public static int SCHED_E_UNSUPPORTED_ACCOUNT_OPTION;
    public static int SCHED_E_SERVICE_NOT_RUNNING;
    public static int SCHED_E_SERVICE_NOT_LOCALSYSTEM;
}
[GuidAttribute("148BD528-A2AB-11CE-B11F-00AA00530503")]
[InterfaceTypeAttribute("1")]
[SuppressUnmanagedCodeSecurityAttribute]
internal interface Microsoft.Win32.TaskScheduler.V1Interop.IEnumWorkItems {
    public abstract virtual int Next(UInt32 RequestCount, IntPtr& Names, UInt32& Fetched);
    public abstract virtual void Skip(UInt32 Count);
    public abstract virtual void Reset();
    public abstract virtual IEnumWorkItems Clone();
}
[GuidAttribute("148BD524-A2AB-11CE-B11F-00AA00530503")]
[InterfaceTypeAttribute("1")]
[SuppressUnmanagedCodeSecurityAttribute]
[CoClassAttribute("Microsoft.Win32.TaskScheduler.V1Interop.CTask")]
internal interface Microsoft.Win32.TaskScheduler.V1Interop.ITask {
    public abstract virtual ITaskTrigger CreateTrigger(UInt16& NewTriggerIndex);
    public abstract virtual void DeleteTrigger(ushort TriggerIndex);
    public abstract virtual ushort GetTriggerCount();
    public abstract virtual ITaskTrigger GetTrigger(ushort TriggerIndex);
    public abstract virtual CoTaskMemString GetTriggerString(ushort TriggerIndex);
    public abstract virtual void GetRunTimes(SYSTEMTIME& Begin, SYSTEMTIME& End, UInt16& Count, IntPtr& TaskTimes);
    public abstract virtual SYSTEMTIME GetNextRunTime();
    public abstract virtual void SetIdleWait(ushort IdleMinutes, ushort DeadlineMinutes);
    public abstract virtual void GetIdleWait(UInt16& IdleMinutes, UInt16& DeadlineMinutes);
    public abstract virtual void Run();
    public abstract virtual void Terminate();
    public abstract virtual void EditWorkItem(IntPtr hParent, UInt32 dwReserved);
    public abstract virtual SYSTEMTIME GetMostRecentRunTime();
    public abstract virtual TaskStatus GetStatus();
    public abstract virtual UInt32 GetExitCode();
    public abstract virtual void SetComment(string Comment);
    public abstract virtual CoTaskMemString GetComment();
    public abstract virtual void SetCreator(string Creator);
    public abstract virtual CoTaskMemString GetCreator();
    public abstract virtual void SetWorkItemData(ushort DataLen, Byte[] Data);
    public abstract virtual void GetWorkItemData(UInt16& DataLen, IntPtr& Data);
    public abstract virtual void SetErrorRetryCount(ushort RetryCount);
    public abstract virtual ushort GetErrorRetryCount();
    public abstract virtual void SetErrorRetryInterval(ushort RetryInterval);
    public abstract virtual ushort GetErrorRetryInterval();
    public abstract virtual void SetFlags(TaskFlags Flags);
    public abstract virtual TaskFlags GetFlags();
    public abstract virtual void SetAccountInformation(string AccountName, IntPtr Password);
    public abstract virtual CoTaskMemString GetAccountInformation();
    public abstract virtual void SetApplicationName(string ApplicationName);
    public abstract virtual CoTaskMemString GetApplicationName();
    public abstract virtual void SetParameters(string Parameters);
    public abstract virtual CoTaskMemString GetParameters();
    public abstract virtual void SetWorkingDirectory(string WorkingDirectory);
    public abstract virtual CoTaskMemString GetWorkingDirectory();
    public abstract virtual void SetPriority(UInt32 Priority);
    public abstract virtual UInt32 GetPriority();
    public abstract virtual void SetTaskFlags(UInt32 Flags);
    public abstract virtual UInt32 GetTaskFlags();
    public abstract virtual void SetMaxRunTime(UInt32 MaxRunTimeMS);
    public abstract virtual UInt32 GetMaxRunTime();
}
[GuidAttribute("148BD527-A2AB-11CE-B11F-00AA00530503")]
[InterfaceTypeAttribute("1")]
[SuppressUnmanagedCodeSecurityAttribute]
[CoClassAttribute("Microsoft.Win32.TaskScheduler.V1Interop.CTaskScheduler")]
internal interface Microsoft.Win32.TaskScheduler.V1Interop.ITaskScheduler {
    public abstract virtual void SetTargetComputer(string Computer);
    public abstract virtual CoTaskMemString GetTargetComputer();
    public abstract virtual IEnumWorkItems Enum();
    public abstract virtual ITask Activate(string Name, Guid riid);
    public abstract virtual void Delete(string Name);
    public abstract virtual ITask NewWorkItem(string TaskName, Guid rclsid, Guid riid);
    public abstract virtual void AddWorkItem(string TaskName, ITask WorkItem);
    public abstract virtual void IsOfType(string TaskName, Guid riid);
}
[GuidAttribute("148BD52B-A2AB-11CE-B11F-00AA00530503")]
[InterfaceTypeAttribute("1")]
[SuppressUnmanagedCodeSecurityAttribute]
internal interface Microsoft.Win32.TaskScheduler.V1Interop.ITaskTrigger {
    public abstract virtual void SetTrigger(TaskTrigger& Trigger);
    public abstract virtual TaskTrigger GetTrigger();
    public abstract virtual CoTaskMemString GetTriggerString();
}
internal class Microsoft.Win32.TaskScheduler.V1Interop.MonthlyDate : ValueType {
    public UInt32 Days;
    public MonthsOfTheYear Months;
}
internal class Microsoft.Win32.TaskScheduler.V1Interop.MonthlyDOW : ValueType {
    public ushort WhichWeek;
    public DaysOfTheWeek DaysOfTheWeek;
    public MonthsOfTheYear Months;
    public WhichWeek V2WhichWeek { get; public set; }
    public WhichWeek get_V2WhichWeek();
    public void set_V2WhichWeek(WhichWeek value);
}
[FlagsAttribute]
internal enum Microsoft.Win32.TaskScheduler.V1Interop.TaskFlags : Enum {
    public int value__;
    public static TaskFlags Interactive;
    public static TaskFlags DeleteWhenDone;
    public static TaskFlags Disabled;
    public static TaskFlags StartOnlyIfIdle;
    public static TaskFlags KillOnIdleEnd;
    public static TaskFlags DontStartIfOnBatteries;
    public static TaskFlags KillIfGoingOnBatteries;
    public static TaskFlags RunOnlyIfDocked;
    public static TaskFlags Hidden;
    public static TaskFlags RunIfConnectedToInternet;
    public static TaskFlags RestartOnIdleResume;
    public static TaskFlags SystemRequired;
    public static TaskFlags RunOnlyIfLoggedOn;
}
internal enum Microsoft.Win32.TaskScheduler.V1Interop.TaskStatus : Enum {
    public int value__;
    public static TaskStatus Ready;
    public static TaskStatus Running;
    public static TaskStatus NotScheduled;
    public static TaskStatus NeverRun;
    public static TaskStatus Disabled;
    public static TaskStatus NoMoreRuns;
    public static TaskStatus Terminated;
    public static TaskStatus NoTriggers;
    public static TaskStatus NoTriggerTime;
}
internal class Microsoft.Win32.TaskScheduler.V1Interop.TaskTrigger : ValueType {
    public ushort TriggerSize;
    public ushort Reserved1;
    public ushort BeginYear;
    public ushort BeginMonth;
    public ushort BeginDay;
    public ushort EndYear;
    public ushort EndMonth;
    public ushort EndDay;
    public ushort StartHour;
    public ushort StartMinute;
    public UInt32 MinutesDuration;
    public UInt32 MinutesInterval;
    public TaskTriggerFlags Flags;
    public TaskTriggerType Type;
    public TriggerTypeData Data;
    public ushort Reserved2;
    public ushort RandomMinutesInterval;
    public DateTime BeginDate { get; public set; }
    public Nullable`1<DateTime> EndDate { get; public set; }
    public DateTime get_BeginDate();
    public void set_BeginDate(DateTime value);
    public Nullable`1<DateTime> get_EndDate();
    public void set_EndDate(Nullable`1<DateTime> value);
    public virtual string ToString();
}
[FlagsAttribute]
internal enum Microsoft.Win32.TaskScheduler.V1Interop.TaskTriggerFlags : Enum {
    public UInt32 value__;
    public static TaskTriggerFlags HasEndDate;
    public static TaskTriggerFlags KillAtDurationEnd;
    public static TaskTriggerFlags Disabled;
}
internal enum Microsoft.Win32.TaskScheduler.V1Interop.TaskTriggerType : Enum {
    public int value__;
    public static TaskTriggerType RunOnce;
    public static TaskTriggerType RunDaily;
    public static TaskTriggerType RunWeekly;
    public static TaskTriggerType RunMonthly;
    public static TaskTriggerType RunMonthlyDOW;
    public static TaskTriggerType OnIdle;
    public static TaskTriggerType OnSystemStart;
    public static TaskTriggerType OnLogon;
}
internal class Microsoft.Win32.TaskScheduler.V1Interop.TriggerTypeData : ValueType {
    public Daily daily;
    public Weekly weekly;
    public MonthlyDate monthlyDate;
    public MonthlyDOW monthlyDOW;
}
internal class Microsoft.Win32.TaskScheduler.V1Interop.Weekly : ValueType {
    public ushort WeeksInterval;
    public DaysOfTheWeek DaysOfTheWeek;
}
[GuidAttribute("BAE54997-48B1-4CBE-9965-D6BE263EBEA4")]
[InterfaceTypeAttribute("0")]
[SuppressUnmanagedCodeSecurityAttribute]
internal interface Microsoft.Win32.TaskScheduler.V2Interop.IAction {
    public string Id { get; public set; }
    public TaskActionType Type { get; }
    public abstract virtual string get_Id();
    public abstract virtual void set_Id(string value);
    public abstract virtual TaskActionType get_Type();
}
[DefaultMemberAttribute("Item")]
[GuidAttribute("02820E19-7B98-4ED2-B2E8-FDCCCEFF619B")]
[InterfaceTypeAttribute("0")]
[SuppressUnmanagedCodeSecurityAttribute]
internal interface Microsoft.Win32.TaskScheduler.V2Interop.IActionCollection {
    public int Count { get; }
    public IAction Item { get; }
    public string XmlText { get; public set; }
    public string Context { get; public set; }
    public abstract virtual int get_Count();
    public abstract virtual IAction get_Item(int index);
    public abstract virtual IEnumerator GetEnumerator();
    public abstract virtual string get_XmlText();
    public abstract virtual void set_XmlText(string value);
    public abstract virtual IAction Create(TaskActionType Type);
    public abstract virtual void Remove(object index);
    public abstract virtual void Clear();
    public abstract virtual string get_Context();
    public abstract virtual void set_Context(string value);
}
[GuidAttribute("2A9C35DA-D357-41F4-BBC1-207AC1B1F3CB")]
[InterfaceTypeAttribute("0")]
[SuppressUnmanagedCodeSecurityAttribute]
internal interface Microsoft.Win32.TaskScheduler.V2Interop.IBootTrigger {
    public TaskTriggerType Type { get; }
    public string Id { get; public set; }
    public IRepetitionPattern Repetition { get; public set; }
    public string ExecutionTimeLimit { get; public set; }
    public string StartBoundary { get; public set; }
    public string EndBoundary { get; public set; }
    public bool Enabled { get; public set; }
    public string Delay { get; public set; }
    public abstract virtual TaskTriggerType get_Type();
    public abstract virtual string get_Id();
    public abstract virtual void set_Id(string value);
    public abstract virtual IRepetitionPattern get_Repetition();
    public abstract virtual void set_Repetition(IRepetitionPattern value);
    public abstract virtual string get_ExecutionTimeLimit();
    public abstract virtual void set_ExecutionTimeLimit(string value);
    public abstract virtual string get_StartBoundary();
    public abstract virtual void set_StartBoundary(string value);
    public abstract virtual string get_EndBoundary();
    public abstract virtual void set_EndBoundary(string value);
    public abstract virtual bool get_Enabled();
    public abstract virtual void set_Enabled(bool value);
    public abstract virtual string get_Delay();
    public abstract virtual void set_Delay(string value);
}
[GuidAttribute("6D2FD252-75C5-4F66-90BA-2A7D8CC3039F")]
[InterfaceTypeAttribute("0")]
[SuppressUnmanagedCodeSecurityAttribute]
internal interface Microsoft.Win32.TaskScheduler.V2Interop.IComHandlerAction {
    public string Id { get; public set; }
    public TaskActionType Type { get; }
    public string ClassId { get; public set; }
    public string Data { get; public set; }
    public abstract virtual string get_Id();
    public abstract virtual void set_Id(string value);
    public abstract virtual TaskActionType get_Type();
    public abstract virtual string get_ClassId();
    public abstract virtual void set_ClassId(string value);
    public abstract virtual string get_Data();
    public abstract virtual void set_Data(string value);
}
[InterfaceTypeAttribute("0")]
[GuidAttribute("126C5CD8-B288-41D5-8DBF-E491446ADC5C")]
[SuppressUnmanagedCodeSecurityAttribute]
internal interface Microsoft.Win32.TaskScheduler.V2Interop.IDailyTrigger {
    public TaskTriggerType Type { get; }
    public string Id { get; public set; }
    public IRepetitionPattern Repetition { get; public set; }
    public string ExecutionTimeLimit { get; public set; }
    public string StartBoundary { get; public set; }
    public string EndBoundary { get; public set; }
    public bool Enabled { get; public set; }
    public short DaysInterval { get; public set; }
    public string RandomDelay { get; public set; }
    public abstract virtual TaskTriggerType get_Type();
    public abstract virtual string get_Id();
    public abstract virtual void set_Id(string value);
    public abstract virtual IRepetitionPattern get_Repetition();
    public abstract virtual void set_Repetition(IRepetitionPattern value);
    public abstract virtual string get_ExecutionTimeLimit();
    public abstract virtual void set_ExecutionTimeLimit(string value);
    public abstract virtual string get_StartBoundary();
    public abstract virtual void set_StartBoundary(string value);
    public abstract virtual string get_EndBoundary();
    public abstract virtual void set_EndBoundary(string value);
    public abstract virtual bool get_Enabled();
    public abstract virtual void set_Enabled(bool value);
    public abstract virtual short get_DaysInterval();
    public abstract virtual void set_DaysInterval(short value);
    public abstract virtual string get_RandomDelay();
    public abstract virtual void set_RandomDelay(string value);
}
[GuidAttribute("10F62C64-7E16-4314-A0C2-0C3683F99D40")]
[InterfaceTypeAttribute("0")]
[SuppressUnmanagedCodeSecurityAttribute]
internal interface Microsoft.Win32.TaskScheduler.V2Interop.IEmailAction {
    public string Id { get; public set; }
    public TaskActionType Type { get; }
    public string Server { get; public set; }
    public string Subject { get; public set; }
    public string To { get; public set; }
    public string Cc { get; public set; }
    public string Bcc { get; public set; }
    public string ReplyTo { get; public set; }
    public string From { get; public set; }
    public ITaskNamedValueCollection HeaderFields { get; public set; }
    public string Body { get; public set; }
    public Object[] Attachments { get; public set; }
    public abstract virtual string get_Id();
    public abstract virtual void set_Id(string value);
    public abstract virtual TaskActionType get_Type();
    public abstract virtual string get_Server();
    public abstract virtual void set_Server(string value);
    public abstract virtual string get_Subject();
    public abstract virtual void set_Subject(string value);
    public abstract virtual string get_To();
    public abstract virtual void set_To(string value);
    public abstract virtual string get_Cc();
    public abstract virtual void set_Cc(string value);
    public abstract virtual string get_Bcc();
    public abstract virtual void set_Bcc(string value);
    public abstract virtual string get_ReplyTo();
    public abstract virtual void set_ReplyTo(string value);
    public abstract virtual string get_From();
    public abstract virtual void set_From(string value);
    public abstract virtual ITaskNamedValueCollection get_HeaderFields();
    public abstract virtual void set_HeaderFields(ITaskNamedValueCollection value);
    public abstract virtual string get_Body();
    public abstract virtual void set_Body(string value);
    public abstract virtual Object[] get_Attachments();
    public abstract virtual void set_Attachments(Object[] value);
}
[GuidAttribute("D45B0167-9653-4EEF-B94F-0732CA7AF251")]
[InterfaceTypeAttribute("0")]
[SuppressUnmanagedCodeSecurityAttribute]
internal interface Microsoft.Win32.TaskScheduler.V2Interop.IEventTrigger {
    public TaskTriggerType Type { get; }
    public string Id { get; public set; }
    public IRepetitionPattern Repetition { get; public set; }
    public string ExecutionTimeLimit { get; public set; }
    public string StartBoundary { get; public set; }
    public string EndBoundary { get; public set; }
    public bool Enabled { get; public set; }
    public string Subscription { get; public set; }
    public string Delay { get; public set; }
    public ITaskNamedValueCollection ValueQueries { get; public set; }
    public abstract virtual TaskTriggerType get_Type();
    public abstract virtual string get_Id();
    public abstract virtual void set_Id(string value);
    public abstract virtual IRepetitionPattern get_Repetition();
    public abstract virtual void set_Repetition(IRepetitionPattern value);
    public abstract virtual string get_ExecutionTimeLimit();
    public abstract virtual void set_ExecutionTimeLimit(string value);
    public abstract virtual string get_StartBoundary();
    public abstract virtual void set_StartBoundary(string value);
    public abstract virtual string get_EndBoundary();
    public abstract virtual void set_EndBoundary(string value);
    public abstract virtual bool get_Enabled();
    public abstract virtual void set_Enabled(bool value);
    public abstract virtual string get_Subscription();
    public abstract virtual void set_Subscription(string value);
    public abstract virtual string get_Delay();
    public abstract virtual void set_Delay(string value);
    public abstract virtual ITaskNamedValueCollection get_ValueQueries();
    public abstract virtual void set_ValueQueries(ITaskNamedValueCollection value);
}
[GuidAttribute("4C3D624D-FD6B-49A3-B9B7-09CB3CD3F047")]
[InterfaceTypeAttribute("0")]
[SuppressUnmanagedCodeSecurityAttribute]
internal interface Microsoft.Win32.TaskScheduler.V2Interop.IExecAction {
    public string Id { get; public set; }
    public TaskActionType Type { get; }
    public string Path { get; public set; }
    public string Arguments { get; public set; }
    public string WorkingDirectory { get; public set; }
    public abstract virtual string get_Id();
    public abstract virtual void set_Id(string value);
    public abstract virtual TaskActionType get_Type();
    public abstract virtual string get_Path();
    public abstract virtual void set_Path(string value);
    public abstract virtual string get_Arguments();
    public abstract virtual void set_Arguments(string value);
    public abstract virtual string get_WorkingDirectory();
    public abstract virtual void set_WorkingDirectory(string value);
}
[GuidAttribute("84594461-0053-4342-A8FD-088FABF11F32")]
[InterfaceTypeAttribute("0")]
[SuppressUnmanagedCodeSecurityAttribute]
internal interface Microsoft.Win32.TaskScheduler.V2Interop.IIdleSettings {
    public string IdleDuration { get; public set; }
    public string WaitTimeout { get; public set; }
    public bool StopOnIdleEnd { get; public set; }
    public bool RestartOnIdle { get; public set; }
    public abstract virtual string get_IdleDuration();
    public abstract virtual void set_IdleDuration(string value);
    public abstract virtual string get_WaitTimeout();
    public abstract virtual void set_WaitTimeout(string value);
    public abstract virtual bool get_StopOnIdleEnd();
    public abstract virtual void set_StopOnIdleEnd(bool value);
    public abstract virtual bool get_RestartOnIdle();
    public abstract virtual void set_RestartOnIdle(bool value);
}
[GuidAttribute("D537D2B0-9FB3-4D34-9739-1FF5CE7B1EF3")]
[InterfaceTypeAttribute("0")]
[SuppressUnmanagedCodeSecurityAttribute]
internal interface Microsoft.Win32.TaskScheduler.V2Interop.IIdleTrigger {
    public TaskTriggerType Type { get; }
    public string Id { get; public set; }
    public IRepetitionPattern Repetition { get; public set; }
    public string ExecutionTimeLimit { get; public set; }
    public string StartBoundary { get; public set; }
    public string EndBoundary { get; public set; }
    public bool Enabled { get; public set; }
    public abstract virtual TaskTriggerType get_Type();
    public abstract virtual string get_Id();
    public abstract virtual void set_Id(string value);
    public abstract virtual IRepetitionPattern get_Repetition();
    public abstract virtual void set_Repetition(IRepetitionPattern value);
    public abstract virtual string get_ExecutionTimeLimit();
    public abstract virtual void set_ExecutionTimeLimit(string value);
    public abstract virtual string get_StartBoundary();
    public abstract virtual void set_StartBoundary(string value);
    public abstract virtual string get_EndBoundary();
    public abstract virtual void set_EndBoundary(string value);
    public abstract virtual bool get_Enabled();
    public abstract virtual void set_Enabled(bool value);
}
[GuidAttribute("72DADE38-FAE4-4B3E-BAF4-5D009AF02B1C")]
[InterfaceTypeAttribute("0")]
[SuppressUnmanagedCodeSecurityAttribute]
internal interface Microsoft.Win32.TaskScheduler.V2Interop.ILogonTrigger {
    public TaskTriggerType Type { get; }
    public string Id { get; public set; }
    public IRepetitionPattern Repetition { get; public set; }
    public string ExecutionTimeLimit { get; public set; }
    public string StartBoundary { get; public set; }
    public string EndBoundary { get; public set; }
    public bool Enabled { get; public set; }
    public string Delay { get; public set; }
    public string UserId { get; public set; }
    public abstract virtual TaskTriggerType get_Type();
    public abstract virtual string get_Id();
    public abstract virtual void set_Id(string value);
    public abstract virtual IRepetitionPattern get_Repetition();
    public abstract virtual void set_Repetition(IRepetitionPattern value);
    public abstract virtual string get_ExecutionTimeLimit();
    public abstract virtual void set_ExecutionTimeLimit(string value);
    public abstract virtual string get_StartBoundary();
    public abstract virtual void set_StartBoundary(string value);
    public abstract virtual string get_EndBoundary();
    public abstract virtual void set_EndBoundary(string value);
    public abstract virtual bool get_Enabled();
    public abstract virtual void set_Enabled(bool value);
    public abstract virtual string get_Delay();
    public abstract virtual void set_Delay(string value);
    public abstract virtual string get_UserId();
    public abstract virtual void set_UserId(string value);
}
[GuidAttribute("A6024FA8-9652-4ADB-A6BF-5CFCD877A7BA")]
[InterfaceTypeAttribute("0")]
[SuppressUnmanagedCodeSecurityAttribute]
internal interface Microsoft.Win32.TaskScheduler.V2Interop.IMaintenanceSettings {
    public string Period { get; public set; }
    public string Deadline { get; public set; }
    public bool Exclusive { get; public set; }
    public abstract virtual void set_Period(string value);
    public abstract virtual string get_Period();
    public abstract virtual void set_Deadline(string value);
    public abstract virtual string get_Deadline();
    public abstract virtual void set_Exclusive(bool value);
    public abstract virtual bool get_Exclusive();
}
[GuidAttribute("77D025A3-90FA-43AA-B52E-CDA5499B946A")]
[InterfaceTypeAttribute("0")]
[SuppressUnmanagedCodeSecurityAttribute]
internal interface Microsoft.Win32.TaskScheduler.V2Interop.IMonthlyDOWTrigger {
    public TaskTriggerType Type { get; }
    public string Id { get; public set; }
    public IRepetitionPattern Repetition { get; public set; }
    public string ExecutionTimeLimit { get; public set; }
    public string StartBoundary { get; public set; }
    public string EndBoundary { get; public set; }
    public bool Enabled { get; public set; }
    public short DaysOfWeek { get; public set; }
    public short WeeksOfMonth { get; public set; }
    public short MonthsOfYear { get; public set; }
    public bool RunOnLastWeekOfMonth { get; public set; }
    public string RandomDelay { get; public set; }
    public abstract virtual TaskTriggerType get_Type();
    public abstract virtual string get_Id();
    public abstract virtual void set_Id(string value);
    public abstract virtual IRepetitionPattern get_Repetition();
    public abstract virtual void set_Repetition(IRepetitionPattern value);
    public abstract virtual string get_ExecutionTimeLimit();
    public abstract virtual void set_ExecutionTimeLimit(string value);
    public abstract virtual string get_StartBoundary();
    public abstract virtual void set_StartBoundary(string value);
    public abstract virtual string get_EndBoundary();
    public abstract virtual void set_EndBoundary(string value);
    public abstract virtual bool get_Enabled();
    public abstract virtual void set_Enabled(bool value);
    public abstract virtual short get_DaysOfWeek();
    public abstract virtual void set_DaysOfWeek(short value);
    public abstract virtual short get_WeeksOfMonth();
    public abstract virtual void set_WeeksOfMonth(short value);
    public abstract virtual short get_MonthsOfYear();
    public abstract virtual void set_MonthsOfYear(short value);
    public abstract virtual bool get_RunOnLastWeekOfMonth();
    public abstract virtual void set_RunOnLastWeekOfMonth(bool value);
    public abstract virtual string get_RandomDelay();
    public abstract virtual void set_RandomDelay(string value);
}
[GuidAttribute("97C45EF1-6B02-4A1A-9C0E-1EBFBA1500AC")]
[InterfaceTypeAttribute("0")]
[SuppressUnmanagedCodeSecurityAttribute]
internal interface Microsoft.Win32.TaskScheduler.V2Interop.IMonthlyTrigger {
    public TaskTriggerType Type { get; }
    public string Id { get; public set; }
    public IRepetitionPattern Repetition { get; public set; }
    public string ExecutionTimeLimit { get; public set; }
    public string StartBoundary { get; public set; }
    public string EndBoundary { get; public set; }
    public bool Enabled { get; public set; }
    public int DaysOfMonth { get; public set; }
    public short MonthsOfYear { get; public set; }
    public bool RunOnLastDayOfMonth { get; public set; }
    public string RandomDelay { get; public set; }
    public abstract virtual TaskTriggerType get_Type();
    public abstract virtual string get_Id();
    public abstract virtual void set_Id(string value);
    public abstract virtual IRepetitionPattern get_Repetition();
    public abstract virtual void set_Repetition(IRepetitionPattern value);
    public abstract virtual string get_ExecutionTimeLimit();
    public abstract virtual void set_ExecutionTimeLimit(string value);
    public abstract virtual string get_StartBoundary();
    public abstract virtual void set_StartBoundary(string value);
    public abstract virtual string get_EndBoundary();
    public abstract virtual void set_EndBoundary(string value);
    public abstract virtual bool get_Enabled();
    public abstract virtual void set_Enabled(bool value);
    public abstract virtual int get_DaysOfMonth();
    public abstract virtual void set_DaysOfMonth(int value);
    public abstract virtual short get_MonthsOfYear();
    public abstract virtual void set_MonthsOfYear(short value);
    public abstract virtual bool get_RunOnLastDayOfMonth();
    public abstract virtual void set_RunOnLastDayOfMonth(bool value);
    public abstract virtual string get_RandomDelay();
    public abstract virtual void set_RandomDelay(string value);
}
[GuidAttribute("9F7DEA84-C30B-4245-80B6-00E9F646F1B4")]
[InterfaceTypeAttribute("0")]
[SuppressUnmanagedCodeSecurityAttribute]
internal interface Microsoft.Win32.TaskScheduler.V2Interop.INetworkSettings {
    public string Name { get; public set; }
    public string Id { get; public set; }
    public abstract virtual string get_Name();
    public abstract virtual void set_Name(string value);
    public abstract virtual string get_Id();
    public abstract virtual void set_Id(string value);
}
[GuidAttribute("D98D51E5-C9B4-496A-A9C1-18980261CF0F")]
[InterfaceTypeAttribute("0")]
[SuppressUnmanagedCodeSecurityAttribute]
internal interface Microsoft.Win32.TaskScheduler.V2Interop.IPrincipal {
    public string Id { get; public set; }
    public string DisplayName { get; public set; }
    public string UserId { get; public set; }
    public TaskLogonType LogonType { get; public set; }
    public string GroupId { get; public set; }
    public TaskRunLevel RunLevel { get; public set; }
    public abstract virtual string get_Id();
    public abstract virtual void set_Id(string value);
    public abstract virtual string get_DisplayName();
    public abstract virtual void set_DisplayName(string value);
    public abstract virtual string get_UserId();
    public abstract virtual void set_UserId(string value);
    public abstract virtual TaskLogonType get_LogonType();
    public abstract virtual void set_LogonType(TaskLogonType value);
    public abstract virtual string get_GroupId();
    public abstract virtual void set_GroupId(string value);
    public abstract virtual TaskRunLevel get_RunLevel();
    public abstract virtual void set_RunLevel(TaskRunLevel value);
}
[DefaultMemberAttribute("Item")]
[GuidAttribute("248919AE-E345-4A6D-8AEB-E0D3165C904E")]
[InterfaceTypeAttribute("0")]
[SuppressUnmanagedCodeSecurityAttribute]
internal interface Microsoft.Win32.TaskScheduler.V2Interop.IPrincipal2 {
    public TaskProcessTokenSidType ProcessTokenSidType { get; public set; }
    public int RequiredPrivilegeCount { get; }
    public string Item { get; }
    public abstract virtual TaskProcessTokenSidType get_ProcessTokenSidType();
    public abstract virtual void set_ProcessTokenSidType(TaskProcessTokenSidType value);
    public abstract virtual int get_RequiredPrivilegeCount();
    public abstract virtual string get_Item(int index);
    public abstract virtual void AddRequiredPrivilege(string privilege);
}
[GuidAttribute("9C86F320-DEE3-4DD1-B972-A303F26B061E")]
[InterfaceTypeAttribute("0")]
[SuppressUnmanagedCodeSecurityAttribute]
[DefaultMemberAttribute("Path")]
internal interface Microsoft.Win32.TaskScheduler.V2Interop.IRegisteredTask {
    public string Name { get; }
    public string Path { get; }
    public TaskState State { get; }
    public bool Enabled { get; public set; }
    public DateTime LastRunTime { get; }
    public int LastTaskResult { get; }
    public int NumberOfMissedRuns { get; }
    public DateTime NextRunTime { get; }
    public ITaskDefinition Definition { get; }
    public string Xml { get; }
    public abstract virtual string get_Name();
    public abstract virtual string get_Path();
    public abstract virtual TaskState get_State();
    public abstract virtual bool get_Enabled();
    public abstract virtual void set_Enabled(bool value);
    public abstract virtual IRunningTask Run(object parameters);
    public abstract virtual IRunningTask RunEx(object parameters, int flags, int sessionID, string user);
    public abstract virtual IRunningTaskCollection GetInstances(int flags);
    public abstract virtual DateTime get_LastRunTime();
    public abstract virtual int get_LastTaskResult();
    public abstract virtual int get_NumberOfMissedRuns();
    public abstract virtual DateTime get_NextRunTime();
    public abstract virtual ITaskDefinition get_Definition();
    public abstract virtual string get_Xml();
    public abstract virtual string GetSecurityDescriptor(int securityInformation);
    public abstract virtual void SetSecurityDescriptor(string sddl, int flags);
    public abstract virtual void Stop(int flags);
    [DispIdAttribute("1610743825")]
public abstract virtual void GetRunTimes(SYSTEMTIME& pstStart, SYSTEMTIME& pstEnd, UInt32& pCount, IntPtr& pRunTimes);
}
[DefaultMemberAttribute("Item")]
[GuidAttribute("86627EB4-42A7-41E4-A4D9-AC33A72F2D52")]
[InterfaceTypeAttribute("0")]
[SuppressUnmanagedCodeSecurityAttribute]
internal interface Microsoft.Win32.TaskScheduler.V2Interop.IRegisteredTaskCollection {
    public int Count { get; }
    public IRegisteredTask Item { get; }
    public abstract virtual int get_Count();
    public abstract virtual IRegisteredTask get_Item(object index);
    public abstract virtual IEnumerator GetEnumerator();
}
[GuidAttribute("416D8B73-CB41-4EA1-805C-9BE9A5AC4A74")]
[InterfaceTypeAttribute("0")]
[SuppressUnmanagedCodeSecurityAttribute]
internal interface Microsoft.Win32.TaskScheduler.V2Interop.IRegistrationInfo {
    public string Description { get; public set; }
    public string Author { get; public set; }
    public string Version { get; public set; }
    public string Date { get; public set; }
    public string Documentation { get; public set; }
    public string XmlText { get; public set; }
    public string URI { get; public set; }
    public object SecurityDescriptor { get; public set; }
    public string Source { get; public set; }
    public abstract virtual string get_Description();
    public abstract virtual void set_Description(string value);
    public abstract virtual string get_Author();
    public abstract virtual void set_Author(string value);
    public abstract virtual string get_Version();
    public abstract virtual void set_Version(string value);
    public abstract virtual string get_Date();
    public abstract virtual void set_Date(string value);
    public abstract virtual string get_Documentation();
    public abstract virtual void set_Documentation(string value);
    public abstract virtual string get_XmlText();
    public abstract virtual void set_XmlText(string value);
    public abstract virtual string get_URI();
    public abstract virtual void set_URI(string value);
    public abstract virtual object get_SecurityDescriptor();
    public abstract virtual void set_SecurityDescriptor(object value);
    public abstract virtual string get_Source();
    public abstract virtual void set_Source(string value);
}
[GuidAttribute("4C8FEC3A-C218-4E0C-B23D-629024DB91A2")]
[InterfaceTypeAttribute("0")]
[SuppressUnmanagedCodeSecurityAttribute]
internal interface Microsoft.Win32.TaskScheduler.V2Interop.IRegistrationTrigger {
    public TaskTriggerType Type { get; }
    public string Id { get; public set; }
    public IRepetitionPattern Repetition { get; public set; }
    public string ExecutionTimeLimit { get; public set; }
    public string StartBoundary { get; public set; }
    public string EndBoundary { get; public set; }
    public bool Enabled { get; public set; }
    public string Delay { get; public set; }
    public abstract virtual TaskTriggerType get_Type();
    public abstract virtual string get_Id();
    public abstract virtual void set_Id(string value);
    public abstract virtual IRepetitionPattern get_Repetition();
    public abstract virtual void set_Repetition(IRepetitionPattern value);
    public abstract virtual string get_ExecutionTimeLimit();
    public abstract virtual void set_ExecutionTimeLimit(string value);
    public abstract virtual string get_StartBoundary();
    public abstract virtual void set_StartBoundary(string value);
    public abstract virtual string get_EndBoundary();
    public abstract virtual void set_EndBoundary(string value);
    public abstract virtual bool get_Enabled();
    public abstract virtual void set_Enabled(bool value);
    public abstract virtual string get_Delay();
    public abstract virtual void set_Delay(string value);
}
[GuidAttribute("7FB9ACF1-26BE-400E-85B5-294B9C75DFD6")]
[InterfaceTypeAttribute("0")]
[SuppressUnmanagedCodeSecurityAttribute]
internal interface Microsoft.Win32.TaskScheduler.V2Interop.IRepetitionPattern {
    public string Interval { get; public set; }
    public string Duration { get; public set; }
    public bool StopAtDurationEnd { get; public set; }
    public abstract virtual string get_Interval();
    public abstract virtual void set_Interval(string value);
    public abstract virtual string get_Duration();
    public abstract virtual void set_Duration(string value);
    public abstract virtual bool get_StopAtDurationEnd();
    public abstract virtual void set_StopAtDurationEnd(bool value);
}
[GuidAttribute("653758FB-7B9A-4F1E-A471-BEEB8E9B834E")]
[InterfaceTypeAttribute("0")]
[SuppressUnmanagedCodeSecurityAttribute]
[DefaultMemberAttribute("InstanceGuid")]
internal interface Microsoft.Win32.TaskScheduler.V2Interop.IRunningTask {
    public string Name { get; }
    public string InstanceGuid { get; }
    public string Path { get; }
    public TaskState State { get; }
    public string CurrentAction { get; }
    public UInt32 EnginePID { get; }
    public abstract virtual string get_Name();
    public abstract virtual string get_InstanceGuid();
    public abstract virtual string get_Path();
    public abstract virtual TaskState get_State();
    public abstract virtual string get_CurrentAction();
    public abstract virtual void Stop();
    public abstract virtual void Refresh();
    public abstract virtual UInt32 get_EnginePID();
}
[DefaultMemberAttribute("Item")]
[GuidAttribute("6A67614B-6828-4FEC-AA54-6D52E8F1F2DB")]
[InterfaceTypeAttribute("0")]
[SuppressUnmanagedCodeSecurityAttribute]
internal interface Microsoft.Win32.TaskScheduler.V2Interop.IRunningTaskCollection {
    public int Count { get; }
    public IRunningTask Item { get; }
    public abstract virtual int get_Count();
    public abstract virtual IRunningTask get_Item(object index);
    public abstract virtual IEnumerator GetEnumerator();
}
[InterfaceTypeAttribute("0")]
[GuidAttribute("754DA71B-4385-4475-9DD9-598294FA3641")]
[SuppressUnmanagedCodeSecurityAttribute]
internal interface Microsoft.Win32.TaskScheduler.V2Interop.ISessionStateChangeTrigger {
    public TaskTriggerType Type { get; }
    public string Id { get; public set; }
    public IRepetitionPattern Repetition { get; public set; }
    public string ExecutionTimeLimit { get; public set; }
    public string StartBoundary { get; public set; }
    public string EndBoundary { get; public set; }
    public bool Enabled { get; public set; }
    public string Delay { get; public set; }
    public string UserId { get; public set; }
    public TaskSessionStateChangeType StateChange { get; public set; }
    public abstract virtual TaskTriggerType get_Type();
    public abstract virtual string get_Id();
    public abstract virtual void set_Id(string value);
    public abstract virtual IRepetitionPattern get_Repetition();
    public abstract virtual void set_Repetition(IRepetitionPattern value);
    public abstract virtual string get_ExecutionTimeLimit();
    public abstract virtual void set_ExecutionTimeLimit(string value);
    public abstract virtual string get_StartBoundary();
    public abstract virtual void set_StartBoundary(string value);
    public abstract virtual string get_EndBoundary();
    public abstract virtual void set_EndBoundary(string value);
    public abstract virtual bool get_Enabled();
    public abstract virtual void set_Enabled(bool value);
    public abstract virtual string get_Delay();
    public abstract virtual void set_Delay(string value);
    public abstract virtual string get_UserId();
    public abstract virtual void set_UserId(string value);
    public abstract virtual TaskSessionStateChangeType get_StateChange();
    public abstract virtual void set_StateChange(TaskSessionStateChangeType value);
}
[GuidAttribute("505E9E68-AF89-46B8-A30F-56162A83D537")]
[InterfaceTypeAttribute("0")]
[SuppressUnmanagedCodeSecurityAttribute]
internal interface Microsoft.Win32.TaskScheduler.V2Interop.IShowMessageAction {
    public string Id { get; public set; }
    public TaskActionType Type { get; }
    public string Title { get; public set; }
    public string MessageBody { get; public set; }
    public abstract virtual string get_Id();
    public abstract virtual void set_Id(string value);
    public abstract virtual TaskActionType get_Type();
    public abstract virtual string get_Title();
    public abstract virtual void set_Title(string value);
    public abstract virtual string get_MessageBody();
    public abstract virtual void set_MessageBody(string value);
}
[GuidAttribute("F5BC8FC5-536D-4F77-B852-FBC1356FDEB6")]
[InterfaceTypeAttribute("0")]
[SuppressUnmanagedCodeSecurityAttribute]
internal interface Microsoft.Win32.TaskScheduler.V2Interop.ITaskDefinition {
    public IRegistrationInfo RegistrationInfo { get; public set; }
    public ITriggerCollection Triggers { get; public set; }
    public ITaskSettings Settings { get; public set; }
    public string Data { get; public set; }
    public IPrincipal Principal { get; public set; }
    public IActionCollection Actions { get; public set; }
    public string XmlText { get; public set; }
    public abstract virtual IRegistrationInfo get_RegistrationInfo();
    public abstract virtual void set_RegistrationInfo(IRegistrationInfo value);
    public abstract virtual ITriggerCollection get_Triggers();
    public abstract virtual void set_Triggers(ITriggerCollection value);
    public abstract virtual ITaskSettings get_Settings();
    public abstract virtual void set_Settings(ITaskSettings value);
    public abstract virtual string get_Data();
    public abstract virtual void set_Data(string value);
    public abstract virtual IPrincipal get_Principal();
    public abstract virtual void set_Principal(IPrincipal value);
    public abstract virtual IActionCollection get_Actions();
    public abstract virtual void set_Actions(IActionCollection value);
    public abstract virtual string get_XmlText();
    public abstract virtual void set_XmlText(string value);
}
[GuidAttribute("8CFAC062-A080-4C15-9A88-AA7C2AF80DFC")]
[InterfaceTypeAttribute("0")]
[SuppressUnmanagedCodeSecurityAttribute]
[DefaultMemberAttribute("Path")]
internal interface Microsoft.Win32.TaskScheduler.V2Interop.ITaskFolder {
    public string Name { get; }
    public string Path { get; }
    public abstract virtual string get_Name();
    public abstract virtual string get_Path();
    public abstract virtual ITaskFolder GetFolder(string Path);
    public abstract virtual ITaskFolderCollection GetFolders(int flags);
    public abstract virtual ITaskFolder CreateFolder(string subFolderName, object sddl);
    public abstract virtual void DeleteFolder(string subFolderName, int flags);
    public abstract virtual IRegisteredTask GetTask(string Path);
    public abstract virtual IRegisteredTaskCollection GetTasks(int flags);
    public abstract virtual void DeleteTask(string Name, int flags);
    public abstract virtual IRegisteredTask RegisterTask(string Path, string XmlText, int flags, object UserId, object password, TaskLogonType LogonType, object sddl);
    public abstract virtual IRegisteredTask RegisterTaskDefinition(string Path, ITaskDefinition pDefinition, int flags, object UserId, object password, TaskLogonType LogonType, object sddl);
    public abstract virtual string GetSecurityDescriptor(int securityInformation);
    public abstract virtual void SetSecurityDescriptor(string sddl, int flags);
}
[DefaultMemberAttribute("Item")]
[GuidAttribute("79184A66-8664-423F-97F1-637356A5D812")]
[InterfaceTypeAttribute("0")]
[SuppressUnmanagedCodeSecurityAttribute]
internal interface Microsoft.Win32.TaskScheduler.V2Interop.ITaskFolderCollection {
    public int Count { get; }
    public ITaskFolder Item { get; }
    public abstract virtual int get_Count();
    public abstract virtual ITaskFolder get_Item(object index);
    public abstract virtual IEnumerator GetEnumerator();
}
[DefaultMemberAttribute("Item")]
[GuidAttribute("B4EF826B-63C3-46E4-A504-EF69E4F7EA4D")]
[InterfaceTypeAttribute("0")]
[SuppressUnmanagedCodeSecurityAttribute]
internal interface Microsoft.Win32.TaskScheduler.V2Interop.ITaskNamedValueCollection {
    public int Count { get; }
    public ITaskNamedValuePair Item { get; }
    public abstract virtual int get_Count();
    public abstract virtual ITaskNamedValuePair get_Item(int index);
    public abstract virtual IEnumerator GetEnumerator();
    public abstract virtual ITaskNamedValuePair Create(string Name, string Value);
    public abstract virtual void Remove(int index);
    public abstract virtual void Clear();
}
[GuidAttribute("39038068-2B46-4AFD-8662-7BB6F868D221")]
[InterfaceTypeAttribute("0")]
[SuppressUnmanagedCodeSecurityAttribute]
[DefaultMemberAttribute("Name")]
internal interface Microsoft.Win32.TaskScheduler.V2Interop.ITaskNamedValuePair {
    public string Name { get; public set; }
    public string Value { get; public set; }
    public abstract virtual string get_Name();
    public abstract virtual void set_Name(string value);
    public abstract virtual string get_Value();
    public abstract virtual void set_Value(string value);
}
[DefaultMemberAttribute("TargetServer")]
[GuidAttribute("2FABA4C7-4DA9-4013-9697-20CC3FD40F85")]
[SuppressUnmanagedCodeSecurityAttribute]
[CoClassAttribute("Microsoft.Win32.TaskScheduler.V2Interop.TaskSchedulerClass")]
internal interface Microsoft.Win32.TaskScheduler.V2Interop.ITaskService {
    [DispIdAttribute("5")]
public bool Connected { get; }
    [DispIdAttribute("0")]
public string TargetServer { get; }
    [DispIdAttribute("6")]
public string ConnectedUser { get; }
    [DispIdAttribute("7")]
public string ConnectedDomain { get; }
    [DispIdAttribute("8")]
public UInt32 HighestVersion { get; }
    [DispIdAttribute("1")]
public abstract virtual ITaskFolder GetFolder(string Path);
    [DispIdAttribute("2")]
public abstract virtual IRunningTaskCollection GetRunningTasks(int flags);
    [DispIdAttribute("3")]
public abstract virtual ITaskDefinition NewTask(UInt32 flags);
    [DispIdAttribute("4")]
public abstract virtual void Connect(object serverName, object user, object domain, object password);
    [DispIdAttribute("5")]
public abstract virtual bool get_Connected();
    [DispIdAttribute("0")]
public abstract virtual string get_TargetServer();
    [DispIdAttribute("6")]
public abstract virtual string get_ConnectedUser();
    [DispIdAttribute("7")]
public abstract virtual string get_ConnectedDomain();
    [DispIdAttribute("8")]
public abstract virtual UInt32 get_HighestVersion();
}
[GuidAttribute("8FD4711D-2D02-4C8C-87E3-EFF699DE127E")]
[InterfaceTypeAttribute("0")]
[SuppressUnmanagedCodeSecurityAttribute]
internal interface Microsoft.Win32.TaskScheduler.V2Interop.ITaskSettings {
    public bool AllowDemandStart { get; public set; }
    public string RestartInterval { get; public set; }
    public int RestartCount { get; public set; }
    public TaskInstancesPolicy MultipleInstances { get; public set; }
    public bool StopIfGoingOnBatteries { get; public set; }
    public bool DisallowStartIfOnBatteries { get; public set; }
    public bool AllowHardTerminate { get; public set; }
    public bool StartWhenAvailable { get; public set; }
    public string XmlText { get; public set; }
    public bool RunOnlyIfNetworkAvailable { get; public set; }
    public string ExecutionTimeLimit { get; public set; }
    public bool Enabled { get; public set; }
    public string DeleteExpiredTaskAfter { get; public set; }
    public int Priority { get; public set; }
    public TaskCompatibility Compatibility { get; public set; }
    public bool Hidden { get; public set; }
    public IIdleSettings IdleSettings { get; public set; }
    public bool RunOnlyIfIdle { get; public set; }
    public bool WakeToRun { get; public set; }
    public INetworkSettings NetworkSettings { get; public set; }
    public abstract virtual bool get_AllowDemandStart();
    public abstract virtual void set_AllowDemandStart(bool value);
    public abstract virtual string get_RestartInterval();
    public abstract virtual void set_RestartInterval(string value);
    public abstract virtual int get_RestartCount();
    public abstract virtual void set_RestartCount(int value);
    public abstract virtual TaskInstancesPolicy get_MultipleInstances();
    public abstract virtual void set_MultipleInstances(TaskInstancesPolicy value);
    public abstract virtual bool get_StopIfGoingOnBatteries();
    public abstract virtual void set_StopIfGoingOnBatteries(bool value);
    public abstract virtual bool get_DisallowStartIfOnBatteries();
    public abstract virtual void set_DisallowStartIfOnBatteries(bool value);
    public abstract virtual bool get_AllowHardTerminate();
    public abstract virtual void set_AllowHardTerminate(bool value);
    public abstract virtual bool get_StartWhenAvailable();
    public abstract virtual void set_StartWhenAvailable(bool value);
    public abstract virtual string get_XmlText();
    public abstract virtual void set_XmlText(string value);
    public abstract virtual bool get_RunOnlyIfNetworkAvailable();
    public abstract virtual void set_RunOnlyIfNetworkAvailable(bool value);
    public abstract virtual string get_ExecutionTimeLimit();
    public abstract virtual void set_ExecutionTimeLimit(string value);
    public abstract virtual bool get_Enabled();
    public abstract virtual void set_Enabled(bool value);
    public abstract virtual string get_DeleteExpiredTaskAfter();
    public abstract virtual void set_DeleteExpiredTaskAfter(string value);
    public abstract virtual int get_Priority();
    public abstract virtual void set_Priority(int value);
    public abstract virtual TaskCompatibility get_Compatibility();
    public abstract virtual void set_Compatibility(TaskCompatibility value);
    public abstract virtual bool get_Hidden();
    public abstract virtual void set_Hidden(bool value);
    public abstract virtual IIdleSettings get_IdleSettings();
    public abstract virtual void set_IdleSettings(IIdleSettings value);
    public abstract virtual bool get_RunOnlyIfIdle();
    public abstract virtual void set_RunOnlyIfIdle(bool value);
    public abstract virtual bool get_WakeToRun();
    public abstract virtual void set_WakeToRun(bool value);
    public abstract virtual INetworkSettings get_NetworkSettings();
    public abstract virtual void set_NetworkSettings(INetworkSettings value);
}
[GuidAttribute("2C05C3F0-6EED-4c05-A15F-ED7D7A98A369")]
[InterfaceTypeAttribute("0")]
[SuppressUnmanagedCodeSecurityAttribute]
internal interface Microsoft.Win32.TaskScheduler.V2Interop.ITaskSettings2 {
    public bool DisallowStartOnRemoteAppSession { get; public set; }
    public bool UseUnifiedSchedulingEngine { get; public set; }
    public abstract virtual bool get_DisallowStartOnRemoteAppSession();
    public abstract virtual void set_DisallowStartOnRemoteAppSession(bool value);
    public abstract virtual bool get_UseUnifiedSchedulingEngine();
    public abstract virtual void set_UseUnifiedSchedulingEngine(bool value);
}
[GuidAttribute("0AD9D0D7-0C7F-4EBB-9A5F-D1C648DCA528")]
[InterfaceTypeAttribute("0")]
[SuppressUnmanagedCodeSecurityAttribute]
internal interface Microsoft.Win32.TaskScheduler.V2Interop.ITaskSettings3 {
    public bool AllowDemandStart { get; public set; }
    public string RestartInterval { get; public set; }
    public int RestartCount { get; public set; }
    public TaskInstancesPolicy MultipleInstances { get; public set; }
    public bool StopIfGoingOnBatteries { get; public set; }
    public bool DisallowStartIfOnBatteries { get; public set; }
    public bool AllowHardTerminate { get; public set; }
    public bool StartWhenAvailable { get; public set; }
    public string XmlText { get; public set; }
    public bool RunOnlyIfNetworkAvailable { get; public set; }
    public string ExecutionTimeLimit { get; public set; }
    public bool Enabled { get; public set; }
    public string DeleteExpiredTaskAfter { get; public set; }
    public int Priority { get; public set; }
    public TaskCompatibility Compatibility { get; public set; }
    public bool Hidden { get; public set; }
    public IIdleSettings IdleSettings { get; public set; }
    public bool RunOnlyIfIdle { get; public set; }
    public bool WakeToRun { get; public set; }
    public INetworkSettings NetworkSettings { get; public set; }
    public bool DisallowStartOnRemoteAppSession { get; public set; }
    public bool UseUnifiedSchedulingEngine { get; public set; }
    public IMaintenanceSettings MaintenanceSettings { get; public set; }
    public bool Volatile { get; public set; }
    public abstract virtual bool get_AllowDemandStart();
    public abstract virtual void set_AllowDemandStart(bool value);
    public abstract virtual string get_RestartInterval();
    public abstract virtual void set_RestartInterval(string value);
    public abstract virtual int get_RestartCount();
    public abstract virtual void set_RestartCount(int value);
    public abstract virtual TaskInstancesPolicy get_MultipleInstances();
    public abstract virtual void set_MultipleInstances(TaskInstancesPolicy value);
    public abstract virtual bool get_StopIfGoingOnBatteries();
    public abstract virtual void set_StopIfGoingOnBatteries(bool value);
    public abstract virtual bool get_DisallowStartIfOnBatteries();
    public abstract virtual void set_DisallowStartIfOnBatteries(bool value);
    public abstract virtual bool get_AllowHardTerminate();
    public abstract virtual void set_AllowHardTerminate(bool value);
    public abstract virtual bool get_StartWhenAvailable();
    public abstract virtual void set_StartWhenAvailable(bool value);
    public abstract virtual string get_XmlText();
    public abstract virtual void set_XmlText(string value);
    public abstract virtual bool get_RunOnlyIfNetworkAvailable();
    public abstract virtual void set_RunOnlyIfNetworkAvailable(bool value);
    public abstract virtual string get_ExecutionTimeLimit();
    public abstract virtual void set_ExecutionTimeLimit(string value);
    public abstract virtual bool get_Enabled();
    public abstract virtual void set_Enabled(bool value);
    public abstract virtual string get_DeleteExpiredTaskAfter();
    public abstract virtual void set_DeleteExpiredTaskAfter(string value);
    public abstract virtual int get_Priority();
    public abstract virtual void set_Priority(int value);
    public abstract virtual TaskCompatibility get_Compatibility();
    public abstract virtual void set_Compatibility(TaskCompatibility value);
    public abstract virtual bool get_Hidden();
    public abstract virtual void set_Hidden(bool value);
    public abstract virtual IIdleSettings get_IdleSettings();
    public abstract virtual void set_IdleSettings(IIdleSettings value);
    public abstract virtual bool get_RunOnlyIfIdle();
    public abstract virtual void set_RunOnlyIfIdle(bool value);
    public abstract virtual bool get_WakeToRun();
    public abstract virtual void set_WakeToRun(bool value);
    public abstract virtual INetworkSettings get_NetworkSettings();
    public abstract virtual void set_NetworkSettings(INetworkSettings value);
    public abstract virtual bool get_DisallowStartOnRemoteAppSession();
    public abstract virtual void set_DisallowStartOnRemoteAppSession(bool value);
    public abstract virtual bool get_UseUnifiedSchedulingEngine();
    public abstract virtual void set_UseUnifiedSchedulingEngine(bool value);
    public abstract virtual IMaintenanceSettings get_MaintenanceSettings();
    public abstract virtual void set_MaintenanceSettings(IMaintenanceSettings value);
    public abstract virtual IMaintenanceSettings CreateMaintenanceSettings();
    public abstract virtual bool get_Volatile();
    public abstract virtual void set_Volatile(bool value);
}
[GuidAttribute("3E4C9351-D966-4B8B-BB87-CEBA68BB0107")]
[InterfaceTypeAttribute("1")]
[SuppressUnmanagedCodeSecurityAttribute]
internal interface Microsoft.Win32.TaskScheduler.V2Interop.ITaskVariables {
    public abstract virtual string GetInput();
    public abstract virtual void SetOutput(string input);
    public abstract virtual string GetContext();
}
[GuidAttribute("B45747E0-EBA7-4276-9F29-85C5BB300006")]
[InterfaceTypeAttribute("0")]
[SuppressUnmanagedCodeSecurityAttribute]
internal interface Microsoft.Win32.TaskScheduler.V2Interop.ITimeTrigger {
    public TaskTriggerType Type { get; }
    public string Id { get; public set; }
    public IRepetitionPattern Repetition { get; public set; }
    public string ExecutionTimeLimit { get; public set; }
    public string StartBoundary { get; public set; }
    public string EndBoundary { get; public set; }
    public bool Enabled { get; public set; }
    public string RandomDelay { get; public set; }
    public abstract virtual TaskTriggerType get_Type();
    public abstract virtual string get_Id();
    public abstract virtual void set_Id(string value);
    public abstract virtual IRepetitionPattern get_Repetition();
    public abstract virtual void set_Repetition(IRepetitionPattern value);
    public abstract virtual string get_ExecutionTimeLimit();
    public abstract virtual void set_ExecutionTimeLimit(string value);
    public abstract virtual string get_StartBoundary();
    public abstract virtual void set_StartBoundary(string value);
    public abstract virtual string get_EndBoundary();
    public abstract virtual void set_EndBoundary(string value);
    public abstract virtual bool get_Enabled();
    public abstract virtual void set_Enabled(bool value);
    public abstract virtual string get_RandomDelay();
    public abstract virtual void set_RandomDelay(string value);
}
[GuidAttribute("09941815-EA89-4B5B-89E0-2A773801FAC3")]
[InterfaceTypeAttribute("0")]
[SuppressUnmanagedCodeSecurityAttribute]
internal interface Microsoft.Win32.TaskScheduler.V2Interop.ITrigger {
    public TaskTriggerType Type { get; }
    public string Id { get; public set; }
    public IRepetitionPattern Repetition { get; public set; }
    public string ExecutionTimeLimit { get; public set; }
    public string StartBoundary { get; public set; }
    public string EndBoundary { get; public set; }
    public bool Enabled { get; public set; }
    public abstract virtual TaskTriggerType get_Type();
    public abstract virtual string get_Id();
    public abstract virtual void set_Id(string value);
    public abstract virtual IRepetitionPattern get_Repetition();
    public abstract virtual void set_Repetition(IRepetitionPattern value);
    public abstract virtual string get_ExecutionTimeLimit();
    public abstract virtual void set_ExecutionTimeLimit(string value);
    public abstract virtual string get_StartBoundary();
    public abstract virtual void set_StartBoundary(string value);
    public abstract virtual string get_EndBoundary();
    public abstract virtual void set_EndBoundary(string value);
    public abstract virtual bool get_Enabled();
    public abstract virtual void set_Enabled(bool value);
}
[DefaultMemberAttribute("Item")]
[GuidAttribute("85DF5081-1B24-4F32-878A-D9D14DF4CB77")]
[InterfaceTypeAttribute("0")]
[SuppressUnmanagedCodeSecurityAttribute]
internal interface Microsoft.Win32.TaskScheduler.V2Interop.ITriggerCollection {
    public int Count { get; }
    public ITrigger Item { get; }
    public abstract virtual int get_Count();
    public abstract virtual ITrigger get_Item(int index);
    public abstract virtual IEnumerator GetEnumerator();
    public abstract virtual ITrigger Create(TaskTriggerType Type);
    public abstract virtual void Remove(object index);
    public abstract virtual void Clear();
}
[GuidAttribute("5038FC98-82FF-436D-8728-A512A57C9DC1")]
[InterfaceTypeAttribute("0")]
[SuppressUnmanagedCodeSecurityAttribute]
internal interface Microsoft.Win32.TaskScheduler.V2Interop.IWeeklyTrigger {
    public TaskTriggerType Type { get; }
    public string Id { get; public set; }
    public IRepetitionPattern Repetition { get; public set; }
    public string ExecutionTimeLimit { get; public set; }
    public string StartBoundary { get; public set; }
    public string EndBoundary { get; public set; }
    public bool Enabled { get; public set; }
    public short DaysOfWeek { get; public set; }
    public short WeeksInterval { get; public set; }
    public string RandomDelay { get; public set; }
    public abstract virtual TaskTriggerType get_Type();
    public abstract virtual string get_Id();
    public abstract virtual void set_Id(string value);
    public abstract virtual IRepetitionPattern get_Repetition();
    public abstract virtual void set_Repetition(IRepetitionPattern value);
    public abstract virtual string get_ExecutionTimeLimit();
    public abstract virtual void set_ExecutionTimeLimit(string value);
    public abstract virtual string get_StartBoundary();
    public abstract virtual void set_StartBoundary(string value);
    public abstract virtual string get_EndBoundary();
    public abstract virtual void set_EndBoundary(string value);
    public abstract virtual bool get_Enabled();
    public abstract virtual void set_Enabled(bool value);
    public abstract virtual short get_DaysOfWeek();
    public abstract virtual void set_DaysOfWeek(short value);
    public abstract virtual short get_WeeksInterval();
    public abstract virtual void set_WeeksInterval(short value);
    public abstract virtual string get_RandomDelay();
    public abstract virtual void set_RandomDelay(string value);
}
internal enum Microsoft.Win32.TaskScheduler.V2Interop.TaskEnumFlags : Enum {
    public int value__;
    public static TaskEnumFlags Hidden;
}
[DefaultMemberAttribute("TargetServer")]
[GuidAttribute("0F87369F-A4E5-4CFC-BD3E-73E6154572DD")]
[ClassInterfaceAttribute("0")]
[SuppressUnmanagedCodeSecurityAttribute]
internal class Microsoft.Win32.TaskScheduler.V2Interop.TaskSchedulerClass : object {
}
[XmlRootAttribute("CalendarTrigger")]
public class Microsoft.Win32.TaskScheduler.WeeklyTrigger : Trigger {
    [DefaultValueAttribute("0")]
public DaysOfTheWeek DaysOfWeek { get; public set; }
    [DefaultValueAttribute("System.TimeSpan", "00:00:00")]
[XmlIgnoreAttribute]
public TimeSpan RandomDelay { get; public set; }
    [DefaultValueAttribute("1")]
public short WeeksInterval { get; public set; }
    private TimeSpan Microsoft.Win32.TaskScheduler.ITriggerDelay.Delay { get; private set; }
    public WeeklyTrigger(DaysOfTheWeek daysOfWeek, short weeksInterval);
    internal WeeklyTrigger(ITaskTrigger iTrigger);
    internal WeeklyTrigger(ITrigger iTrigger);
    public DaysOfTheWeek get_DaysOfWeek();
    public void set_DaysOfWeek(DaysOfTheWeek value);
    public TimeSpan get_RandomDelay();
    public void set_RandomDelay(TimeSpan value);
    public short get_WeeksInterval();
    public void set_WeeksInterval(short value);
    private sealed virtual override TimeSpan Microsoft.Win32.TaskScheduler.ITriggerDelay.get_Delay();
    private sealed virtual override void Microsoft.Win32.TaskScheduler.ITriggerDelay.set_Delay(TimeSpan value);
    public virtual void CopyProperties(Trigger sourceTrigger);
    public virtual bool Equals(Trigger other);
    private sealed virtual override XmlSchema System.Xml.Serialization.IXmlSerializable.GetSchema();
    private sealed virtual override void System.Xml.Serialization.IXmlSerializable.ReadXml(XmlReader reader);
    private sealed virtual override void System.Xml.Serialization.IXmlSerializable.WriteXml(XmlWriter writer);
    protected virtual string V2GetTriggerString();
    private void ReadMyXml(XmlReader reader);
    private void WriteMyXml(XmlWriter writer);
}
[FlagsAttribute]
public enum Microsoft.Win32.TaskScheduler.WhichWeek : Enum {
    public short value__;
    public static WhichWeek FirstWeek;
    public static WhichWeek SecondWeek;
    public static WhichWeek ThirdWeek;
    public static WhichWeek FourthWeek;
    public static WhichWeek LastWeek;
    public static WhichWeek AllWeeks;
}
public class Microsoft.Win32.TaskScheduler.Wildcard : Regex {
    public Wildcard(string pattern, RegexOptions options);
    public static string WildcardToRegex(string pattern);
}
internal static class Microsoft.Win32.TaskScheduler.XmlSerializationHelper : object {
    public static object GetDefaultValue(PropertyInfo prop);
    private static bool GetPropertyValue(object obj, string property, Object& outVal);
    private static bool GetAttributeValue(Type objType, Type attrType, string property, bool inherit, Object& outVal);
    private static bool GetAttributeValue(PropertyInfo propInfo, Type attrType, string property, bool inherit, Object& outVal);
    private static bool IsStandardType(Type type);
    private static bool HasMembers(object obj);
    public static string GetPropertyAttributeName(PropertyInfo pi);
    public static string GetPropertyElementName(PropertyInfo pi);
    public static bool WriteProperty(XmlWriter writer, PropertyInfo pi, object obj, PropertyConversionHandler handler);
    private static string GetXmlValue(object value, Type propType);
    public static void WriteObjectAttributes(XmlWriter writer, object obj, PropertyConversionHandler handler);
    public static void WriteObjectAttribute(XmlWriter writer, PropertyInfo pi, object obj, PropertyConversionHandler handler);
    public static void WriteObjectProperties(XmlWriter writer, object obj, PropertyConversionHandler handler);
    public static void WriteObject(XmlWriter writer, object obj, PropertyConversionHandler handler, bool includeNS, string elemName);
    public static string GetElementName(object obj);
    public static string GetTopLevelNamespace(object obj);
    public static void ReadObjectProperties(XmlReader reader, object obj, PropertyConversionHandler handler);
    public static void ReadObject(XmlReader reader, object obj, PropertyConversionHandler handler);
    public static void ReadObjectFromXmlText(string xml, object obj, PropertyConversionHandler handler);
    public static string WriteObjectToXmlText(object obj, PropertyConversionHandler handler);
}
internal class Microsoft.Win32.WindowsImpersonatedIdentity : object {
    private static int LOGON_TYPE_NEW_CREDENTIALS;
    private static int LOGON32_LOGON_INTERACTIVE;
    private static int LOGON32_PROVIDER_DEFAULT;
    private static int LOGON32_PROVIDER_WINNT50;
    private SafeTokenHandle token;
    private WindowsIdentity identity;
    public string AuthenticationType { get; }
    public bool IsAuthenticated { get; }
    public string Name { get; }
    public WindowsImpersonatedIdentity(string userName, string domainName, string password);
    public sealed virtual string get_AuthenticationType();
    public sealed virtual bool get_IsAuthenticated();
    public sealed virtual string get_Name();
    public sealed virtual void Dispose();
}
[ExtensionAttribute]
internal static class System.EnumUtil : object {
    public static void CheckIsEnum(bool checkHasFlags);
    public static bool IsFlags();
    public static void CheckHasValue(T value, string argName);
    [ExtensionAttribute]
public static byte BitPosition(T flags);
    [ExtensionAttribute]
public static bool IsFlagSet(T flags, T flag);
    [ExtensionAttribute]
public static bool IsValidFlagValue(T flags);
    public static void SetFlags(T& flags, T flag, bool set);
    [ExtensionAttribute]
public static T SetFlags(T flags, T flag, bool set);
    [ExtensionAttribute]
public static T ClearFlags(T flags, T flag);
    [IteratorStateMachineAttribute("System.EnumUtil/<GetFlags>d__9`1")]
[ExtensionAttribute]
public static IEnumerable`1<T> GetFlags(T value);
    [ExtensionAttribute]
public static T CombineFlags(IEnumerable`1<T> flags);
    [ExtensionAttribute]
public static string GetDescription(T value);
    public static TEnum TryParse(string value, bool ignoreCase, TEnum defaultVal);
}
internal static class System.Reflection.ReflectionHelper : object {
    public static Type LoadType(string typeName, string asmRef);
    private static bool TryGetType(string asmRef, string typeName, Type& type);
    private static bool TryGetType(Assembly asm, string typeName, Type& type);
    public static T InvokeMethod(Type type, string methodName, Object[] args);
    public static T InvokeMethod(Type type, Object[] instArgs, string methodName, Object[] args);
    public static T InvokeMethod(object obj, string methodName, Object[] args);
    public static T InvokeMethod(object obj, string methodName, Type[] argTypes, Object[] args);
    public static T GetProperty(object obj, string propName, T defaultValue);
    public static void SetProperty(object obj, string propName, T value);
}
[CompilerGeneratedAttribute]
[EmbeddedAttribute]
[AttributeUsageAttribute("27524")]
internal class System.Runtime.CompilerServices.NullableAttribute : Attribute {
    public Byte[] NullableFlags;
    public NullableAttribute(byte );
    public NullableAttribute(Byte[] );
}
[CompilerGeneratedAttribute]
[EmbeddedAttribute]
[AttributeUsageAttribute("2")]
internal class System.Runtime.CompilerServices.RefSafetyRulesAttribute : Attribute {
    public int Version;
    public RefSafetyRulesAttribute(int );
}
internal class System.Runtime.InteropServices.ComEnumerator`2 : object {
    protected Func`2<TIn, T> converter;
    protected IEnumerator`1<TIn> iEnum;
    private object System.Collections.IEnumerator.Current { get; }
    public T Current { get; }
    public ComEnumerator`2(Func`1<int> getCount, Func`2<int, TIn> indexer, Func`2<TIn, T> converter);
    public ComEnumerator`2(Func`1<int> getCount, Func`2<object, TIn> indexer, Func`2<TIn, T> converter);
    private sealed virtual override object System.Collections.IEnumerator.get_Current();
    public virtual T get_Current();
    public virtual void Dispose();
    public virtual bool MoveNext();
    public virtual void Reset();
}
internal static class System.Runtime.InteropServices.InteropUtil : object {
    private static int cbBuffer;
    public static T ToStructure(IntPtr ptr);
    public static IntPtr StructureToPtr(object value);
    public static void AllocString(IntPtr& ptr, UInt32& size);
    public static void FreeString(IntPtr& ptr, UInt32& size);
    public static string GetString(IntPtr pString);
    public static bool SetString(IntPtr& ptr, UInt32& size, string value);
    public static T[] ToArray(IntPtr ptr, int count);
    public static T[] ToArray(IntPtr ptr, int count);
}
[ExtensionAttribute]
public static class System.Security.AccessControl.AccessControlExtension : object {
    [ExtensionAttribute]
public static void Canonicalize(RawAcl acl);
    [ExtensionAttribute]
public static void CanonicalizeAccessRules(ObjectSecurity objectSecurity);
    [ExtensionAttribute]
public static Byte[] GetBinaryForm(GenericSecurityDescriptor sd);
    private static byte GetComparisonValue(GenericAce ace);
}
