public abstract class DotNet.Testcontainers.Builders.AbstractBuilder`4 : object {
    protected TConfigurationEntity DockerResourceConfiguration { get; }
    protected AbstractBuilder`4(TConfigurationEntity dockerResourceConfiguration);
    protected abstract virtual TConfigurationEntity get_DockerResourceConfiguration();
    public sealed virtual TBuilderEntity WithDockerEndpoint(string endpoint);
    public sealed virtual TBuilderEntity WithDockerEndpoint(Uri endpoint);
    public sealed virtual TBuilderEntity WithDockerEndpoint(IDockerEndpointAuthenticationConfiguration dockerEndpointAuthConfig);
    public sealed virtual TBuilderEntity WithCleanUp(bool cleanUp);
    public sealed virtual TBuilderEntity WithReuse(bool reuse);
    public sealed virtual TBuilderEntity WithLabel(string name, string value);
    public sealed virtual TBuilderEntity WithLabel(IReadOnlyDictionary`2<string, string> labels);
    public sealed virtual TBuilderEntity WithCreateParameterModifier(Action`1<TCreateResourceEntity> parameterModifier);
    public sealed virtual TBuilderEntity WithLogger(ILogger logger);
    public abstract virtual TResourceEntity Build();
    protected TBuilderEntity WithResourceReaperSessionId(Guid resourceReaperSessionId);
    protected virtual TBuilderEntity Init();
    protected virtual void Validate();
    protected abstract virtual TBuilderEntity Clone(IResourceConfiguration`1<TCreateResourceEntity> resourceConfiguration);
    protected abstract virtual TBuilderEntity Merge(TConfigurationEntity oldValue, TConfigurationEntity newValue);
}
internal class DotNet.Testcontainers.Builders.Base64Provider : object {
    private JsonElement _rootElement;
    private ILogger _logger;
    [CompilerGeneratedAttribute]
private static Func`3<JsonProperty, string, bool> <HasDockerRegistryKey>k__BackingField;
    public static Func`3<JsonProperty, string, bool> HasDockerRegistryKey { get; }
    public Base64Provider(JsonDocument jsonDocument, ILogger logger);
    public Base64Provider(JsonElement jsonElement, ILogger logger);
    private static Base64Provider();
    [CompilerGeneratedAttribute]
public static Func`3<JsonProperty, string, bool> get_HasDockerRegistryKey();
    public sealed virtual bool IsApplicable(string hostname);
    public sealed virtual IDockerRegistryAuthenticationConfiguration GetAuthConfig(string hostname);
}
public static class DotNet.Testcontainers.Builders.BuildConfiguration : object {
    public static T Combine(T oldValue, T newValue);
    public static IEnumerable`1<T> Combine(IEnumerable`1<T> oldValue, IEnumerable`1<T> newValue);
    public static IReadOnlyList`1<T> Combine(IReadOnlyList`1<T> oldValue, IReadOnlyList`1<T> newValue);
    public static IReadOnlyDictionary`2<TKey, TValue> Combine(IReadOnlyDictionary`2<TKey, TValue> oldValue, IReadOnlyDictionary`2<TKey, TValue> newValue);
}
[IsReadOnlyAttribute]
public class DotNet.Testcontainers.Builders.CommonDirectoryPath : ValueType {
    private static string WorkingDirectoryPath;
    [CompilerGeneratedAttribute]
private string <DirectoryPath>k__BackingField;
    public string DirectoryPath { get; }
    public CommonDirectoryPath(string directoryPath);
    private static CommonDirectoryPath();
    [CompilerGeneratedAttribute]
public string get_DirectoryPath();
    public static CommonDirectoryPath GetBinDirectory();
    public static CommonDirectoryPath GetGitDirectory(string filePath);
    public static CommonDirectoryPath GetSolutionDirectory(string filePath);
    public static CommonDirectoryPath GetProjectDirectory(string filePath);
    public static CommonDirectoryPath GetCallerFileDirectory(string filePath);
    private static string GetDirectoryPath(string path, string searchPattern);
    private static string GetDirectoryPath(DirectoryInfo path, string searchPattern);
}
public static class DotNet.Testcontainers.Builders.Consume : object {
    public static IOutputConsumer DoNotConsumeStdoutAndStderr();
    public static IOutputConsumer RedirectStdoutAndStderrToConsole();
    public static IOutputConsumer RedirectStdoutAndStderrToStream(Stream stdout, Stream stderr);
}
public class DotNet.Testcontainers.Builders.ContainerBuilder : ContainerBuilder`3<ContainerBuilder, IContainer, IContainerConfiguration> {
    [CompilerGeneratedAttribute]
private IContainerConfiguration <DockerResourceConfiguration>k__BackingField;
    protected IContainerConfiguration DockerResourceConfiguration { get; }
    protected ContainerBuilder(IContainerConfiguration dockerResourceConfiguration);
    [CompilerGeneratedAttribute]
protected virtual IContainerConfiguration get_DockerResourceConfiguration();
    public virtual IContainer Build();
    protected sealed virtual ContainerBuilder Init();
    protected virtual ContainerBuilder Clone(IResourceConfiguration`1<CreateContainerParameters> resourceConfiguration);
    protected virtual ContainerBuilder Clone(IContainerConfiguration resourceConfiguration);
    protected virtual ContainerBuilder Merge(IContainerConfiguration oldValue, IContainerConfiguration newValue);
}
public abstract class DotNet.Testcontainers.Builders.ContainerBuilder`3 : AbstractBuilder`4<TBuilderEntity, TContainerEntity, CreateContainerParameters, TConfigurationEntity> {
    protected ContainerBuilder`3(TConfigurationEntity dockerResourceConfiguration);
    public sealed virtual TBuilderEntity DependsOn(IContainer container);
    public sealed virtual TBuilderEntity DependsOn(INetwork network);
    public sealed virtual TBuilderEntity DependsOn(IVolume volume, string destination);
    public sealed virtual TBuilderEntity DependsOn(IVolume volume, string destination, AccessMode accessMode);
    public sealed virtual TBuilderEntity WithImage(string image);
    public sealed virtual TBuilderEntity WithImage(IImage image);
    public sealed virtual TBuilderEntity WithImagePullPolicy(Func`2<ImageInspectResponse, bool> imagePullPolicy);
    public sealed virtual TBuilderEntity WithName(string name);
    public sealed virtual TBuilderEntity WithHostname(string hostname);
    public sealed virtual TBuilderEntity WithMacAddress(string macAddress);
    public sealed virtual TBuilderEntity WithWorkingDirectory(string workingDirectory);
    public sealed virtual TBuilderEntity WithEntrypoint(String[] entrypoint);
    public sealed virtual TBuilderEntity WithCommand(String[] command);
    public sealed virtual TBuilderEntity WithEnvironment(string name, string value);
    public sealed virtual TBuilderEntity WithEnvironment(IReadOnlyDictionary`2<string, string> environments);
    public sealed virtual TBuilderEntity WithExposedPort(int port);
    public sealed virtual TBuilderEntity WithExposedPort(string port);
    public sealed virtual TBuilderEntity WithPortBinding(int port, bool assignRandomHostPort);
    public sealed virtual TBuilderEntity WithPortBinding(int hostPort, int containerPort);
    public sealed virtual TBuilderEntity WithPortBinding(string port, bool assignRandomHostPort);
    public sealed virtual TBuilderEntity WithPortBinding(string hostPort, string containerPort);
    public sealed virtual TBuilderEntity WithResourceMapping(IResourceMapping resourceMapping);
    public sealed virtual TBuilderEntity WithResourceMapping(Byte[] resourceContent, string filePath, UnixFileModes fileMode);
    public sealed virtual TBuilderEntity WithResourceMapping(string source, string target, UnixFileModes fileMode);
    public sealed virtual TBuilderEntity WithResourceMapping(DirectoryInfo source, string target, UnixFileModes fileMode);
    public sealed virtual TBuilderEntity WithResourceMapping(FileInfo source, string target, UnixFileModes fileMode);
    public sealed virtual TBuilderEntity WithResourceMapping(FileInfo source, FileInfo target, UnixFileModes fileMode);
    public sealed virtual TBuilderEntity WithResourceMapping(Uri source, string target, UnixFileModes fileMode);
    public sealed virtual TBuilderEntity WithMount(IMount mount);
    public sealed virtual TBuilderEntity WithBindMount(string source, string destination);
    public sealed virtual TBuilderEntity WithBindMount(string source, string destination, AccessMode accessMode);
    public sealed virtual TBuilderEntity WithVolumeMount(string source, string destination);
    public sealed virtual TBuilderEntity WithVolumeMount(string source, string destination, AccessMode accessMode);
    public sealed virtual TBuilderEntity WithVolumeMount(IVolume volume, string destination);
    public sealed virtual TBuilderEntity WithVolumeMount(IVolume volume, string destination, AccessMode accessMode);
    public sealed virtual TBuilderEntity WithTmpfsMount(string destination);
    public sealed virtual TBuilderEntity WithTmpfsMount(string destination, AccessMode accessMode);
    public sealed virtual TBuilderEntity WithNetwork(string name);
    public sealed virtual TBuilderEntity WithNetwork(INetwork network);
    public sealed virtual TBuilderEntity WithNetworkAliases(String[] networkAliases);
    public sealed virtual TBuilderEntity WithNetworkAliases(IEnumerable`1<string> networkAliases);
    public sealed virtual TBuilderEntity WithExtraHost(string hostname, string ipAddress);
    public sealed virtual TBuilderEntity WithAutoRemove(bool autoRemove);
    public sealed virtual TBuilderEntity WithPrivileged(bool privileged);
    public sealed virtual TBuilderEntity WithOutputConsumer(IOutputConsumer outputConsumer);
    public sealed virtual TBuilderEntity WithWaitStrategy(IWaitForContainerOS waitStrategy);
    public sealed virtual TBuilderEntity WithStartupCallback(Func`3<TContainerEntity, CancellationToken, Task> startupCallback);
    protected virtual TBuilderEntity Init();
    protected virtual void Validate();
    protected abstract virtual TBuilderEntity Clone(IContainerConfiguration resourceConfiguration);
    private TBuilderEntity WithPortForwarding();
}
internal class DotNet.Testcontainers.Builders.CredsHelperProvider : object {
    private JsonElement _rootElement;
    private ILogger _logger;
    public CredsHelperProvider(JsonDocument jsonDocument, ILogger logger);
    public CredsHelperProvider(JsonElement jsonElement, ILogger logger);
    public sealed virtual bool IsApplicable(string hostname);
    public sealed virtual IDockerRegistryAuthenticationConfiguration GetAuthConfig(string hostname);
}
internal class DotNet.Testcontainers.Builders.CredsStoreProvider : object {
    private JsonElement _rootElement;
    private ILogger _logger;
    public CredsStoreProvider(JsonDocument jsonDocument, ILogger logger);
    public CredsStoreProvider(JsonElement jsonElement, ILogger logger);
    public sealed virtual bool IsApplicable(string hostname);
    public sealed virtual IDockerRegistryAuthenticationConfiguration GetAuthConfig(string hostname);
}
internal static class DotNet.Testcontainers.Builders.DockerCredentialProcess : object {
    public static string Get(string credentialProviderName, string hostname);
}
internal class DotNet.Testcontainers.Builders.DockerDesktopEndpointAuthenticationProvider : RootlessUnixEndpointAuthenticationProvider {
    public virtual bool IsApplicable();
    public sealed virtual string GetDockerConfig();
    public sealed virtual Uri GetDockerHost();
    public sealed virtual string GetDockerHostOverride();
    public sealed virtual string GetDockerSocketOverride();
    public sealed virtual JsonDocument GetDockerAuthConfig();
    public sealed virtual string GetDockerCertPath();
    public sealed virtual bool GetDockerTls();
    public sealed virtual bool GetDockerTlsVerify();
    public sealed virtual bool GetRyukDisabled();
    public sealed virtual bool GetRyukContainerPrivileged();
    public sealed virtual IImage GetRyukContainerImage();
    public sealed virtual string GetHubImageNamePrefix();
}
internal class DotNet.Testcontainers.Builders.DockerEndpointAuthenticationProvider : object {
    private static TaskFactory TaskFactory;
    private static DockerEndpointAuthenticationProvider();
    public virtual bool IsApplicable();
    public virtual bool IsAvailable();
    public virtual IDockerEndpointAuthenticationConfiguration GetAuthConfig();
}
internal class DotNet.Testcontainers.Builders.DockerRegistryAuthenticationProvider : object {
    private static string DockerHub;
    private static ConcurrentDictionary`2<string, Lazy`1<IDockerRegistryAuthenticationConfiguration>> Credentials;
    private static string UserProfileDockerConfigDirectoryPath;
    private FileInfo _dockerConfigFilePath;
    private ILogger _logger;
    public DockerRegistryAuthenticationProvider(ILogger logger);
    public DockerRegistryAuthenticationProvider(string dockerConfigFilePath, ILogger logger);
    public DockerRegistryAuthenticationProvider(FileInfo dockerConfigFilePath, ILogger logger);
    private static DockerRegistryAuthenticationProvider();
    public sealed virtual bool IsApplicable(string hostname);
    public sealed virtual IDockerRegistryAuthenticationConfiguration GetAuthConfig(string hostname);
    private static string GetDefaultDockerConfigFilePath();
    private static JsonDocument GetDefaultDockerAuthConfig();
    private IDockerRegistryAuthenticationConfiguration GetUncachedAuthConfig(string hostname);
    [CompilerGeneratedAttribute]
private Lazy`1<IDockerRegistryAuthenticationConfiguration> <GetAuthConfig>b__9_0(string key);
}
internal class DotNet.Testcontainers.Builders.EnvironmentEndpointAuthenticationProvider : DockerEndpointAuthenticationProvider {
    private Uri _dockerEngine;
    public EnvironmentEndpointAuthenticationProvider(ICustomConfiguration[] customConfigurations);
    public virtual bool IsApplicable();
    public virtual IDockerEndpointAuthenticationConfiguration GetAuthConfig();
}
public interface DotNet.Testcontainers.Builders.IAbstractBuilder`3 {
    public abstract virtual TBuilderEntity WithDockerEndpoint(string endpoint);
    public abstract virtual TBuilderEntity WithDockerEndpoint(Uri endpoint);
    public abstract virtual TBuilderEntity WithDockerEndpoint(IDockerEndpointAuthenticationConfiguration dockerEndpointAuthConfig);
    public abstract virtual TBuilderEntity WithCleanUp(bool cleanUp);
    public abstract virtual TBuilderEntity WithReuse(bool reuse);
    public abstract virtual TBuilderEntity WithLabel(string name, string value);
    public abstract virtual TBuilderEntity WithLabel(IReadOnlyDictionary`2<string, string> labels);
    public abstract virtual TBuilderEntity WithCreateParameterModifier(Action`1<TCreateResourceEntity> parameterModifier);
    public abstract virtual TBuilderEntity WithLogger(ILogger logger);
    public abstract virtual TResourceEntity Build();
}
public interface DotNet.Testcontainers.Builders.IContainerBuilder`2 {
    public abstract virtual TBuilderEntity DependsOn(IContainer container);
    public abstract virtual TBuilderEntity DependsOn(INetwork network);
    public abstract virtual TBuilderEntity DependsOn(IVolume volume, string destination);
    public abstract virtual TBuilderEntity DependsOn(IVolume volume, string destination, AccessMode accessMode);
    public abstract virtual TBuilderEntity WithImage(string image);
    public abstract virtual TBuilderEntity WithImage(IImage image);
    public abstract virtual TBuilderEntity WithImagePullPolicy(Func`2<ImageInspectResponse, bool> imagePullPolicy);
    public abstract virtual TBuilderEntity WithName(string name);
    public abstract virtual TBuilderEntity WithHostname(string hostname);
    public abstract virtual TBuilderEntity WithMacAddress(string macAddress);
    public abstract virtual TBuilderEntity WithWorkingDirectory(string workingDirectory);
    public abstract virtual TBuilderEntity WithEntrypoint(String[] entrypoint);
    public abstract virtual TBuilderEntity WithCommand(String[] command);
    public abstract virtual TBuilderEntity WithEnvironment(string name, string value);
    public abstract virtual TBuilderEntity WithEnvironment(IReadOnlyDictionary`2<string, string> environments);
    public abstract virtual TBuilderEntity WithExposedPort(int port);
    public abstract virtual TBuilderEntity WithExposedPort(string port);
    public abstract virtual TBuilderEntity WithPortBinding(int port, bool assignRandomHostPort);
    public abstract virtual TBuilderEntity WithPortBinding(int hostPort, int containerPort);
    public abstract virtual TBuilderEntity WithPortBinding(string port, bool assignRandomHostPort);
    public abstract virtual TBuilderEntity WithPortBinding(string hostPort, string containerPort);
    public abstract virtual TBuilderEntity WithResourceMapping(IResourceMapping resourceMapping);
    public abstract virtual TBuilderEntity WithResourceMapping(Byte[] resourceContent, string filePath, UnixFileModes fileMode);
    public abstract virtual TBuilderEntity WithResourceMapping(string source, string target, UnixFileModes fileMode);
    public abstract virtual TBuilderEntity WithResourceMapping(DirectoryInfo source, string target, UnixFileModes fileMode);
    public abstract virtual TBuilderEntity WithResourceMapping(FileInfo source, string target, UnixFileModes fileMode);
    public abstract virtual TBuilderEntity WithResourceMapping(FileInfo source, FileInfo target, UnixFileModes fileMode);
    public abstract virtual TBuilderEntity WithResourceMapping(Uri source, string target, UnixFileModes fileMode);
    public abstract virtual TBuilderEntity WithMount(IMount mount);
    public abstract virtual TBuilderEntity WithBindMount(string source, string destination);
    public abstract virtual TBuilderEntity WithBindMount(string source, string destination, AccessMode accessMode);
    public abstract virtual TBuilderEntity WithVolumeMount(string source, string destination);
    public abstract virtual TBuilderEntity WithVolumeMount(string source, string destination, AccessMode accessMode);
    public abstract virtual TBuilderEntity WithVolumeMount(IVolume volume, string destination);
    public abstract virtual TBuilderEntity WithVolumeMount(IVolume volume, string destination, AccessMode accessMode);
    public abstract virtual TBuilderEntity WithTmpfsMount(string destination);
    public abstract virtual TBuilderEntity WithTmpfsMount(string destination, AccessMode accessMode);
    public abstract virtual TBuilderEntity WithNetwork(string name);
    public abstract virtual TBuilderEntity WithNetwork(INetwork network);
    public abstract virtual TBuilderEntity WithNetworkAliases(String[] networkAliases);
    public abstract virtual TBuilderEntity WithNetworkAliases(IEnumerable`1<string> networkAliases);
    public abstract virtual TBuilderEntity WithExtraHost(string hostname, string ipAddress);
    public abstract virtual TBuilderEntity WithAutoRemove(bool autoRemove);
    public abstract virtual TBuilderEntity WithPrivileged(bool privileged);
    public abstract virtual TBuilderEntity WithOutputConsumer(IOutputConsumer outputConsumer);
    public abstract virtual TBuilderEntity WithWaitStrategy(IWaitForContainerOS waitStrategy);
    public abstract virtual TBuilderEntity WithStartupCallback(Func`3<TContainerEntity, CancellationToken, Task> startupCallback);
}
internal interface DotNet.Testcontainers.Builders.IDockerEndpointAuthenticationProvider {
    public abstract virtual bool IsApplicable();
    public abstract virtual bool IsAvailable();
    public abstract virtual IDockerEndpointAuthenticationConfiguration GetAuthConfig();
}
internal interface DotNet.Testcontainers.Builders.IDockerRegistryAuthenticationProvider {
    public abstract virtual bool IsApplicable(string hostname);
    public abstract virtual IDockerRegistryAuthenticationConfiguration GetAuthConfig(string hostname);
}
public interface DotNet.Testcontainers.Builders.IImageFromDockerfileBuilder`1 {
    public abstract virtual TBuilderEntity WithName(string name);
    public abstract virtual TBuilderEntity WithName(IImage name);
    public abstract virtual TBuilderEntity WithDockerfile(string dockerfile);
    public abstract virtual TBuilderEntity WithDockerfileDirectory(string dockerfileDirectory);
    public abstract virtual TBuilderEntity WithDockerfileDirectory(CommonDirectoryPath commonDirectoryPath, string dockerfileDirectory);
    public abstract virtual TBuilderEntity WithImageBuildPolicy(Func`2<ImageInspectResponse, bool> imageBuildPolicy);
    public abstract virtual TBuilderEntity WithDeleteIfExists(bool deleteIfExists);
    public abstract virtual TBuilderEntity WithBuildArgument(string name, string value);
}
public class DotNet.Testcontainers.Builders.ImageFromDockerfileBuilder : AbstractBuilder`4<ImageFromDockerfileBuilder, IFutureDockerImage, ImageBuildParameters, IImageFromDockerfileConfiguration> {
    [CompilerGeneratedAttribute]
private IImageFromDockerfileConfiguration <DockerResourceConfiguration>k__BackingField;
    protected IImageFromDockerfileConfiguration DockerResourceConfiguration { get; }
    private ImageFromDockerfileBuilder(IImageFromDockerfileConfiguration dockerResourceConfiguration);
    [CompilerGeneratedAttribute]
protected virtual IImageFromDockerfileConfiguration get_DockerResourceConfiguration();
    public sealed virtual ImageFromDockerfileBuilder WithName(string name);
    public sealed virtual ImageFromDockerfileBuilder WithName(IImage name);
    public sealed virtual ImageFromDockerfileBuilder WithDockerfile(string dockerfile);
    public sealed virtual ImageFromDockerfileBuilder WithDockerfileDirectory(string dockerfileDirectory);
    public sealed virtual ImageFromDockerfileBuilder WithDockerfileDirectory(CommonDirectoryPath commonDirectoryPath, string dockerfileDirectory);
    public sealed virtual ImageFromDockerfileBuilder WithImageBuildPolicy(Func`2<ImageInspectResponse, bool> imageBuildPolicy);
    public sealed virtual ImageFromDockerfileBuilder WithDeleteIfExists(bool deleteIfExists);
    public sealed virtual ImageFromDockerfileBuilder WithBuildArgument(string name, string value);
    public virtual IFutureDockerImage Build();
    protected sealed virtual ImageFromDockerfileBuilder Init();
    protected virtual void Validate();
    protected virtual ImageFromDockerfileBuilder Clone(IResourceConfiguration`1<ImageBuildParameters> resourceConfiguration);
    protected virtual ImageFromDockerfileBuilder Merge(IImageFromDockerfileConfiguration oldValue, IImageFromDockerfileConfiguration newValue);
}
public interface DotNet.Testcontainers.Builders.INetworkBuilder`1 {
    public abstract virtual TBuilderEntity WithName(string name);
    public abstract virtual TBuilderEntity WithDriver(NetworkDriver driver);
    public abstract virtual TBuilderEntity WithOption(string name, string value);
}
public interface DotNet.Testcontainers.Builders.IVolumeBuilder`1 {
    public abstract virtual TBuilderEntity WithName(string name);
}
internal class DotNet.Testcontainers.Builders.MTlsEndpointAuthenticationProvider : TlsEndpointAuthenticationProvider {
    public MTlsEndpointAuthenticationProvider(ICustomConfiguration[] customConfigurations);
    public virtual bool IsApplicable();
    public virtual IDockerEndpointAuthenticationConfiguration GetAuthConfig();
    protected virtual X509Certificate2 GetClientCertificate();
    [CompilerGeneratedAttribute]
private string <IsApplicable>b__2_0(string fileName);
}
public class DotNet.Testcontainers.Builders.NetworkBuilder : AbstractBuilder`4<NetworkBuilder, INetwork, NetworksCreateParameters, INetworkConfiguration> {
    [CompilerGeneratedAttribute]
private INetworkConfiguration <DockerResourceConfiguration>k__BackingField;
    protected INetworkConfiguration DockerResourceConfiguration { get; }
    protected NetworkBuilder(INetworkConfiguration dockerResourceConfiguration);
    [CompilerGeneratedAttribute]
protected virtual INetworkConfiguration get_DockerResourceConfiguration();
    public sealed virtual NetworkBuilder WithName(string name);
    public sealed virtual NetworkBuilder WithDriver(NetworkDriver driver);
    public sealed virtual NetworkBuilder WithOption(string name, string value);
    public virtual INetwork Build();
    protected sealed virtual NetworkBuilder Init();
    protected virtual void Validate();
    protected virtual NetworkBuilder Clone(IResourceConfiguration`1<NetworksCreateParameters> resourceConfiguration);
    protected virtual NetworkBuilder Merge(INetworkConfiguration oldValue, INetworkConfiguration newValue);
}
internal class DotNet.Testcontainers.Builders.NpipeEndpointAuthenticationProvider : DockerEndpointAuthenticationProvider {
    [CompilerGeneratedAttribute]
private static Uri <DockerEngine>k__BackingField;
    public static Uri DockerEngine { get; }
    private static NpipeEndpointAuthenticationProvider();
    [CompilerGeneratedAttribute]
public static Uri get_DockerEngine();
    public virtual bool IsApplicable();
    public virtual IDockerEndpointAuthenticationConfiguration GetAuthConfig();
}
internal class DotNet.Testcontainers.Builders.RootlessUnixEndpointAuthenticationProvider : DockerEndpointAuthenticationProvider {
    [CompilerGeneratedAttribute]
private Uri <DockerEngine>k__BackingField;
    protected Uri DockerEngine { get; }
    public RootlessUnixEndpointAuthenticationProvider(String[] socketPaths);
    [CompilerGeneratedAttribute]
protected Uri get_DockerEngine();
    public virtual bool IsApplicable();
    public virtual IDockerEndpointAuthenticationConfiguration GetAuthConfig();
    protected static string GetSocketPathFromEnv();
    protected static string GetSocketPathFromHomeDesktopDir();
    protected static string GetSocketPathFromHomeRunDir();
    protected static string GetSocketPathFromRunDir();
}
internal class DotNet.Testcontainers.Builders.TestcontainersEndpointAuthenticationProvider : DockerEndpointAuthenticationProvider {
    private ICustomConfiguration _customConfiguration;
    private Uri _dockerEngine;
    public TestcontainersEndpointAuthenticationProvider(String[] lines);
    private TestcontainersEndpointAuthenticationProvider(ICustomConfiguration customConfiguration);
    public virtual bool IsApplicable();
    public virtual IDockerEndpointAuthenticationConfiguration GetAuthConfig();
    public sealed virtual string GetDockerConfig();
    public sealed virtual Uri GetDockerHost();
    public sealed virtual string GetDockerHostOverride();
    public sealed virtual string GetDockerSocketOverride();
    public sealed virtual JsonDocument GetDockerAuthConfig();
    public sealed virtual string GetDockerCertPath();
    public sealed virtual bool GetDockerTls();
    public sealed virtual bool GetDockerTlsVerify();
    public sealed virtual bool GetRyukDisabled();
    public sealed virtual bool GetRyukContainerPrivileged();
    public sealed virtual IImage GetRyukContainerImage();
    public sealed virtual string GetHubImageNamePrefix();
}
internal class DotNet.Testcontainers.Builders.TlsCredentials : CertificateCredentials {
    public virtual bool IsTlsCredentials();
    public virtual HttpMessageHandler GetHandler(HttpMessageHandler innerHandler);
}
internal class DotNet.Testcontainers.Builders.TlsEndpointAuthenticationProvider : DockerEndpointAuthenticationProvider {
    protected static string CaCertificateFileName;
    protected static string ClientCertificateFileName;
    protected static string ClientCertificateKeyFileName;
    [CompilerGeneratedAttribute]
private bool <TlsEnabled>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <TlsVerifyEnabled>k__BackingField;
    [CompilerGeneratedAttribute]
private string <CertificatesDirectoryPath>k__BackingField;
    [CompilerGeneratedAttribute]
private Uri <DockerEngine>k__BackingField;
    protected bool TlsEnabled { get; }
    protected bool TlsVerifyEnabled { get; }
    protected string CertificatesDirectoryPath { get; }
    protected Uri DockerEngine { get; }
    public TlsEndpointAuthenticationProvider(ICustomConfiguration[] customConfigurations);
    private TlsEndpointAuthenticationProvider(ICustomConfiguration customConfiguration);
    [CompilerGeneratedAttribute]
protected bool get_TlsEnabled();
    [CompilerGeneratedAttribute]
protected bool get_TlsVerifyEnabled();
    [CompilerGeneratedAttribute]
protected string get_CertificatesDirectoryPath();
    [CompilerGeneratedAttribute]
protected Uri get_DockerEngine();
    public virtual bool IsApplicable();
    public virtual IDockerEndpointAuthenticationConfiguration GetAuthConfig();
    protected virtual X509Certificate2 GetCaCertificate();
    protected virtual X509Certificate2 GetClientCertificate();
    protected virtual bool ServerCertificateValidationCallback(object sender, X509Certificate certificate, X509Chain chain, SslPolicyErrors sslPolicyErrors);
}
internal class DotNet.Testcontainers.Builders.UnixEndpointAuthenticationProvider : DockerEndpointAuthenticationProvider {
    [CompilerGeneratedAttribute]
private static Uri <DockerEngine>k__BackingField;
    public static Uri DockerEngine { get; }
    private static UnixEndpointAuthenticationProvider();
    [CompilerGeneratedAttribute]
public static Uri get_DockerEngine();
    public virtual bool IsApplicable();
    public virtual IDockerEndpointAuthenticationConfiguration GetAuthConfig();
}
public class DotNet.Testcontainers.Builders.VolumeBuilder : AbstractBuilder`4<VolumeBuilder, IVolume, VolumesCreateParameters, IVolumeConfiguration> {
    [CompilerGeneratedAttribute]
private IVolumeConfiguration <DockerResourceConfiguration>k__BackingField;
    protected IVolumeConfiguration DockerResourceConfiguration { get; }
    protected VolumeBuilder(IVolumeConfiguration dockerResourceConfiguration);
    [CompilerGeneratedAttribute]
protected virtual IVolumeConfiguration get_DockerResourceConfiguration();
    public sealed virtual VolumeBuilder WithName(string name);
    public virtual IVolume Build();
    protected sealed virtual VolumeBuilder Init();
    protected virtual void Validate();
    protected virtual VolumeBuilder Clone(IResourceConfiguration`1<VolumesCreateParameters> resourceConfiguration);
    protected virtual VolumeBuilder Merge(IVolumeConfiguration oldValue, IVolumeConfiguration newValue);
}
public static class DotNet.Testcontainers.Builders.Wait : object {
    public static IWaitForContainerOS ForUnixContainer();
    public static IWaitForContainerOS ForWindowsContainer();
}
internal abstract class DotNet.Testcontainers.Clients.BaseConverter`2 : object {
    protected BaseConverter`2(string name);
    public abstract virtual TTarget Convert(TSource source);
}
internal abstract class DotNet.Testcontainers.Clients.CollectionConverter`2 : BaseConverter`2<IEnumerable`1<TSource>, IEnumerable`1<TTarget>> {
    protected CollectionConverter`2(string name);
}
internal class DotNet.Testcontainers.Clients.ContainerConfigurationConverter : object {
    private static string UdpPortSuffix;
    private static string TcpPortSuffix;
    private static string SctpPortSuffix;
    [CompilerGeneratedAttribute]
private IList`1<string> <Entrypoint>k__BackingField;
    [CompilerGeneratedAttribute]
private IList`1<string> <Command>k__BackingField;
    [CompilerGeneratedAttribute]
private IList`1<string> <ExtraHosts>k__BackingField;
    [CompilerGeneratedAttribute]
private IList`1<string> <Environments>k__BackingField;
    [CompilerGeneratedAttribute]
private IDictionary`2<string, string> <Labels>k__BackingField;
    [CompilerGeneratedAttribute]
private IDictionary`2<string, EmptyStruct> <ExposedPorts>k__BackingField;
    [CompilerGeneratedAttribute]
private IDictionary`2<string, IList`1<PortBinding>> <PortBindings>k__BackingField;
    [CompilerGeneratedAttribute]
private IList`1<Mount> <Mounts>k__BackingField;
    [CompilerGeneratedAttribute]
private IDictionary`2<string, EndpointSettings> <Networks>k__BackingField;
    public IList`1<string> Entrypoint { get; }
    public IList`1<string> Command { get; }
    public IList`1<string> ExtraHosts { get; }
    public IList`1<string> Environments { get; }
    public IDictionary`2<string, string> Labels { get; }
    public IDictionary`2<string, EmptyStruct> ExposedPorts { get; }
    public IDictionary`2<string, IList`1<PortBinding>> PortBindings { get; }
    public IList`1<Mount> Mounts { get; }
    public IDictionary`2<string, EndpointSettings> Networks { get; }
    public ContainerConfigurationConverter(IContainerConfiguration configuration);
    [CompilerGeneratedAttribute]
public IList`1<string> get_Entrypoint();
    [CompilerGeneratedAttribute]
public IList`1<string> get_Command();
    [CompilerGeneratedAttribute]
public IList`1<string> get_ExtraHosts();
    [CompilerGeneratedAttribute]
public IList`1<string> get_Environments();
    [CompilerGeneratedAttribute]
public IDictionary`2<string, string> get_Labels();
    [CompilerGeneratedAttribute]
public IDictionary`2<string, EmptyStruct> get_ExposedPorts();
    [CompilerGeneratedAttribute]
public IDictionary`2<string, IList`1<PortBinding>> get_PortBindings();
    [CompilerGeneratedAttribute]
public IList`1<Mount> get_Mounts();
    [CompilerGeneratedAttribute]
public IDictionary`2<string, EndpointSettings> get_Networks();
    private static string GetQualifiedPort(string containerPort);
}
internal class DotNet.Testcontainers.Clients.DefaultLabels : ReadOnlyDictionary`2<string, string> {
    [CompilerGeneratedAttribute]
private static IReadOnlyDictionary`2<string, string> <Instance>k__BackingField;
    public static IReadOnlyDictionary`2<string, string> Instance { get; }
    private static DefaultLabels();
    [CompilerGeneratedAttribute]
public static IReadOnlyDictionary`2<string, string> get_Instance();
}
internal abstract class DotNet.Testcontainers.Clients.DictionaryConverter`1 : BaseConverter`2<IEnumerable`1<KeyValuePair`2<string, string>>, TTarget> {
    protected DictionaryConverter`1(string name);
}
internal class DotNet.Testcontainers.Clients.DockerApiClient : object {
    private static ConcurrentDictionary`2<Uri, Lazy`1<IDockerClient>> Clients;
    private static ISet`1<int> ProcessedHashCodes;
    private static SemaphoreSlim RuntimeInitialized;
    [CompilerGeneratedAttribute]
private IDockerClient <DockerClient>k__BackingField;
    [CompilerGeneratedAttribute]
private ILogger <Logger>k__BackingField;
    protected IDockerClient DockerClient { get; }
    protected ILogger Logger { get; }
    protected DockerApiClient(Guid sessionId, IDockerEndpointAuthenticationConfiguration dockerEndpointAuthConfig, ILogger logger);
    protected DockerApiClient(IDockerClient dockerClient, ILogger logger);
    private static DockerApiClient();
    [CompilerGeneratedAttribute]
protected IDockerClient get_DockerClient();
    [CompilerGeneratedAttribute]
protected ILogger get_Logger();
    [AsyncStateMachineAttribute("DotNet.Testcontainers.Clients.DockerApiClient/<LogContainerRuntimeInfoAsync>d__11")]
public sealed virtual Task LogContainerRuntimeInfoAsync(CancellationToken ct);
    private static IDockerClient GetDockerClient(Guid sessionId, IDockerEndpointAuthenticationConfiguration dockerEndpointAuthConfig);
}
internal class DotNet.Testcontainers.Clients.DockerContainerOperations : DockerApiClient {
    public DockerContainerOperations(Guid sessionId, IDockerEndpointAuthenticationConfiguration dockerEndpointAuthConfig, ILogger logger);
    [AsyncStateMachineAttribute("DotNet.Testcontainers.Clients.DockerContainerOperations/<GetAllAsync>d__1")]
public sealed virtual Task`1<IEnumerable`1<ContainerListResponse>> GetAllAsync(CancellationToken ct);
    [AsyncStateMachineAttribute("DotNet.Testcontainers.Clients.DockerContainerOperations/<GetAllAsync>d__2")]
public sealed virtual Task`1<IEnumerable`1<ContainerListResponse>> GetAllAsync(FilterByProperty filters, CancellationToken ct);
    [AsyncStateMachineAttribute("DotNet.Testcontainers.Clients.DockerContainerOperations/<ByIdAsync>d__3")]
public sealed virtual Task`1<ContainerInspectResponse> ByIdAsync(string id, CancellationToken ct);
    [AsyncStateMachineAttribute("DotNet.Testcontainers.Clients.DockerContainerOperations/<ExistsWithIdAsync>d__4")]
public sealed virtual Task`1<bool> ExistsWithIdAsync(string id, CancellationToken ct);
    [AsyncStateMachineAttribute("DotNet.Testcontainers.Clients.DockerContainerOperations/<GetExitCodeAsync>d__5")]
public sealed virtual Task`1<long> GetExitCodeAsync(string id, CancellationToken ct);
    [AsyncStateMachineAttribute("DotNet.Testcontainers.Clients.DockerContainerOperations/<GetLogsAsync>d__6")]
public sealed virtual Task`1<ValueTuple`2<string, string>> GetLogsAsync(string id, TimeSpan since, TimeSpan until, bool timestampsEnabled, CancellationToken ct);
    public sealed virtual Task StartAsync(string id, CancellationToken ct);
    public sealed virtual Task StopAsync(string id, CancellationToken ct);
    public sealed virtual Task RemoveAsync(string id, CancellationToken ct);
    public sealed virtual Task ExtractArchiveToContainerAsync(string id, string path, TarOutputMemoryStream tarStream, CancellationToken ct);
    [AsyncStateMachineAttribute("DotNet.Testcontainers.Clients.DockerContainerOperations/<GetArchiveFromContainerAsync>d__11")]
public sealed virtual Task`1<Stream> GetArchiveFromContainerAsync(string id, string path, CancellationToken ct);
    [AsyncStateMachineAttribute("DotNet.Testcontainers.Clients.DockerContainerOperations/<AttachAsync>d__12")]
public sealed virtual Task AttachAsync(string id, IOutputConsumer outputConsumer, CancellationToken ct);
    [AsyncStateMachineAttribute("DotNet.Testcontainers.Clients.DockerContainerOperations/<ExecAsync>d__13")]
public sealed virtual Task`1<ExecResult> ExecAsync(string id, IList`1<string> command, CancellationToken ct);
    [AsyncStateMachineAttribute("DotNet.Testcontainers.Clients.DockerContainerOperations/<RunAsync>d__14")]
public sealed virtual Task`1<string> RunAsync(IContainerConfiguration configuration, CancellationToken ct);
}
internal class DotNet.Testcontainers.Clients.DockerImageOperations : DockerApiClient {
    private TraceProgress _traceProgress;
    public DockerImageOperations(Guid sessionId, IDockerEndpointAuthenticationConfiguration dockerEndpointAuthConfig, ILogger logger);
    [AsyncStateMachineAttribute("DotNet.Testcontainers.Clients.DockerImageOperations/<GetAllAsync>d__2")]
public sealed virtual Task`1<IEnumerable`1<ImagesListResponse>> GetAllAsync(CancellationToken ct);
    [AsyncStateMachineAttribute("DotNet.Testcontainers.Clients.DockerImageOperations/<GetAllAsync>d__3")]
public sealed virtual Task`1<IEnumerable`1<ImagesListResponse>> GetAllAsync(FilterByProperty filters, CancellationToken ct);
    [AsyncStateMachineAttribute("DotNet.Testcontainers.Clients.DockerImageOperations/<ByIdAsync>d__4")]
public sealed virtual Task`1<ImageInspectResponse> ByIdAsync(string id, CancellationToken ct);
    [AsyncStateMachineAttribute("DotNet.Testcontainers.Clients.DockerImageOperations/<ExistsWithIdAsync>d__5")]
public sealed virtual Task`1<bool> ExistsWithIdAsync(string id, CancellationToken ct);
    [AsyncStateMachineAttribute("DotNet.Testcontainers.Clients.DockerImageOperations/<CreateAsync>d__6")]
public sealed virtual Task CreateAsync(IImage image, IDockerRegistryAuthenticationConfiguration dockerRegistryAuthConfig, CancellationToken ct);
    public sealed virtual Task DeleteAsync(IImage image, CancellationToken ct);
    [AsyncStateMachineAttribute("DotNet.Testcontainers.Clients.DockerImageOperations/<BuildAsync>d__8")]
public sealed virtual Task`1<string> BuildAsync(IImageFromDockerfileConfiguration configuration, ITarArchive dockerfileArchive, CancellationToken ct);
}
internal class DotNet.Testcontainers.Clients.DockerNetworkOperations : DockerApiClient {
    public DockerNetworkOperations(Guid sessionId, IDockerEndpointAuthenticationConfiguration dockerEndpointAuthConfig, ILogger logger);
    [AsyncStateMachineAttribute("DotNet.Testcontainers.Clients.DockerNetworkOperations/<GetAllAsync>d__1")]
public sealed virtual Task`1<IEnumerable`1<NetworkResponse>> GetAllAsync(CancellationToken ct);
    [AsyncStateMachineAttribute("DotNet.Testcontainers.Clients.DockerNetworkOperations/<GetAllAsync>d__2")]
public sealed virtual Task`1<IEnumerable`1<NetworkResponse>> GetAllAsync(FilterByProperty filters, CancellationToken ct);
    [AsyncStateMachineAttribute("DotNet.Testcontainers.Clients.DockerNetworkOperations/<ByIdAsync>d__3")]
public sealed virtual Task`1<NetworkResponse> ByIdAsync(string id, CancellationToken ct);
    [AsyncStateMachineAttribute("DotNet.Testcontainers.Clients.DockerNetworkOperations/<ExistsWithIdAsync>d__4")]
public sealed virtual Task`1<bool> ExistsWithIdAsync(string id, CancellationToken ct);
    [AsyncStateMachineAttribute("DotNet.Testcontainers.Clients.DockerNetworkOperations/<CreateAsync>d__5")]
public sealed virtual Task`1<string> CreateAsync(INetworkConfiguration configuration, CancellationToken ct);
    public sealed virtual Task DeleteAsync(string id, CancellationToken ct);
    public sealed virtual Task ConnectAsync(string networkId, string containerId, CancellationToken ct);
}
internal class DotNet.Testcontainers.Clients.DockerSystemOperations : DockerApiClient {
    public DockerSystemOperations(Guid sessionId, IDockerEndpointAuthenticationConfiguration dockerEndpointAuthConfig, ILogger logger);
    [AsyncStateMachineAttribute("DotNet.Testcontainers.Clients.DockerSystemOperations/<GetIsWindowsEngineEnabled>d__1")]
public sealed virtual Task`1<bool> GetIsWindowsEngineEnabled(CancellationToken ct);
    public sealed virtual Task`1<SystemInfoResponse> GetInfoAsync(CancellationToken ct);
    public sealed virtual Task`1<VersionResponse> GetVersionAsync(CancellationToken ct);
}
internal class DotNet.Testcontainers.Clients.DockerVolumeOperations : DockerApiClient {
    public DockerVolumeOperations(Guid sessionId, IDockerEndpointAuthenticationConfiguration dockerEndpointAuthConfig, ILogger logger);
    [AsyncStateMachineAttribute("DotNet.Testcontainers.Clients.DockerVolumeOperations/<GetAllAsync>d__1")]
public sealed virtual Task`1<IEnumerable`1<VolumeResponse>> GetAllAsync(CancellationToken ct);
    [AsyncStateMachineAttribute("DotNet.Testcontainers.Clients.DockerVolumeOperations/<GetAllAsync>d__2")]
public sealed virtual Task`1<IEnumerable`1<VolumeResponse>> GetAllAsync(FilterByProperty filters, CancellationToken ct);
    [AsyncStateMachineAttribute("DotNet.Testcontainers.Clients.DockerVolumeOperations/<ByIdAsync>d__3")]
public sealed virtual Task`1<VolumeResponse> ByIdAsync(string id, CancellationToken ct);
    [AsyncStateMachineAttribute("DotNet.Testcontainers.Clients.DockerVolumeOperations/<ExistsWithIdAsync>d__4")]
public sealed virtual Task`1<bool> ExistsWithIdAsync(string id, CancellationToken ct);
    [AsyncStateMachineAttribute("DotNet.Testcontainers.Clients.DockerVolumeOperations/<CreateAsync>d__5")]
public sealed virtual Task`1<string> CreateAsync(IVolumeConfiguration configuration, CancellationToken ct);
    public sealed virtual Task DeleteAsync(string name, CancellationToken ct);
}
public class DotNet.Testcontainers.Clients.FilterByProperty : ConcurrentDictionary`2<string, IDictionary`2<string, bool>> {
    public FilterByProperty Add(string property, string value);
}
public class DotNet.Testcontainers.Clients.FilterByReuseHash : FilterByProperty {
    public FilterByReuseHash(IContainerConfiguration resourceConfiguration);
    public FilterByReuseHash(INetworkConfiguration resourceConfiguration);
    public FilterByReuseHash(IVolumeConfiguration resourceConfiguration);
    private FilterByReuseHash(string hash);
}
internal interface DotNet.Testcontainers.Clients.IDockerContainerOperations {
    public abstract virtual Task`1<long> GetExitCodeAsync(string id, CancellationToken ct);
    public abstract virtual Task`1<ValueTuple`2<string, string>> GetLogsAsync(string id, TimeSpan since, TimeSpan until, bool timestampsEnabled, CancellationToken ct);
    public abstract virtual Task StartAsync(string id, CancellationToken ct);
    public abstract virtual Task StopAsync(string id, CancellationToken ct);
    public abstract virtual Task RemoveAsync(string id, CancellationToken ct);
    public abstract virtual Task ExtractArchiveToContainerAsync(string id, string path, TarOutputMemoryStream tarStream, CancellationToken ct);
    public abstract virtual Task`1<Stream> GetArchiveFromContainerAsync(string id, string path, CancellationToken ct);
    public abstract virtual Task AttachAsync(string id, IOutputConsumer outputConsumer, CancellationToken ct);
    public abstract virtual Task`1<ExecResult> ExecAsync(string id, IList`1<string> command, CancellationToken ct);
    public abstract virtual Task`1<string> RunAsync(IContainerConfiguration configuration, CancellationToken ct);
}
internal interface DotNet.Testcontainers.Clients.IDockerImageOperations {
    public abstract virtual Task CreateAsync(IImage image, IDockerRegistryAuthenticationConfiguration dockerRegistryAuthConfig, CancellationToken ct);
    public abstract virtual Task DeleteAsync(IImage image, CancellationToken ct);
    public abstract virtual Task`1<string> BuildAsync(IImageFromDockerfileConfiguration configuration, ITarArchive dockerfileArchive, CancellationToken ct);
}
internal interface DotNet.Testcontainers.Clients.IDockerNetworkOperations {
    public abstract virtual Task`1<string> CreateAsync(INetworkConfiguration configuration, CancellationToken ct);
    public abstract virtual Task DeleteAsync(string id, CancellationToken ct);
    public abstract virtual Task ConnectAsync(string networkId, string containerId, CancellationToken ct);
}
internal interface DotNet.Testcontainers.Clients.IDockerSystemOperations {
    public abstract virtual Task LogContainerRuntimeInfoAsync(CancellationToken ct);
    public abstract virtual Task`1<bool> GetIsWindowsEngineEnabled(CancellationToken ct);
    public abstract virtual Task`1<SystemInfoResponse> GetInfoAsync(CancellationToken ct);
    public abstract virtual Task`1<VersionResponse> GetVersionAsync(CancellationToken ct);
}
internal interface DotNet.Testcontainers.Clients.IDockerVolumeOperations {
    public abstract virtual Task`1<string> CreateAsync(IVolumeConfiguration configuration, CancellationToken ct);
    public abstract virtual Task DeleteAsync(string name, CancellationToken ct);
}
internal interface DotNet.Testcontainers.Clients.IHasListOperations`2 {
    public abstract virtual Task`1<IEnumerable`1<TListEntity>> GetAllAsync(CancellationToken ct);
    public abstract virtual Task`1<IEnumerable`1<TListEntity>> GetAllAsync(FilterByProperty filters, CancellationToken ct);
    public abstract virtual Task`1<TInspectEntity> ByIdAsync(string id, CancellationToken ct);
    public abstract virtual Task`1<bool> ExistsWithIdAsync(string id, CancellationToken ct);
}
internal interface DotNet.Testcontainers.Clients.ITestcontainersClient {
    public IDockerContainerOperations Container { get; }
    public IDockerImageOperations Image { get; }
    public IDockerNetworkOperations Network { get; }
    public IDockerVolumeOperations Volume { get; }
    public IDockerSystemOperations System { get; }
    public bool IsRunningInsideDocker { get; }
    public abstract virtual IDockerContainerOperations get_Container();
    public abstract virtual IDockerImageOperations get_Image();
    public abstract virtual IDockerNetworkOperations get_Network();
    public abstract virtual IDockerVolumeOperations get_Volume();
    public abstract virtual IDockerSystemOperations get_System();
    public abstract virtual bool get_IsRunningInsideDocker();
    public abstract virtual Task`1<long> GetContainerExitCodeAsync(string id, CancellationToken ct);
    public abstract virtual Task`1<ValueTuple`2<string, string>> GetContainerLogsAsync(string id, DateTime since, DateTime until, bool timestampsEnabled, CancellationToken ct);
    public abstract virtual Task StartAsync(string id, CancellationToken ct);
    public abstract virtual Task StopAsync(string id, CancellationToken ct);
    public abstract virtual Task RemoveAsync(string id, CancellationToken ct);
    public abstract virtual Task AttachAsync(string id, IOutputConsumer outputConsumer, CancellationToken ct);
    public abstract virtual Task`1<ExecResult> ExecAsync(string id, IList`1<string> command, CancellationToken ct);
    public abstract virtual Task CopyAsync(string id, IResourceMapping resourceMapping, CancellationToken ct);
    public abstract virtual Task CopyAsync(string id, DirectoryInfo source, string target, UnixFileModes fileMode, CancellationToken ct);
    public abstract virtual Task CopyAsync(string id, FileInfo source, string target, UnixFileModes fileMode, CancellationToken ct);
    public abstract virtual Task`1<Byte[]> ReadFileAsync(string id, string filePath, CancellationToken ct);
    public abstract virtual Task`1<string> RunAsync(IContainerConfiguration configuration, CancellationToken ct);
    public abstract virtual Task`1<string> BuildAsync(IImageFromDockerfileConfiguration configuration, CancellationToken ct);
}
internal class DotNet.Testcontainers.Clients.TestcontainersClient : object {
    public static string TestcontainersLabel;
    public static string TestcontainersLangLabel;
    public static string TestcontainersVersionLabel;
    public static string TestcontainersSessionIdLabel;
    public static string TestcontainersReuseHashLabel;
    public static string Version;
    private static string OSRootDirectory;
    private DockerRegistryAuthenticationProvider _registryAuthenticationProvider;
    private ILogger _logger;
    [CompilerGeneratedAttribute]
private IDockerContainerOperations <Container>k__BackingField;
    [CompilerGeneratedAttribute]
private IDockerImageOperations <Image>k__BackingField;
    [CompilerGeneratedAttribute]
private IDockerNetworkOperations <Network>k__BackingField;
    [CompilerGeneratedAttribute]
private IDockerVolumeOperations <Volume>k__BackingField;
    [CompilerGeneratedAttribute]
private IDockerSystemOperations <System>k__BackingField;
    public IDockerContainerOperations Container { get; }
    public IDockerImageOperations Image { get; }
    public IDockerNetworkOperations Network { get; }
    public IDockerVolumeOperations Volume { get; }
    public IDockerSystemOperations System { get; }
    public bool IsRunningInsideDocker { get; }
    public TestcontainersClient(Guid sessionId, IDockerEndpointAuthenticationConfiguration dockerEndpointAuthConfig, ILogger logger);
    private TestcontainersClient(IDockerContainerOperations containerOperations, IDockerImageOperations imageOperations, IDockerNetworkOperations networkOperations, IDockerVolumeOperations volumeOperations, IDockerSystemOperations systemOperations, DockerRegistryAuthenticationProvider registryAuthenticationProvider, ILogger logger);
    private static TestcontainersClient();
    [CompilerGeneratedAttribute]
public sealed virtual IDockerContainerOperations get_Container();
    [CompilerGeneratedAttribute]
public sealed virtual IDockerImageOperations get_Image();
    [CompilerGeneratedAttribute]
public sealed virtual IDockerNetworkOperations get_Network();
    [CompilerGeneratedAttribute]
public sealed virtual IDockerVolumeOperations get_Volume();
    [CompilerGeneratedAttribute]
public sealed virtual IDockerSystemOperations get_System();
    public sealed virtual bool get_IsRunningInsideDocker();
    public sealed virtual Task`1<long> GetContainerExitCodeAsync(string id, CancellationToken ct);
    public sealed virtual Task`1<ValueTuple`2<string, string>> GetContainerLogsAsync(string id, DateTime since, DateTime until, bool timestampsEnabled, CancellationToken ct);
    [AsyncStateMachineAttribute("DotNet.Testcontainers.Clients.TestcontainersClient/<StartAsync>d__30")]
public sealed virtual Task StartAsync(string id, CancellationToken ct);
    [AsyncStateMachineAttribute("DotNet.Testcontainers.Clients.TestcontainersClient/<StopAsync>d__31")]
public sealed virtual Task StopAsync(string id, CancellationToken ct);
    [AsyncStateMachineAttribute("DotNet.Testcontainers.Clients.TestcontainersClient/<RemoveAsync>d__32")]
public sealed virtual Task RemoveAsync(string id, CancellationToken ct);
    public sealed virtual Task AttachAsync(string id, IOutputConsumer outputConsumer, CancellationToken ct);
    public sealed virtual Task`1<ExecResult> ExecAsync(string id, IList`1<string> command, CancellationToken ct);
    [AsyncStateMachineAttribute("DotNet.Testcontainers.Clients.TestcontainersClient/<CopyAsync>d__35")]
public sealed virtual Task CopyAsync(string id, IResourceMapping resourceMapping, CancellationToken ct);
    [AsyncStateMachineAttribute("DotNet.Testcontainers.Clients.TestcontainersClient/<CopyAsync>d__36")]
public sealed virtual Task CopyAsync(string id, DirectoryInfo source, string target, UnixFileModes fileMode, CancellationToken ct);
    [AsyncStateMachineAttribute("DotNet.Testcontainers.Clients.TestcontainersClient/<CopyAsync>d__37")]
public sealed virtual Task CopyAsync(string id, FileInfo source, string target, UnixFileModes fileMode, CancellationToken ct);
    [AsyncStateMachineAttribute("DotNet.Testcontainers.Clients.TestcontainersClient/<ReadFileAsync>d__38")]
public sealed virtual Task`1<Byte[]> ReadFileAsync(string id, string filePath, CancellationToken ct);
    [AsyncStateMachineAttribute("DotNet.Testcontainers.Clients.TestcontainersClient/<RunAsync>d__39")]
public sealed virtual Task`1<string> RunAsync(IContainerConfiguration configuration, CancellationToken ct);
    [AsyncStateMachineAttribute("DotNet.Testcontainers.Clients.TestcontainersClient/<BuildAsync>d__40")]
public sealed virtual Task`1<string> BuildAsync(IImageFromDockerfileConfiguration configuration, CancellationToken ct);
    [AsyncStateMachineAttribute("DotNet.Testcontainers.Clients.TestcontainersClient/<PullImageAsync>d__41")]
private Task PullImageAsync(IImage image, CancellationToken ct);
}
internal class DotNet.Testcontainers.Clients.TraceProgress : object {
    private ILogger _logger;
    public TraceProgress(ILogger logger);
    public sealed virtual void Report(JSONMessage value);
}
[IsReadOnlyAttribute]
public class DotNet.Testcontainers.Configurations.AccessMode : ValueType {
    public static AccessMode ReadOnly;
    public static AccessMode ReadWrite;
    [CompilerGeneratedAttribute]
private string <Value>k__BackingField;
    public string Value { get; }
    private AccessMode(string value);
    private static AccessMode();
    [CompilerGeneratedAttribute]
public string get_Value();
}
internal class DotNet.Testcontainers.Configurations.BinaryResourceMapping : FileResourceMapping {
    private Byte[] _resourceContent;
    public BinaryResourceMapping(Byte[] resourceContent, string containerPath, UnixFileModes fileMode);
    public virtual Task`1<Byte[]> GetAllBytesAsync(CancellationToken ct);
}
[IsReadOnlyAttribute]
internal class DotNet.Testcontainers.Configurations.BindMount : ValueType {
    [CompilerGeneratedAttribute]
private MountType <Type>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Source>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Target>k__BackingField;
    [CompilerGeneratedAttribute]
private AccessMode <AccessMode>k__BackingField;
    public MountType Type { get; }
    public string Source { get; }
    public string Target { get; }
    public AccessMode AccessMode { get; }
    public BindMount(string hostPath, string containerPath, AccessMode accessMode);
    [CompilerGeneratedAttribute]
public sealed virtual MountType get_Type();
    [CompilerGeneratedAttribute]
public sealed virtual string get_Source();
    [CompilerGeneratedAttribute]
public sealed virtual string get_Target();
    [CompilerGeneratedAttribute]
public sealed virtual AccessMode get_AccessMode();
    public sealed virtual Task CreateAsync(CancellationToken ct);
    public sealed virtual Task DeleteAsync(CancellationToken ct);
}
public class DotNet.Testcontainers.Configurations.ContainerConfiguration : ResourceConfiguration`1<CreateContainerParameters> {
    [CompilerGeneratedAttribute]
private Nullable`1<bool> <AutoRemove>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<bool> <Privileged>k__BackingField;
    [CompilerGeneratedAttribute]
private IImage <Image>k__BackingField;
    [CompilerGeneratedAttribute]
private Func`2<ImageInspectResponse, bool> <ImagePullPolicy>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Name>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Hostname>k__BackingField;
    [CompilerGeneratedAttribute]
private string <MacAddress>k__BackingField;
    [CompilerGeneratedAttribute]
private string <WorkingDirectory>k__BackingField;
    [CompilerGeneratedAttribute]
private IEnumerable`1<string> <Entrypoint>k__BackingField;
    [CompilerGeneratedAttribute]
private IEnumerable`1<string> <Command>k__BackingField;
    [CompilerGeneratedAttribute]
private IReadOnlyDictionary`2<string, string> <Environments>k__BackingField;
    [CompilerGeneratedAttribute]
private IReadOnlyDictionary`2<string, string> <ExposedPorts>k__BackingField;
    [CompilerGeneratedAttribute]
private IReadOnlyDictionary`2<string, string> <PortBindings>k__BackingField;
    [CompilerGeneratedAttribute]
private IEnumerable`1<IResourceMapping> <ResourceMappings>k__BackingField;
    [CompilerGeneratedAttribute]
private IEnumerable`1<IContainer> <Containers>k__BackingField;
    [CompilerGeneratedAttribute]
private IEnumerable`1<IMount> <Mounts>k__BackingField;
    [CompilerGeneratedAttribute]
private IEnumerable`1<INetwork> <Networks>k__BackingField;
    [CompilerGeneratedAttribute]
private IEnumerable`1<string> <NetworkAliases>k__BackingField;
    [CompilerGeneratedAttribute]
private IEnumerable`1<string> <ExtraHosts>k__BackingField;
    [CompilerGeneratedAttribute]
private IOutputConsumer <OutputConsumer>k__BackingField;
    [CompilerGeneratedAttribute]
private IEnumerable`1<IWaitUntil> <WaitStrategies>k__BackingField;
    [CompilerGeneratedAttribute]
private Func`3<IContainer, CancellationToken, Task> <StartupCallback>k__BackingField;
    [JsonIgnoreAttribute]
public Nullable`1<bool> AutoRemove { get; }
    [JsonIgnoreAttribute]
public Nullable`1<bool> Privileged { get; }
    public IImage Image { get; }
    [JsonIgnoreAttribute]
public Func`2<ImageInspectResponse, bool> ImagePullPolicy { get; }
    [JsonIgnoreAttribute]
public string Name { get; }
    [JsonIgnoreAttribute]
public string Hostname { get; }
    [JsonIgnoreAttribute]
public string MacAddress { get; }
    [JsonIgnoreAttribute]
public string WorkingDirectory { get; }
    public IEnumerable`1<string> Entrypoint { get; }
    public IEnumerable`1<string> Command { get; }
    public IReadOnlyDictionary`2<string, string> Environments { get; }
    public IReadOnlyDictionary`2<string, string> ExposedPorts { get; }
    public IReadOnlyDictionary`2<string, string> PortBindings { get; }
    [JsonIgnoreAttribute]
public IEnumerable`1<IResourceMapping> ResourceMappings { get; }
    [JsonIgnoreAttribute]
public IEnumerable`1<IContainer> Containers { get; }
    [JsonIgnoreAttribute]
public IEnumerable`1<IMount> Mounts { get; }
    [JsonIgnoreAttribute]
public IEnumerable`1<INetwork> Networks { get; }
    public IEnumerable`1<string> NetworkAliases { get; }
    public IEnumerable`1<string> ExtraHosts { get; }
    [JsonIgnoreAttribute]
public IOutputConsumer OutputConsumer { get; }
    [JsonIgnoreAttribute]
public IEnumerable`1<IWaitUntil> WaitStrategies { get; }
    [JsonIgnoreAttribute]
public Func`3<IContainer, CancellationToken, Task> StartupCallback { get; }
    public ContainerConfiguration(IImage image, Func`2<ImageInspectResponse, bool> imagePullPolicy, string name, string hostname, string macAddress, string workingDirectory, IEnumerable`1<string> entrypoint, IEnumerable`1<string> command, IReadOnlyDictionary`2<string, string> environments, IReadOnlyDictionary`2<string, string> exposedPorts, IReadOnlyDictionary`2<string, string> portBindings, IEnumerable`1<IResourceMapping> resourceMappings, IEnumerable`1<IContainer> containers, IEnumerable`1<IMount> mounts, IEnumerable`1<INetwork> networks, IEnumerable`1<string> networkAliases, IEnumerable`1<string> extraHosts, IOutputConsumer outputConsumer, IEnumerable`1<IWaitUntil> waitStrategies, Func`3<IContainer, CancellationToken, Task> startupCallback, Nullable`1<bool> autoRemove, Nullable`1<bool> privileged);
    public ContainerConfiguration(IResourceConfiguration`1<CreateContainerParameters> resourceConfiguration);
    public ContainerConfiguration(IContainerConfiguration resourceConfiguration);
    public ContainerConfiguration(IContainerConfiguration oldValue, IContainerConfiguration newValue);
    [CompilerGeneratedAttribute]
public sealed virtual Nullable`1<bool> get_AutoRemove();
    [CompilerGeneratedAttribute]
public sealed virtual Nullable`1<bool> get_Privileged();
    [CompilerGeneratedAttribute]
public sealed virtual IImage get_Image();
    [CompilerGeneratedAttribute]
public sealed virtual Func`2<ImageInspectResponse, bool> get_ImagePullPolicy();
    [CompilerGeneratedAttribute]
public sealed virtual string get_Name();
    [CompilerGeneratedAttribute]
public sealed virtual string get_Hostname();
    [CompilerGeneratedAttribute]
public sealed virtual string get_MacAddress();
    [CompilerGeneratedAttribute]
public sealed virtual string get_WorkingDirectory();
    [CompilerGeneratedAttribute]
public sealed virtual IEnumerable`1<string> get_Entrypoint();
    [CompilerGeneratedAttribute]
public sealed virtual IEnumerable`1<string> get_Command();
    [CompilerGeneratedAttribute]
public sealed virtual IReadOnlyDictionary`2<string, string> get_Environments();
    [CompilerGeneratedAttribute]
public sealed virtual IReadOnlyDictionary`2<string, string> get_ExposedPorts();
    [CompilerGeneratedAttribute]
public sealed virtual IReadOnlyDictionary`2<string, string> get_PortBindings();
    [CompilerGeneratedAttribute]
public sealed virtual IEnumerable`1<IResourceMapping> get_ResourceMappings();
    [CompilerGeneratedAttribute]
public sealed virtual IEnumerable`1<IContainer> get_Containers();
    [CompilerGeneratedAttribute]
public sealed virtual IEnumerable`1<IMount> get_Mounts();
    [CompilerGeneratedAttribute]
public sealed virtual IEnumerable`1<INetwork> get_Networks();
    [CompilerGeneratedAttribute]
public sealed virtual IEnumerable`1<string> get_NetworkAliases();
    [CompilerGeneratedAttribute]
public sealed virtual IEnumerable`1<string> get_ExtraHosts();
    [CompilerGeneratedAttribute]
public sealed virtual IOutputConsumer get_OutputConsumer();
    [CompilerGeneratedAttribute]
public sealed virtual IEnumerable`1<IWaitUntil> get_WaitStrategies();
    [CompilerGeneratedAttribute]
public sealed virtual Func`3<IContainer, CancellationToken, Task> get_StartupCallback();
}
internal abstract class DotNet.Testcontainers.Configurations.CustomConfiguration : object {
    private IReadOnlyDictionary`2<string, string> _properties;
    protected CustomConfiguration(IReadOnlyDictionary`2<string, string> properties);
    protected virtual string GetDockerConfig(string propertyName);
    protected virtual Uri GetDockerHost(string propertyName);
    protected virtual string GetDockerHostOverride(string propertyName);
    protected virtual string GetDockerSocketOverride(string propertyName);
    protected virtual JsonDocument GetDockerAuthConfig(string propertyName);
    protected virtual string GetDockerCertPath(string propertyName);
    protected virtual bool GetDockerTls(string propertyName);
    protected virtual bool GetDockerTlsVerify(string propertyName);
    protected virtual bool GetRyukDisabled(string propertyName);
    protected virtual bool GetRyukContainerPrivileged(string propertyName);
    protected virtual IImage GetRyukContainerImage(string propertyName);
    protected virtual string GetHubImageNamePrefix(string propertyName);
    private T GetPropertyValue(string propertyName);
}
[IsReadOnlyAttribute]
public class DotNet.Testcontainers.Configurations.DockerEndpointAuthenticationConfiguration : ValueType {
    [CompilerGeneratedAttribute]
private Credentials <Credentials>k__BackingField;
    [CompilerGeneratedAttribute]
private Uri <Endpoint>k__BackingField;
    public Credentials Credentials { get; }
    public Uri Endpoint { get; }
    public DockerEndpointAuthenticationConfiguration(Uri endpoint, Credentials credentials);
    [CompilerGeneratedAttribute]
public sealed virtual Credentials get_Credentials();
    [CompilerGeneratedAttribute]
public sealed virtual Uri get_Endpoint();
    public sealed virtual DockerClientConfiguration GetDockerClientConfiguration(Guid sessionId);
}
[IsReadOnlyAttribute]
internal class DotNet.Testcontainers.Configurations.DockerRegistryAuthenticationConfiguration : ValueType {
    [CompilerGeneratedAttribute]
private string <RegistryEndpoint>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Username>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Password>k__BackingField;
    [CompilerGeneratedAttribute]
private string <IdentityToken>k__BackingField;
    public string RegistryEndpoint { get; }
    public string Username { get; }
    public string Password { get; }
    public string IdentityToken { get; }
    public DockerRegistryAuthenticationConfiguration(string registryEndpoint, string username, string password, string identityToken);
    public DockerRegistryAuthenticationConfiguration(string registryEndpoint, JsonElement credential);
    [CompilerGeneratedAttribute]
public sealed virtual string get_RegistryEndpoint();
    [CompilerGeneratedAttribute]
public sealed virtual string get_Username();
    [CompilerGeneratedAttribute]
public sealed virtual string get_Password();
    [CompilerGeneratedAttribute]
public sealed virtual string get_IdentityToken();
}
internal class DotNet.Testcontainers.Configurations.EnvironmentConfiguration : CustomConfiguration {
    private static string DockerConfig;
    private static string DockerHost;
    private static string DockerAuthConfig;
    private static string DockerCertPath;
    private static string DockerTls;
    private static string DockerTlsVerify;
    private static string DockerHostOverride;
    private static string DockerSocketOverride;
    private static string RyukDisabled;
    private static string RyukContainerPrivileged;
    private static string RyukContainerImage;
    private static string HubImageNamePrefix;
    [CompilerGeneratedAttribute]
private static ICustomConfiguration <Instance>k__BackingField;
    public static ICustomConfiguration Instance { get; }
    private static EnvironmentConfiguration();
    [CompilerGeneratedAttribute]
public static ICustomConfiguration get_Instance();
    public sealed virtual string GetDockerConfig();
    public sealed virtual Uri GetDockerHost();
    public sealed virtual string GetDockerHostOverride();
    public sealed virtual string GetDockerSocketOverride();
    public sealed virtual JsonDocument GetDockerAuthConfig();
    public sealed virtual string GetDockerCertPath();
    public sealed virtual bool GetDockerTls();
    public sealed virtual bool GetDockerTlsVerify();
    public sealed virtual bool GetRyukDisabled();
    public sealed virtual bool GetRyukContainerPrivileged();
    public sealed virtual IImage GetRyukContainerImage();
    public sealed virtual string GetHubImageNamePrefix();
}
internal class DotNet.Testcontainers.Configurations.FileResourceMapping : object {
    [CompilerGeneratedAttribute]
private MountType <Type>k__BackingField;
    [CompilerGeneratedAttribute]
private AccessMode <AccessMode>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Source>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Target>k__BackingField;
    [CompilerGeneratedAttribute]
private UnixFileModes <FileMode>k__BackingField;
    public MountType Type { get; }
    public AccessMode AccessMode { get; }
    public string Source { get; }
    public string Target { get; }
    public UnixFileModes FileMode { get; }
    public FileResourceMapping(string hostPath, string containerPath, UnixFileModes fileMode);
    [CompilerGeneratedAttribute]
public sealed virtual MountType get_Type();
    [CompilerGeneratedAttribute]
public sealed virtual AccessMode get_AccessMode();
    [CompilerGeneratedAttribute]
public sealed virtual string get_Source();
    [CompilerGeneratedAttribute]
public sealed virtual string get_Target();
    [CompilerGeneratedAttribute]
public sealed virtual UnixFileModes get_FileMode();
    public sealed virtual Task CreateAsync(CancellationToken ct);
    public sealed virtual Task DeleteAsync(CancellationToken ct);
    public virtual Task`1<Byte[]> GetAllBytesAsync(CancellationToken ct);
}
public enum DotNet.Testcontainers.Configurations.FileSystem : Enum {
    public int value__;
    public static FileSystem Host;
    public static FileSystem Container;
}
public class DotNet.Testcontainers.Configurations.HttpWaitStrategy : object {
    private static ushort HttpPort;
    private static ushort HttpsPort;
    private IDictionary`2<string, string> _httpHeaders;
    private ISet`1<HttpStatusCode> _httpStatusCodes;
    private Predicate`1<HttpStatusCode> _httpStatusCodePredicate;
    private Func`2<HttpResponseMessage, Task`1<bool>> _httpResponseMessagePredicate;
    private HttpMethod _httpMethod;
    private string _schemeName;
    private string _pathValue;
    private Nullable`1<ushort> _portNumber;
    private HttpMessageHandler _httpMessageHandler;
    private Func`1<HttpContent> _httpContentCallback;
    [AsyncStateMachineAttribute("DotNet.Testcontainers.Configurations.HttpWaitStrategy/<UntilAsync>d__13")]
public sealed virtual Task`1<bool> UntilAsync(IContainer container);
    public HttpWaitStrategy ForStatusCode(HttpStatusCode statusCode);
    public HttpWaitStrategy ForStatusCodeMatching(Predicate`1<HttpStatusCode> statusCodePredicate);
    public HttpWaitStrategy ForResponseMessageMatching(Func`2<HttpResponseMessage, Task`1<bool>> responseMessagePredicate);
    public HttpWaitStrategy ForPath(string path);
    public HttpWaitStrategy ForPort(ushort port);
    public HttpWaitStrategy UsingTls(bool tlsEnabled);
    public HttpWaitStrategy UsingHttpMessageHandler(HttpMessageHandler handler);
    public HttpWaitStrategy WithMethod(HttpMethod method);
    public HttpWaitStrategy WithBasicAuthentication(string username, string password);
    public HttpWaitStrategy WithHeader(string name, string value);
    public HttpWaitStrategy WithHeaders(IReadOnlyDictionary`2<string, string> headers);
    public HttpWaitStrategy WithContent(Func`1<HttpContent> httpContentCallback);
    [CompilerGeneratedAttribute]
private bool <UntilAsync>b__13_1(HttpStatusCode statusCode);
    [CompilerGeneratedAttribute]
private bool <UntilAsync>b__13_2(HttpStatusCode statusCode);
}
public interface DotNet.Testcontainers.Configurations.IContainerConfiguration {
    public Nullable`1<bool> AutoRemove { get; }
    public Nullable`1<bool> Privileged { get; }
    public IImage Image { get; }
    public Func`2<ImageInspectResponse, bool> ImagePullPolicy { get; }
    public string Name { get; }
    public string Hostname { get; }
    public string MacAddress { get; }
    public string WorkingDirectory { get; }
    public IEnumerable`1<string> Entrypoint { get; }
    public IEnumerable`1<string> Command { get; }
    public IReadOnlyDictionary`2<string, string> Environments { get; }
    public IReadOnlyDictionary`2<string, string> ExposedPorts { get; }
    public IReadOnlyDictionary`2<string, string> PortBindings { get; }
    public IEnumerable`1<IResourceMapping> ResourceMappings { get; }
    public IEnumerable`1<IContainer> Containers { get; }
    public IEnumerable`1<IMount> Mounts { get; }
    public IEnumerable`1<INetwork> Networks { get; }
    public IEnumerable`1<string> NetworkAliases { get; }
    public IEnumerable`1<string> ExtraHosts { get; }
    public IOutputConsumer OutputConsumer { get; }
    public IEnumerable`1<IWaitUntil> WaitStrategies { get; }
    public Func`3<IContainer, CancellationToken, Task> StartupCallback { get; }
    public abstract virtual Nullable`1<bool> get_AutoRemove();
    public abstract virtual Nullable`1<bool> get_Privileged();
    public abstract virtual IImage get_Image();
    public abstract virtual Func`2<ImageInspectResponse, bool> get_ImagePullPolicy();
    public abstract virtual string get_Name();
    public abstract virtual string get_Hostname();
    public abstract virtual string get_MacAddress();
    public abstract virtual string get_WorkingDirectory();
    public abstract virtual IEnumerable`1<string> get_Entrypoint();
    public abstract virtual IEnumerable`1<string> get_Command();
    public abstract virtual IReadOnlyDictionary`2<string, string> get_Environments();
    public abstract virtual IReadOnlyDictionary`2<string, string> get_ExposedPorts();
    public abstract virtual IReadOnlyDictionary`2<string, string> get_PortBindings();
    public abstract virtual IEnumerable`1<IResourceMapping> get_ResourceMappings();
    public abstract virtual IEnumerable`1<IContainer> get_Containers();
    public abstract virtual IEnumerable`1<IMount> get_Mounts();
    public abstract virtual IEnumerable`1<INetwork> get_Networks();
    public abstract virtual IEnumerable`1<string> get_NetworkAliases();
    public abstract virtual IEnumerable`1<string> get_ExtraHosts();
    public abstract virtual IOutputConsumer get_OutputConsumer();
    public abstract virtual IEnumerable`1<IWaitUntil> get_WaitStrategies();
    public abstract virtual Func`3<IContainer, CancellationToken, Task> get_StartupCallback();
}
internal interface DotNet.Testcontainers.Configurations.ICustomConfiguration {
    public abstract virtual string GetDockerConfig();
    public abstract virtual Uri GetDockerHost();
    public abstract virtual string GetDockerHostOverride();
    public abstract virtual string GetDockerSocketOverride();
    public abstract virtual JsonDocument GetDockerAuthConfig();
    public abstract virtual string GetDockerCertPath();
    public abstract virtual bool GetDockerTls();
    public abstract virtual bool GetDockerTlsVerify();
    public abstract virtual bool GetRyukDisabled();
    public abstract virtual bool GetRyukContainerPrivileged();
    public abstract virtual IImage GetRyukContainerImage();
    public abstract virtual string GetHubImageNamePrefix();
}
public interface DotNet.Testcontainers.Configurations.IDockerEndpointAuthenticationConfiguration {
    public Uri Endpoint { get; }
    public Credentials Credentials { get; }
    public abstract virtual Uri get_Endpoint();
    public abstract virtual Credentials get_Credentials();
    public abstract virtual DockerClientConfiguration GetDockerClientConfiguration(Guid sessionId);
}
public interface DotNet.Testcontainers.Configurations.IDockerRegistryAuthenticationConfiguration {
    public string RegistryEndpoint { get; }
    public string Username { get; }
    public string Password { get; }
    public string IdentityToken { get; }
    public abstract virtual string get_RegistryEndpoint();
    public abstract virtual string get_Username();
    public abstract virtual string get_Password();
    public abstract virtual string get_IdentityToken();
}
public interface DotNet.Testcontainers.Configurations.IImageFromDockerfileConfiguration {
    public Nullable`1<bool> DeleteIfExists { get; }
    public string Dockerfile { get; }
    public string DockerfileDirectory { get; }
    public IImage Image { get; }
    public Func`2<ImageInspectResponse, bool> ImageBuildPolicy { get; }
    public IReadOnlyDictionary`2<string, string> BuildArguments { get; }
    public abstract virtual Nullable`1<bool> get_DeleteIfExists();
    public abstract virtual string get_Dockerfile();
    public abstract virtual string get_DockerfileDirectory();
    public abstract virtual IImage get_Image();
    public abstract virtual Func`2<ImageInspectResponse, bool> get_ImageBuildPolicy();
    public abstract virtual IReadOnlyDictionary`2<string, string> get_BuildArguments();
}
internal class DotNet.Testcontainers.Configurations.ImageFromDockerfileConfiguration : ResourceConfiguration`1<ImageBuildParameters> {
    [CompilerGeneratedAttribute]
private Nullable`1<bool> <DeleteIfExists>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Dockerfile>k__BackingField;
    [CompilerGeneratedAttribute]
private string <DockerfileDirectory>k__BackingField;
    [CompilerGeneratedAttribute]
private IImage <Image>k__BackingField;
    [CompilerGeneratedAttribute]
private Func`2<ImageInspectResponse, bool> <ImageBuildPolicy>k__BackingField;
    [CompilerGeneratedAttribute]
private IReadOnlyDictionary`2<string, string> <BuildArguments>k__BackingField;
    [JsonIgnoreAttribute]
public Nullable`1<bool> DeleteIfExists { get; }
    [JsonIgnoreAttribute]
public string Dockerfile { get; }
    [JsonIgnoreAttribute]
public string DockerfileDirectory { get; }
    [JsonIgnoreAttribute]
public IImage Image { get; }
    [JsonIgnoreAttribute]
public Func`2<ImageInspectResponse, bool> ImageBuildPolicy { get; }
    [JsonIgnoreAttribute]
public IReadOnlyDictionary`2<string, string> BuildArguments { get; }
    public ImageFromDockerfileConfiguration(string dockerfile, string dockerfileDirectory, IImage image, Func`2<ImageInspectResponse, bool> imageBuildPolicy, IReadOnlyDictionary`2<string, string> buildArguments, Nullable`1<bool> deleteIfExists);
    public ImageFromDockerfileConfiguration(IResourceConfiguration`1<ImageBuildParameters> resourceConfiguration);
    public ImageFromDockerfileConfiguration(IImageFromDockerfileConfiguration resourceConfiguration);
    public ImageFromDockerfileConfiguration(IImageFromDockerfileConfiguration oldValue, IImageFromDockerfileConfiguration newValue);
    [CompilerGeneratedAttribute]
public sealed virtual Nullable`1<bool> get_DeleteIfExists();
    [CompilerGeneratedAttribute]
public sealed virtual string get_Dockerfile();
    [CompilerGeneratedAttribute]
public sealed virtual string get_DockerfileDirectory();
    [CompilerGeneratedAttribute]
public sealed virtual IImage get_Image();
    [CompilerGeneratedAttribute]
public sealed virtual Func`2<ImageInspectResponse, bool> get_ImageBuildPolicy();
    [CompilerGeneratedAttribute]
public sealed virtual IReadOnlyDictionary`2<string, string> get_BuildArguments();
}
public interface DotNet.Testcontainers.Configurations.IMount {
    public MountType Type { get; }
    public AccessMode AccessMode { get; }
    public string Source { get; }
    public string Target { get; }
    public abstract virtual MountType get_Type();
    public abstract virtual AccessMode get_AccessMode();
    public abstract virtual string get_Source();
    public abstract virtual string get_Target();
}
public interface DotNet.Testcontainers.Configurations.INetworkConfiguration {
    public string Name { get; }
    public NetworkDriver Driver { get; }
    public IReadOnlyDictionary`2<string, string> Options { get; }
    public abstract virtual string get_Name();
    public abstract virtual NetworkDriver get_Driver();
    public abstract virtual IReadOnlyDictionary`2<string, string> get_Options();
}
public interface DotNet.Testcontainers.Configurations.IOperatingSystem {
    public IDockerEndpointAuthenticationConfiguration DockerEndpointAuthConfig { get; }
    public abstract virtual IDockerEndpointAuthenticationConfiguration get_DockerEndpointAuthConfig();
    public abstract virtual string NormalizePath(string path);
}
public interface DotNet.Testcontainers.Configurations.IOutputConsumer {
    public bool Enabled { get; }
    public Stream Stdout { get; }
    public Stream Stderr { get; }
    public abstract virtual bool get_Enabled();
    public abstract virtual Stream get_Stdout();
    public abstract virtual Stream get_Stderr();
}
public interface DotNet.Testcontainers.Configurations.IResourceConfiguration`1 {
    public Guid SessionId { get; }
    public IDockerEndpointAuthenticationConfiguration DockerEndpointAuthConfig { get; }
    public IReadOnlyDictionary`2<string, string> Labels { get; }
    public IReadOnlyList`1<Action`1<TCreateResourceEntity>> ParameterModifiers { get; }
    public Nullable`1<bool> Reuse { get; }
    public ILogger Logger { get; }
    public abstract virtual Guid get_SessionId();
    public abstract virtual IDockerEndpointAuthenticationConfiguration get_DockerEndpointAuthConfig();
    public abstract virtual IReadOnlyDictionary`2<string, string> get_Labels();
    public abstract virtual IReadOnlyList`1<Action`1<TCreateResourceEntity>> get_ParameterModifiers();
    public abstract virtual Nullable`1<bool> get_Reuse();
    public abstract virtual ILogger get_Logger();
    public abstract virtual string GetReuseHash();
}
public interface DotNet.Testcontainers.Configurations.IResourceMapping {
    public UnixFileModes FileMode { get; }
    public abstract virtual UnixFileModes get_FileMode();
    public abstract virtual Task`1<Byte[]> GetAllBytesAsync(CancellationToken ct);
}
public interface DotNet.Testcontainers.Configurations.IVolumeConfiguration {
    public string Name { get; }
    public abstract virtual string get_Name();
}
public interface DotNet.Testcontainers.Configurations.IWaitForContainerOS {
    public abstract virtual IWaitForContainerOS AddCustomWaitStrategy(IWaitUntil waitStrategy);
    public abstract virtual IWaitForContainerOS UntilCommandIsCompleted(string command);
    public abstract virtual IWaitForContainerOS UntilCommandIsCompleted(String[] command);
    public abstract virtual IWaitForContainerOS UntilPortIsAvailable(int port);
    public abstract virtual IWaitForContainerOS UntilFileExists(string filePath, FileSystem fileSystem);
    public abstract virtual IWaitForContainerOS UntilMessageIsLogged(string pattern);
    public abstract virtual IWaitForContainerOS UntilMessageIsLogged(Regex pattern);
    public abstract virtual IWaitForContainerOS UntilOperationIsSucceeded(Func`1<bool> operation, int maxCallCount);
    public abstract virtual IWaitForContainerOS UntilHttpRequestIsSucceeded(Func`2<HttpWaitStrategy, HttpWaitStrategy> request);
    public abstract virtual IWaitForContainerOS UntilContainerIsHealthy(long failingStreak);
    public abstract virtual IEnumerable`1<IWaitUntil> Build();
}
public interface DotNet.Testcontainers.Configurations.IWaitUntil {
    public abstract virtual Task`1<bool> UntilAsync(IContainer container);
}
public interface DotNet.Testcontainers.Configurations.IWaitWhile {
    public abstract virtual Task`1<bool> WhileAsync(IContainer container);
}
internal class DotNet.Testcontainers.Configurations.JsonIgnoreRuntimeResourceLabels : JsonConverter`1<IReadOnlyDictionary`2<string, string>> {
    private static ISet`1<string> IgnoreLabels;
    private static JsonIgnoreRuntimeResourceLabels();
    public virtual bool CanConvert(Type typeToConvert);
    public virtual IReadOnlyDictionary`2<string, string> Read(Utf8JsonReader& reader, Type typeToConvert, JsonSerializerOptions options);
    public virtual void Write(Utf8JsonWriter writer, IReadOnlyDictionary`2<string, string> value, JsonSerializerOptions options);
}
[IsReadOnlyAttribute]
public class DotNet.Testcontainers.Configurations.MountType : ValueType {
    public static MountType Bind;
    public static MountType Volume;
    public static MountType Tmpfs;
    public static MountType NamedPipe;
    [CompilerGeneratedAttribute]
private string <Type>k__BackingField;
    public string Type { get; }
    private MountType(string type);
    private static MountType();
    [CompilerGeneratedAttribute]
public string get_Type();
}
internal class DotNet.Testcontainers.Configurations.NetworkConfiguration : ResourceConfiguration`1<NetworksCreateParameters> {
    [CompilerGeneratedAttribute]
private string <Name>k__BackingField;
    [CompilerGeneratedAttribute]
private NetworkDriver <Driver>k__BackingField;
    [CompilerGeneratedAttribute]
private IReadOnlyDictionary`2<string, string> <Options>k__BackingField;
    public string Name { get; }
    [JsonIgnoreAttribute]
public NetworkDriver Driver { get; }
    [JsonIgnoreAttribute]
public IReadOnlyDictionary`2<string, string> Options { get; }
    public NetworkConfiguration(string name, NetworkDriver driver, IReadOnlyDictionary`2<string, string> options);
    public NetworkConfiguration(IResourceConfiguration`1<NetworksCreateParameters> resourceConfiguration);
    public NetworkConfiguration(INetworkConfiguration resourceConfiguration);
    public NetworkConfiguration(INetworkConfiguration oldValue, INetworkConfiguration newValue);
    [CompilerGeneratedAttribute]
public sealed virtual string get_Name();
    [CompilerGeneratedAttribute]
public sealed virtual NetworkDriver get_Driver();
    [CompilerGeneratedAttribute]
public sealed virtual IReadOnlyDictionary`2<string, string> get_Options();
}
[IsReadOnlyAttribute]
public class DotNet.Testcontainers.Configurations.NetworkDriver : ValueType {
    public static NetworkDriver Bridge;
    public static NetworkDriver Host;
    [CompilerGeneratedAttribute]
private string <Value>k__BackingField;
    public string Value { get; }
    private NetworkDriver(string value);
    private static NetworkDriver();
    [CompilerGeneratedAttribute]
public string get_Value();
}
internal class DotNet.Testcontainers.Configurations.PropertiesFileConfiguration : CustomConfiguration {
    [CompilerGeneratedAttribute]
private static ICustomConfiguration <Instance>k__BackingField;
    public static ICustomConfiguration Instance { get; }
    private static PropertiesFileConfiguration();
    public PropertiesFileConfiguration(string propertiesFilePath);
    public PropertiesFileConfiguration(String[] lines);
    [CompilerGeneratedAttribute]
public static ICustomConfiguration get_Instance();
    public sealed virtual string GetDockerConfig();
    public sealed virtual Uri GetDockerHost();
    public sealed virtual string GetDockerHostOverride();
    public sealed virtual string GetDockerSocketOverride();
    public sealed virtual JsonDocument GetDockerAuthConfig();
    public sealed virtual string GetDockerCertPath();
    public sealed virtual bool GetDockerTls();
    public sealed virtual bool GetDockerTlsVerify();
    public sealed virtual bool GetRyukDisabled();
    public sealed virtual bool GetRyukContainerPrivileged();
    public sealed virtual IImage GetRyukContainerImage();
    public sealed virtual string GetHubImageNamePrefix();
}
internal class DotNet.Testcontainers.Configurations.RedirectStdoutAndStderrToNull : object {
    [CompilerGeneratedAttribute]
private static IOutputConsumer <Instance>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <Enabled>k__BackingField;
    [CompilerGeneratedAttribute]
private Stream <Stdout>k__BackingField;
    [CompilerGeneratedAttribute]
private Stream <Stderr>k__BackingField;
    public static IOutputConsumer Instance { get; }
    public bool Enabled { get; }
    public Stream Stdout { get; }
    public Stream Stderr { get; }
    private static RedirectStdoutAndStderrToNull();
    [CompilerGeneratedAttribute]
public static IOutputConsumer get_Instance();
    [CompilerGeneratedAttribute]
public sealed virtual bool get_Enabled();
    [CompilerGeneratedAttribute]
public sealed virtual Stream get_Stdout();
    [CompilerGeneratedAttribute]
public sealed virtual Stream get_Stderr();
    public sealed virtual void Dispose();
}
internal class DotNet.Testcontainers.Configurations.RedirectStdoutAndStderrToStream : object {
    private StreamWriter _stdout;
    private StreamWriter _stderr;
    [CompilerGeneratedAttribute]
private bool <Enabled>k__BackingField;
    public bool Enabled { get; }
    public Stream Stdout { get; }
    public Stream Stderr { get; }
    public RedirectStdoutAndStderrToStream(Stream stdout, Stream stderr);
    [CompilerGeneratedAttribute]
public sealed virtual bool get_Enabled();
    public sealed virtual Stream get_Stdout();
    public sealed virtual Stream get_Stderr();
    public sealed virtual void Dispose();
}
public class DotNet.Testcontainers.Configurations.ResourceConfiguration`1 : object {
    [CompilerGeneratedAttribute]
private Guid <SessionId>k__BackingField;
    [CompilerGeneratedAttribute]
private IDockerEndpointAuthenticationConfiguration <DockerEndpointAuthConfig>k__BackingField;
    [CompilerGeneratedAttribute]
private IReadOnlyDictionary`2<string, string> <Labels>k__BackingField;
    [CompilerGeneratedAttribute]
private IReadOnlyList`1<Action`1<TCreateResourceEntity>> <ParameterModifiers>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<bool> <Reuse>k__BackingField;
    [CompilerGeneratedAttribute]
private ILogger <Logger>k__BackingField;
    [JsonIgnoreAttribute]
public Guid SessionId { get; }
    [JsonIgnoreAttribute]
public IDockerEndpointAuthenticationConfiguration DockerEndpointAuthConfig { get; }
    [JsonConverterAttribute("DotNet.Testcontainers.Configurations.JsonIgnoreRuntimeResourceLabels")]
public IReadOnlyDictionary`2<string, string> Labels { get; }
    [JsonIgnoreAttribute]
public IReadOnlyList`1<Action`1<TCreateResourceEntity>> ParameterModifiers { get; }
    [JsonIgnoreAttribute]
public Nullable`1<bool> Reuse { get; }
    [JsonIgnoreAttribute]
public ILogger Logger { get; }
    public ResourceConfiguration`1(IDockerEndpointAuthenticationConfiguration dockerEndpointAuthenticationConfiguration, IReadOnlyDictionary`2<string, string> labels, IReadOnlyList`1<Action`1<TCreateResourceEntity>> parameterModifiers, Nullable`1<bool> reuse, ILogger logger);
    protected ResourceConfiguration`1(IResourceConfiguration`1<TCreateResourceEntity> resourceConfiguration);
    protected ResourceConfiguration`1(IResourceConfiguration`1<TCreateResourceEntity> oldValue, IResourceConfiguration`1<TCreateResourceEntity> newValue);
    [CompilerGeneratedAttribute]
public sealed virtual Guid get_SessionId();
    [CompilerGeneratedAttribute]
public sealed virtual IDockerEndpointAuthenticationConfiguration get_DockerEndpointAuthConfig();
    [CompilerGeneratedAttribute]
public sealed virtual IReadOnlyDictionary`2<string, string> get_Labels();
    [CompilerGeneratedAttribute]
public sealed virtual IReadOnlyList`1<Action`1<TCreateResourceEntity>> get_ParameterModifiers();
    [CompilerGeneratedAttribute]
public sealed virtual Nullable`1<bool> get_Reuse();
    [CompilerGeneratedAttribute]
public sealed virtual ILogger get_Logger();
    public virtual string GetReuseHash();
}
public static class DotNet.Testcontainers.Configurations.TestcontainersSettings : object {
    private static ManualResetEventSlim ManualResetEvent;
    private static IDockerEndpointAuthenticationProvider DockerEndpointAuthProvider;
    private static IDockerEndpointAuthenticationConfiguration DockerEndpointAuthConfig;
    [CompilerGeneratedAttribute]
private static string <DockerHostOverride>k__BackingField;
    [CompilerGeneratedAttribute]
private static string <DockerSocketOverride>k__BackingField;
    [CompilerGeneratedAttribute]
private static bool <ResourceReaperEnabled>k__BackingField;
    [CompilerGeneratedAttribute]
private static bool <ResourceReaperPrivilegedModeEnabled>k__BackingField;
    [CompilerGeneratedAttribute]
private static IImage <ResourceReaperImage>k__BackingField;
    [CompilerGeneratedAttribute]
private static Func`2<IDockerEndpointAuthenticationConfiguration, ushort> <ResourceReaperPublicHostPort>k__BackingField;
    [CompilerGeneratedAttribute]
private static string <HubImageNamePrefix>k__BackingField;
    [CompilerGeneratedAttribute]
private static ILogger <Logger>k__BackingField;
    [CompilerGeneratedAttribute]
private static IOperatingSystem <OS>k__BackingField;
    public static string DockerHostOverride { get; public set; }
    public static string DockerSocketOverride { get; public set; }
    public static bool ResourceReaperEnabled { get; public set; }
    public static bool ResourceReaperPrivilegedModeEnabled { get; public set; }
    public static IImage ResourceReaperImage { get; public set; }
    [ObsoleteAttribute("The Resource Reaper will use Docker's assigned random host port. This property is no longer supported. For DinD configurations see: https://dotnet.testcontainers.org/examples/dind/.")]
public static Func`2<IDockerEndpointAuthenticationConfiguration, ushort> ResourceReaperPublicHostPort { get; public set; }
    public static string HubImageNamePrefix { get; public set; }
    [ObsoleteAttribute("Use the builder API WithLogger(ILogger) instead.")]
public static ILogger Logger { get; public set; }
    public static IOperatingSystem OS { get; public set; }
    [ObsoleteAttribute("This property is no longer supported.")]
public static WaitHandle SettingsInitialized { get; }
    private static TestcontainersSettings();
    [CompilerGeneratedAttribute]
public static string get_DockerHostOverride();
    [CompilerGeneratedAttribute]
public static void set_DockerHostOverride(string value);
    [CompilerGeneratedAttribute]
public static string get_DockerSocketOverride();
    [CompilerGeneratedAttribute]
public static void set_DockerSocketOverride(string value);
    [CompilerGeneratedAttribute]
public static bool get_ResourceReaperEnabled();
    [CompilerGeneratedAttribute]
public static void set_ResourceReaperEnabled(bool value);
    [CompilerGeneratedAttribute]
public static bool get_ResourceReaperPrivilegedModeEnabled();
    [CompilerGeneratedAttribute]
public static void set_ResourceReaperPrivilegedModeEnabled(bool value);
    [CompilerGeneratedAttribute]
public static IImage get_ResourceReaperImage();
    [CompilerGeneratedAttribute]
public static void set_ResourceReaperImage(IImage value);
    [CompilerGeneratedAttribute]
public static Func`2<IDockerEndpointAuthenticationConfiguration, ushort> get_ResourceReaperPublicHostPort();
    [CompilerGeneratedAttribute]
public static void set_ResourceReaperPublicHostPort(Func`2<IDockerEndpointAuthenticationConfiguration, ushort> value);
    [CompilerGeneratedAttribute]
public static string get_HubImageNamePrefix();
    [CompilerGeneratedAttribute]
public static void set_HubImageNamePrefix(string value);
    [CompilerGeneratedAttribute]
public static ILogger get_Logger();
    [CompilerGeneratedAttribute]
public static void set_Logger(ILogger value);
    [CompilerGeneratedAttribute]
public static IOperatingSystem get_OS();
    [CompilerGeneratedAttribute]
public static void set_OS(IOperatingSystem value);
    public static WaitHandle get_SettingsInitialized();
    public static Task ExposeHostPortsAsync(ushort port, CancellationToken ct);
    [AsyncStateMachineAttribute("DotNet.Testcontainers.Configurations.TestcontainersSettings/<ExposeHostPortsAsync>d__43")]
public static Task ExposeHostPortsAsync(IEnumerable`1<ushort> ports, CancellationToken ct);
}
[IsReadOnlyAttribute]
internal class DotNet.Testcontainers.Configurations.TmpfsMount : ValueType {
    [CompilerGeneratedAttribute]
private MountType <Type>k__BackingField;
    [CompilerGeneratedAttribute]
private AccessMode <AccessMode>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Source>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Target>k__BackingField;
    public MountType Type { get; }
    public AccessMode AccessMode { get; }
    public string Source { get; }
    public string Target { get; }
    public TmpfsMount(string containerPath, AccessMode accessMode);
    [CompilerGeneratedAttribute]
public sealed virtual MountType get_Type();
    [CompilerGeneratedAttribute]
public sealed virtual AccessMode get_AccessMode();
    [CompilerGeneratedAttribute]
public sealed virtual string get_Source();
    [CompilerGeneratedAttribute]
public sealed virtual string get_Target();
    public sealed virtual Task CreateAsync(CancellationToken ct);
    public sealed virtual Task DeleteAsync(CancellationToken ct);
}
public class DotNet.Testcontainers.Configurations.Unix : object {
    public static UnixFileModes FileMode644;
    public static UnixFileModes FileMode666;
    public static UnixFileModes FileMode700;
    public static UnixFileModes FileMode755;
    public static UnixFileModes FileMode777;
    [CompilerGeneratedAttribute]
private static IOperatingSystem <Instance>k__BackingField;
    [CompilerGeneratedAttribute]
private IDockerEndpointAuthenticationConfiguration <DockerEndpointAuthConfig>k__BackingField;
    public static IOperatingSystem Instance { get; }
    public IDockerEndpointAuthenticationConfiguration DockerEndpointAuthConfig { get; }
    private static Unix();
    public Unix(string endpoint);
    public Unix(Uri endpoint);
    public Unix(IDockerEndpointAuthenticationConfiguration dockerEndpointAuthConfig);
    [CompilerGeneratedAttribute]
public static IOperatingSystem get_Instance();
    [CompilerGeneratedAttribute]
public sealed virtual IDockerEndpointAuthenticationConfiguration get_DockerEndpointAuthConfig();
    public sealed virtual string NormalizePath(string path);
}
[FlagsAttribute]
public enum DotNet.Testcontainers.Configurations.UnixFileModes : Enum {
    public int value__;
    public static UnixFileModes None;
    public static UnixFileModes OtherExecute;
    public static UnixFileModes OtherWrite;
    public static UnixFileModes OtherRead;
    public static UnixFileModes GroupExecute;
    public static UnixFileModes GroupWrite;
    public static UnixFileModes GroupRead;
    public static UnixFileModes UserExecute;
    public static UnixFileModes UserWrite;
    public static UnixFileModes UserRead;
    public static UnixFileModes StickyBit;
    public static UnixFileModes SetGroup;
    public static UnixFileModes SetUser;
}
internal class DotNet.Testcontainers.Configurations.UntilContainerIsHealthy : object {
    private long _failingStreak;
    public UntilContainerIsHealthy(long failingStreak);
    public sealed virtual Task`1<bool> UntilAsync(IContainer container);
}
internal class DotNet.Testcontainers.Configurations.UntilContainerIsRunning : object {
    private static TestcontainersStates ContainerHasBeenRunningStates;
    public sealed virtual Task`1<bool> UntilAsync(IContainer container);
}
internal class DotNet.Testcontainers.Configurations.UntilFileExistsInContainer : object {
    private string _file;
    public UntilFileExistsInContainer(string file);
    [AsyncStateMachineAttribute("DotNet.Testcontainers.Configurations.UntilFileExistsInContainer/<UntilAsync>d__2")]
public sealed virtual Task`1<bool> UntilAsync(IContainer container);
}
internal class DotNet.Testcontainers.Configurations.UntilFileExistsOnHost : object {
    private string _file;
    public UntilFileExistsOnHost(string file);
    public sealed virtual Task`1<bool> UntilAsync(IContainer container);
}
internal class DotNet.Testcontainers.Configurations.UntilMessageIsLogged : object {
    private Regex _pattern;
    public UntilMessageIsLogged(string pattern);
    public UntilMessageIsLogged(Regex pattern);
    [AsyncStateMachineAttribute("DotNet.Testcontainers.Configurations.UntilMessageIsLogged/<UntilAsync>d__3")]
public sealed virtual Task`1<bool> UntilAsync(IContainer container);
}
internal class DotNet.Testcontainers.Configurations.UntilOperationIsSucceeded : object {
    private int _maxCallCount;
    private Func`1<bool> _operation;
    private int _tryCount;
    public UntilOperationIsSucceeded(Func`1<bool> operation, int maxCallCount);
    public sealed virtual Task`1<bool> UntilAsync(IContainer container);
}
internal class DotNet.Testcontainers.Configurations.UntilUnixCommandIsCompleted : object {
    private String[] _command;
    public UntilUnixCommandIsCompleted(string command);
    public UntilUnixCommandIsCompleted(String[] command);
    [AsyncStateMachineAttribute("DotNet.Testcontainers.Configurations.UntilUnixCommandIsCompleted/<UntilAsync>d__3")]
public virtual Task`1<bool> UntilAsync(IContainer container);
}
internal class DotNet.Testcontainers.Configurations.UntilUnixPortIsAvailable : UntilUnixCommandIsCompleted {
    public UntilUnixPortIsAvailable(int port);
}
internal class DotNet.Testcontainers.Configurations.UntilWindowsCommandIsCompleted : UntilUnixCommandIsCompleted {
    public UntilWindowsCommandIsCompleted(string command);
    public UntilWindowsCommandIsCompleted(String[] command);
}
internal class DotNet.Testcontainers.Configurations.UntilWindowsPortIsAvailable : UntilWindowsCommandIsCompleted {
    public UntilWindowsPortIsAvailable(int port);
}
internal class DotNet.Testcontainers.Configurations.UriResourceMapping : object {
    private Uri _uri;
    [CompilerGeneratedAttribute]
private MountType <Type>k__BackingField;
    [CompilerGeneratedAttribute]
private AccessMode <AccessMode>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Source>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Target>k__BackingField;
    [CompilerGeneratedAttribute]
private UnixFileModes <FileMode>k__BackingField;
    public MountType Type { get; }
    public AccessMode AccessMode { get; }
    public string Source { get; }
    public string Target { get; }
    public UnixFileModes FileMode { get; }
    public UriResourceMapping(Uri uri, string containerPath, UnixFileModes fileMode);
    [CompilerGeneratedAttribute]
public sealed virtual MountType get_Type();
    [CompilerGeneratedAttribute]
public sealed virtual AccessMode get_AccessMode();
    [CompilerGeneratedAttribute]
public sealed virtual string get_Source();
    [CompilerGeneratedAttribute]
public sealed virtual string get_Target();
    [CompilerGeneratedAttribute]
public sealed virtual UnixFileModes get_FileMode();
    public sealed virtual Task CreateAsync(CancellationToken ct);
    public sealed virtual Task DeleteAsync(CancellationToken ct);
    [AsyncStateMachineAttribute("DotNet.Testcontainers.Configurations.UriResourceMapping/<GetAllBytesAsync>d__19")]
public sealed virtual Task`1<Byte[]> GetAllBytesAsync(CancellationToken ct);
}
internal class DotNet.Testcontainers.Configurations.VolumeConfiguration : ResourceConfiguration`1<VolumesCreateParameters> {
    [CompilerGeneratedAttribute]
private string <Name>k__BackingField;
    public string Name { get; }
    public VolumeConfiguration(string name);
    public VolumeConfiguration(IResourceConfiguration`1<VolumesCreateParameters> resourceConfiguration);
    public VolumeConfiguration(IVolumeConfiguration resourceConfiguration);
    public VolumeConfiguration(IVolumeConfiguration oldValue, IVolumeConfiguration newValue);
    [CompilerGeneratedAttribute]
public sealed virtual string get_Name();
}
[IsReadOnlyAttribute]
internal class DotNet.Testcontainers.Configurations.VolumeMount : ValueType {
    private IVolume _volume;
    [CompilerGeneratedAttribute]
private MountType <Type>k__BackingField;
    [CompilerGeneratedAttribute]
private AccessMode <AccessMode>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Target>k__BackingField;
    public MountType Type { get; }
    public AccessMode AccessMode { get; }
    public string Source { get; }
    public string Target { get; }
    public VolumeMount(IVolume volume, string containerPath, AccessMode accessMode);
    [CompilerGeneratedAttribute]
public sealed virtual MountType get_Type();
    [CompilerGeneratedAttribute]
public sealed virtual AccessMode get_AccessMode();
    public sealed virtual string get_Source();
    [CompilerGeneratedAttribute]
public sealed virtual string get_Target();
    public sealed virtual Task CreateAsync(CancellationToken ct);
    public sealed virtual Task DeleteAsync(CancellationToken ct);
}
internal abstract class DotNet.Testcontainers.Configurations.WaitForContainerOS : object {
    private ICollection`1<IWaitUntil> _waitStrategies;
    public abstract virtual IWaitForContainerOS UntilCommandIsCompleted(string command);
    public abstract virtual IWaitForContainerOS UntilCommandIsCompleted(String[] command);
    public abstract virtual IWaitForContainerOS UntilPortIsAvailable(int port);
    public virtual IWaitForContainerOS AddCustomWaitStrategy(IWaitUntil waitStrategy);
    public virtual IWaitForContainerOS UntilFileExists(string filePath, FileSystem fileSystem);
    public sealed virtual IWaitForContainerOS UntilMessageIsLogged(string pattern);
    public sealed virtual IWaitForContainerOS UntilMessageIsLogged(Regex pattern);
    public virtual IWaitForContainerOS UntilOperationIsSucceeded(Func`1<bool> operation, int maxCallCount);
    public virtual IWaitForContainerOS UntilHttpRequestIsSucceeded(Func`2<HttpWaitStrategy, HttpWaitStrategy> request);
    public virtual IWaitForContainerOS UntilContainerIsHealthy(long failingStreak);
    public sealed virtual IEnumerable`1<IWaitUntil> Build();
}
internal class DotNet.Testcontainers.Configurations.WaitForContainerUnix : WaitForContainerOS {
    public virtual IWaitForContainerOS UntilCommandIsCompleted(string command);
    public virtual IWaitForContainerOS UntilCommandIsCompleted(String[] command);
    public virtual IWaitForContainerOS UntilPortIsAvailable(int port);
}
internal class DotNet.Testcontainers.Configurations.WaitForContainerWindows : WaitForContainerOS {
    public virtual IWaitForContainerOS UntilCommandIsCompleted(string command);
    public virtual IWaitForContainerOS UntilCommandIsCompleted(String[] command);
    public virtual IWaitForContainerOS UntilPortIsAvailable(int port);
}
public static class DotNet.Testcontainers.Configurations.WaitStrategy : object {
    [AsyncStateMachineAttribute("DotNet.Testcontainers.Configurations.WaitStrategy/<WaitWhileAsync>d__0")]
public static Task WaitWhileAsync(Func`1<Task`1<bool>> wait, TimeSpan frequency, TimeSpan timeout, CancellationToken ct);
    [AsyncStateMachineAttribute("DotNet.Testcontainers.Configurations.WaitStrategy/<WaitUntilAsync>d__1")]
public static Task WaitUntilAsync(Func`1<Task`1<bool>> wait, TimeSpan frequency, TimeSpan timeout, CancellationToken ct);
}
public class DotNet.Testcontainers.Configurations.Windows : object {
    [CompilerGeneratedAttribute]
private static IOperatingSystem <Instance>k__BackingField;
    [CompilerGeneratedAttribute]
private IDockerEndpointAuthenticationConfiguration <DockerEndpointAuthConfig>k__BackingField;
    public static IOperatingSystem Instance { get; }
    public IDockerEndpointAuthenticationConfiguration DockerEndpointAuthConfig { get; }
    private static Windows();
    public Windows(string endpoint);
    public Windows(Uri endpoint);
    public Windows(IDockerEndpointAuthenticationConfiguration dockerEndpointAuthConfig);
    [CompilerGeneratedAttribute]
public static IOperatingSystem get_Instance();
    [CompilerGeneratedAttribute]
public sealed virtual IDockerEndpointAuthenticationConfiguration get_DockerEndpointAuthConfig();
    public sealed virtual string NormalizePath(string path);
}
public class DotNet.Testcontainers.ConsoleLogger : object {
    private Stopwatch _stopwatch;
    private LogLevel _minLogLevel;
    [CompilerGeneratedAttribute]
private static ConsoleLogger <Instance>k__BackingField;
    public static ConsoleLogger Instance { get; }
    public bool DebugLogLevelEnabled { get; public set; }
    private static ConsoleLogger();
    [CompilerGeneratedAttribute]
public static ConsoleLogger get_Instance();
    public bool get_DebugLogLevelEnabled();
    public void set_DebugLogLevelEnabled(bool value);
    public sealed virtual void Dispose();
    public sealed virtual void Log(LogLevel logLevel, EventId eventId, TState state, Exception exception, Func`3<TState, Exception, string> formatter);
    public sealed virtual bool IsEnabled(LogLevel logLevel);
    public sealed virtual IDisposable BeginScope(TState state);
}
public class DotNet.Testcontainers.Containers.DockerContainer : Resource {
    private static TestcontainersStates ContainerHasBeenCreatedStates;
    private static TestcontainersHealthStatus ContainerHasHealthCheck;
    private ITestcontainersClient _client;
    private IContainerConfiguration _configuration;
    private ContainerInspectResponse _container;
    [CompilerGeneratedAttribute]
private EventHandler Creating;
    [CompilerGeneratedAttribute]
private EventHandler Starting;
    [CompilerGeneratedAttribute]
private EventHandler Stopping;
    [CompilerGeneratedAttribute]
private EventHandler Created;
    [CompilerGeneratedAttribute]
private EventHandler Started;
    [CompilerGeneratedAttribute]
private EventHandler Stopped;
    [CompilerGeneratedAttribute]
private DateTime <CreatedTime>k__BackingField;
    [CompilerGeneratedAttribute]
private DateTime <StartedTime>k__BackingField;
    [CompilerGeneratedAttribute]
private DateTime <StoppedTime>k__BackingField;
    public DateTime CreatedTime { get; private set; }
    public DateTime StartedTime { get; private set; }
    public DateTime StoppedTime { get; private set; }
    public ILogger Logger { get; }
    public string Id { get; }
    public string Name { get; }
    public string IpAddress { get; }
    public string MacAddress { get; }
    public string Hostname { get; }
    public IImage Image { get; }
    public TestcontainersStates State { get; }
    public TestcontainersHealthStatus Health { get; }
    public long HealthCheckFailingStreak { get; }
    public DockerContainer(IContainerConfiguration configuration);
    [ObsoleteAttribute("Use the constructor DockerContainer(IContainerConfiguration) instead.")]
public DockerContainer(IContainerConfiguration configuration, ILogger logger);
    [CompilerGeneratedAttribute]
public sealed virtual void add_Creating(EventHandler value);
    [CompilerGeneratedAttribute]
public sealed virtual void remove_Creating(EventHandler value);
    [CompilerGeneratedAttribute]
public sealed virtual void add_Starting(EventHandler value);
    [CompilerGeneratedAttribute]
public sealed virtual void remove_Starting(EventHandler value);
    [CompilerGeneratedAttribute]
public sealed virtual void add_Stopping(EventHandler value);
    [CompilerGeneratedAttribute]
public sealed virtual void remove_Stopping(EventHandler value);
    [CompilerGeneratedAttribute]
public sealed virtual void add_Created(EventHandler value);
    [CompilerGeneratedAttribute]
public sealed virtual void remove_Created(EventHandler value);
    [CompilerGeneratedAttribute]
public sealed virtual void add_Started(EventHandler value);
    [CompilerGeneratedAttribute]
public sealed virtual void remove_Started(EventHandler value);
    [CompilerGeneratedAttribute]
public sealed virtual void add_Stopped(EventHandler value);
    [CompilerGeneratedAttribute]
public sealed virtual void remove_Stopped(EventHandler value);
    [CompilerGeneratedAttribute]
public sealed virtual DateTime get_CreatedTime();
    [CompilerGeneratedAttribute]
private void set_CreatedTime(DateTime value);
    [CompilerGeneratedAttribute]
public sealed virtual DateTime get_StartedTime();
    [CompilerGeneratedAttribute]
private void set_StartedTime(DateTime value);
    [CompilerGeneratedAttribute]
public sealed virtual DateTime get_StoppedTime();
    [CompilerGeneratedAttribute]
private void set_StoppedTime(DateTime value);
    public sealed virtual ILogger get_Logger();
    public sealed virtual string get_Id();
    public sealed virtual string get_Name();
    public sealed virtual string get_IpAddress();
    public sealed virtual string get_MacAddress();
    public sealed virtual string get_Hostname();
    public sealed virtual IImage get_Image();
    public sealed virtual TestcontainersStates get_State();
    public sealed virtual TestcontainersHealthStatus get_Health();
    public sealed virtual long get_HealthCheckFailingStreak();
    public sealed virtual ushort GetMappedPublicPort(int containerPort);
    public sealed virtual ushort GetMappedPublicPort(string containerPort);
    public sealed virtual Task`1<long> GetExitCodeAsync(CancellationToken ct);
    public sealed virtual Task`1<ValueTuple`2<string, string>> GetLogsAsync(DateTime since, DateTime until, bool timestampsEnabled, CancellationToken ct);
    [AsyncStateMachineAttribute("DotNet.Testcontainers.Containers.DockerContainer/<StartAsync>d__61")]
public virtual Task StartAsync(CancellationToken ct);
    [AsyncStateMachineAttribute("DotNet.Testcontainers.Containers.DockerContainer/<StopAsync>d__62")]
public virtual Task StopAsync(CancellationToken ct);
    public sealed virtual Task CopyAsync(Byte[] fileContent, string filePath, UnixFileModes fileMode, CancellationToken ct);
    public sealed virtual Task CopyAsync(string source, string target, UnixFileModes fileMode, CancellationToken ct);
    public sealed virtual Task CopyAsync(FileInfo source, string target, UnixFileModes fileMode, CancellationToken ct);
    public sealed virtual Task CopyAsync(DirectoryInfo source, string target, UnixFileModes fileMode, CancellationToken ct);
    public sealed virtual Task`1<Byte[]> ReadFileAsync(string filePath, CancellationToken ct);
    public sealed virtual Task`1<ExecResult> ExecAsync(IList`1<string> command, CancellationToken ct);
    [AsyncStateMachineAttribute("DotNet.Testcontainers.Containers.DockerContainer/<DisposeAsyncCore>d__69")]
protected virtual ValueTask DisposeAsyncCore();
    [AsyncStateMachineAttribute("DotNet.Testcontainers.Containers.DockerContainer/<UnsafeCreateAsync>d__70")]
protected virtual Task UnsafeCreateAsync(CancellationToken ct);
    [AsyncStateMachineAttribute("DotNet.Testcontainers.Containers.DockerContainer/<UnsafeDeleteAsync>d__71")]
protected virtual Task UnsafeDeleteAsync(CancellationToken ct);
    [AsyncStateMachineAttribute("DotNet.Testcontainers.Containers.DockerContainer/<UnsafeStartAsync>d__72")]
protected virtual Task UnsafeStartAsync(CancellationToken ct);
    [AsyncStateMachineAttribute("DotNet.Testcontainers.Containers.DockerContainer/<UnsafeStopAsync>d__73")]
protected virtual Task UnsafeStopAsync(CancellationToken ct);
    protected virtual bool Exists();
    [CompilerGeneratedAttribute]
[DebuggerHiddenAttribute]
private ValueTask <>n__0();
}
[IsReadOnlyAttribute]
public class DotNet.Testcontainers.Containers.ExecResult : ValueType {
    [CompilerGeneratedAttribute]
private string <Stdout>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Stderr>k__BackingField;
    [CompilerGeneratedAttribute]
private long <ExitCode>k__BackingField;
    public string Stdout { get; }
    public string Stderr { get; }
    public long ExitCode { get; }
    public ExecResult(string stdout, string stderr, long exitCode);
    [CompilerGeneratedAttribute]
public string get_Stdout();
    [CompilerGeneratedAttribute]
public string get_Stderr();
    [CompilerGeneratedAttribute]
public long get_ExitCode();
}
public interface DotNet.Testcontainers.Containers.IContainer {
    public DateTime CreatedTime { get; }
    public DateTime StartedTime { get; }
    public DateTime StoppedTime { get; }
    public ILogger Logger { get; }
    public string Id { get; }
    public string Name { get; }
    public string IpAddress { get; }
    public string MacAddress { get; }
    public string Hostname { get; }
    public IImage Image { get; }
    public TestcontainersStates State { get; }
    public TestcontainersHealthStatus Health { get; }
    public long HealthCheckFailingStreak { get; }
    [CompilerGeneratedAttribute]
public abstract virtual void add_Creating(EventHandler value);
    [CompilerGeneratedAttribute]
public abstract virtual void remove_Creating(EventHandler value);
    [CompilerGeneratedAttribute]
public abstract virtual void add_Starting(EventHandler value);
    [CompilerGeneratedAttribute]
public abstract virtual void remove_Starting(EventHandler value);
    [CompilerGeneratedAttribute]
public abstract virtual void add_Stopping(EventHandler value);
    [CompilerGeneratedAttribute]
public abstract virtual void remove_Stopping(EventHandler value);
    [CompilerGeneratedAttribute]
public abstract virtual void add_Created(EventHandler value);
    [CompilerGeneratedAttribute]
public abstract virtual void remove_Created(EventHandler value);
    [CompilerGeneratedAttribute]
public abstract virtual void add_Started(EventHandler value);
    [CompilerGeneratedAttribute]
public abstract virtual void remove_Started(EventHandler value);
    [CompilerGeneratedAttribute]
public abstract virtual void add_Stopped(EventHandler value);
    [CompilerGeneratedAttribute]
public abstract virtual void remove_Stopped(EventHandler value);
    public abstract virtual DateTime get_CreatedTime();
    public abstract virtual DateTime get_StartedTime();
    public abstract virtual DateTime get_StoppedTime();
    public abstract virtual ILogger get_Logger();
    public abstract virtual string get_Id();
    public abstract virtual string get_Name();
    public abstract virtual string get_IpAddress();
    public abstract virtual string get_MacAddress();
    public abstract virtual string get_Hostname();
    public abstract virtual IImage get_Image();
    public abstract virtual TestcontainersStates get_State();
    public abstract virtual TestcontainersHealthStatus get_Health();
    public abstract virtual long get_HealthCheckFailingStreak();
    public abstract virtual ushort GetMappedPublicPort(int containerPort);
    public abstract virtual ushort GetMappedPublicPort(string containerPort);
    public abstract virtual Task`1<long> GetExitCodeAsync(CancellationToken ct);
    public abstract virtual Task`1<ValueTuple`2<string, string>> GetLogsAsync(DateTime since, DateTime until, bool timestampsEnabled, CancellationToken ct);
    public abstract virtual Task StartAsync(CancellationToken ct);
    public abstract virtual Task StopAsync(CancellationToken ct);
    public abstract virtual Task CopyAsync(Byte[] fileContent, string filePath, UnixFileModes fileMode, CancellationToken ct);
    public abstract virtual Task CopyAsync(string source, string target, UnixFileModes fileMode, CancellationToken ct);
    public abstract virtual Task CopyAsync(DirectoryInfo source, string target, UnixFileModes fileMode, CancellationToken ct);
    public abstract virtual Task CopyAsync(FileInfo source, string target, UnixFileModes fileMode, CancellationToken ct);
    public abstract virtual Task`1<Byte[]> ReadFileAsync(string filePath, CancellationToken ct);
    public abstract virtual Task`1<ExecResult> ExecAsync(IList`1<string> command, CancellationToken ct);
}
public interface DotNet.Testcontainers.Containers.IDatabaseContainer {
    public abstract virtual string GetConnectionString();
}
internal class DotNet.Testcontainers.Containers.PortForwardingContainer : DockerContainer {
    private PortForwardingConfiguration _configuration;
    [CompilerGeneratedAttribute]
private static PortForwardingContainer <Instance>k__BackingField;
    public static PortForwardingContainer Instance { get; }
    private static PortForwardingContainer();
    private PortForwardingContainer(PortForwardingConfiguration configuration);
    [CompilerGeneratedAttribute]
public static PortForwardingContainer get_Instance();
    public Task ExposeHostPortsAsync(IEnumerable`1<ushort> ports, CancellationToken ct);
}
public class DotNet.Testcontainers.Containers.ResourceReaper : object {
    public static string ResourceReaperSessionLabel;
    private static ushort RyukPort;
    private static int ConnectionTimeoutInSeconds;
    private static int RetryTimeoutInSeconds;
    private static IImage RyukImage;
    private static SemaphoreSlim DefaultLock;
    private static LingerOption DiscardAllPendingData;
    private static ResourceReaper _defaultInstance;
    private CancellationTokenSource _maintainConnectionCts;
    private IContainer _resourceReaperContainer;
    private Task _maintainConnectionTask;
    private bool _disposed;
    [CompilerGeneratedAttribute]
private static EventHandler`1<ResourceReaperStateEventArgs> StateChanged;
    [CompilerGeneratedAttribute]
private static Guid <DefaultSessionId>k__BackingField;
    [CompilerGeneratedAttribute]
private Guid <SessionId>k__BackingField;
    public static Guid DefaultSessionId { get; }
    public Guid SessionId { get; }
    private static ResourceReaper();
    private ResourceReaper(Guid sessionId, IDockerEndpointAuthenticationConfiguration dockerEndpointAuthConfig, IImage resourceReaperImage, IMount dockerSocket, ILogger logger, bool requiresPrivilegedMode);
    [CompilerGeneratedAttribute]
public static void add_StateChanged(EventHandler`1<ResourceReaperStateEventArgs> value);
    [CompilerGeneratedAttribute]
public static void remove_StateChanged(EventHandler`1<ResourceReaperStateEventArgs> value);
    [CompilerGeneratedAttribute]
public static Guid get_DefaultSessionId();
    [CompilerGeneratedAttribute]
public Guid get_SessionId();
    [ObsoleteAttribute("Use GetAndStartDefaultAsync(IDockerEndpointAuthenticationConfiguration, ILogger, bool, CancellationToken) instead.")]
public static Task`1<ResourceReaper> GetAndStartDefaultAsync(IDockerEndpointAuthenticationConfiguration dockerEndpointAuthConfig, bool isWindowsEngineEnabled, CancellationToken ct);
    [AsyncStateMachineAttribute("DotNet.Testcontainers.Containers.ResourceReaper/<GetAndStartDefaultAsync>d__24")]
public static Task`1<ResourceReaper> GetAndStartDefaultAsync(IDockerEndpointAuthenticationConfiguration dockerEndpointAuthConfig, ILogger logger, bool isWindowsEngineEnabled, CancellationToken ct);
    [AsyncStateMachineAttribute("DotNet.Testcontainers.Containers.ResourceReaper/<DisposeAsync>d__25")]
public sealed virtual ValueTask DisposeAsync();
    private static Task`1<ResourceReaper> GetAndStartNewAsync(IDockerEndpointAuthenticationConfiguration dockerEndpointAuthConfig, IImage resourceReaperImage, IMount dockerSocket, ILogger logger, bool requiresPrivilegedMode, TimeSpan initTimeout, CancellationToken ct);
    [AsyncStateMachineAttribute("DotNet.Testcontainers.Containers.ResourceReaper/<GetAndStartNewAsync>d__27")]
private static Task`1<ResourceReaper> GetAndStartNewAsync(Guid sessionId, IDockerEndpointAuthenticationConfiguration dockerEndpointAuthConfig, IImage resourceReaperImage, IMount dockerSocket, ILogger logger, bool requiresPrivilegedMode, TimeSpan initTimeout, CancellationToken ct);
    private bool TryGetEndpoint(String& host, UInt16& port);
    [AsyncStateMachineAttribute("DotNet.Testcontainers.Containers.ResourceReaper/<MaintainRyukConnection>d__29")]
private Task MaintainRyukConnection(TaskCompletionSource`1<bool> ryukInitializedTaskSource, CancellationToken ct);
}
public class DotNet.Testcontainers.Containers.ResourceReaperException : Exception {
    public ResourceReaperException(string message);
}
public enum DotNet.Testcontainers.Containers.ResourceReaperState : Enum {
    public int value__;
    public static ResourceReaperState Created;
    public static ResourceReaperState InitializingConnection;
    public static ResourceReaperState MaintainingConnection;
    public static ResourceReaperState ConnectionTerminated;
}
public class DotNet.Testcontainers.Containers.ResourceReaperStateEventArgs : EventArgs {
    [CompilerGeneratedAttribute]
private ResourceReaper <Instance>k__BackingField;
    [CompilerGeneratedAttribute]
private ResourceReaperState <State>k__BackingField;
    public ResourceReaper Instance { get; }
    public ResourceReaperState State { get; }
    public ResourceReaperStateEventArgs(ResourceReaper resourceReaper, ResourceReaperState resourceReaperState);
    [CompilerGeneratedAttribute]
public ResourceReaper get_Instance();
    [CompilerGeneratedAttribute]
public ResourceReaperState get_State();
}
public class DotNet.Testcontainers.Containers.TarOutputMemoryStream : TarOutputStream {
    private string _targetDirectoryPath;
    private ILogger _logger;
    private long _contentLength;
    public long ContentLength { get; }
    public TarOutputMemoryStream(string targetDirectoryPath, ILogger logger);
    public TarOutputMemoryStream(ILogger logger);
    public long get_ContentLength();
    [AsyncStateMachineAttribute("DotNet.Testcontainers.Containers.TarOutputMemoryStream/<AddAsync>d__7")]
public Task AddAsync(IResourceMapping resourceMapping, CancellationToken ct);
    public Task AddAsync(FileInfo file, UnixFileModes fileMode, CancellationToken ct);
    [AsyncStateMachineAttribute("DotNet.Testcontainers.Containers.TarOutputMemoryStream/<AddAsync>d__9")]
public Task AddAsync(DirectoryInfo directory, bool recurse, UnixFileModes fileMode, CancellationToken ct);
    [AsyncStateMachineAttribute("DotNet.Testcontainers.Containers.TarOutputMemoryStream/<AddAsync>d__10")]
public Task AddAsync(DirectoryInfo directory, FileInfo file, UnixFileModes fileMode, CancellationToken ct);
}
[FlagsAttribute]
public enum DotNet.Testcontainers.Containers.TestcontainersHealthStatus : Enum {
    public int value__;
    public static TestcontainersHealthStatus Undefined;
    public static TestcontainersHealthStatus None;
    public static TestcontainersHealthStatus Starting;
    public static TestcontainersHealthStatus Healthy;
    public static TestcontainersHealthStatus Unhealthy;
}
[FlagsAttribute]
public enum DotNet.Testcontainers.Containers.TestcontainersStates : Enum {
    public int value__;
    public static TestcontainersStates Undefined;
    public static TestcontainersStates Created;
    public static TestcontainersStates Restarting;
    public static TestcontainersStates Running;
    public static TestcontainersStates Paused;
    public static TestcontainersStates Exited;
    public static TestcontainersStates Dead;
}
[ExtensionAttribute]
[DebuggerStepThroughAttribute]
public static class DotNet.Testcontainers.Guard : object {
    public static ArgumentInfo`1<TType> Argument(TType value, string name);
    [ExtensionAttribute]
public static ArgumentInfo`1& modreq(System.Runtime.InteropServices.InAttribute) Null(ArgumentInfo`1& argument, string exceptionMessage);
    [ExtensionAttribute]
public static ArgumentInfo`1& modreq(System.Runtime.InteropServices.InAttribute) NotNull(ArgumentInfo`1& argument, string exceptionMessage);
    [ExtensionAttribute]
public static ArgumentInfo`1<TType> ThrowIf(ArgumentInfo`1& argument, Func`2<ArgumentInfo`1<TType>, bool> condition, Func`2<ArgumentInfo`1<TType>, Exception> ifClause);
    [ExtensionAttribute]
public static ArgumentInfo`1& modreq(System.Runtime.InteropServices.InAttribute) Empty(ArgumentInfo`1& argument, string exceptionMessage);
    [ExtensionAttribute]
public static ArgumentInfo`1& modreq(System.Runtime.InteropServices.InAttribute) NotEmpty(ArgumentInfo`1& argument, string exceptionMessage);
    [ExtensionAttribute]
public static ArgumentInfo`1& modreq(System.Runtime.InteropServices.InAttribute) NotUppercase(ArgumentInfo`1& argument, string exceptionMessage);
}
public interface DotNet.Testcontainers.IFutureResource {
    public abstract virtual Task CreateAsync(CancellationToken ct);
    public abstract virtual Task DeleteAsync(CancellationToken ct);
}
internal class DotNet.Testcontainers.Images.DockerfileArchive : object {
    private static Regex FromLinePattern;
    private DirectoryInfo _dockerfileDirectory;
    private FileInfo _dockerfile;
    private IImage _image;
    private ILogger _logger;
    public DockerfileArchive(string dockerfileDirectory, string dockerfile, IImage image, ILogger logger);
    public DockerfileArchive(DirectoryInfo dockerfileDirectory, FileInfo dockerfile, IImage image, ILogger logger);
    private static DockerfileArchive();
    public IEnumerable`1<IImage> GetBaseImages();
    [AsyncStateMachineAttribute("DotNet.Testcontainers.Images.DockerfileArchive/<Tar>d__8")]
public sealed virtual Task`1<string> Tar(CancellationToken ct);
    private static IEnumerable`1<string> GetFiles(string directory);
}
internal class DotNet.Testcontainers.Images.DockerIgnoreFile : IgnoreFile {
    public DockerIgnoreFile(string dockerignoreFileDirectory, string dockerignoreFile, string dockerfileFile, ILogger logger);
    public DockerIgnoreFile(FileSystemInfo dockerignoreFileDirectory, string dockerignoreFile, string dockerfileFile, ILogger logger);
    private static IEnumerable`1<string> GetPatterns(FileSystemInfo dockerignoreFileDirectory, string dockerignoreFile, string dockerfileFile);
}
public class DotNet.Testcontainers.Images.DockerImage : object {
    private static string LatestTag;
    private static Func`2<string, IImage> GetDockerImage;
    private static Char[] TrimChars;
    private static Char[] HostnameIdentifierChars;
    private string _hubImageNamePrefix;
    private Lazy`1<string> _lazyFullName;
    private Lazy`1<string> _lazyHostname;
    [CompilerGeneratedAttribute]
private string <Repository>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Name>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Tag>k__BackingField;
    public string Repository { get; }
    public string Name { get; }
    public string Tag { get; }
    public string FullName { get; }
    public DockerImage(IImage image);
    public DockerImage(string image);
    public DockerImage(string repository, string name, string tag, string hubImageNamePrefix);
    private static DockerImage();
    [CompilerGeneratedAttribute]
public sealed virtual string get_Repository();
    [CompilerGeneratedAttribute]
public sealed virtual string get_Name();
    [CompilerGeneratedAttribute]
public sealed virtual string get_Tag();
    public sealed virtual string get_FullName();
    public sealed virtual string GetHostname();
    private static string TrimOrDefault(string value, string defaultValue);
    [CompilerGeneratedAttribute]
private string <.ctor>b__9_0();
    [CompilerGeneratedAttribute]
private string <.ctor>b__9_1();
}
internal class DotNet.Testcontainers.Images.FutureDockerImage : Resource {
    private ITestcontainersClient _client;
    private IImageFromDockerfileConfiguration _configuration;
    private ImageInspectResponse _image;
    public string Repository { get; }
    public string Name { get; }
    public string Tag { get; }
    public string FullName { get; }
    public FutureDockerImage(IImageFromDockerfileConfiguration configuration);
    public sealed virtual string get_Repository();
    public sealed virtual string get_Name();
    public sealed virtual string get_Tag();
    public sealed virtual string get_FullName();
    public sealed virtual string GetHostname();
    [AsyncStateMachineAttribute("DotNet.Testcontainers.Images.FutureDockerImage/<CreateAsync>d__13")]
public sealed virtual Task CreateAsync(CancellationToken ct);
    [AsyncStateMachineAttribute("DotNet.Testcontainers.Images.FutureDockerImage/<DeleteAsync>d__14")]
public sealed virtual Task DeleteAsync(CancellationToken ct);
    protected virtual bool Exists();
    [AsyncStateMachineAttribute("DotNet.Testcontainers.Images.FutureDockerImage/<UnsafeCreateAsync>d__16")]
protected virtual Task UnsafeCreateAsync(CancellationToken ct);
    [AsyncStateMachineAttribute("DotNet.Testcontainers.Images.FutureDockerImage/<UnsafeDeleteAsync>d__17")]
protected virtual Task UnsafeDeleteAsync(CancellationToken ct);
}
public interface DotNet.Testcontainers.Images.IFutureDockerImage {
}
public class DotNet.Testcontainers.Images.IgnoreFile : object {
    private static ISearchAndReplace`1[] PrepareRegex;
    private IEnumerable`1<KeyValuePair`2<Regex, bool>> _ignorePatterns;
    public IgnoreFile(IEnumerable`1<string> patterns, ILogger logger);
    private static IgnoreFile();
    public bool Accepts(string file);
    public bool Denies(string file);
}
public interface DotNet.Testcontainers.Images.IImage {
    public string Repository { get; }
    public string Name { get; }
    public string Tag { get; }
    public string FullName { get; }
    public abstract virtual string get_Repository();
    public abstract virtual string get_Name();
    public abstract virtual string get_Tag();
    public abstract virtual string get_FullName();
    public abstract virtual string GetHostname();
}
internal interface DotNet.Testcontainers.Images.ITarArchive {
    public abstract virtual Task`1<string> Tar(CancellationToken ct);
}
internal static class DotNet.Testcontainers.Images.MatchImage : object {
    private static Char[] SlashSeparator;
    private static Char[] ColonSeparator;
    private static MatchImage();
    public static IImage Match(string image);
}
public static class DotNet.Testcontainers.Images.PullPolicy : object {
    public static Func`2<ImageInspectResponse, bool> Never { get; }
    public static Func`2<ImageInspectResponse, bool> Missing { get; }
    public static Func`2<ImageInspectResponse, bool> Always { get; }
    public static Func`2<ImageInspectResponse, bool> get_Never();
    public static Func`2<ImageInspectResponse, bool> get_Missing();
    public static Func`2<ImageInspectResponse, bool> get_Always();
}
[ExtensionAttribute]
internal static class DotNet.Testcontainers.Logging : object {
    private static Action`3<ILogger, Regex, Exception> _IgnorePatternAdded;
    private static Action`3<ILogger, string, Exception> _DockerContainerCreated;
    private static Action`3<ILogger, string, Exception> _StartDockerContainer;
    private static Action`3<ILogger, string, Exception> _StopDockerContainer;
    private static Action`3<ILogger, string, Exception> _DeleteDockerContainer;
    private static Action`3<ILogger, string, Exception> _StartReadinessCheck;
    private static Action`3<ILogger, string, Exception> _CompleteReadinessCheck;
    private static Action`4<ILogger, long, string, Exception> _CopyArchiveToDockerContainer;
    private static Action`4<ILogger, string, string, Exception> _ReadArchiveFromDockerContainer;
    private static Action`4<ILogger, Type, string, Exception> _AttachToDockerContainer;
    private static Action`4<ILogger, string, string, Exception> _ConnectToDockerNetwork;
    private static Action`4<ILogger, string, string, Exception> _ExecuteCommandInDockerContainer;
    private static Action`3<ILogger, string, Exception> _DockerImageCreated;
    private static Action`3<ILogger, string, Exception> _DockerImageBuilt;
    private static Action`3<ILogger, string, Exception> _DeleteDockerImage;
    private static Action`3<ILogger, string, Exception> _DockerNetworkCreated;
    private static Action`3<ILogger, string, Exception> _DeleteDockerNetwork;
    private static Action`3<ILogger, string, Exception> _DockerVolumeCreated;
    private static Action`3<ILogger, string, Exception> _DeleteDockerVolume;
    private static Action`3<ILogger, Guid, Exception> _CanNotGetResourceReaperEndpoint;
    private static Action`4<ILogger, Guid, string, Exception> _CanNotConnectToResourceReaper;
    private static Action`4<ILogger, Guid, string, Exception> _LostConnectionToResourceReaper;
    private static Action`3<ILogger, string, Exception> _DockerConfigFileNotFound;
    private static Action`3<ILogger, string, Exception> _SearchingDockerRegistryCredential;
    private static Action`4<ILogger, string, JsonValueKind, Exception> _DockerRegistryAuthPropertyValueKindInvalid;
    private static Action`3<ILogger, string, Exception> _DockerRegistryAuthPropertyValueNotFound;
    private static Action`3<ILogger, string, Exception> _DockerRegistryAuthPropertyValueInvalidBase64;
    private static Action`3<ILogger, string, Exception> _DockerRegistryAuthPropertyValueInvalidBasicAuthenticationFormat;
    private static Action`3<ILogger, string, Exception> _DockerRegistryCredentialNotFound;
    private static Action`3<ILogger, string, Exception> _DockerRegistryCredentialFound;
    private static Action`2<ILogger, Exception> _ReusableExperimentalFeature;
    private static Action`2<ILogger, Exception> _ReusableResourceFound;
    private static Action`2<ILogger, Exception> _ReusableResourceNotFound;
    private static Logging();
    [ExtensionAttribute]
public static void IgnorePatternAdded(ILogger logger, Regex ignorePattern);
    [ExtensionAttribute]
public static void DockerContainerCreated(ILogger logger, string id);
    [ExtensionAttribute]
public static void StartDockerContainer(ILogger logger, string id);
    [ExtensionAttribute]
public static void StopDockerContainer(ILogger logger, string id);
    [ExtensionAttribute]
public static void DeleteDockerContainer(ILogger logger, string id);
    [ExtensionAttribute]
public static void StartReadinessCheck(ILogger logger, string id);
    [ExtensionAttribute]
public static void CompleteReadinessCheck(ILogger logger, string id);
    [ExtensionAttribute]
public static void CopyArchiveToDockerContainer(ILogger logger, string id, long length);
    [ExtensionAttribute]
public static void ReadArchiveFromDockerContainer(ILogger logger, string id, string path);
    [ExtensionAttribute]
public static void AttachToDockerContainer(ILogger logger, string id, Type type);
    [ExtensionAttribute]
public static void ConnectToDockerNetwork(ILogger logger, string networkId, string containerId);
    [ExtensionAttribute]
public static void ExecuteCommandInDockerContainer(ILogger logger, string id, IEnumerable`1<string> command);
    [ExtensionAttribute]
public static void DockerImageCreated(ILogger logger, IImage image);
    [ExtensionAttribute]
public static void DockerImageBuilt(ILogger logger, IImage image);
    [ExtensionAttribute]
public static void DeleteDockerImage(ILogger logger, IImage image);
    [ExtensionAttribute]
public static void DockerNetworkCreated(ILogger logger, string id);
    [ExtensionAttribute]
public static void DeleteDockerNetwork(ILogger logger, string id);
    [ExtensionAttribute]
public static void DockerVolumeCreated(ILogger logger, string name);
    [ExtensionAttribute]
public static void DeleteDockerVolume(ILogger logger, string name);
    [ExtensionAttribute]
public static void CanNotGetResourceReaperEndpoint(ILogger logger, Guid id, Exception e);
    [ExtensionAttribute]
public static void CanNotConnectToResourceReaper(ILogger logger, Guid id, string host, ushort port, Exception e);
    [ExtensionAttribute]
public static void LostConnectionToResourceReaper(ILogger logger, Guid id, string host, ushort port, Exception e);
    [ExtensionAttribute]
public static void DockerConfigFileNotFound(ILogger logger, string dockerConfigFilePath);
    [ExtensionAttribute]
public static void SearchingDockerRegistryCredential(ILogger logger, string credentialStore);
    [ExtensionAttribute]
public static void DockerRegistryAuthPropertyValueKindInvalid(ILogger logger, string dockerRegistry, JsonValueKind valueKind);
    [ExtensionAttribute]
public static void DockerRegistryAuthPropertyValueNotFound(ILogger logger, string dockerRegistry);
    [ExtensionAttribute]
public static void DockerRegistryAuthPropertyValueInvalidBase64(ILogger logger, string dockerRegistry, Exception e);
    [ExtensionAttribute]
public static void DockerRegistryAuthPropertyValueInvalidBasicAuthenticationFormat(ILogger logger, string dockerRegistry);
    [ExtensionAttribute]
public static void DockerRegistryCredentialNotFound(ILogger logger, string dockerRegistry);
    [ExtensionAttribute]
public static void DockerRegistryCredentialFound(ILogger logger, string dockerRegistry);
    [ExtensionAttribute]
public static void ReusableExperimentalFeature(ILogger logger);
    [ExtensionAttribute]
public static void ReusableResourceFound(ILogger logger);
    [ExtensionAttribute]
public static void ReusableResourceNotFound(ILogger logger);
    private static string TruncId(string id);
}
internal class DotNet.Testcontainers.Networks.DockerNetwork : Resource {
    private ITestcontainersClient _client;
    private INetworkConfiguration _configuration;
    private NetworkResponse _network;
    public string Name { get; }
    public DockerNetwork(INetworkConfiguration configuration);
    public sealed virtual string get_Name();
    [AsyncStateMachineAttribute("DotNet.Testcontainers.Networks.DockerNetwork/<CreateAsync>d__6")]
public sealed virtual Task CreateAsync(CancellationToken ct);
    [AsyncStateMachineAttribute("DotNet.Testcontainers.Networks.DockerNetwork/<DeleteAsync>d__7")]
public sealed virtual Task DeleteAsync(CancellationToken ct);
    [AsyncStateMachineAttribute("DotNet.Testcontainers.Networks.DockerNetwork/<DisposeAsyncCore>d__8")]
protected virtual ValueTask DisposeAsyncCore();
    protected virtual bool Exists();
    [AsyncStateMachineAttribute("DotNet.Testcontainers.Networks.DockerNetwork/<UnsafeCreateAsync>d__10")]
protected virtual Task UnsafeCreateAsync(CancellationToken ct);
    [AsyncStateMachineAttribute("DotNet.Testcontainers.Networks.DockerNetwork/<UnsafeDeleteAsync>d__11")]
protected virtual Task UnsafeDeleteAsync(CancellationToken ct);
    [CompilerGeneratedAttribute]
[DebuggerHiddenAttribute]
private ValueTask <>n__0();
}
public interface DotNet.Testcontainers.Networks.INetwork {
    public string Name { get; }
    public abstract virtual string get_Name();
}
public abstract class DotNet.Testcontainers.Resource : object {
    private SemaphoreSlim _semaphoreSlim;
    private int _disposed;
    protected bool Disposed { get; }
    protected bool get_Disposed();
    [AsyncStateMachineAttribute("DotNet.Testcontainers.Resource/<DisposeAsync>d__4")]
public sealed virtual ValueTask DisposeAsync();
    protected abstract virtual bool Exists();
    protected abstract virtual Task UnsafeCreateAsync(CancellationToken ct);
    protected abstract virtual Task UnsafeDeleteAsync(CancellationToken ct);
    protected virtual ValueTask DisposeAsyncCore();
    protected virtual IDisposable AcquireLock();
    protected virtual void ThrowIfResourceNotFound();
    protected virtual void ThrowIfLockNotAcquired();
}
internal class DotNet.Testcontainers.Volumes.DockerVolume : Resource {
    private ITestcontainersClient _client;
    private IVolumeConfiguration _configuration;
    private VolumeResponse _volume;
    public string Name { get; }
    public DockerVolume(IVolumeConfiguration configuration);
    public sealed virtual string get_Name();
    [AsyncStateMachineAttribute("DotNet.Testcontainers.Volumes.DockerVolume/<CreateAsync>d__6")]
public sealed virtual Task CreateAsync(CancellationToken ct);
    [AsyncStateMachineAttribute("DotNet.Testcontainers.Volumes.DockerVolume/<DeleteAsync>d__7")]
public sealed virtual Task DeleteAsync(CancellationToken ct);
    [AsyncStateMachineAttribute("DotNet.Testcontainers.Volumes.DockerVolume/<DisposeAsyncCore>d__8")]
protected virtual ValueTask DisposeAsyncCore();
    protected virtual bool Exists();
    [AsyncStateMachineAttribute("DotNet.Testcontainers.Volumes.DockerVolume/<UnsafeCreateAsync>d__10")]
protected virtual Task UnsafeCreateAsync(CancellationToken ct);
    [AsyncStateMachineAttribute("DotNet.Testcontainers.Volumes.DockerVolume/<UnsafeDeleteAsync>d__11")]
protected virtual Task UnsafeDeleteAsync(CancellationToken ct);
    [CompilerGeneratedAttribute]
[DebuggerHiddenAttribute]
private ValueTask <>n__0();
}
public interface DotNet.Testcontainers.Volumes.IVolume {
    public string Name { get; }
    public abstract virtual string get_Name();
}
[CompilerGeneratedAttribute]
[EmbeddedAttribute]
internal class Microsoft.CodeAnalysis.EmbeddedAttribute : Attribute {
}
[CompilerGeneratedAttribute]
[EmbeddedAttribute]
[AttributeUsageAttribute("27524")]
internal class System.Runtime.CompilerServices.NullableAttribute : Attribute {
    public Byte[] NullableFlags;
    public NullableAttribute(byte );
    public NullableAttribute(Byte[] );
}
