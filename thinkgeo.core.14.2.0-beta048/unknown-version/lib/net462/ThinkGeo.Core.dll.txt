internal class 2jI=.0Do= : object {
    private 2zg= 4zY=;
    private T[][] ojM=;
    public 2zg= 0zo= { get; public set; }
    internal 0Do=(int width, int height, FT4=<T> allocator);
    public 2zg= 0To=();
    public void 0jo=(2zg= value);
    public T[][] 1Do=(int startRow, int numberOfRows);
}
internal class 2jI=.0jk= : 2zg= {
    internal yDo= 0zk=;
    internal int pTU=;
    internal int MTk=;
    internal int NTk=;
    internal 1To= Njk=;
    internal 1To= 1Dk=;
    internal int 1Tk=;
    internal int 1jk=;
    internal bool 1zk=;
    internal bool 2Dk=;
    internal 3Do= QTk=;
    internal bool 2Tk=;
    internal bool 2jk=;
    internal bool 2zk=;
    internal 4Do= 3Dk=;
    internal bool 3Tk=;
    internal int 3jk=;
    internal bool 3zk=;
    internal bool 4Dk=;
    internal bool 4Tk=;
    internal int 4jk=;
    internal int 4zk=;
    internal int 5Dk=;
    internal int 5Tk=;
    internal int 5jk=;
    internal int 5zk=;
    internal Byte[][] 6Dk=;
    internal int 6Tk=;
    internal int 6jk=;
    internal int 6zk=;
    internal int 7Dk=;
    internal int 7Tk=;
    internal Int32[][] 7jk=;
    internal zjo=[] ODk=;
    internal uzg=[] OTk=;
    internal uzg=[] Ojk=;
    internal int NDk=;
    private 8Tg=[] Nzk=;
    internal bool Szk=;
    internal int ojU=;
    internal bool 7zk=;
    internal byte RDk=;
    internal byte RTk=;
    internal oDY= Rjk=;
    internal short Rzk=;
    internal short SDk=;
    internal bool 8Dk=;
    internal byte 8Tk=;
    internal bool Pzk=;
    internal List`1<rTo=> 8jk=;
    internal int TDk=;
    internal int TTk=;
    internal int 8zk=;
    internal int Tjk=;
    internal Byte[] 9Dk=;
    internal int 9Tk=;
    internal int Tzk=;
    internal Int32[] UDk=;
    internal int UTk=;
    internal int Ujk=;
    internal int Uzk=;
    internal Int32[] VDk=;
    internal int VTk=;
    internal int Vjk=;
    internal int Vzk=;
    internal int WDk=;
    internal int 9jk=;
    internal KTc= WTk=;
    internal WTc= Wjk=;
    internal Pjc= XDk=;
    internal azc= 9zk=;
    internal rDc= /Dk=;
    internal 4jc= XTk=;
    internal dDc= YTk=;
    internal uTc= /Tk=;
    internal Ijg= /jk=;
    internal 9DY= Xjk=;
    internal Azc= /zk=;
    public bool 3zg= { get; }
    public yDo= Ajo= { get; public set; }
    public int aTk= { get; }
    public int bDk= { get; }
    public int eDk= { get; }
    public 1To= ezk= { get; public set; }
    public 1To= BTo= { get; public set; }
    public int CDo= { get; public set; }
    public int Czo= { get; public set; }
    public bool Djo= { get; public set; }
    public bool ETo= { get; public set; }
    public 3Do= ijk= { get; public set; }
    public bool FDo= { get; public set; }
    public bool Fzo= { get; public set; }
    public bool Gjo= { get; public set; }
    public 4Do= HTo= { get; public set; }
    public bool IDo= { get; public set; }
    public int Izo= { get; public set; }
    public bool Jjo= { get; public set; }
    public bool KTo= { get; public set; }
    public bool LDo= { get; public set; }
    public int Ljo= { get; }
    public int MDo= { get; }
    public int Mjo= { get; }
    public int NDo= { get; }
    public int Njo= { get; }
    public int OTo= { get; public set; }
    public Byte[][] PDo= { get; public set; }
    public int Pjo= { get; }
    public int QDo= { get; }
    public int Qjo= { get; }
    public int RDo= { get; }
    public int Rjo= { get; }
    public Int32[][] SDo= { get; }
    public oDY= nDk= { get; }
    public short nzk= { get; }
    public short ojk= { get; }
    public int dTk= { get; }
    public int pzk= { get; }
    public int Sjo= { get; }
    public 8Tg=[] TTo= { get; internal set; }
    public 0jk=(aTo= errorManager);
    public virtual bool 3jg=();
    public yDo= ADo=();
    public void ATo=(yDo= value);
    public int Zzk=();
    public int ajk=();
    public int djk=();
    public 1To= eTk=();
    public void ejk=(1To= value);
    public 1To= Azo=();
    public void BDo=(1To= value);
    public int Bjo=();
    public void Bzo=(int value);
    public int CTo=();
    public void Cjo=(int value);
    public bool DDo=();
    public void DTo=(bool value);
    public bool Dzo=();
    public void EDo=(bool value);
    public 3Do= iDk=();
    public void iTk=(3Do= value);
    public bool Ejo=();
    public void Ezo=(bool value);
    public bool FTo=();
    public void Fjo=(bool value);
    public bool GDo=();
    public void GTo=(bool value);
    public 4Do= Gzo=();
    public void HDo=(4Do= value);
    public bool Hjo=();
    public void Hzo=(bool value);
    public int ITo=();
    public void Ijo=(int value);
    public bool JDo=();
    public void JTo=(bool value);
    public bool Jzo=();
    public void KDo=(bool value);
    public bool Kjo=();
    public void Kzo=(bool value);
    public int LTo=();
    public int Lzo=();
    public int MTo=();
    public int Mzo=();
    public int NTo=();
    public int Nzo=();
    public void ODo=(int value);
    public Byte[][] Ojo=();
    public void Ozo=(Byte[][] value);
    public int PTo=();
    public int Pzo=();
    public int QTo=();
    public int Qzo=();
    public int RTo=();
    public Int32[][] Rzo=();
    public oDY= mjk=();
    public short nTk=();
    public short oDk=();
    public int czk=();
    public int pjk=();
    public int STo=();
    public 8Tg=[] Szo=();
    internal void TDo=(8Tg=[] value);
    public void Tjo=(Stream infile);
    public TDs= Tzo=(bool require_image);
    public bool UDo=();
    public int UTo=(Byte[][] scanlines, int max_lines);
    public bool Ujo=();
    public int Uzo=(Byte[][][] data, int max_lines);
    public bool VDo=();
    public bool VTo=(int scan_number);
    public bool Vjo=();
    public bool Vzo=();
    public TDs= WDo=();
    public void WTo=();
    public 0Do=[] Wjo=();
    public void Wzo=(JTk= dstinfo);
    public void XDo=();
    public void 8zc=(int marker_code, jpeg_marker_parser_method routine);
    public void 9Dc=(int marker_code, int length_limit);
    internal bool XTo=();
    private void xjk=();
    private void Xjo=();
    private bool Xzo=();
    private void YDo=();
    private void YTo=();
    private TDs= Yjo=();
}
internal class 2jI=.0zs= : object {
    private static int 1Ds=;
    private static int 1Ts=;
    private static int 1js=;
    private static int 1zs=;
    private static int 2Ds=;
    private static int 2Ts=;
    private static int 2js=;
    private static Fj4=[] 2zs=;
    private static String[] 3Ds=;
    private static int 3Ts=;
    private static int 3js=;
    private static int 3zs=;
    private static int 4Ds=;
    private static int 4Ts=;
    private static int 4js=;
    private static int 4zs=;
    private static int 5Ds=;
    private static int 5Ts=;
    private static int 5js=;
    private static int 5zs=;
    private static int 6Ds=;
    private static int 6Ts=;
    private static int 6js=;
    private static int 6zs=;
    private static int 7Ds=;
    private static int 7Ts=;
    private static int 7js=;
    private static int 7zs=;
    private static int 8Ds=;
    private static int 8Ts=;
    private static int 8js=;
    private static int 8zs=;
    private static int 9Ds=;
    private static int 9Ts=;
    private static int 9js=;
    private static int 9zs=;
    private static int /Ds=;
    private static int /Ts=;
    private static int /js=;
    private static int /zs=;
    private static int ADw=;
    private static int ATw=;
    private static int Ajw=;
    private static int Azw=;
    private static int BDw=;
    private static int BTw=;
    private static int Bjw=;
    private static int Bzw=;
    private static int CDw=;
    private static int CTw=;
    private static int Cjw=;
    private static int Czw=;
    private static int DDw=;
    private static int DTw=;
    private static int Djw=;
    private static int Dzw=;
    internal 9zw= EDw=;
    internal int ETw=;
    internal Byte[] Ejw=;
    internal int Ezw=;
    internal int FDw=;
    internal int FTw=;
    internal int Fjw=;
    internal byte Fzw=;
    internal byte GDw=;
    internal int GTw=;
    internal int Gjw=;
    internal int Gzw=;
    internal int HDw=;
    internal Byte[] HTw=;
    internal int Hjw=;
    internal Int16[] Hzw=;
    internal Int16[] IDw=;
    internal int ITw=;
    internal int Ijw=;
    internal int Izw=;
    internal int JDw=;
    internal int JTw=;
    internal int Jjw=;
    internal int Jzw=;
    internal int KDw=;
    internal int KTw=;
    internal int Kjw=;
    internal int Kzw=;
    internal int LDw=;
    internal int LTw=;
    internal int Ljw=;
    internal int Lzw=;
    internal int lx8=;
    internal int 1Ro=;
    internal int MDw=;
    internal int MTw=;
    internal Int16[] Mjw=;
    internal Int16[] Mzw=;
    internal Int16[] NDw=;
    internal 3zw= NTw=;
    internal 3zw= Njw=;
    internal 3zw= Nzw=;
    internal Int16[] ODw=;
    internal Int32[] OTw=;
    internal int Ojw=;
    internal int Ozw=;
    internal Byte[] PDw=;
    internal int PTw=;
    internal int Pjw=;
    internal int Pzw=;
    internal int QDw=;
    internal int QTw=;
    internal int Qjw=;
    internal int Qzw=;
    internal int RDw=;
    internal short RTw=;
    internal int Rjw=;
    private static 0zs=();
    internal void Rzw=();
    internal void SDw=();
    internal void STw=();
    internal void Sjw=(Int16[] tree, int k);
    internal static bool Szw=(Int16[] tree, int n, int m, Byte[] depth);
    internal void TDw=(Int16[] tree, int max_code);
    internal int TTw=();
    internal void Tjw=(int lcodes, int dcodes, int blcodes);
    internal void Tzw=(Int16[] tree, int max_code);
    internal void UDw=(Byte[] p, int start, int len);
    internal void UDw=(byte c);
    internal void UTw=(int w);
    internal void Ujw=(int b);
    internal void Uzw=(int c, Int16[] tree);
    internal void VDw=(int value_Renamed, int length);
    internal void VTw=();
    internal bool Vjw=(int dist, int lc);
    internal void Vzw=(Int16[] ltree, Int16[] dtree);
    internal void WDw=();
    internal void WTw=();
    internal void Wjw=();
    internal void Wzw=(int buf, int len, bool header);
    internal void XDw=(bool eof);
    internal int XTw=(int flush);
    internal void Xjw=(int buf, int stored_len, bool eof);
    internal void Xzw=(int buf, int stored_len, bool eof);
    internal void YDw=();
    internal int YTw=(int flush);
    internal int Yjw=(int flush);
    internal int Yzw=(int cur_match);
    internal int ZDw=(9zw= strm, int level, int bits);
    internal int ZDw=(9zw= strm, int level);
    internal int ZTw=(9zw= strm, int level, int method, int windowBits, int memLevel, int strategy);
    internal int Zjw=(9zw= strm);
    internal int Zzw=();
    internal int aDw=(9zw= strm, int _level, int _strategy);
    internal int aTw=(9zw= strm, Byte[] dictionary, int dictLength);
    internal int ajw=(9zw= strm, int flush);
}
internal class 2jI=.1jY= : object {
    private static int 1zY=;
    private static int 2DY=;
    private static int lDY=;
    private static int 2TY=;
    private static int 2jY=;
    private static int 2zY=;
    private static int 3DY=;
    private static int 3TY=;
    private static int 3jY=;
    private static int 3zY=;
    private static int 4DY=;
    private static int 4TY=;
    private static int 4jY=;
    private JTk= 4zY=;
    private bool 5DY=;
    private bool 5TY=;
    private bool 5jY=;
    private bool 5zY=;
    private bool 6DY=;
    private bool 6TY=;
    private Int32[] 6jY=;
    public 1jY=(JTk= cinfo);
    public void uzY=();
    public void 6zY=(Byte[][] input_buf, int input_row, Byte[][][] output_buf, int output_row, int num_rows);
    private void 7DY=();
    private void 7TY=();
    private static int 7jY=(double x);
    private void 7zY=(Byte[][] input_buf, int input_row, Byte[][][] output_buf, int output_row, int num_rows);
    private void 8DY=(Byte[][] input_buf, int input_row, Byte[][][] output_buf, int output_row, int num_rows);
    private void 8TY=(Byte[][] input_buf, int input_row, Byte[][][] output_buf, int output_row, int num_rows);
    private void 8jY=(Byte[][] input_buf, int input_row, Byte[][][] output_buf, int output_row, int num_rows);
    private void 8zY=(Byte[][] input_buf, int input_row, Byte[][][] output_buf, int output_row, int num_rows);
}
internal enum 2jI=.1To= : Enum {
    public int value__;
    public static 1To= 1jo=;
    public static 1To= 1zo=;
    public static 1To= 2Do=;
    public static 1To= 2To=;
    public static 1To= 2jo=;
    public static 1To= 2zo=;
}
internal class 2jI=.2jw= : object {
    public static long /SE=(long literal);
    public static ulong /SE=(ulong literal);
    public static float /SE=(float literal);
    public static double /SE=(double literal);
    public static int 2zw=(int number, int bits);
    public static int 2zw=(int number, long bits);
    public static long 2zw=(long number, int bits);
    public static long 2zw=(long number, long bits);
    public static int 3Dw=(Stream sourceStream, Byte[] target, int start, int count);
    public static int 3Dw=(TextReader sourceTextReader, Byte[] target, int start, int count);
    public static Byte[] 3Tw=(string sourceString);
    public static Char[] 3jw=(Byte[] byteArray);
}
internal enum 2jI=.2TI= : Enum {
    public int value__;
    public static 2TI= 2zI=;
    public static 2TI= 3DI=;
    public static 2TI= 3TI=;
}
internal abstract class 2jI=.2zg= : object {
    internal aTo= GDU=;
    internal szo= 3Dg=;
    internal BD4= 3Tg=;
    public bool 3zg= { get; }
    public szo= 4jg= { get; public set; }
    public aTo= 5Tg= { get; public set; }
    public static string 6xM= { get; }
    public static string 5zg= { get; }
    public 2zg=(aTo= errorManager);
    public abstract virtual bool 3jg=();
    public szo= 4Dg=();
    public void 4Tg=(szo= value);
    public aTo= 4zg=();
    public void 5Dg=(aTo= value);
    public static string 6RM=();
    public static string 5jg=();
    public static 0Do=<byte> 6Dg=(int samplesPerRow, int numberOfRows);
    public static 0Do=<ujg=> 6Tg=(int blocksPerRow, int numberOfRows);
    public static Byte[][] 6jg=(int samplesPerRow, int numberOfRows);
    private static ujg=[][] 6zg=(int blocksPerRow, int numberOfRows);
    public void 7Dg=();
    public void 7Tg=();
    public void 7jg=(5Do= code);
    public void 7jg=(5Do= code, Object[] args);
    public void 7jg=(int code, Object[] args);
    public void 7zg=(5Do= code);
    public void 7zg=(5Do= code, Object[] args);
    public void 7zg=(int code, Object[] args);
    public void 8Dg=(int lvl, 5Do= code);
    public void 8Dg=(int lvl, 5Do= code, Object[] args);
    public void 8Dg=(int lvl, int code, Object[] args);
}
internal enum 2jI=.3Do= : Enum {
    public int value__;
    public static 3Do= 3To=;
    public static 3Do= 3jo=;
    public static 3Do= 3zo=;
}
internal enum 2jI=.3jI= : Enum {
    public int value__;
    public static 3jI= 3zI=;
    public static 3jI= 4DI=;
    public static 3jI= 4TI=;
    public static 3jI= 4jI=;
    public static 3jI= 4zI=;
}
internal class 2jI=.3zw= : object {
    private static int CDw=;
    private static int Cjw=;
    private static int CTw=;
    private static int DDw=;
    private static int Czw=;
    private static int DTw=;
    private static int Djw=;
    internal static int zzw=;
    internal static int Dzw=;
    internal static int Ajw=;
    internal static int Azw=;
    internal static int BDw=;
    internal static Int32[] 4Dw=;
    internal static Int32[] 4Tw=;
    internal static Int32[] 4jw=;
    internal static Byte[] 4zw=;
    internal static int ATw=;
    internal static int 5Dw=;
    internal static Byte[] 5Tw=;
    internal static Byte[] 5jw=;
    internal static Int32[] 5zw=;
    internal static Int32[] 6Dw=;
    internal Int16[] 6Tw=;
    internal int 6jw=;
    internal zjw= 6zw=;
    private static 3zw=();
    internal static int 7Dw=(int dist);
    internal void 7Tw=(0zs= s);
    internal void 7jw=(0zs= s);
    internal static void 7zw=(Int16[] tree, int max_code, Int16[] bl_count);
    internal static int 8Dw=(int code, int len);
}
internal enum 2jI=.4Do= : Enum {
    public int value__;
    public static 4Do= 4To=;
    public static 4Do= 4jo=;
    public static 4Do= 4zo=;
}
internal class 2jI=.4jc= : object {
    private static int 4zc=;
    private static int 5Dc=;
    private static int 5Tc=;
    private 0jk= 4zY=;
    private jpeg_marker_parser_method 5jc=;
    private jpeg_marker_parser_method[] 5zc=;
    private int 6Dc=;
    private Int32[] 6Tc=;
    private bool 6jc=;
    private bool 6zc=;
    private int wDY=;
    private int 7Dc=;
    private rTo= 7Tc=;
    private int 7jc=;
    public 4jc=(0jk= cinfo);
    public void 7zc=();
    public TDs= 8Dc=();
    public bool 8Tc=();
    public bool 8jc=();
    public void 8zc=(int marker_code, jpeg_marker_parser_method routine);
    public void 9Dc=(int marker_code, int length_limit);
    public bool 9Tc=();
    public bool 9jc=();
    public int 9zc=();
    public int /Dc=();
    public void lis=(int count);
    private static bool /Tc=(0jk= cinfo);
    private static bool /jc=(0jk= cinfo);
    private static bool /zc=(0jk= cinfo);
    private static void ADg=(0jk= cinfo, Byte[] data, int datalen, int remaining);
    private static void ATg=(0jk= cinfo, Byte[] data, int datalen, int remaining);
    private bool Ajg=();
    private bool Azg=(bool is_prog);
    private bool BDg=();
    private bool BTg=();
    private bool Bjg=();
    private bool Bzg=();
    private bool CDg=();
}
internal class 2jI=.4jM= : TiffTagMethods {
    public virtual bool SetField(Tiff tif, TiffTag tag, FieldValue[] ap);
    public virtual FieldValue[] GetField(Tiff tif, TiffTag tag);
    public virtual void PrintDir(Tiff tif, Stream fd, TiffPrintFlags flags);
}
internal class 2jI=.4zM= : TiffCodec {
    public static int 5DM=;
    private static TiffFieldInfo[] 5TM=;
    private IjM= 5jM=;
    private int 5zM=;
    private int 6DM=;
    private TiffTagMethods ijM=;
    private TiffTagMethods izM=;
    private TiffTagMethods 6TM=;
    private bool 6jM=;
    private bool 6zM=;
    private dz0= 7DM=;
    public 4zM=(Tiff tif, Compression scheme, string name);
    private static 4zM=();
    public void 7TM=(TiffTagMethods tagMethods);
    public void 7jM=();
    public virtual bool SetupDecode();
    public virtual bool DecodeRow(Byte[] buffer, int offset, int count, short plane);
    public virtual bool DecodeStrip(Byte[] buffer, int offset, int count, short plane);
    public virtual bool DecodeTile(Byte[] buffer, int offset, int count, short plane);
    public virtual bool SetupEncode();
    public virtual bool EncodeRow(Byte[] buffer, int offset, int count, short plane);
    public virtual bool EncodeStrip(Byte[] buffer, int offset, int count, short plane);
    public virtual bool EncodeTile(Byte[] buffer, int offset, int count, short plane);
    public virtual bool 7zM=();
    public virtual bool 8DM=(Byte[] buffer, int offset, int count, short plane);
    public virtual bool 8TM=(Byte[] buffer, int offset, int count, short plane);
    public virtual bool 8jM=(Byte[] buffer, int offset, int count, short plane);
    public virtual bool 8zM=();
    public virtual bool 9DM=(Byte[] buffer, int offset, int count, short plane);
    public virtual bool 9TM=(Byte[] buffer, int offset, int count, short plane);
    public virtual bool 9jM=(Byte[] buffer, int offset, int count, short plane);
    public IjM= 9zM=();
    public void /DM=(IjM= value);
    public TiffTagMethods /TM=();
    private void /jM=(Byte[] buffer, int offset, int count);
    private void /zM=(Byte[] buffer, int offset, int count);
    private void ADQ=(Byte[] buffer, int offset, int count);
    private void ATQ=(Byte[] buffer, int offset, int count);
    private void AjQ=(Byte[] buffer, int offset, int count);
    private void AzQ=(Byte[] buffer, int offset, int count);
    private void BDQ=(Byte[] buffer, int offset, int count);
    private void BTQ=(Byte[] buffer, int offset, int count);
    private void BjQ=(Byte[] buffer, int offset, int count);
    private void BzQ=(Byte[] buffer, int offset, int count);
    private void CDQ=(Byte[] buffer, int offset, int count);
    private bool CTQ=(Byte[] buffer, int offset, int count, short plane);
    private bool CjQ=(Byte[] buffer, int offset, int count, short plane);
    private bool CzQ=(Byte[] buffer, int offset, int count, short plane);
    private bool DDQ=(Byte[] buffer, int offset, int count, short plane);
    private bool DTQ=();
    private bool DjQ=();
    private bool DzQ=();
}
internal enum 2jI=.5DI= : Enum {
    public int value__;
    public static 5DI= 5TI=;
    public static 5DI= 5jI=;
    public static 5DI= 5zI=;
}
internal enum 2jI=.5Do= : Enum {
    public int value__;
    public static 5Do= 5To=;
    public static 5Do= 5jo=;
    public static 5Do= 5zo=;
    public static 5Do= 6Do=;
    public static 5Do= 6To=;
    public static 5Do= 6jo=;
    public static 5Do= 6zo=;
    public static 5Do= 7Do=;
    public static 5Do= 7To=;
    public static 5Do= 7jo=;
    public static 5Do= 7zo=;
    public static 5Do= 8Do=;
    public static 5Do= 8To=;
    public static 5Do= 8jo=;
    public static 5Do= 8zo=;
    public static 5Do= 9Do=;
    public static 5Do= 9To=;
    public static 5Do= 9jo=;
    public static 5Do= 9zo=;
    public static 5Do= /Do=;
    public static 5Do= /To=;
    public static 5Do= /jo=;
    public static 5Do= /zo=;
    public static 5Do= ADs=;
    public static 5Do= ATs=;
    public static 5Do= Ajs=;
    public static 5Do= Azs=;
    public static 5Do= BDs=;
    public static 5Do= BTs=;
    public static 5Do= Bjs=;
    public static 5Do= Bzs=;
    public static 5Do= CDs=;
    public static 5Do= CTs=;
    public static 5Do= Cjs=;
    public static 5Do= Czs=;
    public static 5Do= DDs=;
    public static 5Do= DTs=;
    public static 5Do= Djs=;
    public static 5Do= Dzs=;
    public static 5Do= EDs=;
    public static 5Do= ETs=;
    public static 5Do= Ejs=;
    public static 5Do= Ezs=;
    public static 5Do= FDs=;
    public static 5Do= FTs=;
    public static 5Do= Fjs=;
    public static 5Do= Fzs=;
    public static 5Do= GDs=;
    public static 5Do= GTs=;
    public static 5Do= Gjs=;
    public static 5Do= Gzs=;
    public static 5Do= HDs=;
    public static 5Do= HTs=;
    public static 5Do= Hjs=;
    public static 5Do= Hzs=;
    public static 5Do= IDs=;
    public static 5Do= ITs=;
    public static 5Do= Ijs=;
    public static 5Do= Izs=;
    public static 5Do= JDs=;
    public static 5Do= JTs=;
    public static 5Do= Jjs=;
    public static 5Do= Jzs=;
    public static 5Do= KDs=;
    public static 5Do= KTs=;
    public static 5Do= Kjs=;
    public static 5Do= Kzs=;
    public static 5Do= LDs=;
    public static 5Do= LTs=;
    public static 5Do= Ljs=;
    public static 5Do= Lzs=;
    public static 5Do= MDs=;
    public static 5Do= MTs=;
    public static 5Do= Mjs=;
    public static 5Do= Mzs=;
    public static 5Do= NDs=;
    public static 5Do= NTs=;
    public static 5Do= Njs=;
    public static 5Do= Nzs=;
    public static 5Do= ODs=;
    public static 5Do= OTs=;
    public static 5Do= Ojs=;
    public static 5Do= Ozs=;
    public static 5Do= PDs=;
    public static 5Do= PTs=;
    public static 5Do= Pjs=;
    public static 5Do= Pzs=;
    public static 5Do= QDs=;
    public static 5Do= QTs=;
    public static 5Do= Qjs=;
    public static 5Do= Qzs=;
    public static 5Do= RDs=;
    public static 5Do= RTs=;
    public static 5Do= Rjs=;
    public static 5Do= Rzs=;
    public static 5Do= SDs=;
    public static 5Do= STs=;
    public static 5Do= Sjs=;
    public static 5Do= Szs=;
}
[FlagsAttribute]
internal enum 2jI=.6DI= : Enum {
    public int value__;
    public static 6DI= 6TI=;
    public static 6DI= 6jI=;
    public static 6DI= 6zI=;
    public static 6DI= 7DI=;
    public static 6DI= 7TI=;
    public static 6DI= 7jI=;
}
[FlagsAttribute]
internal enum 2jI=.7zI= : Enum {
    public int value__;
    public static 7zI= 8DI=;
    public static 7zI= 8TI=;
    public static 7zI= 8jI=;
}
internal class 2jI=.8Tg= : object {
    private int 8jg=;
    private int HTg=;
    private int 8zg=;
    private int 9Dg=;
    private int 9Tg=;
    private int 9jg=;
    private int 9zg=;
    private int /Dg=;
    internal int /Tg=;
    internal int /jg=;
    internal int /zg=;
    internal int ADk=;
    internal bool ATk=;
    internal int Ajk=;
    internal int Azk=;
    internal int BDk=;
    internal int BTk=;
    internal int Bjk=;
    internal int Bzk=;
    internal zjo= CDk=;
    public int Czk= { get; public set; }
    public int Djk= { get; public set; }
    public int ETk= { get; public set; }
    public int FDk= { get; public set; }
    public int Fzk= { get; public set; }
    public int Gjk= { get; public set; }
    public int HTk= { get; public set; }
    public int IDk= { get; public set; }
    public int Ijk= { get; }
    internal void Izk=(8Tg= ci);
    public int CTk=();
    public void Cjk=(int value);
    public int DDk=();
    public void DTk=(int value);
    public int Dzk=();
    public void EDk=(int value);
    public int Ejk=();
    public void Ezk=(int value);
    public int FTk=();
    public void Fjk=(int value);
    public int GDk=();
    public void GTk=(int value);
    public int Gzk=();
    public void HDk=(int value);
    public int Hjk=();
    public void Hzk=(int value);
    public int ITk=();
    internal static 8Tg=[] JDk=(int length);
}
internal class 2jI=.8Tw= : object {
    private static string 8jw=;
    public static int 8zw=;
    public static int 9Dw=;
    public static int 9Tw=;
    public static int 1Ts=;
    public static int 4js=;
    public static int 4zs=;
    public static int 5Ds=;
    public static int 5Ts=;
    public static int 5js=;
    public static int 5zs=;
    public static int 6Ds=;
    public static int 6Ts=;
    public static int 6js=;
    public static int 6zs=;
    public static int 7Ds=;
    public static int 7Ts=;
    public static int 7js=;
    public static int 7zs=;
    public static int 8Ds=;
    public static int 8Ts=;
    public static int 8js=;
    public static string 9jw=();
}
internal enum 2jI=.8zI= : Enum {
    public int value__;
    public static 8zI= 9DI=;
    public static 8zI= 9TI=;
}
internal class 2jI=.9DY= : object {
    private static int 1zY=;
    private static int lDY=;
    private tD0= 9TY=;
    private 0jk= 4zY=;
    private Int32[] 9jY=;
    private Int32[] 9zY=;
    private Int32[] /DY=;
    private Int32[] /TY=;
    private Int32[] /jY=;
    public 9DY=(0jk= cinfo);
    public void 6zY=(qDY=[] input_buf, Int32[] perComponentOffsets, int input_row, Byte[][] output_buf, int output_row, int num_rows);
    private void /zY=();
    private void ADc=(qDY=[] input_buf, int input_row, Byte[][] output_buf, int output_row, int num_rows);
    private void ATc=(qDY=[] input_buf, int input_row, Byte[][] output_buf, int output_row, int num_rows);
    private void Ajc=(qDY=[] input_buf, int input_row, Byte[][] output_buf, int output_row, int num_rows);
    private void 8jY=(qDY=[] input_buf, int input_row, Byte[][] output_buf, int output_row, int num_rows);
    private void 8zY=(qDY=[] input_buf, int input_row, Byte[][] output_buf, int output_row, int num_rows);
    private static int 7jY=(double x);
}
internal enum 2jI=.9jI= : Enum {
    public int value__;
    public static 9jI= 9zI=;
    public static 9jI= /DI=;
    public static 9jI= /TI=;
    public static 9jI= /jI=;
    public static 9jI= /zI=;
}
internal class 2jI=.9zw= : object {
    private static int 1js=;
    private static int /Dw=;
    private static int 5Ts=;
    private static int 5js=;
    private static int 5zs=;
    private static int 6Ds=;
    private static int 6Ts=;
    private static int 1Ds=;
    private static int 6js=;
    private static int 6zs=;
    private static int 7Ds=;
    private static int 7Ts=;
    private static int 7js=;
    private static int 7zs=;
    private static int 8Ds=;
    private static int 8Ts=;
    private static int 8js=;
    public Byte[] /Tw=;
    public int /jw=;
    public int /zw=;
    public long AD0=;
    public Byte[] AT0=;
    public int Aj0=;
    public int Az0=;
    public long BD0=;
    public string BT0=;
    internal 0zs= Bj0=;
    internal pjw= Bz0=;
    internal int Fzw=;
    public long CD0=;
    internal zzs= CT0=;
    public int uzw=();
    public int uTw=();
    public int uzw=(int w);
    public int vDw=(int f);
    public int ujw=();
    public int vjw=();
    public int vTw=(Byte[] dictionary, int dictLength);
    public int ZDw=(int level);
    public int ZDw=(int level, int bits);
    public int ajw=(int flush);
    public int Zzw=();
    public int aDw=(int level, int strategy);
    public int aTw=(Byte[] dictionary, int dictLength);
    internal void Cj0=();
    internal int Cz0=(Byte[] buf, int start, int size);
    public void iTw=();
}
[FlagsAttribute]
internal enum 2jI=.ADM= : Enum {
    public int value__;
    public static ADM= ATM=;
    public static ADM= AjM=;
    public static ADM= AzM=;
    public static ADM= BDM=;
}
internal class 2jI=.aTo= : object {
    internal int ajo=;
    internal Object[] azo=;
    internal int bDo=;
    internal int bTo=;
    public int cDo= { get; public set; }
    public int cjo= { get; }
    public int bjo=();
    public void bzo=(int value);
    public int cTo=();
    public virtual void SjU=();
    public virtual void czo=(int msg_level);
    public virtual void SzU=();
    public virtual string dDo=();
    public virtual void dTo=();
    protected virtual string djo=(int code);
}
internal class 2jI=.azc= : object {
    private zT0= bDc=;
    private 0jk= 4zY=;
    private 0Do=<byte> Szc=;
    private Byte[][] ojM=;
    private int bTc=;
    private int bjc=;
    private int bzc=;
    public azc=(0jk= cinfo, bool need_full_buffer);
    public void uzY=(JDg= pass_mode);
    public void cDc=(qDY=[] input_buf, Int32& in_row_group_ctr, int in_row_groups_avail, Byte[][] output_buf, Int32& out_row_ctr, int out_rows_avail);
    private void cTc=(qDY=[] input_buf, Int32& in_row_group_ctr, int in_row_groups_avail, Byte[][] output_buf, Int32& out_row_ctr, int out_rows_avail);
    private void cjc=(qDY=[] input_buf, Int32& in_row_group_ctr, int in_row_groups_avail, Int32& out_row_ctr);
    private void czc=(Byte[][] output_buf, Int32& out_row_ctr, int out_rows_avail);
}
internal interface 2jI=.Azc= {
    public abstract virtual void uzY=(bool is_pre_scan);
    public abstract virtual void BDc=(Byte[][] input_buf, int in_row, Byte[][] output_buf, int out_row, int num_rows);
    public abstract virtual void xDY=();
    public abstract virtual void BTc=();
}
internal class 2jI=.azw= : object {
    private static int bDw=;
    private static Int32[] bTw=;
    internal static Int32[] bjw=;
    private static int 6js=;
    private static int 6zs=;
    private static int 7Ds=;
    private static int 7Ts=;
    private static int 7js=;
    private static int 7zs=;
    private static int 8Ds=;
    private static int 8Ts=;
    private static int 8js=;
    private static int bzw=;
    private static int cDw=;
    private static int 2Ds=;
    private static int cTw=;
    private static int cjw=;
    private static int czw=;
    private static int dDw=;
    private static int dTw=;
    private static int djw=;
    private static int dzw=;
    internal int zBg=;
    internal int eDw=;
    internal int eTw=;
    internal int AB0=;
    internal Int32[] ejw=;
    internal Int32[] ezw=;
    internal Int32[] fDw=;
    internal jTw= fTw=;
    internal int fjw=;
    internal int fzw=;
    internal int gDw=;
    internal Int32[] gTw=;
    internal Byte[] HTw=;
    internal int gjw=;
    internal int gzw=;
    internal int hDw=;
    internal object hTw=;
    internal long hjw=;
    internal azw=(9zw= z, object checkfn, int w);
    private static azw=();
    internal void hzw=(9zw= z, Int64[] c);
    internal int iDw=(9zw= z, int r);
    internal void iTw=(9zw= z);
    internal void ijw=(Byte[] d, int start, int n);
    internal int izw=();
    internal int jDw=(9zw= z, int r);
}
internal class 2jI=.Bjc= : object {
    private JTk= 4zY=;
    private bool Bzc=;
    private bool CDc=;
    private uj0= CTc=;
    private int Cjc=;
    private int Czc=;
    private int DDc=;
    public Bjc=(JTk= cinfo, bool transcode_only);
    public void DTc=();
    public void Djc=();
    public void xDY=();
    public bool Dzc=();
    public bool EDc=();
    private void ETc=();
    private bool Ejc=();
    private void Ezc=();
    private void FDc=();
    private void FTc=();
}
internal enum 2jI=.BTM= : Enum {
    public int value__;
    public static BTM= BjM=;
    public static BTM= BzM=;
}
internal class 2jI=.BzU= : TiffCodec {
    public static int CDU=;
    public static int ZjM=;
    public static int ZzM=;
    public static int aDM=;
    public static int aTM=;
    internal JTk= CTU=;
    internal 0jk= CjU=;
    internal 2zg= CzU=;
    internal int DDU=;
    internal int DTU=;
    internal Byte[] DjU=;
    internal int DzU=;
    internal int EDU=;
    internal CDM= ETU=;
    internal DjM= EjU=;
    internal bool EzU=;
    internal int cDM=;
    internal string cTM=;
    internal int cjM=;
    internal string czM=;
    private static TiffFieldInfo[] FDU=;
    private bool FTU=;
    private bool FjU=;
    private TiffTagMethods izM=;
    private TiffTagMethods ijM=;
    private bool FzU=;
    internal aTo= GDU=;
    private FDM= GTU=;
    private int GjU=;
    private Byte[][][] GzU=;
    private int HDU=;
    private int HTU=;
    public bool CanEncode { get; }
    public bool CanDecode { get; }
    public BzU=(Tiff tif, Compression scheme, string name);
    private static BzU=();
    private void sDM=();
    public virtual bool Init();
    public virtual bool get_CanEncode();
    public virtual bool get_CanDecode();
    public virtual bool SetupDecode();
    public virtual bool PreDecode(short plane);
    public virtual bool DecodeRow(Byte[] buffer, int offset, int count, short plane);
    public virtual bool DecodeStrip(Byte[] buffer, int offset, int count, short plane);
    public virtual bool DecodeTile(Byte[] buffer, int offset, int count, short plane);
    public virtual bool SetupEncode();
    public virtual bool PreEncode(short plane);
    public virtual bool PostEncode();
    public virtual bool EncodeRow(Byte[] buffer, int offset, int count, short plane);
    public virtual bool EncodeStrip(Byte[] buffer, int offset, int count, short plane);
    public virtual bool EncodeTile(Byte[] buffer, int offset, int count, short plane);
    public virtual void Cleanup();
    public virtual int DefStripSize(int size);
    public virtual void DefTileSize(Int32& width, Int32& height);
    public bool HjU=(bool force_encode, bool force_decode);
    public Tiff HzU=();
    public void IDU=();
    private bool ITU=(short s);
    private bool IjU=();
    private bool IzU=();
    private void JDU=();
    private bool JTU=(short s);
    private bool JjU=();
    private bool JzU=();
    private int KDU=(Byte[][] scanlines, int max_lines);
    private bool KTU=(Byte[] buffer, int offset, int count, short plane);
    private bool KjU=(Byte[] buffer, int offset, int count, short plane);
    private bool KzU=(Byte[] buffer, int offset, int count, short plane);
    private bool LDU=(Byte[] buffer, int offset, int count, short plane);
    private int LTU=(int s);
    private void LjU=(Int32& tw, Int32& th);
    private bool LzU=();
    private bool MDU=();
    private bool MTU=();
    private bool MjU=(1To= colorspace);
    private bool MzU=(int quality, bool force_baseline);
    private bool NDU=(bool suppress);
    private bool NTU=(bool write_all_tables);
    private int NjU=(Byte[][] scanlines, int num_lines);
    private int NzU=(Byte[][][] data, int num_lines);
    private bool ODU=();
    private bool OTU=();
    private TDs= OjU=(bool require_image);
    private bool OzU=();
    private int PDU=(Byte[][][] data, int max_lines);
    private bool PTU=();
    private bool PjU=();
    private bool PzU=();
    private static Byte[][] QDU=(int samplesperrow, int numrows);
    private bool QTU=(8Tg=[] comp_info, int num_components);
    private void QjU=(int tblno);
    private void QzU=(int tblno);
    private void RDU=();
    private bool RTU=();
}
internal enum 2jI=.CDM= : Enum {
    public int value__;
    public static CDM= CTM=;
    public static CDM= CjM=;
}
internal class 2jI=.cjg= : object {
    private JDg= czg=;
    private JTk= 4zY=;
    private int dDg=;
    private int dTg=;
    private int SDc=;
    private int STc=;
    private ujg=[][] Sjc=;
    private 0Do=[] Szc=;
    public cjg=(JTk= cinfo, bool need_full_buffer);
    public virtual void uzY=(JDg= pass_mode);
    public virtual bool Fzc=(Byte[][][] input_buf);
    private bool djg=(Byte[][][] input_buf);
    private bool dzg=(Byte[][][] input_buf);
    private bool eDg=();
    private void WDc=();
}
internal class 2jI=.CTg= : object {
    private JTk= 4zY=;
    private int Cjg=;
    public CTg=(JTk= cinfo);
    public void Czg=();
    public void DDg=();
    public void DTg=();
    public void Djg=();
    public void Dzg=();
    public void EDg=(int marker, int datalen);
    public void ETg=(byte val);
    private void Ejg=();
    private void Ezg=(dzo= code);
    private void FDg=();
    private void FTg=();
    private void Fjg=(int index, bool is_ac);
    private int Fzg=(int index);
    private void GDg=();
    private void GTg=(dzo= mark);
    private void Gjg=(int value);
    private void yzY=(int val);
}
internal enum 2jI=.CzM= : Enum {
    public int value__;
    public static CzM= DDM=;
    public static CzM= DTM=;
}
[FlagsAttribute]
internal enum 2jI=.czY= : Enum {
    public int value__;
    public static czY= 9DI=;
    public static czY= 9TI=;
    public static czY= dDY=;
    public static czY= dTY=;
    public static czY= djY=;
    public static czY= dzY=;
    public static czY= eDY=;
    public static czY= eTY=;
    public static czY= ejY=;
    public static czY= ezY=;
    public static czY= fDY=;
    public static czY= fTY=;
    public static czY= fjY=;
    public static czY= fzY=;
    public static czY= gDY=;
    public static czY= gTY=;
    public static czY= gjY=;
    public static czY= gzY=;
    public static czY= hDY=;
}
internal class 2jI=.DD0= : IOException {
    public DD0=(string s);
}
internal abstract class 2jI=.dDc= : object {
    private static Int32[] dTc=;
    private static Int32[] djc=;
    protected static int dzc=;
    protected static int eDc=;
    protected 0jk= 4zY=;
    protected bool eTc=;
    private static dDc=();
    public abstract virtual void uzY=();
    public abstract virtual bool vDY=(ujg=[] MCU_data);
    protected static int ejc=(int x, int s);
    protected void ezc=(ozY= bitstate, Int32& get_buffer, Int32& bits_left, pjY=& br_state);
    protected static void fDc=(ozY=& bitstate, int get_buffer, int bits_left);
    protected void fTc=(bool isDC, int tblno, qzY=& dtbl);
    protected static bool fjc=(pjY=& state, int nbits, Int32& get_buffer, Int32& bits_left);
    protected static int fzc=(int nbits, int get_buffer, Int32& bits_left);
    protected static int gDc=(int nbits, int get_buffer, int bits_left);
    protected static void gTc=(int nbits, Int32& bits_left);
    protected static bool gjc=(pjY=& state, int get_buffer, int bits_left, int nbits);
    protected static bool gzc=(Int32& result, pjY=& state, qzY= htbl, Int32& get_buffer, Int32& bits_left);
    protected static int hDc=(pjY=& state, int get_buffer, int bits_left, qzY= htbl, int min_bits);
}
[FlagsAttribute]
internal enum 2jI=.DjM= : Enum {
    public int value__;
    public static DjM= DzM=;
    public static DjM= EDM=;
    public static DjM= ETM=;
}
internal enum 2jI=.dzo= : Enum {
    public int value__;
    public static dzo= eDo=;
    public static dzo= eTo=;
    public static dzo= ejo=;
    public static dzo= ezo=;
    public static dzo= fDo=;
    public static dzo= fTo=;
    public static dzo= fjo=;
    public static dzo= fzo=;
    public static dzo= gDo=;
    public static dzo= gTo=;
    public static dzo= gjo=;
    public static dzo= gzo=;
    public static dzo= hDo=;
    public static dzo= hTo=;
    public static dzo= hjo=;
    public static dzo= hzo=;
    public static dzo= iDo=;
    public static dzo= iTo=;
    public static dzo= ijo=;
    public static dzo= izo=;
    public static dzo= jDo=;
    public static dzo= jTo=;
    public static dzo= jjo=;
    public static dzo= jzo=;
    public static dzo= kDo=;
    public static dzo= kTo=;
    public static dzo= kjo=;
    public static dzo= kzo=;
    public static dzo= lDo=;
    public static dzo= lTo=;
    public static dzo= ljo=;
    public static dzo= lzo=;
    public static dzo= mDo=;
    public static dzo= mTo=;
    public static dzo= mjo=;
    public static dzo= mzo=;
    public static dzo= nDo=;
    public static dzo= nTo=;
    public static dzo= njo=;
    public static dzo= nzo=;
    public static dzo= oDo=;
    public static dzo= oTo=;
    public static dzo= ojo=;
    public static dzo= ozo=;
    public static dzo= pDo=;
    public static dzo= pTo=;
    public static dzo= pjo=;
    public static dzo= pzo=;
    public static dzo= qDo=;
    public static dzo= qTo=;
    public static dzo= qjo=;
    public static dzo= qzo=;
    public static dzo= rDo=;
}
internal class 2jI=.EDQ= : TiffTagMethods {
    public virtual bool SetField(Tiff tif, TiffTag tag, FieldValue[] ap);
    public virtual FieldValue[] GetField(Tiff tif, TiffTag tag);
    public virtual void PrintDir(Tiff tif, Stream fd, TiffPrintFlags flags);
}
internal enum 2jI=.EjM= : Enum {
    public int value__;
    public static EjM= EzM=;
    public static EjM= 8DI=;
    public static EjM= 8TI=;
}
internal class 2jI=.EjY= : TiffTagMethods {
    public virtual bool SetField(Tiff tif, TiffTag tag, FieldValue[] ap);
    public virtual FieldValue[] GetField(Tiff tif, TiffTag tag);
    public virtual void PrintDir(Tiff tif, Stream fd, TiffPrintFlags flags);
}
internal class 2jI=.eTg= : Yzo= {
    private static int ejg=;
    private JTk= 4zY=;
    private Stream ezg=;
    private Byte[] ojM=;
    public eTg=(JTk= cinfo, Stream alreadyOpenFile);
    public virtual void TjU=();
    public virtual bool TzU=();
    public virtual void UDU=();
    private void fDg=(int dataCount);
}
internal class 2jI=.ETQ= : 4zM= {
    public static int EjQ=;
    public static int EzQ=;
    public 9zw= FDQ=;
    public int FTQ=;
    public int FjQ=;
    private static TiffFieldInfo[] FzQ=;
    private TiffTagMethods izM=;
    public bool CanEncode { get; }
    public bool CanDecode { get; }
    public ETQ=(Tiff tif, Compression scheme, string name);
    private static ETQ=();
    public virtual bool Init();
    public virtual bool get_CanEncode();
    public virtual bool get_CanDecode();
    public virtual bool PreDecode(short plane);
    public virtual bool PreEncode(short plane);
    public virtual bool PostEncode();
    public virtual void Cleanup();
    public virtual bool 7zM=();
    public virtual bool 8DM=(Byte[] buffer, int offset, int count, short plane);
    public virtual bool 8TM=(Byte[] buffer, int offset, int count, short plane);
    public virtual bool 8jM=(Byte[] buffer, int offset, int count, short plane);
    public virtual bool 8zM=();
    public virtual bool 9DM=(Byte[] buffer, int offset, int count, short plane);
    public virtual bool 9TM=(Byte[] buffer, int offset, int count, short plane);
    public virtual bool 9jM=(Byte[] buffer, int offset, int count, short plane);
    private void GDQ=();
    private bool GTQ=(Byte[] buffer, int offset, int count, short plane);
    private bool GjQ=(Byte[] buffer, int offset, int count, short plane);
    private bool GzQ=();
    private bool HDQ=(short s);
    private bool HTQ=(short s);
    private bool HjQ=();
    private bool HzQ=();
}
internal class 2jI=.EzY= : aTo= {
    private ijU= STU=;
    public EzY=(ijU= sp);
    public virtual void SjU=();
    public virtual void SzU=();
}
internal enum 2jI=.FDM= : Enum {
    public int value__;
    public static FDM= FTM=;
    public static FDM= FjM=;
    public static FDM= CjM=;
    public static FDM= FzM=;
    public static FDM= 8jI=;
    public static FDM= GDM=;
    public static FDM= GTM=;
    public static FDM= GjM=;
    public static FDM= GzM=;
    public static FDM= HDM=;
    public static FDM= HTM=;
    public static FDM= HjM=;
}
internal class 2jI=.FDY= : yDo= {
    protected ijU= STU=;
    public FDY=(ijU= sp);
    public virtual void UzU=();
    public virtual bool VDU=();
    public virtual void FTY=(int num_bytes);
    public virtual bool FjY=(0jk= cinfo, int desired);
    public virtual void FzY=();
}
internal interface 2jI=.Fjc= {
    public abstract virtual void uzY=(JDg= pass_mode);
    public abstract virtual bool Fzc=(Byte[][][] input_buf);
}
internal class 2jI=.fTg= : Ijg= {
    private static int 1zY=;
    private static int lDY=;
    private 0jk= 4zY=;
    private bool fjg=;
    private Int32[] 9zY=;
    private Int32[] /DY=;
    private Int32[] /TY=;
    private Int32[] /jY=;
    private Byte[] fzg=;
    private bool gDg=;
    private int gTg=;
    private int IDc=;
    public fTg=(0jk= cinfo);
    public virtual void uzY=();
    public virtual void Izg=(qDY=[] input_buf, Int32& in_row_group_ctr, int in_row_groups_avail, Byte[][] output_buf, Int32& out_row_ctr, int out_rows_avail);
    private void gjg=(qDY=[] input_buf, Int32& in_row_group_ctr, Byte[][] output_buf, Int32& out_row_ctr);
    private void gzg=(qDY=[] input_buf, Int32& in_row_group_ctr, Byte[][] output_buf, Int32& out_row_ctr, int out_rows_avail);
    private void hDg=(qDY=[] input_buf, int in_row_group_ctr, Byte[][] output_buf, int outRow);
    private void hTg=(qDY=[] input_buf, int in_row_group_ctr, Byte[][] output_buf);
    private void /zY=();
    private static int 7jY=(double x);
}
internal class 2jI=.GDc= : object {
    private JTk= 4zY=;
    private int GTc=;
    private int Gjc=;
    private bool Gzc=;
    private Byte[][][] ojM=;
    public GDc=(JTk= cinfo);
    public void uzY=(JDg= pass_mode);
    public void HDc=(Byte[][] input_buf, Int32& in_row_ctr, int in_rows_avail);
}
internal class 2jI=.GDY= : TiffCodec {
    private int GTY=;
    public bool CanEncode { get; }
    public bool CanDecode { get; }
    public GDY=(Tiff tif, Compression scheme, string name);
    public virtual bool Init();
    public virtual bool get_CanEncode();
    public virtual bool get_CanDecode();
    public virtual bool DecodeRow(Byte[] buffer, int offset, int count, short plane);
    public virtual bool DecodeStrip(Byte[] buffer, int offset, int count, short plane);
    public virtual bool DecodeTile(Byte[] buffer, int offset, int count, short plane);
    public virtual bool PreEncode(short plane);
    public virtual bool EncodeRow(Byte[] buffer, int offset, int count, short plane);
    public virtual bool EncodeStrip(Byte[] buffer, int offset, int count, short plane);
    public virtual bool EncodeTile(Byte[] buffer, int offset, int count, short plane);
    private bool GjY=(short s);
    private bool GzY=(Byte[] buf, int offset, int cc, short s);
    private bool HDY=(Byte[] buffer, int offset, int count, short plane);
    private bool HTY=(Byte[] buffer, int offset, int count, short plane);
}
internal class 2jI=.Gzg= : object {
    public int HDg=;
    public Int32[] HTg=;
    public int Hjg=;
    public int Hzg=;
    public int IDg=;
    public int ITg=;
}
internal class 2jI=.hjg= : yDo= {
    private static int hzg=;
    private 0jk= 4zY=;
    private Stream iDg=;
    private Byte[] ojM=;
    private bool iTg=;
    public hjg=(0jk= cinfo);
    public void ijg=(Stream infile);
    public virtual void UzU=();
    public virtual bool VDU=();
}
internal class 2jI=.HjY= : object {
    private sealed virtual override int System.Collections.IComparer.Compare(object x, object y);
}
internal abstract class 2jI=.hTc= : object {
    protected static int hjc=;
    private static int hzc=;
    protected JTk= 4zY=;
    public abstract virtual void uzY=(bool gather_statistics);
    public abstract virtual bool wzY=(ujg=[][] MCU_data);
    public abstract virtual void xDY=();
    protected void iDc=(bool isDC, int tblno, c_derived_tbl& dtbl);
    protected void iTc=(uzg= htbl, Int64[] freq);
}
internal class 2jI=.HTc= : object {
    private JTk= 4zY=;
    private Byte[][][] Hjc=;
    private int Hzc=;
    private int IDc=;
    private int ITc=;
    private int Ijc=;
    private int Izc=;
    public HTc=(JTk= cinfo);
    public void uzY=(JDg= pass_mode);
    public void JDc=(Byte[][] input_buf, Int32& in_row_ctr, int in_rows_avail, Byte[][][] output_buf, Int32& out_row_group_ctr, int out_row_groups_avail);
    private void JTc=();
    private void Jjc=(Byte[][] input_buf, Int32& in_row_ctr, int in_rows_avail, Byte[][][] output_buf, Int32& out_row_group_ctr, int out_row_groups_avail);
    private void Jzc=(Byte[][] input_buf, Int32& in_row_ctr, int in_rows_avail, Byte[][][] output_buf, Int32& out_row_group_ctr, int out_row_groups_avail);
    private static void KDc=(Byte[][] image_data, int rowsOffset, int num_cols, int input_rows, int output_rows);
}
internal class 2jI=.hTY= : ValueType {
    public static int hjY=;
    public static int hzY=;
    public static int iDY=;
    public short iTY=;
    public short ijY=;
    public ulong izY=;
    public short jDY=;
    public short jTY=;
    public static int ZDY=(bool isBigTiff);
}
internal enum 2jI=.HzM= : Enum {
    public int value__;
    public static HzM= ATM=;
    public static HzM= IDM=;
    public static HzM= ITM=;
}
internal class 2jI=.HzY= : object {
    public static int IDY=;
    private int ITY=;
    private float IjY=;
    private float IzY=;
    private float JDY=;
    private float JTY=;
    private float JjY=;
    private float JzY=;
    private ZTY= KDY=;
    private Single[] KTY=;
    private Single[] KjY=;
    private Single[] KzY=;
    public void xR4=(ZTY= refDisplay, Single[] refWhite);
    public void LDY=(int l, int a, int b, Single& X, Single& Y, Single& Z);
    public void LTY=(float X, float Y, float Z, Int32& r, Int32& g, Int32& b);
    private static int LjY=(float R);
}
internal class 2jI=.IDQ= : TiffTagMethods {
    public virtual bool SetField(Tiff tif, TiffTag tag, FieldValue[] ap);
    public virtual FieldValue[] GetField(Tiff tif, TiffTag tag);
}
internal class 2jI=.ijc= : object {
    private static int izc=;
    private static int jDc=;
    private static int jTc=;
    private static int jjc=;
    private static int jzc=;
    private static int kDc=;
    private static int kTc=;
    private static int kjc=;
    private static int kzc=;
    private static int lDc=;
    private static int lTc=;
    private static int ljc=;
    private static int lzc=;
    private static int mDc=;
    private static int mTc=;
    private static int mjc=;
    private static int mzc=;
    private static int nDc=;
    private static int nTc=;
    private static int njc=;
    private static Int16[] nzc=;
    private static Double[] oDc=;
    private JTk= 4zY=;
    private bool oTc=;
    private bool ojc=;
    private Int32[][] ozc=;
    private Single[][] pDc=;
    public ijc=(JTk= cinfo);
    private static ijc=();
    public virtual void uzY=();
    public virtual void pTc=(int quant_tbl_no, Byte[][] sample_data, ujg=[] coef_blocks, int start_row, int start_col, int num_blocks);
    private void pjc=(int quant_tbl_no, Byte[][] sample_data, ujg=[] coef_blocks, int start_row, int start_col, int num_blocks);
    private void pzc=(int quant_tbl_no, Byte[][] sample_data, ujg=[] coef_blocks, int start_row, int start_col, int num_blocks);
    private static void qDc=(Single[] data);
    private static void qTc=(Int32[] data);
    private static void qjc=(Int32[] data);
    private static int qzc=(int var, int c);
}
internal abstract class 2jI=.Ijg= : object {
    protected bool NDc=;
    public abstract virtual void uzY=();
    public abstract virtual void Izg=(qDY=[] input_buf, Int32& in_row_group_ctr, int in_row_groups_avail, Byte[][] output_buf, Int32& out_row_ctr, int out_rows_avail);
    public bool Njc=();
}
internal enum 2jI=.IjM= : Enum {
    public int value__;
    public static IjM= DzM=;
    public static IjM= IzM=;
    public static IjM= JDM=;
}
internal class 2jI=.ijU= : TiffCodec {
    internal static int izU=;
    internal static int jDU=;
    internal static int jTU=;
    internal static int jjU=;
    internal static int jzU=;
    internal static int kDU=;
    internal static int kTU=;
    internal static int kjU=;
    private static int kzU=;
    private static TiffFieldInfo[] lDU=;
    internal UInt32 lTU=;
    internal UInt32 ljU=;
    internal byte lzU=;
    internal bool mDU=;
    internal bool mTU=;
    internal byte mjU=;
    internal byte mzU=;
    internal byte nDU=;
    internal byte nTU=;
    internal byte njU=;
    internal UInt32[] nzU=;
    internal UInt32[] oDU=;
    internal UInt32[] oTU=;
    internal ushort ojU=;
    internal 0jk= ozU=;
    private TiffTagMethods izM=;
    private TiffTagMethods ijM=;
    private UInt32 pDU=;
    private UInt32 pTU=;
    private UInt32 pjU=;
    private UInt32 pzU=;
    private UInt32 qDU=;
    private UInt32 qTU=;
    private byte qjU=;
    private byte qzU=;
    private byte rDU=;
    private bool rTU=;
    private bool rjU=;
    private Byte[][] rzU=;
    private Byte[][] sDU=;
    private Byte[][] sTU=;
    private byte sjU=;
    private bool szU=;
    private byte tDU=;
    private UInt32 tTU=;
    private UInt32 tjU=;
    private Byte[] tzU=;
    private Byte[] uDU=;
    private Byte[] uTU=;
    private Byte[] ujU=;
    private Byte[] uzU=;
    private qj0=[] vDU=;
    private bool vTU=;
    private bool vjU=;
    private short vzU=;
    private UInt32 wDU=;
    private bool wTU=;
    private byte wjU=;
    private aTo= wzU=;
    private yDo= xDU=;
    private bool xTU=;
    private UInt32 xjU=;
    private UInt32 xzU=;
    private UInt32 yDU=;
    private UInt32 yTU=;
    private Byte[][] yjU=;
    private Byte[][] yzU=;
    private Byte[][] zDU=;
    private Byte[][][] zTU=;
    private UInt32 zjU=;
    private UInt32 zzU=;
    private UInt32 0DU=;
    private UInt32 0TU=;
    private kT0= 0jU=;
    private UInt32 0zU=;
    private UInt32 1DU=;
    private UInt32 1TU=;
    private bool 1jU=;
    private UInt32 1zU=;
    private ushort 2DU=;
    private int 2TU=;
    private Byte[] 2jU=;
    private lj0= 2zU=;
    private Byte[] 3DU=;
    private Byte[] 3TU=;
    private bool 3jU=;
    public bool CanEncode { get; }
    public bool CanDecode { get; }
    public ijU=(Tiff tif, Compression scheme, string name);
    private static ijU=();
    private void sDM=();
    public virtual bool Init();
    public virtual bool get_CanEncode();
    public virtual bool get_CanDecode();
    public Tiff HzU=();
    public virtual bool SetupDecode();
    public virtual bool PreDecode(short plane);
    public virtual bool DecodeRow(Byte[] buffer, int offset, int count, short plane);
    public virtual bool DecodeStrip(Byte[] buffer, int offset, int count, short plane);
    public virtual bool DecodeTile(Byte[] buffer, int offset, int count, short plane);
    public virtual bool SetupEncode();
    public virtual bool PreEncode(short plane);
    public virtual bool PostEncode();
    public virtual bool EncodeRow(Byte[] buffer, int offset, int count, short plane);
    public virtual bool EncodeStrip(Byte[] buffer, int offset, int count, short plane);
    public virtual bool EncodeTile(Byte[] buffer, int offset, int count, short plane);
    public virtual void Cleanup();
    internal void 3zU=(bool force);
    private bool 4DU=();
    private bool 4TU=(short s);
    private bool 4jU=(Byte[] buf, int offset, int cc, short s);
    private bool 4zU=();
    private void 5DU=();
    private bool 5TU=();
    private bool 5jU=();
    private bool 5zU=(Byte[] buf, int offset, int cc);
    private bool 6DU=(Byte[] buf, int offset, int cc);
    public void 6TU=();
    private bool 6jU=();
    private bool 6zU=(short s);
    private bool 7DU=();
    private void 7TU=();
    private bool 7jU=();
    private bool 7zU=();
    private bool 8DU=();
    private bool 8TU=();
    private bool 8jU=(byte marker_id);
    private bool 8zU=();
    private bool 9DU=();
    private bool 9TU=();
    private bool 9jU=();
    private bool 9zU=();
    private bool /DU=(Byte& b);
    public bool /TU=(Byte& b);
    private void /jU=();
    private bool /zU=(UInt16& word);
    public bool ADY=(ushort len, Byte[] mem, int offset);
    private void ATY=(ushort len);
    internal bool AjY=(Byte[]& mem, UInt32& len);
    private void AzY=(Byte[]& mem, UInt32& len);
    private void BDY=(byte table_index, Byte[]& mem, UInt32& len);
    private void BTY=(byte table_index, Byte[]& mem, UInt32& len);
    private void BjY=(byte table_index, Byte[]& mem, UInt32& len);
    private void BzY=(Byte[]& mem, UInt32& len);
    private void CDY=(Byte[]& mem, UInt32& len);
    private void CTY=(Byte[]& mem, UInt32& len);
    private bool CjY=(Byte[]& mem, UInt32& len);
    private void CzY=(Byte[]& mem, UInt32& len);
    private void DDY=(Byte[]& mem, UInt32& len);
    private bool DTY=();
    private TDs= DjY=(bool require_image);
    private bool DzY=();
    private int EDY=(Byte[] scanlines, int max_lines);
    private int ETY=(int max_lines);
}
internal class 2jI=.ITQ= : TiffCodec {
    public bool CanEncode { get; }
    public bool CanDecode { get; }
    public ITQ=(Tiff tif, Compression scheme, string name);
    public virtual bool Init();
    public virtual bool get_CanEncode();
    public virtual bool get_CanDecode();
    public virtual bool DecodeRow(Byte[] buffer, int offset, int count, short plane);
    public virtual bool DecodeStrip(Byte[] buffer, int offset, int count, short plane);
    public virtual bool DecodeTile(Byte[] buffer, int offset, int count, short plane);
    public virtual bool EncodeRow(Byte[] buffer, int offset, int count, short plane);
    public virtual bool EncodeStrip(Byte[] buffer, int offset, int count, short plane);
    public virtual bool EncodeTile(Byte[] buffer, int offset, int count, short plane);
    public virtual bool Seek(int row);
    private bool IjQ=(Byte[] buffer, int offset, int count, short plane);
    private bool IzQ=(Byte[] buffer, int offset, int count, short plane);
}
internal class 2jI=.izg= : object {
    private JTk= 4zY=;
    private int dDg=;
    private int dTg=;
    private int SDc=;
    private int STc=;
    private 0Do=[] Szc=;
    private ujg=[][] jDg=;
    public izg=(JTk= cinfo, 0Do=[] coef_arrays);
    public virtual void uzY=(JDg= pass_mode);
    public virtual bool Fzc=(Byte[][][] input_buf);
    private void WDc=();
}
internal enum 2jI=.JDg= : Enum {
    public int value__;
    public static JDg= JTg=;
    public static JDg= Jjg=;
    public static JDg= Jzg=;
    public static JDg= KDg=;
}
internal class 2jI=.jjY= : ValueType {
    public TiffFieldInfo jzY=;
    public int Qiw=;
    public Byte[] kDY=;
}
internal class 2jI=.jTg= : Ijg= {
    private 0jk= 4zY=;
    private qDY=[] Hjc=;
    private Int32[] 9jY=;
    private 7T0=[] jjg=;
    private int jzg=;
    private int kDg=;
    private int kTg=;
    private int IDc=;
    private Int32[] kjg=;
    private Byte[] kzg=;
    private Byte[] lDg=;
    public jTg=(0jk= cinfo);
    public virtual void uzY=();
    public virtual void Izg=(qDY=[] input_buf, Int32& in_row_group_ctr, int in_row_groups_avail, Byte[][] output_buf, Int32& out_row_ctr, int out_rows_avail);
    private void lTg=(qDY=& input_data);
    private static void ljg=();
    private void lzg=(qDY=& input_data);
    private void mDg=(int downsampled_width, qDY=& input_data);
    private void mTg=(qDY=& input_data);
    private void mjg=(int downsampled_width, qDY=& input_data);
    private void mzg=(qDY=& input_data);
    private void nDg=(qDY=& input_data);
}
internal class 2jI=.JTk= : 2zg= {
    private static Int32[] Jjk=;
    private static Int32[] Jzk=;
    private static Byte[] KDk=;
    private static Byte[] KTk=;
    private static Byte[] Kjk=;
    private static Byte[] Kzk=;
    private static Byte[] LDk=;
    private static Byte[] LTk=;
    private static Byte[] Ljk=;
    private static Byte[] Lzk=;
    internal Yzo= MDk=;
    internal int pTU=;
    internal int MTk=;
    internal int Mjk=;
    internal 1To= Mzk=;
    internal int NDk=;
    internal int NTk=;
    internal 1To= Njk=;
    private 8Tg=[] Nzk=;
    internal zjo=[] ODk=;
    internal uzg=[] OTk=;
    internal uzg=[] Ojk=;
    internal int Ozk=;
    internal Gzg=[] PDk=;
    internal bool PTk=;
    internal bool Pjk=;
    internal bool Pzk=;
    internal int QDk=;
    internal 3Do= QTk=;
    internal int ojU=;
    internal int Qjk=;
    internal bool Qzk=;
    internal byte RDk=;
    internal byte RTk=;
    internal oDY= Rjk=;
    internal short Rzk=;
    internal short SDk=;
    internal bool STk=;
    internal int Sjk=;
    internal bool Szk=;
    internal int TDk=;
    internal int TTk=;
    internal int Tjk=;
    internal int Tzk=;
    internal Int32[] UDk=;
    internal int UTk=;
    internal int Ujk=;
    internal int Uzk=;
    internal Int32[] VDk=;
    internal int VTk=;
    internal int Vjk=;
    internal int Vzk=;
    internal int WDk=;
    internal Bjc= WTk=;
    internal GDc= Wjk=;
    internal HTc= Wzk=;
    internal Fjc= XDk=;
    internal CTg= XTk=;
    internal 1jY= Xjk=;
    internal Mjc= Xzk=;
    internal ijc= YDk=;
    internal hTc= YTk=;
    internal Gzg=[] Yjk=;
    internal int Yzk=;
    public bool 3zg= { get; }
    public Yzo= Zjk= { get; public set; }
    public int aTk= { get; public set; }
    public int bDk= { get; public set; }
    public int bzk= { get; public set; }
    public 1To= cjk= { get; public set; }
    public int dTk= { get; public set; }
    public int eDk= { get; public set; }
    public 1To= ezk= { get; public set; }
    public bool fjk= { get; public set; }
    public bool gTk= { get; public set; }
    public bool hDk= { get; public set; }
    public int hzk= { get; public set; }
    public 3Do= ijk= { get; public set; }
    public int jTk= { get; public set; }
    public int kDk= { get; public set; }
    public bool kzk= { get; public set; }
    public byte ljk= { get; public set; }
    public byte mTk= { get; public set; }
    public oDY= nDk= { get; public set; }
    public short nzk= { get; public set; }
    public short ojk= { get; public set; }
    public bool pTk= { get; public set; }
    public int pzk= { get; }
    public 8Tg=[] qTk= { get; }
    public zjo=[] qzk= { get; }
    public uzg=[] rTk= { get; }
    public uzg=[] rzk= { get; }
    public int sTk= { get; }
    public JTk=(aTo= errorManager);
    private static JTk=();
    public virtual bool 3jg=();
    public Yzo= ZDk=();
    public void ZTk=(Yzo= value);
    public int Zzk=();
    public void aDk=(int value);
    public int ajk=();
    public void azk=(int value);
    public int bTk=();
    public void bjk=(int value);
    public 1To= cDk=();
    public void cTk=(1To= value);
    public int czk=();
    public void dDk=(int value);
    public int djk=();
    public void dzk=(int value);
    public 1To= eTk=();
    public void ejk=(1To= value);
    public bool fDk=();
    public void fTk=(bool value);
    public bool fzk=();
    public void gDk=(bool value);
    public bool gjk=();
    public void gzk=(bool value);
    public int hTk=();
    public void hjk=(int value);
    public 3Do= iDk=();
    public void iTk=(3Do= value);
    public int izk=();
    public void jDk=(int value);
    public int jjk=();
    public void jzk=(int value);
    public bool kTk=();
    public void kjk=(bool value);
    public byte lDk=();
    public void lTk=(byte value);
    public byte lzk=();
    public void mDk=(byte value);
    public oDY= mjk=();
    public void mzk=(oDY= value);
    public short nTk=();
    public void njk=(short value);
    public short oDk=();
    public void oTk=(short value);
    public bool ozk=();
    public void pDk=(bool value);
    public int pjk=();
    public 8Tg=[] qDk=();
    public zjo=[] qjk=();
    public uzg=[] rDk=();
    public uzg=[] rjk=();
    public int sDk=();
    public void sjk=();
    public void szk=(bool suppress);
    public void tDk=();
    public void tTk=(int marker, Byte[] data);
    public void tjk=(int marker, int datalen);
    public void tzk=(byte val);
    public void uDk=();
    public void uTk=(Stream outfile);
    public void ujk=();
    public void uzk=(1To= colorspace);
    public void vDk=();
    public void vTk=(int quality, bool force_baseline);
    public void vjk=(int scale_factor, bool force_baseline);
    public void vzk=(int which_tbl, Int32[] basic_table, int scale_factor, bool force_baseline);
    public static int wDk=(int quality);
    public void wTk=();
    public void wjk=(bool write_all_tables);
    public int wzk=(Byte[][] scanlines, int num_lines);
    public int xDk=(Byte[][][] data, int num_lines);
    public void xTk=(0Do=[] coef_arrays);
    private void xjk=();
    private void xzk=();
    private void yDk=(bool transcode_only);
    private void yTk=(bool need_full_buffer);
    private void yjk=(0Do=[] coef_arrays);
    private void tzc=();
    private void yzk=();
    private void zDk=();
    private void zTk=(uzg=& htblptr, Byte[] bits, Byte[] val);
    private void zjk=(Int32& scanIndex, int ci, int Ss, int Se, int Ah, int Al);
    private void zzk=(Int32& scanIndex, int ncomps, int Ah, int Al);
    private void 0Dk=(Int32& scanIndex, int ncomps, int Ss, int Se, int Ah, int Al);
    private void 0Tk=(int index, int id, int hsamp, int vsamp, int quant, int dctbl, int actbl);
}
internal enum 2jI=.JTM= : Enum {
    public int value__;
    public static JTM= DzM=;
    public static JTM= JjM=;
    public static JTM= JzM=;
}
internal class 2jI=.jTw= : object {
    private static Int32[] bTw=;
    private static int 6js=;
    private static int 6zs=;
    private static int 7Ds=;
    private static int 7Ts=;
    private static int 7js=;
    private static int 7zs=;
    private static int 8Ds=;
    private static int 8Ts=;
    private static int 8js=;
    private static int jjw=;
    private static int jzw=;
    private static int kDw=;
    private static int kTw=;
    private static int kjw=;
    private static int kzw=;
    private static int lDw=;
    private static int lTw=;
    private static int ljw=;
    private static int lzw=;
    internal int zBg=;
    internal int mDw=;
    internal Int32[] mTw=;
    internal int mjw=;
    internal int mzw=;
    internal int nDw=;
    internal int nTw=;
    internal int njw=;
    internal byte nzw=;
    internal byte oDw=;
    internal Int32[] oTw=;
    internal int ojw=;
    internal Int32[] ozw=;
    internal int pDw=;
    internal jTw=(int bl, int bd, Int32[] tl, int tl_index, Int32[] td, int td_index, 9zw= z);
    internal jTw=(int bl, int bd, Int32[] tl, Int32[] td, 9zw= z);
    private static jTw=();
    internal int iDw=(azw= s, 9zw= z, int r);
    internal void iTw=(9zw= z);
    internal int pTw=(int bl, int bd, Int32[] tl, int tl_index, Int32[] td, int td_index, azw= s, 9zw= z);
}
internal enum 2jI=.KDM= : Enum {
    public int value__;
    public static KDM= KTM=;
    public static KDM= KjM=;
    public static KDM= KzM=;
    public static KDM= LDM=;
    public static KDM= LTM=;
    public static KDM= LjM=;
}
internal class 2jI=.KTc= : object {
    private 0jk= 4zY=;
    private int Cjc=;
    private bool Kjc=;
    private bool Kzc=;
    private Azc= LDc=;
    private Azc= LTc=;
    public KTc=(0jk= cinfo);
    public void Ezc=();
    public void Ljc=();
    public bool Lzc=();
    private void MDc=();
    private void MTc=();
}
internal class 2jI=.KTg= : object {
    private static Int32[] Kjg=;
    private static int Kzg=;
    private static int LDg=;
    private static int LTg=;
    private static int Ljg=;
    private static Byte[][] Lzg=;
    private 2z0= MDg=;
    private 0jk= 4zY=;
    private Byte[][] MTg=;
    private int Mjg=;
    private Byte[][] Mzg=;
    private Int32[] NDg=;
    private bool NTg=;
    private Int32[] Njg=;
    private int Nzg=;
    private Int32[][][] ODg=;
    private Int16[][] OTg=;
    private bool Ojg=;
    public KTg=(0jk= cinfo);
    private static KTg=();
    public virtual void uzY=(bool is_pre_scan);
    public virtual void BDc=(Byte[][] input_buf, int in_row, Byte[][] output_buf, int out_row, int num_rows);
    public virtual void xDY=();
    public virtual void BTc=();
    private void Ozg=(Byte[][] input_buf, int in_row, Byte[][] output_buf, int out_row, int num_rows);
    private void PDg=(Byte[][] input_buf, int in_row, Byte[][] output_buf, int out_row, int num_rows);
    private void PTg=(Byte[][] input_buf, int in_row, Byte[][] output_buf, int out_row, int num_rows);
    private void Pjg=(Byte[][] input_buf, int in_row, Byte[][] output_buf, int out_row, int num_rows);
    private void Pzg=(Byte[][] input_buf, int in_row, Byte[][] output_buf, int out_row, int num_rows);
    private void QDg=();
    private void QTg=();
    private void Qjg=();
    private void Qzg=();
    private static int RDg=(int j, int maxj);
    private static int RTg=(int j, int maxj);
    private int Rjg=(Int32[] Ncolors);
    private static Int32[][] Rzg=(int ncolors);
}
internal class 2jI=.kTY= : object {
    private static int kjY=;
    private static int kzY=;
    private static int lDY=;
    private Byte[] lTY=;
    private Int32[] ljY=;
    private Int32[] lzY=;
    private Int32[] mDY=;
    private Int32[] mTY=;
    private Int32[] mjY=;
    public void xR4=(Single[] luma, Single[] refBlackWhite);
    public void mzY=(int Y, int Cb, int Cr, Int32& r, Int32& g, Int32& b);
    private static int nDY=(float x);
    private static int nTY=(int c, float RB, float RW, float CR);
    private static int njY=(int f, int min, int max);
    private static int nzY=(int f, int max);
}
internal enum 2jI=.LzM= : Enum {
    public int value__;
    public static LzM= MDM=;
    public static LzM= MTM=;
    public static LzM= MjM=;
}
internal class 2jI=.LzY= : object {
    public Int32[] MDY=;
    public int MTY=;
    public int MjY=;
    public int MzY=;
    public int NDY=;
    public int NTY=;
    public int NjY=;
    public 7zI= NzY=;
    public short ODY=;
    public KDM= OTY=;
    public Compression OjY=;
    public FDM= OzY=;
    public LzM= PDY=;
    public 8zI= PTY=;
    public Orientation PjY=;
    public short PzY=;
    public int QDY=;
    public ushort QTY=;
    public ushort QjY=;
    public double QzY=;
    public double RDY=;
    public float RTY=;
    public float RjY=;
    public JTM= RzY=;
    public HzM= SDY=;
    public float STY=;
    public float SjY=;
    public Int16[] SzY=;
    public Int16[][] TDY=;
    public Int16[] TTY=;
    public short TjY=;
    public 5DI=[] TzY=;
    public int UDY=;
    public int UTY=;
    public UInt64[] UjY=;
    public UInt64[] UzY=;
    public bool VDY=;
    public int VTY=;
    public Int64[] VjY=;
    public Int16[] VzY=;
    public MzM= WDY=;
    public Single[] WTY=;
    public Int16[][] WjY=;
    public int WzY=;
    public string XDY=;
    public int XTY=;
    public jjY=[] XjY=;
}
internal class 2jI=.Mjc= : object {
    private vj0=[] Mzc=;
    private JTk= 4zY=;
    private bool NDc=;
    public Mjc=(JTk= cinfo);
    public void NTc=(Byte[][][] input_buf, int in_row_index, Byte[][][] output_buf, int out_row_group_index);
    public bool Njc=();
    private void Nzc=(int componentIndex, Byte[][] input_data, int startInputRow, Byte[][] output_data, int startOutRow);
    private void ODc=(int componentIndex, Byte[][] input_data, int startInputRow, Byte[][] output_data, int startOutRow);
    private void OTc=(int componentIndex, Byte[][] input_data, int startInputRow, Byte[][] output_data, int startOutRow);
    private void Ojc=(int componentIndex, Byte[][] input_data, int startInputRow, Byte[][] output_data, int startOutRow);
    private void Ozc=(int componentIndex, Byte[][] input_data, int startInputRow, Byte[][] output_data, int startOutRow);
    private void PDc=(int componentIndex, Byte[][] input_data, int startInputRow, Byte[][] output_data, int startOutRow);
    private static void PTc=(Byte[][] image_data, int startInputRow, int num_rows, int input_cols, int output_cols);
}
internal enum 2jI=.MzM= : Enum {
    public int value__;
    public static MzM= NDM=;
    public static MzM= NTM=;
}
internal static class 2jI=.NjM= : object {
    internal static int NzM=;
    internal static short ODM=;
    internal static short OTM=;
    internal static short OjM=;
    internal static short OzM=;
    internal static short PDM=;
    internal static short PTM=;
    internal static short PjM=;
    internal static short PzM=;
    internal static short QDM=;
    internal static short QTM=;
    internal static short QjM=;
    internal static short QzM=;
    internal static short RDM=;
    internal static short RTM=;
    internal static short RjM=;
    internal static short RzM=;
    internal static short SDM=;
    internal static short STM=;
    internal static short SjM=;
    internal static short SzM=;
    internal static short TDM=;
    internal static short TTM=;
    internal static short TjM=;
    internal static short TzM=;
    internal static short UDM=;
    internal static short UTM=;
    internal static short UjM=;
    internal static short UzM=;
    internal static short VDM=;
    internal static short VTM=;
    internal static short VjM=;
    internal static short VzM=;
    internal static short WDM=;
    internal static short WTM=;
    public static short WjM=;
    public static short WzM=;
    public static short XDM=;
    public static short XTM=;
    public static short XjM=;
}
internal class 2jI=.nTg= : dDc= {
    private 9j0= jzM=;
    private ozY= sjY=;
    private sD0= szY=;
    private int tDY=;
    private qzY=[] njg=;
    private qzY= nzg=;
    public nTg=(0jk= cinfo);
    public virtual void uzY=();
    public virtual bool vDY=(ujg=[] MCU_data);
    private bool oDg=(ujg=[] MCU_data);
    private bool oTg=(ujg=[] MCU_data);
    private bool ojg=(ujg=[] MCU_data);
    private bool ozg=(ujg=[] MCU_data);
    private bool vTY=();
    private static void pDg=(ujg=[] block, Int32[] newnz_pos, int num_newnz);
}
internal enum 2jI=.oDY= : Enum {
    public int value__;
    public static oDY= RxQ=;
    public static oDY= oTY=;
    public static oDY= ojY=;
}
internal class 2jI=.ozY= : ValueType {
    public int pDY=;
    public int pTY=;
}
internal class 2jI=.Pjc= : object {
    private static int Pzc=;
    private static int QDc=;
    private static int QTc=;
    private static int Qjc=;
    private static int Qzc=;
    private static int RDc=;
    private 0jk= 4zY=;
    private bool RTc=;
    private xT0= Rjc=;
    private int Rzc=;
    private int SDc=;
    private int STc=;
    private ujg=[] Sjc=;
    private 0Do=[] Szc=;
    private 0Do=[] TDc=;
    private Int32[] TTc=;
    private int Tjc=;
    public Pjc=(0jk= cinfo, bool need_full_buffer);
    public void Tzc=();
    public TDs= UDc=();
    public void UTc=();
    public TDs= Ujc=(qDY=[] output_buf);
    public 0Do=[] Uzc=();
    private TDs= VDc=(qDY=[] output_buf);
    private TDs= VTc=(qDY=[] output_buf);
    private TDs= Vjc=(qDY=[] output_buf);
    private bool Vzc=();
    private void WDc=();
}
internal class 2jI=.pjw= : object {
    private static int 1js=;
    private static int 4Ts=;
    internal static int 5Ts=;
    internal static int 5js=;
    internal static int 5zs=;
    internal static int 6Ds=;
    internal static int 6Ts=;
    private static int 9js=;
    private static int 6js=;
    private static int 6zs=;
    private static int 7Ds=;
    private static int 7Ts=;
    private static int 7js=;
    private static int 7zs=;
    private static int 8Ds=;
    private static int 8Ts=;
    private static int 8js=;
    private static int pzw=;
    private static int qDw=;
    private static int qTw=;
    private static int qjw=;
    private static int qzw=;
    private static int rDw=;
    private static int rTw=;
    private static int rjw=;
    private static int rzw=;
    private static int sDw=;
    private static int sTw=;
    private static int sjw=;
    private static int djw=;
    private static int dzw=;
    internal int zBg=;
    internal int GDw=;
    internal Int64[] szw=;
    internal long mzw=;
    internal int tDw=;
    internal int tTw=;
    internal int tjw=;
    internal azw= tzw=;
    private static Byte[] uDw=;
    private static pjw=();
    internal int uTw=(9zw= z);
    internal int ujw=(9zw= z);
    internal int uzw=(9zw= z, int w);
    internal int vDw=(9zw= z, int f);
    internal int vTw=(9zw= z, Byte[] dictionary, int dictLength);
    internal int vjw=(9zw= z);
    internal int vzw=(9zw= z);
}
internal class 2jI=.pjY= : ValueType {
    public int pDY=;
    public int pTY=;
    public 0jk= pzY=;
}
internal class 2jI=.pTg= : hTc= {
    private static int pjg=;
    private /z0= pzg=;
    private bool vzY=;
    private int qDg=;
    private int qTg=;
    private Int32[] qjg=;
    private int qzg=;
    private int rDg=;
    private int rTg=;
    private Char[] rjg=;
    private int tDY=;
    private int wDY=;
    private c_derived_tbl[] njg=;
    private Int64[][] rzg=;
    public pTg=(JTk= cinfo);
    public virtual void uzY=(bool gather_statistics);
    public virtual bool wzY=(ujg=[][] MCU_data);
    public virtual void xDY=();
    private bool sDg=(ujg=[][] MCU_data);
    private bool sTg=(ujg=[][] MCU_data);
    private bool sjg=(ujg=[][] MCU_data);
    private bool szg=(ujg=[][] MCU_data);
    private void tDg=();
    private void tTg=();
    private void yzY=(int val);
    private void zDY=(int code, int size);
    private void zTY=();
    private void tjg=(int tbl_no, int symbol);
    private void tzg=(int offset, int nbits);
    private void uDg=();
    private void zjY=(int restart_num);
    private static int uTg=(int x, int shft);
}
[DefaultMemberAttribute("Item")]
internal class 2jI=.qDY= : object {
    private Byte[][] ojM=;
    private Int32[] qTY=;
    private int qjY=;
    public Byte[] gxw= { get; }
    public qDY=(Byte[][] buf, Int32[] funnyIndices, int funnyOffset);
    public void hxw=(Byte[][] buf, Int32[] funnyIndices, int funnyOffset);
    public Byte[] gRw=(int i);
}
internal class 2jI=.qzY= : object {
    public Int32[] rDY=;
    public Int32[] rTY=;
    public uzg= rjY=;
    public Int32[] rzY=;
    public Byte[] sDY=;
}
internal class 2jI=.rDc= : object {
    private 0jk= 4zY=;
    private bool rTc=;
    private bool rjc=;
    private bool rzc=;
    private bool sDc=;
    public rDc=(0jk= cinfo);
    public TDs= sTc=();
    public void sjc=();
    public void Tzc=();
    public void szc=();
    public bool tDc=();
    public bool tTc=();
    private TDs= tjc=();
    private void tzc=();
    private void uDc=();
    private void FTc=();
}
internal class 2jI=.RjU= : TiffTagMethods {
    public virtual bool SetField(Tiff tif, TiffTag tag, FieldValue[] ap);
    public virtual FieldValue[] GetField(Tiff tif, TiffTag tag);
    public virtual void PrintDir(Tiff tif, Stream fd, TiffPrintFlags flags);
    private static void RzU=(Tiff tif);
}
internal class 2jI=.rTo= : object {
    private byte XTk=;
    private int rjo=;
    private Byte[] kTM=;
    public byte sDo= { get; }
    public int sjo= { get; }
    public Byte[] jB8= { get; }
    internal rTo=(byte marker, int originalDataLength, int lengthLimit);
    public byte rzo=();
    public int sTo=();
    public Byte[] ih8=();
}
internal class 2jI=.SDg= : object {
    private static int STg=;
    private static int Sjg=;
    private static int Szg=;
    private static int TDg=;
    private static int TTg=;
    private static int Tjg=;
    private static int Tzg=;
    private static int UDg=;
    private static int UTg=;
    private static int Ujg=;
    private static int Uzg=;
    private static int VDg=;
    private static int VTg=;
    private static int Vjg=;
    private static int Vzg=;
    private static int WDg=;
    private static int WTg=;
    private static int Wjg=;
    private static int Wzg=;
    private static int XDg=;
    private static int XTg=;
    private static int Xjg=;
    private 2z0= MDg=;
    private bool Xzg=;
    private 0jk= 4zY=;
    private Byte[][] MTg=;
    private int YDg=;
    private UInt16[][] YTg=;
    private bool Yjg=;
    private Int16[] OTg=;
    private bool Ojg=;
    private Int32[] Yzg=;
    public SDg=(0jk= cinfo);
    public virtual void uzY=(bool is_pre_scan);
    public virtual void BDc=(Byte[][] input_buf, int in_row, Byte[][] output_buf, int out_row, int num_rows);
    public virtual void xDY=();
    public virtual void BTc=();
    private void ZDg=(Byte[][] input_buf, int in_row, int num_rows);
    private void ZTg=(Byte[][] input_buf, int in_row, Byte[][] output_buf, int out_row, int num_rows);
    private void Zjg=(Byte[][] input_buf, int in_row, Byte[][] output_buf, int out_row, int num_rows);
    private void Zzg=();
    private void aDg=(4T0=[] boxlist, int boxIndex, int icolor);
    private void aTg=(int desired_colors);
    private int ajg=(4T0=[] boxlist, int numboxes, int desired_colors);
    private static int azg=(4T0=[] boxlist, int numboxes);
    private static int bDg=(4T0=[] boxlist, int numboxes);
    private void bTg=(4T0=[] boxlist, int boxIndex);
    private void bjg=();
    private int bzg=(int minc0, int minc1, int minc2, Byte[] colorlist);
    private void cDg=(int minc0, int minc1, int minc2, int numcolors, Byte[] colorlist, Byte[] bestcolor);
    private void cTg=(int c0, int c1, int c2);
}
internal class 2jI=.SDU= : aTo= {
    private BzU= STU=;
    public SDU=(BzU= sp);
    public virtual void SjU=();
    public virtual void SzU=();
}
internal class 2jI=.sTY= : dDc= {
    private ozY= sjY=;
    private sD0= szY=;
    private int tDY=;
    private qzY=[] tTY=;
    private qzY=[] tjY=;
    private qzY=[] tzY=;
    private qzY=[] uDY=;
    private Boolean[] uTY=;
    private Boolean[] ujY=;
    public sTY=(0jk= cinfo);
    public virtual void uzY=();
    public virtual bool vDY=(ujg=[] MCU_data);
    private bool vTY=();
}
internal class 2jI=.szo= : object {
    private int tDo=;
    private int tTo=;
    private int tjo=;
    private int tzo=;
    [CompilerGeneratedAttribute]
private EventHandler OnProgress;
    public int ujo= { get; public set; }
    public int vTo= { get; public set; }
    public int wDo= { get; public set; }
    public int wzo= { get; public set; }
    [CompilerGeneratedAttribute]
public void xDo=(EventHandler value);
    [CompilerGeneratedAttribute]
public void xTo=(EventHandler value);
    public int uDo=();
    public void uTo=(int value);
    public int uzo=();
    public void vDo=(int value);
    public int vjo=();
    public void vzo=(int value);
    public int wTo=();
    public void wjo=(int value);
    public void xzo=();
}
internal enum 2jI=.TDs= : Enum {
    public int value__;
    public static TDs= TTs=;
    public static TDs= Tjs=;
    public static TDs= Tzs=;
    public static TDs= UDs=;
    public static TDs= UTs=;
    public static TDs= Ujs=;
    public static TDs= Uzs=;
}
internal class 2jI=.TDU= : Yzo= {
    private Tiff TTU=;
    public TDU=(Tiff tif);
    public virtual void TjU=();
    public virtual bool TzU=();
    public virtual void UDU=();
}
[DefaultMemberAttribute("Item")]
internal class 2jI=.ujg= : object {
    internal Int16[] qxM=;
    public short gxw= { get; public set; }
    public short gRw=(int index);
    public void ghw=(int index, short value);
}
internal class 2jI=.uTc= : object {
    private static int ujc=;
    private static int uzc=;
    private static int kDc=;
    private static int kTc=;
    private static int kjc=;
    private static int kzc=;
    private static int lDc=;
    private static int lTc=;
    private static int ljc=;
    private static int lzc=;
    private static int mDc=;
    private static int mTc=;
    private static int mjc=;
    private static int mzc=;
    private static int nDc=;
    private static int nTc=;
    private static int izc=;
    private static int vDc=;
    private static int vTc=;
    private static int vjc=;
    private static int vzc=;
    private static int wDc=;
    private static int wTc=;
    private static int wjc=;
    private static int wzc=;
    private static int xDc=;
    private static int xTc=;
    private static int xjc=;
    private static int xzc=;
    private static int yDc=;
    private static int yTc=;
    private static int yjc=;
    private static int yzc=;
    private static int zDc=;
    private static int zTc=;
    private static int zjc=;
    private static int zzc=;
    private static int 0Dc=;
    private static Int16[] nzc=;
    private static int njc=;
    private static Double[] oDc=;
    private 0T0=[] 0Tc=;
    private 2D0=[] 0jc=;
    private 0jk= 4zY=;
    private Int32[] 0zc=;
    private qDY= 1Dc=;
    public uTc=(0jk= cinfo);
    private static uTc=();
    public void uzY=();
    public void 1Tc=(int component_index, Int16[] coef_block, qDY= output_buf, int output_row, int output_col);
    private void 1jc=(int component_index, Int16[] coef_block, int output_row, int output_col);
    private static int 1zc=(int coef, int quantval);
    private void 2Dc=(int component_index, Int16[] coef_block, int output_row, int output_col);
    private static int qzc=(int var, int c);
    private static int 2Tc=(short coef, int quantval);
    private static int 2jc=(int x, int shft);
    private static int 2zc=(int x, int n);
    private void 3Dc=(int component_index, Int16[] coef_block, int output_row, int output_col);
    private static float 3Tc=(short coef, float quantval);
    private void 3jc=(int component_index, Int16[] coef_block, int output_row, int output_col);
    private void 3zc=(int component_index, Int16[] coef_block, int output_row, int output_col);
    private void 4Dc=(int component_index, Int16[] coef_block, int output_row, int output_col);
    private static int 4Tc=(short coef, int quantval);
}
internal class 2jI=.UTU= : yDo= {
    private static Byte[] UjU=;
    protected BzU= STU=;
    public UTU=(BzU= sp);
    private static UTU=();
    public virtual void UzU=();
    public virtual bool VDU=();
}
internal class 2jI=.uzg= : object {
    private Byte[] vDg=;
    private Byte[] vTg=;
    private bool vjg=;
    internal Byte[] wDg= { get; }
    internal Byte[] wjg= { get; }
    public bool xTg= { get; public set; }
    internal Byte[] vzg=();
    internal Byte[] wTg=();
    public bool wzg=();
    public void xDg=(bool value);
}
internal class 2jI=.VjU= : UTU= {
    public VjU=(BzU= sp);
    public virtual void UzU=();
}
internal class 2jI=.vjY= : hTc= {
    private bool vzY=;
    private sD0= szY=;
    private int tDY=;
    private int wDY=;
    private c_derived_tbl[] tTY=;
    private c_derived_tbl[] tjY=;
    private Int64[][] wTY=;
    private Int64[][] wjY=;
    public vjY=(JTk= cinfo);
    public virtual void uzY=(bool gather_statistics);
    public virtual bool wzY=(ujg=[][] MCU_data);
    public virtual void xDY=();
    private bool xTY=(ujg=[][] MCU_data);
    private void xjY=();
    private bool xzY=(ujg=[][] MCU_data);
    private void yDY=();
    private bool yTY=(sD0= state, Int16[] block, int last_dc_val, c_derived_tbl dctbl, c_derived_tbl actbl);
    private void yjY=(Int16[] block, int last_dc_val, Int64[] dc_counts, Int64[] ac_counts);
    private bool yzY=(int val);
    private bool zDY=(sD0= state, int code, int size);
    private bool zTY=(sD0= state);
    private bool zjY=(sD0= state, int restart_num);
}
internal class 2jI=.VTU= : Yzo= {
    private BzU= STU=;
    public VTU=(BzU= sp);
    public virtual void TjU=();
    public virtual bool TzU=();
    public virtual void UDU=();
}
internal class 2jI=.VzU= : 4zM= {
    private bool WDU=;
    private static short WTU=;
    private static short WjU=;
    private static short WzU=;
    private static short XDU=;
    private static short XTU=;
    private static short XjU=;
    private static short XzU=;
    private static int YDU=;
    private static int YTU=;
    private static int YjU=;
    private static int YzU=;
    private bool ZDU=;
    private short ZTU=;
    private short ZjU=;
    private short ZzU=;
    private int aDU=;
    private int aTU=;
    private int jDM=;
    private int ajU=;
    private int azU=;
    private int bDU=;
    private bool bTU=;
    private int bjU=;
    private int bzU=;
    private int cDU=;
    private int cTU=;
    private jT0=[] cjU=;
    private int czU=;
    private int dDU=;
    private int dTU=;
    private int djU=;
    private int dzU=;
    private int eDU=;
    private jz0=[] eTU=;
    public bool CanEncode { get; }
    public bool CanDecode { get; }
    public VzU=(Tiff tif, Compression scheme, string name);
    public virtual bool Init();
    public virtual bool get_CanEncode();
    public virtual bool get_CanDecode();
    public virtual bool PreDecode(short plane);
    public virtual bool PreEncode(short plane);
    public virtual bool PostEncode();
    public virtual void Cleanup();
    public virtual bool 7zM=();
    public virtual bool 8DM=(Byte[] buffer, int offset, int count, short plane);
    public virtual bool 8TM=(Byte[] buffer, int offset, int count, short plane);
    public virtual bool 8jM=(Byte[] buffer, int offset, int count, short plane);
    public virtual bool 8zM=();
    public virtual bool 9DM=(Byte[] buffer, int offset, int count, short plane);
    public virtual bool 9TM=(Byte[] buffer, int offset, int count, short plane);
    public virtual bool 9jM=(Byte[] buffer, int offset, int count, short plane);
    private bool ejU=();
    private bool ezU=(short s);
    private bool fDU=(Byte[] buffer, int offset, int count, short plane);
    private bool fTU=(Byte[] buffer, int offset, int count, short plane);
    private bool fjU=();
    private bool fzU=(short s);
    private bool gDU=();
    private bool gTU=(Byte[] buffer, int offset, int count, short plane);
    private void gjU=();
    private static int gzU=(int n);
    private void hDU=(int c);
    private void hTU=();
    private void hjU=(Int16& _code, bool compat);
    private void hzU=(Int16& code);
    private void iDU=(Int16& code);
    private void iTU=();
}
internal class 2jI=.wDw= : object {
    private static int bDw=;
    private static int 6js=;
    private static int 6zs=;
    private static int 7Ds=;
    private static int 7Ts=;
    private static int 7js=;
    private static int 7zs=;
    private static int 8Ds=;
    private static int 8Ts=;
    private static int 8js=;
    internal static int wTw=;
    internal static int wjw=;
    internal static Int32[] wzw=;
    internal static Int32[] xDw=;
    internal static Int32[] xTw=;
    internal static Int32[] xjw=;
    internal static Int32[] xzw=;
    internal static Int32[] yDw=;
    internal static int yTw=;
    private static wDw=();
    internal static int yjw=(Int32[] b, int bindex, int n, int s, Int32[] d, Int32[] e, Int32[] t, Int32[] m, Int32[] hp, Int32[] hn, Int32[] v);
    internal static int yzw=(Int32[] c, Int32[] bb, Int32[] tb, Int32[] hp, 9zw= z);
    internal static int zDw=(int nl, int nd, Int32[] c, Int32[] bl, Int32[] bd, Int32[] tl, Int32[] td, Int32[] hp, 9zw= z);
    internal static int zTw=(Int32[] bl, Int32[] bd, Int32[][] tl, Int32[][] td, 9zw= z);
}
internal class 2jI=.WTc= : object {
    private static int Wjc=;
    private static int Wzc=;
    private static int XDc=;
    private yT0= XTc=;
    private 0jk= 4zY=;
    private Byte[][][] ojM=;
    private bool Xjc=;
    private int Gjc=;
    private Int32[][][] qTY=;
    private Int32[] Xzc=;
    private int YDc=;
    private int YTc=;
    private int Yjc=;
    private int Yzc=;
    public WTc=(0jk= cinfo);
    public void uzY=(JDg= pass_mode);
    public void HDc=(Byte[][] output_buf, Int32& out_row_ctr, int out_rows_avail);
    private void ZDc=(Byte[][] output_buf, Int32& out_row_ctr, int out_rows_avail);
    private void ZTc=(Byte[][] output_buf, Int32& out_row_ctr, int out_rows_avail);
    private void Zjc=(Byte[][] output_buf, Int32& out_row_ctr, int out_rows_avail);
    private void Zzc=();
    private void aDc=();
    private void aTc=();
    private void ajc=();
}
internal class 2jI=.XDs= : object {
    internal static string XTs=;
    private Tiff Xjs=;
    private bool Xzs=;
    private bool YDs=;
    private 5DI= rBk=;
    private int iCw=;
    private int hBk=;
    private short YTs=;
    private short Yjs=;
    private Orientation Yzs=;
    private Orientation ZDs=;
    private FDM= ZTs=;
    private UInt16[] Zjs=;
    private UInt16[] Zzs=;
    private UInt16[] aDs=;
    private GetDelegate aTs=;
    private PutContigDelegate ajs=;
    private PutSeparateDelegate azs=;
    private Byte[] bDs=;
    private Int32[][] bTs=;
    private Int32[][] bjs=;
    private kTY= bzs=;
    private HzY= cDs=;
    private static ZTY= cTs=;
    private static int zhk=;
    private static int cjs=;
    private static int czs=;
    internal int dDs=;
    internal int dTs=;
    public bool dzs= { get; }
    public 5DI= eTs= { get; }
    public int fy0= { get; }
    public int gi0= { get; }
    public short ezs= { get; }
    public short fTs= { get; }
    public Orientation fzs= { get; }
    public Orientation gjs= { get; public set; }
    public FDM= hDs= { get; }
    public GetDelegate hzs= { get; public set; }
    public PutContigDelegate ijs= { get; public set; }
    public PutSeparateDelegate jTs= { get; public set; }
    private static XDs=();
    public static XDs= RB8=(Tiff tif, bool stopOnError, String& errorMsg);
    public bool djs=();
    public 5DI= eDs=();
    public int fS0=();
    public int gC0=();
    public short ejs=();
    public short fDs=();
    public Orientation fjs=();
    public Orientation gDs=();
    public void gTs=(Orientation value);
    public FDM= gzs=();
    public GetDelegate hTs=();
    public void hjs=(GetDelegate value);
    public PutContigDelegate iDs=();
    public void iTs=(PutContigDelegate value);
    public PutSeparateDelegate izs=();
    public void jDs=(PutSeparateDelegate value);
    public bool jjs=(Int32[] raster, int offset, int width, int height);
    private static int jzs=(int r, int g, int b);
    private static int kDs=(int r, int g, int b, int a);
    private static int kDs=(int rgb, int a);
    private static int kTs=(short v);
    private static int kjs=(short r, short g, short b);
    private static int kzs=(short r, short g, short b, short a);
    private void lDs=(int x, int i, Int32& j);
    private void lTs=(int x, int i, Int32& j);
    private static bool ljs=(XDs= img, Int32[] raster, int offset, int width, int height);
    private static bool lzs=(XDs= img, Int32[] raster, int offset, int width, int height);
    private static bool mDs=(XDs= img, Int32[] raster, int offset, int width, int height);
    private static bool mTs=(XDs= img, Int32[] raster, int offset, int width, int height);
    private bool mjs=();
    private int mzs=();
    private bool nDs=();
    private bool nTs=();
    private bool njs=();
    private PutContigDelegate nzs=();
    private bool oDs=();
    private bool oTs=();
    private int ojs=();
    private void ozs=();
    private bool pDs=();
    private bool pTs=();
    private void mzY=(Int32& dst, int Y, int Cb, int Cr);
    private static void pjs=(XDs= img, Int32[] raster, int rasterOffset, int rasterShift, int x, int y, int width, int height, Byte[] buffer, int offset, int bufferShift);
    private static void pzs=(XDs= img, Int32[] raster, int rasterOffset, int rasterShift, int x, int y, int width, int height, Byte[] buffer, int offset, int bufferShift);
    private static void qDs=(XDs= img, Int32[] raster, int rasterOffset, int rasterShift, int x, int y, int width, int height, Byte[] buffer, int offset, int bufferShift);
    private static void qTs=(XDs= img, Int32[] raster, int rasterOffset, int rasterShift, int x, int y, int width, int height, Byte[] buffer, int offset, int bufferShift);
    private static void qjs=(XDs= img, Int32[] raster, int rasterOffset, int rasterShift, int x, int y, int width, int height, Byte[] buffer, int offset, int bufferShift);
    private static void qzs=(XDs= img, Int32[] raster, int rasterOffset, int rasterShift, int x, int y, int width, int height, Byte[] buffer, int offset, int bufferShift);
    private static void rDs=(XDs= img, Int32[] raster, int rasterOffset, int rasterShift, int x, int y, int width, int height, Byte[] buffer, int offset, int bufferShift);
    private static void rTs=(XDs= img, Int32[] raster, int rasterOffset, int rasterShift, int x, int y, int width, int height, Byte[] buffer, int offset, int bufferShift);
    private static void rjs=(XDs= img, Int32[] raster, int rasterOffset, int rasterShift, int x, int y, int width, int height, Byte[] buffer, int offset, int bufferShift);
    private static void rzs=(XDs= img, Int32[] raster, int rasterOffset, int rasterShift, int x, int y, int width, int height, Byte[] buffer, int offset, int bufferShift);
    private static void sDs=(XDs= img, Int32[] raster, int rasterOffset, int rasterShift, int x, int y, int width, int height, Byte[] buffer, int offset, int bufferShift);
    private static void sTs=(XDs= img, Int32[] raster, int rasterOffset, int rasterShift, int x, int y, int width, int height, Byte[] buffer, int offset, int bufferShift);
    private static void sjs=(XDs= img, Int32[] raster, int rasterOffset, int rasterShift, int x, int y, int width, int height, Byte[] buffer, int offset, int bufferShift);
    private static void szs=(XDs= img, Int32[] raster, int rasterOffset, int rasterShift, int x, int y, int width, int height, Byte[] buffer, int offset, int bufferShift);
    private static void tDs=(XDs= img, Int32[] raster, int rasterOffset, int rasterShift, int x, int y, int width, int height, Byte[] buffer, int offset, int bufferShift);
    private static void tTs=(XDs= img, Int32[] raster, int rasterOffset, int rasterShift, int x, int y, int width, int height, Byte[] buffer, int offset, int bufferShift);
    private static void tjs=(XDs= img, Int32[] raster, int rasterOffset, int rasterShift, int x, int y, int width, int height, Byte[] buffer, int offset, int bufferShift);
    private static void tzs=(XDs= img, Int32[] raster, int rasterOffset, int rasterShift, int x, int y, int width, int height, Byte[] buffer, int offset, int bufferShift);
    private static void uDs=(XDs= img, Int32[] raster, int rasterOffset, int rasterShift, int x, int y, int width, int height, Byte[] buffer, int offset, int bufferShift);
    private static void uTs=(XDs= img, Int32[] raster, int rasterOffset, int rasterShift, int x, int y, int width, int height, Byte[] buffer, int offset, int bufferShift);
    private static void ujs=(XDs= img, Int32[] raster, int rasterOffset, int rasterShift, int x, int y, int width, int height, Byte[] buffer, int offset, int bufferShift);
    private static void uzs=(XDs= img, Int32[] raster, int rasterOffset, int rasterShift, int x, int y, int width, int height, Byte[] buffer, int offset, int bufferShift);
    private static void vDs=(XDs= img, Int32[] raster, int rasterOffset, int rasterShift, int x, int y, int width, int height, Byte[] buffer, int offset, int bufferShift);
    private static void vTs=(XDs= img, Int32[] raster, int rasterOffset, int rasterShift, int x, int y, int width, int height, Byte[] buffer, int offset, int bufferShift);
    private static void vjs=(XDs= img, Int32[] raster, int rasterOffset, int rasterShift, int x, int y, int width, int height, Byte[] buffer, int offset, int bufferShift);
    private static void vzs=(XDs= img, Int32[] raster, int rasterOffset, int rasterShift, int x, int y, int width, int height, Byte[] buffer, int offset, int bufferShift);
    private static void wDs=(XDs= img, Int32[] raster, int rasterOffset, int rasterShift, int x, int y, int width, int height, Byte[] buffer, int offset1, int offset2, int offset3, int offset4, int bufferShift);
    private static void wTs=(XDs= img, Int32[] raster, int rasterOffset, int rasterShift, int x, int y, int width, int height, Byte[] buffer, int offset1, int offset2, int offset3, int offset4, int bufferShift);
    private static void wjs=(XDs= img, Int32[] raster, int rasterOffset, int rasterShift, int x, int y, int width, int height, Byte[] buffer, int offset1, int offset2, int offset3, int offset4, int bufferShift);
    private static void wzs=(XDs= img, Int32[] raster, int rasterOffset, int rasterShift, int x, int y, int width, int height, Byte[] buffer, int offset1, int offset2, int offset3, int offset4, int bufferShift);
    private static void xDs=(XDs= img, Int32[] raster, int rasterOffset, int rasterShift, int x, int y, int width, int height, Byte[] buffer, int offset1, int offset2, int offset3, int offset4, int bufferShift);
    private static void xTs=(XDs= img, Int32[] raster, int rasterOffset, int rasterShift, int x, int y, int width, int height, Byte[] buffer, int offset1, int offset2, int offset3, int offset4, int bufferShift);
    private static void xjs=(XDs= img, Int32[] raster, int rasterOffset, int rasterShift, int x, int y, int width, int height, Byte[] buffer, int offset1, int offset2, int offset3, int offset4, int bufferShift);
    private static void xzs=(XDs= img, Int32[] raster, int rasterOffset, int rasterShift, int x, int y, int width, int height, Byte[] buffer, int offset, int bufferShift);
}
internal static class 2jI=.xjg= : object {
    public static int xzg=;
    public static int yDg=;
    public static int yTg=;
    public static int yjg=;
    public static int yzg=;
    public static int zDg=;
    public static int zTg=;
    public static int zjg=;
    public static int zzg=;
    public static int 0Dg=;
    public static 3Do= 0Tg=;
    public static 3Do= 0jg=;
    public static int 0zg=;
    public static int 1Dg=;
    public static int 1Tg=;
    public static int 1jg=;
    public static int 1zg=;
    public static int 2Dg=;
    public static int 2Tg=;
    public static int 2jg=;
}
internal class 2jI=.XzY= : object {
    public TiffTag YDY=;
    public TiffType YTY=;
    public int YjY=;
    public ulong YzY=;
    public string xhM=();
    public static int ZDY=(bool isBigTiff);
}
internal abstract class 2jI=.yDo= : object {
    private Byte[] yTo=;
    private int yjo=;
    private int ZDo=;
    public abstract virtual void UzU=();
    public abstract virtual bool VDU=();
    protected void aDo=(Byte[] buffer, int size);
    public virtual void FTY=(int num_bytes);
    public virtual bool FjY=(0jk= cinfo, int desired);
    public virtual void FzY=();
    public virtual bool yzo=(Int32& V);
    public virtual bool zDo=(Int32& V);
    public virtual int yhM=(Byte[] dest, int amount);
    public virtual bool zTo=();
}
internal class 2jI=.YjM= : TiffCodec {
    public static int YzM=;
    public static int ZDM=;
    public static int ZTM=;
    public static int ZjM=;
    public static int ZzM=;
    public static int aDM=;
    public static int aTM=;
    public static int ajM=;
    internal 6DI= azM=;
    internal ADM= bDM=;
    internal 2TI= bTM=;
    internal int bjM=;
    internal int bzM=;
    internal int cDM=;
    internal string cTM=;
    internal int cjM=;
    internal string czM=;
    internal FaxFillFunc dDM=;
    private static int dTM=;
    private static byte djM=;
    private static byte dzM=;
    private static byte eDM=;
    private static byte eTM=;
    private static byte ejM=;
    private static byte ezM=;
    private static byte fDM=;
    private static byte fTM=;
    private static byte fjM=;
    private static byte fzM=;
    private static byte gDM=;
    private static byte gTM=;
    private static byte gjM=;
    private static short gzM=;
    private static short hDM=;
    private static short hTM=;
    private static short hjM=;
    private static TiffFieldInfo[] hzM=;
    private static TiffFieldInfo[] iDM=;
    private static TiffFieldInfo[] iTM=;
    private TiffTagMethods ijM=;
    private TiffTagMethods izM=;
    private int jDM=;
    private int jTM=;
    private int jjM=;
    private bz0= jzM=;
    private Byte[] kDM=;
    private int kTM=;
    private int kjM=;
    private int kzM=;
    private Int32[] lDM=;
    private int lTM=;
    private int ljM=;
    private int lzM=;
    private int mDM=;
    private int mTM=;
    private int mjM=;
    private int mzM=;
    private dD0= nDM=;
    private bool nTM=;
    private Byte[] njM=;
    private int nzM=;
    private int oDM=;
    private int oTM=;
    private Byte[] ojM=;
    private int ozM=;
    private static Int32[] pDM=;
    private static Int32[] pTM=;
    private static Int32[] pjM=;
    private static Int16[] pzM=;
    private static Int16[] qDM=;
    private static aD0= qTM=;
    private static aD0= qjM=;
    private static aD0=[] qzM=;
    private static Int32[] rDM=;
    private static Byte[] rTM=;
    private static Byte[] rjM=;
    private static Byte[] rzM=;
    public bool CanEncode { get; }
    public bool CanDecode { get; }
    public YjM=(Tiff tif, Compression scheme, string name);
    private static YjM=();
    private void sDM=();
    public virtual bool Init();
    public virtual bool get_CanEncode();
    public virtual bool get_CanDecode();
    public virtual bool SetupDecode();
    public virtual bool PreDecode(short plane);
    public virtual bool DecodeRow(Byte[] buffer, int offset, int count, short plane);
    public virtual bool DecodeStrip(Byte[] buffer, int offset, int count, short plane);
    public virtual bool DecodeTile(Byte[] buffer, int offset, int count, short plane);
    public virtual bool SetupEncode();
    public virtual bool PreEncode(short plane);
    public virtual bool PostEncode();
    public virtual bool EncodeRow(Byte[] buffer, int offset, int count, short plane);
    public virtual bool EncodeStrip(Byte[] buffer, int offset, int count, short plane);
    public virtual bool EncodeTile(Byte[] buffer, int offset, int count, short plane);
    public virtual void Close();
    public virtual void Cleanup();
    private bool sTM=();
    private void sjM=(Int32& b1);
    private static void Fig=(Int32& a, Int32& b);
    private static bool szM=(int offset);
    private static bool tDM=(int offset);
    private static void tTM=(int n, Byte[] cp, Int32& offset, byte value);
    private static void tjM=(Byte[] buffer, int offset, Int32[] runs, int thisRunOffset, int nextRunOffset, int width);
    private static int tzM=(Byte[] bp, int bpOffset, int bs, int be);
    private static int uDM=(Byte[] bp, int bpOffset, int bs, int be);
    private static int uTM=(Byte[] bp, int bpOffset, int _bs, int _be, int _color);
    private static int ujM=(Byte[] bp, int bpOffset, int _bs, int _be, int _color);
    private bool uzM=();
    private int vDM=(int n);
    private void vTM=(int n);
    private bool vjM=(int n);
    private bool vzM=(int n);
    private bool wDM=(az0=& TabEnt, int wid);
    private bool wTM=(az0=& TabEnt, int wid, bool useBlack);
    private bool wjM=();
    private bool wzM=();
    private void xDM=(string module);
    private void xTM=(string module);
    private void xjM=(string module);
    private void xzM=(string module);
    private bool yDM=(Byte[] buffer, int offset, int count);
    private bool yTM=(Byte[] buffer, int offset, int count);
    private bool yjM=();
    private bool yzM=();
    private static int zDM=(Byte[] buf, int bufOffset, int ix);
    private bool zTM=(Byte[] buffer, int offset, int count);
    private bool zjM=();
    private void zzM=();
    private bool 0DM=();
    private void 0TM=();
    private void 0jM=(int bits, int length);
    private void 0zM=(aD0= te);
    private void 1DM=(int span, bool useBlack);
    private void 1TM=();
    private void 1jM=(int x);
    private void 1zM=(string module);
    private void 2DM=(string module);
    private bool 2TM=(string module);
    private bool 2jM=(string module, int b1);
    private bool 2zM=();
    private bool 3DM=();
    private bool 3TM=(Byte[] buffer, int offset, int count);
    private bool 3jM=();
    private bool 3zM=(Byte[] buffer, int offset, int count);
    private bool 4DM=(Byte[] buffer, int offset, int count);
    private bool 4TM=();
}
internal abstract class 2jI=.Yzo= : object {
    private Byte[] ojM=;
    private int ZDo=;
    private int ZTo=;
    protected int Zzo= { get; }
    public abstract virtual void TjU=();
    public abstract virtual bool TzU=();
    public abstract virtual void UDU=();
    public virtual bool yzY=(int val);
    protected void aDo=(Byte[] buffer, int offset);
    protected int Zjo=();
}
internal class 2jI=.zjo= : object {
    private bool vjg=;
    internal Int16[] zzo=;
    public bool xTg= { get; public set; }
    public bool wzg=();
    public void xDg=(bool value);
}
internal class 2jI=.zjw= : object {
    private static int CDw=;
    private static int Cjw=;
    private static int CTw=;
    private static int DDw=;
    private static int Czw=;
    private static int DTw=;
    internal static int zzw=;
    internal static Int16[] 0Dw=;
    internal static Int16[] 0Tw=;
    internal static zjw= 0jw=;
    internal static zjw= 0zw=;
    internal static zjw= 1Dw=;
    internal Int16[] 1Tw=;
    internal Int32[] 1jw=;
    internal int 1zw=;
    internal int 2Dw=;
    internal int 2Tw=;
    internal zjw=(Int16[] static_tree, Int32[] extra_bits, int extra_base, int elems, int max_length);
    private static zjw=();
}
internal class 2jI=.ZTY= : object {
    internal Single[][] ZjY=;
    internal float ZzY=;
    internal float aDY=;
    internal float aTY=;
    internal int ajY=;
    internal int azY=;
    internal int bDY=;
    internal float bTY=;
    internal float bjY=;
    internal float bzY=;
    internal float cDY=;
    internal float cTY=;
    internal float cjY=;
    public ZTY=(Single[] mat0, Single[] mat1, Single[] mat2, float YCR, float YCG, float YCB, int Vrwr, int Vrwg, int Vrwb, float Y0R, float Y0G, float Y0B, float gammaR, float gammaG, float gammaB);
}
internal class 2jI=.zzs= : object {
    private static int 0Ds=;
    private static int 0Ts=;
    internal long 0js=(long adler, Byte[] buf, int index, int len);
}
internal class 2jI=.zzY= : object {
    public static Int32[] 0DY=;
    private static zzY=();
    public static int 0TY=(int x, int shft);
    public static int 0jY=(int x, int n);
    public static int 0zY=(int a, int b);
    public static int 1DY=(int a, int b);
    public static void 1TY=(qDY= input_array, int source_row, Byte[][] output_array, int dest_row, int num_rows, int num_cols);
    public static void 1TY=(qDY= input_array, int source_row, qDY= output_array, int dest_row, int num_rows, int num_cols);
    public static void 1TY=(Byte[][] input_array, int source_row, Byte[][] output_array, int dest_row, int num_rows, int num_cols);
}
internal class 8RQ=./Cw= : object {
    private List`1<rC0=> /Sw=;
    private int /iw=;
    private int /yw=;
    private double iyw=;
    [CompilerGeneratedAttribute]
private List`1<Lyw=> 5yw=;
    [CompilerGeneratedAttribute]
private byte AC0=;
    [CompilerGeneratedAttribute]
private int 6Cw=;
    [CompilerGeneratedAttribute]
private short 6Sw=;
    [CompilerGeneratedAttribute]
private short 6iw=;
    [CompilerGeneratedAttribute]
private int AS0=;
    [CompilerGeneratedAttribute]
private byte Ai0=;
    [CompilerGeneratedAttribute]
private QSw= Ay0=;
    [CompilerGeneratedAttribute]
private string JCw=;
    [CompilerGeneratedAttribute]
private ushort JSw=;
    public List`1<Lyw=> 7Sw= { get; public set; }
    public byte Bi0= { get; private set; }
    public int 8Cw= { get; private set; }
    public short 8yw= { get; private set; }
    public short 9iw= { get; private set; }
    public int CS0= { get; private set; }
    public byte DC0= { get; private set; }
    public QSw= Dy0= { get; private set; }
    public string Kyw= { get; public set; }
    public ushort Liw= { get; public set; }
    public /Cw=(double extentWidthLimitation);
    [CompilerGeneratedAttribute]
public void 7Cw=(List`1<Lyw=> value);
    [CompilerGeneratedAttribute]
public List`1<Lyw=> 6yw=();
    [CompilerGeneratedAttribute]
private void BS0=(byte value);
    [CompilerGeneratedAttribute]
public byte BC0=();
    [CompilerGeneratedAttribute]
private void 7yw=(int value);
    [CompilerGeneratedAttribute]
public int 7iw=();
    [CompilerGeneratedAttribute]
private void 8iw=(short value);
    [CompilerGeneratedAttribute]
public short 8Sw=();
    [CompilerGeneratedAttribute]
private void 9Sw=(short value);
    [CompilerGeneratedAttribute]
public short 9Cw=();
    [CompilerGeneratedAttribute]
private void CC0=(int value);
    [CompilerGeneratedAttribute]
public int By0=();
    [CompilerGeneratedAttribute]
private void Cy0=(byte value);
    [CompilerGeneratedAttribute]
public byte Ci0=();
    [CompilerGeneratedAttribute]
private void Di0=(QSw= value);
    [CompilerGeneratedAttribute]
public QSw= DS0=();
    [CompilerGeneratedAttribute]
public void Kiw=(string value);
    [CompilerGeneratedAttribute]
public string KSw=();
    [CompilerGeneratedAttribute]
public ushort LCw=();
    [CompilerGeneratedAttribute]
public void LSw=(ushort value);
    public void EC0=(double LoCenter, double LaCenter, byte BitsPerCoord, Dictionary`2<string, int> lblDictionary);
    private void ES0=();
    private void Ei0=();
}
internal class 8RQ=./hg= : Txo= {
    internal /hg=(string id, string desc);
    private void uhg=();
    internal virtual hRg= uxg=(hRg= pjConsts, Int32& pj_Error);
    internal virtual void whg=(XRg= lp, hRg= pjConsts, EBg= fac, Int32& pj_Error);
    internal virtual XRg= wBg=(XBo= xy, hRg= pjConsts, Int32& pj_Error);
    internal virtual XBo= wRg=(XRg= lp, hRg= pjConsts, Int32& pj_Error);
}
internal class 8RQ=./xg= : Txo= {
    internal /xg=(string id, string desc);
    private void uhg=();
    internal virtual hRg= uxg=(hRg= pjConsts, Int32& pj_Error);
    internal virtual void whg=(XRg= lp, hRg= pjConsts, EBg= fac, Int32& pj_Error);
    internal virtual XRg= wBg=(XBo= xy, hRg= pjConsts, Int32& pj_Error);
    internal virtual XBo= wRg=(XRg= lp, hRg= pjConsts, Int32& pj_Error);
}
internal class 8RQ=./xk= : ValueType {
    internal double 1Bc=;
    internal double 8Bk=;
    internal double kBg=;
    internal double ABo=;
}
internal class 8RQ=./xw= : object {
    private int AB0=;
    public BaseShape ZRw=(string wellKnownText);
    public BaseShape ZRw=(TextReader reader);
    private Vertex[] AR0=(IList tokens, bool skipExtraParenthesis);
    private Vertex Ah0=(IList tokens, bool skipExtraParenthesis);
    private bool Ax0=(IList tokens, string stringValue);
    private bool BB0=(IList tokens);
    private double BR0=(IList tokens);
    private string Bh0=(IList tokens);
    private string Bx0=(IList tokens);
    private string CB0=(IList tokens);
    private string CR0=(IList tokens);
    private BaseShape Ch0=(IList tokens);
    private PointShape Cx0=(IList tokens);
    private LineShape DB0=(IList tokens);
    private RingShape DR0=(IList tokens);
    private MultipointShape Dh0=(IList tokens);
    private IEnumerable`1<PointShape> Dx0=(Vertex[] coordinates);
    private PolygonShape EB0=(IList tokens);
    private MultilineShape ER0=(IList tokens);
    private MultipolygonShape Eh0=(IList tokens);
    private GeometryCollectionShape Ex0=(IList tokens);
}
internal class 8RQ=./yo= : ValueType {
    public double XRo=;
    public double Xho=;
}
internal static class 8RQ=.0CE= : object {
    public static string 0SE=(string degreesMinutesSeconds);
}
internal class 8RQ=.0Ck= : gSo= {
    private static int hCQ=;
    private static int hSQ=;
    private static int hiQ=;
    private static int hyQ=;
    private Sig= 0Sk=;
    public Sig= 0yk= { get; }
    public int VSU= { get; public set; }
    public rio= WCU= { get; public set; }
    public 0Ck=(yCY= poDefnIn);
    public Sig= 0ik=();
    public virtual NCg= ric=();
    public virtual int ryc=(5yg= poMapFile);
    public virtual GSg= sCc=(yCY= poNewDefn);
    public double 1Ck=();
    public double 1Sk=();
    public virtual int sSc=(5yg= poMapFile, lSk= poObjHdr, bool bCoordBlockDataOnly, wig=& ppoCoordBlock);
    public virtual int sic=(5yg= poMapFile, lSk= poObjHdr, bool bCoordBlockDataOnly, wig=& ppoCoordBlock);
    public virtual int syc=(eyU= fp);
    public virtual int tCc=(eyU= fp);
    public virtual string xiY=();
    public virtual void tSc=(Stream fsOut);
    public virtual int UyU=();
    public virtual void VCU=(int value);
    public virtual rio= ViU=();
    public virtual void VyU=(rio= value);
    public virtual int WSU=();
    public virtual rio= WiU=();
    public virtual short WyU=();
    public virtual short XCU=();
    public virtual int XSU=();
    public virtual void XiU=(short val);
    public virtual void XyU=(short val);
    public virtual void YCU=(int clr);
    public virtual string YSU=(double dfAngle);
    public virtual void YiU=(string pszStyleString);
    public virtual void YyU=(Stream fpOut);
}
internal enum 8RQ=.0iE= : Enum {
    public int value__;
    public static 0iE= 0yE=;
    public static 0iE= 1CE=;
}
internal class 8RQ=.0xg= : Txo= {
    internal double 1Bg=;
    internal double xRg=;
    internal double xhg=;
    internal double 1Rg=;
    internal int zBg=;
    internal int 1hg=;
    internal 0xg=(string id, string desc);
    private void uhg=();
    internal virtual hRg= uxg=(hRg= pjConsts, Int32& pj_Error);
    internal virtual void whg=(XRg= lp, hRg= pjConsts, EBg= fac, Int32& pj_Error);
    internal virtual XRg= wBg=(XBo= xy, hRg= pjConsts, Int32& pj_Error);
    internal virtual XBo= wRg=(XRg= lp, hRg= pjConsts, Int32& pj_Error);
}
internal class 8RQ=.0xo= : object {
    private static 0xo= 1Bo=;
    private GeoJsonSerializeStrategy 1Ro=;
    public static 0xo= 1xo= { get; }
    public GeoJsonSerializeStrategy 2ho= { get; public set; }
    public static 0xo= 1ho=();
    public GeoJsonSerializeStrategy 2Bo=();
    public void 2Ro=(GeoJsonSerializeStrategy value);
    public string 2xo=(XElement xElement);
    public string 3Bo=(object obj);
    public XElement 3Ro=(object obj);
    public XElement 3ho=(string json);
    public XElement 3ho=(string json, Encoding encoding);
    public T 3xo=(XElement xElement);
    public T 4Bo=(string json, Encoding encoding);
    private static string 4Ro=(XElement element);
    private static XAttribute 4ho=(GeoJsonType type);
    private object 4xo=(object obj);
    private IEnumerable`1<XElement> 5Bo=(object obj);
    private static string 5Ro=(PropertyInfo property);
    private IEnumerable`1<XElement> 5ho=(T obj);
    private GeoJsonType 5xo=(object obj);
    [CompilerGeneratedAttribute]
private XElement <CreateXArray>b__20_0(object o);
}
internal static class 8RQ=.0yI= : object {
    public static double 1CI=(xiI= rectangle);
    public static double 1SI=(xiI= rectangle);
    public static double 1iI=(xiI= rectangle);
    public static double 1yI=(xiI= rectangle);
    public static double 2CI=(xiI= rectangle);
    public static xiI= 2SI=(xiI= rectangle);
    public static xiI= 2iI=(xiI= rectangle);
    public static xiI= 2yI=(xiI= rectangle);
    public static xiI= 3CI=(xiI= rectangle);
}
internal class 8RQ=.1C4= : object {
    [CompilerGeneratedAttribute]
private string 1S4=;
    [CompilerGeneratedAttribute]
private PointShape 1i4=;
    [CompilerGeneratedAttribute]
private xy4= 1y4=;
    public string 2i4= { get; public set; }
    public PointShape 3S4= { get; public set; }
    public xy4= 4C4= { get; public set; }
    [CompilerGeneratedAttribute]
public string 2C4=();
    [CompilerGeneratedAttribute]
public void 2S4=(string value);
    [CompilerGeneratedAttribute]
public PointShape 2y4=();
    [CompilerGeneratedAttribute]
public void 3C4=(PointShape value);
    [CompilerGeneratedAttribute]
public xy4= 3i4=();
    [CompilerGeneratedAttribute]
public void 3y4=(xy4= value);
}
internal class 8RQ=.1hY= : object {
    internal static String[] 1xY=;
    internal static String[] 2BY=;
    internal static String[] 2RY=;
    internal static List`1<String[]> 2hY=;
    internal List`1<1hY=> 2xY=;
    internal 1hY= 3BY=;
    internal string 3RY=;
    internal 1hY=(string nodeValue);
    private static 1hY=();
    internal 1hY= 3hY=(string nodeName);
    internal int 3xY=(string nodeValue);
    internal void 4BY=();
    internal 1hY= 4RY=();
    private bool 4hY=();
    internal string bxY=();
    internal void 4xY=(Char[] wktCharArray, Int32& processedIndex);
    internal void 5BY=(string node, String[] mappingTable, int srcIndex, int dstIndex, int stepSize);
    internal void 5BY=(string node, String[] mappingTable, int srcIndex, int dstIndex, int stepSize, bool childOfHit);
    internal void 5RY=(string nodeValue);
    internal void txY=();
    private int 5hY=(String[] list, string target);
}
internal class 8RQ=.1i0= : object {
    [CompilerGeneratedAttribute]
private int 1y0=;
    [CompilerGeneratedAttribute]
private int 2C0=;
    public int 2y0= { get; public set; }
    public int 3i0= { get; public set; }
    public 1i0=(int x, int y);
    [CompilerGeneratedAttribute]
public int 2S0=();
    [CompilerGeneratedAttribute]
public void 2i0=(int value);
    [CompilerGeneratedAttribute]
public int 3C0=();
    [CompilerGeneratedAttribute]
public void 3S0=(int value);
    public virtual string ToString();
}
internal class 8RQ=.1ic= : 0Ck= {
    protected byte 1yc=;
    public byte 2Cc=;
    private static int hCQ=;
    private static int hSQ=;
    private static int hiQ=;
    private static int hyQ=;
    private Qig= 2Sc=;
    public int MyU= { get; public set; }
    public cCg= NiU= { get; public set; }
    public 1ic=(yCY= poDefnIn);
    public virtual NCg= ric=();
    public virtual GSg= sCc=(yCY= poNewDefn);
    public virtual int sSc=(5yg= poMapFile, lSk= poObjHdr, bool bCoordBlockDataOnly, wig=& ppoCoordBlock);
    public virtual int sic=(5yg= poMapFile, lSk= poObjHdr, bool bCoordBlockDataOnly, wig=& ppoCoordBlock);
    public virtual int syc=(eyU= fp);
    public virtual int tCc=(eyU= fp);
    public virtual string xiY=();
    public byte 2ic=();
    public void 2yc=(byte nStyle);
    public virtual int MSU=();
    public virtual void MiU=(int value);
    public virtual cCg= NCU=();
    public virtual void NSU=(cCg= value);
    public virtual int NyU=();
    public virtual cCg= OCU=();
    public virtual string OSU=();
    public virtual void OiU=(string pszName);
    public virtual void OyU=(Stream fpOut);
}
internal class 8RQ=.1ik= : PointBaseStyle {
    private static int 1yk=;
    private static int 2Ck=;
    private static int 2Sk=;
    private static int 2ik=;
    private static int 2yk=;
    private static int /xQ=;
    private static int ARU=;
    private static int AhU=;
    private static int AxU=;
    private static int ABU=;
    private static double 3Ck=;
    private static int BhU=;
    private static int BBU=;
    private static int 3Sk=;
    private static int 3ik=;
    private static int 3yk=;
    [ObfuscationAttribute]
private int symbolNumber;
    [ObfuscationAttribute]
private GeoBrush characterBrush;
    [ObfuscationAttribute]
private GeoFont characterFont;
    [ObfuscationAttribute]
private int characterIndex;
    [ObfuscationAttribute]
private GeoImage image;
    [ObfuscationAttribute]
private double imageScale;
    [ObfuscationAttribute]
private PointType pointType;
    [ObfuscationAttribute]
private Dictionary`2<float, GeoFont> wingdingsFontCache;
    public int 4ik= { get; public set; }
    public 1ik=(GeoImage image, GeoFont characterFont, int characterIndex, GeoSolidBrush characterSolidBrush, PointType pointType, int symbolNumber, GeoSolidBrush symbolSolidBrush, GeoPen symbolPen, int symbolSize);
    public int 4Ck=();
    public void 4Sk=(int value);
    protected virtual void DrawCore(IEnumerable`1<Feature> features, GeoCanvas canvas, Collection`1<SimpleCandidate> labelsInThisLayer, Collection`1<SimpleCandidate> labelsInAllLayers);
    private void 4yk=(Feature feature, GeoCanvas canvas, GeoPen geoPen, GeoBrush geoBrush);
    private void 5Ck=(Feature feature, GeoCanvas canvas, GeoPen geoPen, GeoBrush geoBrush);
    private void 5Sk=(Feature feature, GeoCanvas canvas, GeoPen geoPen, GeoBrush geoBrush);
    private void 5ik=(Feature feature, GeoCanvas canvas, GeoPen geoPen, GeoBrush geoBrush);
    private void 5yk=(Feature feature, GeoCanvas canvas, GeoPen geoPen, GeoBrush geoBrush);
    private void 6Ck=(Feature feature, GeoCanvas canvas, GeoPen geoPen, GeoBrush geoBrush, int pixelOffset);
    private GeoFont 6Sk=();
    private void 6ik=(Feature feature, GeoCanvas canvas, GeoPen geoPen, GeoBrush geoBrush);
    private void 6yk=(Feature feature, GeoCanvas canvas, GeoPen geoPen, GeoBrush geoBrush, int pixelOffset);
    private void 7Ck=(PointShape point, GeoCanvas canvas);
    private int 7Sk=(Byte[] centerPointWkb, int startIndex, GeoCanvas canvas, GeoPen geoPen, GeoBrush geoBrush, int pixelOffset);
    private int 7ik=(Byte[] centerPointWkb, int startIndex, GeoCanvas canvas, GeoPen geoPen, GeoBrush geoBrush);
    private static int FBU=(Byte[] wkb, int startIndex, byte byteOrder);
    private void 7yk=(int indexOfCharacter, Feature feature, GeoCanvas canvas, GeoBrush geoBrush, GeoPen haloPen);
    private void 8Ck=(int indexOfCharacter, PointShape point, GeoCanvas canvas, GeoBrush geoBrush, GeoPen haloPen);
    private void 8Sk=(Feature feature, GeoCanvas canvas, GeoPen geoPen);
    private int 8ik=(Byte[] centerPointWkb, int startIndex, GeoCanvas canvas, GeoPen geoPen);
    private void 8yk=(Feature feature, GeoCanvas canvas, GeoPen geoPen, GeoBrush geoBrush);
    private void 9Ck=(Feature feature, GeoCanvas canvas, GeoPen geoPen, GeoBrush geoBrush, int pixelOffset);
    private void 9Sk=(Feature feature, GeoCanvas canvas, GeoPen geoPen, GeoBrush geoBrush);
    private int 9ik=(Byte[] centerPointWkb, int startIndex, GeoCanvas canvas, GeoPen geoPen, GeoBrush geoBrush);
    private int 9yk=(Byte[] centerPointWkb, int startIndex, GeoCanvas canvas, GeoPen geoPen, GeoBrush geoBrush, int pixelOffset);
    private static double FRU=(Byte[] wkb, int startIndex, byte byteOrder);
    private bool /Ck=(double screenX, double screenY, float canvasWidth, float canvasHeight);
    private static void QR0=(Byte[] sourceArray, Byte[] destinateArray, long destinateIndex);
    private void /Sk=(Feature feature, GeoCanvas canvas);
    private void /ik=(Feature feature, GeoCanvas canvas, GeoPen geoPen, GeoBrush geoBrush, float widthScale, float heightScale);
    private void /yk=(Feature feature, GeoCanvas canvas, GeoPen geoPen, GeoBrush geoBrush);
    private void ACo=(Feature feature, GeoCanvas canvas, GeoPen geoPen, GeoBrush geoBrush);
    private void ASo=(Feature feature, GeoCanvas canvas, GeoPen geoPen, GeoBrush geoBrush, ScreenPointF[] points);
    private void Aio=(Feature feature, GeoCanvas canvas, GeoPen geoPen, ScreenPointF[] points);
    private void Ayo=(Feature feature, GeoCanvas canvas, GeoPen geoPen, GeoBrush geoBrush);
    private void BCo=(Feature feature, GeoCanvas canvas, GeoPen geoPen, GeoBrush geoBrush);
    private void BSo=(Feature feature, GeoCanvas canvas, GeoPen geoPen, GeoBrush geoBrush);
    private void Bio=(Feature feature, GeoCanvas canvas, GeoPen geoPen, GeoBrush geoBrush);
    private void Byo=(String[] pointsCollection, Feature feature, GeoCanvas canvas, GeoPen geoPen, GeoBrush geoBrush);
    private void CCo=(Feature feature, GeoCanvas canvas, GeoPen geoPen, GeoBrush geoBrush);
    private void CSo=(Feature feature, GeoCanvas canvas, GeoPen geoPen, GeoBrush geoBrush);
    private void Cio=(Feature feature, GeoCanvas canvas, GeoPen geoPen, GeoBrush geoBrush);
    private void Cyo=(Feature feature, GeoCanvas canvas, GeoPen geoPen, GeoBrush geoBrush);
    private void DCo=(Feature feature, GeoCanvas canvas, GeoPen geoPen, GeoBrush geoBrush);
    private void DSo=(Feature feature, GeoCanvas canvas, GeoPen geoPen, GeoBrush geoBrush);
    private void Dio=(Feature feature, GeoCanvas canvas, GeoPen geoPen, GeoBrush geoBrush);
    private void Dyo=(Feature feature, GeoCanvas canvas, GeoPen geoPen, GeoBrush geoBrush);
    private void ECo=(Feature feature, GeoCanvas canvas, GeoPen geoPen, GeoBrush geoBrush);
    private void ESo=(Feature feature, GeoCanvas canvas, GeoPen geoPen, GeoBrush geoBrush);
    private void Eio=(Feature feature, GeoCanvas canvas, GeoPen geoPen, GeoBrush geoBrush);
    private void Eyo=(Feature feature, GeoCanvas canvas, GeoPen geoPen, GeoBrush geoBrush);
}
internal class 8RQ=.1iY= : object {
    public bool 1yY=;
    public int lBU=;
    public double 2CY=;
    public string 2SY=;
    public List`1<int> 2iY=;
    public List`1<double> 2yY=;
    public List`1<string> 3CY=;
    public List`1<byte> 3SY=;
    public 3yY= 3iY=;
    public object 4RY=();
}
internal class 8RQ=.1xg= : Txo= {
    internal double 2Bg=;
    internal int zBg=;
    internal 1xg=(string id, string desc);
    private void uhg=();
    internal virtual hRg= uxg=(hRg= pjConsts, Int32& pj_Error);
    internal virtual void whg=(XRg= lp, hRg= pjConsts, EBg= fac, Int32& pj_Error);
    internal virtual XRg= wBg=(XBo= xy, hRg= pjConsts, Int32& pj_Error);
    internal virtual XBo= wRg=(XRg= lp, hRg= pjConsts, Int32& pj_Error);
}
internal enum 8RQ=.1yo= : Enum {
    public int value__;
    public static 1yo= 2Co=;
    public static 1yo= 2So=;
    public static 1yo= 2io=;
}
internal class 8RQ=.2Cw= : object {
    [CompilerGeneratedAttribute]
private double 2Sw=;
    [CompilerGeneratedAttribute]
private int 2iw=;
    [CompilerGeneratedAttribute]
private int 2yw=;
    public double 3iw= { get; public set; }
    public int 4Sw= { get; public set; }
    public int 5Cw= { get; public set; }
    public 2Cw=(double splitBaseNumber, int subdivisionBaseNumber, int rTreeMaxNode);
    [CompilerGeneratedAttribute]
public void 3Sw=(double value);
    [CompilerGeneratedAttribute]
public double 3Cw=();
    [CompilerGeneratedAttribute]
public void 4Cw=(int value);
    [CompilerGeneratedAttribute]
public int 3yw=();
    [CompilerGeneratedAttribute]
public void 4yw=(int value);
    [CompilerGeneratedAttribute]
public int 4iw=();
}
internal class 8RQ=.2Rg= : Txo= {
    internal FRc=[] 2hg=;
    internal double 2xg=;
    internal double 3Bg=;
    internal int Rhc=;
    internal 2Rg=(string id, string desc);
    private void uhg=();
    internal virtual hRg= uxg=(hRg= pjConsts, Int32& pj_Error);
    internal virtual void whg=(XRg= lp, hRg= pjConsts, EBg= fac, Int32& pj_Error);
    internal virtual XRg= wBg=(XBo= xy, hRg= pjConsts, Int32& pj_Error);
    internal virtual XBo= wRg=(XRg= lp, hRg= pjConsts, Int32& pj_Error);
    private XRg= zxg=(XBo= xy, hRg= pjConsts, Int32& pj_Error);
    private XBo= 0hg=(XRg= lp, hRg= pjConsts, Int32& pj_Error);
    private FRc= 3Rg=(FRc= z, FRc=[] C, int n, FRc= der);
    private FRc= 3hg=(FRc= z, FRc=[] C, int n);
}
internal abstract class 8RQ=.2Rw= : object {
    private static NumberFormatInfo 2hw=;
    protected int lRw=;
    protected object 2xw=;
    private bool 3Bw=;
    private string 3Rw=;
    public int 3xw= { get; }
    public object 4Rw= { get; }
    public bool 5Bw= { get; public set; }
    public string 5xw= { get; public set; }
    public string 6Rw= { get; }
    public 2Rw=(int line);
    private static 2Rw=();
    public int 3hw=();
    public object 4Bw=();
    public bool 4hw=();
    public void 4xw=(bool value);
    public string 5Rw=();
    public void 5hw=(string value);
    public virtual bool Equals(object other);
    public bool bRU=(string s);
    public bool bRU=(char c);
    public static bool uRM=(2Rw= t, object o);
    public static bool uhM=(2Rw= t, object o);
    public static bool uRM=(2Rw= t, char c);
    public static bool uhM=(2Rw= t, char c);
    public static bool uRM=(2Rw= t, string s);
    public static bool uhM=(2Rw= t, string s);
    public virtual int GetHashCode();
    public virtual string 6Bw=();
    public object 6hw=(Type t);
}
internal enum 8RQ=.2yo= : Enum {
    public int value__;
    public static 2yo= 3Co=;
    public static 2yo= 3So=;
    public static 2yo= 3io=;
}
internal enum 8RQ=.3Cc= : Enum {
    public int value__;
    public static 3Cc= 3Sc=;
    public static 3Cc= 3ic=;
    public static 3Cc= 3yc=;
}
internal class 8RQ=.3ig= : ValueType {
    public int 3yg=;
    public int 4Cg=;
    public int 4Sg=;
    public int 4ig=;
    public int 4yg=;
    public int 5Cg=;
    public int 5Sg=;
    public int 5ig=;
}
internal class 8RQ=.3SI= : FilterCondition {
    private bool 3iI=;
    internal 3SI=(string columnName, bool operation);
    internal virtual bool 3yI=(KeyValuePair`2<string, string> v);
    internal virtual bool 3yI=(Feature feature);
}
internal enum 8RQ=.3Ss= : Enum {
    public int value__;
    public static 3Ss= 3is=;
    public static 3Ss= 3ys=;
}
internal class 8RQ=.3xg= : Txo= {
    internal int 4Bg=;
    internal int 4Rg=;
    internal 3xg=(string id, string desc);
    private void uhg=();
    internal virtual hRg= uxg=(hRg= pjConsts, Int32& pj_Error);
    internal virtual void whg=(XRg= lp, hRg= pjConsts, EBg= fac, Int32& pj_Error);
    internal virtual XRg= wBg=(XBo= xy, hRg= pjConsts, Int32& pj_Error);
    internal virtual XBo= wRg=(XRg= lp, hRg= pjConsts, Int32& pj_Error);
}
internal class 8RQ=.3y0= : object {
    private BinaryReader 4C0=;
    private BinaryReader 4S0=;
    private BinaryReader 4i0=;
    private BinaryReader 4y0=;
    private BinaryReader 5C0=;
    private BinaryReader 5S0=;
    private tyw= 5i0=;
    private string 5y0=;
    private int 6C0=;
    private double 6S0=;
    private int 6i0=;
    private List`1<string> 6y0=;
    private FeatureLayer 7C0=;
    private Collection`1<string> 7S0=;
    private int vC0=;
    private double iyw=;
    private TinyGeoFileType vy0=;
    public TinyGeoFileType 7y0= { get; }
    public 3y0=(li0= tGeoParameters, 2Cw= parameter, string tGeoPath, int maxNode, double extentWidthLimitation);
    public TinyGeoFileType 7i0=();
    public tyw= NSs=();
    public List`1<Lyw=> 8C0=(Iiw= ReadInfo);
    private static double 8S0=(Vertex source, Vertex des);
    public List`1<Lyw=> axw=(Iiw= ReadInfo);
    public Lyw= aRw=(Iiw= ReadInfo);
    private void 8i0=();
    private static int 8y0=(IEnumerable`1<PolygonShape> polygons);
    public void 9C0=();
    private static void 9S0=(PointShape pointShape, BinaryWriter shapeWriter, BinaryWriter idxWriter);
    private PointShape 9i0=(int index);
    private static void 9y0=(LineShape lineshape, BinaryWriter shapeWriter, BinaryWriter idxWriter);
    private LineShape /C0=(int index);
    private static void /S0=(PolygonShape polygon, BinaryWriter shapeWriter, BinaryWriter idxWriter);
    private PolygonShape /i0=(int index);
    private void /y0=(List`1<yyw=> savers);
    private static Collection`1<RectangleShape> AC4=(RectangleShape totalBoundingBox, double ratio);
    private static RectangleShape AS4=(double minX, double minY, double width, double height);
}
internal enum 8RQ=.3yo= : Enum {
    public int value__;
    public static 3yo= 4Co=;
    public static 3yo= 4So=;
    public static 3yo= 4io=;
}
internal class 8RQ=.3yY= : object {
    public short 4CY=;
    public byte 4SY=;
    public byte 4iY=;
    public byte 4yY=;
    public byte 5CY=;
    public byte 5SY=;
    public byte 5iY=;
    public object 4RY=();
}
internal class 8RQ=.4Cc= : object {
    public string 4Sc=;
    public char 4ic=;
    public byte 4yc=;
    public byte 5Cc=;
    public Tig= 5Sc=;
}
internal enum 8RQ=.4Cs= : Enum {
    public int value__;
    public static 4Cs= PRY=;
    public static 4Cs= 4Ss=;
}
internal class 8RQ=.4hg= : Txo= {
    internal 4hg=(string id, string desc);
    private void uhg=();
    internal virtual hRg= uxg=(hRg= pjConsts, Int32& pj_Error);
    internal virtual void whg=(XRg= lp, hRg= pjConsts, EBg= fac, Int32& pj_Error);
    internal virtual XRg= wBg=(XBo= xy, hRg= pjConsts, Int32& pj_Error);
    internal virtual XBo= wRg=(XRg= lp, hRg= pjConsts, Int32& pj_Error);
}
internal enum 8RQ=.4is= : Enum {
    public int value__;
    public static 4is= 4ys=;
    public static 4is= 5Cs=;
    public static 4is= 5Ss=;
    public static 4is= 5is=;
    public static 4is= 5ys=;
    public static 4is= 6Cs=;
    public static 4is= 6Ss=;
    public static 4is= 6is=;
    public static 4is= 6ys=;
    public static 4is= 7Cs=;
    public static 4is= 7Ss=;
    public static 4is= 7is=;
}
internal class 8RQ=.4R8= : ValueType {
    public ushort 4h8=;
    public ushort 4x8=;
    public bool ZRw=(BinaryReader r);
    public bool cxw=(BinaryWriter w);
    public virtual string ToString();
}
internal class 8RQ=.4S4= : object {
    private long 4h8=;
    private Fy8= 4i4=;
    private Collection`1<By8=> 4y4=;
    private Collection`1<9C4=> 5C4=;
    public long 5y4= { get; public set; }
    internal Fy8= 6i4= { get; internal set; }
    internal Collection`1<By8=> 7S4= { get; internal set; }
    internal Collection`1<9C4=> 8C4= { get; internal set; }
    public long 5S4=();
    public void 5i4=(long value);
    internal Fy8= 6C4=();
    internal void 6S4=(Fy8= value);
    internal Collection`1<By8=> 6y4=();
    internal void 7C4=(Collection`1<By8=> value);
    internal Collection`1<9C4=> 7i4=();
    internal void 7y4=(Collection`1<9C4=> value);
}
internal class 8RQ=.4xg= : Txo= {
    internal int 4Bg=;
    internal int 4Rg=;
    internal 4xg=(string id, string desc);
    private void uhg=();
    internal virtual hRg= uxg=(hRg= pjConsts, Int32& pj_Error);
    internal virtual void whg=(XRg= lp, hRg= pjConsts, EBg= fac, Int32& pj_Error);
    internal virtual XRg= wBg=(XBo= xy, hRg= pjConsts, Int32& pj_Error);
    internal virtual XBo= wRg=(XRg= lp, hRg= pjConsts, Int32& pj_Error);
}
internal class 8RQ=.4yo= : lyQ= {
    protected yyk=[] 5Co=;
    protected int 5So=;
    protected int 5io=;
    protected xSc=[] 5yo=;
    protected int 6Co=;
    protected int 6So=;
    protected cCg=[] 6io=;
    protected int 6yo=;
    protected int 7Co=;
    protected rio=[] 7So=;
    protected int 7io=;
    protected int 7yo=;
    public int 8Co=(vyk= poBlock);
    public int 8So=(vyk= poBlock);
    public yyk= RCU=(int nIndex);
    public int 8io=(yyk= poNewPenDef);
    public int 8yo=();
    public xSc= JCU=(int nIndex);
    public int 9Co=(xSc= poNewBrushDef);
    public int 9So=();
    public cCg= OCU=(int nIndex);
    public int 9io=(cCg= poNewFontDef);
    public int 9yo=();
    public rio= WiU=(int nIndex);
    public int /Co=(rio= poNewSymbolDef);
    public int /So=();
    public int /io=();
}
internal class 8RQ=.5Bg= : Txo= {
    internal int 5Rg=;
    internal 5Bg=(string id, string desc);
    private void uhg=();
    internal virtual hRg= uxg=(hRg= pjConsts, Int32& pj_Error);
    internal virtual void whg=(XRg= lp, hRg= pjConsts, EBg= fac, Int32& pj_Error);
    internal virtual XRg= wBg=(XBo= xy, hRg= pjConsts, Int32& pj_Error);
    internal virtual XBo= wRg=(XRg= lp, hRg= pjConsts, Int32& pj_Error);
}
internal class 8RQ=.5hg= : Txo= {
    internal 5hg=(string id, string desc);
    private void uhg=();
    internal virtual hRg= uxg=(hRg= pjConsts, Int32& pj_Error);
    internal virtual void whg=(XRg= lp, hRg= pjConsts, EBg= fac, Int32& pj_Error);
    internal virtual XRg= wBg=(XBo= xy, hRg= pjConsts, Int32& pj_Error);
    internal virtual XBo= wRg=(XRg= lp, hRg= pjConsts, Int32& pj_Error);
}
internal class 8RQ=.5ic= : lyQ= {
    public Encoding rB4=;
    private string gSU=;
    private Stream 5yc=;
    private oSc= giU=;
    private sio= 6Cc=;
    private XSo= 6Sc=;
    private int 6ic=;
    private 4Cc=[] 6yc=;
    private XSo= 7Cc=;
    private int uyc=;
    private int 7Sc=;
    private int 7ic=;
    private bool 7yc=;
    private int 8Cc=;
    private int 8Sc=;
    private bool 8ic=;
    private string 8yc=;
    private static int nyc=;
    private static int oCc=;
    private static int nic=;
    public string BSY=(int columnNum, int recordNum);
    private int 9Cc=();
    private int 2h4=();
    public int sB4=(string pszFname, FileAccess pszAccess, sio= eTableType);
    public int QB8=();
    public int 9Sc=();
    public Tig= tR4=(int nFieldId);
    public int 9ic=(int nFieldId);
    public int 9yc=(int nFieldId);
    public int /Cc=(int iField, string pszName, Tig= eType, int nWidth, int nPrecision);
    public int /Sc=(string pszName, Tig= eType, int nWidth, int nPrecision);
    public int /ic=();
    public XSo= /yc=(int nRecordId);
    public bool ACg=();
    public int ASg=();
    public string Aig=(int nWidth);
    public int Ayg=(int nWidth);
    public short BCg=(int nWidth);
    public double BSg=(int nWidth);
    public double Big=(int nWidth);
    public string Byg=(int nWidth);
    public string CCg=(int nWidth);
    public string CSg=(int nWidth);
    public string Cig=(int nWidth);
    public int Cyg=(string pszStr, int nWidth, lCg= poINDFile, int nIndexNo);
    public int DCg=(int nValue, lCg= poINDFile, int nIndexNo);
    public int DSg=(short nValue, lCg= poINDFile, int nIndexNo);
    public int Dig=(float dValue, lCg= poINDFile, int nIndexNo);
    public int Dyg=(double dValue, int nWidth, int nPrecision, lCg= poINDFile, int nIndexNo);
    public int ECg=(string pszValue, lCg= poINDFile, int nIndexNo);
    public int ESg=(string pszValue, lCg= poINDFile, int nIndexNo);
    public int Eig=(string pszValue, lCg= poINDFile, int nIndexNo);
    public int Eyg=(string pszValue, lCg= poINDFile, int nIndexNo);
    public sealed virtual void Dispose();
}
internal class 8RQ=.5iE= : Exception {
}
internal class 8RQ=.5SE= : Exception {
    public 5SE=(string message);
}
internal static class 8RQ=.5SI= : object {
    internal static Style ahU=(JsonElement typeElement, JsonElement paintElement, JsonElement layoutElement, int zoomLevel);
    private static AreaStyle 5iI=(JsonElement paint, int zoomLevel);
    private static LineStyle 5yI=(JsonElement paint, int zoomLevel);
    private static TextStyle 6CI=(JsonElement paint, JsonElement layout, int zoomLevel);
    private static string 6SI=(JsonElement element, int zoomLevel);
    private static float 6iI=(JsonElement element, int zoomLevel);
    private static Collection`1<float> 6yI=(JsonElement element, int zoomLevel);
    private static T 7CI=(JsonElement element, int zoomLevel, Func`3<JsonElement, int, T> parseMethod);
    private static T 7SI=(JsonElement element, int zoomLevel, Func`3<JsonElement, int, T> parseMethod);
    public static GeoColor 7iI=(JsonElement colorElement, JsonElement fillOpacityElement, int zoomLevel);
    private static string 7yI=(JsonElement textFontElement);
}
internal class 8RQ=.5Sw= : object {
    private int 5iw=;
    private double iyw=;
    [CompilerGeneratedAttribute]
private List`1<Lyw=> 5yw=;
    [CompilerGeneratedAttribute]
private int 6Cw=;
    [CompilerGeneratedAttribute]
private short 6Sw=;
    [CompilerGeneratedAttribute]
private short 6iw=;
    public List`1<Lyw=> 7Sw= { get; public set; }
    public int 8Cw= { get; private set; }
    public short 8yw= { get; private set; }
    public short 9iw= { get; private set; }
    public 5Sw=(double extentWidthLimitation);
    [CompilerGeneratedAttribute]
public void 7Cw=(List`1<Lyw=> value);
    [CompilerGeneratedAttribute]
public List`1<Lyw=> 6yw=();
    [CompilerGeneratedAttribute]
private void 7yw=(int value);
    [CompilerGeneratedAttribute]
public int 7iw=();
    [CompilerGeneratedAttribute]
private void 8iw=(short value);
    [CompilerGeneratedAttribute]
public short 8Sw=();
    [CompilerGeneratedAttribute]
private void 9Sw=(short value);
    [CompilerGeneratedAttribute]
public short 9Cw=();
    public bool 9yw=(double LoCenter, double LaCenter, int BitsPerCoord, Dictionary`2<string, int> lableDictnory);
}
internal class 8RQ=.5xg= : Txo= {
    internal double thg=;
    internal double 6Bg=;
    internal double 6Rg=;
    internal double xxg=;
    internal Double[] uBg=;
    internal 5xg=(string id, string desc);
    private void uhg=();
    internal virtual hRg= uxg=(hRg= pjConsts, Int32& pj_Error);
    internal virtual void whg=(XRg= lp, hRg= pjConsts, EBg= fac, Int32& pj_Error);
    private XBo= 0hg=(XRg= lp, hRg= pjConsts, Int32& pj_Error);
    private XBo= 0Bg=(XRg= lp, hRg= pjConsts, Int32& pj_Error);
    private XRg= zxg=(XBo= xy, hRg= pjConsts, Int32& pj_Error);
    private XRg= zRg=(XBo= xy, hRg= pjConsts, Int32& pj_Error);
    internal virtual XRg= wBg=(XBo= xy, hRg= pjConsts, Int32& pj_Error);
    internal virtual XBo= wRg=(XRg= lp, hRg= pjConsts, Int32& pj_Error);
}
internal class 8RQ=.5xY= : ValueType {
    internal string 6BY=;
    internal string 6RY=;
    internal int 6hY=;
    internal int 6xY=;
}
internal class 8RQ=.5yE= : Exception {
}
internal class 8RQ=.5yg= : lyQ= {
    private static int nyc=;
    private static int oCc=;
    private static int nic=;
    public Encoding rB4=;
    private int 6Cg=;
    private Stream 5yc=;
    private oSc= giU=;
    private uic= lSg=;
    private KSk= 6Sg=;
    private SSk= 6ig=;
    private bool 6yg=;
    private jyg= 7Cg=;
    private fCk= 7Sg=;
    private int 7ig=;
    private int 7yg=;
    private int 8Cg=;
    private wig= 8Sg=;
    private 4yo= 8ig=;
    private /yo= 8yg=;
    private /yo= 9Cg=;
    private int 9Sg=;
    private int 9ig=;
    private int 9yg=;
    private int /Cg=;
    private SSk= /Sg=;
    private int /ig=(bool bDeleteObjects);
    private int /yg=(int nBlockPtr);
    private fCk= ACk=(lSk= poObjHdrToAdd, int nSizeOfObjToAdd);
    private int ASk=(lSk= poObjHdr, wig= poSrcCoordBlock, fCk= poDstObjBlock, wig= ppoDstCoordBlock);
    private int Aik=(int nObjType, fCk= poObjBlock, wig=& ppoCoordBlock);
    private int Ayk=();
    private int BCk=();
    private int BSk=();
    private int Bik=(int bFirstObject);
    private XSo= Byk=(int nFileOffset);
    public int sB4=(string pszFname, FileAccess pszAccess, bool bNoErrorMsg);
    public int QB8=();
    public int CCk=(bool bQuickSpatialIndexMode);
    public int CSk=(int nX, int nY, Double& dX, Double& dY);
    public int Cik=(double dX, double dY, Int32& nX, Int32& nY, bool bIgnoreOverflow);
    public int Cyk=(int nX, int nY, Double& dX, Double& dY);
    public int DCk=(double dX, double dY, Int32& nX, Int32& nY);
    public void DSk=(/yo= sMin, /yo= sMax);
    public void Dik=(/yo=& sMin, /yo=& sMax);
    public void Dyk=();
    public int ECk=(double dXMin, double dYMin, double dXMax, double dYMax);
    public int ESk=(int nObjId);
    public void Eik=(byte nObjType);
    public int Eyk=(lSk= poObjHdr);
    public int FCk=(lSk= poObjHdr);
    public int FSk=(lSk= poObjHdr);
    public int Fik=(lSk= poObjHdr);
    public void Fyk=();
    public int GCk=(int nPrevId);
    public int GSk=();
    public int Gik=();
    public fCk= Gyk=();
    public wig= HCk=();
    public wig= HSk=(int nFileOffset);
    public KSk= Hik=();
    public XSo= Hyk=(int nFileOffset);
    public int ICk=(int nPenIndex, yyk= psDef);
    public int ISk=(int nBrushIndex, xSc= psDef);
    public int Iik=(int nFontIndex, cCg= psDef);
    public int Iyk=(int nSymbolIndex, rio= psDef);
    public int JCk=(yyk= psDef);
    public int JSk=(xSc= psDef);
    public int Jik=(cCg= psDef);
    public int Jyk=(rio= psDef);
    public int KCk=();
    public sealed virtual void Dispose();
}
internal class 8RQ=.5yY= : object {
    private string 6CY=;
    private USY= 6SY=;
    private int 6iY=;
    private int 6yY=;
    public 5yY=(string pszNameIn, USY= eTypeIn);
    private void oRw=(string pszNameIn, USY= eTypeIn);
    public void 7CY=(string pszNameIn);
    public string 7SY=();
    public USY= 7iY=();
    public static string 7yY=(USY= eType);
    public int HxU=();
    public void 8CY=(int nWidthIn);
    public int 8SY=();
    public void 8iY=(int nPrecisionIn);
}
internal class 8RQ=.6Bo= : object {
    public static double 6Ro=(double rad);
    public static double 6ho=(double degree);
    public static float 6xo=(Byte[] bs, int startIndex);
}
internal class 8RQ=.6CE= : Exception {
}
internal class 8RQ=.6hg= : Txo= {
    internal double 6xg=;
    internal double Rhc=;
    internal double ghg=;
    internal double 7Bg=;
    internal double sRg=;
    internal double Fhc=;
    internal double shg=;
    internal double 7Rg=;
    internal double 7hg=;
    internal double 7xg=;
    internal Double[] uBg=;
    internal 6hg=(string id, string desc);
    private void uhg=();
    internal virtual hRg= uxg=(hRg= pjConsts, Int32& pj_Error);
    internal virtual void whg=(XRg= lp, hRg= pjConsts, EBg= fac, Int32& pj_Error);
    private XBo= 0hg=(XRg= lp, hRg= pjConsts, Int32& pj_Error);
    private XBo= 0Bg=(XRg= lp, hRg= pjConsts, Int32& pj_Error);
    private XRg= zxg=(XBo= xy, hRg= pjConsts, Int32& pj_Error);
    private XRg= zRg=(XBo= xy, hRg= pjConsts, Int32& pj_Error);
    internal virtual XRg= wBg=(XBo= xy, hRg= pjConsts, Int32& pj_Error);
    internal virtual XBo= wRg=(XRg= lp, hRg= pjConsts, Int32& pj_Error);
}
internal class 8RQ=.6iA= : object {
    private static HyE= 6yA=;
    private NiE= 7CA=;
    private bool 7SA=;
    private ESE=[] eRw=;
    private EyE= 7iA=;
    private long 7yA=;
    private bool tx0=;
    public bool 8iA= { get; public set; }
    public bool 9SA= { get; public set; }
    public char /CA= { get; public set; }
    public Nullable`1<char> /yA= { get; public set; }
    public EyE= AiE= { get; public set; }
    public long BCE= { get; }
    public bool BiE= { get; }
    public IEnumerable`1<ESE=> CCE= { get; }
    public 6iA=(string pathFilename);
    public 6iA=(string pathFilename, Encoding encoding);
    public 6iA=(Stream stream);
    public 6iA=(Stream stream, Encoding encoding);
    public 6iA=(Stream stream, Encoding encoding, bool leaveOpen);
    public 6iA=(TextReader textReader);
    public 6iA=(TextReader textReader, bool leaveOpen);
    private static 6iA=();
    public bool 8CA=();
    public void 8SA=(bool value);
    public bool 8yA=();
    public void 9CA=(bool value);
    public char 9iA=();
    public void 9yA=(char value);
    public Nullable`1<char> /SA=();
    public void /iA=(Nullable`1<char> value);
    public EyE= ACE=();
    public void ASE=(EyE= value);
    public long AyE=();
    public bool BSE=();
    public static 6iA= CSE=(string csv);
    [IteratorStateMachineAttribute("8RQ=.6iA=/<get_DataRecords>d__35")]
public IEnumerable`1<ESE=> ByE=();
    public bool CiE=();
    public bool CiE=(bool incrementRecordNumber);
    public int CyE=(int count);
    public int CyE=(int count, bool incrementRecordNumber);
    public EyE= DCE=();
    public ESE= DSE=();
    public int DiE=(ESE=[] buffer, int offset, int count);
    public void QB8=();
    public sealed virtual void Dispose();
    protected virtual void Dispose(bool disposing);
    private void DyE=();
    private void ECE=();
}
internal class 8RQ=.6iE= : Exception {
}
internal class 8RQ=.6SE= : Exception {
}
internal class 8RQ=.6xk= : Txo= {
    internal double thg=;
    internal double 7Bk=;
    internal double 7Rk=;
    internal int zBg=;
    internal 6xk=(string id, string desc);
    private void uhg=();
    internal virtual hRg= uxg=(hRg= pjConsts, Int32& pj_Error);
    internal virtual void whg=(XRg= lp, hRg= pjConsts, EBg= fac, Int32& pj_Error);
    internal virtual XRg= wBg=(XBo= xy, hRg= pjConsts, Int32& pj_Error);
    internal virtual XBo= wRg=(XRg= lp, hRg= pjConsts, Int32& pj_Error);
}
internal class 8RQ=.6xw= : 2Rw= {
    public string 6Rw= { get; }
    public 6xw=(int line);
    public virtual string ToString();
    public virtual bool Equals(object other);
    public virtual string 6Bw=();
    public virtual int GetHashCode();
}
internal class 8RQ=.6yE= : Exception {
}
internal class 8RQ=.7Bo= : object {
    private static UInt32 7Ro=;
    private static UInt32 7ho=;
    private static UInt32 7xo=;
    private static UInt32 8Bo=;
    private static UInt32 8Ro=;
    private static UInt32 8ho=;
    private static UInt32 8xo=;
    private static UInt32 9Bo=;
    private static UInt32 9Ro=;
    private static UInt32 9ho=;
    private static UInt32 9xo=;
    private static double mRc=;
    private static double mhc=;
    private static int /Bo=;
    private static int /Ro=;
    private static int /ho=;
    private static int /xo=;
    private static int ABs=;
    private static int ARs=;
    private static int Ahs=;
    private static int Axs=;
    private static int BBs=;
    private static int BRs=;
    private static int Bhs=;
    private static int Bxs=;
    private static int CBs=;
    private static int CRs=;
    private static int Chs=;
    private static int Cxs=;
    private static int DBs=;
    private static int DRs=;
    private static int Dhs=;
    private static int Dxs=;
    private static int EBs=;
    private static int ERs=;
    private static int Ehs=;
    private static int Exs=;
    private static int FBs=;
    private static int FRs=;
    private static int Fhs=;
    private static double Fxs=;
    private static double GBs=;
    private static bool GRs=;
    private static bool Ghs=;
    private static double IRY=;
    private static double Ihc=;
    private static double Gxs=;
    private static double HBs=;
    private static double HRs=;
    private static double Hhs=;
    private static double Hxs=;
    private static double IBs=;
    private static double IRs=;
    private static double Ihs=;
    private static double Ixs=;
    private double JBs=;
    private double JRs=;
    private double Jhs=;
    private string Jxs=;
    private static string KBs=;
    private static string KRs=;
    private static string Khs=;
    private static string Kxs=;
    internal static ET0=[] LBs=;
    private static Fj0=[] LRs=;
    private static 7Bo=();
    public bool Lhs=(string mgrs, Double& Latitude, Double& Longitude);
    public bool Lxs=(double Latitude, double Longitude, String& mgrs);
    private long MBs=(int letter, Double& min_northing);
    private long MRs=(long letter, Double& north, Double& south);
    private long Mhs=(double latitude, Int32& letter);
    private long Mxs=(string MGRS, Boolean& zone_exists);
    private long NBs=(double _value);
    private long NRs=(String& MGRS, int Zone, Int32[] Letters, double Easting, double Northing, int Precision);
    private long Nhs=(string MGRS, Int32& Zone, Int32[]& Letters, Double& Easting, Double& Northing, Int32& Precision);
    private void Nxs=(int zone, Int32& ltr2_low_value, Int32& ltr2_high_value, Double& false_northing);
    internal long OBs=(int Zone, double Latitude, double Easting, double Northing, int Precision, String& MGRS);
    public long ORs=(double a, double f, string Ellipsoid_Code);
    private void Ohs=(Double& a, Double& f, String& Ellipsoid_Code);
    internal long Oxs=(double Latitude, double Longitude, int Precision, String& MGRS);
    internal long PBs=(string MGRS, Double& Latitude, Double& Longitude);
    internal long PRs=(int Zone, char Hemisphere, double Easting, double Northing, int Precision, String& MGRS);
    internal long Phs=(string MGRS, Int32& Zone, Char& Hemisphere, Double& Easting, Double& Northing);
    internal long Pxs=(char Hemisphere, double Easting, double Northing, int Precision, String& MGRS);
    internal long QBs=(string MGRS, Char& Hemisphere, Double& Easting, Double& Northing);
}
internal class 8RQ=.7Bw= : 2Rw= {
    public string 6Rw= { get; }
    public 7Bw=(int line);
    public virtual string ToString();
    public virtual bool Equals(object other);
    public virtual string 6Bw=();
    public virtual int GetHashCode();
}
internal class 8RQ=.7BY= : object {
    private string 7RY=;
    private string 7hY=;
    private XmlDocument 7xY=;
    private XmlNodeList 8BY=;
    internal XmlNodeList 8hY= { get; }
    internal 7BY=(string baseInfoFile, string xmlPath);
    internal XmlNodeList 8RY=();
    private bool 8xY=();
    internal XmlNode 9BY=(string xmlKeyField, string xmlKeyWord);
}
[DefaultMemberAttribute("Item")]
internal class 8RQ=.7CE= : object {
    private Double[0...,0...] 7SE=;
    public double gxw= { get; public set; }
    public int 8CE= { get; public set; }
    public int 8yE= { get; public set; }
    public Double[0...,0...] 9SE= { get; }
    public 7CE=(int noRows, int noCols);
    public 7CE=(Double[0...,0...] Mat);
    public double gRw=(int Row, int Col);
    public void ghw=(int Row, int Col, double value);
    public int 7iE=();
    public void 7yE=(int value);
    public int 8SE=();
    public void 8iE=(int value);
    public Double[0...,0...] 9CE=();
    private static void 9iE=(Double[] Mat, Int32& Row);
    private static void 9iE=(Double[0...,0...] Mat, Int32& Row, Int32& Col);
    public static Double[0...,0...] 9yE=(Double[] Mat);
    public static Double[] /CE=(Double[0...,0...] Mat);
    public static Double[0...,0...] /SE=(int n);
    public static Double[0...,0...] /iE=(Double[0...,0...] Mat1, Double[0...,0...] Mat2);
    public static 7CE= /iE=(7CE= Mat1, 7CE= Mat2);
    public static 7CE= rhM=(7CE= Mat1, 7CE= Mat2);
    public static Double[0...,0...] /yE=(Double[0...,0...] Mat1, Double[0...,0...] Mat2);
    public static 7CE= /yE=(7CE= Mat1, 7CE= Mat2);
    public static 7CE= sBM=(7CE= Mat1, 7CE= Mat2);
    public static Double[0...,0...] ACI=(Double[0...,0...] Mat1, Double[0...,0...] Mat2);
    public static 7CE= ACI=(7CE= Mat1, 7CE= Mat2);
    public static 7CE= shM=(7CE= Mat1, 7CE= Mat2);
    public static double ASI=(Double[0...,0...] Mat);
    public static double ASI=(7CE= Mat);
    public static Double[0...,0...] AiI=(Double[0...,0...] Mat);
    public static 7CE= AiI=(7CE= Mat);
    public static Double[0...,0...] AyI=(Double[0...,0...] Mat);
    public static 7CE= AyI=(7CE= Mat);
    public static void BCI=(Double[0...,0...] Mat_, Double[0...,0...]& S_, Double[0...,0...]& U_, Double[0...,0...]& V_);
    private static double BSI=(double a);
    private static double BiI=(double a, double b);
    private static double ByI=(double a, double b);
    public static void BCI=(7CE= Mat, 7CE=& S, 7CE=& U, 7CE=& V);
    public static void CCI=(Double[0...,0...] Mat, Double[0...,0...]& L, Double[0...,0...]& U, Double[0...,0...]& P);
    private static void CSI=(Double[0...,0...] Mat, int Row, int toRow);
    public static void CCI=(7CE= Mat, 7CE=& L, 7CE=& U, 7CE=& P);
    public static Double[0...,0...] CiI=(Double[0...,0...] MatA, Double[0...,0...] MatB);
    public static 7CE= CiI=(7CE= MatA, 7CE= MatB);
    public static int CyI=(Double[0...,0...] Mat);
    public static int CyI=(7CE= Mat);
    public static Double[0...,0...] DCI=(Double[0...,0...] Mat);
    public static 7CE= DCI=(7CE= Mat);
    public static void DSI=(Double[0...,0...] Mat, Double[0...,0...]& d, Double[0...,0...]& v);
    private static void DiI=(double g, double h, double s, double tau, Double[0...,0...] a, int i, int j, int k, int l);
    public static void DSI=(7CE= Mat, 7CE=& d, 7CE=& v);
    public static Double[0...,0...] DyI=(double Value, Double[0...,0...] Mat);
    public static 7CE= DyI=(double Value, 7CE= Mat);
    public static 7CE= shM=(7CE= Mat, double Value);
    public static 7CE= shM=(double Value, 7CE= Mat);
    public static Double[0...,0...] ECI=(double Value, Double[0...,0...] Mat);
    public static 7CE= ECI=(double Value, 7CE= Mat);
    public static 7CE= wRM=(7CE= Mat, double Value);
    public static Double[] ESI=(Double[] V1, Double[] V2);
    public static Double[0...,0...] ESI=(Double[0...,0...] V1, Double[0...,0...] V2);
    public static 7CE= ESI=(7CE= V1, 7CE= V2);
    public static double EiI=(Double[] V1, Double[] V2);
    public static double EiI=(Double[0...,0...] V1, Double[0...,0...] V2);
    public static double EiI=(7CE= V1, 7CE= V2);
    public static double EyI=(Double[] V);
    public static double EyI=(Double[0...,0...] V);
    public static double EyI=(7CE= V);
    public static bool FCI=(Double[0...,0...] Mat1, Double[0...,0...] Mat2);
    public static bool FCI=(7CE= Mat1, 7CE= Mat2);
    public static bool uRM=(7CE= Mat1, 7CE= Mat2);
    public static bool uhM=(7CE= Mat1, 7CE= Mat2);
    public virtual bool Equals(object obj);
    public static string FSI=(Double[0...,0...] Mat);
    public static string FSI=(7CE= Mat);
    public virtual string ToString();
    public virtual int GetHashCode();
}
internal class 8RQ=.7hk= : Txo= {
    internal Double[] uBg=;
    internal double CRk=;
    internal double Rhc=;
    internal double eRc=;
    internal double ehc=;
    internal 7hk=(string id, string desc);
    private void uhg=();
    internal virtual hRg= uxg=(hRg= pjConsts, Int32& pj_Error);
    internal virtual void whg=(XRg= lp, hRg= pjConsts, EBg= fac, Int32& pj_Error);
    internal virtual XRg= wBg=(XBo= xy, hRg= pjConsts, Int32& pj_Error);
    internal virtual XBo= wRg=(XRg= lp, hRg= pjConsts, Int32& pj_Error);
    private XBo= 0hg=(XRg= lp, hRg= pjConsts, Int32& pj_Error);
    private XBo= 0Bg=(XRg= lp, hRg= pjConsts, Int32& pj_Error);
    private XRg= zxg=(XBo= xy, hRg= pjConsts, Int32& pj_Error);
    private XRg= zRg=(XBo= xy, hRg= pjConsts, Int32& pj_Error);
}
internal class 8RQ=.7hw= : 7Rw= {
    public 7hw=(string s);
    public 7hw=(string s, int line);
}
internal abstract class 8RQ=.7Rw= : 2Rw= {
    public string 6Rw= { get; }
    public 7Rw=(string s);
    public 7Rw=(string s, int line);
    public virtual string ToString();
    public virtual string 6Bw=();
    public virtual int GetHashCode();
}
internal class 8RQ=.7xk= : Txo= {
    internal double 8Bk=;
    internal double sRg=;
    internal double 8Rk=;
    internal double 8hk=;
    internal double 8xk=;
    internal double 9Bk=;
    internal 7xk=(string id, string desc);
    private void uhg=();
    internal virtual hRg= uxg=(hRg= pjConsts, Int32& pj_Error);
    internal virtual void whg=(XRg= lp, hRg= pjConsts, EBg= fac, Int32& pj_Error);
    internal virtual XRg= wBg=(XBo= xy, hRg= pjConsts, Int32& pj_Error);
    internal virtual XBo= wRg=(XRg= lp, hRg= pjConsts, Int32& pj_Error);
}
internal class 8RQ=.7xw= : 7Rw= {
    public 7xw=(string s);
    public 7xw=(string s, int line);
}
internal class 8RQ=.7ys= : ValueType {
    public static double 8Cs=;
    public static double 8Ss=;
    public static double 8is=;
    public static double 8ys=;
    public static double 9Cs=;
    public static double 9Ss=;
    public static double 9is=;
    public static double 9ys=;
    public static double /Cs=;
    public static double /Ss=;
    public static double /is=;
    public static double /ys=;
    public static double ACw=;
    public static double ASw=;
    public static double Aiw=;
    public static double Ayw=;
    public static double BCw=;
    public static double BSw=;
    public static double Biw=;
    public static double Byw=;
    public static double CCw=;
    public static double CSw=;
    public static double Ciw=;
    public static double Cyw=;
    public static double DCw=;
    public static double DSw=;
    public static double Diw=;
    public static double Dyw=;
    public static double ECw=;
    public static double ESw=;
    public static double Eiw=;
    public static double Eyw=;
    public static double FCw=;
    public static double FSw=;
    public static double Fiw=;
    public static double Fyw=;
    private static 7ys=();
}
internal class 8RQ=.8Bg= : Txo= {
    internal double 8Rg=;
    internal 8Bg=(string id, string desc);
    private void uhg=();
    internal virtual hRg= uxg=(hRg= pjConsts, Int32& pj_Error);
    internal virtual void whg=(XRg= lp, hRg= pjConsts, EBg= fac, Int32& pj_Error);
    internal virtual XRg= wBg=(XBo= xy, hRg= pjConsts, Int32& pj_Error);
    internal virtual XBo= wRg=(XRg= lp, hRg= pjConsts, Int32& pj_Error);
}
internal static class 8RQ=.8BQ= : object {
    public static string 7xQ=(IEnumerable`1<string> source, string delimiter);
}
internal class 8RQ=.8Bw= : 7Rw= {
    public 8Bw=(string s);
    public 8Bw=(string s, int line);
}
internal class 8RQ=.8hg= : Txo= {
    internal double 8xg=;
    internal Double[] 9Bg=;
    internal 8hg=(string id, string desc);
    private void uhg=();
    internal virtual hRg= uxg=(hRg= pjConsts, Int32& pj_Error);
    internal virtual void whg=(XRg= lp, hRg= pjConsts, EBg= fac, Int32& pj_Error);
    private XRg= zxg=(XBo= xy, hRg= pjConsts, Int32& pj_Error);
    private XRg= zRg=(XBo= xy, hRg= pjConsts, Int32& pj_Error);
    private XBo= 0hg=(XRg= lp, hRg= pjConsts, Int32& pj_Error);
    private XBo= 0Bg=(XRg= lp, hRg= pjConsts, Int32& pj_Error);
    internal virtual XRg= wBg=(XBo= xy, hRg= pjConsts, Int32& pj_Error);
    internal virtual XBo= wRg=(XRg= lp, hRg= pjConsts, Int32& pj_Error);
}
internal class 8RQ=.8hw= : 2Rw= {
    public string 6Rw= { get; }
    public 8hw=(string s, int line);
    public 8hw=(char c);
    public 8hw=(char c, int line);
    public virtual string ToString();
    public virtual int GetHashCode();
    public virtual string 6Bw=();
    public virtual bool Equals(object other);
}
internal class 8RQ=.8Rw= : 7Rw= {
    public 8Rw=(string s);
    public 8Rw=(string s, int line);
}
internal class 8RQ=.8S4= : object {
    public static 4S4= ahU=(BinaryReader br);
    private static Fy8= myg=(BinaryReader br);
    private static 9C4= 8i4=(BinaryReader br);
    private static By8= Zxw=(BinaryReader br);
    public static DataType 7iY=(BinaryReader br);
}
internal class 8RQ=.8xw= : 2Rw= {
    public string 6Rw= { get; }
    public 8xw=(string s);
    public 8xw=(float f);
    public 8xw=(double d);
    public 8xw=(string s, int line);
    public 8xw=(double f, int line);
    public virtual string ToString();
    public virtual int GetHashCode();
    public virtual string 6Bw=();
    public virtual bool Equals(object other);
}
internal class 8RQ=.8y4= : object {
}
internal abstract class 8RQ=.8yY= : object {
    private OSc= 9CY=;
    protected int 9SY=;
    public abstract virtual 8yY= 9iY=();
    public abstract virtual void 9yY=(qyY= psEnvelope);
    public virtual int /CY=();
    public abstract virtual OiY= /SY=(String& ppszDstText);
    public abstract virtual PyY= /iY=();
    public abstract virtual string /yY=();
    public virtual void ACc=(int nNewDimension);
    public void ASc=(OSc= poSR);
    public OSc= Aic=();
    public virtual int Ayc=(8yY= poOtherGeom);
}
internal class 8RQ=.9Bw= : 2Rw= {
    public string 6Rw= { get; }
    public 9Bw=(int i);
    public 9Bw=(long i);
    public 9Bw=(string s);
    public 9Bw=(string s, int line);
    public 9Bw=(int i, int line);
    public 9Bw=(long l, int line);
    public static 9Bw= 9Rw=(string s, int lineNumber);
    private void ahU=(string s);
    public virtual string ToString();
    public virtual int GetHashCode();
    public virtual string 6Bw=();
    public virtual bool Equals(object other);
}
internal class 8RQ=.9C4= : object {
    private string 9S4=;
    private string 9i4=;
    private string 9y4=;
    private string yC4=;
    private string yS4=;
    private string yi4=;
    private string /C4=;
    private string /S4=;
    public string AC8= { get; public set; }
    public string Ay8= { get; public set; }
    public string zS4= { get; public set; }
    public string 0C4= { get; public set; }
    public string 0y4= { get; public set; }
    public string cC4= { get; public set; }
    public string Bi8= { get; public set; }
    public string /i4=();
    public void /y4=(string value);
    public string AS8=();
    public void Ai8=(string value);
    public string yy4=();
    public void zC4=(string value);
    public string zi4=();
    public void zy4=(string value);
    public string 0S4=();
    public void 0i4=(string value);
    public string bi4=();
    public void by4=(string value);
    public string BC8=();
    public void BS8=(string value);
    public void ZRw=(BinaryReader reader);
}
internal enum 8RQ=.9hw= : Enum {
    public int value__;
    public static 9hw= 9xw=;
    public static 9hw= /Bw=;
    public static 9hw= /Rw=;
    public static 9hw= /hw=;
}
internal class 8RQ=.9Rg= : Txo= {
    internal XBo= 9hg=;
    internal double 9xg=;
    internal double /Bg=;
    internal double /Rg=;
    internal 9Rg=(string id, string desc);
    private void uhg=();
    internal virtual hRg= uxg=(hRg= pjConsts, Int32& pj_Error);
    internal virtual void whg=(XRg= lp, hRg= pjConsts, EBg= fac, Int32& pj_Error);
    internal virtual XRg= wBg=(XBo= xy, hRg= pjConsts, Int32& pj_Error);
    internal virtual XBo= wRg=(XRg= lp, hRg= pjConsts, Int32& pj_Error);
}
internal class 8RQ=.9Rk= : Txo= {
    internal double 9hk=;
    internal double 9xk=;
    internal double /Bk=;
    internal double /Rk=;
    internal int zBg=;
    internal 9Rk=(string id, string desc);
    private void uhg=();
    internal virtual hRg= uxg=(hRg= pjConsts, Int32& pj_Error);
    internal virtual void whg=(XRg= lp, hRg= pjConsts, EBg= fac, Int32& pj_Error);
    internal virtual XRg= wBg=(XBo= xy, hRg= pjConsts, Int32& pj_Error);
    internal virtual XBo= wRg=(XRg= lp, hRg= pjConsts, Int32& pj_Error);
    private double /hk=(double phit, double sinphi, double eccen, Int32& pj_Error);
    private XBo= 0hg=(XRg= lp, hRg= pjConsts, Int32& pj_Error);
    private XBo= 0Bg=(XRg= lp, hRg= pjConsts, Int32& pj_Error);
    private XRg= zxg=(XBo= xy, hRg= pjConsts, Int32& pj_Error);
    private XRg= zRg=(XBo= xy, hRg= pjConsts, Int32& pj_Error);
}
internal static class 8RQ=.9RY= : object {
    private static double 9hY=;
    private static 9RY=();
    internal static double 9xY=(double lon, Int32& pj_Error);
    internal static double /BY=(double phi, double sphi, double cphi, Double[] en);
    internal static double /RY=(double v, Int32& pj_Error);
    internal static double /hY=(double arg, double es, Double[] en, Int32& pj_Error);
    internal static Double[] /xY=(double es);
    internal static Double[] ABc=(double es);
    internal static double ARc=(double beta, Double[] APA, Int32& pj_Error);
    internal static double Ahc=(double n, double d, Int32& pj_Error);
    internal static double Axc=(double v, Int32& pj_Error);
    internal static double BBc=(double sinphi, double e, double one_es, Int32& pj_Error);
    internal static double BRc=(double v, Int32& pj_Error);
    internal static double Bhc=(double sinphi, double cosphi, double es, Int32& pj_Error);
    internal static double Bxc=(double phi, double sinphi, double e, Int32& pj_Error);
    internal static double CBc=(double ts, double e, Int32& pj_Error);
    internal static gRg= CRc=(Dictionary`2<string, string> paras, string param, Int32& pj_Error);
    internal static double Chc=(string p, Int32& pj_Error);
    internal static double Cxc=(string handleStr, String& tempStr);
    internal static string DBc=(string lineStr);
    internal static Stream DRc=(string filePath, FileAccess readWriteMode);
    internal static bool Dhc=();
    internal static void Dxc=(Byte[] data, int offsetIndex, int wordSize, int wordCount);
    internal static string EBc=(Byte[] characters, int index, int count);
    internal static int ERc=(Byte[] byteArray, int index, int count, Int32& pj_Error);
    internal static double Ehc=(Byte[] byteArray, int index, int count);
    internal static void Exc=(double x, Int32& pj_Error);
    internal static string FBc=(string param);
}
internal class 8RQ=.ABk= : Txo= {
    internal ABk=(string id, string desc);
    private void uhg=();
    internal virtual hRg= uxg=(hRg= pjConsts, Int32& pj_Error);
    internal virtual void whg=(XRg= lp, hRg= pjConsts, EBg= fac, Int32& pj_Error);
    internal virtual XRg= wBg=(XBo= xy, hRg= pjConsts, Int32& pj_Error);
    internal virtual XBo= wRg=(XRg= lp, hRg= pjConsts, Int32& pj_Error);
}
internal class 8RQ=.ACs= : ECU= {
    private string gSU=;
    private oSc= giU=;
    private List`1<string> Wig=;
    private string ASs=;
    private List`1<string> Ais=;
    private List`1<WSg=> Ays=;
    private int BCs=;
    private int BSs=;
    private List`1<string> Bis=;
    private List`1<string> Bys=;
    private iCo= CCs=;
    private bool CSs=;
    private int qCo=(string pszFname, bool bTestOpenNoError);
    private int Cis=(string pszFname);
    private int Cys=(string pszDatasetPath, bool bTestOpenNoError);
    private int Zyg=();
    public virtual int Close();
    public virtual int GetFeatureCount(bool bForce);
    public virtual void ResetReading();
    public virtual int Open(string pszFname, FileAccess pszAccess, bool bTestOpenNoError);
    public virtual int SetQuickSpatialIndexMode(bool bQuickSpatialIndexMode);
    public virtual int GetNextFeatureId(int nPrevId);
    public virtual GSg= GetFeatureRef(int nFeatureId);
    public virtual int SetFeature(GSg= poFeature, int nFeatureId);
    public virtual yCY= GetLayerDefn();
    public virtual int SetFeatureDefn(yCY= poFeatureDefn, List`1<Tig=> paeMapInfoNativeFieldTypes);
    public virtual Tig= GetNativeFieldType(int nFieldId);
    public virtual int AddFieldNative(string pszName, Tig= eMapInfoType, int nWidth, int nPrecision, bool bIndexed, bool bUnique);
    public virtual int SetFieldIndexed(int nFieldId);
    public virtual bool IsFieldIndexed(int nFieldId);
    public virtual bool IsFieldUnique(int nFieldId);
    public virtual int GetBounds(Double& dXMin, Double& dYMin, Double& dXMax, Double& dYMax, bool bForce);
    public virtual OiY= GetExtent(qyY= psExtent, bool bForce);
    public virtual int GetFeatureCountByType(Int32& numPoints, Int32& numLines, Int32& numRegions, Int32& numTexts, bool bForce);
    public virtual OSc= GetSpatialRef();
    public virtual int SetSpatialRef(OSc= poSpatialRef);
    public virtual int SetBounds(double dXMin, double dYMin, double dXMax, double dYMax);
    public virtual bool TestCapability(string pszCap);
}
internal class 8RQ=.aDE= : FilterCondition {
    private string 3iI=;
    internal aDE=(string columnName, string operation, string expression);
    internal virtual bool 3yI=(KeyValuePair`2<string, string> value);
    internal virtual bool 3yI=(Feature feature);
    private bool aTE=(string parameter, Double& value);
    private bool ajE=(string inputValue, Double& filterValue);
}
internal class 8RQ=.Ahk= : Txo= {
    internal XBo= 9hg=;
    internal double 9xg=;
    internal double /Bg=;
    internal double /Rg=;
    internal Ahk=(string id, string desc);
    private void uhg=();
    internal virtual hRg= uxg=(hRg= pjConsts, Int32& pj_Error);
    internal virtual void whg=(XRg= lp, hRg= pjConsts, EBg= fac, Int32& pj_Error);
    internal virtual XRg= wBg=(XBo= xy, hRg= pjConsts, Int32& pj_Error);
    internal virtual XBo= wRg=(XRg= lp, hRg= pjConsts, Int32& pj_Error);
}
internal class 8RQ=.ahs= : object {
    private double axs=;
    private double bBs=;
    public double bxs= { get; public set; }
    public double chs= { get; public set; }
    public ahs=(double easting, double northing);
    public double bRs=();
    public void bhs=(double value);
    public double cBs=();
    public void cRs=(double value);
    public virtual string ToString();
}
internal class 8RQ=.ai0= : object {
    private double iyw=;
    [CompilerGeneratedAttribute]
private int ay0=;
    [CompilerGeneratedAttribute]
private byte bC0=;
    [CompilerGeneratedAttribute]
private int bS0=;
    [CompilerGeneratedAttribute]
private int bi0=;
    [CompilerGeneratedAttribute]
private ushort by0=;
    [CompilerGeneratedAttribute]
private ushort cC0=;
    public int cy0= { get; private set; }
    public byte di0= { get; private set; }
    public int eS0= { get; private set; }
    public int fC0= { get; private set; }
    public ushort fy0= { get; private set; }
    public ushort gi0= { get; private set; }
    public ai0=(double extentWidthLimitation);
    [CompilerGeneratedAttribute]
private void ci0=(int value);
    [CompilerGeneratedAttribute]
public int cS0=();
    [CompilerGeneratedAttribute]
private void dS0=(byte value);
    [CompilerGeneratedAttribute]
public byte dC0=();
    [CompilerGeneratedAttribute]
private void eC0=(int value);
    [CompilerGeneratedAttribute]
public int dy0=();
    [CompilerGeneratedAttribute]
private void ey0=(int value);
    [CompilerGeneratedAttribute]
public int ei0=();
    [CompilerGeneratedAttribute]
private void fi0=(ushort value);
    [CompilerGeneratedAttribute]
public ushort fS0=();
    [CompilerGeneratedAttribute]
private void gS0=(ushort value);
    [CompilerGeneratedAttribute]
public ushort gC0=();
    public void EC0=(int featureDataOffset, byte objectType, LC0= subdivision);
}
internal class 8RQ=.ai4= : object {
    private int ay4=;
    private int TC4=;
    private int rBM=;
    public int Ci4= { get; }
    public int ii0= { get; }
    public int jS0= { get; }
    public int CC4=();
    public int iC0=();
    public int iy0=();
    public void ZRw=(Stream stream, int rgnOffset);
}
internal class 8RQ=.Ai4= : object {
    [CompilerGeneratedAttribute]
private string SC0=;
    [CompilerGeneratedAttribute]
private int Ay4=;
    [CompilerGeneratedAttribute]
private int BC4=;
    [CompilerGeneratedAttribute]
private int 6Cw=;
    public string UC0= { get; public set; }
    public int By4= { get; public set; }
    public int Ci4= { get; public set; }
    public int 8Cw= { get; public set; }
    [CompilerGeneratedAttribute]
public string Ti0=();
    [CompilerGeneratedAttribute]
public void Ty0=(string value);
    [CompilerGeneratedAttribute]
public int BS4=();
    [CompilerGeneratedAttribute]
public void Bi4=(int value);
    [CompilerGeneratedAttribute]
public int CC4=();
    [CompilerGeneratedAttribute]
public void CS4=(int value);
    [CompilerGeneratedAttribute]
public int 7iw=();
    [CompilerGeneratedAttribute]
public void 7yw=(int value);
}
internal class 8RQ=.ai8= : object {
    private Collection`1<1C4=> ay8=;
    private Dictionary`2<string, string> aiM=;
    private BaseShape bC8=;
    private long 4h8=;
    public long 5y4= { get; public set; }
    public string XRQ= { get; public set; }
    public Collection`1<1C4=> bi8= { get; }
    public Dictionary`2<string, string> /x8= { get; }
    public BaseShape cS8= { get; public set; }
    public long 5S4=();
    public void 5i4=(long value);
    public string WxQ=();
    public void XBQ=(string value);
    public Collection`1<1C4=> bS8=();
    public Dictionary`2<string, string> /h8=();
    private RectangleShape ci8=();
    public BaseShape by8=();
    public void cC8=(BaseShape value);
}
internal enum 8RQ=.aig= : Enum {
    public int value__;
    public static aig= ayg=;
    public static aig= bCg=;
    public static aig= bSg=;
    public static aig= big=;
    public static aig= byg=;
}
internal static class 8RQ=.aiQ= : object {
    public static int ayQ=;
    [ThreadStaticAttribute]
public static List`1<string> bCQ=;
    [ThreadStaticAttribute]
public static int bSQ=;
    private static aiQ=();
    public static List`1<string> biQ=(List`1<string> papszStrList, string pszNewString);
    public static int byQ=(List`1<string> papszStrList);
    public static string cCQ=(List`1<string> papszStrList, int iField);
    public static string cSQ=(List`1<string> papszStrList, string pszName);
    public static void ciQ=(List`1<string> papszStrList);
    public static int 5hY=(List`1<string> papszList, string pszTarget);
    public static List`1<string> cyQ=(string pszString);
    public static List`1<string> dCQ=(string pszString, string pszDelimiters, bool bHonourStrings, bool bAllowEmptyTokens);
    public static List`1<string> dSQ=(string pszString, string pszDelimiters, int nCSLTFlags);
    public static string diQ=(string fmt, Object[] vaList);
    public static string dyQ=(int nBytes, Byte[] pabyData);
}
internal class 8RQ=.aiU= : object {
    public int ayU=;
    public string bCU=;
    public int bSU=;
    public double biU=;
    public double byU=;
    public double cCU=;
    public double cSU=;
    public double ciU=;
    public double cyU=;
    public double dCU=;
    public double dSU=;
    public aiU=(int nMapInfoDatumID, string pszOGCDatumName, int nEllipsoid, double dfShiftX, double dfShiftY, double dfShiftZ, double dfDatumParm0, double dfDatumParm1, double dfDatumParm2, double dfDatumParm3, double dfDatumParm4);
}
internal class 8RQ=.aiw= : object {
    private int ayw=;
    private bool bCw=;
    [CompilerGeneratedAttribute]
private yyw= bSw=;
    [CompilerGeneratedAttribute]
private int biw=;
    [CompilerGeneratedAttribute]
private giw= byw=;
    [CompilerGeneratedAttribute]
private ushort TCw=;
    [CompilerGeneratedAttribute]
private ushort cCw=;
    public yyw= cyw= { get; public set; }
    public int diw= { get; private set; }
    public giw= eSw= { get; public set; }
    public ushort Uyw= { get; public set; }
    public ushort fCw= { get; public set; }
    public aiw=(RectangleShape box);
    public aiw=(yyw= saver);
    [CompilerGeneratedAttribute]
public void ciw=(yyw= value);
    [CompilerGeneratedAttribute]
public yyw= cSw=();
    [CompilerGeneratedAttribute]
private void dSw=(int value);
    [CompilerGeneratedAttribute]
public int dCw=();
    [CompilerGeneratedAttribute]
public giw= dyw=();
    [CompilerGeneratedAttribute]
public void eCw=(giw= value);
    [CompilerGeneratedAttribute]
public void Uiw=(ushort value);
    [CompilerGeneratedAttribute]
public ushort USw=();
    [CompilerGeneratedAttribute]
public void eyw=(ushort value);
    [CompilerGeneratedAttribute]
public ushort eiw=();
    public double fSw=(aiw= pREntry, bool isLeaf);
    private double fiw=(aiw= pREntry, bool isLeaf);
    private double fyw=(aiw= pREntry);
    public void gCw=(giw= childNode);
    public void gSw=(int nodeIndex, int entryIndex, List`1& rTree);
}
internal class 8RQ=.ARk= : Txo= {
    internal ARk=(string id, string desc);
    private void uhg=();
    internal virtual hRg= uxg=(hRg= pjConsts, Int32& pj_Error);
    internal virtual void whg=(XRg= lp, hRg= pjConsts, EBg= fac, Int32& pj_Error);
    internal virtual XRg= wBg=(XBo= xy, hRg= pjConsts, Int32& pj_Error);
    internal virtual XBo= wRg=(XRg= lp, hRg= pjConsts, Int32& pj_Error);
}
internal class 8RQ=.ARo= : Txo= {
    internal int Nxc=;
    internal Double[] Aho=;
    internal double Axo=;
    internal double BBo=;
    internal double BRo=;
    internal /xk=[] uBg=;
    internal ARo=(string id, string desc);
    private void uhg=();
    internal virtual hRg= uxg=(hRg= pjConsts, Int32& pj_Error);
    internal virtual void whg=(XRg= lp, hRg= pjConsts, EBg= fac, Int32& pj_Error);
    internal virtual XRg= wBg=(XBo= xy, hRg= pjConsts, Int32& pj_Error);
    internal virtual XBo= wRg=(XRg= lp, hRg= pjConsts, Int32& pj_Error);
    private double Bho=(double esinp, double exp, Int32& pj_Error);
    private /xk= Bxo=(double e, double phi0, Double[] chi, Double[] rc, Int32& pj_Error);
    private XRg= CBo=(XRg= slp, /xk=[] en, Int32& pj_Error);
    private XRg= CRo=(XRg= elp, /xk=[] en, Int32& pj_Error);
}
internal class 8RQ=.Axk= : Txo= {
    internal double eRc=;
    internal double ehc=;
    internal double BBk=;
    internal double BRk=;
    internal Axk=(string id, string desc);
    private void uhg=();
    internal virtual hRg= uxg=(hRg= pjConsts, Int32& pj_Error);
    internal virtual void whg=(XRg= lp, hRg= pjConsts, EBg= fac, Int32& pj_Error);
    internal virtual XRg= wBg=(XBo= xy, hRg= pjConsts, Int32& pj_Error);
    internal virtual XBo= wRg=(XRg= lp, hRg= pjConsts, Int32& pj_Error);
}
internal abstract class 8RQ=.azE= : object {
    protected static string bDE=;
    protected static string bTE=;
    protected static string bjE=;
    protected static string bzE=;
    protected static string cDE=;
    protected static string cTE=;
    protected static string cjE=;
    protected static string czE=;
    protected static string dDE=;
    protected static Dictionary`2<string, FilterCondition> dTE=;
    public abstract virtual StyleJsonDocument ahU=(JObject jsonObject);
    protected static Dictionary`2<int, GeoColor> djE=(JObject jsonObject);
    protected static string dzE=(string styleNodeFilter, string filter);
    protected static Style eDE=(JObject propertyObject, FilterApplyMode& styleFilterApplyMode);
    protected static void eTE=(JToken jToken, Dictionary`2<string, string> variables);
}
internal class 8RQ=.bC4= : object {
    [CompilerGeneratedAttribute]
private int 6Cw=;
    [CompilerGeneratedAttribute]
private List`1<1i0=> 5yw=;
    [CompilerGeneratedAttribute]
private string bS4=;
    public int 8Cw= { get; public set; }
    public List`1<1i0=> 7Sw= { get; public set; }
    public string cC4= { get; public set; }
    [CompilerGeneratedAttribute]
public int 7iw=();
    [CompilerGeneratedAttribute]
public void 7yw=(int value);
    [CompilerGeneratedAttribute]
public List`1<1i0=> 6yw=();
    [CompilerGeneratedAttribute]
public void 7Cw=(List`1<1i0=> value);
    [CompilerGeneratedAttribute]
public string bi4=();
    [CompilerGeneratedAttribute]
public void by4=(string value);
}
internal abstract class 8RQ=.bCc= : object {
    private int bSc=;
    private double bic=;
    private VCY= byc=;
    private WyY= cCc=;
    private string tSY=;
    public bCc=(WyY= eClassId);
    public abstract virtual int ahU=();
    public int ahU=(RSc=[] pasStyle, SCc=[] pasValue, int nCount);
    public void cSc=();
    public int cic=();
    public void cyc=();
    public WyY= 7iY=();
    public void dCc=(string pszString);
    public void dSc=(VCY= eUnit, double dfScale);
    public VCY= dic=();
    public void xyY=(string pszStyleString);
    public string VCc=(RSc= sStyleParam, SCc= sStyleValue, Int32& bValueIsNull);
    public double Yyc=(RSc= sStyleParam, SCc= sStyleValue, Int32& bValueIsNull);
    public void dyc=(RSc= sStyleParam, SCc= sStyleValue, string pszParamString);
    public double eCc=(double dfValue, VCY= eInputUnit);
    public int eCc=(int nValue, VCY= eUnit);
}
internal class 8RQ=.BCc= : 8yY= {
    private int BSc=;
    private 8yY=[] Bic=;
    public virtual string /yY=();
    public virtual PyY= /iY=();
    public virtual 8yY= 9iY=();
    public virtual OiY= /SY=(String& ppszDstText);
    public virtual void 9yY=(qyY= psEnvelope);
    public int Byc=();
    public 8yY= CCc=(int i);
    public virtual OiY= CSc=(8yY= poNewGeom);
    public virtual OiY= Cic=(8yY= poNewGeom);
    public virtual OiY= Cyc=(int iGeom, int bDelete);
}
internal class 8RQ=.Bhk= : Txo= {
    internal Bhk=(string id, string desc);
    private void uhg=();
    internal virtual hRg= uxg=(hRg= pjConsts, Int32& pj_Error);
    internal virtual void whg=(XRg= lp, hRg= pjConsts, EBg= fac, Int32& pj_Error);
    internal virtual XRg= wBg=(XBo= xy, hRg= pjConsts, Int32& pj_Error);
    internal virtual XBo= wRg=(XRg= lp, hRg= pjConsts, Int32& pj_Error);
}
internal enum 8RQ=.BiY= : Enum {
    public int value__;
    public static BiY= ByY=;
    public static BiY= CCY=;
    public static BiY= CSY=;
    public static BiY= CiY=;
    public static BiY= CyY=;
    public static BiY= DCY=;
    public static BiY= DSY=;
    public static BiY= DiY=;
    public static BiY= DyY=;
    public static BiY= ECY=;
    public static BiY= ESY=;
    public static BiY= EiY=;
}
internal class 8RQ=.Bxk= : Txo= {
    internal Bxk=(string id, string desc);
    private void uhg=();
    internal virtual hRg= uxg=(hRg= pjConsts, Int32& pj_Error);
    internal virtual void whg=(XRg= lp, hRg= pjConsts, EBg= fac, Int32& pj_Error);
    internal virtual XRg= wBg=(XBo= xy, hRg= pjConsts, Int32& pj_Error);
    internal virtual XBo= wRg=(XRg= lp, hRg= pjConsts, Int32& pj_Error);
}
internal class 8RQ=.By8= : object {
    private string 9S4=;
    private string CC8=;
    private string CS8=;
    private string Ci8=;
    private string Cy8=;
    private string DC8=;
    private string DS8=;
    private string Di8=;
    public bool EC8= { get; }
    public string Ey8= { get; public set; }
    public string Fi8= { get; public set; }
    public bool Dy8=();
    public string ES8=();
    public void Ei8=(string value);
    public string FC8=();
    public void FS8=(string value);
    public void ZRw=(BinaryReader reader);
}
internal class 8RQ=.byk= : nCk= {
    public int cCk=;
    public int cSk=;
    public int cik=;
    public int Hyg=;
    public int ICg=;
    public int cyk=;
    public int dCk=;
    public int dSk=;
    public byte dik=;
    public byte dyk=;
    public byte eCk=;
    public byte eSk=;
    public virtual int bSk=(fCk= poObjBlock);
    public virtual int bik=(fCk= poObjBlock);
    private int nCQ=(int nGenoType);
}
internal class 8RQ=.CBg= : object {
    internal Txo= CRg=(string projID, string desc, Dictionary`2<string, string> pj_List);
}
internal class 8RQ=.CBk= : Txo= {
    internal Double[] uBg=;
    internal double CRk=;
    internal double Rhc=;
    internal double eRc=;
    internal double ehc=;
    internal CBk=(string id, string desc);
    private void uhg=();
    internal virtual hRg= uxg=(hRg= pjConsts, Int32& pj_Error);
    internal virtual void whg=(XRg= lp, hRg= pjConsts, EBg= fac, Int32& pj_Error);
    internal virtual XRg= wBg=(XBo= xy, hRg= pjConsts, Int32& pj_Error);
    internal virtual XBo= wRg=(XRg= lp, hRg= pjConsts, Int32& pj_Error);
}
internal class 8RQ=.cBw= : object {
    protected static int cRw=;
    protected WkbByteOrder chw=;
    public cBw=(WkbByteOrder encodingType);
    public virtual Byte[] cxw=(BaseShape geometry);
    public virtual void cxw=(BaseShape geometry, Stream stream);
    protected void cxw=(BaseShape geometry, BinaryWriter writer);
    protected void dBw=(BinaryWriter writer);
    protected void cxw=(Vertex coordinate, BinaryWriter writer);
    protected void cxw=(PointShape point, BinaryWriter writer);
    protected void cxw=(LineShape lineString, BinaryWriter writer);
    protected void cxw=(RingShape ring, BinaryWriter writer);
    protected void cxw=(PolygonShape polygon, BinaryWriter writer);
    protected void cxw=(MultipointShape multiPoint, BinaryWriter writer);
    protected void cxw=(MultilineShape multiLineString, BinaryWriter writer);
    protected void cxw=(MultipolygonShape multiPolygon, BinaryWriter writer);
    protected void cxw=(GeometryCollectionShape geomCollection, BinaryWriter writer);
    protected Byte[] yhM=(BaseShape geometry);
    protected virtual int dRw=(BaseShape geometry);
    protected int dRw=(GeometryCollectionShape geometry);
    protected int dRw=(MultipolygonShape geometry);
    protected int dRw=(MultilineShape geometry);
    protected int dRw=(MultipointShape geometry);
    protected int dRw=(PolygonShape geometry);
    protected int dRw=(LineShape geometry);
    protected int dRw=(PointShape geometry);
    private static int dhw=(PolygonShape polygon);
    [CompilerGeneratedAttribute]
private int <SetByteStream>b__19_0(BaseShape geom);
    [CompilerGeneratedAttribute]
private int <SetByteStream>b__20_0(PolygonShape geom);
    [CompilerGeneratedAttribute]
private int <SetByteStream>b__21_0(LineShape geom);
    [CompilerGeneratedAttribute]
private int <SetByteStream>b__22_0(PointShape geom);
}
internal class 8RQ=.cCg= : object {
    public int ySY=;
    public string cSg=;
    public cCg=(int nRefCount, string szFontName);
}
internal enum 8RQ=.Chg= : Enum {
    public int value__;
    public static Chg= Cxg=;
    public static Chg= DBg=;
    public static Chg= DRg=;
    public static Chg= Dhg=;
    public static Chg= Dxg=;
}
internal class 8RQ=.chk= : Txo= {
    internal chk=(string id, string desc);
    private void uhg=();
    internal virtual hRg= uxg=(hRg= pjConsts, Int32& pj_Error);
    internal virtual void whg=(XRg= lp, hRg= pjConsts, EBg= fac, Int32& pj_Error);
    internal virtual XRg= wBg=(XBo= xy, hRg= pjConsts, Int32& pj_Error);
    internal virtual XBo= wRg=(XRg= lp, hRg= pjConsts, Int32& pj_Error);
}
internal class 8RQ=.Chk= : Txo= {
    internal double Cxk=;
    internal Chk=(string id, string desc);
    private void uhg=();
    internal virtual void whg=(XRg= lp, hRg= pjConsts, EBg= fac, Int32& pj_Error);
    internal virtual hRg= uxg=(hRg= pjConsts, Int32& pj_Error);
    internal virtual XRg= wBg=(XBo= xy, hRg= pjConsts, Int32& pj_Error);
    internal virtual XBo= wRg=(XRg= lp, hRg= pjConsts, Int32& pj_Error);
}
internal class 8RQ=.Cho= : Txo= {
    internal double 8Rg=;
    internal Cho=(string id, string desc);
    private void uhg=();
    internal virtual hRg= uxg=(hRg= pjConsts, Int32& pj_Error);
    internal virtual void whg=(XRg= lp, hRg= pjConsts, EBg= fac, Int32& pj_Error);
    internal virtual XRg= wBg=(XBo= xy, hRg= pjConsts, Int32& pj_Error);
    internal virtual XBo= wRg=(XRg= lp, hRg= pjConsts, Int32& pj_Error);
}
internal class 8RQ=.ci4= : object {
    [CompilerGeneratedAttribute]
private int cy4=;
    [CompilerGeneratedAttribute]
private int dC4=;
    [CompilerGeneratedAttribute]
private byte dS4=;
    [CompilerGeneratedAttribute]
private int bS0=;
    [CompilerGeneratedAttribute]
private int bi0=;
    [CompilerGeneratedAttribute]
private long by0=;
    [CompilerGeneratedAttribute]
private long cC0=;
    [CompilerGeneratedAttribute]
private byte di4=;
    [CompilerGeneratedAttribute]
private int xi0=;
    [CompilerGeneratedAttribute]
private int xy0=;
    [CompilerGeneratedAttribute]
private int yC0=;
    [CompilerGeneratedAttribute]
private int yS0=;
    public int eS4= { get; public set; }
    public int fC4= { get; public set; }
    public byte fy4= { get; public set; }
    public int eS0= { get; public set; }
    public int fC0= { get; public set; }
    public long fy0= { get; public set; }
    public long gi0= { get; public set; }
    public byte gi4= { get; public set; }
    public int zC0= { get; public set; }
    public int zy0= { get; public set; }
    public int 0i0= { get; public set; }
    public int 1S0= { get; public set; }
    [CompilerGeneratedAttribute]
public int dy4=();
    [CompilerGeneratedAttribute]
public void eC4=(int value);
    [CompilerGeneratedAttribute]
public int ei4=();
    [CompilerGeneratedAttribute]
public void ey4=(int value);
    [CompilerGeneratedAttribute]
public byte fS4=();
    [CompilerGeneratedAttribute]
public void fi4=(byte value);
    [CompilerGeneratedAttribute]
public int dy0=();
    [CompilerGeneratedAttribute]
public void eC0=(int value);
    [CompilerGeneratedAttribute]
public int ei0=();
    [CompilerGeneratedAttribute]
public void ey0=(int value);
    [CompilerGeneratedAttribute]
public long fS0=();
    [CompilerGeneratedAttribute]
public void fi0=(long value);
    [CompilerGeneratedAttribute]
public long gC0=();
    [CompilerGeneratedAttribute]
public void gS0=(long value);
    [CompilerGeneratedAttribute]
public byte gC4=();
    [CompilerGeneratedAttribute]
public void gS4=(byte value);
    [CompilerGeneratedAttribute]
public int yi0=();
    [CompilerGeneratedAttribute]
public void yy0=(int value);
    [CompilerGeneratedAttribute]
public int zS0=();
    [CompilerGeneratedAttribute]
public void zi0=(int value);
    [CompilerGeneratedAttribute]
public int 0C0=();
    [CompilerGeneratedAttribute]
public void 0S0=(int value);
    [CompilerGeneratedAttribute]
public int 0y0=();
    [CompilerGeneratedAttribute]
public void 1C0=(int value);
    public bool Uy4=(xS0= range);
}
internal class 8RQ=.cig= : 0Ck= {
    protected double cyg=;
    protected short dCg=;
    private Qig= dSg=;
    private static int hCQ=;
    private static int hSQ=;
    private static int hiQ=;
    private static int hyQ=;
    internal Qig= dyg= { get; }
    public int MyU= { get; public set; }
    public cCg= NiU= { get; public set; }
    public cig=(yCY= poDefnIn);
    internal Qig= dig=();
    public virtual NCg= ric=();
    public virtual GSg= sCc=(yCY= poNewDefn);
    public virtual int sSc=(5yg= poMapFile, lSk= poObjHdr, bool bCoordBlockDataOnly, wig=& ppoCoordBlock);
    public virtual int sic=(5yg= poMapFile, lSk= poObjHdr, bool bCoordBlockDataOnly, wig=& ppoCoordBlock);
    public virtual int syc=(eyU= fp);
    public virtual int tCc=(eyU= fp);
    public virtual string xiY=();
    public int eCg=();
    public void eSg=(int nStyle);
    public int eig=();
    public void eyg=(int nStyle);
    public double fCg=();
    public void fSg=(double dAngle);
    public virtual int MSU=();
    public virtual void MiU=(int value);
    public virtual cCg= NCU=();
    public virtual void NSU=(cCg= value);
    public virtual int NyU=();
    public virtual cCg= OCU=();
    public virtual string OSU=();
    public virtual void OiU=(string pszName);
    public virtual void OyU=(Stream fpOut);
}
internal class 8RQ=.ciM= : object {
    public Collection`1<Feature> cyM=(string FeatureCollectionString);
    private void dCM=(JObject joFeature, Feature& feature);
    private Feature dSM=(JObject joFeature);
    private PointShape diM=(JArray PointCoordinates);
    private LineShape dyM=(JArray LineCoordinates);
    private PolygonShape eCM=(JArray PolygonCoordinates);
    private MultipolygonShape eSM=(JArray MultipolygonCoordinates);
}
internal class 8RQ=.cR8= : object {
    public double ch8=;
    public UB8= cx8=;
    public cR8=(double minDist, UB8= node);
    public sealed virtual int CompareTo(object rhs);
}
internal class 8RQ=.cRU= : object {
    private GeoColor chU=;
    private GeoColor cxU=;
    public GeoColor dhU= { get; public set; }
    public GeoColor eRU= { get; public set; }
    public GeoColor dBU=();
    public void dRU=(GeoColor value);
    public GeoColor dxU=();
    public void eBU=(GeoColor value);
}
internal class 8RQ=.cS4= : object {
    [CompilerGeneratedAttribute]
private List`1<bC4=> 5yw=;
    [CompilerGeneratedAttribute]
private List`1<bC4=> Li0=;
    [CompilerGeneratedAttribute]
private List`1<bC4=> Ly0=;
    [CompilerGeneratedAttribute]
private int bS0=;
    [CompilerGeneratedAttribute]
private int bi0=;
    [CompilerGeneratedAttribute]
private int xi0=;
    [CompilerGeneratedAttribute]
private int xy0=;
    [CompilerGeneratedAttribute]
private int yC0=;
    [CompilerGeneratedAttribute]
private int yS0=;
    public List`1<bC4=> 7Sw= { get; public set; }
    public List`1<bC4=> OC0= { get; public set; }
    public List`1<bC4=> Oy0= { get; public set; }
    public int eS0= { get; public set; }
    public int fC0= { get; public set; }
    public int zC0= { get; public set; }
    public int zy0= { get; public set; }
    public int 0i0= { get; public set; }
    public int 1S0= { get; public set; }
    [CompilerGeneratedAttribute]
public List`1<bC4=> 6yw=();
    [CompilerGeneratedAttribute]
public void 7Cw=(List`1<bC4=> value);
    [CompilerGeneratedAttribute]
public List`1<bC4=> Ni0=();
    [CompilerGeneratedAttribute]
public void Ny0=(List`1<bC4=> value);
    [CompilerGeneratedAttribute]
public List`1<bC4=> OS0=();
    [CompilerGeneratedAttribute]
public void Oi0=(List`1<bC4=> value);
    [CompilerGeneratedAttribute]
public int dy0=();
    [CompilerGeneratedAttribute]
public void eC0=(int value);
    [CompilerGeneratedAttribute]
public int ei0=();
    [CompilerGeneratedAttribute]
public void ey0=(int value);
    [CompilerGeneratedAttribute]
public int yi0=();
    [CompilerGeneratedAttribute]
public void yy0=(int value);
    [CompilerGeneratedAttribute]
public int zS0=();
    [CompilerGeneratedAttribute]
public void zi0=(int value);
    [CompilerGeneratedAttribute]
public int 0C0=();
    [CompilerGeneratedAttribute]
public void 0S0=(int value);
    [CompilerGeneratedAttribute]
public int 0y0=();
    [CompilerGeneratedAttribute]
public void 1C0=(int value);
    public bool Uy4=(xS0= range);
}
internal enum 8RQ=.cSY= : Enum {
    public int value__;
    public static cSY= ciY=;
    public static cSY= cyY=;
    public static cSY= dCY=;
    public static cSY= dSY=;
    public static cSY= diY=;
    public static cSY= dyY=;
    public static cSY= eCY=;
    public static cSY= eSY=;
    public static cSY= eiY=;
}
internal class 8RQ=.cxk= : Txo= {
    internal cxk=(string id, string desc);
    private void uhg=();
    internal virtual hRg= uxg=(hRg= pjConsts, Int32& pj_Error);
    internal virtual void whg=(XRg= lp, hRg= pjConsts, EBg= fac, Int32& pj_Error);
    internal virtual XRg= wBg=(XBo= xy, hRg= pjConsts, Int32& pj_Error);
    internal virtual XBo= wRg=(XRg= lp, hRg= pjConsts, Int32& pj_Error);
}
internal class 8RQ=.Cxo= : Txo= {
    internal double DBo=;
    internal Cxo=(string id, string desc);
    private void uhg=();
    internal virtual hRg= uxg=(hRg= pjConsts, Int32& pj_Error);
    internal virtual void whg=(XRg= lp, hRg= pjConsts, EBg= fac, Int32& pj_Error);
    internal virtual XRg= wBg=(XBo= xy, hRg= pjConsts, Int32& pj_Error);
    internal virtual XBo= wRg=(XRg= lp, hRg= pjConsts, Int32& pj_Error);
}
internal class 8RQ=.cxs= : Zxs= {
    internal static UInt32 dBs=;
    internal static UInt32 dRs=;
    internal static UInt32 dhs=;
    internal static UInt32 dxs=;
    internal static UInt32 eBs=;
    internal static UInt32 eRs=;
    internal static UInt32 ehs=;
    internal static UInt32 exs=;
    internal static UInt32 fBs=;
    internal static UInt32 fRs=;
    internal static UInt32 fhs=;
    internal static double IRY=;
    internal static double fxs=;
    internal static double gBs=;
    internal static double gRs=;
    internal static double ghs=;
    internal static double gxs=;
    private double hBs=;
    private double hRs=;
    private double hhs=;
    private double hxs=;
    private double iBs=;
    private double iRs=;
    private double ihs=;
    private double ixs=;
    private double jBs=;
    private double jRs=;
    private double jhs=;
    private double jxs=;
    private double kBs=;
    private double kRs=;
    private double khs=;
    private double kxs=;
    public cxs=(double originLatitude, double centralMeridian, double falseEasting, double falseNorthing, double Scale);
    private double lBs=(double Latitude);
    private double lRs=(double Latitude);
    private double lhs=(double Latitude);
    private double lxs=(double Latitude);
    public virtual long aRs=();
    public bool mBs=(double Origin_Latitude, double Central_Meridian, double False_Easting, double False_Northing, double Scale);
    internal long mRs=(double a, double f, double Origin_Latitude, double Central_Meridian, double False_Easting, double False_Northing, double Scale_Factor);
    public void mhs=(Double& Origin_Latitude, Double& Central_Meridian, Double& False_Easting, Double& False_Northing, Double& Scale_Factor);
    internal void mxs=(Double& a, Double& f, Double& Origin_Latitude, Double& Central_Meridian, Double& False_Easting, Double& False_Northing, Double& Scale_Factor);
    public bool nBs=(double Latitude, double Longitude, Double& Easting, Double& Northing);
    internal long nRs=(double Latitude, double Longitude, Double& Easting, Double& Northing);
    public bool nhs=(ahs= trmct, Double& Latitude, Double& Longitude);
    public bool nhs=(double Easting, double Northing, Double& Latitude, Double& Longitude);
    internal long nxs=(double Easting, double Northing, Double& Latitude, Double& Longitude);
}
internal class 8RQ=.Cy4= : object {
    private double WS0=;
    private double DC4=;
    private double DS4=;
    private double Di4=;
    private double Dy4=;
    private long EC4=;
    private long ES4=;
    private long Ei4=;
    private long Ey4=;
    private string uy0=;
    private List`1<Siw=> FC4=;
    private List`1<gy4=> FS4=;
    private Oi4= Fi4=;
    private Ni4= Fy4=;
    private Stream GC4=;
    private BinaryReader GS4=;
    private double iyw=;
    private string YCw=;
    [CompilerGeneratedAttribute]
private EventHandler`1<StreamLoadingEventArgs> StreamLoading;
    public Cy4=(string tGeoFilePathName);
    [CompilerGeneratedAttribute]
public void PB8=(EventHandler`1<StreamLoadingEventArgs> value);
    [CompilerGeneratedAttribute]
public void PR8=(EventHandler`1<StreamLoadingEventArgs> value);
    public void sB4=(bool isEncrypted, string password);
    public TinyGeoFileType Gi4=();
    private String[] Gy4=(bool isEncrypted);
    public void HC4=(bool isEncrypted);
    private void HS4=();
    public RectangleShape bxo=();
    public Collection`1<FeatureSourceColumn> Hi4=();
    public void Hy4=(string targetFile);
    public void dhQ=(string targetFile);
    private void IC4=(string targetFile);
    private void IS4=(string targetFile);
    private void Ii4=(string targetFile);
    private void Iy4=(string targetFile);
    private void JC4=(string targetFile);
    private void JS4=(string targetFile);
    private void Ji4=(string targetFile);
    private void Jy4=(string targetFile);
    private void KC4=(string targetFile);
    private void KS4=(string targetFile, 3Ss= encryptMode);
    private List`1<Siw=> Ki4=(Siw= node);
    private List`1<Siw=> Ky4=(RectangleShape box, Siw= node);
    public void LC4=();
    public List`1<Feature> LS4=(IEnumerable`1<string> ids, IEnumerable`1<string> returningColumnNames);
    public List`1<Feature> LS4=(RectangleShape box, IEnumerable`1<string> returningColumnNames, int startIndex, int takeCount);
    public List`1<Feature> LS4=(RectangleShape box, IEnumerable`1<string> returningColumnNames);
    private xS0= Li4=(RectangleShape rect);
    private Dictionary`2<string, int> Ly4=(IEnumerable`1<string> returningColumnNames);
    public void Px8=(StreamLoadingEventArgs e);
    private void MC4=(List`1<giw=> rtree);
    public String[] MS4=(bool isEncrypted);
    public void Mi4=();
    public void My4=(Int32[] select, bool isEncrypted);
    public void My4=(bool isEncrypted);
    private void NC4=(bool isEncrypted);
    public List`1<Feature> NS4=(xS0= range, List`1<Siw=> queryIndeces, Dictionary`2<string, int> returningColumns, int startIndex, int takeCount);
    public List`1<Feature> NS4=(IEnumerable`1<string> ids, Dictionary`2<string, int> returningColumns);
    public void QB8=();
}
internal class 8RQ=.cy8= : object {
    private BinaryReader dC8=;
    public cy8=(string basFile, FileAccess access);
    public Collection`1<string> Hi4=();
    public ai8= dS8=(long offset);
    public Collection`1<ai8=> di8=();
    public void QB8=();
}
internal class 8RQ=.CyM= : FilterCondition {
    private bool DCM=;
    private static string DSM=;
    private static string DiM=;
    private static string DyM=;
    private static char ECM=;
    [CompilerGeneratedAttribute]
private Regex ESM=;
    [CompilerGeneratedAttribute]
private String[] EiM=;
    [CompilerGeneratedAttribute]
private String[] EyM=;
    public Regex FiM= { get; public set; }
    public String[] GSM= { get; public set; }
    public String[] HCM= { get; public set; }
    internal CyM=(string columnName, string operation, string expression);
    [CompilerGeneratedAttribute]
public Regex FCM=();
    [CompilerGeneratedAttribute]
public void FSM=(Regex value);
    [CompilerGeneratedAttribute]
public String[] FyM=();
    [CompilerGeneratedAttribute]
public void GCM=(String[] value);
    [CompilerGeneratedAttribute]
public String[] GiM=();
    [CompilerGeneratedAttribute]
public void GyM=(String[] value);
    internal virtual bool 3yI=(KeyValuePair`2<string, string> v);
    internal virtual bool 3yI=(Feature feature);
}
internal class 8RQ=.dB8= : ValueType {
    public UInt32 dR8=;
    public ushort dh8=;
    public ushort dx8=;
    public ushort eB8=;
    public ushort eR8=;
    public UInt32 eh8=;
    public void xR4=();
    public bool ZRw=(BinaryReader r);
    public bool cxw=(BinaryWriter w);
    public virtual string ToString();
}
internal class 8RQ=.dBk= : Txo= {
    internal Double[] uBg=;
    internal double CRk=;
    internal double Rhc=;
    internal double eRc=;
    internal double ehc=;
    internal dBk=(string id, string desc);
    private void uhg=();
    internal virtual hRg= uxg=(hRg= pjConsts, Int32& pj_Error);
    internal virtual void whg=(XRg= lp, hRg= pjConsts, EBg= fac, Int32& pj_Error);
    internal virtual XRg= wBg=(XBo= xy, hRg= pjConsts, Int32& pj_Error);
    internal virtual XBo= wRg=(XRg= lp, hRg= pjConsts, Int32& pj_Error);
}
internal class 8RQ=.DBk= : Txo= {
    internal double thg=;
    internal double txg=;
    internal double Rhc=;
    internal double tRg=;
    internal double tBg=;
    internal double sRg=;
    internal Double[] uBg=;
    internal int uRg=;
    internal DBk=(string id, string desc);
    private void uhg=();
    internal virtual hRg= uxg=(hRg= pjConsts, Int32& pj_Error);
    internal virtual void whg=(XRg= lp, hRg= pjConsts, EBg= fac, Int32& pj_Error);
    internal virtual XRg= wBg=(XBo= xy, hRg= pjConsts, Int32& pj_Error);
    internal virtual XBo= wRg=(XRg= lp, hRg= pjConsts, Int32& pj_Error);
}
internal abstract class 8RQ=.DCc= : object {
    protected bool DSc=;
    protected 8yY= Dic=;
    protected qyY= Dyc=;
    protected bool ECc=(8yY= poGeometry);
    protected bool ESc=(8yY= poFilter);
    public virtual void SetSpatialFilter(8yY= poGeomIn);
    public abstract virtual void ResetReading();
    public virtual sCY= GetNextFeature();
    public virtual sCY= GetFeature(long nFID);
    public virtual OiY= CreateFeature(sCY= poFeature);
    public abstract virtual yCY= GetLayerDefn();
    public virtual OSc= GetSpatialRef();
    public virtual int GetFeatureCount(bool bForce);
    public virtual OiY= GetExtent(qyY= psExtent, bool bForce);
    public abstract virtual bool TestCapability(string pszCap);
}
internal enum 8RQ=.DCs= : Enum {
    public byte value__;
    public static DCs= 0SQ=;
    public static DCs= 0iQ=;
    public static DCs= 0yQ=;
    public static DCs= 1CQ=;
    public static DCs= 1SQ=;
    public static DCs= 1iQ=;
    public static DCs= 1yQ=;
    public static DCs= 2CQ=;
    public static DCs= 2SQ=;
    public static DCs= 2iQ=;
    public static DCs= 2yQ=;
    public static DCs= 3CQ=;
    public static DCs= 3SQ=;
    public static DCs= 3iQ=;
    public static DCs= 3yQ=;
    public static DCs= 4CQ=;
    public static DCs= 4SQ=;
    public static DCs= 4iQ=;
    public static DCs= 4yQ=;
    public static DCs= 5CQ=;
    public static DCs= 5SQ=;
    public static DCs= 5iQ=;
    public static DCs= 5yQ=;
    public static DCs= 6CQ=;
    public static DCs= 6SQ=;
    public static DCs= 6iQ=;
    public static DCs= 6yQ=;
    public static DCs= 7CQ=;
    public static DCs= 7SQ=;
    public static DCs= 7iQ=;
    public static DCs= 7yQ=;
    public static DCs= 8CQ=;
    public static DCs= 8SQ=;
    public static DCs= 8iQ=;
    public static DCs= 8yQ=;
    public static DCs= 9CQ=;
    public static DCs= 9SQ=;
    public static DCs= 9iQ=;
    public static DCs= 9yQ=;
    public static DCs= /CQ=;
    public static DCs= /SQ=;
    public static DCs= /iQ=;
    public static DCs= /yQ=;
}
internal class 8RQ=.dhg= : object {
    private string dxg=;
    private GBc= eBg=;
    private Stream eRg=;
    internal GBc= fBg= { get; internal set; }
    internal dhg=(string name);
    internal dhg=(Stream fs);
    private void fRg=(string name);
    internal GBc= ehg=();
    internal void exg=(GBc= value);
    internal GBc= fhg=();
    private int fxg=(object obj);
    internal bool gBg=(GBc= ct);
    public sealed virtual void Dispose();
}
internal class 8RQ=.dhk= : Txo= {
    internal double eRc=;
    internal double ehc=;
    internal double fBc=;
    internal int Fhk=;
    internal dhk=(string id, string desc);
    private void uhg=();
    internal virtual hRg= uxg=(hRg= pjConsts, Int32& pj_Error);
    internal virtual void whg=(XRg= lp, hRg= pjConsts, EBg= fac, Int32& pj_Error);
    internal virtual XRg= wBg=(XBo= xy, hRg= pjConsts, Int32& pj_Error);
    internal virtual XBo= wRg=(XRg= lp, hRg= pjConsts, Int32& pj_Error);
}
internal class 8RQ=.Dho= : Txo= {
    private double Dxo=;
    private double uhk=;
    private Double[] uBg=;
    internal Dho=(string id, string desc);
    private void uhg=();
    internal virtual hRg= uxg=(hRg= pjConsts, Int32& pj_Error);
    internal virtual void whg=(XRg= lp, hRg= pjConsts, EBg= fac, Int32& pj_Error);
    internal virtual XRg= wBg=(XBo= xy, hRg= pjConsts, Int32& pj_Error);
    internal virtual XBo= wRg=(XRg= lp, hRg= pjConsts, Int32& pj_Error);
    private XBo= 0hg=(XRg= lp, hRg= pjConsts, Int32& pj_Error);
    private XBo= 0Bg=(XRg= lp, hRg= pjConsts, Int32& pj_Error);
    private XRg= zxg=(XBo= xy, hRg= pjConsts, Int32& pj_Error);
    private XRg= zRg=(XBo= xy, hRg= pjConsts, Int32& pj_Error);
}
internal class 8RQ=.diU= : object {
    public int dyU=;
    public string eCU=;
    public double eSU=;
    public double eiU=;
    public diU=(int nMapInfoId, string pszMapinfoName, double dfA, double dfInvFlattening);
}
internal class 8RQ=.DR8= : UB8= {
    public DR8=(Dx8= page);
    internal virtual bool Dh8=(gx8= insertRec, UB8=[]& nodeList);
}
internal class 8RQ=.dRk= : Txo= {
    internal dRk=(string id, string desc);
    private void uhg=();
    internal virtual hRg= uxg=(hRg= pjConsts, Int32& pj_Error);
    internal virtual void whg=(XRg= lp, hRg= pjConsts, EBg= fac, Int32& pj_Error);
    internal virtual XRg= wBg=(XBo= xy, hRg= pjConsts, Int32& pj_Error);
    internal virtual XBo= wRg=(XRg= lp, hRg= pjConsts, Int32& pj_Error);
}
internal class 8RQ=.DRk= : Txo= {
    internal double Rhc=;
    internal double Dhk=;
    internal double Dxk=;
    internal double EBk=;
    internal double ERk=;
    internal double Ehk=;
    internal DRk=(string id, string desc);
    private void uhg=();
    internal virtual hRg= uxg=(hRg= pjConsts, Int32& pj_Error);
    internal virtual void whg=(XRg= lp, hRg= pjConsts, EBg= fac, Int32& pj_Error);
    internal virtual XRg= wBg=(XBo= xy, hRg= pjConsts, Int32& pj_Error);
    internal virtual XBo= wRg=(XRg= lp, hRg= pjConsts, Int32& pj_Error);
    private int Exk=(hRg= pjConsts, Double[] del, Int32& pj_Error);
}
internal class 8RQ=.DRo= : Txo= {
    internal double Rhc=;
    internal double Dhk=;
    internal double Dxk=;
    internal double EBk=;
    internal double ERk=;
    internal double Ehk=;
    internal DRo=(string id, string desc);
    private void uhg=();
    internal virtual hRg= uxg=(hRg= pjConsts, Int32& pj_Error);
    internal virtual void whg=(XRg= lp, hRg= pjConsts, EBg= fac, Int32& pj_Error);
    internal virtual XRg= wBg=(XBo= xy, hRg= pjConsts, Int32& pj_Error);
    internal virtual XBo= wRg=(XRg= lp, hRg= pjConsts, Int32& pj_Error);
    private int Exk=(hRg= pjConsts, Double[] del, Int32& pj_Error);
}
internal class 8RQ=.dSE= : object {
    private int diE=;
    private int dyE=;
    private float eCE=;
    private float eSE=;
    private GeoImage eiE=;
    public int fSE= { get; public set; }
    public int gCE= { get; public set; }
    public float giE= { get; }
    public float hCE= { get; }
    public GeoImage hiE= { get; }
    public dSE=(int screenStartX, int screenStartY, float screenStartPositionX, float screenStartPositionY, GeoImage drawingWholeGeoImage);
    public int eyE=();
    public void fCE=(int value);
    public int fiE=();
    public void fyE=(int value);
    public float gSE=();
    public float gyE=();
    public GeoImage hSE=();
}
internal enum 8RQ=.DSs= : Enum {
    public int value__;
    public static DSs= QiQ=;
    public static DSs= Dis=;
    public static DSs= QSQ=;
}
internal class 8RQ=.Dx8= : TB8= {
    public Dx8=(RtreeFile rtFile, UInt32 pageNo, Gist_Ext_Id extId);
    public Dx8=(RtreeFile rtFile, Gist_Ext_Id extId);
    internal virtual gx8= EB8=();
    internal virtual int ER8=();
    internal virtual bool Eh8=(Lx8= ent, int idx);
}
internal class 8RQ=.dxk= : Txo= {
    internal dxk=(string id, string desc);
    private void uhg=();
    internal virtual hRg= uxg=(hRg= pjConsts, Int32& pj_Error);
    private double Bhc=(double sinphi, double cosphi, double es, Int32& pj_Error);
    internal virtual void whg=(XRg= lp, hRg= pjConsts, EBg= fac, Int32& pj_Error);
    internal virtual XRg= wBg=(XBo= xy, hRg= pjConsts, Int32& pj_Error);
    internal virtual XBo= wRg=(XRg= lp, hRg= pjConsts, Int32& pj_Error);
    private XBo= 0hg=(XRg= lp, hRg= pjConsts, Int32& pj_Error);
    private XBo= 0Bg=(XRg= lp, hRg= pjConsts, Int32& pj_Error);
    private XRg= zxg=(XBo= xy, hRg= pjConsts, Int32& pj_Error);
    private XRg= zRg=(XBo= xy, hRg= pjConsts, Int32& pj_Error);
    private double eBk=(double phi, double sinphi, double e, Int32& pj_Error);
    private double CBc=(double ts, double e, Int32& pj_Error);
}
[DefaultMemberAttribute("Item")]
internal class 8RQ=.dxw= : object {
    private int eBw=;
    private Char[] eRw=;
    private int ehw=;
    private int exw=;
    public int fhw= { get; public set; }
    public int gBw= { get; }
    public char gxw= { get; public set; }
    public dxw=(int capacity);
    public int fBw=();
    public void fRw=(int value);
    public int fxw=();
    protected void hBw=(int requestedLen);
    protected void hRw=(int requestedLength);
    protected void hhw=();
    public void hxw=(Char[] b, int len);
    public void iBw=(char c);
    public void iBw=(string s);
    public void iBw=(dxw= s);
    public void iRw=(int i);
    public void iRw=(int i, int n);
    public int ihw=(char c);
    public void QhU=();
    public char gRw=(int index);
    public void ghw=(int index, char value);
    public virtual string ToString();
}
internal static class 8RQ=.dy8= : object {
    public static ai8= cyM=(4S4= entity);
    private static void eC8=(ai8= featureEntity, Fy8= header);
    private static void eS8=(ai8= featureEntiye, Collection`1<By8=> coordinates);
    private static void ei8=(ai8= featureEntity, Collection`1<9C4=> annotations);
}
internal enum 8RQ=.Dys= : Enum {
    public int value__;
    public static Dys= MiE=;
    public static Dys= ECs=;
}
internal class 8RQ=.EBg= : object {
    internal double ERg=;
    internal double Ehg=;
    internal double Exg=;
    internal int FBg=;
}
internal class 8RQ=.EBo= : Txo= {
    internal double ERo=;
    internal double Eho=;
    internal double Exo=;
    internal double FBo=;
    internal double FRo=;
    internal double Fho=;
    internal double Fxo=;
    internal double GBo=;
    internal double GRo=;
    internal double Gho=;
    internal double Gxo=;
    internal double HBo=;
    internal double HRo=;
    internal double bRk=;
    internal double bBk=;
    internal double Hho=;
    internal double KRk=;
    internal EBo=(string id, string desc);
    private void uhg=();
    internal virtual hRg= uxg=(hRg= pjConsts, Int32& pj_Error);
    internal virtual void whg=(XRg= lp, hRg= pjConsts, EBg= fac, Int32& pj_Error);
    internal virtual XRg= wBg=(XBo= xy, hRg= pjConsts, Int32& pj_Error);
    internal virtual XBo= wRg=(XRg= lp, hRg= pjConsts, Int32& pj_Error);
}
internal class 8RQ=.eCA= : ValueType {
    public bool eSA=;
    public bool eiA=;
    public bool eyA=;
    public bool fCA=;
    public bool fSA=;
    public bool fiA=;
    public bool fyA=;
    public string gCA=;
    public bool dSA=;
    public int gSA=;
}
internal static class 8RQ=.eCQ= : object {
    public static FileAttributes eSQ=(string pszFilename);
    public static long eiQ=(Stream fp);
    public static string eyQ=(string pszBuffer, int nBufferSize, Stream fp, Encoding encoding);
    public static long fCQ=(Stream fp, long nOffset, int nWhence);
    public static Stream fSQ=(string pszFilename, FileAccess pszAccess, FileShare fileShare);
    public static void fiQ=(Stream fp);
    public static void fyQ=(Stream fp);
    public static int gCQ=(Byte[] pBuffer, int nSize, int nCount, Stream fp);
    public static int gSQ=(Byte[] pBuffer, int nSize, int nCount, Stream fp);
    public static bool giQ=(Stream fp);
}
internal abstract class 8RQ=.ECU= : DCc= {
    protected int ESU=;
    protected GSg= EiU=;
    protected bool EyU=;
    protected string FCU=;
    public Encoding FSU=;
    public virtual aig= GetFileClass();
    public abstract virtual int Open(string pszFname, FileAccess pszAccess, bool bTestOpenNoError);
    public abstract virtual int Close();
    public virtual int SetQuickSpatialIndexMode(bool bQuickSpatialIndexMode);
    public virtual string GetTableName();
    public static ECU= FiU=(string pszFname, bool bTestOpenNoError, Encoding encoding);
    public virtual int GetFeatureCount(bool bForce);
    public virtual sCY= GetNextFeature();
    public virtual sCY= GetFeature(long nFeatureId);
    public virtual OiY= CreateFeature(sCY= poFeature);
    public abstract virtual OiY= GetExtent(qyY= psExtent, bool bForce);
    public abstract virtual int GetNextFeatureId(int nPrevId);
    public abstract virtual GSg= GetFeatureRef(int nFeatureId);
    public abstract virtual Tig= GetNativeFieldType(int nFieldId);
    public abstract virtual int GetBounds(Double& dXMin, Double& dYMin, Double& dXMax, Double& YMax, bool bForce);
    public abstract virtual OSc= GetSpatialRef();
    public abstract virtual int GetFeatureCountByType(Int32& numPoints, Int32& numLines, Int32& numRegions, Int32& numTexts, bool bForce);
    public abstract virtual bool IsFieldIndexed(int nFieldId);
    public abstract virtual bool IsFieldUnique(int nFieldId);
    public abstract virtual int SetBounds(double dXMin, double dYMin, double dXMax, double dYMax);
    public virtual int SetFeatureDefn(yCY= poFeatureDefn, List`1<Tig=> paeMapInfoNativeFieldTypes);
    public abstract virtual int AddFieldNative(string pszName, Tig= eMapInfoType, int nWidth, int nPrecision, bool bIndexed, bool bUnique);
    public abstract virtual int SetSpatialRef(OSc= poSpatialRef);
    public abstract virtual int SetFeature(GSg= poFeature, int nFeatureId);
    public abstract virtual int SetFieldIndexed(int nFieldId);
    public virtual int GetProjInfo(GCo= poPI);
    public virtual int SetProjInfo(GCo= poPI);
    public virtual int SetMIFCoordSys(string pszMIFCoordSys);
}
internal class 8RQ=.ehk= : Txo= {
    internal FRc=[] 2hg=;
    internal double 2xg=;
    internal double 3Bg=;
    internal int Rhc=;
    internal ehk=(string id, string desc);
    private void uhg=();
    internal virtual hRg= uxg=(hRg= pjConsts, Int32& pj_Error);
    internal virtual void whg=(XRg= lp, hRg= pjConsts, EBg= fac, Int32& pj_Error);
    internal virtual XRg= wBg=(XBo= xy, hRg= pjConsts, Int32& pj_Error);
    internal virtual XBo= wRg=(XRg= lp, hRg= pjConsts, Int32& pj_Error);
    private XRg= zxg=(XBo= xy, hRg= pjConsts, Int32& pj_Error);
    private XBo= 0hg=(XRg= lp, hRg= pjConsts, Int32& pj_Error);
    private FRc= 3Rg=(FRc= z, FRc=[] C, int n, FRc= der);
    private FRc= 3hg=(FRc= z, FRc=[] C, int n);
}
internal class 8RQ=.Eic= : Fyc= {
    public Eic=(Eic= poSrcRing);
    public virtual int Eyc=(int b3D);
    public virtual string /yY=();
    public virtual 8yY= 9iY=();
    public virtual int FCc=();
    public virtual void FSc=();
    public virtual double Fic=();
}
internal class 8RQ=.eik= : rik= {
    public byte 2Cc=;
    public byte 1yc=;
    public byte eyk=;
    public virtual int bSk=(fCk= poObjBlock);
    public virtual int bik=(fCk= poObjBlock);
}
internal class 8RQ=.ejE= : azE= {
    private static string ezE=;
    private static string fDE=;
    private static string fTE=;
    public virtual StyleJsonDocument ahU=(JObject jsonObject);
    protected static List`1<JToken> fjE=(JObject jsonObject);
    protected static List`1<ValueTuple`2<int, JObject>> fzE=(JObject jObject);
}
internal class 8RQ=.eRk= : Txo= {
    internal eRk=(string id, string desc);
    private void uhg=();
    internal virtual hRg= uxg=(hRg= pjConsts, Int32& pj_Error);
    internal virtual void whg=(XRg= lp, hRg= pjConsts, EBg= fac, Int32& pj_Error);
    internal virtual XRg= wBg=(XBo= xy, hRg= pjConsts, Int32& pj_Error);
    internal virtual XBo= wRg=(XRg= lp, hRg= pjConsts, Int32& pj_Error);
}
internal class 8RQ=.eSc= : bCc= {
    public RSc=[] eic=;
    private SCc=[] UCc=;
    public virtual int ahU=();
}
[DefaultMemberAttribute("Item")]
internal class 8RQ=.ESE= : TSE= {
    private static HyE= 6yA=;
    private EyE= 7iA=;
    public EyE= AiE= { get; }
    public string gxw= { get; public set; }
    public ESE=(EyE= headerRecord);
    public ESE=(EyE= headerRecord, String[] values);
    public ESE=(EyE= headerRecord, bool readOnly, String[] values);
    public ESE=(EyE= headerRecord, IEnumerable`1<string> values);
    public ESE=(EyE= headerRecord, bool readOnly, IEnumerable`1<string> values);
    internal ESE=(EyE= headerRecord, IList`1<string> values);
    private static ESE=();
    public EyE= ACE=();
    public string gRw=(string columnName);
    public void ghw=(string columnName, string value);
    public string EiE=(string columnName);
    public sealed virtual bool Equals(ESE= other);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
}
internal class 8RQ=.ex8= : gx8= {
    private xx8= fB8=;
    internal xx8= fx8= { get; internal set; }
    internal ex8=(kR8= rh, xx8= pt, int idx);
    public virtual string ToString();
    internal xx8= fR8=();
    internal void fh8=(xx8= value);
    internal virtual xx8= gB8=();
    internal virtual bool ZRw=(BinaryReader r, bool isFloat);
    internal virtual bool cxw=(BinaryWriter w, bool isFloat);
    internal virtual bool WR8=(nR8= rect);
    internal virtual bool WB8=(nR8= rect);
    internal virtual bool Wh8=(nR8= rect);
    internal virtual int MB8=(bool isFloat);
    internal virtual nR8= gR8=();
    internal virtual double gh8=();
}
internal class 8RQ=.Ex8= : RTPage {
    protected dB8= FB8=;
    protected lR8= FR8=;
    protected int Fh8=;
    protected static int Fx8=;
    protected static string GB8=;
    public dB8= Gx8= { get; public set; }
    public Ex8=(RtreeFile rtFile, UInt32 pageNo, Gist_Ext_Id extId);
    public Ex8=(RtreeFile rtFile, Gist_Ext_Id extId);
    internal virtual bool HB8=(gx8= rec);
    internal virtual void HR8=(int idx);
    public virtual bool Hh8=();
    public dB8= GR8=();
    public void Gh8=(dB8= value);
    internal ushort Hx8=();
    internal void IB8=(ushort level);
    internal void IR8=(UInt32 pageNo);
    internal void Ih8=();
    public int Ix8=();
    public bool JB8=();
    public bool JR8=();
    public bool Jh8=();
    public bool Jx8=();
    public virtual gx8= KB8=();
    public virtual gx8= KR8=();
    public bool Kh8=();
    public virtual gx8= Kx8=(int idx);
    internal virtual int ER8=();
    public virtual string LB8=();
    public virtual nR8= LR8=();
    public UInt32 Lh8=();
    internal virtual bool Eh8=(Lx8= ent, int idx);
}
internal class 8RQ=.exk= : Txo= {
    internal double eRc=;
    internal double ehc=;
    internal double fBc=;
    internal exk=(string id, string desc);
    private void uhg=();
    internal virtual hRg= uxg=(hRg= pjConsts, Int32& pj_Error);
    internal virtual void whg=(XRg= lp, hRg= pjConsts, EBg= fac, Int32& pj_Error);
    internal virtual XRg= wBg=(XBo= xy, hRg= pjConsts, Int32& pj_Error);
    internal virtual XBo= wRg=(XRg= lp, hRg= pjConsts, Int32& pj_Error);
    private hRg= fBk=(hRg= pjConsts, double p, Int32& pj_Error);
}
internal class 8RQ=.Ey0= : object {
    private List`1<rC0=> /Sw=;
    private int /iw=;
    private int /yw=;
    private double iyw=;
    [CompilerGeneratedAttribute]
private List`1<Lyw=> 5yw=;
    [CompilerGeneratedAttribute]
private byte FC0=;
    [CompilerGeneratedAttribute]
private int 6Cw=;
    [CompilerGeneratedAttribute]
private short 6Sw=;
    [CompilerGeneratedAttribute]
private short 6iw=;
    [CompilerGeneratedAttribute]
private int AS0=;
    [CompilerGeneratedAttribute]
private byte Ai0=;
    [CompilerGeneratedAttribute]
private QSw= Ay0=;
    [CompilerGeneratedAttribute]
private string JCw=;
    [CompilerGeneratedAttribute]
private ushort JSw=;
    public List`1<Lyw=> 7Sw= { get; public set; }
    public byte Fy0= { get; private set; }
    public int 8Cw= { get; private set; }
    public short 8yw= { get; private set; }
    public short 9iw= { get; private set; }
    public int CS0= { get; private set; }
    public byte DC0= { get; private set; }
    public QSw= Dy0= { get; private set; }
    public string Kyw= { get; public set; }
    public ushort Liw= { get; public set; }
    public Ey0=(double extentWidthLimitation);
    [CompilerGeneratedAttribute]
public void 7Cw=(List`1<Lyw=> value);
    [CompilerGeneratedAttribute]
public List`1<Lyw=> 6yw=();
    [CompilerGeneratedAttribute]
private void Fi0=(byte value);
    [CompilerGeneratedAttribute]
public byte FS0=();
    [CompilerGeneratedAttribute]
private void 7yw=(int value);
    [CompilerGeneratedAttribute]
public int 7iw=();
    [CompilerGeneratedAttribute]
private void 8iw=(short value);
    [CompilerGeneratedAttribute]
public short 8Sw=();
    [CompilerGeneratedAttribute]
private void 9Sw=(short value);
    [CompilerGeneratedAttribute]
public short 9Cw=();
    [CompilerGeneratedAttribute]
private void CC0=(int value);
    [CompilerGeneratedAttribute]
public int By0=();
    [CompilerGeneratedAttribute]
private void Cy0=(byte value);
    [CompilerGeneratedAttribute]
public byte Ci0=();
    [CompilerGeneratedAttribute]
private void Di0=(QSw= value);
    [CompilerGeneratedAttribute]
public QSw= DS0=();
    [CompilerGeneratedAttribute]
public string KSw=();
    [CompilerGeneratedAttribute]
public void Kiw=(string value);
    [CompilerGeneratedAttribute]
public ushort LCw=();
    [CompilerGeneratedAttribute]
public void LSw=(ushort value);
    public void EC0=(double LoCenter, double LaCenter, byte BitsPerCoord, Dictionary`2<string, int> lblDictionary);
    private void ES0=();
    private void Ei0=();
}
internal class 8RQ=.ey8= : object {
    public static Vertex fC8=(string latlonString);
    public static string fS8=(Vertex vertex);
    public static Vertex fi8=(string XY18String);
    public static string fy8=(Vertex vertex);
    public static Vertex gC8=(string XY20String);
    public static string gS8=(Vertex vertex);
    public static DateTime gi8=(string YYMMDDString);
    public static string gy8=(DateTime datetime);
    public static float hC8=(string textAngle);
}
internal class 8RQ=.EyA= : object {
    private static double FCA=;
    private static int FSA=;
    private static int FiA=;
    private static int FyA=;
    private static int GCA=;
    private static int GSA=;
    private static float GiA=;
    private static float GyA=;
    private static float HCA=;
    private static int HSA=;
    private static int HiA=;
    private static double IRY=;
    private static double HyA=;
    private static double ICA=;
    private Double[] ISA=;
    private Double[] IiA=;
    private Double[] IyA=;
    private Double[] JCA=;
    private Int32[] JSA=;
    private Int32[] JiA=;
    private Int32[] JyA=;
    private Int32[] KCA=;
    private String[] KSA=;
    private Single[] KiA=;
    private Single[] KyA=;
    private Single[] LCA=;
    private Single[] LSA=;
    private Single[] LiA=;
    private int LyA=;
    private int MCA=;
    private int MSA=;
    private int MiA=;
    private int MyA=;
    private int NCA=;
    private float NSA=;
    private float NiA=;
    private float NyA=;
    private float OCA=;
    private float OSA=;
    private double OiA=;
    private double OyA=;
    private double PCA=;
    private double PSA=;
    private double xxk=;
    private double yBk=;
    private double PiA=;
    private double 1xc=;
    private double Rxc=;
    private double PyA=;
    private double QCA=;
    private double QSA=;
    private double QiA=;
    private double QyA=;
    private double RCA=;
    private double RSA=;
    private double RiA=;
    private double RyA=;
    private double SCA=;
    private double SSA=;
    private double SiA=;
    private double SyA=;
    private double TCA=;
    private double TSA=;
    private double TiA=;
    private double TyA=;
    private double UCA=;
    private eCA= USA=;
    public double VCA= { get; public set; }
    public double VyA= { get; public set; }
    public double WSA= { get; }
    public float XCA= { get; public set; }
    public double UiA=();
    public void UyA=(double value);
    public double VSA=();
    public void ViA=(double value);
    public double WCA=();
    public float WiA=();
    public void WyA=(float value);
    private void XSA=(eCA= Msg, string Caller);
    private void XiA=(Stream magneticFieldStream);
    private static double XyA=(DateTime myDate);
    public void YCA=(string magneticFieldFilePathName, DateTime thisDate, double Lat, double Lon, float Elevation, ZiA=& Result);
    public void YCA=(Stream magneticFieldStream, DateTime thisDate, double Lat, double Lon, float Elevation, ZiA=& Result);
    private int YSA=(Stream magneticFieldStream, int iflag, long StartRec, int nMax_of_GH, int GH);
    private int YiA=(double mYear, double dTe1, int nMax1, int nMax2, int GH);
    private int YyA=(double mYear, double dte1, int nmax1, double dte2, int nmax2, int gh);
    private int ZCA=(int IDGDC, double fLat, double fLon, float Elev, int nMax, int gh, int iExt, float Ext1, float Ext2, float Ext3);
    private int ZSA=(int GH);
}
internal class 8RQ=.eyc= : object {
    public static T[] fCc=(T[] srcArray, int destLength);
    public static void fSc=(String& pszTarget, double x, double y, double z, int nDimension);
    public static void fic=(Char[] pszTarget);
    public static bool fyc=(string pszInput, 1iY= psField, int nOptions);
    public static void gCc=(String& pszStrBuf, double dfValue);
}
[DefaultMemberAttribute("Item")]
internal class 8RQ=.EyE= : TSE= {
    private static HyE= 6yA=;
    private IDictionary`2<string, int> FCE=;
    public int gxw= { get; }
    public string Item { get; public set; }
    public EyE=(String[] columnNames);
    public EyE=(bool readOnly, String[] columnNames);
    public EyE=(IEnumerable`1<string> columnNames);
    public EyE=(bool readOnly, IEnumerable`1<string> columnNames);
    internal EyE=(IList`1<string> columnNames);
    private static EyE=();
    public int gRw=(string columnName);
    public Nullable`1<int> FSE=(string columnName);
    public virtual string get_Item(int index);
    public virtual void set_Item(int index, string value);
    public virtual void Add(string value);
    public virtual void Insert(int index, string value);
    public virtual void Clear();
    public virtual bool Remove(string value);
    public virtual void RemoveAt(int index);
    private void FiE=(int startIndex, bool checkForDuplicates);
}
internal class 8RQ=.eyU= : object {
    private Stream fCU=;
    private string fSU=;
    private static int fiU=;
    private Char[] fyU=;
    private Char[] gCU=;
    private string gSU=;
    private oSc= giU=;
    private double gyU=;
    private double hCU=;
    private double hSU=;
    private double hiU=;
    private Encoding rB4=;
    protected virtual override void Finalize();
    public sealed virtual void Dispose();
    protected void kh0=(bool isDispose);
    public void QB8=();
    public int sB4=(string pszFname, FileAccess pszAccess);
    public string hyU=();
    public string iCU=();
    public int iSU=();
    public void iiU=(string pszLine);
    public string iyU=();
    public void jCU=(string pszFormat, Object[] vaList);
    public bool jSU=(string pszString);
    public void jiU=(double dfXMul, double dfYMul, double dfXTran, double dfYTran);
    public double jyU=(double dfX);
    public double kCU=(double dfY);
    public double kSU=();
    public string kiU=();
    public void kyU=(string pszDelimiter);
    public void lCU=(bool bEof);
}
internal enum 8RQ=.eyY= : Enum {
    public int value__;
    public static eyY= fCY=;
    public static eyY= fSY=;
    public static eyY= fiY=;
    public static eyY= fyY=;
    public static eyY= gCY=;
    public static eyY= gSY=;
    public static eyY= giY=;
    public static eyY= gyY=;
    public static eyY= hCY=;
    public static eyY= hSY=;
    public static eyY= hiY=;
    public static eyY= hyY=;
}
internal static class 8RQ=.EyY= : object {
    public static List`1<ZCU=> FCY=;
    public static List`1<ZCU=> FSY=;
    private static EyY=();
    public static void FiY=();
    private static void FyY=();
    private static void GCY=(Stream deCompressedStream);
    private static ZCU= GSY=(string wholeData);
    public static bool GiY=(double a, double b);
    private static byte GyY=(string byteStr);
    public static bool HCY=(GCo= psCS, Double& dXMin, Double& dYMin, Double& dXMax, Double& dYMax);
    public static int HSY=(string pszFname);
    public static int HSY=(string pszFname, Encoding encoding);
    public static void HiY=();
}
internal class 8RQ=.FB0= : object {
    public virtual string cxw=(BaseShape geometry);
    public virtual void cxw=(BaseShape geometry, StringBuilder writer);
    private void FR0=(BaseShape geometry, StringBuilder writer);
    private void Fh0=(Vertex coordinate, StringBuilder writer);
    private void Fh0=(PointShape coordinate, StringBuilder writer);
    private void Fx0=(LineShape lineString, StringBuilder writer);
    private void GB0=(RingShape linearRing, StringBuilder writer);
    private void GR0=(PolygonShape polygon, StringBuilder writer);
    private void Gh0=(MultipointShape multipoint, StringBuilder writer);
    private void Gx0=(MultilineShape multiLineString, StringBuilder writer);
    private void HB0=(MultipolygonShape multiPolygon, StringBuilder writer);
    private void HR0=(GeometryCollectionShape geometryCollection, StringBuilder writer);
    private void Hh0=(Vertex coordinate, StringBuilder writer);
    private void Hh0=(PointShape coordinate, StringBuilder writer);
    private void Hx0=(Vertex coordinate, StringBuilder writer);
    private void Hx0=(PointShape coordinate, StringBuilder writer);
    private void IB0=(LineShape lineString, StringBuilder writer);
    private void IB0=(RingShape lineString, StringBuilder writer);
    private void IR0=(PolygonShape polygon, StringBuilder writer);
    private void Ih0=(MultipointShape multiPoint, StringBuilder writer);
    private void Ix0=(MultilineShape multiLineString, StringBuilder writer);
    private void JB0=(MultipolygonShape multiPolygon, StringBuilder writer);
    private void JR0=(GeometryCollectionShape geometryCollection, StringBuilder writer);
    public static IEnumerable`1<Vertex> Jh0=(BaseShape shape);
}
internal class 8RQ=.FBk= : Txo= {
    internal XBo= 9hg=;
    internal double 9xg=;
    internal double /Bg=;
    internal double /Rg=;
    internal FBk=(string id, string desc);
    private void uhg=();
    internal virtual hRg= uxg=(hRg= pjConsts, Int32& pj_Error);
    internal virtual void whg=(XRg= lp, hRg= pjConsts, EBg= fac, Int32& pj_Error);
    internal virtual XRg= wBg=(XBo= xy, hRg= pjConsts, Int32& pj_Error);
    internal virtual XBo= wRg=(XRg= lp, hRg= pjConsts, Int32& pj_Error);
}
internal class 8RQ=.FCg= : object {
    public static int FSg=(double x0, double x, double x1);
    public static void Fig=(double a, double b, double t);
    public static Eic= Fyg=(Lic= poly, int i);
}
internal class 8RQ=.fCk= : XSo= {
    public static int fSk=;
    protected int xCg=;
    protected int fik=;
    protected int fyk=;
    protected int gCk=;
    protected int gSk=;
    protected int xyg=;
    protected int yCg=;
    protected int ySg=;
    protected int yig=;
    protected int gik=;
    protected int gyk=;
    protected int hCk=;
    public fCk=(oSc= eAccessMode);
    public virtual int CommitToFile();
    public virtual int InitBlockFromData(Byte[] pabyBuf, int nBlockSize, int nSizeUsed, bool bMakeCopy, Stream fsSrc, int nOffset);
    public virtual int InitNewBlock(Stream fsSrc, int nBlockSize, int nFileOffset);
    public virtual int GetBlockClass();
    public int 0yg=(bool bCompressed, Int32& nX, Int32& nY);
    public int 2Sg=(int nX, int nY, bool bCompressed);
    public int hSk=(int nXMin, int nYMin, int nXMax, int nYMax, bool bCompressed);
    public int rSc=(int nX, int nY);
    public int hik=(lSk= poObjHdr);
    public int hyk=(lSk= poObjHdr);
    public void iCk=(int nNewBlockAddress);
    public int iSk=();
    public int iik=();
    public void LCg=(Int32& nXMin, Int32& nYMin, Int32& nXMax, Int32& nYMax);
    public void Kyg=(int nXMin, int nYMin, int nXMax, int nYMax);
    public void iSU=();
    public int iyk=(KSk= poHeader);
    public int jCk=();
    public int jSk=();
    public int jik=();
}
internal class 8RQ=.FCo= : gSo= {
    private bool xik=;
    private double qSc=;
    private double qic=;
    private bool FSo=;
    private Rig= qCc=;
    private static int hCQ=;
    private static int hSQ=;
    private static int hiQ=;
    private static int hyQ=;
    public bool rSk=;
    public yyk= PyU= { get; public set; }
    public int QiU= { get; public set; }
    public FCo=(yCY= poDefnIn);
    public virtual NCg= ric=();
    public virtual int ryc=(5yg= poMapFile);
    public virtual GSg= sCc=(yCY= poNewDefn);
    public int Fio=();
    public Fyc= Fyo=(int nPartIndex);
    public virtual int sSc=(5yg= poMapFile, lSk= poObjHdr, bool bCoordBlockDataOnly, wig=& ppoCoordBlock);
    public virtual int sic=(5yg= poMapFile, lSk= poObjHdr, bool bCoordBlockDataOnly, wig=& ppoCoordBlock);
    public virtual int syc=(eyU= fp);
    public virtual int tCc=(eyU= fp);
    public virtual string xiY=();
    public virtual void tSc=(Stream fsOut);
    public int ySk=(Double& dX, Double& dY);
    public void yik=(double dX, double dY);
    public virtual int QyU=();
    public virtual yyk= RCU=();
    public virtual byte RSU=();
    public virtual double RiU=();
    public virtual int RyU=();
    public virtual byte SCU=();
    public virtual int SSU=();
    public virtual string SiU=();
    public sealed virtual yyk= PSU=();
    public sealed virtual void PiU=(yyk= value);
    public sealed virtual int QCU=();
    public sealed virtual void QSU=(int value);
    public virtual void SyU=(byte val);
    public virtual void TCU=(double val);
    public virtual void TSU=(int val);
    public virtual void TiU=(byte val);
    public virtual void TyU=(int clr);
    public virtual void UCU=(string pszStyleString);
    public virtual void USU=(Stream fpOut);
}
internal class 8RQ=.fhk= : Txo= {
    internal double Rhc=;
    internal double Dhk=;
    internal double Dxk=;
    internal double EBk=;
    internal double ERk=;
    internal double Ehk=;
    internal fhk=(string id, string desc);
    private void uhg=();
    internal virtual hRg= uxg=(hRg= pjConsts, Int32& pj_Error);
    internal virtual void whg=(XRg= lp, hRg= pjConsts, EBg= fac, Int32& pj_Error);
    internal virtual XRg= wBg=(XBo= xy, hRg= pjConsts, Int32& pj_Error);
    internal virtual XBo= wRg=(XRg= lp, hRg= pjConsts, Int32& pj_Error);
    private int Exk=(hRg= pjConsts, Double[] del, Int32& pj_Error);
}
internal enum 8RQ=.fig= : Enum {
    public int value__;
    public static fig= fyg=;
    public static fig= gCg=;
    public static fig= gSg=;
    public static fig= gig=;
    public static fig= gyg=;
    public static fig= hCg=;
    public static fig= hSg=;
    public static fig= hig=;
    public static fig= hyg=;
    public static fig= iCg=;
    public static fig= iSg=;
    public static fig= iig=;
    public static fig= iyg=;
}
internal class 8RQ=.FiI= : object {
    private Quadtree`1<object> FyI=;
    private List`1<int> qxM=;
    public void GCI=(double x, double y, int value);
    public void GSI=(double xMin, double xMax, double yMin, double yMax);
    public void GiI=();
    public List`1<int> GyI=();
    public FiI= 4RY=();
}
internal class 8RQ=.FRc= : ValueType {
    internal double Fhc=;
    internal double Fxc=;
}
internal class 8RQ=.FRg= : ValueType {
    internal float Fhg=;
    internal float Fxg=;
}
internal class 8RQ=.fRk= : Txo= {
    internal double Rhc=;
    internal double Dhk=;
    internal double Dxk=;
    internal double EBk=;
    internal double ERk=;
    internal double Ehk=;
    internal fRk=(string id, string desc);
    private void uhg=();
    internal virtual hRg= uxg=(hRg= pjConsts, Int32& pj_Error);
    internal virtual void whg=(XRg= lp, hRg= pjConsts, EBg= fac, Int32& pj_Error);
    internal virtual XRg= wBg=(XBo= xy, hRg= pjConsts, Int32& pj_Error);
    internal virtual XBo= wRg=(XRg= lp, hRg= pjConsts, Int32& pj_Error);
    private int Exk=(hRg= pjConsts, Double[] del, Int32& pj_Error);
}
internal class 8RQ=.FRk= : Txo= {
    internal double eRc=;
    internal double ehc=;
    internal double fBc=;
    internal int Fhk=;
    internal FRk=(string id, string desc);
    private void uhg=();
    internal virtual hRg= uxg=(hRg= pjConsts, Int32& pj_Error);
    internal virtual void whg=(XRg= lp, hRg= pjConsts, EBg= fac, Int32& pj_Error);
    internal virtual XRg= wBg=(XBo= xy, hRg= pjConsts, Int32& pj_Error);
    internal virtual XBo= wRg=(XRg= lp, hRg= pjConsts, Int32& pj_Error);
}
internal class 8RQ=.fSo= : gSo= {
    private static int hCQ=;
    private static int hSQ=;
    private static int hiQ=;
    private static int hyQ=;
    public bool fio=;
    public double fyo=;
    public double gCo=;
    public fSo=(yCY= poDefnIn);
    public virtual int rSc=(5yg= poMapFile);
    public virtual NCg= ric=();
    public virtual int ryc=(5yg= poMapFile);
    public virtual GSg= sCc=(yCY= poNewDefn);
    public virtual int sSc=(5yg= poMapFile, lSk= poObjHdr, bool bCoordBlockDataOnly, wig=& ppoCoordBlock);
    public virtual int sic=(5yg= poMapFile, lSk= poObjHdr, bool bCoordBlockDataOnly, wig=& ppoCoordBlock);
    public virtual int syc=(eyU= fp);
    public virtual int tCc=(eyU= fp);
    public virtual string xiY=();
    public virtual void tSc=(Stream fsOut);
}
internal class 8RQ=.fxk= : Txo= {
    internal double Rhc=;
    internal double Dhk=;
    internal double Dxk=;
    internal double EBk=;
    internal double ERk=;
    internal double Ehk=;
    internal fxk=(string id, string desc);
    private void uhg=();
    internal virtual hRg= uxg=(hRg= pjConsts, Int32& pj_Error);
    internal virtual void whg=(XRg= lp, hRg= pjConsts, EBg= fac, Int32& pj_Error);
    internal virtual XRg= wBg=(XBo= xy, hRg= pjConsts, Int32& pj_Error);
    internal virtual XBo= wRg=(XRg= lp, hRg= pjConsts, Int32& pj_Error);
    private int Exk=(hRg= pjConsts, Double[] del, Int32& pj_Error);
}
internal class 8RQ=.Fxk= : Txo= {
    internal double Rhc=;
    internal double yBg=;
    internal Fxk=(string id, string desc);
    private void uhg=();
    internal virtual hRg= uxg=(hRg= pjConsts, Int32& pj_Error);
    internal virtual void whg=(XRg= lp, hRg= pjConsts, EBg= fac, Int32& pj_Error);
    internal virtual XRg= wBg=(XBo= xy, hRg= pjConsts, Int32& pj_Error);
    internal virtual XBo= wRg=(XRg= lp, hRg= pjConsts, Int32& pj_Error);
}
internal class 8RQ=.Fy8= : object {
    private string 9S4=;
    private string GC8=;
    private string GS8=;
    private Dictionary`2<string, string> Gi8=;
    private string Gy8=;
    private string HC8=;
    private string HS8=;
    private string Hi8=;
    private string Hy8=;
    private string IC8=;
    private Dictionary`2<string, string> IS8=;
    public Dictionary`2<string, string> Iy8= { get; }
    public string Ji8= { get; public set; }
    public string KS8= { get; public set; }
    public Dictionary`2<string, string> Ky8= { get; }
    public string Li8= { get; public set; }
    public string MS8= { get; public set; }
    public string NC8= { get; public set; }
    public string Ny8= { get; public set; }
    public string Oi8= { get; public set; }
    public string PS8= { get; public set; }
    public Dictionary`2<string, string> Ii8=();
    public string JC8=();
    public void JS8=(string value);
    public string Jy8=();
    public void KC8=(string value);
    public Dictionary`2<string, string> Ki8=();
    public string LC8=();
    public void LS8=(string value);
    public string Ly8=();
    public void MC8=(string value);
    public string Mi8=();
    public void My8=(string value);
    public string NS8=();
    public void Ni8=(string value);
    public string OC8=();
    public void OS8=(string value);
    public string Oy8=();
    public void PC8=(string value);
    public void ZRw=(BinaryReader reader);
    private void Pi8=(string NameFormatType, BinaryReader reader);
    private void Py8=(BinaryReader reader);
    private void QC8=(BinaryReader reader);
    private void QS8=(BinaryReader reader);
    private void Qi8=(BinaryReader reader);
    private void Qy8=(BinaryReader reader);
    private void RC8=(BinaryReader reader);
    private void RS8=(BinaryReader reader);
    private bool Ri8=(string col);
}
internal class 8RQ=.Fyc= : NiY= {
    protected int GCc=;
    protected OCc=[] GSc=;
    protected Double[] Gic=;
    protected void Gyc=();
    protected void HCc=();
    public virtual OiY= /SY=(String& ppszDstText);
    public virtual 8yY= 9iY=();
    public virtual void 9yY=(qyY= psEnvelope);
    public virtual void NyY=(KSc= poPoint);
    public virtual void OCY=(KSc= poPoint);
    public int HSc=();
    public void Hic=(int i, KSc= poPoint);
    public double Hyc=(int i);
    public double ICc=(int i);
    public double ISc=(int iVertex);
    public virtual void ACc=(int nNewDimension);
    public void Iic=(int nNewPointCount);
    public void Iyc=(int iPoint, double xIn, double yIn);
    public void Iyc=(int iPoint, double xIn, double yIn, double zIn);
    public void JCc=(int nPointsIn, OCc=[] paoPointsIn, Double[] padfZ);
    public void JCc=(int nPointsIn, Double[] padfX, int indexX, Double[] padfY, int indexY, Double[] padfZ, int indexZ);
    public void JSc=(double x, double y);
    public virtual PyY= /iY=();
    public virtual string /yY=();
}
internal static class 8RQ=.FyE= : object {
    [DebuggerHiddenAttribute]
public static void GCE=(T arg, string argName);
    [DebuggerHiddenAttribute]
public static void GCE=(Nullable`1<T> arg, string argName);
    [DebuggerHiddenAttribute]
public static void GSE=(T arg, string argName);
    [DebuggerHiddenAttribute]
public static void GCE=(IEnumerable`1<T> arg, string argName, bool assertContentsNotNull);
    [DebuggerHiddenAttribute]
public static void GiE=(string arg, string argName);
    [DebuggerHiddenAttribute]
public static void GiE=(IEnumerable arg, string argName);
    [DebuggerHiddenAttribute]
public static void GiE=(ICollection arg, string argName);
    [DebuggerHiddenAttribute]
public static void GyE=(string arg, string argName);
    [DebuggerHiddenAttribute]
public static void HCE=(TEnum enumValue, string argName);
    [DebuggerHiddenAttribute]
public static void HCE=(TEnum enumValue, string argName, TEnum[] validValues);
    private static bool HSE=(string arg);
    private static IEnumerable`1<T> HiE=();
}
[ExtensionAttribute]
internal static class 8RQ=.FyQ= : object {
    [ExtensionAttribute]
public static void bBo=(ProjectionConverter projection, Feature feature);
}
internal enum 8RQ=.FyU= : Enum {
    public int value__;
    public static FyU= GCU=;
    public static FyU= GSU=;
    public static FyU= GiU=;
    public static FyU= GyU=;
}
internal class 8RQ=.GBc= : object {
    internal string VRQ=;
    internal XRg= GRc=;
    internal XRg= Ghc=;
    internal XBg= Gxc=;
    internal FRg=[] HBc=;
}
internal class 8RQ=.GBg= : object {
    internal double GRg=;
    internal double Ghg=;
    internal double Gxg=;
    internal double HBg=;
    internal double HRg=;
    internal double Hhg=;
}
internal class 8RQ=.gBk= : Txo= {
    internal gBk=(string id, string desc);
    private void uhg=();
    internal virtual hRg= uxg=(hRg= pjConsts, Int32& pj_Error);
    internal virtual void whg=(XRg= lp, hRg= pjConsts, EBg= fac, Int32& pj_Error);
    internal virtual XRg= wBg=(XBo= xy, hRg= pjConsts, Int32& pj_Error);
    internal virtual XBo= wRg=(XRg= lp, hRg= pjConsts, Int32& pj_Error);
}
internal class 8RQ=.GBk= : Txo= {
    internal GBk=(string id, string desc);
    private void uhg=();
    internal virtual hRg= uxg=(hRg= pjConsts, Int32& pj_Error);
    internal virtual void whg=(XRg= lp, hRg= pjConsts, EBg= fac, Int32& pj_Error);
    internal virtual XRg= wBg=(XBo= xy, hRg= pjConsts, Int32& pj_Error);
    internal virtual XBo= wRg=(XRg= lp, hRg= pjConsts, Int32& pj_Error);
}
internal class 8RQ=.GC0= : object {
    private int GS0=;
    [CompilerGeneratedAttribute]
private int lCw=;
    [CompilerGeneratedAttribute]
private byte Gi0=;
    [CompilerGeneratedAttribute]
private List`1<List`1<LC0=>> Gy0=;
    [CompilerGeneratedAttribute]
private List`1<List`1<string>> HC0=;
    [CompilerGeneratedAttribute]
private List`1<RectangleShape> HS0=;
    public int ryw= { get; private set; }
    public byte IC0= { get; private set; }
    public List`1<List`1<LC0=>> Iy0= { get; private set; }
    public List`1<List`1<string>> Ji0= { get; private set; }
    public List`1<RectangleShape> KS0= { get; private set; }
    public GC0=(int treParameter);
    [CompilerGeneratedAttribute]
private void riw=(int value);
    [CompilerGeneratedAttribute]
public int rSw=();
    [CompilerGeneratedAttribute]
private void Hy0=(byte value);
    [CompilerGeneratedAttribute]
public byte Hi0=();
    [CompilerGeneratedAttribute]
private void Ii0=(List`1<List`1<LC0=>> value);
    [CompilerGeneratedAttribute]
public List`1<List`1<LC0=>> IS0=();
    [CompilerGeneratedAttribute]
private void JS0=(List`1<List`1<string>> value);
    [CompilerGeneratedAttribute]
public List`1<List`1<string>> JC0=();
    [CompilerGeneratedAttribute]
private void KC0=(List`1<RectangleShape> value);
    [CompilerGeneratedAttribute]
public List`1<RectangleShape> Jy0=();
    public void EC0=(tyw= RTree, int accuracy);
    private void Ki0=(giw= rNode, int accuracy, tyw= RTree);
    private void Ky0=(giw= rNode, List`1<giw=> list, tyw= rRtee);
    private void Ky0=(giw= rNode, List`1<aiw=> list);
}
internal class 8RQ=.GCg= : gSo= {
    private static int hCQ=;
    private static int hSQ=;
    private static int hiQ=;
    private static int hyQ=;
    public double qSc=;
    public double qic=;
    public double qyc=;
    public double rCc=;
    public GCg=(yCY= poDefnIn);
    public virtual int rSc=(5yg= poMapFile);
    public virtual NCg= ric=();
    public virtual int ryc=(5yg= poMapFile);
    public virtual GSg= sCc=(yCY= poNewDefn);
    public virtual int sSc=(5yg= poMapFile, lSk= poObjHdr, bool bCoordBlockDataOnly, wig=& ppoCoordBlock);
    public virtual int sic=(5yg= poMapFile, lSk= poObjHdr, bool bCoordBlockDataOnly, wig=& ppoCoordBlock);
    public virtual int syc=(eyU= fp);
    public virtual int tCc=(eyU= fp);
    public virtual string xiY=();
    public virtual void tSc=(Stream fsOut);
}
internal class 8RQ=.GCo= : object {
    private byte GSo=;
    private byte Gio=;
    private byte Gyo=;
    private Double[] HCo=;
    private short HSo=;
    private double Hio=;
    private double Hyo=;
    private double ICo=;
    private Double[] ISo=;
    private byte Iio=;
    private byte Iyo=;
    private double JCo=;
    private double JSo=;
    private double Jio=;
    private double Jyo=;
    private double KCo=;
    private double KSo=;
    public byte LCo= { get; public set; }
    public byte Lyo= { get; public set; }
    public byte Mio= { get; public set; }
    public Double[] NSo= { get; public set; }
    public short OCo= { get; public set; }
    public double Oyo= { get; public set; }
    public double Pio= { get; public set; }
    public double QSo= { get; public set; }
    public Double[] RCo= { get; public set; }
    public byte Ryo= { get; public set; }
    public byte Sio= { get; public set; }
    public double TSo= { get; public set; }
    public double UCo= { get; public set; }
    public double Uyo= { get; public set; }
    public double Vio= { get; public set; }
    public double WSo= { get; public set; }
    public double XCo= { get; public set; }
    public GCo=(byte nProjId, byte nEllipsoidId, byte nUnitsId, Double[] adProjParams, short nDatumId, double dDatumShiftX, double dDatumShiftY, double dDatumShiftZ, Double[] adDatumParams);
    public byte Kio=();
    public void Kyo=(byte value);
    public byte LSo=();
    public void Lio=(byte value);
    public byte MCo=();
    public void MSo=(byte value);
    public Double[] Myo=();
    public void NCo=(Double[] value);
    public short Nio=();
    public void Nyo=(short value);
    public double OSo=();
    public void Oio=(double value);
    public double PCo=();
    public void PSo=(double value);
    public double Pyo=();
    public void QCo=(double value);
    public Double[] Qio=();
    public void Qyo=(Double[] value);
    public byte RSo=();
    public void Rio=(byte value);
    public byte SCo=();
    public void SSo=(byte value);
    public double Syo=();
    public void TCo=(double value);
    public double Tio=();
    public void Tyo=(double value);
    public double USo=();
    public void Uio=(double value);
    public double VCo=();
    public void VSo=(double value);
    public double Vyo=();
    public void WCo=(double value);
    public double Wio=();
    public void Wyo=(double value);
    internal void vyc=();
}
internal class 8RQ=.gCs= : object {
    private Byte[] eRw=;
    private ulong 4x8=;
    private ulong gSs=;
    [CompilerGeneratedAttribute]
private int gis=;
    [CompilerGeneratedAttribute]
private ulong gys=;
    [CompilerGeneratedAttribute]
private Uys= hCs=;
    public int hys= { get; private set; }
    public ulong iis= { get; private set; }
    public Uys= jSs= { get; private set; }
    public gCs=(Byte[] tileBuffer);
    [CompilerGeneratedAttribute]
public int hSs=();
    [CompilerGeneratedAttribute]
private void his=(int value);
    [CompilerGeneratedAttribute]
public ulong iCs=();
    [CompilerGeneratedAttribute]
private void iSs=(ulong value);
    [CompilerGeneratedAttribute]
public Uys= iys=();
    [CompilerGeneratedAttribute]
private void jCs=(Uys= value);
    public long jis=();
    public Byte[] jys=();
    public List`1<UInt32> kCs=();
    public double kSs=();
    public float kis=();
    public string kys=(ulong length);
    public bool lCs=();
    public ulong lSs=();
    private void lis=(ulong skip);
}
internal enum 8RQ=.GCw= : Enum {
    public byte value__;
    public static GCw= GSw=;
    public static GCw= yx8=;
    public static GCw= Giw=;
    public static GCw= Gyw=;
}
internal class 8RQ=.gDE= : azE= {
    private static string ezE=;
    private static string fDE=;
    public virtual StyleJsonDocument ahU=(JObject jsonObject);
    protected static List`1<JToken> fjE=(JObject jsonObject);
    protected static List`1<ValueTuple`2<int, JObject>> fzE=(JObject jObject);
}
internal class 8RQ=.ghk= : Txo= {
    internal ghk=(string id, string desc);
    private void uhg=();
    internal virtual hRg= uxg=(hRg= pjConsts, Int32& pj_Error);
    internal virtual void whg=(XRg= lp, hRg= pjConsts, EBg= fac, Int32& pj_Error);
    internal virtual XRg= wBg=(XBo= xy, hRg= pjConsts, Int32& pj_Error);
    internal virtual XBo= wRg=(XRg= lp, hRg= pjConsts, Int32& pj_Error);
}
internal class 8RQ=.Ghk= : Txo= {
    private double ERg=;
    private double Gxk=;
    private double HBk=;
    private double HRk=;
    private double Hhk=;
    private double Hxk=;
    private double 1Bc=;
    internal Ghk=(string id, string desc);
    private void uhg=();
    internal virtual hRg= uxg=(hRg= pjConsts, Int32& pj_Error);
    internal virtual void whg=(XRg= lp, hRg= pjConsts, EBg= fac, Int32& pj_Error);
    private XRg= zxg=(XBo= xy, hRg= pjConsts, Int32& pj_Error);
    private XRg= zRg=(XBo= xy, hRg= pjConsts, Int32& pj_Error);
    private XBo= 0hg=(XRg= lp, hRg= pjConsts, Int32& pj_Error);
    private XBo= 0Bg=(XRg= lp, hRg= pjConsts, Int32& pj_Error);
    internal virtual XRg= wBg=(XBo= xy, hRg= pjConsts, Int32& pj_Error);
    internal virtual XBo= wRg=(XRg= lp, hRg= pjConsts, Int32& pj_Error);
}
internal enum 8RQ=.giA= : Enum {
    public int value__;
    public static giA= gyA=;
    public static giA= hCA=;
    public static giA= hSA=;
    public static giA= hiA=;
    public static giA= hyA=;
    public static giA= iCA=;
    public static giA= iSA=;
    public static giA= fyA=;
}
internal class 8RQ=.GiQ= : ValueType {
    public long GyQ=;
    public float HCQ=;
    public float HSQ=;
    public float HiQ=;
    public float HyQ=;
    public GiQ=(Byte[] buffer);
}
internal class 8RQ=.giw= : object {
    private int gyw=;
    private int hCw=;
    private int hSw=;
    private double hiw=;
    private double hyw=;
    private double iCw=;
    private double hBk=;
    private aiw= iSw=;
    private aiw= iiw=;
    private double iyw=;
    [CompilerGeneratedAttribute]
private 4Cs= YiM=;
    [CompilerGeneratedAttribute]
private RectangleShape jCw=;
    [CompilerGeneratedAttribute]
private int jSw=;
    [CompilerGeneratedAttribute]
private int jiw=;
    [CompilerGeneratedAttribute]
private bool jyw=;
    [CompilerGeneratedAttribute]
private int kCw=;
    [CompilerGeneratedAttribute]
private List`1<aiw=> kSw=;
    [CompilerGeneratedAttribute]
private List`1<aiw=> kiw=;
    [CompilerGeneratedAttribute]
private int kyw=;
    [CompilerGeneratedAttribute]
private int lCw=;
    public 4Cs= Viw= { get; private set; }
    public RectangleShape lyw= { get; public set; }
    public int miw= { get; private set; }
    public int nSw= { get; private set; }
    public bool oCw= { get; private set; }
    public int oyw= { get; private set; }
    public List`1<aiw=> piw= { get; private set; }
    public List`1<aiw=> qSw= { get; public set; }
    public int rCw= { get; private set; }
    public int ryw= { get; public set; }
    public giw=(4Cs= nType, int nMax, int nMin, int depth, double extentWidthLimitation, int accuracy);
    [CompilerGeneratedAttribute]
private void VSw=(4Cs= value);
    [CompilerGeneratedAttribute]
public 4Cs= VCw=();
    [CompilerGeneratedAttribute]
public RectangleShape lSw=();
    [CompilerGeneratedAttribute]
public void liw=(RectangleShape value);
    [CompilerGeneratedAttribute]
private void mSw=(int value);
    [CompilerGeneratedAttribute]
public int mCw=();
    [CompilerGeneratedAttribute]
private void nCw=(int value);
    [CompilerGeneratedAttribute]
public int myw=();
    [CompilerGeneratedAttribute]
private void nyw=(bool value);
    [CompilerGeneratedAttribute]
public bool niw=();
    [CompilerGeneratedAttribute]
private void oiw=(int value);
    [CompilerGeneratedAttribute]
public int oSw=();
    [CompilerGeneratedAttribute]
private void pSw=(List`1<aiw=> value);
    [CompilerGeneratedAttribute]
public List`1<aiw=> pCw=();
    [CompilerGeneratedAttribute]
public List`1<aiw=> pyw=();
    [CompilerGeneratedAttribute]
public void qCw=(List`1<aiw=> value);
    [CompilerGeneratedAttribute]
private void qyw=(int value);
    [CompilerGeneratedAttribute]
public int qiw=();
    [CompilerGeneratedAttribute]
public void riw=(int value);
    [CompilerGeneratedAttribute]
public int rSw=();
    public void /iE=(aiw= value);
    public bool sCw=(aiw= value);
    public giw= sSw=();
    public void Dh8=(aiw= DesEntry, List`1& RTree, bool isLeaf);
    public aiw= siw=(aiw= DesEntry, bool isLeaf);
    public RectangleShape syw=();
    public void tCw=(int NodeIndex, int EntryIndex);
    public void tSw=(int index, List`1& RTree);
    private void VB8=();
    private void tiw=(List`1<aiw=> TempAllEntrys, bool isLeaf);
    private aiw= Yx8=(List`1<aiw=> SelectEntrys, bool isLeaf);
}
internal class 8RQ=.gRg= : object {
    internal bool ghg=;
    internal double gxg=;
    internal int Fxc=;
    internal string hBg=;
}
internal class 8RQ=.gRk= : Txo= {
    internal gRk=(string id, string desc);
    private void uhg=();
    internal virtual hRg= uxg=(hRg= pjConsts, Int32& pj_Error);
    internal virtual void whg=(XRg= lp, hRg= pjConsts, EBg= fac, Int32& pj_Error);
    internal virtual XRg= wBg=(XBo= xy, hRg= pjConsts, Int32& pj_Error);
    internal virtual XBo= wRg=(XRg= lp, hRg= pjConsts, Int32& pj_Error);
}
internal class 8RQ=.GRk= : Txo= {
    internal GRk=(string id, string desc);
    private void uhg=();
    internal virtual hRg= uxg=(hRg= pjConsts, Int32& pj_Error);
    internal virtual void whg=(XRg= lp, hRg= pjConsts, EBg= fac, Int32& pj_Error);
    internal virtual XRg= wBg=(XBo= xy, hRg= pjConsts, Int32& pj_Error);
    internal virtual XBo= wRg=(XRg= lp, hRg= pjConsts, Int32& pj_Error);
}
internal class 8RQ=.gSc= : object {
    private string SSc=;
    private gSc=[] gic=;
    private gSc= gyc=;
    private int hCc=;
    public gSc=[] hyc= { get; public set; }
    public gSc=(string pszValueIn);
    public gSc=[] hSc=();
    public void hic=(gSc=[] value);
    private int 4hY=();
    public int iCc=();
    public gSc= jh8=(int iChild);
    public gSc= 3hY=(string pszName);
    public void iSc=(gSc= poNew, int iChild);
    public void iic=(gSc= poNew);
    public int 3xY=(string pszValue);
    public void iyc=(int iChild);
    public string jCc=();
    public void jSc=(string pszNewValue);
    public gSc= 4RY=();
    public OiY= /SY=(String& ppszResult);
}
internal class 8RQ=.GSg= : sCY= {
    protected int Gig=;
    protected double nSU=;
    protected double niU=;
    protected double nyU=;
    protected double oCU=;
    protected int Gyg=;
    protected int HCg=;
    protected int HSg=;
    protected int Hig=;
    protected int Hyg=;
    protected int ICg=;
    public GSg=(yCY= poDefnIn);
    protected void ISg=(GSg= poDestFeature);
    public virtual int rSc=(5yg= poMapFile);
    public static GSg= Iig=(int nMapInfoType, yCY= poDefn);
    public virtual GSg= sCc=(yCY= poNewDefn);
    public virtual NCg= ric=();
    public virtual int Iyg=();
    public virtual int ryc=(5yg= poMapFile);
    public void JCg=(bool bDeleted);
    public virtual int JSg=(5ic= poDATFile);
    public virtual int sSc=(5yg= poMapFile, lSk= poObjHdr, bool bCoordDataOnly, wig=& ppoCoordBlock);
    public virtual int Jig=(5ic= poDATFile, lCg= poINDFile, Int32[] panIndexNo);
    public virtual int sic=(5yg= poMapFile, lSk= poObjHdr, bool bCoordDataOnly, wig=& ppoCoordBlock);
    public bool Jyg=(5yg= poMapFile);
    public void KCg=(int nMapInfoType, bool bCompr, int nComprOrgX, int nComprOrgY, int nXMin, int nYMin, int nXMax, int nYMax);
    public virtual int KSg=(eyU= fp);
    public virtual int syc=(eyU= fp);
    public virtual int Kig=(eyU= fp);
    public virtual int tCc=(eyU= fp);
    public void Kyg=(double dXMin, double dYMin, double dXMax, double dYMax);
    public void LCg=(Double& dXMin, Double& dYMin, Double& dXMax, Double& dYMax);
    public void LSg=(int nXMin, int nYMin, int nXMax, int nYMax);
    public void Lig=(Int32& nXMin, Int32& nYMin, Int32& nXMax, Int32& nYMax);
    public virtual void Lyg=(Stream fsOut);
    public virtual void tSc=(Stream fsOut);
}
internal class 8RQ=.gSo= : GSg= {
    private bool rSk=;
    private bool xik=;
    private double qSc=;
    private double qic=;
    private Rig= gio=;
    private MCg= gyo=;
    public yyk= PyU= { get; public set; }
    public xSc= HyU= { get; public set; }
    public int QiU= { get; public set; }
    public int IiU= { get; public set; }
    public gSo=(yCY= poDefnIn);
    private int hCo=(3ig=[]& ppasSecHdrs, 5yg= poMAPFile, bool bFlag);
    private int hSo=(Lic= poPolygon, 3ig=[]& pasSecHdrs, 5yg= poMapFile, Int32& iLastRing);
    public virtual NCg= ric=();
    public virtual int ryc=(5yg= poMapFile);
    public virtual GSg= sCc=(yCY= poNewDefn);
    public int hio=();
    public Eic= hyo=(int nRequestedRingIndex);
    public virtual int sSc=(5yg= poMapFile, lSk= poObjHdr, bool bCoordBlockDataOnly, wig=& ppoCoordBlock);
    public virtual int sic=(5yg= poMapFile, lSk= poObjHdr, bool bCoordBlockDataOnly, wig=& ppoCoordBlock);
    public virtual int syc=(eyU= fp);
    public virtual int tCc=(eyU= fp);
    public virtual string xiY=();
    public virtual void tSc=(Stream fsOut);
    public int ySk=(Double& dX, Double& dY);
    public void yik=(double dX, double dY);
    public virtual int IyU=();
    public virtual xSc= JCU=();
    public virtual int JSU=();
    public virtual int JiU=();
    public virtual byte JyU=();
    public virtual byte KCU=();
    public virtual void KSU=(int clr);
    public virtual void KiU=(int clr);
    public virtual void KyU=(byte val);
    public virtual void LCU=(byte val);
    public virtual string LSU=();
    public virtual void LiU=(string pszStyleString);
    public virtual void LyU=(Stream fpOut);
    public virtual int QyU=();
    public virtual yyk= RCU=();
    public virtual byte RSU=();
    public virtual double RiU=();
    public virtual int RyU=();
    public virtual byte SCU=();
    public virtual int SSU=();
    public virtual string SiU=();
    public virtual void SyU=(byte val);
    public virtual void TCU=(double val);
    public virtual void TSU=(int val);
    public virtual void TiU=(byte val);
    public virtual void TyU=(int clr);
    public virtual void UCU=(string pszStyleString);
    public virtual void USU=(Stream fpOut);
    public sealed virtual void PiU=(yyk= value);
    public sealed virtual yyk= PSU=();
    public sealed virtual void HiU=(xSc= value);
    public sealed virtual xSc= HSU=();
    public sealed virtual int QCU=();
    public sealed virtual void QSU=(int value);
    public sealed virtual int ICU=();
    public sealed virtual void ISU=(int value);
}
internal class 8RQ=.gTE= : FilterCondition {
    private static string DSM=;
    private static string DiM=;
    private static string DyM=;
    private static char ECM=;
    [CompilerGeneratedAttribute]
private Regex ESM=;
    [CompilerGeneratedAttribute]
private String[] EiM=;
    [CompilerGeneratedAttribute]
private String[] EyM=;
    public Regex FiM= { get; public set; }
    public String[] GSM= { get; public set; }
    public String[] HCM= { get; public set; }
    internal gTE=(string columnName, string operation, string expression);
    [CompilerGeneratedAttribute]
public Regex FCM=();
    [CompilerGeneratedAttribute]
public void FSM=(Regex value);
    [CompilerGeneratedAttribute]
public String[] FyM=();
    [CompilerGeneratedAttribute]
public void GCM=(String[] value);
    [CompilerGeneratedAttribute]
public String[] GiM=();
    [CompilerGeneratedAttribute]
public void GyM=(String[] value);
    internal virtual bool 3yI=(KeyValuePair`2<string, string> v);
    internal virtual bool 3yI=(Feature feature);
}
internal abstract class 8RQ=.gx8= : object {
    internal kR8= hB8=;
    internal UInt32 qxM=;
    internal static int hR8=;
    internal static int hh8=;
    internal kR8= iR8= { get; internal set; }
    public UInt32 jB8= { get; public set; }
    public static gx8= jR8=(Gist_Ext_Id extId);
    internal kR8= hx8=();
    internal void iB8=(kR8= value);
    public UInt32 ih8=();
    public void ix8=(UInt32 value);
    internal UInt32 jh8=();
    internal abstract virtual nR8= gR8=();
    internal virtual xx8= gB8=();
    internal abstract virtual bool ZRw=(BinaryReader r, bool isFloat);
    internal abstract virtual bool cxw=(BinaryWriter w, bool isFloat);
    internal abstract virtual bool WR8=(nR8= rect);
    internal abstract virtual bool WB8=(nR8= rect);
    internal abstract virtual bool Wh8=(nR8= rect);
    internal abstract virtual int MB8=(bool isFloat);
    internal abstract virtual double gh8=();
}
internal class 8RQ=.gxk= : Txo= {
    internal double hBk=;
    internal double xRg=;
    internal double xhg=;
    internal double 9hg=;
    internal double hRk=;
    internal double hhk=;
    internal double hxk=;
    internal double ERg=;
    internal double iBk=;
    internal double iRk=;
    internal double ihk=;
    internal double ixk=;
    internal int zBg=;
    internal int jBk=;
    internal gxk=(string id, string desc);
    private void uhg=();
    internal virtual hRg= uxg=(hRg= pjConsts, Int32& pj_Error);
    internal virtual void whg=(XRg= lp, hRg= pjConsts, EBg= fac, Int32& pj_Error);
    internal virtual XRg= wBg=(XBo= xy, hRg= pjConsts, Int32& pj_Error);
    internal virtual XBo= wRg=(XRg= lp, hRg= pjConsts, Int32& pj_Error);
}
internal class 8RQ=.gy0= : object {
    [CompilerGeneratedAttribute]
private UInt32 hC0=;
    [CompilerGeneratedAttribute]
private UInt32 hS0=;
    [CompilerGeneratedAttribute]
private List`1<string> hi0=;
    [CompilerGeneratedAttribute]
private Dictionary`2<string, int> hy0=;
    public UInt32 ii0= { get; private set; }
    public UInt32 jS0= { get; private set; }
    public List`1<string> kC0= { get; public set; }
    public Dictionary`2<string, int> ky0= { get; private set; }
    [CompilerGeneratedAttribute]
public UInt32 iC0=();
    [CompilerGeneratedAttribute]
private void iS0=(UInt32 value);
    [CompilerGeneratedAttribute]
public UInt32 iy0=();
    [CompilerGeneratedAttribute]
private void jC0=(UInt32 value);
    [CompilerGeneratedAttribute]
public void jy0=(List`1<string> value);
    [CompilerGeneratedAttribute]
public List`1<string> ji0=();
    [CompilerGeneratedAttribute]
public Dictionary`2<string, int> kS0=();
    [CompilerGeneratedAttribute]
private void ki0=(Dictionary`2<string, int> value);
    public void lC0=(List`1<string> lbls, Encoding encoding);
    private void lS0=(List`1<string> lbls, Encoding encoding);
}
internal class 8RQ=.gy4= : object {
    private Ai4= hC4=;
    private ki4= VS4=;
    private mC4= hS4=;
    private VC4= hi4=;
    private ai4= Vi4=;
    private Si4= hy4=;
    private Ry4= Vy4=;
    private Stream GC4=;
    private double iyw=;
    private string YCw=;
    [CompilerGeneratedAttribute]
private int kCw=;
    public ki4= iS4= { get; }
    public mC4= iy4= { get; }
    public VC4= jS4= { get; }
    public int oyw= { get; public set; }
    public gy4=(Ai4= info, Stream stream, string password, double extentWidthLimitation);
    public ki4= iC4=();
    public mC4= ii4=();
    public VC4= jC4=();
    [CompilerGeneratedAttribute]
public int oSw=();
    [CompilerGeneratedAttribute]
public void oiw=(int value);
    public void ji4=(bool isEncrypted);
    public void jy4=();
    public void kC4=(Encoding encoding);
    public List`1<Feature> kS4=(xS0= range, int index, Dictionary`2<string, int> returningColumns, Xyw= encryptor);
    public List`1<Feature> kS4=(IEnumerable`1<string> featureIds, Dictionary`2<string, int> returningColumns, Xyw= encryptor);
}
internal enum 8RQ=.gyQ= : Enum {
    public int value__;
    public static gyQ= hCQ=;
    public static gyQ= hSQ=;
    public static gyQ= hiQ=;
    public static gyQ= hyQ=;
}
[ExtensionAttribute]
internal static class 8RQ=.hBU= : object {
    [ExtensionAttribute]
public static void hRU=(IList`1<T> initial, IEnumerable`1<T> collection);
    [ExtensionAttribute]
public static BindingFlags hhU=(BindingFlags bindingAttr, BindingFlags flag);
    [ExtensionAttribute]
public static Type hxU=(Type type);
    [ExtensionAttribute]
public static bool iBU=(Type type);
    [ExtensionAttribute]
public static MemberTypes iRU=(MemberInfo memberInfo);
    [ExtensionAttribute]
public static bool ihU=(Type type);
}
internal static class 8RQ=.HBU= : object {
    public static SKBitmap HRU=(Stream stream);
    public static SKBitmap HRU=(Byte[] bytes);
    public static SKBitmap HRU=(string pathFilename);
    public static SKBitmap HRU=(int width, int height);
    public static SKBitmap HRU=(int width, int height, GeoColorType colorType, GeoAlphaType alphaType);
    public static int HhU=(object image);
    public static int HxU=(object image);
    public static void IBU=(object image, float opacityFactor);
    public static Stream IRU=(object image, GeoImageFormat imageFormat, int quality);
    public static Byte[] IhU=(object image, GeoImageFormat imageFormat, int quality);
    public static void IxU=(object image, string fileName, GeoImageFormat imageFormat, int quality);
    public static void IxU=(object image, Stream stream, GeoImageFormat imageFormat, int quality);
    public static SKBitmap JBU=(object image, int width, int height);
    public static SKBitmap JRU=(object image, DrawingRectangle srcRect, bool extendCanvasIfCutRectLargerThanImage);
    public static void JhU=(object destImage, GeoImage srcImage, float pointX, float pointY);
    public static GeoImage GBU=(GeoImage image, bool isGrayscale, bool isNegative, float transparency, float redTranslation, float greenTranslation, float blueTranslation);
    public static GeoImage GRU=(GeoImage image, Dictionary`2<GeoColor, GeoColor> colorMappings);
    public static void JxU=(object image, GeoColor[] pixels);
    public static IntPtr KBU=(object image);
    private static SKData KRU=(SKBitmap bitmap, GeoImageFormat imageFormat, int quality);
    private static SKEncodedImageFormat KhU=(GeoImageFormat imageFormat);
    private static Single[][] KxU=(bool isGrayscale, bool isNegative, float transparency, float redTranslation, float greenTranslation, float blueTranslation);
    private static Single[][] LBU=(float transparency);
    private static Single[][] LRU=(float transparency);
    private static Single[][] LhU=(float redTranslation, float greenTranslation, float blueTranslation, float transparency);
}
internal interface 8RQ=.HCU= {
    public xSc= HyU= { get; public set; }
    public int IiU= { get; public set; }
    public abstract virtual int IyU=();
    public abstract virtual xSc= JCU=();
    public abstract virtual int JSU=();
    public abstract virtual int JiU=();
    public abstract virtual byte JyU=();
    public abstract virtual byte KCU=();
    public abstract virtual void KSU=(int clr);
    public abstract virtual void KiU=(int clr);
    public abstract virtual void KyU=(byte val);
    public abstract virtual void LCU=(byte val);
    public abstract virtual string LSU=();
    public abstract virtual void LiU=(string pszStyleString);
    public abstract virtual void LyU=(Stream fpOut);
    public abstract virtual xSc= HSU=();
    public abstract virtual void HiU=(xSc= value);
    public abstract virtual int ICU=();
    public abstract virtual void ISU=(int value);
}
internal class 8RQ=.HCw= : BinaryWriter {
    public HCw=(Stream output);
    public void HSw=(byte Value, int length);
}
internal class 8RQ=.hiI= : object {
    private static double hyI=;
    public static yyI= iCI=(GridCell[0...,0...] gridPoints, double level, double noDataValue);
    private static Collection`1<Collection`1<GridCell>> iSI=(double level, WCI= functionGrid);
    private static Collection`1<Collection`1<GridCell>> iiI=(double level, WCI= functionGrid);
    private static Collection`1<Collection`1<GridCell>> iyI=(double level, WCI= functionGrid);
    private static Collection`1<GridCell> jCI=(int leftTopGridIndexX, int leftTopGridIndexY, GridCell enterPoint, wCI= enterDirection, WCI= functionGrid);
}
internal static class 8RQ=.Hiw= : object {
    public static MultilineShape Hyw=(LineShape lineShap, double ratio);
    public static MultilineShape Hyw=(MultilineShape multiLineShape, double ratio);
    private static List`1<PCw=> ICw=(List`1<PCw=> points, double ratio);
    private static void ISw=(List`1<PCw=> value);
}
internal static class 8RQ=.hjE= : object {
    internal static string hzE=;
    internal static string iDE=;
    internal static string iTE=;
    internal static string ijE=;
    internal static string izE=;
    internal static string jDE=;
    internal static string jTE=;
    internal static string jjE=;
    internal static string jzE=;
    internal static string kDE=;
    internal static String[] kTE=;
    internal static String[] kjE=;
    internal static String[] kzE=;
    internal static String[] lDE=;
    private static hjE=();
}
internal static class 8RQ=.HRc= : object {
    internal static double Hhc=;
    internal static double Hxc=;
    internal static double IBc=;
    internal static double IRc=;
    internal static double Ihc=;
    internal static double Ixc=;
    internal static double JBc=;
    internal static double HhY=;
    internal static double JRc=;
    internal static double Jhc=;
    internal static double Jxc=;
    internal static double KBc=;
    internal static double KRc=;
    internal static double Khc=;
    internal static double Kxc=;
    internal static double LBc=;
    internal static double LRc=;
    internal static double Lhc=;
    internal static double Lxc=;
    internal static double MBc=;
    internal static double MRc=;
    internal static double Mhc=;
    internal static double Mxc=;
    internal static double NBc=;
    internal static double NRc=;
    internal static double Nhc=;
    internal static int Nxc=;
    internal static int OBc=;
    internal static int ORc=;
    internal static int Ohc=;
    internal static int Oxc=;
    internal static int PBc=;
    internal static int PRc=;
    internal static int Phc=;
    internal static int Pxc=;
    internal static double QBc=;
    internal static double QRc=;
    internal static double IRY=;
    internal static double Qhc=;
    internal static double Qxc=;
    internal static double RBc=;
    internal static double RRc=;
    internal static double Rhc=;
    internal static double Rxc=;
    internal static double SBc=;
    internal static double SRc=;
    internal static double Shc=;
    internal static double Sxc=;
    internal static double TBc=;
    internal static double TRc=;
    internal static double Thc=;
    internal static double Txc=;
    internal static double UBc=;
    internal static double URc=;
    internal static double Uhc=;
    internal static double Uxc=;
    internal static double VBc=;
    internal static double VRc=;
    internal static int Vhc=;
    internal static double Vxc=;
    internal static double WBc=;
    internal static double WRc=;
    internal static double Whc=;
    internal static double Wxc=;
    internal static double XBc=;
    internal static double XRc=;
    internal static double Xhc=;
    internal static double Xxc=;
    internal static int YBc=;
    internal static double YRc=;
    internal static double Yhc=;
    internal static double Yxc=;
    internal static double ZBc=;
    internal static double ZRc=;
    internal static double Zhc=;
    internal static double Zxc=;
    internal static double aBc=;
    internal static double aRc=;
    internal static double ahc=;
    internal static double axc=;
    internal static double bBc=;
    internal static double bRc=;
    internal static double bhc=;
    internal static double bxc=;
    internal static double cBc=;
    internal static double cRc=;
    internal static double chc=;
    internal static double cxc=;
    internal static double dBc=;
    internal static double dRc=;
    internal static double dhc=;
    internal static double dxc=;
    internal static double eBc=;
    internal static double eRc=;
    internal static double ehc=;
    internal static double exc=;
    internal static double fBc=;
    internal static double fRc=;
    internal static int fhc=;
    internal static double fxc=;
    internal static double gBc=;
    internal static double gRc=;
    internal static double ghc=;
    internal static double gxc=;
    internal static double hBc=;
    internal static double hRc=;
    internal static double hhc=;
    internal static double hxc=;
    internal static double iBc=;
    internal static double iRc=;
    internal static double ihc=;
    internal static double ixc=;
    internal static int jBc=;
    internal static int jRc=;
    internal static double jhc=;
    internal static double jxc=;
    internal static double kBc=;
    internal static double kRc=;
    internal static double khc=;
    internal static double kxc=;
    internal static double lBc=;
    internal static double lRc=;
    internal static double lhc=;
    internal static double lxc=;
    internal static double mBc=;
    internal static double mRc=;
    internal static double mhc=;
    internal static double mxc=;
    internal static double nBc=;
    internal static double nRc=;
    internal static double nhc=;
    internal static double nxc=;
    internal static double oBc=;
    internal static double oRc=;
    internal static double ohc=;
    internal static double oxc=;
    internal static double pBc=;
    internal static double pRc=;
    internal static double phc=;
    internal static byte pxc=;
    internal static byte qBc=;
    internal static byte qRc=;
    internal static byte qhc=;
    internal static int qxc=;
    internal static int rBc=;
    internal static double rRc=;
    internal static double rhc=;
    internal static double rxc=;
    internal static double sBc=;
    internal static double sRc=;
    internal static int shc=;
    internal static double sxc=;
    internal static double tBc=;
    internal static double tRc=;
    internal static double thc=;
    internal static double txc=;
    internal static double uBc=;
    internal static double uRc=;
    internal static double uhc=;
    internal static double uxc=;
    internal static double vBc=;
    internal static double vRc=;
    internal static double vhc=;
    internal static int vxc=;
    internal static double wBc=;
    internal static double wRc=;
    internal static double whc=;
    internal static double wxc=;
    internal static double xBc=;
    internal static double xRc=;
    internal static double xhc=;
    internal static int xxc=;
    internal static double yBc=;
    internal static double yRc=;
    internal static int yhc=;
    internal static int yxc=;
    internal static int zBc=;
    internal static double zRc=;
    internal static double zhc=;
    internal static double zxc=;
    internal static double 0Bc=;
    internal static double 0Rc=;
    internal static int 0hc=;
    internal static double 0xc=;
    internal static double 1Bc=;
    internal static double 1Rc=;
    internal static double 1hc=;
    internal static double 1xc=;
    internal static double 2Bc=;
    internal static double 2Rc=;
    internal static int 2hc=;
    internal static double 2xc=;
    internal static int 3Bc=;
    internal static double 3Rc=;
    internal static double 3hc=;
    internal static double 3xc=;
    internal static double 4Bc=;
    internal static double 4Rc=;
    internal static double 4hc=;
    internal static double 4xc=;
    internal static double 5Bc=;
    internal static double 5Rc=;
    internal static double 5hc=;
    internal static double 5xc=;
    internal static double 6Bc=;
    internal static double 6Rc=;
    internal static double 6hc=;
    internal static double 6xc=;
    internal static double 7Bc=;
    internal static double 7Rc=;
    internal static double 7hc=;
    internal static double 7xc=;
    internal static double 8Bc=;
    internal static double 8Rc=;
    internal static double 8hc=;
    internal static double 8xc=;
    internal static double 9Bc=;
    internal static double 9Rc=;
    internal static double 9hc=;
    internal static long 9xc=;
    internal static long /Bc=;
    internal static long /Rc=;
    internal static long /hc=;
    internal static double 9hY=;
    internal static double /xc=;
    internal static double ABg=;
    internal static int ARg=;
    internal static double Ahg=;
    internal static double Axg=;
    internal static double BBg=;
    internal static string BRg=;
    internal static double Bhg=;
    internal static double Bxg=;
    private static HRc=();
}
internal class 8RQ=.hRg= : object {
    internal string hhg=;
    internal Dictionary`2<string, string> hxg=;
    internal bool iBg=;
    internal int iRg=;
    internal bool ihg=;
    internal bool ixg=;
    internal double jBg=;
    internal double jRg=;
    internal double jhg=;
    internal double jxg=;
    internal double kBg=;
    internal double kRg=;
    internal double khg=;
    internal double kxg=;
    internal double lBg=;
    internal double lRg=;
    internal double lhg=;
    internal double lxg=;
    internal double mBg=;
    internal double mRg=;
    internal double mhg=;
    internal Chg= mxg=;
    internal Double[] nBg=;
    internal double nRg=;
    internal double nhg=;
}
internal class 8RQ=.Hxg= : object {
    private Int32[] IBg=;
    private int IRg=;
    private List`1<RBo=> Ihg=;
    private string Ixg=;
    private List`1<RBo=> JBg=;
    private double JRg=;
    private double Jhg=;
    private bool Jxg=(Double[] height, bool z_is_temp, Int32& pj_Error);
    internal int KBg=(Txo= srcdefn, Txo= dstdefn, long point_count, int point_offset, Double[] height, Uho=[] uvList, Int32& pj_Error);
    internal static Dictionary`2<string, string> KRg=(String[] args);
    internal static void Khg=(Dictionary`2<string, string> paras, string arg);
    internal int Kxg=(Txo= srcdefn, Txo= dstdefn, long point_count, int point_offset, Uho=[] uvList, Double[] height, Int32& pj_Error);
    internal int LBg=(double a, double es, long point_count, int point_offset, Uho=[] uvList, Double[] height, Int32& pj_Error);
    private long LRg=(GBg= gi, double a, double b);
    private void Lhg=(GBg= gi, double x, double y, double z, Uho=[] uv, Double[] height, long io, Int32& pj_Error);
    private XRg= Lxg=(XBo= xy, Txo= p, Int32& pj_Error);
    private XBo= MBg=(double phi, double lambda, double lambda0);
    private double MRg=(double phi);
    private XRg= Mhg=(double x, double y, double cmeridian);
    private double Mxg=(double y);
    private double NBg=(int zone);
    private double NRg=(double deg);
    private double Nhg=(double rad);
    private int Nxg=(double lat, double lon, int zone, XBo=& xy);
    private XBo= OBg=(XRg= geodetic_loc, Txo= dstdefn, Int32& pj_Error);
    private int ORg=(Txo= dstdefn, long point_count, int point_offset, Uho=[] list, Double[] height, Int32& pj_Error);
    private int Ohg=(Txo= srcdefn, long point_count, int point_offset, Uho=[] list, Double[] height, Int32& pj_Error);
    internal int Oxg=(double src_a, double src_es, long point_count, int point_offset, Uho=[] list, Double[] height, Int32& pj_Error);
    private bool PBg=(GBg= gi, Uho=[] projUV, Double[] height, long io, Int32& pj_Error);
    private int PRg=(string nadgrids, int inverse, long point_count, int point_offset, Uho=[] uvList, Double[] height, Int32& pj_Error);
    private XRg= Phg=(XRg= input, int inverse, GBc= ct, Int32& pj_Error);
    private XRg= Pxg=(XRg= tb, GBc= ct);
    private bool QBg=(RBo= gi, Int32& pj_Error);
    private List`1<RBo=> QRg=(string nadgrids, Int32& grid_count, Int32& pj_Error);
    private bool Qhg=(Txo= srcdefn, Txo= dstdefn, Int32& pj_Error);
    private int Qxg=(string gridName, Int32& pj_Error);
    private void RBg=(string gridName, List`1<RBo=> giList, Int32& pj_Error);
    private void RRg=(Stream fs, RBo= gi, List`1<RBo=> giList, Int32& pj_Error);
    private void Rhg=(Stream fs, RBo= gi, Int32& pj_Error);
}
internal class 8RQ=.Hxo= : Txo= {
    internal double hBk=;
    internal double xRg=;
    internal double xhg=;
    internal double 9hg=;
    internal double hRk=;
    internal double hhk=;
    internal double hxk=;
    internal double ERg=;
    internal double iBk=;
    internal double iRk=;
    internal double ihk=;
    internal double ixk=;
    internal int zBg=;
    internal int jBk=;
    internal Hxo=(string id, string desc);
    private void uhg=();
    internal virtual hRg= uxg=(hRg= pjConsts, Int32& pj_Error);
    internal virtual void whg=(XRg= lp, hRg= pjConsts, EBg= fac, Int32& pj_Error);
    internal virtual XRg= wBg=(XBo= xy, hRg= pjConsts, Int32& pj_Error);
    internal virtual XBo= wRg=(XRg= lp, hRg= pjConsts, Int32& pj_Error);
}
internal enum 8RQ=.hyE= : Enum {
    public int value__;
    public static hyE= iCE=;
    public static hyE= iSE=;
    public static hyE= iiE=;
}
internal class 8RQ=.HyE= : object {
    private static string ICE=;
    private static IDictionary`2<Lz0=, XDocument> ISE=;
    private static object IiE=;
    private Type IyE=;
    private string JCE=;
    public HyE=(Type forType);
    public HyE=(Type forType, string resourceName);
    private HyE=(Type forType, string resourceName, int dummy);
    private static HyE=();
    [DebuggerHiddenAttribute]
public Exception JSE=(string exceptionKey, Object[] messageArgs);
    [DebuggerHiddenAttribute]
public Exception JSE=(string exceptionKey, Exception innerException, Object[] messageArgs);
    [DebuggerHiddenAttribute]
public Exception JSE=(string exceptionKey, Object[] constructorArgs, Exception innerException);
    [DebuggerHiddenAttribute]
public Exception JSE=(string exceptionKey, Object[] constructorArgs, Object[] messageArgs);
    [DebuggerHiddenAttribute]
public Exception JSE=(string exceptionKey, Object[] constructorArgs, Exception innerException, Object[] messageArgs);
    [DebuggerHiddenAttribute]
public void JiE=(bool condition, string exceptionKey, Object[] messageArgs);
    [DebuggerHiddenAttribute]
public void JiE=(bool condition, string exceptionKey, Exception innerException, Object[] messageArgs);
    [DebuggerHiddenAttribute]
public void JiE=(bool condition, string exceptionKey, Object[] constructorArgs, Exception innerException);
    [DebuggerHiddenAttribute]
public void JiE=(bool condition, string exceptionKey, Object[] constructorArgs, Object[] messageArgs);
    [DebuggerHiddenAttribute]
public void JiE=(bool condition, string exceptionKey, Object[] constructorArgs, Exception innerException, Object[] messageArgs);
    [DebuggerHiddenAttribute]
private static XDocument JyE=(Assembly assembly, string resourceName);
    private static int KCE=(Object[] arguments, ParameterInfo[] parameters);
    private static int KSE=(object argument, ParameterInfo parameter);
}
internal class 8RQ=.HyY= : object {
    public static double ICY=(List`1<string> papszFields, int iField, double dfDefault);
    public static OSc= ISY=(string pszCoordSys);
    public static string IiY=(OSc= poSR);
    public static bool IyY=(string pszCoordSys, Double& dXMin, Double& dYMin, Double& dXMax, Double& dYMax);
}
internal class 8RQ=.IBk= : Txo= {
    internal IBk=(string id, string desc);
    private void uhg=();
    internal virtual hRg= uxg=(hRg= pjConsts, Int32& pj_Error);
    internal virtual void whg=(XRg= lp, hRg= pjConsts, EBg= fac, Int32& pj_Error);
    internal virtual XRg= wBg=(XBo= xy, hRg= pjConsts, Int32& pj_Error);
    internal virtual XBo= wRg=(XRg= lp, hRg= pjConsts, Int32& pj_Error);
}
internal class 8RQ=.IBo= : Txo= {
    internal double 9hk=;
    internal double 9xk=;
    internal double /Bk=;
    internal double /Rk=;
    internal int zBg=;
    internal IBo=(string id, string desc);
    private void uhg=();
    internal virtual hRg= uxg=(hRg= pjConsts, Int32& pj_Error);
    internal virtual void whg=(XRg= lp, hRg= pjConsts, EBg= fac, Int32& pj_Error);
    internal virtual XRg= wBg=(XBo= xy, hRg= pjConsts, Int32& pj_Error);
    internal virtual XBo= wRg=(XRg= lp, hRg= pjConsts, Int32& pj_Error);
    private double /hk=(double phit, double sinphi, double eccen, Int32& pj_Error);
    private XBo= 0hg=(XRg= lp, hRg= pjConsts, Int32& pj_Error);
    private XBo= 0Bg=(XRg= lp, hRg= pjConsts, Int32& pj_Error);
    private XRg= zxg=(XBo= xy, hRg= pjConsts, Int32& pj_Error);
    private XRg= zRg=(XBo= xy, hRg= pjConsts, Int32& pj_Error);
}
internal class 8RQ=.IBY= : object {
    private static double IRY=;
    private static int IhY=;
    private static int IxY=;
    private static int JBY=;
    private static int JRY=;
    private static int JhY=;
    private static int JxY=;
    private static int KBY=;
    private static int KRY=;
    private static int KhY=;
    private static int KxY=;
    private static int LBY=;
    private static int LRY=;
    private static int LhY=;
    private static int LxY=;
    private static int MBY=;
    private static int MRY=;
    private static int MhY=;
    private static int MxY=;
    private static int NBY=;
    private static int NRY=;
    private static int NhY=;
    private static int NxY=;
    private static int OBY=;
    private static int ORY=;
    private static int OhY=;
    private static int OxY=;
    private static String[] PBY=;
    internal 1hY= PRY=;
    private bool PhY=;
    private double PxY=;
    private double QBY=;
    private double QRY=;
    private IFormatProvider QhY=;
    internal static String[] QxY=;
    internal static String[] RBY=;
    internal static String[] RRY=;
    internal static String[] RhY=;
    internal static String[] RxY=;
    internal static String[] SBY=;
    internal static String[] SRY=;
    internal static String[] ShY=;
    internal static String[] SxY=;
    internal static String[] TBY=;
    internal static String[] TRY=;
    internal static String[] ThY=;
    internal static String[] TxY=;
    internal static String[] UBY=;
    internal static String[] URY=;
    internal static String[] UhY=;
    internal static String[] UxY=;
    private static string VBY=;
    private static String[] VRY=;
    private static object VhY=;
    private static List`1<5xY=> VxY=;
    internal static String[] WRY= { get; }
    internal static List`1<5xY=> WxY= { get; }
    internal IBY=(IFormatProvider inputProvider);
    private static IBY=();
    private static void XBY=(String& datum);
    private static double XRY=(string angleValue, int uomAngle, IFormatProvider provider);
    private static bool XhY=(int nUOMAngleCode, String& ppszUOMName, Double& pdfInDegrees, IFormatProvider provider);
    private static bool XxY=(int uomLengthCode, String& uomName, Double& inMeters, IFormatProvider provider);
    internal static bool YBY=(int geogCS, Double[] padTransform, IFormatProvider provider);
    private static bool YRY=(int pmCode, String& name, Double& offset, IFormatProvider provider);
    internal static bool YhY=(int code, String& refName, Int32& refDatum, String& refDatumName, Int32& refPM, Int32& refEllipsoid, Int32& refUOMAngle, Int32& refCoordSysCode, IFormatProvider provider);
    private static void YxY=(int code, String& ellipseName, Double& semiMajor, Double& invFlattening, IFormatProvider provider);
    private static bool ZBY=(int pcsCode, Int32& projMethod, Int32[] parmIds, Double[] projParms, IFormatProvider provider);
    internal static bool ZRY=(int pcsCode, String& epsgName, Int32& uomLengthCode, Int32& uomAngleCode, Int32& geogCS, Int32& pnTRFCode, Int32& pnCoordSysCode, IFormatProvider provider);
    private static void ZhY=(IBY= srs, string targetKey, int cooridSysCode, IFormatProvider provider);
    private static double ZxY=(Double[] padfProjParms, Int32[] panParmIds, int nTargetId, double dfFromGreenwich);
    internal static void aBY=(IBY= srs, int geogCS, IFormatProvider provider);
    internal static void aRY=(IBY= srs, int pcsCode, IFormatProvider provider);
    private bool ahY=(int code, IFormatProvider provider);
    private bool axY=(int code, IFormatProvider provider);
    private bool bBY=(string fileName, int code);
    private void QhU=();
    internal 1hY= bRY=(string nodePath);
    private string bhY=(string nodeName);
    private string bhY=(string nodeName, int valueIndex);
    internal string bxY=();
    internal void cBY=(string wkt);
    private void cRY=(string nodePath, string nodeValue);
    private void chY=(string name, double inRadians);
    private double cxY=(String& parameterName);
    private void dBY=(string unitName, double inMeter);
    private double dRY=();
    private double dRY=(String& parameterName);
    private double dhY=();
    private double dhY=(String& parameterName);
    internal void dxY=(string geogName, string datumName, string spheroidName, double semiMajor, double invFlattening, string pmName, double pmOffset);
    internal void dxY=(string geogName, string datumName, string spheroidName, double semiMajor, double invFlattening, string pmName, double pmOffset, string angularUnits, double convertToRadians);
    private void eBY=(string nameValue, IFormatProvider provider);
    private void eRY=(IBY= other);
    private double ehY=();
    private double exY=();
    private double fBY=();
    private void fRY=(string projection);
    private void fhY=(string parmName, double defaultValue);
    private int fxY=(string parameterName);
    private int fxY=(string parameterName, 1hY= projCSnode);
    private double gBY=(string parameterName, double defaultValue);
    private double gBY=(string parameterName, double defaultValue, Boolean& isSucceed);
    private double gRY=(string parameterName, double defaultValue);
    private void ghY=(string name, double value);
    private void gxY=(double dfCenterLat, double dfCenterLong, double dfScale, double dfFalseEasting, double dfFalseNorthing);
    private void hBY=(double dfCenterLat, double dfCenterLong, double dfScale, double dfFalseEasting, double dfFalseNorthing);
    private void hRY=(double dfLat1, double dfLong1, double dfLat2, double dfLong2, double dfFalseEasting, double dfFalseNorthing);
    private void hhY=(double dfCenterLat, double dfCenterLong, double dfFalseEasting, double dfFalseNorthing);
    private void hxY=(double dfStdP1, double dfStdP2, double dfCenterLat, double dfCenterLong, double dfFalseEasting, double dfFalseNorthing);
    private void iBY=(double dfCenterLat, double dfCenterLong, double dfFalseEasting, double dfFalseNorthing);
    private void iRY=(double stdP1, double centralMeridian, double falseEasting, double falseNorthing);
    private void ihY=(double dfStdP1, double dfCentralMeridian, double dfFalseEasting, double dfFalseNorthing);
    private void ixY=(double centerLat, double centerLong, double falseEasting, double falseNorthing);
    private void jBY=(double dfStdP1, double dfStdP2, double dfCenterLat, double dfCenterLong, double dfFalseEasting, double dfFalseNorthing);
    private void jRY=(int nVariation, double dfCentralMeridian, double dfFalseEasting, double dfFalseNorthing);
    private void jhY=(double dfCenterLat, double dfCenterLong, double dfFalseEasting, double dfFalseNorthing);
    private void jxY=(double dfCenterLat, double dfCenterLong, double dfStdParallel1, double dfFalseEasting, double dfFalseNorthing);
    private void kBY=(double dfCentralMeridian, double dfFalseEasting, double dfFalseNorthing);
    private void kRY=(double dfCentralMeridian, double dfFalseEasting, double dfFalseNorthing);
    private void khY=(double dfCentralMeridian, double dfSatelliteHeight, double dfFalseEasting, double dfFalseNorthing);
    private void kxY=(double dfCenterLat, double dfCenterLong, double dfScale, double dfFalseEasting, double dfFalseNorthing);
    private void lBY=(double dfCenterLat, double dfCenterLong, double dfFalseEasting, double dfFalseNorthing);
    private void lRY=(double dfCenterLat, double dfCenterLong, double dfAzimuth, double dfRectToSkew, double dfScale, double dfFalseEasting, double dfFalseNorthing);
    private void lhY=(double dfLat1, double dfLat2, double dfCenterLong, double dfFalseEasting, double dfFalseNorthing);
    private void lxY=(double dfCenterLat, double dfCenterLong, double dfAzimuth, double dfPseudoStdParallel1, double dfScale, double dfFalseEasting, double dfFalseNorthing);
    private void mBY=(double dfCenterLat, double dfCenterLong, double dfFalseEasting, double dfFalseNorthing);
    private void mRY=(double dfStdP1, double dfStdP2, double dfCenterLat, double dfCenterLong, double dfFalseEasting, double dfFalseNorthing);
    private void mhY=(double dfCenterLat, double dfCenterLong, double dfScale, double dfFalseEasting, double dfFalseNorthing);
    private void mxY=(double dfStdP1, double dfStdP2, double dfCenterLat, double dfCenterLong, double dfFalseEasting, double dfFalseNorthing);
    private void nBY=(double dfCenterLat, double dfCenterLong, double dfFalseEasting, double dfFalseNorthing);
    private void nRY=(double dfCenterLat, double dfCenterLong, double dfScale, double dfFalseEasting, double dfFalseNorthing);
    private void nhY=(double dfStdP1, double dfCenterLat, double dfCenterLong, double dfFalseEasting, double dfFalseNorthing);
    private void nxY=(double dfCentralMeridian, double dfFalseEasting, double dfFalseNorthing);
    private void oBY=(double dfCenterLat, double dfCenterLong, double dfFalseEasting, double dfFalseNorthing);
    private void oRY=(double dfOriginLat, double dfCMeridian, double dfScale, double dfFalseEasting, double dfFalseNorthing);
    private void ohY=(double dfCenterLat, double dfCenterLong, double dfFalseEasting, double dfFalseNorthing);
    private void oxY=(double dfCenterLat, double dfCenterLong, double dfFalseEasting, double dfFalseNorthing);
    private void pBY=(double dfCenterLat, double dfCenterLong, double dfScale, double dfFalseEasting, double dfFalseNorthing);
    private void pRY=(double dfCenterLong, double dfFalseEasting, double dfFalseNorthing);
    private void phY=(double dfCenterLong, double dfFalseEasting, double dfFalseNorthing);
    private void pxY=(double dfOriginLat, double dfCMeridian, double dfScale, double dfFalseEasting, double dfFalseNorthing);
    private void qBY=(double dfLatitudeOfOrigin, double dfCentralMeridian, double dfFalseEasting, double dfFalseNorthing);
    private void qRY=(double dfCMeridian, double dfFalseEasting, double dfFalseNorthing);
    private void qhY=(int nZone, int isNorth);
    private int qxY=(Boolean& isNorth);
    private void rBY=(int nVariation, double dfCenterLat, double dfFalseEasting, double dfFalseNorthing);
    internal void rRY=(string targetKey, string authority, int code);
    private string rhY=(string targetKey);
    private string rxY=(string targetKey);
    private bool sBY=();
    private bool sRY=();
    private bool shY=();
    private void sxY=(double x, double y, double z);
    private void sxY=(double x, double y, double z, double eX, double eY, double eZ, double ppm);
    private bool tBY=(string parameterName);
    private static bool tRY=(string parameterName);
    private void thY=();
    private void txY=();
    private string uBY=(string targetKey, string extensionName, string defaultValue);
    private void uRY=(string targetKey, string name, string value);
    internal void uhY=(string targetKey, string xAxisName, qhU= xAxisOrientation, string yAxisName, qhU= yAxisOrientation);
    private void uxY=();
    private void vBY=();
    private void vBY=(1hY= currentNode);
    private void vRY=();
    private static double vhY=(string valueString, IFormatProvider provider);
    private static int vxY=(string valueString, IFormatProvider provider);
    private static void wBY=(String& name);
    private static void wRY=();
    private static string whY=(string name);
    internal void wxY=();
    internal void xBY=(string wkt);
    private void xRY=();
    private static void xhY=(IBY= ogr, string keyName, string newName);
    private static int xxY=(IBY= ogr, string name, string keyName, String[] mappingTable);
    private static int yBY=(IBY= ogr, string name1, string name2, String[] mappingTable, int tableStepSize, String[] keyNames, int keys);
    private static int yRY=(IBY= ogr, string projCSName, String[] mappingTable);
    private static int yhY=(IBY= ogr, string projCSName, String[] mappingTable);
    private static int yxY=(IBY= ogr, string projectionName, String[] mappingTable);
    private static int zBY=(IBY= ogr, string projectionName, String[] mappingTable);
    private static int zRY=(IBY= ogr, string geogcsName);
    internal static String[] WBY=();
    internal static List`1<5xY=> WhY=();
    private static string zhY=(string datunName, int epsgDatum);
    private String[] zxY=(string proj4String);
    private static double 0BY=(String[] source, string field, double defaultValue, IFormatProvider provider);
    private static string 0RY=(string value, string field);
    internal void 0hY=(string proj4String);
    internal string 0xY=();
    private static string 1BY=(String[] source, string name);
    private static double 1RY=(string value, IFormatProvider provider);
}
internal class 8RQ=.iCo= : lyQ= {
    private WSg= iSo=;
    private string iio=;
    private int iyo=;
    private WSg= jCo=;
    private string jSo=;
    private int jio=;
    private lCg= jyo=;
    private int kCo=;
    private Int32[] kSo=;
    private Int32[] kio=;
    private yCY= qiU=;
    private void kyo=();
    private Byte[] lCo=(GSg= poFeature, int nFieldNo, Tig= eType, int nIndexNo);
    public int xR4=(string pszViewName, WSg= poMainTable, WSg= poRelTable, string pszMainFieldName, string pszRelFieldName, List`1<string> papszSelectedFields);
    public int lSo=();
    public yCY= lio=();
    public Tig= lyo=(int nFieldId);
    public GSg= aCE=(int nFeatureId);
    public int mCo=(GSg= poFeature, int nFeatureIds);
    public int mSo=(yCY= poFeatureDefn);
    public int mio=(string pszName, Tig= eMapInfoType, int nWidth, int nPrecision, bool bIndexed, bool bUnique);
    public int myo=(int nFieldId);
    public bool nCo=(int nFieldId);
    public bool nSo=(int nFieldId);
    public string nio=();
    public string nyo=();
}
internal enum 8RQ=.iCQ= : Enum {
    public int value__;
    public static iCQ= iSQ=;
    public static iCQ= iiQ=;
    public static iCQ= iyQ=;
    public static iCQ= jCQ=;
    public static iCQ= jSQ=;
    public static iCQ= jiQ=;
    public static iCQ= jyQ=;
    public static iCQ= kCQ=;
    public static iCQ= kSQ=;
}
internal class 8RQ=.ICQ= : ValueType {
    public long GyQ=;
    public int HCQ=;
    public int HSQ=;
    public int HiQ=;
    public int HyQ=;
    public ICQ=(Byte[] buffer);
}
internal enum 8RQ=.iCY= : Enum {
    public int value__;
    public static iCY= iSY=;
    public static iCY= iiY=;
    public static iCY= iyY=;
    public static iCY= jCY=;
    public static iCY= jSY=;
    public static iCY= jiY=;
    public static iCY= jyY=;
    public static iCY= kCY=;
    public static iCY= kSY=;
    public static iCY= kiY=;
    public static iCY= kyY=;
    public static iCY= lCY=;
    public static iCY= lSY=;
    public static iCY= liY=;
    public static iCY= lyY=;
    public static iCY= mCY=;
    public static iCY= mSY=;
    public static iCY= miY=;
    public static iCY= myY=;
    public static iCY= nCY=;
    public static iCY= nSY=;
}
internal class 8RQ=.Ihk= : Txo= {
    internal Double[] uBg=;
    internal double CRk=;
    internal double Rhc=;
    internal double eRc=;
    internal double ehc=;
    internal Ihk=(string id, string desc);
    private void uhg=();
    internal virtual hRg= uxg=(hRg= pjConsts, Int32& pj_Error);
    internal virtual void whg=(XRg= lp, hRg= pjConsts, EBg= fac, Int32& pj_Error);
    internal virtual XRg= wBg=(XBo= xy, hRg= pjConsts, Int32& pj_Error);
    internal virtual XBo= wRg=(XRg= lp, hRg= pjConsts, Int32& pj_Error);
}
internal class 8RQ=.iiA= : ValueType {
    public string iyA=;
    public string jCA=;
    public string jSA=;
}
internal class 8RQ=.Iiw= : object {
    [CompilerGeneratedAttribute]
private int Iyw=;
    [CompilerGeneratedAttribute]
private string JCw=;
    [CompilerGeneratedAttribute]
private ushort JSw=;
    public int KCw= { get; private set; }
    public string Kyw= { get; public set; }
    public ushort Liw= { get; public set; }
    public Iiw=(int index, string lable, ushort fclass);
    [CompilerGeneratedAttribute]
private void Jyw=(int value);
    [CompilerGeneratedAttribute]
public int Jiw=();
    [CompilerGeneratedAttribute]
public string KSw=();
    [CompilerGeneratedAttribute]
public void Kiw=(string value);
    [CompilerGeneratedAttribute]
public ushort LCw=();
    [CompilerGeneratedAttribute]
public void LSw=(ushort value);
}
internal class 8RQ=.IRk= : Txo= {
    internal double xRg=;
    internal double xhg=;
    internal int zBg=;
    internal IRk=(string id, string desc);
    private void uhg=();
    internal virtual hRg= uxg=(hRg= pjConsts, Int32& pj_Error);
    internal virtual void whg=(XRg= lp, hRg= pjConsts, EBg= fac, Int32& pj_Error);
    internal virtual XRg= wBg=(XBo= xy, hRg= pjConsts, Int32& pj_Error);
    internal virtual XBo= wRg=(XRg= lp, hRg= pjConsts, Int32& pj_Error);
}
internal class 8RQ=.IRo= : Txo= {
    internal double CRk=;
    internal double Iho=;
    internal double Ixo=;
    internal double Rhc=;
    internal IRo=(string id, string desc);
    private void uhg=();
    internal virtual hRg= uxg=(hRg= pjConsts, Int32& pj_Error);
    internal virtual void whg=(XRg= lp, hRg= pjConsts, EBg= fac, Int32& pj_Error);
    internal virtual XRg= wBg=(XBo= xy, hRg= pjConsts, Int32& pj_Error);
    internal virtual XBo= wRg=(XRg= lp, hRg= pjConsts, Int32& pj_Error);
}
internal static class 8RQ=.ISM= : object {
    public static string IiM=(string metarText);
    private static void IyM=(string text, StringBuilder resultStrBuffer);
    private static bool JCM=(char ch);
    private static void JSM=(string token, StringBuilder resultStrBuffer);
    private static string JiM=(string text, StringBuilder resultStrBuffer);
}
internal class 8RQ=.ISQ= : object {
    private short IiQ=;
    public short IyQ=;
    public GiQ=[] JCQ=;
    public float HCQ=;
    public float HSQ=;
    public float HiQ=;
    public float HyQ=;
    public ISQ=(Byte[] buffer);
}
internal class 8RQ=.Ixk= : Txo= {
    internal Txo= JBk=;
    internal Txo= JRk=;
    internal Ixk=(string id, string desc);
    internal void uhg=();
    internal virtual hRg= uxg=(hRg= pjConsts, Int32& pj_Error);
    internal virtual XRg= wBg=(XBo= xy, hRg= pjConsts, Int32& pj_Error);
    internal virtual XBo= wRg=(XRg= lp, hRg= pjConsts, Int32& pj_Error);
    internal virtual void whg=(XRg= lp, hRg= pjConsts, EBg= fac, Int32& pj_Error);
}
internal class 8RQ=.ixU= : MulticastDelegate {
    public ixU=(object object, IntPtr method);
    public virtual TResult Invoke(T target, Object[] args);
    public virtual IAsyncResult BeginInvoke(T target, Object[] args, AsyncCallback callback, object object);
    public virtual TResult EndInvoke(IAsyncResult result);
}
[FlagsAttribute]
internal enum 8RQ=.ixw= : Enum {
    public byte value__;
    public static ixw= jBw=;
    public static ixw= jRw=;
    public static ixw= jhw=;
    public static ixw= jxw=;
    public static ixw= kBw=;
    public static ixw= kRw=;
    public static ixw= khw=;
}
internal class 8RQ=.JBo= : Txo= {
    internal double Rhc=;
    internal double ehc=;
    internal JBo=(string id, string desc);
    private void uhg=();
    internal virtual hRg= uxg=(hRg= pjConsts, Int32& pj_Error);
    internal virtual void whg=(XRg= lp, hRg= pjConsts, EBg= fac, Int32& pj_Error);
    internal virtual XRg= wBg=(XBo= xy, hRg= pjConsts, Int32& pj_Error);
    internal virtual XBo= wRg=(XRg= lp, hRg= pjConsts, Int32& pj_Error);
}
internal class 8RQ=.jBU= : MulticastDelegate {
    public jBU=(object object, IntPtr method);
    public virtual object Invoke(Object[] args);
    public virtual IAsyncResult BeginInvoke(Object[] args, AsyncCallback callback, object object);
    public virtual object EndInvoke(IAsyncResult result);
}
internal class 8RQ=.jCg= : object {
    public static List`1<aiU=> jSg=;
    public static List`1<diU=> jig=;
    private static jCg=();
}
internal class 8RQ=.JCI= : ValueType {
    public byte JSI=;
    public int xxk=;
    public int yBk=;
    public JCI=(int x, int y, byte intensity);
}
internal class 8RQ=.JCY= : object {
    public static double IRY=;
    public static TD0=[] JSY=;
    private static JCY=();
    public static int JiY=(Fyc= poLine, int numPoints, double dCenterX, double dCenterY, double dXRadius, double dYRadius, double dStartAngle, double dEndAngle);
    public static int JyY=(Fyc= poRing);
    public static bool KCY=(String& pszFname);
    public static string KSY=(string pszFname);
    public static List`1<string> KiY=(string pszFname, Encoding encoding);
    public static string KyY=(String& pszString, bool bSrcIsConst);
    public static string LCY=(string pszString);
    public static string LSY=(string pszSrcName);
    public static string LiY=(int nId);
    public static int LyY=(string pszName);
    public static bool IyY=(string pszCoordSys, Double& dXMin, Double& dYMin, Double& dXMax, Double& dYMax);
    public static int MCY=(string pszCoordSys, GCo= psProj);
}
internal class 8RQ=.Jhk= : Txo= {
    internal FRc=[] 2hg=;
    internal double 2xg=;
    internal double 3Bg=;
    internal int Rhc=;
    internal Jhk=(string id, string desc);
    private void uhg=();
    internal virtual hRg= uxg=(hRg= pjConsts, Int32& pj_Error);
    internal virtual void whg=(XRg= lp, hRg= pjConsts, EBg= fac, Int32& pj_Error);
    internal virtual XRg= wBg=(XBo= xy, hRg= pjConsts, Int32& pj_Error);
    internal virtual XBo= wRg=(XRg= lp, hRg= pjConsts, Int32& pj_Error);
    private XRg= zxg=(XBo= xy, hRg= pjConsts, Int32& pj_Error);
    private XBo= 0hg=(XRg= lp, hRg= pjConsts, Int32& pj_Error);
    private FRc= 3Rg=(FRc= z, FRc=[] C, int n, FRc= der);
    private FRc= 3hg=(FRc= z, FRc=[] C, int n);
}
internal class 8RQ=.jho= : XmlGeoSerializationFormatter {
    protected virtual GeoObjectModel LoadCore(Stream stream);
    private static void jxo=(XElement xElement, Dictionary`2<string, PointType> correctStyleTypes);
    private static bool kBo=(XElement xelement, string styleName, PointType pointType);
    private static XElement kRo=(XElement contentXml);
    private static XElement kho=(XElement layerElement);
}
internal class 8RQ=.Jho= : Txo= {
    internal Jho=(string id, string desc);
    private void uhg=();
    internal virtual hRg= uxg=(hRg= pjConsts, Int32& pj_Error);
    internal virtual void whg=(XRg= lp, hRg= pjConsts, EBg= fac, Int32& pj_Error);
    internal virtual XRg= wBg=(XBo= xy, hRg= pjConsts, Int32& pj_Error);
    internal virtual XBo= wRg=(XRg= lp, hRg= pjConsts, Int32& pj_Error);
}
internal class 8RQ=.jic= : object {
    public static string jyc=;
    public static string kCc=;
    public static string kSc=;
    public static string kic=;
    public static string kyc=;
    public static string lCc=;
    public static string lSc=;
    public static string lic=;
    public static string lyc=;
    public static string mCc=;
    public static string mSc=;
    public static string mic=;
    public static string myc=;
    public static string nCc=;
}
internal class 8RQ=.Jic= : BCc= {
    public virtual string /yY=();
    public virtual PyY= /iY=();
    public virtual 8yY= 9iY=();
    public virtual OiY= /SY=(String& ppszDstText);
    public virtual OiY= Cic=(8yY= poNewGeom);
}
internal static class 8RQ=.JiQ= : object {
    public static List`1 modreq(System.Runtime.CompilerServices.IsVolatile) JyQ=;
    public static Boolean modreq(System.Runtime.CompilerServices.IsVolatile) KCQ=;
    public static string KSQ=(string pszBuffer, int nBufferSize, Stream fp, Encoding encoding);
    public static string KiQ=(int nRequiredSize);
    public static string KyQ=(Stream fp, Encoding encoding);
    public static long LCQ=(string pszString, int nMaxLength);
    public static string LSQ=(string pszKey, string pszDefault);
}
internal class 8RQ=.jRk= : Txo= {
    internal FRc=[] jhk=;
    internal Double[] jxk=;
    internal Double[] kBk=;
    internal jRk=(string id, string desc);
    private void uhg=();
    internal virtual hRg= uxg=(hRg= pjConsts, Int32& pj_Error);
    internal virtual void whg=(XRg= lp, hRg= pjConsts, EBg= fac, Int32& pj_Error);
    internal virtual XRg= wBg=(XBo= xy, hRg= pjConsts, Int32& pj_Error);
    internal virtual XBo= wRg=(XRg= lp, hRg= pjConsts, Int32& pj_Error);
    private FRc= 3Rg=(FRc= z, FRc=[] C, int n, FRc=& der);
    private FRc= 3hg=(FRc= z, FRc=[] df, int n);
}
internal class 8RQ=.JRo= : Txo= {
    private double Dxo=;
    private double uhk=;
    private Double[] uBg=;
    internal JRo=(string id, string desc);
    private void uhg=();
    internal virtual hRg= uxg=(hRg= pjConsts, Int32& pj_Error);
    internal virtual void whg=(XRg= lp, hRg= pjConsts, EBg= fac, Int32& pj_Error);
    internal virtual XRg= wBg=(XBo= xy, hRg= pjConsts, Int32& pj_Error);
    internal virtual XBo= wRg=(XRg= lp, hRg= pjConsts, Int32& pj_Error);
    private XBo= 0hg=(XRg= lp, hRg= pjConsts, Int32& pj_Error);
    private XBo= 0Bg=(XRg= lp, hRg= pjConsts, Int32& pj_Error);
    private XRg= zxg=(XBo= xy, hRg= pjConsts, Int32& pj_Error);
    private XRg= zRg=(XBo= xy, hRg= pjConsts, Int32& pj_Error);
}
internal class 8RQ=.jSI= : object {
    private int XRo=;
    private int Xho=;
    public int kCI= { get; public set; }
    public int kyI= { get; public set; }
    public jSI=(int x, int y);
    public int jiI=();
    public void jyI=(int value);
    public int kSI=();
    public void kiI=(int value);
}
internal class 8RQ=.JSQ= : object {
    private short IiQ=;
    public short IyQ=;
    public ICQ=[] JCQ=;
    public int HCQ=;
    public int HSQ=;
    public int HiQ=;
    public int HyQ=;
    public JSQ=(Byte[] buffer);
}
internal class 8RQ=.jx8= : object {
    public double ch8=;
    public gx8= kB8=;
    public jx8=(double minDist, gx8= record);
    public sealed virtual int CompareTo(object rhs);
}
internal class 8RQ=.Jxk= : Txo= {
    internal FRc=[] 2hg=;
    internal double 2xg=;
    internal double 3Bg=;
    internal int Rhc=;
    internal Jxk=(string id, string desc);
    private void uhg=();
    internal virtual hRg= uxg=(hRg= pjConsts, Int32& pj_Error);
    internal virtual void whg=(XRg= lp, hRg= pjConsts, EBg= fac, Int32& pj_Error);
    internal virtual XRg= wBg=(XBo= xy, hRg= pjConsts, Int32& pj_Error);
    internal virtual XBo= wRg=(XRg= lp, hRg= pjConsts, Int32& pj_Error);
    private XRg= zxg=(XBo= xy, hRg= pjConsts, Int32& pj_Error);
    private XBo= 0hg=(XRg= lp, hRg= pjConsts, Int32& pj_Error);
    private FRc= 3Rg=(FRc= z, FRc=[] C, int n, FRc= der);
    private FRc= 3hg=(FRc= z, FRc=[] C, int n);
}
internal class 8RQ=.Jxo= : Txo= {
    internal int KBo=;
    internal Jxo=(string id, string desc);
    private void uhg=();
    internal virtual hRg= uxg=(hRg= pjConsts, Int32& pj_Error);
    internal virtual void whg=(XRg= lp, hRg= pjConsts, EBg= fac, Int32& pj_Error);
    internal virtual XRg= wBg=(XBo= xy, hRg= pjConsts, Int32& pj_Error);
    internal virtual XBo= wRg=(XRg= lp, hRg= pjConsts, Int32& pj_Error);
}
internal class 8RQ=.Jyc= : BCc= {
    public virtual string /yY=();
    public virtual PyY= /iY=();
    public virtual 8yY= 9iY=();
    public virtual OiY= /SY=(String& ppszDstText);
    public virtual OiY= Cic=(8yY= poNewGeom);
}
internal class 8RQ=.jyg= : lyQ= {
    private string gSU=;
    private Stream 5yc=;
    private oSc= giU=;
    private XSo= kCg=;
    private int uyc=;
    private int kSg=;
    public int sB4=(string pszFname, FileAccess pszAccess);
    public int QB8=();
    public int kig=(int nObjId);
    public int kyg=(int nObjId, int nObjPtr);
    public sealed virtual void Dispose();
}
internal class 8RQ=.jyk= : rik= {
    public byte kCk=;
    public short dCg=;
    public byte kSk=;
    public byte kik=;
    public byte kyk=;
    public short lCk=;
    public byte eyk=;
    public virtual int bSk=(fCk= poObjBlock);
    public virtual int bik=(fCk= poObjBlock);
}
[ExtensionAttribute]
internal static class 8RQ=.JyM= : object {
    [ExtensionAttribute]
public static string KCM=(string input, int startIndex, int length);
    public static int KSM=(string input);
}
[ExtensionAttribute]
internal static class 8RQ=.KB0= : object {
    [ExtensionAttribute]
internal static T KR0=(JObject jObject, string key, Func`2<string, T> converter);
    [ExtensionAttribute]
internal static T KR0=(JObject jObject, String[] keys, Func`2<String[], T> converter);
    [ExtensionAttribute]
internal static Nullable`1<T> Kh0=(string s);
    [ExtensionAttribute]
internal static bool Kx0=(GeoBrush geoBrush);
    [ExtensionAttribute]
internal static bool Kx0=(GeoPen geoPen);
    [AsyncStateMachineAttribute("8RQ=.KB0=/<GetResponseAsync>d__5")]
[ExtensionAttribute]
public static Task`1<WebResponse> LB0=(WebRequest request, CancellationToken cancellationToken);
}
internal class 8RQ=.KBk= : Txo= {
    internal double KRk=;
    internal double Khk=;
    internal double sRg=;
    internal double yBg=;
    internal double sxg=;
    internal double Kxk=;
    internal double LBk=;
    internal KBk=(string id, string desc);
    private void uhg=();
    internal virtual hRg= uxg=(hRg= pjConsts, Int32& pj_Error);
    internal virtual void whg=(XRg= lp, hRg= pjConsts, EBg= fac, Int32& pj_Error);
    internal virtual XRg= wBg=(XBo= xy, hRg= pjConsts, Int32& pj_Error);
    internal virtual XBo= wRg=(XRg= lp, hRg= pjConsts, Int32& pj_Error);
}
internal class 8RQ=.KCc= : BCc= {
    public virtual string /yY=();
    public virtual PyY= /iY=();
    public virtual 8yY= 9iY=();
    public virtual OiY= /SY=(String& ppszDstText);
    public virtual OiY= Cic=(8yY= poNewGeom);
}
internal class 8RQ=.Kho= : Txo= {
    internal Kho=(string id, string desc);
    private void uhg=();
    internal virtual hRg= uxg=(hRg= pjConsts, Int32& pj_Error);
    internal virtual void whg=(XRg= lp, hRg= pjConsts, EBg= fac, Int32& pj_Error);
    internal virtual XRg= wBg=(XBo= xy, hRg= pjConsts, Int32& pj_Error);
    internal virtual XBo= wRg=(XRg= lp, hRg= pjConsts, Int32& pj_Error);
}
internal class 8RQ=.ki4= : object {
    private List`1<ci4=> ky4=;
    private mC4= hS4=;
    private Stream GC4=;
    public List`1<ci4=> lS4= { get; }
    public ki4=(mC4= header, Stream stream);
    public List`1<ci4=> lC4=();
    public void li4=();
    private void ly4=();
}
[ExtensionAttribute]
internal static class 8RQ=.KiE= : object {
    [ExtensionAttribute]
[DebuggerHiddenAttribute]
public static void GCE=(T arg, string argName);
    [ExtensionAttribute]
[DebuggerHiddenAttribute]
public static void GCE=(Nullable`1<T> arg, string argName);
    [DebuggerHiddenAttribute]
[ExtensionAttribute]
public static void GSE=(T arg, string argName);
    [DebuggerHiddenAttribute]
[ExtensionAttribute]
public static void GCE=(IEnumerable`1<T> arg, string argName, bool assertContentsNotNull);
    [DebuggerHiddenAttribute]
[ExtensionAttribute]
public static void GiE=(string arg, string argName);
    [DebuggerHiddenAttribute]
[ExtensionAttribute]
public static void GiE=(IEnumerable arg, string argName);
    [ExtensionAttribute]
[DebuggerHiddenAttribute]
public static void GiE=(ICollection arg, string argName);
    [DebuggerHiddenAttribute]
[ExtensionAttribute]
public static void GyE=(string arg, string argName);
    [DebuggerHiddenAttribute]
[ExtensionAttribute]
public static void HCE=(TEnum enumValue, string argName);
    [DebuggerHiddenAttribute]
[ExtensionAttribute]
public static void HCE=(TEnum enumValue, string argName, TEnum[] validValues);
}
internal class 8RQ=.kiQ= : MulticastDelegate {
    public kiQ=(object object, IntPtr method);
    public virtual void Invoke(LiQ= errEnum, int tempInt, string errorInfo);
    public virtual IAsyncResult BeginInvoke(LiQ= errEnum, int tempInt, string errorInfo, AsyncCallback callback, object object);
    public virtual void EndInvoke(IAsyncResult result);
}
internal class 8RQ=.KjE= : ValueType {
    internal int XRo=;
    internal int Xho=;
    public KjE=(int x, int y);
}
internal class 8RQ=.kR8= : ValueType {
    public ushort kh8=;
    public ushort kx8=;
    public UInt32 lB8=;
    public static int MB8=();
    public bool ZRw=(BinaryReader r);
    public bool cxw=(BinaryWriter w);
    public virtual string ToString();
}
internal class 8RQ=.kRk= : Txo= {
    internal Txo= khk=;
    internal double kxk=;
    internal double lBk=;
    internal double lRk=;
    internal double lhk=;
    internal kRk=(string id, string desc);
    private void uhg=();
    internal virtual hRg= uxg=(hRg= pjConsts, Int32& pj_Error);
    internal virtual void whg=(XRg= lp, hRg= pjConsts, EBg= fac, Int32& pj_Error);
    internal virtual XRg= wBg=(XBo= xy, hRg= pjConsts, Int32& pj_Error);
    internal virtual XBo= wRg=(XRg= lp, hRg= pjConsts, Int32& pj_Error);
    private XBo= lxk=(XRg= lp, hRg= pjConsts, Int32& pj_Error);
    private XBo= mBk=(XRg= lp, hRg= pjConsts, Int32& pj_Error);
    private XRg= mRk=(XBo= xy, hRg= pjConsts, Int32& pj_Error);
    private XRg= mhk=(XBo= xy, hRg= pjConsts, Int32& pj_Error);
}
internal class 8RQ=.KRo= : Txo= {
    internal int KBo=;
    internal KRo=(string id, string desc);
    private void uhg=();
    internal virtual hRg= uxg=(hRg= pjConsts, Int32& pj_Error);
    internal virtual void whg=(XRg= lp, hRg= pjConsts, EBg= fac, Int32& pj_Error);
    internal virtual XRg= wBg=(XBo= xy, hRg= pjConsts, Int32& pj_Error);
    internal virtual XBo= wRg=(XRg= lp, hRg= pjConsts, Int32& pj_Error);
}
internal enum 8RQ=.kRU= : Enum {
    public int value__;
    public static kRU= khU=;
    public static kRU= kxU=;
    public static kRU= lBU=;
}
internal class 8RQ=.KSc= : 8yY= {
    private double XRo=;
    private double Xho=;
    private double Kic=;
    public KSc=(double xIn, double yIn);
    public KSc=(double xIn, double yIn, double zIn);
    public virtual OiY= /SY=(String& ppszDstText);
    public virtual 8yY= 9iY=();
    public virtual void 9yY=(qyY= psEnvelope);
    public double Hyc=();
    public double ICc=();
    public double ISc=();
    public virtual void ACc=(int nNewDimension);
    public void Kyc=(double xIn);
    public void LCc=(double yIn);
    public void LSc=(double zIn);
    public virtual string /yY=();
    public virtual PyY= /iY=();
}
internal class 8RQ=.KSk= : XSo= {
    protected GCo= Kik=;
    public short Kyk=;
    public double LCk=;
    public int Gyg=;
    public int HCg=;
    public int HSg=;
    public int Hig=;
    public bool LSk=;
    public int Lik=;
    public int Lyk=;
    public int MCk=;
    public int MSk=;
    public int Mik=;
    public int Myk=;
    public int NCk=;
    public int NSk=;
    public byte Nik=;
    public byte Nyk=;
    public byte OCk=;
    public byte OSk=;
    public byte Oik=;
    public byte Oyk=;
    public byte PCk=;
    public byte PSk=;
    public byte Pik=;
    public byte Pyk=;
    public short QCk=;
    public double QSk=;
    public double Qik=;
    public double Qyk=;
    public double RCk=;
    public KSk=(oSc= eAccessMode);
    public virtual int CommitToFile();
    public virtual int InitBlockFromData(Byte[] pabyBuf, int nBlockSize, int nSizeUsed, bool bMakeCopy, Stream fsSrc, int nOffset);
    public virtual int InitNewBlock(Stream fsSrc, int nBlockSize, int nFileOffset);
    public virtual int GetBlockClass();
    public int CSk=(int nX, int nY, Double& dX, Double& dY);
    public int Cik=(double dX, double dY, Int32& nX, Int32& nY, bool bIgnoreOverflow);
    public int Cyk=(int nX, int nY, Double& dX, Double& dY);
    public int DCk=(double dX, double dY, Int32& nX, Int32& nY);
    public int ECk=(double dXMin, double dYMin, double dXMax, double dYMax);
    public int RSk=(int nObjType);
    public bool Rik=(int nObjType);
    public int Ryk=(GCo= psProjInfo);
    public int SCk=(GCo= psProjInfo);
}
internal class 8RQ=.Kxo= : Txo= {
    internal double Rhc=;
    internal double Dhk=;
    internal double Dxk=;
    internal double EBk=;
    internal double ERk=;
    internal double Ehk=;
    internal Kxo=(string id, string desc);
    private void uhg=();
    internal virtual hRg= uxg=(hRg= pjConsts, Int32& pj_Error);
    internal virtual void whg=(XRg= lp, hRg= pjConsts, EBg= fac, Int32& pj_Error);
    internal virtual XRg= wBg=(XBo= xy, hRg= pjConsts, Int32& pj_Error);
    internal virtual XBo= wRg=(XRg= lp, hRg= pjConsts, Int32& pj_Error);
    private int Exk=(hRg= pjConsts, Double[] del, Int32& pj_Error);
}
internal class 8RQ=.kxw= : object {
    public static int lBw=;
    private static int khw=;
    private int lRw=;
    private dxw= lhw=;
    private dxw= lxw=;
    private TextReader mBw=;
    private dxw= mRw=;
    private dxw= mhw=;
    private qhw= mxw=;
    public TextReader nhw= { get; public set; }
    public qhw= oBw= { get; }
    public kxw=(TextReader sr);
    public kxw=(string str);
    private static kxw=();
    public TextReader nBw=();
    public void nRw=(TextReader value);
    public qhw= nxw=();
    private void oRw=();
    private Gj0= ohw=(byte ctype, int c);
    private Gj0= ohw=(byte ctype, int c, Gj0= excludeState);
    private int oxw=();
    public bool pBw=(2Rw=& token);
    private bool pRw=(dxw= sb, bool allowPlus, Char& thisChar);
    public bool phw=(List`1<2Rw=> tokens);
    public bool pxw=(TextReader tr, List`1<2Rw=> tokens);
    public bool qBw=(string str, List`1<2Rw=> tokens);
    public bool qRw=(Stream s, List`1<2Rw=> tokens);
}
[ExtensionAttribute]
internal static class 8RQ=.KyE= : object {
    [DebuggerHiddenAttribute]
[ExtensionAttribute]
public static void LCE=(EventHandler handler, object sender);
    [DebuggerHiddenAttribute]
[ExtensionAttribute]
public static void LCE=(EventHandler`1<T> handler, object sender, T e);
    [ExtensionAttribute]
[DebuggerHiddenAttribute]
public static void LCE=(EventHandler`1<T> handler, object sender, Func`1<T> createEventArguments);
    [ExtensionAttribute]
[DebuggerHiddenAttribute]
public static void LCE=(Delegate handler, object sender, EventArgs e);
    [ExtensionAttribute]
[DebuggerHiddenAttribute]
public static void LSE=(EventHandler handler, object sender, AsyncCallback callback, object asyncState);
    [ExtensionAttribute]
[DebuggerHiddenAttribute]
public static void LSE=(EventHandler`1<T> handler, object sender, T e, AsyncCallback callback, object asyncState);
    [ExtensionAttribute]
[DebuggerHiddenAttribute]
public static void LSE=(EventHandler`1<T> handler, object sender, Func`1<T> createEventArguments, AsyncCallback callback, object asyncState);
    [ExtensionAttribute]
[DebuggerHiddenAttribute]
public static void LSE=(Delegate handler, object sender, EventArgs e, AsyncCallback callback, object asyncState);
}
internal class 8RQ=.KyI= : object {
    [CompilerGeneratedAttribute]
private long LCI=;
    [CompilerGeneratedAttribute]
private long LSI=;
    [CompilerGeneratedAttribute]
private GridCell[0...,0...] LiI=;
    [CompilerGeneratedAttribute]
private GridInterpolationModel LyI=;
    [CompilerGeneratedAttribute]
private RectangleShape MCI=;
    [CompilerGeneratedAttribute]
private GridDefinition MSI=;
    [CompilerGeneratedAttribute]
private ManualResetEvent MiI=;
    public long NSI= { get; public set; }
    public long OCI= { get; public set; }
    public GridCell[0...,0...] OyI= { get; public set; }
    public GridInterpolationModel PiI= { get; public set; }
    public RectangleShape QSI= { get; public set; }
    public GridDefinition RCI= { get; public set; }
    public ManualResetEvent RyI= { get; public set; }
    public KyI=(long x, long y, RectangleShape cellExtent, GridCell[0...,0...] cells, GridInterpolationModel model, GridDefinition definition, ManualResetEvent finished);
    [CompilerGeneratedAttribute]
public long MyI=();
    [CompilerGeneratedAttribute]
public void NCI=(long value);
    [CompilerGeneratedAttribute]
public long NiI=();
    [CompilerGeneratedAttribute]
public void NyI=(long value);
    [CompilerGeneratedAttribute]
public GridCell[0...,0...] OSI=();
    [CompilerGeneratedAttribute]
public void OiI=(GridCell[0...,0...] value);
    [CompilerGeneratedAttribute]
public GridInterpolationModel PCI=();
    [CompilerGeneratedAttribute]
public void PSI=(GridInterpolationModel value);
    [CompilerGeneratedAttribute]
public RectangleShape PyI=();
    [CompilerGeneratedAttribute]
public void QCI=(RectangleShape value);
    [CompilerGeneratedAttribute]
public GridDefinition QiI=();
    [CompilerGeneratedAttribute]
public void QyI=(GridDefinition value);
    [CompilerGeneratedAttribute]
public ManualResetEvent RSI=();
    [CompilerGeneratedAttribute]
public void RiI=(ManualResetEvent value);
}
internal enum 8RQ=.kyQ= : Enum {
    public int value__;
    public static kyQ= lCQ=;
    public static kyQ= lSQ=;
    public static kyQ= liQ=;
}
internal class 8RQ=.LBo= : Txo= {
    internal double Rhc=;
    internal double ehc=;
    internal LBo=(string id, string desc);
    private void uhg=();
    internal virtual hRg= uxg=(hRg= pjConsts, Int32& pj_Error);
    internal virtual void whg=(XRg= lp, hRg= pjConsts, EBg= fac, Int32& pj_Error);
    internal virtual XRg= wBg=(XBo= xy, hRg= pjConsts, Int32& pj_Error);
    internal virtual XBo= wRg=(XRg= lp, hRg= pjConsts, Int32& pj_Error);
}
internal class 8RQ=.LC0= : object {
    [CompilerGeneratedAttribute]
private byte Gi0=;
    [CompilerGeneratedAttribute]
private List`1<Iiw=> LS0=;
    [CompilerGeneratedAttribute]
private List`1<Iiw=> Li0=;
    [CompilerGeneratedAttribute]
private List`1<Iiw=> Ly0=;
    [CompilerGeneratedAttribute]
private double MC0=;
    [CompilerGeneratedAttribute]
private double MS0=;
    [CompilerGeneratedAttribute]
private RectangleShape Mi0=;
    public byte IC0= { get; private set; }
    public List`1<Iiw=> NS0= { get; private set; }
    public List`1<Iiw=> OC0= { get; private set; }
    public List`1<Iiw=> Oy0= { get; private set; }
    public double Pi0= { get; private set; }
    public double QS0= { get; private set; }
    public RectangleShape RC0= { get; private set; }
    public LC0=(byte accuracy);
    [CompilerGeneratedAttribute]
private void Hy0=(byte value);
    [CompilerGeneratedAttribute]
public byte Hi0=();
    [CompilerGeneratedAttribute]
private void NC0=(List`1<Iiw=> value);
    [CompilerGeneratedAttribute]
public List`1<Iiw=> My0=();
    [CompilerGeneratedAttribute]
private void Ny0=(List`1<Iiw=> value);
    [CompilerGeneratedAttribute]
public List`1<Iiw=> Ni0=();
    [CompilerGeneratedAttribute]
private void Oi0=(List`1<Iiw=> value);
    [CompilerGeneratedAttribute]
public List`1<Iiw=> OS0=();
    [CompilerGeneratedAttribute]
private void PS0=(double value);
    [CompilerGeneratedAttribute]
public double PC0=();
    [CompilerGeneratedAttribute]
private void QC0=(double value);
    [CompilerGeneratedAttribute]
public double Py0=();
    [CompilerGeneratedAttribute]
private void Qy0=(RectangleShape value);
    [CompilerGeneratedAttribute]
public RectangleShape Qi0=();
    public void EC0=(giw= RTreeLeaf, RectangleShape Box, List`1<string> lblDatas, bool addLblDatas);
    private void RS0=(RectangleShape box);
}
internal class 8RQ=.lCg= : lyQ= {
    private string gSU=;
    private Stream 5yc=;
    private oSc= giU=;
    private uic= lSg=;
    private int lig=;
    private oSg=[] lyg=;
    private Byte[][] mCg=;
    private static int mSg=;
    private int mig=(int nIndexNumber);
    private int myg=();
    private int 2h4=();
    public int sB4=(string pszFname, FileAccess pszAccess, bool bTestOpenNoError);
    public int QB8=();
    public int nCg=(int nIndexNumber, Tig= eType);
    public Byte[] nSg=(int nIndexNumber, int nValue);
    public Byte[] nSg=(int nIndexNumber, string pszStr);
    public Byte[] nSg=(int nIndexNumber, double dValue);
    public int nig=(int nIndexNumber, Byte[] pKeyValue);
    public int nyg=(Tig= eType, int nFieldSize);
    public int oCg=(int nIndexNumber, Byte[] pKeyValue, int nRecordNo);
    public sealed virtual void Dispose();
}
internal class 8RQ=.lCI= : riI= {
    private jSI= lSI=;
    private jSI= liI=;
    private jSI= lyI=;
    private jSI= mCI=;
    public jSI= myI= { get; public set; }
    public jSI= niI= { get; public set; }
    public jSI= oSI= { get; public set; }
    public jSI= pCI= { get; public set; }
    public jSI= mSI=();
    public void miI=(jSI= value);
    public jSI= nCI=();
    public void nSI=(jSI= value);
    public jSI= nyI=();
    public void oCI=(jSI= value);
    public jSI= oiI=();
    public void oyI=(jSI= value);
}
internal class 8RQ=.Lho= : Txo= {
    internal double eRc=;
    internal Lho=(string id, string desc);
    private void uhg=();
    internal virtual hRg= uxg=(hRg= pjConsts, Int32& pj_Error);
    internal virtual void whg=(XRg= lp, hRg= pjConsts, EBg= fac, Int32& pj_Error);
    internal virtual XRg= wBg=(XBo= xy, hRg= pjConsts, Int32& pj_Error);
    internal virtual XBo= wRg=(XRg= lp, hRg= pjConsts, Int32& pj_Error);
}
internal class 8RQ=.li0= : object {
    private double iyw=;
    private Encoding rB4=;
    [CompilerGeneratedAttribute]
private List`1<string> ly0=;
    [CompilerGeneratedAttribute]
private FeatureLayer mC0=;
    [CompilerGeneratedAttribute]
private int mS0=;
    [CompilerGeneratedAttribute]
private Collection`1<string> mi0=;
    public List`1<string> nS0= { get; public set; }
    public FeatureLayer oC0= { get; public set; }
    public int oy0= { get; private set; }
    public Collection`1<string> pi0= { get; private set; }
    public double qC0= { get; }
    public Encoding qi0= { get; }
    public li0=(FeatureLayer featureLayer, IEnumerable`1<string> columnNames, 4is= accuracy, Collection`1<string> ids, double extentWidthLimitation, Encoding encoding);
    [CompilerGeneratedAttribute]
public List`1<string> my0=();
    [CompilerGeneratedAttribute]
public void nC0=(List`1<string> value);
    [CompilerGeneratedAttribute]
public FeatureLayer ni0=();
    [CompilerGeneratedAttribute]
public void ny0=(FeatureLayer value);
    [CompilerGeneratedAttribute]
public int oS0=();
    [CompilerGeneratedAttribute]
private void oi0=(int value);
    [CompilerGeneratedAttribute]
public Collection`1<string> pC0=();
    [CompilerGeneratedAttribute]
private void pS0=(Collection`1<string> value);
    public double py0=();
    public Encoding qS0=();
    private static int qy0=(4is= accuracy);
}
internal class 8RQ=.Lic= : 8yY= {
    private int Lyc=;
    private Eic=[] MCc=;
    public virtual string /yY=();
    public virtual PyY= /iY=();
    public virtual 8yY= 9iY=();
    public virtual OiY= /SY=(String& ppszDstText);
    public virtual void 9yY=(qyY= psEnvelope);
    public virtual void ACc=(int nNewDimension);
    public void MSc=(Eic= poNewRing);
    public void Mic=(Eic= poNewRing);
    public Eic= Myc=();
    public int NCc=();
    public Eic= NSc=(int iRing);
}
internal static class 8RQ=.LiE= : object {
    public static char LyE=;
    public static char MCE=;
    public static char MSE=;
    public static char MiE=;
    public static char MyE=;
    public static char NCE=;
    public static Encoding NSE=;
    private static LiE=();
}
internal enum 8RQ=.LiQ= : Enum {
    public int value__;
    public static LiQ= LyQ=;
    public static LiQ= MCQ=;
    public static LiQ= MSQ=;
    public static LiQ= MiQ=;
    public static LiQ= MyQ=;
    public static LiQ= NCQ=;
    public static LiQ= NSQ=;
}
internal class 8RQ=.lR8= : ValueType {
    public UInt32 lh8=;
    public ushort lx8=;
    public ushort eh8=;
    public bool ZRw=(BinaryReader r);
    public bool cxw=(BinaryWriter w);
    public virtual string ToString();
}
internal class 8RQ=.LRk= : Txo= {
    internal double Lhk=;
    internal double CRk=;
    internal double Lxk=;
    internal LRk=(string id, string desc);
    private void uhg=();
    internal virtual hRg= uxg=(hRg= pjConsts, Int32& pj_Error);
    internal virtual void whg=(XRg= lp, hRg= pjConsts, EBg= fac, Int32& pj_Error);
    internal virtual XRg= wBg=(XBo= xy, hRg= pjConsts, Int32& pj_Error);
    internal virtual XBo= wRg=(XRg= lp, hRg= pjConsts, Int32& pj_Error);
}
internal class 8RQ=.LRo= : Txo= {
    internal LRo=(string id, string desc);
    private void uhg=();
    internal virtual hRg= uxg=(hRg= pjConsts, Int32& pj_Error);
    internal virtual void whg=(XRg= lp, hRg= pjConsts, EBg= fac, Int32& pj_Error);
    internal virtual XRg= wBg=(XBo= xy, hRg= pjConsts, Int32& pj_Error);
    internal virtual XBo= wRg=(XRg= lp, hRg= pjConsts, Int32& pj_Error);
}
internal class 8RQ=.lRU= : object {
    internal static string lhU=;
    private static Dictionary`2<string, ohU=> lxU=;
    internal static String[] mBU=(string fileName, string keyFieldName, string value, kRU= criteria, IFormatProvider provider);
    internal static int mRU=(string fileName, string keyFieldName);
    internal static string mhU=(string baseName);
    internal static string mxU=(string fileName, string keyFieldName, string keyFieldValue, kRU= criteria, string targetField, IFormatProvider provider);
    internal static String[] nBU=(string fileName);
    private static string nRU=(string baseName);
    internal static String[] nhU=(string csvFileName, String[] columnNames);
    private static List`1<string> nxU=(string recordLine);
    private static ohU= oBU=(string fileName);
    private static DataTable oRU=(string fileName);
}
internal class 8RQ=.lSE= : object {
    private int liE=;
    private int lyE=;
    private int mCE=;
    private double mSE=;
    [CompilerGeneratedAttribute]
private GeoImage miE=;
    public int nCE= { get; }
    public int niE= { get; }
    public int oCE= { get; }
    public double oiE= { get; }
    public GeoImage pSE= { get; public set; }
    public lSE=(int column, int row, int zoomLevelNumber, double scale);
    public int myE=();
    public int nSE=();
    public int nyE=();
    public double oSE=();
    [CompilerGeneratedAttribute]
public GeoImage oyE=();
    [CompilerGeneratedAttribute]
public void pCE=(GeoImage value);
}
internal class 8RQ=.lSk= : qSQ= {
    public byte lik=;
    public int lyk=;
    public int xyg=;
    public int yCg=;
    public int ySg=;
    public int yig=;
    public static lSk= mCk=(byte nNewObjType, int nId);
    public static lSk= mSk=(fCk= poObjBlock, KSk= poHeader);
    public bool mik=();
    public int myk=(fCk= poObjBlock);
    public void Kyg=(int nMinX, int nMinY, int nMaxX, int nMaxY);
    public virtual int bSk=(fCk= poObjBlock);
    public virtual int bik=(fCk= poObjBlock);
}
internal static class 8RQ=.LSs= : object {
    internal static void Lis=(bool isEditable);
    internal static void Lys=(bool isOpen);
    internal static void MCs=(bool isInTransaction);
    internal static void MSs=(bool isInTransaction);
    internal static void Mis=(int value);
    internal static void Mys=(string contractId);
    internal static void NCs=(int symbolNumber, string parameterName);
}
internal class 8RQ=.lSU= : ECU= {
    private string gSU=;
    private oSc= giU=;
    private int liU=;
    private string fSU=;
    private string lyU=;
    private string mCU=;
    private string mSU=;
    private List`1<Tig=> miU=;
    private List`1<bool> myU=;
    private List`1<bool> nCU=;
    private double gyU=;
    private double hCU=;
    private double hSU=;
    private double hiU=;
    private double nSU=;
    private double niU=;
    private double nyU=;
    private double oCU=;
    private int oSU=;
    private qyY= oiU=;
    private int oyU=;
    private int pCU=;
    private int pSU=;
    private int piU=;
    private int pyU=;
    private eyU= qCU=;
    private eyU= qSU=;
    private yCY= qiU=;
    private OSc= qyU=;
    private int rCU=;
    private int rSU=;
    private bool riU=;
    private bool ryU=;
    private int sCU=();
    private void sSU=();
    private int siU=(string pszLine);
    private int syU=(int nFeatureId);
    private int tCU=();
    private int tSU=();
    private void tiU=(double dfX, double dfY);
    public virtual int Close();
    public virtual aig= GetFileClass();
    public virtual int Open(string pszFname, FileAccess pszAccess, bool bTestOpenNoError);
    public virtual string GetTableName();
    public virtual bool TestCapability(string pszCap);
    public virtual int GetFeatureCount(bool bForce);
    public virtual void ResetReading();
    public virtual OiY= GetExtent(qyY= psExtent, bool bForce);
    public virtual int GetNextFeatureId(int nPrevId);
    public virtual GSg= GetFeatureRef(int nFeatureId);
    public virtual yCY= GetLayerDefn();
    public virtual Tig= GetNativeFieldType(int nFieldId);
    public virtual int GetBounds(Double& dXMin, Double& dYMin, Double& dXMax, Double& dYMax, bool bForce);
    public virtual OSc= GetSpatialRef();
    public virtual int GetFeatureCountByType(Int32& numPoints, Int32& numLines, Int32& numRegions, Int32& numTexts, bool bForce);
    public virtual bool IsFieldIndexed(int nFieldId);
    public virtual bool IsFieldUnique(int nFieldId);
    public virtual int SetBounds(double dXMin, double dYMin, double dXMax, double dYMax);
    public virtual int SetFeatureDefn(yCY= poFeatureDefn, List`1<Tig=> paeMapInfoNativeFieldTypes);
    public virtual int AddFieldNative(string pszName, Tig= eMapInfoType, int nWidth, int nPrecision, bool bIndexed, bool bUnique);
    public virtual int SetSpatialRef(OSc= poSpatialRef);
    public virtual int SetFeature(GSg= poFeature, int nFeatureId);
    public virtual int SetFieldIndexed(int nFieldId);
    public virtual int GetProjInfo(GCo= poPI);
    public virtual int SetProjInfo(GCo= poPI);
    public virtual int SetMIFCoordSys(string pszMIFCoordSys);
    public void kh0=();
    private sealed virtual override void System.IDisposable.Dispose();
}
internal static class 8RQ=.lTE= : object {
    internal static String[] ljE=;
    internal static String[] lzE=;
    private static lTE=();
}
internal static class 8RQ=.lTI= : object {
    [CompilerGeneratedAttribute]
private static string ljI=;
    private static vDI= lzI=;
    private static vDI= mDI=;
    private static vDI= mTI=;
    private static string mjI=;
    private static string mzI=;
    private static string OjA=;
    internal static string nDI=;
    private static string nTI=;
    private static Guid[] njI=;
    private static vDI= nzI=;
    private static object oDI=;
    private static Nullable`1<bool> oTI=;
    private static Nullable`1<bool> ojI=;
    public static string pTI= { get; public set; }
    public static vDI= pzI= { get; }
    private static lTI=();
    [CompilerGeneratedAttribute]
public static string ozI=();
    [CompilerGeneratedAttribute]
public static void pDI=(string value);
    public static void qDI=(Dictionary`2<string, Collection`1<string>> licenseContents);
    public static vDI= pjI=();
    private static vDI= qTI=();
    internal static bool qjI=();
    private static vDI= qzI=(bool needToShowProductCenter);
    private static void rDI=(string uri);
    private static vDI= rTI=();
    private static string rjI=(BRQ= currentNode);
    internal static Guid rzI=();
    private static Guid sDI=();
    private static Guid sTI=();
    private static bool sjI=(Guid productId);
    [IteratorStateMachineAttribute("8RQ=.lTI=/<GetPossibleDependencyPath>d__27")]
private static IEnumerable`1<string> szI=();
    internal static BRQ= tDI=(Assembly assembly);
    internal static BRQ= tTI=(Assembly assembly);
    public static bool tjI=();
    public static bool tzI=();
    internal static BRQ= tDI=(Guid productId);
    private static BRQ= uDI=(Guid productId);
    private static int uTI=(BRQ= productNode);
    private static Guid ujI=();
    private static Guid uzI=(Assembly assembly);
}
internal class 8RQ=.Lx8= : mB8= {
    internal Lx8=(kR8= rh, nR8= rt);
    public virtual string ToString();
    internal virtual int MB8=(bool isFloat);
    internal virtual bool ZRw=(BinaryReader r, bool isFloat);
    internal virtual bool cxw=(BinaryWriter w, bool isFloat);
}
internal class 8RQ=.Lxo= : Txo= {
    internal double eRc=;
    internal double ehc=;
    internal double fBc=;
    internal Lxo=(string id, string desc);
    private void uhg=();
    internal virtual hRg= uxg=(hRg= pjConsts, Int32& pj_Error);
    internal virtual void whg=(XRg= lp, hRg= pjConsts, EBg= fac, Int32& pj_Error);
    internal virtual XRg= wBg=(XBo= xy, hRg= pjConsts, Int32& pj_Error);
    internal virtual XBo= wRg=(XRg= lp, hRg= pjConsts, Int32& pj_Error);
    private hRg= fBk=(hRg= pjConsts, double p, Int32& pj_Error);
}
internal class 8RQ=.lyQ= : qSQ= {
    public static XSo= mCQ=(Stream fsSrc, int nOffset, int nSize, bool bHardBlockSize, oSc= eAccessMode);
    public static int mSQ=(Char[] charArray);
    public static Char[] miQ=(Char[] szCharSet, Char[] szCharSetToBeFound);
    public static int myQ=(Char[] numCharArray);
    public static int nCQ=(int nGeomType);
    public static bool nSQ=(int numSegments, int umVerticesTotal);
    public static int niQ=(double dX);
    public static byte nyQ=(int color);
    public static byte oCQ=(int color);
    public static byte oSQ=(int color);
    public static bool oiQ=(string charArray1, string charArray2, int count);
    public static bool oyQ=(string charArray1, string charArray2);
    public static T[] pCQ=(T[] srcArray, int destLength);
    public static void pSQ=(Double& min, Double& max);
    public static void pSQ=(Int32& min, Int32& max);
    public static string piQ=(Tig= type);
    public static PyY= pyQ=(int x);
    public static bool qCQ=(T[] src, int indexSrc, T[] dest, int indexDest, int count);
}
internal class 8RQ=.lys= : ValueType {
    [CompilerGeneratedAttribute]
private int 0Bs=;
    [CompilerGeneratedAttribute]
private int 0Rs=;
    public int kCI= { get; public set; }
    public int kyI= { get; public set; }
    public lys=(int x, int y);
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public int jiI=();
    [CompilerGeneratedAttribute]
public void jyI=(int value);
    [CompilerGeneratedAttribute]
[IsReadOnlyAttribute]
public int kSI=();
    [CompilerGeneratedAttribute]
public void kiI=(int value);
    public virtual bool Equals(object obj);
    private bool bRU=(lys= pointI);
    public static bool uRM=(lys= a, lys= b);
    public static bool uhM=(lys= a, lys= b);
    public virtual int GetHashCode();
}
internal class 8RQ=.Lyw= : object {
    [CompilerGeneratedAttribute]
private Vertex MCw=;
    [CompilerGeneratedAttribute]
private string JCw=;
    [CompilerGeneratedAttribute]
private List`1<int> MSw=;
    [CompilerGeneratedAttribute]
private bool Miw=;
    public Vertex NSw= { get; public set; }
    public string Kyw= { get; public set; }
    public List`1<int> OCw= { get; public set; }
    public bool Oyw= { get; public set; }
    [CompilerGeneratedAttribute]
public Vertex Myw=();
    [CompilerGeneratedAttribute]
public void NCw=(Vertex value);
    [CompilerGeneratedAttribute]
public string KSw=();
    [CompilerGeneratedAttribute]
public void Kiw=(string value);
    [CompilerGeneratedAttribute]
public List`1<int> Niw=();
    [CompilerGeneratedAttribute]
public void Nyw=(List`1<int> value);
    [CompilerGeneratedAttribute]
public void Oiw=(bool value);
    [CompilerGeneratedAttribute]
public bool OSw=();
    public virtual string ToString();
}
internal class 8RQ=.mB8= : gx8= {
    protected nR8= mR8=;
    public nR8= nB8= { get; public set; }
    public mB8=(kR8= rh, nR8= rt, int idx);
    public nR8= mh8=();
    public void mx8=(nR8= value);
    internal virtual bool ZRw=(BinaryReader r, bool isFloat);
    internal virtual bool cxw=(BinaryWriter w, bool isFloat);
    internal virtual bool WR8=(nR8= rect);
    internal virtual bool WB8=(nR8= rect);
    internal virtual bool Wh8=(nR8= rect);
    internal virtual int MB8=(bool isFloat);
    internal virtual nR8= gR8=();
    internal virtual double gh8=();
    public virtual string ToString();
}
internal class 8RQ=.MBk= : Txo= {
    internal MBk=(string id, string desc);
    private void uhg=();
    internal virtual hRg= uxg=(hRg= pjConsts, Int32& pj_Error);
    internal virtual void whg=(XRg= lp, hRg= pjConsts, EBg= fac, Int32& pj_Error);
    internal virtual XRg= wBg=(XBo= xy, hRg= pjConsts, Int32& pj_Error);
    internal virtual XBo= wRg=(XRg= lp, hRg= pjConsts, Int32& pj_Error);
}
internal class 8RQ=.MBo= : Txo= {
    internal double eRc=;
    internal double ehc=;
    internal double fBc=;
    internal MBo=(string id, string desc);
    private void uhg=();
    internal virtual hRg= uxg=(hRg= pjConsts, Int32& pj_Error);
    internal virtual void whg=(XRg= lp, hRg= pjConsts, EBg= fac, Int32& pj_Error);
    internal virtual XRg= wBg=(XBo= xy, hRg= pjConsts, Int32& pj_Error);
    internal virtual XBo= wRg=(XRg= lp, hRg= pjConsts, Int32& pj_Error);
    private hRg= fBk=(hRg= pjConsts, double p, Int32& pj_Error);
}
internal class 8RQ=.mC4= : object {
    private int DC4=;
    private int Di4=;
    private int DS4=;
    private int Dy4=;
    private byte gyw=;
    private ushort mS4=;
    public int YC0= { get; }
    public int Yy0= { get; }
    public int Zi0= { get; }
    public int aS0= { get; }
    public byte IC0= { get; }
    public ushort ryw= { get; }
    public int Xi0=();
    public int YS0=();
    public int ZC0=();
    public int Zy0=();
    public byte Hi0=();
    public ushort rSw=();
    public void ZRw=(Stream stream, int treOffset);
}
internal class 8RQ=.MCg= : object {
    protected int MSg=;
    protected xSc= Mig=;
    private static xSc= Myg=;
    public xSc= HyU= { get; public set; }
    public int IiU= { get; public set; }
    public virtual int IyU=();
    public virtual xSc= JCU=();
    public virtual int JSU=();
    public virtual int JiU=();
    public virtual byte JyU=();
    public virtual byte KCU=();
    public virtual void KSU=(int clr);
    public virtual void KiU=(int clr);
    public virtual void KyU=(byte val);
    public virtual void LCU=(byte val);
    public virtual string LSU=();
    public virtual void LiU=(string pszStyleString);
    public virtual void LyU=(Stream fpOut);
    public sealed virtual xSc= HSU=();
    public sealed virtual void HiU=(xSc= value);
    public sealed virtual int ICU=();
    public sealed virtual void ISU=(int value);
}
internal class 8RQ=.mCs= : ValueType {
    [CompilerGeneratedAttribute]
private int mSs=;
    [CompilerGeneratedAttribute]
private int mis=;
    [CompilerGeneratedAttribute]
private int mys=;
    [CompilerGeneratedAttribute]
private int nCs=;
    public int nys= { get; public set; }
    public int ois= { get; public set; }
    public int pSs= { get; public set; }
    public int qCs= { get; public set; }
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public int nSs=();
    [CompilerGeneratedAttribute]
public void nis=(int value);
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public int oCs=();
    [CompilerGeneratedAttribute]
public void oSs=(int value);
    [CompilerGeneratedAttribute]
[IsReadOnlyAttribute]
public int oys=();
    [CompilerGeneratedAttribute]
public void pCs=(int value);
    [CompilerGeneratedAttribute]
[IsReadOnlyAttribute]
public int pis=();
    [CompilerGeneratedAttribute]
public void pys=(int value);
    public virtual string ToString();
}
internal interface 8RQ=.MCU= {
    public int MyU= { get; public set; }
    public cCg= NiU= { get; public set; }
    public abstract virtual int MSU=();
    public abstract virtual void MiU=(int value);
    public abstract virtual cCg= NCU=();
    public abstract virtual void NSU=(cCg= value);
    public abstract virtual int NyU=();
    public abstract virtual cCg= OCU=();
    public abstract virtual string OSU=();
    public abstract virtual void OiU=(string pszName);
    public abstract virtual void OyU=(Stream fpOut);
}
internal static class 8RQ=.mDE= : object {
    internal static string jjE=;
    internal static string jzE=;
    internal static String[] mTE=;
    internal static string mjE=;
    internal static String[] mzE=;
    private static mDE=();
}
internal class 8RQ=.Mho= : Txo= {
    internal Mho=(string id, string desc);
    private void uhg=();
    internal virtual hRg= uxg=(hRg= pjConsts, Int32& pj_Error);
    internal virtual void whg=(XRg= lp, hRg= pjConsts, EBg= fac, Int32& pj_Error);
    internal virtual XRg= wBg=(XBo= xy, hRg= pjConsts, Int32& pj_Error);
    internal virtual XBo= wRg=(XRg= lp, hRg= pjConsts, Int32& pj_Error);
}
internal class 8RQ=.mi4= : object {
    private HCw= my4=;
    private string uy0=;
    public mi4=(string tGeoFilePathName);
    public void 2h4=(List`1<Ri0=> shifterTGeoFATs, li0= tGeoParameters, double extentWidthLimitation, TinyGeoFileType type);
    private void nC4=(Ri0= shifterTGeoFAT, int startPart, Encoding encoding);
    public void nS4=(string rgnTempPath);
    public void ni4=(string treTempPath);
    public void ny4=(string lblTempPath);
    public void QB8=();
}
internal class 8RQ=.MRk= : Txo= {
    internal double Mhk=;
    internal double Mxk=;
    internal double NBk=;
    internal double NRk=;
    internal double Nhk=;
    internal double Nxk=;
    internal double OBk=;
    internal double ORk=;
    internal double XBc=;
    internal double Ohk=;
    internal double Oxk=;
    internal double PBk=;
    internal Double[] uBg=;
    internal int zBg=;
    internal MRk=(string id, string desc);
    private void uhg=();
    internal virtual hRg= uxg=(hRg= pjConsts, Int32& pj_Error);
    internal virtual void whg=(XRg= lp, hRg= pjConsts, EBg= fac, Int32& pj_Error);
    internal virtual XRg= wBg=(XBo= xy, hRg= pjConsts, Int32& pj_Error);
    internal virtual XBo= wRg=(XRg= lp, hRg= pjConsts, Int32& pj_Error);
    internal int Exk=(hRg= pjConsts, Double[] del, Double[] sig, Int32& pj_Error);
    private XBo= PRk=(XRg= lp, hRg= pjConsts, Double[] yc, Int32& pj_Error);
}
internal class 8RQ=.MRo= : Txo= {
    internal double eRc=;
    internal double ehc=;
    internal double BBk=;
    internal double BRk=;
    internal MRo=(string id, string desc);
    private void uhg=();
    internal virtual hRg= uxg=(hRg= pjConsts, Int32& pj_Error);
    internal virtual void whg=(XRg= lp, hRg= pjConsts, EBg= fac, Int32& pj_Error);
    internal virtual XRg= wBg=(XBo= xy, hRg= pjConsts, Int32& pj_Error);
    internal virtual XBo= wRg=(XRg= lp, hRg= pjConsts, Int32& pj_Error);
}
internal class 8RQ=.MSY= : object {
    public int MiY=;
    public OiY= MyY=(Lic= poPoly, KSc= poLabelPoint);
    private bool NCY=(KSc= poPoint, Lic= poPoly);
    private bool NSY=(KSc= poPoint, Fyc= poRing);
}
internal class 8RQ=.mxk= : Txo= {
    internal double nBk=;
    internal double nRk=;
    internal double nhk=;
    internal double nxk=;
    internal double oBk=;
    internal double oRk=;
    internal mxk=(string id, string desc);
    private void uhg=();
    internal virtual hRg= uxg=(hRg= pjConsts, Int32& pj_Error);
    internal virtual void whg=(XRg= lp, hRg= pjConsts, EBg= fac, Int32& pj_Error);
    internal virtual XRg= wBg=(XBo= xy, hRg= pjConsts, Int32& pj_Error);
    internal virtual XBo= wRg=(XRg= lp, hRg= pjConsts, Int32& pj_Error);
}
internal class 8RQ=.Mxo= : Txo= {
    internal double 2Bg=;
    internal Mxo=(string id, string desc);
    private void uhg=();
    internal virtual hRg= uxg=(hRg= pjConsts, Int32& pj_Error);
    internal virtual void whg=(XRg= lp, hRg= pjConsts, EBg= fac, Int32& pj_Error);
    internal virtual XRg= wBg=(XBo= xy, hRg= pjConsts, Int32& pj_Error);
    internal virtual XBo= wRg=(XRg= lp, hRg= pjConsts, Int32& pj_Error);
}
internal class 8RQ=.NBo= : Txo= {
    internal double 2Bg=;
    internal NBo=(string id, string desc);
    private void uhg=();
    internal virtual hRg= uxg=(hRg= pjConsts, Int32& pj_Error);
    internal virtual void whg=(XRg= lp, hRg= pjConsts, EBg= fac, Int32& pj_Error);
    internal virtual XRg= wBg=(XBo= xy, hRg= pjConsts, Int32& pj_Error);
    internal virtual XBo= wRg=(XRg= lp, hRg= pjConsts, Int32& pj_Error);
}
internal enum 8RQ=.NCg= : Enum {
    public int value__;
    public static NCg= NSg=;
    public static NCg= Nig=;
    public static NCg= Nyg=;
    public static NCg= OCg=;
    public static NCg= OSg=;
    public static NCg= Oig=;
    public static NCg= Oyg=;
    public static NCg= PCg=;
    public static NCg= PSg=;
    public static NCg= Pig=;
    public static NCg= Pyg=;
    public static NCg= QCg=;
    public static NCg= QSg=;
}
internal class 8RQ=.nCk= : lSk= {
    public int nSk=;
    public int nik=;
}
internal static class 8RQ=.nDE= : object {
    internal static string nTE=;
    internal static string njE=;
    internal static string nzE=;
    internal static string oDE=;
    internal static string oTE=;
    internal static string iDE=;
    internal static string iTE=;
    internal static string ojE=;
    internal static string ozE=;
    internal static string pDE=;
    internal static string pTE=;
    internal static string pjE=;
    internal static string pzE=;
    internal static string izE=;
    internal static string qDE=;
    internal static string qTE=;
    internal static string qjE=;
    internal static string qzE=;
    internal static string jjE=;
    internal static string jzE=;
    internal static String[] rDE=;
    internal static String[] kjE=;
    internal static string rTE=;
    internal static String[] rjE=;
    internal static string rzE=;
    internal static string sDE=;
    internal static string sTE=;
    private static nDE=();
}
internal class 8RQ=.Nho= : object {
    private Txo= Nxo=;
    private Dictionary`2<string, string> OBo=;
    internal Txo= Oho= { get; }
    internal Nho=(Dictionary`2<string, string> proj_List);
    private string Oxo=(Dictionary`2<string, string> args);
    internal void PBo=(Dictionary`2<string, string> args);
    internal Txo= ORo=();
    private bool PRo=(string projID);
}
internal class 8RQ=.Ni4= : object {
    private List`1<Ai4=> Ny4=;
    private Xyw= YSw=;
    public List`1<Ai4=> OS4= { get; }
    public List`1<Ai4=> OC4=();
    public void ZRw=(Stream stream, int endOffset, bool isEncrypted, Encoding encoding, int columnNameBlockCount, string password);
}
internal class 8RQ=.Nic= : object {
    public static void Nyc=(String& destString, int index, string srcString);
    public static void qCQ=(T[] dest, int indexDest, T[] src, int indexSrc, int count);
    public static T[] pCQ=(T[] srcArray, int destLength);
    public static int mSQ=(String& stringDst, int index);
    public static int mSQ=(string charArray);
    public static string miQ=(string strOgr, string strSub);
    public static bool oiQ=(string string1, string string2, int count);
    public static bool oyQ=(string string1, string string2);
}
internal class 8RQ=.NiE= : object {
    public static int NyE=;
    private static HyE= 6yA=;
    private TextReader OCE=;
    private Char[] eRw=;
    private MT0= OSE=;
    private NT0= OiE=;
    private int OyE=;
    private int PCE=;
    private int PSE=;
    private int PiE=;
    private bool PyE=;
    private bool QCE=;
    private char QSE=;
    private Nullable`1<char> QiE=;
    public TextReader nhw= { get; }
    public bool 8iA= { get; public set; }
    public bool 9SA= { get; public set; }
    public char /CA= { get; public set; }
    public Nullable`1<char> /yA= { get; public set; }
    public bool BiE= { get; }
    private bool RCE= { get; }
    public NiE=(TextReader reader);
    private static NiE=();
    public TextReader nBw=();
    public bool 8CA=();
    public void 8SA=(bool value);
    public bool 8yA=();
    public void 9CA=(bool value);
    public char 9iA=();
    public void 9yA=(char value);
    public Nullable`1<char> /SA=();
    public void /iA=(Nullable`1<char> value);
    public bool BSE=();
    private bool QyE=();
    public int CyE=(int skip);
    public int RSE=(EyE= headerRecord, ESE=[] buffer, int offset, int count);
    private static bool RiE=(char ch);
    private void RyE=();
    private bool SCE=(char ch);
    private bool SSE=();
    private bool SiE=();
}
internal enum 8RQ=.NiQ= : Enum {
    public int value__;
    public static NiQ= NyQ=;
    public static NiQ= OCQ=;
    public static NiQ= OSQ=;
    public static NiQ= OiQ=;
    public static NiQ= OyQ=;
    public static NiQ= PCQ=;
    public static NiQ= PSQ=;
    public static NiQ= PiQ=;
    public static NiQ= PyQ=;
    public static NiQ= QCQ=;
    public static NiQ= QSQ=;
    public static NiQ= QiQ=;
}
internal enum 8RQ=.niY= : Enum {
    public int value__;
    public static niY= nyY=;
    public static niY= oCY=;
    public static niY= oSY=;
    public static niY= oiY=;
    public static niY= oyY=;
    public static niY= pCY=;
    public static niY= pSY=;
    public static niY= piY=;
}
internal abstract class 8RQ=.NiY= : 8yY= {
    public abstract virtual void NyY=(KSc= ogrPoint);
    public abstract virtual void OCY=(KSc= ogrPoint);
    public virtual int OSY=();
}
internal class 8RQ=.njA= : object {
    private double nzA=;
    private double oDA=;
    private PointShape oTA=;
    public PointShape ozA= { get; }
    public double pTA= { get; }
    public double pzA= { get; }
    public njA=(PointShape midLinePoint, double lineSegmentLength, double angle);
    public PointShape ojA=();
    public double pDA=();
    public double pjA=();
}
internal class 8RQ=.nR8= : ValueType {
    public xx8= nh8=;
    public xx8= nx8=;
    public nR8=(double x1, double y1, double x2, double y2);
    public double oB8=(xx8= p);
    public void oR8=();
    public static int MB8=(bool isFloat);
    public bool ZRw=(BinaryReader r, bool isFloat);
    public bool cxw=(BinaryWriter w, bool isFloat);
    public bool WB8=(nR8= testRect);
    public bool WB8=(xx8= testPoint);
    public bool WR8=(nR8= testRect);
    public bool Wh8=(nR8= testRect);
    public double oh8=();
    public double ox8=();
    public double gh8=();
    public bool pB8=(nR8= testRt);
    public DrawingRectangleF pR8=();
    public nR8= ph8=(nR8= rt);
    public double px8=(nR8= rt);
    public virtual string ToString();
}
internal class 8RQ=.NRo= : Txo= {
    internal double 2Bg=;
    internal int zBg=;
    internal NRo=(string id, string desc);
    private void uhg=();
    internal virtual hRg= uxg=(hRg= pjConsts, Int32& pj_Error);
    internal virtual void whg=(XRg= lp, hRg= pjConsts, EBg= fac, Int32& pj_Error);
    internal virtual XRg= wBg=(XBo= xy, hRg= pjConsts, Int32& pj_Error);
    internal virtual XBo= wRg=(XRg= lp, hRg= pjConsts, Int32& pj_Error);
}
internal class 8RQ=.nS8= : object {
    private String[] ni8=;
    private int ny8=;
    public nS8=(TextReader reader, Char[] delimiter);
    public string oC8=();
}
internal enum 8RQ=.nSc= : Enum {
    public int value__;
    public static nSc= nic=;
    public static nSc= nyc=;
    public static nSc= oCc=;
}
internal class 8RQ=.nTA= : object {
    public sealed virtual int Compare(FeatureLabelingCandidate x, FeatureLabelingCandidate y);
}
internal class 8RQ=.Nx8= : object {
    internal static bool OB8=(Double& left, Double& bottom, Double& right, Double& top);
    internal static void Mx4=(Double& a, Double& b);
}
internal class 8RQ=.nxg= : object {
    private Pho= oBg=;
    private Dictionary`2<string, Pho=> oRg=;
    internal Pho= oxg= { get; }
    internal nxg=(Dictionary`2<string, string> args, Dictionary`2<string, Pho=> pj_Datums_List);
    private string pBg=(Dictionary`2<string, string> args);
    private void pRg=(string datumID);
    internal Pho= ohg=();
}
internal class 8RQ=.NxU= : object {
    private static ConcurrentDictionary`2<GeoFont, SKTypeface> OBU=;
    private SKBitmap ORU=;
    private SKCanvas OhU=;
    private bool OxU=;
    private bool PBU=;
    private float PRU=;
    [CompilerGeneratedAttribute]
private SKFilterQuality PhU=;
    public SKFilterQuality QRU= { get; public set; }
    public NxU=(GeoImage image);
    private static NxU=();
    [CompilerGeneratedAttribute]
public SKFilterQuality PxU=();
    [CompilerGeneratedAttribute]
public void QBU=(SKFilterQuality value);
    public void QhU=(GeoColor color);
    public void QxU=();
    public void RBU=(float dx, float dy);
    public void RRU=(float angle);
    public void IxU=();
    public void RhU=();
    public void NBU=(GeoImage image, int srcX, int srcY, int srcWidth, int srcHeight, cRU=[] colors);
    public void JhU=(GeoImage image, float x, float y);
    public void JhU=(GeoImage image, DrawingRectangleF destRect, DrawingRectangleF srcRect);
    public void JhU=(GeoImage image, float x, float y, float width, float height);
    public void RxU=(GeoImage image, float x, float y, float width, float height);
    public void RxU=(GeoImage image, float x, float y, float width, float height, float canvasWidth, float canvasHeight);
    public void JhU=(GeoImage image, DrawingRectangle destRect, DrawingRectangle srcRect, Single[][] colorMatrix);
    public void SBU=(GeoImage image, int x, int y, float canvasWidth, float canvasHeight);
    public void SRU=(IEnumerable`1<ScreenPointF[]> screenPoints, GeoPen outlinePen, GeoBrush fillBrush, PenBrushDrawingOrder penBrushDrawingOrder);
    public void ShU=(ScreenPointF screenPoint, float width, float height, GeoPen outlinePen, GeoBrush fillBrush, PenBrushDrawingOrder penBrushDrawingOrder);
    public void DxU=(IEnumerable`1<ScreenPointF> screenPoints, GeoPen linePen);
    public void SxU=(GeoPen pen, float x, float y, float width, float height, float startAngle, float sweepAngle);
    public void NRU=(ScreenPointF centerPoint, int radius, Single[] positions, GeoColor[] colors);
    public void TBU=(string text, GeoFont font, GeoBrush brush, GeoPen haloPen, IEnumerable`1<ScreenPointF> textPathInScreen, DrawingTextAlignment drawingTextAlignment);
    private SKTypeface TRU=(string text, SKTypeface sKTypeface);
    private ValueTuple`2<SKTypeface, string> ThU=(string text);
    internal float FhU=(GeoFont font, DrawingTextBaseline textBaseline, string text);
    public void TBU=(string text, GeoFont font, GeoBrush brush, GeoPen haloPen, ScreenPointF point, DrawingTextAlignment drawingTextAlignment);
    public DrawingRectangleF TxU=(string text, GeoFont font);
    private SKPaint UBU=();
    private SKColor URU=(GeoColor geoColor);
    private SKRect UhU=(DrawingRectangle rect);
    private SKRect UhU=(DrawingRectangleF rect);
    private SKRectI UxU=(DrawingRectangle rect);
    private SKPaint VBU=(GeoBrush geoBrush, SKPoint[] points);
    private SKPaint VRU=(GeoPen geoPen);
    private SKPaint VhU=(GeoFont font, GeoBrush brush, IEnumerable`1<ScreenPointF> points);
    private static SKTypeface VxU=(GeoFont font);
    private SKPaint VhU=(GeoFont font, GeoBrush brush, DrawingTextAlignment align, IEnumerable`1<ScreenPointF> points);
    private static SKFontStyle WBU=(DrawingFontStyles style);
    private void WRU=(GeoBrush geoBrush, SKPaint paint, IEnumerable`1<ScreenPointF> points);
    private void WhU=(string text, SKPaint paint, GeoFont geoFont);
    private SKShader WxU=(GeoHatchStyle hatchStyle, GeoColor foreColor, GeoColor backColor);
    private static void XBU=(float startX, float startY, float endX, float endY, SKPaint linePaint, SKCanvas canvas, DrawingLineCap drawingLineCap);
    private static SKPoint XRU=(float x, float y, double rotateRadian, float dx, float dy);
    private static double XhU=(float startX, float startY, float endX, float endY);
    public sealed virtual void Dispose();
}
internal class 8RQ=.nyk= : lSk= {
    public int oCk=;
    public int oSk=;
    public int oik=;
    public int oyk=;
    public byte bCk=;
    public virtual int bSk=(fCk= poObjBlock);
    public virtual int bik=(fCk= poObjBlock);
}
internal class 8RQ=.oBs= : object {
    private static UInt32 oRs=;
    private static UInt32 ohs=;
    private static UInt32 oxs=;
    private static UInt32 pBs=;
    private static UInt32 pRs=;
    private static UInt32 phs=;
    private static UInt32 pxs=;
    private static UInt32 qBs=;
    private static double IRY=;
    private static double fxs=;
    private static double gBs=;
    private static double qRs=;
    private static double qhs=;
    private static double qxs=;
    private static double Ihs=;
    private static double Ixs=;
    private double rBs=;
    private double rRs=;
    private double rhs=;
    private double rxs=;
    private double sBs=;
    private double sRs=;
    private double shs=;
    private double sxs=;
    private double tBs=;
    private double tRs=;
    internal long ths=(double a, double f);
    internal void txs=(Double& a, Double& f);
    public bool uBs=(double Latitude, double Longitude, Char& Hemisphere, Double& Easting, Double& Northing);
    internal long uRs=(double Latitude, double Longitude, Char& Hemisphere, Double& Easting, Double& Northing);
    public bool uhs=(char Hemisphere, double Easting, double Northing, Double& Latitude, Double& Longitude);
    internal long uxs=(char Hemisphere, double Easting, double Northing, Double& Latitude, Double& Longitude);
}
internal class 8RQ=.oC4= : object {
    private HCw= oS4=;
    private int oi4=;
    private int rBM=;
    public oC4=(string outPut);
    public void ny4=(gy0= lblPara, Encoding encoding);
    public void QB8=();
    public void oy4=();
}
internal class 8RQ=.OCc= : object {
    public double XRo=;
    public double Xho=;
}
internal class 8RQ=.oCo= : ECU= {
    private string gSU=;
    private string oSo=;
    private yCY= oio=;
    private WSg= oyo=;
    private int pCo=;
    private int pSo=;
    private WSg= pio=;
    private bool pyo=;
    private int qCo=(string pszFname, bool bTestOpenNoError);
    private int qSo=(GSg= poIndexFeature, bool bTestOpenNoError);
    private int qSo=(int nTableId, bool bTestOpenNoError);
    private int qio=(bool bTestOpenNoError);
    private int qyo=(int nTableId, int nBaseFeatureId);
    private int rCo=(int nEncodedFeatureId);
    private int rSo=(int nEncodedFeatureId);
    public virtual int Close();
    public virtual aig= GetFileClass();
    public virtual int Open(string pszFname, FileAccess pszAccess, bool bTestOpenNoError);
    public virtual string GetTableName();
    public virtual void SetSpatialFilter(8yY= poGeomIn);
    public virtual void ResetReading();
    public virtual bool TestCapability(string pszCap);
    public virtual int GetFeatureCount(bool bForce);
    public virtual OiY= GetExtent(qyY= psExtent, bool bForce);
    public virtual int GetNextFeatureId(int nPrevId);
    public virtual GSg= GetFeatureRef(int nFeatureId);
    public virtual yCY= GetLayerDefn();
    public virtual Tig= GetNativeFieldType(int nFieldId);
    public virtual int GetBounds(Double& dXMin, Double& dYMin, Double& dXMax, Double& dYMax, bool bForce);
    public virtual OSc= GetSpatialRef();
    public virtual int GetFeatureCountByType(Int32& numPoints, Int32& numLines, Int32& numRegions, Int32& numTexts, bool bForce);
    public virtual bool IsFieldIndexed(int nFieldId);
    public virtual bool IsFieldUnique(int nFieldId);
    public virtual int SetBounds(double dXMin, double dYMin, double dXMax, double dYMax);
    public virtual int SetFeatureDefn(yCY= poFeatureDefn, List`1<Tig=> paeMapInfoNativeFieldTypes);
    public virtual int AddFieldNative(string pszName, Tig= eMapInfoType, int nWidth, int nPrecision, bool bIndexed, bool bUnique);
    public virtual int SetSpatialRef(OSc= poSpatialRef);
    public virtual int SetFeature(GSg= poFeature, int nFeatureId);
    public virtual int SetFieldIndexed(int nFieldId);
    public virtual int GetProjInfo(GCo= poPI);
    public virtual int SetProjInfo(GCo= poPI);
    public virtual int SetMIFCoordSys(string pszMIFCoordSys);
}
internal class 8RQ=.ohk= : Txo= {
    internal double oxk=;
    internal double CRk=;
    internal double Rhc=;
    internal double pBk=;
    internal double pRk=;
    internal double Lxk=;
    internal double phk=;
    internal double pxk=;
    internal double qBk=;
    internal double qRk=;
    internal double qhk=;
    internal ohk=(string id, string desc);
    private void uhg=();
    internal virtual hRg= uxg=(hRg= pjConsts, Int32& pj_Error);
    internal virtual void whg=(XRg= lp, hRg= pjConsts, EBg= fac, Int32& pj_Error);
    internal virtual XRg= wBg=(XBo= xy, hRg= pjConsts, Int32& pj_Error);
    internal virtual XBo= wRg=(XRg= lp, hRg= pjConsts, Int32& pj_Error);
}
internal class 8RQ=.ohU= : object {
    internal DataTable oxU=;
    internal string pBU=;
    internal int pRU=;
}
internal class 8RQ=.Oi4= : object {
    private List`1<string> Oy4=;
    private int PC4=;
    private int PS4=;
    private double iyw=;
    private Encoding rB4=;
    private int Pi4=;
    private TinyGeoFileType vy0=;
    public List`1<string> QC4= { get; }
    public int Qi4= { get; }
    public int RC4= { get; }
    public double qC0= { get; }
    public int Ri4= { get; }
    public Encoding qi0= { get; }
    public TinyGeoFileType 7y0= { get; }
    public List`1<string> Py4=();
    public int QS4=();
    public int Qy4=();
    public double py0=();
    public int RS4=();
    public Encoding qS0=();
    public TinyGeoFileType 7i0=();
    public void ZRw=(Stream stream, bool isEncrypted, string password);
}
internal enum 8RQ=.OiY= : Enum {
    public int value__;
    public static OiY= OyY=;
    public static OiY= tyQ=;
    public static OiY= uCQ=;
    public static OiY= uSQ=;
    public static OiY= uiQ=;
    public static OiY= uyQ=;
    public static OiY= vCQ=;
    public static OiY= vSQ=;
    public static OiY= viQ=;
}
internal enum 8RQ=.oSc= : Enum {
    public int value__;
    public static oSc= oic=;
    public static oSc= oyc=;
    public static oSc= pCc=;
}
internal class 8RQ=.OSc= : object {
    private double Oic=;
    private double Oyc=;
    private double PCc=;
    private gSc= PSc=;
    private int ySY=;
    private int Pic=;
    private void thY=();
    public int 0yY=();
    public int 1CY=();
    public OSc= 4RY=();
    public OiY= gxY=(double dfCenterLat, double dfCenterLong, double dfScale, double dfFalseEasting, double dfFalseNorthing);
    public OiY= hxY=(double dfStdP1, double dfStdP2, double dfCenterLat, double dfCenterLong, double dfFalseEasting, double dfFalseNorthing);
    public OiY= iBY=(double dfCenterLat, double dfCenterLong, double dfFalseEasting, double dfFalseNorthing);
    public OiY= ihY=(double dfStdP1, double dfCentralMeridian, double dfFalseEasting, double dfFalseNorthing);
    public OiY= ixY=(double dfCenterLat, double dfCenterLong, double dfFalseEasting, double dfFalseNorthing);
    public OiY= jBY=(double dfStdP1, double dfStdP2, double dfCenterLat, double dfCenterLong, double dfFalseEasting, double dfFalseNorthing);
    public OiY= Pyc=(double dfCentralMeridian, double dfFalseEasting, double dfFalseNorthing);
    public OiY= QCc=(double dfCentralMeridian, double dfFalseEasting, double dfFalseNorthing);
    public OiY= kBY=(double dfCentralMeridian, double dfFalseEasting, double dfFalseNorthing);
    public OiY= lRY=(double dfCenterLat, double dfCenterLong, double dfAzimuth, double dfRectToSkew, double dfScale, double dfFalseEasting, double dfFalseNorthing);
    public OiY= mBY=(double dfCenterLat, double dfCenterLong, double dfFalseEasting, double dfFalseNorthing);
    public OiY= mRY=(double dfStdP1, double dfStdP2, double dfCenterLat, double dfCenterLong, double dfFalseEasting, double dfFalseNorthing);
    public OiY= mxY=(double dfStdP1, double dfStdP2, double dfCenterLat, double dfCenterLong, double dfFalseEasting, double dfFalseNorthing);
    public OiY= nBY=(double dfCenterLat, double dfCenterLong, double dfFalseEasting, double dfFalseNorthing);
    public OiY= nRY=(double dfCenterLat, double dfCenterLong, double dfScale, double dfFalseEasting, double dfFalseNorthing);
    public OiY= nxY=(double dfCentralMeridian, double dfFalseEasting, double dfFalseNorthing);
    public OiY= oBY=(double dfCenterLat, double dfCenterLong, double dfFalseEasting, double dfFalseNorthing);
    public OiY= oxY=(double dfCenterLat, double dfCenterLong, double dfFalseEasting, double dfFalseNorthing);
    public OiY= pRY=(double dfCenterLong, double dfFalseEasting, double dfFalseNorthing);
    public OiY= phY=(double dfCenterLong, double dfFalseEasting, double dfFalseNorthing);
    public OiY= pxY=(double dfOriginLat, double dfCMeridian, double dfScale, double dfFalseEasting, double dfFalseNorthing);
    public OiY= qBY=(double dfLatitudeOfOrigin, double dfCentralMeridian, double dfFalseEasting, double dfFalseNorthing);
    public OiY= QSc=(string pszVariantName, double dfCenterLat, double dfCenterLong, double dfScale, double dfFalseEasting, double dfFalseNorthing);
    public OiY= /SY=(String& ppszResult);
    public static int tBY=(string pszParameterName);
    public OiY= sxY=(double dfDX, double dfDY, double dfDZ, double dfEX, double dfEY, double dfEZ, double dfPPM);
    public gSc= 0B8=();
    public void Qic=(gSc= poNewRoot);
    public gSc= bRY=(string pszNodePath);
    public string bhY=(string pszNodeName, int iAttr);
    public OiY= cRY=(string pszNodePath, string pszNewNodeValue);
    public OiY= dBY=(string pszUnitsName, double dfInMeters);
    public double dRY=(String& ppszName);
    public double cxY=(String& ppszName);
    public double dhY=(String& ppszName);
    public void QhU=();
    public OiY= dxY=(string pszGeogName, string pszDatumName, string pszSpheroidName, double dfSemiMajor, double dfInvFlattening, string pszPMName, double dfPMOffset, string pszAngularUnits, double dfConvertToRadians);
    public OiY= fhY=(string pszParmName, double dfValue);
    public double gBY=(string pszName, double dfDefaultValue, OiY=& pnErr);
    public double gBY=(string pszName, double dfDefaultValue);
    public OiY= ghY=(string pszName, double dfValue);
    public static int tRY=(string pszParameterName);
    public OiY= Qyc=(string pszName);
    public OiY= fRY=(string pszProjection);
}
internal class 8RQ=.oSg= : lyQ= {
    private Stream 5yc=;
    private oSc= giU=;
    private oSg= oig=;
    private oSg= oyg=;
    private uic= pCg=;
    private int pSg=;
    private int pig=;
    private Tig= pyg=;
    private bool qCg=;
    private int qSg=;
    private int qig=;
    private XSo= qyg=;
    private int rCg=;
    private int rSg=;
    private int rig=;
    public oSg=(oSc= eAccessMode);
    private int ryg=(int nNewNodePtr);
    private int sCg=(int nEntryNo, Byte[] pKeyValue);
    private int sSg=(Byte[] pKeyValue, int nEntryNo);
    private int sig=(Byte[] pKeyValue, int nRecordNo, bool bInsertAfterCurChild, bool bMakeNewEntryCurChild);
    private int syg=(int numEntries, Byte[] pBuf, int nCurIndexEntry, oSg= poCurChild);
    public int tCg=(Stream fs, int nBlockPtr, int nKeyLength, int nSubTreeDepth, bool bUnique, uic= poBlockMgr, oSg= poParentNode, int nPrevNodePtr, int nNextNodePtr);
    public int tSg=(Tig= eType);
    public int tig=();
    public int tyg=();
    public int uCg=();
    public int uSg=();
    public int uig=();
    public int nig=(Byte[] pKeyValue);
    public int uyg=();
    public int oCg=(Byte[] pKeyValue, int nRecordNo, bool bAddInThisNodeOnly, bool bInsertAfterCurChild, bool bMakeNewEntryCurChild);
    public int Dh8=();
    public int vCg=();
    public Byte[] vSg=();
    public int vig=(Byte[] pKeyValue, int nRecordNo);
    public int vyg=(Byte[] pKeyValue1, int nRecordNo1, Byte[] pKeyValue2, int nRecordNo2, int nNewCurChildNo);
    public int wCg=(int nPrevNodePtr);
    public int wSg=(int nNextNodePtr);
}
internal enum 8RQ=.OSs= : Enum {
    public int value__;
    public static OSs= Ois=;
    public static OSs= Oys=;
    public static OSs= PCs=;
}
internal class 8RQ=.Ox4= : EventArgs {
    private bool PB4=;
    internal bool Px4= { get; internal set; }
    internal bool PR4=();
    internal void Ph4=(bool value);
}
internal class 8RQ=.pC4= : object {
    private HCw= pS4=;
    private HCw= pi4=;
    private UInt32 py4=;
    private int rBM=;
    private int oi4=;
    private bool qC4=;
    private bool qS4=;
    private bool qi4=;
    private MemoryStream qy4=;
    [CompilerGeneratedAttribute]
private List`1<int> rC4=;
    [CompilerGeneratedAttribute]
private List`1<byte> rS4=;
    public List`1<int> sC4= { get; private set; }
    public List`1<byte> sy4= { get; private set; }
    public pC4=(string output);
    [CompilerGeneratedAttribute]
private void ry4=(List`1<int> value);
    [CompilerGeneratedAttribute]
public List`1<int> ri4=();
    [CompilerGeneratedAttribute]
private void si4=(List`1<byte> value);
    [CompilerGeneratedAttribute]
public List`1<byte> sS4=();
    public void 2h4=();
    public void tC4=();
    public void tS4=(5Sw= rgnPoint);
    public void ti4=(Ey0= rgnLine);
    public void ty4=(/Cw= rgnGon);
    public void uC4=();
    public void QB8=();
    public void oy4=();
}
internal class 8RQ=.pCk= : nCk= {
    public int pSk=;
    public int Hyg=;
    public int ICg=;
    public byte pik=;
    public int pyk=;
    public int qCk=;
    public virtual int bSk=(fCk= poObjBlock);
    public virtual int bik=(fCk= poObjBlock);
}
internal interface 8RQ=.PCU= {
    public yyk= PyU= { get; public set; }
    public int QiU= { get; public set; }
    public abstract virtual int QyU=();
    public abstract virtual yyk= RCU=();
    public abstract virtual byte RSU=();
    public abstract virtual double RiU=();
    public abstract virtual int RyU=();
    public abstract virtual byte SCU=();
    public abstract virtual int SSU=();
    public abstract virtual string SiU=();
    public abstract virtual yyk= PSU=();
    public abstract virtual void PiU=(yyk= value);
    public abstract virtual void QSU=(int value);
    public abstract virtual int QCU=();
    public abstract virtual void SyU=(byte val);
    public abstract virtual void TCU=(double val);
    public abstract virtual void TSU=(int val);
    public abstract virtual void TiU=(byte val);
    public abstract virtual void TyU=(int clr);
    public abstract virtual void UCU=(string pszStyleString);
    public abstract virtual void USU=(Stream fpOut);
}
internal class 8RQ=.PCw= : object {
    [CompilerGeneratedAttribute]
private bool PSw=;
    [CompilerGeneratedAttribute]
private Vertex MCw=;
    public bool QCw= { get; public set; }
    public Vertex NSw= { get; public set; }
    public PCw=(double x, double y);
    public PCw=(Vertex vertex);
    [CompilerGeneratedAttribute]
public void Pyw=(bool value);
    [CompilerGeneratedAttribute]
public bool Piw=();
    [CompilerGeneratedAttribute]
public Vertex Myw=();
    [CompilerGeneratedAttribute]
public void NCw=(Vertex value);
}
internal enum 8RQ=.PCY= : Enum {
    public int value__;
    public static PCY= PSY=;
    public static PCY= PiY=;
}
internal class 8RQ=.phg= : object {
    private QRo= pxg=;
    private Pho= qBg=;
    private Dictionary`2<string, QRo=> qRg=;
    private hRg= qhg=;
    private Dictionary`2<string, string> qxg=;
    internal hRg= rRg= { get; }
    internal phg=(Dictionary`2<string, string> argList, Pho= datums, hRg= pj_consts, Dictionary`2<string, QRo=> pj_Ellps_List, Int32& pj_Error);
    private void rhg=(Dictionary`2<string, string> paras, string ellpsID, Int32& pj_Error);
    internal hRg= rBg=();
}
internal class 8RQ=.Phk= : Txo= {
    internal double eRc=;
    internal double ehc=;
    internal double fBc=;
    internal int Fhk=;
    internal Phk=(string id, string desc);
    private void uhg=();
    internal virtual hRg= uxg=(hRg= pjConsts, Int32& pj_Error);
    internal virtual void whg=(XRg= lp, hRg= pjConsts, EBg= fac, Int32& pj_Error);
    internal virtual XRg= wBg=(XBo= xy, hRg= pjConsts, Int32& pj_Error);
    internal virtual XBo= wRg=(XRg= lp, hRg= pjConsts, Int32& pj_Error);
}
internal class 8RQ=.Pho= : object {
    internal string Pxo=;
    internal string QBo=;
    internal Pho=(string id, string defn, string ellipse_id);
}
internal static class 8RQ=.phU= : object {
    internal static string pxU=(string esriWkt, IFormatProvider provider);
    internal static string qBU=(string proj4, IFormatProvider provider);
    private static void qRU=();
}
internal class 8RQ=.pSc= : GSg= {
    private double pic=;
    private double pyc=;
    private static int hCQ=;
    private static int hSQ=;
    private static int hiQ=;
    private static int hyQ=;
    private Rig= qCc=;
    public double qSc=;
    public double qic=;
    public double qyc=;
    public double rCc=;
    public yyk= PyU= { get; public set; }
    public int QiU= { get; public set; }
    public pSc=(yCY= poDefnIn);
    public virtual int rSc=(5yg= poMapFile);
    public virtual NCg= ric=();
    public virtual int ryc=(5yg= poMapFile);
    public virtual GSg= sCc=(yCY= poNewDefn);
    public virtual int sSc=(5yg= poMapFile, lSk= poObjHdr, bool bCoordBlockDataOnly, wig=& ppoCoordBlock);
    public virtual int sic=(5yg= poMapFile, lSk= poObjHdr, bool bCoordBlockDataOnly, wig=& ppoCoordBlock);
    public virtual int syc=(eyU= fp);
    public virtual int tCc=(eyU= fp);
    public virtual string xiY=();
    public virtual void tSc=(Stream fsOut);
    public double tic=();
    public double tyc=();
    public void uCc=(double dAngle);
    public void uSc=(double dAngle);
    public virtual int QyU=();
    public virtual yyk= RCU=();
    public virtual byte RSU=();
    public virtual double RiU=();
    public virtual int RyU=();
    public virtual byte SCU=();
    public virtual int SSU=();
    public virtual string SiU=();
    public sealed virtual yyk= PSU=();
    public sealed virtual void PiU=(yyk= value);
    public virtual int QCU=();
    public virtual void QSU=(int value);
    public virtual void SyU=(byte val);
    public virtual void TCU=(double val);
    public virtual void TSU=(int val);
    public virtual void TiU=(byte val);
    public virtual void TyU=(int clr);
    public virtual void UCU=(string pszStyleString);
    public virtual void USU=(Stream fpOut);
}
internal enum 8RQ=.PSs= : Enum {
    public int value__;
    public static PSs= xxo=;
    public static PSs= Pis=;
    public static PSs= Pys=;
    public static PSs= QCs=;
    public static PSs= QSs=;
}
internal class 8RQ=.Pxk= : Txo= {
    internal double eRc=;
    internal double ehc=;
    internal double BBk=;
    internal double BRk=;
    internal Pxk=(string id, string desc);
    private void uhg=();
    internal virtual hRg= uxg=(hRg= pjConsts, Int32& pj_Error);
    internal virtual void whg=(XRg= lp, hRg= pjConsts, EBg= fac, Int32& pj_Error);
    internal virtual XRg= wBg=(XBo= xy, hRg= pjConsts, Int32& pj_Error);
    internal virtual XBo= wRg=(XRg= lp, hRg= pjConsts, Int32& pj_Error);
}
internal enum 8RQ=.pyY= : Enum {
    public int value__;
    public static pyY= qCY=;
    public static pyY= qSY=;
    public static pyY= qiY=;
}
internal enum 8RQ=.PyY= : Enum {
    public UInt32 value__;
    public static PyY= QCY=;
    public static PyY= QSY=;
    public static PyY= QiY=;
    public static PyY= QyY=;
    public static PyY= RCY=;
    public static PyY= RSY=;
    public static PyY= RiY=;
    public static PyY= RyY=;
    public static PyY= SCY=;
    public static PyY= SSY=;
    public static PyY= SiY=;
    public static PyY= SyY=;
    public static PyY= TCY=;
    public static PyY= TSY=;
    public static PyY= TiY=;
    public static PyY= TyY=;
    public static PyY= UCY=;
}
internal class 8RQ=.QBk= : Txo= {
    internal double eRc=;
    internal QBk=(string id, string desc);
    private void uhg=();
    internal virtual hRg= uxg=(hRg= pjConsts, Int32& pj_Error);
    internal virtual void whg=(XRg= lp, hRg= pjConsts, EBg= fac, Int32& pj_Error);
    internal virtual XRg= wBg=(XBo= xy, hRg= pjConsts, Int32& pj_Error);
    internal virtual XBo= wRg=(XRg= lp, hRg= pjConsts, Int32& pj_Error);
}
internal enum 8RQ=.QBw= : Enum {
    public int value__;
    public static QBw= QRw=;
    public static QBw= Qhw=;
    public static QBw= Qxw=;
    public static QBw= RBw=;
}
internal enum 8RQ=.qhU= : Enum {
    public int value__;
    public static qhU= qxU=;
    public static qhU= rBU=;
    public static qhU= rRU=;
    public static qhU= rhU=;
    public static qhU= rxU=;
    public static qhU= sBU=;
    public static qhU= sRU=;
}
internal class 8RQ=.qhw= : object {
    private Byte[] qxw=;
    private bool rBw=;
    private bool rRw=;
    private bool rhw=;
    private bool rxw=;
    private bool sBw=;
    private bool sRw=;
    private bool shw=;
    private bool sxw=;
    public Byte[] tRw= { get; }
    public bool uBw= { get; public set; }
    public bool uxw= { get; public set; }
    public bool vhw= { get; public set; }
    public bool wRw= { get; public set; }
    public bool xBw= { get; public set; }
    public bool xxw= { get; public set; }
    public bool yhw= { get; public set; }
    public bool zRw= { get; public set; }
    public Byte[] tBw=();
    public bool thw=();
    public void txw=(bool value);
    public bool uRw=();
    public void uhw=(bool value);
    public bool vBw=();
    public void vRw=(bool value);
    public bool vxw=();
    public void wBw=(bool value);
    public bool whw=();
    public void wxw=(bool value);
    public bool xRw=();
    public void xhw=(bool value);
    public bool yBw=();
    public void yRw=(bool value);
    public bool yxw=();
    public void zBw=(bool value);
    public bool zhw=();
    public void zxw=();
    public void 0Bw=(int c);
    public void 0Rw=(int startChar, int endChar);
    public void 0Rw=(string s);
    public void 0hw=(int c);
    public void 0xw=(int startChar, int endChar);
    public void 1Bw=(int startChar, int endChar);
    public void 1Rw=(int c);
    public void 1hw=(int c);
    public void 1xw=(int c);
    public bool 2Bw=(byte ctype, ixw= type);
    public bool 2Bw=(char c, ixw= type);
    public bool 2Bw=(int c, ixw= type);
}
internal class 8RQ=.Qig= : object {
    protected int Qyg=;
    protected cCg= RCg=;
    private static cCg= RSg=;
    public int MyU= { get; public set; }
    public cCg= NiU= { get; public set; }
    private static Qig=();
    public virtual int NyU=();
    public virtual cCg= OCU=();
    public virtual string OSU=();
    public virtual void OiU=(string pszName);
    public virtual void OyU=(Stream fpOut);
    public virtual int MSU=();
    public virtual void MiU=(int value);
    public virtual cCg= NCU=();
    public virtual void NSU=(cCg= value);
}
internal class 8RQ=.qik= : nCk= {
    public int qyk=;
    public int pyk=;
    public int qCk=;
    public int Hyg=;
    public int ICg=;
    public byte bCk=;
    public byte rCk=;
    public bool rSk=;
    public virtual int bSk=(fCk= poObjBlock);
    public virtual int bik=(fCk= poObjBlock);
}
internal enum 8RQ=.Qis= : Enum {
    public int value__;
    public static Qis= Qys=;
    public static Qis= RCs=;
    public static Qis= RSs=;
    public static Qis= Ris=;
    public static Qis= Rys=;
    public static Qis= SCs=;
}
internal class 8RQ=.QRk= : Txo= {
    internal double Qhk=;
    internal double Qxk=;
    internal double RBk=;
    internal double BBk=;
    internal double 1Bc=;
    internal double RRk=;
    internal double Rhk=;
    internal double Rxk=;
    internal double SBk=;
    internal int SRk=;
    internal QRk=(string id, string desc);
    private void uhg=();
    internal virtual hRg= uxg=(hRg= pjConsts, Int32& pj_Error);
    internal virtual void whg=(XRg= lp, hRg= pjConsts, EBg= fac, Int32& pj_Error);
    internal virtual XRg= wBg=(XBo= xy, hRg= pjConsts, Int32& pj_Error);
    internal virtual XBo= wRg=(XRg= lp, hRg= pjConsts, Int32& pj_Error);
}
internal class 8RQ=.QRo= : object {
    internal string Qho=;
    internal string Qxo=;
    internal QRo=(string id, string major, string ell, string name);
}
internal class 8RQ=.QRs= : object {
    internal static UInt32 Qhs=;
    internal static UInt32 Qxs=;
    internal static UInt32 RBs=;
    internal static UInt32 RRs=;
    internal static UInt32 Rhs=;
    internal static UInt32 Rxs=;
    internal static UInt32 SBs=;
    internal static UInt32 SRs=;
    internal static UInt32 Shs=;
    internal static UInt32 Sxs=;
    private static double IRY=;
    private static double Ihc=;
    private static double TBs=;
    private static double TRs=;
    private double Ths=;
    private double Txs=;
    private double jxg=;
    private double UBs=;
    private double URs=;
    private double Uhs=;
    private double Uxs=;
    private double VBs=;
    private double VRs=;
    private double Vhs=;
    private double Vxs=;
    private double WBs=;
    private double WRs=;
    private double Whs=;
    private double Wxs=;
    private double XBs=;
    public QRs=(double Latitude_of_True_Scale, double Longitude_Down_from_Pole, double False_Easting, double False_Northing);
    private double XRs=(double EsSin);
    public bool Xhs=(double Latitude_of_True_Scale, double Longitude_Down_from_Pole, double False_Easting, double False_Northing);
    internal long Xxs=(double a, double f, double Latitude_of_True_Scale, double Longitude_Down_from_Pole, double False_Easting, double False_Northing);
    internal long YBs=(double a, double f, double Latitude_of_True_Scale, double Longitude_Down_from_Pole, double False_Easting, double False_Northing);
    public void YRs=(Double& Latitude_of_True_Scale, Double& Longitude_Down_from_Pole, Double& False_Easting, Double& False_Northing);
    internal void Yhs=(Double& a, Double& f, Double& Latitude_of_True_Scale, Double& Longitude_Down_from_Pole, Double& False_Easting, Double& False_Northing);
    public bool Yxs=(double Latitude, double Longitude, Double& Easting, Double& Northing);
    internal long ZBs=(double Latitude, double Longitude, Double& Easting, Double& Northing);
    public bool ZRs=(double Easting, double Northing, Double& Latitude, Double& Longitude);
    internal long Zhs=(double Easting, double Northing, Double& Latitude, Double& Longitude);
}
internal class 8RQ=.qSk= : lSk= {
    public virtual int bSk=(fCk= poObjBlock);
    public virtual int bik=(fCk= poObjBlock);
}
internal class 8RQ=.qSQ= : object {
    public static int qiQ=;
    public static int qyQ=;
    public static int rCQ=;
    public static int rSQ=;
    public static double IRY=;
    public static cCg= riQ=;
    public static xSc= ryQ=;
    public static yyk= sCQ=;
    public static rio= sSQ=;
    public static int siQ=;
    public static int syQ=;
    public static int tCQ=;
    public static int tSQ=;
    public static int tiQ=;
    public static int tyQ=;
    public static int uCQ=;
    public static int uSQ=;
    public static int uiQ=;
    public static int uyQ=;
    public static int vCQ=;
    public static int vSQ=;
    public static int viQ=;
    public static int vyQ=;
    public static int wCQ=;
    public static int wSQ=;
    public static int wiQ=;
    public static int wyQ=;
    public static int xCQ=;
    public static int xSQ=;
    public static int xiQ=;
    public static int xyQ=;
    public static int yCQ=;
    public static int ySQ=;
    public static int yiQ=;
    public static int yyQ=;
    public static int zCQ=;
    public static int zSQ=;
    public static int ziQ=;
    public static int zyQ=;
    public static int 0CQ=;
    public static int 0SQ=;
    public static int 0iQ=;
    public static int 0yQ=;
    public static int 1CQ=;
    public static int 1SQ=;
    public static int 1iQ=;
    public static int 1yQ=;
    public static int 2CQ=;
    public static int 2SQ=;
    public static int 2iQ=;
    public static int 2yQ=;
    public static int 3CQ=;
    public static int 3SQ=;
    public static int 3iQ=;
    public static int 3yQ=;
    public static int 4CQ=;
    public static int 4SQ=;
    public static int 4iQ=;
    public static int 4yQ=;
    public static int 5CQ=;
    public static int 5SQ=;
    public static int 5iQ=;
    public static int 5yQ=;
    public static int 6CQ=;
    public static int 6SQ=;
    public static int 6iQ=;
    public static int 6yQ=;
    public static int 7CQ=;
    public static int 7SQ=;
    public static int 7iQ=;
    public static int 7yQ=;
    public static int 8CQ=;
    public static int 8SQ=;
    public static int 8iQ=;
    public static int 8yQ=;
    public static int 9CQ=;
    public static int 9SQ=;
    public static int 9iQ=;
    public static int 9yQ=;
    public static int /CQ=;
    public static int /SQ=;
    public static int /iQ=;
    public static int /yQ=;
    public static int ACU=;
    public static int ASU=;
    public static int AiU=;
    public static int AyU=;
    public static int BCU=;
    public static int BSU=;
    public static int BiU=;
    public static int ByU=;
    public static int CCU=;
    public static int CSU=;
    public static int CiU=;
    public static int CyU=;
    public static int DCU=;
    public static int DSU=;
    public Byte[] DiU=;
    public static double DyU=;
    private static qSQ=();
}
internal static class 8RQ=.qSs= : object {
    public static Byte[] qis=(Byte[] bytes);
    public static Byte[] qys=(Byte[] bytes);
    internal static Byte[] rCs=(Uri styleJsonUri);
    internal static Collection`1<Feature> rSs=(Collection`1<VectorTile> vectorTiles, List`1<string> pbfLayerNames);
    private static Byte[] ris=(Uri styleJsonUri, Int32& count);
    private static lys=[] rys=(lys=[] points, int simplificationFactor);
    internal static double sCs=(ZoomLevelSet zoomLevelSet, int zoomLevel);
    internal static RectangleShape sSs=(long tileX, long tileY, int zoomLevel, int tileSize);
    internal static lys= sis=(double pointX, double pointY, int zoomLevel, int tileSize, RectangleShape tileBoundingBox);
    internal static List`1<string> sys=(Collection`1<string> sourceString, int startIndex, int count);
    private static void tCs=(lys=[] input, mCs= tileScreenBoundingBox, List`1<int> clippedPoints, List`1<int> parts);
    private static List`1<lys=> tSs=(lys=[] inputPoints, mCs= tileScreenBoundingBox);
    private static void tis=(lys=[] points, int firstPoint, int lastPoint, double tolerance, List`1<int> pointIndexsToKeep);
    private static double tys=(lys=& a, lys=& b, lys=& c);
    private static double uCs=(lys=& a, lys=& b, lys=& c);
    private static double uSs=(lys=& a, lys=& b);
    private static double uis=(lys=& a, lys=& b, lys=& c);
    private static lys=[] uys=(lys=[] inputPoints, double tolerance);
    private static bool vCs=(IList`1<lys=> points, int numPoints);
    private static Tz0= vSs=(double x, double y, mCs=& tileScreenBoundingBox);
    private static bool vis=(Double& x0, Double& y0, Double& x1, Double& y1, mCs=& tileScreenBoundingBox, UT0=& clipState);
}
internal class 8RQ=.QSw= : object {
    private int Qiw=;
    private byte Qyw=;
    [CompilerGeneratedAttribute]
private List`1<byte> RCw=;
    public List`1<byte> Ryw= { get; private set; }
    [CompilerGeneratedAttribute]
private void Riw=(List`1<byte> value);
    [CompilerGeneratedAttribute]
public List`1<byte> RSw=();
    public void SCw=(int input);
    public void SSw=();
}
internal class 8RQ=.qxk= : Txo= {
    internal double rBk=;
    internal double KRk=;
    internal double rRk=;
    internal double thg=;
    internal double rhk=;
    internal double txg=;
    internal double rxk=;
    internal double sBk=;
    internal double sRk=;
    internal double shk=;
    internal double oBk=;
    internal double oRk=;
    internal double sxk=;
    internal double tBk=;
    internal double tRk=;
    internal int uRg=;
    internal int SRk=;
    internal qxk=(string id, string desc);
    private void uhg=();
    internal virtual hRg= uxg=(hRg= pjConsts, Int32& pj_Error);
    internal virtual void whg=(XRg= lp, hRg= pjConsts, EBg= fac, Int32& pj_Error);
    internal virtual XRg= wBg=(XBo= xy, hRg= pjConsts, Int32& pj_Error);
    internal virtual XBo= wRg=(XRg= lp, hRg= pjConsts, Int32& pj_Error);
}
internal class 8RQ=.qyE= : ValueType {
    private double rCE=;
    private double rSE=;
    private double riE=;
    private double ryE=;
    public double siE= { get; public set; }
    public double tSE= { get; public set; }
    public double uCE= { get; public set; }
    public double uyE= { get; public set; }
    public qyE=(double maxLat, double minLat, double maxLong, double minLong);
    public double sCE=();
    public void sSE=(double value);
    public double syE=();
    public void tCE=(double value);
    public double tiE=();
    public void tyE=(double value);
    public double uSE=();
    public void uiE=(double value);
}
internal static class 8RQ=.QyQ= : object {
    public static kiQ= RCQ=;
    public static bool RSQ=;
    public static Stream RiQ=;
    public static StackTrace RyQ=;
    public static StackFrame SCQ=;
    private static QyQ=();
    public static void SSQ=(LiQ= eErrClass, int nError, string pszErrorMsg);
    public static void SiQ=(LiQ= eErrClass, int nError, string pszErrorMsg);
    public static kiQ= SyQ=(kiQ= pfnErrorHandlerNew);
    public static void TCQ=(kiQ= pfnErrorHandlerNew);
    public static void TSQ=();
    public static ViQ= TiQ=();
    public static void TyQ=(LiQ= eErrClass, int err_no, string fmt, Object[] valist);
    private static void UCQ=(LiQ= eErrClass, int err_no, string fmt, Object[] valist);
    public static void USQ=(string pszCategory, string pszFormat, Object[] list);
    public static void UiQ=();
    public static int UyQ=();
    public static LiQ= VCQ=();
    public static void VSQ=(string pszExpression, string pszFile, int iLine);
}
internal class 8RQ=.qyY= : object {
    public double rCY=;
    public double rSY=;
    public double riY=;
    public double ryY=;
}
internal class 8RQ=.RBo= : object {
    internal string RRo=;
    internal string Rho=;
    internal string Rxo=;
    internal long SBo=;
    internal GBc= SRo=;
    internal List`1<RBo=> Sho=;
}
internal class 8RQ=.rC0= : object {
    [CompilerGeneratedAttribute]
private int 0Bs=;
    [CompilerGeneratedAttribute]
private int 0Rs=;
    public int kCI= { get; private set; }
    public int kyI= { get; private set; }
    public rC0=(int inputX, int inputY);
    [CompilerGeneratedAttribute]
private void jyI=(int value);
    [CompilerGeneratedAttribute]
public int jiI=();
    [CompilerGeneratedAttribute]
private void kiI=(int value);
    [CompilerGeneratedAttribute]
public int kSI=();
    public int rS0=();
    public int ri0=();
}
internal class 8RQ=.RCc= : object {
    public static string tRU=;
    public static string vxU=;
    public static string thU=;
    public static string uBU=;
    public static string vBU=;
    public static string vhU=;
    public static string yhU=;
    public static string 6BU=;
    public static string zxU=;
    public static string whU=;
    public static string 6xU=;
    public static string yxU=;
    public static string 0hU=;
    public static string 5RU=;
    public static string 5hU=;
    public static string 2BU=;
    public static string 5xU=;
    public static string zRU=;
    public static string zBU=;
    public static string 4RU=;
    public static string BhY=;
    public static string 0RU=;
    public static string 2RU=;
    public static string 2hU=;
    public static string 2xU=;
    public static string 3BU=;
    public static string xhU=;
    public static string 3hU=;
    public static string wBU=;
    public static string wRU=;
    public static string yRU=;
    public static string yBU=;
    public static string 8xU=;
    public static string xxU=;
    public static string 1hU=;
    public static string 1xU=;
    public static string xBU=;
    public static string xRU=;
    public static string 1RU=;
    public static string CxY=;
    public static string DBY=;
    public static string DRY=;
    public static string DhY=;
    public static string DxY=;
    public static string EBY=;
    public static string ERY=;
    public static string EhY=;
    public static string ExY=;
    public static string FBY=;
    public static string FRY=;
    public static string FhY=;
    public static string FxY=;
    public static string GBY=;
    public static string 1BU=;
    public static string 0xU=;
    private static RCc=();
}
internal class 8RQ=.Rh8= : UB8= {
    public Rh8=(TB8= page);
    internal virtual int Rx8=(ArrayList& al);
    internal virtual int Rx8=(ArrayList& al, double resolution, int simplifyPixelBufferSize, Collection`1<RectangleShape> smallBoxes);
    internal virtual int Xx4=(nR8= rt, ArrayList& al);
    internal virtual int SB8=(nR8= rt, ArrayList& al);
    internal virtual int SR8=(nR8= rt, ArrayList& al);
    internal virtual int SR8=(nR8= rt, ArrayList& al, double resolution, int simplifyPixelBufferSize, Collection`1<RectangleShape> smallBoxes);
    internal virtual bool HB8=(gx8= rec, UB8=[]& nodeList);
    internal virtual bool Dh8=(gx8= insertRec, UB8=[]& nodeList);
    internal virtual bool Sh8=(gx8= delRec, Int32& idx, Rh8=& leafToDel);
    internal virtual void Sx8=(gx8= delRec, Collection`1<LeafRecordWrapper> leaves, IdsEngine idsEngine);
}
internal class 8RQ=.Ri0= : object {
    [CompilerGeneratedAttribute]
private string Ry0=;
    [CompilerGeneratedAttribute]
private StringBuilder SC0=;
    [CompilerGeneratedAttribute]
private ushort SS0=;
    [CompilerGeneratedAttribute]
private int Si0=;
    public string TS0= { get; private set; }
    public StringBuilder UC0= { get; private set; }
    public ushort Uy0= { get; private set; }
    public int Vi0= { get; private set; }
    [CompilerGeneratedAttribute]
private void TC0=(string value);
    [CompilerGeneratedAttribute]
public string Sy0=();
    [CompilerGeneratedAttribute]
private void Ty0=(StringBuilder value);
    [CompilerGeneratedAttribute]
public StringBuilder Ti0=();
    [CompilerGeneratedAttribute]
private void Ui0=(ushort value);
    [CompilerGeneratedAttribute]
public ushort US0=();
    [CompilerGeneratedAttribute]
public int VC0=();
    [CompilerGeneratedAttribute]
private void VS0=(int value);
    public void EC0=(StringBuilder name, string type);
    private StringBuilder Vy0=(StringBuilder Name);
}
internal class 8RQ=.Rig= : object {
    protected int Ryg=;
    protected yyk= SCg=;
    private static yyk= SSg=;
    public yyk= PyU= { get; public set; }
    public int QiU= { get; public set; }
    private static Rig=();
    public virtual int QyU=();
    public virtual yyk= RCU=();
    public virtual byte RSU=();
    public virtual double RiU=();
    public virtual int RyU=();
    public virtual string SiU=();
    public virtual byte SCU=();
    public virtual int SSU=();
    public virtual void SyU=(byte val);
    public virtual void TCU=(double val);
    public virtual void TSU=(int val);
    public virtual void TiU=(byte val);
    public virtual void TyU=(int clr);
    public virtual void UCU=(string pszStyleString);
    public virtual void USU=(Stream fpOut);
    public sealed virtual yyk= PSU=();
    public sealed virtual void PiU=(yyk= value);
    public sealed virtual int QCU=();
    public sealed virtual void QSU=(int value);
}
internal class 8RQ=.riI= : object {
    private GridCell ryI=;
    private GridCell sCI=;
    private GridCell sSI=;
    private GridCell siI=;
    public GridCell tSI= { get; public set; }
    public GridCell uCI= { get; public set; }
    public GridCell uyI= { get; public set; }
    public GridCell viI= { get; public set; }
    public riI=(GridCell leftBottom, GridCell bottomRight, GridCell rightTop, GridCell topLeft);
    public GridCell syI=();
    public void tCI=(GridCell value);
    public GridCell tiI=();
    public void tyI=(GridCell value);
    public GridCell uSI=();
    public void uiI=(GridCell value);
    public GridCell vCI=();
    public void vSI=(GridCell value);
    public xiI= vyI=();
}
internal class 8RQ=.rik= : lSk= {
    public int ryk=;
    public int sCk=;
    public byte pik=;
    public virtual int bSk=(fCk= poObjBlock);
    public virtual int bik=(fCk= poObjBlock);
}
internal class 8RQ=.rio= : object {
    public int ySY=;
    public short ryo=;
    public short sCo=;
    public byte sSo=;
    public int zyk=;
    public rio=(int nRefCount, short nSymbolNo, short nPointSize, byte _nUnknownValue_, int rgbColor);
}
internal class 8RQ=.RSc= : object {
    public string Ric=;
    public int Ryc=;
    public YiY= 6SY=;
    public RSc=(int inParam, string pszInput, int bGeo, YiY= ogrType);
}
internal class 8RQ=.rxg= : Txo= {
    internal double sBg=;
    internal double Rhc=;
    internal double sRg=;
    internal double shg=;
    internal double sxg=;
    internal double tBg=;
    internal double tRg=;
    internal double thg=;
    internal double txg=;
    internal Double[] uBg=;
    internal int uRg=;
    private double Khc=;
    internal rxg=(string id, string desc);
    private void uhg=();
    internal virtual hRg= uxg=(hRg= pjConsts, Int32& pj_Error);
    internal XBo= vBg=(XRg= lp, hRg= pjConsts);
    internal XRg= vRg=(XBo= xy, hRg= pjConsts);
    internal void vhg=(XRg= lp, hRg= pjConsts, EBg= factors);
    internal void vxg=(hRg= pjConsts);
    internal virtual XRg= wBg=(XBo= xy, hRg= pjConsts, Int32& pj_Error);
    internal virtual XBo= wRg=(XRg= lp, hRg= pjConsts, Int32& pj_Error);
    internal virtual void whg=(XRg= lp, hRg= pjConsts, EBg= fac, Int32& pj_Error);
    private double BBc=(double sinphi, double e, double one_es, Int32& pj_Error);
    private double wxg=(double qs, double Te, double Tone_es, Int32& pj_Error);
}
internal class 8RQ=.Rxg= : object {
    private Dictionary`2<string, QRo=> SBg=;
    private Dictionary`2<string, Pho=> SRg=;
    private Dictionary`2<string, TRo=> Shg=;
    private Dictionary`2<string, Sxo=> Sxg=;
    private Dictionary`2<string, string> TBg=;
    private int TRg=;
    private void Thg=();
    private void Txg=();
    private void UBg=();
    private void URg=();
    private void Uhg=();
    internal Txo= Uxg=(string args);
    internal int KBg=(Txo= srcdefn, Txo= dstdefn, long point_count, int point_offset, Uho=[] uvList, Double[] z);
    private void VBg=(nxg= datum, VRo= unitObj, Xhg= meridian, Txo= projObj, Dictionary`2<string, string> argList);
    private void VRg=(Pho= pjDatum, Dictionary`2<string, string> args, Txo= projObj);
    private void Vhg=(Txo= projObj, string projName);
    private void Vxg=(Stream stream, string keyField, Txo= projObj);
    private bool WBg=(string lineStr);
    private void WRg=(TRo= pjUnit, Dictionary`2<string, string> args, Txo= projObj);
    private double Whg=(Sxo= meri);
    private double Wxg=(string meriDefn, Int32& pj_Error);
}
internal class 8RQ=.ry0= : object {
    private mi4= sC0=;
    private List`1<pC4=> sS0=;
    private List`1<uS4=> si0=;
    private List`1<oC4=> sy0=;
    private 3y0= tC0=;
    private GC0= tS0=;
    private tyw= ti0=;
    private gy0= ty0=;
    private string uC0=;
    private string uS0=;
    private string ui0=;
    private string uy0=;
    private int vC0=;
    private li0= vS0=;
    private 2Cw= vi0=;
    private double iyw=;
    private TinyGeoFileType vy0=;
    public ry0=(li0= tGeoParameters, string tGeoFilePathName);
    public void wC0=();
    public void wS0=(int count);
    public void wi0=();
    public void wy0=(int count);
    public void xC0=();
}
internal class 8RQ=.Ry4= : object {
    private BinaryReader OCE=;
    private Si4= SC4=;
    private Stream GC4=;
    private Encoding rB4=;
    public Ry4=(Stream stream, Si4= header, Encoding encoding);
    public string SS4=(int offset, Xyw= encryptor);
}
internal enum 8RQ=.Ry8= : Enum {
    public int value__;
    public static Ry8= SC8=;
    public static Ry8= SS8=;
    public static Ry8= Si8=;
}
internal class 8RQ=.SCc= : object {
    public string SSc=;
    public double Sic=;
    public int Syc=;
    public int TCc=;
    public VCY= TSc=;
    public SCc=(string pszInput, double dValue, int eParam, int bGeo, VCY= ogrUnit);
}
internal class 8RQ=.sCY= : lyQ= {
    private long sSY=;
    private yCY= siY=;
    private 8yY= syY=;
    private List`1<1iY=> tCY=;
    protected string tSY=;
    protected string tiY=;
    public sCY=(yCY= poDefnIn);
    public yCY= tyY=();
    public OiY= uCY=(8yY= poGeomIn);
    public OiY= uSY=(8yY= poGeomIn);
    public 8yY= uiY=();
    public sCY= 4RY=();
    public int uyY=();
    public 5yY= vCY=(int iField);
    public int vSY=(string pszName);
    public bool viY=(int iField);
    public 1iY= vyY=(int i);
    public int wCY=(int iField);
    public double wSY=(int iField);
    public string wiY=(int iField);
    public string wiY=(string pszFName);
    public void wyY=(int iField, int nValue);
    public void wyY=(int iField, double dfValue);
    public void wyY=(int iField, string pszValue);
    public void wyY=(int iField, 1iY= puValue);
    public long xCY=();
    public virtual OiY= xSY=(long nFID);
    public virtual string xiY=();
    public virtual void xyY=(string pszString);
}
internal class 8RQ=.Shk= : Txo= {
    internal double Sxk=;
    internal double TBk=;
    internal double TRk=;
    internal double Thk=;
    internal double Txk=;
    internal double 8xg=;
    internal double shg=;
    internal double UBk=;
    internal Double[] 9Bg=;
    internal int zBg=;
    internal Shk=(string id, string desc);
    private void uhg=();
    internal virtual hRg= uxg=(hRg= pjConsts, Int32& pj_Error);
    internal virtual void whg=(XRg= lp, hRg= pjConsts, EBg= fac, Int32& pj_Error);
    internal virtual XRg= wBg=(XBo= xy, hRg= pjConsts, Int32& pj_Error);
    internal virtual XBo= wRg=(XRg= lp, hRg= pjConsts, Int32& pj_Error);
    private XBo= 0hg=(XRg= lp, hRg= pjConsts, Int32& pj_Error);
    private XBo= 0Bg=(XRg= lp, hRg= pjConsts, Int32& pj_Error);
    private XRg= zxg=(XBo= xy, hRg= pjConsts, Int32& pj_Error);
    private XRg= zRg=(XBo= xy, hRg= pjConsts, Int32& pj_Error);
}
internal class 8RQ=.shU= : object {
    internal static string sxU=;
    internal static string tBU=;
    internal static string tRU=;
    internal static string thU=;
    internal static string txU=;
    internal static string uBU=;
    internal static string uRU=;
    internal static string uhU=;
    internal static string uxU=;
    internal static string vBU=;
    internal static string vRU=;
    internal static string vhU=;
    internal static string vxU=;
    internal static string wBU=;
    internal static string wRU=;
    internal static string whU=;
    internal static string wxU=;
    internal static string xBU=;
    internal static string xRU=;
    internal static string xhU=;
    internal static string xxU=;
    internal static string yBU=;
    internal static string yRU=;
    internal static string yhU=;
    internal static string yxU=;
    internal static string zBU=;
    internal static string zRU=;
    internal static string zhU=;
    internal static string zxU=;
    internal static string 0BU=;
    internal static string 0RU=;
    internal static string 0hU=;
    internal static string 0xU=;
    internal static string 1BU=;
    internal static string 1RU=;
    internal static string 1hU=;
    internal static string 1xU=;
    internal static string 2BU=;
    internal static string 2RU=;
    internal static string 2hU=;
    internal static string 2xU=;
    internal static string 3BU=;
    internal static string 3RU=;
    internal static string 3hU=;
    internal static string 3xU=;
    internal static string 4BU=;
    internal static string 4RU=;
    internal static string 4hU=;
    internal static string 4xU=;
    internal static string 5BU=;
    internal static string 5RU=;
    internal static string 5hU=;
    internal static string 5xU=;
    internal static string 6BU=;
    internal static string 6RU=;
    internal static string 6hU=;
    internal static string 6xU=;
    internal static string 7BU=;
    internal static string 7RU=;
    internal static string 7hU=;
    internal static string 7xU=;
    internal static string 8BU=;
    internal static string 8RU=;
    internal static string 8hU=;
    internal static string 8xU=;
    internal static string 9BU=;
    internal static string 9RU=;
    internal static string 9hU=;
    internal static string 9xU=;
    internal static string /BU=;
    internal static string /RU=;
    internal static string /hU=;
    internal static string /xU=;
    internal static string ABY=;
    internal static string ARY=;
    internal static string AhY=;
    internal static string AxY=;
    internal static string BBY=;
    internal static string BRY=;
    internal static string BhY=;
    internal static string BxY=;
    internal static string CBY=;
    internal static string CRY=;
    internal static string ChY=;
    internal static string CxY=;
    internal static string DBY=;
    internal static string DRY=;
    internal static string DhY=;
    internal static string DxY=;
    internal static string EBY=;
    internal static string ERY=;
    internal static string EhY=;
    internal static string ExY=;
    internal static string FBY=;
    internal static string FRY=;
    internal static string FhY=;
    internal static string FxY=;
    internal static string GBY=;
    internal static string GRY=;
    internal static string GhY=;
    internal static string GxY=;
    internal static string HBY=;
    internal static string HRY=;
    internal static double HhY=;
    internal static double HxY=;
}
internal class 8RQ=.Si4= : object {
    private int Sy4=;
    private int TC4=;
    private int rBM=;
    public int 8Cw= { get; }
    public int ii0= { get; }
    public int jS0= { get; }
    public int 7iw=();
    public int iC0=();
    public int iy0=();
    public void ZRw=(Stream stream, int lblOffset, string password);
}
internal class 8RQ=.Sig= : object {
    protected int Syg=;
    protected rio= TCg=;
    private static rio= TSg=;
    public int VSU= { get; public set; }
    public rio= WCU= { get; public set; }
    private static Sig=();
    public virtual int WSU=();
    public virtual rio= WiU=();
    public virtual short WyU=();
    public virtual short XCU=();
    public virtual int XSU=();
    public virtual void XiU=(short val);
    public virtual void XyU=(short val);
    public virtual void YCU=(int clr);
    public virtual string YSU=(double dfAngle);
    public virtual void YiU=(string pszStyleString);
    public sealed virtual void YyU=(Stream fpOut);
    public virtual int UyU=();
    public virtual void VCU=(int value);
    public virtual rio= ViU=();
    public virtual void VyU=(rio= value);
}
internal enum 8RQ=.sio= : Enum {
    public int value__;
    public static sio= syo=;
    public static sio= tCo=;
    public static sio= tSo=;
}
internal class 8RQ=.Siw= : object {
    [CompilerGeneratedAttribute]
private int Syw=;
    [CompilerGeneratedAttribute]
private int TCw=;
    [CompilerGeneratedAttribute]
private byte YiM=;
    [CompilerGeneratedAttribute]
private List`1<TS4=> TSw=;
    public int UCw= { get; private set; }
    public int Uyw= { get; private set; }
    public byte Viw= { get; private set; }
    public List`1<TS4=> WSw= { get; public set; }
    public Siw=(byte type, int subFileIndex, int subdivisionIndex);
    [CompilerGeneratedAttribute]
private void Tyw=(int value);
    [CompilerGeneratedAttribute]
public int Tiw=();
    [CompilerGeneratedAttribute]
private void Uiw=(int value);
    [CompilerGeneratedAttribute]
public int USw=();
    [CompilerGeneratedAttribute]
private void VSw=(byte value);
    [CompilerGeneratedAttribute]
public byte VCw=();
    [CompilerGeneratedAttribute]
public void WCw=(List`1<TS4=> value);
    [CompilerGeneratedAttribute]
public List`1<TS4=> Vyw=();
}
internal static class 8RQ=.sjE= : object {
    public static Feature szE=(PointShape centerPoint, double resolutionX, double resolutionY, float halfRadius);
    public static Feature tDE=(PointShape centerPoint, double resolutionX, double resolutionY, float halfRadius);
    public static Feature tTE=(PointShape centerPoint, double resolutionX, double resolutionY, float halfRadius);
    public static Feature tjE=(PointShape centerPoint, double resolutionX, double resolutionY, float halfRadius);
    public static LineShape tzE=(PointShape centerPoint, double resolutionX, double radius);
    public static LineShape uDE=(PointShape centerPoint, double resolutionX, double radius);
    public static LineShape uTE=(PointShape centerPoint, double resolutionX, double radius);
    public static LineShape ujE=(PointShape centerPoint, double resolutionX, double radius);
    public static RectangleShape uzE=(PointShape centerPoint, double resolutionX, double resolutionY, double radius);
    public static RectangleShape vDE=(PointShape centerPoint, double resolutionX, double resolutionY, float radius);
    public static LineShape vTE=(RectangleShape bigRectangleShape);
    public static LineShape vjE=(RectangleShape bigRectangleShape);
    public static LineShape vzE=(RectangleShape bigRectangleShape, RectangleShape smallRectangleShape);
    public static LineShape wDE=(RectangleShape bigRectangleShape, RectangleShape smallRectangleShape);
    public static LineShape wTE=(PointShape centerPoint, double resolutionY, float radius, float halfRadius);
    public static LineShape wjE=(PointShape centerPoint, double resolutionY, float radius, float halfRadius);
    public static LineShape wzE=(PointShape centerPoint, double resolutionX, float radius, float halfRadius);
    public static LineShape xDE=(PointShape centerPoint, double resolutionX, float radius, float halfRadius);
    public static LineShape xTE=(RectangleShape bigRectangleShape, RectangleShape smallRectangleShape);
    public static LineShape xjE=(RectangleShape bigRectangleShape, RectangleShape smallRectangleShape);
    public static Feature xzE=(double resolutionX, double resolutionY, float radius, RectangleShape biggerRectangleShape);
    public static Feature yDE=(double resolutionX, double resolutionY, float radius, RectangleShape smallRectangleShape);
    public static Feature yTE=(double resolutionX, double resolutionY, float radius, RectangleShape smallRectangleShape);
    public static Feature yjE=(double resolutionX, double resolutionY, float radius, RectangleShape smallRectangleShape);
    public static Feature yzE=(PointShape topPoint, double resolutionX, double resolutionY, float radius);
    public static Feature zDE=(PointShape topPoint, double resolutionX, double resolutionY, float radius);
}
internal class 8RQ=.SSI= : object {
    private int SiI=;
    public wCI= SyI=(xiI= destRect, wCI= enterDirection, double enterValue);
    private static int TCI=(xiI= diffValueRect);
    private wCI= TSI=(xiI= destRect, double enterValue);
    private wCI= TiI=(xiI= destRect, double enterValue);
    private wCI= TyI=(xiI= destRect, double enterValue);
    private wCI= UCI=(xiI= destRect, double enterValue);
    private wCI= USI=(xiI= destRect, wCI= enterDirection, double enterValue);
    private wCI= UiI=(xiI= destRect, wCI= enterDirection, double enterValue);
    private wCI= UyI=(xiI= destRect, wCI= enterDirection, double enterValue);
    private wCI= VCI=(xiI= destRect, wCI= enterDirection, double enterValue);
    private wCI= VSI=(xiI= destRect, wCI= enterDirection, double enterValue);
    private static bool ViI=(wCI= enterDir, wCI= exitDir);
    private static wCI= VyI=(wCI= enterDirection);
}
internal class 8RQ=.sSk= : lSk= {
    public int sik=;
    public int syk=;
    public byte bCk=;
    public byte rCk=;
    public virtual int bSk=(fCk= poObjBlock);
    public virtual int bik=(fCk= poObjBlock);
}
internal class 8RQ=.SSk= : XSo= {
    protected int Sik=;
    protected ZCk=[] Syk=;
    protected int xyg=;
    protected int yCg=;
    protected int ySg=;
    protected int yig=;
    protected uic= pCg=;
    protected SSk= TCk=;
    protected int TSk=;
    protected SSk= Tik=;
    public SSk=(oSc= eAccessMode);
    protected int Tyk=(ZCk= psEntry);
    protected int UCk=(ZCk= psEntry);
    protected int USk=();
    public virtual int InitBlockFromData(Byte[] pabyBuf, int nBlockSize, int nSizeUsed, bool bMakeCopy, Stream fsSrc, int nOffset);
    public virtual int InitNewBlock(Stream fsSrc, int nBlockSize, int nFileOffset);
    public virtual int CommitToFile();
    public virtual int GetBlockClass();
    public int Uik=();
    public int uSg=();
    public ZCk= Uyk=(int iIndex);
    public int oCg=(int nXMin, int nYMin, int nXMax, int nYMax, int nBlockPtr, bool bAddInThisNodeOnly);
    public int VCk=();
    public void LCg=(Int32& nXMin, Int32& nYMin, Int32& nXMax, Int32& nYMax);
    public int uCg=();
    public void 0Sg=(uic= poBlockMgr);
    public void VSk=(SSk= poParent);
    public void Vik=(SSk= poChild, int nChildIndex);
    public int Vyk=();
    public SSk= WCk=();
    public int Dh8=(int nNewEntryXMin, int nNewEntryYMin, int nNewEntryXMax, int nNewEntryYMax);
    public int vCg=(int nNewEntryXMin, int nNewEntryYMin, int nNewEntryXMax, int nNewEntryYMax);
    public void WSk=(int nXMin, int nYMin, int nXMax, int nYMax, int nBlockPtr);
    public void Wik=();
    public int sig=(int nXMin, int nYMin, int nXMax, int nYMax, int nBlockPtr);
    public int Wyk=(int nXMin, int nYMin, int nXMax, int nYMax);
    private int XCk=(int paraA, int paraB);
    private int XSk=(int paraA, int paraB);
    public int Xik=(int nXMin, int nYMin, int nXMax, int nYMax);
    public int Xyk=(int nBlockPtr, int nXMin, int nYMin, int nXMax, int nYMax);
    public int YCk=(int nBlockPtr, Int32& nXMin, Int32& nYMin, Int32& nXMax, Int32& nYMax);
    private static double YSk=(int x1, int y1, int x2, int y2);
    public static double Yik=(int nNodeXMin, int nNodeYMin, int nNodeXMax, int nNodeYMax, int nEntryXMin, int nEntryYMin, int nEntryXMax, int nEntryYMax);
    public static int Yyk=(ZCk=[] pasEntries, int numEntries, int nSrcCurChildIndex, int nNewEntryXMin, int nNewEntryYMin, int nNewEntryXMax, int nNewEntryYMax, Int32& nSeed1, Int32& nSeed2);
    public sealed virtual void Dispose();
}
internal enum 8RQ=.SSs= : Enum {
    public int value__;
    public static SSs= Sis=;
}
internal class 8RQ=.Sxo= : object {
    internal string TBo=;
    internal Sxo=(string id, string defn);
}
internal enum 8RQ=.Sy8= : Enum {
    public int value__;
    public static Sy8= TC8=;
    public static Sy8= TS8=;
    public static Sy8= Ti8=;
    public static Sy8= Ty8=;
    public static Sy8= UC8=;
    public static Sy8= US8=;
    public static Sy8= Ui8=;
}
[DefaultMemberAttribute("Item")]
internal class 8RQ=.SyE= : object {
    private IDictionary`2<TKey, TValue> TCE=;
    public int Count { get; }
    public bool IsReadOnly { get; }
    public ICollection`1<TKey> Keys { get; }
    public ICollection`1<TValue> Values { get; }
    public TValue Item { get; public set; }
    public SyE=(IDictionary`2<TKey, TValue> underlyingDictionary);
    public sealed virtual int get_Count();
    public sealed virtual bool get_IsReadOnly();
    public sealed virtual ICollection`1<TKey> get_Keys();
    public sealed virtual ICollection`1<TValue> get_Values();
    public sealed virtual TValue get_Item(TKey key);
    public sealed virtual void set_Item(TKey key, TValue value);
    public sealed virtual void Add(TKey key, TValue value);
    public sealed virtual void Add(KeyValuePair`2<TKey, TValue> item);
    public sealed virtual void Clear();
    public sealed virtual bool ContainsKey(TKey key);
    public sealed virtual bool Remove(TKey key);
    public sealed virtual bool TryGetValue(TKey key, TValue& value);
    public sealed virtual bool Contains(KeyValuePair`2<TKey, TValue> item);
    public sealed virtual void CopyTo(KeyValuePair`2[] array, int arrayIndex);
    public sealed virtual bool Remove(KeyValuePair`2<TKey, TValue> item);
    public sealed virtual IEnumerator`1<KeyValuePair`2<TKey, TValue>> GetEnumerator();
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
}
internal enum 8RQ=.Sys= : Enum {
    public int value__;
    public static Sys= TCs=;
    public static Sys= TSs=;
    public static Sys= Tis=;
    public static Sys= Tys=;
    public static Sys= UCs=;
    public static Sys= USs=;
    public static Sys= Uis=;
}
internal class 8RQ=.TB8= : Ex8= {
    private static int TR8=;
    public TB8=(RtreeFile rtFile, UInt32 pageNo, Gist_Ext_Id extId);
    public TB8=(RtreeFile rtFile, Gist_Ext_Id extId);
    internal virtual gx8= EB8=();
    public virtual gx8= Kx8=(int idx);
    public virtual gx8= KB8=();
    public virtual gx8= KR8=();
    internal virtual bool HB8=(gx8= rec);
    private bool Th8=();
    internal bool Tx8=(gx8= rec);
    internal virtual void HR8=(int idx);
    internal virtual int ER8=();
    public virtual nR8= LR8=();
    public virtual string LB8=();
}
internal class 8RQ=.tCk= : nCk= {
    public short tSk=;
    public int lCk=;
    public short dCg=;
    public byte tik=;
    public byte tyk=;
    public byte uCk=;
    public byte uSk=;
    public byte uik=;
    public byte uyk=;
    public int vCk=;
    public int vSk=;
    public int vik=;
    public byte eyk=;
    public byte bCk=;
    public virtual int bSk=(fCk= poObjBlock);
    public virtual int bik=(fCk= poObjBlock);
}
internal class 8RQ=.thk= : Txo= {
    internal int 4Bg=;
    internal int 4Rg=;
    internal thk=(string id, string desc);
    private void uhg=();
    internal virtual hRg= uxg=(hRg= pjConsts, Int32& pj_Error);
    internal virtual void whg=(XRg= lp, hRg= pjConsts, EBg= fac, Int32& pj_Error);
    internal virtual XRg= wBg=(XBo= xy, hRg= pjConsts, Int32& pj_Error);
    internal virtual XBo= wRg=(XRg= lp, hRg= pjConsts, Int32& pj_Error);
}
internal class 8RQ=.Tic= : bCc= {
    public RSc=[] Tyc=;
    private SCc=[] UCc=;
    public virtual int ahU=();
    public string USc=(Int32& bDefault);
    public string Uic=(Int32& bDefault);
    public string Uyc=(Int32& bDefault);
    public string VCc=(cSY= eParam, Int32& bValueIsNull);
}
internal enum 8RQ=.Tig= : Enum {
    public int value__;
    public static Tig= Tyg=;
    public static Tig= UCg=;
    public static Tig= USg=;
    public static Tig= Uig=;
    public static Tig= Uyg=;
    public static Tig= VCg=;
    public static Tig= VSg=;
    public static Tig= Vig=;
    public static Tig= Vyg=;
    public static Tig= WCg=;
}
internal class 8RQ=.tio= : GSg= {
    protected Char[] tyo=;
    protected double cyg=;
    protected double uCo=;
    protected double uSo=;
    protected double uio=;
    protected double uyo=;
    protected bool vCo=;
    protected int vSo=;
    protected int vio=;
    protected short tSk=;
    protected short dCg=;
    private Qig= 2Sc=;
    private Rig= qCc=;
    private static cCg= RSg=;
    private static int hCQ=;
    private static int hSQ=;
    private static int hiQ=;
    private static int hyQ=;
    public yyk= PyU= { get; public set; }
    public int QiU= { get; public set; }
    public int MyU= { get; public set; }
    public cCg= NiU= { get; public set; }
    public tio=(yCY= poDefnIn);
    private static tio=();
    protected string vyo=();
    public virtual int rSc=(5yg= poMapFile);
    public virtual NCg= ric=();
    public virtual int ryc=(5yg= poMapFile);
    public virtual GSg= sCc=(yCY= poNewDefn);
    public virtual int sSc=(5yg= poMapFile, lSk= poObjHdr, bool bCoordBlockDataOnly, wig=& ppoCoordBlock);
    public virtual int sic=(5yg= poMapFile, lSk= poObjHdr, bool bCoordBlockDataOnly, wig=& ppoCoordBlock);
    public virtual int syc=(eyU= fp);
    public virtual int tCc=(eyU= fp);
    public virtual string xiY=();
    public virtual void tSc=(Stream fsOut);
    public Char[] wCo=();
    public double wSo=();
    public double wio=();
    public double wyo=();
    public int xCo=();
    public int xSo=();
    public void xio=(Double& dX, Double& dY);
    public 1yo= xyo=();
    public 3yo= yCo=();
    public 2yo= ySo=();
    public bool yio=(fig= eStyleToQuery);
    public void yyo=(Char[] pszNewStr);
    public void zCo=(double dAngle);
    public void zSo=(double dHeight);
    public void zio=(double dWidth);
    public void zyo=(int rgbColor);
    public void 0Co=(int rgbColor);
    public void 0So=(double dX, double dY);
    public void 0io=(1yo= eJustification);
    public void 0yo=(3yo= eSpacing);
    public void 1Co=(2yo= eLineType);
    public void 1So=(fig= eStyleToToggle, bool bStyleOn);
    public int eCg=();
    public void eSg=(int nStyle, bool bBGColorSet);
    public bool 1io=();
    public int eig=();
    public void eyg=(int nStyle);
    public virtual int QyU=();
    public virtual yyk= RCU=();
    public virtual byte RSU=();
    public virtual double RiU=();
    public virtual int RyU=();
    public virtual byte SCU=();
    public virtual int SSU=();
    public virtual string SiU=();
    public sealed virtual yyk= PSU=();
    public sealed virtual void PiU=(yyk= value);
    public virtual int QCU=();
    public virtual void QSU=(int value);
    public virtual void SyU=(byte val);
    public virtual void TCU=(double val);
    public virtual void TSU=(int val);
    public virtual void TiU=(byte val);
    public virtual void TyU=(int clr);
    public virtual void UCU=(string pszStyleString);
    public virtual void USU=(Stream fpOut);
    public virtual int MSU=();
    public virtual void MiU=(int value);
    public virtual cCg= NCU=();
    public virtual void NSU=(cCg= value);
    public virtual int NyU=();
    public virtual cCg= OCU=();
    public virtual string OSU=();
    public virtual void OiU=(string pszName);
    public virtual void OyU=(Stream fpOut);
}
internal class 8RQ=.tR0= : object {
    [ObfuscationAttribute]
private int baseUriIndex;
    private static int th0=;
    private static string mRQ=;
    private Timer mhQ=;
    [ObfuscationAttribute]
private Collection`1<Uri> baseUris;
    private bool tx0=;
    [CompilerGeneratedAttribute]
private string uB0=;
    [CompilerGeneratedAttribute]
private string uR0=;
    [CompilerGeneratedAttribute]
private double uh0=;
    [CompilerGeneratedAttribute]
private IWebProxy ux0=;
    [CompilerGeneratedAttribute]
private string vB0=;
    public Collection`1<Uri> vh0= { get; }
    public string wR0= { get; public set; }
    public string xB0= { get; public set; }
    public double xx0= { get; public set; }
    public IWebProxy yh0= { get; public set; }
    public string zR0= { get; public set; }
    public tR0=(string clientId, string clientSecret);
    [AsyncStateMachineAttribute("8RQ=.tR0=/<OpenAsync>d__8")]
public Task zh0=();
    public Collection`1<Uri> vR0=();
    [CompilerGeneratedAttribute]
public string vx0=();
    [CompilerGeneratedAttribute]
public void wB0=(string value);
    [CompilerGeneratedAttribute]
public string wh0=();
    [CompilerGeneratedAttribute]
public void wx0=(string value);
    [CompilerGeneratedAttribute]
public double xR0=();
    [CompilerGeneratedAttribute]
public void xh0=(double value);
    [CompilerGeneratedAttribute]
public IWebProxy yB0=();
    [CompilerGeneratedAttribute]
public void yR0=(IWebProxy value);
    [CompilerGeneratedAttribute]
public string yx0=();
    [CompilerGeneratedAttribute]
public void zB0=(string value);
    [AsyncStateMachineAttribute("8RQ=.tR0=/<CreateHttpRequestMessageAsync>d__31")]
public Task`1<HttpRequestMessage> zx0=(string apiPath, HttpMethod method);
    private HttpRequestMessage 0B0=(string apiPath, StringContent content);
    [AsyncStateMachineAttribute("8RQ=.tR0=/<GetTokenAsync>d__33")]
public Task`1<string> 0R0=();
    public virtual void kh0=();
    private string 0h0=();
    [AsyncStateMachineAttribute("8RQ=.tR0=/<UpdateToken>d__36")]
private void 0x0=();
    [CompilerGeneratedAttribute]
private void <OpenAsync>b__8_0(object _);
}
internal class 8RQ=.TRo= : object {
    internal string Tho=;
    internal TRo=(string id, string to_meter, string name);
}
internal class 8RQ=.TRw= : object {
    private Dictionary`2<KeyValuePair`2<string, string>, IEnumerable`1<Feature>> Thw=;
    public Dictionary`2<KeyValuePair`2<string, string>, IEnumerable`1<Feature>> UBw= { get; }
    public TRw=(IEnumerable`1<Feature> features, string columnName);
    public Dictionary`2<KeyValuePair`2<string, string>, IEnumerable`1<Feature>> Txw=();
    public sealed virtual IEnumerator`1<Feature> GetEnumerator();
    [IteratorStateMachineAttribute("8RQ=.TRw=/<System-Collections-IEnumerable-GetEnumerator>d__5")]
private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
}
internal class 8RQ=.TS4= : object {
    private int Ti4=;
    private double Ty4=;
    private double UC4=;
    private double US4=;
    private double Ui4=;
    public int diw= { get; }
    public TS4=(int childIndex, double xMin, double yMin, double xMax, double yMax);
    public int dCw=();
    public bool Uy4=(RectangleShape range);
}
[DefaultMemberAttribute("Item")]
internal abstract class 8RQ=.TSE= : object {
    private static char TiE=;
    private IList`1<string> OSE=;
    public string Item { get; public set; }
    public IList`1<string> UCE= { get; }
    public bool IsReadOnly { get; }
    public int Count { get; }
    protected TSE=(bool readOnly, IEnumerable`1<string> values);
    internal TSE=(IList`1<string> values);
    public virtual string get_Item(int index);
    public virtual void set_Item(int index, string value);
    public IList`1<string> TyE=();
    public sealed virtual bool get_IsReadOnly();
    public sealed virtual int get_Count();
    public string EiE=(int index);
    public virtual void Clear();
    public sealed virtual bool Contains(string value);
    public sealed virtual int IndexOf(string value);
    public virtual void Add(string value);
    public virtual void Insert(int index, string value);
    public virtual bool Remove(string value);
    public virtual void RemoveAt(int index);
    public sealed virtual void CopyTo(String[] array, int arrayIndex);
    public sealed virtual bool Equals(TSE= other);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    public sealed virtual string ToString();
    private sealed virtual override IEnumerator`1<string> System.Collections.Generic.IEnumerable<System.String>.GetEnumerator();
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
}
internal class 8RQ=.txk= : Txo= {
    internal double xRg=;
    internal double xhg=;
    internal int zBg=;
    internal txk=(string id, string desc);
    private void uhg=();
    internal virtual hRg= uxg=(hRg= pjConsts, Int32& pj_Error);
    internal virtual void whg=(XRg= lp, hRg= pjConsts, EBg= fac, Int32& pj_Error);
    internal virtual XRg= wBg=(XBo= xy, hRg= pjConsts, Int32& pj_Error);
    internal virtual XBo= wRg=(XRg= lp, hRg= pjConsts, Int32& pj_Error);
}
internal abstract class 8RQ=.Txo= : object {
    internal hRg= UBo=;
    internal string VRQ=;
    internal string URo=;
    internal abstract virtual hRg= uxg=(hRg= pjConsts, Int32& pj_Error);
    internal abstract virtual XRg= wBg=(XBo= xy, hRg= pjConsts, Int32& pj_Error);
    internal abstract virtual XBo= wRg=(XRg= lp, hRg= pjConsts, Int32& pj_Error);
    internal abstract virtual void whg=(XRg= lp, hRg= pjConsts, EBg= fac, Int32& pj_Error);
}
[ExtensionAttribute]
internal static class 8RQ=.ty8= : object {
    [ExtensionAttribute]
internal static void QB8=(XmlReader reader);
}
internal class 8RQ=.tyU= : object {
    public static int uCU=;
    public static tyU= uSU=;
    private static tyU=();
    public int uiU=();
    public int uyU=();
    public ECU= vCU=(string pszFilename, Encoding encoding);
    public void vSU=(ECU= handle);
    public ECU= viU=(string filename, string mif_or_tab, string mif_projection, double north, double south, double east, double west, Encoding encoding);
    public int vyU=(ECU= dataset);
    public int wCU=(ECU= dataset, string field_name, Tig= field_type, int width, int precision, bool indexed, bool unique);
    public void wSU=(GSg= feature);
    public int wiU=(ECU= handle, int last_feature_id);
    public GSg= wyU=(ECU= handle, int feature_id);
    public bool xCU=(ECU= handle, GSg= feature);
    public GSg= xSU=(ECU= handle, int feature_type);
    public void xiU=(GSg= feature, int field_index, string field_value);
    public void xyU=(GSg= feature, int part, int vertex_count, Double[] x, Double[] y);
    public void yCU=(GSg= feature, double center_x, double center_y, double x_radius, double y_radius, double start_angle, double end_angle);
    public void ySU=(GSg= feature, String& text);
    public string yiU=(GSg= feature);
    public int yyU=(GSg= feature, String& text, int l);
    public void zCU=(GSg= feature, double angle, double height, double width, int fg_color, int bg_color, int justification, int spacing, int linetype);
    public void zSU=(GCo= projInfo, Int32& nProjId, Int32& nEllipsoidId, Int32& nUnitsId, Double[] adProjParams);
    public double ziU=(GSg= feature);
    public double zyU=(GSg= feature);
    public double 0CU=(GSg= feature);
    public int 0SU=(GSg= feature);
    public int 0iU=(GSg= feature);
    public int 0yU=(GSg= feature);
    public int 1CU=(GSg= feature);
    public int 1SU=(GSg= feature);
    public void 1iU=(GSg= feature, string fontname);
    public string 1yU=(GSg= feature);
    public void 2CU=(GSg= feature, int fg_color, int bg_color, int pattern, int transparent);
    public int 2SU=(GSg= feature);
    public int 2iU=(GSg= feature);
    public int 2yU=(GSg= feature);
    public int 3CU=(GSg= feature);
    public void 3SU=(GSg= feature, int width, int pattern, int color);
    public int 3iU=(GSg= feature);
    public int 3yU=(GSg= feature);
    public int 4CU=(GSg= feature);
    public void 4SU=(GSg= feature, int symbol_no, int symbol_size, int symbol_color);
    public int 4iU=(GSg= feature);
    public int 4yU=(GSg= feature);
    public int 5CU=(GSg= feature);
    public int 5SU=(GSg= feature);
    public double 5iU=(GSg= feature, int part, int vertex);
    public int 5yU=(ECU= handle);
    public int 6CU=(ECU= handle);
    public int 6SU=(ECU= handle, int field);
    public string 6iU=(ECU= handle, int field);
    public int 6yU=(ECU= handle, int field);
    public int 7CU=(ECU= handle, int field);
    public string 7SU=(ECU= dataset);
    public string 7iU=(ECU= dataset);
    public void 7yU=(GCo= projInfo, int nProjId, int nEllipsoidId, int nUnitsId, Double[] adProjParams);
    public void 8CU=(GCo= projInfo, Double& dDatumShiftX, Double& dDatumShiftY, Double& dDatumShiftZ, Double[]& adDatumParams);
    public void 8SU=(GCo= projInfo, double dDatumShiftX, double dDatumShiftY, double dDatumShiftZ, Double[] adDatumParams);
    public int 8iU=(GCo= projInfo, Int32& nAffineUnits, Double[]& adAffineParams);
    public void 8yU=(GCo= projInfo, int nAffineUnits, Double[] adAffineParams);
    public int 9CU=(ECU= dataset, String& coordsys, int length);
    public int 9SU=(ECU= dataset, String& coordsys, int length);
    public int 9iU=(string filename);
    public int 9yU=(GSg= feature, GSg= region, int make_copy);
    public int /CU=(GSg= feature, GSg= polyline, int make_copy);
    public int /SU=(GSg= feature, GSg= multipoint, int make_copy);
    public string /iU=(GSg= feature, int field);
    public bool /yU=(ECU= handle, int field);
    public bool ACY=(ECU= handle, int field);
    public int ASY=(GSg= feature, int field, String& value, int l);
    public double AiY=(GSg= feature, int field);
    public GCo= AyY=(ECU= dataset);
    public int BCY=(ECU= dataset, GCo= projinfo);
    public string BSY=(ECU= file, int columnNum, int recordNum);
}
internal class 8RQ=.tyw= : object {
    private double iyw=;
    private int gyw=;
    private int hSw=;
    public List`1<giw=> uCw=;
    [CompilerGeneratedAttribute]
private int uSw=;
    [CompilerGeneratedAttribute]
private int kyw=;
    [CompilerGeneratedAttribute]
private int uiw=;
    [CompilerGeneratedAttribute]
private Dictionary`2<int, List`1<int>> uyw=;
    public int viw= { get; private set; }
    public int rCw= { get; private set; }
    public int wSw= { get; public set; }
    public Dictionary`2<int, List`1<int>> xCw= { get; private set; }
    public tyw=(int nMax, int nMin, int accuray, double extentWidthLimitation);
    [CompilerGeneratedAttribute]
private void vSw=(int value);
    [CompilerGeneratedAttribute]
public int vCw=();
    [CompilerGeneratedAttribute]
private void qyw=(int value);
    [CompilerGeneratedAttribute]
public int qiw=();
    [CompilerGeneratedAttribute]
public void wCw=(int value);
    [CompilerGeneratedAttribute]
public int vyw=();
    [CompilerGeneratedAttribute]
private void wyw=(Dictionary`2<int, List`1<int>> value);
    [CompilerGeneratedAttribute]
public Dictionary`2<int, List`1<int>> wiw=();
    public void xSw=(int max);
    public void xiw=();
    public void xyw=();
    public int yCw=(giw= rNode);
    public void ySw=();
    public void GCI=(yyw= Info);
    public void GCI=(aiw= ceaterEntry);
    private int yiw=(aiw= DesEntry);
    private bool Zh8=(int OriginalNode, bool DoSplit);
}
internal class 8RQ=.UB8= : object {
    protected Ex8= UR8=;
    protected int Fh8=;
    internal UB8=(Ex8= page);
    internal static UB8= Uh8=(Ex8= dtPage);
    internal Gist_Ext_Id Ux8=();
    internal bool VB8=();
    public UB8= VR8=(int index);
    internal ushort Hx8=();
    internal void IB8=(ushort level);
    public UInt32 Vh8=();
    internal void IR8=(UInt32 pageNo);
    internal gx8= KB8=();
    internal gx8= KR8=();
    internal bool Kh8=();
    public int Ix8=();
    internal int Vx8=();
    internal nR8= LR8=();
    internal bool WB8=(nR8= rt);
    internal bool WR8=(nR8= rt);
    internal bool Wh8=(nR8= rt);
    internal virtual int Rx8=(ArrayList& al);
    internal virtual int Rx8=(ArrayList& al, double resolution, int simplifyPixelBufferSize, Collection`1<RectangleShape> smallBoxes);
    internal ArrayList Wx8=(xx8= p, UB8= nRoot, int nMax);
    private void Wx8=(UB8= node, xx8= p, double nearest, int nMax, ArrayList& nodeStack, ArrayList& candidateStack, ArrayList& resuLbStack);
    private static void XB8=(ArrayList& nodeStack, UB8= node, xx8= p);
    private static void XR8=(ArrayList& candidateStack, ArrayList& resuLbStack, int nMax, double nearest);
    private static void Xh8=(UB8= node, xx8= p, ArrayList& candidateStack);
    internal virtual int Xx4=(nR8= rt, ArrayList& al);
    internal virtual int SB8=(nR8= rt, ArrayList& al);
    internal virtual int SR8=(nR8= rt, ArrayList& al);
    internal virtual int SR8=(nR8= rt, ArrayList& al, double resolution, int simplifyPixelBufferSize, Collection`1<RectangleShape> smallBoxes);
    internal string LB8=();
    public gx8= Kx8=(int idx);
    public bool Xx8=();
    public bool YB8=();
    internal bool YR8=();
    internal ArrayList[] Yh8=(ArrayList rectList);
    internal static void Yx8=(nR8=[] rectArr, ArrayList& spRectList, ArrayList& leftRectList, ArrayList& rightRectList, nR8=& mbr1, nR8=& mbr2);
    internal static void ZB8=(ArrayList& spRectList, ArrayList& rectList);
    internal static Int32[] ZR8=(nR8=[] rtArr);
    internal static void Zh8=(UB8= n, int index, bool bSplitted);
    internal static bool Eh8=(UB8= n, Lx8= ent, int index);
    internal int Zx8=(nR8= rt);
    internal virtual bool HB8=(gx8= rec, UB8=[]& nodelist);
    internal bool aB8=(gx8= rec, UB8=[]& nodeList);
    internal bool aR8=(gx8= insertRec, UB8=[] nodeListIn, UB8=[]& nodeListOut);
    private UInt32 Lh8=();
    internal virtual bool Dh8=(gx8= rec, UB8=[]& nodeList);
    internal bool ah8=(UB8=[] a);
    internal void ax8=(UB8= node);
    internal bool bB8=(gx8= delRec);
    internal void bB8=(gx8= delRec, IEnumerable`1<string> ids, IdsEngine idsEngine);
    internal virtual bool Sh8=(gx8= rec, Int32& idx, Rh8=& leafToDel);
    internal virtual void Sx8=(gx8= rec, Collection`1<LeafRecordWrapper> leaves, IdsEngine idsEngine);
    private static void bR8=(gx8= rec, UB8= subNode, Collection`1<LeafRecordWrapper> leaves, IdsEngine idsEngine);
    private static void bh8=(gx8= rec, UB8= subNode, Collection`1<LeafRecordWrapper> leaves, IdsEngine idsEngine);
    private static bool bx8=(gx8= rec, Int32& idx, Rh8=& leafToDel, UB8= subNode);
    private static bool cB8=(gx8= rec, Int32& idx, Rh8=& leafToDel, UB8= subNode);
    internal void HR8=(int idx);
}
internal class 8RQ=.uBk= : Txo= {
    internal double Rhc=;
    internal double Dhk=;
    internal double Dxk=;
    internal double EBk=;
    internal double ERk=;
    internal double Ehk=;
    internal uBk=(string id, string desc);
    private void uhg=();
    internal virtual hRg= uxg=(hRg= pjConsts, Int32& pj_Error);
    internal virtual void whg=(XRg= lp, hRg= pjConsts, EBg= fac, Int32& pj_Error);
    internal virtual XRg= wBg=(XBo= xy, hRg= pjConsts, Int32& pj_Error);
    internal virtual XBo= wRg=(XRg= lp, hRg= pjConsts, Int32& pj_Error);
    private int Exk=(hRg= pjConsts, Double[] del, Int32& pj_Error);
}
internal class 8RQ=.Uho= : ValueType {
    internal double Uxo=;
    internal double VBo=;
}
internal class 8RQ=.uic= : object {
    protected int uyc=;
    protected int vCc=;
    protected wyc= vSc=;
    public int vic=();
    public void vyc=();
    public void wCc=(int nBlockPtr);
    public int wSc=();
    public int wic=();
}
internal class 8RQ=.UiM= : object {
    [CompilerGeneratedAttribute]
private string UyM=;
    [CompilerGeneratedAttribute]
private string VCM=;
    [CompilerGeneratedAttribute]
private string OSM=;
    [CompilerGeneratedAttribute]
private List`1<XyM=> VSM=;
    [CompilerGeneratedAttribute]
private XSM= ViM=;
    [CompilerGeneratedAttribute]
private string VyM=;
    [CompilerGeneratedAttribute]
private List`1<string> WCM=;
    [CompilerGeneratedAttribute]
private string WSM=;
    [CompilerGeneratedAttribute]
private string WiM=;
    [ObfuscationAttribute]
[JsonPropertyNameAttribute("id")]
public string Id { get; public set; }
    [JsonPropertyNameAttribute("title")]
[ObfuscationAttribute]
public string Title { get; public set; }
    [JsonPropertyNameAttribute("description")]
[ObfuscationAttribute]
public string Description { get; public set; }
    [JsonPropertyNameAttribute("links")]
[ObfuscationAttribute]
public List`1<XyM=> Links { get; public set; }
    [ObfuscationAttribute]
[JsonPropertyNameAttribute("extent")]
public XSM= Extent { get; public set; }
    [JsonPropertyNameAttribute("itemType")]
[ObfuscationAttribute]
public string ItemType { get; public set; }
    [ObfuscationAttribute]
[JsonPropertyNameAttribute("crs")]
public List`1<string> Crs { get; public set; }
    [JsonPropertyNameAttribute("storageCrs")]
[ObfuscationAttribute]
public string StorageCrs { get; public set; }
    [JsonPropertyNameAttribute("storageCRS")]
[ObfuscationAttribute]
public string DefaultCrs { get; public set; }
    public UiM=(string id, string title, string description, List`1<XyM=> links, XSM= extent, string itemType, List`1<string> crs, string storageCrs);
    [CompilerGeneratedAttribute]
public string get_Id();
    [CompilerGeneratedAttribute]
public void set_Id(string value);
    [CompilerGeneratedAttribute]
public string get_Title();
    [CompilerGeneratedAttribute]
public void set_Title(string value);
    [CompilerGeneratedAttribute]
public string get_Description();
    [CompilerGeneratedAttribute]
public void set_Description(string value);
    [CompilerGeneratedAttribute]
public List`1<XyM=> get_Links();
    [CompilerGeneratedAttribute]
public void set_Links(List`1<XyM=> value);
    [CompilerGeneratedAttribute]
public XSM= get_Extent();
    [CompilerGeneratedAttribute]
public void set_Extent(XSM= value);
    [CompilerGeneratedAttribute]
public string get_ItemType();
    [CompilerGeneratedAttribute]
public void set_ItemType(string value);
    [CompilerGeneratedAttribute]
public List`1<string> get_Crs();
    [CompilerGeneratedAttribute]
public void set_Crs(List`1<string> value);
    [CompilerGeneratedAttribute]
public string get_StorageCrs();
    [CompilerGeneratedAttribute]
public void set_StorageCrs(string value);
    [CompilerGeneratedAttribute]
public string get_DefaultCrs();
    [CompilerGeneratedAttribute]
public void set_DefaultCrs(string value);
}
internal interface 8RQ=.UiU= {
    public int VSU= { get; public set; }
    public rio= WCU= { get; public set; }
    public abstract virtual int UyU=();
    public abstract virtual void VCU=(int value);
    public abstract virtual rio= ViU=();
    public abstract virtual void VyU=(rio= value);
    public abstract virtual int WSU=();
    public abstract virtual rio= WiU=();
    public abstract virtual short WyU=();
    public abstract virtual short XCU=();
    public abstract virtual int XSU=();
    public abstract virtual void XiU=(short val);
    public abstract virtual void XyU=(short val);
    public abstract virtual void YCU=(int clr);
    public abstract virtual string YSU=(double dfAngle);
    public abstract virtual void YiU=(string pszStyleString);
    public abstract virtual void YyU=(Stream fpOut);
}
internal enum 8RQ=.UiY= : Enum {
    public int value__;
    public static UiY= UyY=;
}
internal class 8RQ=.uRk= : Txo= {
    private double uhk=;
    private Double[] uBg=;
    internal uRk=(string id, string desc);
    private void uhg=();
    internal virtual hRg= uxg=(hRg= pjConsts, Int32& pj_Error);
    internal virtual void whg=(XRg= lp, hRg= pjConsts, EBg= fac, Int32& pj_Error);
    internal virtual XRg= wBg=(XBo= xy, hRg= pjConsts, Int32& pj_Error);
    internal virtual XBo= wRg=(XRg= lp, hRg= pjConsts, Int32& pj_Error);
    private XBo= 0hg=(XRg= lp, hRg= pjConsts, Int32& pj_Error);
    private XBo= 0Bg=(XRg= lp, hRg= pjConsts, Int32& pj_Error);
    private XRg= zxg=(XBo= xy, hRg= pjConsts, Int32& pj_Error);
    private XRg= zRg=(XBo= xy, hRg= pjConsts, Int32& pj_Error);
}
internal class 8RQ=.URk= : Txo= {
    internal double Uhk=;
    internal double Uxk=;
    internal double 7Bg=;
    internal URk=(string id, string desc);
    private void uhg=();
    internal virtual hRg= uxg=(hRg= pjConsts, Int32& pj_Error);
    internal virtual void whg=(XRg= lp, hRg= pjConsts, EBg= fac, Int32& pj_Error);
    internal virtual XRg= wBg=(XBo= xy, hRg= pjConsts, Int32& pj_Error);
    internal virtual XBo= wRg=(XRg= lp, hRg= pjConsts, Int32& pj_Error);
}
internal class 8RQ=.uS4= : object {
    private HCw= my4=;
    private int rBM=;
    private int oi4=;
    public uS4=(string path);
    public void QB8=();
    public void oy4=();
    public void 2h4=(WC0= HeaderPrama, int count, byte accuray);
    public void ui4=(ai0= SubdivisionPrama);
    public void uy4=();
}
internal enum 8RQ=.USY= : Enum {
    public int value__;
    public static USY= wSQ=;
    public static USY= wiQ=;
    public static USY= wyQ=;
    public static USY= xCQ=;
    public static USY= xSQ=;
    public static USY= xiQ=;
    public static USY= xyQ=;
    public static USY= yCQ=;
    public static USY= ySQ=;
    public static USY= yiQ=;
    public static USY= yyQ=;
    public static USY= zCQ=;
}
internal class 8RQ=.uxk= : Txo= {
    internal double eRc=;
    internal double ehc=;
    internal double BBk=;
    internal double BRk=;
    internal uxk=(string id, string desc);
    private void uhg=();
    internal virtual hRg= uxg=(hRg= pjConsts, Int32& pj_Error);
    internal virtual void whg=(XRg= lp, hRg= pjConsts, EBg= fac, Int32& pj_Error);
    internal virtual XRg= wBg=(XBo= xy, hRg= pjConsts, Int32& pj_Error);
    internal virtual XBo= wRg=(XRg= lp, hRg= pjConsts, Int32& pj_Error);
}
internal enum 8RQ=.Uy8= : Enum {
    public int value__;
    public static Uy8= TC8=;
    public static Uy8= TS8=;
    public static Uy8= VC8=;
    public static Uy8= VS8=;
    public static Uy8= Vi8=;
}
internal enum 8RQ=.Uys= : Enum {
    public int value__;
    public static Uys= VCs=;
    public static Uys= VSs=;
    public static Uys= Vis=;
    public static Uys= Vys=;
    public static Uys= WCs=;
}
internal class 8RQ=.vBk= : Txo= {
    internal vBk=(string id, string desc);
    private void uhg=();
    internal virtual hRg= uxg=(hRg= pjConsts, Int32& pj_Error);
    internal virtual void whg=(XRg= lp, hRg= pjConsts, EBg= fac, Int32& pj_Error);
    internal virtual XRg= wBg=(XBo= xy, hRg= pjConsts, Int32& pj_Error);
    internal virtual XBo= wRg=(XRg= lp, hRg= pjConsts, Int32& pj_Error);
}
internal class 8RQ=.VBk= : Txo= {
    internal VBk=(string id, string desc);
    private void uhg=();
    internal virtual hRg= uxg=(hRg= pjConsts, Int32& pj_Error);
    internal virtual void whg=(XRg= lp, hRg= pjConsts, EBg= fac, Int32& pj_Error);
    internal virtual XRg= wBg=(XBo= xy, hRg= pjConsts, Int32& pj_Error);
    internal virtual XBo= wRg=(XRg= lp, hRg= pjConsts, Int32& pj_Error);
}
internal class 8RQ=.vBs= : object {
    internal static UInt32 vRs=;
    internal static UInt32 vhs=;
    internal static UInt32 vxs=;
    internal static UInt32 wBs=;
    internal static UInt32 wRs=;
    internal static UInt32 whs=;
    internal static UInt32 wxs=;
    internal static UInt32 xBs=;
    internal static UInt32 xRs=;
    internal static UInt32 xhs=;
    private static double IRY=;
    private static double xxs=;
    private static double gBs=;
    private static double Gxs=;
    private static double HBs=;
    private static double HRs=;
    private static double Hhs=;
    private double yBs=;
    private double yRs=;
    private long yhs=;
    public vBs=(long _override);
    public bool yxs=(long _override);
    internal long zBs=(double a, double f, long _override);
    internal void zRs=(Double& a, Double& f, Int64& _override);
    internal long zhs=(double Latitude, double Longitude, Int32& Zone, Char& Hemisphere, Double& Easting, Double& Northing);
    internal long zxs=(int Zone, char Hemisphere, double Easting, double Northing, Double& Latitude, Double& Longitude);
}
internal class 8RQ=.VC4= : object {
    private BinaryReader OCE=;
    private ki4= VS4=;
    private ai4= Vi4=;
    private Ry4= Vy4=;
    private double WS0=;
    public VC4=(Stream stream, ki4= trebody, ai4= header, Ry4= lblBody, double extentWidthLimitation);
    private List`1<Feature> WC4=(cS4= subdivision, IEnumerable`1<string> recordIndexes, Dictionary`2<string, int> returningColumns, Xyw= encryptor);
    private List`1<Feature> WC4=(cS4= subdivision, xS0= range, Dictionary`2<string, int> returningColumns, Xyw= encryptor);
    private Byte[] WS4=(1i0= point, int latitutde, int longitude);
    private Byte[] Wi4=(List`1<1i0=> points, int latitutde, int longitude);
    private Byte[] Wy4=(List`1<1i0=> points, int latitutde, int longitude);
    private void XC4=(List`1<1i0=> points, Int32& latitutde, Int32& longitude, Byte[] wkb, int startPosition);
    private static void XS4=(double latitutde, double longitude, Byte[] wkb, int startPosition, int i);
    private string Xi4=(int offset, Xyw= encryptor);
    public void Xy4=(int index, BinaryWriter bw, string password, 3Ss= encryptMode);
    private void YC4=(ci4= subDefine, int nextSubAbsSubOffset, BinaryWriter bw, string password, 3Ss= encryptMode);
    private void Xy4=(GCw= shapeType, int nextSubAbsSubOffset, int rgnEndOffset, BinaryWriter bw, string password, 3Ss= encryptMode);
    private void YS4=(BinaryWriter bw, Xyw= encryptor);
    private void Yi4=(BinaryWriter bw, Xyw= encryptor);
    private void Yy4=(BinaryWriter bw, Xyw= encryptor);
    private void ZC4=(BinaryWriter bw, Xyw= encryptor);
    private void ZS4=(BinaryWriter bw, Xyw= encryptor);
    private void Zi4=(BinaryWriter bw, Xyw= encryptor);
    private static Byte[] Hy4=(Byte[] inputBytes, Xyw= encryptor);
    private static Byte[] dhQ=(Byte[] inputBytes, Xyw= encryptor);
    private Byte[] yhM=(int bitstreamLength);
    public List`1<Feature> Zy4=(xS0= range, int subdivisionIndex, Dictionary`2<string, int> returningColumns, Xyw= encryptor);
    public List`1<Feature> Zy4=(IEnumerable`1<string> featureIds, Dictionary`2<string, int> returningColumns, Xyw= encryptor);
    private cS4= aC4=(ci4= subDefine, int nextSubAbsSubOffset, Xyw= encryptor);
    private void aC4=(GCw= shapeType, cS4= subdivision, int nextSubAbsSubOffset, int rgnEndOffset, byte shfitBits, Xyw= encryptor);
    private static void aS4=(byte bitstreamInfo, Byte[] bitstream, byte shiftbits, List`1<1i0=> points);
}
internal enum 8RQ=.VCY= : Enum {
    public int value__;
    public static VCY= VSY=;
    public static VCY= ViY=;
    public static VCY= VyY=;
    public static VCY= WCY=;
    public static VCY= WSY=;
    public static VCY= WiY=;
}
internal class 8RQ=.vDI= : object {
    private string FRQ=;
    private Exception vTI=;
    private bool vjI=;
    private ThinkGeoLicenseStatus FBQ=;
    private static int vzI=;
    private bool wDI=;
    private double wTI=;
    private int wjI=;
    [CompilerGeneratedAttribute]
private DateTime wzI=;
    [CompilerGeneratedAttribute]
private DateTime xDI=;
    public bool xjI= { get; }
    public string QBQ= { get; public set; }
    public Exception yTI= { get; public set; }
    public bool zDI= { get; public set; }
    internal ThinkGeoLicenseStatus PRQ= { get; internal set; }
    internal bool zjI= { get; }
    internal DateTime 0TI= { get; internal set; }
    private DateTime 1DI= { get; private set; }
    internal double 1zI= { get; internal set; }
    public bool xTI=();
    public string PhQ=();
    public void PxQ=(string value);
    public Exception xzI=();
    public void yDI=(Exception value);
    public bool yjI=();
    public void yzI=(bool value);
    internal ThinkGeoLicenseStatus OxQ=();
    internal void PBQ=(ThinkGeoLicenseStatus value);
    internal bool zTI=();
    [CompilerGeneratedAttribute]
internal DateTime zzI=();
    [CompilerGeneratedAttribute]
internal void 0DI=(DateTime value);
    [CompilerGeneratedAttribute]
private DateTime 0jI=();
    [CompilerGeneratedAttribute]
private void 0zI=(DateTime value);
    internal double 1TI=();
    internal void 1jI=(double value);
    private bool 2DI=();
}
internal class 8RQ=.vhk= : Txo= {
    internal double BBk=;
    internal vhk=(string id, string desc);
    private void uhg=();
    internal virtual hRg= uxg=(hRg= pjConsts, Int32& pj_Error);
    internal virtual void whg=(XRg= lp, hRg= pjConsts, EBg= fac, Int32& pj_Error);
    internal virtual XRg= wBg=(XBo= xy, hRg= pjConsts, Int32& pj_Error);
    internal virtual XBo= wRg=(XRg= lp, hRg= pjConsts, Int32& pj_Error);
}
internal class 8RQ=.Vhk= : Txo= {
    internal Vhk=(string id, string desc);
    private void uhg=();
    internal virtual void whg=(XRg= lp, hRg= pjConsts, EBg= fac, Int32& pj_Error);
    internal virtual hRg= uxg=(hRg= pjConsts, Int32& pj_Error);
    internal virtual XRg= wBg=(XBo= xy, hRg= pjConsts, Int32& pj_Error);
    internal virtual XBo= wRg=(XRg= lp, hRg= pjConsts, Int32& pj_Error);
}
internal class 8RQ=.Vhw= : BinaryReader {
    public Vhw=(Stream stream);
    public Vhw=(Stream input, Encoding encoding);
    public virtual short ReadInt16();
    public virtual ushort ReadUInt16();
    public virtual int ReadInt32();
    public virtual UInt32 ReadUInt32();
    public virtual long ReadInt64();
    public virtual ulong ReadUInt64();
    public virtual float ReadSingle();
    public virtual double ReadDouble();
}
internal class 8RQ=.ViQ= : object {
    public static int NCQ=;
    public int VyQ=;
    public LiQ= WCQ=;
    public WyQ= WSQ=;
    public StringBuilder WiQ=;
    private static ViQ=();
}
internal class 8RQ=.vRk= : Txo= {
    internal double BBk=;
    internal vRk=(string id, string desc);
    private void uhg=();
    internal virtual hRg= uxg=(hRg= pjConsts, Int32& pj_Error);
    internal virtual void whg=(XRg= lp, hRg= pjConsts, EBg= fac, Int32& pj_Error);
    internal virtual XRg= wBg=(XBo= xy, hRg= pjConsts, Int32& pj_Error);
    internal virtual XBo= wRg=(XRg= lp, hRg= pjConsts, Int32& pj_Error);
}
internal class 8RQ=.VRk= : Txo= {
    internal VRk=(string id, string desc);
    private void uhg=();
    internal virtual hRg= uxg=(hRg= pjConsts, Int32& pj_Error);
    internal virtual void whg=(XRg= lp, hRg= pjConsts, EBg= fac, Int32& pj_Error);
    internal virtual XRg= wBg=(XBo= xy, hRg= pjConsts, Int32& pj_Error);
    internal virtual XBo= wRg=(XRg= lp, hRg= pjConsts, Int32& pj_Error);
}
internal class 8RQ=.VRo= : object {
    internal TRo= Vho=;
    internal Dictionary`2<string, TRo=> Vxo=;
    internal TRo= WRo= { get; }
    internal VRo=(Dictionary`2<string, string> args, Dictionary`2<string, TRo=> pj_Units_List);
    private string Who=(Dictionary`2<string, string> args);
    private void Wxo=(string unitID);
    internal TRo= WBo=();
}
internal static class 8RQ=.vS8= : object {
    internal static GeoImage vi8=(int tileWidth, int tileHeight, RowColumnRange rowColumnRange, List`1<CloudRasterTileInfo> cloudTileInfos);
    internal static ValueTuple`2<GeoImage, RectangleShape> vi8=(int tileWidth, int tileHeight, RowColumnRange rowColumnRange, long widthInMatrix, double widthInWorld, Dictionary`2<ValueTuple`2<long, long>, CloudRasterTileInfo> cloudTileInfos, WrappingMode wrappingMode);
    private static void vy8=(int tileWidth, int tileHeight, RowColumnRange rowColumnRange, long widthInMatrix, double widthInWorld, Dictionary`2<ValueTuple`2<long, long>, CloudRasterTileInfo> cloudTileInfos, WrappingMode wrappingMode, long i, long j, GeoImage cloudImage, List`1<RectangleShape> boxes);
    [AsyncStateMachineAttribute("8RQ=.vS8=/<CacheProjectedTilesAsync>d__3")]
internal static Task wC8=(RasterTileCache projectedTileCache, GeoImage cloudImage, RectangleShape cloudImageExtent, TileMatrix canvasTileMatrix, int zoomIndex, CancellationToken cancellationToken);
    private static List`1<RasterTile> wS8=(GeoImage geoImage, RectangleShape imageExtent, TileMatrix tileMatrix, int zoomLevel);
}
internal class 8RQ=.VSc= : bCc= {
    public RSc=[] Vic=;
    private SCc=[] UCc=;
    public virtual int ahU=();
}
internal class 8RQ=.vxk= : Txo= {
    internal double eRc=;
    internal double ehc=;
    internal vxk=(string id, string desc);
    private void uhg=();
    internal virtual hRg= uxg=(hRg= pjConsts, Int32& pj_Error);
    internal virtual void whg=(XRg= lp, hRg= pjConsts, EBg= fac, Int32& pj_Error);
    internal virtual XRg= wBg=(XBo= xy, hRg= pjConsts, Int32& pj_Error);
    internal virtual XBo= wRg=(XRg= lp, hRg= pjConsts, Int32& pj_Error);
}
internal class 8RQ=.Vxk= : Txo= {
    internal Vxk=(string id, string desc);
    private void uhg=();
    internal virtual void whg=(XRg= lp, hRg= pjConsts, EBg= fac, Int32& pj_Error);
    internal virtual hRg= uxg=(hRg= pjConsts, Int32& pj_Error);
    internal virtual XRg= wBg=(XBo= xy, hRg= pjConsts, Int32& pj_Error);
    internal virtual XBo= wRg=(XRg= lp, hRg= pjConsts, Int32& pj_Error);
}
internal class 8RQ=.Vxw= : BinaryWriter {
    public Vxw=(Stream output);
    public Vxw=(Stream output, Encoding encoding);
    public virtual void Write(short value);
    public virtual void Write(ushort value);
    public virtual void Write(int value);
    public virtual void Write(UInt32 value);
    public virtual void Write(long value);
    public virtual void Write(ulong value);
    public virtual void Write(float value);
    public virtual void Write(double value);
}
internal enum 8RQ=.Vy8= : Enum {
    public int value__;
    public static Vy8= TC8=;
    public static Vy8= TS8=;
    public static Vy8= WC8=;
    public static Vy8= Ty8=;
    public static Vy8= UC8=;
    public static Vy8= US8=;
    public static Vy8= WS8=;
}
internal class 8RQ=.Vyc= : object {
    private Zyc= WCc=;
    private string WSc=;
    public Vyc=(Zyc= poDataSetStyleTable);
    public bool Wic=(string pszStyleString);
    public string Wyc=(string pszStyleName);
    public int XCc=(string pszStyleString);
    public bCc= XSc=(int hPartId, string pszStyleString);
    public bCc= Xic=(string pszStyleString);
}
internal class 8RQ=.vyk= : XSo= {
    public static int wCk=;
    public Encoding rB4=;
    protected int xCg=;
    protected int wSk=;
    protected int xig=;
    protected uic= pCg=;
    public vyk=(oSc= eAccessMode);
    public virtual int InitBlockFromData(Byte[] pabyBuf, int nBlockSize, int nSizeUsed, bool bMakeCopy, Stream fsSrc, int nOffset);
    public virtual int InitNewBlock(Stream fsSrc, int nBlockSize, int nFileOffset);
    public virtual int CommitToFile();
    public virtual int GetBlockClass();
    public void 0Sg=(uic= poBlockManager);
    public virtual int ReadBytes(int numBytes, Byte[] pabyDstBuf);
    public virtual int WriteBytes(int nBytesToWrite, Byte[] pBuf);
    public void wik=(int nNextCoordBlockAddress);
    public bool wyk=();
    public int 2ig=();
    public int xCk=(int nToolType);
}
internal class 8RQ=.wBk= : Txo= {
    internal double BBk=;
    internal double BRk=;
    internal wBk=(string id, string desc);
    private void uhg=();
    internal virtual hRg= uxg=(hRg= pjConsts, Int32& pj_Error);
    internal virtual void whg=(XRg= lp, hRg= pjConsts, EBg= fac, Int32& pj_Error);
    internal virtual XRg= wBg=(XBo= xy, hRg= pjConsts, Int32& pj_Error);
    internal virtual XBo= wRg=(XRg= lp, hRg= pjConsts, Int32& pj_Error);
}
internal class 8RQ=.WBk= : Txo= {
    internal double thg=;
    internal double txg=;
    internal double Rhc=;
    internal double tRg=;
    internal double tBg=;
    internal double sRg=;
    internal int uRg=;
    internal WBk=(string id, string desc);
    private void uhg=();
    internal virtual hRg= uxg=(hRg= pjConsts, Int32& pj_Error);
    internal virtual void whg=(XRg= lp, hRg= pjConsts, EBg= fac, Int32& pj_Error);
    internal virtual XRg= wBg=(XBo= xy, hRg= pjConsts, Int32& pj_Error);
    internal virtual XBo= wRg=(XRg= lp, hRg= pjConsts, Int32& pj_Error);
}
internal static class 8RQ=.wBo= : object {
    private static Dictionary`2<string, Type> wRo=;
    private static string who=;
    private static 0xo= wxo=;
    public static string xBo=;
    public static string xRo=;
    public static string xho=;
    public static string xxo=;
    public static string yBo=;
    public static string yRo=;
    public static string yho=;
    public static Dictionary`2<string, Type> zBo= { get; }
    private static wBo=();
    public static Dictionary`2<string, Type> yxo=();
    public static string zRo=(object targetObject);
    public static object zho=(string geoJson);
    public static GeoJsonObject zxo=(object targetObject);
    private static object 0Bo=(GeoJsonObject geoJsonObject);
    private static PolygonShape 0Ro=(Collection`1<Collection`1<Double[]>> rings);
    private static RingShape 0ho=(Collection`1<Double[]> ring);
}
internal static class 8RQ=.WBw= : object {
    public static WkbShapeType WRw=(Byte[] wkb, int startIndex);
    internal static byte Whw=(WkbByteOrder byteOrder);
    internal static WkbByteOrder Wxw=(byte content);
    internal static WellKnownType XBw=(Byte[] wkb);
    internal static RectangleShape XRw=(Byte[] wkb);
    private static RectangleShape Xhw=(Byte[] wkb);
    private static RectangleShape Xxw=(Byte[] wkb);
    private static RectangleShape YBw=(Byte[] wkb);
    private static RectangleShape YRw=(Byte[] wkb);
    private static RectangleShape Yhw=(Byte[] wkb);
    private static RectangleShape Yxw=(Byte[] wkb);
}
internal class 8RQ=.WC0= : object {
    private double WS0=;
    [CompilerGeneratedAttribute]
private int Wi0=;
    [CompilerGeneratedAttribute]
private int Wy0=;
    [CompilerGeneratedAttribute]
private int XC0=;
    [CompilerGeneratedAttribute]
private int XS0=;
    public int YC0= { get; private set; }
    public int Yy0= { get; private set; }
    public int Zi0= { get; private set; }
    public int aS0= { get; private set; }
    public WC0=(double extentWidthLimitation);
    [CompilerGeneratedAttribute]
private void Xy0=(int value);
    [CompilerGeneratedAttribute]
public int Xi0=();
    [CompilerGeneratedAttribute]
private void Yi0=(int value);
    [CompilerGeneratedAttribute]
public int YS0=();
    [CompilerGeneratedAttribute]
private void ZS0=(int value);
    [CompilerGeneratedAttribute]
public int ZC0=();
    [CompilerGeneratedAttribute]
private void aC0=(int value);
    [CompilerGeneratedAttribute]
public int Zy0=();
    public void EC0=(RectangleShape Frontier);
}
internal enum 8RQ=.wCI= : Enum {
    public int value__;
    public static wCI= wSI=;
    public static wCI= wiI=;
    public static wCI= wyI=;
    public static wCI= xCI=;
    public static wCI= xSI=;
}
internal class 8RQ=.WCI= : object {
    private static double WSI=;
    public Boolean[0...,0...] WiI=;
    public Boolean[0...,0...] WyI=;
    public Boolean[0...,0...] XCI=;
    public Boolean[0...,0...] XSI=;
    private GridCell[0...,0...] XiI=;
    [CompilerGeneratedAttribute]
private int XyI=;
    [CompilerGeneratedAttribute]
private int YCI=;
    [CompilerGeneratedAttribute]
private bool YSI=;
    public int ZCI= { get; private set; }
    public int ZyI= { get; private set; }
    public bool aiI= { get; private set; }
    public WCI=(GridCell[0...,0...] grid, double noDataValue);
    [CompilerGeneratedAttribute]
public int YiI=();
    [CompilerGeneratedAttribute]
private void YyI=(int value);
    [CompilerGeneratedAttribute]
public int ZSI=();
    [CompilerGeneratedAttribute]
private void ZiI=(int value);
    [CompilerGeneratedAttribute]
public bool aCI=();
    [CompilerGeneratedAttribute]
private void aSI=(bool value);
    public void ayI=(int lowwerColumnIndex, int upperColumnIndex, int rowIndex);
    public void bCI=(int lowwerRowIndex, int upperRowIndex, int ColumnIndex);
    public bool bSI=(int lowwerColumnIndex, int upperColumnIndex, int rowIndex, double isoValue, wCI= enterDirection);
    public bool biI=(int lowwerRowIndex, int upperRowIndex, int ColumnIndex, double isoValue, wCI= enterDirection);
    public bool byI=(int lowwerColumnIndex, int upperColumnIndex, int rowIndex, double isoValue, wCI= enterDirection);
    public bool cCI=(int lowwerRowIndex, int upperRowIndex, int ColumnIndex, double isoValue, wCI= enterDirection);
    public bool cSI=(int lowwerColumnIndex, int upperColumnIndex, int rowIndex);
    public bool ciI=(int lowwerRowIndex, int upperRowIndex, int ColumnIndex);
    public GridCell cyI=(double isoValue, jSI= enterIndex1, jSI= enterIndex2, GridCell previousCell);
    public GridCell cyI=(double isoValue, int pointIndexX1, int pointIndexY1, int pointIndexX2, int pointIndexY2);
    public GridCell dCI=(int rowIndex, int columnIndex);
    public lCI= dSI=(int leftTopIndexX, int leftTopIndexY);
    private void diI=(GridCell[0...,0...] grid);
    private void diI=(GridCell[0...,0...] grid, double noDataValue);
    private bool dyI=(int lowwerColumnIndex, int upperColumnIndex, int rowIndex);
    private bool eCI=(int lowwerRowIndex, int upperRowIndex, int ColumnIndex);
    private bool eSI=(int lowwerColumnIndex, int upperColumnIndex, int rowIndex);
    private bool eiI=(int lowwerRowIndex, int upperRowIndex, int ColumnIndex);
    private bool eyI=(int lowwerColumnIndex, int upperColumnIndex, int rowIndex, wCI= enterDirection);
    private bool fCI=(int lowwerRowIndex, int upperRowIndex, int ColumnIndex, wCI= enterDirection);
    private void fSI=(int lowwerColumnIndex, int upperColumnIndex, int rowIndex);
    private void fiI=(int lowwerRowIndex, int upperRowIndex, int ColumnIndex);
    private void fyI=(int lowwerColumnIndex, int upperColumnIndex, int rowIndex);
    private void gCI=(int lowwerRowIndex, int upperRowIndex, int ColumnIndex);
    private static bool gSI=(double isoValue1, double isoValue2, double destIsoValue);
}
internal class 8RQ=.whk= : Txo= {
    internal double eRc=;
    internal double ehc=;
    internal double BBk=;
    internal double BRk=;
    internal double 1xc=;
    internal whk=(string id, string desc);
    private void uhg=();
    internal virtual hRg= uxg=(hRg= pjConsts, Int32& pj_Error);
    internal virtual void whg=(XRg= lp, hRg= pjConsts, EBg= fac, Int32& pj_Error);
    internal virtual XRg= wBg=(XBo= xy, hRg= pjConsts, Int32& pj_Error);
    internal virtual XBo= wRg=(XRg= lp, hRg= pjConsts, Int32& pj_Error);
}
internal class 8RQ=.wi8= : object {
    public static string wy8=;
    public static string xC8=;
    public static string xS8=;
    public static string xi8=;
    public static string xy8=;
    public static string yC8=;
    public static string yS8=;
    public static string yi8=;
    public static string yy8=;
    public static string zC8=;
    public static string zS8=;
    public static string zi8=;
    public static string zy8=;
    public static string 0C8=;
    public static string 0S8=;
    public static string 0i8=;
    public static string 0y8=;
    public static string 1C8=;
    public static string 1S8=;
    public static string 1i8=;
    public static string 1y8=;
    public static string 2C8=;
    public static string 2S8=;
    public static string 2i8=;
    public static string 2y8=;
    public static string 3C8=;
    public static string 3S8=;
    public static string 3i8=;
    public static string 3y8=;
    public static string 4C8=;
    public static string 4S8=;
    public static string 4i8=;
    public static string 4y8=;
    public static string 5C8=;
    public static string 5S8=;
    public static string 5i8=;
    public static string 5y8=;
    public static string 6C8=;
    public static string 6S8=;
    public static string 6i8=;
    public static string 6y8=;
    public static string 7C8=;
    public static string 7S8=;
    public static string 7i8=;
    public static string 7y8=;
    public static string 8C8=;
    public static string 8S8=;
    public static string 8i8=;
    public static string 8y8=;
    public static string 9C8=;
    public static string 9S8=;
    public static string 9i8=;
    public static string 9y8=;
    public static string /C8=;
    public static string /S8=;
    public static string /i8=;
    public static string /y8=;
    public static string ADA=;
    public static string ATA=;
    public static string AjA=;
    public static string AzA=;
    public static string BDA=;
    public static string BTA=;
    public static string BjA=;
    public static string BzA=;
    public static string CDA=;
    public static string CTA=;
    public static string CjA=;
    public static string CzA=;
    public static string DDA=;
    public static string DTA=;
    public static string DjA=;
    public static string DzA=;
    public static string EDA=;
    public static string ETA=;
    public static string EjA=;
    public static string EzA=;
    public static string FDA=;
    public static string FTA=;
    public static string FjA=;
    public static string FzA=;
    public static string GDA=;
    public static string GTA=;
    public static string GjA=;
    public static string GzA=;
    public static string HDA=;
    public static string HTA=;
    public static string HjA=;
    public static string HzA=;
    public static string IDA=;
    public static string ITA=;
    public static string IjA=;
    public static string IzA=;
    public static string JDA=;
    public static string JTA=;
    public static string JjA=;
    public static string JzA=;
    public static string KDA=;
    public static string KTA=;
    public static string KjA=;
    public static string KzA=;
    public static string LDA=;
    public static string LTA=;
    public static string LjA=;
    public static string TCs=;
    public static string LzA=;
    public static string MDA=;
    public static string MTA=;
    public static string MjA=;
    public static string MzA=;
    public static string NDA=;
    public static string NTA=;
    public static string NjA=;
    public static string NzA=;
    public static string ODA=;
    public static string OTA=;
    public static string OjA=;
    public static string OzA=;
    public static string PDA=;
    public static string PTA=;
    public static string PjA=;
    public static string PzA=;
    public static string QDA=;
    public static string QTA=;
    public static string QjA=;
    public static string QzA=;
    public static string RDA=;
    public static string RTA=;
    public static string RjA=;
    public static string RzA=;
    public static string SDA=;
    public static string STA=;
    public static string SjA=;
    public static string SzA=;
    public static string TDA=;
    public static string TTA=;
    public static string TjA=;
    public static string TzA=;
    public static string UDA=;
    public static string UTA=;
    public static string UjA=;
    public static string UzA=;
    private static Assembly VDA=;
    public static string VjA= { get; }
    public static string WDA= { get; }
    public static string WjA= { get; }
    public static string XDA= { get; }
    public static string XjA= { get; }
    public static string YDA= { get; }
    public static Byte[] YjA= { get; }
    public static Byte[] ZDA= { get; }
    public static Byte[] ZjA= { get; }
    public static Byte[] aDA= { get; }
    public static Byte[] ajA= { get; }
    public static Byte[] bDA= { get; }
    public static Byte[] bjA= { get; }
    public static Byte[] cDA= { get; }
    public static Byte[] cjA= { get; }
    public static Byte[] dDA= { get; }
    public static Byte[] djA= { get; }
    public static Byte[] eDA= { get; }
    public static Byte[] ejA= { get; }
    public static Byte[] fDA= { get; }
    public static Byte[] fjA= { get; }
    public static Byte[] gDA= { get; }
    public static Byte[] gjA= { get; }
    public static Byte[] hDA= { get; }
    private static wi8=();
    public static string VTA=();
    public static string VzA=();
    public static string WTA=();
    public static string WzA=();
    public static string XTA=();
    public static string XzA=();
    public static Byte[] YTA=();
    public static Byte[] YzA=();
    public static Byte[] ZTA=();
    public static Byte[] ZzA=();
    public static Byte[] aTA=();
    public static Byte[] azA=();
    public static Byte[] bTA=();
    public static Byte[] bzA=();
    public static Byte[] cTA=();
    public static Byte[] czA=();
    public static Byte[] dTA=();
    public static Byte[] dzA=();
    public static Byte[] eTA=();
    public static Byte[] ezA=();
    public static Byte[] fTA=();
    public static Byte[] fzA=();
    public static Byte[] gTA=();
    public static Byte[] gzA=();
    public static Byte[] yhM=(string resourceName);
    public static string kys=(string resourceName);
    public static Byte[] hTA=(Stream stream);
}
internal enum 8RQ=.Wi8= : Enum {
    public int value__;
    public static Wi8= TC8=;
    public static Wi8= TS8=;
    public static Wi8= VC8=;
    public static Wi8= Wy8=;
    public static Wi8= Vi8=;
}
internal class 8RQ=.wig= : XSo= {
    private static int wyg=;
    protected int xCg=;
    protected int xSg=;
    protected int xig=;
    protected int Hyg=;
    protected int ICg=;
    protected int xyg=;
    protected int yCg=;
    protected int ySg=;
    protected int yig=;
    protected uic= pCg=;
    protected int yyg=;
    protected int zCg=;
    protected int zSg=;
    protected int zig=;
    protected int zyg=;
    protected int 0Cg=;
    public wig=(oSc= eAccessMode);
    public virtual int InitBlockFromData(Byte[] pabyBuf, int nBlockSize, int nSizeUsed, bool bMakeCopy, Stream fsSrc, int nOffset);
    public virtual int InitNewBlock(Stream fsSrc, int nBlockSize, int nFileOffset);
    public virtual int CommitToFile();
    public virtual int GetBlockClass();
    public void 0Sg=(uic= poBlockManager);
    public virtual int ReadBytes(int numBytes, Byte[] pabyDstBuf);
    public virtual int WriteBytes(int nBytesToWrite, Byte[] pabySrcBuf);
    public void 0ig=(int nX, int nY);
    public int 0yg=(bool bCompressed, Int32& nX, Int32& nY);
    public int 1Cg=(bool bCompressed, int numCoordPairs, Int32[] panXY);
    public int 1Sg=(bool bCompressed, int nVersion, int numSections, 3ig=[] pasHdrs, Int32& numVerticesTotal);
    public int 1ig=(int nVersion, int numSections, 3ig=[] pasHdrs, bool bCompressed);
    public void 1yg=(int nNextCoordBlockAddress);
    public int 2Cg=();
    public int 2Sg=(int nX, int nY, bool bCompressed);
    public int 2ig=();
    public void 2yg=();
    public void 3Cg=();
    public int 3Sg=();
}
internal static class 8RQ=.Wiw= : object {
    public static int Wyw=(double realValue, int accuracy, double extentWidthLimitation);
    public static short XCw=(double realValue, int accuracy, double extentWidthLimitation);
    public static ushort XSw=(double realValue, int accuracy, double extentWidthLimitation);
    public static int Xiw=(double realValue, int accuracy, double extentWidthLimitation);
}
internal class 8RQ=.wRk= : Txo= {
    internal double BBk=;
    internal double BRk=;
    internal wRk=(string id, string desc);
    private void uhg=();
    internal virtual hRg= uxg=(hRg= pjConsts, Int32& pj_Error);
    internal virtual void whg=(XRg= lp, hRg= pjConsts, EBg= fac, Int32& pj_Error);
    internal virtual XRg= wBg=(XBo= xy, hRg= pjConsts, Int32& pj_Error);
    internal virtual XBo= wRg=(XRg= lp, hRg= pjConsts, Int32& pj_Error);
}
internal class 8RQ=.WRk= : Txo= {
    internal Double[] uBg=;
    internal double Whk=;
    internal double Wxk=;
    internal double XBk=;
    internal double 1Bc=;
    internal WRk=(string id, string desc);
    private void uhg=();
    internal virtual hRg= uxg=(hRg= pjConsts, Int32& pj_Error);
    internal virtual void whg=(XRg= lp, hRg= pjConsts, EBg= fac, Int32& pj_Error);
    internal virtual XRg= wBg=(XBo= xy, hRg= pjConsts, Int32& pj_Error);
    internal virtual XBo= wRg=(XRg= lp, hRg= pjConsts, Int32& pj_Error);
    private static double XRk=(double S, double C);
    private static double Xhk=(double S, double C);
}
internal class 8RQ=.WSg= : ECU= {
    private string gSU=;
    private oSc= giU=;
    private List`1<string> Wig=;
    private int liU=;
    private Int32[] Wyg=;
    private sio= 6Cc=;
    private 5ic= XCg=;
    private 5yg= XSg=;
    private lCg= Xig=;
    private yCY= qiU=;
    private OSc= qyU=;
    private bool Xyg=;
    private int YCg=;
    [CompilerGeneratedAttribute]
private object YSg=;
    public object ZCg= { get; private set; }
    [CompilerGeneratedAttribute]
public object Yig=();
    [CompilerGeneratedAttribute]
private void Yyg=(object value);
    public virtual int Close();
    private int ZSg=(bool bTestOpenNoError);
    private int Zig=();
    private int Zyg=();
    public virtual aig= GetFileClass();
    public virtual int Open(string pszFname, FileAccess pszAccess, bool bTestOpenNoError);
    public string BSY=(int columnNum, int recordNum);
    public virtual int SetQuickSpatialIndexMode(bool bQuickSpatialIndexMode);
    public virtual string GetTableName();
    public virtual void ResetReading();
    public virtual bool TestCapability(string pszCap);
    public virtual int GetFeatureCount(bool bForce);
    public virtual OiY= GetExtent(qyY= psExtent, bool bForce);
    public virtual int GetNextFeatureId(int nPrevId);
    public virtual GSg= GetFeatureRef(int nFeatureId);
    public virtual yCY= GetLayerDefn();
    public virtual Tig= GetNativeFieldType(int nFieldId);
    public virtual int GetBounds(Double& dXMin, Double& dYMin, Double& dXMax, Double& dYMax, bool bForce);
    public virtual OSc= GetSpatialRef();
    public virtual int GetFeatureCountByType(Int32& numPoints, Int32& numLines, Int32& numRegions, Int32& numTexts, bool bForce);
    public virtual bool IsFieldIndexed(int nFieldId);
    public virtual bool IsFieldUnique(int nFieldId);
    public virtual int SetBounds(double dXMin, double dYMin, double dXMax, double dYMax);
    public virtual int SetFeatureDefn(yCY= poFeatureDefn, List`1<Tig=> paeMapInfoNativeFieldTypes);
    public virtual int AddFieldNative(string pszName, Tig= eMapInfoType, int nWidth, int nPrecision, bool bIndexed, bool bUnique);
    public virtual int SetSpatialRef(OSc= poSpatialRef);
    public virtual int SetFeature(GSg= poFeature, int nFeatureId);
    public virtual int SetFieldIndexed(int nFieldId);
    public virtual int GetProjInfo(GCo= poPI);
    public virtual int SetProjInfo(GCo= poPI);
    public virtual int SetMIFCoordSys(string pszMIFCoordSys);
    public int aCg=(int nFieldId);
    public lCg= aSg=();
    public void kh0=();
    private sealed virtual override void System.IDisposable.Dispose();
}
internal class 8RQ=.WSs= : object {
    private gCs= OCE=;
    [CompilerGeneratedAttribute]
private ulong UyM=;
    [CompilerGeneratedAttribute]
private WellKnownType Wis=;
    [CompilerGeneratedAttribute]
private Dictionary`2<string, string> Wys=;
    [CompilerGeneratedAttribute]
private List`1<UInt32> XCs=;
    [CompilerGeneratedAttribute]
private List`1<int> XSs=;
    public ulong XRQ= { get; public set; }
    public WellKnownType YCs= { get; public set; }
    public Dictionary`2<string, string> Yis= { get; }
    private List`1<UInt32> ZSs= { get; private set; }
    private List`1<int> aCs= { get; private set; }
    public WSs=(Byte[] data, List`1<string> keys, List`1<object> values);
    [CompilerGeneratedAttribute]
public ulong WxQ=();
    [CompilerGeneratedAttribute]
public void XBQ=(ulong value);
    [CompilerGeneratedAttribute]
public WellKnownType Xis=();
    [CompilerGeneratedAttribute]
public void Xys=(WellKnownType value);
    [CompilerGeneratedAttribute]
public Dictionary`2<string, string> YSs=();
    [CompilerGeneratedAttribute]
private List`1<UInt32> Yys=();
    [CompilerGeneratedAttribute]
private void ZCs=(List`1<UInt32> value);
    [CompilerGeneratedAttribute]
private List`1<int> Zis=();
    [CompilerGeneratedAttribute]
private void Zys=(List`1<int> value);
    private List`1<List`1<Vertex>> aSs=(float scale);
    public Feature ais=(RectangleShape vectorTileWorldExtent, ulong extent);
    private void ays=(List`1<string> keys, List`1<object> values);
    private void bCs=(List`1<string> keys, List`1<object> values);
    private Vertex bSs=(long x, long y);
    private List`1<List`1<Vertex>> bis=(List`1<List`1<Vertex>> geometries, RectangleShape vectorTileWorldExtent, ulong vectorTileRelativeExtent);
    private BaseShape bys=(List`1<List`1<Vertex>> geometries, WellKnownType shapeType);
    private BaseShape cCs=(List`1<List`1<Vertex>> geometries);
    private BaseShape cSs=(List`1<List`1<Vertex>> geometries);
    private BaseShape cis=(List`1<List`1<Vertex>> geometries);
}
internal class 8RQ=.wxk= : Txo= {
    internal double eRc=;
    internal double ehc=;
    internal double BBk=;
    internal double BRk=;
    internal double 1xc=;
    internal wxk=(string id, string desc);
    private void uhg=();
    internal virtual hRg= uxg=(hRg= pjConsts, Int32& pj_Error);
    internal virtual void whg=(XRg= lp, hRg= pjConsts, EBg= fac, Int32& pj_Error);
    internal virtual XRg= wBg=(XBo= xy, hRg= pjConsts, Int32& pj_Error);
    internal virtual XBo= wRg=(XRg= lp, hRg= pjConsts, Int32& pj_Error);
}
internal class 8RQ=.wyc= : object {
    public int xCc=;
    public wyc= XCQ=;
}
internal class 8RQ=.WyM= : object {
    [CompilerGeneratedAttribute]
private List`1<XyM=> VSM=;
    [CompilerGeneratedAttribute]
private List`1<UiM=> XCM=;
    [ObfuscationAttribute]
[JsonPropertyNameAttribute("links")]
public List`1<XyM=> Links { get; public set; }
    [ObfuscationAttribute]
[JsonPropertyNameAttribute("collections")]
public List`1<UiM=> Collections { get; public set; }
    public WyM=(List`1<XyM=> links, List`1<UiM=> collections);
    [CompilerGeneratedAttribute]
public List`1<XyM=> get_Links();
    [CompilerGeneratedAttribute]
public void set_Links(List`1<XyM=> value);
    [CompilerGeneratedAttribute]
public List`1<UiM=> get_Collections();
    [CompilerGeneratedAttribute]
public void set_Collections(List`1<UiM=> value);
}
internal class 8RQ=.WyQ= : object {
    public WyQ= XCQ=;
    public kiQ= XSQ=;
}
internal enum 8RQ=.WyY= : Enum {
    public int value__;
    public static WyY= XCY=;
    public static WyY= XSY=;
    public static WyY= XiY=;
    public static WyY= XyY=;
    public static WyY= YCY=;
    public static WyY= YSY=;
}
internal class 8RQ=.xBg= : Txo= {
    internal double xRg=;
    internal double xhg=;
    internal Double[] uBg=;
    internal double xxg=;
    internal double yBg=;
    internal double yRg=;
    internal double yhg=;
    internal double yxg=;
    internal int zBg=;
    private static double Khc=;
    internal xBg=(string id, string desc);
    private static xBg=();
    private void uhg=();
    internal virtual hRg= uxg=(hRg= pjConsts, Int32& pj_Error);
    private XRg= zRg=(XBo= xy, hRg= pjConsts, Int32& pj_Error);
    private XRg= zhg=(XBo= xy, hRg= pjConsts, Int32& pj_Error);
    private XRg= zxg=(XBo= xy, hRg= pjConsts, Int32& pj_Error);
    private XBo= 0Bg=(XRg= lp, hRg= pjConsts, Int32& pj_Error);
    private XBo= 0Rg=(XRg= lp, hRg= pjConsts, Int32& pj_Error);
    private XBo= 0hg=(XRg= lp, hRg= pjConsts, Int32& pj_Error);
    internal virtual void whg=(XRg= lp, hRg= pjConsts, EBg= fac, Int32& pj_Error);
    internal virtual XRg= wBg=(XBo= xy, hRg= pjConsts, Int32& pj_Error);
    internal virtual XBo= wRg=(XRg= lp, hRg= pjConsts, Int32& pj_Error);
}
internal class 8RQ=.XBg= : ValueType {
    internal int Fhg=;
    internal int Fxg=;
}
internal class 8RQ=.xBk= : ValueType {
    internal float xRk=;
    internal float ERk=;
    internal float Ehk=;
    internal float aBk=;
    internal xBk=(float c0, float c1, float c2, float c3);
}
internal class 8RQ=.XBo= : object {
    internal double XRo=;
    internal double Xho=;
}
internal enum 8RQ=.XC8= : Enum {
    public int value__;
    public static XC8= TC8=;
    public static XC8= TS8=;
    public static XC8= XS8=;
}
internal class 8RQ=.Xhg= : object {
    private Sxo= Xxg=;
    private Dictionary`2<string, Sxo=> YBg=;
    internal Sxo= Yhg= { get; }
    internal Xhg=(Dictionary`2<string, string> args, Dictionary`2<string, Sxo=> meridiansList, Int32& pj_Error);
    private static string Yxg=(Dictionary`2<string, string> args);
    private void ZBg=(string id, Int32& pj_Error);
    internal Sxo= YRg=();
}
internal class 8RQ=.xhk= : Txo= {
    internal xBk=[] xxk=;
    internal xBk=[] yBk=;
    internal xhk=(string id, string desc);
    private void uhg=();
    internal virtual hRg= uxg=(hRg= pjConsts, Int32& pj_Error);
    internal virtual void whg=(XRg= lp, hRg= pjConsts, EBg= fac, Int32& pj_Error);
    internal virtual XRg= wBg=(XBo= xy, hRg= pjConsts, Int32& pj_Error);
    internal virtual XBo= wRg=(XRg= lp, hRg= pjConsts, Int32& pj_Error);
}
internal enum 8RQ=.Xi8= : Enum {
    public int value__;
    public static Xi8= Xy8=;
}
internal class 8RQ=.xiI= : object {
    private double xyI=;
    private double yCI=;
    private double ySI=;
    private double yiI=;
    public double viI= { get; public set; }
    public double uyI= { get; public set; }
    public double uCI= { get; public set; }
    public double tSI= { get; public set; }
    public void vSI=(double value);
    public double vCI=();
    public void uiI=(double value);
    public double uSI=();
    public void tyI=(double value);
    public double tiI=();
    public void tCI=(double value);
    public double syI=();
}
internal enum 8RQ=.XiQ= : Enum {
    public int value__;
    public static XiQ= XyQ=;
    public static XiQ= YCQ=;
    public static XiQ= YSQ=;
    public static XiQ= YiQ=;
    public static XiQ= YyQ=;
}
internal class 8RQ=.XRg= : ValueType {
    internal double Fhg=;
    internal double Fxg=;
}
internal class 8RQ=.xS0= : ValueType {
    [CompilerGeneratedAttribute]
private int xi0=;
    [CompilerGeneratedAttribute]
private int xy0=;
    [CompilerGeneratedAttribute]
private int yC0=;
    [CompilerGeneratedAttribute]
private int yS0=;
    public int zC0= { get; public set; }
    public int zy0= { get; public set; }
    public int 0i0= { get; public set; }
    public int 1S0= { get; public set; }
    [CompilerGeneratedAttribute]
[IsReadOnlyAttribute]
public int yi0=();
    [CompilerGeneratedAttribute]
public void yy0=(int value);
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public int zS0=();
    [CompilerGeneratedAttribute]
public void zi0=(int value);
    [CompilerGeneratedAttribute]
[IsReadOnlyAttribute]
public int 0C0=();
    [CompilerGeneratedAttribute]
public void 0S0=(int value);
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public int 0y0=();
    [CompilerGeneratedAttribute]
public void 1C0=(int value);
}
internal class 8RQ=.xSc= : object {
    public int ySY=;
    public byte xic=;
    public byte xyc=;
    public int yCc=;
    public int ySc=;
    public xSc=(int nRefCount, byte nFillPattern, byte bTransparentFill, int rgbFGColor, int rgbBGColor);
}
internal class 8RQ=.xSk= : 0Ck= {
    private bool xik=;
    private double qSc=;
    private double qic=;
    private static int hCQ=;
    private static int hSQ=;
    private static int hiQ=;
    private static int hyQ=;
    public xSk=(yCY= poDefnIn);
    public virtual NCg= ric=();
    public virtual int ryc=(5yg= poMapFile);
    public virtual GSg= sCc=(yCY= poNewDefn);
    public int xyk=(int i, Double& dX, Double& dY);
    public int yCk=();
    public int ySk=(Double& dX, Double& dY);
    public void yik=(double dX, double dY);
    public virtual int sSc=(5yg= poMapFile, lSk= poObjHdr, bool bCoordBlockDataOnly, wig=& ppoCoordBlock);
    public virtual int sic=(5yg= poMapFile, lSk= poObjHdr, bool bCoordBlockDataOnly, wig=& ppoCoordBlock);
    public virtual int syc=(eyU= fp);
    public virtual int tCc=(eyU= fp);
    public virtual void tSc=(Stream fsOut);
}
internal class 8RQ=.XSM= : object {
    [CompilerGeneratedAttribute]
private YyM= XiM=;
    [JsonPropertyNameAttribute("spatial")]
[ObfuscationAttribute]
public YyM= Spatial { get; public set; }
    public XSM=(YyM= spatial);
    [CompilerGeneratedAttribute]
public YyM= get_Spatial();
    [CompilerGeneratedAttribute]
public void set_Spatial(YyM= value);
}
internal class 8RQ=.XSo= : lyQ= {
    protected Stream 5yc=;
    protected oSc= Xio=;
    protected int Xyo=;
    protected Byte[] YCo=;
    protected int uyc=;
    protected int YSo=;
    protected bool Yio=;
    protected int Yyo=;
    protected int ZCo=;
    protected int ZSo=;
    protected bool Zio=;
    public XSo=(oSc= eAccessMode, bool bHardBlockSize);
    public virtual int ReadFromFile(Stream fsSrc, int nOffset, int nSize);
    public virtual int CommitToFile();
    public int Zyo=(int nNextBlockPtr);
    public virtual int InitBlockFromData(Byte[] pabyBuf, int nBlockSize, int nSizeUsed, bool bMakeCopy, Stream fsSrc, int nOffset);
    public virtual int InitNewBlock(Stream fsSrc, int nBlockSize, int nFileOffset);
    public int aCo=();
    public virtual int GetBlockClass();
    public int aSo=();
    public int aio=(int nOffset);
    public int ayo=(int nOffset);
    public int bCo=(int nOffset, bool bForceReadFromFile, bool bOffsetIsEndOfData);
    public void bSo=(int nOffset);
    public int bio=();
    public int byo=();
    public int cCo=();
    public virtual int ReadBytes(int numBytes, Byte[] pabyDstBuf);
    public byte cSo=();
    public short cio=();
    public int cyo=();
    public double dCo=();
    public virtual int WriteBytes(int nBytesToWrite, Byte[] pabySrcBuf);
    public int dSo=(byte byValue);
    public int dio=(short n16Value);
    public int dyo=(int n32Value);
    public int eCo=(double dValue);
    public int eSo=(int nBytesToWrite);
    public Byte[] eio=();
    public int eyo=();
    public Byte[] fCo=();
}
internal class 8RQ=.xx8= : ValueType {
    public double xxk=;
    public double yBk=;
    private static int yB8=;
    public xx8=(double x, double y);
    public bool pB8=(xx8= pt);
    public static int MB8=(bool isFloat);
    public bool ZRw=(BinaryReader r, bool isFloat);
    public bool cxw=(BinaryWriter w, bool isFloat);
    public virtual string ToString();
}
internal class 8RQ=.Xxk= : Txo= {
    internal double sBg=;
    internal double Rhc=;
    internal double sRg=;
    internal double shg=;
    internal double sxg=;
    internal double tBg=;
    internal double tRg=;
    internal double thg=;
    internal double txg=;
    internal Double[] uBg=;
    internal int uRg=;
    private double Khc=;
    internal Xxk=(string id, string desc);
    private void uhg=();
    internal virtual hRg= uxg=(hRg= pjConsts, Int32& pj_Error);
    internal XBo= vBg=(XRg= lp, hRg= pjConsts);
    internal XRg= vRg=(XBo= xy, hRg= pjConsts);
    internal void vhg=(XRg= lp, hRg= pjConsts, EBg= factors);
    internal void vxg=(hRg= pjConsts);
    internal virtual XRg= wBg=(XBo= xy, hRg= pjConsts, Int32& pj_Error);
    internal virtual XBo= wRg=(XRg= lp, hRg= pjConsts, Int32& pj_Error);
    internal virtual void whg=(XRg= lp, hRg= pjConsts, EBg= fac, Int32& pj_Error);
    private double BBc=(double sinphi, double e, double one_es, Int32& pj_Error);
    private double wxg=(double qs, double Te, double Tone_es, Int32& pj_Error);
}
internal class 8RQ=.xy4= : object {
    private float yC4=;
    private float yS4=;
    private int yi4=;
    public float zS4= { get; public set; }
    public float 0C4= { get; public set; }
    public int 0y4= { get; public set; }
    public float yy4=();
    public void zC4=(float value);
    public float zi4=();
    public void zy4=(float value);
    public int 0S4=();
    public void 0i4=(int value);
}
internal class 8RQ=.Xyc= : bCc= {
    public RSc=[] YCc=;
    private SCc=[] UCc=;
    public virtual int ahU=();
    public string YSc=(Int32& bDefault);
    public double oh8=(Int32& bDefault);
    public string Yic=(Int32& bDefault);
    public string Uyc=(Int32& bDefault);
    public string VCc=(ZyY= eParam, Int32& bValueIsNull);
    public double Yyc=(ZyY= eParam, Int32& bValueIsNull);
}
internal class 8RQ=.XyM= : object {
    [CompilerGeneratedAttribute]
private string YCM=;
    [CompilerGeneratedAttribute]
private string YSM=;
    [CompilerGeneratedAttribute]
private string YiM=;
    [CompilerGeneratedAttribute]
private string VCM=;
    [ObfuscationAttribute]
[JsonPropertyNameAttribute("href")]
public string Href { get; public set; }
    [JsonPropertyNameAttribute("rel")]
[ObfuscationAttribute]
public string Rel { get; public set; }
    [ObfuscationAttribute]
[JsonPropertyNameAttribute("type")]
public string Type { get; public set; }
    [JsonPropertyNameAttribute("title")]
[ObfuscationAttribute]
public string Title { get; public set; }
    public XyM=(string href, string rel, string type, string title);
    [CompilerGeneratedAttribute]
public string get_Href();
    [CompilerGeneratedAttribute]
public void set_Href(string value);
    [CompilerGeneratedAttribute]
public string get_Rel();
    [CompilerGeneratedAttribute]
public void set_Rel(string value);
    [CompilerGeneratedAttribute]
public string get_Type();
    [CompilerGeneratedAttribute]
public void set_Type(string value);
    [CompilerGeneratedAttribute]
public string get_Title();
    [CompilerGeneratedAttribute]
public void set_Title(string value);
}
internal class 8RQ=.Xyw= : object {
    private string YCw=;
    private ICryptoTransform YSw=;
    private ICryptoTransform Yiw=;
    public string ZCw= { get; }
    public Xyw=(string password);
    public string Yyw=();
    private void ZSw=(string password);
    public Byte[] Ziw=(Byte[] inputBytes);
    public Byte[] Zyw=(Byte[] inputBytes, int offSet, int count);
    public ICryptoTransform aCw=(string password, int cipherMode, Byte[] providerIV, int paddingMode);
    public ICryptoTransform aSw=(string password, int cipherMode, Byte[] providerIV, int paddingMode);
}
internal class 8RQ=.YBk= : Txo= {
    internal FRc=[] 2hg=;
    internal double 2xg=;
    internal double 3Bg=;
    internal int Rhc=;
    internal YBk=(string id, string desc);
    private void uhg=();
    internal virtual hRg= uxg=(hRg= pjConsts, Int32& pj_Error);
    internal virtual void whg=(XRg= lp, hRg= pjConsts, EBg= fac, Int32& pj_Error);
    internal virtual XRg= wBg=(XBo= xy, hRg= pjConsts, Int32& pj_Error);
    internal virtual XBo= wRg=(XRg= lp, hRg= pjConsts, Int32& pj_Error);
    private XRg= zxg=(XBo= xy, hRg= pjConsts, Int32& pj_Error);
    private XBo= 0hg=(XRg= lp, hRg= pjConsts, Int32& pj_Error);
    private FRc= 3Rg=(FRc= z, FRc=[] C, int n, FRc= der);
    private FRc= 3hg=(FRc= z, FRc=[] C, int n);
}
internal enum 8RQ=.YC8= : Enum {
    public int value__;
    public static YC8= TC8=;
    public static YC8= TS8=;
    public static YC8= YS8=;
    public static YC8= Yi8=;
    public static YC8= Yy8=;
    public static YC8= ZC8=;
    public static YC8= ZS8=;
    public static YC8= Ti8=;
    public static YC8= Ty8=;
    public static YC8= Zi8=;
    public static YC8= Zy8=;
    public static YC8= aC8=;
    public static YC8= aS8=;
}
internal class 8RQ=.yCY= : object {
    private int ySY=;
    private int yiY=;
    private List`1<5yY=> yyY=;
    private PyY= zCY=;
    private string zSY=;
    public yCY=(string pszName);
    public string ziY=();
    public int uyY=();
    public 5yY= zyY=(int iField);
    public int vSY=(string pszFieldName);
    public void 0CY=(5yY= poNewDefn);
    public PyY= 0SY=();
    public void 0iY=(PyY= eNewType);
    public int 0yY=();
    public int 1CY=();
    public void 1SY=();
}
internal class 8RQ=.Yhk= : Txo= {
    internal Yhk=(string id, string desc);
    private void uhg=();
    internal virtual void whg=(XRg= lp, hRg= pjConsts, EBg= fac, Int32& pj_Error);
    internal virtual hRg= uxg=(hRg= pjConsts, Int32& pj_Error);
    internal virtual XRg= wBg=(XBo= xy, hRg= pjConsts, Int32& pj_Error);
    internal virtual XBo= wRg=(XRg= lp, hRg= pjConsts, Int32& pj_Error);
}
internal class 8RQ=.yic= : GSg= {
    private gSo= yyc=;
    private FCo= zCc=;
    private xSk= zSc=;
    private Sig= zic=;
    private static int hCQ=;
    private static int hSQ=;
    private static int hiQ=;
    private static int hyQ=;
    public int VSU= { get; public set; }
    public rio= WCU= { get; public set; }
    public yic=(yCY= poDefnIn);
    private void zyc=();
    private int 0Cc=(wig= poCoordBlock, bool bComprCoord, int nComprOrgX, int nComprOrgY, Int32& pnMinX, Int32& pnMinY, Int32& pnMaxX, Int32& pnMaxY, Int32& pnLabelX, Int32& pnLabelY);
    private int 0Sc=(wig= poCoordBlock, bool bComprCoord, int nMinX, int nMinY, int nMaxX, int nMaxY, int nLabelX, int nLabelY);
    private int 0ic=(bool bSyncRegion, bool bSyncPline, bool bSyncMpoint);
    public virtual NCg= ric=();
    public virtual int ryc=(5yg= poMapFile);
    public virtual GSg= sCc=(yCY= poNewDefn);
    public virtual int sSc=(5yg= poMapFile, lSk= poObjHdr, bool bCoordDataOnly, wig=& ppoCoordBlock);
    public virtual int sic=(5yg= poMapFile, lSk= poObjHdr, bool bCoordBlockDataOnly, wig=& ppoCoordBlock);
    public virtual int syc=(eyU= fp);
    public virtual int tCc=(eyU= fp);
    public virtual string xiY=();
    public virtual void tSc=(Stream fsOut);
    public int 0yc=(gSo= poRegion);
    public int 1Cc=(FCo= poPline);
    public int 1Sc=(xSk= poMpoint);
    public virtual int UyU=();
    public virtual void VCU=(int value);
    public virtual rio= ViU=();
    public virtual void VyU=(rio= value);
    public virtual int WSU=();
    public virtual rio= WiU=();
    public virtual short WyU=();
    public virtual short XCU=();
    public virtual int XSU=();
    public virtual void XiU=(short val);
    public virtual void XyU=(short val);
    public virtual void YCU=(int clr);
    public virtual string YSU=(double dfAngle);
    public virtual void YiU=(string pszStyleString);
    public virtual void YyU=(Stream fpOut);
}
internal enum 8RQ=.YiY= : Enum {
    public int value__;
    public static YiY= YyY=;
    public static YiY= ZCY=;
    public static YiY= ZSY=;
    public static YiY= ZiY=;
}
internal enum 8RQ=.yR8= : Enum {
    public int value__;
    public static yR8= yh8=;
    public static yR8= yx8=;
}
internal class 8RQ=.yRk= : ValueType {
    internal int yhk=;
    internal double jxg=;
    internal double yxk=;
    internal Double[] Zxk=;
    public yRk=(int nb, double es, double E, Double[] b);
}
internal class 8RQ=.YRk= : Txo= {
    internal YRk=(string id, string desc);
    private void uhg=();
    internal virtual void whg=(XRg= lp, hRg= pjConsts, EBg= fac, Int32& pj_Error);
    internal virtual hRg= uxg=(hRg= pjConsts, Int32& pj_Error);
    internal virtual XRg= wBg=(XBo= xy, hRg= pjConsts, Int32& pj_Error);
    internal virtual XBo= wRg=(XRg= lp, hRg= pjConsts, Int32& pj_Error);
}
internal class 8RQ=.Yxk= : Txo= {
    internal double thg=;
    internal double 2Bg=;
    internal double ZBk=;
    internal Yxk=(string id, string desc);
    private void uhg=();
    internal virtual hRg= uxg=(hRg= pjConsts, Int32& pj_Error);
    internal virtual void whg=(XRg= lp, hRg= pjConsts, EBg= fac, Int32& pj_Error);
    internal virtual XRg= wBg=(XBo= xy, hRg= pjConsts, Int32& pj_Error);
    internal virtual XBo= wRg=(XRg= lp, hRg= pjConsts, Int32& pj_Error);
}
internal class 8RQ=.yyI= : object {
    private List`1<Collection`1<GridCell>> zCI=;
    private double zSI=;
    public List`1<Collection`1<GridCell>> zyI= { get; }
    public double 0iI= { get; public set; }
    public List`1<Collection`1<GridCell>> ziI=();
    public void 0SI=(double value);
    public double 0CI=();
}
internal class 8RQ=.yyk= : object {
    public int ySY=;
    public byte zCk=;
    public byte zSk=;
    public int zik=;
    public int zyk=;
    public yyk=(int nRefCount, byte nPixelWidth, byte nLinePattern, int nPointWidth, int rgbColor);
}
internal class 8RQ=.YyM= : object {
    [CompilerGeneratedAttribute]
private List`1<List`1<double>> ZCM=;
    [CompilerGeneratedAttribute]
private string WCM=;
    [JsonPropertyNameAttribute("bbox")]
[ObfuscationAttribute]
public List`1<List`1<double>> Bbox { get; public set; }
    [JsonPropertyNameAttribute("crs")]
[ObfuscationAttribute]
public string Crs { get; public set; }
    public YyM=(List`1<List`1<double>> bbox, string crs);
    [CompilerGeneratedAttribute]
public List`1<List`1<double>> get_Bbox();
    [CompilerGeneratedAttribute]
public void set_Bbox(List`1<List`1<double>> value);
    [CompilerGeneratedAttribute]
public string get_Crs();
    [CompilerGeneratedAttribute]
public void set_Crs(string value);
}
internal class 8RQ=.yyw= : object {
    [CompilerGeneratedAttribute]
private ushort zCw=;
    [CompilerGeneratedAttribute]
private string zSw=;
    [CompilerGeneratedAttribute]
private WellKnownType YiM=;
    [CompilerGeneratedAttribute]
private RectangleShape ziw=;
    [CompilerGeneratedAttribute]
private int Iyw=;
    public ushort 0Sw= { get; private set; }
    public string 1Cw= { get; public set; }
    public WellKnownType Viw= { get; private set; }
    public RectangleShape 1yw= { get; public set; }
    public int KCw= { get; private set; }
    public yyw=(RectangleShape box);
    public yyw=(RectangleShape box, WellKnownType objType, int objIndex, string lable, ushort fclass);
    [CompilerGeneratedAttribute]
private void 0Cw=(ushort value);
    [CompilerGeneratedAttribute]
public ushort zyw=();
    [CompilerGeneratedAttribute]
public void 0yw=(string value);
    [CompilerGeneratedAttribute]
public string 0iw=();
    [CompilerGeneratedAttribute]
private void VSw=(WellKnownType value);
    [CompilerGeneratedAttribute]
public WellKnownType VCw=();
    [CompilerGeneratedAttribute]
public void 1iw=(RectangleShape value);
    [CompilerGeneratedAttribute]
public RectangleShape 1Sw=();
    [CompilerGeneratedAttribute]
private void Jyw=(int value);
    [CompilerGeneratedAttribute]
public int Jiw=();
}
internal class 8RQ=.zBk= : Txo= {
    internal double zRk=;
    internal double zhk=;
    internal double zxk=;
    internal double 0Bk=;
    internal double 0Rk=;
    internal double 0hk=;
    internal double 0xk=;
    internal double 1Bk=;
    internal double 1Rk=;
    internal double 1hk=;
    internal double 1xk=;
    internal double 2Bk=;
    internal double 2Rk=;
    internal double 2hk=;
    internal double 2xk=;
    internal double Wxc=;
    internal double XBc=;
    internal double XRc=;
    internal double Xhc=;
    internal double Xxc=;
    internal double 3Bk=;
    internal double 3Rk=;
    internal double 3hk=;
    internal double cRc=;
    internal double 3xk=;
    internal double 4Bk=;
    internal double 4Rk=;
    internal double chc=;
    internal double 4hk=;
    internal double 4xk=;
    internal double 5Bk=;
    internal double 5Rk=;
    internal double 5hk=;
    internal double 5xk=;
    internal yRk= uBg=;
    private int Nxc=;
    internal zBk=(string id, string desc);
    private void uhg=();
    internal virtual hRg= uxg=(hRg= pjConsts, Int32& pj_Error);
    internal virtual void whg=(XRg= lp, hRg= pjConsts, EBg= fac, Int32& pj_Error);
    internal virtual XRg= wBg=(XBo= xy, hRg= pjConsts, Int32& pj_Error);
    internal virtual XBo= wRg=(XRg= lp, hRg= pjConsts, Int32& pj_Error);
    private yRk= 6Bk=(double es);
    private double 6Rk=(double phi, double sphi, double cphi, yRk= b, Int32& pj_Error);
    private double 6hk=(double dist, yRk= b, Int32& pj_Error);
}
internal class 8RQ=.ZBw= : object {
    public BaseShape ZRw=(Byte[] data);
    public static WkbShapeType WRw=(Byte[] wkb, int startIndex);
    public virtual BaseShape ZRw=(Stream stream);
    protected BaseShape ZRw=(BinaryReader reader);
    protected WkbByteOrder Zhw=(BinaryReader reader);
    protected Vertex Zxw=(BinaryReader reader);
    protected RingShape aBw=(BinaryReader reader);
    protected PointShape aRw=(BinaryReader reader);
    protected LineShape ahw=(BinaryReader reader);
    protected PolygonShape axw=(BinaryReader reader);
    protected MultipointShape bBw=(BinaryReader reader);
    protected MultilineShape bRw=(BinaryReader reader);
    protected MultipolygonShape bhw=(BinaryReader reader);
    protected GeometryCollectionShape bxw=(BinaryReader reader);
}
internal class 8RQ=.ZCc= : bCc= {
    public RSc=[] ZSc=;
    private SCc=[] UCc=;
    public virtual int ahU=();
    public string Uyc=(Int32& bDefault);
    public string YSc=(Int32& bDefault);
    public double Zic=(Int32& bDefault);
    public string VCc=(eyY= eParam, Int32& bValueIsNull);
    public double Yyc=(eyY= eParam, Int32& bValueIsNull);
}
internal class 8RQ=.ZCk= : object {
    public int HCQ=;
    public int HiQ=;
    public int HSQ=;
    public int HyQ=;
    public int xCc=;
}
internal static class 8RQ=.ZCQ= : object {
    public static bool ZSQ=;
    public static LocalDataStoreSlot ZiQ=;
    public static object ZyQ=(int nIndex);
    public static void aCQ=(int nIndex, object pData, bool bFreeOnExit);
    public static Object[] aSQ=();
}
internal class 8RQ=.ZCU= : object {
    public GCo= ZSU=;
    public double ZiU=;
    public double ZyU=;
    public double aCU=;
    public double aSU=;
    public ZCU=(GCo= sProj, double dXMin, double dYMin, double dXMax, double dYMax);
}
internal class 8RQ=.ZiA= : ValueType {
    public double ZyA=;
    public string aCA=;
    public string aSA=;
    public string aiA=;
    public iiA= ayA=;
    public iiA= bCA=;
    public string bSA=;
    public string biA=;
    public string byA=;
    public string cCA=;
    public string cSA=;
    public string ciA=;
    public string cyA=;
    public string dCA=;
    public bool dSA=;
    public string diA=;
    public int dyA=;
}
internal class 8RQ=.ZRg= : object {
    internal static double IRY=;
    internal static double Zhg=(double d);
    internal static double Zxg=(double x, double y);
    internal static double aBg=(double d, Int32& pj_Error);
    internal static double aRg=(double d, Int32& pj_Error);
    internal static double ahg=(double d, Int32& pj_Error);
    internal static double axg=(double d, Int32& pj_Error);
    internal static double bBg=(double d, Int32& pj_Error);
    internal static double bRg=(double d, Int32& pj_Error);
    internal static double bhg=(double y, double x, Int32& pj_Error);
    internal static double bxg=(double d, Int32& pj_Error);
    internal static double cBg=(double d, Int32& pj_Error);
    internal static double cRg=(double d, Int32& pj_Error);
    internal static double chg=(double x, double y, Int32& pj_Error);
    internal static double cxg=(double d, Int32& pj_Error);
    internal static double dBg=(double d, Int32& pj_Error);
    internal static double dRg=(double d, Int32& pj_Error);
}
internal class 8RQ=.ZRk= : Txo= {
    internal double 7hg=;
    internal double Zhk=;
    internal double Zxk=;
    internal double ERk=;
    internal double aBk=;
    internal double aRk=;
    internal double ghg=;
    internal double ahk=;
    internal double Lhk=;
    internal double axk=;
    internal double bBk=;
    internal double bRk=;
    internal double bhk=;
    internal double bxk=;
    internal double cBk=;
    internal ZRk=(string id, string desc);
    private void uhg=();
    internal virtual hRg= uxg=(hRg= pjConsts, Int32& pj_Error);
    internal virtual void whg=(XRg= lp, hRg= pjConsts, EBg= fac, Int32& pj_Error);
    internal virtual XRg= wBg=(XBo= xy, hRg= pjConsts, Int32& pj_Error);
    internal virtual XBo= wRg=(XRg= lp, hRg= pjConsts, Int32& pj_Error);
    private void cRk=(double lam, double mult, hRg= pjConsts, Int32& pj_Error);
}
internal class 8RQ=.ZSk= : lSk= {
    public int Zik=;
    public int Zyk=;
    public int aCk=;
    public int aSk=;
    public int aik=;
    public int ayk=;
    public byte bCk=;
    public virtual int bSk=(fCk= poObjBlock);
    public virtual int bik=(fCk= poObjBlock);
}
internal class 8RQ=.ZSM= : object {
    [CompilerGeneratedAttribute]
private string YiM=;
    [CompilerGeneratedAttribute]
private JsonElement ZiM=;
    [CompilerGeneratedAttribute]
private DateTime ZyM=;
    [CompilerGeneratedAttribute]
private List`1<XyM=> VSM=;
    [CompilerGeneratedAttribute]
private int aCM=;
    [JsonPropertyNameAttribute("type")]
[ObfuscationAttribute]
public string Type { get; public set; }
    [JsonPropertyNameAttribute("features")]
[ObfuscationAttribute]
public JsonElement Features { get; public set; }
    [JsonPropertyNameAttribute("timeStamp")]
[ObfuscationAttribute]
public DateTime TimeStamp { get; public set; }
    [JsonPropertyNameAttribute("links")]
[ObfuscationAttribute]
public List`1<XyM=> Links { get; public set; }
    [JsonPropertyNameAttribute("numberReturned")]
[ObfuscationAttribute]
public int NumberReturned { get; public set; }
    public ZSM=(string type, JsonElement features, DateTime timeStamp, List`1<XyM=> links, int numberReturned);
    [CompilerGeneratedAttribute]
public string get_Type();
    [CompilerGeneratedAttribute]
public void set_Type(string value);
    [CompilerGeneratedAttribute]
public JsonElement get_Features();
    [CompilerGeneratedAttribute]
public void set_Features(JsonElement value);
    [CompilerGeneratedAttribute]
public DateTime get_TimeStamp();
    [CompilerGeneratedAttribute]
public void set_TimeStamp(DateTime value);
    [CompilerGeneratedAttribute]
public List`1<XyM=> get_Links();
    [CompilerGeneratedAttribute]
public void set_Links(List`1<XyM=> value);
    [CompilerGeneratedAttribute]
public int get_NumberReturned();
    [CompilerGeneratedAttribute]
public void set_NumberReturned(int value);
}
internal class 8RQ=.Zxs= : object {
    protected long aBs=;
    public virtual long aRs=();
}
internal class 8RQ=.Zyc= : object {
    private String[] aCc=;
    public string aSc=(string pszName);
    public int aic=(string pszName);
    public string ayc=(string pszStyleString);
}
internal enum 8RQ=.ZyY= : Enum {
    public int value__;
    public static ZyY= aCY=;
    public static ZyY= aSY=;
    public static ZyY= aiY=;
    public static ZyY= ayY=;
    public static ZyY= bCY=;
    public static ZyY= bSY=;
    public static ZyY= biY=;
    public static ZyY= byY=;
    public static ZyY= cCY=;
}
[CompilerGeneratedAttribute]
[EmbeddedAttribute]
internal class Microsoft.CodeAnalysis.EmbeddedAttribute : Attribute {
}
internal class qRM=./RM= : TBQ= {
    protected ThinkGeoLicenseStatus[] 9RM= { get; }
    public virtual void 9hM=(eBQ= context);
    protected virtual ThinkGeoLicenseStatus[] 9BM=();
    private static bool /hM=(BRQ= productNode);
}
internal class qRM=./xM= : TBQ= {
    private static string ABQ=;
    protected ThinkGeoLicenseStatus[] 9RM= { get; }
    private static /xM=();
    public virtual void 9hM=(eBQ= context);
    private static bool ARQ=(BRQ= node);
    protected virtual ThinkGeoLicenseStatus[] 9BM=();
    private bool AhQ=(BRQ= productNode);
    private static bool AxQ=(BRQ= productNode, bool isDebug);
}
internal class qRM=.0RM= : 4RM= {
    private static Dictionary`2<string, 0RM=> 0hM=;
    private static object oRM=;
    private static bool 0xM=;
    private static Dictionary`2<string, 0RM=> 1RM= { get; }
    private static 0RM=();
    public static void 1hM=(Dictionary`2<string, Collection`1<string>> licenseContents);
    private static Dictionary`2<string, 0RM=> 1BM=();
    public static IEnumerable`1<BRQ=> 1xM=(Guid productId);
    private static void 2BM=(Guid productId, RhQ= nodeType, IEnumerable`1<BRQ=> source, List`1<BRQ=> licenseNodes);
    public static void 2RM=();
    private static 0RM= 2hM=(string fileLicensePathName);
    private static 0RM= 2xM=(Stream licenseStream);
    private static 0RM= 3BM=(Collection`1<string> licenseLines);
    private static void 3RM=(BRQ= node);
    private static BRQ= 3hM=(string content);
    private static IEnumerable`1<string> 3xM=(string licenseFileExtension, string searchPattern);
    private static IEnumerable`1<string> 4BM=();
}
internal abstract class qRM=.4RM= : object {
    [CompilerGeneratedAttribute]
private string 4hM=;
    [CompilerGeneratedAttribute]
private string 4xM=;
    private Collection`1<BRQ=> 5BM=;
    private Collection`1<BRQ=> 5RM=;
    public string 6BM= { get; public set; }
    public string 6xM= { get; public set; }
    public IEnumerable`1<BRQ=> 7RM= { get; }
    public IEnumerable`1<BRQ=> 7xM= { get; }
    public bool 8RM= { get; }
    [CompilerGeneratedAttribute]
public string 5hM=();
    [CompilerGeneratedAttribute]
public void 5xM=(string value);
    [CompilerGeneratedAttribute]
public string 6RM=();
    [CompilerGeneratedAttribute]
public void 6hM=(string value);
    public IEnumerable`1<BRQ=> 7BM=();
    public IEnumerable`1<BRQ=> 7hM=();
    public void 8hM=(BRQ= node);
    public bool 8BM=();
}
internal class qRM=.8xM= : TBQ= {
    protected ThinkGeoLicenseStatus[] 9RM= { get; }
    public virtual void 9hM=(eBQ= context);
    protected virtual ThinkGeoLicenseStatus[] 9BM=();
    private static bool 9xM=(BRQ= productNode);
    private static Assembly /BM=(string assemblyPath, string assemblyName);
}
internal class qRM=.BBQ= : TBQ= {
    protected ThinkGeoLicenseStatus[] 9RM= { get; }
    public virtual void 9hM=(eBQ= context);
    protected virtual ThinkGeoLicenseStatus[] 9BM=();
}
internal class qRM=.BRQ= : object {
    public static BRQ= BhQ=;
    private Guid BxQ=;
    private Version CBQ=;
    private string CRQ=;
    private string ChQ=;
    private string CxQ=;
    private VBQ= DBQ=;
    private BRQ= DRQ=;
    private BRQ= DhQ=;
    private string DxQ=;
    private DateTime EBQ=;
    private Nullable`1<DateTime> ERQ=;
    private RhQ= EhQ=;
    private 4RM= ExQ=;
    private ThinkGeoLicenseStatus FBQ=;
    private string FRQ=;
    public string FhQ=;
    public Guid GRQ= { get; public set; }
    public Version 6xM= { get; public set; }
    public string HBQ= { get; public set; }
    public string HxQ= { get; public set; }
    public string IhQ= { get; public set; }
    public VBQ= JRQ= { get; public set; }
    public BRQ= KBQ= { get; public set; }
    public BRQ= KxQ= { get; public set; }
    public string LhQ= { get; public set; }
    public DateTime MRQ= { get; public set; }
    public Nullable`1<DateTime> NBQ= { get; public set; }
    public RhQ= NxQ= { get; public set; }
    public 4RM= OhQ= { get; internal set; }
    public ThinkGeoLicenseStatus PRQ= { get; public set; }
    public string QBQ= { get; public set; }
    public string QxQ= { get; public set; }
    public bool RRQ= { get; }
    private static BRQ=();
    public Guid FxQ=();
    public void GBQ=(Guid value);
    public Version 6RM=();
    public void 6hM=(Version value);
    public string GhQ=();
    public void GxQ=(string value);
    public string HRQ=();
    public void HhQ=(string value);
    public string IBQ=();
    public void IRQ=(string value);
    public VBQ= IxQ=();
    public void JBQ=(VBQ= value);
    public BRQ= JhQ=();
    public void JxQ=(BRQ= value);
    public BRQ= KRQ=();
    public void KhQ=(BRQ= value);
    public string LBQ=();
    public void LRQ=(string value);
    public DateTime LxQ=();
    public void MBQ=(DateTime value);
    public Nullable`1<DateTime> MhQ=();
    public void MxQ=(Nullable`1<DateTime> value);
    public RhQ= NRQ=();
    public void NhQ=(RhQ= value);
    public 4RM= OBQ=();
    internal void ORQ=(4RM= value);
    public ThinkGeoLicenseStatus OxQ=();
    public void PBQ=(ThinkGeoLicenseStatus value);
    public string PhQ=();
    public void PxQ=(string value);
    public string QRQ=();
    public void QhQ=(string value);
    public bool RBQ=();
}
internal class qRM=.bxQ= : object {
    private static string cBQ=;
    private qBM= cRQ=;
    private qBM= chQ=;
    private RSACryptoServiceProvider cxQ=;
    private static bxQ=();
    private void dBQ=(string publicKeyBase64);
    public Byte[] dRQ=(Byte[] encryptedData);
    public sealed virtual void Dispose();
    public string dhQ=(string encryptedData);
}
internal class qRM=.dxQ= : TBQ= {
    protected ThinkGeoLicenseStatus[] 9RM= { get; }
    public virtual void 9hM=(eBQ= context);
    private static bool ARQ=(BRQ= node);
    protected virtual ThinkGeoLicenseStatus[] 9BM=();
}
internal class qRM=.eBQ= : object {
    [CompilerGeneratedAttribute]
private BRQ= eRQ=;
    [CompilerGeneratedAttribute]
private ThinkGeoLicenseStatus ehQ=;
    [CompilerGeneratedAttribute]
private bool exQ=;
    public BRQ= fhQ= { get; private set; }
    public ThinkGeoLicenseStatus gRQ= { get; public set; }
    public bool hBQ= { get; private set; }
    public eBQ=(BRQ= productNode, bool isDebug);
    [CompilerGeneratedAttribute]
public BRQ= fBQ=();
    [CompilerGeneratedAttribute]
private void fRQ=(BRQ= value);
    [CompilerGeneratedAttribute]
public ThinkGeoLicenseStatus fxQ=();
    [CompilerGeneratedAttribute]
public void gBQ=(ThinkGeoLicenseStatus value);
    [CompilerGeneratedAttribute]
public bool ghQ=();
    [CompilerGeneratedAttribute]
private void gxQ=(bool value);
}
internal class qRM=.qBM= : object {
    private static int qhM=;
    private UInt32[] qxM=;
    public int rBM=;
    public qBM=(long value);
    public qBM=(ulong value);
    public qBM=(qBM= bi);
    public qBM=(string value, int radix);
    public qBM=(Byte[] inData);
    public qBM=(Byte[] inData, int inLen);
    public qBM=(UInt32[] inData);
    public static qBM= rRM=(long value);
    public static qBM= rRM=(ulong value);
    public static qBM= rRM=(int value);
    public static qBM= rRM=(UInt32 value);
    public static qBM= rhM=(qBM= bi1, qBM= bi2);
    public static qBM= rxM=(qBM= bi1);
    public static qBM= sBM=(qBM= bi1, qBM= bi2);
    public static qBM= sRM=(qBM= bi1);
    public static qBM= shM=(qBM= bi1, qBM= bi2);
    public static qBM= sxM=(qBM= bi1, int shiftVal);
    private static int tBM=(UInt32[] buffer, int shiftVal);
    public static qBM= tRM=(qBM= bi1, int shiftVal);
    private static int thM=(UInt32[] buffer, int shiftVal);
    public static qBM= txM=(qBM= bi1);
    public static qBM= uBM=(qBM= bi1);
    public static bool uRM=(qBM= bi1, qBM= bi2);
    public static bool uhM=(qBM= bi1, qBM= bi2);
    public virtual bool Equals(object o);
    public virtual int GetHashCode();
    public static bool uxM=(qBM= bi1, qBM= bi2);
    public static bool vBM=(qBM= bi1, qBM= bi2);
    public static bool vRM=(qBM= bi1, qBM= bi2);
    public static bool vhM=(qBM= bi1, qBM= bi2);
    private static void vxM=(qBM= bi1, qBM= bi2, qBM= outQuotient, qBM= outRemainder);
    private static void wBM=(qBM= bi1, qBM= bi2, qBM= outQuotient, qBM= outRemainder);
    public static qBM= wRM=(qBM= bi1, qBM= bi2);
    public static qBM= whM=(qBM= bi1, qBM= bi2);
    public static qBM= wxM=(qBM= bi1, qBM= bi2);
    public static qBM= xBM=(qBM= bi1, qBM= bi2);
    public static qBM= xRM=(qBM= bi1, qBM= bi2);
    public virtual string ToString();
    public string xhM=(int radix);
    public qBM= xxM=(qBM= exp, qBM= n);
    private qBM= yBM=(qBM= x, qBM= n, qBM= constant);
    private int yRM=();
    public Byte[] yhM=();
}
internal enum qRM=.RhQ= : Enum {
    public int value__;
    public static RhQ= RxQ=;
    public static RhQ= SBQ=;
    public static RhQ= SRQ=;
    public static RhQ= ShQ=;
}
internal class qRM=.SxQ= : TBQ= {
    protected ThinkGeoLicenseStatus[] 9RM= { get; }
    public virtual void 9hM=(eBQ= context);
    protected virtual ThinkGeoLicenseStatus[] 9BM=();
}
internal abstract class qRM=.TBQ= : object {
    [CompilerGeneratedAttribute]
private TBQ= TRQ=;
    protected TBQ= UBQ= { get; private set; }
    protected ThinkGeoLicenseStatus[] 9RM= { get; }
    [CompilerGeneratedAttribute]
protected TBQ= ThQ=();
    [CompilerGeneratedAttribute]
private void TxQ=(TBQ= value);
    public virtual void 9hM=(eBQ= context);
    public TBQ= URQ=(TBQ= next);
    protected abstract virtual ThinkGeoLicenseStatus[] 9BM=();
}
internal static class qRM=.UhQ= : object {
    private static TBQ= UxQ=;
    private static UhQ=();
    public static ThinkGeoLicenseStatus 9hM=(eBQ= validationContext);
}
internal class qRM=.VBQ= : object {
    private Guid VRQ=;
    private string VhQ=;
    private string VxQ=;
    private string WBQ=;
    private string WRQ=;
    internal static Collection`1<VBQ=> WhQ=;
    public Guid XRQ= { get; public set; }
    public string YBQ= { get; public set; }
    internal string YxQ= { get; internal set; }
    internal string ZhQ= { get; internal set; }
    internal string aRQ= { get; internal set; }
    public bool axQ= { get; }
    public bool bRQ= { get; }
    private static VBQ=();
    public Guid WxQ=();
    public void XBQ=(Guid value);
    public string XhQ=();
    public void XxQ=(string value);
    internal string YRQ=();
    internal void YhQ=(string value);
    internal string ZBQ=();
    internal void ZRQ=(string value);
    internal string ZxQ=();
    internal void aBQ=(string value);
    public bool ahQ=();
    public bool bBQ=();
    private static Collection`1<VBQ=> bhQ=();
    [CompilerGeneratedAttribute]
private bool <get_NeedServerInRuntime>b__23_0(VBQ= p);
}
internal static class qRM=.yxM= : object {
    internal static string zBM=(string plainText);
    internal static string zRM=(string plainText);
    internal static string zhM=(string plainText);
    internal static DateTime zxM=(string formatedDate);
    internal static string 0BM=(DateTime expireTime);
}
public class SecureTeam.Attributes.ObfuscatedByAgileDotNetAttribute : Attribute {
}
[AttributeUsageAttribute("1")]
public class System.Reflection.AssemblyTimestampAttribute : Attribute {
    [CompilerGeneratedAttribute]
private string pxM=;
    public string Timestamp { get; }
    public AssemblyTimestampAttribute(string timestamp);
    [CompilerGeneratedAttribute]
public string get_Timestamp();
}
[CompilerGeneratedAttribute]
[EmbeddedAttribute]
internal class System.Runtime.CompilerServices.IsReadOnlyAttribute : Attribute {
}
public class ThinkGeo.Core.AddedGeoCollectionEventArgs : EventArgs {
    [ObfuscationAttribute]
private object item;
    [ObfuscationAttribute]
private string key;
    public object Item { get; public set; }
    public string Key { get; public set; }
    public AddedGeoCollectionEventArgs(object item);
    public AddedGeoCollectionEventArgs(object item, string key);
    public object get_Item();
    public void set_Item(object value);
    public string get_Key();
    public void set_Key(string value);
}
public class ThinkGeo.Core.AddingGeoCollectionEventArgs : EventArgs {
    [ObfuscationAttribute]
private object item;
    public object Item { get; public set; }
    public AddingGeoCollectionEventArgs(object item);
    public object get_Item();
    public void set_Item(object value);
}
public abstract class ThinkGeo.Core.AdornmentLayer : Layer {
    [ObfuscationAttribute]
private float xOffsetInPixel;
    [ObfuscationAttribute]
private float yOffsetInPixel;
    [ObfuscationAttribute]
private AdornmentLocation location;
    [ObfuscationAttribute]
private float width;
    [ObfuscationAttribute]
private float height;
    [ObfuscationAttribute]
private AreaStyle backgroundMask;
    public float Width { get; public set; }
    public float Height { get; public set; }
    public AreaStyle BackgroundMask { get; public set; }
    public AdornmentLocation Location { get; public set; }
    public float XOffsetInPixel { get; public set; }
    public float YOffsetInPixel { get; public set; }
    public float get_Width();
    public void set_Width(float value);
    public float get_Height();
    public void set_Height(float value);
    public AreaStyle get_BackgroundMask();
    public void set_BackgroundMask(AreaStyle value);
    public AdornmentLocation get_Location();
    public void set_Location(AdornmentLocation value);
    public float get_XOffsetInPixel();
    public void set_XOffsetInPixel(float value);
    public float get_YOffsetInPixel();
    public void set_YOffsetInPixel(float value);
    protected virtual void DrawCore(GeoCanvas canvas, Collection`1<SimpleCandidate> labelsInAllLayers);
    public virtual ScreenPointF GetDrawingLocation(GeoCanvas canvas, float adornmentWidth, float adornmentHeight);
}
public enum ThinkGeo.Core.AdornmentLocation : Enum {
    public int value__;
    public static AdornmentLocation UseOffsets;
    public static AdornmentLocation UpperLeft;
    public static AdornmentLocation UpperCenter;
    public static AdornmentLocation UpperRight;
    public static AdornmentLocation CenterLeft;
    public static AdornmentLocation Center;
    public static AdornmentLocation CenterRight;
    public static AdornmentLocation LowerLeft;
    public static AdornmentLocation LowerCenter;
    public static AdornmentLocation LowerRight;
}
public enum ThinkGeo.Core.AngleUnit : Enum {
    public int value__;
    public static AngleUnit Degrees;
    public static AngleUnit Radians;
    public static AngleUnit Gradians;
}
public enum ThinkGeo.Core.ApplyUntilZoomLevel : Enum {
    public int value__;
    public static ApplyUntilZoomLevel None;
    public static ApplyUntilZoomLevel Level01;
    public static ApplyUntilZoomLevel Level02;
    public static ApplyUntilZoomLevel Level03;
    public static ApplyUntilZoomLevel Level04;
    public static ApplyUntilZoomLevel Level05;
    public static ApplyUntilZoomLevel Level06;
    public static ApplyUntilZoomLevel Level07;
    public static ApplyUntilZoomLevel Level08;
    public static ApplyUntilZoomLevel Level09;
    public static ApplyUntilZoomLevel Level10;
    public static ApplyUntilZoomLevel Level11;
    public static ApplyUntilZoomLevel Level12;
    public static ApplyUntilZoomLevel Level13;
    public static ApplyUntilZoomLevel Level14;
    public static ApplyUntilZoomLevel Level15;
    public static ApplyUntilZoomLevel Level16;
    public static ApplyUntilZoomLevel Level17;
    public static ApplyUntilZoomLevel Level18;
    public static ApplyUntilZoomLevel Level19;
    public static ApplyUntilZoomLevel Level20;
}
public class ThinkGeo.Core.ArcGisServerRestAsyncLayer : WebBasedAsyncLayer {
    [ObfuscationAttribute]
private Dictionary`2<string, string> parameters;
    [ObfuscationAttribute]
private ArcGISServerRestLayerImageFormat imageFormat;
    [ObfuscationAttribute]
private bool enableImageFormat;
    [CompilerGeneratedAttribute]
private Uri qB0=;
    public Uri ServerUri { get; public set; }
    public Dictionary`2<string, string> Parameters { get; }
    public ArcGISServerRestLayerImageFormat ImageFormat { get; public set; }
    public ArcGisServerRestAsyncLayer(Uri serverUri);
    public ArcGisServerRestAsyncLayer(Uri serverUri, IWebProxy webProxy);
    [CompilerGeneratedAttribute]
public Uri get_ServerUri();
    [CompilerGeneratedAttribute]
public void set_ServerUri(Uri value);
    public Dictionary`2<string, string> get_Parameters();
    public ArcGISServerRestLayerImageFormat get_ImageFormat();
    public void set_ImageFormat(ArcGISServerRestLayerImageFormat value);
    [AsyncStateMachineAttribute("ThinkGeo.Core.ArcGisServerRestAsyncLayer/<DrawAsyncCore>d__15")]
protected virtual Task DrawAsyncCore(GeoCanvas canvas, Collection`1<SimpleCandidate> labelsInAllLayers);
    private string qR0=(Dictionary`2<string, string> tempDictionary);
}
public enum ThinkGeo.Core.ArcGISServerRestLayerImageFormat : Enum {
    public int value__;
    public static ArcGISServerRestLayerImageFormat Png;
    public static ArcGISServerRestLayerImageFormat Png8;
    public static ArcGISServerRestLayerImageFormat Png24;
    public static ArcGISServerRestLayerImageFormat Jpeg;
    public static ArcGISServerRestLayerImageFormat Gif;
}
public abstract class ThinkGeo.Core.AreaBaseShape : BaseShape {
    public double GetPerimeter(GeographyUnit shapeUnit, DistanceUnit returningUnit);
    protected virtual double GetPerimeterCore(GeographyUnit shapeUnit, DistanceUnit returningUnit);
    public double GetArea(GeographyUnit shapeUnit, AreaUnit returningUnit);
    protected virtual double GetAreaCore(GeographyUnit shapeUnit, AreaUnit returningUnit);
    public static AreaBaseShape ScaleUp(AreaBaseShape targetShape, double percentage);
    public static Feature ScaleUp(Feature targetFeature, double percentage);
    public void ScaleUp(double percentage);
    public double GetArea(int shapeSrid, AreaUnit returningUnit);
    public double GetArea(string shapeProjString, AreaUnit returningUnit);
    public double GetArea(Projection shapeProjection, AreaUnit returningUnit);
    public double GetArea(int shapeSrid, AreaUnit returningUnit, DistanceCalculationMode distanceCalculationMode);
    public double GetArea(string shapeProjString, AreaUnit returningUnit, DistanceCalculationMode distanceCalculationMode);
    public double GetArea(Projection shapeProjection, AreaUnit returningUnit, DistanceCalculationMode distanceCalculationMode);
    protected virtual double GetAreaCore(Projection shapeProjection, AreaUnit returningUnit, DistanceCalculationMode distanceCalculationMode);
    public double GetPerimeter(int shapeSrid, DistanceUnit returningUnit);
    public double GetPerimeter(string shapeProjString, DistanceUnit returningUnit);
    public double GetPerimeter(Projection shapeProjection, DistanceUnit returningUnit);
    public double GetPerimeter(int shapeSrid, DistanceUnit returningUnit, DistanceCalculationMode distanceCalculationMode);
    public double GetPerimeter(string shapeProjString, DistanceUnit returningUnit, DistanceCalculationMode distanceCalculationMode);
    public double GetPerimeter(Projection shapeProjection, DistanceUnit returningUnit, DistanceCalculationMode distanceCalculationMode);
    protected virtual double GetPerimeterCore(Projection shapeProjection, DistanceUnit returningUnit, DistanceCalculationMode distanceCalculationMode);
    protected virtual void ScaleUpCore(double percentage);
    public static AreaBaseShape ScaleDown(AreaBaseShape targetShape, double percentage);
    public static Feature ScaleDown(Feature targetFeature, double percentage);
    public void ScaleDown(double percentage);
    protected virtual void ScaleDownCore(double percentage);
    public RingShape GetConvexHull();
    protected virtual RingShape GetConvexHullCore();
    public MultipolygonShape GetIntersection(AreaBaseShape targetShape);
    public MultipolygonShape GetIntersection(Feature targetFeature);
    protected virtual MultipolygonShape GetIntersectionCore(AreaBaseShape targetShape);
    public virtual MultipolygonShape Union(AreaBaseShape targetShape);
    public MultipolygonShape Union(Feature targetFeature);
    protected virtual MultipolygonShape UnionCore(AreaBaseShape targetShape);
    public static MultipolygonShape Union(IEnumerable`1<Feature> targetFeatures);
    public static MultipolygonShape Union(IEnumerable`1<AreaBaseShape> areaShapes);
    private static MultipolygonShape kxo=(IEnumerable`1<BaseShape> areaShapes, bool isPrivate);
    private static BaseShape lBo=(IEnumerable`1<BaseShape> areaShapes, int count);
    public MultipolygonShape GetDifference(AreaBaseShape targetShape);
    public MultipolygonShape GetDifference(Feature targetFeature);
    protected virtual MultipolygonShape GetDifferenceCore(AreaBaseShape targetShape);
    public MultipolygonShape GetSymmetricalDifference(AreaBaseShape targetShape);
    public MultipolygonShape GetSymmetricalDifference(Feature targetFeature);
    protected virtual MultipolygonShape GetSymmetricalDifferenceCore(AreaBaseShape targetShape);
    public static Collection`1<MultipolygonShape> Split(AreaBaseShape areaToSplit, AreaBaseShape areaToSplitBy);
    public static Collection`1<Feature> Split(Feature areaToSplit, Feature areaToSplitBy);
    public static MultipolygonShape Simplify(AreaBaseShape targetShape, GeographyUnit targetShapeUnit, double tolerance, DistanceUnit toleranceUnit, SimplificationType simplificationType);
    public static MultipolygonShape Simplify(AreaBaseShape targetShape, double tolerance, SimplificationType simplificationType);
    public MultipolygonShape Simplify(GeographyUnit shapeUnit, double tolerance, DistanceUnit toleranceUnit, SimplificationType simplificationType);
    public MultipolygonShape Simplify(double tolerance, SimplificationType simplificationType);
    protected virtual MultipolygonShape SimplifyCore(double tolerance, SimplificationType simplificationType);
    private static void lRo=(MultipolygonShape returnMultipolygon, GeometryCollection geometryCollection);
    private void JBU=(double factor);
    public static Collection`1<PolygonShape> Snap(IEnumerable`1<AreaBaseShape> shapes, GeographyUnit shapeUnit, double snappingTolerance, DistanceUnit toleranceUnit);
    private static bool lho=(IEnumerable`1<PolygonShape> polygonShapes, double tolerance);
    private static bool lxo=(Collection`1<PolygonShape> polygons, double tolerance);
    private static bool mBo=(IEnumerable`1<PolygonShape> polygons, PolygonShape polygon, RingShape ringShape, double tolerance, STRtree`1<BaseShape> rTree, Collection`1<Vertex> checkedVertices, double squareTolerance, Boolean& noClusterTolerance);
    private static void mRo=(string id, Vertex vertex, IList`1<BaseShape> intersectingPolys);
    private static bool mho=(Vertex currentVertex, PolygonShape currentPolygonShape, int currentVertexIndex, PolygonShape closestPolygonShape, PointShape closestPoint);
    private static void mxo=(Vertex currentVertex, RingShape currentRing, int currentVertexIndex, RingShape closestRing, PointShape closestPoint, Boolean& updateSucceed);
    private static bool nBo=(PolygonShape polygonShape, PolygonShape intersectingPolygon);
    private static bool nRo=(RingShape polygonRing, RingShape intersectingRing);
    private static bool mxo=(IEnumerable`1<PolygonShape> polygonShapes, RingShape ringShape, double tolerance, Collection`1<Vertex> checkedVertices, Collection`1<Vertex> updatedVertices, STRtree`1<BaseShape> rTree, Boolean& noClusterTolerance);
    private static bool nho=(IEnumerable`1<PolygonShape> polygonShapes, RingShape ringShape, Vertex vertex, double squareTolerance, Feature feature, Collection`1<PointShape> pendingUpdatedVertex, Collection`1<KeyValuePair`2<RingShape, int>> pendingUpdatedVertexIndex);
    private static void nxo=(Collection`1<KeyValuePair`2<RingShape, int>> ringsCache, Vertex newVertex);
}
public class ThinkGeo.Core.AreaFilterCondition : FilterCondition {
    [ObfuscationAttribute]
private AreaUnit caculatedAreaUnit;
    private GeographyUnit TDE=;
    public AreaUnit AreaUnit { get; public set; }
    public GeographyUnit GeographyUnit { get; public set; }
    public AreaFilterCondition(AreaUnit areaUnit);
    public AreaUnit get_AreaUnit();
    public void set_AreaUnit(AreaUnit value);
    public GeographyUnit get_GeographyUnit();
    public void set_GeographyUnit(GeographyUnit value);
    internal virtual bool 3yI=(Feature feature);
}
public class ThinkGeo.Core.AreaStyle : Style {
    [ObfuscationAttribute]
private Collection`1<AreaStyle> customAreaStyles;
    [ObfuscationAttribute]
private GeoBrush fillBrush;
    [ObfuscationAttribute]
private GeoPen outlinePen;
    [ObfuscationAttribute]
private PenBrushDrawingOrder penBrushDrawingOrder;
    [ObfuscationAttribute]
private float xOffsetInPixel;
    [ObfuscationAttribute]
private float yOffsetInPixel;
    [ObfuscationAttribute]
private DrawingLevel drawingLevel;
    [CompilerGeneratedAttribute]
private AreaStyle hzA=;
    public float XOffsetInPixel { get; public set; }
    public float YOffsetInPixel { get; public set; }
    public GeoBrush FillBrush { get; public set; }
    public Collection`1<AreaStyle> CustomAreaStyles { get; }
    public GeoPen OutlinePen { get; public set; }
    public PenBrushDrawingOrder PenBrushDrawingOrder { get; public set; }
    public DrawingLevel DrawingLevel { get; public set; }
    internal AreaStyle ijA= { get; internal set; }
    internal bool fBU= { get; }
    public AreaStyle(GeoBrush fillBrush);
    public AreaStyle(GeoPen outlinePen);
    public AreaStyle(GeoPen outlinePen, GeoBrush fillBrush);
    public AreaStyle(GeoPen outlinePen, GeoBrush fillBrush, PenBrushDrawingOrder penBrushDrawingOrder);
    public float get_XOffsetInPixel();
    public void set_XOffsetInPixel(float value);
    public float get_YOffsetInPixel();
    public void set_YOffsetInPixel(float value);
    public GeoBrush get_FillBrush();
    public void set_FillBrush(GeoBrush value);
    public Collection`1<AreaStyle> get_CustomAreaStyles();
    public GeoPen get_OutlinePen();
    public void set_OutlinePen(GeoPen value);
    public PenBrushDrawingOrder get_PenBrushDrawingOrder();
    public void set_PenBrushDrawingOrder(PenBrushDrawingOrder value);
    public DrawingLevel get_DrawingLevel();
    public void set_DrawingLevel(DrawingLevel value);
    [CompilerGeneratedAttribute]
internal AreaStyle iDA=();
    [CompilerGeneratedAttribute]
internal void iTA=(AreaStyle value);
    internal virtual bool ehU=();
    public static AreaStyle Parse(string styleJson);
    internal static AreaStyle ahU=(JObject jObject);
    public static AreaStyle CreateSimpleAreaStyle(GeoColor fillBrushColor);
    public static AreaStyle CreateSimpleAreaStyle(GeoColor fillBrushColor, GeoColor outlinePenColor);
    public static AreaStyle CreateSimpleAreaStyle(GeoColor fillBrushColor, GeoColor outlinePenColor, int outlinePenWidth);
    public static AreaStyle CreateSimpleAreaStyle(GeoColor fillBrushColor, GeoColor outlinePenColor, int outlinePenWidth, LineDashStyle borderStyle);
    public static AreaStyle CreateSimpleAreaStyle(GeoColor fillBrushColor, float xOffsetInPixel, float yOffsetInPixel);
    public static AreaStyle CreateSimpleAreaStyle(GeoColor fillBrushColor, GeoColor outlinePenColor, float xOffsetInPixel, float yOffsetInPixel);
    public static AreaStyle CreateSimpleAreaStyle(GeoColor fillBrushColor, GeoColor outlinePenColor, int outlinePenWidth, float xOffsetInPixel, float yOffsetInPixel);
    public static AreaStyle CreateSimpleAreaStyle(GeoColor fillBrushColor, GeoColor outlinePenColor, int outlinePenWidth, LineDashStyle borderStyle, float xOffsetInPixel, float yOffsetInPixel);
    public static AreaStyle CreateHatchStyle(GeoHatchStyle hatchStyle, GeoColor foregroundBrushColor, GeoColor backgroundBrushColor);
    public static AreaStyle CreateHatchStyle(GeoHatchStyle hatchStyle, GeoColor foregroundBrushColor, GeoColor backgroundBrushColor, GeoColor outlinePenColor);
    public static AreaStyle CreateHatchStyle(GeoHatchStyle hatchStyle, GeoColor foregroundBrushColor, GeoColor backgroundColor, GeoColor outlinePenColor, int outlinePenWidth, LineDashStyle outlineDashStyle, float xOffsetInPixel, float yOffsetInPixel);
    public static AreaStyle CreateLinearGradientStyle(GeoColor fromColor, GeoColor toColor, float angle);
    public static AreaStyle CreateLinearGradientStyle(GeoColor fromColor, GeoColor toColor, float angle, GeoColor outlinePenColor);
    public static AreaStyle CreateHueFamilyAreaStyle(GeoColor outlinePenColor, GeoColor baseColor, int numberOfColors);
    public static AreaStyle CreateHueFamilyLinearGradientAreaStyle(GeoColor outlinePenColor, GeoColor baseColor, int numberOfColors, GeoColor fromColor, GeoColor toColor, float angle);
    public static AreaStyle CreateQualityFamilyAreaStyle(GeoColor outlinePenColor, GeoColor baseColor, int numberOfColors);
    public static AreaStyle CreateQualityFamilyLinearGradientAreaStyle(GeoColor outlinePenColor, GeoColor baseColor, int numberOfColors, GeoColor fromColor, GeoColor toColor, float angle);
    protected virtual void DrawCore(IEnumerable`1<Feature> features, GeoCanvas canvas, Collection`1<SimpleCandidate> labelsInThisLayer, Collection`1<SimpleCandidate> labelsInAllLayers);
    private void izA=(GeoCanvas canvas, Collection`1<SimpleCandidate> labelsInThisLayer, Collection`1<SimpleCandidate> labelsInAllLayers, IEnumerable`1<Feature> featureList);
    private GeoPen jDA=();
    protected virtual void DrawSampleCore(GeoCanvas canvas, DrawingRectangleF drawingExtent);
    private static List`1<Feature> jTA=(RectangleShape currentExtent, IEnumerable`1<Feature> featureList);
    private static bool jjA=(AreaBaseShape currentAreaShape);
    private static GeoPen jzA=(String[] valueExpressions);
    private static GeoBrush kDA=(String[] valueExpressions);
}
public enum ThinkGeo.Core.AreaUnit : Enum {
    public int value__;
    public static AreaUnit Acres;
    public static AreaUnit SquareMeters;
    public static AreaUnit Hectares;
    public static AreaUnit SquareFeet;
    public static AreaUnit SquareKilometers;
    public static AreaUnit SquareMiles;
    public static AreaUnit SquareUsSurveyFeet;
    public static AreaUnit SquareYards;
}
[ObsoleteAttribute("This class is obsoleted and will be removed after v14.3, please use ThinkGeo.Core.ArcGisServerRestAsyncLayer instead")]
public class ThinkGeo.Core.Async.ArcGisServerRestLayer : WebBasedLayer {
    [ObfuscationAttribute]
private Dictionary`2<string, string> parameters;
    [ObfuscationAttribute]
private ArcGISServerRestLayerImageFormat imageFormat;
    [ObfuscationAttribute]
private bool enableImageFormat;
    [CompilerGeneratedAttribute]
private Uri qB0=;
    public Uri ServerUri { get; public set; }
    public Dictionary`2<string, string> Parameters { get; }
    public ArcGISServerRestLayerImageFormat ImageFormat { get; public set; }
    public ArcGisServerRestLayer(Uri serverUri);
    public ArcGisServerRestLayer(Uri serverUri, IWebProxy webProxy);
    [CompilerGeneratedAttribute]
public Uri get_ServerUri();
    [CompilerGeneratedAttribute]
public void set_ServerUri(Uri value);
    public Dictionary`2<string, string> get_Parameters();
    public ArcGISServerRestLayerImageFormat get_ImageFormat();
    public void set_ImageFormat(ArcGISServerRestLayerImageFormat value);
    [AsyncStateMachineAttribute("ThinkGeo.Core.Async.ArcGisServerRestLayer/<DrawAsyncCore>d__15")]
protected virtual Task DrawAsyncCore(GeoCanvas canvas, Collection`1<SimpleCandidate> labelsInAllLayers);
    private string qR0=(Dictionary`2<string, string> tempDictionary);
}
[ObsoleteAttribute("This class is obsoleted and will be removed after v14.3, please use ThinkGeo.Core.BingMapsAsyncLayer instead")]
public class ThinkGeo.Core.Async.BingMapsLayer : XyzTileLayer {
    private static int rx0=;
    private static string sB0=;
    private static string sR0=;
    [ObfuscationAttribute]
private string applicationId;
    [ObfuscationAttribute]
private BingMapsMapType mapType;
    [ObfuscationAttribute]
private string imageUriTemplate;
    [ObfuscationAttribute]
private Collection`1<string> subDomains;
    [ObfuscationAttribute]
private GeoImage logo;
    [ObfuscationAttribute]
private bool isDirty;
    [ObfuscationAttribute]
private RequestProtocol httpRequestProtocol;
    public string ApplicationId { get; public set; }
    public BingMapsMapType MapType { get; public set; }
    public GeoImage Logo { get; }
    public RequestProtocol HttpRequestProtocol { get; public set; }
    public BingMapsLayer(string applicationId);
    public BingMapsLayer(string applicationId, BingMapsMapType mapType);
    private static BingMapsLayer();
    [AsyncStateMachineAttribute("ThinkGeo.Core.Async.BingMapsLayer/<OpenAsyncCore>d__13")]
protected virtual Task OpenAsyncCore(CancellationToken cancellationToken);
    public string get_ApplicationId();
    public void set_ApplicationId(string value);
    public BingMapsMapType get_MapType();
    public void set_MapType(BingMapsMapType value);
    public GeoImage get_Logo();
    public RequestProtocol get_HttpRequestProtocol();
    public void set_HttpRequestProtocol(RequestProtocol value);
    [AsyncStateMachineAttribute("ThinkGeo.Core.Async.BingMapsLayer/<DrawAsyncCore>d__25")]
protected virtual Task DrawAsyncCore(GeoCanvas canvas, Collection`1<SimpleCandidate> labelsInAllLayers);
    [AsyncStateMachineAttribute("ThinkGeo.Core.Async.BingMapsLayer/<GetImageUriAsyncCore>d__26")]
protected virtual Task`1<string> GetImageUriAsyncCore(int zoomLevel, long x, long y, float resolutionFactor);
    private static string sh0=(long tileX, long tileY, int levelOfDetail);
    [AsyncStateMachineAttribute("ThinkGeo.Core.Async.BingMapsLayer/<ValidateAsync>d__28")]
private Task sx0=();
    [AsyncStateMachineAttribute("ThinkGeo.Core.Async.BingMapsLayer/<RequestXmlAsync>d__29")]
private Task`1<XmlDocument> tB0=(string xmlPath);
    [CompilerGeneratedAttribute]
[DebuggerHiddenAttribute]
private Task <>n__0(CancellationToken cancellationToken);
    [CompilerGeneratedAttribute]
[DebuggerHiddenAttribute]
private Task <>n__1(GeoCanvas canvas, Collection`1<SimpleCandidate> labelsInAllLayers);
}
[ObsoleteAttribute("This class is obsoleted and will be removed after v14.3, please use ThinkGeo.Core.GoogleMapsAsyncLayer instead")]
public class ThinkGeo.Core.Async.GoogleMapsLayer : WebBasedLayer {
    private static RectangleShape 1B0=;
    [ObfuscationAttribute]
private ProjectionConverter projectionFromSphericalMercator;
    [ObfuscationAttribute]
private ProjectionConverter googleWgs84Projection;
    [ObfuscationAttribute]
private double currentRequestSphereResolution;
    [CompilerGeneratedAttribute]
private GoogleMapsPictureFormat 1R0=;
    [CompilerGeneratedAttribute]
private GoogleMapsMapType 1h0=;
    [CompilerGeneratedAttribute]
private string 1x0=;
    [CompilerGeneratedAttribute]
private string uB0=;
    [CompilerGeneratedAttribute]
private string 2B0=;
    [CompilerGeneratedAttribute]
private string 2R0=;
    [CompilerGeneratedAttribute]
private string 2h0=;
    [CompilerGeneratedAttribute]
private Dictionary`2<string, string> 2x0=;
    [CompilerGeneratedAttribute]
private Projection 3B0=;
    public GoogleMapsPictureFormat PictureFormat { get; public set; }
    public GoogleMapsMapType MapType { get; public set; }
    public string Language { get; public set; }
    public string ClientId { get; public set; }
    public string PrivateKey { get; public set; }
    public string UriSigningSecret { get; public set; }
    public string ApiKey { get; public set; }
    public Dictionary`2<string, string> CustomParameters { get; }
    public Projection TargetProjection { get; public set; }
    public GoogleMapsLayer(string apiKey);
    public GoogleMapsLayer(string apiKey, string uriSigningSecret);
    private static GoogleMapsLayer();
    [CompilerGeneratedAttribute]
public GoogleMapsPictureFormat get_PictureFormat();
    [CompilerGeneratedAttribute]
public void set_PictureFormat(GoogleMapsPictureFormat value);
    [CompilerGeneratedAttribute]
public GoogleMapsMapType get_MapType();
    [CompilerGeneratedAttribute]
public void set_MapType(GoogleMapsMapType value);
    [CompilerGeneratedAttribute]
public string get_Language();
    [CompilerGeneratedAttribute]
public void set_Language(string value);
    [CompilerGeneratedAttribute]
public string get_ClientId();
    [CompilerGeneratedAttribute]
public void set_ClientId(string value);
    [CompilerGeneratedAttribute]
public string get_PrivateKey();
    [CompilerGeneratedAttribute]
public void set_PrivateKey(string value);
    [CompilerGeneratedAttribute]
public string get_UriSigningSecret();
    [CompilerGeneratedAttribute]
public void set_UriSigningSecret(string value);
    [CompilerGeneratedAttribute]
public string get_ApiKey();
    [CompilerGeneratedAttribute]
public void set_ApiKey(string value);
    [CompilerGeneratedAttribute]
public Dictionary`2<string, string> get_CustomParameters();
    [CompilerGeneratedAttribute]
public Projection get_TargetProjection();
    [CompilerGeneratedAttribute]
public void set_TargetProjection(Projection value);
    [AsyncStateMachineAttribute("ThinkGeo.Core.Async.GoogleMapsLayer/<OpenAsyncCore>d__42")]
protected virtual Task OpenAsyncCore(CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("ThinkGeo.Core.Async.GoogleMapsLayer/<CloseAsyncCore>d__43")]
protected virtual Task CloseAsyncCore(CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("ThinkGeo.Core.Async.GoogleMapsLayer/<DrawAsyncCore>d__44")]
protected virtual Task DrawAsyncCore(GeoCanvas canvas, Collection`1<SimpleCandidate> labelsInAllLayers);
    [AsyncStateMachineAttribute("ThinkGeo.Core.Async.GoogleMapsLayer/<DownloadImageAsyncCore>d__45")]
protected virtual Task`1<Byte[]> DownloadImageAsyncCore(double width, double height, double scaleFactor, RectangleShape extent, GeographyUnit mapUnit, CancellationToken cancellationToken);
    private RectangleShape 3R0=(GeoCanvas canvas);
    private string 3h0=(double latitude, double longitude, int zoomLevelNumber, double tileWidth, double tileHeight, int scaleFactor);
    private static string 3x0=(double newWidth, double newHeight, int zoomLevelNumber, double latitude, double longitude);
    private string 4B0=();
    public string GetPictureFormat();
    private string 4R0=(string url);
    private string 4R0=(string url, string uriSigningSecret);
    private static Byte[] 4h0=(string value);
    [CompilerGeneratedAttribute]
[DebuggerHiddenAttribute]
private Task <>n__0(CancellationToken cancellationToken);
    [CompilerGeneratedAttribute]
[DebuggerHiddenAttribute]
private Task <>n__1(CancellationToken cancellationToken);
}
[ObsoleteAttribute("This class is obsoleted and will be removed after v14.3, please use ThinkGeo.Core.HereMapsRasterTileAsyncLayer instead")]
public class ThinkGeo.Core.Async.HereMapsRasterTileLayer : XyzTileLayer {
    private static int rx0=;
    private static string 4x0=;
    private string 5B0=;
    private string 5R0=;
    private string 5h0=;
    [CompilerGeneratedAttribute]
private string 2h0=;
    [CompilerGeneratedAttribute]
private HereMapsRasterType 1h0=;
    [CompilerGeneratedAttribute]
private HereMapsRasterTileFormat 5x0=;
    [CompilerGeneratedAttribute]
private Dictionary`2<string, string> 6B0=;
    public string ApiKey { get; public set; }
    public HereMapsRasterType MapType { get; public set; }
    public HereMapsRasterTileFormat Format { get; public set; }
    public Dictionary`2<string, string> Parameters { get; }
    public HereMapsRasterTileLayer(string apiKey);
    public HereMapsRasterTileLayer(string apiKey, HereMapsRasterType mapType);
    [CompilerGeneratedAttribute]
public string get_ApiKey();
    [CompilerGeneratedAttribute]
public void set_ApiKey(string value);
    [CompilerGeneratedAttribute]
public HereMapsRasterType get_MapType();
    [CompilerGeneratedAttribute]
public void set_MapType(HereMapsRasterType value);
    [CompilerGeneratedAttribute]
public HereMapsRasterTileFormat get_Format();
    [CompilerGeneratedAttribute]
public void set_Format(HereMapsRasterTileFormat value);
    [CompilerGeneratedAttribute]
public Dictionary`2<string, string> get_Parameters();
    protected virtual Task`1<string> GetImageUriAsyncCore(int zoomLevel, long x, long y, float resolutionFactor);
}
[ObsoleteAttribute("This class is obsoleted and will be removed after v14.3, please use ThinkGeo.Core.AsyncLayer instead")]
public abstract class ThinkGeo.Core.Async.LayerAsync : LayerBase {
    private Exception qh0=;
    [CompilerGeneratedAttribute]
private double qx0=;
    [CompilerGeneratedAttribute]
private double rB0=;
    public double UpperThreshold { get; public set; }
    public double LowerThreshold { get; public set; }
    [CompilerGeneratedAttribute]
public double get_UpperThreshold();
    [CompilerGeneratedAttribute]
public void set_UpperThreshold(double value);
    [CompilerGeneratedAttribute]
public double get_LowerThreshold();
    [CompilerGeneratedAttribute]
public void set_LowerThreshold(double value);
    [AsyncStateMachineAttribute("ThinkGeo.Core.Async.LayerAsync/<OpenAsync>d__10")]
public Task OpenAsync(CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("ThinkGeo.Core.Async.LayerAsync/<OpenAsyncCore>d__11")]
protected virtual Task OpenAsyncCore(CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("ThinkGeo.Core.Async.LayerAsync/<CloseAsync>d__12")]
public Task CloseAsync(CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("ThinkGeo.Core.Async.LayerAsync/<CloseAsyncCore>d__13")]
protected virtual Task CloseAsyncCore(CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("ThinkGeo.Core.Async.LayerAsync/<DrawAsync>d__14")]
public Task DrawAsync(GeoCanvas canvas, Collection`1<SimpleCandidate> labelsInAllLayers);
    [AsyncStateMachineAttribute("ThinkGeo.Core.Async.LayerAsync/<DrawTranslationAsync>d__15")]
private Task rR0=(GeoCanvas canvas, Collection`1<SimpleCandidate> labelsInAllLayers);
    protected abstract virtual Task DrawAsyncCore(GeoCanvas canvas, Collection`1<SimpleCandidate> labelsInAllLayers);
    private void rh0=(object sender, DrawingProgressChangedEventArgs e);
}
[ObsoleteAttribute("This class is obsoleted and will be removed after v14.3, please use ThinkGeo.Core.MapBoxStaticTilesAsyncLayer instead")]
public class ThinkGeo.Core.Async.MapBoxStaticTilesLayer : XyzTileLayer {
    private static int rx0=;
    [ObfuscationAttribute]
private MapBoxStyleId styleId;
    [ObfuscationAttribute]
private string baseUrl;
    [ObfuscationAttribute]
private string apiVersion;
    [CompilerGeneratedAttribute]
private string 6R0=;
    public string AccessToken { get; public set; }
    public MapBoxStyleId StyleId { get; public set; }
    public MapBoxStaticTilesLayer(string accessToken);
    public MapBoxStaticTilesLayer(string accessToken, MapBoxStyleId styleId);
    [CompilerGeneratedAttribute]
public string get_AccessToken();
    [CompilerGeneratedAttribute]
public void set_AccessToken(string value);
    public MapBoxStyleId get_StyleId();
    public void set_StyleId(MapBoxStyleId value);
    protected virtual Task`1<string> GetImageUriAsyncCore(int zoomLevel, long x, long y, float resolutionFactor);
    private string 6h0=();
    private void 6x0=(MapBoxStyleId id);
    private bool 7B0=(string cacheId);
    private string 7R0=(MapBoxStyleId id);
}
[ObsoleteAttribute("This class is obsoleted and will be removed after v14.3, please use ThinkGeo.Core.OpenStreetMapAsyncLayer instead")]
public class ThinkGeo.Core.Async.OpenStreetMapLayer : XyzTileLayer {
    [ObfuscationAttribute]
private static int TILE_SIZE;
    [ObfuscationAttribute]
private static Uri[] DefaultUris;
    [ObfuscationAttribute]
private Collection`1<Uri> customServerUris;
    public Collection`1<Uri> CustomServerUris { get; }
    public OpenStreetMapLayer(string userAgent);
    public OpenStreetMapLayer(IWebProxy webProxy);
    public OpenStreetMapLayer(string userAgent, IWebProxy webProxy);
    private static OpenStreetMapLayer();
    [AsyncStateMachineAttribute("ThinkGeo.Core.Async.OpenStreetMapLayer/<OpenAsyncCore>d__7")]
protected virtual Task OpenAsyncCore(CancellationToken cancellationToken);
    public Collection`1<Uri> get_CustomServerUris();
    protected virtual Task`1<string> GetImageUriAsyncCore(int zoomLevel, long x, long y, float resolutionFactor);
    [CompilerGeneratedAttribute]
[DebuggerHiddenAttribute]
private Task <>n__0(CancellationToken cancellationToken);
}
[ObsoleteAttribute("This class is obsoleted and will be removed after v14.3, please use ThinkGeo.Core.ThinkGeoRasterMapsAsyncLayer instead")]
public class ThinkGeo.Core.Async.ThinkGeoCloudRasterMapsLayer : XyzTileLayer {
    private static int rx0=;
    private tR0= 7h0=;
    private ThinkGeoCloudRasterMapsMapType 7x0=;
    public RasterTileCache TileCache { get; public set; }
    public RasterTileCache ProjectedTileCache { get; public set; }
    public ProjectionConverter ProjectionConverterFromServerProjection { get; public set; }
    public ThinkGeoCloudRasterMapsMapType MapType { get; public set; }
    public string ClientId { get; public set; }
    public string ClientSecret { get; public set; }
    public ThinkGeoCloudRasterMapsLayer(string clientId, string clientSecret);
    public ThinkGeoCloudRasterMapsLayer(string clientId, string clientSecret, ThinkGeoCloudRasterMapsMapType mapType);
    public virtual RasterTileCache get_TileCache();
    public virtual void set_TileCache(RasterTileCache value);
    public virtual RasterTileCache get_ProjectedTileCache();
    public virtual void set_ProjectedTileCache(RasterTileCache value);
    public virtual ProjectionConverter get_ProjectionConverterFromServerProjection();
    public virtual void set_ProjectionConverterFromServerProjection(ProjectionConverter value);
    public ThinkGeoCloudRasterMapsMapType get_MapType();
    public void set_MapType(ThinkGeoCloudRasterMapsMapType value);
    public string get_ClientId();
    public void set_ClientId(string value);
    public string get_ClientSecret();
    public void set_ClientSecret(string value);
    [AsyncStateMachineAttribute("ThinkGeo.Core.Async.ThinkGeoCloudRasterMapsLayer/<OpenAsyncCore>d__24")]
protected virtual Task OpenAsyncCore(CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("ThinkGeo.Core.Async.ThinkGeoCloudRasterMapsLayer/<CloseAsyncCore>d__25")]
protected virtual Task CloseAsyncCore(CancellationToken cancellationToken);
    protected virtual Task`1<string> GetImageUriAsyncCore(int zoomLevel, long x, long y, float resolutionFactor);
    [AsyncStateMachineAttribute("ThinkGeo.Core.Async.ThinkGeoCloudRasterMapsLayer/<ThinkGeoCloudRasterMapsLayer2_SendingHttpRequest>d__27")]
private void 8B0=(object sender, SendingHttpRequestMessageEventArgs e);
    private void 6x0=();
    private string 8R0=(string cacheIdWithSuffix);
    protected virtual int GetTileScale();
    private string 8h0=();
    private string 8x0=(ThinkGeoCloudRasterMapsMapType mapType);
    private string 9B0=(ThinkGeoCloudRasterMapsMapType mapType);
    private string 9R0=(ThinkGeoCloudRasterMapsMapType mapType);
    private GeoImageFormat uBY=(ThinkGeoCloudRasterMapsMapType mapType);
    [CompilerGeneratedAttribute]
[DebuggerHiddenAttribute]
private Task <>n__0(CancellationToken cancellationToken);
    [CompilerGeneratedAttribute]
[DebuggerHiddenAttribute]
private Task <>n__1(CancellationToken cancellationToken);
}
[ObsoleteAttribute("This class is obsoleted and will be removed after v14.3, please use ThinkGeo.Core.ThinkGeoVectorMapsAsyncLayer instead")]
public class ThinkGeo.Core.Async.ThinkGeoCloudVectorMapsLayer : WebBasedLayer {
    private static int 9h0=;
    [ObfuscationAttribute]
private Uri styleJsonUri;
    [ObfuscationAttribute]
private RasterTileCache bitmapTileCache;
    private ZoomLevelSet 9x0=;
    private tR0= 7h0=;
    private ThinkGeoCloudVectorMapsMapType 7x0=;
    private FileVectorTileCache /B0=;
    private ProjectionConverter /R0=;
    [CompilerGeneratedAttribute]
private bool /h0=;
    [CompilerGeneratedAttribute]
private int /x0=;
    private bool AB4=;
    public bool ShowDebugInfo { get; public set; }
    public int TileSize { get; public set; }
    public string ClientId { get; public set; }
    public string ClientSecret { get; public set; }
    public ThinkGeoCloudVectorMapsMapType MapType { get; public set; }
    public FileVectorTileCache VectorTileCache { get; public set; }
    public RasterTileCache BitmapTileCache { get; public set; }
    public Uri StyleJsonUri { get; public set; }
    public ProjectionConverter ProjectionConverter { get; public set; }
    public ThinkGeoCloudVectorMapsLayer(string clientId, string clientSecret);
    public ThinkGeoCloudVectorMapsLayer(string clientId, string clientSecret, Uri styleJsonUri);
    public ThinkGeoCloudVectorMapsLayer(string clientId, string clientSecret, ThinkGeoCloudVectorMapsMapType mapType);
    [CompilerGeneratedAttribute]
public bool get_ShowDebugInfo();
    [CompilerGeneratedAttribute]
public void set_ShowDebugInfo(bool value);
    [CompilerGeneratedAttribute]
public int get_TileSize();
    [CompilerGeneratedAttribute]
public void set_TileSize(int value);
    public string get_ClientId();
    public void set_ClientId(string value);
    public string get_ClientSecret();
    public void set_ClientSecret(string value);
    public ThinkGeoCloudVectorMapsMapType get_MapType();
    public void set_MapType(ThinkGeoCloudVectorMapsMapType value);
    public FileVectorTileCache get_VectorTileCache();
    public void set_VectorTileCache(FileVectorTileCache value);
    public RasterTileCache get_BitmapTileCache();
    public void set_BitmapTileCache(RasterTileCache value);
    public Uri get_StyleJsonUri();
    public void set_StyleJsonUri(Uri value);
    public ProjectionConverter get_ProjectionConverter();
    public void set_ProjectionConverter(ProjectionConverter value);
    [AsyncStateMachineAttribute("ThinkGeo.Core.Async.ThinkGeoCloudVectorMapsLayer/<OpenAsyncCore>d__42")]
protected virtual Task OpenAsyncCore(CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("ThinkGeo.Core.Async.ThinkGeoCloudVectorMapsLayer/<CloseAsyncCore>d__43")]
protected virtual Task CloseAsyncCore(CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("ThinkGeo.Core.Async.ThinkGeoCloudVectorMapsLayer/<GetFeaturesFromPbfVectorTileAsync>d__44")]
private Task`1<Collection`1<Feature>> AR4=(int zoom, long column, long row, List`1<string> pbfLayerNames, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("ThinkGeo.Core.Async.ThinkGeoCloudVectorMapsLayer/<GetPbfVectorTileAsync>d__45")]
private Task`1<VectorTile> Ah4=(int zoom, long column, long row, CancellationToken cancellationToken);
    private void Ax4=();
    [AsyncStateMachineAttribute("ThinkGeo.Core.Async.ThinkGeoCloudVectorMapsLayer/<DrawTileAsync>d__47")]
public Task DrawTileAsync(GeoCanvas canvas, int zoomIndex, long columnIndex, long rowIndex);
    [AsyncStateMachineAttribute("ThinkGeo.Core.Async.ThinkGeoCloudVectorMapsLayer/<DrawAsyncCore>d__48")]
protected virtual Task DrawAsyncCore(GeoCanvas canvas, Collection`1<SimpleCandidate> labelsInAllLayers);
    private void 6x0=(ThinkGeoCloudVectorMapsMapType mapType);
    private bool 7B0=(string cacheId);
    [CompilerGeneratedAttribute]
[DebuggerHiddenAttribute]
private Task <>n__0(CancellationToken cancellationToken);
    [CompilerGeneratedAttribute]
[DebuggerHiddenAttribute]
private Task <>n__1(CancellationToken cancellationToken);
}
[ObsoleteAttribute("This class is obsoleted and will be removed after v14.3, please use ThinkGeo.Core.WebBasedAsyncLayer instead")]
public abstract class ThinkGeo.Core.Async.WebBasedLayer : LayerAsync {
    [CompilerGeneratedAttribute]
private EventHandler`1<SendingHttpRequestMessageEventArgs> SendingHttpRequest;
    [CompilerGeneratedAttribute]
private EventHandler`1<ReceivedHttpResponseMessageEventArgs> ReceivedHttpResponse;
    [CompilerGeneratedAttribute]
private HttpClient BB4=;
    [CompilerGeneratedAttribute]
private IWebProxy ux0=;
    [CompilerGeneratedAttribute]
private int uh0=;
    [CompilerGeneratedAttribute]
private ICredentials BR4=;
    [CompilerGeneratedAttribute]
private string Bh4=;
    protected HttpClient HttpClient { get; protected set; }
    public IWebProxy WebProxy { get; public set; }
    public int TimeoutInSeconds { get; public set; }
    public ICredentials Credentials { get; public set; }
    public string UserAgent { get; public set; }
    [CompilerGeneratedAttribute]
public void add_SendingHttpRequest(EventHandler`1<SendingHttpRequestMessageEventArgs> value);
    [CompilerGeneratedAttribute]
public void remove_SendingHttpRequest(EventHandler`1<SendingHttpRequestMessageEventArgs> value);
    [CompilerGeneratedAttribute]
public void add_ReceivedHttpResponse(EventHandler`1<ReceivedHttpResponseMessageEventArgs> value);
    [CompilerGeneratedAttribute]
public void remove_ReceivedHttpResponse(EventHandler`1<ReceivedHttpResponseMessageEventArgs> value);
    [CompilerGeneratedAttribute]
protected HttpClient get_HttpClient();
    [CompilerGeneratedAttribute]
protected void set_HttpClient(HttpClient value);
    [CompilerGeneratedAttribute]
public sealed virtual IWebProxy get_WebProxy();
    [CompilerGeneratedAttribute]
public sealed virtual void set_WebProxy(IWebProxy value);
    [CompilerGeneratedAttribute]
public sealed virtual int get_TimeoutInSeconds();
    [CompilerGeneratedAttribute]
public sealed virtual void set_TimeoutInSeconds(int value);
    [AsyncStateMachineAttribute("ThinkGeo.Core.Async.WebBasedLayer/<OpenAsyncCore>d__18")]
protected virtual Task OpenAsyncCore(CancellationToken cancellationToken);
    [CompilerGeneratedAttribute]
public sealed virtual ICredentials get_Credentials();
    [CompilerGeneratedAttribute]
public sealed virtual void set_Credentials(ICredentials value);
    [AsyncStateMachineAttribute("ThinkGeo.Core.Async.WebBasedLayer/<SendWebRequestAsync>d__23")]
protected Task`1<HttpResponseMessage> SendWebRequestAsync(HttpRequestMessage httpRequest, CancellationToken cancellationToken);
    [CompilerGeneratedAttribute]
public sealed virtual string get_UserAgent();
    [CompilerGeneratedAttribute]
public sealed virtual void set_UserAgent(string value);
    public Task`1<Byte[]> FetchImageAsync(HttpRequestMessage requestMessage, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("ThinkGeo.Core.Async.WebBasedLayer/<FetchImageAsyncCore>d__29")]
protected Task`1<Byte[]> FetchImageAsyncCore(HttpRequestMessage requestMessage, CancellationToken cancellationToken);
    public Task`1<Byte[]> DownloadImageAsync(double width, double height, double scaleFactor, RectangleShape extent, GeographyUnit mapUnit, CancellationToken cancellationToken);
    protected virtual Task`1<Byte[]> DownloadImageAsyncCore(double width, double height, double scaleFactor, RectangleShape extent, GeographyUnit mapUnit, CancellationToken cancellationToken);
    protected virtual void OnSendingHttpRequestMessage(SendingHttpRequestMessageEventArgs e);
    protected virtual void OnReceivedHttpResponseMessage(ReceivedHttpResponseMessageEventArgs e);
    [CompilerGeneratedAttribute]
[DebuggerHiddenAttribute]
private Task <>n__0(CancellationToken cancellationToken);
}
[ObsoleteAttribute("This class is obsoleted and will be removed after v14.3, please use ThinkGeo.Core.WmsAsyncLayer instead")]
public class ThinkGeo.Core.Async.WmsLayer : WebBasedLayer {
    private XmlDocument Bx4=;
    [ObfuscationAttribute]
private string _crs;
    [ObfuscationAttribute]
private String[] _exceptionFormats;
    [ObfuscationAttribute]
private RectangleShape _currentExtent;
    [ObfuscationAttribute]
private WmsOnlineResource[] _wmsRequests;
    [ObfuscationAttribute]
private bool _hasParsedCapabilities;
    [ObfuscationAttribute]
private Collection`1<string> _serverCrsCollection;
    [ObfuscationAttribute]
private Collection`1<string> _serverLayerNames;
    [ObfuscationAttribute]
private Collection`1<string> _serverOutputFormats;
    [ObfuscationAttribute]
private Collection`1<string> _serverFeatureInfoFormats;
    [ObfuscationAttribute]
private Collection`1<string> _serverStyleNames;
    [ObfuscationAttribute]
private string _version;
    [ObfuscationAttribute]
private int _height;
    [ObfuscationAttribute]
private int _width;
    private WmsServerLayer CB4=;
    private Collection`1<WmsServerLayer> CR4=;
    [ObfuscationAttribute]
private Uri _uri;
    [ObfuscationAttribute]
private WmsAxisOrder _axisOrder;
    [ObfuscationAttribute]
private string _hrefNamespace;
    [ObfuscationAttribute]
private String[] _availableHrefNamespace;
    [ObfuscationAttribute]
private bool _fastMode;
    private static object Ch4=;
    [CompilerGeneratedAttribute]
private EventHandler`1<RequestedImageExceptionEventArgs> RequestedImageException;
    [CompilerGeneratedAttribute]
private Collection`1<string> Cx4=;
    [CompilerGeneratedAttribute]
private Collection`1<string> DB4=;
    [CompilerGeneratedAttribute]
private bool DR4=;
    [CompilerGeneratedAttribute]
private string Dh4=;
    [CompilerGeneratedAttribute]
private string Dx4=;
    [CompilerGeneratedAttribute]
private Dictionary`2<string, string> 6B0=;
    [CompilerGeneratedAttribute]
private TimeSpan EB4=;
    public Collection`1<string> ActiveLayerNames { get; }
    public Collection`1<string> ActiveStyleNames { get; }
    public Uri Uri { get; public set; }
    public string Version { get; }
    public bool IsTransparent { get; public set; }
    public string OutputFormat { get; public set; }
    public string Crs { get; public set; }
    public string Exceptions { get; public set; }
    public Dictionary`2<string, string> Parameters { get; }
    public WmsAxisOrder AxisOrder { get; public set; }
    public bool FastMode { get; public set; }
    public TimeSpan CapabilitiesCacheTimeout { get; public set; }
    public bool HasBoundingBox { get; }
    public WmsLayer(Uri uri);
    public WmsLayer(Uri uri, IWebProxy webProxy);
    public WmsLayer(Uri uri, IWebProxy webProxy, string crs, WmsAxisOrder axisOrder, string version, bool fastMode);
    public WmsLayer(Collection`1<WmsServerLayer> flatWmsServerLayers);
    private static WmsLayer();
    [CompilerGeneratedAttribute]
public void add_RequestedImageException(EventHandler`1<RequestedImageExceptionEventArgs> value);
    [CompilerGeneratedAttribute]
public void remove_RequestedImageException(EventHandler`1<RequestedImageExceptionEventArgs> value);
    protected virtual void OnRequestedImageException(RequestedImageExceptionEventArgs e);
    [CompilerGeneratedAttribute]
public sealed virtual Collection`1<string> get_ActiveLayerNames();
    [CompilerGeneratedAttribute]
public sealed virtual Collection`1<string> get_ActiveStyleNames();
    public sealed virtual Uri get_Uri();
    public sealed virtual void set_Uri(Uri value);
    public sealed virtual string get_Version();
    [CompilerGeneratedAttribute]
public sealed virtual bool get_IsTransparent();
    [CompilerGeneratedAttribute]
public sealed virtual void set_IsTransparent(bool value);
    [CompilerGeneratedAttribute]
public sealed virtual string get_OutputFormat();
    [CompilerGeneratedAttribute]
public sealed virtual void set_OutputFormat(string value);
    public sealed virtual string get_Crs();
    public sealed virtual void set_Crs(string value);
    [CompilerGeneratedAttribute]
public sealed virtual string get_Exceptions();
    [CompilerGeneratedAttribute]
public sealed virtual void set_Exceptions(string value);
    [CompilerGeneratedAttribute]
public sealed virtual Dictionary`2<string, string> get_Parameters();
    public sealed virtual WmsAxisOrder get_AxisOrder();
    public sealed virtual void set_AxisOrder(WmsAxisOrder value);
    public sealed virtual bool get_FastMode();
    public sealed virtual void set_FastMode(bool value);
    [CompilerGeneratedAttribute]
public sealed virtual TimeSpan get_CapabilitiesCacheTimeout();
    [CompilerGeneratedAttribute]
public sealed virtual void set_CapabilitiesCacheTimeout(TimeSpan value);
    public virtual bool get_HasBoundingBox();
    public Collection`1<WmsServerLayer> GetServerLayers();
    public Collection`1<string> GetServerStyleNames();
    public Collection`1<string> GetServerOutputFormats();
    public Collection`1<string> GetServerCrsCollection();
    public Collection`1<string> GetServerExceptionFormats();
    public string GetServiceVersion();
    public string GetServiceBaseUrl();
    public Collection`1<string> GetServerFeatureInfoFormats();
    public string GetServerCapabilitiesXml();
    public string GetRequestUrl(RectangleShape worldExtent, int canvasWidth, int canvasHeight);
    protected virtual string GetRequestUrlCore(RectangleShape worldExtent, int canvasWidth, int canvasHeight);
    [AsyncStateMachineAttribute("ThinkGeo.Core.Async.WmsLayer/<OpenAsyncCore>d__83")]
protected virtual Task OpenAsyncCore(CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("ThinkGeo.Core.Async.WmsLayer/<CloseAsyncCore>d__84")]
protected virtual Task CloseAsyncCore(CancellationToken cancellationToken);
    protected virtual RectangleShape GetBoundingBoxCore();
    [AsyncStateMachineAttribute("ThinkGeo.Core.Async.WmsLayer/<DrawAsyncCore>d__86")]
protected virtual Task DrawAsyncCore(GeoCanvas canvas, Collection`1<SimpleCandidate> labelsInAllLayers);
    private bool cB0=();
    private static int ER4=(string texts, int fontSize);
    private static string nhQ=(XmlDocument xmlDocument);
    private static string Eh4=(string message, int width);
    private WmsOnlineResource Ex4=();
    private void FB4=();
    private void FR4=(WmsServerLayer serverLayer);
    private void Fh4=(WmsServerLayer serverLayer);
    private void Fx4=(WmsServerLayer serverLayer);
    private void GB4=(WmsServerLayer layer);
    [AsyncStateMachineAttribute("ThinkGeo.Core.Async.WmsLayer/<ProcessCapabilitiesAsync>d__97")]
private Task GR4=(string url, CancellationToken cancellationToken);
    private static void Gh4=(string requestCapabilities, XmlDocument xmlDocument);
    [AsyncStateMachineAttribute("ThinkGeo.Core.Async.WmsLayer/<GetCacheXmlAsync>d__99")]
private Task`1<XmlDocument> Gx4=(string requestCapabilities);
    [AsyncStateMachineAttribute("ThinkGeo.Core.Async.WmsLayer/<GetRemoteXmlAsync>d__100")]
private Task`1<XmlDocument> HB4=(string requestCapabilities, IWebProxy proxy, ICredentials credentials, CancellationToken cancellationToken);
    private void HR4=(XmlDocument xmlDocument, XmlNamespaceManager namespaceManager);
    private static string Hh4=(XmlNode node, string nodeName, XmlNamespaceManager namespaceManager);
    private void Hx4=(XmlNode nodeCapability, XmlNamespaceManager namespaceManager);
    private void IB4=(XmlNode xmlRequestNode, XmlNamespaceManager namespaceManager);
    private WmsServerLayer IR4=(XmlNode xmlLayer, XmlNamespaceManager namespaceManager);
    private XmlAttribute Ih4=(XmlNode xmlNode);
    private RectangleShape Ix4=(XmlNode xmlLayer, XmlNamespaceManager namespaceManager);
    private void JB4=(XmlNode xnException, XmlNamespaceManager namespaceManager);
    private void JR4=(HttpRequestMessage httpRequestMessage);
    private static Collection`1<string> Jh4=(IEnumerable`1<string> collection);
    private static Collection`1<WmsServerLayer> Jh4=(IEnumerable`1<WmsServerLayer> collection);
    private void Jx4=(string propertyName);
    protected virtual string BuildWmsGetFeatureInfoUri(ScreenPointF screenPointF, string infoFormat, int maxFeatures);
    [AsyncStateMachineAttribute("ThinkGeo.Core.Async.WmsLayer/<GetFeatureInfoAsync>d__114")]
public Task`1<Dictionary`2<string, Collection`1<Feature>>> GetFeatureInfoAsync(ScreenPointF screenPointF, int maxFeatures, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("ThinkGeo.Core.Async.WmsLayer/<GetFeatureInfoAsync>d__115")]
public Task`1<Dictionary`2<string, Collection`1<Feature>>> GetFeatureInfoAsync(ScreenPointF screenPointF, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("ThinkGeo.Core.Async.WmsLayer/<GetFeatureInfoAsync>d__116")]
public Task`1<Dictionary`2<string, Collection`1<Feature>>> GetFeatureInfoAsync(ScreenPointF screenPointF, string infoFormat, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("ThinkGeo.Core.Async.WmsLayer/<GetFeatureInfo>d__117")]
public Task`1<Dictionary`2<string, Collection`1<Feature>>> GetFeatureInfo(ScreenPointF screenPointF, int maxFeatures, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("ThinkGeo.Core.Async.WmsLayer/<GetFeatureInfoAsync>d__118")]
public Task`1<Dictionary`2<string, Collection`1<Feature>>> GetFeatureInfoAsync(ScreenPointF screenPointF, string infoFormat, int maxFeatures, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("ThinkGeo.Core.Async.WmsLayer/<GetFeatureInfoAsyncCore>d__119")]
protected virtual Task`1<Dictionary`2<string, Collection`1<Feature>>> GetFeatureInfoAsyncCore(ScreenPointF screenPointF, string infoFormat, int maxFeatures, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("ThinkGeo.Core.Async.WmsLayer/<DownloadImageAsyncCore>d__120")]
protected virtual Task`1<Byte[]> DownloadImageAsyncCore(double width, double height, double scaleFactor, RectangleShape extent, GeographyUnit mapUnit, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("ThinkGeo.Core.Async.WmsLayer/<HandleResponseAsync>d__121")]
internal Task`1<Dictionary`2<string, Collection`1<Feature>>> KB4=(HttpRequestMessage request, CancellationToken cancellationToken);
    internal Dictionary`2<string, Collection`1<Feature>> KR4=(XmlDocument xmlDocument);
    [CompilerGeneratedAttribute]
[DebuggerHiddenAttribute]
private Task <>n__0(CancellationToken cancellationToken);
    [CompilerGeneratedAttribute]
[DebuggerHiddenAttribute]
private Task <>n__1(CancellationToken cancellationToken);
}
[ObsoleteAttribute("This class is obsoleted and will be removed after v14.3, please use ThinkGeo.Core.WmtsAsyncLayer instead")]
public class ThinkGeo.Core.Async.WmtsLayer : XyzTileLayer {
    [ObfuscationAttribute]
private Collection`1<Uri> serverUris;
    [ObfuscationAttribute]
private Uri serverUri;
    [ObfuscationAttribute]
private Dictionary`2<string, WmtsTileMatrixSet> tileMatrixSets;
    [ObfuscationAttribute]
private Collection`1<WmtsServerLayer> wmtsServerLayers;
    [ObfuscationAttribute]
private string activeLayerName;
    [ObfuscationAttribute]
private string activeStyleName;
    [ObfuscationAttribute]
private WmtsSeverEncodingType wmtsSeverEncodingType;
    [ObfuscationAttribute]
private string tileMatrixSetName;
    [ObfuscationAttribute]
private Dictionary`2<string, string> parameters;
    [ObfuscationAttribute]
private string outputFormat;
    [ObfuscationAttribute]
private double lowerScale;
    [ObfuscationAttribute]
private double upperScale;
    [ObfuscationAttribute]
private XmlDocument xmlDoc;
    [ObfuscationAttribute]
private TimeSpan capabilitesCacheTimeout;
    [ObfuscationAttribute]
private double wmtsConversionFactorForMeter;
    [ObfuscationAttribute]
private Dictionary`2<string, string> dimensions;
    [ObfuscationAttribute]
private WmtsAxisOrder axisOrder;
    [ObfuscationAttribute]
private RasterTileCache projectedTileCache;
    [ObfuscationAttribute]
private bool isCacheOnly;
    [ObfuscationAttribute]
private Dictionary`2<WmtsSeverEncodingType, string> getTileEncodingTypes;
    [ObsoleteAttribute("This property is obsoleted and will be removed after v14.4. Please use ServerUri instead.")]
public Collection`1<Uri> ServerUris { get; }
    public Uri ServerUri { get; public set; }
    private Dictionary`2<string, string> LB4= { get; private set; }
    public TimeSpan CapabilitesCacheTimeout { get; public set; }
    public string ActiveLayerName { get; public set; }
    public WmtsSeverEncodingType WmtsSeverEncodingType { get; public set; }
    public Collection`1<WmtsServerLayer> WmtsServerLayers { get; public set; }
    public string ActiveStyleName { get; public set; }
    public Dictionary`2<string, string> Parameters { get; }
    public string OutputFormat { get; public set; }
    public double LowerScale { get; public set; }
    public double UpperScale { get; public set; }
    public string TileMatrixSetName { get; public set; }
    public WmtsAxisOrder AxisOrder { get; public set; }
    [ObsoleteAttribute("This property is obsoleted and will be removed after v14.3. Please use ProjectionConverterFromServerProjection instead. ")]
public ProjectionConverter ProjectionConverter { get; public set; }
    public RasterTileCache ProjectedTileCache { get; public set; }
    public bool IsCacheOnly { get; public set; }
    public Dictionary`2<string, WmtsTileMatrixSet> TileMatrixSets { get; }
    public bool HasBoundingBox { get; }
    [ObsoleteAttribute("This constructor is obsoleted and will be removed after v14.4.")]
public WmtsLayer(IEnumerable`1<Uri> serverUris);
    [ObsoleteAttribute("This constructor is obsoleted and will be removed after v14.4.")]
public WmtsLayer(IEnumerable`1<Uri> serverUris, IWebProxy webProxy);
    [ObsoleteAttribute("This constructor is obsoleted and will be removed after v14.4.")]
public WmtsLayer(IEnumerable`1<Uri> serverUris, IWebProxy webProxy, WmtsSeverEncodingType wmtsSeverEncodingType);
    public WmtsLayer(Uri serverUri);
    public WmtsLayer(Uri serverUri, IWebProxy webProxy);
    public WmtsLayer(Uri serverUri, IWebProxy webProxy, WmtsSeverEncodingType wmtsSeverEncodingType);
    public Collection`1<Uri> get_ServerUris();
    public Uri get_ServerUri();
    public void set_ServerUri(Uri value);
    private Dictionary`2<string, string> Kh4=();
    private void Kx4=(Dictionary`2<string, string> value);
    public TimeSpan get_CapabilitesCacheTimeout();
    public void set_CapabilitesCacheTimeout(TimeSpan value);
    public string get_ActiveLayerName();
    public void set_ActiveLayerName(string value);
    public WmtsSeverEncodingType get_WmtsSeverEncodingType();
    public void set_WmtsSeverEncodingType(WmtsSeverEncodingType value);
    public Collection`1<WmtsServerLayer> get_WmtsServerLayers();
    public void set_WmtsServerLayers(Collection`1<WmtsServerLayer> value);
    public string get_ActiveStyleName();
    public void set_ActiveStyleName(string value);
    public Dictionary`2<string, string> get_Parameters();
    public string get_OutputFormat();
    public void set_OutputFormat(string value);
    public double get_LowerScale();
    public void set_LowerScale(double value);
    public double get_UpperScale();
    public void set_UpperScale(double value);
    public string get_TileMatrixSetName();
    public void set_TileMatrixSetName(string value);
    public WmtsAxisOrder get_AxisOrder();
    public void set_AxisOrder(WmtsAxisOrder value);
    public ProjectionConverter get_ProjectionConverter();
    public void set_ProjectionConverter(ProjectionConverter value);
    public RasterTileCache get_ProjectedTileCache();
    public void set_ProjectedTileCache(RasterTileCache value);
    public bool get_IsCacheOnly();
    public void set_IsCacheOnly(bool value);
    public Dictionary`2<string, WmtsTileMatrixSet> get_TileMatrixSets();
    [AsyncStateMachineAttribute("ThinkGeo.Core.Async.WmtsLayer/<OpenAsyncCore>d__78")]
protected virtual Task OpenAsyncCore(CancellationToken cancellationToken);
    public virtual bool get_HasBoundingBox();
    public RectangleShape GetWGS84BoundingBox();
    protected virtual RectangleShape GetBoundingBoxCore();
    public Collection`1<Uri> GetRequestUris(RectangleShape requestExtent, int canvasWidth, int canvasHeight);
    protected virtual Collection`1<Uri> GetRequestUrisCore(RectangleShape requestExtent, int canvasWidth, int canvasHeight);
    public string GetServerCapabilitiesXml();
    public Collection`1<string> GetServerLayerNames();
    public Collection`1<string> GetServerLayerStyles();
    public Collection`1<string> GetServerTileMatrixSetNames();
    public Collection`1<WmtsSeverEncodingType> GetServerEncodingType();
    public Collection`1<string> GetLayerOutputFormats(string layerName);
    protected virtual Task CloseAsyncCore(CancellationToken cancellationToken);
    private Uri qR0=();
    private Tuple`2<string, string> LR4=();
    [AsyncStateMachineAttribute("ThinkGeo.Core.Async.WmtsLayer/<GetCapabilitiesAsync>d__94")]
private Task Lh4=(CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("ThinkGeo.Core.Async.WmtsLayer/<LoadCapabilities>d__95")]
private Task`1<bool> Lx4=(string kvpUrl, CancellationToken cancellationToken);
    public bool RemoveCachedCapability();
    private string MB4=();
    private void HR4=(XmlElement element, XmlNamespaceManager namespaceManager);
    private void MR4=(XmlNode operationTileNode, XmlNamespaceManager namespaceManager);
    public ZoomLevelSet GetZoomLevelSet(string tileMatrixSetName);
    public TileMatrix GetTileMatrix(string tileMatrixSetName, double scale);
    private void Mh4=(XmlNode node, XmlNamespaceManager namespaceManager);
    private void Mx4=(T& left, T& top);
    private void NB4=(XmlNode node, XmlNamespaceManager namespaceManager);
    [AsyncStateMachineAttribute("ThinkGeo.Core.Async.WmtsLayer/<DrawAsyncCore>d__105")]
protected virtual Task DrawAsyncCore(GeoCanvas canvas, Collection`1<SimpleCandidate> labelsInAllLayers);
    private int NR4=(double newWidth, RectangleShape newTileExtent, GeographyUnit mapUnit);
    protected virtual void DrawExceptionCore(GeoCanvas canvas, Exception e);
    private string Nh4=(WmtsServerLayer serverLayer, string zoomLevel, long y, long x, string tileMatrixSetName, int resourceURLIndex);
    public string GetRequestUri(long x, long y, int zoomLevel);
    private string Nx4=(string requestString);
    [AsyncStateMachineAttribute("ThinkGeo.Core.Async.WmtsLayer/<GetCloudRasterTileInfoAsync>d__111")]
private Task`1<CloudRasterTileInfo> OB4=(MatrixCell cell, int zoomLevelIndex, int tileSize, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("ThinkGeo.Core.Async.WmtsLayer/<GetTileAsync>d__112")]
private Task`1<RasterTile> OR4=(int zoomLevel, long x, long y, CancellationToken cancellationToken);
    protected virtual Task`1<string> GetImageUriAsyncCore(int zoomLevel, long x, long y, float resolutionFactor);
    [CompilerGeneratedAttribute]
[DebuggerHiddenAttribute]
private Task <>n__0(CancellationToken cancellationToken);
    [CompilerGeneratedAttribute]
private bool <GetWGS84BoundingBox>b__81_0(WmtsServerLayer l);
    [CompilerGeneratedAttribute]
private bool <GetBoundingBoxCore>b__82_0(WmtsServerLayer l);
    [CompilerGeneratedAttribute]
private bool <GetRequestUri>b__109_1(WmtsServerLayer l);
}
[ObsoleteAttribute("This class is obsoleted and will be removed after v14.3, please use ThinkGeo.Core.XyzTileAsyncLayer instead")]
public abstract class ThinkGeo.Core.Async.XyzTileLayer : WebBasedLayer {
    [ObfuscationAttribute]
private RasterTileCache tileCache;
    [ObfuscationAttribute]
private RasterTileCache projectedTileCache;
    [ObfuscationAttribute]
private ProjectionConverter projectionConverterFromServerProjection;
    [ObfuscationAttribute]
private int cloudTileWidth;
    [ObfuscationAttribute]
private int cloudTileHeight;
    [ObfuscationAttribute]
private RectangleShape maxExtent;
    [ObfuscationAttribute]
private GeographyUnit cloudTileMapUnit;
    public int TileWidth { get; protected set; }
    public int TileHeight { get; protected set; }
    public GeographyUnit MapUnit { get; protected set; }
    public RectangleShape MaxExtent { get; protected set; }
    public RasterTileCache TileCache { get; public set; }
    public RasterTileCache ProjectedTileCache { get; public set; }
    public ProjectionConverter ProjectionConverterFromServerProjection { get; public set; }
    public XyzTileLayer(int tileSize, GeographyUnit mapUnit, RectangleShape maxExtent);
    public int get_TileWidth();
    protected void set_TileWidth(int value);
    public int get_TileHeight();
    protected void set_TileHeight(int value);
    public GeographyUnit get_MapUnit();
    protected void set_MapUnit(GeographyUnit value);
    public RectangleShape get_MaxExtent();
    protected void set_MaxExtent(RectangleShape value);
    public virtual RasterTileCache get_TileCache();
    public virtual void set_TileCache(RasterTileCache value);
    public virtual RasterTileCache get_ProjectedTileCache();
    public virtual void set_ProjectedTileCache(RasterTileCache value);
    public virtual ProjectionConverter get_ProjectionConverterFromServerProjection();
    public virtual void set_ProjectionConverterFromServerProjection(ProjectionConverter value);
    [AsyncStateMachineAttribute("ThinkGeo.Core.Async.XyzTileLayer/<GetImageUriAsync>d__30")]
public Task`1<string> GetImageUriAsync(int zoomLevel, long x, long y, float resolutionFactor);
    protected abstract virtual Task`1<string> GetImageUriAsyncCore(int zoomLevel, long x, long y, float resolutionFactor);
    protected virtual Task OpenAsyncCore(CancellationToken cancellationToken);
    protected virtual Task CloseAsyncCore(CancellationToken cancellationToken);
    protected virtual int GetTileScale();
    [AsyncStateMachineAttribute("ThinkGeo.Core.Async.XyzTileLayer/<DrawAsyncCore>d__35")]
protected virtual Task DrawAsyncCore(GeoCanvas canvas, Collection`1<SimpleCandidate> labelsInAllLayers);
    private static Dictionary`2<ValueTuple`2<long, long>, MatrixCell> Oh4=(TileMatrix tileMatrix, RectangleShape requestedExtent, WrappingMode wrapDateline);
    protected virtual RectangleShape GetBoundingBoxCore();
    [AsyncStateMachineAttribute("ThinkGeo.Core.Async.XyzTileLayer/<GetTileAsync>d__38")]
private Task`1<RasterTile> OR4=(int zoomLevel, long x, long y, float resolutionFactor, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("ThinkGeo.Core.Async.XyzTileLayer/<GetCloudRasterTileInfoAsync>d__39")]
private Task`1<CloudRasterTileInfo> OB4=(MatrixCell cell, int zoomLevelIndex, float scaleFactor, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("ThinkGeo.Core.Async.XyzTileLayer/<DownloadImageAsync>d__40")]
public Task`1<Byte[]> DownloadImageAsync(int zoomLevelIndex, long column, long row, float scaleFactor, CancellationToken cancellationToken);
}
public abstract class ThinkGeo.Core.AsyncLayer : LayerBase {
    private Exception qh0=;
    [CompilerGeneratedAttribute]
private double qx0=;
    [CompilerGeneratedAttribute]
private double rB0=;
    public double UpperThreshold { get; public set; }
    public double LowerThreshold { get; public set; }
    [CompilerGeneratedAttribute]
public double get_UpperThreshold();
    [CompilerGeneratedAttribute]
public void set_UpperThreshold(double value);
    [CompilerGeneratedAttribute]
public double get_LowerThreshold();
    [CompilerGeneratedAttribute]
public void set_LowerThreshold(double value);
    [AsyncStateMachineAttribute("ThinkGeo.Core.AsyncLayer/<OpenAsync>d__10")]
public Task OpenAsync(CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("ThinkGeo.Core.AsyncLayer/<OpenAsyncCore>d__11")]
protected virtual Task OpenAsyncCore(CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("ThinkGeo.Core.AsyncLayer/<CloseAsync>d__12")]
public Task CloseAsync(CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("ThinkGeo.Core.AsyncLayer/<CloseAsyncCore>d__13")]
protected virtual Task CloseAsyncCore(CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("ThinkGeo.Core.AsyncLayer/<DrawAsync>d__14")]
public Task DrawAsync(GeoCanvas canvas, Collection`1<SimpleCandidate> labelsInAllLayers);
    [AsyncStateMachineAttribute("ThinkGeo.Core.AsyncLayer/<DrawTranslationAsync>d__15")]
private Task rR0=(GeoCanvas canvas, Collection`1<SimpleCandidate> labelsInAllLayers);
    protected abstract virtual Task DrawAsyncCore(GeoCanvas canvas, Collection`1<SimpleCandidate> labelsInAllLayers);
    private void rh0=(object sender, DrawingProgressChangedEventArgs e);
}
public static class ThinkGeo.Core.AsyncLocker : object {
    private static ConcurrentDictionary`2<object, SemaphoreSlim> Jx0=;
    private static AsyncLocker();
    [AsyncStateMachineAttribute("ThinkGeo.Core.AsyncLocker/<LockAsync>d__1")]
public static Task`1<IDisposable> LockAsync(object lockObject);
}
public class ThinkGeo.Core.BackgroundLayer : Layer {
    [ObfuscationAttribute]
private GeoBrush backgroundBrush;
    public GeoBrush BackgroundBrush { get; public set; }
    public BackgroundLayer(GeoBrush backgroundBrush);
    public GeoBrush get_BackgroundBrush();
    public void set_BackgroundBrush(GeoBrush value);
    protected virtual void DrawCore(GeoCanvas canvas, Collection`1<SimpleCandidate> labelsInAllLayers);
}
public enum ThinkGeo.Core.BasAnnotationTextStylingType : Enum {
    public int value__;
    public static BasAnnotationTextStylingType Default;
    public static BasAnnotationTextStylingType CustomStyling;
    public static BasAnnotationTextStylingType StandardStyling;
}
public abstract class ThinkGeo.Core.BaseShape : object {
    private static int oBo=;
    [ObfuscationAttribute]
private string id;
    [ObfuscationAttribute]
private object tag;
    public string Id { get; public set; }
    public object Tag { get; public set; }
    private static BaseShape();
    public string get_Id();
    public void set_Id(string value);
    public object get_Tag();
    public void set_Tag(object value);
    public static BaseShape CreateShapeFromWellKnownData(string wellKnownText);
    public void LoadFromWellKnownData(string wellKnownText);
    protected abstract virtual void LoadFromWellKnownDataCore(string wellKnownText);
    public string GetWellKnownText();
    public string GetGeoJson();
    protected virtual string GetGeoJsonCore();
    public string GetWellKnownText(RingOrder outerRingOrder);
    protected abstract virtual string GetWellKnownTextCore(RingOrder outerRingOrder);
    public static BaseShape CreateShapeFromWellKnownData(Byte[] wellKnownBinary);
    public static BaseShape CreateShapeFromGeoJson(string geoJson);
    public void LoadFromWellKnownData(Byte[] wellKnownBinary);
    protected virtual void LoadFromWellKnownDataCore(Byte[] wellKnownBinary);
    public Byte[] GetWellKnownBinary();
    public Byte[] GetWellKnownBinary(WkbByteOrder byteOrder);
    public Byte[] GetWellKnownBinary(RingOrder outerRingOrder);
    public Byte[] GetWellKnownBinary(RingOrder outerRingOrder, WkbByteOrder byteOrder);
    protected virtual Byte[] GetWellKnownBinaryCore(RingOrder outerRingOrder, WkbByteOrder byteOrder);
    public RectangleShape GetBoundingBox();
    protected virtual RectangleShape GetBoundingBoxCore();
    public WellKnownType GetWellKnownType();
    protected virtual WellKnownType GetWellKnownTypeCore();
    public BaseShape CloneDeep();
    protected virtual BaseShape CloneDeepCore();
    public static BaseShape TranslateByOffset(BaseShape targetShape, double xOffsetDistance, double yOffsetDistance, GeographyUnit shapeUnit, DistanceUnit distanceUnit);
    public static Feature TranslateByOffset(Feature targetFeature, double xOffsetDistance, double yOffsetDistance, GeographyUnit shapeUnit, DistanceUnit distanceUnit);
    public void TranslateByOffset(double xOffsetDistance, double yOffsetDistance, GeographyUnit shapeUnit, DistanceUnit distanceUnit);
    public void TranslateByOffset(double xOffsetDistance, double yOffsetDistance);
    protected virtual void TranslateByOffsetCore(double xOffsetDistance, double yOffsetDistance, GeographyUnit shapeUnit, DistanceUnit distanceUnit);
    public static BaseShape TranslateByDegree(BaseShape targetShape, double distance, double angleInDegrees, GeographyUnit shapeUnit, DistanceUnit distanceUnit);
    public static BaseShape TranslateByDegree(Feature targetFeature, double distance, double angleInDegrees, GeographyUnit shapeUnit, DistanceUnit distanceUnit);
    public void TranslateByDegree(double distance, double angleInDegrees, GeographyUnit shapeUnit, DistanceUnit distanceUnit);
    public void TranslateByDegree(double distance, double angleInDegrees);
    protected virtual void TranslateByDegreeCore(double distance, double angleInDegrees, GeographyUnit shapeUnit, DistanceUnit distanceUnit);
    public static BaseShape Rotate(BaseShape sourceBaseShape, PointShape pivotPoint, float degreeAngle);
    public static BaseShape Rotate(Feature targetFeature, PointShape pivotPoint, float degreeAngle);
    public void Rotate(PointShape pivotPoint, double degreeAngle);
    protected virtual void RotateCore(PointShape pivotPoint, double degreeAngle);
    public MultilineShape GetShortestLineTo(BaseShape targetShape, GeographyUnit shapeUnit);
    public MultilineShape GetShortestLineTo(Feature targetFeature, GeographyUnit shapeUnit);
    protected virtual MultilineShape GetShortestLineToCore(BaseShape targetShape, GeographyUnit shapeUnit);
    public PointShape GetClosestPointTo(BaseShape targetShape, GeographyUnit shapeUnit);
    public PointShape GetClosestPointTo(Feature targetFeature, GeographyUnit shapeUnit);
    protected virtual PointShape GetClosestPointToCore(BaseShape targetShape, GeographyUnit shapeUnit);
    public PointShape GetCenterPoint();
    protected virtual PointShape GetCenterPointCore();
    public MultipolygonShape Buffer(double distance, GeographyUnit shapeUnit, DistanceUnit distanceUnit);
    public MultipolygonShape Buffer(double distance, int quadrantSegments, GeographyUnit shapeUnit, DistanceUnit distanceUnit);
    public MultipolygonShape Buffer(double distance, int quadrantSegments, BufferCapType bufferCapType, GeographyUnit shapeUnit, DistanceUnit distanceUnit);
    protected virtual MultipolygonShape BufferCore(double distance, int quadrantSegments, BufferCapType bufferCapType, GeographyUnit shapeUnit, DistanceUnit distanceUnit);
    private MultipolygonShape oRo=(double distance, int quadrantSegments, BufferCapType bufferCapType);
    public double GetDistanceTo(BaseShape targetShape, GeographyUnit shapeUnit, DistanceUnit distanceUnit);
    public double GetDistanceTo(Feature targetFeature, GeographyUnit shapeUnit, DistanceUnit distanceUnit);
    protected virtual double GetDistanceToCore(BaseShape targetShape, GeographyUnit shapeUnit, DistanceUnit distanceUnit);
    public BaseShape Register(PointShape fromPoint, PointShape toPoint, DistanceUnit fromUnit, GeographyUnit toUnit);
    public BaseShape Register(Feature fromPoint, Feature toPoint, DistanceUnit fromUnit, GeographyUnit toUnit);
    protected virtual BaseShape RegisterCore(PointShape fromPoint, PointShape toPoint, DistanceUnit fromUnit, GeographyUnit toUnit);
    public ShapeValidationResult Validate(ShapeValidationMode validationMode);
    protected virtual ShapeValidationResult ValidateCore(ShapeValidationMode validationMode);
    public bool IsDisjointed(BaseShape targetShape);
    public bool IsDisjointed(Feature targetFeature);
    protected virtual bool IsDisjointedCore(BaseShape targetShape);
    public bool Intersects(BaseShape targetShape);
    public bool Intersects(Feature targetFeature);
    protected virtual bool IntersectsCore(BaseShape targetShape);
    public bool Touches(BaseShape targetShape);
    public bool Touches(Feature targetFeature);
    protected virtual bool TouchesCore(BaseShape targetShape);
    public bool Crosses(BaseShape targetShape);
    public bool Crosses(Feature targetFeature);
    protected virtual bool CrossesCore(BaseShape targetShape);
    public bool IsWithin(BaseShape targetShape);
    public bool IsWithin(Feature targetFeature);
    protected virtual bool IsWithinCore(BaseShape targetShape);
    public bool Contains(BaseShape targetShape);
    public bool Contains(Feature targetFeature);
    protected virtual bool ContainsCore(BaseShape targetShape);
    public bool Overlaps(BaseShape targetShape);
    public bool Overlaps(Feature targetFeature);
    protected virtual bool OverlapsCore(BaseShape targetShape);
    public bool IsTopologicallyEqual(BaseShape targetShape);
    public bool IsTopologicallyEqual(Feature targetFeature);
    protected virtual bool IsTopologicallyEqualCore(BaseShape targetShape);
    public Feature GetFeature();
    public Feature GetFeature(IDictionary`2<string, string> columnValues);
    public MultipointShape GetCrossing(BaseShape targetShape);
    protected virtual MultipointShape GetCrossingCore(BaseShape targetShape);
    public static BaseShape ScaleTo(BaseShape baseShape, double scale);
    public void ScaleTo(double scale);
    protected virtual void ScaleToCore(double scale);
    private static EndCapStyle oho=(BufferCapType bufferCapStyle);
    private static ByteOrder oxo=(WkbByteOrder wkbByteOrder);
}
public class ThinkGeo.Core.BaseShapeTypeConverter : TypeConverter {
    public virtual bool CanConvertFrom(ITypeDescriptorContext context, Type sourceType);
    public virtual object ConvertFrom(ITypeDescriptorContext context, CultureInfo culture, object value);
}
public class ThinkGeo.Core.BingMapsAsyncLayer : XyzTileAsyncLayer {
    private static int rx0=;
    private static string sB0=;
    private static string sR0=;
    [ObfuscationAttribute]
private string applicationId;
    [ObfuscationAttribute]
private BingMapsMapType mapType;
    [ObfuscationAttribute]
private string imageUriTemplate;
    [ObfuscationAttribute]
private Collection`1<string> subDomains;
    [ObfuscationAttribute]
private GeoImage logo;
    [ObfuscationAttribute]
private bool isDirty;
    [ObfuscationAttribute]
private RequestProtocol httpRequestProtocol;
    public string ApplicationId { get; public set; }
    public BingMapsMapType MapType { get; public set; }
    public GeoImage Logo { get; }
    public RequestProtocol HttpRequestProtocol { get; public set; }
    public BingMapsAsyncLayer(string applicationId);
    public BingMapsAsyncLayer(string applicationId, BingMapsMapType mapType);
    private static BingMapsAsyncLayer();
    [AsyncStateMachineAttribute("ThinkGeo.Core.BingMapsAsyncLayer/<OpenAsyncCore>d__13")]
protected virtual Task OpenAsyncCore(CancellationToken cancellationToken);
    public string get_ApplicationId();
    public void set_ApplicationId(string value);
    public BingMapsMapType get_MapType();
    public void set_MapType(BingMapsMapType value);
    public GeoImage get_Logo();
    public RequestProtocol get_HttpRequestProtocol();
    public void set_HttpRequestProtocol(RequestProtocol value);
    [AsyncStateMachineAttribute("ThinkGeo.Core.BingMapsAsyncLayer/<DrawAsyncCore>d__25")]
protected virtual Task DrawAsyncCore(GeoCanvas canvas, Collection`1<SimpleCandidate> labelsInAllLayers);
    [AsyncStateMachineAttribute("ThinkGeo.Core.BingMapsAsyncLayer/<GetImageUriAsyncCore>d__26")]
protected virtual Task`1<string> GetImageUriAsyncCore(int zoomLevel, long x, long y, float resolutionFactor);
    private static string sh0=(long tileX, long tileY, int levelOfDetail);
    [AsyncStateMachineAttribute("ThinkGeo.Core.BingMapsAsyncLayer/<ValidateAsync>d__28")]
private Task sx0=();
    [AsyncStateMachineAttribute("ThinkGeo.Core.BingMapsAsyncLayer/<RequestXmlAsync>d__29")]
private Task`1<XmlDocument> tB0=(string xmlPath);
    [DebuggerHiddenAttribute]
[CompilerGeneratedAttribute]
private Task <>n__0(CancellationToken cancellationToken);
    [DebuggerHiddenAttribute]
[CompilerGeneratedAttribute]
private Task <>n__1(GeoCanvas canvas, Collection`1<SimpleCandidate> labelsInAllLayers);
}
public enum ThinkGeo.Core.BingMapsMapType : Enum {
    public int value__;
    public static BingMapsMapType Road;
    public static BingMapsMapType AerialWithLabels;
    public static BingMapsMapType Aerial;
    public static BingMapsMapType CanvasDark;
}
public class ThinkGeo.Core.BingMapsZoomLevelSet : ZoomLevelSet {
}
public enum ThinkGeo.Core.BreakValueInclusion : Enum {
    public int value__;
    public static BreakValueInclusion IncludeValue;
    public static BreakValueInclusion ExcludeValue;
}
public enum ThinkGeo.Core.BufferCapType : Enum {
    public int value__;
    public static BufferCapType Round;
    public static BufferCapType Square;
    public static BufferCapType Butt;
}
public enum ThinkGeo.Core.BuildIndexMode : Enum {
    public int value__;
    public static BuildIndexMode DoNotRebuild;
    public static BuildIndexMode Rebuild;
}
public class ThinkGeo.Core.BuildingAreaStyle : AreaStyle {
    private static int LjE=;
    private static int LzE=;
    private int MDE=;
    private string MTE=;
    private DistanceUnit MjE=;
    private GeoBrush MzE=;
    private GeoBrush NDE=;
    private GeoBrush NTE=;
    private BuildingShadowMode NjE=;
    internal bool fBU= { get; }
    public DistanceUnit HeightUnit { get; public set; }
    public string HeightColumnName { get; public set; }
    public GeoBrush LightSideBrush { get; public set; }
    public GeoBrush ShadowSideBrush { get; public set; }
    public GeoBrush RoofBrush { get; public set; }
    public BuildingShadowMode ShadowMode { get; public set; }
    public BuildingAreaStyle(string heightColumnName, DistanceUnit heightUnit);
    private static BuildingAreaStyle();
    internal virtual bool ehU=();
    public DistanceUnit get_HeightUnit();
    public void set_HeightUnit(DistanceUnit value);
    public string get_HeightColumnName();
    public void set_HeightColumnName(string value);
    public GeoBrush get_LightSideBrush();
    public void set_LightSideBrush(GeoBrush value);
    public GeoBrush get_ShadowSideBrush();
    public void set_ShadowSideBrush(GeoBrush value);
    public GeoBrush get_RoofBrush();
    public void set_RoofBrush(GeoBrush value);
    public BuildingShadowMode get_ShadowMode();
    public void set_ShadowMode(BuildingShadowMode value);
    protected virtual Collection`1<string> GetRequiredColumnNamesCore();
    protected virtual void DrawCore(IEnumerable`1<Feature> features, GeoCanvas canvas, Collection`1<SimpleCandidate> labelsInThisLayer, Collection`1<SimpleCandidate> labelsInAllLayers);
    [IteratorStateMachineAttribute("ThinkGeo.Core.BuildingAreaStyle/<ToPolygonFeatures>d__33")]
private static IEnumerable`1<Feature> NzE=(Feature feature);
    private void ODE=(GeoCanvas canvas, PolygonShape buildingPolygon, double buildingHeight, int currentLevel, ScreenPointF screenOrigin);
    private ScreenPointF[] OTE=(GeoCanvas canvas, double buildingHeight, ScreenPointF[] footPrints, bool isCounterClockwise, ScreenPointF screenOrigin);
    protected virtual double GetHeightInMeters(Feature feature);
    private static void Mx4=(T& a, T& b);
    private static int OjE=(double scale, List`1<double> zoomLevelScales);
    private static ScreenPointF OzE=(Vertex v, GeoCanvas canvas);
    private static double PDE=(GeoCanvas canvas);
    private ScreenPointF PTE=(ScreenPointF point, double scale, ScreenPointF origin);
    private static bool PjE=(Vertex[] vertices);
}
public class ThinkGeo.Core.BuildingIndexBasFileFeatureSourceEventArgs : EventArgs {
    [ObfuscationAttribute]
private int recordCount;
    [ObfuscationAttribute]
private long currentRecordOffset;
    [ObfuscationAttribute]
private Feature currentFeature;
    [ObfuscationAttribute]
private DateTime startProcessTime;
    [ObfuscationAttribute]
private bool cancel;
    [ObfuscationAttribute]
private string basPathFilename;
    public int RecordCount { get; }
    public long CurrentRecordOffset { get; }
    public Feature CurrentFeature { get; }
    public DateTime StartProcessTime { get; }
    public bool Cancel { get; public set; }
    public string ShapePathFilename { get; }
    public BuildingIndexBasFileFeatureSourceEventArgs(int recordCount, long currentRecordOffset, Feature currentFeature, DateTime startProcessTime, bool cancel);
    public BuildingIndexBasFileFeatureSourceEventArgs(int recordCount, long currentRecordOffset, Feature currentFeature, DateTime startProcessTime, bool cancel, string shapePathFilename);
    public int get_RecordCount();
    public long get_CurrentRecordOffset();
    public Feature get_CurrentFeature();
    public DateTime get_StartProcessTime();
    public bool get_Cancel();
    public void set_Cancel(bool value);
    public string get_ShapePathFilename();
}
public class ThinkGeo.Core.BuildingIndexDelimitedFeatureSourceEventArgs : EventArgs {
    [ObfuscationAttribute]
private int recordCount;
    [ObfuscationAttribute]
private int currentRecordIndex;
    [ObfuscationAttribute]
private Feature currentFeature;
    [ObfuscationAttribute]
private DateTime startProcessTime;
    [ObfuscationAttribute]
private bool cancel;
    [ObfuscationAttribute]
private string delimitedPathFilename;
    public int RecordCount { get; }
    public int CurrentRecordIndex { get; }
    public Feature CurrentFeature { get; }
    public DateTime StartProcessTime { get; }
    public string DelimitedPathFilename { get; }
    public bool Cancel { get; public set; }
    public BuildingIndexDelimitedFeatureSourceEventArgs(int recordCount, int currentRecordIndex, Feature currentFeature, DateTime startProcessTime, string delimitedPathFilename);
    public int get_RecordCount();
    public int get_CurrentRecordIndex();
    public Feature get_CurrentFeature();
    public DateTime get_StartProcessTime();
    public string get_DelimitedPathFilename();
    public bool get_Cancel();
    public void set_Cancel(bool value);
}
public class ThinkGeo.Core.BuildingIndexShapeFileFeatureSourceEventArgs : EventArgs {
    [ObfuscationAttribute]
private long recordCount;
    [ObfuscationAttribute]
private long currentRecordIndex;
    [ObfuscationAttribute]
private Feature currentFeature;
    [ObfuscationAttribute]
private DateTime startProcessTime;
    [ObfuscationAttribute]
private bool cancel;
    [ObfuscationAttribute]
private string shapePathFilename;
    public long RecordCount { get; }
    public long CurrentRecordIndex { get; }
    public Feature CurrentFeature { get; }
    public DateTime StartProcessTime { get; }
    public bool Cancel { get; public set; }
    public string ShapePathFilename { get; }
    public BuildingIndexShapeFileFeatureSourceEventArgs(long recordCount, long currentRecordIndex, Feature currentFeature, DateTime startProcessTime, string shapePathFilename);
    public long get_RecordCount();
    public long get_CurrentRecordIndex();
    public Feature get_CurrentFeature();
    public DateTime get_StartProcessTime();
    public bool get_Cancel();
    public void set_Cancel(bool value);
    public string get_ShapePathFilename();
}
public enum ThinkGeo.Core.BuildingShadowMode : Enum {
    public int value__;
    public static BuildingShadowMode Perspective;
    public static BuildingShadowMode FixedDirection;
}
public enum ThinkGeo.Core.BuildRecordIdMode : Enum {
    public int value__;
    public static BuildRecordIdMode DoNotRebuild;
    public static BuildRecordIdMode Rebuild;
}
public class ThinkGeo.Core.CircularKrigingGridInterpolationModel : KrigingGridInterpolationModel {
    public CircularKrigingGridInterpolationModel(IDictionary`2<PointShape, double> points);
    public CircularKrigingGridInterpolationModel(IDictionary`2<PointShape, double> points, int numberOfReferencedPoints);
    protected virtual double GetSemivarianceCore(double distance, EmpiricalFunctionCoefficients coefficients);
    protected virtual double GetSillSlopeCore(double distance, double range);
}
public class ThinkGeo.Core.ClassBreak : object {
    [ObfuscationAttribute]
private double value;
    [ObfuscationAttribute]
private PointStyle defaultPointStyle;
    [ObfuscationAttribute]
private LineStyle defaultLineStyle;
    [ObfuscationAttribute]
private AreaStyle defaultAreaStyle;
    [ObfuscationAttribute]
private TextStyle defaultTextStyle;
    [ObfuscationAttribute]
private Collection`1<Style> customStyles;
    public double Value { get; public set; }
    public AreaStyle DefaultAreaStyle { get; public set; }
    public LineStyle DefaultLineStyle { get; public set; }
    public PointStyle DefaultPointStyle { get; public set; }
    public TextStyle DefaultTextStyle { get; public set; }
    public Collection`1<Style> CustomStyles { get; }
    public ClassBreak(double value, AreaStyle areaStyle);
    public ClassBreak(double value, PointStyle pointStyle);
    public ClassBreak(double value, LineStyle lineStyle);
    public ClassBreak(double value, TextStyle textStyle);
    public ClassBreak(double value, Collection`1<Style> customStyles);
    private ClassBreak(double value, AreaStyle areaStyle, PointStyle pointStyle, LineStyle lineStyle, TextStyle textStyle, Collection`1<Style> styles);
    public double get_Value();
    public void set_Value(double value);
    public AreaStyle get_DefaultAreaStyle();
    public void set_DefaultAreaStyle(AreaStyle value);
    public LineStyle get_DefaultLineStyle();
    public void set_DefaultLineStyle(LineStyle value);
    public PointStyle get_DefaultPointStyle();
    public void set_DefaultPointStyle(PointStyle value);
    public TextStyle get_DefaultTextStyle();
    public void set_DefaultTextStyle(TextStyle value);
    public Collection`1<Style> get_CustomStyles();
}
public enum ThinkGeo.Core.ClassBreakDrawingOrder : Enum {
    public int value__;
    public static ClassBreakDrawingOrder Default;
    public static ClassBreakDrawingOrder OrderByFeatures;
    public static ClassBreakDrawingOrder OrderByClassBreak;
}
public class ThinkGeo.Core.ClassBreakStyle : Style {
    [ObfuscationAttribute]
private BreakValueInclusion breakValueInclusion;
    [ObfuscationAttribute]
private Collection`1<ClassBreak> classBreaks;
    [ObfuscationAttribute]
private string columnName;
    [ObfuscationAttribute]
private ClassBreakDrawingOrder drawingOrder;
    [CompilerGeneratedAttribute]
private EventHandler`1<GottenFeatureValueClassBreakStyleEventArgs> GottenFeatureValue;
    public string ColumnName { get; public set; }
    public BreakValueInclusion BreakValueInclusion { get; public set; }
    public Collection`1<ClassBreak> ClassBreaks { get; }
    public ClassBreakDrawingOrder DrawingOrder { get; public set; }
    public ClassBreakStyle(string columnName);
    public ClassBreakStyle(string columnName, BreakValueInclusion breakValueInclusion);
    public ClassBreakStyle(string columnName, BreakValueInclusion breakValueInclusion, Collection`1<ClassBreak> classBreaks);
    [CompilerGeneratedAttribute]
public void add_GottenFeatureValue(EventHandler`1<GottenFeatureValueClassBreakStyleEventArgs> value);
    [CompilerGeneratedAttribute]
public void remove_GottenFeatureValue(EventHandler`1<GottenFeatureValueClassBreakStyleEventArgs> value);
    protected virtual void OnGottenFeatureValue(GottenFeatureValueClassBreakStyleEventArgs e);
    public string get_ColumnName();
    public void set_ColumnName(string value);
    public BreakValueInclusion get_BreakValueInclusion();
    public void set_BreakValueInclusion(BreakValueInclusion value);
    public Collection`1<ClassBreak> get_ClassBreaks();
    public ClassBreakDrawingOrder get_DrawingOrder();
    public void set_DrawingOrder(ClassBreakDrawingOrder value);
    protected virtual void DrawCore(IEnumerable`1<Feature> features, GeoCanvas canvas, Collection`1<SimpleCandidate> labelsInThisLayer, Collection`1<SimpleCandidate> labelsInAllLayers);
    protected virtual void DrawSampleCore(GeoCanvas canvas, DrawingRectangleF drawingExtent);
    [IteratorStateMachineAttribute("ThinkGeo.Core.ClassBreakStyle/<GetSampleStyles>d__25")]
private IEnumerable`1<Style> QTE=();
    private static Collection`1<ClassBreak> QjE=(Collection`1<ClassBreak> classBreaks);
    private static ClassBreak QzE=(double columnValue, BreakValueInclusion breakValueInclusion, Collection`1<ClassBreak> sortedClassBreaks);
    protected virtual Collection`1<string> GetRequiredColumnNamesCore();
    private static void RDE=(Collection`1<string> requiredFieldNames, Collection`1<string> fieldNames);
}
public static class ThinkGeo.Core.ClassBreakValidatorHelper : object {
    public static void CheckClassBreaksAreValid(IEnumerable`1<ClassBreak> classBreaks);
}
public class ThinkGeo.Core.ClearedItemsGeoCollectionEventArgs : EventArgs {
}
public class ThinkGeo.Core.ClearingItemsGeoCollectionEventArgs : EventArgs {
}
public class ThinkGeo.Core.ClosedFeatureSourceEventArgs : EventArgs {
}
public class ThinkGeo.Core.ClosedRasterSourceEventArgs : EventArgs {
}
public class ThinkGeo.Core.ClosingFeatureSourceEventArgs : EventArgs {
}
public class ThinkGeo.Core.ClosingRasterSourceEventArgs : EventArgs {
}
public abstract class ThinkGeo.Core.CloudClient : object {
    private string kxQ=;
    private int lBQ=;
    private IWebProxy lRQ=;
    private string lhQ=;
    private string lxQ=;
    private int mBQ=;
    private static string mRQ=;
    private Timer mhQ=;
    private object oRM=;
    private SemaphoreSlim mxQ=;
    [CompilerGeneratedAttribute]
private EventHandler`1<GettingAccessTokenEventArgs> GettingAccessToken;
    [CompilerGeneratedAttribute]
private EventHandler`1<SendingWebRequestEventArgs> SendingWebRequest;
    [CompilerGeneratedAttribute]
private EventHandler`1<SentWebRequestEventArgs> SentWebRequest;
    [CompilerGeneratedAttribute]
private Collection`1<Uri> nBQ=;
    public int TimeoutInSeconds { get; public set; }
    public IWebProxy WebProxy { get; public set; }
    public string ClientId { get; public set; }
    public string ClientSecret { get; public set; }
    public Collection`1<Uri> BaseUris { get; }
    protected CloudClient(string clientId, string clientSecret);
    [CompilerGeneratedAttribute]
public void add_GettingAccessToken(EventHandler`1<GettingAccessTokenEventArgs> value);
    [CompilerGeneratedAttribute]
public void remove_GettingAccessToken(EventHandler`1<GettingAccessTokenEventArgs> value);
    [CompilerGeneratedAttribute]
public void add_SendingWebRequest(EventHandler`1<SendingWebRequestEventArgs> value);
    [CompilerGeneratedAttribute]
public void remove_SendingWebRequest(EventHandler`1<SendingWebRequestEventArgs> value);
    [CompilerGeneratedAttribute]
public void add_SentWebRequest(EventHandler`1<SentWebRequestEventArgs> value);
    [CompilerGeneratedAttribute]
public void remove_SentWebRequest(EventHandler`1<SentWebRequestEventArgs> value);
    public int get_TimeoutInSeconds();
    public void set_TimeoutInSeconds(int value);
    public IWebProxy get_WebProxy();
    public void set_WebProxy(IWebProxy value);
    public string get_ClientId();
    public void set_ClientId(string value);
    public string get_ClientSecret();
    public void set_ClientSecret(string value);
    [CompilerGeneratedAttribute]
public Collection`1<Uri> get_BaseUris();
    protected void AuthenticateWebRequest(WebRequest webRequest);
    [AsyncStateMachineAttribute("ThinkGeo.Core.CloudClient/<AuthenticateWebRequestAsync>d__37")]
protected Task AuthenticateWebRequestAsync(WebRequest webRequest);
    protected string GetToken();
    [AsyncStateMachineAttribute("ThinkGeo.Core.CloudClient/<GetTokenAsync>d__39")]
protected Task`1<string> GetTokenAsync();
    [AsyncStateMachineAttribute("ThinkGeo.Core.CloudClient/<GetTokenCoreAsync>d__40")]
protected virtual Task`1<string> GetTokenCoreAsync();
    protected virtual string GetTokenCore();
    protected WebResponse SendWebRequest(WebRequest webRequest);
    [AsyncStateMachineAttribute("ThinkGeo.Core.CloudClient/<SendWebRequestAsync>d__43")]
protected Task`1<WebResponse> SendWebRequestAsync(WebRequest webRequest);
    protected string GetNextCandidateBaseUri();
    protected virtual string GetNextCandidateBaseUriCore();
    protected virtual void OnGettingAccessToken(GettingAccessTokenEventArgs e);
    protected virtual void OnSendingWebRequest(SendingWebRequestEventArgs e);
    protected virtual void OnSentWebRequest(SentWebRequestEventArgs e);
    public virtual void Dispose();
    private void nRQ=(object state);
    private static string nhQ=(HttpWebResponse httpWebResponse);
}
[ObfuscationAttribute]
internal class ThinkGeo.Core.CloudDurationMinuteReader : CloudJsonConverter`1<object> {
    public virtual object ReadJson(CloudGeoJObject jObject, Type objectType);
    public virtual void WriteJson(CloudGeoJObject jObject, object value);
}
[ObfuscationAttribute]
public class ThinkGeo.Core.CloudElevationPointResult : ValueType {
    [CompilerGeneratedAttribute]
private double <Elevation>k__BackingField;
    [CompilerGeneratedAttribute]
private PointShape <Point>k__BackingField;
    [CompilerGeneratedAttribute]
private ThinkGeoCloudApplicationException <Exception>k__BackingField;
    public double Elevation { get; }
    public PointShape Point { get; }
    public ThinkGeoCloudApplicationException Exception { get; }
    public CloudElevationPointResult(double elevation, PointShape point, ThinkGeoCloudApplicationException exception);
    [CompilerGeneratedAttribute]
[IsReadOnlyAttribute]
public double get_Elevation();
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public PointShape get_Point();
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public ThinkGeoCloudApplicationException get_Exception();
}
[ObfuscationAttribute]
public class ThinkGeo.Core.CloudElevationResult : object {
    [CompilerGeneratedAttribute]
private Collection`1<CloudElevationPointResult> <ElevationPoints>k__BackingField;
    [CompilerGeneratedAttribute]
private CloudElevationPointResult <HighestElevationPoint>k__BackingField;
    [CompilerGeneratedAttribute]
private CloudElevationPointResult <LowestElevationPoint>k__BackingField;
    [CompilerGeneratedAttribute]
private double <AverageElevation>k__BackingField;
    public Collection`1<CloudElevationPointResult> ElevationPoints { get; }
    public CloudElevationPointResult HighestElevationPoint { get; }
    public CloudElevationPointResult LowestElevationPoint { get; }
    public double AverageElevation { get; }
    public CloudElevationResult(CloudElevationPointResult highestElevationPoint, CloudElevationPointResult lowestElevationPoint, double averageElevation);
    [CompilerGeneratedAttribute]
public Collection`1<CloudElevationPointResult> get_ElevationPoints();
    [CompilerGeneratedAttribute]
public CloudElevationPointResult get_HighestElevationPoint();
    [CompilerGeneratedAttribute]
public CloudElevationPointResult get_LowestElevationPoint();
    [CompilerGeneratedAttribute]
public double get_AverageElevation();
}
[ExtensionAttribute]
[ObfuscationAttribute]
internal static class ThinkGeo.Core.CloudExtensionHelper : object {
    internal static WebRequest CreateWebRequest(string baseUri, string apiPath, string method, string parameters, string body, int timeoutInSeconds, IWebProxy webProxy);
    [AsyncStateMachineAttribute("ThinkGeo.Core.CloudExtensionHelper/<CreateWebRequestAsync>d__1")]
internal static Task`1<WebRequest> CreateWebRequestAsync(string baseUri, string apiPath, string method, string parameters, string body, int timeoutInSeconds, IWebProxy webProxy);
    [ExtensionAttribute]
internal static T ReadAnonymousObject(WebResponse response, T anonymousObject);
    [ExtensionAttribute]
internal static CloudGeoJObject ReadAnonymousObject(WebResponse response);
    [ExtensionAttribute]
internal static Byte[] ReadRaw(WebResponse response);
    [ExtensionAttribute]
internal static string ReadContentAsString(WebResponse webResponse, Encoding encoding);
}
[ObfuscationAttribute]
public class ThinkGeo.Core.CloudGeocodingLocation : object {
    [CompilerGeneratedAttribute]
private PointShape <LocationPoint>k__BackingField;
    [CompilerGeneratedAttribute]
private string <LocationName>k__BackingField;
    [CompilerGeneratedAttribute]
private string <LocationType>k__BackingField;
    [CompilerGeneratedAttribute]
private RectangleShape <BoundingBox>k__BackingField;
    [CompilerGeneratedAttribute]
private BaseShape <Shape>k__BackingField;
    [CompilerGeneratedAttribute]
private Dictionary`2<string, string> <Properties>k__BackingField;
    public PointShape LocationPoint { get; public set; }
    public string LocationName { get; public set; }
    public string LocationType { get; public set; }
    public RectangleShape BoundingBox { get; public set; }
    public BaseShape Shape { get; public set; }
    public Dictionary`2<string, string> Properties { get; public set; }
    [CompilerGeneratedAttribute]
public PointShape get_LocationPoint();
    [CompilerGeneratedAttribute]
public void set_LocationPoint(PointShape value);
    [CompilerGeneratedAttribute]
public string get_LocationName();
    [CompilerGeneratedAttribute]
public void set_LocationName(string value);
    [CompilerGeneratedAttribute]
public string get_LocationType();
    [CompilerGeneratedAttribute]
public void set_LocationType(string value);
    [CompilerGeneratedAttribute]
public RectangleShape get_BoundingBox();
    [CompilerGeneratedAttribute]
public void set_BoundingBox(RectangleShape value);
    [CompilerGeneratedAttribute]
public BaseShape get_Shape();
    [CompilerGeneratedAttribute]
public void set_Shape(BaseShape value);
    [CompilerGeneratedAttribute]
public Dictionary`2<string, string> get_Properties();
    [CompilerGeneratedAttribute]
public void set_Properties(Dictionary`2<string, string> value);
}
[FlagsAttribute]
[ObfuscationAttribute]
public enum ThinkGeo.Core.CloudGeocodingLocationType : Enum {
    public int value__;
    public static CloudGeocodingLocationType Default;
    public static CloudGeocodingLocationType Country;
    public static CloudGeocodingLocationType State;
    public static CloudGeocodingLocationType County;
    public static CloudGeocodingLocationType City;
    public static CloudGeocodingLocationType Street;
    public static CloudGeocodingLocationType Address;
    public static CloudGeocodingLocationType Zipcode;
    public static CloudGeocodingLocationType Locality;
    public static CloudGeocodingLocationType Town;
    public static CloudGeocodingLocationType Neighbourhood;
    public static CloudGeocodingLocationType Place;
    public static CloudGeocodingLocationType District;
}
[ObfuscationAttribute]
public class ThinkGeo.Core.CloudGeocodingOptions : object {
    [CompilerGeneratedAttribute]
private bool <Autocomplete>k__BackingField;
    [CompilerGeneratedAttribute]
private int <MaxResults>k__BackingField;
    [CompilerGeneratedAttribute]
private RectangleShape <BBox>k__BackingField;
    [CompilerGeneratedAttribute]
private CloudGeocodingResultDetail <ResultDetail>k__BackingField;
    [CompilerGeneratedAttribute]
private CloudGeocodingSearchMode <SearchMode>k__BackingField;
    [CompilerGeneratedAttribute]
private CloudGeocodingLocationType <LocationType>k__BackingField;
    [CompilerGeneratedAttribute]
private IEnumerable`1<string> <Countries>k__BackingField;
    [CompilerGeneratedAttribute]
private IEnumerable`1<string> <Language>k__BackingField;
    [CompilerGeneratedAttribute]
private int <ResultProjectionInSrid>k__BackingField;
    [CompilerGeneratedAttribute]
private string <ResultProjectionInProj4String>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <Debug>k__BackingField;
    public bool Autocomplete { get; public set; }
    public int MaxResults { get; public set; }
    public RectangleShape BBox { get; public set; }
    public CloudGeocodingResultDetail ResultDetail { get; public set; }
    public CloudGeocodingSearchMode SearchMode { get; public set; }
    public CloudGeocodingLocationType LocationType { get; public set; }
    public IEnumerable`1<string> Countries { get; public set; }
    public IEnumerable`1<string> Language { get; public set; }
    public int ResultProjectionInSrid { get; public set; }
    public string ResultProjectionInProj4String { get; public set; }
    public bool Debug { get; public set; }
    [CompilerGeneratedAttribute]
public bool get_Autocomplete();
    [CompilerGeneratedAttribute]
public void set_Autocomplete(bool value);
    [CompilerGeneratedAttribute]
public int get_MaxResults();
    [CompilerGeneratedAttribute]
public void set_MaxResults(int value);
    [CompilerGeneratedAttribute]
public RectangleShape get_BBox();
    [CompilerGeneratedAttribute]
public void set_BBox(RectangleShape value);
    [CompilerGeneratedAttribute]
public CloudGeocodingResultDetail get_ResultDetail();
    [CompilerGeneratedAttribute]
public void set_ResultDetail(CloudGeocodingResultDetail value);
    [CompilerGeneratedAttribute]
public CloudGeocodingSearchMode get_SearchMode();
    [CompilerGeneratedAttribute]
public void set_SearchMode(CloudGeocodingSearchMode value);
    [CompilerGeneratedAttribute]
public CloudGeocodingLocationType get_LocationType();
    [CompilerGeneratedAttribute]
public void set_LocationType(CloudGeocodingLocationType value);
    [CompilerGeneratedAttribute]
public IEnumerable`1<string> get_Countries();
    [CompilerGeneratedAttribute]
public void set_Countries(IEnumerable`1<string> value);
    [CompilerGeneratedAttribute]
public IEnumerable`1<string> get_Language();
    [CompilerGeneratedAttribute]
public void set_Language(IEnumerable`1<string> value);
    [CompilerGeneratedAttribute]
public int get_ResultProjectionInSrid();
    [CompilerGeneratedAttribute]
public void set_ResultProjectionInSrid(int value);
    [CompilerGeneratedAttribute]
public string get_ResultProjectionInProj4String();
    [CompilerGeneratedAttribute]
public void set_ResultProjectionInProj4String(string value);
    [CompilerGeneratedAttribute]
public bool get_Debug();
    [CompilerGeneratedAttribute]
public void set_Debug(bool value);
}
[ObfuscationAttribute]
public class ThinkGeo.Core.CloudGeocodingResult : object {
    [CompilerGeneratedAttribute]
private Collection`1<CloudGeocodingLocation> <Locations>k__BackingField;
    [CompilerGeneratedAttribute]
private ThinkGeoCloudApplicationException <Exception>k__BackingField;
    public Collection`1<CloudGeocodingLocation> Locations { get; }
    public ThinkGeoCloudApplicationException Exception { get; }
    public CloudGeocodingResult(IEnumerable`1<CloudGeocodingLocation> locations, ThinkGeoCloudApplicationException exception);
    [CompilerGeneratedAttribute]
public Collection`1<CloudGeocodingLocation> get_Locations();
    [CompilerGeneratedAttribute]
public ThinkGeoCloudApplicationException get_Exception();
}
[ObfuscationAttribute]
public enum ThinkGeo.Core.CloudGeocodingResultDetail : Enum {
    public int value__;
    public static CloudGeocodingResultDetail Default;
    public static CloudGeocodingResultDetail Verbose;
    public static CloudGeocodingResultDetail Standard;
}
[ObfuscationAttribute]
public enum ThinkGeo.Core.CloudGeocodingSearchMode : Enum {
    public int value__;
    public static CloudGeocodingSearchMode Default;
    public static CloudGeocodingSearchMode ExactMatch;
    public static CloudGeocodingSearchMode FuzzyMatch;
}
[ObfuscationAttribute]
internal class ThinkGeo.Core.CloudGeoJObject : object {
    [ObfuscationAttribute]
private string key;
    [ObfuscationAttribute]
private object value;
    public string Key { get; public set; }
    public object Value { get; public set; }
    public CloudGeoJObject(string key, object value);
    public string get_Key();
    public void set_Key(string value);
    public object get_Value();
    public void set_Value(object value);
}
[ObfuscationAttribute]
public class ThinkGeo.Core.CloudGradeResult : object {
    [CompilerGeneratedAttribute]
private Collection`1<CloudGradeSegment> <GradeSegments>k__BackingField;
    [CompilerGeneratedAttribute]
private CloudGradeSegment <HighestGradeSegment>k__BackingField;
    [CompilerGeneratedAttribute]
private CloudGradeSegment <LowestGradeSegment>k__BackingField;
    [CompilerGeneratedAttribute]
private double <AverageGrade>k__BackingField;
    public Collection`1<CloudGradeSegment> GradeSegments { get; }
    public CloudGradeSegment HighestGradeSegment { get; }
    public CloudGradeSegment LowestGradeSegment { get; }
    public double AverageGrade { get; }
    public CloudGradeResult(CloudGradeSegment highestGradeSegment, CloudGradeSegment lowestGradeSegment, double averageGrade);
    [CompilerGeneratedAttribute]
public Collection`1<CloudGradeSegment> get_GradeSegments();
    [CompilerGeneratedAttribute]
public CloudGradeSegment get_HighestGradeSegment();
    [CompilerGeneratedAttribute]
public CloudGradeSegment get_LowestGradeSegment();
    [CompilerGeneratedAttribute]
public double get_AverageGrade();
}
[ObfuscationAttribute]
public class ThinkGeo.Core.CloudGradeSegment : ValueType {
    [CompilerGeneratedAttribute]
private double <Grade>k__BackingField;
    [CompilerGeneratedAttribute]
private LineShape <GradeLine>k__BackingField;
    [CompilerGeneratedAttribute]
private double <StartingElevation>k__BackingField;
    [CompilerGeneratedAttribute]
private double <EndingElevation>k__BackingField;
    public double Grade { get; }
    public LineShape GradeLine { get; }
    public double StartingElevation { get; }
    public double EndingElevation { get; }
    public CloudGradeSegment(double grade, LineShape gradeLine, double startingElevation, double endingElevation);
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public double get_Grade();
    [CompilerGeneratedAttribute]
[IsReadOnlyAttribute]
public LineShape get_GradeLine();
    [CompilerGeneratedAttribute]
[IsReadOnlyAttribute]
public double get_StartingElevation();
    [CompilerGeneratedAttribute]
[IsReadOnlyAttribute]
public double get_EndingElevation();
}
[ObfuscationAttribute]
internal abstract class ThinkGeo.Core.CloudJsonConverter`1 : object {
    public abstract virtual T ReadJson(CloudGeoJObject jObject, Type objectType);
    public abstract virtual void WriteJson(CloudGeoJObject jObject, T value);
}
[ObfuscationAttribute]
internal class ThinkGeo.Core.CloudJsonConverterAttribute : Attribute {
    [ObfuscationAttribute]
private Type type;
    public Type Type { get; public set; }
    public CloudJsonConverterAttribute(Type type);
    public Type get_Type();
    public void set_Type(Type value);
}
[ObfuscationAttribute]
internal class ThinkGeo.Core.CloudJsonPropertyAttribute : Attribute {
    [ObfuscationAttribute]
private string name;
    public string Name { get; public set; }
    public CloudJsonPropertyAttribute(string name);
    public string get_Name();
    public void set_Name(string value);
}
[ObfuscationAttribute]
internal class ThinkGeo.Core.CloudJsonSerializer : object {
    [ObfuscationAttribute]
private static Regex jsonRegex;
    [ObfuscationAttribute]
private static Regex fieldNameRegex;
    [ObfuscationAttribute]
private static BindingFlags bindingFlags;
    [ObfuscationAttribute]
private Encoding encoding;
    [ObfuscationAttribute]
private CloudGeoJObject jObject;
    public Encoding Encoding { get; public set; }
    private static CloudJsonSerializer();
    public Encoding get_Encoding();
    public void set_Encoding(Encoding value);
    public string Serialize();
    private static string SerializeCore(CloudGeoJObject jObject);
    public CloudGeoJObject Deserialize(string json);
    public CloudGeoJObject Deserialize(Stream stream);
    private CloudGeoJObject DeserializeCore(string json);
    private string GetWholevalue(MatchCollection matches, Match currentMatch, string json, string value, Int32& i);
    public static string Serialize(CloudGeoJObject jObject);
    public static string Serialize(T obj);
    private static object SerializeCore(object obj, FieldInfo fieldInfo);
    public static T Deserialize(string json, T obj);
    private static object DeserializeCore(object jObject, Type type, Type parentType, FieldInfo field);
    private static void CreateIEnumerableObject(object result, CloudGeoJObject jObject, Type type, Type parentType, FieldInfo field);
    private static object CreateNormalObject(object jObject, object result);
    private static Collection`1<MemberInfo> GetMembers(Type type);
    private static bool IsSerializable(FieldInfo field);
    private static object CreateArray(CloudGeoJObject jObject, Type type, Type parentType, FieldInfo field);
    private static void SetValue(Array results, int rank, List`1<int> indecies, Collection`1<object> values, Int32& index);
    private static object CreateSimpleObject(CloudGeoJObject jObject, Type type);
    private static object GetSimpleTypeResult(Type type, object value);
    private static bool IsSimpleType(Type type);
}
[ObfuscationAttribute]
internal static class ThinkGeo.Core.CloudJsonSerializerUtils : object {
    internal static T DeserializeObject(string json);
    internal static T DeserializeAnonymousType(string json, T anonymousObject);
    internal static string SerializeObject(T obj);
}
[ObfuscationAttribute]
[FlagsAttribute]
public enum ThinkGeo.Core.CloudLocationCategories : Enum {
    public UInt32 value__;
    public static CloudLocationCategories None;
    public static CloudLocationCategories Common;
    public static CloudLocationCategories All;
    public static CloudLocationCategories Aeroway;
    public static CloudLocationCategories Amenity;
    public static CloudLocationCategories Barrier;
    public static CloudLocationCategories Boundary;
    public static CloudLocationCategories Building;
    public static CloudLocationCategories Education;
    public static CloudLocationCategories Entertainment;
    public static CloudLocationCategories Financial;
    public static CloudLocationCategories Healthcare;
    public static CloudLocationCategories Historic;
    public static CloudLocationCategories Leisure;
    public static CloudLocationCategories Manmade;
    public static CloudLocationCategories Natural;
    public static CloudLocationCategories Rail;
    public static CloudLocationCategories Power;
    public static CloudLocationCategories Road;
    public static CloudLocationCategories Shop;
    public static CloudLocationCategories Sport;
    public static CloudLocationCategories Sustenance;
    public static CloudLocationCategories Tourism;
    public static CloudLocationCategories Transportation;
    public static CloudLocationCategories Waterway;
    public static CloudLocationCategories Intersection;
    public static CloudLocationCategories AddressPoint;
    public static CloudLocationCategories Others;
}
[ObsoleteAttribute("This class is deprecated and will be removed after v13.3. Please use ThinkGeo Cloud Layers to display ThinkGeo Maps.")]
public class ThinkGeo.Core.CloudMapClient : object {
    [ObfuscationAttribute]
private string token;
    [ObfuscationAttribute]
private int timeoutInSeconds;
    [ObfuscationAttribute]
private IWebProxy webProxy;
    [ObfuscationAttribute]
private string clientId;
    [ObfuscationAttribute]
private string clientSecret;
    [ObfuscationAttribute]
private bool isOpen;
    [ObfuscationAttribute]
private int baseUriIndex;
    private static int th0=;
    private static string mRQ=;
    private Timer mhQ=;
    [ObfuscationAttribute]
private Collection`1<Uri> baseUris;
    private bool tx0=;
    public bool IsOpen { get; public set; }
    public Collection`1<Uri> Uris { get; }
    public int TimeoutInSeconds { get; public set; }
    public string ClientId { get; public set; }
    public string ClientSecret { get; public set; }
    public IWebProxy WebProxy { get; public set; }
    public CloudMapClient(string clientId, string clientSecret);
    public bool get_IsOpen();
    public void set_IsOpen(bool value);
    public void Open();
    public Collection`1<Uri> get_Uris();
    public int get_TimeoutInSeconds();
    public void set_TimeoutInSeconds(int value);
    public string get_ClientId();
    public void set_ClientId(string value);
    public string get_ClientSecret();
    public void set_ClientSecret(string value);
    public IWebProxy get_WebProxy();
    public void set_WebProxy(IWebProxy value);
    public WebRequest CreateWebRequest(string apiPath, string method, string parameters, string body, int timeoutInSeconds, IWebProxy webProxy, bool isNeedToken);
    private string Nis=();
    public virtual void Dispose();
    private string 0h0=();
    private void nRQ=(object state);
}
[ObfuscationAttribute]
public enum ThinkGeo.Core.CloudMapProjection : Enum {
    public int value__;
    public static CloudMapProjection SphericalMercator;
}
[ObfuscationAttribute]
public class ThinkGeo.Core.CloudMapsQueryCustomQueryOptions : object {
    [CompilerGeneratedAttribute]
private string <QueryLayer>k__BackingField;
    [CompilerGeneratedAttribute]
private CloudMapsQueryCustomQueryType <QueryType>k__BackingField;
    [CompilerGeneratedAttribute]
private BaseShape <Shape>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<int> <Srid>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Proj4String>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<double> <Distance>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<DistanceUnit> <DistanceUnit>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<double> <SearchRadius>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<DistanceUnit> <SearchRadiusUnit>k__BackingField;
    [CompilerGeneratedAttribute]
private int <MaxResults>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <ReturnFeatureAttributes>k__BackingField;
    [CompilerGeneratedAttribute]
private IEnumerable`1<string> <FeatureAttributesToReturn>k__BackingField;
    public string QueryLayer { get; public set; }
    public CloudMapsQueryCustomQueryType QueryType { get; public set; }
    [CloudJsonPropertyAttribute("wkt")]
[CloudJsonConverterAttribute("ThinkGeo.Core.CloudShapeWktConverter")]
public BaseShape Shape { get; public set; }
    public Nullable`1<int> Srid { get; public set; }
    public string Proj4String { get; public set; }
    public Nullable`1<double> Distance { get; public set; }
    public Nullable`1<DistanceUnit> DistanceUnit { get; public set; }
    public Nullable`1<double> SearchRadius { get; public set; }
    public Nullable`1<DistanceUnit> SearchRadiusUnit { get; public set; }
    public int MaxResults { get; public set; }
    public bool ReturnFeatureAttributes { get; public set; }
    public IEnumerable`1<string> FeatureAttributesToReturn { get; public set; }
    [CompilerGeneratedAttribute]
public string get_QueryLayer();
    [CompilerGeneratedAttribute]
public void set_QueryLayer(string value);
    [CompilerGeneratedAttribute]
public CloudMapsQueryCustomQueryType get_QueryType();
    [CompilerGeneratedAttribute]
public void set_QueryType(CloudMapsQueryCustomQueryType value);
    [CompilerGeneratedAttribute]
public BaseShape get_Shape();
    [CompilerGeneratedAttribute]
public void set_Shape(BaseShape value);
    [CompilerGeneratedAttribute]
public Nullable`1<int> get_Srid();
    [CompilerGeneratedAttribute]
public void set_Srid(Nullable`1<int> value);
    [CompilerGeneratedAttribute]
public string get_Proj4String();
    [CompilerGeneratedAttribute]
public void set_Proj4String(string value);
    [CompilerGeneratedAttribute]
public Nullable`1<double> get_Distance();
    [CompilerGeneratedAttribute]
public void set_Distance(Nullable`1<double> value);
    [CompilerGeneratedAttribute]
public Nullable`1<DistanceUnit> get_DistanceUnit();
    [CompilerGeneratedAttribute]
public void set_DistanceUnit(Nullable`1<DistanceUnit> value);
    [CompilerGeneratedAttribute]
public Nullable`1<double> get_SearchRadius();
    [CompilerGeneratedAttribute]
public void set_SearchRadius(Nullable`1<double> value);
    [CompilerGeneratedAttribute]
public Nullable`1<DistanceUnit> get_SearchRadiusUnit();
    [CompilerGeneratedAttribute]
public void set_SearchRadiusUnit(Nullable`1<DistanceUnit> value);
    [CompilerGeneratedAttribute]
public int get_MaxResults();
    [CompilerGeneratedAttribute]
public void set_MaxResults(int value);
    [CompilerGeneratedAttribute]
public bool get_ReturnFeatureAttributes();
    [CompilerGeneratedAttribute]
public void set_ReturnFeatureAttributes(bool value);
    [CompilerGeneratedAttribute]
public IEnumerable`1<string> get_FeatureAttributesToReturn();
    [CompilerGeneratedAttribute]
public void set_FeatureAttributesToReturn(IEnumerable`1<string> value);
}
[ObfuscationAttribute]
public enum ThinkGeo.Core.CloudMapsQueryCustomQueryType : Enum {
    public int value__;
    public static CloudMapsQueryCustomQueryType Within;
    public static CloudMapsQueryCustomQueryType Containing;
    public static CloudMapsQueryCustomQueryType Intersecting;
    public static CloudMapsQueryCustomQueryType Overlapping;
    public static CloudMapsQueryCustomQueryType Touching;
    public static CloudMapsQueryCustomQueryType Nearest;
    public static CloudMapsQueryCustomQueryType WithinDistance;
}
[ObfuscationAttribute]
public class ThinkGeo.Core.CloudMapsQueryGetAttributesOfLayerResult : object {
    [CompilerGeneratedAttribute]
private Collection`1<string> <Attributes>k__BackingField;
    [CompilerGeneratedAttribute]
private ThinkGeoCloudApplicationException <Exception>k__BackingField;
    public Collection`1<string> Attributes { get; public set; }
    public ThinkGeoCloudApplicationException Exception { get; public set; }
    [CompilerGeneratedAttribute]
public Collection`1<string> get_Attributes();
    [CompilerGeneratedAttribute]
public void set_Attributes(Collection`1<string> value);
    [CompilerGeneratedAttribute]
public ThinkGeoCloudApplicationException get_Exception();
    [CompilerGeneratedAttribute]
public void set_Exception(ThinkGeoCloudApplicationException value);
}
[ObfuscationAttribute]
public class ThinkGeo.Core.CloudMapsQueryGetLayersResult : object {
    [CompilerGeneratedAttribute]
private Collection`1<string> <QueryLayers>k__BackingField;
    [CompilerGeneratedAttribute]
private ThinkGeoCloudApplicationException <Exception>k__BackingField;
    public Collection`1<string> QueryLayers { get; public set; }
    public ThinkGeoCloudApplicationException Exception { get; public set; }
    [CompilerGeneratedAttribute]
public Collection`1<string> get_QueryLayers();
    [CompilerGeneratedAttribute]
public void set_QueryLayers(Collection`1<string> value);
    [CompilerGeneratedAttribute]
public ThinkGeoCloudApplicationException get_Exception();
    [CompilerGeneratedAttribute]
public void set_Exception(ThinkGeoCloudApplicationException value);
}
[ObfuscationAttribute]
public static class ThinkGeo.Core.CloudMapsQueryLayers : object {
    public static string Countries;
    public static string States;
    public static string Roads;
    public static string Rail;
    public static string Addresses;
    public static string Cities;
    public static string LandUse;
    public static string Places;
    public static string Pois;
    public static string Transport;
    public static string Water;
    public static string Waterways;
    public static string Buildings;
}
[ObfuscationAttribute]
public class ThinkGeo.Core.CloudMapsQueryNearestQueryOptions : object {
    [CompilerGeneratedAttribute]
private bool <ReturnFeatureAttributes>k__BackingField;
    [CompilerGeneratedAttribute]
private IEnumerable`1<string> <FeatureAttributesToReturn>k__BackingField;
    public bool ReturnFeatureAttributes { get; public set; }
    public IEnumerable`1<string> FeatureAttributesToReturn { get; public set; }
    [CompilerGeneratedAttribute]
public bool get_ReturnFeatureAttributes();
    [CompilerGeneratedAttribute]
public void set_ReturnFeatureAttributes(bool value);
    [CompilerGeneratedAttribute]
public IEnumerable`1<string> get_FeatureAttributesToReturn();
    [CompilerGeneratedAttribute]
public void set_FeatureAttributesToReturn(IEnumerable`1<string> value);
}
[ObfuscationAttribute]
public class ThinkGeo.Core.CloudMapsQueryResult : object {
    [CompilerGeneratedAttribute]
private Collection`1<Feature> <Features>k__BackingField;
    [CompilerGeneratedAttribute]
private ThinkGeoCloudApplicationException <Exception>k__BackingField;
    public Collection`1<Feature> Features { get; public set; }
    public ThinkGeoCloudApplicationException Exception { get; public set; }
    [CompilerGeneratedAttribute]
public Collection`1<Feature> get_Features();
    [CompilerGeneratedAttribute]
public void set_Features(Collection`1<Feature> value);
    [CompilerGeneratedAttribute]
public ThinkGeoCloudApplicationException get_Exception();
    [CompilerGeneratedAttribute]
public void set_Exception(ThinkGeoCloudApplicationException value);
}
[ObfuscationAttribute]
public class ThinkGeo.Core.CloudMapsQuerySpatialQueryOptions : object {
    [CompilerGeneratedAttribute]
private int <MaxResults>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <ReturnFeatureAttributes>k__BackingField;
    [CompilerGeneratedAttribute]
private IEnumerable`1<string> <FeatureAttributesToReturn>k__BackingField;
    public int MaxResults { get; public set; }
    public bool ReturnFeatureAttributes { get; public set; }
    public IEnumerable`1<string> FeatureAttributesToReturn { get; public set; }
    [CompilerGeneratedAttribute]
public int get_MaxResults();
    [CompilerGeneratedAttribute]
public void set_MaxResults(int value);
    [CompilerGeneratedAttribute]
public bool get_ReturnFeatureAttributes();
    [CompilerGeneratedAttribute]
public void set_ReturnFeatureAttributes(bool value);
    [CompilerGeneratedAttribute]
public IEnumerable`1<string> get_FeatureAttributesToReturn();
    [CompilerGeneratedAttribute]
public void set_FeatureAttributesToReturn(IEnumerable`1<string> value);
}
[ObfuscationAttribute]
public enum ThinkGeo.Core.CloudRasterMapType : Enum {
    public int value__;
    public static CloudRasterMapType Default;
    public static CloudRasterMapType Light;
    public static CloudRasterMapType Dark;
    public static CloudRasterMapType Hybrid;
    public static CloudRasterMapType Aerial;
    public static CloudRasterMapType TransparentBackground;
}
internal class ThinkGeo.Core.CloudRasterTileInfo : object {
    [ObfuscationAttribute]
private RectangleShape boundingBox;
    [ObfuscationAttribute]
private RasterTile rasterTile;
    [ObfuscationAttribute]
private Exception exception;
    public RectangleShape BoundingBox { get; public set; }
    public RasterTile RasterTile { get; public set; }
    public string TileId { get; }
    internal Exception Exception { get; internal set; }
    public CloudRasterTileInfo(RasterTile rasterTile, RectangleShape boundingBox);
    public RectangleShape get_BoundingBox();
    public void set_BoundingBox(RectangleShape value);
    public RasterTile get_RasterTile();
    public void set_RasterTile(RasterTile value);
    public string get_TileId();
    internal Exception get_Exception();
    internal void set_Exception(Exception value);
    public sealed virtual void Dispose();
    private void Dispose(bool disposing);
}
[ObfuscationAttribute]
internal class ThinkGeo.Core.CloudRequestAllTimeZoneNamesFromResponse : object {
    [CompilerGeneratedAttribute]
private Collection`1<string> <data>k__BackingField;
    [CompilerGeneratedAttribute]
private CloudRequestResponseError <error>k__BackingField;
    public Collection`1<string> data { get; public set; }
    public CloudRequestResponseError error { get; public set; }
    [CompilerGeneratedAttribute]
public Collection`1<string> get_data();
    [CompilerGeneratedAttribute]
public void set_data(Collection`1<string> value);
    [CompilerGeneratedAttribute]
public CloudRequestResponseError get_error();
    [CompilerGeneratedAttribute]
public void set_error(CloudRequestResponseError value);
}
[ObfuscationAttribute]
internal class ThinkGeo.Core.CloudRequestAllTimeZoneResponse : object {
    [CompilerGeneratedAttribute]
private CloudRequestAllTimeZoneResponseData <data>k__BackingField;
    [CompilerGeneratedAttribute]
private CloudRequestResponseError <error>k__BackingField;
    public CloudRequestAllTimeZoneResponseData data { get; public set; }
    public CloudRequestResponseError error { get; public set; }
    [CompilerGeneratedAttribute]
public CloudRequestAllTimeZoneResponseData get_data();
    [CompilerGeneratedAttribute]
public void set_data(CloudRequestAllTimeZoneResponseData value);
    [CompilerGeneratedAttribute]
public CloudRequestResponseError get_error();
    [CompilerGeneratedAttribute]
public void set_error(CloudRequestResponseError value);
}
[ObfuscationAttribute]
internal class ThinkGeo.Core.CloudRequestAllTimeZoneResponseData : object {
    public CloudRequestTimeZone[] timezones;
}
[ObfuscationAttribute]
internal class ThinkGeo.Core.CloudRequestColorResponse : object {
    [CompilerGeneratedAttribute]
private CloudRequestColorResponseData <Data>k__BackingField;
    public CloudRequestColorResponseData Data { get; public set; }
    [CompilerGeneratedAttribute]
public CloudRequestColorResponseData get_Data();
    [CompilerGeneratedAttribute]
public void set_Data(CloudRequestColorResponseData value);
}
[ObfuscationAttribute]
internal class ThinkGeo.Core.CloudRequestColorResponseData : object {
    [CompilerGeneratedAttribute]
private List`1<string> <Colors>k__BackingField;
    public List`1<string> Colors { get; public set; }
    [CompilerGeneratedAttribute]
public List`1<string> get_Colors();
    [CompilerGeneratedAttribute]
public void set_Colors(List`1<string> value);
}
[ObfuscationAttribute]
internal class ThinkGeo.Core.CloudRequestElevationResponse : object {
    [CompilerGeneratedAttribute]
private CloudRequestElevationResponseData <Data>k__BackingField;
    [CompilerGeneratedAttribute]
private CloudRequestResponseError <error>k__BackingField;
    public CloudRequestElevationResponseData Data { get; public set; }
    public CloudRequestResponseError error { get; public set; }
    [CompilerGeneratedAttribute]
public CloudRequestElevationResponseData get_Data();
    [CompilerGeneratedAttribute]
public void set_Data(CloudRequestElevationResponseData value);
    [CompilerGeneratedAttribute]
public CloudRequestResponseError get_error();
    [CompilerGeneratedAttribute]
public void set_error(CloudRequestResponseError value);
}
[ObfuscationAttribute]
internal class ThinkGeo.Core.CloudRequestElevationResponseData : object {
    [CompilerGeneratedAttribute]
private double <elevation>k__BackingField;
    public double elevation { get; public set; }
    [CompilerGeneratedAttribute]
public double get_elevation();
    [CompilerGeneratedAttribute]
public void set_elevation(double value);
}
[ObfuscationAttribute]
internal class ThinkGeo.Core.CloudRequestElevationResultOfMultiPointsResponse : object {
    [CompilerGeneratedAttribute]
private CloudRequestElevationResultOfMultiPointsResponseDataItem[] <data>k__BackingField;
    [CompilerGeneratedAttribute]
private CloudRequestElevationResultOfMultiPointsResponseLowestElevationPoint <lowestElevationPoint>k__BackingField;
    [CompilerGeneratedAttribute]
private CloudRequestElevationResultOfMultiPointsResponseHighestElevationPoint <highestElevationPoint>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<double> <averageElevation>k__BackingField;
    [CompilerGeneratedAttribute]
private CloudRequestResponseError <error>k__BackingField;
    public CloudRequestElevationResultOfMultiPointsResponseDataItem[] data { get; public set; }
    public CloudRequestElevationResultOfMultiPointsResponseLowestElevationPoint lowestElevationPoint { get; public set; }
    public CloudRequestElevationResultOfMultiPointsResponseHighestElevationPoint highestElevationPoint { get; public set; }
    public Nullable`1<double> averageElevation { get; public set; }
    public CloudRequestResponseError error { get; public set; }
    [CompilerGeneratedAttribute]
public CloudRequestElevationResultOfMultiPointsResponseDataItem[] get_data();
    [CompilerGeneratedAttribute]
public void set_data(CloudRequestElevationResultOfMultiPointsResponseDataItem[] value);
    [CompilerGeneratedAttribute]
public CloudRequestElevationResultOfMultiPointsResponseLowestElevationPoint get_lowestElevationPoint();
    [CompilerGeneratedAttribute]
public void set_lowestElevationPoint(CloudRequestElevationResultOfMultiPointsResponseLowestElevationPoint value);
    [CompilerGeneratedAttribute]
public CloudRequestElevationResultOfMultiPointsResponseHighestElevationPoint get_highestElevationPoint();
    [CompilerGeneratedAttribute]
public void set_highestElevationPoint(CloudRequestElevationResultOfMultiPointsResponseHighestElevationPoint value);
    [CompilerGeneratedAttribute]
public Nullable`1<double> get_averageElevation();
    [CompilerGeneratedAttribute]
public void set_averageElevation(Nullable`1<double> value);
    [CompilerGeneratedAttribute]
public CloudRequestResponseError get_error();
    [CompilerGeneratedAttribute]
public void set_error(CloudRequestResponseError value);
}
[ObfuscationAttribute]
internal class ThinkGeo.Core.CloudRequestElevationResultOfMultiPointsResponseDataItem : object {
    [CompilerGeneratedAttribute]
private Dictionary`2<string, String[]> <errors>k__BackingField;
    [CompilerGeneratedAttribute]
private double <elevation>k__BackingField;
    public Dictionary`2<string, String[]> errors { get; public set; }
    public double elevation { get; public set; }
    [CompilerGeneratedAttribute]
public Dictionary`2<string, String[]> get_errors();
    [CompilerGeneratedAttribute]
public void set_errors(Dictionary`2<string, String[]> value);
    [CompilerGeneratedAttribute]
public double get_elevation();
    [CompilerGeneratedAttribute]
public void set_elevation(double value);
}
[ObfuscationAttribute]
internal class ThinkGeo.Core.CloudRequestElevationResultOfMultiPointsResponseHighestElevationPoint : object {
    [CompilerGeneratedAttribute]
private double <elevation>k__BackingField;
    [CompilerGeneratedAttribute]
private string <wellKnownText>k__BackingField;
    public double elevation { get; public set; }
    public string wellKnownText { get; public set; }
    [CompilerGeneratedAttribute]
public double get_elevation();
    [CompilerGeneratedAttribute]
public void set_elevation(double value);
    [CompilerGeneratedAttribute]
public string get_wellKnownText();
    [CompilerGeneratedAttribute]
public void set_wellKnownText(string value);
}
[ObfuscationAttribute]
internal class ThinkGeo.Core.CloudRequestElevationResultOfMultiPointsResponseLowestElevationPoint : object {
    [CompilerGeneratedAttribute]
private double <elevation>k__BackingField;
    [CompilerGeneratedAttribute]
private string <wellKnownText>k__BackingField;
    public double elevation { get; public set; }
    public string wellKnownText { get; public set; }
    [CompilerGeneratedAttribute]
public double get_elevation();
    [CompilerGeneratedAttribute]
public void set_elevation(double value);
    [CompilerGeneratedAttribute]
public string get_wellKnownText();
    [CompilerGeneratedAttribute]
public void set_wellKnownText(string value);
}
[ObfuscationAttribute]
internal class ThinkGeo.Core.CloudRequestElevationResultResponse : object {
    [CompilerGeneratedAttribute]
private CloudRequestElevationResultResponseDataItem[] <data>k__BackingField;
    [CompilerGeneratedAttribute]
private CloudRequestElevationResultResponseLowestElevationPoint <lowestElevationPoint>k__BackingField;
    [CompilerGeneratedAttribute]
private CloudRequestElevationResultResponseHighestElevationPoint <highestElevationPoint>k__BackingField;
    [CompilerGeneratedAttribute]
private double <averageElevation>k__BackingField;
    [CompilerGeneratedAttribute]
private CloudRequestResponseError <error>k__BackingField;
    public CloudRequestElevationResultResponseDataItem[] data { get; public set; }
    public CloudRequestElevationResultResponseLowestElevationPoint lowestElevationPoint { get; public set; }
    public CloudRequestElevationResultResponseHighestElevationPoint highestElevationPoint { get; public set; }
    public double averageElevation { get; public set; }
    public CloudRequestResponseError error { get; public set; }
    [CompilerGeneratedAttribute]
public CloudRequestElevationResultResponseDataItem[] get_data();
    [CompilerGeneratedAttribute]
public void set_data(CloudRequestElevationResultResponseDataItem[] value);
    [CompilerGeneratedAttribute]
public CloudRequestElevationResultResponseLowestElevationPoint get_lowestElevationPoint();
    [CompilerGeneratedAttribute]
public void set_lowestElevationPoint(CloudRequestElevationResultResponseLowestElevationPoint value);
    [CompilerGeneratedAttribute]
public CloudRequestElevationResultResponseHighestElevationPoint get_highestElevationPoint();
    [CompilerGeneratedAttribute]
public void set_highestElevationPoint(CloudRequestElevationResultResponseHighestElevationPoint value);
    [CompilerGeneratedAttribute]
public double get_averageElevation();
    [CompilerGeneratedAttribute]
public void set_averageElevation(double value);
    [CompilerGeneratedAttribute]
public CloudRequestResponseError get_error();
    [CompilerGeneratedAttribute]
public void set_error(CloudRequestResponseError value);
}
[ObfuscationAttribute]
internal class ThinkGeo.Core.CloudRequestElevationResultResponseDataItem : object {
    [CompilerGeneratedAttribute]
private double <elevation>k__BackingField;
    [CompilerGeneratedAttribute]
private string <wellKnownText>k__BackingField;
    public double elevation { get; public set; }
    public string wellKnownText { get; public set; }
    [CompilerGeneratedAttribute]
public double get_elevation();
    [CompilerGeneratedAttribute]
public void set_elevation(double value);
    [CompilerGeneratedAttribute]
public string get_wellKnownText();
    [CompilerGeneratedAttribute]
public void set_wellKnownText(string value);
}
[ObfuscationAttribute]
internal class ThinkGeo.Core.CloudRequestElevationResultResponseHighestElevationPoint : object {
    [CompilerGeneratedAttribute]
private double <elevation>k__BackingField;
    [CompilerGeneratedAttribute]
private string <wellKnownText>k__BackingField;
    public double elevation { get; public set; }
    public string wellKnownText { get; public set; }
    [CompilerGeneratedAttribute]
public double get_elevation();
    [CompilerGeneratedAttribute]
public void set_elevation(double value);
    [CompilerGeneratedAttribute]
public string get_wellKnownText();
    [CompilerGeneratedAttribute]
public void set_wellKnownText(string value);
}
[ObfuscationAttribute]
internal class ThinkGeo.Core.CloudRequestElevationResultResponseLowestElevationPoint : object {
    [CompilerGeneratedAttribute]
private double <elevation>k__BackingField;
    [CompilerGeneratedAttribute]
private string <wellKnownText>k__BackingField;
    public double elevation { get; public set; }
    public string wellKnownText { get; public set; }
    [CompilerGeneratedAttribute]
public double get_elevation();
    [CompilerGeneratedAttribute]
public void set_elevation(double value);
    [CompilerGeneratedAttribute]
public string get_wellKnownText();
    [CompilerGeneratedAttribute]
public void set_wellKnownText(string value);
}
[ObfuscationAttribute]
internal class ThinkGeo.Core.CloudRequestGeocodingResultResponse : object {
    [CompilerGeneratedAttribute]
private CloudRequestGeocodingResultResponseData <data>k__BackingField;
    [CompilerGeneratedAttribute]
private CloudRequestResponseError <error>k__BackingField;
    public CloudRequestGeocodingResultResponseData data { get; public set; }
    public CloudRequestResponseError error { get; public set; }
    [CompilerGeneratedAttribute]
public CloudRequestGeocodingResultResponseData get_data();
    [CompilerGeneratedAttribute]
public void set_data(CloudRequestGeocodingResultResponseData value);
    [CompilerGeneratedAttribute]
public CloudRequestResponseError get_error();
    [CompilerGeneratedAttribute]
public void set_error(CloudRequestResponseError value);
}
[ObfuscationAttribute]
internal class ThinkGeo.Core.CloudRequestGeocodingResultResponseData : object {
    [CompilerGeneratedAttribute]
private GeocodingLocationDto[] <locations>k__BackingField;
    public GeocodingLocationDto[] locations { get; public set; }
    [CompilerGeneratedAttribute]
public GeocodingLocationDto[] get_locations();
    [CompilerGeneratedAttribute]
public void set_locations(GeocodingLocationDto[] value);
}
[ObfuscationAttribute]
internal class ThinkGeo.Core.CloudRequestGetAttributesOfLayerResultResponse : object {
    [CompilerGeneratedAttribute]
private CloudRequestGetAttributesOfLayerResultResponseData <data>k__BackingField;
    [CompilerGeneratedAttribute]
private CloudRequestResponseError <error>k__BackingField;
    public CloudRequestGetAttributesOfLayerResultResponseData data { get; public set; }
    public CloudRequestResponseError error { get; public set; }
    [CompilerGeneratedAttribute]
public CloudRequestGetAttributesOfLayerResultResponseData get_data();
    [CompilerGeneratedAttribute]
public void set_data(CloudRequestGetAttributesOfLayerResultResponseData value);
    [CompilerGeneratedAttribute]
public CloudRequestResponseError get_error();
    [CompilerGeneratedAttribute]
public void set_error(CloudRequestResponseError value);
}
[ObfuscationAttribute]
internal class ThinkGeo.Core.CloudRequestGetAttributesOfLayerResultResponseData : object {
    [CompilerGeneratedAttribute]
private List`1<string> <attributes>k__BackingField;
    public List`1<string> attributes { get; public set; }
    [CompilerGeneratedAttribute]
public List`1<string> get_attributes();
    [CompilerGeneratedAttribute]
public void set_attributes(List`1<string> value);
}
[ObfuscationAttribute]
internal class ThinkGeo.Core.CloudRequestGetDistanceCostMatrixResultResponse : object {
    [CompilerGeneratedAttribute]
private CloudRoutingDistanceCostMatrixResult <data>k__BackingField;
    [CompilerGeneratedAttribute]
private CloudRequestResponseError <error>k__BackingField;
    public CloudRoutingDistanceCostMatrixResult data { get; public set; }
    public CloudRequestResponseError error { get; public set; }
    [CompilerGeneratedAttribute]
public CloudRoutingDistanceCostMatrixResult get_data();
    [CompilerGeneratedAttribute]
public void set_data(CloudRoutingDistanceCostMatrixResult value);
    [CompilerGeneratedAttribute]
public CloudRequestResponseError get_error();
    [CompilerGeneratedAttribute]
public void set_error(CloudRequestResponseError value);
}
[ObfuscationAttribute]
internal class ThinkGeo.Core.CloudRequestGetLayersResultResponse : object {
    [CompilerGeneratedAttribute]
private CloudRequestGetLayersResultResponseData <data>k__BackingField;
    [CompilerGeneratedAttribute]
private CloudRequestResponseError <error>k__BackingField;
    public CloudRequestGetLayersResultResponseData data { get; public set; }
    public CloudRequestResponseError error { get; public set; }
    [CompilerGeneratedAttribute]
public CloudRequestGetLayersResultResponseData get_data();
    [CompilerGeneratedAttribute]
public void set_data(CloudRequestGetLayersResultResponseData value);
    [CompilerGeneratedAttribute]
public CloudRequestResponseError get_error();
    [CompilerGeneratedAttribute]
public void set_error(CloudRequestResponseError value);
}
[ObfuscationAttribute]
internal class ThinkGeo.Core.CloudRequestGetLayersResultResponseData : object {
    [CompilerGeneratedAttribute]
private List`1<string> <layers>k__BackingField;
    public List`1<string> layers { get; public set; }
    [CompilerGeneratedAttribute]
public List`1<string> get_layers();
    [CompilerGeneratedAttribute]
public void set_layers(List`1<string> value);
}
[ObfuscationAttribute]
internal class ThinkGeo.Core.CloudRequestGetProjectGeometryResultResponseData : object {
    [CompilerGeneratedAttribute]
private string <wkt>k__BackingField;
    public string wkt { get; public set; }
    [CompilerGeneratedAttribute]
public string get_wkt();
    [CompilerGeneratedAttribute]
public void set_wkt(string value);
}
[ObfuscationAttribute]
internal class ThinkGeo.Core.CloudRequestGetRouteResultResponse : object {
    [CompilerGeneratedAttribute]
private CloudRoutingRouteResult <data>k__BackingField;
    [CompilerGeneratedAttribute]
private CloudRequestResponseError <error>k__BackingField;
    public CloudRoutingRouteResult data { get; public set; }
    public CloudRequestResponseError error { get; public set; }
    [CompilerGeneratedAttribute]
public CloudRoutingRouteResult get_data();
    [CompilerGeneratedAttribute]
public void set_data(CloudRoutingRouteResult value);
    [CompilerGeneratedAttribute]
public CloudRequestResponseError get_error();
    [CompilerGeneratedAttribute]
public void set_error(CloudRequestResponseError value);
}
[ObfuscationAttribute]
internal class ThinkGeo.Core.CloudRequestGetServiceAreaResultResponse : object {
    [CompilerGeneratedAttribute]
private CloudRoutingServiceAreaResult <data>k__BackingField;
    [CompilerGeneratedAttribute]
private CloudRequestResponseError <error>k__BackingField;
    public CloudRoutingServiceAreaResult data { get; public set; }
    public CloudRequestResponseError error { get; public set; }
    [CompilerGeneratedAttribute]
public CloudRoutingServiceAreaResult get_data();
    [CompilerGeneratedAttribute]
public void set_data(CloudRoutingServiceAreaResult value);
    [CompilerGeneratedAttribute]
public CloudRequestResponseError get_error();
    [CompilerGeneratedAttribute]
public void set_error(CloudRequestResponseError value);
}
[ObfuscationAttribute]
internal class ThinkGeo.Core.CloudRequestGetTimeCostMatrixResultResponse : object {
    [CompilerGeneratedAttribute]
private CloudRoutingTimeCostMatrixResult <data>k__BackingField;
    [CompilerGeneratedAttribute]
private CloudRequestResponseError <error>k__BackingField;
    public CloudRoutingTimeCostMatrixResult data { get; public set; }
    public CloudRequestResponseError error { get; public set; }
    [CompilerGeneratedAttribute]
public CloudRoutingTimeCostMatrixResult get_data();
    [CompilerGeneratedAttribute]
public void set_data(CloudRoutingTimeCostMatrixResult value);
    [CompilerGeneratedAttribute]
public CloudRequestResponseError get_error();
    [CompilerGeneratedAttribute]
public void set_error(CloudRequestResponseError value);
}
[ObfuscationAttribute]
internal class ThinkGeo.Core.CloudRequestGradeResponse : object {
    [CompilerGeneratedAttribute]
private CloudRequestGradeResponseDataItem[] <Data>k__BackingField;
    [CompilerGeneratedAttribute]
private CloudRequestGradeResponseLowestGradeSegment <lowestGradeSegment>k__BackingField;
    [CompilerGeneratedAttribute]
private CloudRequestGradeResponseHighestGradeSegment <highestGradeSegment>k__BackingField;
    [CompilerGeneratedAttribute]
private double <averageGrade>k__BackingField;
    [CompilerGeneratedAttribute]
private CloudRequestResponseError <error>k__BackingField;
    public CloudRequestGradeResponseDataItem[] Data { get; public set; }
    public CloudRequestGradeResponseLowestGradeSegment lowestGradeSegment { get; public set; }
    public CloudRequestGradeResponseHighestGradeSegment highestGradeSegment { get; public set; }
    public double averageGrade { get; public set; }
    public CloudRequestResponseError error { get; public set; }
    [CompilerGeneratedAttribute]
public CloudRequestGradeResponseDataItem[] get_Data();
    [CompilerGeneratedAttribute]
public void set_Data(CloudRequestGradeResponseDataItem[] value);
    [CompilerGeneratedAttribute]
public CloudRequestGradeResponseLowestGradeSegment get_lowestGradeSegment();
    [CompilerGeneratedAttribute]
public void set_lowestGradeSegment(CloudRequestGradeResponseLowestGradeSegment value);
    [CompilerGeneratedAttribute]
public CloudRequestGradeResponseHighestGradeSegment get_highestGradeSegment();
    [CompilerGeneratedAttribute]
public void set_highestGradeSegment(CloudRequestGradeResponseHighestGradeSegment value);
    [CompilerGeneratedAttribute]
public double get_averageGrade();
    [CompilerGeneratedAttribute]
public void set_averageGrade(double value);
    [CompilerGeneratedAttribute]
public CloudRequestResponseError get_error();
    [CompilerGeneratedAttribute]
public void set_error(CloudRequestResponseError value);
}
[ObfuscationAttribute]
internal class ThinkGeo.Core.CloudRequestGradeResponseDataItem : object {
    [CompilerGeneratedAttribute]
private double <grade>k__BackingField;
    [CompilerGeneratedAttribute]
private string <wellKnownText>k__BackingField;
    [CompilerGeneratedAttribute]
private double <startingElevation>k__BackingField;
    [CompilerGeneratedAttribute]
private double <endingElevation>k__BackingField;
    public double grade { get; public set; }
    public string wellKnownText { get; public set; }
    public double startingElevation { get; public set; }
    public double endingElevation { get; public set; }
    [CompilerGeneratedAttribute]
public double get_grade();
    [CompilerGeneratedAttribute]
public void set_grade(double value);
    [CompilerGeneratedAttribute]
public string get_wellKnownText();
    [CompilerGeneratedAttribute]
public void set_wellKnownText(string value);
    [CompilerGeneratedAttribute]
public double get_startingElevation();
    [CompilerGeneratedAttribute]
public void set_startingElevation(double value);
    [CompilerGeneratedAttribute]
public double get_endingElevation();
    [CompilerGeneratedAttribute]
public void set_endingElevation(double value);
}
[ObfuscationAttribute]
internal class ThinkGeo.Core.CloudRequestGradeResponseHighestGradeSegment : object {
    [CompilerGeneratedAttribute]
private double <grade>k__BackingField;
    [CompilerGeneratedAttribute]
private string <wellKnownText>k__BackingField;
    [CompilerGeneratedAttribute]
private double <startingElevation>k__BackingField;
    [CompilerGeneratedAttribute]
private double <endingElevation>k__BackingField;
    public double grade { get; public set; }
    public string wellKnownText { get; public set; }
    public double startingElevation { get; public set; }
    public double endingElevation { get; public set; }
    [CompilerGeneratedAttribute]
public double get_grade();
    [CompilerGeneratedAttribute]
public void set_grade(double value);
    [CompilerGeneratedAttribute]
public string get_wellKnownText();
    [CompilerGeneratedAttribute]
public void set_wellKnownText(string value);
    [CompilerGeneratedAttribute]
public double get_startingElevation();
    [CompilerGeneratedAttribute]
public void set_startingElevation(double value);
    [CompilerGeneratedAttribute]
public double get_endingElevation();
    [CompilerGeneratedAttribute]
public void set_endingElevation(double value);
}
[ObfuscationAttribute]
internal class ThinkGeo.Core.CloudRequestGradeResponseLowestGradeSegment : object {
    [CompilerGeneratedAttribute]
private double <grade>k__BackingField;
    [CompilerGeneratedAttribute]
private string <wellKnownText>k__BackingField;
    [CompilerGeneratedAttribute]
private double <startingElevation>k__BackingField;
    [CompilerGeneratedAttribute]
private double <endingElevation>k__BackingField;
    public double grade { get; public set; }
    public string wellKnownText { get; public set; }
    public double startingElevation { get; public set; }
    public double endingElevation { get; public set; }
    [CompilerGeneratedAttribute]
public double get_grade();
    [CompilerGeneratedAttribute]
public void set_grade(double value);
    [CompilerGeneratedAttribute]
public string get_wellKnownText();
    [CompilerGeneratedAttribute]
public void set_wellKnownText(string value);
    [CompilerGeneratedAttribute]
public double get_startingElevation();
    [CompilerGeneratedAttribute]
public void set_startingElevation(double value);
    [CompilerGeneratedAttribute]
public double get_endingElevation();
    [CompilerGeneratedAttribute]
public void set_endingElevation(double value);
}
[ObfuscationAttribute]
internal class ThinkGeo.Core.CloudRequestGroupedColorResponse : object {
    [CompilerGeneratedAttribute]
private CloudRequestGroupedColorResponseDataItem[] <Data>k__BackingField;
    public CloudRequestGroupedColorResponseDataItem[] Data { get; public set; }
    [CompilerGeneratedAttribute]
public CloudRequestGroupedColorResponseDataItem[] get_Data();
    [CompilerGeneratedAttribute]
public void set_Data(CloudRequestGroupedColorResponseDataItem[] value);
}
[ObfuscationAttribute]
internal class ThinkGeo.Core.CloudRequestGroupedColorResponseDataItem : object {
    [CompilerGeneratedAttribute]
private List`1<string> <Colors>k__BackingField;
    [CompilerGeneratedAttribute]
private string <BaseColor>k__BackingField;
    public List`1<string> Colors { get; public set; }
    public string BaseColor { get; public set; }
    [CompilerGeneratedAttribute]
public List`1<string> get_Colors();
    [CompilerGeneratedAttribute]
public void set_Colors(List`1<string> value);
    [CompilerGeneratedAttribute]
public string get_BaseColor();
    [CompilerGeneratedAttribute]
public void set_BaseColor(string value);
}
[ObfuscationAttribute]
internal class ThinkGeo.Core.CloudRequestMultiGeocodingResultResponse : object {
    [CompilerGeneratedAttribute]
private CloudRequestMultiGeocodingResultResponseDataItem[] <data>k__BackingField;
    public CloudRequestMultiGeocodingResultResponseDataItem[] data { get; public set; }
    [CompilerGeneratedAttribute]
public CloudRequestMultiGeocodingResultResponseDataItem[] get_data();
    [CompilerGeneratedAttribute]
public void set_data(CloudRequestMultiGeocodingResultResponseDataItem[] value);
}
[ObfuscationAttribute]
internal class ThinkGeo.Core.CloudRequestMultiGeocodingResultResponseDataItem : object {
    [CompilerGeneratedAttribute]
private GeocodingLocationDto[] <locations>k__BackingField;
    [CompilerGeneratedAttribute]
private Dictionary`2<string, String[]> <errors>k__BackingField;
    public GeocodingLocationDto[] locations { get; public set; }
    public Dictionary`2<string, String[]> errors { get; public set; }
    [CompilerGeneratedAttribute]
public GeocodingLocationDto[] get_locations();
    [CompilerGeneratedAttribute]
public void set_locations(GeocodingLocationDto[] value);
    [CompilerGeneratedAttribute]
public Dictionary`2<string, String[]> get_errors();
    [CompilerGeneratedAttribute]
public void set_errors(Dictionary`2<string, String[]> value);
}
[ObfuscationAttribute]
internal class ThinkGeo.Core.CloudRequestOptimizationResultResponse : object {
    [CompilerGeneratedAttribute]
private CloudRoutingTspResult <data>k__BackingField;
    [CompilerGeneratedAttribute]
private CloudRequestResponseError <error>k__BackingField;
    public CloudRoutingTspResult data { get; public set; }
    public CloudRequestResponseError error { get; public set; }
    [CompilerGeneratedAttribute]
public CloudRoutingTspResult get_data();
    [CompilerGeneratedAttribute]
public void set_data(CloudRoutingTspResult value);
    [CompilerGeneratedAttribute]
public CloudRequestResponseError get_error();
    [CompilerGeneratedAttribute]
public void set_error(CloudRequestResponseError value);
}
[ObfuscationAttribute]
internal class ThinkGeo.Core.CloudRequestProjectGeometriesResultResponse : object {
    [CompilerGeneratedAttribute]
private CloudRequestProjectGeometriesResultResponseDataItem[] <data>k__BackingField;
    [CompilerGeneratedAttribute]
private CloudRequestResponseError <error>k__BackingField;
    public CloudRequestProjectGeometriesResultResponseDataItem[] data { get; public set; }
    public CloudRequestResponseError error { get; public set; }
    [CompilerGeneratedAttribute]
public CloudRequestProjectGeometriesResultResponseDataItem[] get_data();
    [CompilerGeneratedAttribute]
public void set_data(CloudRequestProjectGeometriesResultResponseDataItem[] value);
    [CompilerGeneratedAttribute]
public CloudRequestResponseError get_error();
    [CompilerGeneratedAttribute]
public void set_error(CloudRequestResponseError value);
}
[ObfuscationAttribute]
internal class ThinkGeo.Core.CloudRequestProjectGeometriesResultResponseDataItem : object {
    [CompilerGeneratedAttribute]
private string <projectedWellKnownText>k__BackingField;
    public Dictionary`2<string, String[]> errors;
    public string projectedWellKnownText { get; public set; }
    [CompilerGeneratedAttribute]
public string get_projectedWellKnownText();
    [CompilerGeneratedAttribute]
public void set_projectedWellKnownText(string value);
}
[ObfuscationAttribute]
internal class ThinkGeo.Core.CloudRequestProjectGeometryResultResponse : object {
    [CompilerGeneratedAttribute]
private CloudRequestGetProjectGeometryResultResponseData <data>k__BackingField;
    [CompilerGeneratedAttribute]
private CloudRequestResponseError <error>k__BackingField;
    public CloudRequestGetProjectGeometryResultResponseData data { get; public set; }
    public CloudRequestResponseError error { get; public set; }
    [CompilerGeneratedAttribute]
public CloudRequestGetProjectGeometryResultResponseData get_data();
    [CompilerGeneratedAttribute]
public void set_data(CloudRequestGetProjectGeometryResultResponseData value);
    [CompilerGeneratedAttribute]
public CloudRequestResponseError get_error();
    [CompilerGeneratedAttribute]
public void set_error(CloudRequestResponseError value);
}
[ObfuscationAttribute]
internal class ThinkGeo.Core.CloudRequestQueryResultResponse : object {
    [CompilerGeneratedAttribute]
private CloudRequestQueryResultResponseData <data>k__BackingField;
    [CompilerGeneratedAttribute]
private CloudRequestResponseError <error>k__BackingField;
    public CloudRequestQueryResultResponseData data { get; public set; }
    public CloudRequestResponseError error { get; public set; }
    [CompilerGeneratedAttribute]
public CloudRequestQueryResultResponseData get_data();
    [CompilerGeneratedAttribute]
public void set_data(CloudRequestQueryResultResponseData value);
    [CompilerGeneratedAttribute]
public CloudRequestResponseError get_error();
    [CompilerGeneratedAttribute]
public void set_error(CloudRequestResponseError value);
}
[ObfuscationAttribute]
internal class ThinkGeo.Core.CloudRequestQueryResultResponseData : object {
    [CompilerGeneratedAttribute]
private CloudRequestQueryResultResponseFeatureItem[] <features>k__BackingField;
    public CloudRequestQueryResultResponseFeatureItem[] features { get; public set; }
    [CompilerGeneratedAttribute]
public CloudRequestQueryResultResponseFeatureItem[] get_features();
    [CompilerGeneratedAttribute]
public void set_features(CloudRequestQueryResultResponseFeatureItem[] value);
}
[ObfuscationAttribute]
internal class ThinkGeo.Core.CloudRequestQueryResultResponseFeatureItem : object {
    [CompilerGeneratedAttribute]
private string <id>k__BackingField;
    [CompilerGeneratedAttribute]
private string <geometry>k__BackingField;
    [CompilerGeneratedAttribute]
private Dictionary`2<string, string> <attributes>k__BackingField;
    public string id { get; public set; }
    public string geometry { get; public set; }
    public Dictionary`2<string, string> attributes { get; public set; }
    [CompilerGeneratedAttribute]
public string get_id();
    [CompilerGeneratedAttribute]
public void set_id(string value);
    [CompilerGeneratedAttribute]
public string get_geometry();
    [CompilerGeneratedAttribute]
public void set_geometry(string value);
    [CompilerGeneratedAttribute]
public Dictionary`2<string, string> get_attributes();
    [CompilerGeneratedAttribute]
public void set_attributes(Dictionary`2<string, string> value);
}
[ObfuscationAttribute]
internal class ThinkGeo.Core.CloudRequestResponseError : object {
    [CompilerGeneratedAttribute]
private int <code>k__BackingField;
    [CompilerGeneratedAttribute]
private string <message>k__BackingField;
    public int code { get; public set; }
    public string message { get; public set; }
    [CompilerGeneratedAttribute]
public int get_code();
    [CompilerGeneratedAttribute]
public void set_code(int value);
    [CompilerGeneratedAttribute]
public string get_message();
    [CompilerGeneratedAttribute]
public void set_message(string value);
}
[ObfuscationAttribute]
internal class ThinkGeo.Core.CloudRequestReverseGeocoderResultArrayResponse : object {
    [CompilerGeneratedAttribute]
private CloudRequestReverseGeocoderResultArrayResponseDataItem[] <data>k__BackingField;
    [CompilerGeneratedAttribute]
private CloudRequestResponseError <error>k__BackingField;
    public CloudRequestReverseGeocoderResultArrayResponseDataItem[] data { get; public set; }
    public CloudRequestResponseError error { get; public set; }
    [CompilerGeneratedAttribute]
public CloudRequestReverseGeocoderResultArrayResponseDataItem[] get_data();
    [CompilerGeneratedAttribute]
public void set_data(CloudRequestReverseGeocoderResultArrayResponseDataItem[] value);
    [CompilerGeneratedAttribute]
public CloudRequestResponseError get_error();
    [CompilerGeneratedAttribute]
public void set_error(CloudRequestResponseError value);
}
[ObfuscationAttribute]
internal class ThinkGeo.Core.CloudRequestReverseGeocoderResultArrayResponseDataItem : object {
    public Dictionary`2<string, String[]> errors;
    [CompilerGeneratedAttribute]
private CloudRequestReverseGeocoderResultArrayResponseDataMatchLocation <bestMatchLocation>k__BackingField;
    [CompilerGeneratedAttribute]
private CloudRequestReverseGeocoderResultArrayResponseDataMatchLocation[] <nearbyLocations>k__BackingField;
    public CloudRequestReverseGeocoderResultArrayResponseDataMatchLocation bestMatchLocation { get; public set; }
    public CloudRequestReverseGeocoderResultArrayResponseDataMatchLocation[] nearbyLocations { get; public set; }
    [CompilerGeneratedAttribute]
public CloudRequestReverseGeocoderResultArrayResponseDataMatchLocation get_bestMatchLocation();
    [CompilerGeneratedAttribute]
public void set_bestMatchLocation(CloudRequestReverseGeocoderResultArrayResponseDataMatchLocation value);
    [CompilerGeneratedAttribute]
public CloudRequestReverseGeocoderResultArrayResponseDataMatchLocation[] get_nearbyLocations();
    [CompilerGeneratedAttribute]
public void set_nearbyLocations(CloudRequestReverseGeocoderResultArrayResponseDataMatchLocation[] value);
}
[ObfuscationAttribute]
internal class ThinkGeo.Core.CloudRequestReverseGeocoderResultArrayResponseDataMatchLocation : object {
    [CompilerGeneratedAttribute]
private ReverseGeocodingLocationDto <data>k__BackingField;
    public ReverseGeocodingLocationDto data { get; public set; }
    [CompilerGeneratedAttribute]
public ReverseGeocodingLocationDto get_data();
    [CompilerGeneratedAttribute]
public void set_data(ReverseGeocodingLocationDto value);
}
[ObfuscationAttribute]
internal class ThinkGeo.Core.CloudRequestReverseGeocoderResultResponse : object {
    [CompilerGeneratedAttribute]
private CloudRequestReverseGeocoderResultResponseData <data>k__BackingField;
    [CompilerGeneratedAttribute]
private CloudRequestResponseError <error>k__BackingField;
    public CloudRequestReverseGeocoderResultResponseData data { get; public set; }
    public CloudRequestResponseError error { get; public set; }
    [CompilerGeneratedAttribute]
public CloudRequestReverseGeocoderResultResponseData get_data();
    [CompilerGeneratedAttribute]
public void set_data(CloudRequestReverseGeocoderResultResponseData value);
    [CompilerGeneratedAttribute]
public CloudRequestResponseError get_error();
    [CompilerGeneratedAttribute]
public void set_error(CloudRequestResponseError value);
}
[ObfuscationAttribute]
internal class ThinkGeo.Core.CloudRequestReverseGeocoderResultResponseData : object {
    [CompilerGeneratedAttribute]
private CloudRequestReverseGeocoderResultResponseDataMatchLocation <bestMatchLocation>k__BackingField;
    [CompilerGeneratedAttribute]
private CloudRequestReverseGeocoderResultResponseDataMatchLocation[] <nearbyLocations>k__BackingField;
    public CloudRequestReverseGeocoderResultResponseDataMatchLocation bestMatchLocation { get; public set; }
    public CloudRequestReverseGeocoderResultResponseDataMatchLocation[] nearbyLocations { get; public set; }
    [CompilerGeneratedAttribute]
public CloudRequestReverseGeocoderResultResponseDataMatchLocation get_bestMatchLocation();
    [CompilerGeneratedAttribute]
public void set_bestMatchLocation(CloudRequestReverseGeocoderResultResponseDataMatchLocation value);
    [CompilerGeneratedAttribute]
public CloudRequestReverseGeocoderResultResponseDataMatchLocation[] get_nearbyLocations();
    [CompilerGeneratedAttribute]
public void set_nearbyLocations(CloudRequestReverseGeocoderResultResponseDataMatchLocation[] value);
}
[ObfuscationAttribute]
internal class ThinkGeo.Core.CloudRequestReverseGeocoderResultResponseDataMatchLocation : object {
    [CompilerGeneratedAttribute]
private ReverseGeocodingLocationDto <data>k__BackingField;
    public ReverseGeocodingLocationDto data { get; public set; }
    [CompilerGeneratedAttribute]
public ReverseGeocodingLocationDto get_data();
    [CompilerGeneratedAttribute]
public void set_data(ReverseGeocodingLocationDto value);
}
[ObfuscationAttribute]
internal class ThinkGeo.Core.CloudRequestTimeZone : object {
    [CompilerGeneratedAttribute]
private string <timezone>k__BackingField;
    [CompilerGeneratedAttribute]
private string <countryName>k__BackingField;
    [CompilerGeneratedAttribute]
private string <countryCode>k__BackingField;
    [CompilerGeneratedAttribute]
private string <comment>k__BackingField;
    [CompilerGeneratedAttribute]
private string <currentUtcTime>k__BackingField;
    [CompilerGeneratedAttribute]
private string <currentLocalTime>k__BackingField;
    [CompilerGeneratedAttribute]
private double <offsetSeconds>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <daylightSavingsActive>k__BackingField;
    [CompilerGeneratedAttribute]
private string <geometry>k__BackingField;
    public string timezone { get; public set; }
    public string countryName { get; public set; }
    public string countryCode { get; public set; }
    public string comment { get; public set; }
    public string currentUtcTime { get; public set; }
    public string currentLocalTime { get; public set; }
    public double offsetSeconds { get; public set; }
    public bool daylightSavingsActive { get; public set; }
    public string geometry { get; public set; }
    [CompilerGeneratedAttribute]
public string get_timezone();
    [CompilerGeneratedAttribute]
public void set_timezone(string value);
    [CompilerGeneratedAttribute]
public string get_countryName();
    [CompilerGeneratedAttribute]
public void set_countryName(string value);
    [CompilerGeneratedAttribute]
public string get_countryCode();
    [CompilerGeneratedAttribute]
public void set_countryCode(string value);
    [CompilerGeneratedAttribute]
public string get_comment();
    [CompilerGeneratedAttribute]
public void set_comment(string value);
    [CompilerGeneratedAttribute]
public string get_currentUtcTime();
    [CompilerGeneratedAttribute]
public void set_currentUtcTime(string value);
    [CompilerGeneratedAttribute]
public string get_currentLocalTime();
    [CompilerGeneratedAttribute]
public void set_currentLocalTime(string value);
    [CompilerGeneratedAttribute]
public double get_offsetSeconds();
    [CompilerGeneratedAttribute]
public void set_offsetSeconds(double value);
    [CompilerGeneratedAttribute]
public bool get_daylightSavingsActive();
    [CompilerGeneratedAttribute]
public void set_daylightSavingsActive(bool value);
    [CompilerGeneratedAttribute]
public string get_geometry();
    [CompilerGeneratedAttribute]
public void set_geometry(string value);
}
[ObfuscationAttribute]
internal class ThinkGeo.Core.CloudRequestTimeZoneResultResponse : object {
    [CompilerGeneratedAttribute]
private CloudRequestTimeZone <data>k__BackingField;
    [CompilerGeneratedAttribute]
private CloudRequestResponseError <error>k__BackingField;
    public CloudRequestTimeZone data { get; public set; }
    public CloudRequestResponseError error { get; public set; }
    [CompilerGeneratedAttribute]
public CloudRequestTimeZone get_data();
    [CompilerGeneratedAttribute]
public void set_data(CloudRequestTimeZone value);
    [CompilerGeneratedAttribute]
public CloudRequestResponseError get_error();
    [CompilerGeneratedAttribute]
public void set_error(CloudRequestResponseError value);
}
[ObfuscationAttribute]
internal class ThinkGeo.Core.CloudRequestTimeZoneResultResponseData : object {
    [CompilerGeneratedAttribute]
private string <timezone>k__BackingField;
    [CompilerGeneratedAttribute]
private string <countryName>k__BackingField;
    [CompilerGeneratedAttribute]
private string <countryCode>k__BackingField;
    [CompilerGeneratedAttribute]
private string <comment>k__BackingField;
    [CompilerGeneratedAttribute]
private string <currentUtcTime>k__BackingField;
    [CompilerGeneratedAttribute]
private string <currentLocalTime>k__BackingField;
    [CompilerGeneratedAttribute]
private double <offsetSeconds>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <daylightSavingsActive>k__BackingField;
    [CompilerGeneratedAttribute]
private string <geometry>k__BackingField;
    public string timezone { get; public set; }
    public string countryName { get; public set; }
    public string countryCode { get; public set; }
    public string comment { get; public set; }
    public string currentUtcTime { get; public set; }
    public string currentLocalTime { get; public set; }
    public double offsetSeconds { get; public set; }
    public bool daylightSavingsActive { get; public set; }
    public string geometry { get; public set; }
    [CompilerGeneratedAttribute]
public string get_timezone();
    [CompilerGeneratedAttribute]
public void set_timezone(string value);
    [CompilerGeneratedAttribute]
public string get_countryName();
    [CompilerGeneratedAttribute]
public void set_countryName(string value);
    [CompilerGeneratedAttribute]
public string get_countryCode();
    [CompilerGeneratedAttribute]
public void set_countryCode(string value);
    [CompilerGeneratedAttribute]
public string get_comment();
    [CompilerGeneratedAttribute]
public void set_comment(string value);
    [CompilerGeneratedAttribute]
public string get_currentUtcTime();
    [CompilerGeneratedAttribute]
public void set_currentUtcTime(string value);
    [CompilerGeneratedAttribute]
public string get_currentLocalTime();
    [CompilerGeneratedAttribute]
public void set_currentLocalTime(string value);
    [CompilerGeneratedAttribute]
public double get_offsetSeconds();
    [CompilerGeneratedAttribute]
public void set_offsetSeconds(double value);
    [CompilerGeneratedAttribute]
public bool get_daylightSavingsActive();
    [CompilerGeneratedAttribute]
public void set_daylightSavingsActive(bool value);
    [CompilerGeneratedAttribute]
public string get_geometry();
    [CompilerGeneratedAttribute]
public void set_geometry(string value);
}
[ObfuscationAttribute]
internal class ThinkGeo.Core.CloudRequestTokenResponse : object {
    [CompilerGeneratedAttribute]
private CloudRequestTokenResponseData <Data>k__BackingField;
    public CloudRequestTokenResponseData Data { get; public set; }
    [CompilerGeneratedAttribute]
public CloudRequestTokenResponseData get_Data();
    [CompilerGeneratedAttribute]
public void set_Data(CloudRequestTokenResponseData value);
}
[ObfuscationAttribute]
internal class ThinkGeo.Core.CloudRequestTokenResponseData : object {
    [CompilerGeneratedAttribute]
private string <access_token>k__BackingField;
    [CompilerGeneratedAttribute]
private int <expires_in>k__BackingField;
    [CompilerGeneratedAttribute]
private string <token_type>k__BackingField;
    public string access_token { get; public set; }
    public int expires_in { get; public set; }
    public string token_type { get; public set; }
    [CompilerGeneratedAttribute]
public string get_access_token();
    [CompilerGeneratedAttribute]
public void set_access_token(string value);
    [CompilerGeneratedAttribute]
public int get_expires_in();
    [CompilerGeneratedAttribute]
public void set_expires_in(int value);
    [CompilerGeneratedAttribute]
public string get_token_type();
    [CompilerGeneratedAttribute]
public void set_token_type(string value);
}
[ObfuscationAttribute]
public class ThinkGeo.Core.CloudReverseGeocodingLocation : object {
    [CompilerGeneratedAttribute]
private Feature <LocationFeature>k__BackingField;
    [CompilerGeneratedAttribute]
private string <LocationName>k__BackingField;
    [CompilerGeneratedAttribute]
private string <DirectionFromQueryFeature>k__BackingField;
    [CompilerGeneratedAttribute]
private double <DistanceFromQueryFeature>k__BackingField;
    [CompilerGeneratedAttribute]
private string <LocationCategory>k__BackingField;
    [CompilerGeneratedAttribute]
private string <LocationType>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Address>k__BackingField;
    [CompilerGeneratedAttribute]
private string <HouseNumber>k__BackingField;
    [CompilerGeneratedAttribute]
private Dictionary`2<string, string> <Properties>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Postcode>k__BackingField;
    [CompilerGeneratedAttribute]
private Dictionary`2<string, string> <AddressComponents>k__BackingField;
    public Feature LocationFeature { get; public set; }
    public string LocationName { get; public set; }
    public string DirectionFromQueryFeature { get; public set; }
    public double DistanceFromQueryFeature { get; public set; }
    public string LocationCategory { get; public set; }
    public string LocationType { get; public set; }
    public string Address { get; public set; }
    public string HouseNumber { get; public set; }
    public Dictionary`2<string, string> Properties { get; public set; }
    public string Postcode { get; public set; }
    public Dictionary`2<string, string> AddressComponents { get; public set; }
    [CompilerGeneratedAttribute]
public Feature get_LocationFeature();
    [CompilerGeneratedAttribute]
public void set_LocationFeature(Feature value);
    [CompilerGeneratedAttribute]
public string get_LocationName();
    [CompilerGeneratedAttribute]
public void set_LocationName(string value);
    [CompilerGeneratedAttribute]
public string get_DirectionFromQueryFeature();
    [CompilerGeneratedAttribute]
public void set_DirectionFromQueryFeature(string value);
    [CompilerGeneratedAttribute]
public double get_DistanceFromQueryFeature();
    [CompilerGeneratedAttribute]
public void set_DistanceFromQueryFeature(double value);
    [CompilerGeneratedAttribute]
public string get_LocationCategory();
    [CompilerGeneratedAttribute]
public void set_LocationCategory(string value);
    [CompilerGeneratedAttribute]
public string get_LocationType();
    [CompilerGeneratedAttribute]
public void set_LocationType(string value);
    [CompilerGeneratedAttribute]
public string get_Address();
    [CompilerGeneratedAttribute]
public void set_Address(string value);
    [CompilerGeneratedAttribute]
public string get_HouseNumber();
    [CompilerGeneratedAttribute]
public void set_HouseNumber(string value);
    [CompilerGeneratedAttribute]
public Dictionary`2<string, string> get_Properties();
    [CompilerGeneratedAttribute]
public void set_Properties(Dictionary`2<string, string> value);
    [CompilerGeneratedAttribute]
public string get_Postcode();
    [CompilerGeneratedAttribute]
public void set_Postcode(string value);
    [CompilerGeneratedAttribute]
public Dictionary`2<string, string> get_AddressComponents();
    [CompilerGeneratedAttribute]
public void set_AddressComponents(Dictionary`2<string, string> value);
}
[ObfuscationAttribute]
public class ThinkGeo.Core.CloudReverseGeocodingOptions : object {
    [CompilerGeneratedAttribute]
private string <Lang>k__BackingField;
    [CompilerGeneratedAttribute]
private int <MaxResults>k__BackingField;
    [CompilerGeneratedAttribute]
private CloudLocationCategories <LocationCategories>k__BackingField;
    [CompilerGeneratedAttribute]
private CloudReverseGeocodingResultDetail <ResultDetail>k__BackingField;
    [CompilerGeneratedAttribute]
private DistanceUnit <DistanceUnit>k__BackingField;
    [CompilerGeneratedAttribute]
private Collection`1<string> <LocationTypes>k__BackingField;
    public string Lang { get; public set; }
    public int MaxResults { get; public set; }
    public CloudLocationCategories LocationCategories { get; public set; }
    public CloudReverseGeocodingResultDetail ResultDetail { get; public set; }
    public DistanceUnit DistanceUnit { get; public set; }
    public Collection`1<string> LocationTypes { get; }
    [CompilerGeneratedAttribute]
public string get_Lang();
    [CompilerGeneratedAttribute]
public void set_Lang(string value);
    [CompilerGeneratedAttribute]
public int get_MaxResults();
    [CompilerGeneratedAttribute]
public void set_MaxResults(int value);
    [CompilerGeneratedAttribute]
public CloudLocationCategories get_LocationCategories();
    [CompilerGeneratedAttribute]
public void set_LocationCategories(CloudLocationCategories value);
    [CompilerGeneratedAttribute]
public CloudReverseGeocodingResultDetail get_ResultDetail();
    [CompilerGeneratedAttribute]
public void set_ResultDetail(CloudReverseGeocodingResultDetail value);
    [CompilerGeneratedAttribute]
public DistanceUnit get_DistanceUnit();
    [CompilerGeneratedAttribute]
public void set_DistanceUnit(DistanceUnit value);
    [CompilerGeneratedAttribute]
public Collection`1<string> get_LocationTypes();
}
[ObfuscationAttribute]
public class ThinkGeo.Core.CloudReverseGeocodingResult : object {
    [CompilerGeneratedAttribute]
private Feature <QueryFeature>k__BackingField;
    [CompilerGeneratedAttribute]
private CloudReverseGeocodingLocation <BestMatchLocation>k__BackingField;
    [CompilerGeneratedAttribute]
private Collection`1<CloudReverseGeocodingLocation> <NearbyLocations>k__BackingField;
    [CompilerGeneratedAttribute]
private ThinkGeoCloudApplicationException <Exception>k__BackingField;
    public Feature QueryFeature { get; }
    public CloudReverseGeocodingLocation BestMatchLocation { get; }
    public Collection`1<CloudReverseGeocodingLocation> NearbyLocations { get; }
    public ThinkGeoCloudApplicationException Exception { get; }
    public CloudReverseGeocodingResult(Feature queryFeature, CloudReverseGeocodingLocation bestMatchLocation, ThinkGeoCloudApplicationException exception);
    [CompilerGeneratedAttribute]
public Feature get_QueryFeature();
    [CompilerGeneratedAttribute]
public CloudReverseGeocodingLocation get_BestMatchLocation();
    [CompilerGeneratedAttribute]
public Collection`1<CloudReverseGeocodingLocation> get_NearbyLocations();
    [CompilerGeneratedAttribute]
public ThinkGeoCloudApplicationException get_Exception();
}
[ObfuscationAttribute]
public enum ThinkGeo.Core.CloudReverseGeocodingResultDetail : Enum {
    public int value__;
    public static CloudReverseGeocodingResultDetail Default;
    public static CloudReverseGeocodingResultDetail Verbose;
    public static CloudReverseGeocodingResultDetail Standard;
}
[ObfuscationAttribute]
public class ThinkGeo.Core.CloudRoutingDistanceCostMatrixResult : object {
    [CompilerGeneratedAttribute]
private Collection`1<CloudRoutingWaypoint> <Origins>k__BackingField;
    [CompilerGeneratedAttribute]
private Collection`1<CloudRoutingWaypoint> <Destinations>k__BackingField;
    [CompilerGeneratedAttribute]
private Single[0...,0...] <Distances>k__BackingField;
    public Collection`1<CloudRoutingWaypoint> Origins { get; public set; }
    public Collection`1<CloudRoutingWaypoint> Destinations { get; public set; }
    public Single[0...,0...] Distances { get; public set; }
    [CompilerGeneratedAttribute]
public Collection`1<CloudRoutingWaypoint> get_Origins();
    [CompilerGeneratedAttribute]
public void set_Origins(Collection`1<CloudRoutingWaypoint> value);
    [CompilerGeneratedAttribute]
public Collection`1<CloudRoutingWaypoint> get_Destinations();
    [CompilerGeneratedAttribute]
public void set_Destinations(Collection`1<CloudRoutingWaypoint> value);
    [CompilerGeneratedAttribute]
public Single[0...,0...] get_Distances();
    [CompilerGeneratedAttribute]
public void set_Distances(Single[0...,0...] value);
}
[ObfuscationAttribute]
public class ThinkGeo.Core.CloudRoutingGetCostMatrixOptions : object {
    [CompilerGeneratedAttribute]
private float <CoordinateSnapRadius>k__BackingField;
    [CompilerGeneratedAttribute]
private DistanceUnit <CoordinateSnapRadiusUnit>k__BackingField;
    [CompilerGeneratedAttribute]
private DistanceUnit <DistanceUnit>k__BackingField;
    public float CoordinateSnapRadius { get; public set; }
    public DistanceUnit CoordinateSnapRadiusUnit { get; public set; }
    public DistanceUnit DistanceUnit { get; public set; }
    [CompilerGeneratedAttribute]
public float get_CoordinateSnapRadius();
    [CompilerGeneratedAttribute]
public void set_CoordinateSnapRadius(float value);
    [CompilerGeneratedAttribute]
public DistanceUnit get_CoordinateSnapRadiusUnit();
    [CompilerGeneratedAttribute]
public void set_CoordinateSnapRadiusUnit(DistanceUnit value);
    [CompilerGeneratedAttribute]
public DistanceUnit get_DistanceUnit();
    [CompilerGeneratedAttribute]
public void set_DistanceUnit(DistanceUnit value);
}
[ObfuscationAttribute]
public class ThinkGeo.Core.CloudRoutingGetDistanceCostMatrixResult : object {
    [CompilerGeneratedAttribute]
private CloudRoutingDistanceCostMatrixResult <CostMatrixResult>k__BackingField;
    [CompilerGeneratedAttribute]
private ThinkGeoCloudApplicationException <Exception>k__BackingField;
    public CloudRoutingDistanceCostMatrixResult CostMatrixResult { get; public set; }
    public ThinkGeoCloudApplicationException Exception { get; public set; }
    [CompilerGeneratedAttribute]
public CloudRoutingDistanceCostMatrixResult get_CostMatrixResult();
    [CompilerGeneratedAttribute]
public void set_CostMatrixResult(CloudRoutingDistanceCostMatrixResult value);
    [CompilerGeneratedAttribute]
public ThinkGeoCloudApplicationException get_Exception();
    [CompilerGeneratedAttribute]
public void set_Exception(ThinkGeoCloudApplicationException value);
}
[ObfuscationAttribute]
public class ThinkGeo.Core.CloudRoutingGetRouteOptions : object {
    [CompilerGeneratedAttribute]
private bool <TurnByTurn>k__BackingField;
    [CompilerGeneratedAttribute]
private float <CoordinateSnapRadius>k__BackingField;
    [CompilerGeneratedAttribute]
private DistanceUnit <CoordinateSnapRadiusUnit>k__BackingField;
    [CompilerGeneratedAttribute]
private DistanceUnit <DistanceUnit>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<RouteType> <RouteType>k__BackingField;
    public bool TurnByTurn { get; public set; }
    public float CoordinateSnapRadius { get; public set; }
    public DistanceUnit CoordinateSnapRadiusUnit { get; public set; }
    public DistanceUnit DistanceUnit { get; public set; }
    public Nullable`1<RouteType> RouteType { get; public set; }
    [CompilerGeneratedAttribute]
public bool get_TurnByTurn();
    [CompilerGeneratedAttribute]
public void set_TurnByTurn(bool value);
    [CompilerGeneratedAttribute]
public float get_CoordinateSnapRadius();
    [CompilerGeneratedAttribute]
public void set_CoordinateSnapRadius(float value);
    [CompilerGeneratedAttribute]
public DistanceUnit get_CoordinateSnapRadiusUnit();
    [CompilerGeneratedAttribute]
public void set_CoordinateSnapRadiusUnit(DistanceUnit value);
    [CompilerGeneratedAttribute]
public DistanceUnit get_DistanceUnit();
    [CompilerGeneratedAttribute]
public void set_DistanceUnit(DistanceUnit value);
    [CompilerGeneratedAttribute]
public Nullable`1<RouteType> get_RouteType();
    [CompilerGeneratedAttribute]
public void set_RouteType(Nullable`1<RouteType> value);
}
[ObfuscationAttribute]
public class ThinkGeo.Core.CloudRoutingGetRouteResult : object {
    [CompilerGeneratedAttribute]
private CloudRoutingRouteResult <RouteResult>k__BackingField;
    [CompilerGeneratedAttribute]
private ThinkGeoCloudApplicationException <Exception>k__BackingField;
    public CloudRoutingRouteResult RouteResult { get; public set; }
    public ThinkGeoCloudApplicationException Exception { get; public set; }
    [CompilerGeneratedAttribute]
public CloudRoutingRouteResult get_RouteResult();
    [CompilerGeneratedAttribute]
public void set_RouteResult(CloudRoutingRouteResult value);
    [CompilerGeneratedAttribute]
public ThinkGeoCloudApplicationException get_Exception();
    [CompilerGeneratedAttribute]
public void set_Exception(ThinkGeoCloudApplicationException value);
}
[ObfuscationAttribute]
public class ThinkGeo.Core.CloudRoutingGetServiceAreaOptions : object {
    [CompilerGeneratedAttribute]
private DistanceUnit <DistanceUnit>k__BackingField;
    [CompilerGeneratedAttribute]
private float <ContourGranularity>k__BackingField;
    [CompilerGeneratedAttribute]
private float <CoordinateSnapRadius>k__BackingField;
    [CompilerGeneratedAttribute]
private DistanceUnit <CoordinateSnapRadiusUnit>k__BackingField;
    [CompilerGeneratedAttribute]
private float <GridSizeInMeters>k__BackingField;
    [CompilerGeneratedAttribute]
private CloudRoutingServiceAreaSeparationType <ServiceAreaSeparationType>k__BackingField;
    [CompilerGeneratedAttribute]
private CloudRoutingServiceAreaObjectType <ServiceAreaType>k__BackingField;
    [CompilerGeneratedAttribute]
private CloudRoutingServiceAreaTravelDirection <TravelDirection>k__BackingField;
    public DistanceUnit DistanceUnit { get; public set; }
    public float ContourGranularity { get; public set; }
    public float CoordinateSnapRadius { get; public set; }
    public DistanceUnit CoordinateSnapRadiusUnit { get; public set; }
    public float GridSizeInMeters { get; public set; }
    public CloudRoutingServiceAreaSeparationType ServiceAreaSeparationType { get; public set; }
    public CloudRoutingServiceAreaObjectType ServiceAreaType { get; public set; }
    public CloudRoutingServiceAreaTravelDirection TravelDirection { get; public set; }
    [CompilerGeneratedAttribute]
public DistanceUnit get_DistanceUnit();
    [CompilerGeneratedAttribute]
public void set_DistanceUnit(DistanceUnit value);
    [CompilerGeneratedAttribute]
public float get_ContourGranularity();
    [CompilerGeneratedAttribute]
public void set_ContourGranularity(float value);
    [CompilerGeneratedAttribute]
public float get_CoordinateSnapRadius();
    [CompilerGeneratedAttribute]
public void set_CoordinateSnapRadius(float value);
    [CompilerGeneratedAttribute]
public DistanceUnit get_CoordinateSnapRadiusUnit();
    [CompilerGeneratedAttribute]
public void set_CoordinateSnapRadiusUnit(DistanceUnit value);
    [CompilerGeneratedAttribute]
public float get_GridSizeInMeters();
    [CompilerGeneratedAttribute]
public void set_GridSizeInMeters(float value);
    [CompilerGeneratedAttribute]
public CloudRoutingServiceAreaSeparationType get_ServiceAreaSeparationType();
    [CompilerGeneratedAttribute]
public void set_ServiceAreaSeparationType(CloudRoutingServiceAreaSeparationType value);
    [CompilerGeneratedAttribute]
public CloudRoutingServiceAreaObjectType get_ServiceAreaType();
    [CompilerGeneratedAttribute]
public void set_ServiceAreaType(CloudRoutingServiceAreaObjectType value);
    [CompilerGeneratedAttribute]
public CloudRoutingServiceAreaTravelDirection get_TravelDirection();
    [CompilerGeneratedAttribute]
public void set_TravelDirection(CloudRoutingServiceAreaTravelDirection value);
}
[ObfuscationAttribute]
public class ThinkGeo.Core.CloudRoutingGetServiceAreaResult : object {
    [CompilerGeneratedAttribute]
private CloudRoutingServiceAreaResult <ServiceAreaResult>k__BackingField;
    [CompilerGeneratedAttribute]
private ThinkGeoCloudApplicationException <Exception>k__BackingField;
    public CloudRoutingServiceAreaResult ServiceAreaResult { get; public set; }
    public ThinkGeoCloudApplicationException Exception { get; public set; }
    [CompilerGeneratedAttribute]
public CloudRoutingServiceAreaResult get_ServiceAreaResult();
    [CompilerGeneratedAttribute]
public void set_ServiceAreaResult(CloudRoutingServiceAreaResult value);
    [CompilerGeneratedAttribute]
public ThinkGeoCloudApplicationException get_Exception();
    [CompilerGeneratedAttribute]
public void set_Exception(ThinkGeoCloudApplicationException value);
}
[ObfuscationAttribute]
public class ThinkGeo.Core.CloudRoutingGetTimeCostMatrixResult : object {
    [CompilerGeneratedAttribute]
private CloudRoutingTimeCostMatrixResult <CostMatrixResult>k__BackingField;
    [CompilerGeneratedAttribute]
private ThinkGeoCloudApplicationException <Exception>k__BackingField;
    public CloudRoutingTimeCostMatrixResult CostMatrixResult { get; public set; }
    public ThinkGeoCloudApplicationException Exception { get; public set; }
    [CompilerGeneratedAttribute]
public CloudRoutingTimeCostMatrixResult get_CostMatrixResult();
    [CompilerGeneratedAttribute]
public void set_CostMatrixResult(CloudRoutingTimeCostMatrixResult value);
    [CompilerGeneratedAttribute]
public ThinkGeoCloudApplicationException get_Exception();
    [CompilerGeneratedAttribute]
public void set_Exception(ThinkGeoCloudApplicationException value);
}
[ObfuscationAttribute]
public class ThinkGeo.Core.CloudRoutingOptimizationOptions : object {
    [CompilerGeneratedAttribute]
private bool <Roundtrip>k__BackingField;
    [CompilerGeneratedAttribute]
private CloudRoutingTspFixSourceCoordinate <Source>k__BackingField;
    [CompilerGeneratedAttribute]
private CloudRoutingTspFixDestinationCoordinate <Destination>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <TurnByTurn>k__BackingField;
    [CompilerGeneratedAttribute]
private float <CoordinateSnapRadius>k__BackingField;
    [CompilerGeneratedAttribute]
private DistanceUnit <CoordinateSnapRadiusUnit>k__BackingField;
    [CompilerGeneratedAttribute]
private DistanceUnit <DistanceUnit>k__BackingField;
    public bool Roundtrip { get; public set; }
    public CloudRoutingTspFixSourceCoordinate Source { get; public set; }
    public CloudRoutingTspFixDestinationCoordinate Destination { get; public set; }
    public bool TurnByTurn { get; public set; }
    public float CoordinateSnapRadius { get; public set; }
    public DistanceUnit CoordinateSnapRadiusUnit { get; public set; }
    public DistanceUnit DistanceUnit { get; public set; }
    [CompilerGeneratedAttribute]
public bool get_Roundtrip();
    [CompilerGeneratedAttribute]
public void set_Roundtrip(bool value);
    [CompilerGeneratedAttribute]
public CloudRoutingTspFixSourceCoordinate get_Source();
    [CompilerGeneratedAttribute]
public void set_Source(CloudRoutingTspFixSourceCoordinate value);
    [CompilerGeneratedAttribute]
public CloudRoutingTspFixDestinationCoordinate get_Destination();
    [CompilerGeneratedAttribute]
public void set_Destination(CloudRoutingTspFixDestinationCoordinate value);
    [CompilerGeneratedAttribute]
public bool get_TurnByTurn();
    [CompilerGeneratedAttribute]
public void set_TurnByTurn(bool value);
    [CompilerGeneratedAttribute]
public float get_CoordinateSnapRadius();
    [CompilerGeneratedAttribute]
public void set_CoordinateSnapRadius(float value);
    [CompilerGeneratedAttribute]
public DistanceUnit get_CoordinateSnapRadiusUnit();
    [CompilerGeneratedAttribute]
public void set_CoordinateSnapRadiusUnit(DistanceUnit value);
    [CompilerGeneratedAttribute]
public DistanceUnit get_DistanceUnit();
    [CompilerGeneratedAttribute]
public void set_DistanceUnit(DistanceUnit value);
}
[ObfuscationAttribute]
public class ThinkGeo.Core.CloudRoutingOptimizationResult : object {
    [CompilerGeneratedAttribute]
private CloudRoutingTspResult <TspResult>k__BackingField;
    [CompilerGeneratedAttribute]
private ThinkGeoCloudApplicationException <Exception>k__BackingField;
    public CloudRoutingTspResult TspResult { get; public set; }
    public ThinkGeoCloudApplicationException Exception { get; public set; }
    [CompilerGeneratedAttribute]
public CloudRoutingTspResult get_TspResult();
    [CompilerGeneratedAttribute]
public void set_TspResult(CloudRoutingTspResult value);
    [CompilerGeneratedAttribute]
public ThinkGeoCloudApplicationException get_Exception();
    [CompilerGeneratedAttribute]
public void set_Exception(ThinkGeoCloudApplicationException value);
}
[ObfuscationAttribute]
public class ThinkGeo.Core.CloudRoutingRoute : object {
    [CompilerGeneratedAttribute]
private double <Distance>k__BackingField;
    [CompilerGeneratedAttribute]
private TimeSpan <Duration>k__BackingField;
    [CompilerGeneratedAttribute]
private LineShape <Shape>k__BackingField;
    [CompilerGeneratedAttribute]
private Collection`1<CloudRoutingSegment> <Segments>k__BackingField;
    [CompilerGeneratedAttribute]
private Dictionary`2<string, string> <Warnings>k__BackingField;
    public double Distance { get; public set; }
    [CloudJsonConverterAttribute("ThinkGeo.Core.CloudDurationMinuteReader")]
public TimeSpan Duration { get; public set; }
    [CloudJsonConverterAttribute("ThinkGeo.Core.CloudShapeWktConverter")]
[CloudJsonPropertyAttribute("geometry")]
public LineShape Shape { get; public set; }
    public Collection`1<CloudRoutingSegment> Segments { get; public set; }
    public Dictionary`2<string, string> Warnings { get; public set; }
    [CompilerGeneratedAttribute]
public double get_Distance();
    [CompilerGeneratedAttribute]
public void set_Distance(double value);
    [CompilerGeneratedAttribute]
public TimeSpan get_Duration();
    [CompilerGeneratedAttribute]
public void set_Duration(TimeSpan value);
    [CompilerGeneratedAttribute]
public LineShape get_Shape();
    [CompilerGeneratedAttribute]
public void set_Shape(LineShape value);
    [CompilerGeneratedAttribute]
public Collection`1<CloudRoutingSegment> get_Segments();
    [CompilerGeneratedAttribute]
public void set_Segments(Collection`1<CloudRoutingSegment> value);
    [CompilerGeneratedAttribute]
public Dictionary`2<string, string> get_Warnings();
    [CompilerGeneratedAttribute]
public void set_Warnings(Dictionary`2<string, string> value);
}
[ObfuscationAttribute]
public class ThinkGeo.Core.CloudRoutingRouteResult : object {
    [CompilerGeneratedAttribute]
private Collection`1<CloudRoutingWaypoint> <Waypoints>k__BackingField;
    [CompilerGeneratedAttribute]
private Collection`1<CloudRoutingRoute> <Routes>k__BackingField;
    public Collection`1<CloudRoutingWaypoint> Waypoints { get; public set; }
    public Collection`1<CloudRoutingRoute> Routes { get; public set; }
    [CompilerGeneratedAttribute]
public Collection`1<CloudRoutingWaypoint> get_Waypoints();
    [CompilerGeneratedAttribute]
public void set_Waypoints(Collection`1<CloudRoutingWaypoint> value);
    [CompilerGeneratedAttribute]
public Collection`1<CloudRoutingRoute> get_Routes();
    [CompilerGeneratedAttribute]
public void set_Routes(Collection`1<CloudRoutingRoute> value);
}
[ObfuscationAttribute]
public class ThinkGeo.Core.CloudRoutingSegment : object {
    [CompilerGeneratedAttribute]
private double <Distance>k__BackingField;
    [CompilerGeneratedAttribute]
private TimeSpan <Duration>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Name>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Instruction>k__BackingField;
    [CompilerGeneratedAttribute]
private string <ManeuverType>k__BackingField;
    [CompilerGeneratedAttribute]
private LineShape <Shape>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Ref>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<bool> <IsToll>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<bool> <IsPrivate>k__BackingField;
    [CompilerGeneratedAttribute]
private Vertex <ManeuverLocation>k__BackingField;
    public double Distance { get; public set; }
    [CloudJsonConverterAttribute("ThinkGeo.Core.CloudDurationMinuteReader")]
public TimeSpan Duration { get; public set; }
    public string Name { get; public set; }
    public string Instruction { get; public set; }
    public string ManeuverType { get; public set; }
    [CloudJsonPropertyAttribute("geometry")]
[CloudJsonConverterAttribute("ThinkGeo.Core.CloudShapeWktConverter")]
public LineShape Shape { get; public set; }
    public string Ref { get; public set; }
    public Nullable`1<bool> IsToll { get; public set; }
    public Nullable`1<bool> IsPrivate { get; public set; }
    public Vertex ManeuverLocation { get; public set; }
    [CompilerGeneratedAttribute]
public double get_Distance();
    [CompilerGeneratedAttribute]
public void set_Distance(double value);
    [CompilerGeneratedAttribute]
public TimeSpan get_Duration();
    [CompilerGeneratedAttribute]
public void set_Duration(TimeSpan value);
    [CompilerGeneratedAttribute]
public string get_Name();
    [CompilerGeneratedAttribute]
public void set_Name(string value);
    [CompilerGeneratedAttribute]
public string get_Instruction();
    [CompilerGeneratedAttribute]
public void set_Instruction(string value);
    [CompilerGeneratedAttribute]
public string get_ManeuverType();
    [CompilerGeneratedAttribute]
public void set_ManeuverType(string value);
    [CompilerGeneratedAttribute]
public LineShape get_Shape();
    [CompilerGeneratedAttribute]
public void set_Shape(LineShape value);
    [CompilerGeneratedAttribute]
public string get_Ref();
    [CompilerGeneratedAttribute]
public void set_Ref(string value);
    [CompilerGeneratedAttribute]
public Nullable`1<bool> get_IsToll();
    [CompilerGeneratedAttribute]
public void set_IsToll(Nullable`1<bool> value);
    [CompilerGeneratedAttribute]
public Nullable`1<bool> get_IsPrivate();
    [CompilerGeneratedAttribute]
public void set_IsPrivate(Nullable`1<bool> value);
    [CompilerGeneratedAttribute]
public Vertex get_ManeuverLocation();
    [CompilerGeneratedAttribute]
public void set_ManeuverLocation(Vertex value);
}
[ObfuscationAttribute]
public enum ThinkGeo.Core.CloudRoutingServiceAreaObjectType : Enum {
    public int value__;
    public static CloudRoutingServiceAreaObjectType Polygon;
    public static CloudRoutingServiceAreaObjectType LineString;
}
[ObfuscationAttribute]
public class ThinkGeo.Core.CloudRoutingServiceAreaResult : object {
    [CompilerGeneratedAttribute]
private CloudRoutingWaypoint <Waypoint>k__BackingField;
    [CompilerGeneratedAttribute]
private Collection`1<BaseShape> <ServiceAreas>k__BackingField;
    public CloudRoutingWaypoint Waypoint { get; public set; }
    [CloudJsonConverterAttribute("ThinkGeo.Core.CloudShapeWktConverter")]
public Collection`1<BaseShape> ServiceAreas { get; public set; }
    [CompilerGeneratedAttribute]
public CloudRoutingWaypoint get_Waypoint();
    [CompilerGeneratedAttribute]
public void set_Waypoint(CloudRoutingWaypoint value);
    [CompilerGeneratedAttribute]
public Collection`1<BaseShape> get_ServiceAreas();
    [CompilerGeneratedAttribute]
public void set_ServiceAreas(Collection`1<BaseShape> value);
}
[ObfuscationAttribute]
public enum ThinkGeo.Core.CloudRoutingServiceAreaSeparationType : Enum {
    public int value__;
    public static CloudRoutingServiceAreaSeparationType Separated;
    public static CloudRoutingServiceAreaSeparationType Merged;
}
[ObfuscationAttribute]
public enum ThinkGeo.Core.CloudRoutingServiceAreaTravelDirection : Enum {
    public int value__;
    public static CloudRoutingServiceAreaTravelDirection From;
    public static CloudRoutingServiceAreaTravelDirection To;
}
[ObfuscationAttribute]
public class ThinkGeo.Core.CloudRoutingTimeCostMatrixResult : object {
    [CompilerGeneratedAttribute]
private Collection`1<CloudRoutingWaypoint> <Origins>k__BackingField;
    [CompilerGeneratedAttribute]
private Collection`1<CloudRoutingWaypoint> <Destinations>k__BackingField;
    [CompilerGeneratedAttribute]
private TimeSpan[0...,0...] <Durations>k__BackingField;
    public Collection`1<CloudRoutingWaypoint> Origins { get; public set; }
    public Collection`1<CloudRoutingWaypoint> Destinations { get; public set; }
    [CloudJsonConverterAttribute("ThinkGeo.Core.CloudDurationMinuteReader")]
public TimeSpan[0...,0...] Durations { get; public set; }
    [CompilerGeneratedAttribute]
public Collection`1<CloudRoutingWaypoint> get_Origins();
    [CompilerGeneratedAttribute]
public void set_Origins(Collection`1<CloudRoutingWaypoint> value);
    [CompilerGeneratedAttribute]
public Collection`1<CloudRoutingWaypoint> get_Destinations();
    [CompilerGeneratedAttribute]
public void set_Destinations(Collection`1<CloudRoutingWaypoint> value);
    [CompilerGeneratedAttribute]
public TimeSpan[0...,0...] get_Durations();
    [CompilerGeneratedAttribute]
public void set_Durations(TimeSpan[0...,0...] value);
}
[ObfuscationAttribute]
public enum ThinkGeo.Core.CloudRoutingTspFixDestinationCoordinate : Enum {
    public int value__;
    public static CloudRoutingTspFixDestinationCoordinate Any;
    public static CloudRoutingTspFixDestinationCoordinate Last;
}
[ObfuscationAttribute]
public enum ThinkGeo.Core.CloudRoutingTspFixSourceCoordinate : Enum {
    public int value__;
    public static CloudRoutingTspFixSourceCoordinate Any;
    public static CloudRoutingTspFixSourceCoordinate First;
}
[ObfuscationAttribute]
public class ThinkGeo.Core.CloudRoutingTspResult : object {
    [CompilerGeneratedAttribute]
private Collection`1<CloudRoutingWaypoint> <Waypoints>k__BackingField;
    [CompilerGeneratedAttribute]
private Collection`1<int> <VisitSequences>k__BackingField;
    [CompilerGeneratedAttribute]
private Collection`1<CloudRoutingRoute> <Routes>k__BackingField;
    public Collection`1<CloudRoutingWaypoint> Waypoints { get; public set; }
    public Collection`1<int> VisitSequences { get; public set; }
    public Collection`1<CloudRoutingRoute> Routes { get; public set; }
    [CompilerGeneratedAttribute]
public Collection`1<CloudRoutingWaypoint> get_Waypoints();
    [CompilerGeneratedAttribute]
public void set_Waypoints(Collection`1<CloudRoutingWaypoint> value);
    [CompilerGeneratedAttribute]
public Collection`1<int> get_VisitSequences();
    [CompilerGeneratedAttribute]
public void set_VisitSequences(Collection`1<int> value);
    [CompilerGeneratedAttribute]
public Collection`1<CloudRoutingRoute> get_Routes();
    [CompilerGeneratedAttribute]
public void set_Routes(Collection`1<CloudRoutingRoute> value);
}
[ObfuscationAttribute]
public class ThinkGeo.Core.CloudRoutingWaypoint : object {
    [CompilerGeneratedAttribute]
private Vertex <Coordinate>k__BackingField;
    [CompilerGeneratedAttribute]
private float <SnappedDistance>k__BackingField;
    public Vertex Coordinate { get; public set; }
    public float SnappedDistance { get; public set; }
    [CompilerGeneratedAttribute]
public Vertex get_Coordinate();
    [CompilerGeneratedAttribute]
public void set_Coordinate(Vertex value);
    [CompilerGeneratedAttribute]
public float get_SnappedDistance();
    [CompilerGeneratedAttribute]
public void set_SnappedDistance(float value);
}
[ObfuscationAttribute]
internal class ThinkGeo.Core.CloudShapeWktConverter : CloudJsonConverter`1<BaseShape> {
    public virtual BaseShape ReadJson(CloudGeoJObject jObject, Type objectType);
    public virtual void WriteJson(CloudGeoJObject jObject, BaseShape value);
}
[ObfuscationAttribute]
public enum ThinkGeo.Core.CloudTileSize : Enum {
    public int value__;
    public static CloudTileSize Default;
    public static CloudTileSize Small;
    public static CloudTileSize Medium;
}
[ObfuscationAttribute]
public class ThinkGeo.Core.CloudTimeZoneResult : object {
    [CompilerGeneratedAttribute]
private string <TimeZone>k__BackingField;
    [CompilerGeneratedAttribute]
private string <CountryName>k__BackingField;
    [CompilerGeneratedAttribute]
private string <CountryCode>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Comment>k__BackingField;
    [CompilerGeneratedAttribute]
private DateTime <CurrentLocalTime>k__BackingField;
    [CompilerGeneratedAttribute]
private DateTime <CurrentUtcTime>k__BackingField;
    [CompilerGeneratedAttribute]
private double <OffsetSeconds>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <DaylightSavingsActive>k__BackingField;
    [CompilerGeneratedAttribute]
private MultipolygonShape <Shape>k__BackingField;
    public string TimeZone { get; }
    public string CountryName { get; }
    public string CountryCode { get; }
    public string Comment { get; }
    public DateTime CurrentLocalTime { get; }
    public DateTime CurrentUtcTime { get; }
    public double OffsetSeconds { get; }
    public bool DaylightSavingsActive { get; }
    public MultipolygonShape Shape { get; }
    public CloudTimeZoneResult(string timezone, string countryName, string countryCode, string comment, DateTime currentLocalTime, DateTime currentUtcTime, double offsetSeconds, bool daylightSavingsActive, MultipolygonShape shape);
    [CompilerGeneratedAttribute]
public string get_TimeZone();
    [CompilerGeneratedAttribute]
public string get_CountryName();
    [CompilerGeneratedAttribute]
public string get_CountryCode();
    [CompilerGeneratedAttribute]
public string get_Comment();
    [CompilerGeneratedAttribute]
public DateTime get_CurrentLocalTime();
    [CompilerGeneratedAttribute]
public DateTime get_CurrentUtcTime();
    [CompilerGeneratedAttribute]
public double get_OffsetSeconds();
    [CompilerGeneratedAttribute]
public bool get_DaylightSavingsActive();
    [CompilerGeneratedAttribute]
public MultipolygonShape get_Shape();
}
[ObfuscationAttribute]
internal static class ThinkGeo.Core.CloudValidators : object {
    internal static void ValueInRange(string parameterName, int value, int minValue, bool includeMinValue, int maxValue, bool includeMaxValue);
    internal static void ValueInRange(string parameterName, double value, double minValue, bool includeMinValue, double maxValue, bool includeMaxValue);
    internal static void ValueInRange(string parameterName, int value, int minValue, int maxValue);
    internal static void ValueInRange(string parameterName, double value, double minValue, double maxValue);
    internal static void NotNull(object value, string paramName);
    internal static void NotNullOrEmpty(string value, string paramName);
    internal static void ItemNotNull(IEnumerable`1<T> values, string paramName);
}
public class ThinkGeo.Core.ClusterPointStyle : Style {
    [ObfuscationAttribute]
private int cellSize;
    [ObfuscationAttribute]
private TextStyle defaultTextSytle;
    [ObfuscationAttribute]
private int minimumFeaturesPerCellToCluster;
    [ObfuscationAttribute]
private bool clusterCellLinesVisible;
    [ObfuscationAttribute]
private Collection`1<Style> customStyles;
    [ObfuscationAttribute]
private PointStyle defaultPointStyle;
    [ObfuscationAttribute]
private PointStyle clusteredPointStyle;
    [CompilerGeneratedAttribute]
private EventHandler`1<DrawingClusteredFeatureClusterPointStyleEventArgs> DrawingClusteredFeature;
    public PointStyle DefaultPointStyle { get; public set; }
    public PointStyle ClusteredPointStyle { get; public set; }
    public TextStyle DefaultTextStyle { get; public set; }
    public Collection`1<Style> CustomStyles { get; }
    public int CellSize { get; public set; }
    public bool ClusterCellLinesVisible { get; public set; }
    public int MinimumFeaturesPerCellToCluster { get; public set; }
    public ClusterPointStyle(PointStyle defaultPointStyle);
    public ClusterPointStyle(PointStyle defaultPointStyle, TextStyle defaultTextStyle);
    public ClusterPointStyle(PointStyle defaultPointStyle, TextStyle defaultTextStyle, PointStyle clusteredPointStyle);
    [CompilerGeneratedAttribute]
public void add_DrawingClusteredFeature(EventHandler`1<DrawingClusteredFeatureClusterPointStyleEventArgs> value);
    [CompilerGeneratedAttribute]
public void remove_DrawingClusteredFeature(EventHandler`1<DrawingClusteredFeatureClusterPointStyleEventArgs> value);
    public PointStyle get_DefaultPointStyle();
    public void set_DefaultPointStyle(PointStyle value);
    public PointStyle get_ClusteredPointStyle();
    public void set_ClusteredPointStyle(PointStyle value);
    public TextStyle get_DefaultTextStyle();
    public void set_DefaultTextStyle(TextStyle value);
    public Collection`1<Style> get_CustomStyles();
    public int get_CellSize();
    public void set_CellSize(int value);
    public bool get_ClusterCellLinesVisible();
    public void set_ClusterCellLinesVisible(bool value);
    public int get_MinimumFeaturesPerCellToCluster();
    public void set_MinimumFeaturesPerCellToCluster(int value);
    protected virtual void DrawCore(IEnumerable`1<Feature> features, GeoCanvas canvas, Collection`1<SimpleCandidate> labelsInThisLayer, Collection`1<SimpleCandidate> labelsInAllLayers);
    protected virtual Collection`1<string> GetRequiredColumnNamesCore();
    protected virtual void OnDrawingClusterdFeature(DrawingClusteredFeatureClusterPointStyleEventArgs e);
    private static bool WR8=(RectangleShape bbox, PointShape point);
    private static T RTE=(object obj);
}
public class ThinkGeo.Core.CollectedMapArgumentsMapViewEventArgs : EventArgs {
    [ObfuscationAttribute]
private MapArguments mapArguments;
    public MapArguments MapArguments { get; public set; }
    public CollectedMapArgumentsMapViewEventArgs(MapArguments mapArguments);
    public MapArguments get_MapArguments();
    public void set_MapArguments(MapArguments value);
}
public class ThinkGeo.Core.ColorCloudClient : CloudClient {
    public ColorCloudClient(string clientId, string clientSecret);
    public Dictionary`2<GeoColor, Collection`1<GeoColor>> GetColorsInAnalogousFamily(int numberOfColors);
    [AsyncStateMachineAttribute("ThinkGeo.Core.ColorCloudClient/<GetColorsInAnalogousFamilyAsync>d__3")]
public Task`1<Dictionary`2<GeoColor, Collection`1<GeoColor>>> GetColorsInAnalogousFamilyAsync(int numberOfColors);
    public Dictionary`2<GeoColor, Collection`1<GeoColor>> GetColorsInAnalogousFamily(GeoColor color, int numberOfColors);
    [AsyncStateMachineAttribute("ThinkGeo.Core.ColorCloudClient/<GetColorsInAnalogousFamilyAsync>d__5")]
public Task`1<Dictionary`2<GeoColor, Collection`1<GeoColor>>> GetColorsInAnalogousFamilyAsync(GeoColor color, int numberOfColors);
    public Dictionary`2<GeoColor, Collection`1<GeoColor>> GetColorsInComplementaryFamily(int numberOfColors);
    [AsyncStateMachineAttribute("ThinkGeo.Core.ColorCloudClient/<GetColorsInComplementaryFamilyAsync>d__7")]
public Task`1<Dictionary`2<GeoColor, Collection`1<GeoColor>>> GetColorsInComplementaryFamilyAsync(int numberOfColors);
    public Dictionary`2<GeoColor, Collection`1<GeoColor>> GetColorsInComplementaryFamily(GeoColor color, int numberOfColors);
    [AsyncStateMachineAttribute("ThinkGeo.Core.ColorCloudClient/<GetColorsInComplementaryFamilyAsync>d__9")]
public Task`1<Dictionary`2<GeoColor, Collection`1<GeoColor>>> GetColorsInComplementaryFamilyAsync(GeoColor color, int numberOfColors);
    public Dictionary`2<GeoColor, Collection`1<GeoColor>> GetColorsInContrastingFamily(int numberOfColors);
    [AsyncStateMachineAttribute("ThinkGeo.Core.ColorCloudClient/<GetColorsInContrastingFamilyAsync>d__11")]
public Task`1<Dictionary`2<GeoColor, Collection`1<GeoColor>>> GetColorsInContrastingFamilyAsync(int numberOfColors);
    public Dictionary`2<GeoColor, Collection`1<GeoColor>> GetColorsInContrastingFamily(GeoColor color, int numberOfColors);
    [AsyncStateMachineAttribute("ThinkGeo.Core.ColorCloudClient/<GetColorsInContrastingFamilyAsync>d__13")]
public Task`1<Dictionary`2<GeoColor, Collection`1<GeoColor>>> GetColorsInContrastingFamilyAsync(GeoColor color, int numberOfColors);
    public Collection`1<GeoColor> GetColorsInHueFamily(int numberOfColors);
    [AsyncStateMachineAttribute("ThinkGeo.Core.ColorCloudClient/<GetColorsInHueFamilyAsync>d__15")]
public Task`1<Collection`1<GeoColor>> GetColorsInHueFamilyAsync(int numberOfColors);
    public Collection`1<GeoColor> GetColorsInHueFamily(GeoColor color, int numberOfColors);
    [AsyncStateMachineAttribute("ThinkGeo.Core.ColorCloudClient/<GetColorsInHueFamilyAsync>d__17")]
public Task`1<Collection`1<GeoColor>> GetColorsInHueFamilyAsync(GeoColor color, int numberOfColors);
    public Collection`1<GeoColor> GetColorsInQualityFamily(int numberOfColors);
    [AsyncStateMachineAttribute("ThinkGeo.Core.ColorCloudClient/<GetColorsInQualityFamilyAsync>d__19")]
public Task`1<Collection`1<GeoColor>> GetColorsInQualityFamilyAsync(int numberOfColors);
    public Collection`1<GeoColor> GetColorsInQualityFamily(GeoColor color, int numberOfColors);
    [AsyncStateMachineAttribute("ThinkGeo.Core.ColorCloudClient/<GetColorsInQualityFamilyAsync>d__21")]
public Task`1<Collection`1<GeoColor>> GetColorsInQualityFamilyAsync(GeoColor color, int numberOfColors);
    public Dictionary`2<GeoColor, Collection`1<GeoColor>> GetColorsInTetradFamily(int numberOfColors);
    [AsyncStateMachineAttribute("ThinkGeo.Core.ColorCloudClient/<GetColorsInTetradFamilyAsync>d__23")]
public Task`1<Dictionary`2<GeoColor, Collection`1<GeoColor>>> GetColorsInTetradFamilyAsync(int numberOfColors);
    public Dictionary`2<GeoColor, Collection`1<GeoColor>> GetColorsInTetradFamily(GeoColor color, int numberOfColors);
    [AsyncStateMachineAttribute("ThinkGeo.Core.ColorCloudClient/<GetColorsInTetradFamilyAsync>d__25")]
public Task`1<Dictionary`2<GeoColor, Collection`1<GeoColor>>> GetColorsInTetradFamilyAsync(GeoColor color, int numberOfColors);
    public Dictionary`2<GeoColor, Collection`1<GeoColor>> GetColorsInTriadFamily(int numberOfColors);
    [AsyncStateMachineAttribute("ThinkGeo.Core.ColorCloudClient/<GetColorsInTriadFamilyAsync>d__27")]
public Task`1<Dictionary`2<GeoColor, Collection`1<GeoColor>>> GetColorsInTriadFamilyAsync(int numberOfColors);
    public Dictionary`2<GeoColor, Collection`1<GeoColor>> GetColorsInTriadFamily(GeoColor color, int numberOfColors);
    [AsyncStateMachineAttribute("ThinkGeo.Core.ColorCloudClient/<GetColorsInTriadFamilyAsync>d__29")]
public Task`1<Dictionary`2<GeoColor, Collection`1<GeoColor>>> GetColorsInTriadFamilyAsync(GeoColor color, int numberOfColors);
    private Collection`1<GeoColor> oBQ=(WebResponse response);
    private Dictionary`2<GeoColor, Collection`1<GeoColor>> oRQ=(WebResponse response);
    private Collection`1<GeoColor> ohQ=(List`1<string> result);
    private GeoColor oxQ=(string colorExpression);
    private string pBQ=(GeoColor color);
}
[ObfuscationAttribute]
internal enum ThinkGeo.Core.ColorType : Enum {
    public int value__;
    public static ColorType NonStandardColor;
    public static ColorType StandardColor;
    public static ColorType SimpleColor;
}
public enum ThinkGeo.Core.ColorWheelDirection : Enum {
    public int value__;
    public static ColorWheelDirection Clockwise;
    public static ColorWheelDirection CounterClockwise;
}
public class ThinkGeo.Core.CommittedTransactionEventArgs : EventArgs {
    [ObfuscationAttribute]
private TransactionBuffer transactionBuffer;
    public TransactionBuffer TransactionBuffer { get; public set; }
    public CommittedTransactionEventArgs(TransactionBuffer transactionBuffer);
    public TransactionBuffer get_TransactionBuffer();
    public void set_TransactionBuffer(TransactionBuffer value);
}
public class ThinkGeo.Core.CommittingTransactionEventArgs : EventArgs {
    [ObfuscationAttribute]
private TransactionBuffer transactionBuffer;
    [ObfuscationAttribute]
private bool cancel;
    public bool Cancel { get; public set; }
    public TransactionBuffer TransactionBuffer { get; public set; }
    public CommittingTransactionEventArgs(TransactionBuffer transactionBuffer);
    public bool get_Cancel();
    public void set_Cancel(bool value);
    public TransactionBuffer get_TransactionBuffer();
    public void set_TransactionBuffer(TransactionBuffer value);
}
public class ThinkGeo.Core.CompositeStyle : Style {
    [ObfuscationAttribute]
private ObservableCollection`1<Style> styles;
    [ObfuscationAttribute]
private Collection`1<string> filtersFromStyles;
    public ObservableCollection`1<Style> Styles { get; }
    protected Collection`1<string> FiltersCore { get; }
    public CompositeStyle(Style style);
    public CompositeStyle(IEnumerable`1<Style> styles);
    public ObservableCollection`1<Style> get_Styles();
    protected virtual void DrawCore(IEnumerable`1<Feature> features, GeoCanvas canvas, Collection`1<SimpleCandidate> labelsInThisLayer, Collection`1<SimpleCandidate> labelsInAllLayers);
    protected virtual void DrawSampleCore(GeoCanvas canvas, DrawingRectangleF drawingExtent);
    protected virtual Collection`1<string> GetRequiredColumnNamesCore();
    protected virtual Collection`1<string> get_FiltersCore();
}
internal class ThinkGeo.Core.ContractResolver : object {
    private static ContractResolver _instance;
    private ThreadSafeStore`2<Type, JsonContract> _contractCache;
    internal static ContractResolver Instance { get; }
    private static ContractResolver();
    internal static ContractResolver get_Instance();
    public virtual JsonContract ResolveContract(Type type);
    private JsonContract CreateContract(Type objectType);
    private IList`1<JsonProperty> CreateConstructorParameters(ConstructorInfo constructor, JsonPropertyCollection memberProperties);
    private JsonProperty CreatePropertyFromConstructorParameter(JsonProperty matchingMemberProperty, ParameterInfo parameterInfo);
    private JsonProperty MatchProperty(JsonPropertyCollection properties, string name, Type type);
    private jBU=<object> CreateParameterizedConstructor(MethodBase method);
    private ConstructorInfo GetParameterizedConstructor(Type objectType);
    private IList`1<JsonProperty> CreateProperties(Type type);
    private JsonProperty CreateProperty(MemberInfo member);
    private static bool CanSetMemberValue(MemberInfo member, bool nonPublic, bool canSetReadOnly);
    private static bool CanReadMemberValue(MemberInfo member, bool nonPublic);
    private void SetPropertySettingsFromAttributes(JsonProperty property, object attributeProvider, string name, Type declaringType, Boolean& allowNonPublicAccess);
    private List`1<MemberInfo> GetSerializableMembers(Type objectType);
    private static List`1<MemberInfo> GetFieldsAndProperties(Type type, BindingFlags bindingAttr);
    private static bool IsOverridenGenericMember(MemberInfo memberInfo, BindingFlags bindingAttr);
    public static bool IsVirtual(PropertyInfo propertyInfo);
    private static Type GetMemberUnderlyingType(MemberInfo member);
    private static IEnumerable`1<PropertyInfo> GetProperties(Type targetType, BindingFlags bindingAttr);
    private static IEnumerable`1<FieldInfo> GetFields(Type targetType, BindingFlags bindingAttr);
    private static void GetChildPrivateFields(IList`1<MemberInfo> initialFields, Type targetType, BindingFlags bindingAttr);
}
public class ThinkGeo.Core.ControlPointSelectedEditInteractiveOverlayEventArgs : EventArgs {
    [CompilerGeneratedAttribute]
private Feature hRQ=;
    public Feature SelectedFeature { get; public set; }
    public ControlPointSelectedEditInteractiveOverlayEventArgs(Feature selectedFeature);
    [CompilerGeneratedAttribute]
public Feature get_SelectedFeature();
    [CompilerGeneratedAttribute]
public void set_SelectedFeature(Feature value);
}
public class ThinkGeo.Core.ControlPointSelectingEditInteractiveOverlayEventArgs : EventArgs {
    [ObfuscationAttribute]
private PointShape targetPointShape;
    [ObfuscationAttribute]
private bool cancel;
    public PointShape TargetPointShape { get; public set; }
    public bool Cancel { get; public set; }
    public ControlPointSelectingEditInteractiveOverlayEventArgs(bool cancel, PointShape targetPointShape);
    public PointShape get_TargetPointShape();
    public void set_TargetPointShape(PointShape value);
    public bool get_Cancel();
    public void set_Cancel(bool value);
}
public static class ThinkGeo.Core.Conversion : object {
    [ObfuscationAttribute]
private static Dictionary`2<DistanceUnit, double> distanceDictionary;
    [ObfuscationAttribute]
private static Dictionary`2<AreaUnit, double> areaDictionary;
    private static Conversion();
    public static double ConvertMeasureUnits(double amount, DistanceUnit fromUnit, DistanceUnit toUnit);
    public static double ConvertMeasureUnits(double amount, AreaUnit fromUnit, AreaUnit toUnit);
    public static DistanceUnit ConvertGeographyUnitToDistanceUnit(GeographyUnit unit);
    internal static double rRo=(double degrees);
    public static double ConvertAngleUnits(double angle, AngleUnit fromUnit, AngleUnit toUnit);
}
public class ThinkGeo.Core.ConvertedShapeToNtsGeometryShapeConverterEventArgs : object {
    [CompilerGeneratedAttribute]
private BaseShape rho=;
    [CompilerGeneratedAttribute]
private Geometry rxo=;
    public BaseShape FromShape { get; public set; }
    public Geometry ToGeometry { get; public set; }
    [CompilerGeneratedAttribute]
public BaseShape get_FromShape();
    [CompilerGeneratedAttribute]
public void set_FromShape(BaseShape value);
    [CompilerGeneratedAttribute]
public Geometry get_ToGeometry();
    [CompilerGeneratedAttribute]
public void set_ToGeometry(Geometry value);
}
internal class ThinkGeo.Core.CreatedMemberNodeGeoObjectModelerEventArgs : EventArgs {
    [ObfuscationAttribute]
private string name;
    [ObfuscationAttribute]
private object value;
    [ObfuscationAttribute]
private Type type;
    [ObfuscationAttribute]
private object owner;
    [ObfuscationAttribute]
private GeoObjectNode node;
    public string Name { get; public set; }
    public object Value { get; public set; }
    public Type Type { get; public set; }
    public object Owner { get; public set; }
    public GeoObjectNode Node { get; public set; }
    public CreatedMemberNodeGeoObjectModelerEventArgs(string name, object value, Type type, object owner, GeoObjectNode node);
    public string get_Name();
    public void set_Name(string value);
    public object get_Value();
    public void set_Value(object value);
    public Type get_Type();
    public void set_Type(Type value);
    public object get_Owner();
    public void set_Owner(object value);
    public GeoObjectNode get_Node();
    public void set_Node(GeoObjectNode value);
}
internal class ThinkGeo.Core.CreatedMemberObjectGeoObjectModelerEventArgs : EventArgs {
    [ObfuscationAttribute]
private string name;
    [ObfuscationAttribute]
private object value;
    [ObfuscationAttribute]
private Type type;
    [ObfuscationAttribute]
private object owner;
    public string Name { get; public set; }
    public object Value { get; public set; }
    public Type Type { get; public set; }
    public object Owner { get; public set; }
    public CreatedMemberObjectGeoObjectModelerEventArgs(string name, object value, Type type, object owner);
    public string get_Name();
    public void set_Name(string value);
    public object get_Value();
    public void set_Value(object value);
    public Type get_Type();
    public void set_Type(Type value);
    public object get_Owner();
    public void set_Owner(object value);
}
internal class ThinkGeo.Core.CreatingMemberNodeGeoObjectModelerEventArgs : EventArgs {
    [ObfuscationAttribute]
private string name;
    [ObfuscationAttribute]
private object value;
    [ObfuscationAttribute]
private Type type;
    [ObfuscationAttribute]
private object owner;
    public string Name { get; public set; }
    public object Value { get; public set; }
    public Type Type { get; public set; }
    public object Owner { get; public set; }
    public CreatingMemberNodeGeoObjectModelerEventArgs(string name, object value, Type type, object owner);
    public string get_Name();
    public void set_Name(string value);
    public object get_Value();
    public void set_Value(object value);
    public Type get_Type();
    public void set_Type(Type value);
    public object get_Owner();
    public void set_Owner(object value);
}
internal class ThinkGeo.Core.CreatingMemberObjectGeoObjectModelerEventArgs : EventArgs {
    [ObfuscationAttribute]
private string name;
    [ObfuscationAttribute]
private Type type;
    [ObfuscationAttribute]
private object owner;
    [ObfuscationAttribute]
private GeoObjectNode node;
    public string Name { get; public set; }
    public Type Type { get; public set; }
    public object Owner { get; public set; }
    public GeoObjectNode Node { get; public set; }
    public CreatingMemberObjectGeoObjectModelerEventArgs(string name, Type type, object owner, GeoObjectNode node);
    public string get_Name();
    public void set_Name(string value);
    public Type get_Type();
    public void set_Type(Type value);
    public object get_Owner();
    public void set_Owner(object value);
    public GeoObjectNode get_Node();
    public void set_Node(GeoObjectNode value);
}
public class ThinkGeo.Core.CreatingRequestGoogleMapsLayerEventArgs : EventArgs {
    [ObfuscationAttribute]
private Uri requestUri;
    public Uri RequestUri { get; public set; }
    public CreatingRequestGoogleMapsLayerEventArgs(Uri requestUri);
    public Uri get_RequestUri();
    public void set_RequestUri(Uri value);
}
public class ThinkGeo.Core.CustomColumnFetchEventArgs : EventArgs {
    [ObfuscationAttribute]
private string columnName;
    [ObfuscationAttribute]
private string id;
    [ObfuscationAttribute]
private string columnValue;
    public string ColumnName { get; }
    public string Id { get; }
    public string ColumnValue { get; public set; }
    public CustomColumnFetchEventArgs(string columnName, string id);
    public string get_ColumnName();
    public string get_Id();
    public string get_ColumnValue();
    public void set_ColumnValue(string value);
}
public enum ThinkGeo.Core.DatabaseConnectionMode : Enum {
    public int value__;
    public static DatabaseConnectionMode Default;
    public static DatabaseConnectionMode AutoClose;
    public static DatabaseConnectionMode KeepOpen;
}
public class ThinkGeo.Core.DateRangeFilterCondition : FilterCondition {
    [ObfuscationAttribute]
private DateTime fromDate;
    [ObfuscationAttribute]
private DateTime toDate;
    public DateTime FromDate { get; public set; }
    public DateTime ToDate { get; public set; }
    public DateRangeFilterCondition(DateTime fromDate, DateTime toDate);
    public DateTime get_FromDate();
    public void set_FromDate(DateTime value);
    public DateTime get_ToDate();
    public void set_ToDate(DateTime value);
    internal virtual bool 3yI=(Feature feature);
    private bool TTE=(Feature feature);
    private bool TjE=(DateTime currentDate, string dateString);
}
public class ThinkGeo.Core.DbfColumn : FeatureSourceColumn {
    [ObfuscationAttribute]
private DbfColumnType columnType;
    [ObfuscationAttribute]
private int length;
    [ObfuscationAttribute]
private int decimalLength;
    public DbfColumnType ColumnType { get; public set; }
    public int Length { get; public set; }
    public int DecimalLength { get; public set; }
    public DbfColumn(string columnName, DbfColumnType columnType, int length, int decimalLength);
    public DbfColumnType get_ColumnType();
    public void set_ColumnType(DbfColumnType value);
    public int get_Length();
    public void set_Length(int value);
    public int get_DecimalLength();
    public void set_DecimalLength(int value);
}
internal class ThinkGeo.Core.DbfColumnInfo : ValueType {
    [ObfuscationAttribute]
private int offset;
    [ObfuscationAttribute]
private int size;
    [ObfuscationAttribute]
private int decimals;
    [ObfuscationAttribute]
private byte byteType;
    public int Offset { get; public set; }
    public int Size { get; public set; }
    public int Decimals { get; public set; }
    public byte ByteType { get; public set; }
    public int get_Offset();
    public void set_Offset(int value);
    public int get_Size();
    public void set_Size(int value);
    public int get_Decimals();
    public void set_Decimals(int value);
    public byte get_ByteType();
    public void set_ByteType(byte value);
    public virtual bool Equals(object obj);
    private bool Equals(DbfColumnInfo dbfColumnInfo);
    public virtual int GetHashCode();
    public static DbfColumnInfo op_Addition(DbfColumnInfo dbfColumnInfo1, DbfColumnInfo dbfColumnInfo2);
    public static bool op_Equality(DbfColumnInfo dbfColumnInfo1, DbfColumnInfo dbfColumnInfo2);
    public static bool op_Inequality(DbfColumnInfo dbfColumnInfo1, DbfColumnInfo dbfColumnInfo2);
}
public enum ThinkGeo.Core.DbfColumnType : Enum {
    public int value__;
    public static DbfColumnType Null;
    public static DbfColumnType Logical;
    public static DbfColumnType Memo;
    public static DbfColumnType Date;
    public static DbfColumnType DateTime;
    public static DbfColumnType IntegerInBinary;
    public static DbfColumnType DoubleInBinary;
    public static DbfColumnType Character;
    public static DbfColumnType Float;
    public static DbfColumnType Numeric;
}
public static class ThinkGeo.Core.DecimalDegreesHelper : object {
    private static double sBo=;
    private static double sRo=;
    private static double sho=;
    private static int sxo=;
    public static string GetDegreesMinutesStringFromDecimalDegreePoint(Feature point, int decimals);
    public static string GetDegreesMinutesStringFromDecimalDegreePoint(Feature point);
    public static string GetDegreesMinutesStringFromDecimalDegreePoint(PointShape pointShape);
    public static string GetDegreesMinutesStringFromDecimalDegreePoint(PointShape pointShape, int decimals);
    internal static string tBo=(double decimalDegreesValue);
    internal static string tBo=(double decimalDegreesValue, int decimals);
    public static DegreesMinutesSeconds GetDegreesMinutesSecondsFromDecimalDegree(double decimalDegreesValue);
    public static string GetDegreesMinutesSecondsStringFromDecimalDegree(double decimalDegreesValue);
    public static string GetDegreesMinutesSecondsStringFromDecimalDegree(double decimalDegreesValue, int decimals);
    public static string GetDegreesMinutesSecondsStringFromDecimalDegreePoint(PointShape pointShape);
    public static string GetDegreesMinutesSecondsStringFromDecimalDegreePoint(PointShape pointShape, int decimals);
    public static string GetDegreesMinutesSecondsStringFromDecimalDegreePoint(Feature point, int decimalPlaces);
    public static string GetDegreesMinutesSecondsStringFromDecimalDegreePoint(Feature point);
    public static double GetDecimalDegreeFromDegreesMinutesSeconds(string degreesMinutesSeconds);
    public static double GetDecimalDegreeFromDegreesMinutesSeconds(DegreesMinutesSeconds degreesMinutesSeconds);
    public static double GetDecimalDegreeFromDegreesMinutesSeconds(int degrees, int minutes, double seconds);
    public static double GetDistanceFromDecimalDegrees(PointShape fromPoint, PointShape toPoint, DistanceUnit returningUnit);
    public static double GetDistanceFromDecimalDegrees(Feature fromPointFeature, Feature toPointFeature, DistanceUnit returningUnit);
    public static double GetDistanceFromDecimalDegrees(double fromLatitude, double fromLongitude, double toLatitude, double toLongitude, DistanceUnit returningUnit);
    public static double GetLongitudeDifferenceFromDistance(double distance, DistanceUnit distanceUnit, double latitude);
    public static double GetLatitudeDifferenceFromDistance(double distance, DistanceUnit distanceUnit);
    public static string ConvertToMgrs(double latitude, double longitude);
    public static PointShape ConvertFromMgrs(string mgrs);
    internal static double tRo=(double fromLongitude, double fromLatitude, double distance, DistanceUnit distanceUnit, double degree);
    internal static double tho=(double fromLongitude, double fromLatitude, double distance, DistanceUnit distanceUnit, double degree);
    internal static MultilineShape txo=(PointShape fromPoint, PointShape toPoint, int count);
    internal static double uBo=(double fromPointX, double fromPointY, double toPointX, double toPointY, PointShape pointShape, DistanceUnit lengthUnit);
    internal static PointShape uRo=(double fromPointX, double fromPointY, double toPointX, double toPointY, PointShape pointShape);
    internal static double uho=(double degreeX, double degreeY, DistanceUnit distanceUnit);
    internal static double uxo=(double degreeY, DistanceUnit distanceUnit);
}
public class ThinkGeo.Core.DegreesMinutesSeconds : ValueType {
    [ObfuscationAttribute]
private int degrees;
    [ObfuscationAttribute]
private int minutes;
    [ObfuscationAttribute]
private double seconds;
    public int Degrees { get; public set; }
    public int Minutes { get; public set; }
    public double Seconds { get; public set; }
    public DegreesMinutesSeconds(int degrees, int minutes, double seconds);
    private static double vBo=(int degrees, int minutes, double seconds);
    public int get_Degrees();
    public void set_Degrees(int value);
    public int get_Minutes();
    public void set_Minutes(int value);
    public double get_Seconds();
    public void set_Seconds(double value);
    public virtual int GetHashCode();
    public virtual bool Equals(object obj);
    private bool bRU=(DegreesMinutesSeconds compareObj);
    public DegreesMinutesSeconds Add(DegreesMinutesSeconds targetDegreesMinutesSeconds);
    public static DegreesMinutesSeconds op_Addition(DegreesMinutesSeconds degreesMinutesSeconds1, DegreesMinutesSeconds degreesMinutesSeconds2);
    public static bool op_Equality(DegreesMinutesSeconds degreesMinutesSeconds1, DegreesMinutesSeconds degreesMinutesSeconds2);
    public static bool op_Inequality(DegreesMinutesSeconds degreesMinutesSeconds1, DegreesMinutesSeconds degreesMinutesSeconds2);
    public virtual string ToString();
    public string GetFormattedString(int decimals);
    public string GetFormattedString(DegreesMinutesSecondsFormatType formatType);
    public string GetFormattedString(DegreesMinutesSecondsFormatType formatType, int decimals);
}
public enum ThinkGeo.Core.DegreesMinutesSecondsFormatType : Enum {
    public int value__;
    public static DegreesMinutesSecondsFormatType DegreesMinutesSeconds;
    public static DegreesMinutesSecondsFormatType DegreesMinutes;
}
public enum ThinkGeo.Core.DelimitedColumnHeaderType : Enum {
    public int value__;
    public static DelimitedColumnHeaderType FirstRowAsHeader;
    public static DelimitedColumnHeaderType NoHeader;
}
public class ThinkGeo.Core.DelimitedFeatureLayer : FeatureLayer {
    [ObfuscationAttribute]
private DelimitedFeatureSource featureSource;
    public string DelimitedPathFilename { get; public set; }
    public string XColumnName { get; public set; }
    public string YColumnName { get; public set; }
    public string WellKnownTextColumnName { get; public set; }
    internal int UyE= { get; internal set; }
    internal int ViE= { get; internal set; }
    internal int WSE= { get; internal set; }
    public string Delimiter { get; public set; }
    public DelimitedSpatialColumnsType SpatialColumnType { get; public set; }
    internal DelimitedColumnHeaderType XCE= { get; internal set; }
    public Encoding Encoding { get; public set; }
    public bool RequireIndex { get; public set; }
    public bool HasBoundingBox { get; }
    public DelimitedFeatureLayer(string delimitedPathFilename, string wellKnownTextColumnName, string delimiter);
    public DelimitedFeatureLayer(string delimitedPathFilename, string xColumnName, string yColumnName, string delimiter);
    private DelimitedFeatureLayer(string delimitedPathFilename);
    public string get_DelimitedPathFilename();
    public void set_DelimitedPathFilename(string value);
    public string get_XColumnName();
    public void set_XColumnName(string value);
    public string get_YColumnName();
    public void set_YColumnName(string value);
    public string get_WellKnownTextColumnName();
    public void set_WellKnownTextColumnName(string value);
    internal int USE=();
    internal void UiE=(int value);
    internal int VCE=();
    internal void VSE=(int value);
    internal int VyE=();
    internal void WCE=(int value);
    public string get_Delimiter();
    public void set_Delimiter(string value);
    public DelimitedSpatialColumnsType get_SpatialColumnType();
    public void set_SpatialColumnType(DelimitedSpatialColumnsType value);
    internal DelimitedColumnHeaderType WiE=();
    internal void WyE=(DelimitedColumnHeaderType value);
    public Encoding get_Encoding();
    public void set_Encoding(Encoding value);
    public bool get_RequireIndex();
    public void set_RequireIndex(bool value);
    public virtual bool get_HasBoundingBox();
    public static void BuildIndexFile(string delimitedPathFilename, string xColumnName, string yColumnName, string delimiter, BuildIndexMode buildIndexMode, Encoding encoding);
    public static void BuildIndexFile(string delimitedPathFilename, string wellKnownTextColumnName, string delimiter, BuildIndexMode buildIndexMode, Encoding encoding);
    public static void BuildIndexFile(string delimitedPathFilename, string xColumnName, string yColumnName, string delimiter, BuildIndexMode buildIndexMode);
    public static void BuildIndexFile(string delimitedPathFilename, string wellKnownTextColumnName, string delimiter, BuildIndexMode buildIndexMode);
    public static void CreateDelimitedFile(string delimitedPathFilename, IEnumerable`1<string> columnNames, string delimiter, OverwriteMode overwriteMode);
    public static void CreateDelimitedFile(string delimitedPathFilename, IEnumerable`1<string> columnNames, string delimiter, OverwriteMode overwriteMode, Encoding encoding);
}
public class ThinkGeo.Core.DelimitedFeatureSource : FeatureSource {
    private static int XSE=;
    [CompilerGeneratedAttribute]
private static EventHandler`1<BuildingIndexDelimitedFeatureSourceEventArgs> BuildingIndex;
    [ObfuscationAttribute]
private string delimitedPathFilename;
    [ObfuscationAttribute]
private string xColumnName;
    [ObfuscationAttribute]
private string yColumnName;
    [ObfuscationAttribute]
private int xColumnPosition;
    [ObfuscationAttribute]
private int yColumnPosition;
    [ObfuscationAttribute]
private string wellKnownTextColumnName;
    [ObfuscationAttribute]
private int wellKnownTextColumnPosition;
    [ObfuscationAttribute]
private string delimiter;
    [ObfuscationAttribute]
private DelimitedSpatialColumnsType spatialColumnType;
    [ObfuscationAttribute]
private DelimitedColumnHeaderType columnHeaderType;
    [ObfuscationAttribute]
private Encoding encoding;
    [ObfuscationAttribute]
private bool requireIndex;
    private RtreeSpatialIndex XiE=;
    private String[] XyE=;
    private string YCE=;
    public string DelimitedPathFilename { get; public set; }
    public string XColumnName { get; public set; }
    public string YColumnName { get; public set; }
    public string WellKnownTextColumnName { get; public set; }
    internal int UyE= { get; internal set; }
    internal int ViE= { get; internal set; }
    internal int WSE= { get; internal set; }
    public string Delimiter { get; public set; }
    public DelimitedSpatialColumnsType SpatialColumnType { get; public set; }
    internal DelimitedColumnHeaderType XCE= { get; internal set; }
    public Encoding Encoding { get; public set; }
    public bool RequireIndex { get; public set; }
    public bool IsEditable { get; }
    public DelimitedFeatureSource(string delimitedPathFilename, string xColumnName, string yColumnName, string delimiter);
    public DelimitedFeatureSource(string delimitedPathFilename, string wellKnownTextColumnName, string delimiter);
    internal DelimitedFeatureSource(string delimitedPathFilename, int xColumnPosition, int yColumnPosition, string delimiter);
    internal DelimitedFeatureSource(string delimitedPathFilename, int wellKnownTextColumnPosition, string delimiter);
    private DelimitedFeatureSource(string delimitedPathFilename, string delimiter);
    private static DelimitedFeatureSource();
    [CompilerGeneratedAttribute]
public static void add_BuildingIndex(EventHandler`1<BuildingIndexDelimitedFeatureSourceEventArgs> value);
    [CompilerGeneratedAttribute]
public static void remove_BuildingIndex(EventHandler`1<BuildingIndexDelimitedFeatureSourceEventArgs> value);
    public string get_DelimitedPathFilename();
    public void set_DelimitedPathFilename(string value);
    public string get_XColumnName();
    public void set_XColumnName(string value);
    public string get_YColumnName();
    public void set_YColumnName(string value);
    public string get_WellKnownTextColumnName();
    public void set_WellKnownTextColumnName(string value);
    internal int USE=();
    internal void UiE=(int value);
    internal int VCE=();
    internal void VSE=(int value);
    internal int VyE=();
    internal void WCE=(int value);
    public string get_Delimiter();
    public void set_Delimiter(string value);
    public DelimitedSpatialColumnsType get_SpatialColumnType();
    public void set_SpatialColumnType(DelimitedSpatialColumnsType value);
    internal DelimitedColumnHeaderType WiE=();
    internal void WyE=(DelimitedColumnHeaderType value);
    public Encoding get_Encoding();
    public void set_Encoding(Encoding value);
    public bool get_RequireIndex();
    public void set_RequireIndex(bool value);
    protected virtual void OpenCore();
    public virtual bool get_IsEditable();
    protected virtual bool CanGetCountQuicklyCore();
    protected virtual void CloseCore();
    protected virtual long GetCountCore();
    protected virtual RectangleShape GetBoundingBoxCore();
    protected virtual Collection`1<FeatureSourceColumn> GetColumnsCore();
    protected virtual Collection`1<Feature> GetFeaturesByIdsCore(IEnumerable`1<string> ids, IEnumerable`1<string> returningColumnNames);
    protected virtual Collection`1<string> GetFeatureIdsCore();
    protected virtual Collection`1<Feature> GetAllFeaturesCore(IEnumerable`1<string> returningColumnNames, int startIndex, int takeCount);
    protected virtual Collection`1<Feature> GetAllFeaturesCore(IEnumerable`1<string> returningColumnNames);
    protected virtual Collection`1<Feature> GetFeaturesInsideBoundingBoxCore(RectangleShape boundingBox, IEnumerable`1<string> returningColumnNames);
    protected virtual TransactionResult CommitTransactionCore(TransactionBuffer transactions);
    private void YSE=(Collection`1<string> deleteColumns);
    private void YiE=(List`1<string> addedColumns);
    private void YyE=(Dictionary`2<string, FeatureSourceColumn> updateColumns);
    private void ZCE=();
    private void ZSE=(Dictionary`2<string, Feature> addBuffer, String[] columnNames, TransactionResult transactionResult);
    private void HR8=(Collection`1<string> deleteBuffer, TransactionResult transactionResult);
    private void ZiE=(Dictionary`2<string, Feature> keyValue, String[] columnNames, TransactionResult transactionResult);
    private string ZyE=(Feature feature, String[] columnNames);
    private Feature aCE=(string id, ESE= csvDataRecord);
    private static Feature aCE=(string id, ESE= csvDataRecord, DelimitedSpatialColumnsType spatialColumnType, string xColumnName, string yColumnName, string wellKnownTextColumnName);
    public static void BuildIndexFile(string delimitedPathFilename, string xColumnName, string yColumnName, string delimiter, BuildIndexMode buildIndexMode);
    public static void BuildIndexFile(string delimitedPathFilename, string wellKnownTextColumnName, string delimiter, BuildIndexMode buildIndexMode);
    public static void BuildIndexFile(string delimitedPathFilename, string xColumnName, string yColumnName, string delimiter, BuildIndexMode buildIndexMode, Encoding encoding);
    public static void BuildIndexFile(string delimitedPathFilename, string wellKnownTextColumnName, string delimiter, BuildIndexMode buildIndexMode, Encoding encoding);
    private static void aSE=(string delimitedPathFilename, string xColumnName, string yColumnName, string wellKnownTextColumnName, string delimiter, DelimitedSpatialColumnsType spatialColumnType, BuildIndexMode buildIndexMode, Encoding encoding);
    public static void CreateDelimitedFile(string delimitedPathFilename, IEnumerable`1<string> columnNames, string delimiter, OverwriteMode overwriteMode);
    public static void CreateDelimitedFile(string delimitedPathFilename, IEnumerable`1<string> columnNames, string delimiter, OverwriteMode overwriteMode, Encoding encoding);
    protected static void OnBuildingIndex(BuildingIndexDelimitedFeatureSourceEventArgs e);
    private void aiE=();
    private 6iA= ayE=();
    private static 6iA= ayE=(string delimitedPathFilename, string delimiter, Encoding encoding);
}
public enum ThinkGeo.Core.DelimitedSpatialColumnsType : Enum {
    public int value__;
    public static DelimitedSpatialColumnsType XAndY;
    public static DelimitedSpatialColumnsType WellKnownText;
}
public enum ThinkGeo.Core.DistanceCalculationMode : Enum {
    public int value__;
    public static DistanceCalculationMode Default;
    public static DistanceCalculationMode LocalizedUtmZone;
    public static DistanceCalculationMode Haversine;
}
public enum ThinkGeo.Core.DistanceUnit : Enum {
    public int value__;
    public static DistanceUnit Meter;
    public static DistanceUnit Feet;
    public static DistanceUnit Kilometer;
    public static DistanceUnit Mile;
    public static DistanceUnit UsSurveyFeet;
    public static DistanceUnit Yard;
    public static DistanceUnit NauticalMile;
    public static DistanceUnit Inch;
    public static DistanceUnit Link;
    public static DistanceUnit Chain;
    public static DistanceUnit Pole;
    public static DistanceUnit Rod;
    public static DistanceUnit Furlong;
    public static DistanceUnit Vara;
    public static DistanceUnit Arpent;
}
public class ThinkGeo.Core.DistinctColumnValue : object {
    [ObfuscationAttribute]
private string columnValue;
    [ObfuscationAttribute]
private int columnValueCount;
    public string ColumnValue { get; public set; }
    public int ColumnValueCount { get; public set; }
    public DistinctColumnValue(string columnValue, int columnValueCount);
    public string get_ColumnValue();
    public void set_ColumnValue(string value);
    public int get_ColumnValueCount();
    public void set_ColumnValueCount(int value);
}
public class ThinkGeo.Core.DotDensityStyle : Style {
    private static int 2Sk=;
    private static int RjE=;
    [ObfuscationAttribute]
private string columnName;
    [ObfuscationAttribute]
private PointStyle customPointStyle;
    [ObfuscationAttribute]
private PointStyle defaultPointStyle;
    private Dictionary`2<string, Collection`1<Vertex>> RzE=;
    [ObfuscationAttribute]
private double pointToValueRatio;
    public PointStyle CustomPointStyle { get; public set; }
    public string ColumnName { get; public set; }
    public int PointSize { get; public set; }
    public GeoColor PointColor { get; public set; }
    public double PointToValueRatio { get; public set; }
    public Dictionary`2<string, Collection`1<Vertex>> CachedPoints { get; }
    public DotDensityStyle(string columnName, double pointToValueRatio, int pointSize, GeoColor pointColor);
    public DotDensityStyle(string columnName, double pointToValueRatio, PointStyle customPointStyle);
    private DotDensityStyle(string columnName, double pointToValueRatio, int pointSize, GeoColor pointColor, PointStyle customPointStyle);
    public PointStyle get_CustomPointStyle();
    public void set_CustomPointStyle(PointStyle value);
    public string get_ColumnName();
    public void set_ColumnName(string value);
    public int get_PointSize();
    public void set_PointSize(int value);
    public GeoColor get_PointColor();
    public void set_PointColor(GeoColor value);
    public double get_PointToValueRatio();
    public void set_PointToValueRatio(double value);
    public Dictionary`2<string, Collection`1<Vertex>> get_CachedPoints();
    protected virtual Collection`1<string> GetRequiredColumnNamesCore();
    protected virtual void DrawCore(IEnumerable`1<Feature> features, GeoCanvas canvas, Collection`1<SimpleCandidate> labelsInThisLayer, Collection`1<SimpleCandidate> labelsInAllLayers);
    private void uDA=(double worldX, double worldY, GeoCanvas canvas, Dictionary`2<string, string> columnValues, Collection`1<SimpleCandidate> labelsInThisLayer, Collection`1<SimpleCandidate> labelsInAllLayers);
    private static Collection`1<Vertex> SDE=(Feature feature, GeoCanvas canvas, int count);
    private static double STE=(double min, double max, double initValue, Random random);
    private static void SjE=(PolygonShape polygon, GeoCanvas canvas, Collection`1<Vertex> resultDots, int count);
    private static PolygonShape SzE=(PolygonShape polygon, GeoCanvas canvas);
    private static void QR0=(Byte[] sourceArray, Byte[] destinateArray, long destinateIndex);
    private static bool IjE=(PolygonShape polygon, double pointX, double pointY, RectangleShape boundingBox);
    private static void IzE=(Collection`1<Vertex> crossingPoints, RingShape ringShape, double pointX, double pointY, double secondLineEndPointX);
    private static Vertex JDE=(Vertex startPoint, Vertex endPoint, double secondLineStartX, double secondLineStartY, double secondLineEndPointX);
    private static bool JTE=(Collection`1<Vertex> crossingPoints, Vertex vertex);
    private static bool sjA=(double value, double start, double end);
    private static bool JjE=(Vertex vertex);
}
public class ThinkGeo.Core.DrawingAdornmentLayerEventArgs : EventArgs {
    [ObfuscationAttribute]
private AdornmentLayer adornmentLayer;
    public AdornmentLayer AdornmentLayer { get; public set; }
    public DrawingAdornmentLayerEventArgs(AdornmentLayer adornmentLayer);
    public AdornmentLayer get_AdornmentLayer();
    public void set_AdornmentLayer(AdornmentLayer value);
}
public class ThinkGeo.Core.DrawingAdornmentLayersEventArgs : EventArgs {
    [ObfuscationAttribute]
private IEnumerable`1<AdornmentLayer> adornmentLayers;
    public IEnumerable`1<AdornmentLayer> AdornmentLayers { get; public set; }
    public DrawingAdornmentLayersEventArgs(IEnumerable`1<AdornmentLayer> adornmentLayers);
    public IEnumerable`1<AdornmentLayer> get_AdornmentLayers();
    public void set_AdornmentLayers(IEnumerable`1<AdornmentLayer> value);
}
[ObsoleteAttribute("Layer.Attribution (as well as Drawing Attribution) is deprecate and will be removed after v14.2. You can accomplish the similar feature by overriding layer.DrawCore/Layer.DrawAsyncCore method")]
public class ThinkGeo.Core.DrawingAttributionLayerEventArgs : EventArgs {
    [ObfuscationAttribute]
private string attribution;
    [ObfuscationAttribute]
private GeoCanvas geoCanvas;
    [ObfuscationAttribute]
private bool cancel;
    public bool Cancel { get; public set; }
    public GeoCanvas GeoCanvas { get; public set; }
    public string Attribution { get; public set; }
    public DrawingAttributionLayerEventArgs(GeoCanvas canvas, string attribution);
    public bool get_Cancel();
    public void set_Cancel(bool value);
    public GeoCanvas get_GeoCanvas();
    public void set_GeoCanvas(GeoCanvas value);
    public string get_Attribution();
    public void set_Attribution(string value);
}
public class ThinkGeo.Core.DrawingClusteredFeatureClusterPointStyleEventArgs : EventArgs {
    [ObfuscationAttribute]
private bool cancel;
    [ObfuscationAttribute]
private Feature clusteredFeature;
    [ObfuscationAttribute]
private Collection`1<Feature> clusteringFeatures;
    [ObfuscationAttribute]
private Collection`1<Style> styles;
    public bool Cancel { get; public set; }
    public Feature ClusteredFeature { get; public set; }
    public Collection`1<Feature> ClusteringFeatures { get; }
    public Collection`1<Style> Styles { get; }
    public DrawingClusteredFeatureClusterPointStyleEventArgs(Feature clusteredFeature, IEnumerable`1<Feature> clusteringFeatures, IEnumerable`1<Style> styles);
    public bool get_Cancel();
    public void set_Cancel(bool value);
    public Feature get_ClusteredFeature();
    public void set_ClusteredFeature(Feature value);
    public Collection`1<Feature> get_ClusteringFeatures();
    public Collection`1<Style> get_Styles();
}
public class ThinkGeo.Core.DrawingDirectionPointEventArgs : EventArgs {
    private Feature kTA=;
    private PointShape kjA=;
    private float kzA=;
    private float lDA=;
    private bool lTA=;
    public PointShape DirectionPoint { get; public set; }
    public Feature LineFeature { get; }
    public float SymbolSize { get; public set; }
    public float RotationAngle { get; public set; }
    public bool Cancel { get; public set; }
    public DrawingDirectionPointEventArgs(Feature lineFeature, PointShape directionPoint, float symbolSize, float rotationAngle);
    public PointShape get_DirectionPoint();
    public void set_DirectionPoint(PointShape value);
    public Feature get_LineFeature();
    public float get_SymbolSize();
    public void set_SymbolSize(float value);
    public float get_RotationAngle();
    public void set_RotationAngle(float value);
    public bool get_Cancel();
    public void set_Cancel(bool value);
}
public class ThinkGeo.Core.DrawingExceptionLayerEventArgs : EventArgs {
    [ObfuscationAttribute]
private Exception exception;
    [ObfuscationAttribute]
private GeoCanvas canvas;
    [ObfuscationAttribute]
private bool cancel;
    public Exception Exception { get; public set; }
    public GeoCanvas Canvas { get; public set; }
    public bool Cancel { get; public set; }
    public DrawingExceptionLayerEventArgs(GeoCanvas canvas, Exception exception, bool cancel);
    public Exception get_Exception();
    public void set_Exception(Exception value);
    public GeoCanvas get_Canvas();
    public void set_Canvas(GeoCanvas value);
    public bool get_Cancel();
    public void set_Cancel(bool value);
}
public enum ThinkGeo.Core.DrawingExceptionMode : Enum {
    public int value__;
    public static DrawingExceptionMode Default;
    public static DrawingExceptionMode ThrowException;
    public static DrawingExceptionMode DrawException;
}
public class ThinkGeo.Core.DrawingFeaturesEventArgs : EventArgs {
    [ObfuscationAttribute]
private Collection`1<Feature> featuresToDraw;
    [ObfuscationAttribute]
private ZoomLevel drawingZoomLevel;
    [ObfuscationAttribute]
private bool cancel;
    public Collection`1<Feature> FeaturesToDraw { get; }
    public ZoomLevel DrawingZoomLevel { get; public set; }
    public bool Cancel { get; public set; }
    public DrawingFeaturesEventArgs(IEnumerable`1<Feature> featuresToDraw);
    public DrawingFeaturesEventArgs(IEnumerable`1<Feature> featuresToDraw, ZoomLevel drawingZoomLevel);
    public Collection`1<Feature> get_FeaturesToDraw();
    public ZoomLevel get_DrawingZoomLevel();
    public void set_DrawingZoomLevel(ZoomLevel value);
    public bool get_Cancel();
    public void set_Cancel(bool value);
}
[FlagsAttribute]
public enum ThinkGeo.Core.DrawingFontStyles : Enum {
    public int value__;
    public static DrawingFontStyles Regular;
    public static DrawingFontStyles Bold;
    public static DrawingFontStyles Italic;
    public static DrawingFontStyles Underline;
    public static DrawingFontStyles Strikeout;
    public static DrawingFontStyles Black;
}
public enum ThinkGeo.Core.DrawingGraphicsUnit : Enum {
    public int value__;
    public static DrawingGraphicsUnit World;
    public static DrawingGraphicsUnit Display;
    public static DrawingGraphicsUnit Pixel;
    public static DrawingGraphicsUnit Point;
    public static DrawingGraphicsUnit Inch;
    public static DrawingGraphicsUnit Document;
    public static DrawingGraphicsUnit Millimeter;
}
public enum ThinkGeo.Core.DrawingLevel : Enum {
    public int value__;
    public static DrawingLevel LevelOne;
    public static DrawingLevel LevelTwo;
    public static DrawingLevel LevelThree;
    public static DrawingLevel LevelFour;
    public static DrawingLevel LabelLevel;
}
public enum ThinkGeo.Core.DrawingLineCap : Enum {
    public int value__;
    public static DrawingLineCap Round;
    public static DrawingLineCap AnchorMask;
    public static DrawingLineCap ArrowAnchor;
    public static DrawingLineCap Custom;
    public static DrawingLineCap DiamondAnchor;
    public static DrawingLineCap Flat;
    public static DrawingLineCap NoAnchor;
    public static DrawingLineCap RoundAnchor;
    public static DrawingLineCap Square;
    public static DrawingLineCap SquareAnchor;
    public static DrawingLineCap Triangle;
    public static DrawingLineCap Butt;
}
public enum ThinkGeo.Core.DrawingLineJoin : Enum {
    public int value__;
    public static DrawingLineJoin Bevel;
    public static DrawingLineJoin Miter;
    public static DrawingLineJoin MiterClipped;
    public static DrawingLineJoin Round;
}
public class ThinkGeo.Core.DrawingMargin : ValueType {
    [CompilerGeneratedAttribute]
private int ljA=;
    [CompilerGeneratedAttribute]
private int lzA=;
    [CompilerGeneratedAttribute]
private int mDA=;
    [CompilerGeneratedAttribute]
private int mTA=;
    public int Top { get; public set; }
    public int Right { get; public set; }
    public int Down { get; public set; }
    public int Left { get; public set; }
    public DrawingMargin(int top, int right, int down, int left);
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public int get_Top();
    [CompilerGeneratedAttribute]
public void set_Top(int value);
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public int get_Right();
    [CompilerGeneratedAttribute]
public void set_Right(int value);
    [CompilerGeneratedAttribute]
[IsReadOnlyAttribute]
public int get_Down();
    [CompilerGeneratedAttribute]
public void set_Down(int value);
    [CompilerGeneratedAttribute]
[IsReadOnlyAttribute]
public int get_Left();
    [CompilerGeneratedAttribute]
public void set_Left(int value);
}
public enum ThinkGeo.Core.DrawingPenAlignment : Enum {
    public int value__;
    public static DrawingPenAlignment Center;
    public static DrawingPenAlignment Inset;
    public static DrawingPenAlignment Left;
    public static DrawingPenAlignment Outset;
    public static DrawingPenAlignment Right;
}
public class ThinkGeo.Core.DrawingProgressChangedEventArgs : ProgressChangedEventArgs {
    [ObfuscationAttribute]
private bool cancel;
    [ObfuscationAttribute]
private int featuresToDraw;
    [ObfuscationAttribute]
private int featuresDrawn;
    public bool Cancel { get; public set; }
    public int FeaturesToDraw { get; }
    public int FeaturesDrawn { get; }
    public DrawingProgressChangedEventArgs(int progressPercentage, object userState);
    public DrawingProgressChangedEventArgs(int progressPercentage, object userState, int featuresToDraw, int featuresDrawn);
    public bool get_Cancel();
    public void set_Cancel(bool value);
    public int get_FeaturesToDraw();
    public int get_FeaturesDrawn();
}
public enum ThinkGeo.Core.DrawingQuality : Enum {
    public int value__;
    public static DrawingQuality Default;
    public static DrawingQuality HighQuality;
    public static DrawingQuality HighSpeed;
    public static DrawingQuality Medium;
}
public class ThinkGeo.Core.DrawingRectangle : ValueType {
    [ObfuscationAttribute]
private int centerX;
    [ObfuscationAttribute]
private int centerY;
    [ObfuscationAttribute]
private int width;
    [ObfuscationAttribute]
private int height;
    public int CenterX { get; }
    public int CenterY { get; }
    public int Width { get; }
    public int Height { get; }
    public int MinimumX { get; }
    public int MinimumY { get; }
    public int MaximumX { get; }
    public int MaximumY { get; }
    public DrawingRectangle(int centerX, int centerY, int width, int height);
    public DrawingRectangle(int anchorPointX, int anchorPointY, int width, int height, DrawingRectangleAnchorReference anchorReference);
    public int get_CenterX();
    public int get_CenterY();
    public int get_Width();
    public int get_Height();
    public int get_MinimumX();
    public int get_MinimumY();
    public int get_MaximumX();
    public int get_MaximumY();
    public static bool op_Equality(DrawingRectangle rectangleF1, DrawingRectangle rectangleF2);
    public static bool op_Inequality(DrawingRectangle rectangleF1, DrawingRectangle rectangleF2);
    public virtual bool Equals(object obj);
    private bool bRU=(DrawingRectangle obj);
    public virtual int GetHashCode();
}
public enum ThinkGeo.Core.DrawingRectangleAnchorReference : Enum {
    public int value__;
    public static DrawingRectangleAnchorReference Center;
    public static DrawingRectangleAnchorReference UpperLeft;
    public static DrawingRectangleAnchorReference UpperRight;
    public static DrawingRectangleAnchorReference LowerLeft;
    public static DrawingRectangleAnchorReference LowerRight;
}
public class ThinkGeo.Core.DrawingRectangleF : ValueType {
    [ObfuscationAttribute]
private float centerX;
    [ObfuscationAttribute]
private float centerY;
    [ObfuscationAttribute]
private float width;
    [ObfuscationAttribute]
private float height;
    public float CenterX { get; }
    public float CenterY { get; }
    public float Width { get; }
    public float Height { get; }
    public float MinimumX { get; }
    public float MinimumY { get; }
    public float MaximumX { get; }
    public float MaximumY { get; }
    public DrawingRectangleF(float centerX, float centerY, float width, float height);
    public DrawingRectangleF(float anchorPointX, float anchorPointY, float width, float height, DrawingRectangleAnchorReference anchorReference);
    public float get_CenterX();
    public float get_CenterY();
    public float get_Width();
    public float get_Height();
    public float get_MinimumX();
    public float get_MinimumY();
    public float get_MaximumX();
    public float get_MaximumY();
    public static bool op_Equality(DrawingRectangleF rectangleF1, DrawingRectangleF rectangleF2);
    public static bool op_Inequality(DrawingRectangleF rectangleF1, DrawingRectangleF rectangleF2);
    public virtual bool Equals(object obj);
    private bool bRU=(DrawingRectangleF obj);
    public virtual int GetHashCode();
}
public enum ThinkGeo.Core.DrawingTextAlignment : Enum {
    public int value__;
    public static DrawingTextAlignment Default;
    public static DrawingTextAlignment Left;
    public static DrawingTextAlignment Center;
    public static DrawingTextAlignment Right;
}
internal enum ThinkGeo.Core.DrawingTextBaseline : Enum {
    public int value__;
    public static DrawingTextBaseline Middle;
    public static DrawingTextBaseline Alphabetic;
    public static DrawingTextBaseline Top;
    public static DrawingTextBaseline Bottom;
    public static DrawingTextBaseline Hanging;
}
public enum ThinkGeo.Core.DrawingTextLetterCase : Enum {
    public int value__;
    public static DrawingTextLetterCase Default;
    public static DrawingTextLetterCase Uppercase;
    public static DrawingTextLetterCase Lowercase;
}
public class ThinkGeo.Core.DrawingWrappingFeaturesFeatureLayerEventArgs : EventArgs {
    [ObfuscationAttribute]
private Collection`1<Feature> featuresToDraw;
    public Collection`1<Feature> FeaturesToDraw { get; }
    public DrawingWrappingFeaturesFeatureLayerEventArgs(Collection`1<Feature> featuresToDraw);
    public Collection`1<Feature> get_FeaturesToDraw();
}
public class ThinkGeo.Core.DrawnAdornmentLayerEventArgs : EventArgs {
    [ObfuscationAttribute]
private AdornmentLayer adornmentLayer;
    public AdornmentLayer AdornmentLayer { get; public set; }
    public DrawnAdornmentLayerEventArgs(AdornmentLayer adornmentLayer);
    public AdornmentLayer get_AdornmentLayer();
    public void set_AdornmentLayer(AdornmentLayer value);
}
public class ThinkGeo.Core.DrawnAdornmentLayersEventArgs : EventArgs {
    [ObfuscationAttribute]
private IEnumerable`1<AdornmentLayer> adornmentLayers;
    public IEnumerable`1<AdornmentLayer> AdornmentLayers { get; public set; }
    public DrawnAdornmentLayersEventArgs(IEnumerable`1<AdornmentLayer> adornmentLayers);
    public IEnumerable`1<AdornmentLayer> get_AdornmentLayers();
    public void set_AdornmentLayers(IEnumerable`1<AdornmentLayer> value);
}
[ObsoleteAttribute("Layer.Attribution (as well as Drawing Attribution) is deprecate and will be removed after v14.2. You can accomplish the similar feature by overriding layer.DrawCore/Layer.DrawAsyncCore method")]
public class ThinkGeo.Core.DrawnAttributionLayerEventArgs : EventArgs {
    [ObfuscationAttribute]
private GeoCanvas geoCanvas;
    [ObfuscationAttribute]
private string attribution;
    public GeoCanvas GeoCanvas { get; public set; }
    [ObsoleteAttribute("Layer.Attribution (as well as Drawing Attribution) is deprecate and will be removed after v14.2. You can accomplish the similar feature by overriding layer.DrawCore/Layer.DrawAsyncCore method")]
public string Attribution { get; public set; }
    public DrawnAttributionLayerEventArgs(GeoCanvas canvas, string attribution);
    public GeoCanvas get_GeoCanvas();
    public void set_GeoCanvas(GeoCanvas value);
    public string get_Attribution();
    public void set_Attribution(string value);
}
public class ThinkGeo.Core.DrawnExceptionLayerEventArgs : EventArgs {
    [ObfuscationAttribute]
private Exception exception;
    [ObfuscationAttribute]
private GeoCanvas canvas;
    public Exception Exception { get; public set; }
    public GeoCanvas Canvas { get; public set; }
    public DrawnExceptionLayerEventArgs(GeoCanvas canvas, Exception exception);
    public Exception get_Exception();
    public void set_Exception(Exception value);
    public GeoCanvas get_Canvas();
    public void set_Canvas(GeoCanvas value);
}
public class ThinkGeo.Core.DynamicIsoLineLayer : IsoLineLayer {
    [ObfuscationAttribute]
private Dictionary`2<PointShape, double> dataPoints;
    [ObfuscationAttribute]
private GridInterpolationModel dynamicGridInterpolationModel;
    [ObfuscationAttribute]
private double noDataValue;
    [ObfuscationAttribute]
private int cellWidthInPixel;
    [ObfuscationAttribute]
private int cellHeightInPixel;
    public Dictionary`2<PointShape, double> DataPoints { get; }
    public double NoDataValue { get; public set; }
    public int CellWidthInPixel { get; public set; }
    public int CellHeightInPixel { get; public set; }
    public GridInterpolationModel DynamicGridInterpolationModel { get; public set; }
    public DynamicIsoLineLayer(IDictionary`2<PointShape, double> dataPoints);
    public DynamicIsoLineLayer(IDictionary`2<PointShape, double> dataPoints, IEnumerable`1<double> isoLineLevels);
    public DynamicIsoLineLayer(IDictionary`2<PointShape, double> dataPoints, IEnumerable`1<double> isoLineLevels, GridInterpolationModel gridInterpolationModel);
    public DynamicIsoLineLayer(IDictionary`2<PointShape, double> dataPoints, IEnumerable`1<double> isoLineLevels, GridInterpolationModel gridInterpolationModel, IsoLineType isoLineType);
    private DynamicIsoLineLayer(IDictionary`2<PointShape, double> dataPoints, IEnumerable`1<double> isoLineLevels, GridInterpolationModel gridInterpolationModel, double lowerScale, double upperScale, IsoLineType isoLineType);
    public Dictionary`2<PointShape, double> get_DataPoints();
    public double get_NoDataValue();
    public void set_NoDataValue(double value);
    public int get_CellWidthInPixel();
    public void set_CellWidthInPixel(int value);
    public int get_CellHeightInPixel();
    public void set_CellHeightInPixel(int value);
    public GridInterpolationModel get_DynamicGridInterpolationModel();
    public void set_DynamicGridInterpolationModel(GridInterpolationModel value);
    public Collection`1<Feature> GetIsoLineFeatures(RectangleShape worldExtent, double scale, GeographyUnit mapUnit);
    protected virtual Collection`1<Feature> GetFeaturesForDrawingCore(GeoCanvas canvas, Collection`1<SimpleCandidate> labelsInAllLayers);
    private static GridCell[0...,0...] SCI=(GridDefinition gridDefinition, GridInterpolationModel dynamicGridInterpolationModel, double scale, float cellWithInDot, float cellHeightInDot, GeographyUnit mapUnit);
}
public class ThinkGeo.Core.EditEndedEditInteractiveOverlayEventArgs : EventArgs {
    private Feature hhQ=;
    public Feature EditedFeature { get; public set; }
    public EditEndedEditInteractiveOverlayEventArgs(Feature editedFeature);
    public Feature get_EditedFeature();
    public void set_EditedFeature(Feature value);
}
public class ThinkGeo.Core.EditTools : object {
    [ObfuscationAttribute]
private FeatureSource featureSource;
    public bool IsInTransaction { get; }
    public bool IsTransactionLive { get; public set; }
    public bool IsEditable { get; }
    public TransactionBuffer TransactionBuffer { get; public set; }
    public EditTools(FeatureSource featureSource);
    public bool get_IsInTransaction();
    public bool get_IsTransactionLive();
    public void set_IsTransactionLive(bool value);
    public bool get_IsEditable();
    public TransactionBuffer get_TransactionBuffer();
    public void set_TransactionBuffer(TransactionBuffer value);
    public void BeginTransaction();
    public string Add(BaseShape shape);
    public string Add(Feature feature);
    public string Add(BaseShape shape, Dictionary`2<string, string> columnValues);
    public void ScaleUp(string featureId, double percentage);
    public void ScaleDown(string featureId, double percentage);
    public void TranslateByDegree(string featureId, double distance, double angleInDegrees, GeographyUnit shapeUnit, DistanceUnit distanceUnit);
    public void TranslateByOffset(string featureId, double xOffset, double yOffset, GeographyUnit shapeUnit, DistanceUnit offsetUnit);
    public void Rotate(string featureId, PointShape pivotPoint, float degreeAngle);
    public void Union(string featureId, AreaBaseShape targetShape);
    public void Union(string featureId, Feature targetAreaFeature);
    public void GetDifference(string featureId, AreaBaseShape targetShape);
    public void GetDifference(string featureId, Feature targetAreaFeature);
    public void Delete(string id);
    public void Update(BaseShape shape);
    public void Update(Feature feature);
    public void Update(BaseShape shape, Dictionary`2<string, string> columnValues);
    public void RollbackTransaction();
    public TransactionResult CommitTransaction();
}
public class ThinkGeo.Core.ElevationCloudClient : CloudClient {
    private static int pRQ=;
    public ElevationCloudClient(string clientId, string clientSecret);
    public double GetElevationOfPointInDecimalDegree(double latitude, double longitude, DistanceUnit elevationUnit);
    public double GetElevationOfPoint(double x, double y, int pointProjectionInSrid, DistanceUnit elevationUnit);
    public double GetElevationOfPoint(double x, double y, string pointProjectionInProj4String, DistanceUnit elevationUnit);
    [AsyncStateMachineAttribute("ThinkGeo.Core.ElevationCloudClient/<GetElevationOfPointInDecimalDegreeAsync>d__6")]
public Task`1<double> GetElevationOfPointInDecimalDegreeAsync(double latitude, double longitude, DistanceUnit elevationUnit);
    [AsyncStateMachineAttribute("ThinkGeo.Core.ElevationCloudClient/<GetElevationOfPointAsync>d__7")]
public Task`1<double> GetElevationOfPointAsync(double x, double y, int pointProjectionInSrid, DistanceUnit elevationUnit);
    [AsyncStateMachineAttribute("ThinkGeo.Core.ElevationCloudClient/<GetElevationOfPointAsync>d__8")]
public Task`1<double> GetElevationOfPointAsync(double x, double y, string pointProjectionInProj4String, DistanceUnit elevationUnit);
    public CloudElevationResult GetElevationOfPointsInDecimalDegree(IEnumerable`1<PointShape> points, DistanceUnit elevationUnit);
    public CloudElevationResult GetElevationOfPoints(IEnumerable`1<PointShape> points, int pointsProjectionInSrid, DistanceUnit elevationUnit);
    public CloudElevationResult GetElevationOfPoints(IEnumerable`1<PointShape> points, string pointsProjectionInProj4String, DistanceUnit elevationUnit);
    [AsyncStateMachineAttribute("ThinkGeo.Core.ElevationCloudClient/<GetElevationOfPointsInDecimalDegreeAsync>d__12")]
public Task`1<CloudElevationResult> GetElevationOfPointsInDecimalDegreeAsync(IEnumerable`1<PointShape> points, DistanceUnit elevationUnit);
    [AsyncStateMachineAttribute("ThinkGeo.Core.ElevationCloudClient/<GetElevationOfPointsAsync>d__13")]
public Task`1<CloudElevationResult> GetElevationOfPointsAsync(IEnumerable`1<PointShape> points, int pointsProjectionInSrid, DistanceUnit elevationUnit);
    [AsyncStateMachineAttribute("ThinkGeo.Core.ElevationCloudClient/<GetElevationOfPointsAsync>d__14")]
public Task`1<CloudElevationResult> GetElevationOfPointsAsync(IEnumerable`1<PointShape> points, string pointsProjectionInProj4String, DistanceUnit elevationUnit);
    public CloudElevationResult GetElevationOfLineInDecimalDegree(LineBaseShape line, int numberOfSegments, DistanceUnit elevationUnit);
    public CloudElevationResult GetElevationOfLine(LineBaseShape line, int lineProjectionInSrid, int numberOfSegments, DistanceUnit elevationUnit);
    public CloudElevationResult GetElevationOfLine(LineBaseShape line, string lineProjectionInProj4String, int numberOfSegments, DistanceUnit elevationUnit);
    public CloudElevationResult GetElevationOfLineInDecimalDegree(LineBaseShape line, double intervalDistance, DistanceUnit intervalDistanceUnit, DistanceUnit elevationUnit);
    public CloudElevationResult GetElevationOfLine(LineBaseShape line, int lineProjectionInSrid, double intervalDistance, DistanceUnit intervalDistanceUnit, DistanceUnit elevationUnit);
    public CloudElevationResult GetElevationOfLine(LineBaseShape line, string lineProjectionInProj4String, double intervalDistance, DistanceUnit intervalDistanceUnit, DistanceUnit elevationUnit);
    [AsyncStateMachineAttribute("ThinkGeo.Core.ElevationCloudClient/<GetElevationOfLineInDecimalDegreeAsync>d__21")]
public Task`1<CloudElevationResult> GetElevationOfLineInDecimalDegreeAsync(LineBaseShape line, int numberOfSegments, DistanceUnit elevationUnit);
    [AsyncStateMachineAttribute("ThinkGeo.Core.ElevationCloudClient/<GetElevationOfLineAsync>d__22")]
public Task`1<CloudElevationResult> GetElevationOfLineAsync(LineBaseShape line, int lineProjectionInSrid, int numberOfSegments, DistanceUnit elevationUnit);
    [AsyncStateMachineAttribute("ThinkGeo.Core.ElevationCloudClient/<GetElevationOfLineAsync>d__23")]
public Task`1<CloudElevationResult> GetElevationOfLineAsync(LineBaseShape line, string lineProjectionInProj4String, int numberOfSegments, DistanceUnit elevationUnit);
    [AsyncStateMachineAttribute("ThinkGeo.Core.ElevationCloudClient/<GetElevationOfLineInDecimalDegreeAsync>d__24")]
public Task`1<CloudElevationResult> GetElevationOfLineInDecimalDegreeAsync(LineBaseShape line, double intervalDistance, DistanceUnit intervalDistanceUnit, DistanceUnit elevationUnit);
    [AsyncStateMachineAttribute("ThinkGeo.Core.ElevationCloudClient/<GetElevationOfLineAsync>d__25")]
public Task`1<CloudElevationResult> GetElevationOfLineAsync(LineBaseShape line, int lineProjectionInSrid, double intervalDistance, DistanceUnit intervalDistanceUnit, DistanceUnit elevationUnit);
    [AsyncStateMachineAttribute("ThinkGeo.Core.ElevationCloudClient/<GetElevationOfLineAsync>d__26")]
public Task`1<CloudElevationResult> GetElevationOfLineAsync(LineBaseShape line, string lineProjectionInProj4String, double intervalDistance, DistanceUnit intervalDistanceUnit, DistanceUnit elevationUnit);
    public CloudGradeResult GetGradeOfLineInDecimalDegree(LineShape line, int numberOfSegments, DistanceUnit elevationUnit);
    public CloudGradeResult GetGradeOfLine(LineShape line, int lineProjectionInSrid, int numberOfSegments, DistanceUnit elevationUnit);
    public CloudGradeResult GetGradeOfLine(LineShape line, string lineProjectionInProj4String, int numberOfSegments, DistanceUnit elevationUnit);
    public CloudGradeResult GetGradeOfLineInDecimalDegree(LineShape line, double intervalDistance, DistanceUnit intervalDistanceUnit, DistanceUnit elevationUnit);
    public CloudGradeResult GetGradeOfLine(LineShape line, int lineProjectionInSrid, double intervalDistance, DistanceUnit intervalDistanceUnit, DistanceUnit elevationUnit);
    public CloudGradeResult GetGradeOfLine(LineShape line, string lineProjectionInProj4String, double intervalDistance, DistanceUnit intervalDistanceUnit, DistanceUnit elevationUnit);
    [AsyncStateMachineAttribute("ThinkGeo.Core.ElevationCloudClient/<GetGradeOfLineInDecimalDegreeAsync>d__33")]
public Task`1<CloudGradeResult> GetGradeOfLineInDecimalDegreeAsync(LineShape line, int numberOfSegments, DistanceUnit elevationUnit);
    [AsyncStateMachineAttribute("ThinkGeo.Core.ElevationCloudClient/<GetGradeOfLineAsync>d__34")]
public Task`1<CloudGradeResult> GetGradeOfLineAsync(LineShape line, int lineProjectionInSrid, double intervalDistance, DistanceUnit intervalDistanceUnit, DistanceUnit elevationUnit);
    [AsyncStateMachineAttribute("ThinkGeo.Core.ElevationCloudClient/<GetGradeOfLineAsync>d__35")]
public Task`1<CloudGradeResult> GetGradeOfLineAsync(LineShape line, string lineProjectionInProj4String, double intervalDistance, DistanceUnit intervalDistanceUnit, DistanceUnit elevationUnit);
    [AsyncStateMachineAttribute("ThinkGeo.Core.ElevationCloudClient/<GetGradeOfLineInDecimalDegreeAsync>d__36")]
public Task`1<CloudGradeResult> GetGradeOfLineInDecimalDegreeAsync(LineShape line, double intervalDistance, DistanceUnit intervalDistanceUnit, DistanceUnit elevationUnit);
    [AsyncStateMachineAttribute("ThinkGeo.Core.ElevationCloudClient/<GetGradeOfLineAsync>d__37")]
public Task`1<CloudGradeResult> GetGradeOfLineAsync(LineShape line, int lineProjectionInSrid, int numberOfSegments, DistanceUnit elevationUnit);
    [AsyncStateMachineAttribute("ThinkGeo.Core.ElevationCloudClient/<GetGradeOfLineAsync>d__38")]
public Task`1<CloudGradeResult> GetGradeOfLineAsync(LineShape line, string lineProjectionInProj4String, int numberOfSegments, DistanceUnit elevationUnit);
    public CloudElevationResult GetElevationOfAreaInDecimalDegree(AreaBaseShape area, double intervalDistance, DistanceUnit intervalDistanceUnit, DistanceUnit elevationUnit);
    public CloudElevationResult GetElevationOfArea(AreaBaseShape area, int areaProjectionInSrid, double intervalDistance, DistanceUnit intervalDistanceUnit, DistanceUnit elevationUnit);
    public CloudElevationResult GetElevationOfArea(AreaBaseShape area, string areaProjectionInProj4String, double intervalDistance, DistanceUnit intervalDistanceUnit, DistanceUnit elevationUnit);
    [AsyncStateMachineAttribute("ThinkGeo.Core.ElevationCloudClient/<GetElevationOfAreaInDecimalDegreeAsync>d__42")]
public Task`1<CloudElevationResult> GetElevationOfAreaInDecimalDegreeAsync(AreaBaseShape area, double intervalDistance, DistanceUnit intervalDistanceUnit, DistanceUnit elevationUnit);
    [AsyncStateMachineAttribute("ThinkGeo.Core.ElevationCloudClient/<GetElevationOfAreaAsync>d__43")]
public Task`1<CloudElevationResult> GetElevationOfAreaAsync(AreaBaseShape area, int areaProjectionInSrid, double intervalDistance, DistanceUnit intervalDistanceUnit, DistanceUnit elevationUnit);
    [AsyncStateMachineAttribute("ThinkGeo.Core.ElevationCloudClient/<GetElevationOfAreaAsync>d__44")]
public Task`1<CloudElevationResult> GetElevationOfAreaAsync(AreaBaseShape area, string areaProjectionInProj4String, double intervalDistance, DistanceUnit intervalDistanceUnit, DistanceUnit elevationUnit);
    private double phQ=(double x, double y, Nullable`1<int> projectionInSrid, string projectionInProj4String, DistanceUnit elevationUnit);
    [AsyncStateMachineAttribute("ThinkGeo.Core.ElevationCloudClient/<GetElevationOfPointAsync>d__46")]
private Task`1<double> pxQ=(double x, double y, Nullable`1<int> projectionInSrid, string projectionInProj4String, DistanceUnit elevationUnit);
    private CloudElevationResult qBQ=(IEnumerable`1<PointShape> points, Nullable`1<int> projectionInSrid, string projectionInProj4String, DistanceUnit elevationUnit);
    [AsyncStateMachineAttribute("ThinkGeo.Core.ElevationCloudClient/<GetElevationOfPointsAsync>d__48")]
private Task`1<CloudElevationResult> qRQ=(IEnumerable`1<PointShape> points, Nullable`1<int> projectionInSrid, string projectionInProj4String, DistanceUnit elevationUnit);
    private CloudElevationResult qhQ=(LineBaseShape line, Nullable`1<int> projectionInSrid, string projectionInProj4String, Nullable`1<int> numberOfSegments, Nullable`1<double> intervalDistance, Nullable`1<DistanceUnit> intervalDistanceUnit, DistanceUnit elevationUnit);
    [AsyncStateMachineAttribute("ThinkGeo.Core.ElevationCloudClient/<GetElevationOfLineAsync>d__50")]
private Task`1<CloudElevationResult> qxQ=(LineBaseShape line, Nullable`1<int> projectionInSrid, string projectionInProj4String, Nullable`1<int> numberOfSegments, Nullable`1<double> intervalDistance, Nullable`1<DistanceUnit> intervalDistanceUnit, DistanceUnit elevationUnit);
    private CloudGradeResult rBQ=(LineShape line, Nullable`1<int> projectionInSrid, string projectionInProj4String, Nullable`1<int> numberOfSegments, Nullable`1<double> intervalDistance, Nullable`1<DistanceUnit> intervalDistanceUnit, DistanceUnit elevationUnit);
    [AsyncStateMachineAttribute("ThinkGeo.Core.ElevationCloudClient/<GetGradeOfLineAsync>d__52")]
private Task`1<CloudGradeResult> rRQ=(LineShape line, Nullable`1<int> projectionInSrid, string projectionInProj4String, Nullable`1<int> numberOfSegments, Nullable`1<double> intervalDistance, Nullable`1<DistanceUnit> intervalDistanceUnit, DistanceUnit elevationUnit);
    private CloudElevationResult rhQ=(AreaBaseShape area, Nullable`1<int> projectionInSrid, string projectionInProj4String, double intervalDistance, DistanceUnit intervalDistanceUnit, DistanceUnit elevationUnit);
    [AsyncStateMachineAttribute("ThinkGeo.Core.ElevationCloudClient/<GetElevationOfAreaAsync>d__54")]
private Task`1<CloudElevationResult> rxQ=(AreaBaseShape area, Nullable`1<int> projectionInSrid, string projectionInProj4String, double intervalDistance, DistanceUnit intervalDistanceUnit, DistanceUnit elevationUnit);
    private static double sBQ=(WebResponse response);
    private static CloudElevationResult sRQ=(WebResponse response);
    private static CloudElevationResult shQ=(WebResponse response, IEnumerable`1<PointShape> queryPoints);
    private static CloudGradeResult sxQ=(WebResponse response);
    private static string tBQ=(string wkt, Nullable`1<int> projectionInSrid, string projectionInProj4String, Nullable`1<int> numberOfSegments, Nullable`1<double> intervalDistance, Nullable`1<DistanceUnit> intervalDistanceUnit, DistanceUnit elevationUnit);
}
[TypeConverterAttribute("ThinkGeo.Core.BaseShapeTypeConverter")]
public class ThinkGeo.Core.EllipseShape : AreaBaseShape {
    private static int 5xs=;
    [ObfuscationAttribute]
private PointShape center;
    [ObfuscationAttribute]
private double width;
    [ObfuscationAttribute]
private double height;
    public double Width { get; }
    public double Height { get; }
    public PointShape Center { get; public set; }
    public EllipseShape(PointShape center, double radius);
    public EllipseShape(Feature centerPointFeature, double radius);
    public EllipseShape(PointShape center, double horizontalRadius, double verticalRadius);
    public EllipseShape(Feature centerPointFeature, double horizontalRadius, double verticalRadius);
    public EllipseShape(string wellKnownText);
    public EllipseShape(Byte[] wellKnownBinary);
    public EllipseShape(PointShape center, double radius, GeographyUnit shapeUnit, DistanceUnit unitOfRadius);
    public EllipseShape(Feature centerPointFeature, double radius, GeographyUnit shapeUnit, DistanceUnit unitOfRadius);
    public EllipseShape(PointShape center, double horizontalRadius, double verticalRadius, GeographyUnit shapeUnit, DistanceUnit unitOfRadius);
    public EllipseShape(Feature centerPointFeature, double horizontalRadius, double verticalRadius, GeographyUnit shapeUnit, DistanceUnit unitOfRadius);
    protected virtual BaseShape CloneDeepCore();
    protected virtual WellKnownType GetWellKnownTypeCore();
    public double get_Width();
    public void SetWidthByUnit(double newWidth, GeographyUnit shapeUnit, DistanceUnit unitOfWidth);
    public double GetWidthByUnit(GeographyUnit shapeUnit, DistanceUnit returningUnit);
    public double get_Height();
    public void SetHeightByUnit(double newHeight, GeographyUnit shapeUnit, DistanceUnit unitOfHeight);
    public double GetHeightByUnit(GeographyUnit shapeUnit, DistanceUnit returningUnit);
    public PointShape get_Center();
    public void set_Center(PointShape value);
    public PolygonShape ToPolygon();
    public PolygonShape ToPolygon(int vertexCountInQuarter);
    public Collection`1<PointShape> GetTangents(EllipseShape targetEllipse);
    protected virtual double GetPerimeterCore(GeographyUnit shapeUnit, DistanceUnit returningUnit);
    protected virtual double GetAreaCore(GeographyUnit shapeUnit, AreaUnit returningUnit);
    protected virtual void ScaleUpCore(double percentage);
    protected virtual void ScaleDownCore(double percentage);
    protected virtual RectangleShape GetBoundingBoxCore();
    protected virtual BaseShape RegisterCore(PointShape fromPoint, PointShape toPoint, DistanceUnit fromUnit, GeographyUnit toUnit);
    protected virtual void TranslateByOffsetCore(double xOffsetDistance, double yOffsetDistance, GeographyUnit shapeUnit, DistanceUnit distanceUnit);
    protected virtual void TranslateByDegreeCore(double distance, double angleInDegrees, GeographyUnit shapeUnit, DistanceUnit distanceUnit);
    protected virtual void RotateCore(PointShape pivotPoint, double degreeAngle);
    protected virtual PointShape GetClosestPointToCore(BaseShape targetShape, GeographyUnit shapeUnit);
    protected virtual double GetDistanceToCore(BaseShape targetShape, GeographyUnit shapeUnit, DistanceUnit distanceUnit);
    protected string GetWellKnownTextCore(int vertexCountInQuarter);
    protected virtual string GetWellKnownTextCore(RingOrder outerRingOrder);
    protected string GetWellKnownTextCore(RingOrder outerRingOrder, int vertexCountInQuarter);
    protected Byte[] GetWellKnownBinaryCore(WkbByteOrder byteOrder, int vertexCountInQuarter);
    protected virtual Byte[] GetWellKnownBinaryCore(RingOrder outerRingOrder, WkbByteOrder byteOrder);
    protected Byte[] GetWellKnownBinaryCore(RingOrder outerRingOrder, WkbByteOrder byteOrder, int vertexCountInQuarter);
    protected virtual void LoadFromWellKnownDataCore(string wellKnownText);
    protected virtual void LoadFromWellKnownDataCore(Byte[] wellKnownBinary);
    protected virtual ShapeValidationResult ValidateCore(ShapeValidationMode validationMode);
    protected virtual bool ContainsCore(BaseShape targetShape);
    protected virtual bool IntersectsCore(BaseShape targetShape);
    protected virtual MultipointShape GetCrossingCore(BaseShape targetShape);
    private void 6Bs=(PointShape center, double newWidth, double newHeight, GeographyUnit shapeUnit, DistanceUnit unitOfSize);
    private PolygonShape 6Rs=(int quaterVertexCount);
    private void JBU=(double factor);
    private void 6hs=(PointShape targetPointShape, GeographyUnit shapeUnit, DistanceUnit distanceUnit, PointShape& closestPoint, Double& minDistance);
    private void 6xs=(MultipointShape targetMultiPoint, GeographyUnit shapeUnit, DistanceUnit distanceUnit, PointShape& closestPoint, Double& minDistance);
    private void 7Bs=(LineShape lineShape, GeographyUnit shapeUnit, DistanceUnit distanceUnit, PointShape& closestPoint, Double& minDistance);
    private void 7Rs=(MultilineShape multiLineShape, GeographyUnit shapeUnit, DistanceUnit distanceUnit, PointShape& closestPoint, Double& minDistance);
    private void 7hs=(PolygonShape polygonShape, GeographyUnit shapeUnit, DistanceUnit distanceUnit, PointShape& closestPoint, Double& minDistance);
    private PointShape 7xs=(MultipolygonShape multiPolygonShape, GeographyUnit shapeUnit, DistanceUnit distanceUnit, PointShape& closestPoint, Double& minDistance);
    private void 8Bs=(EllipseShape ellipseShape, GeographyUnit shapeUnit, DistanceUnit distanceUnit, PointShape& closestPoint, Double& minDistance);
    private bool 8Rs=(MultipointShape multiPointShape);
    private bool 8hs=(LineShape lineShape);
    private bool 8xs=(MultilineShape multiLineShape);
    private bool 9Bs=(RingShape ringShape);
    private bool 9Rs=(RectangleShape rectangleShape);
    private bool 9hs=(EllipseShape ellipseShape);
    private bool 9xs=(PolygonShape polygonShape);
    private bool /Bs=(MultipolygonShape multipolygonShape);
    private bool /Rs=(PointShape pointShape);
    private bool /hs=(MultipointShape multiPointShape);
    private bool /xs=(LineShape lineShape);
    private bool ABw=(MultilineShape multiLineShape);
    private bool ARw=(RingShape ringShape);
    private bool Ahw=(RectangleShape rectangleShape);
    private bool Axw=(EllipseShape ellipseShape);
    private bool BBw=(PolygonShape polygonShape);
    private bool BRw=(MultipolygonShape multipolygonShape);
    private Collection`1<PointShape> Bhw=(EllipseShape secondEllipse);
    private bool Bxw=(PointShape pointShape);
    private bool Bxw=(double pointX, double pointY);
    private static bool CBw=(double p, double b, double c);
    internal PointShape CRw=(PointShape pointShape);
}
public class ThinkGeo.Core.EmpiricalFunctionCoefficients : object {
    [ObfuscationAttribute]
private double range;
    [ObfuscationAttribute]
private double nugget;
    [ObfuscationAttribute]
private double sill;
    public double Range { get; public set; }
    public double Nugget { get; public set; }
    public double Sill { get; public set; }
    public EmpiricalFunctionCoefficients(double range, double sill, double nugget);
    public double get_Range();
    public void set_Range(double value);
    public double get_Nugget();
    public void set_Nugget(double value);
    public double get_Sill();
    public void set_Sill(double value);
}
public class ThinkGeo.Core.EncryptedFileRasterTileCache : FileRasterTileCache {
    public EncryptedFileRasterTileCache(string cacheDirectory);
    public EncryptedFileRasterTileCache(string cacheDirectory, string cacheId);
    protected virtual void SaveTileCore(Tile tile);
    protected virtual Tile GetTileCore(int zoom, long column, long row);
    private string hh0=(int zoom, long column, long row);
}
internal class ThinkGeo.Core.EnumInfo : object {
    public bool IsFlags;
    public UInt64[] Values;
    public String[] Names;
    public String[] ResolvedNames;
    public EnumInfo(bool isFlags, UInt64[] values, String[] names, String[] resolvedNames);
}
internal static class ThinkGeo.Core.EnumUtils : object {
    private static char EnumSeparatorChar;
    private static ThreadSafeStore`2<Type, EnumInfo> ValuesAndNamesPerEnum;
    private static EnumUtils();
    private static EnumInfo InitializeValuesAndNames(Type key);
    public static bool TryToString(Type enumType, object value, bool camelCase, String& name);
    private static ulong ToUInt64(object value);
    public static object ParseEnum(Type enumType, string value, bool disallowNumber);
    private static Nullable`1<int> MatchName(string value, String[] enumNames, String[] resolvedNames, int valueIndex, int valueSubstringLength, StringComparison comparison);
    private static Nullable`1<int> FindIndexByName(String[] enumNames, string value, int valueIndex, int valueSubstringLength, StringComparison comparison);
}
[ObfuscationAttribute]
internal static class ThinkGeo.Core.EventHelper : object {
    private static HyE= exceptionHelper;
    private static EventHelper();
    [DebuggerHiddenAttribute]
public static void Raise(EventHandler handler, object sender);
    [DebuggerHiddenAttribute]
public static void Raise(EventHandler`1<T> handler, object sender, T e);
    [DebuggerHiddenAttribute]
public static void Raise(EventHandler`1<T> handler, object sender, Func`1<T> createEventArguments);
    [DebuggerHiddenAttribute]
public static void Raise(Delegate handler, object sender, EventArgs e);
    [DebuggerHiddenAttribute]
public static void BeginRaise(EventHandler handler, object sender, AsyncCallback callback, object asyncState);
    [DebuggerHiddenAttribute]
public static void BeginRaise(EventHandler`1<T> handler, object sender, T e, AsyncCallback callback, object asyncState);
    [DebuggerHiddenAttribute]
public static void BeginRaise(EventHandler`1<T> handler, object sender, Func`1<T> createEventArguments, AsyncCallback callback, object asyncState);
    [DebuggerHiddenAttribute]
public static void BeginRaise(Delegate handler, object sender, EventArgs e, AsyncCallback callback, object asyncState);
}
public class ThinkGeo.Core.ExecutingSqlStatementSqliteFeatureSourceEventArgs : EventArgs {
    [ObfuscationAttribute]
private string sqlStatement;
    [ObfuscationAttribute]
private ExecutingSqlStatementType excutingStatementType;
    [ObfuscationAttribute]
private RectangleShape featureQueryingExtent;
    public string SqlStatement { get; public set; }
    public ExecutingSqlStatementType ExcutingSqlStatementType { get; public set; }
    public RectangleShape FeatureQueryingExtent { get; }
    public ExecutingSqlStatementSqliteFeatureSourceEventArgs(string sqlStatement);
    public ExecutingSqlStatementSqliteFeatureSourceEventArgs(string sqlStatement, ExecutingSqlStatementType sqlStatementType, RectangleShape featureQueryingExtent);
    public string get_SqlStatement();
    public void set_SqlStatement(string value);
    public ExecutingSqlStatementType get_ExcutingSqlStatementType();
    public void set_ExcutingSqlStatementType(ExecutingSqlStatementType value);
    public RectangleShape get_FeatureQueryingExtent();
}
public enum ThinkGeo.Core.ExecutingSqlStatementType : Enum {
    public int value__;
    public static ExecutingSqlStatementType GetFeaturesByIds;
    public static ExecutingSqlStatementType GetFeaturesByColumnValue;
    public static ExecutingSqlStatementType GetFeaturesOutsideBoundingBox;
    public static ExecutingSqlStatementType GetSpatialDataType;
    public static ExecutingSqlStatementType GetBoundingBox;
    public static ExecutingSqlStatementType GetAllFeatures;
    public static ExecutingSqlStatementType GetCount;
    public static ExecutingSqlStatementType GetColumns;
    public static ExecutingSqlStatementType BuildIndex;
    public static ExecutingSqlStatementType ExecuteScalar;
    public static ExecutingSqlStatementType ExecuteQuery;
    public static ExecutingSqlStatementType ExecuteNonQuery;
    public static ExecutingSqlStatementType GetFirstGeometryType;
    public static ExecutingSqlStatementType MakeAllGeometriesValid;
    public static ExecutingSqlStatementType Validate;
    public static ExecutingSqlStatementType CommitTransactionEx;
    public static ExecutingSqlStatementType GetFeaturesInsideBoundingBoxEx;
    public static ExecutingSqlStatementType Unknown;
    public static ExecutingSqlStatementType ExecuteSpatialQuery;
    public static ExecutingSqlStatementType GetFeatureIds;
    public static ExecutingSqlStatementType InsertFeature;
}
public class ThinkGeo.Core.ExponentialKrigingGridInterpolationModel : KrigingGridInterpolationModel {
    public ExponentialKrigingGridInterpolationModel(IDictionary`2<PointShape, double> points);
    public ExponentialKrigingGridInterpolationModel(IDictionary`2<PointShape, double> dataPoints, int numberOfRefrencedPoints);
    protected virtual double GetSillSlopeCore(double distance, double range);
}
[ExtensionAttribute]
public static class ThinkGeo.Core.Extension : object {
    [ExtensionAttribute]
public static string GetGeoJson(IEnumerable`1<Feature> features);
}
public class ThinkGeo.Core.Feature : object {
    private static int vRo=;
    private static string vho=;
    [ObfuscationAttribute]
private Byte[] wellKnownBinary;
    [ObfuscationAttribute]
private string id;
    [ObfuscationAttribute]
private object tag;
    [ObfuscationAttribute]
private Dictionary`2<string, string> columnValues;
    [ObfuscationAttribute]
private RectangleShape boundingBox;
    public string Id { get; public set; }
    public object Tag { get; public set; }
    public Dictionary`2<string, string> ColumnValues { get; }
    public Feature(BaseShape baseShape);
    public Feature(Byte[] wellKnownBinary);
    public Feature(Byte[] wellKnownBinary, string id);
    public Feature(string wellKnownText);
    public Feature(string wellKnownText, string id);
    public Feature(BaseShape baseShape, IDictionary`2<string, string> columnValues);
    public Feature(BaseShape baseShape, IEnumerable`1<string> columnValues);
    public Feature(string wellKnownText, string id, IDictionary`2<string, string> columnValues);
    public Feature(string wellKnownText, string id, IEnumerable`1<string> columnValues);
    public Feature(Byte[] wellKnownBinary, string id, IEnumerable`1<string> columnValues);
    private Feature(Byte[] wellKnownBinary, string id, IEnumerable`1<string> columnValues, object tag);
    public Feature(Byte[] wellKnownBinary, string id, IDictionary`2<string, string> columnValues);
    private Feature(Byte[] wellKnownBinary, string id, IDictionary`2<string, string> columnValues, object tag);
    public Feature(Vertex vertex);
    public Feature(Vertex vertex, string id);
    public Feature(Vertex vertex, string id, IEnumerable`1<string> columnValues);
    public Feature(Vertex vertex, string id, IDictionary`2<string, string> columnValues);
    public Feature(double x, double y);
    public Feature(double x, double y, string id);
    public Feature(double x, double y, string id, IEnumerable`1<string> columnValues);
    public Feature(double x, double y, string id, IDictionary`2<string, string> columnValues);
    public Byte[] GetWellKnownBinary();
    public Byte[] GetWellKnownBinary(WkbByteOrder byteOrder);
    public Byte[] GetWellKnownBinary(RingOrder outerRingOrder);
    public Byte[] GetWellKnownBinary(RingOrder outerRingOrder, WkbByteOrder byteOrder);
    protected virtual Byte[] GetWellKnownBinaryCore(RingOrder outerRingOrder, WkbByteOrder byteOrder);
    public string get_Id();
    public void set_Id(string value);
    public object get_Tag();
    public void set_Tag(object value);
    public Dictionary`2<string, string> get_ColumnValues();
    public virtual string ToString();
    public WellKnownType GetWellKnownType();
    protected virtual WellKnownType GetWellKnownTypeCore();
    public BaseShape GetShape();
    public string GetWellKnownText();
    public string GetWellKnownText(RingOrder outerRingOrder);
    protected virtual string GetWellKnownTextCore(RingOrder outerRingOrder);
    public string GetGeoJson();
    protected virtual string GetGeoJsonCore();
    public static Feature CreateFeatureFromGeoJson(string geoJson);
    public static Collection`1<Feature> CreateFeaturesFromGeoJson(string geoJson);
    public static Feature CreateFeatureFromWellKnownData(Byte[] wellKnownBinary);
    public static Feature CreateFeatureFromWellKnownData(string wellKnownText);
    public RectangleShape GetBoundingBox();
    protected virtual RectangleShape GetBoundingBoxCore();
    public Feature CloneDeep(IEnumerable`1<string> returningColumnNames);
    private Feature vxo=(IEnumerable`1<string> returningColumnNames);
    public Feature CloneDeep(ReturningColumnsType returningColumnNamesType);
    public Feature CloneDeep();
    public static Feature Union(IEnumerable`1<Feature> targetFeatures);
    private static Byte[] lBo=(IEnumerable`1<Feature> targetFeatures, int count);
    public Feature Union(Feature targetFeature);
    public Feature Buffer(double distance, GeographyUnit featureUnit, DistanceUnit distanceUnit);
    public Feature Buffer(double distance, int quadrantSegments, GeographyUnit featureUnit, DistanceUnit distanceUnit);
    public Feature Buffer(double distance, int quadrantSegments, BufferCapType bufferCapType, GeographyUnit featureUnit, DistanceUnit distanceUnit);
    private Byte[] oRo=(double distance, int quadrantSegments, BufferCapType bufferCapType);
    private static EndCapStyle oho=(BufferCapType bufferCapStyle);
    public bool Contains(Feature targetFeature);
    public bool Crosses(Feature targetFeature);
    public bool IsWithin(Feature targetFeature);
    public bool Intersects(Feature targetFeature);
    public bool IsDisjointed(Feature targetFeature);
    public bool IsTopologicallyEqual(Feature targetFeature);
    public bool Overlaps(Feature targetFeature);
    public bool Touches(Feature targetFeature);
    public Feature GetIntersection(Feature targetFeature);
    public Feature GetDifference(Feature targetFeature);
    public Feature GetConvexHull();
    public void SetWellKnownBinary(Byte[] wellKnownBinary);
    public string GetInvalidReason();
    public bool IsGeometryValid();
    protected virtual BaseShape GetShapeCore();
}
public class ThinkGeo.Core.FeatureCache : object {
    private Quadtree`1<string> Xh4=;
    [ObfuscationAttribute]
private Collection`1<RectangleShape> cachedExtents;
    [ObfuscationAttribute]
private Dictionary`2<string, Feature> cachedFeatures;
    [ObfuscationAttribute]
private bool isActive;
    public bool IsActive { get; public set; }
    public bool get_IsActive();
    public void set_IsActive(bool value);
    public Collection`1<Feature> GetFeatures(RectangleShape worldExtent);
    protected virtual Collection`1<Feature> GetFeaturesCore(RectangleShape worldExtent);
    public void Clear();
    public void Add(RectangleShape worldExtent, Collection`1<Feature> features);
    protected virtual void AddCore(RectangleShape worldExtent, Collection`1<Feature> features);
    public void Open();
    protected virtual void OpenCore();
    public void Close();
    protected virtual void CloseCore();
    public bool IsExtentCached(RectangleShape worldExtent);
    private static bool Xx4=(RectangleShape extent, RectangleShape targetExtent);
}
public class ThinkGeo.Core.FeatureDraggedEditInteractiveOverlayEventArgs : EventArgs {
    [ObfuscationAttribute]
private Feature draggedFeature;
    public Feature DraggedFeature { get; public set; }
    public FeatureDraggedEditInteractiveOverlayEventArgs(Feature draggedFeature);
    public Feature get_DraggedFeature();
    public void set_DraggedFeature(Feature value);
}
public class ThinkGeo.Core.FeatureDraggingEditInteractiveOverlayEventArgs : EventArgs {
    [ObfuscationAttribute]
private Feature draggingFeature;
    [ObfuscationAttribute]
private PointShape sourceControlPoint;
    [ObfuscationAttribute]
private PointShape targetControlPoint;
    [ObfuscationAttribute]
private bool cancel;
    public Feature DraggingFeature { get; public set; }
    public PointShape SourceControlPoint { get; public set; }
    public PointShape TargetControlPoint { get; public set; }
    public bool Cancel { get; public set; }
    public FeatureDraggingEditInteractiveOverlayEventArgs(Feature draggingFeature, bool cancel, PointShape sourceControlPoint, PointShape targetControlPoint);
    public Feature get_DraggingFeature();
    public void set_DraggingFeature(Feature value);
    public PointShape get_SourceControlPoint();
    public void set_SourceControlPoint(PointShape value);
    public PointShape get_TargetControlPoint();
    public void set_TargetControlPoint(PointShape value);
    public bool get_Cancel();
    public void set_Cancel(bool value);
}
public class ThinkGeo.Core.FeatureDroppedEditInteractiveOverlayEventArgs : EventArgs {
    [ObfuscationAttribute]
private Feature droppedFeature;
    public Feature DroppedFeature { get; public set; }
    public FeatureDroppedEditInteractiveOverlayEventArgs(Feature droppedFeature);
    public Feature get_DroppedFeature();
    public void set_DroppedFeature(Feature value);
}
public class ThinkGeo.Core.FeatureEditedEditInteractiveOverlayEventArgs : EventArgs {
    [ObfuscationAttribute]
private Feature editedFeature;
    [ObfuscationAttribute]
private Feature lastEditedFeature;
    public Feature EditedFeature { get; public set; }
    public Feature LastEditedFeature { get; }
    public FeatureEditedEditInteractiveOverlayEventArgs(Feature lastEditedFeature, Feature editedFeature);
    public Feature get_EditedFeature();
    public void set_EditedFeature(Feature value);
    public Feature get_LastEditedFeature();
}
public class ThinkGeo.Core.FeatureEditingEditInteractiveOverlayEventArgs : EventArgs {
    [ObfuscationAttribute]
private Feature editingFeature;
    public Feature EditingFeature { get; public set; }
    public FeatureEditingEditInteractiveOverlayEventArgs(Feature editingFeature);
    public Feature get_EditingFeature();
    public void set_EditingFeature(Feature value);
}
public class ThinkGeo.Core.FeatureLabelingCandidate : object {
    [ObfuscationAttribute]
private Feature feature;
    [ObfuscationAttribute]
private Collection`1<LabelingCandidate> labelingCandidates;
    [ObfuscationAttribute]
private LabelingCandidate basePointLabelingCandidate;
    [ObfuscationAttribute]
private string key;
    [ObfuscationAttribute]
private PositionStyle positionStyle;
    public Feature Feature { get; public set; }
    public Collection`1<LabelingCandidate> LabelingCandidates { get; public set; }
    public LabelingCandidate BasePointLabelingCandidate { get; public set; }
    public string Key { get; public set; }
    public PositionStyle PositionStyle { get; public set; }
    public Feature get_Feature();
    public void set_Feature(Feature value);
    public Collection`1<LabelingCandidate> get_LabelingCandidates();
    public void set_LabelingCandidates(Collection`1<LabelingCandidate> value);
    public LabelingCandidate get_BasePointLabelingCandidate();
    public void set_BasePointLabelingCandidate(LabelingCandidate value);
    public string get_Key();
    public void set_Key(string value);
    public PositionStyle get_PositionStyle();
    public void set_PositionStyle(PositionStyle value);
    public sealed virtual int CompareTo(FeatureLabelingCandidate other);
    public static void Sort(List`1<FeatureLabelingCandidate> featureLabelingCandidates, float canvasWidth, float canvasHeight);
    private static bool mjA=(double minX, double minY, double maxX, double maxY, float canvasWidth, float canvasHeight);
    private static bool mzA=(double minX, double minY, double maxX, double maxY, float canvasWidth, float canvasHeight);
    private static void nDA=(LabelingCandidate labelingCandidate, Double& minX, Double& minY, Double& maxX, Double& maxY);
}
public abstract class ThinkGeo.Core.FeatureLayer : Layer {
    [ObfuscationAttribute]
private float drawingMarginInPixel;
    [ObfuscationAttribute]
private EditTools editTools;
    [ObfuscationAttribute]
private QueryTools queryTools;
    [ObfuscationAttribute]
private FeatureSource featureSource;
    [ObfuscationAttribute]
private ZoomLevelSet zoomLevelSet;
    [ObfuscationAttribute]
private DrawingQuality drawingQuality;
    [CompilerGeneratedAttribute]
private EventHandler`1<DrawingFeaturesEventArgs> DrawingFeatures;
    [CompilerGeneratedAttribute]
private EventHandler`1<DrawingWrappingFeaturesFeatureLayerEventArgs> DrawingWrappingFeatures;
    public Projection Projection { get; }
    public EditTools EditTools { get; protected set; }
    public Collection`1<string> FeatureIdsToExclude { get; }
    public QueryTools QueryTools { get; protected set; }
    public int MaxRecordsToDraw { get; public set; }
    public FeatureSource FeatureSource { get; public set; }
    public DrawingQuality DrawingQuality { get; public set; }
    public ZoomLevelSet ZoomLevelSet { get; public set; }
    public float DrawingMarginInPixel { get; public set; }
    protected bool IsOpenCore { get; }
    [CompilerGeneratedAttribute]
public void add_DrawingFeatures(EventHandler`1<DrawingFeaturesEventArgs> value);
    [CompilerGeneratedAttribute]
public void remove_DrawingFeatures(EventHandler`1<DrawingFeaturesEventArgs> value);
    [CompilerGeneratedAttribute]
public void add_DrawingWrappingFeatures(EventHandler`1<DrawingWrappingFeaturesFeatureLayerEventArgs> value);
    [CompilerGeneratedAttribute]
public void remove_DrawingWrappingFeatures(EventHandler`1<DrawingWrappingFeaturesFeatureLayerEventArgs> value);
    protected virtual void OnDrawingFeatures(DrawingFeaturesEventArgs e);
    [ObsoleteAttribute("This API will be removed after V13.2. Please use OnDrawingFeatures instead. e.FeaturesToDraw in DrawingFeaturesEventArgs event includes the wrapping features. ")]
protected virtual void OnDrawingWrappingFeatures(DrawingWrappingFeaturesFeatureLayerEventArgs e);
    public virtual Projection get_Projection();
    public EditTools get_EditTools();
    protected void set_EditTools(EditTools value);
    public Collection`1<string> get_FeatureIdsToExclude();
    public QueryTools get_QueryTools();
    protected void set_QueryTools(QueryTools value);
    public int get_MaxRecordsToDraw();
    public void set_MaxRecordsToDraw(int value);
    public FeatureSource get_FeatureSource();
    public void set_FeatureSource(FeatureSource value);
    public DrawingQuality get_DrawingQuality();
    public void set_DrawingQuality(DrawingQuality value);
    public ZoomLevelSet get_ZoomLevelSet();
    public void set_ZoomLevelSet(ZoomLevelSet value);
    public float get_DrawingMarginInPixel();
    public void set_DrawingMarginInPixel(float value);
    protected virtual bool get_IsOpenCore();
    protected virtual void DrawCore(GeoCanvas canvas, Collection`1<SimpleCandidate> labelsInAllLayers);
    protected virtual bool IsDrawingNeededCore(double currentScale);
    protected void SetupTools();
    protected virtual void SetupToolsCore();
    protected virtual void OpenCore();
    protected virtual void CloseCore();
    protected virtual RectangleShape GetBoundingBoxCore();
    protected Collection`1<Feature> GetWrappingFeaturesForDrawing(RectangleShape drawingExtent, IEnumerable`1<string> returningColumnNames, RectangleShape wrappingExtent);
    private Collection`1<Feature> 5R8=(RectangleShape drawingWorldExtent, IEnumerable`1<string> returningColumnNames, RectangleShape wrappingWorldExtent, double minRatioX, double maxRatioX);
    public double GetCeiling(double d);
    private void 5h8=(object sender, DrawingProgressChangedEventArgs e);
}
public class ThinkGeo.Core.FeatureResizedEditInteractiveOverlayEventArgs : EventArgs {
    [ObfuscationAttribute]
private Feature resizedFeature;
    public Feature ResizedFeature { get; public set; }
    public FeatureResizedEditInteractiveOverlayEventArgs(Feature resizedFeature);
    public Feature get_ResizedFeature();
    public void set_ResizedFeature(Feature value);
}
public class ThinkGeo.Core.FeatureResizingEditInteractiveOverlayEventArgs : EventArgs {
    [ObfuscationAttribute]
private Feature resizingFeature;
    [ObfuscationAttribute]
private PointShape sourceControlPoint;
    [ObfuscationAttribute]
private PointShape targetControlPoint;
    [ObfuscationAttribute]
private bool cancel;
    public Feature ResizingFeature { get; public set; }
    public PointShape SourceControlPoint { get; public set; }
    public PointShape TargetControlPoint { get; public set; }
    public bool Cancel { get; public set; }
    public FeatureResizingEditInteractiveOverlayEventArgs(Feature resizingFeature, bool cancel, PointShape sourceControlPoint, PointShape targetControlPoint);
    public Feature get_ResizingFeature();
    public void set_ResizingFeature(Feature value);
    public PointShape get_SourceControlPoint();
    public void set_SourceControlPoint(PointShape value);
    public PointShape get_TargetControlPoint();
    public void set_TargetControlPoint(PointShape value);
    public bool get_Cancel();
    public void set_Cancel(bool value);
}
public class ThinkGeo.Core.FeatureRotatedEditInteractiveOverlayEventArgs : EventArgs {
    [ObfuscationAttribute]
private Feature rotatedFeature;
    public Feature RotatedFeature { get; public set; }
    public FeatureRotatedEditInteractiveOverlayEventArgs(Feature rotatedFeature);
    public Feature get_RotatedFeature();
    public void set_RotatedFeature(Feature value);
}
public class ThinkGeo.Core.FeatureRotatingEditInteractiveOverlayEventArgs : EventArgs {
    [ObfuscationAttribute]
private Feature rotatingFeature;
    [ObfuscationAttribute]
private PointShape sourceControlPoint;
    [ObfuscationAttribute]
private PointShape targetControlPoint;
    [ObfuscationAttribute]
private bool cancel;
    public Feature RotatingFeature { get; public set; }
    public PointShape SourceControlPoint { get; public set; }
    public PointShape TargetControlPoint { get; public set; }
    public bool Cancel { get; public set; }
    public FeatureRotatingEditInteractiveOverlayEventArgs(Feature rotatingFeature, bool cancel, PointShape sourceControlPoint, PointShape targetControlPoint);
    public Feature get_RotatingFeature();
    public void set_RotatingFeature(Feature value);
    public PointShape get_SourceControlPoint();
    public void set_SourceControlPoint(PointShape value);
    public PointShape get_TargetControlPoint();
    public void set_TargetControlPoint(PointShape value);
    public bool get_Cancel();
    public void set_Cancel(bool value);
}
public abstract class ThinkGeo.Core.FeatureSource : object {
    [ObfuscationAttribute]
private string id;
    [ObfuscationAttribute]
private static int maximumLoopCount;
    [ObfuscationAttribute]
private static int progressDrawingRaisingFrequency;
    [ObfuscationAttribute]
private int progressDrawingRaisedCount;
    private bool Zxo=;
    [ObfuscationAttribute]
private bool isInTransaction;
    [ObfuscationAttribute]
private bool isTransactionLive;
    [ObfuscationAttribute]
private TransactionBuffer transactionBuffer;
    [ObfuscationAttribute]
private Collection`1<FeatureSourceColumn> featureSourceColumns;
    [ObfuscationAttribute]
private Collection`1<string> featureIdsToExclude;
    [ObfuscationAttribute]
private ProjectionConverter projectionConverter;
    [ObfuscationAttribute]
private Projection projection;
    [ObfuscationAttribute]
private FeatureCache geoCache;
    [ObfuscationAttribute]
private int maxRecordsToDraw;
    [ObfuscationAttribute]
private bool canModifyColumnStructure;
    [CompilerGeneratedAttribute]
private EventHandler`1<DrawingProgressChangedEventArgs> DrawingProgressChanged;
    [CompilerGeneratedAttribute]
private EventHandler`1<GettingColumnsFeatureSourceEventArgs> GettingColumns;
    [CompilerGeneratedAttribute]
private EventHandler`1<GottenColumnsFeatureSourceEventArgs> GottenColumns;
    [CompilerGeneratedAttribute]
private EventHandler`1<GettingFeaturesByIdsFeatureSourceEventArgs> GettingFeaturesByIds;
    [CompilerGeneratedAttribute]
private EventHandler`1<GettingFeaturesForDrawingFeatureSourceEventArgs> GettingFeaturesForDrawing;
    [CompilerGeneratedAttribute]
private EventHandler`1<CustomColumnFetchEventArgs> CustomColumnFetch;
    [CompilerGeneratedAttribute]
private EventHandler`1<CommittingTransactionEventArgs> CommittingTransaction;
    [CompilerGeneratedAttribute]
private EventHandler`1<CommittedTransactionEventArgs> CommittedTransaction;
    [CompilerGeneratedAttribute]
private EventHandler`1<OpeningFeatureSourceEventArgs> OpeningFeatureSource;
    [CompilerGeneratedAttribute]
private EventHandler`1<OpenedFeatureSourceEventArgs> OpenedFeatureSource;
    [CompilerGeneratedAttribute]
private EventHandler`1<ClosingFeatureSourceEventArgs> ClosingFeatureSource;
    [CompilerGeneratedAttribute]
private EventHandler`1<ClosedFeatureSourceEventArgs> ClosedFeatureSource;
    public string Id { get; }
    public bool CanExecuteSqlQuery { get; }
    protected bool CanExecuteSqlQueryCore { get; }
    public bool IsOpen { get; }
    public Projection Projection { get; protected set; }
    protected bool IsOpenCore { get; protected set; }
    public bool CanModifyColumnStructure { get; }
    protected bool CanModifyColumnStructureCore { get; protected set; }
    protected Collection`1<FeatureSourceColumn> FeatureSourceColumns { get; }
    public bool IsInTransaction { get; }
    public bool IsTransactionLive { get; public set; }
    public bool IsEditable { get; }
    public ProjectionConverter ProjectionConverter { get; public set; }
    public FeatureCache GeoCache { get; public set; }
    public Collection`1<string> FeatureIdsToExclude { get; }
    public TransactionBuffer TransactionBuffer { get; public set; }
    public int MaxRecordsToDraw { get; public set; }
    [CompilerGeneratedAttribute]
public void add_DrawingProgressChanged(EventHandler`1<DrawingProgressChangedEventArgs> value);
    [CompilerGeneratedAttribute]
public void remove_DrawingProgressChanged(EventHandler`1<DrawingProgressChangedEventArgs> value);
    [CompilerGeneratedAttribute]
public void add_GettingColumns(EventHandler`1<GettingColumnsFeatureSourceEventArgs> value);
    [CompilerGeneratedAttribute]
public void remove_GettingColumns(EventHandler`1<GettingColumnsFeatureSourceEventArgs> value);
    [CompilerGeneratedAttribute]
public void add_GottenColumns(EventHandler`1<GottenColumnsFeatureSourceEventArgs> value);
    [CompilerGeneratedAttribute]
public void remove_GottenColumns(EventHandler`1<GottenColumnsFeatureSourceEventArgs> value);
    [CompilerGeneratedAttribute]
public void add_GettingFeaturesByIds(EventHandler`1<GettingFeaturesByIdsFeatureSourceEventArgs> value);
    [CompilerGeneratedAttribute]
public void remove_GettingFeaturesByIds(EventHandler`1<GettingFeaturesByIdsFeatureSourceEventArgs> value);
    [CompilerGeneratedAttribute]
public void add_GettingFeaturesForDrawing(EventHandler`1<GettingFeaturesForDrawingFeatureSourceEventArgs> value);
    [CompilerGeneratedAttribute]
public void remove_GettingFeaturesForDrawing(EventHandler`1<GettingFeaturesForDrawingFeatureSourceEventArgs> value);
    [CompilerGeneratedAttribute]
public void add_CustomColumnFetch(EventHandler`1<CustomColumnFetchEventArgs> value);
    [CompilerGeneratedAttribute]
public void remove_CustomColumnFetch(EventHandler`1<CustomColumnFetchEventArgs> value);
    [CompilerGeneratedAttribute]
public void add_CommittingTransaction(EventHandler`1<CommittingTransactionEventArgs> value);
    [CompilerGeneratedAttribute]
public void remove_CommittingTransaction(EventHandler`1<CommittingTransactionEventArgs> value);
    [CompilerGeneratedAttribute]
public void add_CommittedTransaction(EventHandler`1<CommittedTransactionEventArgs> value);
    [CompilerGeneratedAttribute]
public void remove_CommittedTransaction(EventHandler`1<CommittedTransactionEventArgs> value);
    [CompilerGeneratedAttribute]
public void add_OpeningFeatureSource(EventHandler`1<OpeningFeatureSourceEventArgs> value);
    [CompilerGeneratedAttribute]
public void remove_OpeningFeatureSource(EventHandler`1<OpeningFeatureSourceEventArgs> value);
    [CompilerGeneratedAttribute]
public void add_OpenedFeatureSource(EventHandler`1<OpenedFeatureSourceEventArgs> value);
    [CompilerGeneratedAttribute]
public void remove_OpenedFeatureSource(EventHandler`1<OpenedFeatureSourceEventArgs> value);
    [CompilerGeneratedAttribute]
public void add_ClosingFeatureSource(EventHandler`1<ClosingFeatureSourceEventArgs> value);
    [CompilerGeneratedAttribute]
public void remove_ClosingFeatureSource(EventHandler`1<ClosingFeatureSourceEventArgs> value);
    [CompilerGeneratedAttribute]
public void add_ClosedFeatureSource(EventHandler`1<ClosedFeatureSourceEventArgs> value);
    [CompilerGeneratedAttribute]
public void remove_ClosedFeatureSource(EventHandler`1<ClosedFeatureSourceEventArgs> value);
    protected virtual void OnGettingColumns(GettingColumnsFeatureSourceEventArgs e);
    protected virtual void OnGottenColumns(GottenColumnsFeatureSourceEventArgs e);
    protected virtual void OnCustomColumnFetch(CustomColumnFetchEventArgs e);
    protected virtual void OnCommittingTransaction(CommittingTransactionEventArgs e);
    protected virtual void OnCommittedTransaction(CommittedTransactionEventArgs e);
    protected virtual void OnOpeningFeatureSource(OpeningFeatureSourceEventArgs e);
    protected virtual void OnOpenedFeatureSource(OpenedFeatureSourceEventArgs e);
    protected virtual void OnClosingFeatureSource(ClosingFeatureSourceEventArgs e);
    protected virtual void OnClosedFeatureSource(ClosedFeatureSourceEventArgs e);
    protected virtual void OnGettingFeaturesByIds(GettingFeaturesByIdsFeatureSourceEventArgs e);
    protected virtual void OnGettingFeaturesForDrawing(GettingFeaturesForDrawingFeatureSourceEventArgs e);
    public string get_Id();
    public bool get_CanExecuteSqlQuery();
    protected virtual bool get_CanExecuteSqlQueryCore();
    public bool get_IsOpen();
    public Projection get_Projection();
    protected void set_Projection(Projection value);
    protected virtual bool get_IsOpenCore();
    protected virtual void set_IsOpenCore(bool value);
    public bool get_CanModifyColumnStructure();
    protected virtual bool get_CanModifyColumnStructureCore();
    protected virtual void set_CanModifyColumnStructureCore(bool value);
    protected Collection`1<FeatureSourceColumn> get_FeatureSourceColumns();
    public bool get_IsInTransaction();
    public bool get_IsTransactionLive();
    public void set_IsTransactionLive(bool value);
    public virtual bool get_IsEditable();
    public ProjectionConverter get_ProjectionConverter();
    public void set_ProjectionConverter(ProjectionConverter value);
    public FeatureCache get_GeoCache();
    public void set_GeoCache(FeatureCache value);
    public Collection`1<string> get_FeatureIdsToExclude();
    public TransactionBuffer get_TransactionBuffer();
    public void set_TransactionBuffer(TransactionBuffer value);
    public int get_MaxRecordsToDraw();
    public void set_MaxRecordsToDraw(int value);
    public int ExecuteNonQuery(string sqlStatement);
    protected virtual int ExecuteNonQueryCore(string sqlStatement);
    public Collection`1<Feature> GetFeaturesByColumnValue(string columnName, string columnValue, ReturningColumnsType returningColumnType);
    public Collection`1<Feature> GetFeaturesByColumnValue(string columnName, string columnValue, IEnumerable`1<string> returningColumnNames);
    private static Collection`1<Feature> QB4=(Collection`1<Feature> features, TransactionBuffer transactionBuffer, string columnName, string columnValue);
    public Collection`1<Feature> GetFeaturesByColumnValue(string columnName, string columnValue);
    protected virtual Collection`1<Feature> GetFeaturesByColumnValueCore(string columnName, string columnValue, IEnumerable`1<string> returningColumnNames);
    public object ExecuteScalar(string sqlStatement);
    protected virtual object ExecuteScalarCore(string sqlStatement);
    public DataTable ExecuteQuery(string sqlStatement);
    protected virtual DataTable ExecuteQueryCore(string sqlStatement);
    public Collection`1<FeatureSourceColumn> GetColumns();
    protected virtual Collection`1<FeatureSourceColumn> GetColumnsCore();
    public void RefreshColumns();
    public long GetCount();
    protected virtual long GetCountCore();
    public RectangleShape GetBoundingBox();
    protected virtual RectangleShape GetBoundingBoxCore();
    public FeatureSource CloneDeep();
    protected virtual FeatureSource CloneDeepCore();
    public void Open();
    protected virtual void OpenCore();
    public void Close();
    protected virtual void CloseCore();
    public void BeginTransaction();
    public string AddFeature(Feature feature);
    public string AddFeature(BaseShape shape);
    public string AddFeature(BaseShape shape, IDictionary`2<string, string> columnValues);
    public void DeleteFeature(string id);
    public void UpdateFeature(Feature feature);
    public void UpdateFeature(BaseShape shape);
    public void UpdateFeature(BaseShape shape, IDictionary`2<string, string> columnValues);
    public void RollbackTransaction();
    public TransactionResult CommitTransaction();
    protected virtual TransactionResult CommitTransactionCore(TransactionBuffer transactions);
    public void AddColumn(FeatureSourceColumn featureSourceColumn);
    public void DeleteColumn(string columnName);
    public void UpdateColumn(string columnName, FeatureSourceColumn newFeatureSourceColumn);
    public Collection`1<Feature> GetAllFeatures(IEnumerable`1<string> returningColumnNames);
    internal Collection`1<Feature> QR4=(Collection`1<Feature> sourceFeatures, Collection`1<string> fieldNamesOutsideOfSource);
    private Collection`1<Feature> QR4=(Collection`1<Feature> sourceFeatures, Collection`1<string> fieldNamesOutsideOfSource, bool forceRaiseEvent);
    private Collection`1<Feature> Qh4=(Collection`1<Feature> sourceFeatures);
    public Collection`1<Feature> GetAllFeatures(ReturningColumnsType returningColumnNamesType);
    public Collection`1<string> GetFeatureIds();
    protected virtual Collection`1<string> GetFeatureIdsCore();
    protected abstract virtual Collection`1<Feature> GetAllFeaturesCore(IEnumerable`1<string> returningColumnNames);
    public Collection`1<Feature> GetFeaturesOutsideBoundingBox(RectangleShape boundingBox, IEnumerable`1<string> returningColumnNames);
    public Collection`1<Feature> GetFeaturesOutsideBoundingBox(RectangleShape boundingBox, ReturningColumnsType returningColumnNamesType);
    protected virtual Collection`1<Feature> GetFeaturesOutsideBoundingBoxCore(RectangleShape boundingBox, IEnumerable`1<string> returningColumnNames);
    public Collection`1<Feature> GetFeaturesInsideBoundingBox(RectangleShape boundingBox, IEnumerable`1<string> returningColumnNames);
    public Collection`1<Feature> GetFeaturesInsideBoundingBox(RectangleShape boundingBox, ReturningColumnsType returningColumnNamesType);
    protected virtual Collection`1<Feature> GetFeaturesInsideBoundingBoxCore(RectangleShape boundingBox, IEnumerable`1<string> returningColumnNames);
    public Collection`1<string> GetFeatureIdsInsideBoundingBox(RectangleShape boundingBox);
    protected virtual Collection`1<string> GetFeatureIdsInsideBoundingBoxCore(RectangleShape boundingBox);
    public Collection`1<Feature> GetFeaturesForDrawing(RectangleShape boundingBox, double screenWidth, double screenHeight, IEnumerable`1<string> returningColumnNames);
    internal void Qx4=(RectangleShape boundingBox, Collection`1<Feature> returnFeatures, bool needUpdateProjection);
    private Feature cBo=(ProjectionConverter projection, Feature feature);
    public Collection`1<Feature> GetFeaturesForDrawing(RectangleShape boundingBox, double screenWidth, double screenHeight, ReturningColumnsType returningColumnNamesType);
    protected virtual Collection`1<Feature> GetFeaturesForDrawingCore(RectangleShape boundingBox, double screenWidth, double screenHeight, IEnumerable`1<string> returningColumnNames);
    public Collection`1<Feature> SpatialQuery(BaseShape targetShape, QueryType queryType, IEnumerable`1<string> returningColumnNames);
    public Collection`1<Feature> SpatialQuery(BaseShape targetShape, QueryType queryType, ReturningColumnsType returningColumnNamesType);
    public Collection`1<Feature> SpatialQuery(Feature feature, QueryType queryType, IEnumerable`1<string> returningColumnNames);
    public Collection`1<Feature> SpatialQuery(Feature feature, QueryType queryType, ReturningColumnsType returningColumnNamesType);
    protected virtual Collection`1<Feature> SpatialQueryCore(BaseShape targetShape, QueryType queryType, IEnumerable`1<string> returningColumnNames);
    private Collection`1<Feature> RB4=(BaseShape targetShape, IEnumerable`1<string> returningColumnNames);
    private Collection`1<Feature> RR4=(BaseShape targetShape, IEnumerable`1<string> returningColumnNames);
    private Collection`1<Feature> Rh4=(BaseShape targetShape, IEnumerable`1<string> returningColumnNames);
    private Collection`1<Feature> Rx4=(BaseShape targetShape, IEnumerable`1<string> returningColumnNames);
    private Collection`1<Feature> SB4=(BaseShape targetShape, IEnumerable`1<string> returningColumnNames);
    private Collection`1<Feature> SR4=(BaseShape targetShape, IEnumerable`1<string> returningColumnNames);
    private Collection`1<Feature> Sh4=(BaseShape targetShape, IEnumerable`1<string> returningColumnNames);
    private Collection`1<Feature> Sx4=(BaseShape targetShape, IEnumerable`1<string> returningColumnNames);
    private static bool TB4=(BaseShape targetShape, BaseShape sourceShape, QueryType queryType);
    public Collection`1<Feature> GetFeaturesNearestTo(BaseShape targetShape, GeographyUnit unitOfFeatureSource, int maxItemsToFind, IEnumerable`1<string> returningColumnNames);
    public Collection`1<Feature> GetFeaturesNearestTo(BaseShape targetShape, GeographyUnit unitOfData, int maxItemsToFind, ReturningColumnsType returningColumnNamesType);
    public Collection`1<Feature> GetFeaturesNearestTo(Feature targetFeature, GeographyUnit unitOfData, int maxItemsToFind, IEnumerable`1<string> returningColumnNames);
    public Collection`1<Feature> GetFeaturesNearestTo(Feature targetFeature, GeographyUnit unitOfData, int maxItemsToFind, ReturningColumnsType returningColumnNamesType);
    public Collection`1<Feature> GetFeaturesNearestTo(BaseShape targetShape, GeographyUnit unitOfData, int maxItemsToFind, IEnumerable`1<string> returningColumnNames, double searchRadius, DistanceUnit unitOfSearchRadius);
    public Collection`1<Feature> GetFeaturesNearestTo(Feature targetFeature, GeographyUnit unitOfData, int maxItemsToFind, IEnumerable`1<string> returningColumnNames, double searchRadius, DistanceUnit unitOfSearchRadius);
    protected virtual Collection`1<Feature> GetFeaturesNearestToCore(BaseShape targetShape, GeographyUnit unitOfData, int maxItemsToFind, IEnumerable`1<string> returningColumnNames);
    internal static Collection`1<Feature> TR4=(Collection`1<Feature> possibleResults, BaseShape targetShape, GeographyUnit unitOfData, int maxItemsToFind);
    public Collection`1<Feature> GetFeaturesWithinDistanceOf(BaseShape targetShape, GeographyUnit unitOfData, DistanceUnit distanceUnit, double distance, IEnumerable`1<string> returningColumnNames);
    public Collection`1<Feature> GetFeaturesWithinDistanceOf(BaseShape targetShape, GeographyUnit unitOfData, DistanceUnit distanceUnit, double distance, ReturningColumnsType returningColumnNamesType);
    public Collection`1<Feature> GetFeaturesWithinDistanceOf(Feature targetFeature, GeographyUnit unitOfData, DistanceUnit distanceUnit, double distance, IEnumerable`1<string> returningColumnNames);
    public Collection`1<Feature> GetFeaturesWithinDistanceOf(Feature targetFeature, GeographyUnit unitOfData, DistanceUnit distanceUnit, double distance, ReturningColumnsType returningColumnNamesType);
    protected virtual Collection`1<Feature> GetFeaturesWithinDistanceOfCore(BaseShape targetShape, GeographyUnit unitOfData, DistanceUnit distanceUnit, double distance, IEnumerable`1<string> returningColumnNames);
    public Feature GetFeatureById(string id, IEnumerable`1<string> returningColumnNames);
    public Feature GetFeatureById(string id, ReturningColumnsType returningColumnNamesType);
    public Collection`1<Feature> GetFeaturesByIds(IEnumerable`1<string> ids, IEnumerable`1<string> returningColumnNames);
    public Collection`1<Feature> GetFeaturesByIds(IEnumerable`1<string> ids, ReturningColumnsType returningColumnNamesType);
    public RectangleShape GetBoundingBoxById(string id);
    public RectangleShape GetBoundingBoxByIds(IEnumerable`1<string> ids);
    public void RemoveEmptyAndExcludedFeatures(Collection`1<Feature> features);
    public Collection`1<string> GetColumnNamesOutsideFeatureSource(IEnumerable`1<string> returningColumnNames);
    public Collection`1<RectangleShape> GetBoundingBoxesByIds(IEnumerable`1<string> ids);
    protected virtual RectangleShape GetBoundingBoxByIdCore(string id);
    public WellKnownType GetFirstFeaturesWellKnownType();
    protected virtual WellKnownType GetFirstFeaturesWellKnownTypeCore();
    protected virtual Collection`1<Feature> GetFeaturesByIdsCore(IEnumerable`1<string> ids, IEnumerable`1<string> returningColumnNames);
    protected Collection`1<string> GetColumnNamesInsideFeatureSource(IEnumerable`1<string> returningColumnNames);
    protected Collection`1<string> GetReturningColumnNames(ReturningColumnsType returningColumnNamesType);
    public static string GetColumnNameAlias(string columnName, ICollection`1<string> columnNames);
    public static Collection`1<string> SplitColumnNames(IEnumerable`1<string> columnNames);
    public static DataTable ConvertToDataTable(IEnumerable`1<Feature> features, IEnumerable`1<string> columnNames);
    protected static Dictionary`2<string, string> CombineFieldValues(Dictionary`2<string, string> columnValues, IEnumerable`1<string> originalColumnNames);
    private static int Th4=(List`1<double> doubles);
    private static bool Tx4=(IEnumerable`1<string> originalComlumnNames);
    private static Collection`1<string> UB4=(string multiFieldName);
    private static Collection`1<string> UR4=(string multiFieldName);
    private static Collection`1<Feature> QB4=(Collection`1<Feature> features, TransactionBuffer transactionBuffer, IEnumerable`1<string> returningIds);
    private static Dictionary`2<string, Feature> QB4=(Dictionary`2<string, Feature> features, TransactionBuffer transactionBuffer);
    private static Dictionary`2<string, Feature> Uh4=(Collection`1<Feature> features);
    private static Collection`1<Feature> Ux4=(Dictionary`2<string, Feature> features);
    protected virtual void OnDrawingProgressChanged(DrawingProgressChangedEventArgs e);
    internal Collection`1<string> VB4=(IEnumerable`1<string> returningColumnNames);
    [OnGeodeserializedAttribute]
private void VR4=();
    private static Collection`1<Feature> Vh4=(Collection`1<Feature> features, IEnumerable`1<string> returningColumnNames);
    private static string Vx4=(string columnName, ICollection`1<string> columnNames, int alias);
    public bool CanGetBoundingBoxQuickly();
    protected virtual bool CanGetBoundingBoxQuicklyCore();
    public bool CanGetCountQuickly();
    protected virtual bool CanGetCountQuicklyCore();
    public Collection`1<DistinctColumnValue> GetDistinctColumnValues(string columnName);
    protected virtual Collection`1<DistinctColumnValue> GetDistinctColumnValuesCore(string columnName);
    public Collection`1<Feature> GetAllFeatures(ReturningColumnsType returningColumnTypes, int startIndex);
    public Collection`1<Feature> GetAllFeatures(ReturningColumnsType returningColumnTypes, int startIndex, int takeCount);
    public Collection`1<Feature> GetAllFeatures(IEnumerable`1<string> returningColumnNames, int startIndex, int takeCount);
    protected virtual Collection`1<Feature> GetAllFeaturesCore(IEnumerable`1<string> returningColumnNames, int startIndex, int takeCount);
    [CompilerGeneratedAttribute]
private bool <GetFeaturesForDrawing>b__159_0(Feature f);
    [CompilerGeneratedAttribute]
private bool <RemoveEmptyAndExcludedFeatures>b__197_0(Feature f);
}
public class ThinkGeo.Core.FeatureSourceColumn : object {
    [ObfuscationAttribute]
private string columnName;
    [ObfuscationAttribute]
private string typeName;
    [ObfuscationAttribute]
private int maxLength;
    public string ColumnName { get; public set; }
    public string TypeName { get; public set; }
    public int MaxLength { get; public set; }
    public FeatureSourceColumn(string columnName);
    public FeatureSourceColumn(string columnName, string typeName, int maxLength);
    public string get_ColumnName();
    public void set_ColumnName(string value);
    public string get_TypeName();
    public void set_TypeName(string value);
    public int get_MaxLength();
    public void set_MaxLength(int value);
    public virtual string ToString();
}
public enum ThinkGeo.Core.FeatureValidationType : Enum {
    public int value__;
    public static FeatureValidationType Invalid;
    public static FeatureValidationType Valid;
}
[ObfuscationAttribute]
internal class ThinkGeo.Core.FeetValues : ValueType {
    [ObfuscationAttribute]
private double v10;
    [ObfuscationAttribute]
private double v100;
    [ObfuscationAttribute]
private double v1000;
    [ObfuscationAttribute]
private double v20;
    [ObfuscationAttribute]
private double v200;
    [ObfuscationAttribute]
private double v2000;
    [ObfuscationAttribute]
private double v30;
    [ObfuscationAttribute]
private double v300;
    [ObfuscationAttribute]
private double v40;
    [ObfuscationAttribute]
private double v400;
    [ObfuscationAttribute]
private double v50;
    [ObfuscationAttribute]
private double v500;
    public double vSA= { get; }
    public double vyA= { get; }
    public double wSA= { get; }
    public double wyA= { get; }
    public double xSA= { get; }
    public double xyA= { get; }
    public double ySA= { get; }
    public double yyA= { get; }
    public double zSA= { get; }
    public double zyA= { get; }
    public double 0SA= { get; }
    public double 0yA= { get; }
    public FeetValues(int width, double extentLengthBar, DistanceUnit distanceUnit);
    public double vCA=();
    public double viA=();
    public double wCA=();
    public double wiA=();
    public double xCA=();
    public double xiA=();
    public double yCA=();
    public double yiA=();
    public double zCA=();
    public double ziA=();
    public double 0CA=();
    public double 0iA=();
}
[ObfuscationAttribute]
internal class ThinkGeo.Core.FileHeader : ValueType {
    [ObfuscationAttribute]
public string descriptionString;
    [ObfuscationAttribute]
public UInt32 extensionId;
    [ObfuscationAttribute]
public UInt32 freePageId;
    [ObfuscationAttribute]
public string extensionName;
    [ObfuscationAttribute]
public UInt32 pageSize;
    [ObfuscationAttribute]
public bool isFloat;
    private static int MR8=;
    private static int Mh8=;
    private static int Mx8=;
    public void xR4=();
    public bool ZRw=(BinaryReader r);
    public bool cxw=(BinaryWriter w);
    public virtual string ToString();
}
public class ThinkGeo.Core.FileRasterTileCache : RasterTileCache {
    [ObfuscationAttribute]
private static int DigitCount;
    [ObfuscationAttribute]
private string cacheDirectory;
    private static object VhY=;
    public string CacheDirectory { get; public set; }
    public FileRasterTileCache(string cacheDirectory);
    public FileRasterTileCache(string cacheDirectory, string cacheId);
    public FileRasterTileCache(string cacheDirectory, string cacheId, GeoImageFormat imageFormat);
    private static FileRasterTileCache();
    public string get_CacheDirectory();
    public void set_CacheDirectory(string value);
    protected virtual Tile GetTileCore(int zoom, long column, long row);
    [AsyncStateMachineAttribute("ThinkGeo.Core.FileRasterTileCache/<GetTileAsyncCore>d__11")]
protected virtual Task`1<Tile> GetTileAsyncCore(int zoom, long column, long row, CancellationToken cancellationToken);
    protected virtual void SaveTileCore(Tile tile);
    [AsyncStateMachineAttribute("ThinkGeo.Core.FileRasterTileCache/<SaveTileAsyncCore>d__13")]
protected virtual Task SaveTileAsyncCore(Tile tile, CancellationToken cancellationToken);
    protected virtual void DeleteTileCore(Tile tile);
    internal bool hx0=(string tileImageFileName);
    public void ClearCache(TimeSpan tileExpiration);
    public void ClearCache(double maxSizeInMegabytes);
    public void ClearCache(TimeSpan tileExpiration, double maxSizeInMegabytes);
    public virtual string ToString();
    [IteratorStateMachineAttribute("ThinkGeo.Core.FileRasterTileCache/<GetExtensionsToClear>d__20")]
private static IEnumerable`1<string> iB0=();
    private static IEnumerable`1<FileInfo> iR0=(DirectoryInfo dirInfo);
    private static long ih0=(DirectoryInfo dirInfo);
    protected virtual void ClearCacheCore();
    private static bool ix0=(string folder);
    private static string jB0=(int zoom, long column, long row, string cacheId, string cacheDirectory, GeoImageFormat imageFormat);
}
public class ThinkGeo.Core.FileVectorTileCache : TileCache {
    [ObfuscationAttribute]
private string fileExtension;
    [ObfuscationAttribute]
private string cacheDirectory;
    public string CacheDirectory { get; public set; }
    public string FileExtension { get; public set; }
    public FileVectorTileCache(string cacheDirectory);
    public FileVectorTileCache(string cacheDirectory, string cacheId);
    public FileVectorTileCache(string cacheDirectory, string cacheId, string fileExtension);
    public string get_CacheDirectory();
    public void set_CacheDirectory(string value);
    public string get_FileExtension();
    public void set_FileExtension(string value);
    protected virtual void ClearCacheCore();
    protected virtual void DeleteTileCore(Tile tile);
    protected virtual Tile GetTileCore(int zoom, long column, long row);
    [AsyncStateMachineAttribute("ThinkGeo.Core.FileVectorTileCache/<GetTileAsyncCore>d__15")]
protected virtual Task`1<Tile> GetTileAsyncCore(int zoom, long column, long row, CancellationToken cancellationToken);
    protected virtual void SaveTileCore(Tile tile);
    [AsyncStateMachineAttribute("ThinkGeo.Core.FileVectorTileCache/<SaveTileAsyncCore>d__17")]
protected virtual Task SaveTileAsyncCore(Tile tile, CancellationToken cancellationToken);
    private static string jB0=(int zoom, long row, long column, string cacheId, string cacheDirectory, string fileExtension);
}
public enum ThinkGeo.Core.FilterApplyMode : Enum {
    public int value__;
    public static FilterApplyMode ApplyFirst;
    public static FilterApplyMode ApplyAll;
}
public class ThinkGeo.Core.FilterCondition : object {
    internal static string TzE=;
    [ObfuscationAttribute]
private string columnName;
    [ObfuscationAttribute]
private string expression;
    [ObfuscationAttribute]
private string name;
    private Regex UDE=;
    private string UTE=;
    [ObfuscationAttribute]
private RegexOptions regexOptions;
    [ObfuscationAttribute]
private bool logical;
    [ObfuscationAttribute]
private bool isLeftBracket;
    [ObfuscationAttribute]
private bool isRightBracket;
    public string Expression { get; public set; }
    public string ColumnName { get; public set; }
    public string Name { get; public set; }
    public RegexOptions RegexOptions { get; public set; }
    public bool Logical { get; public set; }
    public bool IsLeftBracket { get; public set; }
    public bool IsRightBracket { get; public set; }
    public FilterCondition(string columnName);
    public FilterCondition(string columnName, string expression);
    private static FilterCondition();
    public string get_Expression();
    public void set_Expression(string value);
    public string get_ColumnName();
    public void set_ColumnName(string value);
    public string get_Name();
    public void set_Name(string value);
    public RegexOptions get_RegexOptions();
    public void set_RegexOptions(RegexOptions value);
    public bool get_Logical();
    public void set_Logical(bool value);
    public bool get_IsLeftBracket();
    public void set_IsLeftBracket(bool value);
    public bool get_IsRightBracket();
    public void set_IsRightBracket(bool value);
    public Collection`1<Feature> GetMatchingFeatures(IEnumerable`1<Feature> features);
    protected virtual Collection`1<Feature> GetMatchingFeaturesCore(IEnumerable`1<Feature> features);
    internal bool UjE=(Feature feature);
    internal bool UjE=(KeyValuePair`2<string, string> value);
    internal virtual bool 3yI=(KeyValuePair`2<string, string> value);
    internal virtual bool 3yI=(Feature feature);
    internal bool UzE=(Collection`1<string> values);
    private bool VDE=(string value, string expression);
    private static bool VTE=(Collection`1<string> columnValues, string expression, Func`4<double, double, double, bool> doubleMatchingFunc);
    private static bool VTE=(Collection`1<string> columnValues, string expression, Func`3<double, double, bool> doubleMatchingFunc);
    private static Collection`1<string> VjE=(Feature feature, string columnName);
    private static bool VzE=(IEnumerable`1<string> columnValues, Func`2<string, bool> matchFunc);
    [CompilerGeneratedAttribute]
private bool <GetMatchingFeaturesCore>b__35_0(Feature f);
    [CompilerGeneratedAttribute]
private bool <GetMatchResult>b__40_8(string v);
    [CompilerGeneratedAttribute]
private bool <GetMatchResult>b__40_9(string v);
}
public class ThinkGeo.Core.FilterStyle : Style {
    [ObfuscationAttribute]
private Collection`1<Style> styles;
    [ObfuscationAttribute]
private Collection`1<FilterCondition> conditions;
    public Collection`1<Style> Styles { get; }
    public Collection`1<FilterCondition> Conditions { get; }
    public Collection`1<Style> get_Styles();
    public Collection`1<FilterCondition> get_Conditions();
    protected virtual Collection`1<string> GetRequiredColumnNamesCore();
    protected virtual void DrawCore(IEnumerable`1<Feature> features, GeoCanvas canvas, Collection`1<SimpleCandidate> labelsInThisLayer, Collection`1<SimpleCandidate> labelsInAllLayers);
    protected virtual void DrawSampleCore(GeoCanvas canvas, DrawingRectangleF drawingExtent);
    private static Collection`1<string> WDE=(string expression);
}
public class ThinkGeo.Core.FormattedPositionStyleEventArgs : EventArgs {
    [ObfuscationAttribute]
private string text;
    [ObfuscationAttribute]
private BaseShape shape;
    public string Text { get; public set; }
    public BaseShape Shape { get; public set; }
    public FormattedPositionStyleEventArgs(string text, BaseShape shape);
    public string get_Text();
    public void set_Text(string value);
    public BaseShape get_Shape();
    public void set_Shape(BaseShape value);
}
public class ThinkGeo.Core.FormattingPositionStyleEventArgs : EventArgs {
    [ObfuscationAttribute]
private string text;
    [ObfuscationAttribute]
private BaseShape shape;
    public string Text { get; public set; }
    public BaseShape Shape { get; public set; }
    public FormattingPositionStyleEventArgs(string text, BaseShape shape);
    public string get_Text();
    public void set_Text(string value);
    public BaseShape get_Shape();
    public void set_Shape(BaseShape value);
}
public class ThinkGeo.Core.GaussianKrigingGridInterpolationModel : KrigingGridInterpolationModel {
    public GaussianKrigingGridInterpolationModel(IDictionary`2<PointShape, double> points);
    public GaussianKrigingGridInterpolationModel(IDictionary`2<PointShape, double> points, int numberOfRefrencedPoints);
    protected virtual double GetSillSlopeCore(double distance, double range);
}
public class ThinkGeo.Core.GeneratedTileMBTilesLayerEventArgs : EventArgs {
    public int TileX;
    public int TileY;
    public int ZoomLevel;
    public GeneratedTileMBTilesLayerEventArgs(int tileX, int tileY, int zoomLevel);
}
public class ThinkGeo.Core.GeneratingGridFeatureSourceEventArgs : EventArgs {
    [ObfuscationAttribute]
private int gridCount;
    [ObfuscationAttribute]
private int gridIndex;
    [ObfuscationAttribute]
private DateTime startProcessTime;
    [ObfuscationAttribute]
private bool isCanceled;
    [ObfuscationAttribute]
private string gridPathFilename;
    public string GridPathFilename { get; public set; }
    public bool IsCanceled { get; public set; }
    public DateTime StartProcessTime { get; public set; }
    public int GridIndex { get; public set; }
    public int GridCount { get; public set; }
    public GeneratingGridFeatureSourceEventArgs(int gridCount, int gridIndex, DateTime startProcessTime, bool isCanceled);
    public GeneratingGridFeatureSourceEventArgs(int gridCount, int gridIndex, DateTime startProcessTime, bool isCanceled, string gridPathFilename);
    public string get_GridPathFilename();
    public void set_GridPathFilename(string value);
    public bool get_IsCanceled();
    public void set_IsCanceled(bool value);
    public DateTime get_StartProcessTime();
    public void set_StartProcessTime(DateTime value);
    public int get_GridIndex();
    public void set_GridIndex(int value);
    public int get_GridCount();
    public void set_GridCount(int value);
}
public class ThinkGeo.Core.GeneratingTileMBTilesLayerEventArgs : EventArgs {
    public int TileX;
    public int TileY;
    public int ZoomLevel;
    public bool Cancel;
    public GeneratingTileMBTilesLayerEventArgs(int tileX, int tileY, int zoomLevel);
}
public enum ThinkGeo.Core.GeoAlphaType : Enum {
    public int value__;
    public static GeoAlphaType Unknown;
    public static GeoAlphaType Opaque;
    public static GeoAlphaType Premul;
    public static GeoAlphaType Unpremul;
}
public abstract class ThinkGeo.Core.GeoBrush : object {
    [ObfuscationAttribute]
private long id;
    [ObfuscationAttribute]
private static long geoBrushIdCounter;
    public long Id { get; }
    public long get_Id();
}
public static class ThinkGeo.Core.GeoBrushes : object {
    public static GeoSolidBrush AliceBlue { get; }
    public static GeoSolidBrush AntiqueWhite { get; }
    public static GeoSolidBrush Aqua { get; }
    public static GeoSolidBrush Aquamarine { get; }
    public static GeoSolidBrush Azure { get; }
    public static GeoSolidBrush Beige { get; }
    public static GeoSolidBrush Bisque { get; }
    public static GeoSolidBrush Black { get; }
    public static GeoSolidBrush BlanchedAlmond { get; }
    public static GeoSolidBrush Blue { get; }
    public static GeoSolidBrush BlueViolet { get; }
    public static GeoSolidBrush Brown { get; }
    public static GeoSolidBrush BurlyWood { get; }
    public static GeoSolidBrush CadetBlue { get; }
    public static GeoSolidBrush Chartreuse { get; }
    public static GeoSolidBrush Chocolate { get; }
    public static GeoSolidBrush Coral { get; }
    public static GeoSolidBrush CornflowerBlue { get; }
    public static GeoSolidBrush CornSilk { get; }
    public static GeoSolidBrush Crimson { get; }
    public static GeoSolidBrush Cyan { get; }
    public static GeoSolidBrush DarkBlue { get; }
    public static GeoSolidBrush DarkCyan { get; }
    public static GeoSolidBrush DarkGoldenrod { get; }
    public static GeoSolidBrush DarkGray { get; }
    public static GeoSolidBrush DarkGreen { get; }
    public static GeoSolidBrush DarkKhaki { get; }
    public static GeoSolidBrush DarkMagenta { get; }
    public static GeoSolidBrush DarkOliveGreen { get; }
    public static GeoSolidBrush DarkOrange { get; }
    public static GeoSolidBrush DarkOrchid { get; }
    public static GeoSolidBrush DarkRed { get; }
    public static GeoSolidBrush DarkSalmon { get; }
    public static GeoSolidBrush DarkSeaGreen { get; }
    public static GeoSolidBrush DarkSlateBlue { get; }
    public static GeoSolidBrush DarkSlateGray { get; }
    public static GeoSolidBrush DarkTurquoise { get; }
    public static GeoSolidBrush DarkViolet { get; }
    public static GeoSolidBrush DeepPink { get; }
    public static GeoSolidBrush DeepSkyBlue { get; }
    public static GeoSolidBrush DimGray { get; }
    public static GeoSolidBrush DodgerBlue { get; }
    public static GeoSolidBrush Firebrick { get; }
    public static GeoSolidBrush FloralWhite { get; }
    public static GeoSolidBrush ForestGreen { get; }
    public static GeoSolidBrush Fuchsia { get; }
    public static GeoSolidBrush Gainsboro { get; }
    public static GeoSolidBrush GhostWhite { get; }
    public static GeoSolidBrush Gold { get; }
    public static GeoSolidBrush Goldenrod { get; }
    public static GeoSolidBrush Gray { get; }
    public static GeoSolidBrush Green { get; }
    public static GeoSolidBrush GreenYellow { get; }
    public static GeoSolidBrush HoneyDew { get; }
    public static GeoSolidBrush HotPink { get; }
    public static GeoSolidBrush IndianRed { get; }
    public static GeoSolidBrush Indigo { get; }
    public static GeoSolidBrush Ivory { get; }
    public static GeoSolidBrush Khaki { get; }
    public static GeoSolidBrush Lavender { get; }
    public static GeoSolidBrush LavenderBlush { get; }
    public static GeoSolidBrush LawnGreen { get; }
    public static GeoSolidBrush LemonChiffon { get; }
    public static GeoSolidBrush LightBlue { get; }
    public static GeoSolidBrush LightCoral { get; }
    public static GeoSolidBrush LightCyan { get; }
    public static GeoSolidBrush LightGoldenrodYellow { get; }
    public static GeoSolidBrush LightGray { get; }
    public static GeoSolidBrush LightGreen { get; }
    public static GeoSolidBrush LightPink { get; }
    public static GeoSolidBrush LightRed { get; }
    public static GeoSolidBrush LightSalmon { get; }
    public static GeoSolidBrush LightSeaGreen { get; }
    public static GeoSolidBrush LightSkyBlue { get; }
    public static GeoSolidBrush LightSlateGray { get; }
    public static GeoSolidBrush LightSteelBlue { get; }
    public static GeoSolidBrush LightYellow { get; }
    public static GeoSolidBrush Lime { get; }
    public static GeoSolidBrush LimeGreen { get; }
    public static GeoSolidBrush Linen { get; }
    public static GeoSolidBrush Magenta { get; }
    public static GeoSolidBrush Maroon { get; }
    public static GeoSolidBrush MediumAquamarine { get; }
    public static GeoSolidBrush MediumBlue { get; }
    public static GeoSolidBrush MediumOrchid { get; }
    public static GeoSolidBrush MediumPurple { get; }
    public static GeoSolidBrush MediumSeaGreen { get; }
    public static GeoSolidBrush MediumSlateBlue { get; }
    public static GeoSolidBrush MediumSpringGreen { get; }
    public static GeoSolidBrush MediumTurquoise { get; }
    public static GeoSolidBrush MediumVioletRed { get; }
    public static GeoSolidBrush MidnightBlue { get; }
    public static GeoSolidBrush MintCream { get; }
    public static GeoSolidBrush MistyRose { get; }
    public static GeoSolidBrush Moccasin { get; }
    public static GeoSolidBrush NavajoWhite { get; }
    public static GeoSolidBrush Navy { get; }
    public static GeoSolidBrush OldLace { get; }
    public static GeoSolidBrush Olive { get; }
    public static GeoSolidBrush OliveDrab { get; }
    public static GeoSolidBrush Orange { get; }
    public static GeoSolidBrush OrangeRed { get; }
    public static GeoSolidBrush Orchid { get; }
    public static GeoSolidBrush PaleGoldenrod { get; }
    public static GeoSolidBrush PaleGreen { get; }
    public static GeoSolidBrush PaleTurquoise { get; }
    public static GeoSolidBrush PaleVioletRed { get; }
    public static GeoSolidBrush PapayaWhip { get; }
    public static GeoSolidBrush PeachPuff { get; }
    public static GeoSolidBrush Peru { get; }
    public static GeoSolidBrush Pink { get; }
    public static GeoSolidBrush Plum { get; }
    public static GeoSolidBrush PowderBlue { get; }
    public static GeoSolidBrush Purple { get; }
    public static GeoSolidBrush Red { get; }
    public static GeoSolidBrush RosyBrown { get; }
    public static GeoSolidBrush RoyalBlue { get; }
    public static GeoSolidBrush SaddleBrown { get; }
    public static GeoSolidBrush Salmon { get; }
    public static GeoSolidBrush SandyBrown { get; }
    public static GeoSolidBrush SeaGreen { get; }
    public static GeoSolidBrush SeaShell { get; }
    public static GeoSolidBrush Sienna { get; }
    public static GeoSolidBrush Silver { get; }
    public static GeoSolidBrush SkyBlue { get; }
    public static GeoSolidBrush SlateBlue { get; }
    public static GeoSolidBrush SlateGray { get; }
    public static GeoSolidBrush Snow { get; }
    public static GeoSolidBrush SpringGreen { get; }
    public static GeoSolidBrush SteelBlue { get; }
    public static GeoSolidBrush Tan { get; }
    public static GeoSolidBrush Teal { get; }
    public static GeoSolidBrush Thistle { get; }
    public static GeoSolidBrush Tomato { get; }
    public static GeoSolidBrush Turquoise { get; }
    public static GeoSolidBrush Violet { get; }
    public static GeoSolidBrush Wheat { get; }
    public static GeoSolidBrush White { get; }
    public static GeoSolidBrush WhiteSmoke { get; }
    public static GeoSolidBrush Yellow { get; }
    public static GeoSolidBrush YellowGreen { get; }
    public static GeoSolidBrush DarkYellow { get; }
    public static GeoSolidBrush LightOrange { get; }
    public static GeoSolidBrush PaleRed { get; }
    public static GeoSolidBrush PaleBlue { get; }
    public static GeoSolidBrush PaleYellow { get; }
    public static GeoSolidBrush PaleOrange { get; }
    public static GeoSolidBrush BrightRed { get; }
    public static GeoSolidBrush BrightBlue { get; }
    public static GeoSolidBrush BrightYellow { get; }
    public static GeoSolidBrush BrightOrange { get; }
    public static GeoSolidBrush PastelRed { get; }
    public static GeoSolidBrush PastelBlue { get; }
    public static GeoSolidBrush PastelYellow { get; }
    public static GeoSolidBrush PastelGreen { get; }
    public static GeoSolidBrush PastelOrange { get; }
    public static GeoSolidBrush Copper { get; }
    public static GeoSolidBrush get_AliceBlue();
    public static GeoSolidBrush get_AntiqueWhite();
    public static GeoSolidBrush get_Aqua();
    public static GeoSolidBrush get_Aquamarine();
    public static GeoSolidBrush get_Azure();
    public static GeoSolidBrush get_Beige();
    public static GeoSolidBrush get_Bisque();
    public static GeoSolidBrush get_Black();
    public static GeoSolidBrush get_BlanchedAlmond();
    public static GeoSolidBrush get_Blue();
    public static GeoSolidBrush get_BlueViolet();
    public static GeoSolidBrush get_Brown();
    public static GeoSolidBrush get_BurlyWood();
    public static GeoSolidBrush get_CadetBlue();
    public static GeoSolidBrush get_Chartreuse();
    public static GeoSolidBrush get_Chocolate();
    public static GeoSolidBrush get_Coral();
    public static GeoSolidBrush get_CornflowerBlue();
    public static GeoSolidBrush get_CornSilk();
    public static GeoSolidBrush get_Crimson();
    public static GeoSolidBrush get_Cyan();
    public static GeoSolidBrush get_DarkBlue();
    public static GeoSolidBrush get_DarkCyan();
    public static GeoSolidBrush get_DarkGoldenrod();
    public static GeoSolidBrush get_DarkGray();
    public static GeoSolidBrush get_DarkGreen();
    public static GeoSolidBrush get_DarkKhaki();
    public static GeoSolidBrush get_DarkMagenta();
    public static GeoSolidBrush get_DarkOliveGreen();
    public static GeoSolidBrush get_DarkOrange();
    public static GeoSolidBrush get_DarkOrchid();
    public static GeoSolidBrush get_DarkRed();
    public static GeoSolidBrush get_DarkSalmon();
    public static GeoSolidBrush get_DarkSeaGreen();
    public static GeoSolidBrush get_DarkSlateBlue();
    public static GeoSolidBrush get_DarkSlateGray();
    public static GeoSolidBrush get_DarkTurquoise();
    public static GeoSolidBrush get_DarkViolet();
    public static GeoSolidBrush get_DeepPink();
    public static GeoSolidBrush get_DeepSkyBlue();
    public static GeoSolidBrush get_DimGray();
    public static GeoSolidBrush get_DodgerBlue();
    public static GeoSolidBrush get_Firebrick();
    public static GeoSolidBrush get_FloralWhite();
    public static GeoSolidBrush get_ForestGreen();
    public static GeoSolidBrush get_Fuchsia();
    public static GeoSolidBrush get_Gainsboro();
    public static GeoSolidBrush get_GhostWhite();
    public static GeoSolidBrush get_Gold();
    public static GeoSolidBrush get_Goldenrod();
    public static GeoSolidBrush get_Gray();
    public static GeoSolidBrush get_Green();
    public static GeoSolidBrush get_GreenYellow();
    public static GeoSolidBrush get_HoneyDew();
    public static GeoSolidBrush get_HotPink();
    public static GeoSolidBrush get_IndianRed();
    public static GeoSolidBrush get_Indigo();
    public static GeoSolidBrush get_Ivory();
    public static GeoSolidBrush get_Khaki();
    public static GeoSolidBrush get_Lavender();
    public static GeoSolidBrush get_LavenderBlush();
    public static GeoSolidBrush get_LawnGreen();
    public static GeoSolidBrush get_LemonChiffon();
    public static GeoSolidBrush get_LightBlue();
    public static GeoSolidBrush get_LightCoral();
    public static GeoSolidBrush get_LightCyan();
    public static GeoSolidBrush get_LightGoldenrodYellow();
    public static GeoSolidBrush get_LightGray();
    public static GeoSolidBrush get_LightGreen();
    public static GeoSolidBrush get_LightPink();
    public static GeoSolidBrush get_LightRed();
    public static GeoSolidBrush get_LightSalmon();
    public static GeoSolidBrush get_LightSeaGreen();
    public static GeoSolidBrush get_LightSkyBlue();
    public static GeoSolidBrush get_LightSlateGray();
    public static GeoSolidBrush get_LightSteelBlue();
    public static GeoSolidBrush get_LightYellow();
    public static GeoSolidBrush get_Lime();
    public static GeoSolidBrush get_LimeGreen();
    public static GeoSolidBrush get_Linen();
    public static GeoSolidBrush get_Magenta();
    public static GeoSolidBrush get_Maroon();
    public static GeoSolidBrush get_MediumAquamarine();
    public static GeoSolidBrush get_MediumBlue();
    public static GeoSolidBrush get_MediumOrchid();
    public static GeoSolidBrush get_MediumPurple();
    public static GeoSolidBrush get_MediumSeaGreen();
    public static GeoSolidBrush get_MediumSlateBlue();
    public static GeoSolidBrush get_MediumSpringGreen();
    public static GeoSolidBrush get_MediumTurquoise();
    public static GeoSolidBrush get_MediumVioletRed();
    public static GeoSolidBrush get_MidnightBlue();
    public static GeoSolidBrush get_MintCream();
    public static GeoSolidBrush get_MistyRose();
    public static GeoSolidBrush get_Moccasin();
    public static GeoSolidBrush get_NavajoWhite();
    public static GeoSolidBrush get_Navy();
    public static GeoSolidBrush get_OldLace();
    public static GeoSolidBrush get_Olive();
    public static GeoSolidBrush get_OliveDrab();
    public static GeoSolidBrush get_Orange();
    public static GeoSolidBrush get_OrangeRed();
    public static GeoSolidBrush get_Orchid();
    public static GeoSolidBrush get_PaleGoldenrod();
    public static GeoSolidBrush get_PaleGreen();
    public static GeoSolidBrush get_PaleTurquoise();
    public static GeoSolidBrush get_PaleVioletRed();
    public static GeoSolidBrush get_PapayaWhip();
    public static GeoSolidBrush get_PeachPuff();
    public static GeoSolidBrush get_Peru();
    public static GeoSolidBrush get_Pink();
    public static GeoSolidBrush get_Plum();
    public static GeoSolidBrush get_PowderBlue();
    public static GeoSolidBrush get_Purple();
    public static GeoSolidBrush get_Red();
    public static GeoSolidBrush get_RosyBrown();
    public static GeoSolidBrush get_RoyalBlue();
    public static GeoSolidBrush get_SaddleBrown();
    public static GeoSolidBrush get_Salmon();
    public static GeoSolidBrush get_SandyBrown();
    public static GeoSolidBrush get_SeaGreen();
    public static GeoSolidBrush get_SeaShell();
    public static GeoSolidBrush get_Sienna();
    public static GeoSolidBrush get_Silver();
    public static GeoSolidBrush get_SkyBlue();
    public static GeoSolidBrush get_SlateBlue();
    public static GeoSolidBrush get_SlateGray();
    public static GeoSolidBrush get_Snow();
    public static GeoSolidBrush get_SpringGreen();
    public static GeoSolidBrush get_SteelBlue();
    public static GeoSolidBrush get_Tan();
    public static GeoSolidBrush get_Teal();
    public static GeoSolidBrush get_Thistle();
    public static GeoSolidBrush get_Tomato();
    public static GeoSolidBrush get_Turquoise();
    public static GeoSolidBrush get_Violet();
    public static GeoSolidBrush get_Wheat();
    public static GeoSolidBrush get_White();
    public static GeoSolidBrush get_WhiteSmoke();
    public static GeoSolidBrush get_Yellow();
    public static GeoSolidBrush get_YellowGreen();
    public static GeoSolidBrush get_DarkYellow();
    public static GeoSolidBrush get_LightOrange();
    public static GeoSolidBrush get_PaleRed();
    public static GeoSolidBrush get_PaleBlue();
    public static GeoSolidBrush get_PaleYellow();
    public static GeoSolidBrush get_PaleOrange();
    public static GeoSolidBrush get_BrightRed();
    public static GeoSolidBrush get_BrightBlue();
    public static GeoSolidBrush get_BrightYellow();
    public static GeoSolidBrush get_BrightOrange();
    public static GeoSolidBrush get_PastelRed();
    public static GeoSolidBrush get_PastelBlue();
    public static GeoSolidBrush get_PastelYellow();
    public static GeoSolidBrush get_PastelGreen();
    public static GeoSolidBrush get_PastelOrange();
    public static GeoSolidBrush get_Copper();
}
public enum ThinkGeo.Core.GeoBrushWrapMode : Enum {
    public int value__;
    public static GeoBrushWrapMode Tile;
    public static GeoBrushWrapMode Clamp;
    public static GeoBrushWrapMode TileFlipX;
    public static GeoBrushWrapMode TileFlipY;
    public static GeoBrushWrapMode TileFlipXY;
}
public abstract class ThinkGeo.Core.GeoCanvas : object {
    private static int /xQ=;
    private static int ABU=;
    private static int ARU=;
    private static int AhU=;
    private static int AxU=;
    private static int BBU=;
    private static int BRU=;
    private static int BhU=;
    [ObfuscationAttribute]
private int progressDrawingRaisingFrenquency;
    [ObfuscationAttribute]
private int progressDrawingRaisedCount;
    [ObfuscationAttribute]
private bool isDrawing;
    [ObfuscationAttribute]
private float width;
    [ObfuscationAttribute]
private float height;
    [ObfuscationAttribute]
private double worldToScreenFactorX;
    [ObfuscationAttribute]
private double worldToScreenFactorY;
    [ObfuscationAttribute]
private object nativeImage;
    [ObfuscationAttribute]
private RectangleShape currentWorldExtent;
    [ObfuscationAttribute]
private DrawingQuality drawingQuality;
    [ObfuscationAttribute]
private GeographyUnit mapUnit;
    [ObfuscationAttribute]
private float dpi;
    [ObfuscationAttribute]
private Collection`1<GeoColor> keyColors;
    [ObfuscationAttribute]
private double currentScale;
    [ObfuscationAttribute]
private float scaleFactor;
    [ObfuscationAttribute]
private CancellationToken cancellationToken;
    [ObfuscationAttribute]
private Dictionary`2<int, GeoPen> CachedScaledPen;
    [ObfuscationAttribute]
private RectangleShape clippingArea;
    [CompilerGeneratedAttribute]
private EventHandler`1<DrawingProgressChangedEventArgs> DrawingProgressChanged;
    [CompilerGeneratedAttribute]
private double BxU=;
    public double CurrentScale { get; }
    public double FontDisplayDensity { get; }
    public DrawingQuality DrawingQuality { get; public set; }
    public GeographyUnit MapUnit { get; }
    public float Width { get; protected set; }
    public float Height { get; protected set; }
    public RectangleShape CurrentWorldExtent { get; protected set; }
    public bool SupportKeyColor { get; }
    public Collection`1<GeoColor> KeyColors { get; }
    public object NativeImage { get; }
    public bool IsDrawing { get; protected set; }
    public float Dpi { get; public set; }
    public float ScaleFactor { get; public set; }
    public CancellationToken CancellationToken { get; public set; }
    public RectangleShape ClippingArea { get; public set; }
    private bool CRU= { get; }
    [CompilerGeneratedAttribute]
public void add_DrawingProgressChanged(EventHandler`1<DrawingProgressChangedEventArgs> value);
    [CompilerGeneratedAttribute]
public void remove_DrawingProgressChanged(EventHandler`1<DrawingProgressChangedEventArgs> value);
    public double get_CurrentScale();
    [CompilerGeneratedAttribute]
public virtual double get_FontDisplayDensity();
    public DrawingQuality get_DrawingQuality();
    public void set_DrawingQuality(DrawingQuality value);
    public GeographyUnit get_MapUnit();
    public float get_Width();
    protected void set_Width(float value);
    public float get_Height();
    protected void set_Height(float value);
    public RectangleShape get_CurrentWorldExtent();
    protected void set_CurrentWorldExtent(RectangleShape value);
    public virtual bool get_SupportKeyColor();
    public Collection`1<GeoColor> get_KeyColors();
    public object get_NativeImage();
    public bool get_IsDrawing();
    protected void set_IsDrawing(bool value);
    public virtual float get_Dpi();
    public virtual void set_Dpi(float value);
    public float get_ScaleFactor();
    public void set_ScaleFactor(float value);
    public CancellationToken get_CancellationToken();
    public void set_CancellationToken(CancellationToken value);
    public RectangleShape get_ClippingArea();
    public void set_ClippingArea(RectangleShape value);
    public void Clear(GeoBrush fillBrush);
    protected virtual void ClearCore(GeoBrush fillBrush);
    public void DrawArc(GeoPen pen, DrawingRectangleF rect, float startAngle, float sweepAngle, DrawingLevel drawingLevel);
    public void DrawArc(GeoPen pen, float x, float y, float width, float height, float startAngle, float sweepAngle, DrawingLevel drawingLevel);
    protected abstract virtual void DrawArcCore(GeoPen pen, float x, float y, float width, float height, float startAngle, float sweepAngle, DrawingLevel drawingLevel);
    public void DrawArea(Feature feature, GeoPen outlinePen, DrawingLevel drawingLevel);
    public void DrawArea(AreaBaseShape shape, GeoPen outlinePen, DrawingLevel drawingLevel);
    public void DrawArea(Feature feature, GeoBrush fillBrush, DrawingLevel drawingLevel);
    public void DrawArea(AreaBaseShape shape, GeoBrush fillBrush, DrawingLevel drawingLevel);
    public void DrawArea(Feature feature, GeoPen outlinePen, GeoBrush fillBrush, DrawingLevel drawingLevel);
    public void DrawArea(AreaBaseShape shape, GeoPen outlinePen, GeoBrush fillBrush, DrawingLevel drawingLevel);
    public void DrawArea(Feature feature, GeoPen outlinePen, GeoBrush fillBrush, DrawingLevel drawingLevel, float xOffset, float yOffset, PenBrushDrawingOrder penBrushDrawingOrder);
    public void DrawArea(AreaBaseShape shape, GeoPen outlinePen, GeoBrush fillBrush, DrawingLevel drawingLevel, float xOffset, float yOffset, PenBrushDrawingOrder penBrushDrawingOrder);
    private List`1<List`1<ScreenPointF[]>> ChU=(Byte[] areaShapeWkb, byte byteOrder);
    public void DrawArea(IEnumerable`1<ScreenPointF[]> screenPoints, GeoPen outlinePen, GeoBrush fillBrush, DrawingLevel drawingLevel, float xOffset, float yOffset, PenBrushDrawingOrder penBrushDrawingOrder);
    protected abstract virtual void DrawAreaCore(IEnumerable`1<ScreenPointF[]> screenPoints, GeoPen outlinePen, GeoBrush fillBrush, DrawingLevel drawingLevel, float xOffset, float yOffset, PenBrushDrawingOrder penBrushDrawingOrder);
    public void DrawLine(Feature feature, GeoPen linePen, DrawingLevel drawingLevel);
    public void DrawLine(LineBaseShape shape, GeoPen linePen, DrawingLevel drawingLevel);
    public void DrawLine(Feature feature, GeoPen linePen, DrawingLevel drawingLevel, float xOffset, float yOffset);
    public void DrawLine(LineBaseShape shape, GeoPen linePen, DrawingLevel drawingLevel, float xOffset, float yOffset);
    public void DrawLine(IEnumerable`1<ScreenPointF> screenPoints, GeoPen linePen, DrawingLevel drawingLevel, float xOffset, float yOffset);
    protected abstract virtual void DrawLineCore(IEnumerable`1<ScreenPointF> screenPoints, GeoPen linePen, DrawingLevel drawingLevel, float xOffset, float yOffset);
    public void DrawEllipse(Feature feature, float width, float height, GeoPen outlinePen, DrawingLevel drawingLevel);
    public void DrawEllipse(PointBaseShape shape, float width, float height, GeoPen outlinePen, DrawingLevel drawingLevel);
    public void DrawEllipse(Feature centerPointFeature, float width, float height, GeoBrush fillBrush, DrawingLevel drawingLevel);
    public void DrawEllipse(PointBaseShape shape, float width, float height, GeoBrush fillBrush, DrawingLevel drawingLevel);
    public void DrawEllipse(Feature feature, float width, float height, GeoPen outlinePen, GeoBrush fillBrush, DrawingLevel drawingLevel);
    public void DrawEllipse(PointBaseShape shape, float width, float height, GeoPen outlinePen, GeoBrush fillBrush, DrawingLevel drawingLevel);
    public void DrawEllipse(Feature feature, float width, float height, GeoPen outlinePen, GeoBrush fillBrush, DrawingLevel drawingLevel, float xOffset, float yOffset, PenBrushDrawingOrder penBrushDrawingOrder);
    public void DrawEllipse(PointBaseShape shape, float width, float height, GeoPen outlinePen, GeoBrush fillBrush, DrawingLevel drawingLevel, float xOffset, float yOffset, PenBrushDrawingOrder penBrushDrawingOrder);
    public void DrawEllipse(ScreenPointF screenPoint, float width, float height, GeoPen outlinePen, GeoBrush fillBrush, DrawingLevel drawingLevel, float xOffset, float yOffset, PenBrushDrawingOrder penBrushDrawingOrder);
    protected abstract virtual void DrawEllipseCore(ScreenPointF screenPoint, float width, float height, GeoPen outlinePen, GeoBrush fillBrush, DrawingLevel drawingLevel, float xOffset, float yOffset, PenBrushDrawingOrder penBrushDrawingOrder);
    public void DrawWorldImageWithoutScaling(GeoImage image, double centerXInWorld, double centerYInWorld, DrawingLevel drawingLevel);
    public void DrawWorldImageWithoutScaling(GeoImage image, double centerXInWorld, double centerYInWorld, DrawingLevel drawingLevel, float xOffset, float yOffset, float rotateAngle);
    public void DrawScreenImageWithoutScaling(GeoImage image, float centerXInScreen, float centerYInScreen, DrawingLevel drawingLevel, float xOffset, float yOffset, float rotateAngle);
    protected abstract virtual void DrawScreenImageWithoutScalingCore(GeoImage image, float centerXInScreen, float centerYInScreen, DrawingLevel drawingLevel, float xOffset, float yOffset, float rotateAngle);
    public void DrawWorldImage(GeoImage image, double centerXInWorld, double centerYInWorld, float widthInScreen, float heightInScreen, DrawingLevel drawingLevel);
    public void DrawWorldImage(GeoImage image, double centerXInWorld, double centerYInWorld, double imageScale, DrawingLevel drawingLevel, float xOffset, float yOffset, float rotateAngle);
    public void DrawWorldImage(GeoImage image, double centerXInWorld, double centerYInWorld, float widthInScreen, float heightInScreen, DrawingLevel drawingLevel, float xOffset, float yOffset, float rotateAngle);
    public void DrawScreenImage(GeoImage image, float centerXInScreen, float centerYInScreen, float widthInScreen, float heightInScreen, DrawingLevel drawingLevel, float xOffset, float yOffset, float rotateAngle);
    protected abstract virtual void DrawScreenImageCore(GeoImage image, float centerXInScreen, float centerYInScreen, float widthInScreen, float heightInScreen, DrawingLevel drawingLevel, float xOffset, float yOffset, float rotateAngle);
    public void DrawTextWithScreenCoordinate(string text, GeoFont font, GeoBrush fillBrush, float upperLeftXInScreen, float upperLeftYInScreen, DrawingLevel drawingLevel);
    public void DrawTextWithScreenCoordinate(string text, GeoFont font, GeoBrush fillBrush, GeoPen haloPen, float upperLeftXInScreen, float upperLeftYInScreen, DrawingLevel drawingLevel);
    public void DrawTextWithWorldCoordinate(string text, GeoFont font, GeoBrush fillBrush, double upperLeftXInWorld, double upperLeftYInWorld, DrawingLevel drawingLevel, DrawingTextAlignment drawingTextAlignment);
    public void DrawTextWithWorldCoordinate(string text, GeoFont font, GeoBrush fillBrush, GeoPen haloPen, double upperLeftXInWorld, double upperLeftYInWorld, DrawingLevel drawingLevel, DrawingTextAlignment drawingTextAlignment);
    public void DrawText(string text, GeoFont font, GeoBrush fillBrush, IEnumerable`1<ScreenPointF> textPathInScreen, DrawingLevel drawingLevel);
    public void DrawText(string text, GeoFont font, GeoBrush fillBrush, GeoPen haloPen, IEnumerable`1<ScreenPointF> textPathInScreen, DrawingLevel drawingLevel, float xOffset, float yOffset, DrawingTextAlignment drawingTextAlignment);
    public void DrawText(string text, GeoFont font, GeoBrush fillBrush, GeoPen haloPen, IEnumerable`1<ScreenPointF> textPathInScreen, DrawingLevel drawingLevel, float xOffset, float yOffset, DrawingTextAlignment drawingTextAlignment, float rotateAngle);
    protected abstract virtual void DrawTextCore(string text, GeoFont font, GeoBrush fillBrush, GeoPen haloPen, IEnumerable`1<ScreenPointF> textPathInScreen, DrawingLevel drawingLevel, float xOffset, float yOffset, DrawingTextAlignment drawingTextAlignment, float rotateAngle);
    public DrawingRectangleF MeasureText(string text, GeoFont font);
    protected abstract virtual DrawingRectangleF MeasureTextCore(string text, GeoFont font);
    public void BeginDrawing(object geoImage, RectangleShape worldExtent, GeographyUnit drawingMapUnit);
    protected abstract virtual void BeginDrawingCore(object nativeImage, RectangleShape worldExtent, GeographyUnit drawingMapUnit);
    public void EndDrawing();
    protected float GetCanvasWidth();
    protected abstract virtual float GetCanvasWidthCore();
    protected float GetCanvasHeight();
    protected abstract virtual float GetCanvasHeightCore();
    public static GeoCanvas CreateDefaultGeoCanvas();
    private void CxU=();
    private void DBU=(string waterMarkedString);
    private List`1<ScreenPointF[]> DRU=(Byte[] areaShapeWkb);
    private int DhU=(ScreenPointF[]& areaPoints, Byte[] wkb, int dataIndex, byte byteOrder);
    private int DxU=(Byte[] lineShapeWkb, int startIndex, float xOffset, float yOffset, DrawingLevel drawingLevel, GeoPen linePen);
    private void EBU=(Double& screenX, Double& screenY);
    private int ERU=(Byte[] centerPointWkb, int startIndex, float width, float height, GeoPen outlinePen, GeoBrush fillBrush, DrawingLevel drawingLevel, float xOffset, float yOffset, PenBrushDrawingOrder penBrushDrawingOrder);
    protected abstract virtual void EndDrawingCore();
    public void Flush();
    protected abstract virtual void FlushCore();
    protected virtual void OnDrawingProgressChanged(DrawingProgressChangedEventArgs e);
    public double MeasureOffset(double offsetInPixel);
    protected virtual double MeasureOffsetCore(double offsetInPixel);
    private bool CBU=();
    internal RectangleShape EhU=(DrawingRectangleF drawingRectangle);
    private GeoPen ExU=(GeoPen pen);
    private static int FBU=(Byte[] wkb, int startIndex, byte byteOrder);
    private static double FRU=(Byte[] wkb, int startIndex, byte byteOrder);
    internal virtual float FhU=(GeoFont font, DrawingTextBaseline textBaseline, string text);
}
public class ThinkGeo.Core.GeocodingCloudClient : CloudClient {
    public GeocodingCloudClient(string clientId, string clientSecret);
    public CloudGeocodingResult Search(string location);
    public CloudGeocodingResult Search(string location, CloudGeocodingOptions options);
    [AsyncStateMachineAttribute("ThinkGeo.Core.GeocodingCloudClient/<SearchAsync>d__4")]
public Task`1<CloudGeocodingResult> SearchAsync(string location);
    [AsyncStateMachineAttribute("ThinkGeo.Core.GeocodingCloudClient/<SearchAsync>d__5")]
public Task`1<CloudGeocodingResult> SearchAsync(string location, CloudGeocodingOptions options);
    public Collection`1<CloudGeocodingResult> Search(IEnumerable`1<string> locations);
    public Collection`1<CloudGeocodingResult> Search(IEnumerable`1<string> locations, CloudGeocodingOptions options);
    [AsyncStateMachineAttribute("ThinkGeo.Core.GeocodingCloudClient/<SearchAsync>d__8")]
public Task`1<Collection`1<CloudGeocodingResult>> SearchAsync(IEnumerable`1<string> locations);
    [AsyncStateMachineAttribute("ThinkGeo.Core.GeocodingCloudClient/<SearchAsync>d__9")]
public Task`1<Collection`1<CloudGeocodingResult>> SearchAsync(IEnumerable`1<string> locations, CloudGeocodingOptions options);
    private CloudGeocodingResult tRQ=(string location, CloudGeocodingOptions options);
    [AsyncStateMachineAttribute("ThinkGeo.Core.GeocodingCloudClient/<SearchCoreAsync>d__11")]
private Task`1<CloudGeocodingResult> thQ=(string location, CloudGeocodingOptions options);
    private Collection`1<CloudGeocodingResult> tRQ=(IEnumerable`1<string> locations, CloudGeocodingOptions options);
    [AsyncStateMachineAttribute("ThinkGeo.Core.GeocodingCloudClient/<SearchCoreAsync>d__13")]
private Task`1<Collection`1<CloudGeocodingResult>> thQ=(IEnumerable`1<string> locations, CloudGeocodingOptions options);
    private static string txQ=(CloudGeocodingOptions options);
    private static string uBQ=(IEnumerable`1<string> locations, CloudGeocodingOptions options);
    private static CloudGeocodingResult uRQ=(WebResponse response);
    private static Collection`1<CloudGeocodingResult> uhQ=(WebResponse response);
}
[ObfuscationAttribute]
public class ThinkGeo.Core.GeocodingLocationDto : object {
    [CompilerGeneratedAttribute]
private LocationPoint <LocationPoint>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Address>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Name>k__BackingField;
    [CompilerGeneratedAttribute]
private string <LocationType>k__BackingField;
    [CompilerGeneratedAttribute]
private string <BoundingBox>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Geometry>k__BackingField;
    [CompilerGeneratedAttribute]
private Dictionary`2<string, string> <Properties>k__BackingField;
    [CompilerGeneratedAttribute]
private Dictionary`2<string, string> <AddressComponents>k__BackingField;
    [CompilerGeneratedAttribute]
private string <HouseNumber>k__BackingField;
    public LocationPoint LocationPoint { get; public set; }
    public string Address { get; public set; }
    public string Name { get; public set; }
    public string LocationType { get; public set; }
    public string BoundingBox { get; public set; }
    public string Geometry { get; public set; }
    public Dictionary`2<string, string> Properties { get; public set; }
    public Dictionary`2<string, string> AddressComponents { get; public set; }
    public string HouseNumber { get; public set; }
    [CompilerGeneratedAttribute]
public LocationPoint get_LocationPoint();
    [CompilerGeneratedAttribute]
public void set_LocationPoint(LocationPoint value);
    [CompilerGeneratedAttribute]
public string get_Address();
    [CompilerGeneratedAttribute]
public void set_Address(string value);
    [CompilerGeneratedAttribute]
public string get_Name();
    [CompilerGeneratedAttribute]
public void set_Name(string value);
    [CompilerGeneratedAttribute]
public string get_LocationType();
    [CompilerGeneratedAttribute]
public void set_LocationType(string value);
    [CompilerGeneratedAttribute]
public string get_BoundingBox();
    [CompilerGeneratedAttribute]
public void set_BoundingBox(string value);
    [CompilerGeneratedAttribute]
public string get_Geometry();
    [CompilerGeneratedAttribute]
public void set_Geometry(string value);
    [CompilerGeneratedAttribute]
public Dictionary`2<string, string> get_Properties();
    [CompilerGeneratedAttribute]
public void set_Properties(Dictionary`2<string, string> value);
    [CompilerGeneratedAttribute]
public Dictionary`2<string, string> get_AddressComponents();
    [CompilerGeneratedAttribute]
public void set_AddressComponents(Dictionary`2<string, string> value);
    [CompilerGeneratedAttribute]
public string get_HouseNumber();
    [CompilerGeneratedAttribute]
public void set_HouseNumber(string value);
    public CloudGeocodingLocation ToGeocodingLocation();
}
[DefaultMemberAttribute("Item")]
public class ThinkGeo.Core.GeoCollection`1 : Collection`1<T> {
    [ObfuscationAttribute]
private Dictionary`2<string, T> dictionary;
    [ObfuscationAttribute]
private Dictionary`2<int, string> mappingCache;
    [CompilerGeneratedAttribute]
private EventHandler`1<InsertingGeoCollectionEventArgs> Inserting;
    [CompilerGeneratedAttribute]
private EventHandler`1<InsertedGeoCollectionEventArgs> Inserted;
    [CompilerGeneratedAttribute]
private EventHandler`1<RemovingGeoCollectionEventArgs> Removing;
    [CompilerGeneratedAttribute]
private EventHandler`1<RemovedGeoCollectionEventArgs> Removed;
    [CompilerGeneratedAttribute]
private EventHandler`1<AddingGeoCollectionEventArgs> Adding;
    [CompilerGeneratedAttribute]
private EventHandler`1<AddedGeoCollectionEventArgs> Added;
    [CompilerGeneratedAttribute]
private EventHandler`1<ClearingItemsGeoCollectionEventArgs> ClearingItems;
    [CompilerGeneratedAttribute]
private EventHandler`1<ClearedItemsGeoCollectionEventArgs> ClearedItems;
    [CompilerGeneratedAttribute]
private EventHandler`1<MovedItemGeoCollectionEventArgs> MovedItem;
    [CompilerGeneratedAttribute]
private NotifyCollectionChangedEventHandler CollectionChanged;
    [CompilerGeneratedAttribute]
private PropertyChangedEventHandler PropertyChanged;
    public T Item { get; public set; }
    [CompilerGeneratedAttribute]
public void add_Inserting(EventHandler`1<InsertingGeoCollectionEventArgs> value);
    [CompilerGeneratedAttribute]
public void remove_Inserting(EventHandler`1<InsertingGeoCollectionEventArgs> value);
    [CompilerGeneratedAttribute]
public void add_Inserted(EventHandler`1<InsertedGeoCollectionEventArgs> value);
    [CompilerGeneratedAttribute]
public void remove_Inserted(EventHandler`1<InsertedGeoCollectionEventArgs> value);
    [CompilerGeneratedAttribute]
public void add_Removing(EventHandler`1<RemovingGeoCollectionEventArgs> value);
    [CompilerGeneratedAttribute]
public void remove_Removing(EventHandler`1<RemovingGeoCollectionEventArgs> value);
    [CompilerGeneratedAttribute]
public void add_Removed(EventHandler`1<RemovedGeoCollectionEventArgs> value);
    [CompilerGeneratedAttribute]
public void remove_Removed(EventHandler`1<RemovedGeoCollectionEventArgs> value);
    [CompilerGeneratedAttribute]
public void add_Adding(EventHandler`1<AddingGeoCollectionEventArgs> value);
    [CompilerGeneratedAttribute]
public void remove_Adding(EventHandler`1<AddingGeoCollectionEventArgs> value);
    [CompilerGeneratedAttribute]
public void add_Added(EventHandler`1<AddedGeoCollectionEventArgs> value);
    [CompilerGeneratedAttribute]
public void remove_Added(EventHandler`1<AddedGeoCollectionEventArgs> value);
    [CompilerGeneratedAttribute]
public void add_ClearingItems(EventHandler`1<ClearingItemsGeoCollectionEventArgs> value);
    [CompilerGeneratedAttribute]
public void remove_ClearingItems(EventHandler`1<ClearingItemsGeoCollectionEventArgs> value);
    [CompilerGeneratedAttribute]
public void add_ClearedItems(EventHandler`1<ClearedItemsGeoCollectionEventArgs> value);
    [CompilerGeneratedAttribute]
public void remove_ClearedItems(EventHandler`1<ClearedItemsGeoCollectionEventArgs> value);
    [CompilerGeneratedAttribute]
public void add_MovedItem(EventHandler`1<MovedItemGeoCollectionEventArgs> value);
    [CompilerGeneratedAttribute]
public void remove_MovedItem(EventHandler`1<MovedItemGeoCollectionEventArgs> value);
    protected virtual void OnInserting(InsertingGeoCollectionEventArgs e);
    protected virtual void OnInserted(InsertedGeoCollectionEventArgs e);
    protected virtual void OnRemoving(RemovingGeoCollectionEventArgs e);
    protected virtual void OnRemoved(RemovedGeoCollectionEventArgs e);
    protected virtual void OnAdding(AddingGeoCollectionEventArgs e);
    protected virtual void OnAdded(AddedGeoCollectionEventArgs e);
    protected virtual void OnClearingItems(ClearingItemsGeoCollectionEventArgs e);
    protected virtual void OnClearedItems(ClearedItemsGeoCollectionEventArgs e);
    protected virtual void OnMovedItem(MovedItemGeoCollectionEventArgs e);
    public T get_Item(string key);
    public void set_Item(string key, T value);
    public Collection`1<string> GetKeys();
    public void Add(string key, T item);
    public void Add(T item);
    public void Insert(int index, T item);
    protected virtual void InsertItem(int index, T item);
    public void Insert(int index, string key, T item);
    public void Remove(string key);
    protected virtual void RemoveItem(int index);
    public void MoveUp(int index);
    public void MoveUp(string key);
    public void MoveUp(T item);
    public void MoveDown(int index);
    public void MoveDown(string key);
    public void MoveDown(T item);
    public void MoveToTop(int index);
    public void MoveToTop(string key);
    public void MoveToTop(T item);
    public void MoveToBottom(int index);
    public void MoveToBottom(string key);
    public void MoveToBottom(T item);
    public void MoveTo(int fromIndex, int toIndex);
    public void MoveTo(string key, int toIndex);
    public void MoveTo(T item, int toIndex);
    public bool Contains(string key);
    protected virtual void ClearItems();
    protected virtual void SetItem(int index, T item);
    private int fxU=(string key);
    private string gBU=(T item);
    private void gRU=(string key);
    [CompilerGeneratedAttribute]
public sealed virtual void add_CollectionChanged(NotifyCollectionChangedEventHandler value);
    [CompilerGeneratedAttribute]
public sealed virtual void remove_CollectionChanged(NotifyCollectionChangedEventHandler value);
    protected virtual void OnCollectionChanged(NotifyCollectionChangedEventArgs e);
    [CompilerGeneratedAttribute]
public sealed virtual void add_PropertyChanged(PropertyChangedEventHandler value);
    [CompilerGeneratedAttribute]
public sealed virtual void remove_PropertyChanged(PropertyChangedEventHandler value);
    protected virtual void OnPropertyChanged(PropertyChangedEventArgs e);
}
[DebuggerDisplayAttribute("{NameAndARGBValue}")]
public class ThinkGeo.Core.GeoColor : object {
    private static float XxU=;
    private static float YBU=;
    private static float YRU=;
    private static float YhU=;
    [ObfuscationAttribute]
private byte alphaComponent;
    [ObfuscationAttribute]
private byte redComponent;
    [ObfuscationAttribute]
private byte greenComponent;
    [ObfuscationAttribute]
private byte blueComponent;
    [ObfuscationAttribute]
private string name;
    [ObfuscationAttribute]
private ColorType colorType;
    [ObfuscationAttribute]
private static Random random;
    private static Regex YxU=;
    private static Regex ZBU=;
    private static Regex ZRU=;
    private static Regex ZhU=;
    public bool IsTransparent { get; }
    public string HtmlColor { get; public set; }
    public string Ahsl { get; public set; }
    public string Argb { get; public set; }
    public byte A { get; public set; }
    public byte R { get; public set; }
    public byte G { get; public set; }
    public byte B { get; public set; }
    public float Hue { get; }
    public float Saturation { get; }
    public float Luminance { get; }
    [ObfuscationAttribute]
private string NameAndARGBValue { get; }
    public GeoColor(byte red, byte green, byte blue);
    public GeoColor(byte alpha, byte red, byte green, byte blue);
    public GeoColor(byte alpha, GeoColor color);
    internal GeoColor(string name, ColorType colorType, byte alpha, byte red, byte green, byte blue);
    private static GeoColor();
    public bool get_IsTransparent();
    public string get_HtmlColor();
    public void set_HtmlColor(string value);
    public string get_Ahsl();
    public void set_Ahsl(string value);
    public string get_Argb();
    public void set_Argb(string value);
    public byte get_A();
    public void set_A(byte value);
    public byte get_R();
    public void set_R(byte value);
    public byte get_G();
    public void set_G(byte value);
    public byte get_B();
    public void set_B(byte value);
    public float get_Hue();
    public float get_Saturation();
    public float get_Luminance();
    private string get_NameAndARGBValue();
    public static Collection`1<GeoColor> GetColorsInHueFamily(GeoColor baseColor, int numbersOfColors);
    private static float ZxU=(float saturation, float ratio);
    private static float aBU=(float luminance, float ratio);
    public static Collection`1<GeoColor> GetColorsInQualityFamily(GeoColor baseColor, int numberOfColors);
    public static Collection`1<GeoColor> GetColorsInQualityFamily(GeoColor fromColor, GeoColor toColor, int numberOfColors, ColorWheelDirection colorWheelDirection);
    private static float aRU=(float hue, float ratio);
    public static GeoColor FromArgb(byte alpha, byte red, byte green, byte blue);
    public static GeoColor FromArgb(byte alpha, GeoColor baseColor);
    public static GeoColor FromAhsl(int alpha, float hue, float saturation, float luminance);
    public static GeoColor FromOle(int oleColor);
    public static GeoColor FromHtml(string htmlColor);
    internal static GeoColor ahU=(string colorExpression);
    private static string axU=(string htmlColor);
    private static GeoColor bBU=(string htmlColor);
    public static GeoColor GetRandomGeoColor(RandomColorType colorType);
    public static GeoColor GetRandomGeoColor(byte alpha, RandomColorType colorType);
    public static GeoColor FromWin32(int win32Color);
    public static int ToOle(GeoColor color);
    public static string ToHtml(GeoColor color);
    public static int ToWin32(GeoColor color);
    public virtual string ToString();
    public static bool op_Equality(GeoColor geoColor1, GeoColor geoColor2);
    public static bool op_Inequality(GeoColor geoColor1, GeoColor geoColor2);
    public virtual bool Equals(object obj);
    private bool bRU=(GeoColor compareObj);
    public virtual int GetHashCode();
    private static GeoColor bhU=(float hueIn0To360Format, float saturation, float luminance);
    private static byte bxU=(double v1, double v2, double vH);
    private static void cBU=(GeoColor geoColor, Single& hue, Single& saturation, Single& luminance);
    [CompilerGeneratedAttribute]
internal static Double[] <Parse>g__GetNubmers|62_0(GroupCollection groups);
}
public static class ThinkGeo.Core.GeoColors : object {
    public static GeoColor Sand { get; }
    public static GeoColor Grass { get; }
    public static GeoColor Dirt { get; }
    public static GeoColor Mountains { get; }
    public static GeoColor Lake { get; }
    public static GeoColor DeepOcean { get; }
    public static GeoColor ShallowOcean { get; }
    public static GeoColor Tundra { get; }
    public static GeoColor Forest { get; }
    public static GeoColor Ice { get; }
    public static GeoColor Swamp { get; }
    public static GeoColor Road { get; }
    public static GeoColor Highway { get; }
    public static GeoColor InnerState { get; }
    public static GeoColor LocalRoad { get; }
    public static GeoColor MajorRoad { get; }
    public static GeoColor ActiveBorder { get; }
    public static GeoColor ActiveCaption { get; }
    public static GeoColor ActiveCaptionText { get; }
    public static GeoColor AppWorkspace { get; }
    public static GeoColor Control { get; }
    public static GeoColor ControlDark { get; }
    public static GeoColor ControlDarkDark { get; }
    public static GeoColor ControlLight { get; }
    public static GeoColor ControlLightLight { get; }
    public static GeoColor ControlText { get; }
    public static GeoColor Desktop { get; }
    public static GeoColor GrayText { get; }
    public static GeoColor Highlight { get; }
    public static GeoColor HighlightText { get; }
    public static GeoColor HotTrack { get; }
    public static GeoColor InactiveBorder { get; }
    public static GeoColor InactiveCaption { get; }
    public static GeoColor InactiveCaptionText { get; }
    public static GeoColor Info { get; }
    public static GeoColor InfoText { get; }
    public static GeoColor Menu { get; }
    public static GeoColor MenuText { get; }
    public static GeoColor ScrollBar { get; }
    public static GeoColor Window { get; }
    public static GeoColor WindowFrame { get; }
    public static GeoColor WindowText { get; }
    public static GeoColor Transparent { get; }
    public static GeoColor AliceBlue { get; }
    public static GeoColor AntiqueWhite { get; }
    public static GeoColor Aqua { get; }
    public static GeoColor Aquamarine { get; }
    public static GeoColor Azure { get; }
    public static GeoColor Beige { get; }
    public static GeoColor Bisque { get; }
    public static GeoColor Black { get; }
    public static GeoColor BlanchedAlmond { get; }
    public static GeoColor Blue { get; }
    public static GeoColor BlueViolet { get; }
    public static GeoColor Brown { get; }
    public static GeoColor BurlyWood { get; }
    public static GeoColor CadetBlue { get; }
    public static GeoColor Chartreuse { get; }
    public static GeoColor Chocolate { get; }
    public static GeoColor Coral { get; }
    public static GeoColor CornflowerBlue { get; }
    public static GeoColor Cornsilk { get; }
    public static GeoColor Crimson { get; }
    public static GeoColor Cyan { get; }
    public static GeoColor DarkBlue { get; }
    public static GeoColor DarkCyan { get; }
    public static GeoColor DarkGoldenrod { get; }
    public static GeoColor DarkGray { get; }
    public static GeoColor DarkGreen { get; }
    public static GeoColor DarkKhaki { get; }
    public static GeoColor DarkMagenta { get; }
    public static GeoColor DarkOliveGreen { get; }
    public static GeoColor DarkOrange { get; }
    public static GeoColor DarkOrchid { get; }
    public static GeoColor DarkRed { get; }
    public static GeoColor DarkSalmon { get; }
    public static GeoColor DarkSeaGreen { get; }
    public static GeoColor DarkSlateBlue { get; }
    public static GeoColor DarkSlateGray { get; }
    public static GeoColor DarkTurquoise { get; }
    public static GeoColor DarkViolet { get; }
    public static GeoColor DeepPink { get; }
    public static GeoColor DeepSkyBlue { get; }
    public static GeoColor DimGray { get; }
    public static GeoColor DodgerBlue { get; }
    public static GeoColor Firebrick { get; }
    public static GeoColor FloralWhite { get; }
    public static GeoColor ForestGreen { get; }
    public static GeoColor Fuchsia { get; }
    public static GeoColor Gainsboro { get; }
    public static GeoColor GhostWhite { get; }
    public static GeoColor Gold { get; }
    public static GeoColor Goldenrod { get; }
    public static GeoColor Gray { get; }
    public static GeoColor Green { get; }
    public static GeoColor GreenYellow { get; }
    public static GeoColor Honeydew { get; }
    public static GeoColor HotPink { get; }
    public static GeoColor IndianRed { get; }
    public static GeoColor Indigo { get; }
    public static GeoColor Ivory { get; }
    public static GeoColor Khaki { get; }
    public static GeoColor Lavender { get; }
    public static GeoColor LavenderBlush { get; }
    public static GeoColor LawnGreen { get; }
    public static GeoColor LemonChiffon { get; }
    public static GeoColor LightBlue { get; }
    public static GeoColor LightCoral { get; }
    public static GeoColor LightCyan { get; }
    public static GeoColor LightGoldenrodYellow { get; }
    public static GeoColor LightGray { get; }
    public static GeoColor LightGreen { get; }
    public static GeoColor LightPink { get; }
    public static GeoColor LightSalmon { get; }
    public static GeoColor LightSeaGreen { get; }
    public static GeoColor LightSkyBlue { get; }
    public static GeoColor LightSlateGray { get; }
    public static GeoColor LightSteelBlue { get; }
    public static GeoColor LightYellow { get; }
    public static GeoColor Lime { get; }
    public static GeoColor LimeGreen { get; }
    public static GeoColor Linen { get; }
    public static GeoColor Magenta { get; }
    public static GeoColor Maroon { get; }
    public static GeoColor MediumAquamarine { get; }
    public static GeoColor MediumBlue { get; }
    public static GeoColor MediumOrchid { get; }
    public static GeoColor MediumPurple { get; }
    public static GeoColor MediumSeaGreen { get; }
    public static GeoColor MediumSlateBlue { get; }
    public static GeoColor MediumSpringGreen { get; }
    public static GeoColor MediumTurquoise { get; }
    public static GeoColor MediumVioletRed { get; }
    public static GeoColor MidnightBlue { get; }
    public static GeoColor MintCream { get; }
    public static GeoColor MistyRose { get; }
    public static GeoColor Moccasin { get; }
    public static GeoColor NavajoWhite { get; }
    public static GeoColor Navy { get; }
    public static GeoColor OldLace { get; }
    public static GeoColor Olive { get; }
    public static GeoColor OliveDrab { get; }
    public static GeoColor Orange { get; }
    public static GeoColor OrangeRed { get; }
    public static GeoColor Orchid { get; }
    public static GeoColor PaleGoldenrod { get; }
    public static GeoColor PaleGreen { get; }
    public static GeoColor PaleTurquoise { get; }
    public static GeoColor PaleVioletRed { get; }
    public static GeoColor PapayaWhip { get; }
    public static GeoColor PeachPuff { get; }
    public static GeoColor Peru { get; }
    public static GeoColor Pink { get; }
    public static GeoColor Plum { get; }
    public static GeoColor PowderBlue { get; }
    public static GeoColor Purple { get; }
    public static GeoColor Red { get; }
    public static GeoColor RosyBrown { get; }
    public static GeoColor RoyalBlue { get; }
    public static GeoColor SaddleBrown { get; }
    public static GeoColor Salmon { get; }
    public static GeoColor SandyBrown { get; }
    public static GeoColor SeaGreen { get; }
    public static GeoColor SeaShell { get; }
    public static GeoColor Sienna { get; }
    public static GeoColor Silver { get; }
    public static GeoColor SkyBlue { get; }
    public static GeoColor SlateBlue { get; }
    public static GeoColor SlateGray { get; }
    public static GeoColor Snow { get; }
    public static GeoColor SpringGreen { get; }
    public static GeoColor SteelBlue { get; }
    public static GeoColor Tan { get; }
    public static GeoColor Teal { get; }
    public static GeoColor Thistle { get; }
    public static GeoColor Tomato { get; }
    public static GeoColor Turquoise { get; }
    public static GeoColor Violet { get; }
    public static GeoColor Wheat { get; }
    public static GeoColor White { get; }
    public static GeoColor WhiteSmoke { get; }
    public static GeoColor Yellow { get; }
    public static GeoColor YellowGreen { get; }
    public static GeoColor ButtonFace { get; }
    public static GeoColor ButtonHighlight { get; }
    public static GeoColor ButtonShadow { get; }
    public static GeoColor GradientActiveCaption { get; }
    public static GeoColor GradientInactiveCaption { get; }
    public static GeoColor MenuBar { get; }
    public static GeoColor MenuHighlight { get; }
    public static GeoColor DarkYellow { get; }
    public static GeoColor LightRed { get; }
    public static GeoColor LightOrange { get; }
    public static GeoColor PaleRed { get; }
    public static GeoColor PaleBlue { get; }
    public static GeoColor PaleYellow { get; }
    public static GeoColor PaleOrange { get; }
    public static GeoColor BrightRed { get; }
    public static GeoColor BrightBlue { get; }
    public static GeoColor BrightYellow { get; }
    public static GeoColor BrightGreen { get; }
    public static GeoColor BrightOrange { get; }
    public static GeoColor PastelRed { get; }
    public static GeoColor PastelBlue { get; }
    public static GeoColor PastelYellow { get; }
    public static GeoColor PastelGreen { get; }
    public static GeoColor PastelOrange { get; }
    public static GeoColor Copper { get; }
    public static GeoColor get_Sand();
    public static GeoColor get_Grass();
    public static GeoColor get_Dirt();
    public static GeoColor get_Mountains();
    public static GeoColor get_Lake();
    public static GeoColor get_DeepOcean();
    public static GeoColor get_ShallowOcean();
    public static GeoColor get_Tundra();
    public static GeoColor get_Forest();
    public static GeoColor get_Ice();
    public static GeoColor get_Swamp();
    public static GeoColor get_Road();
    public static GeoColor get_Highway();
    public static GeoColor get_InnerState();
    public static GeoColor get_LocalRoad();
    public static GeoColor get_MajorRoad();
    public static GeoColor get_ActiveBorder();
    public static GeoColor get_ActiveCaption();
    public static GeoColor get_ActiveCaptionText();
    public static GeoColor get_AppWorkspace();
    public static GeoColor get_Control();
    public static GeoColor get_ControlDark();
    public static GeoColor get_ControlDarkDark();
    public static GeoColor get_ControlLight();
    public static GeoColor get_ControlLightLight();
    public static GeoColor get_ControlText();
    public static GeoColor get_Desktop();
    public static GeoColor get_GrayText();
    public static GeoColor get_Highlight();
    public static GeoColor get_HighlightText();
    public static GeoColor get_HotTrack();
    public static GeoColor get_InactiveBorder();
    public static GeoColor get_InactiveCaption();
    public static GeoColor get_InactiveCaptionText();
    public static GeoColor get_Info();
    public static GeoColor get_InfoText();
    public static GeoColor get_Menu();
    public static GeoColor get_MenuText();
    public static GeoColor get_ScrollBar();
    public static GeoColor get_Window();
    public static GeoColor get_WindowFrame();
    public static GeoColor get_WindowText();
    public static GeoColor get_Transparent();
    public static GeoColor get_AliceBlue();
    public static GeoColor get_AntiqueWhite();
    public static GeoColor get_Aqua();
    public static GeoColor get_Aquamarine();
    public static GeoColor get_Azure();
    public static GeoColor get_Beige();
    public static GeoColor get_Bisque();
    public static GeoColor get_Black();
    public static GeoColor get_BlanchedAlmond();
    public static GeoColor get_Blue();
    public static GeoColor get_BlueViolet();
    public static GeoColor get_Brown();
    public static GeoColor get_BurlyWood();
    public static GeoColor get_CadetBlue();
    public static GeoColor get_Chartreuse();
    public static GeoColor get_Chocolate();
    public static GeoColor get_Coral();
    public static GeoColor get_CornflowerBlue();
    public static GeoColor get_Cornsilk();
    public static GeoColor get_Crimson();
    public static GeoColor get_Cyan();
    public static GeoColor get_DarkBlue();
    public static GeoColor get_DarkCyan();
    public static GeoColor get_DarkGoldenrod();
    public static GeoColor get_DarkGray();
    public static GeoColor get_DarkGreen();
    public static GeoColor get_DarkKhaki();
    public static GeoColor get_DarkMagenta();
    public static GeoColor get_DarkOliveGreen();
    public static GeoColor get_DarkOrange();
    public static GeoColor get_DarkOrchid();
    public static GeoColor get_DarkRed();
    public static GeoColor get_DarkSalmon();
    public static GeoColor get_DarkSeaGreen();
    public static GeoColor get_DarkSlateBlue();
    public static GeoColor get_DarkSlateGray();
    public static GeoColor get_DarkTurquoise();
    public static GeoColor get_DarkViolet();
    public static GeoColor get_DeepPink();
    public static GeoColor get_DeepSkyBlue();
    public static GeoColor get_DimGray();
    public static GeoColor get_DodgerBlue();
    public static GeoColor get_Firebrick();
    public static GeoColor get_FloralWhite();
    public static GeoColor get_ForestGreen();
    public static GeoColor get_Fuchsia();
    public static GeoColor get_Gainsboro();
    public static GeoColor get_GhostWhite();
    public static GeoColor get_Gold();
    public static GeoColor get_Goldenrod();
    public static GeoColor get_Gray();
    public static GeoColor get_Green();
    public static GeoColor get_GreenYellow();
    public static GeoColor get_Honeydew();
    public static GeoColor get_HotPink();
    public static GeoColor get_IndianRed();
    public static GeoColor get_Indigo();
    public static GeoColor get_Ivory();
    public static GeoColor get_Khaki();
    public static GeoColor get_Lavender();
    public static GeoColor get_LavenderBlush();
    public static GeoColor get_LawnGreen();
    public static GeoColor get_LemonChiffon();
    public static GeoColor get_LightBlue();
    public static GeoColor get_LightCoral();
    public static GeoColor get_LightCyan();
    public static GeoColor get_LightGoldenrodYellow();
    public static GeoColor get_LightGray();
    public static GeoColor get_LightGreen();
    public static GeoColor get_LightPink();
    public static GeoColor get_LightSalmon();
    public static GeoColor get_LightSeaGreen();
    public static GeoColor get_LightSkyBlue();
    public static GeoColor get_LightSlateGray();
    public static GeoColor get_LightSteelBlue();
    public static GeoColor get_LightYellow();
    public static GeoColor get_Lime();
    public static GeoColor get_LimeGreen();
    public static GeoColor get_Linen();
    public static GeoColor get_Magenta();
    public static GeoColor get_Maroon();
    public static GeoColor get_MediumAquamarine();
    public static GeoColor get_MediumBlue();
    public static GeoColor get_MediumOrchid();
    public static GeoColor get_MediumPurple();
    public static GeoColor get_MediumSeaGreen();
    public static GeoColor get_MediumSlateBlue();
    public static GeoColor get_MediumSpringGreen();
    public static GeoColor get_MediumTurquoise();
    public static GeoColor get_MediumVioletRed();
    public static GeoColor get_MidnightBlue();
    public static GeoColor get_MintCream();
    public static GeoColor get_MistyRose();
    public static GeoColor get_Moccasin();
    public static GeoColor get_NavajoWhite();
    public static GeoColor get_Navy();
    public static GeoColor get_OldLace();
    public static GeoColor get_Olive();
    public static GeoColor get_OliveDrab();
    public static GeoColor get_Orange();
    public static GeoColor get_OrangeRed();
    public static GeoColor get_Orchid();
    public static GeoColor get_PaleGoldenrod();
    public static GeoColor get_PaleGreen();
    public static GeoColor get_PaleTurquoise();
    public static GeoColor get_PaleVioletRed();
    public static GeoColor get_PapayaWhip();
    public static GeoColor get_PeachPuff();
    public static GeoColor get_Peru();
    public static GeoColor get_Pink();
    public static GeoColor get_Plum();
    public static GeoColor get_PowderBlue();
    public static GeoColor get_Purple();
    public static GeoColor get_Red();
    public static GeoColor get_RosyBrown();
    public static GeoColor get_RoyalBlue();
    public static GeoColor get_SaddleBrown();
    public static GeoColor get_Salmon();
    public static GeoColor get_SandyBrown();
    public static GeoColor get_SeaGreen();
    public static GeoColor get_SeaShell();
    public static GeoColor get_Sienna();
    public static GeoColor get_Silver();
    public static GeoColor get_SkyBlue();
    public static GeoColor get_SlateBlue();
    public static GeoColor get_SlateGray();
    public static GeoColor get_Snow();
    public static GeoColor get_SpringGreen();
    public static GeoColor get_SteelBlue();
    public static GeoColor get_Tan();
    public static GeoColor get_Teal();
    public static GeoColor get_Thistle();
    public static GeoColor get_Tomato();
    public static GeoColor get_Turquoise();
    public static GeoColor get_Violet();
    public static GeoColor get_Wheat();
    public static GeoColor get_White();
    public static GeoColor get_WhiteSmoke();
    public static GeoColor get_Yellow();
    public static GeoColor get_YellowGreen();
    public static GeoColor get_ButtonFace();
    public static GeoColor get_ButtonHighlight();
    public static GeoColor get_ButtonShadow();
    public static GeoColor get_GradientActiveCaption();
    public static GeoColor get_GradientInactiveCaption();
    public static GeoColor get_MenuBar();
    public static GeoColor get_MenuHighlight();
    public static GeoColor get_DarkYellow();
    public static GeoColor get_LightRed();
    public static GeoColor get_LightOrange();
    public static GeoColor get_PaleRed();
    public static GeoColor get_PaleBlue();
    public static GeoColor get_PaleYellow();
    public static GeoColor get_PaleOrange();
    public static GeoColor get_BrightRed();
    public static GeoColor get_BrightBlue();
    public static GeoColor get_BrightYellow();
    public static GeoColor get_BrightGreen();
    public static GeoColor get_BrightOrange();
    public static GeoColor get_PastelRed();
    public static GeoColor get_PastelBlue();
    public static GeoColor get_PastelYellow();
    public static GeoColor get_PastelGreen();
    public static GeoColor get_PastelOrange();
    public static GeoColor get_Copper();
}
public enum ThinkGeo.Core.GeoColorType : Enum {
    public int value__;
    public static GeoColorType Unknown;
    public static GeoColorType Alpha8;
    public static GeoColorType Rgb565;
    public static GeoColorType Argb4444;
    public static GeoColorType Rgba8888;
    public static GeoColorType Rgb888x;
    public static GeoColorType Bgra8888;
    public static GeoColorType Rgba1010102;
    public static GeoColorType Rgb101010x;
    public static GeoColorType Gray8;
    public static GeoColorType RgbaF16;
}
public enum ThinkGeo.Core.GeoDashCap : Enum {
    public int value__;
    public static GeoDashCap Flat;
    public static GeoDashCap Round;
    public static GeoDashCap Triangle;
    public static GeoDashCap Square;
}
public class ThinkGeo.Core.GeoDbf : object {
    private static string YB4=;
    private static string YR4=;
    private static Dictionary`2<string, string> Yh4=;
    [ObfuscationAttribute]
private FileAccess readWriteMode;
    [ObfuscationAttribute]
private Dictionary`2<string, int> fieldNameCache;
    [ObfuscationAttribute]
private List`1<string> VFPSupportColumnNames;
    private static int Yx4=;
    private static int ZB4=;
    private static int ZR4=;
    private static int Zh4=;
    private static byte Zx4=;
    private static byte aB4=;
    private static byte aR4=;
    private static byte ah4=;
    private static byte ax4=;
    private static byte bB4=;
    private static byte bR4=;
    private static byte bh4=;
    private static byte bx4=;
    private static byte cB4=;
    private static byte cR4=;
    private static byte ch4=;
    private static byte cx4=;
    private static byte dB4=;
    private static byte dR4=;
    private static byte dh4=;
    private static byte dx4=;
    private static byte eB4=;
    private static byte eR4=;
    private static byte eh4=;
    private static byte ex4=;
    private static int fB4=;
    private static int fR4=;
    private static int fh4=;
    private static int fx4=;
    private static int gB4=;
    private static string gR4=;
    private static string gh4=;
    private static string gx4=;
    private static string hB4=;
    private static string hR4=;
    private static string hh4=;
    private static string hx4=;
    private static string iB4=;
    private static string iR4=;
    private static string ih4=;
    private static string ix4=;
    private static string jB4=;
    private static string jR4=;
    private static string jh4=;
    private static string jx4=;
    private static string kB4=;
    private static string kR4=;
    private static string kh4=;
    private static string kx4=;
    private static string lB4=;
    private static string lR4=;
    private static string lh4=;
    private static string lx4=;
    private static string mB4=;
    private static string mR4=;
    private static string mh4=;
    private static string mx4=;
    private static string nB4=;
    private static string nR4=;
    private static string nh4=;
    private static string nx4=;
    private static string oB4=;
    private static string oR4=;
    private static string oh4=;
    private static string ox4=;
    private static string pB4=;
    private static string pR4=;
    private static string ph4=;
    private static string px4=;
    private static string qB4=;
    private static string qR4=;
    [CompilerGeneratedAttribute]
private EventHandler`1<StreamLoadingEventArgs> StreamLoading;
    [ObfuscationAttribute]
private bool needDBC;
    [ObfuscationAttribute]
private bool isOpenMemoFile;
    [ObfuscationAttribute]
private bool isUsingFPTMemoFile;
    [ObfuscationAttribute]
private string pathFilename;
    [ObfuscationAttribute]
private string dbtFileName;
    private Stream qh4=;
    private Stream qx4=;
    [ObfuscationAttribute]
private int recordCount;
    [ObfuscationAttribute]
private int recordLength;
    [ObfuscationAttribute]
private int headerLength;
    [ObfuscationAttribute]
private int columnCount;
    [ObfuscationAttribute]
private bool isClosed;
    [ObfuscationAttribute]
private ArrayList fieldsHeader;
    [ObfuscationAttribute]
private Byte[] headerBytes;
    [ObfuscationAttribute]
private bool isCurrentRecordModified;
    [ObfuscationAttribute]
private int currentRecord;
    [ObfuscationAttribute]
private Byte[] currentRecords;
    [ObfuscationAttribute]
private ArrayList deletedItems;
    [ObfuscationAttribute]
private ArrayList originalIndexes;
    [ObfuscationAttribute]
private ArrayList newIndexes;
    [ObfuscationAttribute]
private string password;
    [ObfuscationAttribute]
private bool isFileDetached;
    [ObfuscationAttribute]
private bool haveMemoField;
    [ObfuscationAttribute]
private bool isUpdated;
    [ObfuscationAttribute]
private bool isFieldUpdated;
    [ObfuscationAttribute]
private bool isCreating;
    private Encoding rB4=;
    [ObfuscationAttribute]
private CultureInfo cultureInfo;
    [ObfuscationAttribute]
private int startPosition;
    public bool IsOpen { get; }
    public int ColumnCount { get; }
    public int RecordCount { get; }
    public string PathFilename { get; public set; }
    public FileAccess ReadWriteMode { get; public set; }
    public Encoding Encoding { get; public set; }
    public CultureInfo CultureInfo { get; public set; }
    public GeoDbf(string pathFilename);
    public GeoDbf(string pathFilename, FileAccess readWriteMode);
    public GeoDbf(string pathFilename, FileAccess readWriteMode, Encoding encoding);
    public GeoDbf(string pathFilename, FileAccess readWriteMode, Encoding encoding, CultureInfo cultureInfo);
    private static GeoDbf();
    [CompilerGeneratedAttribute]
public void add_StreamLoading(EventHandler`1<StreamLoadingEventArgs> value);
    [CompilerGeneratedAttribute]
public void remove_StreamLoading(EventHandler`1<StreamLoadingEventArgs> value);
    protected virtual void OnStreamLoading(StreamLoadingEventArgs e);
    public bool get_IsOpen();
    public int get_ColumnCount();
    public int get_RecordCount();
    public string get_PathFilename();
    public void set_PathFilename(string value);
    public FileAccess get_ReadWriteMode();
    public void set_ReadWriteMode(FileAccess value);
    public Encoding get_Encoding();
    public void set_Encoding(Encoding value);
    public CultureInfo get_CultureInfo();
    public void set_CultureInfo(CultureInfo value);
    protected virtual override void Finalize();
    public sealed virtual void Dispose();
    public static void CopyDbfHeader(string sourcePathFilename, string destinationPathFilename);
    public static void CopyDbfHeader(string sourcePathFilename, string destinationPathFilename, OverwriteMode overwriteMode);
    public static void CreateDbfFile(string dbfPathFilename, IEnumerable`1<DbfColumn> dbfColumns);
    public static void CreateDbfFile(string dbfPathFilename, IEnumerable`1<DbfColumn> dbfColumns, OverwriteMode overwriteMode);
    public static void CreateDbfFile(string dbfPathFilename, IEnumerable`1<DbfColumn> dbfColumns, OverwriteMode overwriteMode, Encoding encoding);
    public DbfColumn GetColumn(string columnName);
    public DbfColumn GetColumn(int columnNumber);
    public Dictionary`2<string, object> ReadRecord(int recordNumber);
    public bool ReadFieldAsBoolean(int recordNumber, int columnNumber);
    public bool ReadFieldAsBoolean(int recordNumber, string columnName);
    private Nullable`1<bool> rR4=(int recordNumber, int columnNumber);
    private Nullable`1<bool> rR4=(int recordNumber, string columnName);
    private Nullable`1<DateTime> rh4=(int recordNumber, string columnName);
    public DateTime ReadFieldAsDateTime(int recordNumber, string columnName);
    public DateTime ReadFieldAsDateTime(int recordNumber, int columnNumber);
    public double ReadFieldAsDouble(int recordNumber, string columnName);
    public double ReadFieldAsDouble(int recordNumber, int columnNumber);
    public int ReadFieldAsInteger(int recordNumber, int columnNumber);
    public int ReadFieldAsInteger(int recordNumber, string columnName);
    public string ReadFieldAsString(int recordNumber, string columnName);
    public string ReadFieldAsString(int recordNumber, int columnNumber);
    public void WriteField(int recordNumber, string columnName, double value);
    public void WriteField(int recordNumber, int columnNumber, int value);
    public void WriteField(int recordNumber, string columnName, bool value);
    public void WriteField(int recordNumber, int columnNumber, double value);
    public void WriteField(int recordNumber, string columnName, int value);
    public void WriteField(int recordNumber, int columnNumber, string value);
    public void WriteField(int recordNumber, string columnName, string value);
    public void WriteField(int recordNumber, int columnNumber, bool value);
    public void WriteField(int recordNumber, int columnNumber, DateTime value);
    public void WriteField(int recordNumber, string columnName, DateTime value);
    public void Open();
    public void Close();
    public void Flush();
    public void Pack();
    public int GetColumnNumber(string columnName);
    public string GetColumnName(int columnNumber);
    public void DeleteRecord(int recordNumber);
    public void UpdateColumnName(int columnNumber, string newColumnName);
    public void UndeleteRecord(int recordNumber);
    public bool IsRecordDeleted(int recordNumber);
    public void AddEmptyRecord();
    public Dictionary`2<string, string> ReadRecordAsString(int recordNumber);
    public void WriteRecord(int recordNumber, IEnumerable`1<object> values);
    public static Collection`1<DbfColumn> GetValidColumns(IEnumerable`1<DbfColumn> columns);
    public static Collection`1<DbfColumn> GetValidColumns(IEnumerable`1<DbfColumn> columns, Encoding encoding);
    public static Collection`1<string> GetValidColumnNames(IEnumerable`1<string> columnNames);
    public static Collection`1<string> GetValidColumnNames(IEnumerable`1<string> columnNames, Encoding encoding);
    private static string rx4=(string baseString, int repeatNumber, Encoding encoding);
    private void sB4=(FileMode fileMode, FileAccess readWriteMode);
    public void AddStringColumn(string columnName, int length);
    public void AddIntegerColumn(string columnName, int length);
    public void AddDoubleColumn(string columnName, int length, int decimalLength);
    public void AddBooleanColumn(string columnName);
    public void AddMemoColumn(string columnName, int length);
    public void AddDateColumn(string columnName);
    internal void sR4=(string columnName);
    public void UpdateDbcFilename(string newDbcFilename);
    public void AddColumn(string columnName, DbfColumnType columnType, int length, int decimalLength);
    private static string sh4=(string columnName, int length);
    private bool sx4=(string columnName);
    private Collection`1<DbfColumn> tB4=();
    private DbfColumnType tR4=(string fieldName);
    private DbfColumnType tR4=(int fieldIndex);
    private int th4=(string fieldName);
    private int th4=(int fieldIndex);
    private int tx4=(string fieldName);
    private int tx4=(int fieldIndex);
    private string uB4=(int recordIndex, int fieldIndex);
    private static string uR4=(Byte[] result, DbfColumnType type);
    private static string uh4=(Byte[] result);
    private static string ux4=(Byte[] result);
    private static Byte[] vB4=(string datetime);
    private static string vR4=(Byte[] result);
    private string uB4=(int recordIndex, string fieldName);
    private void vh4=(int recordIndex, int fieldIndex, object value);
    private void vh4=(int recordIndex, string fieldName, object value);
    private GeoDbf vx4=(string newPathFilename);
    private void wB4=(string fileName, FileAccess access);
    private static string wR4=(string currentFileName);
    private static Encoding wh4=(string ldid);
    private Stream wx4=(string fileName, FileMode fileMode, FileAccess readWriteMode);
    private Stream xB4=(string fileName, FileMode fileMode, FileAccess readWriteMode);
    private void xR4=(string fileName, FileMode mode, FileAccess access, string strPassWord);
    private void xh4=(string fileName, FileAccess access);
    private void xx4=();
    private void yB4=(Byte[] arrFileHeader, GeoDbf dbfFile);
    private void yR4=(Byte[] arrHeader, GeoDbf dbfFile);
    private void yh4=(string dbcFilePath, String[] columnNames);
    private string yx4=(int iRecord, int iField);
    private string zB4=(Byte[] bytesIn);
    private string zB4=(Byte[] bytesIn, int nIndex, int length);
    private Byte[] zR4=(int iRecord, int iField);
    private Byte[] zh4=(int iRecord, int iField);
    private Byte[] zx4=(int iRecord);
    private Byte[] 0B4=(int iRecord);
    private string 0R4=(int iBlock);
    private string 0h4=(int iBlock);
    private void 0x4=();
    private static void 1B4=(Byte[]& arrUpdateBytes, int nOffset, int nWrittenBytes, int nSize, byte byteBlank);
    private void 1R4=(object value, int nOriginalBlock);
    private string 1h4=(int recordNumber, int fieldIndex);
    private void 1x4=(int iField, object objValue);
    private void 2B4=(object Value, int nOriginalBlock);
    private void 2R4=(int iRecord);
    private void 2h4=(bool bHaveMemoField);
    private void 2x4=();
    private void 3B4=();
    private static string 3R4=(string dbf);
    private static void 3h4=(string strSrcDBF, string strDestDBF);
    private static string 3x4=();
    private int 4B4=(string FieldName, DbfColumnType type, int nWidth, int nDecimals);
    private int 4R4=(string FieldName, DbfColumnType type, int nWidth, int nDecimals);
    private void 4h4=(ArrayList DeletedArray);
    private void 4x4=(ArrayList DeletedArray, ArrayList MemoFields);
    private void 5B4=(Stream& fsDest, ArrayList DeletedArray);
    private void 5R4=(Stream& fsDest, ArrayList DeletedBlocks);
    private void 5h4=(ArrayList memoFields);
    private void 5x4=(Stream fsSrc, int iStart, int iEnd, Stream& fsDest, int iWriteTo);
    private static void 6B4=(Stream fsSrc, int iStart, int iEnd, Stream& fsDest, int iWriteTo);
    private static void 6R4=(Stream fsDBT, int nDeletedBlocks);
    private int 6h4=(int OriginalValue);
    private static void 6x4=(ArrayList& arrOriginal, ArrayList& arrNew, int iOriginalStart, int iOriginalEnd, int iNewStart);
    private ArrayList 7B4=(ArrayList DeletedArray, ArrayList MemoFields);
    private ArrayList 7R4=();
    private void 7h4=();
    private static int 7x4=(int iStart, int iEnd);
    private int 8B4=(Stream fsDBT, int iBlock);
    private Byte[] 8R4=();
    private bool 8h4=(ArrayList Fields);
    private void 8x4=(byte Flag);
    private void 9B4=(string ErrorMsg);
    private DbfColumnInfo 9R4=(DbfColumnType type, int nWidth, int nDecimals);
    private Byte[] 9h4=(string FieldName, DbfColumnInfo Field);
    private string 9x4=(int iField, DbfColumnType type, object objValue);
    private static string /B4=(object objValue, int nDecimalSize, DbfColumnType dbfColumnType, CultureInfo cultureInfo);
    private string /R4=(string FieldName, DbfColumnType type, int nWidth, int nDecimals);
    private static int /h4=(string strNum, CultureInfo cultureInfo);
    private static string /x4=(string strNum);
    private static void AB8=(Byte[]& bytes, int iStart, int intValue);
    private static int AR8=(Byte[] bytes, int iStart);
    private static void Ah8=(Byte[]& FileHeader);
    private void Ax8=(GeoDbf dbfFile, Stream& fsDest);
    private static void BB8=(Stream dbtFile, Stream& fsDest);
    private static string BR8=(string value);
    private void kh0=(bool disposing);
}
public class ThinkGeo.Core.GeoFont : object {
    [ObfuscationAttribute]
private float size;
    [ObfuscationAttribute]
private string fontName;
    [ObfuscationAttribute]
private string fontNameLowercase;
    [ObfuscationAttribute]
private bool isBold;
    [ObfuscationAttribute]
private bool isStrikeout;
    [ObfuscationAttribute]
private bool isItalic;
    [ObfuscationAttribute]
private bool isUnderline;
    [ObfuscationAttribute]
private long id;
    [ObfuscationAttribute]
private static long geoFontIdCounter;
    [ObfuscationAttribute]
private DrawingGraphicsUnit unit;
    [ObfuscationAttribute]
private DrawingFontStyles style;
    [ObfuscationAttribute]
private bool isDefault;
    [ObfuscationAttribute]
internal static Dictionary`2<Regex, string> SpecificFontNames;
    public bool IsBold { get; public set; }
    public bool IsStrikeout { get; public set; }
    public bool IsItalic { get; public set; }
    public bool IsUnderline { get; public set; }
    public string FontName { get; public set; }
    public float Size { get; public set; }
    public DrawingFontStyles Style { get; public set; }
    public long Id { get; }
    public DrawingGraphicsUnit Unit { get; public set; }
    internal bool fBU= { get; internal set; }
    public GeoFont(string fontName, float size);
    public GeoFont(string fontName, float size, DrawingFontStyles style);
    public GeoFont(string fontName, float size, DrawingFontStyles style, DrawingGraphicsUnit unit);
    private static GeoFont();
    public bool get_IsBold();
    public void set_IsBold(bool value);
    public bool get_IsStrikeout();
    public void set_IsStrikeout(bool value);
    public bool get_IsItalic();
    public void set_IsItalic(bool value);
    public bool get_IsUnderline();
    public void set_IsUnderline(bool value);
    public string get_FontName();
    public void set_FontName(string value);
    public float get_Size();
    public void set_Size(float value);
    public DrawingFontStyles get_Style();
    public void set_Style(DrawingFontStyles value);
    public long get_Id();
    public DrawingGraphicsUnit get_Unit();
    public void set_Unit(DrawingGraphicsUnit value);
    internal bool ehU=();
    internal void exU=(bool value);
    public virtual int GetHashCode();
    public static string GetGlyphContent(int glyphIndex);
    public virtual bool Equals(object obj);
}
public enum ThinkGeo.Core.GeographyUnit : Enum {
    public int value__;
    public static GeographyUnit Unknown;
    public static GeographyUnit DecimalDegree;
    public static GeographyUnit Feet;
    public static GeographyUnit Meter;
}
public enum ThinkGeo.Core.GeohashAjacentDirection : Enum {
    public int value__;
    public static GeohashAjacentDirection Up;
    public static GeohashAjacentDirection UpperRight;
    public static GeohashAjacentDirection Right;
    public static GeohashAjacentDirection LowerRight;
    public static GeohashAjacentDirection Down;
    public static GeohashAjacentDirection LowerLeft;
    public static GeohashAjacentDirection Left;
    public static GeohashAjacentDirection UpperLeft;
}
public static class ThinkGeo.Core.GeohashHelper : object {
    private static string ECQ=;
    private static Int32[] ESQ=;
    private static String[][] EiQ=;
    private static String[][] EyQ=;
    private static GeohashHelper();
    public static PointShape ConvertToPointShape(string geohash);
    public static string ConvertToGeohash(PointShape pointShapeInDecimalDegree, int precision);
    public static string ConvertToGeohash(Vertex vertexInDecimalDegree, int precision);
    public static string ConvertToGeohash(double latitude, double longitude, int precision);
    public static string GetAdjacentGeohash(double latitude, double longitude, GeohashAjacentDirection direction);
    public static string GetAdjacentGeohash(double latitude, double longitude, GeohashAjacentDirection direction, int precision);
    public static string GetAdjacentGeohash(PointShape pointShapeInDecimalDegree, GeohashAjacentDirection direction);
    public static string GetAdjacentGeohash(PointShape pointShapeInDecimalDegree, GeohashAjacentDirection direction, int precision);
    public static string GetAdjacentGeohash(Vertex vertexInDecimalDegree, GeohashAjacentDirection direction);
    public static string GetAdjacentGeohash(Vertex vertexInDecimalDegree, GeohashAjacentDirection direction, int precision);
    public static string GetAdjacentGeohash(string geohash, GeohashAjacentDirection direction);
    public static Collection`1<string> GetAdjacentGeohashes(string geohash);
    public static Collection`1<string> GetAdjacentGeohashes(PointShape pointShapeInDecimalDegree);
    public static Collection`1<string> GetAdjacentGeohashes(PointShape pointShapeInDecimalDegree, int precision);
    public static Collection`1<string> GetAdjacentGeohashes(Vertex vertexInDecimalDegree);
    public static Collection`1<string> GetAdjacentGeohashes(Vertex vertexInDecimalDegree, int precision);
    public static Collection`1<string> GetAdjacentGeohashes(double latitude, double longitude);
    public static Collection`1<string> GetAdjacentGeohashes(double latitude, double longitude, int precision);
    private static string FCQ=(string hash, Sz0= direction);
    private static void FSQ=(Double[]& interval, int cd, int mask);
    private static int FiQ=(double doubleNumber);
}
public class ThinkGeo.Core.GeoHatchBrush : GeoBrush {
    [ObfuscationAttribute]
private GeoHatchStyle hatchStyle;
    [ObfuscationAttribute]
private GeoColor foregroundColor;
    [ObfuscationAttribute]
private GeoColor backgroundColor;
    public GeoHatchStyle HatchStyle { get; public set; }
    public GeoColor ForegroundColor { get; public set; }
    public GeoColor BackgroundColor { get; public set; }
    public GeoHatchBrush(GeoHatchStyle hatchStyle, GeoColor foregroundColor);
    public GeoHatchBrush(GeoHatchStyle hatchStyle, GeoColor foregroundColor, GeoColor backgroundColor);
    public GeoHatchStyle get_HatchStyle();
    public void set_HatchStyle(GeoHatchStyle value);
    public GeoColor get_ForegroundColor();
    public void set_ForegroundColor(GeoColor value);
    public GeoColor get_BackgroundColor();
    public void set_BackgroundColor(GeoColor value);
}
public enum ThinkGeo.Core.GeoHatchStyle : Enum {
    public int value__;
    public static GeoHatchStyle Horizontal;
    public static GeoHatchStyle Vertical;
    public static GeoHatchStyle ForwardDiagonal;
    public static GeoHatchStyle BackwardDiagonal;
    public static GeoHatchStyle LargeGrid;
    public static GeoHatchStyle DiagonalCross;
    public static GeoHatchStyle Percent05;
    public static GeoHatchStyle Percent10;
    public static GeoHatchStyle Percent20;
    public static GeoHatchStyle Percent25;
    public static GeoHatchStyle Percent30;
    public static GeoHatchStyle Percent40;
    public static GeoHatchStyle Percent50;
    public static GeoHatchStyle Percent60;
    public static GeoHatchStyle Percent70;
    public static GeoHatchStyle Percent75;
    public static GeoHatchStyle Percent80;
    public static GeoHatchStyle Percent90;
    public static GeoHatchStyle LightDownwardDiagonal;
    public static GeoHatchStyle LightUpwardDiagonal;
    public static GeoHatchStyle DarkDownwardDiagonal;
    public static GeoHatchStyle DarkUpwardDiagonal;
    public static GeoHatchStyle WideDownwardDiagonal;
    public static GeoHatchStyle WideUpwardDiagonal;
    public static GeoHatchStyle LightVertical;
    public static GeoHatchStyle LightHorizontal;
    public static GeoHatchStyle NarrowVertical;
    public static GeoHatchStyle NarrowHorizontal;
    public static GeoHatchStyle DarkVertical;
    public static GeoHatchStyle DarkHorizontal;
    public static GeoHatchStyle DashedDownwardDiagonal;
    public static GeoHatchStyle DashedUpwardDiagonal;
    public static GeoHatchStyle DashedHorizontal;
    public static GeoHatchStyle DashedVertical;
    public static GeoHatchStyle SmallConfetti;
    public static GeoHatchStyle LargeConfetti;
    public static GeoHatchStyle ZigZag;
    public static GeoHatchStyle Wave;
    public static GeoHatchStyle DiagonalBrick;
    public static GeoHatchStyle HorizontalBrick;
    public static GeoHatchStyle Weave;
    public static GeoHatchStyle Plaid;
    public static GeoHatchStyle Divot;
    public static GeoHatchStyle DottedGrid;
    public static GeoHatchStyle DottedDiamond;
    public static GeoHatchStyle Shingle;
    public static GeoHatchStyle Trellis;
    public static GeoHatchStyle Sphere;
    public static GeoHatchStyle SmallGrid;
    public static GeoHatchStyle SmallCheckerBoard;
    public static GeoHatchStyle LargeCheckerBoard;
    public static GeoHatchStyle OutlinedDiamond;
    public static GeoHatchStyle SolidDiamond;
    public static GeoHatchStyle Min;
    public static GeoHatchStyle Max;
    public static GeoHatchStyle Cross;
}
public class ThinkGeo.Core.GeoImage : object {
    [ObfuscationAttribute]
private float opacity;
    [ObfuscationAttribute]
private SKBitmap nativeImage;
    [ObfuscationAttribute]
private Byte[] bytes;
    [ObfuscationAttribute]
private string pathFilename;
    public string PathFilename { get; }
    public float Opacity { get; public set; }
    public int Width { get; }
    public int Height { get; }
    public SKBitmap NativeImage { get; }
    public GeoImage(int width, int height);
    public GeoImage(Stream stream);
    public GeoImage(string pathFilename);
    public GeoImage(Byte[] bytes);
    public GeoImage(SKBitmap skBitmap);
    public string get_PathFilename();
    public float get_Opacity();
    public void set_Opacity(float value);
    public int get_Width();
    public int get_Height();
    public SKBitmap get_NativeImage();
    public static GeoImage CreateCustomizedImage(int width, int height, GeoColorType colorType, GeoAlphaType alphaType);
    public Byte[] GetImageBytes(GeoImageFormat imageFormat, int imageQuality);
    public Byte[] ToBytesArray();
    public Stream GetImageStream(GeoImageFormat imageFormat, int imageQuality);
    public void Save(Stream stream, GeoImageFormat imageFormat, int quality);
    public void Save(string filePath, GeoImageFormat imageFormat, int quality);
    public sealed virtual void Dispose();
    protected virtual override void Finalize();
    protected virtual void Dispose(bool disposing);
    public void Clear(GeoColor color);
    public void SetPixels(GeoColor[] pixels);
    public IntPtr GetIntPtr();
    public GeoImage Scale(int targetWidth, int targetHeight);
    public GeoImage Crop(DrawingRectangle srcRect);
    public GeoImage Clip(DrawingRectangle clippingRectangle, int clippingWidth, int clippingHeight);
    public void DrawImage(GeoImage geoImage, float pointX, float pointY);
    public void DrawText(string text, GeoFont font, GeoBrush fillBrush, ScreenPointF[] points);
    internal GeoImage GBU=(bool isGrayscale, bool isNegative, float transparency, float redTranslation, float greenTranslation, float blueTranslation);
    internal GeoImage GRU=(Dictionary`2<GeoColor, GeoColor> colorMappings);
    [OnGeoserializingAttribute]
[OnSerializingAttribute]
private void GhU=(StreamingContext context);
    [OnGeodeserializedAttribute]
[OnDeserializedAttribute]
private void GxU=(StreamingContext context);
}
public enum ThinkGeo.Core.GeoImageFormat : Enum {
    public int value__;
    public static GeoImageFormat Png;
    public static GeoImageFormat Jpeg;
}
public class ThinkGeo.Core.GeoImageLayer : Layer {
    [ObfuscationAttribute]
private GeoImage _geoImage;
    [CompilerGeneratedAttribute]
private string 7B8=;
    [CompilerGeneratedAttribute]
private PointShape Ox0=;
    [CompilerGeneratedAttribute]
private double 7R8=;
    [CompilerGeneratedAttribute]
private double qx0=;
    [CompilerGeneratedAttribute]
private double rB0=;
    public string ImagePathFilename { get; public set; }
    public PointShape CenterPoint { get; public set; }
    public double Scale { get; public set; }
    public double UpperThreshold { get; public set; }
    public double LowerThreshold { get; public set; }
    public GeoImageLayer(string imagePathFilename);
    [CompilerGeneratedAttribute]
public string get_ImagePathFilename();
    [CompilerGeneratedAttribute]
public void set_ImagePathFilename(string value);
    [CompilerGeneratedAttribute]
public PointShape get_CenterPoint();
    [CompilerGeneratedAttribute]
public void set_CenterPoint(PointShape value);
    [CompilerGeneratedAttribute]
public double get_Scale();
    [CompilerGeneratedAttribute]
public void set_Scale(double value);
    [CompilerGeneratedAttribute]
public double get_UpperThreshold();
    [CompilerGeneratedAttribute]
public void set_UpperThreshold(double value);
    [CompilerGeneratedAttribute]
public double get_LowerThreshold();
    [CompilerGeneratedAttribute]
public void set_LowerThreshold(double value);
    protected virtual RectangleShape GetBoundingBoxCore();
    protected virtual void OpenCore();
    protected virtual void CloseCore();
    protected virtual void DrawCore(GeoCanvas canvas, Collection`1<SimpleCandidate> labelsInAllLayers);
    protected virtual bool IsDrawingNeededCore(double currentScale);
}
[ObfuscationAttribute]
[DataContractAttribute]
internal class ThinkGeo.Core.GeoJsonFeature : GeoJsonObject {
    [CompilerGeneratedAttribute]
private GeoJsonObject <Geometry>k__BackingField;
    [CompilerGeneratedAttribute]
private Dictionary`2<string, string> <Properties>k__BackingField;
    [CompilerGeneratedAttribute]
private Double[] <BoundingBox>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Id>k__BackingField;
    [DataMemberAttribute]
public GeoJsonObject Geometry { get; public set; }
    [DataMemberAttribute]
public Dictionary`2<string, string> Properties { get; public set; }
    [DataMemberAttribute]
public Double[] BoundingBox { get; public set; }
    [DataMemberAttribute]
public string Id { get; public set; }
    public GeoJsonFeature(Feature feature);
    [CompilerGeneratedAttribute]
public GeoJsonObject get_Geometry();
    [CompilerGeneratedAttribute]
public void set_Geometry(GeoJsonObject value);
    [CompilerGeneratedAttribute]
public Dictionary`2<string, string> get_Properties();
    [CompilerGeneratedAttribute]
public void set_Properties(Dictionary`2<string, string> value);
    [CompilerGeneratedAttribute]
public Double[] get_BoundingBox();
    [CompilerGeneratedAttribute]
public void set_BoundingBox(Double[] value);
    [CompilerGeneratedAttribute]
public string get_Id();
    [CompilerGeneratedAttribute]
public void set_Id(string value);
}
[DataContractAttribute]
[ObfuscationAttribute]
internal class ThinkGeo.Core.GeoJsonFeatureCollection : GeoJsonObject {
    [CompilerGeneratedAttribute]
private Collection`1<GeoJsonFeature> <GeoJsonFeatures>k__BackingField;
    [CompilerGeneratedAttribute]
private Dictionary`2<string, string> <Properties>k__BackingField;
    [CompilerGeneratedAttribute]
private Double[] <BoundingBox>k__BackingField;
    [DataMemberAttribute]
public Collection`1<GeoJsonFeature> GeoJsonFeatures { get; public set; }
    [DataMemberAttribute]
public Dictionary`2<string, string> Properties { get; public set; }
    [DataMemberAttribute]
public Double[] BoundingBox { get; public set; }
    public GeoJsonFeatureCollection(IEnumerable`1<Feature> features);
    [CompilerGeneratedAttribute]
public Collection`1<GeoJsonFeature> get_GeoJsonFeatures();
    [CompilerGeneratedAttribute]
public void set_GeoJsonFeatures(Collection`1<GeoJsonFeature> value);
    [CompilerGeneratedAttribute]
public Dictionary`2<string, string> get_Properties();
    [CompilerGeneratedAttribute]
public void set_Properties(Dictionary`2<string, string> value);
    [CompilerGeneratedAttribute]
public Double[] get_BoundingBox();
    [CompilerGeneratedAttribute]
public void set_BoundingBox(Double[] value);
}
[ObfuscationAttribute]
[DataContractAttribute]
internal class ThinkGeo.Core.GeoJsonGeometryCollectionShape : GeoJsonObject {
    [CompilerGeneratedAttribute]
private Collection`1<GeoJsonObject> <Shapes>k__BackingField;
    [DataMemberAttribute]
public Collection`1<GeoJsonObject> Shapes { get; public set; }
    public GeoJsonGeometryCollectionShape(GeometryCollectionShape geometryCollection);
    [CompilerGeneratedAttribute]
public Collection`1<GeoJsonObject> get_Shapes();
    [CompilerGeneratedAttribute]
public void set_Shapes(Collection`1<GeoJsonObject> value);
}
[ObfuscationAttribute]
[DataContractAttribute]
internal class ThinkGeo.Core.GeoJsonLineStringShape : GeoJsonObject {
    [CompilerGeneratedAttribute]
private Collection`1<Double[]> <Vertices>k__BackingField;
    [DataMemberAttribute]
public Collection`1<Double[]> Vertices { get; public set; }
    public GeoJsonLineStringShape(LineShape line);
    [CompilerGeneratedAttribute]
public Collection`1<Double[]> get_Vertices();
    [CompilerGeneratedAttribute]
public void set_Vertices(Collection`1<Double[]> value);
}
[DataContractAttribute]
[ObfuscationAttribute]
internal class ThinkGeo.Core.GeoJsonMultiLineStringShape : GeoJsonObject {
    [CompilerGeneratedAttribute]
private Collection`1<Collection`1<Double[]>> <Lines>k__BackingField;
    [DataMemberAttribute]
public Collection`1<Collection`1<Double[]>> Lines { get; public set; }
    public GeoJsonMultiLineStringShape(MultilineShape multiLine);
    [CompilerGeneratedAttribute]
public Collection`1<Collection`1<Double[]>> get_Lines();
    [CompilerGeneratedAttribute]
public void set_Lines(Collection`1<Collection`1<Double[]>> value);
}
[DataContractAttribute]
[ObfuscationAttribute]
internal class ThinkGeo.Core.GeoJsonMultiPointShape : GeoJsonObject {
    [CompilerGeneratedAttribute]
private Collection`1<Double[]> <Points>k__BackingField;
    [DataMemberAttribute]
public Collection`1<Double[]> Points { get; public set; }
    public GeoJsonMultiPointShape(MultipointShape multiPoint);
    [CompilerGeneratedAttribute]
public Collection`1<Double[]> get_Points();
    [CompilerGeneratedAttribute]
public void set_Points(Collection`1<Double[]> value);
}
[DataContractAttribute]
[ObfuscationAttribute]
internal class ThinkGeo.Core.GeoJsonMultiPolygonShape : GeoJsonObject {
    [CompilerGeneratedAttribute]
private Collection`1<Collection`1<Collection`1<Double[]>>> <Polygons>k__BackingField;
    [DataMemberAttribute]
public Collection`1<Collection`1<Collection`1<Double[]>>> Polygons { get; public set; }
    public GeoJsonMultiPolygonShape(MultipolygonShape multiPolygon);
    [CompilerGeneratedAttribute]
public Collection`1<Collection`1<Collection`1<Double[]>>> get_Polygons();
    [CompilerGeneratedAttribute]
public void set_Polygons(Collection`1<Collection`1<Collection`1<Double[]>>> value);
    private static void FillRings(RingShape ring, Collection`1<Collection`1<Double[]>> polygon);
}
[ObfuscationAttribute]
[KnownTypeAttribute("ThinkGeo.Core.GeoJsonPointShape")]
[KnownTypeAttribute("ThinkGeo.Core.GeoJsonLineStringShape")]
[KnownTypeAttribute("ThinkGeo.Core.GeoJsonFeature")]
[KnownTypeAttribute("ThinkGeo.Core.GeoJsonMultiLineStringShape")]
[KnownTypeAttribute("ThinkGeo.Core.GeoJsonPolygonShape")]
[KnownTypeAttribute("ThinkGeo.Core.GeoJsonGeometryCollectionShape")]
[DataContractAttribute]
[KnownTypeAttribute("ThinkGeo.Core.GeoJsonMultiPointShape")]
[KnownTypeAttribute("ThinkGeo.Core.GeoJsonMultiPolygonShape")]
internal class ThinkGeo.Core.GeoJsonObject : object {
    [CompilerGeneratedAttribute]
private string <ObjectType>k__BackingField;
    [DataMemberAttribute]
public string ObjectType { get; public set; }
    [CompilerGeneratedAttribute]
public string get_ObjectType();
    [CompilerGeneratedAttribute]
public void set_ObjectType(string value);
}
[ObfuscationAttribute]
internal static class ThinkGeo.Core.GeoJsonObjectType : object {
    public static string Point;
    public static string LineString;
    public static string Polygon;
    public static string MultiPoint;
    public static string MultiLineString;
    public static string MultiPolygon;
    public static string GeometryCollection;
    public static string Feature;
    public static string FeatureCollection;
    private static GeoJsonObjectType();
}
[ObfuscationAttribute]
[DataContractAttribute]
internal class ThinkGeo.Core.GeoJsonPointShape : GeoJsonObject {
    [CompilerGeneratedAttribute]
private Double[] <XY>k__BackingField;
    [DataMemberAttribute]
public Double[] XY { get; public set; }
    public GeoJsonPointShape(PointShape point);
    public GeoJsonPointShape(double x, double y);
    [CompilerGeneratedAttribute]
public Double[] get_XY();
    [CompilerGeneratedAttribute]
public void set_XY(Double[] value);
}
[DataContractAttribute]
[ObfuscationAttribute]
internal class ThinkGeo.Core.GeoJsonPolygonShape : GeoJsonObject {
    [CompilerGeneratedAttribute]
private Collection`1<Collection`1<Double[]>> <Rings>k__BackingField;
    [DataMemberAttribute]
public Collection`1<Collection`1<Double[]>> Rings { get; public set; }
    public GeoJsonPolygonShape(PolygonShape polygon);
    [CompilerGeneratedAttribute]
public Collection`1<Collection`1<Double[]>> get_Rings();
    [CompilerGeneratedAttribute]
public void set_Rings(Collection`1<Collection`1<Double[]>> value);
    private void FillRings(RingShape ring);
}
[ObfuscationAttribute]
internal class ThinkGeo.Core.GeoJsonSerializeStrategy : object {
    [CompilerGeneratedAttribute]
private Func`2<object, GeoJsonType> <GetJsonType>k__BackingField;
    [CompilerGeneratedAttribute]
private Func`2<object, object> <GetJsonNode>k__BackingField;
    [CompilerGeneratedAttribute]
private Action`1<XElement> <FormalizedXml>k__BackingField;
    public Func`2<object, GeoJsonType> GetJsonType { get; public set; }
    public Func`2<object, object> GetJsonNode { get; public set; }
    public Action`1<XElement> FormalizedXml { get; public set; }
    [CompilerGeneratedAttribute]
public Func`2<object, GeoJsonType> get_GetJsonType();
    [CompilerGeneratedAttribute]
public void set_GetJsonType(Func`2<object, GeoJsonType> value);
    [CompilerGeneratedAttribute]
public Func`2<object, object> get_GetJsonNode();
    [CompilerGeneratedAttribute]
public void set_GetJsonNode(Func`2<object, object> value);
    [CompilerGeneratedAttribute]
public Action`1<XElement> get_FormalizedXml();
    [CompilerGeneratedAttribute]
public void set_FormalizedXml(Action`1<XElement> value);
    private static GeoJsonType GetJsonTypeHandler(object obj);
    private static object GetJsonNodeHandler(object obj);
    private static void FormalizedXmlHandler(XElement xElement);
}
[ObfuscationAttribute]
internal enum ThinkGeo.Core.GeoJsonType : Enum {
    public int value__;
    public static GeoJsonType unknown;
    public static GeoJsonType string;
    public static GeoJsonType number;
    public static GeoJsonType boolean;
    public static GeoJsonType object;
    public static GeoJsonType array;
    public static GeoJsonType null;
}
public class ThinkGeo.Core.GeoLinearGradientBrush : GeoBrush {
    [ObfuscationAttribute]
private GeoColor startColor;
    [ObfuscationAttribute]
private GeoColor endColor;
    [ObfuscationAttribute]
private GeoBrushWrapMode wrapMode;
    [ObfuscationAttribute]
private float directionAngle;
    public GeoColor StartColor { get; public set; }
    public GeoColor EndColor { get; public set; }
    public float DirectionAngle { get; public set; }
    public GeoBrushWrapMode WrapMode { get; public set; }
    public GeoLinearGradientBrush(GeoColor startColor, GeoColor endColor, GeoLinearGradientDirection direction);
    public GeoLinearGradientBrush(GeoColor startColor, GeoColor endColor, float directionAngle);
    private static float FxU=(GeoLinearGradientDirection direction);
    public GeoColor get_StartColor();
    public void set_StartColor(GeoColor value);
    public GeoColor get_EndColor();
    public void set_EndColor(GeoColor value);
    public float get_DirectionAngle();
    public void set_DirectionAngle(float value);
    public GeoBrushWrapMode get_WrapMode();
    public void set_WrapMode(GeoBrushWrapMode value);
}
public enum ThinkGeo.Core.GeoLinearGradientDirection : Enum {
    public int value__;
    public static GeoLinearGradientDirection LeftToRight;
    public static GeoLinearGradientDirection RightToLeft;
    public static GeoLinearGradientDirection TopToBottom;
    public static GeoLinearGradientDirection BottomToTop;
    public static GeoLinearGradientDirection UpperLeftToLowerRight;
    public static GeoLinearGradientDirection LowerRightToUpperLeft;
    public static GeoLinearGradientDirection LowerLeftToUpperRight;
    public static GeoLinearGradientDirection UpperRightToLowerLeft;
}
[TypeConverterAttribute("ThinkGeo.Core.BaseShapeTypeConverter")]
public class ThinkGeo.Core.GeometryCollectionShape : BaseShape {
    [ObfuscationAttribute]
private Collection`1<BaseShape> shapes;
    public Collection`1<BaseShape> Shapes { get; }
    public GeometryCollectionShape(IEnumerable`1<BaseShape> baseShapes);
    public GeometryCollectionShape(IEnumerable`1<Feature> features);
    public GeometryCollectionShape(string wellKnownText);
    public GeometryCollectionShape(Byte[] wellKnownBinary);
    public Collection`1<BaseShape> get_Shapes();
    protected virtual void LoadFromWellKnownDataCore(Byte[] wellKnownBinary);
    protected virtual void LoadFromWellKnownDataCore(string wellKnownText);
    protected virtual string GetWellKnownTextCore(RingOrder outerRingOrder);
    protected virtual Byte[] GetWellKnownBinaryCore(RingOrder outerRingOrder, WkbByteOrder byteOrder);
    protected virtual WellKnownType GetWellKnownTypeCore();
    private void Chw=(GeometryCollectionShape fromGeometryCollection);
    protected virtual ShapeValidationResult ValidateCore(ShapeValidationMode validationMode);
    protected virtual MultipointShape GetCrossingCore(BaseShape targetShape);
    protected virtual RectangleShape GetBoundingBoxCore();
    protected virtual double GetDistanceToCore(BaseShape targetShape, GeographyUnit shapeUnit, DistanceUnit distanceUnit);
    protected virtual PointShape GetClosestPointToCore(BaseShape targetShape, GeographyUnit shapeUnit);
    protected virtual MultilineShape GetShortestLineToCore(BaseShape targetShape, GeographyUnit shapeUnit);
    protected virtual MultipolygonShape BufferCore(double distance, int quadrantSegments, BufferCapType bufferCapType, GeographyUnit shapeUnit, DistanceUnit distanceUnit);
    protected virtual bool IsDisjointedCore(BaseShape targetShape);
    protected virtual bool IntersectsCore(BaseShape targetShape);
    protected virtual bool TouchesCore(BaseShape targetShape);
    protected virtual bool IsWithinCore(BaseShape targetShape);
    public GeometryCollectionShape GetIntersection(BaseShape targetShape);
    protected virtual GeometryCollectionShape GetIntersectionCore(BaseShape targetShape);
    public GeometryCollectionShape Union(BaseShape targetShape);
    public GeometryCollectionShape Union(IEnumerable`1<BaseShape> targetShape);
    protected virtual GeometryCollectionShape UnionCore(IEnumerable`1<BaseShape> targetShape);
    private static Collection`1<BaseShape> Cxw=(GeometryCollectionShape geometryCollection);
    internal static GeometryCollectionShape DBw=(IEnumerable`1<BaseShape> shapes);
    public GeometryCollectionShape GetDifference(BaseShape targetShape);
    protected virtual GeometryCollectionShape GetDifferenceCore(BaseShape targetShape);
    public GeometryCollectionShape GetSymmetricalDifference(BaseShape targetShape);
    protected virtual GeometryCollectionShape GetSymmetricalDifferenceCore(BaseShape targetShape);
    public RingShape GetConvexHull();
    protected virtual RingShape GetConvexHullCore();
    public GeometryCollectionShape Simplify(GeographyUnit shapeUnit, double tolerance, DistanceUnit toleranceUnit, SimplificationType simplificationType);
    public GeometryCollectionShape Simplify(double tolerance, SimplificationType simplificationType);
    protected virtual GeometryCollectionShape SimplifyCore(double tolerance, SimplificationType simplificationType);
    private static EndCapStyle oho=(BufferCapType bufferCapStyle);
}
public class ThinkGeo.Core.GeoObjectModel : object {
    [ObfuscationAttribute]
private string name;
    [ObfuscationAttribute]
private GeoObjectNode rootNode;
    public string Name { get; public set; }
    public GeoObjectNode RootNode { get; public set; }
    public GeoObjectModel(string name, GeoObjectNode rootNode);
    public string get_Name();
    public void set_Name(string value);
    public GeoObjectNode get_RootNode();
    public void set_RootNode(GeoObjectNode value);
}
internal class ThinkGeo.Core.GeoObjectModeler : object {
    [CompilerGeneratedAttribute]
private EventHandler`1<CreatingMemberNodeGeoObjectModelerEventArgs> CreatingMemberNode;
    [CompilerGeneratedAttribute]
private EventHandler`1<CreatedMemberNodeGeoObjectModelerEventArgs> CreatedMemberNode;
    [CompilerGeneratedAttribute]
private EventHandler`1<CreatingMemberObjectGeoObjectModelerEventArgs> CreatingMemberObject;
    [CompilerGeneratedAttribute]
private EventHandler`1<CreatedMemberObjectGeoObjectModelerEventArgs> CreatedMemberObject;
    [CompilerGeneratedAttribute]
private bool <IsGeneratingCode>k__BackingField;
    private string circularReferenceAttributeName;
    private Type[] parameterToGetConstructor;
    private Object[] parameterToInvokeConstructor;
    private Type onDeserializingAttributeType;
    private Type onDeserializedAttributeType;
    private Type onSerializingAttributeType;
    private Type onSerializedAttributeType;
    private Dictionary`2<string, Collection`1<MethodInfo>> attributedMethodInfosCache;
    private static Dictionary`2<string, string> escapeCharactors;
    [ObfuscationAttribute]
private object referencedObject;
    [ObfuscationAttribute]
private string hashCode;
    [ObfuscationAttribute]
private string referenceTypeName;
    [ObfuscationAttribute]
private Dictionary`2<object, GeoObjectNodeAndGuid> hashCodeModelDictionary;
    [ObfuscationAttribute]
private Dictionary`2<string, object> hashcodeValueDictionary;
    [ObfuscationAttribute]
private Dictionary`2<Type, object> objectsInInitialState;
    [ObfuscationAttribute]
private GeoObjectModelerMemberTypes memberTypes;
    [ObfuscationAttribute]
private GeoObjectModelerDefaultValueMode defaultValueMode;
    [ObfuscationAttribute]
private BindingFlags bindingFlags;
    [ObfuscationAttribute]
private object tmpValue;
    [ObfuscationAttribute]
private PropertyInfo tmpProperty;
    internal bool IsGeneratingCode { get; internal set; }
    private static GeoObjectModeler();
    [CompilerGeneratedAttribute]
public void add_CreatingMemberNode(EventHandler`1<CreatingMemberNodeGeoObjectModelerEventArgs> value);
    [CompilerGeneratedAttribute]
public void remove_CreatingMemberNode(EventHandler`1<CreatingMemberNodeGeoObjectModelerEventArgs> value);
    [CompilerGeneratedAttribute]
public void add_CreatedMemberNode(EventHandler`1<CreatedMemberNodeGeoObjectModelerEventArgs> value);
    [CompilerGeneratedAttribute]
public void remove_CreatedMemberNode(EventHandler`1<CreatedMemberNodeGeoObjectModelerEventArgs> value);
    [CompilerGeneratedAttribute]
public void add_CreatingMemberObject(EventHandler`1<CreatingMemberObjectGeoObjectModelerEventArgs> value);
    [CompilerGeneratedAttribute]
public void remove_CreatingMemberObject(EventHandler`1<CreatingMemberObjectGeoObjectModelerEventArgs> value);
    [CompilerGeneratedAttribute]
public void add_CreatedMemberObject(EventHandler`1<CreatedMemberObjectGeoObjectModelerEventArgs> value);
    [CompilerGeneratedAttribute]
public void remove_CreatedMemberObject(EventHandler`1<CreatedMemberObjectGeoObjectModelerEventArgs> value);
    [CompilerGeneratedAttribute]
internal bool get_IsGeneratingCode();
    [CompilerGeneratedAttribute]
internal void set_IsGeneratingCode(bool value);
    public GeoObjectModel CreateModel(object objectToModel, GeoObjectModelerMemberTypes memberTypes, BindingFlags bindingFlags, GeoObjectModelerDefaultValueMode defaultValueMode);
    public object CreateObject(GeoObjectModel model);
    protected Collection`1<MemberInfo> GetMembers(Type type, GeoObjectModelerMemberTypes memberTypes);
    protected virtual Collection`1<MemberInfo> GetMembersCore(Type type, GeoObjectModelerMemberTypes memberTypes);
    protected virtual void OnCreatingMemberNode(CreatingMemberNodeGeoObjectModelerEventArgs e);
    protected virtual void OnCreatingMemberObject(CreatingMemberObjectGeoObjectModelerEventArgs e);
    protected virtual void OnCreatedMemberNode(CreatedMemberNodeGeoObjectModelerEventArgs e);
    protected virtual void OnCreatedMemberObject(CreatedMemberObjectGeoObjectModelerEventArgs e);
    protected void CreateMemberNode(string memberName, object memberValue, Type memberType, object memberOwner, GeoObjectNode baseMemberNode);
    protected virtual void CreateMemberNodeCore(string memberName, object memberValue, Type memberType, object memberOwner, GeoObjectNode baseMemberNode);
    protected object CreateMemberObject(string memberName, Type memberType, object memberOwner, GeoObjectNode memberNode);
    protected virtual object CreateMemberObjectCore(string memberName, Type memberType, object memberOwner, GeoObjectNode memberNode);
    private GeoObjectNode CreateModelForObject(object modelSource);
    private Collection`1<MemberInfo> GetAllMembers(Type type);
    private void CreateNodeForObject(object serializationObject, GeoObjectNode baseObjectModel, string nodeName, Type parentType);
    private static void InvokeSerializingDeserializingMethods(object serializationObject, IEnumerable`1<MethodInfo> onSerializingMethods);
    private bool IsSpecialTypes(Type type);
    [IteratorStateMachineAttribute("ThinkGeo.Core.GeoObjectModeler/<GetMethodsMarkedAs>d__54")]
private IEnumerable`1<MethodInfo> GetMethodsMarkedAs(Type type, Type attributeType);
    private static GeoObjectNode CreateNewNode(string name);
    private static void SetInheritAttribute(GeoObjectNode objectModel, Type type, Type parentType);
    private static void SetTypeAttribute(GeoObjectNode objectModel, Type objType);
    private static string SimplifyAssemblyQualifiedName(string name);
    private static void SetItemTypeAttribute(GeoObjectNode objectModel, Type objType);
    private bool IsCircularReferenced(object obj, GeoObjectNode objectModel);
    private void HandleCircularReferencing(object obj, GeoObjectNode objectModel, string fieldName);
    private static bool IsSimpleType(Type type);
    private static void CreateNodeForSimpleType(object serializationObject, GeoObjectNode currentModel);
    private void CreateNodeForArrayType(Array array, GeoObjectNode objectModel);
    private void CreateNodeForIEnumerableType(IEnumerable sequence, GeoObjectNode objectModel);
    private void CreateNodeForNormalType(object serializationObject, GeoObjectNode currentModel);
    private void RaiseEventAndCreateNodeForProperty(object serializationObject, GeoObjectNode currentModel, PropertyInfo property);
    private void RaiseEventAndCreateNodeForField(object serializationObject, GeoObjectNode currentModel, FieldInfo field);
    private static bool IsSerializable(FieldInfo field);
    private static bool IsSerializable(PropertyInfo property);
    private object CreateObjectFromModel(GeoObjectNode node, string typeName);
    private static string ReplaceInvalidCharacters(string name);
    private object CreateArray(GeoObjectNode node, Type type);
    private void SetValue(Array b, int rank, List`1<int> indecies, Collection`1<object> values, Int32& index);
    private void CreateIEnumerableObject(object result, GeoObjectNode node, Type type);
    private static object CreateSimpleObject(GeoObjectNode node, Type type);
    private object CreateNormalObject(GeoObjectNode node, object result);
    private static object GetSimpleTypeResult(Type type, string value);
    private Collection`1<MemberInfo> GetPrivateFieldsByType(Type type);
    private static Collection`1<MemberInfo> GetPublicPropertiesByType(Type type);
    private static bool IsSettable(PropertyInfo propertyInfo);
    private bool IsInitValue(FieldInfo fieldInfo, object ownerValue, Type ownerType);
    private bool IsInitValue(PropertyInfo propertyInfo, object ownerValue, Type ownerType);
    private object GetInitObject(Type ownerType);
    private bool AreSame(object obj1, object obj2, Type objType, bool checkProperties, bool checkFields);
    private bool FieldsSame(object obj1, object obj2, Type objType);
    private bool PropertiesSame(object obj1, object obj2, Type objType);
    private IEnumerable`1<FieldInfo> FilterFields(Type objType);
    private static IEnumerable`1<PropertyInfo> FilterProperties(Type objType);
    private bool AreIEnumerablesSame(object obj1, object obj2, bool checkProperties, bool checkFields);
}
internal enum ThinkGeo.Core.GeoObjectModelerDefaultValueMode : Enum {
    public int value__;
    public static GeoObjectModelerDefaultValueMode IncludeDefaultValues;
    public static GeoObjectModelerDefaultValueMode ExcludeDefaultValues;
}
[FlagsAttribute]
internal enum ThinkGeo.Core.GeoObjectModelerMemberTypes : Enum {
    public int value__;
    public static GeoObjectModelerMemberTypes Fields;
    public static GeoObjectModelerMemberTypes Properties;
}
public class ThinkGeo.Core.GeoObjectNode : object {
    [ObfuscationAttribute]
private string name;
    [ObfuscationAttribute]
private GeoObjectNode parent;
    [ObfuscationAttribute]
private Collection`1<GeoObjectNode> children;
    [ObfuscationAttribute]
private Dictionary`2<string, string> attributes;
    [ObfuscationAttribute]
private string actualValue;
    [ObfuscationAttribute]
private bool isDefaultValue;
    [ObfuscationAttribute]
internal bool isNonGenericSequence;
    public string Name { get; public set; }
    public GeoObjectNode Parent { get; public set; }
    public Collection`1<GeoObjectNode> Children { get; private set; }
    public Dictionary`2<string, string> Attributes { get; private set; }
    public string Value { get; public set; }
    public bool IsDefaultValue { get; public set; }
    internal bool hBo= { get; internal set; }
    internal GeoObjectNode hho= { get; }
    internal GeoObjectNode iBo= { get; }
    public GeoObjectNode(string name);
    public string get_Name();
    public void set_Name(string value);
    public GeoObjectNode get_Parent();
    public void set_Parent(GeoObjectNode value);
    public Collection`1<GeoObjectNode> get_Children();
    private void set_Children(Collection`1<GeoObjectNode> value);
    public Dictionary`2<string, string> get_Attributes();
    private void set_Attributes(Dictionary`2<string, string> value);
    public string get_Value();
    public void set_Value(string value);
    public bool get_IsDefaultValue();
    public void set_IsDefaultValue(bool value);
    internal bool gho=();
    internal void gxo=(bool value);
    internal GeoObjectNode hRo=();
    internal GeoObjectNode hxo=();
    internal void iRo=(string attributeName, string attributeValue);
    internal string iho=(string attributeName);
    internal void ixo=(string attributeName);
    public virtual string ToString();
}
[ObfuscationAttribute]
internal class ThinkGeo.Core.GeoObjectNodeAndGuid : object {
    [ObfuscationAttribute]
private GeoObjectNode node;
    [ObfuscationAttribute]
private string id;
    internal GeoObjectNode jRo= { get; }
    internal string XRQ= { get; }
    public GeoObjectNodeAndGuid(GeoObjectNode node, string id);
    internal GeoObjectNode jBo=();
    internal string WxQ=();
}
public class ThinkGeo.Core.GeoPen : object {
    [ObfuscationAttribute]
private float width;
    [ObfuscationAttribute]
private float miterLimit;
    [ObfuscationAttribute]
private GeoBrush brush;
    [ObfuscationAttribute]
private GeoColor color;
    [ObfuscationAttribute]
private GeoDashCap dashCap;
    [ObfuscationAttribute]
private LineDashStyle dashStyle;
    [ObfuscationAttribute]
private DrawingLineCap startCap;
    [ObfuscationAttribute]
private DrawingLineCap endCap;
    [ObfuscationAttribute]
private DrawingLineJoin lineJoin;
    [ObfuscationAttribute]
private Collection`1<float> dashPattern;
    [ObfuscationAttribute]
private long id;
    [ObfuscationAttribute]
private static long geoPenIdCounter;
    public GeoBrush Brush { get; public set; }
    public GeoColor Color { get; public set; }
    public GeoDashCap DashCap { get; public set; }
    public Collection`1<float> DashPattern { get; }
    public LineDashStyle DashStyle { get; public set; }
    public DrawingLineCap EndCap { get; public set; }
    public DrawingLineJoin LineJoin { get; public set; }
    public float MiterLimit { get; public set; }
    public DrawingLineCap StartCap { get; public set; }
    public float Width { get; public set; }
    public long Id { get; }
    public GeoPen(GeoBrush brush);
    public GeoPen(GeoColor color);
    public GeoPen(GeoColor color, float width);
    public GeoPen(GeoBrush brush, float width);
    public void SetLineCap(DrawingLineCap startCap, DrawingLineCap endCap, GeoDashCap dashCap);
    public GeoBrush get_Brush();
    public void set_Brush(GeoBrush value);
    public GeoColor get_Color();
    public void set_Color(GeoColor value);
    public GeoDashCap get_DashCap();
    public void set_DashCap(GeoDashCap value);
    public Collection`1<float> get_DashPattern();
    public LineDashStyle get_DashStyle();
    public void set_DashStyle(LineDashStyle value);
    public DrawingLineCap get_EndCap();
    public void set_EndCap(DrawingLineCap value);
    public DrawingLineJoin get_LineJoin();
    public void set_LineJoin(DrawingLineJoin value);
    public float get_MiterLimit();
    public void set_MiterLimit(float value);
    public DrawingLineCap get_StartCap();
    public void set_StartCap(DrawingLineCap value);
    public float get_Width();
    public void set_Width(float value);
    public long get_Id();
    public GeoPen CloneDeep();
    protected virtual GeoPen CloneDeepCore();
    private void fRU=();
    private bool fhU=();
}
public static class ThinkGeo.Core.GeoPens : object {
    public static GeoPen AliceBlue { get; }
    public static GeoPen AntiqueWhite { get; }
    public static GeoPen Aqua { get; }
    public static GeoPen Aquamarine { get; }
    public static GeoPen Azure { get; }
    public static GeoPen Beige { get; }
    public static GeoPen Bisque { get; }
    public static GeoPen Black { get; }
    public static GeoPen BlanchedAlmond { get; }
    public static GeoPen Blue { get; }
    public static GeoPen BlueViolet { get; }
    public static GeoPen Brown { get; }
    public static GeoPen BurlyWood { get; }
    public static GeoPen CadetBlue { get; }
    public static GeoPen Chartreuse { get; }
    public static GeoPen Chocolate { get; }
    public static GeoPen Coral { get; }
    public static GeoPen CornflowerBlue { get; }
    public static GeoPen CornSilk { get; }
    public static GeoPen Crimson { get; }
    public static GeoPen Cyan { get; }
    public static GeoPen DarkBlue { get; }
    public static GeoPen DarkCyan { get; }
    public static GeoPen DarkGoldenrod { get; }
    public static GeoPen DarkGray { get; }
    public static GeoPen DarkGreen { get; }
    public static GeoPen DarkKhaki { get; }
    public static GeoPen DarkMagenta { get; }
    public static GeoPen DarkOliveGreen { get; }
    public static GeoPen DarkOrange { get; }
    public static GeoPen DarkOrchid { get; }
    public static GeoPen DarkRed { get; }
    public static GeoPen DarkSalmon { get; }
    public static GeoPen DarkSeaGreen { get; }
    public static GeoPen DarkSlateBlue { get; }
    public static GeoPen DarkSlateGray { get; }
    public static GeoPen DarkTurquoise { get; }
    public static GeoPen DarkViolet { get; }
    public static GeoPen DeepPink { get; }
    public static GeoPen DeepSkyBlue { get; }
    public static GeoPen DimGray { get; }
    public static GeoPen DodgerBlue { get; }
    public static GeoPen Firebrick { get; }
    public static GeoPen FloralWhite { get; }
    public static GeoPen ForestGreen { get; }
    public static GeoPen Fuchsia { get; }
    public static GeoPen Gainsboro { get; }
    public static GeoPen GhostWhite { get; }
    public static GeoPen Gold { get; }
    public static GeoPen Goldenrod { get; }
    public static GeoPen Gray { get; }
    public static GeoPen Green { get; }
    public static GeoPen GreenYellow { get; }
    public static GeoPen HoneyDew { get; }
    public static GeoPen HotPink { get; }
    public static GeoPen IndianRed { get; }
    public static GeoPen Indigo { get; }
    public static GeoPen Ivory { get; }
    public static GeoPen Khaki { get; }
    public static GeoPen Lavender { get; }
    public static GeoPen LavenderBlush { get; }
    public static GeoPen LawnGreen { get; }
    public static GeoPen LemonChiffon { get; }
    public static GeoPen LightBlue { get; }
    public static GeoPen LightCoral { get; }
    public static GeoPen LightCyan { get; }
    public static GeoPen LightGoldenrodYellow { get; }
    public static GeoPen LightGray { get; }
    public static GeoPen LightGreen { get; }
    public static GeoPen LightPink { get; }
    public static GeoPen LightRed { get; }
    public static GeoPen LightSalmon { get; }
    public static GeoPen LightSeaGreen { get; }
    public static GeoPen LightSkyBlue { get; }
    public static GeoPen LightSlateGray { get; }
    public static GeoPen LightSteelBlue { get; }
    public static GeoPen LightYellow { get; }
    public static GeoPen Lime { get; }
    public static GeoPen LimeGreen { get; }
    public static GeoPen Linen { get; }
    public static GeoPen Magenta { get; }
    public static GeoPen Maroon { get; }
    public static GeoPen MediumAquamarine { get; }
    public static GeoPen MediumBlue { get; }
    public static GeoPen MediumOrchid { get; }
    public static GeoPen MediumPurple { get; }
    public static GeoPen MediumSeaGreen { get; }
    public static GeoPen MediumSlateBlue { get; }
    public static GeoPen MediumSpringGreen { get; }
    public static GeoPen MediumTurquoise { get; }
    public static GeoPen MediumVioletRed { get; }
    public static GeoPen MidnightBlue { get; }
    public static GeoPen MintCream { get; }
    public static GeoPen MistyRose { get; }
    public static GeoPen Moccasin { get; }
    public static GeoPen NavajoWhite { get; }
    public static GeoPen Navy { get; }
    public static GeoPen OldLace { get; }
    public static GeoPen Olive { get; }
    public static GeoPen OliveDrab { get; }
    public static GeoPen Orange { get; }
    public static GeoPen OrangeRed { get; }
    public static GeoPen Orchid { get; }
    public static GeoPen PaleGoldenrod { get; }
    public static GeoPen PaleGreen { get; }
    public static GeoPen PaleTurquoise { get; }
    public static GeoPen PaleVioletRed { get; }
    public static GeoPen PapayaWhip { get; }
    public static GeoPen PeachPuff { get; }
    public static GeoPen Peru { get; }
    public static GeoPen Pink { get; }
    public static GeoPen Plum { get; }
    public static GeoPen PowderBlue { get; }
    public static GeoPen Purple { get; }
    public static GeoPen Red { get; }
    public static GeoPen RosyBrown { get; }
    public static GeoPen RoyalBlue { get; }
    public static GeoPen SaddleBrown { get; }
    public static GeoPen Salmon { get; }
    public static GeoPen SandyBrown { get; }
    public static GeoPen SeaGreen { get; }
    public static GeoPen SeaShell { get; }
    public static GeoPen Sienna { get; }
    public static GeoPen Silver { get; }
    public static GeoPen SkyBlue { get; }
    public static GeoPen SlateBlue { get; }
    public static GeoPen SlateGray { get; }
    public static GeoPen Snow { get; }
    public static GeoPen SpringGreen { get; }
    public static GeoPen SteelBlue { get; }
    public static GeoPen Tan { get; }
    public static GeoPen Teal { get; }
    public static GeoPen Thistle { get; }
    public static GeoPen Tomato { get; }
    public static GeoPen Turquoise { get; }
    public static GeoPen Violet { get; }
    public static GeoPen Wheat { get; }
    public static GeoPen White { get; }
    public static GeoPen WhiteSmoke { get; }
    public static GeoPen Yellow { get; }
    public static GeoPen YellowGreen { get; }
    public static GeoPen DarkYellow { get; }
    public static GeoPen LightOrange { get; }
    public static GeoPen PaleRed { get; }
    public static GeoPen PaleBlue { get; }
    public static GeoPen PaleYellow { get; }
    public static GeoPen PaleOrange { get; }
    public static GeoPen BrightRed { get; }
    public static GeoPen BrightBlue { get; }
    public static GeoPen BrightYellow { get; }
    public static GeoPen BrightOrange { get; }
    public static GeoPen PastelRed { get; }
    public static GeoPen PastelBlue { get; }
    public static GeoPen PastelYellow { get; }
    public static GeoPen PastelGreen { get; }
    public static GeoPen PastelOrange { get; }
    public static GeoPen Copper { get; }
    public static GeoPen get_AliceBlue();
    public static GeoPen get_AntiqueWhite();
    public static GeoPen get_Aqua();
    public static GeoPen get_Aquamarine();
    public static GeoPen get_Azure();
    public static GeoPen get_Beige();
    public static GeoPen get_Bisque();
    public static GeoPen get_Black();
    public static GeoPen get_BlanchedAlmond();
    public static GeoPen get_Blue();
    public static GeoPen get_BlueViolet();
    public static GeoPen get_Brown();
    public static GeoPen get_BurlyWood();
    public static GeoPen get_CadetBlue();
    public static GeoPen get_Chartreuse();
    public static GeoPen get_Chocolate();
    public static GeoPen get_Coral();
    public static GeoPen get_CornflowerBlue();
    public static GeoPen get_CornSilk();
    public static GeoPen get_Crimson();
    public static GeoPen get_Cyan();
    public static GeoPen get_DarkBlue();
    public static GeoPen get_DarkCyan();
    public static GeoPen get_DarkGoldenrod();
    public static GeoPen get_DarkGray();
    public static GeoPen get_DarkGreen();
    public static GeoPen get_DarkKhaki();
    public static GeoPen get_DarkMagenta();
    public static GeoPen get_DarkOliveGreen();
    public static GeoPen get_DarkOrange();
    public static GeoPen get_DarkOrchid();
    public static GeoPen get_DarkRed();
    public static GeoPen get_DarkSalmon();
    public static GeoPen get_DarkSeaGreen();
    public static GeoPen get_DarkSlateBlue();
    public static GeoPen get_DarkSlateGray();
    public static GeoPen get_DarkTurquoise();
    public static GeoPen get_DarkViolet();
    public static GeoPen get_DeepPink();
    public static GeoPen get_DeepSkyBlue();
    public static GeoPen get_DimGray();
    public static GeoPen get_DodgerBlue();
    public static GeoPen get_Firebrick();
    public static GeoPen get_FloralWhite();
    public static GeoPen get_ForestGreen();
    public static GeoPen get_Fuchsia();
    public static GeoPen get_Gainsboro();
    public static GeoPen get_GhostWhite();
    public static GeoPen get_Gold();
    public static GeoPen get_Goldenrod();
    public static GeoPen get_Gray();
    public static GeoPen get_Green();
    public static GeoPen get_GreenYellow();
    public static GeoPen get_HoneyDew();
    public static GeoPen get_HotPink();
    public static GeoPen get_IndianRed();
    public static GeoPen get_Indigo();
    public static GeoPen get_Ivory();
    public static GeoPen get_Khaki();
    public static GeoPen get_Lavender();
    public static GeoPen get_LavenderBlush();
    public static GeoPen get_LawnGreen();
    public static GeoPen get_LemonChiffon();
    public static GeoPen get_LightBlue();
    public static GeoPen get_LightCoral();
    public static GeoPen get_LightCyan();
    public static GeoPen get_LightGoldenrodYellow();
    public static GeoPen get_LightGray();
    public static GeoPen get_LightGreen();
    public static GeoPen get_LightPink();
    public static GeoPen get_LightRed();
    public static GeoPen get_LightSalmon();
    public static GeoPen get_LightSeaGreen();
    public static GeoPen get_LightSkyBlue();
    public static GeoPen get_LightSlateGray();
    public static GeoPen get_LightSteelBlue();
    public static GeoPen get_LightYellow();
    public static GeoPen get_Lime();
    public static GeoPen get_LimeGreen();
    public static GeoPen get_Linen();
    public static GeoPen get_Magenta();
    public static GeoPen get_Maroon();
    public static GeoPen get_MediumAquamarine();
    public static GeoPen get_MediumBlue();
    public static GeoPen get_MediumOrchid();
    public static GeoPen get_MediumPurple();
    public static GeoPen get_MediumSeaGreen();
    public static GeoPen get_MediumSlateBlue();
    public static GeoPen get_MediumSpringGreen();
    public static GeoPen get_MediumTurquoise();
    public static GeoPen get_MediumVioletRed();
    public static GeoPen get_MidnightBlue();
    public static GeoPen get_MintCream();
    public static GeoPen get_MistyRose();
    public static GeoPen get_Moccasin();
    public static GeoPen get_NavajoWhite();
    public static GeoPen get_Navy();
    public static GeoPen get_OldLace();
    public static GeoPen get_Olive();
    public static GeoPen get_OliveDrab();
    public static GeoPen get_Orange();
    public static GeoPen get_OrangeRed();
    public static GeoPen get_Orchid();
    public static GeoPen get_PaleGoldenrod();
    public static GeoPen get_PaleGreen();
    public static GeoPen get_PaleTurquoise();
    public static GeoPen get_PaleVioletRed();
    public static GeoPen get_PapayaWhip();
    public static GeoPen get_PeachPuff();
    public static GeoPen get_Peru();
    public static GeoPen get_Pink();
    public static GeoPen get_Plum();
    public static GeoPen get_PowderBlue();
    public static GeoPen get_Purple();
    public static GeoPen get_Red();
    public static GeoPen get_RosyBrown();
    public static GeoPen get_RoyalBlue();
    public static GeoPen get_SaddleBrown();
    public static GeoPen get_Salmon();
    public static GeoPen get_SandyBrown();
    public static GeoPen get_SeaGreen();
    public static GeoPen get_SeaShell();
    public static GeoPen get_Sienna();
    public static GeoPen get_Silver();
    public static GeoPen get_SkyBlue();
    public static GeoPen get_SlateBlue();
    public static GeoPen get_SlateGray();
    public static GeoPen get_Snow();
    public static GeoPen get_SpringGreen();
    public static GeoPen get_SteelBlue();
    public static GeoPen get_Tan();
    public static GeoPen get_Teal();
    public static GeoPen get_Thistle();
    public static GeoPen get_Tomato();
    public static GeoPen get_Turquoise();
    public static GeoPen get_Violet();
    public static GeoPen get_Wheat();
    public static GeoPen get_White();
    public static GeoPen get_WhiteSmoke();
    public static GeoPen get_Yellow();
    public static GeoPen get_YellowGreen();
    public static GeoPen get_DarkYellow();
    public static GeoPen get_LightOrange();
    public static GeoPen get_PaleRed();
    public static GeoPen get_PaleBlue();
    public static GeoPen get_PaleYellow();
    public static GeoPen get_PaleOrange();
    public static GeoPen get_BrightRed();
    public static GeoPen get_BrightBlue();
    public static GeoPen get_BrightYellow();
    public static GeoPen get_BrightOrange();
    public static GeoPen get_PastelRed();
    public static GeoPen get_PastelBlue();
    public static GeoPen get_PastelYellow();
    public static GeoPen get_PastelGreen();
    public static GeoPen get_PastelOrange();
    public static GeoPen get_Copper();
}
public abstract class ThinkGeo.Core.GeoSerializationFormatter : object {
    [ObfuscationAttribute]
private Encoding encoding;
    public Encoding Encoding { get; public set; }
    public Encoding get_Encoding();
    public void set_Encoding(Encoding value);
    public void Save(GeoObjectModel model, Stream stream);
    protected abstract virtual void SaveCore(GeoObjectModel model, Stream stream);
    public GeoObjectModel Load(Stream stream);
    protected abstract virtual GeoObjectModel LoadCore(Stream stream);
}
public class ThinkGeo.Core.GeoSerializer : object {
    [ObfuscationAttribute]
private GeoSerializationFormatter formatter;
    [ObfuscationAttribute]
private GeoObjectModeler modeler;
    [ObfuscationAttribute]
private BindingFlags bindingFlags;
    public GeoSerializationFormatter Formatter { get; public set; }
    public GeoSerializer(GeoSerializationFormatter formatter);
    public GeoSerializationFormatter get_Formatter();
    public void set_Formatter(GeoSerializationFormatter value);
    public void Serialize(object objectToSerialize, string targetPathFilename);
    public void Serialize(object objectToSerialize, Stream targetStream);
    public string Serialize(object objectToSerialize);
    public object Deserialize(string sourcePathFilename, FileAccess readWriteMode);
    public object Deserialize(Stream sourceStream);
    public object Deserialize(string sourceString);
    public object Deserialize(Uri sourceUri);
}
public class ThinkGeo.Core.GeoSolidBrush : GeoBrush {
    [ObfuscationAttribute]
private GeoColor color;
    public GeoColor Color { get; public set; }
    public GeoSolidBrush(GeoColor color);
    public GeoColor get_Color();
    public void set_Color(GeoColor value);
}
public class ThinkGeo.Core.GeoTextureBrush : GeoBrush {
    [ObfuscationAttribute]
private GeoImage geoImage;
    [ObfuscationAttribute]
private GeoBrushWrapMode geoWrapMode;
    [ObfuscationAttribute]
private DrawingRectangleF drawingRectangleF;
    public GeoImage GeoImage { get; }
    public DrawingRectangleF DrawingRectangleF { get; public set; }
    public GeoBrushWrapMode GeoWrapMode { get; public set; }
    public GeoTextureBrush(GeoImage image);
    public GeoTextureBrush(GeoImage image, DrawingRectangleF rectangleF);
    public GeoTextureBrush(GeoImage image, GeoBrushWrapMode wrapMode);
    public GeoTextureBrush(GeoImage image, GeoBrushWrapMode wrapMode, DrawingRectangleF rectangleF);
    public GeoImage get_GeoImage();
    public DrawingRectangleF get_DrawingRectangleF();
    public void set_DrawingRectangleF(DrawingRectangleF value);
    public GeoBrushWrapMode get_GeoWrapMode();
    public void set_GeoWrapMode(GeoBrushWrapMode value);
}
public class ThinkGeo.Core.GeoTiffRasterLayer : RasterLayer {
    [ObfuscationAttribute]
private DrawingQuality drawingQuality;
    public string ImagePathFilename { get; public set; }
    public bool HasBoundingBox { get; }
    public DrawingQuality DrawingQuality { get; public set; }
    public GeoTiffRasterLayer(string imagePathFilename);
    public GeoTiffRasterLayer(string imagePathFilename, string worldfilePathFilename);
    public GeoTiffRasterLayer(string imagePathFilename, RectangleShape imageWorldExtent);
    public string get_ImagePathFilename();
    public void set_ImagePathFilename(string value);
    public virtual bool get_HasBoundingBox();
    public DrawingQuality get_DrawingQuality();
    public void set_DrawingQuality(DrawingQuality value);
    protected virtual void DrawCore(GeoCanvas canvas, Collection`1<SimpleCandidate> labelsInAllLayers);
}
public class ThinkGeo.Core.GeoTiffRasterSource : RasterSource {
    [ObfuscationAttribute]
private static int pixelAmount;
    [ObfuscationAttribute]
private string imagePathFilename;
    [ObfuscationAttribute]
private WorldFile tiffWorldFile;
    [ObfuscationAttribute]
private int previousImageWidth;
    [ObfuscationAttribute]
private int previousImageHeight;
    [ObfuscationAttribute]
private int imageWidth;
    [ObfuscationAttribute]
private int imageHeight;
    [ObfuscationAttribute]
private Int32[] imageBuffer;
    [ObfuscationAttribute]
private RectangleShape imageExtent;
    private Tiff bCE=;
    [ObfuscationAttribute]
private string worldfilePathFilename;
    [ObfuscationAttribute]
private bool tiffIsTiled;
    [ObfuscationAttribute]
private int rowNumberPerStrip;
    [ObfuscationAttribute]
private int planarConfig;
    [ObfuscationAttribute]
private Dictionary`2<short, DrawingRectangle> levelImageSize;
    [ObfuscationAttribute]
private short directoriesCount;
    [ObfuscationAttribute]
private int tileLength;
    [ObfuscationAttribute]
private int tileWidth;
    [ObfuscationAttribute]
private int tileDepth;
    [ObfuscationAttribute]
private Int64[] tileOffsets;
    [ObfuscationAttribute]
private Int64[] tileBytesCounts;
    [ObfuscationAttribute]
private short samplesPerPixel;
    [ObfuscationAttribute]
private int tilesCount;
    [ObfuscationAttribute]
private int photoMetric;
    private static object bSE=;
    public string ImagePathFilename { get; public set; }
    public GeoTiffRasterSource(string imagePathFilename);
    public GeoTiffRasterSource(string imagePathFilename, string worldFilePathFilename);
    public GeoTiffRasterSource(string imagePathFilename, RectangleShape imageExtent);
    private static GeoTiffRasterSource();
    public string get_ImagePathFilename();
    public void set_ImagePathFilename(string value);
    protected virtual int GetImageWidthCore();
    protected virtual int GetImageHeightCore();
    protected virtual RectangleShape GetBoundingBoxCore();
    protected virtual void OpenCore();
    protected virtual void CloseCore();
    protected virtual GeoImage GetImageCore(RectangleShape worldExtent, int canvasWidth, int canvasHeight);
    private Dictionary`2<short, double> biE=(RectangleShape imageFullExtentInWorld);
    private Dictionary`2<short, double> byE=(RectangleShape imageFullExtentInWorld);
    private GeoImage cCE=(int overlapUpLeftPointXInImage, int overlapUpLeftPointYInImage, int overlapWidthInImage, int overlapHeightInImage, int overlapWidthInScreen, int overlapHeightInScreen);
    private GeoImage cCE=(RectangleShape worldExtent, int canvasWidth, int canvasHeight);
    private GeoImage cSE=(int screenX, int screenY, int overlapWidth, int overlapHeight, int tempReturnWidth, int tempReturnHeight);
    private void ciE=(object tileInfo);
    private WorldFile cyE=();
    private void dCE=();
}
public class ThinkGeo.Core.GettingAccessTokenEventArgs : EventArgs {
    [CompilerGeneratedAttribute]
private WebRequest nxQ=;
    [CompilerGeneratedAttribute]
private bool ixQ=;
    public WebRequest WebRequest { get; }
    public bool Cancel { get; public set; }
    public GettingAccessTokenEventArgs(WebRequest webRequest);
    public GettingAccessTokenEventArgs(WebRequest webRequest, bool cancel);
    [CompilerGeneratedAttribute]
public WebRequest get_WebRequest();
    [CompilerGeneratedAttribute]
public bool get_Cancel();
    [CompilerGeneratedAttribute]
public void set_Cancel(bool value);
}
public class ThinkGeo.Core.GettingCacheImageBitmapTileCacheEventArgs : EventArgs {
    [ObfuscationAttribute]
private RasterTile bitmapTile;
    public RasterTile BitmapTile { get; public set; }
    public GettingCacheImageBitmapTileCacheEventArgs(RasterTile bitmapTile);
    public RasterTile get_BitmapTile();
    public void set_BitmapTile(RasterTile value);
}
public class ThinkGeo.Core.GettingCacheTileFileVectorTileCacheEventArgs : EventArgs {
    [ObfuscationAttribute]
private string tilePathFilename;
    [CompilerGeneratedAttribute]
private bool ixQ=;
    [CompilerGeneratedAttribute]
private VectorTile Nys=;
    public string TilePathFilename { get; }
    public bool Cancel { get; public set; }
    public VectorTile AlternativeTile { get; public set; }
    public GettingCacheTileFileVectorTileCacheEventArgs(string tilePathFilename);
    public string get_TilePathFilename();
    [CompilerGeneratedAttribute]
public bool get_Cancel();
    [CompilerGeneratedAttribute]
public void set_Cancel(bool value);
    [CompilerGeneratedAttribute]
public VectorTile get_AlternativeTile();
    [CompilerGeneratedAttribute]
public void set_AlternativeTile(VectorTile value);
}
public class ThinkGeo.Core.GettingColumnsFeatureSourceEventArgs : EventArgs {
    [ObfuscationAttribute]
private bool cancel;
    [ObfuscationAttribute]
private Collection`1<FeatureSourceColumn> featureSourceColumns;
    public Collection`1<FeatureSourceColumn> FeatureSourceColumns { get; }
    public bool Cancel { get; public set; }
    public Collection`1<FeatureSourceColumn> get_FeatureSourceColumns();
    public bool get_Cancel();
    public void set_Cancel(bool value);
}
public class ThinkGeo.Core.GettingFeaturesByIdsFeatureSourceEventArgs : EventArgs {
    [ObfuscationAttribute]
private bool cancel;
    [ObfuscationAttribute]
private Collection`1<Feature> features;
    [ObfuscationAttribute]
private Collection`1<string> ids;
    [ObfuscationAttribute]
private Collection`1<string> returningColumnNames;
    [ObfuscationAttribute]
private string filter;
    public string Filter { get; public set; }
    public bool Cancel { get; public set; }
    public Collection`1<string> ReturningColumnNames { get; }
    public Collection`1<Feature> Features { get; }
    public Collection`1<string> Ids { get; }
    public GettingFeaturesByIdsFeatureSourceEventArgs(IEnumerable`1<string> ids, IEnumerable`1<string> returningColumnNames);
    public GettingFeaturesByIdsFeatureSourceEventArgs(IEnumerable`1<string> ids, IEnumerable`1<string> returningColumnNames, string filter);
    public string get_Filter();
    public void set_Filter(string value);
    public bool get_Cancel();
    public void set_Cancel(bool value);
    public Collection`1<string> get_ReturningColumnNames();
    public Collection`1<Feature> get_Features();
    public Collection`1<string> get_Ids();
}
public class ThinkGeo.Core.GettingFeaturesForDrawingFeatureSourceEventArgs : EventArgs {
    [ObfuscationAttribute]
private bool cancel;
    [ObfuscationAttribute]
private string filter;
    [ObfuscationAttribute]
private Collection`1<Feature> features;
    [ObfuscationAttribute]
private RectangleShape worldExtent;
    [ObfuscationAttribute]
private Collection`1<string> returningColumnNames;
    public Collection`1<string> ReturningColumnNames { get; }
    public string Filter { get; }
    public RectangleShape WorldExtent { get; public set; }
    public bool Cancel { get; public set; }
    public Collection`1<Feature> Features { get; }
    public GettingFeaturesForDrawingFeatureSourceEventArgs(RectangleShape worldExtent, IEnumerable`1<string> returningColumnNames);
    public GettingFeaturesForDrawingFeatureSourceEventArgs(RectangleShape worldExtent, IEnumerable`1<string> returningColumnNames, string filter);
    public Collection`1<string> get_ReturningColumnNames();
    public string get_Filter();
    public RectangleShape get_WorldExtent();
    public void set_WorldExtent(RectangleShape value);
    public bool get_Cancel();
    public void set_Cancel(bool value);
    public Collection`1<Feature> get_Features();
}
[ObfuscationAttribute]
internal enum ThinkGeo.Core.Gist_Ext_Id : Enum {
    public int value__;
    public static Gist_Ext_Id rt_point_ext_id;
    public static Gist_Ext_Id rt_rect_ext_id;
    public static Gist_Ext_Id gist_numext;
}
public class ThinkGeo.Core.GoogleMapsAsyncLayer : WebBasedAsyncLayer {
    private static RectangleShape 1B0=;
    [ObfuscationAttribute]
private ProjectionConverter projectionFromSphericalMercator;
    [ObfuscationAttribute]
private ProjectionConverter googleWgs84Projection;
    [ObfuscationAttribute]
private double currentRequestSphereResolution;
    [CompilerGeneratedAttribute]
private GoogleMapsPictureFormat 1R0=;
    [CompilerGeneratedAttribute]
private GoogleMapsMapType 1h0=;
    [CompilerGeneratedAttribute]
private string 1x0=;
    [CompilerGeneratedAttribute]
private string uB0=;
    [CompilerGeneratedAttribute]
private string 2B0=;
    [CompilerGeneratedAttribute]
private string 2R0=;
    [CompilerGeneratedAttribute]
private string 2h0=;
    [CompilerGeneratedAttribute]
private Dictionary`2<string, string> 2x0=;
    [CompilerGeneratedAttribute]
private Projection 3B0=;
    public GoogleMapsPictureFormat PictureFormat { get; public set; }
    public GoogleMapsMapType MapType { get; public set; }
    public string Language { get; public set; }
    public string ClientId { get; public set; }
    public string PrivateKey { get; public set; }
    public string UriSigningSecret { get; public set; }
    public string ApiKey { get; public set; }
    public Dictionary`2<string, string> CustomParameters { get; }
    public Projection TargetProjection { get; public set; }
    public GoogleMapsAsyncLayer(string apiKey);
    public GoogleMapsAsyncLayer(string apiKey, string uriSigningSecret);
    private static GoogleMapsAsyncLayer();
    [CompilerGeneratedAttribute]
public GoogleMapsPictureFormat get_PictureFormat();
    [CompilerGeneratedAttribute]
public void set_PictureFormat(GoogleMapsPictureFormat value);
    [CompilerGeneratedAttribute]
public GoogleMapsMapType get_MapType();
    [CompilerGeneratedAttribute]
public void set_MapType(GoogleMapsMapType value);
    [CompilerGeneratedAttribute]
public string get_Language();
    [CompilerGeneratedAttribute]
public void set_Language(string value);
    [CompilerGeneratedAttribute]
public string get_ClientId();
    [CompilerGeneratedAttribute]
public void set_ClientId(string value);
    [CompilerGeneratedAttribute]
public string get_PrivateKey();
    [CompilerGeneratedAttribute]
public void set_PrivateKey(string value);
    [CompilerGeneratedAttribute]
public string get_UriSigningSecret();
    [CompilerGeneratedAttribute]
public void set_UriSigningSecret(string value);
    [CompilerGeneratedAttribute]
public string get_ApiKey();
    [CompilerGeneratedAttribute]
public void set_ApiKey(string value);
    [CompilerGeneratedAttribute]
public Dictionary`2<string, string> get_CustomParameters();
    [CompilerGeneratedAttribute]
public Projection get_TargetProjection();
    [CompilerGeneratedAttribute]
public void set_TargetProjection(Projection value);
    [AsyncStateMachineAttribute("ThinkGeo.Core.GoogleMapsAsyncLayer/<OpenAsyncCore>d__42")]
protected virtual Task OpenAsyncCore(CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("ThinkGeo.Core.GoogleMapsAsyncLayer/<CloseAsyncCore>d__43")]
protected virtual Task CloseAsyncCore(CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("ThinkGeo.Core.GoogleMapsAsyncLayer/<DrawAsyncCore>d__44")]
protected virtual Task DrawAsyncCore(GeoCanvas canvas, Collection`1<SimpleCandidate> labelsInAllLayers);
    [AsyncStateMachineAttribute("ThinkGeo.Core.GoogleMapsAsyncLayer/<DownloadImageAsyncCore>d__45")]
protected virtual Task`1<Byte[]> DownloadImageAsyncCore(double width, double height, double scaleFactor, RectangleShape extent, GeographyUnit mapUnit, CancellationToken cancellationToken);
    private RectangleShape 3R0=(GeoCanvas canvas);
    private string 3h0=(double latitude, double longitude, int zoomLevelNumber, double tileWidth, double tileHeight, int scaleFactor);
    private static string 3x0=(double newWidth, double newHeight, int zoomLevelNumber, double latitude, double longitude);
    private string 4B0=();
    public string GetPictureFormat();
    private string 4R0=(string url);
    private string 4R0=(string url, string uriSigningSecret);
    private static Byte[] 4h0=(string value);
    [CompilerGeneratedAttribute]
[DebuggerHiddenAttribute]
private Task <>n__0(CancellationToken cancellationToken);
    [DebuggerHiddenAttribute]
[CompilerGeneratedAttribute]
private Task <>n__1(CancellationToken cancellationToken);
}
[ObfuscationAttribute]
internal class ThinkGeo.Core.GoogleMapsLayerImageCache : object {
    [ObfuscationAttribute]
private string cacheDirectory;
    public string jSE= { get; public set; }
    public bool jyE= { get; }
    public string iyE=();
    public void jCE=(string value);
    public bool jiE=();
    public string kCE=(GoogleMapsMapType mapType, int zoomlevel, int tileX, int tileY, GoogleMapsPictureFormat pictureFormat);
    public void kSE=(GeoImage image, GoogleMapsMapType mapType, int zoomlevel, int tileX, int tileY, GoogleMapsPictureFormat pictureFormat);
    public GeoImage kiE=(GoogleMapsMapType mapType, int zoomlevel, int tileX, int tileY, GoogleMapsPictureFormat pictureFormat);
    private static string 4B0=(GoogleMapsMapType mapType);
    public static GeoImageFormat kyE=(GoogleMapsPictureFormat pictureFormat);
    public static string lCE=(GoogleMapsPictureFormat pictureFormat);
}
public enum ThinkGeo.Core.GoogleMapsMapType : Enum {
    public int value__;
    public static GoogleMapsMapType RoadMap;
    public static GoogleMapsMapType Mobile;
    public static GoogleMapsMapType Satellite;
    public static GoogleMapsMapType Terrain;
    public static GoogleMapsMapType Hybrid;
}
public enum ThinkGeo.Core.GoogleMapsPictureFormat : Enum {
    public int value__;
    public static GoogleMapsPictureFormat Jpeg;
    public static GoogleMapsPictureFormat Gif;
    public static GoogleMapsPictureFormat Png8;
    public static GoogleMapsPictureFormat Png32;
}
public class ThinkGeo.Core.GoogleMapsZoomLevelSet : ZoomLevelSet {
    public GoogleMapsZoomLevelSet(int tileSize);
}
public static class ThinkGeo.Core.GoogleMapValidators : object {
    public static void CheckGoogleMapsTypeIsValid(GoogleMapsMapType mapType, string parameterName);
}
public class ThinkGeo.Core.GottenCacheImageBitmapTileCacheEventArgs : EventArgs {
    [ObfuscationAttribute]
private Tile tile;
    public Tile Tile { get; public set; }
    public GottenCacheImageBitmapTileCacheEventArgs(Tile tile);
    public Tile get_Tile();
    public void set_Tile(Tile value);
}
public class ThinkGeo.Core.GottenColumnsFeatureSourceEventArgs : EventArgs {
    [ObfuscationAttribute]
private Collection`1<FeatureSourceColumn> featureSourceColumns;
    public Collection`1<FeatureSourceColumn> FeatureSourceColumns { get; }
    public GottenColumnsFeatureSourceEventArgs(IEnumerable`1<FeatureSourceColumn> featureSourceColumns);
    public Collection`1<FeatureSourceColumn> get_FeatureSourceColumns();
}
public class ThinkGeo.Core.GottenFeatureValueClassBreakStyleEventArgs : EventArgs {
    [ObfuscationAttribute]
private Feature feature;
    [ObfuscationAttribute]
private string columnName;
    [ObfuscationAttribute]
private double newValue;
    public double Value { get; public set; }
    public Feature Feature { get; public set; }
    public string ColumnName { get; public set; }
    public GottenFeatureValueClassBreakStyleEventArgs(Feature feature, string columnName, double value);
    public double get_Value();
    public void set_Value(double value);
    public Feature get_Feature();
    public void set_Feature(Feature value);
    public string get_ColumnName();
    public void set_ColumnName(string value);
}
public class ThinkGeo.Core.GottenTileFileVectorTileCacheEventArgs : EventArgs {
    [CompilerGeneratedAttribute]
private VectorTile OCs=;
    public VectorTile Tile { get; public set; }
    public GottenTileFileVectorTileCacheEventArgs(VectorTile tile);
    [CompilerGeneratedAttribute]
public VectorTile get_Tile();
    [CompilerGeneratedAttribute]
public void set_Tile(VectorTile value);
}
public class ThinkGeo.Core.GpxFeatureLayer : FeatureLayer {
    public string GpxPathFilename { get; public set; }
    public bool HasBoundingBox { get; }
    public GpxFeatureLayer(string gpxPathFilename);
    public string get_GpxPathFilename();
    public void set_GpxPathFilename(string value);
    public void add_StreamLoading(EventHandler`1<StreamLoadingEventArgs> value);
    public void remove_StreamLoading(EventHandler`1<StreamLoadingEventArgs> value);
    public virtual bool get_HasBoundingBox();
}
public class ThinkGeo.Core.GpxFeatureSource : FeatureSource {
    private static string piE=;
    [CompilerGeneratedAttribute]
private EventHandler`1<StreamLoadingEventArgs> StreamLoading;
    [ObfuscationAttribute]
private string gpxPathFilename;
    [ObfuscationAttribute]
private RectangleShape boundingBox;
    [ObfuscationAttribute]
private InMemoryFeatureSource source;
    [ObfuscationAttribute]
private Collection`1<Feature> segmentPoints;
    [ObfuscationAttribute]
private Dictionary`2<string, FeatureSourceColumn> tempColumns;
    [ObfuscationAttribute]
private Dictionary`2<string, string> metadata;
    public string GpxPathFilename { get; public set; }
    public GpxFeatureSource(string gpxPathFilename);
    [CompilerGeneratedAttribute]
public void add_StreamLoading(EventHandler`1<StreamLoadingEventArgs> value);
    [CompilerGeneratedAttribute]
public void remove_StreamLoading(EventHandler`1<StreamLoadingEventArgs> value);
    public string get_GpxPathFilename();
    public void set_GpxPathFilename(string value);
    protected virtual void OnStreamLoading(StreamLoadingEventArgs e);
    public Dictionary`2<string, string> GetMetadata();
    protected virtual void OpenCore();
    protected virtual void CloseCore();
    protected virtual bool CanGetCountQuicklyCore();
    protected virtual Collection`1<Feature> GetAllFeaturesCore(IEnumerable`1<string> returningColumnNames);
    protected virtual Collection`1<Feature> GetAllFeaturesCore(IEnumerable`1<string> returningColumnNames, int startIndex, int takeCount);
    protected virtual long GetCountCore();
    protected virtual Collection`1<FeatureSourceColumn> GetColumnsCore();
    protected virtual Collection`1<Feature> GetFeaturesInsideBoundingBoxCore(RectangleShape boundingBox, IEnumerable`1<string> returningColumnNames);
    protected virtual RectangleShape GetBoundingBoxCore();
    protected virtual WellKnownType GetFirstFeaturesWellKnownTypeCore();
    private Feature pyE=(XElement wayPointNode);
    private Feature qCE=(XElement routeNode);
    private Feature qSE=(XElement trackNode);
    private LineShape qiE=(XElement trackSeg);
}
public class ThinkGeo.Core.GradientStyle : Style {
    [ObfuscationAttribute]
private string columnName;
    [ObfuscationAttribute]
private GeoColor lowerColor;
    [ObfuscationAttribute]
private double lowerValue;
    [ObfuscationAttribute]
private GeoColor noDataColor;
    [ObfuscationAttribute]
private double noDataValue;
    [ObfuscationAttribute]
private GeoColor upperColor;
    [ObfuscationAttribute]
private double upperValue;
    public string ColumnName { get; public set; }
    public double LowerValue { get; public set; }
    public GeoColor LowerColor { get; public set; }
    public double UpperValue { get; public set; }
    public GeoColor UpperColor { get; public set; }
    public double NoDataValue { get; public set; }
    public GeoColor NoDataColor { get; public set; }
    public GradientStyle(string columnName, double lowerValue, GeoColor lowerColor, double upperValue, GeoColor upperColor);
    public GradientStyle(string columnName, double lowerValue, GeoColor lowerColor, double upperValue, GeoColor upperColor, double noDataValue, GeoColor noDataColor);
    public string get_ColumnName();
    public void set_ColumnName(string value);
    public double get_LowerValue();
    public void set_LowerValue(double value);
    public GeoColor get_LowerColor();
    public void set_LowerColor(GeoColor value);
    public double get_UpperValue();
    public void set_UpperValue(double value);
    public GeoColor get_UpperColor();
    public void set_UpperColor(GeoColor value);
    public double get_NoDataValue();
    public void set_NoDataValue(double value);
    public GeoColor get_NoDataColor();
    public void set_NoDataColor(GeoColor value);
    protected virtual void DrawCore(IEnumerable`1<Feature> features, GeoCanvas canvas, Collection`1<SimpleCandidate> labelsInThisLayer, Collection`1<SimpleCandidate> labelsInAllLayers);
    private GeoColor XTE=(GeoColor lowerColor, GeoColor upperColor, double value);
    protected virtual Collection`1<string> GetRequiredColumnNamesCore();
}
public class ThinkGeo.Core.GraticuleFeatureLayer : FeatureLayer {
    [ObfuscationAttribute]
private GraticuleFeatureSource graticuleFeatureSource;
    [ObfuscationAttribute]
private LineStyle graticuleLineStyle;
    [ObfuscationAttribute]
private GeoFont graticuleTextFont;
    [ObfuscationAttribute]
private GeoBrush graticuleTextBrush;
    [ObfuscationAttribute]
private GeoPen graticuleTextHaloPen;
    public LineStyle GraticuleLineStyle { get; public set; }
    public GeoFont GraticuleTextFont { get; public set; }
    public GeoBrush GraticuleTextBrush { get; public set; }
    public WrappingMode WrappingMode { get; public set; }
    public RectangleShape WrappingExtent { get; public set; }
    public GeoPen GraticuleTextHaloPen { get; public set; }
    public GraticuleFeatureLayer(int graticuleDensity);
    public LineStyle get_GraticuleLineStyle();
    public void set_GraticuleLineStyle(LineStyle value);
    public GeoFont get_GraticuleTextFont();
    public void set_GraticuleTextFont(GeoFont value);
    public GeoBrush get_GraticuleTextBrush();
    public void set_GraticuleTextBrush(GeoBrush value);
    public WrappingMode get_WrappingMode();
    public void set_WrappingMode(WrappingMode value);
    public RectangleShape get_WrappingExtent();
    public void set_WrappingExtent(RectangleShape value);
    public GeoPen get_GraticuleTextHaloPen();
    public void set_GraticuleTextHaloPen(GeoPen value);
    protected virtual bool IsDrawingNeededCore(double currentScale);
    protected virtual void DrawCore(GeoCanvas canvas, Collection`1<SimpleCandidate> labelsInAllLayers);
}
public class ThinkGeo.Core.GraticuleFeatureSource : FeatureSource {
    [ObfuscationAttribute]
private FeatureSourceColumn graticuleLabelColumn;
    private int vCE=;
    [ObfuscationAttribute]
private WrappingMode wrappingMode;
    private Collection`1<double> vSE=;
    [ObfuscationAttribute]
private RectangleShape wrappingExtent;
    private static Collection`1<double> viE=;
    private static Collection`1<double> vyE=;
    internal FeatureSourceColumn wSE= { get; }
    public WrappingMode WrappingMode { get; public set; }
    public RectangleShape WrappingExtent { get; public set; }
    public int GraticuleDensity { get; public set; }
    private static GraticuleFeatureSource();
    internal FeatureSourceColumn wCE=();
    public WrappingMode get_WrappingMode();
    public void set_WrappingMode(WrappingMode value);
    public RectangleShape get_WrappingExtent();
    public void set_WrappingExtent(RectangleShape value);
    public int get_GraticuleDensity();
    public void set_GraticuleDensity(int value);
    protected virtual Collection`1<FeatureSourceColumn> GetColumnsCore();
    protected virtual Collection`1<Feature> GetAllFeaturesCore(IEnumerable`1<string> returningColumnNames);
    protected virtual Collection`1<Feature> GetFeaturesForDrawingCore(RectangleShape boundingBox, double screenWidth, double screenHeight, IEnumerable`1<string> returningColumnNames);
    internal Collection`1<Feature> wiE=(RectangleShape extent, float scaleFactor);
    internal Collection`1<Feature> wyE=(RectangleShape extent, float scaleFcator);
    private Collection`1<Feature> xCE=(RectangleShape extent, double currentMinX, double currentMaxX, double currentMaxY, double currentMinY, double increment, double dividor);
    private Collection`1<Feature> xSE=(RectangleShape extent, double currentMinX, double currentMaxX, double currentMaxY, double currentMinY, double increment, double dividor);
    private Vertex xiE=(double x, double y, bool isWrappingLeft);
    private qyE= xyE=(RectangleShape extent);
    private RectangleShape yCE=(RectangleShape extent);
    private static double ySE=(Collection`1<double> values);
    private static double yiE=(Collection`1<double> values);
    private double yyE=(RectangleShape currentExtentWidth, double divisor, GeographyUnit mapUnit);
    private static string zCE=(double value, 0iE= lineType, double increment);
    private static double zSE=(double number, double interval);
    private static double ziE=(double number, double interval);
    private void zyE=();
    [CompilerGeneratedAttribute]
private Feature <GetFeaturesForDrawingCore>b__21_0(Feature f);
}
public class ThinkGeo.Core.GridCell : object {
    [ObfuscationAttribute]
private double centerX;
    [ObfuscationAttribute]
private double centerY;
    [ObfuscationAttribute]
private double value;
    [ObfuscationAttribute]
private double weight;
    public double CenterX { get; public set; }
    public double CenterY { get; public set; }
    public double Value { get; public set; }
    public double Weight { get; public set; }
    public GridCell(double centerX, double centerY, double value);
    public GridCell(double centerX, double centerY, double value, double weight);
    public double get_CenterX();
    public void set_CenterX(double value);
    public double get_CenterY();
    public void set_CenterY(double value);
    public double get_Value();
    public void set_Value(double value);
    public double get_Weight();
    public void set_Weight(double value);
    public virtual int GetHashCode();
}
public class ThinkGeo.Core.GridDefinition : object {
    [ObfuscationAttribute]
private RectangleShape gridExtent;
    [ObfuscationAttribute]
private Dictionary`2<PointShape, double> dataPoints;
    [ObfuscationAttribute]
private double cellSize;
    [ObfuscationAttribute]
private double noDataValue;
    [CompilerGeneratedAttribute]
private FeatureSource HCI=;
    [CompilerGeneratedAttribute]
private string HSI=;
    public FeatureSource DataPointsFeatureSource { get; public set; }
    public string DataPointsFeatureSourceColumnName { get; public set; }
    public RectangleShape GridExtent { get; public set; }
    public Dictionary`2<PointShape, double> DataPoints { get; }
    public double CellSize { get; public set; }
    public double NoDataValue { get; public set; }
    public GridDefinition(RectangleShape gridExtent, double cellSize, double noDataValue, Dictionary`2<PointShape, double> dataPoints);
    [CompilerGeneratedAttribute]
public FeatureSource get_DataPointsFeatureSource();
    [CompilerGeneratedAttribute]
public void set_DataPointsFeatureSource(FeatureSource value);
    [CompilerGeneratedAttribute]
public string get_DataPointsFeatureSourceColumnName();
    [CompilerGeneratedAttribute]
public void set_DataPointsFeatureSourceColumnName(string value);
    public RectangleShape get_GridExtent();
    public void set_GridExtent(RectangleShape value);
    public Dictionary`2<PointShape, double> get_DataPoints();
    public double get_CellSize();
    public void set_CellSize(double value);
    public double get_NoDataValue();
    public void set_NoDataValue(double value);
}
public class ThinkGeo.Core.GridFeatureLayer : FeatureLayer {
    public string PathFilename { get; public set; }
    public double CellSize { get; }
    public int NumberOfColumns { get; }
    public int NumberOfRows { get; }
    public double NoDataValue { get; }
    public bool HasBoundingBox { get; }
    public string DataValueColumnName { get; }
    public GridFeatureLayer(string gridPathFilename);
    public string get_PathFilename();
    public void set_PathFilename(string value);
    public double get_CellSize();
    public int get_NumberOfColumns();
    public int get_NumberOfRows();
    public double get_NoDataValue();
    public virtual bool get_HasBoundingBox();
    public string get_DataValueColumnName();
    protected virtual RectangleShape GetBoundingBoxCore();
    public static void GenerateGrid(GridDefinition gridDefinition, GridInterpolationModel gridInterpolationModel, Stream outputStream, Func`2<double, string> cellValueToStringFunc);
    public static GridCell[0...,0...] GenerateGridMatrix(GridDefinition gridDefinition, GridInterpolationModel gridInterpolationModel);
    public GridCell[0...,0...] GenerateGridMatrix();
    public void add_StreamLoading(EventHandler`1<StreamLoadingEventArgs> value);
    public void remove_StreamLoading(EventHandler`1<StreamLoadingEventArgs> value);
}
public class ThinkGeo.Core.GridFeatureSource : FeatureSource {
    private static string 1SE=;
    [ObfuscationAttribute]
private double cellSize;
    [ObfuscationAttribute]
private Collection`1<FeatureSourceColumn> featureSourceColumns;
    [ObfuscationAttribute]
private RectangleShape gridExtent;
    [ObfuscationAttribute]
private string pathFilename;
    [ObfuscationAttribute]
private PointShape lowerLeftPoint;
    [ObfuscationAttribute]
private double noDataValue;
    [ObfuscationAttribute]
private int columnCount;
    [ObfuscationAttribute]
private int rowCount;
    [ObfuscationAttribute]
private string gridValuesString;
    [ObfuscationAttribute]
private int gridValuesDimension0Length;
    [ObfuscationAttribute]
private int gridValuesDimension1Length;
    private bool Zxo=;
    private Double[0...,0...] 1iE=;
    [CompilerGeneratedAttribute]
private static EventHandler`1<GeneratingGridFeatureSourceEventArgs> GeneratingGrid;
    [CompilerGeneratedAttribute]
private EventHandler`1<StreamLoadingEventArgs> StreamLoading;
    private static Byte[] 1yE=;
    public string PathFilename { get; public set; }
    public double CellSize { get; }
    public int NumberOfColumns { get; }
    public int NumberOfRows { get; }
    public PointShape LowerLeftPoint { get; }
    public double NoDataValue { get; }
    public bool IsEditable { get; }
    public string DataValueColumnName { get; }
    public GridFeatureSource(string gridPathFilename);
    private static GridFeatureSource();
    [CompilerGeneratedAttribute]
public static void add_GeneratingGrid(EventHandler`1<GeneratingGridFeatureSourceEventArgs> value);
    [CompilerGeneratedAttribute]
public static void remove_GeneratingGrid(EventHandler`1<GeneratingGridFeatureSourceEventArgs> value);
    [CompilerGeneratedAttribute]
public void add_StreamLoading(EventHandler`1<StreamLoadingEventArgs> value);
    [CompilerGeneratedAttribute]
public void remove_StreamLoading(EventHandler`1<StreamLoadingEventArgs> value);
    public string get_PathFilename();
    public void set_PathFilename(string value);
    public double get_CellSize();
    public int get_NumberOfColumns();
    public int get_NumberOfRows();
    public PointShape get_LowerLeftPoint();
    public double get_NoDataValue();
    public virtual bool get_IsEditable();
    public string get_DataValueColumnName();
    protected virtual void OpenCore();
    protected virtual void OnStreamLoading(StreamLoadingEventArgs e);
    protected virtual void CloseCore();
    protected virtual Collection`1<FeatureSourceColumn> GetColumnsCore();
    protected virtual TransactionResult CommitTransactionCore(TransactionBuffer transactions);
    protected virtual Collection`1<Feature> GetAllFeaturesCore(IEnumerable`1<string> returningColumnNames);
    protected virtual RectangleShape GetBoundingBoxCore();
    protected virtual long GetCountCore();
    protected virtual Collection`1<Feature> GetFeaturesForDrawingCore(RectangleShape boundingBox, double screenWidth, double screenHeight, IEnumerable`1<string> returningColumnNames);
    protected virtual Collection`1<Feature> GetFeaturesInsideBoundingBoxCore(RectangleShape boundingBox, IEnumerable`1<string> returningColumnNames);
    protected virtual Collection`1<string> GetFeatureIdsCore();
    private Byte[] 2CE=(double x1, double y1, double x2, double y2);
    private static String[] 2SE=(string stringToSplit);
    public static GridCell[0...,0...] GenerateGridMatrix(GridDefinition gridDefinition, GridInterpolationModel gridInterpolationModel);
    public GridCell[0...,0...] GenerateGridMatrix();
    public static GridCell[0...,0...] ReplaceNoDataValue(GridCell[0...,0...] gridMatrix, double noDataValue);
    public static GridCell[0...,0...] ReplaceNoDataValue(GridCell[0...,0...] gridMatrix, double noDataValue, GridInterpolationModel gridInterpolationModel);
    public static void GenerateGrid(GridDefinition gridDefinition, GridInterpolationModel gridInterpolationModel, Stream outputStream, Func`2<double, string> cellValueToStringFunc);
    public static void SaveGridsToStream(GridCell[0...,0...] cells, double noDataValue, Stream outputStream, Func`2<double, string> cellValueToStringFunc);
    public static void SaveGridsToGrdFile(GridCell[0...,0...] cells, double noDataValue, string outputFilePath, Func`2<double, string> cellValueToStringFunc);
    [OnGeoserializingAttribute]
private void 2iE=();
    [OnGeodeserializedAttribute]
private void 2yE=();
    private void 3CE=();
    private static void 3SE=(GeneratingGridFeatureSourceEventArgs e);
}
public abstract class ThinkGeo.Core.GridInterpolationModel : object {
    public ValueTuple`2<double, double> Interpolate(RectangleShape cellExtent, GridDefinition gridDefinition);
    protected abstract virtual ValueTuple`2<double, double> InterpolateCore(RectangleShape cellExtent, GridDefinition gridDefinition);
}
public class ThinkGeo.Core.GridIsoLineLayer : IsoLineLayer {
    [ObfuscationAttribute]
private GridFeatureSource gridFeatureSource;
    [ObfuscationAttribute]
private Collection`1<Feature> cachedIsoLines;
    [ObfuscationAttribute]
private int previousGridMatrixCount;
    [ObfuscationAttribute]
private int previousGridMatrixHashCode;
    [ObfuscationAttribute]
private int previousIsoLineLevelsCount;
    [ObfuscationAttribute]
private int previousIsoLineLevelsHashCode;
    [ObfuscationAttribute]
private string previousDataValueColumnName;
    [ObfuscationAttribute]
private string gridMatrixString;
    [ObfuscationAttribute]
private int gridMatrixDimension0Length;
    [ObfuscationAttribute]
private int gridMatrixDimension1Length;
    private bool Zxo=;
    private GridCell[0...,0...] giI=;
    [CompilerGeneratedAttribute]
private EventHandler`1<StreamLoadingEventArgs> StreamLoading;
    public string GridPathFilename { get; public set; }
    public GridIsoLineLayer(string gridPathFilename);
    public GridIsoLineLayer(string gridPathFilename, IEnumerable`1<double> isoLineLevels);
    public GridIsoLineLayer(string gridPathFilename, IEnumerable`1<double> isoLineLevels, double lowerScale, double upperScale);
    public GridIsoLineLayer(string gridPathFilename, IEnumerable`1<double> isoLineLevels, double lowerScale, double upperScale, IsoLineType isoLineType);
    [CompilerGeneratedAttribute]
public void add_StreamLoading(EventHandler`1<StreamLoadingEventArgs> value);
    [CompilerGeneratedAttribute]
public void remove_StreamLoading(EventHandler`1<StreamLoadingEventArgs> value);
    private void gyI=(object sender, StreamLoadingEventArgs e);
    [OnGeoserializingAttribute]
private void 2iE=();
    [OnGeodeserializedAttribute]
private void 2yE=();
    protected virtual void OpenCore();
    public string get_GridPathFilename();
    public void set_GridPathFilename(string value);
    public Collection`1<Feature> GetIsoLineFeatures();
    protected virtual void OnStreamLoading(StreamLoadingEventArgs e);
    protected virtual Collection`1<Feature> GetFeaturesForDrawingCore(GeoCanvas canvas, Collection`1<SimpleCandidate> labelsInAllLayers);
    private bool hCI=();
    private void hSI=();
}
public class ThinkGeo.Core.GroupLayer : Layer {
    [ObfuscationAttribute]
private GeoCollection`1<Layer> layers;
    public GeoCollection`1<Layer> Layers { get; }
    public bool HasBoundingBox { get; }
    public GroupLayer(IEnumerable`1<Layer> layers);
    public GeoCollection`1<Layer> get_Layers();
    public virtual bool get_HasBoundingBox();
    protected virtual void OpenCore();
    protected virtual void CloseCore();
    protected virtual RectangleShape GetBoundingBoxCore();
    protected virtual void DrawCore(GeoCanvas canvas, Collection`1<SimpleCandidate> labelsInAllLayers);
}
[ObfuscationAttribute]
internal class ThinkGeo.Core.HeaderPage : RTPage {
    [ObfuscationAttribute]
private FileHeader fileHeader;
    public FileHeader Nh8= { get; public set; }
    public HeaderPage(RtreeFile rtFile);
    public HeaderPage(RtreeFile rtFile, UInt32 pageNo, Gist_Ext_Id extId);
    public FileHeader NB8=();
    public void NR8=(FileHeader value);
    public bool ZRw=();
    public bool cxw=();
    public virtual string LB8=();
}
public class ThinkGeo.Core.HeatStyle : Style {
    [ObfuscationAttribute]
private int alpha;
    [ObfuscationAttribute]
private Collection`1<GeoColor> colorPalette;
    [ObfuscationAttribute]
private string intensityColumnName;
    [ObfuscationAttribute]
private double intensityRangeEnd;
    [ObfuscationAttribute]
private double intensityRangeStart;
    [ObfuscationAttribute]
private int pointIntensity;
    [ObfuscationAttribute]
private double pointRadius;
    [ObfuscationAttribute]
private DistanceUnit pointRadiusUnit;
    private static int JiI=;
    public int PointIntensity { get; public set; }
    public int Alpha { get; public set; }
    public double IntensityRangeStart { get; public set; }
    public double IntensityRangeEnd { get; public set; }
    public string IntensityColumnName { get; public set; }
    public double PointRadius { get; public set; }
    public DistanceUnit PointRadiusUnit { get; public set; }
    public Collection`1<GeoColor> ColorPalette { get; }
    public HeatStyle(int pointIntensity);
    public HeatStyle(int pointIntensity, int alpha);
    public HeatStyle(int pointIntensity, double pointRadius, DistanceUnit pointRadiusUnit);
    public HeatStyle(int pointIntensity, int alpha, double pointRadius, DistanceUnit pointRadiusUnit);
    public HeatStyle(string intensityColumnName, double intensityRangeStart, double intensityRangeEnd);
    public HeatStyle(int alpha, string intensityColumnName, double intensityRangeStart, double intensityRangeEnd);
    public HeatStyle(string intensityColumnName, double intensityRangeStart, double intensityRangeEnd, double pointRadius, DistanceUnit pointRadiusUnit);
    public HeatStyle(int alpha, string intensityColumnName, double intensityRangeStart, double intensityRangeEnd, double pointRadius, DistanceUnit pointRadiusUnit);
    public HeatStyle(int pointIntensity, int alpha, string intensityColumnName, double intensityRangeStart, double intensityRangeEnd, double pointRadius, DistanceUnit pointRadiusUnit, GeoColor baseColor);
    public HeatStyle(int pointIntensity, int alpha, string intensityColumnName, double intensityRangeStart, double intensityRangeEnd, double pointRadius, DistanceUnit pointRadiusUnit, GeoColor fromColor, GeoColor toColor, ColorWheelDirection colorWheelDirection);
    private static HeatStyle();
    public int get_PointIntensity();
    public void set_PointIntensity(int value);
    public int get_Alpha();
    public void set_Alpha(int value);
    public double get_IntensityRangeStart();
    public void set_IntensityRangeStart(double value);
    public double get_IntensityRangeEnd();
    public void set_IntensityRangeEnd(double value);
    public string get_IntensityColumnName();
    public void set_IntensityColumnName(string value);
    public double get_PointRadius();
    public void set_PointRadius(double value);
    public DistanceUnit get_PointRadiusUnit();
    public void set_PointRadiusUnit(DistanceUnit value);
    public Collection`1<GeoColor> get_ColorPalette();
    protected virtual void DrawCore(IEnumerable`1<Feature> features, GeoCanvas canvas, Collection`1<SimpleCandidate> labelsInThisLayer, Collection`1<SimpleCandidate> labelsInAllLayers);
    protected virtual Collection`1<string> GetRequiredColumnNamesCore();
    private float JyI=(GeoCanvas canvas);
    private static double KCI=(string value, double lowValue, double highValue);
    private static double KSI=(double degrees);
    private static cRU=[] KiI=(byte alpha, Collection`1<GeoColor> colorPalette);
}
public class ThinkGeo.Core.HereMapsRasterTileAsyncLayer : XyzTileAsyncLayer {
    private static int rx0=;
    private static string 4x0=;
    private string 5B0=;
    private string 5R0=;
    private string 5h0=;
    [CompilerGeneratedAttribute]
private string 2h0=;
    [CompilerGeneratedAttribute]
private HereMapsRasterType 1h0=;
    [CompilerGeneratedAttribute]
private HereMapsRasterTileFormat 5x0=;
    [CompilerGeneratedAttribute]
private Dictionary`2<string, string> 6B0=;
    public string ApiKey { get; public set; }
    public HereMapsRasterType MapType { get; public set; }
    public HereMapsRasterTileFormat Format { get; public set; }
    public Dictionary`2<string, string> Parameters { get; }
    public HereMapsRasterTileAsyncLayer(string apiKey);
    public HereMapsRasterTileAsyncLayer(string apiKey, HereMapsRasterType mapType);
    [CompilerGeneratedAttribute]
public string get_ApiKey();
    [CompilerGeneratedAttribute]
public void set_ApiKey(string value);
    [CompilerGeneratedAttribute]
public HereMapsRasterType get_MapType();
    [CompilerGeneratedAttribute]
public void set_MapType(HereMapsRasterType value);
    [CompilerGeneratedAttribute]
public HereMapsRasterTileFormat get_Format();
    [CompilerGeneratedAttribute]
public void set_Format(HereMapsRasterTileFormat value);
    [CompilerGeneratedAttribute]
public Dictionary`2<string, string> get_Parameters();
    protected virtual Task`1<string> GetImageUriAsyncCore(int zoomLevel, long x, long y, float resolutionFactor);
}
public enum ThinkGeo.Core.HereMapsRasterTileFormat : Enum {
    public int value__;
    public static HereMapsRasterTileFormat Png;
    public static HereMapsRasterTileFormat Png8;
    public static HereMapsRasterTileFormat Jpg;
}
public enum ThinkGeo.Core.HereMapsRasterType : Enum {
    public int value__;
    public static HereMapsRasterType BaseMap;
    public static HereMapsRasterType Aerial;
    public static HereMapsRasterType Hybrid;
}
public class ThinkGeo.Core.HereMapsZoomLevelSet : ZoomLevelSet {
}
public class ThinkGeo.Core.HueFamilyAreaStyle : AreaStyle {
    [ObfuscationAttribute]
private Collection`1<AreaStyle> areaStyles;
    [ObfuscationAttribute]
private Dictionary`2<string, AreaStyle> cache;
    [ObfuscationAttribute]
private int numberOfColors;
    public int NumberOfColors { get; public set; }
    public Dictionary`2<string, AreaStyle> Cache { get; }
    public GeoColor BaseColor { get; public set; }
    public HueFamilyAreaStyle(GeoPen outlinePen, GeoColor baseColor, int numberOfColors);
    public HueFamilyAreaStyle(GeoPen outlinePen, GeoColor baseColor, int numberOfColors, PenBrushDrawingOrder penBrushDrawingOrder);
    public int get_NumberOfColors();
    public void set_NumberOfColors(int value);
    public Dictionary`2<string, AreaStyle> get_Cache();
    public GeoColor get_BaseColor();
    public void set_BaseColor(GeoColor value);
    public void ClearCache();
    protected virtual void DrawCore(IEnumerable`1<Feature> features, GeoCanvas canvas, Collection`1<SimpleCandidate> labelsInThisLayer, Collection`1<SimpleCandidate> labelsInAllLayers);
}
public class ThinkGeo.Core.IconStyle : TextStyle {
    [ObfuscationAttribute]
private GeoImage iconImage;
    [ObfuscationAttribute]
private double iconImageScale;
    [ObfuscationAttribute]
private string iconPathFilename;
    public string IconPathFilename { get; public set; }
    public GeoImage IconImage { get; public set; }
    public double IconImageScale { get; public set; }
    public bool SuppressPartialLabels { get; public set; }
    private bool YjE= { get; }
    public IconStyle(string iconPathFilename, string textColumnName, GeoFont textFont, GeoBrush textBrush);
    public IconStyle(GeoImage iconImage, string textColumnName, GeoFont textFont, GeoBrush textBrush);
    public string get_IconPathFilename();
    public void set_IconPathFilename(string value);
    public GeoImage get_IconImage();
    public void set_IconImage(GeoImage value);
    public double get_IconImageScale();
    public void set_IconImageScale(double value);
    public bool get_SuppressPartialLabels();
    public void set_SuppressPartialLabels(bool value);
    private bool YTE=();
    protected virtual void DrawSampleCore(GeoCanvas canvas, DrawingRectangleF drawingExtent);
    protected virtual void DrawCore(IEnumerable`1<Feature> features, GeoCanvas canvas, Collection`1<SimpleCandidate> labelsInThisLayer, Collection`1<SimpleCandidate> labelsInAllLayers);
    protected virtual Collection`1<LabelingCandidate> GetLabelingCandidateCore(Feature feature, GeoCanvas canvas, GeoFont font, float xOffsetInPixel, float yOffsetInPixel, double rotationAngle);
    private void YzE=(GeoImage imageForIcon, Feature feature, GeoCanvas canvas, int imageWidth, int imageHeight, GeoFont font, float xOffsetInPixel, float yOffsetInPixel, double rotationAngle, Collection`1<SimpleCandidate> labelsInThisLayer, Collection`1<SimpleCandidate> labelsInAllLayers);
    private static RectangleShape ZDE=(PointShape centerPoint, int imageWidth, int imageHeight);
}
public class ThinkGeo.Core.IconValueItem : object {
    [ObfuscationAttribute]
private string fieldValue;
    [ObfuscationAttribute]
private string iconFilePathName;
    [ObfuscationAttribute]
private GeoImage iconImage;
    [ObfuscationAttribute]
private TextStyle textStyle;
    [ObfuscationAttribute]
private int textValueLengthMin;
    [ObfuscationAttribute]
private int textValueLengthMax;
    public TextStyle TextStyle { get; public set; }
    public string FieldValue { get; public set; }
    public string IconFilePathName { get; public set; }
    public int TextValueLengthMin { get; public set; }
    public int TextValueLengthMax { get; public set; }
    public IconValueItem(string fieldValue, string iconPathFilename, TextStyle textStyle);
    public IconValueItem(string fieldValue, GeoImage iconImage, TextStyle textStyle);
    public TextStyle get_TextStyle();
    public void set_TextStyle(TextStyle value);
    public string get_FieldValue();
    public void set_FieldValue(string value);
    public string get_IconFilePathName();
    public void set_IconFilePathName(string value);
    public int get_TextValueLengthMin();
    public void set_TextValueLengthMin(int value);
    public int get_TextValueLengthMax();
    public void set_TextValueLengthMax(int value);
    public GeoImage GetIconImage();
}
public class ThinkGeo.Core.IconValueStyle : PositionStyle {
    private static double XjE=;
    private static int XzE=;
    private static double YDE=;
    [ObfuscationAttribute]
private string columnName;
    [ObfuscationAttribute]
private Dictionary`2<int, GeoImage> geoImageCache;
    [ObfuscationAttribute]
private Dictionary`2<int, int> geoImageHeightCache;
    [ObfuscationAttribute]
private Dictionary`2<int, int> geoImageWidthCache;
    [ObfuscationAttribute]
private Collection`1<IconValueItem> iconValueItems;
    [ObfuscationAttribute]
private int previousValueItemId;
    public string ColumnName { get; public set; }
    public Collection`1<IconValueItem> IconValueItems { get; }
    private bool YjE= { get; }
    public IconValueStyle(string columnName);
    public IconValueStyle(string columnName, IEnumerable`1<IconValueItem> iconValueItems);
    public string get_ColumnName();
    public void set_ColumnName(string value);
    public Collection`1<IconValueItem> get_IconValueItems();
    private bool YTE=();
    protected virtual void DrawCore(IEnumerable`1<Feature> features, GeoCanvas canvas, Collection`1<SimpleCandidate> labelsInThisLayer, Collection`1<SimpleCandidate> labelsInAllLayers);
    protected virtual Collection`1<string> GetRequiredColumnNamesCore();
    protected virtual Collection`1<LabelingCandidate> GetLabelingCandidateCore(Feature feature, GeoCanvas canvas, GeoFont font, float xOffsetInPixel, float yOffsetInPixel, double rotationAngle);
    private void YzE=(Feature feature, GeoCanvas canvas, GeoFont font, GeoBrush textBrush, GeoPen haloPen, DrawingLevel drawingLevel, float xOffsetInPixel, float yOffsetInPixel, DrawingTextAlignment alignment, double rotationAngle, Collection`1<SimpleCandidate> labelsInThisLayer, Collection`1<SimpleCandidate> labelsInAllLayers);
    private static RectangleShape ZDE=(PointShape centerPoint, int imageWidth, int imageHeight);
    private int ZTE=(Feature feature, GeoCanvas canvas);
    private void ZjE=(TextStyle textStyle);
}
[ObfuscationAttribute]
internal class ThinkGeo.Core.IdsEngine : object {
    [ObfuscationAttribute]
private int recordLength;
    [ObfuscationAttribute]
private int headerLength;
    private static int fx4=;
    private static int OR8=;
    private Stream Oh8=;
    private Stream Ox8=;
    [ObfuscationAttribute]
private IdsRecord idsRecord;
    [ObfuscationAttribute]
private IdsHeader idsHeader;
    [ObfuscationAttribute]
private Byte[] cache;
    [ObfuscationAttribute]
private int startIndex;
    [ObfuscationAttribute]
private int endIndex;
    [CompilerGeneratedAttribute]
private EventHandler`1<StreamLoadingEventArgs> StreamLoading;
    [CompilerGeneratedAttribute]
public void PB8=(EventHandler`1<StreamLoadingEventArgs> value);
    [CompilerGeneratedAttribute]
public void PR8=(EventHandler`1<StreamLoadingEventArgs> value);
    internal virtual void Px8=(StreamLoadingEventArgs e);
    public bool sB4=(string fileName, FileAccess readWriteMode);
    public void QB8=();
    public void Hh8=();
    public string QR8=(int block);
    public void Qh8=();
    public int Qx8=(string id);
    public static void RB8=(string fileName);
    private static Byte[] RR8=(int intValue, byte byteOrder);
}
public interface ThinkGeo.Core.IGeoCanvasRotatable {
    public double RotationAngle { get; public set; }
    public double PivotX { get; public set; }
    public double PivotY { get; public set; }
    public abstract virtual double get_RotationAngle();
    public abstract virtual void set_RotationAngle(double value);
    public abstract virtual double get_PivotX();
    public abstract virtual void set_PivotX(double value);
    public abstract virtual double get_PivotY();
    public abstract virtual void set_PivotY(double value);
}
public class ThinkGeo.Core.InMemoryFeatureLayer : FeatureLayer {
    [ObfuscationAttribute]
private Collection`1<FeatureSourceColumn> featureSourceColumns;
    public Collection`1<FeatureSourceColumn> Columns { get; }
    public GeoCollection`1<Feature> InternalFeatures { get; }
    public bool HasBoundingBox { get; }
    public InMemoryFeatureLayer(IEnumerable`1<FeatureSourceColumn> featureSourceColumns);
    public InMemoryFeatureLayer(IEnumerable`1<FeatureSourceColumn> featureSourceColumns, IEnumerable`1<Feature> features);
    public InMemoryFeatureLayer(IEnumerable`1<FeatureSourceColumn> featureSourceColumns, IEnumerable`1<BaseShape> shapes);
    public Collection`1<FeatureSourceColumn> get_Columns();
    public GeoCollection`1<Feature> get_InternalFeatures();
    public virtual bool get_HasBoundingBox();
    public Collection`1<FeatureSourceColumn> GetColumns();
    protected virtual void OpenCore();
    public void BuildIndex();
    public void Clear();
}
public class ThinkGeo.Core.InMemoryFeatureSource : FeatureSource {
    private static string /B8=;
    [ObfuscationAttribute]
private Collection`1<FeatureSourceColumn> columns;
    [ObfuscationAttribute]
private GeoCollection`1<Feature> internalFeatures;
    private STRtree`1<string> /R8=;
    internal Collection`1<FeatureSourceColumn> /x8= { get; }
    public GeoCollection`1<Feature> InternalFeatures { get; }
    public bool IsEditable { get; }
    protected bool CanExecuteSqlQueryCore { get; }
    public InMemoryFeatureSource(IEnumerable`1<FeatureSourceColumn> featureSourceColumns);
    public InMemoryFeatureSource(IEnumerable`1<FeatureSourceColumn> featureSourceColumns, IEnumerable`1<Feature> features);
    public InMemoryFeatureSource(IEnumerable`1<FeatureSourceColumn> featureSourceColumns, IEnumerable`1<BaseShape> shapes);
    internal Collection`1<FeatureSourceColumn> /h8=();
    public GeoCollection`1<Feature> get_InternalFeatures();
    public virtual bool get_IsEditable();
    protected virtual bool get_CanExecuteSqlQueryCore();
    private void ACA=(IEnumerable`1<FeatureSourceColumn> featureSourceColumns, IEnumerable`1<Feature> features);
    public void BuildIndex();
    public void Clear();
    protected virtual long GetCountCore();
    protected virtual TransactionResult CommitTransactionCore(TransactionBuffer transactions);
    private void ASA=(Collection`1<FeatureSourceColumn> addBuffer, TransactionResult transactionResult);
    private void AiA=(Dictionary`2<string, Feature> addBuffer, TransactionResult transactionResult);
    private void AyA=(Collection`1<string> deleteBuffer, TransactionResult transactionResult);
    private void BCA=(Collection`1<string> deleteBuffer, TransactionResult transactionResult);
    private void BSA=(Dictionary`2<string, FeatureSourceColumn> editBuffer, TransactionResult transactionResult);
    private void BiA=(Dictionary`2<string, Feature> editBuffer, TransactionResult transactionResult);
    protected virtual Collection`1<Feature> GetAllFeaturesCore(IEnumerable`1<string> returningColumnNames);
    protected virtual Collection`1<Feature> GetAllFeaturesCore(IEnumerable`1<string> returningColumnNames, int startIndex, int takeCount);
    protected virtual Collection`1<Feature> GetFeaturesInsideBoundingBoxCore(RectangleShape boundingBox, IEnumerable`1<string> returningColumnNames);
    internal Collection`1<Feature> ByA=(RectangleShape boundingBox, IEnumerable`1<string> returningColumnNames);
    protected virtual Collection`1<Feature> GetFeaturesOutsideBoundingBoxCore(RectangleShape boundingBox, IEnumerable`1<string> returningColumnNames);
    protected virtual Collection`1<FeatureSourceColumn> GetColumnsCore();
    private Collection`1<Feature> CCA=(RectangleShape boundingBox, IEnumerable`1<string> returningColumnNames);
    private Collection`1<Feature> CSA=(RectangleShape extent, IEnumerable`1<string> returningColumnNames);
    private void CiA=(Feature feature, IEnumerable`1<string> returningColumnNames);
}
public class ThinkGeo.Core.InMemoryGridFeatureLayer : FeatureLayer {
    public GridCell[0...,0...] GridMatrix { get; public set; }
    public double CellSize { get; }
    public int ColumnCount { get; }
    public int RowCount { get; }
    public double NoDataValue { get; }
    public bool HasBoundingBox { get; }
    public string DataValueColumnName { get; }
    public string DataWeightColumnName { get; }
    public InMemoryGridFeatureLayer(GridCell[0...,0...] gridMatrix);
    public GridCell[0...,0...] get_GridMatrix();
    public void set_GridMatrix(GridCell[0...,0...] value);
    public double get_CellSize();
    public int get_ColumnCount();
    public int get_RowCount();
    public double get_NoDataValue();
    public virtual bool get_HasBoundingBox();
    public string get_DataValueColumnName();
    public string get_DataWeightColumnName();
    protected virtual RectangleShape GetBoundingBoxCore();
    public static void GenerateGrid(GridDefinition gridDefinition, GridInterpolationModel gridInterpolationModel, Stream outputStream, Func`2<double, string> cellValueToStringFunc);
    public static GridCell[0...,0...] GenerateGridMatrix(GridDefinition gridDefinition, GridInterpolationModel gridInterpolationModel);
    public GridCell[0...,0...] GenerateGridMatrix();
}
public class ThinkGeo.Core.InMemoryGridFeatureSource : FeatureSource {
    private static string 1SE=;
    private static string IiI=;
    [ObfuscationAttribute]
private double cellSize;
    [ObfuscationAttribute]
private Collection`1<FeatureSourceColumn> featureSourceColumns;
    [ObfuscationAttribute]
private RectangleShape gridExtent;
    [ObfuscationAttribute]
private PointShape lowerLeftPoint;
    [ObfuscationAttribute]
private double noDataValue;
    [ObfuscationAttribute]
private int columnCount;
    [ObfuscationAttribute]
private int rowCount;
    [ObfuscationAttribute]
private GridCell[0...,0...] gridMatrix;
    public GridCell[0...,0...] GridMatrix { get; public set; }
    public double CellSize { get; }
    public int ColumnCount { get; }
    public int RowCount { get; }
    public PointShape LowerLeftPoint { get; }
    public double NoDataValue { get; }
    public bool IsEditable { get; }
    public string DataValueColumnName { get; }
    public string DataWeightColumnName { get; }
    public InMemoryGridFeatureSource(GridCell[0...,0...] gridMatrix);
    public GridCell[0...,0...] get_GridMatrix();
    public void set_GridMatrix(GridCell[0...,0...] value);
    public double get_CellSize();
    public int get_ColumnCount();
    public int get_RowCount();
    public PointShape get_LowerLeftPoint();
    public double get_NoDataValue();
    public virtual bool get_IsEditable();
    public string get_DataValueColumnName();
    public string get_DataWeightColumnName();
    protected virtual void OpenCore();
    protected virtual Collection`1<FeatureSourceColumn> GetColumnsCore();
    protected virtual TransactionResult CommitTransactionCore(TransactionBuffer transactions);
    protected virtual Collection`1<Feature> GetAllFeaturesCore(IEnumerable`1<string> returningColumnNames);
    protected virtual RectangleShape GetBoundingBoxCore();
    protected virtual long GetCountCore();
    protected virtual Collection`1<Feature> GetFeaturesInsideBoundingBoxCore(RectangleShape boundingBox, IEnumerable`1<string> returningColumnNames);
    public static GridCell[0...,0...] GenerateGridMatrix(GridDefinition gridDefinition, GridInterpolationModel gridInterpolationModel);
    public static void GenerateGrid(GridDefinition gridDefinition, GridInterpolationModel gridInterpolationModel, Stream outputStream, Func`2<double, string> cellValueToStringFunc);
    private void IyI=();
}
public class ThinkGeo.Core.InMemoryGridIsoLineLayer : IsoLineLayer {
    [ObfuscationAttribute]
private Collection`1<Feature> cachedIsoLines;
    [ObfuscationAttribute]
private int previousGridMatrixCount;
    [ObfuscationAttribute]
private int previousGridMatrixHashCode;
    [ObfuscationAttribute]
private int previousIsoLineLevelsCount;
    [ObfuscationAttribute]
private int previousIsoLineLevelsHashCode;
    [ObfuscationAttribute]
private string previousDataValueColumnName;
    [ObfuscationAttribute]
private string gridMatrixString;
    [ObfuscationAttribute]
private int gridMatrixDimension0Length;
    [ObfuscationAttribute]
private int gridMatrixDimension1Length;
    private GridCell[0...,0...] giI=;
    public GridCell[0...,0...] GridMatrix { get; public set; }
    public InMemoryGridIsoLineLayer(GridCell[0...,0...] gridMatrix);
    public InMemoryGridIsoLineLayer(GridCell[0...,0...] gridMatrix, double noDataValue);
    public InMemoryGridIsoLineLayer(GridCell[0...,0...] gridMatrix, IEnumerable`1<double> isoLineLevels);
    public InMemoryGridIsoLineLayer(GridCell[0...,0...] gridMatrix, IEnumerable`1<double> isoLineLevels, double noDataValue);
    public InMemoryGridIsoLineLayer(GridCell[0...,0...] gridMatrix, IEnumerable`1<double> isoLineLevels, double lowerScale, double upperScale);
    public InMemoryGridIsoLineLayer(GridCell[0...,0...] gridMatrix, IEnumerable`1<double> isoLineLevels, double lowerScale, double upperScale, double noDataValue);
    public InMemoryGridIsoLineLayer(GridCell[0...,0...] gridMatrix, IEnumerable`1<double> isoLineLevels, double lowerScale, double upperScale, double noDataValue, IsoLineType isoLineType);
    public GridCell[0...,0...] get_GridMatrix();
    public void set_GridMatrix(GridCell[0...,0...] value);
    [OnGeoserializingAttribute]
private void 2iE=();
    [OnGeodeserializedAttribute]
private void 2yE=();
    public Collection`1<Feature> GetIsoLineFeatures();
    protected virtual Collection`1<Feature> GetFeaturesForDrawingCore(GeoCanvas canvas, Collection`1<SimpleCandidate> labelsInAllLayers);
    private bool hCI=();
    private void hSI=();
}
public class ThinkGeo.Core.InMemoryRasterTileCache : RasterTileCache {
    [ObfuscationAttribute]
private GeoCollection`1<RasterTile> cachedTiles;
    [ObfuscationAttribute]
private int maximumTilesCount;
    public int MaximumTilesCount { get; public set; }
    public int get_MaximumTilesCount();
    public void set_MaximumTilesCount(int value);
    protected virtual Tile GetTileCore(int zoom, long column, long row);
    protected virtual void SaveTileCore(Tile tile);
    protected virtual void DeleteTileCore(Tile tile);
    protected virtual void ClearCacheCore();
}
public class ThinkGeo.Core.InsertedGeoCollectionEventArgs : EventArgs {
    [ObfuscationAttribute]
private object item;
    [ObfuscationAttribute]
private int index;
    public object Item { get; public set; }
    public int Index { get; public set; }
    public InsertedGeoCollectionEventArgs(object item);
    public InsertedGeoCollectionEventArgs(object item, int index);
    public object get_Item();
    public void set_Item(object value);
    public int get_Index();
    public void set_Index(int value);
}
public class ThinkGeo.Core.InsertingGeoCollectionEventArgs : EventArgs {
    [ObfuscationAttribute]
private object item;
    public object Item { get; public set; }
    public InsertingGeoCollectionEventArgs(object item);
    public object get_Item();
    public void set_Item(object value);
}
public class ThinkGeo.Core.InverseDistanceWeightedGridInterpolationModel : GridInterpolationModel {
    [ObfuscationAttribute]
private double power;
    [ObfuscationAttribute]
private double searchRadius;
    private static double HiI=;
    public double Power { get; public set; }
    public double SearchRadius { get; public set; }
    public InverseDistanceWeightedGridInterpolationModel(double power, double searchRadius);
    public double get_Power();
    public void set_Power(double value);
    public double get_SearchRadius();
    public void set_SearchRadius(double value);
    protected virtual ValueTuple`2<double, double> InterpolateCore(RectangleShape cellExtent, GridDefinition gridDefinition);
    private double HyI=(RectangleShape cellExtent, GridDefinition gridDefinition);
    private ValueTuple`2<double, double> ICI=(PointShape point, GridDefinition gridDefinition);
    private ValueTuple`2<double, double> ISI=(PointShape point, Dictionary`2<PointShape, double> dataPoints, double noDataValue);
}
public abstract class ThinkGeo.Core.IsoLineLayer : Layer {
    [ObfuscationAttribute]
private Collection`1<double> isoLineLevels;
    [ObfuscationAttribute]
private string dataValueColumnName;
    [ObfuscationAttribute]
private double lowerScale;
    [ObfuscationAttribute]
private double upperScale;
    [ObfuscationAttribute]
private Collection`1<Style> customStyles;
    [ObfuscationAttribute]
private IsoLineType isoLineType;
    [ObfuscationAttribute]
private double noDataValue;
    public double NoDataValue { get; public set; }
    public double UpperScale { get; public set; }
    public double LowerScale { get; public set; }
    public Collection`1<Style> CustomStyles { get; }
    public string DataValueColumnName { get; public set; }
    public Collection`1<double> IsoLineLevels { get; public set; }
    public IsoLineType IsoLineType { get; public set; }
    protected IsoLineLayer(IEnumerable`1<double> isoLineLevels);
    protected IsoLineLayer(IEnumerable`1<double> isoLineLevels, double lowerScale, double upperScale);
    protected IsoLineLayer(IEnumerable`1<double> isoLineLevels, double lowerScale, double upperScale, IsoLineType isoLineType);
    public double get_NoDataValue();
    public void set_NoDataValue(double value);
    public double get_UpperScale();
    public void set_UpperScale(double value);
    public double get_LowerScale();
    public void set_LowerScale(double value);
    public Collection`1<Style> get_CustomStyles();
    public string get_DataValueColumnName();
    public void set_DataValueColumnName(string value);
    public Collection`1<double> get_IsoLineLevels();
    public void set_IsoLineLevels(Collection`1<double> value);
    public IsoLineType get_IsoLineType();
    public void set_IsoLineType(IsoLineType value);
    protected abstract virtual Collection`1<Feature> GetFeaturesForDrawingCore(GeoCanvas canvas, Collection`1<SimpleCandidate> labelsInAllLayers);
    protected virtual void OpenCore();
    protected virtual void DrawCore(GeoCanvas canvas, Collection`1<SimpleCandidate> labelsInAllLayers);
    public static Collection`1<Feature> GetIsoFeatures(GridCell[0...,0...] gridMatrix, IEnumerable`1<double> isoLineLevels, string dataValueColumnName, IsoLineType isoLineType);
    public static Collection`1<Feature> GetIsoFeatures(GridCell[0...,0...] gridMatrix, IEnumerable`1<double> isoLineLevels, string dataValueColumnName, IsoLineType isoLineType, double noDataValue);
    private static Feature pSI=(GridCell[0...,0...] gridMatrix, string dataValueColumnName);
    public static Collection`1<Feature> GetIsoFeatures(GridFeatureSource gridFeatureSource, IEnumerable`1<double> isoLineLevels, string dataValueColumnName, IsoLineType isoLineType);
    public static Collection`1<double> GetIsoLineLevels(GridCell[0...,0...] gridMatrix, int isoLineLevelCount);
    public static Collection`1<double> GetIsoLineLevels(IEnumerable`1<double> dataValues, int isoLineLevelCount);
    public static Collection`1<double> GetIsoLineLevels(Dictionary`2<PointShape, double> dataPoints, int isoLineLevelCount);
    private static Collection`1<double> piI=(int isoLevelCount, double minValue, double maxValue);
    private static List`1<yyI=> pyI=(GridCell[0...,0...] gridPoints, IEnumerable`1<double> levels, double noDataValue);
    private static BaseShape qCI=(GridCell[0...,0...] originalGrid, GridCell[0...,0...] extensionGrid, double noDataValue, double minValue);
    private static GridCell[0...,0...] qSI=(GridCell[0...,0...] grid, double noDataValue, Double& minValue);
    private static Collection`1<Feature> qiI=(List`1<yyI=> levelLineList, GridCell[0...,0...] grid, BaseShape gridShape, string dataValueColumnName);
    private static BaseShape qyI=(Collection`1<BaseShape> ringGeometries, Dictionary`2<BaseShape, BaseShape> geometriesDict);
    private static void rCI=(Collection`1<Feature> features, Collection`1<BaseShape> shapes, GridCell[0...,0...] grid, string dataValueColumnName);
    private static void rSI=(STRtree`1<object> rTree, Feature feature, BaseShape geometry, string dataValueColumnName);
}
public enum ThinkGeo.Core.IsoLineType : Enum {
    public int value__;
    public static IsoLineType LinesOnly;
    public static IsoLineType ClosedLinesAsPolygons;
}
public interface ThinkGeo.Core.IWmsEntity {
    public Collection`1<string> ActiveLayerNames { get; }
    public Collection`1<string> ActiveStyleNames { get; }
    public Uri Uri { get; public set; }
    public bool IsTransparent { get; public set; }
    public string OutputFormat { get; public set; }
    public IWebProxy WebProxy { get; public set; }
    public int TimeoutInSeconds { get; public set; }
    public string Crs { get; public set; }
    public ICredentials Credentials { get; public set; }
    public string Exceptions { get; public set; }
    public Dictionary`2<string, string> Parameters { get; }
    public WmsAxisOrder AxisOrder { get; public set; }
    public bool FastMode { get; public set; }
    public string Version { get; }
    public TimeSpan CapabilitiesCacheTimeout { get; public set; }
    public string UserAgent { get; public set; }
    public abstract virtual Collection`1<string> get_ActiveLayerNames();
    public abstract virtual Collection`1<string> get_ActiveStyleNames();
    public abstract virtual Uri get_Uri();
    public abstract virtual void set_Uri(Uri value);
    public abstract virtual bool get_IsTransparent();
    public abstract virtual void set_IsTransparent(bool value);
    public abstract virtual string get_OutputFormat();
    public abstract virtual void set_OutputFormat(string value);
    public abstract virtual IWebProxy get_WebProxy();
    public abstract virtual void set_WebProxy(IWebProxy value);
    public abstract virtual int get_TimeoutInSeconds();
    public abstract virtual void set_TimeoutInSeconds(int value);
    public abstract virtual string get_Crs();
    public abstract virtual void set_Crs(string value);
    public abstract virtual ICredentials get_Credentials();
    public abstract virtual void set_Credentials(ICredentials value);
    public abstract virtual string get_Exceptions();
    public abstract virtual void set_Exceptions(string value);
    public abstract virtual Dictionary`2<string, string> get_Parameters();
    public abstract virtual WmsAxisOrder get_AxisOrder();
    public abstract virtual void set_AxisOrder(WmsAxisOrder value);
    public abstract virtual bool get_FastMode();
    public abstract virtual void set_FastMode(bool value);
    public abstract virtual string get_Version();
    public abstract virtual TimeSpan get_CapabilitiesCacheTimeout();
    public abstract virtual void set_CapabilitiesCacheTimeout(TimeSpan value);
    public abstract virtual string get_UserAgent();
    public abstract virtual void set_UserAgent(string value);
}
[DefaultMemberAttribute("Item")]
internal class ThinkGeo.Core.JArray : JContainer {
    private List`1<JToken> _values;
    protected IList`1<JToken> ChildrenTokens { get; }
    internal JTokenType Type { get; }
    public JToken Item { get; public set; }
    public JToken Item { get; public set; }
    public bool IsReadOnly { get; }
    public JArray(object content);
    protected virtual IList`1<JToken> get_ChildrenTokens();
    internal virtual JTokenType get_Type();
    public virtual JToken get_Item(object key);
    public virtual void set_Item(object key, JToken value);
    public sealed virtual JToken get_Item(int index);
    public sealed virtual void set_Item(int index, JToken value);
    public sealed virtual void Insert(int index, JToken item);
    public sealed virtual void RemoveAt(int index);
    public sealed virtual IEnumerator`1<JToken> GetEnumerator();
    public sealed virtual void Add(JToken item);
    public sealed virtual void Clear();
    public sealed virtual bool Contains(JToken item);
    public sealed virtual void CopyTo(JToken[] array, int arrayIndex);
    public sealed virtual bool get_IsReadOnly();
    public sealed virtual bool Remove(JToken item);
}
internal abstract class ThinkGeo.Core.JContainer : JToken {
    private object _syncRoot;
    protected IList`1<JToken> ChildrenTokens { get; }
    public bool HasValues { get; }
    public JToken First { get; }
    public JToken Last { get; }
    private JToken System.Collections.Generic.IList<ThinkGeo.Core.JToken>.Item { get; private set; }
    private bool System.Collections.Generic.ICollection<ThinkGeo.Core.JToken>.IsReadOnly { get; }
    private bool System.Collections.IList.IsFixedSize { get; }
    private bool System.Collections.IList.IsReadOnly { get; }
    private object System.Collections.IList.Item { get; private set; }
    public int Count { get; }
    private bool System.Collections.ICollection.IsSynchronized { get; }
    private object System.Collections.ICollection.SyncRoot { get; }
    protected abstract virtual IList`1<JToken> get_ChildrenTokens();
    public virtual bool get_HasValues();
    public virtual JToken get_First();
    public virtual JToken get_Last();
    internal virtual JEnumerable`1<JToken> Children();
    public IEnumerable`1<JToken> Descendants();
    [IteratorStateMachineAttribute("ThinkGeo.Core.JContainer/<GetDescendants>d__12")]
internal IEnumerable`1<JToken> GetDescendants(bool self);
    internal bool IsMultiContent(object content);
    internal JToken EnsureParentToken(JToken item, bool skipParentCheck);
    internal virtual int IndexOfItem(JToken item);
    internal virtual void InsertItem(int index, JToken item, bool skipParentCheck);
    internal virtual void RemoveItemAt(int index);
    internal virtual bool RemoveItem(JToken item);
    internal virtual JToken GetItem(int index);
    internal virtual void SetItem(int index, JToken item);
    internal virtual void ClearItems();
    internal virtual bool ContainsItem(JToken item);
    internal virtual void CopyItemsTo(Array array, int arrayIndex);
    internal static bool IsTokenUnchanged(JToken currentValue, JToken newValue);
    public virtual void Add(object content);
    public void AddFirst(object content);
    internal void AddInternal(int index, object content, bool skipParentCheck);
    internal static JToken CreateFromContent(object content);
    internal void ReadTokenFrom(JsonReader reader);
    internal void ReadContentFrom(JsonReader r);
    private static JProperty ReadProperty(JsonReader r, JContainer parent);
    private sealed virtual override int System.Collections.Generic.IList<ThinkGeo.Core.JToken>.IndexOf(JToken item);
    private sealed virtual override void System.Collections.Generic.IList<ThinkGeo.Core.JToken>.Insert(int index, JToken item);
    private sealed virtual override void System.Collections.Generic.IList<ThinkGeo.Core.JToken>.RemoveAt(int index);
    private sealed virtual override JToken System.Collections.Generic.IList<ThinkGeo.Core.JToken>.get_Item(int index);
    private sealed virtual override void System.Collections.Generic.IList<ThinkGeo.Core.JToken>.set_Item(int index, JToken value);
    private sealed virtual override void System.Collections.Generic.ICollection<ThinkGeo.Core.JToken>.Add(JToken item);
    private sealed virtual override void System.Collections.Generic.ICollection<ThinkGeo.Core.JToken>.Clear();
    private sealed virtual override bool System.Collections.Generic.ICollection<ThinkGeo.Core.JToken>.Contains(JToken item);
    private sealed virtual override void System.Collections.Generic.ICollection<ThinkGeo.Core.JToken>.CopyTo(JToken[] array, int arrayIndex);
    private sealed virtual override bool System.Collections.Generic.ICollection<ThinkGeo.Core.JToken>.get_IsReadOnly();
    private sealed virtual override bool System.Collections.Generic.ICollection<ThinkGeo.Core.JToken>.Remove(JToken item);
    private JToken EnsureValue(object value);
    private sealed virtual override int System.Collections.IList.Add(object value);
    private sealed virtual override void System.Collections.IList.Clear();
    private sealed virtual override bool System.Collections.IList.Contains(object value);
    private sealed virtual override int System.Collections.IList.IndexOf(object value);
    private sealed virtual override void System.Collections.IList.Insert(int index, object value);
    private sealed virtual override bool System.Collections.IList.get_IsFixedSize();
    private sealed virtual override bool System.Collections.IList.get_IsReadOnly();
    private sealed virtual override void System.Collections.IList.Remove(object value);
    private sealed virtual override void System.Collections.IList.RemoveAt(int index);
    private sealed virtual override object System.Collections.IList.get_Item(int index);
    private sealed virtual override void System.Collections.IList.set_Item(int index, object value);
    private sealed virtual override void System.Collections.ICollection.CopyTo(Array array, int index);
    public sealed virtual int get_Count();
    private sealed virtual override bool System.Collections.ICollection.get_IsSynchronized();
    private sealed virtual override object System.Collections.ICollection.get_SyncRoot();
}
[IsReadOnlyAttribute]
internal class ThinkGeo.Core.JEnumerable`1 : ValueType {
    private IEnumerable`1<T> _enumerable;
    public static JEnumerable`1<T> Empty;
    public JEnumerable`1(IEnumerable`1<T> enumerable);
    private static JEnumerable`1();
    public IEnumerator`1<T> GetEnumerator();
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
    public sealed virtual bool Equals(JEnumerable`1<T> other);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    private sealed virtual override IEnumerator`1<T> System.Collections.Generic.IEnumerable<T>.GetEnumerator();
}
[DefaultMemberAttribute("Item")]
internal class ThinkGeo.Core.JObject : JContainer {
    private List`1<JToken> properties;
    protected IList`1<JToken> ChildrenTokens { get; }
    internal JTokenType Type { get; }
    public JToken Item { get; public set; }
    public JToken Item { get; public set; }
    protected virtual IList`1<JToken> get_ChildrenTokens();
    internal virtual void InsertItem(int index, JToken item, bool skipParentCheck);
    internal virtual JTokenType get_Type();
    internal JProperty Property(string name, StringComparison comparison);
    public virtual JToken get_Item(object key);
    public virtual void set_Item(object key, JToken value);
    public JToken get_Item(string propertyName);
    public void set_Item(string propertyName, JToken value);
    public void Add(string propertyName, JToken value);
    public bool ContainsKey(string propertyName);
}
internal class ThinkGeo.Core.JProperty : JContainer {
    private List`1<JToken> _content;
    private string _name;
    protected IList`1<JToken> ChildrenTokens { get; }
    public string Name { get; }
    public JToken Value { get; public set; }
    internal JTokenType Type { get; }
    internal JProperty(string name);
    public JProperty(string name, object content);
    protected virtual IList`1<JToken> get_ChildrenTokens();
    [DebuggerStepThroughAttribute]
public string get_Name();
    [DebuggerStepThroughAttribute]
public JToken get_Value();
    public void set_Value(JToken value);
    internal virtual JToken GetItem(int index);
    internal virtual void SetItem(int index, JToken item);
    internal virtual void InsertItem(int index, JToken item, bool skipParentCheck);
    internal virtual bool ContainsItem(JToken item);
    [DebuggerStepThroughAttribute]
internal virtual JTokenType get_Type();
}
internal class ThinkGeo.Core.JsonContainerContract : JsonContract {
    [ObfuscationAttribute]
private JsonContract _itemContract;
    [ObfuscationAttribute]
private JsonContract _finalItemContract;
    internal JsonContract ItemContract { get; internal set; }
    internal JsonContainerContract(Type underlyingType);
    internal JsonContract get_ItemContract();
    internal void set_ItemContract(JsonContract value);
}
internal enum ThinkGeo.Core.JsonContainerType : Enum {
    public int value__;
    public static JsonContainerType None;
    public static JsonContainerType Object;
    public static JsonContainerType Array;
    public static JsonContainerType Constructor;
}
internal class ThinkGeo.Core.JsonContract : object {
    [ObfuscationAttribute]
private Type _createdType;
    internal bool IsNullable;
    internal bool IsConvertable;
    internal bool IsEnum;
    internal Type NonNullableUnderlyingType;
    internal ReadType InternalReadType;
    internal JsonContractType ContractType;
    internal bool IsReadOnlyOrFixedSize;
    internal bool IsSealed;
    internal bool IsInstantiable;
    [CompilerGeneratedAttribute]
private Type <UnderlyingType>k__BackingField;
    public Type UnderlyingType { get; }
    public Type CreatedType { get; public set; }
    internal JsonContract(Type underlyingType);
    [CompilerGeneratedAttribute]
public Type get_UnderlyingType();
    public Type get_CreatedType();
    public void set_CreatedType(Type value);
}
internal enum ThinkGeo.Core.JsonContractType : Enum {
    public int value__;
    public static JsonContractType None;
    public static JsonContractType Object;
    public static JsonContractType Array;
    public static JsonContractType Primitive;
    public static JsonContractType String;
    public static JsonContractType Dictionary;
    public static JsonContractType Dynamic;
    public static JsonContractType Serializable;
    public static JsonContractType Linq;
}
internal static class ThinkGeo.Core.JsonConvert : object {
    public static string True;
    public static string False;
    public static string Null;
    public static string Undefined;
    public static string PositiveInfinity;
    public static string NegativeInfinity;
    public static string NaN;
    private static JsonConvert();
    [DebuggerStepThroughAttribute]
public static object DeserializeObject(string value);
    [DebuggerStepThroughAttribute]
public static T DeserializeObject(string value);
    [DebuggerStepThroughAttribute]
public static T DeserializeAnonymousType(string value, T anonymousTypeObject);
    public static object DeserializeObject(string value, Type type);
}
internal class ThinkGeo.Core.JsonDictionaryContract : JsonContainerContract {
    public static string ConcurrentDictionaryTypeName;
    private Type _genericCollectionDefinitionType;
    private ConstructorInfo _parameterizedConstructor;
    [CompilerGeneratedAttribute]
private Type <DictionaryKeyType>k__BackingField;
    [CompilerGeneratedAttribute]
private Type <DictionaryValueType>k__BackingField;
    [CompilerGeneratedAttribute]
private JsonContract <KeyContract>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <ShouldCreateWrapper>k__BackingField;
    [CompilerGeneratedAttribute]
private jBU=<object> <OverrideCreator>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <HasParameterizedCreator>k__BackingField;
    public Type DictionaryKeyType { get; }
    public Type DictionaryValueType { get; }
    internal JsonContract KeyContract { get; internal set; }
    internal bool ShouldCreateWrapper { get; }
    public jBU=<object> OverrideCreator { get; public set; }
    public bool HasParameterizedCreator { get; public set; }
    internal bool HasParameterizedCreatorInternal { get; }
    public JsonDictionaryContract(Type underlyingType);
    [CompilerGeneratedAttribute]
public Type get_DictionaryKeyType();
    [CompilerGeneratedAttribute]
public Type get_DictionaryValueType();
    [CompilerGeneratedAttribute]
internal JsonContract get_KeyContract();
    [CompilerGeneratedAttribute]
internal void set_KeyContract(JsonContract value);
    [CompilerGeneratedAttribute]
internal bool get_ShouldCreateWrapper();
    [CompilerGeneratedAttribute]
public jBU=<object> get_OverrideCreator();
    [CompilerGeneratedAttribute]
public void set_OverrideCreator(jBU=<object> value);
    [CompilerGeneratedAttribute]
public bool get_HasParameterizedCreator();
    [CompilerGeneratedAttribute]
public void set_HasParameterizedCreator(bool value);
    internal bool get_HasParameterizedCreatorInternal();
    internal IDictionary CreateTemporaryDictionary();
}
internal class ThinkGeo.Core.JsonHelper : object {
    public static string CarriageReturnLineFeed;
    public static string Empty;
    public static char CarriageReturn;
    public static char LineFeed;
    public static char Tab;
    private static Dictionary`2<Type, PrimitiveTypeCode> TypeCodeMap;
    private static JsonHelper();
    internal static JObject Parse(string json);
    public static string ToString(object value);
    public static int ByteArrayCompare(Byte[] a1, Byte[] a2);
    public static int IntLength(ulong i);
    public static bool ApproxEquals(double d1, double d2);
    public static Char[] RentBuffer(int minSize);
    internal static bool IsEndToken(JsonToken token);
    internal static bool IsStartToken(JsonToken token);
    internal static bool IsPrimitiveToken(JsonToken token);
    public static void ArgumentNotNull(object value, string parameterName);
    public static ConstructorInfo ResolveEnumerableCollectionConstructor(Type collectionType, Type collectionItemType, Type constructorArgumentType);
    public static bool IsNullable(Type t);
    public static bool IsNullableType(Type t);
    public static bool ImplementsGenericDefinition(Type type, Type genericInterfaceDefinition, Type& implementingType);
    public static PrimitiveTypeCode GetTypeCode(Type t);
    public static PrimitiveTypeCode GetTypeCode(Type t, Boolean& isEnum);
    public static bool IsInteger(object value);
    public static bool TryHexTextToInt(Char[] text, int start, int end, Int32& value);
}
internal class ThinkGeo.Core.JsonObjectContract : JsonContainerContract {
    [ObfuscationAttribute]
private jBU=<object> _parameterizedCreator;
    private JsonPropertyCollection _creatorParameters;
    [CompilerGeneratedAttribute]
private JsonPropertyCollection <Properties>k__BackingField;
    public JsonPropertyCollection Properties { get; }
    internal jBU=<object> ParameterizedCreator { get; internal set; }
    public JsonPropertyCollection CreatorParameters { get; }
    public JsonObjectContract(Type underlyingType);
    [CompilerGeneratedAttribute]
public JsonPropertyCollection get_Properties();
    internal jBU=<object> get_ParameterizedCreator();
    internal void set_ParameterizedCreator(jBU=<object> value);
    public JsonPropertyCollection get_CreatorParameters();
}
internal class ThinkGeo.Core.JsonPrimitiveContract : JsonContract {
    [CompilerGeneratedAttribute]
private PrimitiveTypeCode <TypeCode>k__BackingField;
    private static Dictionary`2<Type, ReadType> ReadTypeMap;
    internal PrimitiveTypeCode TypeCode { get; internal set; }
    public JsonPrimitiveContract(Type underlyingType);
    private static JsonPrimitiveContract();
    [CompilerGeneratedAttribute]
internal PrimitiveTypeCode get_TypeCode();
    [CompilerGeneratedAttribute]
internal void set_TypeCode(PrimitiveTypeCode value);
}
internal class ThinkGeo.Core.JsonProperty : object {
    [ObfuscationAttribute]
private string _propertyName;
    [ObfuscationAttribute]
private Type _propertyType;
    [CompilerGeneratedAttribute]
private JsonContract <PropertyContract>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<int> <Order>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <Ignored>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <Readable>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <Writable>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <HasMemberAttribute>k__BackingField;
    internal JsonContract PropertyContract { get; internal set; }
    public string PropertyName { get; public set; }
    public Nullable`1<int> Order { get; public set; }
    public Type PropertyType { get; public set; }
    public bool Ignored { get; public set; }
    public bool Readable { get; public set; }
    public bool Writable { get; public set; }
    public bool HasMemberAttribute { get; public set; }
    [CompilerGeneratedAttribute]
internal JsonContract get_PropertyContract();
    [CompilerGeneratedAttribute]
internal void set_PropertyContract(JsonContract value);
    public string get_PropertyName();
    public void set_PropertyName(string value);
    [CompilerGeneratedAttribute]
public Nullable`1<int> get_Order();
    [CompilerGeneratedAttribute]
public void set_Order(Nullable`1<int> value);
    public Type get_PropertyType();
    public void set_PropertyType(Type value);
    [CompilerGeneratedAttribute]
public bool get_Ignored();
    [CompilerGeneratedAttribute]
public void set_Ignored(bool value);
    [CompilerGeneratedAttribute]
public bool get_Readable();
    [CompilerGeneratedAttribute]
public void set_Readable(bool value);
    [CompilerGeneratedAttribute]
public bool get_Writable();
    [CompilerGeneratedAttribute]
public void set_Writable(bool value);
    [CompilerGeneratedAttribute]
public bool get_HasMemberAttribute();
    [CompilerGeneratedAttribute]
public void set_HasMemberAttribute(bool value);
    public virtual string ToString();
}
internal class ThinkGeo.Core.JsonPropertyCollection : KeyedCollection`2<string, JsonProperty> {
    private Type _type;
    private List`1<JsonProperty> _list;
    public JsonPropertyCollection(Type type);
    protected virtual string GetKeyForItem(JsonProperty item);
    public void AddProperty(JsonProperty property);
    public JsonProperty GetClosestMatchProperty(string propertyName);
    private bool TryGetValuePrivate(string key, JsonProperty& item);
    public JsonProperty GetProperty(string propertyName, StringComparison comparisonType);
}
internal abstract class ThinkGeo.Core.JsonReader : object {
    private JsonToken _tokenType;
    private object _value;
    internal char _quoteChar;
    internal State _currentState;
    private JsonContainerType currentType;
    [ObfuscationAttribute]
private CultureInfo _culture;
    private Nullable`1<int> _maxDepth;
    private bool _hasExceededMaxDepth;
    [ObfuscationAttribute]
private string _dateFormatString;
    private List`1<JsonContainerType> _stack;
    [CompilerGeneratedAttribute]
private bool <CloseInput>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <SupportMultipleContent>k__BackingField;
    protected State CurrentState { get; }
    public bool CloseInput { get; public set; }
    public bool SupportMultipleContent { get; public set; }
    public string DateFormatString { get; public set; }
    public JsonToken TokenType { get; }
    public object Value { get; }
    public int Depth { get; }
    public CultureInfo Culture { get; public set; }
    protected State get_CurrentState();
    [CompilerGeneratedAttribute]
public bool get_CloseInput();
    [CompilerGeneratedAttribute]
public void set_CloseInput(bool value);
    [CompilerGeneratedAttribute]
public bool get_SupportMultipleContent();
    [CompilerGeneratedAttribute]
public void set_SupportMultipleContent(bool value);
    public string get_DateFormatString();
    public void set_DateFormatString(string value);
    public virtual JsonToken get_TokenType();
    public virtual object get_Value();
    public virtual int get_Depth();
    public CultureInfo get_Culture();
    public void set_Culture(CultureInfo value);
    private void Push(JsonContainerType value);
    private JsonContainerType Pop();
    private JsonContainerType Peek();
    public abstract virtual bool Read();
    public virtual Nullable`1<int> ReadAsInt32();
    internal Nullable`1<int> ReadInt32String(string s);
    public virtual string ReadAsString();
    public virtual Byte[] ReadAsBytes();
    internal Byte[] ReadArrayIntoByteArray();
    private bool ReadArrayElementIntoByteArrayReportDone(List`1<byte> buffer);
    public virtual Nullable`1<double> ReadAsDouble();
    internal Nullable`1<double> ReadDoubleString(string s);
    public virtual Nullable`1<bool> ReadAsBoolean();
    internal Nullable`1<bool> ReadBooleanString(string s);
    public virtual Nullable`1<decimal> ReadAsDecimal();
    internal Nullable`1<decimal> ReadDecimalString(string s);
    internal void ReaderReadAndAssert();
    internal Exception CreateUnexpectedEndException();
    public void Skip();
    protected void SetToken(JsonToken newToken);
    protected void SetToken(JsonToken newToken, object value);
    protected void SetToken(JsonToken newToken, object value, bool updateIndex);
    internal void SetPostValueState(bool updateIndex);
    private void ValidateEnd(JsonToken endToken);
    protected void SetStateBasedOnCurrent();
    private void SetFinished();
    private JsonContainerType GetTypeForCloseToken(JsonToken token);
    private sealed virtual override void System.IDisposable.Dispose();
    protected virtual void Dispose(bool disposing);
    public virtual void Close();
    internal void ReadAndAssert();
    internal bool ReadForType(JsonContract contract, bool hasConverter);
    internal bool ReadAndMoveToContent();
    internal bool MoveToContent();
    private JsonToken GetContentToken();
}
internal class ThinkGeo.Core.JsonSerializerInternalReader : object {
    private JsonContract GetContractSafe(Type type);
    private JsonContract GetContract(Type type);
    public object Deserialize(JsonReader reader, Type objectType);
    private JToken CreateJObject(JsonReader reader);
    private object CreateValueInternal(JsonReader reader, Type objectType, JsonContract contract, JsonProperty containerMember);
    private static bool CoerceEmptyStringToNull(Type objectType, JsonContract contract, string s);
    internal string GetExpectedDescription(JsonContract contract);
    private object CreateObject(JsonReader reader, Type objectType, JsonContract contract, JsonProperty member);
    public object CreateNewObject(JsonReader reader, JsonObjectContract objectContract, JsonProperty containerMember, Boolean& createdFromNonDefaultCreator);
    private object CreateObjectUsingCreatorWithParameters(JsonReader reader, JsonObjectContract contract, JsonProperty containerProperty, jBU=<object> creator);
    private List`1<DT0=> ResolvePropertyAndCreatorValues(JsonObjectContract contract, JsonProperty containerProperty, JsonReader reader, Type objectType);
    private object CreateValueInternal(JsonReader reader, Type objectType, JsonContract contract, JsonProperty member, JsonContainerContract containerContract, JsonProperty containerMember, object existingValue);
    private object CreateObject(JsonReader reader, Type objectType, JsonContract contract, JsonProperty member, JsonContainerContract containerContract, JsonProperty containerMember, object existingValue);
    private bool HasNoDefinedType(JsonContract contract);
    private object EnsureType(JsonReader reader, object value, CultureInfo culture, JsonContract contract, Type targetType);
    private IDictionary CreateNewDictionary(JsonDictionaryContract contract);
    private object PopulateDictionary(IDictionary dictionary, JsonReader reader, JsonDictionaryContract contract, JsonProperty containerProperty);
}
internal class ThinkGeo.Core.JsonTextReader : JsonReader {
    private static char UnicodeReplacementChar;
    [CompilerGeneratedAttribute]
private int <LargeBufferLength>k__BackingField;
    private TextReader _reader;
    private Char[] _chars;
    private int _charsUsed;
    private int _charPos;
    private int _lineStartPos;
    private int _lineNumber;
    private bool _isEndOfFile;
    private StringBuffer _stringBuffer;
    private StringReference _stringReference;
    internal int LargeBufferLength { get; internal set; }
    public JsonTextReader(TextReader reader);
    [CompilerGeneratedAttribute]
internal int get_LargeBufferLength();
    [CompilerGeneratedAttribute]
internal void set_LargeBufferLength(int value);
    private void EnsureBufferNotEmpty();
    private void SetNewLine(bool hasNextChar);
    private void OnNewLine(int pos);
    private void ParseString(char quote, ReadType readType);
    private void ParseReadString(char quote, ReadType readType);
    private static void BlockCopyChars(Char[] src, int srcOffset, Char[] dst, int dstOffset, int count);
    private void ShiftBufferIfNeeded();
    private int ReadData(bool append);
    private void PrepareBufferForReadData(bool append, int charsRequired);
    private int ReadData(bool append, int charsRequired);
    private bool EnsureChars(int relativePosition, bool append);
    private bool ReadChars(int relativePosition, bool append);
    public virtual bool Read();
    public virtual Nullable`1<int> ReadAsInt32();
    public virtual string ReadAsString();
    public virtual Byte[] ReadAsBytes();
    private object ReadStringValue(ReadType readType);
    private object FinishReadQuotedStringValue(ReadType readType);
    private Exception CreateUnexpectedCharacterException(char c);
    public virtual Nullable`1<bool> ReadAsBoolean();
    private void ProcessValueComma();
    private object ReadNumberValue(ReadType readType);
    private object FinishReadQuotedNumber(ReadType readType);
    public virtual Nullable`1<decimal> ReadAsDecimal();
    public virtual Nullable`1<double> ReadAsDouble();
    private void HandleNull();
    private void ReadFinished();
    private bool ReadNullChar();
    private void EnsureBuffer();
    private void ReadStringIntoBuffer(char quote);
    private void FinishReadStringIntoBuffer(int charPos, int initialPosition, int lastWritePosition);
    private void WriteCharToBuffer(char writeChar, int lastWritePosition, int writeToPosition);
    private char ConvertUnicode(bool enoughChars);
    private char ParseUnicode();
    private void ReadNumberIntoBuffer();
    private bool ReadNumberCharIntoBuffer(char currentChar, int charPos);
    private void ClearRecentString();
    private bool ParsePostValue(bool ignoreComments);
    private bool ParseObject();
    private bool ParseProperty();
    private bool ValidIdentifierChar(char value);
    private void ParseUnquotedProperty();
    private bool ReadUnquotedPropertyReportIfDone(char currentChar, int initialPosition);
    private bool ParseValue();
    private void ProcessLineFeed();
    private void ProcessCarriageReturn(bool append);
    private void EatWhitespace();
    private void ParseConstructor();
    private void ParseNumber(ReadType readType);
    private void ParseReadNumber(ReadType readType, char firstChar, int initialPosition);
    private void ParseComment(bool setToken);
    private void EndComment(bool setToken, int initialPosition, int endPosition);
    private bool MatchValue(string value);
    private bool MatchValue(bool enoughChars, string value);
    private bool MatchValueWithTrailingSeparator(string value);
    private bool IsSeparator(char c);
    private void ParseTrue();
    private void ParseNull();
    private void ParseUndefined();
    private void ParseFalse();
    private object ParseNumberNegativeInfinity(ReadType readType);
    private object ParseNumberNegativeInfinity(ReadType readType, bool matched);
    private object ParseNumberPositiveInfinity(ReadType readType);
    private object ParseNumberPositiveInfinity(ReadType readType, bool matched);
    private object ParseNumberNaN(ReadType readType);
    private object ParseNumberNaN(ReadType readType, bool matched);
    public virtual void Close();
}
internal enum ThinkGeo.Core.JsonToken : Enum {
    public int value__;
    public static JsonToken None;
    public static JsonToken StartObject;
    public static JsonToken StartArray;
    public static JsonToken StartConstructor;
    public static JsonToken PropertyName;
    public static JsonToken Comment;
    public static JsonToken Raw;
    public static JsonToken Integer;
    public static JsonToken Float;
    public static JsonToken String;
    public static JsonToken Boolean;
    public static JsonToken Null;
    public static JsonToken Undefined;
    public static JsonToken EndObject;
    public static JsonToken EndArray;
    public static JsonToken EndConstructor;
    public static JsonToken Date;
    public static JsonToken Bytes;
}
[DefaultMemberAttribute("Item")]
internal abstract class ThinkGeo.Core.JToken : object {
    [ObfuscationAttribute]
private JContainer _parent;
    [ObfuscationAttribute]
private JToken _previous;
    [ObfuscationAttribute]
private JToken _next;
    public JContainer Parent { get; internal set; }
    internal JTokenType Type { get; }
    public bool HasValues { get; }
    public JToken Next { get; internal set; }
    public JToken Previous { get; internal set; }
    public JToken Item { get; public set; }
    public JToken First { get; }
    public JToken Last { get; }
    [DebuggerStepThroughAttribute]
public JContainer get_Parent();
    internal void set_Parent(JContainer value);
    internal abstract virtual JTokenType get_Type();
    public abstract virtual bool get_HasValues();
    public JToken get_Next();
    internal void set_Next(JToken value);
    public JToken get_Previous();
    internal void set_Previous(JToken value);
    public virtual JToken get_Item(object key);
    public virtual void set_Item(object key, JToken value);
    public virtual JToken get_First();
    public virtual JToken get_Last();
    internal virtual JEnumerable`1<JToken> Children();
    private static JValue EnsureValue(JToken value);
    public static bool op_Explicit(JToken value);
    public static int op_Explicit(JToken value);
    public static double op_Explicit(JToken value);
    public static float op_Explicit(JToken value);
    public static string op_Explicit(JToken value);
    public static JToken op_Implicit(string value);
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
    private sealed virtual override IEnumerator`1<JToken> System.Collections.Generic.IEnumerable<ThinkGeo.Core.JToken>.GetEnumerator();
    public T ToObject();
}
internal class ThinkGeo.Core.JTokenReader : JsonReader {
    private JToken _root;
    private JToken _parent;
    private JToken _current;
    internal JToken Root { get; }
    public JTokenReader(JToken token);
    internal JToken get_Root();
    public virtual bool Read();
    private bool ReadOver(JToken t);
    private bool ReadToEnd();
    private Nullable`1<JsonToken> GetEndToken(JContainer c);
    private bool ReadInto(JContainer c);
    private bool SetEnd(JContainer c);
    private void SetToken(JToken token);
    private string SafeToString(object value);
}
internal enum ThinkGeo.Core.JTokenType : Enum {
    public int value__;
    public static JTokenType None;
    public static JTokenType Object;
    public static JTokenType Array;
    public static JTokenType Constructor;
    public static JTokenType Property;
    public static JTokenType Comment;
    public static JTokenType Integer;
    public static JTokenType Float;
    public static JTokenType String;
    public static JTokenType Boolean;
    public static JTokenType Null;
    public static JTokenType Undefined;
    public static JTokenType Date;
    public static JTokenType Raw;
    public static JTokenType Bytes;
    public static JTokenType Guid;
    public static JTokenType Uri;
    public static JTokenType TimeSpan;
}
internal class ThinkGeo.Core.JValue : JToken {
    [ObfuscationAttribute]
private JTokenType _valueType;
    [ObfuscationAttribute]
private object _value;
    public bool HasValues { get; }
    internal JTokenType Type { get; }
    public object Value { get; public set; }
    internal JValue(object value, JTokenType type);
    public JValue(string value);
    public JValue(object value);
    public virtual bool get_HasValues();
    internal static int Compare(JTokenType valueType, object objA, object objB);
    private static int CompareFloat(object objA, object objB);
    public static JValue CreateNull();
    public static JValue CreateUndefined();
    private static JTokenType GetValueType(JTokenType current, object value);
    private static JTokenType GetStringValueType(JTokenType current);
    internal virtual JTokenType get_Type();
    public object get_Value();
    public void set_Value(object value);
    private static bool ValuesEquals(JValue v1, JValue v2);
    public sealed virtual bool Equals(JValue other);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    public virtual string ToString();
    public sealed virtual string ToString(string format, IFormatProvider formatProvider);
    private sealed virtual override int System.IComparable.CompareTo(object obj);
    public sealed virtual int CompareTo(JValue obj);
}
[ObfuscationAttribute]
internal class ThinkGeo.Core.KiloMetersValues : ValueType {
    [ObfuscationAttribute]
private double v1;
    [ObfuscationAttribute]
private double v10;
    [ObfuscationAttribute]
private double v100;
    [ObfuscationAttribute]
private double v1000;
    [ObfuscationAttribute]
private double v2;
    [ObfuscationAttribute]
private double v20;
    [ObfuscationAttribute]
private double v200;
    [ObfuscationAttribute]
private double v2000;
    [ObfuscationAttribute]
private double v3;
    [ObfuscationAttribute]
private double v30;
    [ObfuscationAttribute]
private double v300;
    [ObfuscationAttribute]
private double v4;
    [ObfuscationAttribute]
private double v40;
    [ObfuscationAttribute]
private double v400;
    [ObfuscationAttribute]
private double v4000;
    [ObfuscationAttribute]
private double v5;
    [ObfuscationAttribute]
private double v50;
    [ObfuscationAttribute]
private double v500;
    public double 1SA= { get; }
    public double 1yA= { get; }
    public double 2SA= { get; }
    public double 2yA= { get; }
    public double 3SA= { get; }
    public double vSA= { get; }
    public double vyA= { get; }
    public double wSA= { get; }
    public double wyA= { get; }
    public double xSA= { get; }
    public double xyA= { get; }
    public double ySA= { get; }
    public double yyA= { get; }
    public double zSA= { get; }
    public double zyA= { get; }
    public double 0SA= { get; }
    public double 0yA= { get; }
    public double 3yA= { get; }
    public KiloMetersValues(int width, double extentLengthBar, DistanceUnit distanceUnit);
    public double 1CA=();
    public double 1iA=();
    public double 2CA=();
    public double 2iA=();
    public double 3CA=();
    public double vCA=();
    public double viA=();
    public double wCA=();
    public double wiA=();
    public double xCA=();
    public double xiA=();
    public double yCA=();
    public double yiA=();
    public double zCA=();
    public double ziA=();
    public double 0CA=();
    public double 0iA=();
    public double 3iA=();
}
public abstract class ThinkGeo.Core.KrigingGridInterpolationModel : GridInterpolationModel {
    [ObfuscationAttribute]
private int referencingPointCount;
    [ObfuscationAttribute]
private Dictionary`2<PointShape, double> dataPoints;
    [ObfuscationAttribute]
private Double[0...,0...] pointValues;
    private FiI= 3iE=;
    [ObfuscationAttribute]
private Double[] extent;
    public Dictionary`2<PointShape, double> Points { get; }
    public int NumberOfReferencedPoints { get; public set; }
    protected KrigingGridInterpolationModel(IDictionary`2<PointShape, double> points);
    protected KrigingGridInterpolationModel(IDictionary`2<PointShape, double> points, int numberOfReferencedPoints);
    public Dictionary`2<PointShape, double> get_Points();
    public int get_NumberOfReferencedPoints();
    public void set_NumberOfReferencedPoints(int value);
    public double GetSemivariance(double distance, EmpiricalFunctionCoefficients coefficients);
    public EmpiricalFunctionCoefficients GetEmpiricalFunctionCoefficients(int numberOfPoints, Double[0...,0...] distance, Double[0...,0...] semivariances, double maxRange);
    protected virtual ValueTuple`2<double, double> InterpolateCore(RectangleShape cellExtent, GridDefinition gridDefinition);
    protected virtual double GetSemivarianceCore(double distance, EmpiricalFunctionCoefficients coefficients);
    protected double GetSillSlope(double distance, double range);
    protected abstract virtual double GetSillSlopeCore(double distance, double range);
    protected virtual EmpiricalFunctionCoefficients GetEmpiricalFunctionCoefficientsCore(int points, Double[0...,0...] distance, Double[0...,0...] semivariances, double maxRange);
    private ValueTuple`2<double, double> 3yE=(int nPn, double x, double y);
    private void 4CE=(Dictionary`2<PointShape, double> dataPoints);
    private Double[0...,0...] 4SE=(int nPn, double x, double y, FiI= quadTree);
    private Double[0...,0...] 4iE=(int npoints, Double[0...,0...] cpoints, EmpiricalFunctionCoefficients& coefficients);
    private Double[0...,0...] 4yE=(int nPn, Double[0...,0...] mdistances, EmpiricalFunctionCoefficients coefficients);
    private static void 5CE=(Double[]& a, Int32[]& b, int x);
    [OnGeodeserializedAttribute]
private void GxU=();
}
public enum ThinkGeo.Core.LabelDuplicateRule : Enum {
    public int value__;
    public static LabelDuplicateRule OneDuplicateLabelPerQuadrant;
    public static LabelDuplicateRule NoDuplicateLabels;
    public static LabelDuplicateRule UnlimitedDuplicateLabels;
}
public class ThinkGeo.Core.LabelInformation : object {
    [ObfuscationAttribute]
private ScreenPointF positionInScreenCoordinates;
    [ObfuscationAttribute]
private string text;
    [ObfuscationAttribute]
private double rotationAngle;
    public ScreenPointF PositionInScreenCoordinates { get; public set; }
    public string Text { get; public set; }
    public double RotationAngle { get; public set; }
    public LabelInformation(ScreenPointF positionInScreenCoordinates, string text, double rotationAngle);
    public ScreenPointF get_PositionInScreenCoordinates();
    public void set_PositionInScreenCoordinates(ScreenPointF value);
    public string get_Text();
    public void set_Text(string value);
    public double get_RotationAngle();
    public void set_RotationAngle(double value);
}
public class ThinkGeo.Core.LabelingCandidate : object {
    [ObfuscationAttribute]
private string originalText;
    [ObfuscationAttribute]
private PolygonShape screenArea;
    [ObfuscationAttribute]
private ScreenPointF centerPointInScreenCoordinate;
    [ObfuscationAttribute]
private Collection`1<LabelInformation> labelInformation;
    public string OriginalText { get; public set; }
    public PolygonShape ScreenArea { get; public set; }
    public ScreenPointF CenterPointInScreenCoordinate { get; public set; }
    public Collection`1<LabelInformation> LabelInformation { get; }
    public LabelingCandidate(string originalText, PolygonShape simplePolygonInScreenCoordinates, ScreenPointF centerPointInScreenCoordinate);
    public LabelingCandidate(string originalText, PolygonShape simplePolygonInScreenCoordinates, ScreenPointF centerPointInScreenCoordinate, Collection`1<LabelInformation> labelInformation);
    public string get_OriginalText();
    public void set_OriginalText(string value);
    public PolygonShape get_ScreenArea();
    public void set_ScreenArea(PolygonShape value);
    public ScreenPointF get_CenterPointInScreenCoordinate();
    public void set_CenterPointInScreenCoordinate(ScreenPointF value);
    public Collection`1<LabelInformation> get_LabelInformation();
}
public enum ThinkGeo.Core.LabelLeaderLinesRule : Enum {
    public int value__;
    public static LabelLeaderLinesRule NoLeaderLines;
    public static LabelLeaderLinesRule AllowLeaderLines;
}
public enum ThinkGeo.Core.LabelOverlappingRule : Enum {
    public int value__;
    public static LabelOverlappingRule NoOverlapping;
    public static LabelOverlappingRule AllowOverlapping;
}
public abstract class ThinkGeo.Core.Layer : LayerBase {
    private static object oRM=;
    private Exception qh0=;
    [ObfuscationAttribute]
private string attribution;
    [CompilerGeneratedAttribute]
private EventHandler`1<DrawingAttributionLayerEventArgs> DrawingAttribution;
    [CompilerGeneratedAttribute]
private EventHandler`1<DrawnAttributionLayerEventArgs> DrawnAttribution;
    [ObsoleteAttribute("Layer.Attribution (as well as Drawing Attribution) is deprecate and will be removed after v14.2. You can accomplish the similar feature by overriding layer.DrawCore/Layer.DrawAsyncCore method")]
public string Attribution { get; public set; }
    private static Layer();
    [CompilerGeneratedAttribute]
public void add_DrawingAttribution(EventHandler`1<DrawingAttributionLayerEventArgs> value);
    [CompilerGeneratedAttribute]
public void remove_DrawingAttribution(EventHandler`1<DrawingAttributionLayerEventArgs> value);
    [CompilerGeneratedAttribute]
public void add_DrawnAttribution(EventHandler`1<DrawnAttributionLayerEventArgs> value);
    [CompilerGeneratedAttribute]
public void remove_DrawnAttribution(EventHandler`1<DrawnAttributionLayerEventArgs> value);
    public string get_Attribution();
    public void set_Attribution(string value);
    [ObsoleteAttribute("Layer.Attribution (as well as Drawing Attribution) is deprecate and will be removed after v14.2. You can accomplish the similar feature by overriding layer.DrawCore/Layer.DrawAsyncCore method")]
protected virtual void OnDrawingAttribution(DrawingAttributionLayerEventArgs args);
    [ObsoleteAttribute("Layer.Attribution (as well as Drawing Attribution) is deprecate and will be removed after v14.2. You can accomplish the similar feature by overriding layer.DrawCore/Layer.DrawAsyncCore method")]
protected virtual void OnDrawnAttribution(DrawnAttributionLayerEventArgs args);
    public static Layer LoadLayer(Uri layerUri);
    public static Layer LoadLayer(Stream layerStream);
    public void Open();
    protected virtual void OpenCore();
    public void Close();
    protected virtual void CloseCore();
    public void Draw(GeoCanvas canvas, Collection`1<SimpleCandidate> labelsInAllLayers);
    private void 5x8=(GeoCanvas canvas, Collection`1<SimpleCandidate> labelsInAllLayers);
    protected virtual void DrawWithColorTransformation(GeoCanvas canvas, Collection`1<SimpleCandidate> labelsInAllLayers, RectangleShape extent, float width, float height);
    protected abstract virtual void DrawCore(GeoCanvas canvas, Collection`1<SimpleCandidate> labelsInAllLayers);
    private void 6B8=(GeoCanvas canvas, string attribution);
    [ObsoleteAttribute("Layer.Attribution (as well as Drawing Attribution) is deprecate and will be removed after v14.2. You can accomplish the similar feature by overriding layer.DrawCore/Layer.DrawAsyncCore method")]
protected virtual void DrawAttributionCore(GeoCanvas canvas, string attribution);
    private void rh0=(object sender, DrawingProgressChangedEventArgs e);
}
public enum ThinkGeo.Core.LayerAnchorLocation : Enum {
    public int value__;
    public static LayerAnchorLocation UpperLeft;
    public static LayerAnchorLocation UpperRight;
    public static LayerAnchorLocation LowerRight;
    public static LayerAnchorLocation LowerLeft;
    public static LayerAnchorLocation Center;
    public static LayerAnchorLocation UpperCenter;
    public static LayerAnchorLocation LowerCenter;
    public static LayerAnchorLocation LeftCenter;
    public static LayerAnchorLocation RightCenter;
}
public abstract class ThinkGeo.Core.LayerBase : object {
    [ObfuscationAttribute]
private float redTranslation;
    [ObfuscationAttribute]
private float greenTranslation;
    [ObfuscationAttribute]
private float blueTranslation;
    [ObfuscationAttribute]
private float transparency;
    [CompilerGeneratedAttribute]
private EventHandler`1<DrawingProgressChangedEventArgs> DrawingProgressChanged;
    [CompilerGeneratedAttribute]
private EventHandler`1<DrawingExceptionLayerEventArgs> DrawingException;
    [CompilerGeneratedAttribute]
private EventHandler`1<DrawnExceptionLayerEventArgs> DrawnException;
    [CompilerGeneratedAttribute]
private string lR0=;
    [CompilerGeneratedAttribute]
private bool lh0=;
    [CompilerGeneratedAttribute]
private bool lx0=;
    [CompilerGeneratedAttribute]
private TimeSpan mB0=;
    [CompilerGeneratedAttribute]
private Projection mR0=;
    [CompilerGeneratedAttribute]
private DrawingExceptionMode mh0=;
    [CompilerGeneratedAttribute]
private GeoColor mx0=;
    [CompilerGeneratedAttribute]
private Collection`1<GeoColor> nB0=;
    [CompilerGeneratedAttribute]
private bool nR0=;
    [CompilerGeneratedAttribute]
private bool nh0=;
    [CompilerGeneratedAttribute]
private ThreadSafetyLevel nx0=;
    [CompilerGeneratedAttribute]
private Dictionary`2<GeoColor, GeoColor> oB0=;
    [CompilerGeneratedAttribute]
private WrappingMode oR0=;
    [CompilerGeneratedAttribute]
private RectangleShape oh0=;
    internal static RectangleShape ox0=;
    internal static TimeSpan pB0=;
    [ObfuscationAttribute]
private TimeSpan requestDrawingInterval;
    private Timer pR0=;
    [CompilerGeneratedAttribute]
private EventHandler`1<RequestedDrawingLayerEventArgs> RequestedDrawing;
    [CompilerGeneratedAttribute]
private EventHandler`1<RequestingDrawingLayerEventArgs> RequestingDrawing;
    public string Name { get; public set; }
    protected bool IsOpenCore { get; protected set; }
    public bool IsOpen { get; }
    public bool IsVisible { get; public set; }
    public TimeSpan DrawingTime { get; protected set; }
    public Projection Projection { get; public set; }
    public DrawingExceptionMode DrawingExceptionMode { get; public set; }
    public GeoColor Background { get; public set; }
    public float Transparency { get; public set; }
    public float BlueTranslation { get; public set; }
    public float RedTranslation { get; public set; }
    public float GreenTranslation { get; public set; }
    public Collection`1<GeoColor> KeyColors { get; }
    public bool IsNegative { get; public set; }
    public bool IsGrayscale { get; public set; }
    public bool HasBoundingBox { get; }
    public ThreadSafetyLevel ThreadSafe { get; public set; }
    public Dictionary`2<GeoColor, GeoColor> ColorMappings { get; }
    public WrappingMode WrappingMode { get; public set; }
    public RectangleShape WrappingExtent { get; public set; }
    public TimeSpan RequestDrawingInterval { get; public set; }
    private static LayerBase();
    [CompilerGeneratedAttribute]
public void add_DrawingProgressChanged(EventHandler`1<DrawingProgressChangedEventArgs> value);
    [CompilerGeneratedAttribute]
public void remove_DrawingProgressChanged(EventHandler`1<DrawingProgressChangedEventArgs> value);
    [CompilerGeneratedAttribute]
public void add_DrawingException(EventHandler`1<DrawingExceptionLayerEventArgs> value);
    [CompilerGeneratedAttribute]
public void remove_DrawingException(EventHandler`1<DrawingExceptionLayerEventArgs> value);
    [CompilerGeneratedAttribute]
public void add_DrawnException(EventHandler`1<DrawnExceptionLayerEventArgs> value);
    [CompilerGeneratedAttribute]
public void remove_DrawnException(EventHandler`1<DrawnExceptionLayerEventArgs> value);
    [CompilerGeneratedAttribute]
public string get_Name();
    [CompilerGeneratedAttribute]
public void set_Name(string value);
    [CompilerGeneratedAttribute]
protected virtual bool get_IsOpenCore();
    [CompilerGeneratedAttribute]
protected virtual void set_IsOpenCore(bool value);
    public bool get_IsOpen();
    [CompilerGeneratedAttribute]
public bool get_IsVisible();
    [CompilerGeneratedAttribute]
public void set_IsVisible(bool value);
    [CompilerGeneratedAttribute]
public TimeSpan get_DrawingTime();
    [CompilerGeneratedAttribute]
protected void set_DrawingTime(TimeSpan value);
    [CompilerGeneratedAttribute]
public virtual Projection get_Projection();
    [CompilerGeneratedAttribute]
public virtual void set_Projection(Projection value);
    [CompilerGeneratedAttribute]
public DrawingExceptionMode get_DrawingExceptionMode();
    [CompilerGeneratedAttribute]
public void set_DrawingExceptionMode(DrawingExceptionMode value);
    [CompilerGeneratedAttribute]
public GeoColor get_Background();
    [CompilerGeneratedAttribute]
public void set_Background(GeoColor value);
    public bool IsDrawingNeeded(double currentScale);
    protected virtual bool IsDrawingNeededCore(double currentScale);
    public float get_Transparency();
    public void set_Transparency(float value);
    public float get_BlueTranslation();
    public void set_BlueTranslation(float value);
    public float get_RedTranslation();
    public void set_RedTranslation(float value);
    public float get_GreenTranslation();
    public void set_GreenTranslation(float value);
    [CompilerGeneratedAttribute]
public Collection`1<GeoColor> get_KeyColors();
    [CompilerGeneratedAttribute]
public bool get_IsNegative();
    [CompilerGeneratedAttribute]
public void set_IsNegative(bool value);
    [CompilerGeneratedAttribute]
public bool get_IsGrayscale();
    [CompilerGeneratedAttribute]
public void set_IsGrayscale(bool value);
    public virtual bool get_HasBoundingBox();
    [CompilerGeneratedAttribute]
public ThreadSafetyLevel get_ThreadSafe();
    [CompilerGeneratedAttribute]
public void set_ThreadSafe(ThreadSafetyLevel value);
    [CompilerGeneratedAttribute]
public Dictionary`2<GeoColor, GeoColor> get_ColorMappings();
    [CompilerGeneratedAttribute]
public WrappingMode get_WrappingMode();
    [CompilerGeneratedAttribute]
public void set_WrappingMode(WrappingMode value);
    [CompilerGeneratedAttribute]
public RectangleShape get_WrappingExtent();
    [CompilerGeneratedAttribute]
public void set_WrappingExtent(RectangleShape value);
    protected void DrawException(GeoCanvas canvas, Exception e);
    protected virtual void DrawExceptionCore(GeoCanvas canvas, Exception e);
    protected virtual void OnDrawingException(DrawingExceptionLayerEventArgs e);
    public RectangleShape GetBoundingBox();
    protected virtual RectangleShape GetBoundingBoxCore();
    protected virtual void OnDrawnException(DrawnExceptionLayerEventArgs e);
    protected virtual void OnDrawingProgressChanged(DrawingProgressChangedEventArgs e);
    public LayerBase CloneDeep();
    protected virtual LayerBase CloneDeepCore();
    [CompilerGeneratedAttribute]
public void add_RequestedDrawing(EventHandler`1<RequestedDrawingLayerEventArgs> value);
    [CompilerGeneratedAttribute]
public void remove_RequestedDrawing(EventHandler`1<RequestedDrawingLayerEventArgs> value);
    [CompilerGeneratedAttribute]
public void add_RequestingDrawing(EventHandler`1<RequestingDrawingLayerEventArgs> value);
    [CompilerGeneratedAttribute]
public void remove_RequestingDrawing(EventHandler`1<RequestingDrawingLayerEventArgs> value);
    public TimeSpan get_RequestDrawingInterval();
    public void set_RequestDrawingInterval(TimeSpan value);
    public void RequestDrawing();
    public void RequestDrawing(RectangleShape extentToRefresh);
    public void RequestDrawing(IEnumerable`1<RectangleShape> extentsToRefresh);
    public void RequestDrawing(TimeSpan bufferTime);
    public void RequestDrawing(TimeSpan bufferTime, RequestDrawingBufferTimeType bufferTimeType);
    public void RequestDrawing(RectangleShape extentToRefresh, TimeSpan bufferTime);
    public void RequestDrawing(RectangleShape extentToRefresh, TimeSpan bufferTime, RequestDrawingBufferTimeType bufferTimeType);
    public void RequestDrawing(IEnumerable`1<RectangleShape> extentsToRefresh, TimeSpan bufferTime);
    public void RequestDrawing(IEnumerable`1<RectangleShape> extentsToRefresh, TimeSpan bufferTime, RequestDrawingBufferTimeType bufferTimeType);
    protected void StartRequestDrawing();
    protected void StopRequestDrawing();
    protected virtual void OnRequestedDrawing(RequestedDrawingLayerEventArgs eventArgs);
    protected virtual void OnRequestingDrawing(RequestingDrawingLayerEventArgs eventArgs);
    private void ph0=(IEnumerable`1<RectangleShape> extentsToRefresh, TimeSpan bufferTime, RequestDrawingBufferTimeType bufferTimeType);
    private void px0=(object sender, EventArgs e);
}
public class ThinkGeo.Core.LayerDrawingEventArgs : EventArgs {
    [ObfuscationAttribute]
private Layer currentLayer;
    [ObfuscationAttribute]
private RectangleShape worldExtent;
    [ObfuscationAttribute]
private object nativeImage;
    [ObfuscationAttribute]
private bool cancel;
    public bool Cancel { get; public set; }
    public Layer CurrentLayer { get; public set; }
    public RectangleShape WorldExtent { get; public set; }
    public object NativeImage { get; public set; }
    public LayerDrawingEventArgs(Layer currentLayer, RectangleShape worldExtent, object nativeImage);
    public bool get_Cancel();
    public void set_Cancel(bool value);
    public Layer get_CurrentLayer();
    public void set_CurrentLayer(Layer value);
    public RectangleShape get_WorldExtent();
    public void set_WorldExtent(RectangleShape value);
    public object get_NativeImage();
    public void set_NativeImage(object value);
}
public class ThinkGeo.Core.LayerDrawnEventArgs : EventArgs {
    [ObfuscationAttribute]
private Layer currentLayer;
    [ObfuscationAttribute]
private RectangleShape worldExtent;
    [ObfuscationAttribute]
private object nativeImage;
    public Layer CurrentLayer { get; public set; }
    public RectangleShape WorldExtent { get; public set; }
    public object NativeImage { get; public set; }
    public LayerDrawnEventArgs(Layer currentLayer, RectangleShape worldExtent, object nativeImage);
    public Layer get_CurrentLayer();
    public void set_CurrentLayer(Layer value);
    public RectangleShape get_WorldExtent();
    public void set_WorldExtent(RectangleShape value);
    public object get_NativeImage();
    public void set_NativeImage(object value);
}
public class ThinkGeo.Core.LayersDrawingEventArgs : EventArgs {
    [ObfuscationAttribute]
private IEnumerable`1<Layer> layers;
    [ObfuscationAttribute]
private RectangleShape worldExtent;
    [ObfuscationAttribute]
private object nativeImage;
    [ObfuscationAttribute]
private bool cancel;
    public bool Cancel { get; public set; }
    public RectangleShape WorldExtent { get; public set; }
    public object NativeImage { get; public set; }
    public IEnumerable`1<Layer> Layers { get; public set; }
    public LayersDrawingEventArgs(IEnumerable`1<Layer> layers, RectangleShape worldExtent, object nativeImage);
    public bool get_Cancel();
    public void set_Cancel(bool value);
    public RectangleShape get_WorldExtent();
    public void set_WorldExtent(RectangleShape value);
    public object get_NativeImage();
    public void set_NativeImage(object value);
    public IEnumerable`1<Layer> get_Layers();
    public void set_Layers(IEnumerable`1<Layer> value);
}
public class ThinkGeo.Core.LayersDrawnEventArgs : EventArgs {
    [ObfuscationAttribute]
private IEnumerable`1<Layer> layers;
    [ObfuscationAttribute]
private RectangleShape worldExtent;
    [ObfuscationAttribute]
private object nativeImage;
    public RectangleShape WorldExtent { get; public set; }
    public object NativeImage { get; public set; }
    public IEnumerable`1<Layer> Layers { get; public set; }
    public LayersDrawnEventArgs(IEnumerable`1<Layer> layers, RectangleShape worldExtent, object nativeImage);
    public RectangleShape get_WorldExtent();
    public void set_WorldExtent(RectangleShape value);
    public object get_NativeImage();
    public void set_NativeImage(object value);
    public IEnumerable`1<Layer> get_Layers();
    public void set_Layers(IEnumerable`1<Layer> value);
}
internal class ThinkGeo.Core.LeafRecordWrapper : object {
    [CompilerGeneratedAttribute]
private Rh8= <Leaf>k__BackingField;
    [CompilerGeneratedAttribute]
private int <RecordId>k__BackingField;
    [CompilerGeneratedAttribute]
private string <FeatureId>k__BackingField;
    public Rh8= Leaf { get; public set; }
    public int RecordId { get; public set; }
    public string FeatureId { get; public set; }
    public LeafRecordWrapper(Rh8= leaf, int recordId, string featureId);
    [CompilerGeneratedAttribute]
public Rh8= get_Leaf();
    [CompilerGeneratedAttribute]
public void set_Leaf(Rh8= value);
    [CompilerGeneratedAttribute]
public int get_RecordId();
    [CompilerGeneratedAttribute]
public void set_RecordId(int value);
    [CompilerGeneratedAttribute]
public string get_FeatureId();
    [CompilerGeneratedAttribute]
public void set_FeatureId(string value);
}
public class ThinkGeo.Core.LegendAdornmentLayer : AdornmentLayer {
    [ObfuscationAttribute]
private GeoCollection`1<LegendItem> legendItems;
    [ObfuscationAttribute]
private float titleHeight;
    [ObfuscationAttribute]
private float footerHeight;
    [ObfuscationAttribute]
private float rowMaxWidth;
    [ObfuscationAttribute]
private Collection`1<LegendDrawingParameters> offsets;
    [ObfuscationAttribute]
private LegendItem title;
    [ObfuscationAttribute]
private LegendItem footer;
    [ObfuscationAttribute]
private LegendContentResizeMode contentResizeMode;
    public LegendItem Title { get; public set; }
    public LegendItem Footer { get; public set; }
    public GeoCollection`1<LegendItem> LegendItems { get; }
    public LegendContentResizeMode ContentResizeMode { get; public set; }
    public LegendItem get_Title();
    public void set_Title(LegendItem value);
    public LegendItem get_Footer();
    public void set_Footer(LegendItem value);
    public GeoCollection`1<LegendItem> get_LegendItems();
    public LegendContentResizeMode get_ContentResizeMode();
    public void set_ContentResizeMode(LegendContentResizeMode value);
    protected virtual void DrawCore(GeoCanvas canvas, Collection`1<SimpleCandidate> labelsInAllLayers);
    private void DSA=(Collection`1<SimpleCandidate> labelsInAllLayers, GeoCanvas adornmentGeoCanvas, int countPostion, LegendItem legendItem);
    private void DiA=(Collection`1<SimpleCandidate> labelsInAllLayers, GeoCanvas adornmentGeoCanvas);
    private void DyA=(Collection`1<SimpleCandidate> labelsInAllLayers, GeoCanvas adornmentGeoCanvas);
    private void ECA=(float widthEnlargedRatio, float heightEnlargedRatio);
    private bool ESA=(LegendItem legendItem, string type);
}
public enum ThinkGeo.Core.LegendContentResizeMode : Enum {
    public int value__;
    public static LegendContentResizeMode Default;
    public static LegendContentResizeMode Resizable;
    public static LegendContentResizeMode Fixed;
}
public class ThinkGeo.Core.LegendDrawingParameters : ValueType {
    [ObfuscationAttribute]
private float xOffset;
    [ObfuscationAttribute]
private float yOffset;
    public float XOffset { get; public set; }
    public float YOffset { get; public set; }
    public float get_XOffset();
    public void set_XOffset(float value);
    public float get_YOffset();
    public void set_YOffset(float value);
    public virtual int GetHashCode();
    public virtual bool Equals(object obj);
    private bool bRU=(LegendDrawingParameters param);
    public static bool op_Equality(LegendDrawingParameters param1, LegendDrawingParameters param2);
    public static bool op_Inequality(LegendDrawingParameters param1, LegendDrawingParameters param2);
}
public enum ThinkGeo.Core.LegendImageJustificationMode : Enum {
    public int value__;
    public static LegendImageJustificationMode Default;
    public static LegendImageJustificationMode JustifyImageLeft;
    public static LegendImageJustificationMode JustifyImageRight;
}
public class ThinkGeo.Core.LegendItem : object {
    [ObfuscationAttribute]
private float width;
    [ObfuscationAttribute]
private float height;
    [ObfuscationAttribute]
private float imageWidth;
    [ObfuscationAttribute]
private float imageHeight;
    [ObfuscationAttribute]
private float topPadding;
    [ObfuscationAttribute]
private float bottomPadding;
    [ObfuscationAttribute]
private float leftPadding;
    [ObfuscationAttribute]
private float rightPadding;
    [ObfuscationAttribute]
private float imageTopPadding;
    [ObfuscationAttribute]
private float imageBottomPadding;
    [ObfuscationAttribute]
private float imageLeftPadding;
    [ObfuscationAttribute]
private float imageRightPadding;
    [ObfuscationAttribute]
private float textTopPadding;
    [ObfuscationAttribute]
private float textBottomPadding;
    [ObfuscationAttribute]
private float textLeftPadding;
    [ObfuscationAttribute]
private float textRightPadding;
    [ObfuscationAttribute]
private Style imageStyle;
    [ObfuscationAttribute]
private TextStyle textStyle;
    [ObfuscationAttribute]
private AreaStyle backgroundMask;
    [ObfuscationAttribute]
private AreaStyle textMask;
    [ObfuscationAttribute]
private AreaStyle imageMask;
    [ObfuscationAttribute]
private LegendImageJustificationMode imageJustificationMode;
    [ObfuscationAttribute]
private Nullable`1<float> originalFontSize;
    [ObfuscationAttribute]
private float ratio;
    public float TopPadding { get; public set; }
    public float BottomPadding { get; public set; }
    public float LeftPadding { get; public set; }
    public float RightPadding { get; public set; }
    public float ImageTopPadding { get; public set; }
    public float ImageBottomPadding { get; public set; }
    public float ImageLeftPadding { get; public set; }
    public float ImageRightPadding { get; public set; }
    public float TextTopPadding { get; public set; }
    public float TextBottomPadding { get; public set; }
    public float TextLeftPadding { get; public set; }
    public float TextRightPadding { get; public set; }
    public float Width { get; public set; }
    public float Height { get; public set; }
    public float ImageWidth { get; public set; }
    public float ImageHeight { get; public set; }
    public Style ImageStyle { get; public set; }
    public TextStyle TextStyle { get; public set; }
    public AreaStyle BackgroundMask { get; public set; }
    public AreaStyle TextMask { get; public set; }
    public AreaStyle ImageMask { get; public set; }
    public float Ratio { get; public set; }
    public LegendImageJustificationMode ImageJustificationMode { get; public set; }
    public LegendItem(int width, int height, float imageWidth, float imageHeight, Style imageStyle, TextStyle textStyle);
    public float get_TopPadding();
    public void set_TopPadding(float value);
    public float get_BottomPadding();
    public void set_BottomPadding(float value);
    public float get_LeftPadding();
    public void set_LeftPadding(float value);
    public float get_RightPadding();
    public void set_RightPadding(float value);
    public float get_ImageTopPadding();
    public void set_ImageTopPadding(float value);
    public float get_ImageBottomPadding();
    public void set_ImageBottomPadding(float value);
    public float get_ImageLeftPadding();
    public void set_ImageLeftPadding(float value);
    public float get_ImageRightPadding();
    public void set_ImageRightPadding(float value);
    public float get_TextTopPadding();
    public void set_TextTopPadding(float value);
    public float get_TextBottomPadding();
    public void set_TextBottomPadding(float value);
    public float get_TextLeftPadding();
    public void set_TextLeftPadding(float value);
    public float get_TextRightPadding();
    public void set_TextRightPadding(float value);
    public float get_Width();
    public void set_Width(float value);
    public float get_Height();
    public void set_Height(float value);
    public float get_ImageWidth();
    public void set_ImageWidth(float value);
    public float get_ImageHeight();
    public void set_ImageHeight(float value);
    public Style get_ImageStyle();
    public void set_ImageStyle(Style value);
    public TextStyle get_TextStyle();
    public void set_TextStyle(TextStyle value);
    public AreaStyle get_BackgroundMask();
    public void set_BackgroundMask(AreaStyle value);
    public AreaStyle get_TextMask();
    public void set_TextMask(AreaStyle value);
    public AreaStyle get_ImageMask();
    public void set_ImageMask(AreaStyle value);
    public float get_Ratio();
    public void set_Ratio(float value);
    public LegendImageJustificationMode get_ImageJustificationMode();
    public void set_ImageJustificationMode(LegendImageJustificationMode value);
    public void Draw(GeoCanvas adornmentGeoCanvas, Collection`1<SimpleCandidate> labelsInAllLayers, LegendDrawingParameters legendDrawingParameters);
    protected virtual void DrawCore(GeoCanvas adornmentGeoCanvas, Collection`1<SimpleCandidate> labelsInAllLayers, LegendDrawingParameters legendDrawingParameters);
    public void UpdateSizeByTextLength(GeoCanvas canvas, double zoomRatio);
    private string EiA=(int wordWrapLength);
}
public enum ThinkGeo.Core.LibTiff.Compression : Enum {
    public int value__;
    public static Compression NONE;
    public static Compression CCITTRLE;
    public static Compression CCITTFAX3;
    public static Compression CCITT_T4;
    public static Compression CCITTFAX4;
    public static Compression CCITT_T6;
    public static Compression LZW;
    public static Compression OJPEG;
    public static Compression JPEG;
    public static Compression NEXT;
    public static Compression CCITTRLEW;
    public static Compression PACKBITS;
    public static Compression THUNDERSCAN;
    public static Compression IT8CTPAD;
    public static Compression IT8LW;
    public static Compression IT8MP;
    public static Compression IT8BL;
    public static Compression PIXARFILM;
    public static Compression PIXARLOG;
    public static Compression DEFLATE;
    public static Compression ADOBE_DEFLATE;
    public static Compression DCS;
    public static Compression JBIG;
    public static Compression SGILOG;
    public static Compression SGILOG24;
    public static Compression JP2000;
}
public class ThinkGeo.Core.LibTiff.FieldValue : ValueType {
    private object XzM=;
    public object Value { get; }
    internal FieldValue(object o);
    internal static FieldValue[] YDM=(Object[] list);
    internal void YTM=(object o);
    public object get_Value();
    public byte ToByte();
    public short ToShort();
    public ushort ToUShort();
    public int ToInt();
    public UInt32 ToUInt();
    public long ToLong();
    public float ToFloat();
    public double ToDouble();
    public virtual string ToString();
    public Byte[] GetBytes();
    public Byte[] ToByteArray();
    public Int16[] ToShortArray();
    public UInt16[] ToUShortArray();
    public Int32[] ToIntArray();
    public UInt32[] ToUIntArray();
    public Int64[] TolongArray();
    public Single[] ToFloatArray();
    public Double[] ToDoubleArray();
}
public enum ThinkGeo.Core.LibTiff.Orientation : Enum {
    public int value__;
    public static Orientation TOPLEFT;
    public static Orientation TOPRIGHT;
    public static Orientation BOTRIGHT;
    public static Orientation BOTLEFT;
    public static Orientation LEFTTOP;
    public static Orientation RIGHTTOP;
    public static Orientation RIGHTBOT;
    public static Orientation LEFTBOT;
}
public class ThinkGeo.Core.LibTiff.Tiff : object {
    private static TiffErrorHandler JDQ=;
    private static TiffExtendProc JTQ=;
    private static TiffFieldInfo[] JjQ=;
    private static TiffFieldInfo[] JzQ=;
    private static int KDQ=;
    private static int KTQ=;
    private static short KjQ=;
    private static short KzQ=;
    private static short LDQ=;
    private static float LTQ=;
    private static float LjQ=;
    private static float LzQ=;
    internal static int MDQ=;
    internal static czY= MTQ=;
    internal static bool MjQ=;
    internal static bool MzQ=;
    internal static Encoding NDQ=;
    internal string NTQ=;
    internal int azM=;
    internal czY= NjQ=;
    internal ulong NzQ=;
    internal LzY= ODQ=;
    internal int OTQ=;
    internal int OjQ=;
    internal int OzQ=;
    internal int PDQ=;
    internal TiffCodec PTQ=;
    internal int PjQ=;
    internal Byte[] PzQ=;
    internal int QDQ=;
    internal int QTQ=;
    internal int QjQ=;
    internal object QzQ=;
    internal gz0= RDQ=;
    internal TiffTagMethods RTQ=;
    private ulong RjQ=;
    private UInt64[] RzQ=;
    private int SDQ=;
    private short STQ=;
    private hTY= SjQ=;
    private Int32[] SzQ=;
    private UInt32[] TDQ=;
    private short TTQ=;
    private ulong TjQ=;
    private ulong TzQ=;
    private short UDQ=;
    private ulong UTQ=;
    private int UjQ=;
    private bool UzQ=;
    private TiffFieldInfo[] VDQ=;
    private int VTQ=;
    private TiffFieldInfo VjQ=;
    private jD0= VzQ=;
    private TiffCodec[] WDQ=;
    private iT0= WTQ=;
    private TiffTagMethods WjQ=;
    private bool WzQ=;
    private Stream XDQ=;
    private TiffStream FDQ=;
    private static UInt32[] XTQ=;
    private static Int32[] XjQ=;
    private static Int32[] XzQ=;
    private static String[] YDQ=;
    private static String[] YTQ=;
    private static int YjQ=;
    private static int YzQ=;
    internal static int ZDQ=;
    internal static int ZTQ=;
    internal static int ZjQ=;
    internal static int ZzQ=;
    internal static int aDQ=;
    private static Byte[] aTQ=;
    private static Byte[] ajQ=;
    public static string AssemblyVersion { get; }
    private static Tiff();
    private static Tiff sB4=(string fileName, string mode, TiffErrorHandler errorHandler);
    private static Tiff sB4=(string fileName, string mode, TiffErrorHandler errorHandler, TiffExtendProc extender);
    private static Tiff azQ=(string name, string mode, object clientData, TiffStream stream, TiffErrorHandler errorHandler);
    private static Tiff azQ=(string name, string mode, object clientData, TiffStream stream, TiffErrorHandler errorHandler, TiffExtendProc extender);
    private static TiffErrorHandler bDQ=(TiffErrorHandler errorHandler);
    private static TiffExtendProc bTQ=(TiffExtendProc extender);
    private static TiffErrorHandler bjQ=(Tiff tif);
    private static bool bzQ=(LzY= td);
    private static void cDQ=(LzY= td);
    internal static ulong cTQ=(Byte[] buffer, int offset);
    internal static int cjQ=(Byte[] buffer, int offset);
    internal static void czQ=(int value, Byte[] buffer, int offset);
    internal static void dDQ=(ulong value, Byte[] buffer, int offset);
    internal static short dTQ=(Byte[] buffer, int offset);
    internal static void djQ=(Stream fd, string format, Object[] list);
    private static string dzQ=(byte value);
    private void eDQ=();
    internal static bool eTQ=(TiffTag t);
    private bool ejQ=(8zI= o);
    private static int ezQ=(int n);
    private bool fDQ=(TiffTag tag);
    private void fTQ=();
    private bool fjQ=(UInt64& nextdir, Int64& off);
    internal static void fzQ=(String& cpp, string cp);
    internal static void gDQ=(Int16[]& wpp, Int16[] wp, int n);
    internal static void gTQ=(Int32[]& lpp, Int32[] lp, int n);
    internal static void gjQ=(Int64[]& lpp, Int64[] lp, int n);
    internal static void gzQ=(Single[]& fpp, Single[] fp, int n);
    internal bool hDQ=(int field);
    internal void hTQ=(int field);
    internal void hjQ=(int field);
    private static TiffFieldInfo[] hzQ=(Int32& size);
    private static TiffFieldInfo[] iDQ=(Int32& size);
    private void iTQ=(TiffFieldInfo[] info, int n);
    private TiffType ijQ=();
    private static TiffFieldInfo izQ=(TiffTag tag, TiffType field_type);
    internal static int jDQ=(TiffType type);
    private long jTQ=(XzY= dir);
    private bool jjQ=(LzY= td);
    private static int jzQ=(int x);
    private bool kDQ=(XzY=[] dir, long dircount);
    private void kTQ=(string tagname);
    private int kjQ=(XzY= dir);
    private static long kzQ=(XzY=[] dir, ulong dircount, TiffTag tagid);
    private bool lDQ=(ulong diroff);
    private ulong lTQ=(ulong diroff, XzY=[]& pdir, UInt64& nextdiroff);
    private bool ljQ=(XzY= dir);
    private bool lzQ=(XzY= dir, int count);
    private int mDQ=(XzY= dir, Byte[] buffer);
    private int mTQ=(XzY= dir, String& cp);
    private bool mjQ=(XzY= dir, int num, int denom, Single& rv);
    private float mzQ=(XzY= dir);
    private float nDQ=(XzY= dir);
    private bool nTQ=(XzY= dir, Byte[] v);
    private bool njQ=(XzY= dir, Int16[] v);
    private bool nzQ=(XzY= dir);
    private bool oDQ=(XzY= dir, Int32[] v);
    private bool oTQ=(XzY= dir, Int64[] v);
    private bool ojQ=(XzY= dir, Single[] v);
    private bool ozQ=(XzY= dir, Single[] v);
    private bool pDQ=(XzY= dir, Double[] v);
    private bool pTQ=(XzY= dir, Double[] v);
    private bool pjQ=(XzY= dir);
    private bool pzQ=(XzY= dir, Int16& pl);
    private bool qDQ=(XzY= dir, Int32& pl);
    private bool qTQ=(XzY= dir, Double& pl);
    private bool qjQ=(XzY= dir, int nstrips, Int64[]& lpp);
    private bool qjQ=(XzY= dir, int nstrips, UInt64[]& lpp);
    private bool qzQ=(XzY= dir);
    private void rDQ=();
    internal static int rTQ=(int x, int y);
    internal static int rjQ=(int x, int y);
    internal static ulong rjQ=(ulong x, ulong y);
    private ulong rzQ=(TiffType type, int v);
    private static void sDQ=(Int32[] fields, short f);
    private static bool hDQ=(Int32[] fields, short f);
    private bool sTQ=(TiffType type, TiffTag tag, XzY=& dir, float v);
    private bool sjQ=(XzY=[] entries, int dirOffset, TiffType type, TiffTag tag1, float v1, TiffTag tag2, float v2);
    private bool szQ=(bool done);
    private bool tDQ=();
    private bool tTQ=(XzY=& dir, TiffFieldInfo fip);
    private void tjQ=(TiffTag tag, XzY=& dir, int v);
    private void tzQ=(TiffTag tag, XzY=& dir, short v);
    private bool uDQ=(TiffTag tag, XzY=& dir);
    private bool uTQ=(TiffType type, TiffTag tag, XzY=& dir);
    private bool ujQ=(TiffTag tag, XzY=& dir);
    private bool uzQ=(TiffTag tag, XzY=& dir, int n, Int16[][] table);
    private bool vDQ=(XzY=& dir, Byte[] cp);
    private bool vTQ=(XzY=& dir, Int16[] v);
    private bool vjQ=(XzY=& dir, Int32[] v);
    private bool vjQ=(XzY=& dir, UInt32[] v);
    private bool vzQ=(XzY=& dir, Int64[] v);
    private bool vzQ=(XzY=& dir, UInt64[] v);
    private bool wDQ=(XzY=& dir, Single[] v);
    private bool wTQ=(XzY=& dir, Single[] v);
    private bool wjQ=(XzY=& dir, Double[] v);
    private bool wzQ=(TiffType type, TiffTag tag, XzY=& dir, int n, Double[] v);
    private bool xDQ=(XzY=& dir);
    private bool xTQ=(XzY=& dir);
    private bool xjQ=(XzY=& dir, Byte[] buffer, int count);
    private bool xjQ=(XzY=& dir, Int16[] buffer, int count);
    private bool xjQ=(XzY=& dir, Int64[] buffer, int count);
    private bool xjQ=(XzY=& dir, Int32[] cp, int cc);
    private bool xjQ=(XzY=& dir, Single[] cp, int cc);
    private bool xjQ=(XzY=& dir, Double[] buffer, int count);
    private bool xzQ=();
    private void kh0=(bool disposing);
    private bool yDQ=(Int64& pdiroff);
    internal static void yTQ=(UInt32& lp);
    internal static UInt64[] yjQ=(UInt64[] buffer, int elementCount, int newElementCount);
    internal static TiffFieldInfo[] yjQ=(TiffFieldInfo[] buffer, int elementCount, int newElementCount);
    internal static jjY=[] yjQ=(jjY=[] buffer, int elementCount, int newElementCount);
    internal bool yzQ=(Compression scheme);
    private void zDQ=(Byte[] buffer, int offset, int count);
    private void zTQ=(int magic);
    private static int zjQ=(string mode, string module, FileMode& m, FileAccess& a);
    private static void zzQ=(Stream fd, TiffFieldInfo fip, int value_count, object raw_data);
    private bool 0DQ=(Stream fd, TiffTag tag, int value_count, object raw_data);
    private static void 0TQ=(Stream fd, string cp);
    private int 0jQ=(Byte[] buf, int offset, int size);
    private long 0zQ=(long off, SeekOrigin whence);
    private long 1DQ=();
    private bool 1TQ=(Byte[] buf, int size);
    private bool 1jQ=(Int16& value);
    private bool 1zQ=(UInt64& dircount, bool isBigTiff);
    private bool 2DQ=(UInt32& value);
    private bool 2TQ=(UInt64& value);
    private bool 2jQ=(Int64& value);
    private bool 2zQ=(Int32& value);
    private bool 3DQ=(XzY=[] dir, ulong dircount, bool isBigTiff);
    private static void 3TQ=(XzY=[] dir, ulong dircount, Byte[] bytes, int offset, bool isBigTiff);
    private bool 3jQ=(hTY=& header);
    private bool 3zQ=(long off);
    private bool 4DQ=(int row, short sample);
    private int 4TQ=(int strip, Byte[] buf, int offset, int size, string module);
    private int 4jQ=(int tile, Byte[] buf, int offset, int size, string module);
    private bool 4zQ=(int strip);
    private bool 5DQ=(int tile);
    private bool 5TQ=(bool tiles);
    private static void 5jQ=(Byte[] buffer, int offset, int count);
    private static void 5zQ=(Byte[] buffer, int offset, int count);
    private static void 6DQ=(Byte[] buffer, int offset, int count);
    private static void 6TQ=(Byte[] buffer, int offset, int count);
    internal bool 6jQ=(int strip);
    internal bool 6zQ=(int tile);
    private int 7DQ=(int summand1, int summand2, string where);
    private int 7TQ=(int nmemb, int elem_size, string where);
    internal int 7jQ=();
    internal int 7zQ=();
    private bool 8DQ=(string module);
    private bool 8TQ=(string module);
    private void 8jQ=();
    private bool 8zQ=(Byte[] buffer, int offset, int count);
    private bool 9DQ=(hTY= header);
    private bool 9TQ=(XzY=[] entries, long count, bool isBigTiff);
    private bool 9jQ=(short value);
    private bool 9zQ=(long value, bool isBigTiff);
    private bool /DQ=(long value, bool isBigTiff);
    private bool /TQ=(int value);
    private bool /jQ=(long value);
    private bool /zQ=(int f);
    private bool ADU=(int delta);
    private bool ATU=(int strip, Byte[] buffer, int offset, long count);
    internal bool AjU=();
    public static string GetVersion();
    public static string get_AssemblyVersion();
    public static int GetR(int abgr);
    public static int GetG(int abgr);
    public static int GetB(int abgr);
    public static int GetA(int abgr);
    public TiffCodec FindCodec(Compression scheme);
    public void RegisterCodec(TiffCodec codec);
    public void UnRegisterCodec(TiffCodec codec);
    public bool IsCodecConfigured(Compression scheme);
    public TiffCodec[] GetConfiguredCodecs();
    public static Byte[] Realloc(Byte[] array, int size);
    public static Int32[] Realloc(Int32[] array, int size);
    public static int Compare(Int16[] first, Int16[] second, int elementCount);
    public static Tiff Open(string fileName, string mode);
    public static Tiff ClientOpen(string name, string mode, object clientData, TiffStream stream);
    public void Close();
    public sealed virtual void Dispose();
    public int GetTagListCount();
    public int GetTagListEntry(int index);
    public void MergeFieldInfo(TiffFieldInfo[] info, int count);
    public TiffFieldInfo FindFieldInfo(TiffTag tag, TiffType type);
    public TiffFieldInfo FindFieldInfoByName(string name, TiffType type);
    public TiffFieldInfo FieldWithTag(TiffTag tag);
    public TiffFieldInfo FieldWithName(string name);
    public TiffTagMethods GetTagMethods();
    public TiffTagMethods SetTagMethods(TiffTagMethods methods);
    public object GetClientInfo(string name);
    public void SetClientInfo(object data, string name);
    public bool Flush();
    public bool FlushData();
    public FieldValue[] GetField(TiffTag tag);
    public FieldValue[] GetFieldDefaulted(TiffTag tag);
    public bool ReadDirectory();
    public bool ReadCustomDirectory(long offset, TiffFieldInfo[] info, int count);
    public bool ReadEXIFDirectory(long offset);
    public int ScanlineSize();
    public int RasterScanlineSize();
    public int DefaultStripSize(int estimate);
    public int StripSize();
    public int VStripSize(int rowCount);
    public long RawStripSize(int strip);
    public int ComputeStrip(int row, short plane);
    public int NumberOfStrips();
    public void DefaultTileSize(Int32& width, Int32& height);
    public int TileSize();
    public int VTileSize(int rowCount);
    public long RawTileSize(int tile);
    public int TileRowSize();
    public int ComputeTile(int x, int y, int z, short plane);
    public bool CheckTile(int x, int y, int z, short plane);
    public int NumberOfTiles();
    public object Clientdata();
    public object SetClientdata(object data);
    public int GetMode();
    public int SetMode(int mode);
    public bool IsTiled();
    public bool IsByteSwapped();
    public bool IsUpSampled();
    public bool IsMSB2LSB();
    public bool IsBigEndian();
    public TiffStream GetStream();
    public int CurrentRow();
    public short CurrentDirectory();
    public short NumberOfDirectories();
    public long CurrentDirOffset();
    public int CurrentStrip();
    public int CurrentTile();
    public void ReadBufferSetup(Byte[] buffer, int size);
    public void WriteBufferSetup(Byte[] buffer, int size);
    public bool SetupStrips();
    public bool WriteCheck(bool tiles, string method);
    public void FreeDirectory();
    public void CreateDirectory();
    public bool LastDirectory();
    public bool SetDirectory(short number);
    public bool SetSubDirectory(long offset);
    public bool UnlinkDirectory(short number);
    public bool SetField(TiffTag tag, Object[] value);
    public bool WriteDirectory();
    public bool CheckpointDirectory();
    public bool RewriteDirectory();
    public void PrintDirectory(Stream stream);
    public void PrintDirectory(Stream stream, TiffPrintFlags flags);
    public bool ReadScanline(Byte[] buffer, int row);
    public bool ReadScanline(Byte[] buffer, int row, short plane);
    public bool ReadScanline(Byte[] buffer, int offset, int row, short plane);
    public bool WriteScanline(Byte[] buffer, int row);
    public bool WriteScanline(Byte[] buffer, int row, short plane);
    public bool WriteScanline(Byte[] buffer, int offset, int row, short plane);
    public bool ReadRGBAImage(int width, int height, Int32[] raster);
    public bool ReadRGBAImage(int width, int height, Int32[] raster, bool stopOnError);
    public bool ReadRGBAImageOriented(int width, int height, Int32[] raster, Orientation orientation);
    public bool ReadRGBAImageOriented(int width, int height, Int32[] raster, Orientation orientation, bool stopOnError);
    public bool ReadRGBAStrip(int row, Int32[] raster);
    public bool ReadRGBATile(int col, int row, Int32[] raster);
    public bool RGBAImageOK(String& errorMsg);
    public string FileName();
    public string SetFileName(string name);
    public static void Error(Tiff tif, string method, string format, Object[] args);
    public static void Error(string method, string format, Object[] args);
    public static void ErrorExt(Tiff tif, object clientData, string method, string format, Object[] args);
    public static void ErrorExt(object clientData, string method, string format, Object[] args);
    public static void Warning(Tiff tif, string method, string format, Object[] args);
    public static void Warning(string method, string format, Object[] args);
    public static void WarningExt(Tiff tif, object clientData, string method, string format, Object[] args);
    public static void WarningExt(object clientData, string method, string format, Object[] args);
    public static TiffErrorHandler SetErrorHandler(TiffErrorHandler errorHandler);
    public static TiffExtendProc SetTagExtender(TiffExtendProc extender);
    public int ReadTile(Byte[] buffer, int offset, int x, int y, int z, short plane);
    public int ReadEncodedTile(int tile, Byte[] buffer, int offset, int count);
    public int ReadRawTile(int tile, Byte[] buffer, int offset, int count);
    public int WriteTile(Byte[] buffer, int x, int y, int z, short plane);
    public int WriteTile(Byte[] buffer, int offset, int x, int y, int z, short plane);
    public int ReadEncodedStrip(int strip, Byte[] buffer, int offset, int count);
    public int ReadRawStrip(int strip, Byte[] buffer, int offset, int count);
    public int WriteEncodedStrip(int strip, Byte[] buffer, int count);
    public int WriteEncodedStrip(int strip, Byte[] buffer, int offset, int count);
    public int WriteRawStrip(int strip, Byte[] buffer, int count);
    public int WriteRawStrip(int strip, Byte[] buffer, int offset, int count);
    public int WriteEncodedTile(int tile, Byte[] buffer, int count);
    public int WriteEncodedTile(int tile, Byte[] buffer, int offset, int count);
    public int WriteRawTile(int tile, Byte[] buffer, int count);
    public int WriteRawTile(int tile, Byte[] buffer, int offset, int count);
    public void SetWriteOffset(long offset);
    public static int DataWidth(TiffType type);
    public static void SwabShort(Int16& value);
    public static void SwabLong(Int32& value);
    private static void AzU=(UInt64& value);
    private static void BDU=(UInt64& value, bool isBigTiff, bool isShort);
    public static void SwabDouble(Double& value);
    public static void SwabArrayOfShort(Int16[] array, int count);
    public static void SwabArrayOfShort(Int16[] array, int offset, int count);
    public static void SwabArrayOfTriples(Byte[] array, int count);
    public static void SwabArrayOfTriples(Byte[] array, int offset, int count);
    public static void SwabArrayOfLong(Int32[] array, int count);
    public static void SwabArrayOfLong8(Int64[] array, int count);
    public static void SwabArrayOfLong(Int32[] array, int offset, int count);
    public static void SwabArrayOfLong8(Int64[] array, int offset, int count);
    public static void SwabArrayOfDouble(Double[] array, int count);
    public static void SwabArrayOfDouble(Double[] array, int offset, int count);
    public static void ReverseBits(Byte[] buffer, int count);
    public static void ReverseBits(Byte[] buffer, int offset, int count);
    public static Byte[] GetBitRevTable(bool reversed);
    public static Int32[] ByteArrayToInts(Byte[] buffer, int offset, int count);
    public static Int64[] ByteArrayToLong8(Byte[] buffer, int offset, int count);
    public static void Long8ToByteArray(Int64[] source, int srcOffset, int srcCount, Byte[] bytes, int offset);
    public static void IntsToByteArray(Int32[] source, int srcOffset, int srcCount, Byte[] bytes, int offset);
    public static Int16[] ByteArrayToShorts(Byte[] buffer, int offset, int count);
    public static void ShortsToByteArray(Int16[] source, int srcOffset, int srcCount, Byte[] bytes, int offset);
    private static Int64[] BTU=(Int32[] inputArray);
    private static UInt32[] BjU=(UInt64[] inputArray);
    private static Int32[] BjU=(Int64[] inputArray);
}
public class ThinkGeo.Core.LibTiff.TiffCodec : object {
    protected Tiff m_tif;
    protected internal Compression m_scheme;
    protected internal string m_name;
    public bool CanEncode { get; }
    public bool CanDecode { get; }
    public TiffCodec(Tiff tif, Compression scheme, string name);
    public virtual bool get_CanEncode();
    public virtual bool get_CanDecode();
    public virtual bool Init();
    public virtual bool SetupDecode();
    public virtual bool PreDecode(short plane);
    public virtual bool DecodeRow(Byte[] buffer, int offset, int count, short plane);
    public virtual bool DecodeStrip(Byte[] buffer, int offset, int count, short plane);
    public virtual bool DecodeTile(Byte[] buffer, int offset, int count, short plane);
    public virtual bool SetupEncode();
    public virtual bool PreEncode(short plane);
    public virtual bool PostEncode();
    public virtual bool EncodeRow(Byte[] buffer, int offset, int count, short plane);
    public virtual bool EncodeStrip(Byte[] buffer, int offset, int count, short plane);
    public virtual bool EncodeTile(Byte[] buffer, int offset, int count, short plane);
    public virtual void Close();
    public virtual bool Seek(int row);
    public virtual void Cleanup();
    public virtual int DefStripSize(int size);
    public virtual void DefTileSize(Int32& width, Int32& height);
    private bool VDs=(string method);
    private bool VTs=(string method);
}
public class ThinkGeo.Core.LibTiff.TiffErrorHandler : object {
    public virtual void ErrorHandler(Tiff tif, string method, string format, Object[] args);
    public virtual void ErrorHandlerExt(Tiff tif, object clientData, string method, string format, Object[] args);
    public virtual void WarningHandler(Tiff tif, string method, string format, Object[] args);
    public virtual void WarningHandlerExt(Tiff tif, object clientData, string method, string format, Object[] args);
}
public class ThinkGeo.Core.LibTiff.TiffFieldInfo : object {
    private TiffTag Vjs=;
    private short Vzs=;
    private short WDs=;
    private TiffType WTs=;
    private short kjM=;
    private bool Wjs=;
    private bool Wzs=;
    private string NTQ=;
    public static short Variable;
    public static short Spp;
    public static short Variable2;
    public TiffTag Tag { get; }
    public short ReadCount { get; }
    public short WriteCount { get; }
    public TiffType Type { get; }
    public short Bit { get; }
    public bool OkToChange { get; }
    public bool PassCount { get; }
    public string Name { get; internal set; }
    public TiffFieldInfo(TiffTag tag, short readCount, short writeCount, TiffType type, short bit, bool okToChange, bool passCount, string name);
    public virtual string ToString();
    public TiffTag get_Tag();
    public short get_ReadCount();
    public short get_WriteCount();
    public TiffType get_Type();
    public short get_Bit();
    public bool get_OkToChange();
    public bool get_PassCount();
    public string get_Name();
    internal void set_Name(string value);
}
[FlagsAttribute]
public enum ThinkGeo.Core.LibTiff.TiffPrintFlags : Enum {
    public int value__;
    public static TiffPrintFlags NONE;
    public static TiffPrintFlags STRIPS;
    public static TiffPrintFlags CURVES;
    public static TiffPrintFlags COLORMAP;
    public static TiffPrintFlags JPEGQTABLES;
    public static TiffPrintFlags JPEGACTABLES;
    public static TiffPrintFlags JPEGDCTABLES;
}
public class ThinkGeo.Core.LibTiff.TiffStream : object {
    public virtual int Read(object clientData, Byte[] buffer, int offset, int count);
    public virtual void Write(object clientData, Byte[] buffer, int offset, int count);
    public virtual long Seek(object clientData, long offset, SeekOrigin origin);
    public virtual void Close(object clientData);
    public virtual long Size(object clientData);
}
public enum ThinkGeo.Core.LibTiff.TiffTag : Enum {
    public int value__;
    public static TiffTag IGNORE;
    public static TiffTag SUBFILETYPE;
    public static TiffTag OSUBFILETYPE;
    public static TiffTag IMAGEWIDTH;
    public static TiffTag IMAGELENGTH;
    public static TiffTag BITSPERSAMPLE;
    public static TiffTag COMPRESSION;
    public static TiffTag PHOTOMETRIC;
    public static TiffTag THRESHHOLDING;
    public static TiffTag CELLWIDTH;
    public static TiffTag CELLLENGTH;
    public static TiffTag FILLORDER;
    public static TiffTag DOCUMENTNAME;
    public static TiffTag IMAGEDESCRIPTION;
    public static TiffTag MAKE;
    public static TiffTag MODEL;
    public static TiffTag STRIPOFFSETS;
    public static TiffTag ORIENTATION;
    public static TiffTag SAMPLESPERPIXEL;
    public static TiffTag ROWSPERSTRIP;
    public static TiffTag STRIPBYTECOUNTS;
    public static TiffTag MINSAMPLEVALUE;
    public static TiffTag MAXSAMPLEVALUE;
    public static TiffTag XRESOLUTION;
    public static TiffTag YRESOLUTION;
    public static TiffTag PLANARCONFIG;
    public static TiffTag PAGENAME;
    public static TiffTag XPOSITION;
    public static TiffTag YPOSITION;
    public static TiffTag FREEOFFSETS;
    public static TiffTag FREEBYTECOUNTS;
    public static TiffTag GRAYRESPONSEUNIT;
    public static TiffTag GRAYRESPONSECURVE;
    public static TiffTag GROUP3OPTIONS;
    public static TiffTag T4OPTIONS;
    public static TiffTag GROUP4OPTIONS;
    public static TiffTag T6OPTIONS;
    public static TiffTag RESOLUTIONUNIT;
    public static TiffTag PAGENUMBER;
    public static TiffTag COLORRESPONSEUNIT;
    public static TiffTag TRANSFERFUNCTION;
    public static TiffTag SOFTWARE;
    public static TiffTag DATETIME;
    public static TiffTag ARTIST;
    public static TiffTag HOSTCOMPUTER;
    public static TiffTag PREDICTOR;
    public static TiffTag WHITEPOINT;
    public static TiffTag PRIMARYCHROMATICITIES;
    public static TiffTag COLORMAP;
    public static TiffTag HALFTONEHINTS;
    public static TiffTag TILEWIDTH;
    public static TiffTag TILELENGTH;
    public static TiffTag TILEOFFSETS;
    public static TiffTag TILEBYTECOUNTS;
    public static TiffTag BADFAXLINES;
    public static TiffTag CLEANFAXDATA;
    public static TiffTag CONSECUTIVEBADFAXLINES;
    public static TiffTag SUBIFD;
    public static TiffTag INKSET;
    public static TiffTag INKNAMES;
    public static TiffTag NUMBEROFINKS;
    public static TiffTag DOTRANGE;
    public static TiffTag TARGETPRINTER;
    public static TiffTag EXTRASAMPLES;
    public static TiffTag SAMPLEFORMAT;
    public static TiffTag SMINSAMPLEVALUE;
    public static TiffTag SMAXSAMPLEVALUE;
    public static TiffTag CLIPPATH;
    public static TiffTag XCLIPPATHUNITS;
    public static TiffTag YCLIPPATHUNITS;
    public static TiffTag INDEXED;
    public static TiffTag JPEGTABLES;
    public static TiffTag OPIPROXY;
    public static TiffTag JPEGPROC;
    public static TiffTag JPEGIFOFFSET;
    public static TiffTag JPEGIFBYTECOUNT;
    public static TiffTag JPEGRESTARTINTERVAL;
    public static TiffTag JPEGLOSSLESSPREDICTORS;
    public static TiffTag JPEGPOINTTRANSFORM;
    public static TiffTag JPEGQTABLES;
    public static TiffTag JPEGDCTABLES;
    public static TiffTag JPEGACTABLES;
    public static TiffTag YCBCRCOEFFICIENTS;
    public static TiffTag YCBCRSUBSAMPLING;
    public static TiffTag YCBCRPOSITIONING;
    public static TiffTag REFERENCEBLACKWHITE;
    public static TiffTag XMLPACKET;
    public static TiffTag OPIIMAGEID;
    public static TiffTag REFPTS;
    public static TiffTag REGIONTACKPOINT;
    public static TiffTag REGIONWARPCORNERS;
    public static TiffTag REGIONAFFINE;
    public static TiffTag MATTEING;
    public static TiffTag DATATYPE;
    public static TiffTag IMAGEDEPTH;
    public static TiffTag TILEDEPTH;
    public static TiffTag PIXAR_IMAGEFULLWIDTH;
    public static TiffTag PIXAR_IMAGEFULLLENGTH;
    public static TiffTag PIXAR_TEXTUREFORMAT;
    public static TiffTag PIXAR_WRAPMODES;
    public static TiffTag PIXAR_FOVCOT;
    public static TiffTag PIXAR_MATRIX_WORLDTOSCREEN;
    public static TiffTag PIXAR_MATRIX_WORLDTOCAMERA;
    public static TiffTag WRITERSERIALNUMBER;
    public static TiffTag COPYRIGHT;
    public static TiffTag RICHTIFFIPTC;
    public static TiffTag IT8SITE;
    public static TiffTag IT8COLORSEQUENCE;
    public static TiffTag IT8HEADER;
    public static TiffTag IT8RASTERPADDING;
    public static TiffTag IT8BITSPERRUNLENGTH;
    public static TiffTag IT8BITSPEREXTENDEDRUNLENGTH;
    public static TiffTag IT8COLORTABLE;
    public static TiffTag IT8IMAGECOLORINDICATOR;
    public static TiffTag IT8BKGCOLORINDICATOR;
    public static TiffTag IT8IMAGECOLORVALUE;
    public static TiffTag IT8BKGCOLORVALUE;
    public static TiffTag IT8PIXELINTENSITYRANGE;
    public static TiffTag IT8TRANSPARENCYINDICATOR;
    public static TiffTag IT8COLORCHARACTERIZATION;
    public static TiffTag IT8HCUSAGE;
    public static TiffTag IT8TRAPINDICATOR;
    public static TiffTag IT8CMYKEQUIVALENT;
    public static TiffTag FRAMECOUNT;
    public static TiffTag PHOTOSHOP;
    public static TiffTag EXIFIFD;
    public static TiffTag ICCPROFILE;
    public static TiffTag JBIGOPTIONS;
    public static TiffTag GPSIFD;
    public static TiffTag FAXRECVPARAMS;
    public static TiffTag FAXSUBADDRESS;
    public static TiffTag FAXRECVTIME;
    public static TiffTag FAXDCS;
    public static TiffTag STONITS;
    public static TiffTag FEDEX_EDR;
    public static TiffTag INTEROPERABILITYIFD;
    public static TiffTag DNGVERSION;
    public static TiffTag DNGBACKWARDVERSION;
    public static TiffTag UNIQUECAMERAMODEL;
    public static TiffTag LOCALIZEDCAMERAMODEL;
    public static TiffTag CFAPLANECOLOR;
    public static TiffTag CFALAYOUT;
    public static TiffTag LINEARIZATIONTABLE;
    public static TiffTag BLACKLEVELREPEATDIM;
    public static TiffTag BLACKLEVEL;
    public static TiffTag BLACKLEVELDELTAH;
    public static TiffTag BLACKLEVELDELTAV;
    public static TiffTag WHITELEVEL;
    public static TiffTag DEFAULTSCALE;
    public static TiffTag DEFAULTCROPORIGIN;
    public static TiffTag DEFAULTCROPSIZE;
    public static TiffTag COLORMATRIX1;
    public static TiffTag COLORMATRIX2;
    public static TiffTag CAMERACALIBRATION1;
    public static TiffTag CAMERACALIBRATION2;
    public static TiffTag REDUCTIONMATRIX1;
    public static TiffTag REDUCTIONMATRIX2;
    public static TiffTag ANALOGBALANCE;
    public static TiffTag ASSHOTNEUTRAL;
    public static TiffTag ASSHOTWHITEXY;
    public static TiffTag BASELINEEXPOSURE;
    public static TiffTag BASELINENOISE;
    public static TiffTag BASELINESHARPNESS;
    public static TiffTag BAYERGREENSPLIT;
    public static TiffTag LINEARRESPONSELIMIT;
    public static TiffTag CAMERASERIALNUMBER;
    public static TiffTag LENSINFO;
    public static TiffTag CHROMABLURRADIUS;
    public static TiffTag ANTIALIASSTRENGTH;
    public static TiffTag SHADOWSCALE;
    public static TiffTag DNGPRIVATEDATA;
    public static TiffTag MAKERNOTESAFETY;
    public static TiffTag CALIBRATIONILLUMINANT1;
    public static TiffTag CALIBRATIONILLUMINANT2;
    public static TiffTag BESTQUALITYSCALE;
    public static TiffTag RAWDATAUNIQUEID;
    public static TiffTag ORIGINALRAWFILENAME;
    public static TiffTag ORIGINALRAWFILEDATA;
    public static TiffTag ACTIVEAREA;
    public static TiffTag MASKEDAREAS;
    public static TiffTag ASSHOTICCPROFILE;
    public static TiffTag ASSHOTPREPROFILEMATRIX;
    public static TiffTag CURRENTICCPROFILE;
    public static TiffTag CURRENTPREPROFILEMATRIX;
    public static TiffTag DCSHUESHIFTVALUES;
    public static TiffTag FAXMODE;
    public static TiffTag JPEGQUALITY;
    public static TiffTag JPEGCOLORMODE;
    public static TiffTag JPEGTABLESMODE;
    public static TiffTag FAXFILLFUNC;
    public static TiffTag PIXARLOGDATAFMT;
    public static TiffTag DCSIMAGERTYPE;
    public static TiffTag DCSINTERPMODE;
    public static TiffTag DCSBALANCEARRAY;
    public static TiffTag DCSCORRECTMATRIX;
    public static TiffTag DCSGAMMA;
    public static TiffTag DCSTOESHOULDERPTS;
    public static TiffTag DCSCALIBRATIONFD;
    public static TiffTag ZIPQUALITY;
    public static TiffTag PIXARLOGQUALITY;
    public static TiffTag DCSCLIPRECTANGLE;
    public static TiffTag SGILOGDATAFMT;
    public static TiffTag SGILOGENCODE;
    public static TiffTag EXIF_EXPOSURETIME;
    public static TiffTag EXIF_FNUMBER;
    public static TiffTag EXIF_EXPOSUREPROGRAM;
    public static TiffTag EXIF_SPECTRALSENSITIVITY;
    public static TiffTag EXIF_ISOSPEEDRATINGS;
    public static TiffTag EXIF_OECF;
    public static TiffTag EXIF_EXIFVERSION;
    public static TiffTag EXIF_DATETIMEORIGINAL;
    public static TiffTag EXIF_DATETIMEDIGITIZED;
    public static TiffTag EXIF_COMPONENTSCONFIGURATION;
    public static TiffTag EXIF_COMPRESSEDBITSPERPIXEL;
    public static TiffTag EXIF_SHUTTERSPEEDVALUE;
    public static TiffTag EXIF_APERTUREVALUE;
    public static TiffTag EXIF_BRIGHTNESSVALUE;
    public static TiffTag EXIF_EXPOSUREBIASVALUE;
    public static TiffTag EXIF_MAXAPERTUREVALUE;
    public static TiffTag EXIF_SUBJECTDISTANCE;
    public static TiffTag EXIF_METERINGMODE;
    public static TiffTag EXIF_LIGHTSOURCE;
    public static TiffTag EXIF_FLASH;
    public static TiffTag EXIF_FOCALLENGTH;
    public static TiffTag EXIF_SUBJECTAREA;
    public static TiffTag EXIF_MAKERNOTE;
    public static TiffTag EXIF_USERCOMMENT;
    public static TiffTag EXIF_SUBSECTIME;
    public static TiffTag EXIF_SUBSECTIMEORIGINAL;
    public static TiffTag EXIF_SUBSECTIMEDIGITIZED;
    public static TiffTag EXIF_FLASHPIXVERSION;
    public static TiffTag EXIF_COLORSPACE;
    public static TiffTag EXIF_PIXELXDIMENSION;
    public static TiffTag EXIF_PIXELYDIMENSION;
    public static TiffTag EXIF_RELATEDSOUNDFILE;
    public static TiffTag EXIF_FLASHENERGY;
    public static TiffTag EXIF_SPATIALFREQUENCYRESPONSE;
    public static TiffTag EXIF_FOCALPLANEXRESOLUTION;
    public static TiffTag EXIF_FOCALPLANEYRESOLUTION;
    public static TiffTag EXIF_FOCALPLANERESOLUTIONUNIT;
    public static TiffTag EXIF_SUBJECTLOCATION;
    public static TiffTag EXIF_EXPOSUREINDEX;
    public static TiffTag EXIF_SENSINGMETHOD;
    public static TiffTag EXIF_FILESOURCE;
    public static TiffTag EXIF_SCENETYPE;
    public static TiffTag EXIF_CFAPATTERN;
    public static TiffTag EXIF_CUSTOMRENDERED;
    public static TiffTag EXIF_EXPOSUREMODE;
    public static TiffTag EXIF_WHITEBALANCE;
    public static TiffTag EXIF_DIGITALZOOMRATIO;
    public static TiffTag EXIF_FOCALLENGTHIN35MMFILM;
    public static TiffTag EXIF_SCENECAPTURETYPE;
    public static TiffTag EXIF_GAINCONTROL;
    public static TiffTag EXIF_CONTRAST;
    public static TiffTag EXIF_SATURATION;
    public static TiffTag EXIF_SHARPNESS;
    public static TiffTag EXIF_DEVICESETTINGDESCRIPTION;
    public static TiffTag EXIF_SUBJECTDISTANCERANGE;
    public static TiffTag EXIF_IMAGEUNIQUEID;
    public static TiffTag GEOTIFF_MODELPIXELSCALETAG;
    public static TiffTag GEOTIFF_MODELTIEPOINTTAG;
    public static TiffTag GEOTIFF_MODELTRANSFORMATIONTAG;
    public static TiffTag GEOTIFF_GEOASCIIPARAMS;
    public static TiffTag GEOKEYDIRECTORY;
}
public class ThinkGeo.Core.LibTiff.TiffTagMethods : object {
    private static short yDs=;
    private static short yTs=;
    private static short yjs=;
    private static short yzs=;
    public virtual bool SetField(Tiff tif, TiffTag tag, FieldValue[] value);
    public virtual FieldValue[] GetField(Tiff tif, TiffTag tag);
    public virtual void PrintDir(Tiff tif, Stream stream, TiffPrintFlags flags);
    private static bool zDs=(LzY= td, Int32& v, FieldValue[] ap);
    private static int zTs=(Tiff tif, int slen, string s);
    private static void zjs=(String& cpp, string cp, int n);
}
public enum ThinkGeo.Core.LibTiff.TiffType : Enum {
    public short value__;
    public static TiffType NOTYPE;
    public static TiffType ANY;
    public static TiffType BYTE;
    public static TiffType ASCII;
    public static TiffType SHORT;
    public static TiffType LONG;
    public static TiffType RATIONAL;
    public static TiffType SBYTE;
    public static TiffType UNDEFINED;
    public static TiffType SSHORT;
    public static TiffType SLONG;
    public static TiffType SRATIONAL;
    public static TiffType FLOAT;
    public static TiffType DOUBLE;
    public static TiffType IFD;
    public static TiffType LONG8;
    public static TiffType SLONG8;
    public static TiffType IFD8;
}
public class ThinkGeo.Core.LinealKrigingGridInterpolationModel : KrigingGridInterpolationModel {
    public LinealKrigingGridInterpolationModel(IDictionary`2<PointShape, double> points);
    public LinealKrigingGridInterpolationModel(IDictionary`2<PointShape, double> points, int numberOfRefreancedPoints);
    protected virtual double GetSemivarianceCore(double distance, EmpiricalFunctionCoefficients coefficients);
    protected virtual double GetSillSlopeCore(double distance, double range);
}
public abstract class ThinkGeo.Core.LineBaseShape : BaseShape {
    public double GetLength(GeographyUnit shapeUnit, DistanceUnit returningUnit);
    protected virtual double GetLengthCore(GeographyUnit shapeUnit, DistanceUnit returningUnit);
    public static LineBaseShape ScaleUp(LineBaseShape sourceShape, double percentage);
    public static Feature ScaleUp(Feature sourceLine, double percentage);
    public void ScaleUp(double percentage);
    protected virtual void ScaleUpCore(double percentage);
    public static LineBaseShape ScaleDown(LineBaseShape sourceLineBaseShape, double percentage);
    public static Feature ScaleDown(Feature sourceLine, double percentage);
    public void ScaleDown(double percentage);
    protected virtual void ScaleDownCore(double percentage);
    public double GetLength(int shapeSrid, DistanceUnit returningUnit);
    public double GetLength(string shapeProj4ProjectionParameters, DistanceUnit returningUnit);
    public double GetLength(Projection shapeProjection, DistanceUnit returningUnit);
    public double GetLength(int shapeSrid, DistanceUnit returningUnit, DistanceCalculationMode distanceCalculationMode);
    public double GetLength(string shapeProj4ProjectionParameters, DistanceUnit returningUnit, DistanceCalculationMode distanceCalculationMode);
    public double GetLength(Projection shapeProjection, DistanceUnit returningUnit, DistanceCalculationMode distanceCalculationMode);
    protected virtual double GetLengthCore(Projection shapeProjection, DistanceUnit returningUnit, DistanceCalculationMode distanceCalculationMode);
    public RingShape ConvexHull();
    protected virtual RingShape ConvexHullCore();
    private void JBU=(double factor);
    public static MultilineShape Simplify(LineBaseShape targetShape, GeographyUnit targetShapeUnit, double tolerance, DistanceUnit toleranceUnit, SimplificationType simplificationType);
    public static MultilineShape Simplify(LineBaseShape targetShape, double tolerance, SimplificationType simplificationType);
    public MultilineShape Simplify(GeographyUnit shapeUnit, double tolerance, DistanceUnit toleranceUnit, SimplificationType simplificationType);
    public MultilineShape Simplify(double tolerance, SimplificationType simplificationType);
    protected virtual MultilineShape SimplifyCore(double tolerance, SimplificationType simplificationType);
    public MultilineShape Union(LineBaseShape targetShape);
    public static MultilineShape Union(IEnumerable`1<LineBaseShape> lineBaseShapes);
    public MultilineShape Union(Feature targetFeature);
    public static MultilineShape Union(IEnumerable`1<Feature> targetFeatures);
    protected virtual MultilineShape UnionCore(IEnumerable`1<LineBaseShape> lineBaseShapes);
    private BaseShape lBo=(IEnumerable`1<LineBaseShape> lineBaseShapes, int count);
    public MultilineShape GetIntersection(Feature targetFeature);
    public MultilineShape GetIntersection(AreaBaseShape targetShape);
    protected virtual MultilineShape GetIntersectionCore(AreaBaseShape targetShape);
    internal static bool pBo=(Vertex vertex1, Vertex vertex2, PointShape point);
    public static Collection`1<LineShape> Snap(IEnumerable`1<LineBaseShape> shapes, GeographyUnit shapeUnit, double snappingTolerance, DistanceUnit toleranceUnit);
    private static Collection`1<LineShape> pRo=(IEnumerable`1<LineBaseShape> lineBaseShapes);
    private static bool pho=(IEnumerable`1<LineShape> lineShapes, double tolerance);
    private static void pxo=(Collection`1<LineShape> lineshapes);
    private static Collection`1<LineShape> qBo=(IEnumerable`1<LineShape> intersectingLines);
    private static bool qRo=(Collection`1<LineShape> lineShapes, double tolerance);
    private static void qho=(Collection`1<KeyValuePair`2<LineShape, int>> linesCache, Vertex newVertex);
    private static bool qxo=(Vertex currentVertex, LineShape currentLineShape, int currentVertexIndex, LineShape closestLineShape, PointShape closestPoint);
    private static bool rBo=(LineShape lineShape, LineShape intersectingLine);
}
public enum ThinkGeo.Core.LineDashStyle : Enum {
    public int value__;
    public static LineDashStyle Solid;
    public static LineDashStyle Custom;
    public static LineDashStyle DashDot;
    public static LineDashStyle DashDotDot;
    public static LineDashStyle Dot;
    public static LineDashStyle Dash;
}
[TypeConverterAttribute("ThinkGeo.Core.BaseShapeTypeConverter")]
public class ThinkGeo.Core.LineShape : LineBaseShape {
    [ObfuscationAttribute]
private Collection`1<Vertex> vertices;
    public Collection`1<Vertex> Vertices { get; }
    public LineShape(IEnumerable`1<Vertex> points);
    public LineShape(string wellKnownText);
    public LineShape(Byte[] wellKnownBinary);
    public Collection`1<Vertex> get_Vertices();
    public void ReversePoints();
    protected virtual void ReversePointsCore();
    protected virtual BaseShape CloneDeepCore();
    public bool IsClosed();
    protected virtual bool IsClosedCore();
    protected virtual double GetLengthCore(GeographyUnit shapeUnit, DistanceUnit returningUnit);
    public PointShape GetPointOnALine(StartingPoint startingPoint, float percentageOfLine);
    public PointShape GetPointOnALine(StartingPoint startingPoint, double distance, GeographyUnit shapeUnit, DistanceUnit distanceUnit);
    protected virtual PointShape GetPointOnALineCore(StartingPoint startingPoint, double distance, GeographyUnit shapeUnit, DistanceUnit distanceUnit);
    public LineBaseShape GetLineOnALine(StartingPoint startingPoint, float startingPercentageOfTheLine, float percentageOfTheLine);
    public LineBaseShape GetLineOnALine(StartingPoint startingPoint, float percentageOfLine);
    public LineBaseShape GetLineOnALine(StartingPoint startingPoint, double startingDistance, double distance, GeographyUnit shapeUnit, DistanceUnit distanceUnit);
    protected virtual LineBaseShape GetLineOnALineCore(StartingPoint startingPoint, double startingDistance, double distance, GeographyUnit shapeUnit, DistanceUnit distanceUnit);
    public LineBaseShape GetLineOnALine(StartingPoint startingPoint, PointShape endPointShape);
    public LineBaseShape GetLineOnALine(PointShape startPointShape, PointShape endPointShape);
    public double GetSublinePercentage(PointShape sublineEndpoint, double tolerance);
    protected virtual double GetSublinePercentageCore(PointShape sublineEndpoint, double tolerance);
    public PointLineRelationship GetPointPosition(PointShape pointShape, double tolerance);
    protected virtual PointLineRelationship GetPointPositionCore(PointShape pointShape, double tolerance);
    private LineShape DRw=(PointShape startPointShape, PointShape endPointShape);
    private double Dhw=(PointShape pointShape);
    protected virtual double GetDistanceToCore(BaseShape targetShape, GeographyUnit shapeUnit, DistanceUnit distanceUnit);
    protected virtual void ScaleUpCore(double percentage);
    protected virtual void ScaleDownCore(double percentage);
    protected virtual BaseShape RegisterCore(PointShape fromPoint, PointShape toPoint, DistanceUnit fromUnit, GeographyUnit toUnit);
    protected virtual void TranslateByOffsetCore(double xOffsetDistance, double yOffsetDistance, GeographyUnit shapeUnit, DistanceUnit distanceUnit);
    protected virtual void TranslateByDegreeCore(double distance, double angleInDegrees, GeographyUnit shapeUnit, DistanceUnit distanceUnit);
    protected virtual void RotateCore(PointShape pivotPoint, double degreeAngle);
    protected virtual RectangleShape GetBoundingBoxCore();
    protected virtual PointShape GetClosestPointToCore(BaseShape targetShape, GeographyUnit shapeUnit);
    protected virtual string GetWellKnownTextCore(RingOrder outerRingOrder);
    protected virtual WellKnownType GetWellKnownTypeCore();
    protected virtual PointShape GetCenterPointCore();
    protected virtual void LoadFromWellKnownDataCore(string wellKnownText);
    protected virtual void LoadFromWellKnownDataCore(Byte[] wellKnownBinary);
    private static void Dxw=(LineShape fromLine, LineShape toLine);
    protected virtual ShapeValidationResult ValidateCore(ShapeValidationMode validationMode);
    protected virtual MultipointShape GetCrossingCore(BaseShape targetShape);
    public static bool RemoveVertex(Vertex selectedVertex, LineShape lineShape);
    public bool RemoveVertex(Vertex selectedVertex);
    public PolygonShape ToPolygonShape();
    private MultipointShape EBw=(BaseShape targetShape);
    private MultipointShape ERw=(BaseShape targetShape);
    private MultipointShape Ehw=(BaseShape targetShape);
    private static void Exw=(Geometry result, MultipointShape resultMultiPointShape);
    internal void JBU=(double factor);
    private void FBw=(EllipseShape ellipse, GeographyUnit shapeUnit, DistanceUnit distanceUnit, PointShape& closestPointShape, Double& minDistance);
    private void FRw=(PolygonShape polygonShape, GeographyUnit shapeUnit, DistanceUnit distanceUnit, PointShape& closestPointShape, Double& minDistance);
    private void Fhw=(MultipolygonShape multiPolygonShape, GeographyUnit shapeUnit, DistanceUnit distanceUnit, PointShape& closestPointShape, Double& minDistance);
    private void 6hs=(PointShape pointShape, GeographyUnit shapeUnit, DistanceUnit distanceUnit, PointShape& closestPointShape, Double& minDistance);
    private void Fxw=(MultipointShape multiPointShape, GeographyUnit shapeUnit, DistanceUnit distanceUnit, PointShape& closestPointShape, Double& minDistance);
    private void GBw=(LineShape lineShape, GeographyUnit shapeUnit, DistanceUnit distanceUnit, PointShape& closestPointShape, Double& minDistance);
    private void GRw=(MultilineShape multilineShape, GeographyUnit shapeUnit, DistanceUnit distanceUnit, PointShape& closestPointShape, Double& minDistance);
    private static RectangleShape Ghw=(IEnumerable`1<Vertex> vertices);
    private PointShape Gxw=(double distance);
    private PointShape HBw=(double distance, DistanceUnit distanceUnit);
}
public class ThinkGeo.Core.LineStyle : Style {
    [ObfuscationAttribute]
private GeoPen centerPen;
    [ObfuscationAttribute]
private Collection`1<LineStyle> customLineStyles;
    [ObfuscationAttribute]
private GeoPen innerPen;
    [ObfuscationAttribute]
private GeoPen outerPen;
    [ObfuscationAttribute]
private float xOffsetInPixel;
    [ObfuscationAttribute]
private float yOffsetInPixel;
    [ObfuscationAttribute]
private DrawingLevel outerPenDrawingLevel;
    [ObfuscationAttribute]
private DrawingLevel innerPenDrawingLevel;
    [ObfuscationAttribute]
private DrawingLevel centerPenDrawingLevel;
    [ObfuscationAttribute]
private PointStyle directionPointStyle;
    [ObfuscationAttribute]
private double directionPointInterval;
    [ObfuscationAttribute]
private double directionPointMinimumInterval;
    [CompilerGeneratedAttribute]
private EventHandler`1<DrawingDirectionPointEventArgs> DrawingDirectionPoint;
    public float XOffsetInPixel { get; public set; }
    public float YOffsetInPixel { get; public set; }
    public Collection`1<LineStyle> CustomLineStyles { get; }
    public GeoPen OuterPen { get; public set; }
    public GeoPen InnerPen { get; public set; }
    public GeoPen CenterPen { get; public set; }
    public DrawingLevel OuterPenDrawingLevel { get; public set; }
    public DrawingLevel InnerPenDrawingLevel { get; public set; }
    public DrawingLevel CenterPenDrawingLevel { get; public set; }
    internal bool fBU= { get; }
    public PointStyle DirectionPointStyle { get; public set; }
    public double DirectionPointInterval { get; public set; }
    public double DirectionPointMinimumInterval { get; public set; }
    public LineStyle(GeoPen outerPen);
    public LineStyle(GeoPen outerPen, GeoPen innerPen);
    public LineStyle(GeoPen outerPen, GeoPen innerPen, GeoPen centerPen);
    [CompilerGeneratedAttribute]
public void add_DrawingDirectionPoint(EventHandler`1<DrawingDirectionPointEventArgs> value);
    [CompilerGeneratedAttribute]
public void remove_DrawingDirectionPoint(EventHandler`1<DrawingDirectionPointEventArgs> value);
    public float get_XOffsetInPixel();
    public void set_XOffsetInPixel(float value);
    public float get_YOffsetInPixel();
    public void set_YOffsetInPixel(float value);
    public Collection`1<LineStyle> get_CustomLineStyles();
    public GeoPen get_OuterPen();
    public void set_OuterPen(GeoPen value);
    public GeoPen get_InnerPen();
    public void set_InnerPen(GeoPen value);
    public GeoPen get_CenterPen();
    public void set_CenterPen(GeoPen value);
    public DrawingLevel get_OuterPenDrawingLevel();
    public void set_OuterPenDrawingLevel(DrawingLevel value);
    public DrawingLevel get_InnerPenDrawingLevel();
    public void set_InnerPenDrawingLevel(DrawingLevel value);
    public DrawingLevel get_CenterPenDrawingLevel();
    public void set_CenterPenDrawingLevel(DrawingLevel value);
    internal virtual bool ehU=();
    public PointStyle get_DirectionPointStyle();
    public void set_DirectionPointStyle(PointStyle value);
    public double get_DirectionPointInterval();
    public void set_DirectionPointInterval(double value);
    public double get_DirectionPointMinimumInterval();
    public void set_DirectionPointMinimumInterval(double value);
    public static LineStyle Parse(string styleJson);
    internal static LineStyle ahU=(JObject jObject);
    public static LineStyle CreateSimpleLineStyle(GeoColor centerlineColor, float centerlineWidth, bool roundCap);
    public static LineStyle CreateSimpleLineStyle(GeoColor centerlineColor, float centerlineWidth, LineDashStyle centerlineDashStyle, bool roundCap);
    public static LineStyle CreateSimpleLineStyle(GeoColor innerLineColor, float innerLineWidth, GeoColor outerLineColor, float outerLineWidth, bool roundCap);
    public static LineStyle CreateSimpleLineStyle(GeoColor innerLineColor, float innerLineWidth, LineDashStyle innerLineDashStyle, GeoColor outerLineColor, float outerLineWidth, LineDashStyle outerLineDashStyle, bool roundCap);
    public static LineStyle CreateSimpleLineStyle(GeoColor centerlineColor, float centerlineWidth, GeoColor innerLineColor, float innerLineWidth, GeoColor outerLineColor, float outerLineWidth, bool roundCap);
    public static LineStyle CreateSimpleLineStyle(GeoColor centerlineColor, float centerlineWidth, LineDashStyle centerlineDashStyle, GeoColor innerLineColor, float innerLineWidth, LineDashStyle innerLineDashStyle, GeoColor outerLineColor, float outerLineWidth, LineDashStyle outerLineDashStyle, bool roundCap);
    private static LineStyle qDA=(GeoColor innerPenColor, float innerPenWidth, GeoColor outerPenColor, float outerPenWidth, GeoColor centerPenColor, float centerPenWidth, Collection`1<float> dashPattern);
    protected virtual void DrawCore(IEnumerable`1<Feature> features, GeoCanvas canvas, Collection`1<SimpleCandidate> labelsInThisLayer, Collection`1<SimpleCandidate> labelsInAllLayers);
    private void qTA=(GeoCanvas canvas, Collection`1<SimpleCandidate> labelsInThisLayer, Collection`1<SimpleCandidate> labelsInAllLayers, IEnumerable`1<Feature> featuresList);
    private void qjA=(Feature item, GeoCanvas canvas);
    private void qzA=(GeoCanvas canvas, LineShape lineShape, Feature item);
    protected virtual void OnDrawingDirectionPoint(DrawingDirectionPointEventArgs drawingDirectionPointEventArgs);
    private float rDA=(Vertex v1, Vertex v2);
    protected virtual void DrawSampleCore(GeoCanvas canvas, DrawingRectangleF drawingExtent);
    private static LineShape rTA=(RectangleShape rectangle);
    private static List`1<Feature> jTA=(RectangleShape currentExtent, IEnumerable`1<Feature> featureList);
    private static MultilineShape rjA=(LineShape line, RectangleShape rectangle);
    private static MultilineShape rzA=(MultilineShape multiline, RectangleShape rectangle);
    private static LineShape sDA=(Vertex startPoint, Vertex endPoint, RectangleShape rectangle);
    private static Vertex sTA=(Vertex startPoint, Vertex endPoint, RectangleShape rectangle);
    private static bool sjA=(double value, double start, double end);
    internal static GeoPen szA=(String[] valueExpressions);
    private static PointStyle tDA=(String[] valueExpressions);
}
[ObfuscationAttribute]
public class ThinkGeo.Core.LocationPoint : object {
    [CompilerGeneratedAttribute]
private double <PointX>k__BackingField;
    [CompilerGeneratedAttribute]
private double <PointY>k__BackingField;
    public double PointX { get; public set; }
    public double PointY { get; public set; }
    [CompilerGeneratedAttribute]
public double get_PointX();
    [CompilerGeneratedAttribute]
public void set_PointX(double value);
    [CompilerGeneratedAttribute]
public double get_PointY();
    [CompilerGeneratedAttribute]
public void set_PointY(double value);
}
public class ThinkGeo.Core.LogoAdornmentLayer : AdornmentLayer {
    [ObfuscationAttribute]
private GeoImage image;
    public GeoImage Image { get; public set; }
    public LogoAdornmentLayer(GeoImage image);
    public GeoImage get_Image();
    public void set_Image(GeoImage value);
    protected virtual void DrawCore(GeoCanvas canvas, Collection`1<SimpleCandidate> labelsInAllLayers);
}
public class ThinkGeo.Core.MagneticDeclination : object {
    [ObfuscationAttribute]
private double magneticNorthInDegree;
    [ObfuscationAttribute]
private double gridNorthInDegree;
    [ObfuscationAttribute]
private string changedByYear;
    [ObfuscationAttribute]
private double centralMeridian;
    [ObfuscationAttribute]
private string zone;
    public double MagneticNorthInDegree { get; public set; }
    public double GridNorthInDegree { get; public set; }
    public string ChangedByYear { get; public set; }
    public double CentralMeridian { get; public set; }
    public string Zone { get; public set; }
    public MagneticDeclination(double magneticNorthInDegree, double gridNorthInDegree, string changedByYear, double centralMeridian, string zone);
    public double get_MagneticNorthInDegree();
    public void set_MagneticNorthInDegree(double value);
    public double get_GridNorthInDegree();
    public void set_GridNorthInDegree(double value);
    public string get_ChangedByYear();
    public void set_ChangedByYear(string value);
    public double get_CentralMeridian();
    public void set_CentralMeridian(double value);
    public string get_Zone();
    public void set_Zone(string value);
}
public class ThinkGeo.Core.MagneticDeclinationAdornmentLayer : AdornmentLayer {
    private static int jiA=;
    private static int jyA=;
    private static float kCA=;
    private static double kSA=;
    private static double kiA=;
    private static double kyA=;
    private static double lCA=;
    [ObfuscationAttribute]
private TextStyle textStyle;
    [ObfuscationAttribute]
private LineStyle trueNorthLineStyle;
    [ObfuscationAttribute]
private LineStyle magneticNorthLineStyle;
    [ObfuscationAttribute]
private LineStyle gridNorthLineStyle;
    [ObfuscationAttribute]
private PointStyle trueNorthPointStyle;
    [ObfuscationAttribute]
private DistanceUnit elevationUnit;
    [ObfuscationAttribute]
private double elevation;
    [ObfuscationAttribute]
private DateTime sampleDateTime;
    [ObfuscationAttribute]
private string magneticFieldPathFilename;
    [ObfuscationAttribute]
private ProjectionConverter projectionToDecimalDegrees;
    [ObfuscationAttribute]
private PointShape canvasCenterPoint;
    [ObfuscationAttribute]
private int gridNorthTextLocationXoffset;
    [ObfuscationAttribute]
private int gridNorthDegreeLocationXoffset;
    [ObfuscationAttribute]
private int magneticNorthTextLocationYoffset;
    [ObfuscationAttribute]
private int gridNorthTextXOffsetInPixel;
    [ObfuscationAttribute]
private int degreeMinutesSecondsXOffsetInPixel;
    [ObfuscationAttribute]
private Stream magneticFieldFileStream;
    [CompilerGeneratedAttribute]
private EventHandler`1<StreamLoadingEventArgs> StreamLoading;
    public LineStyle GridNorthLineStyle { get; public set; }
    public LineStyle TrueNorthLineStyle { get; public set; }
    public LineStyle MagneticNorthLineStyle { get; public set; }
    public TextStyle TextStyle { get; public set; }
    public PointStyle TrueNorthPointStyle { get; public set; }
    public DistanceUnit ElevationUnit { get; public set; }
    public string MagneticFieldPathFilename { get; }
    public double Elevation { get; public set; }
    public DateTime SampleDateTime { get; public set; }
    public MagneticDeclinationAdornmentLayer(ScreenPointF startPoint);
    public MagneticDeclinationAdornmentLayer(AdornmentLocation adornmentLocation);
    public MagneticDeclinationAdornmentLayer(string magneticFieldPathFilename, AdornmentLocation adornmentLocation);
    [CompilerGeneratedAttribute]
public void add_StreamLoading(EventHandler`1<StreamLoadingEventArgs> value);
    [CompilerGeneratedAttribute]
public void remove_StreamLoading(EventHandler`1<StreamLoadingEventArgs> value);
    public LineStyle get_GridNorthLineStyle();
    public void set_GridNorthLineStyle(LineStyle value);
    public LineStyle get_TrueNorthLineStyle();
    public void set_TrueNorthLineStyle(LineStyle value);
    public LineStyle get_MagneticNorthLineStyle();
    public void set_MagneticNorthLineStyle(LineStyle value);
    public TextStyle get_TextStyle();
    public void set_TextStyle(TextStyle value);
    public PointStyle get_TrueNorthPointStyle();
    public void set_TrueNorthPointStyle(PointStyle value);
    public DistanceUnit get_ElevationUnit();
    public void set_ElevationUnit(DistanceUnit value);
    public string get_MagneticFieldPathFilename();
    public double get_Elevation();
    public void set_Elevation(double value);
    public DateTime get_SampleDateTime();
    public void set_SampleDateTime(DateTime value);
    protected virtual void OnStreamLoading(StreamLoadingEventArgs e);
    public virtual ScreenPointF GetDrawingLocation(GeoCanvas canvas, float adornmentWidth, float adornmentHeight);
    public static MagneticDeclination GetMagneticDeclination(Feature pointFeature, double elevation, DistanceUnit elevationUnit, DateTime sampleDateTime);
    public static MagneticDeclination GetMagneticDeclination(Feature pointFeature, double elevation, DistanceUnit elevationUnit, DateTime sampleDateTime, string magneticFieldPathFilename);
    public static MagneticDeclination GetMagneticDeclination(Feature pointFeature, double elevation, DistanceUnit elevationUnit, DateTime sampleDateTime, Stream magneticFieldStream);
    public static MagneticDeclination GetMagneticDeclination(PointShape point, double elevation, DistanceUnit elevationUnit, DateTime sampleDateTime);
    public static MagneticDeclination GetMagneticDeclination(PointShape point, double elevation, DistanceUnit elevationUnit, DateTime sampleDateTime, string magneticFieldPathFilename);
    public static MagneticDeclination GetMagneticDeclination(PointShape point, double elevation, DistanceUnit elevationUnit, DateTime sampleDateTime, Stream magneticFieldStream);
    public static MagneticDeclination GetMagneticDeclination(double x, double y, double elevation, DistanceUnit elevationUnit, DateTime sampleDateTime);
    public static MagneticDeclination GetMagneticDeclination(double x, double y, double elevation, DistanceUnit elevationUnit, DateTime sampleDateTime, string magneticFieldPathFilename);
    public static MagneticDeclination GetMagneticDeclination(double x, double y, double elevation, DistanceUnit elevationUnit, DateTime sampleDateTime, Stream magneticFieldStream);
    protected virtual void OpenCore();
    protected virtual void CloseCore();
    protected virtual void DrawCore(GeoCanvas canvas, Collection`1<SimpleCandidate> labelsInAllLayers);
    private void lSA=(ScreenPointF startPoint, double length, GeoCanvas canvas);
    private void liA=(ScreenPointF gridNorthLineStartPoint, double length, double offsetInDegree, GeoCanvas canvas);
    private void lyA=(ScreenPointF magneticNorthLineStartPoint, double length, double offsetInDegree, GeoCanvas canvas);
    private static double mCA=(string zoneString, int zoneNum);
    private static string mSA=(PointShape centerPoint, Int32& zoneNum);
    private static double YCA=(PointShape centerPoint, double centralMeridian);
    private static int miA=(object Test);
    private static int myA=(double degree);
    private static double nCA=(double offTrueNorth);
    private static ScreenPointF nSA=(double lineGradient, double lineIntercept, double centerPointX, double centerPointY, double length, bool iswest);
    private static double niA=(double degree);
}
public class ThinkGeo.Core.MagneticNorthLineStyle : LineStyle {
    protected virtual void DrawCore(IEnumerable`1<Feature> features, GeoCanvas canvas, Collection`1<SimpleCandidate> labelsInThisLayer, Collection`1<SimpleCandidate> labelsInAllLayers);
    private static double niA=(double degree);
    private static double nCA=(double offTrueNorth);
    private static ScreenPointF nSA=(double lineK, double lineB, double centerPointX, double centerPointY, double length, bool iswest);
}
public class ThinkGeo.Core.MapArguments : object {
    [ObfuscationAttribute]
private Collection`1<double> zoomLevelScales;
    [ObfuscationAttribute]
private Dictionary`2<string, object> customData;
    [CompilerGeneratedAttribute]
private GeographyUnit LR0=;
    [CompilerGeneratedAttribute]
private double Lh0=;
    [CompilerGeneratedAttribute]
private double Lx0=;
    [CompilerGeneratedAttribute]
private double MB0=;
    [CompilerGeneratedAttribute]
private double MR0=;
    [CompilerGeneratedAttribute]
private double Mh0=;
    [CompilerGeneratedAttribute]
private ZoomLevelSet Mx0=;
    [CompilerGeneratedAttribute]
private ScreenPointF NB0=;
    [CompilerGeneratedAttribute]
private PointShape NR0=;
    [CompilerGeneratedAttribute]
private double Nh0=;
    [CompilerGeneratedAttribute]
private double Nx0=;
    [CompilerGeneratedAttribute]
private double OB0=;
    [CompilerGeneratedAttribute]
private double OR0=;
    [CompilerGeneratedAttribute]
private RectangleShape Oh0=;
    [CompilerGeneratedAttribute]
private PointShape Ox0=;
    [CompilerGeneratedAttribute]
private RectangleShape PB0=;
    [CompilerGeneratedAttribute]
private float PR0=;
    [CompilerGeneratedAttribute]
private ZoomLevelSnappingMode Ph0=;
    [CompilerGeneratedAttribute]
private bool Px0=;
    public GeographyUnit MapUnit { get; public set; }
    public double ScreenWidth { get; public set; }
    public double ScreenHeight { get; public set; }
    public double MapWidth { get; public set; }
    public double MapHeight { get; public set; }
    public double RotationAngle { get; public set; }
    public ZoomLevelSet ZoomLevelSet { get; public set; }
    public Dictionary`2<string, object> CustomData { get; }
    public ScreenPointF PivotScreenPoint { get; public set; }
    public PointShape PivotWorldPoint { get; public set; }
    public Collection`1<double> ZoomLevelScales { get; }
    public double CurrentResolution { get; public set; }
    public double CurrentScale { get; public set; }
    public double MaximumScale { get; public set; }
    public double MinimumScale { get; public set; }
    public RectangleShape CurrentExtent { get; public set; }
    public PointShape CenterPoint { get; public set; }
    public RectangleShape MaxExtent { get; public set; }
    public float ScaleFactor { get; public set; }
    public ZoomLevelSnappingMode ZoomLevelSnappingMode { get; public set; }
    public bool RotationEnabled { get; public set; }
    public MapArguments(RectangleShape currentExtent, GeographyUnit mapUnit, float screenWidth, float screenHeight);
    [CompilerGeneratedAttribute]
public GeographyUnit get_MapUnit();
    [CompilerGeneratedAttribute]
public void set_MapUnit(GeographyUnit value);
    [CompilerGeneratedAttribute]
public double get_ScreenWidth();
    [CompilerGeneratedAttribute]
public void set_ScreenWidth(double value);
    [CompilerGeneratedAttribute]
public double get_ScreenHeight();
    [CompilerGeneratedAttribute]
public void set_ScreenHeight(double value);
    [CompilerGeneratedAttribute]
public double get_MapWidth();
    [CompilerGeneratedAttribute]
public void set_MapWidth(double value);
    [CompilerGeneratedAttribute]
public double get_MapHeight();
    [CompilerGeneratedAttribute]
public void set_MapHeight(double value);
    [CompilerGeneratedAttribute]
public double get_RotationAngle();
    [CompilerGeneratedAttribute]
public void set_RotationAngle(double value);
    [CompilerGeneratedAttribute]
public ZoomLevelSet get_ZoomLevelSet();
    [CompilerGeneratedAttribute]
public void set_ZoomLevelSet(ZoomLevelSet value);
    public Dictionary`2<string, object> get_CustomData();
    [CompilerGeneratedAttribute]
public ScreenPointF get_PivotScreenPoint();
    [CompilerGeneratedAttribute]
public void set_PivotScreenPoint(ScreenPointF value);
    [CompilerGeneratedAttribute]
public PointShape get_PivotWorldPoint();
    [CompilerGeneratedAttribute]
public void set_PivotWorldPoint(PointShape value);
    public Collection`1<double> get_ZoomLevelScales();
    [CompilerGeneratedAttribute]
public double get_CurrentResolution();
    [CompilerGeneratedAttribute]
public void set_CurrentResolution(double value);
    [CompilerGeneratedAttribute]
public double get_CurrentScale();
    [CompilerGeneratedAttribute]
public void set_CurrentScale(double value);
    [CompilerGeneratedAttribute]
public double get_MaximumScale();
    [CompilerGeneratedAttribute]
public void set_MaximumScale(double value);
    [CompilerGeneratedAttribute]
public double get_MinimumScale();
    [CompilerGeneratedAttribute]
public void set_MinimumScale(double value);
    [CompilerGeneratedAttribute]
public RectangleShape get_CurrentExtent();
    [CompilerGeneratedAttribute]
public void set_CurrentExtent(RectangleShape value);
    [CompilerGeneratedAttribute]
public PointShape get_CenterPoint();
    [CompilerGeneratedAttribute]
public void set_CenterPoint(PointShape value);
    [CompilerGeneratedAttribute]
public RectangleShape get_MaxExtent();
    [CompilerGeneratedAttribute]
public void set_MaxExtent(RectangleShape value);
    [CompilerGeneratedAttribute]
public float get_ScaleFactor();
    [CompilerGeneratedAttribute]
public void set_ScaleFactor(float value);
    [CompilerGeneratedAttribute]
public ZoomLevelSnappingMode get_ZoomLevelSnappingMode();
    [CompilerGeneratedAttribute]
public void set_ZoomLevelSnappingMode(ZoomLevelSnappingMode value);
    [CompilerGeneratedAttribute]
public bool get_RotationEnabled();
    [CompilerGeneratedAttribute]
public void set_RotationEnabled(bool value);
    public PointShape ToWorldCoordinate(ScreenPointF screenCoordinate);
    public int GetSnappedZoomLevelIndex(RectangleShape extent);
    public int GetSnappedZoomLevelIndex(double scale);
    public RectangleShape GetSnappedExtent(RectangleShape extent, ZoomSnapDirection zoomSnapDirection);
}
public class ThinkGeo.Core.MapBoxStaticTilesAsyncLayer : XyzTileAsyncLayer {
    private static int rx0=;
    [ObfuscationAttribute]
private MapBoxStyleId styleId;
    [ObfuscationAttribute]
private string baseUrl;
    [ObfuscationAttribute]
private string apiVersion;
    [CompilerGeneratedAttribute]
private string 6R0=;
    public string AccessToken { get; public set; }
    public MapBoxStyleId StyleId { get; public set; }
    public MapBoxStaticTilesAsyncLayer(string accessToken);
    public MapBoxStaticTilesAsyncLayer(string accessToken, MapBoxStyleId styleId);
    [CompilerGeneratedAttribute]
public string get_AccessToken();
    [CompilerGeneratedAttribute]
public void set_AccessToken(string value);
    public MapBoxStyleId get_StyleId();
    public void set_StyleId(MapBoxStyleId value);
    protected virtual Task`1<string> GetImageUriAsyncCore(int zoomLevel, long x, long y, float resolutionFactor);
    private string 6h0=();
    private void 6x0=(MapBoxStyleId id);
    private bool 7B0=(string cacheId);
    private string 7R0=(MapBoxStyleId id);
}
public enum ThinkGeo.Core.MapBoxStyleId : Enum {
    public int value__;
    public static MapBoxStyleId Streets;
    public static MapBoxStyleId Outdoors;
    public static MapBoxStyleId Light;
    public static MapBoxStyleId Dark;
    public static MapBoxStyleId Satellite;
    public static MapBoxStyleId SatelliteStreets;
}
public class ThinkGeo.Core.MapBoxZoomLevelSet : ZoomLevelSet {
    public MapBoxZoomLevelSet(int tileSize);
    public MapBoxZoomLevelSet(int tileSize, RectangleShape maxExtent);
}
public enum ThinkGeo.Core.MapDoubleTapMode : Enum {
    public int value__;
    public static MapDoubleTapMode Default;
    public static MapDoubleTapMode ZoomIn;
    public static MapDoubleTapMode Disabled;
}
public class ThinkGeo.Core.MapEngine : object {
    [ObfuscationAttribute]
private bool showLogo;
    [ObfuscationAttribute]
private RectangleShape currentExtent;
    [ObfuscationAttribute]
private GeoBrush backgroundFillBrush;
    [ObfuscationAttribute]
private GeoCanvas canvas;
    [ObfuscationAttribute]
private Collection`1<SimpleCandidate> labeledFeaturesInLayers;
    [ObfuscationAttribute]
private GeoCollection`1<Layer> staticLayers;
    [ObfuscationAttribute]
private GeoCollection`1<Layer> dynamicLayers;
    [ObfuscationAttribute]
private GeoCollection`1<AdornmentLayer> adornmentLayers;
    [CompilerGeneratedAttribute]
private EventHandler`1<LayersDrawingEventArgs> LayersDrawing;
    [CompilerGeneratedAttribute]
private EventHandler`1<LayersDrawnEventArgs> LayersDrawn;
    [CompilerGeneratedAttribute]
private EventHandler`1<LayerDrawingEventArgs> LayerDrawing;
    [CompilerGeneratedAttribute]
private EventHandler`1<LayerDrawnEventArgs> LayerDrawn;
    [CompilerGeneratedAttribute]
private EventHandler`1<DrawingAdornmentLayersEventArgs> AdornmentLayersDrawing;
    [CompilerGeneratedAttribute]
private EventHandler`1<DrawnAdornmentLayersEventArgs> AdornmentLayersDrawn;
    [CompilerGeneratedAttribute]
private EventHandler`1<DrawingAdornmentLayerEventArgs> AdornmentLayerDrawing;
    [CompilerGeneratedAttribute]
private EventHandler`1<DrawnAdornmentLayerEventArgs> AdornmentLayerDrawn;
    public GeoCanvas Canvas { get; public set; }
    public bool ShowLogo { get; public set; }
    public GeoCollection`1<AdornmentLayer> AdornmentLayers { get; }
    public RectangleShape CurrentExtent { get; public set; }
    public GeoCollection`1<Layer> StaticLayers { get; }
    public GeoCollection`1<Layer> DynamicLayers { get; }
    public GeoBrush BackgroundFillBrush { get; public set; }
    [CompilerGeneratedAttribute]
public void add_LayersDrawing(EventHandler`1<LayersDrawingEventArgs> value);
    [CompilerGeneratedAttribute]
public void remove_LayersDrawing(EventHandler`1<LayersDrawingEventArgs> value);
    [CompilerGeneratedAttribute]
public void add_LayersDrawn(EventHandler`1<LayersDrawnEventArgs> value);
    [CompilerGeneratedAttribute]
public void remove_LayersDrawn(EventHandler`1<LayersDrawnEventArgs> value);
    [CompilerGeneratedAttribute]
public void add_LayerDrawing(EventHandler`1<LayerDrawingEventArgs> value);
    [CompilerGeneratedAttribute]
public void remove_LayerDrawing(EventHandler`1<LayerDrawingEventArgs> value);
    [CompilerGeneratedAttribute]
public void add_LayerDrawn(EventHandler`1<LayerDrawnEventArgs> value);
    [CompilerGeneratedAttribute]
public void remove_LayerDrawn(EventHandler`1<LayerDrawnEventArgs> value);
    [CompilerGeneratedAttribute]
public void add_AdornmentLayersDrawing(EventHandler`1<DrawingAdornmentLayersEventArgs> value);
    [CompilerGeneratedAttribute]
public void remove_AdornmentLayersDrawing(EventHandler`1<DrawingAdornmentLayersEventArgs> value);
    [CompilerGeneratedAttribute]
public void add_AdornmentLayersDrawn(EventHandler`1<DrawnAdornmentLayersEventArgs> value);
    [CompilerGeneratedAttribute]
public void remove_AdornmentLayersDrawn(EventHandler`1<DrawnAdornmentLayersEventArgs> value);
    [CompilerGeneratedAttribute]
public void add_AdornmentLayerDrawing(EventHandler`1<DrawingAdornmentLayerEventArgs> value);
    [CompilerGeneratedAttribute]
public void remove_AdornmentLayerDrawing(EventHandler`1<DrawingAdornmentLayerEventArgs> value);
    [CompilerGeneratedAttribute]
public void add_AdornmentLayerDrawn(EventHandler`1<DrawnAdornmentLayerEventArgs> value);
    [CompilerGeneratedAttribute]
public void remove_AdornmentLayerDrawn(EventHandler`1<DrawnAdornmentLayerEventArgs> value);
    protected virtual void OnAdornmentLayersDrawing(DrawingAdornmentLayersEventArgs e);
    protected virtual void OnAdornmentLayersDrawn(DrawnAdornmentLayersEventArgs e);
    protected virtual void OnAdornmentLayerDrawing(DrawingAdornmentLayerEventArgs e);
    protected virtual void OnAdornmentLayerDrawn(DrawnAdornmentLayerEventArgs e);
    protected virtual void OnLayersDrawing(LayersDrawingEventArgs e);
    protected virtual void OnLayersDrawn(LayersDrawnEventArgs e);
    protected virtual void OnLayerDrawing(LayerDrawingEventArgs e);
    protected virtual void OnLayerDrawn(LayerDrawnEventArgs e);
    public GeoCanvas get_Canvas();
    public void set_Canvas(GeoCanvas value);
    public bool get_ShowLogo();
    public void set_ShowLogo(bool value);
    public GeoCollection`1<AdornmentLayer> get_AdornmentLayers();
    public RectangleShape get_CurrentExtent();
    public void set_CurrentExtent(RectangleShape value);
    public GeoCollection`1<Layer> get_StaticLayers();
    public GeoCollection`1<Layer> get_DynamicLayers();
    public GeoBrush get_BackgroundFillBrush();
    public void set_BackgroundFillBrush(GeoBrush value);
    public FeatureLayer FindStaticFeatureLayer(string name);
    public RasterLayer FindStaticRasterLayer(string name);
    public FeatureLayer FindDynamicFeatureLayer(string name);
    public RasterLayer FindDynamicRasterLayer(string name);
    public RectangleShape GetDrawingExtent(float screenWidth, float screenHeight);
    public static RectangleShape GetDrawingExtent(RectangleShape worldExtent, float screenWidth, float screenHeight);
    public void OpenAllLayers();
    public void CloseAllLayers();
    public static RectangleShape CenterAt(RectangleShape worldExtent, PointShape worldPoint, float screenWidth, float screenHeight);
    public void CenterAt(PointShape worldPoint, float screenWidth, float screenHeight);
    public static RectangleShape CenterAt(RectangleShape worldExtent, Feature centerFeature, float screenWidth, float screenHeight);
    public void CenterAt(Feature centerFeature, float screenWidth, float screenHeight);
    public static RectangleShape CenterAt(RectangleShape worldExtent, float screenX, float screenY, float screenWidth, float screenHeight);
    public void CenterAt(float screenX, float screenY, float screenWidth, float screenHeight);
    public static float GetScreenDistanceBetweenTwoWorldPoints(RectangleShape worldExtent, PointShape worldPoint1, PointShape worldPoint2, float screenWidth, float screenHeight);
    public float GetScreenDistanceBetweenTwoWorldPoints(PointShape worldPoint1, PointShape worldPoint2, float screenWidth, float screenHeight);
    public float GetScreenDistanceBetweenTwoWorldPoints(Feature worldPointFeature1, Feature worldPointFeature2, float screenWidth, float screenHeight);
    public static float GetScreenDistanceBetweenTwoWorldPoints(RectangleShape worldExtent, Feature worldPointFeature1, Feature worldPointFeature2, float screenWidth, float screenHeight);
    public static double GetWorldDistanceBetweenTwoScreenPoints(RectangleShape worldExtent, ScreenPointF screenPoint1, ScreenPointF screenPoint2, float screenWidth, float screenHeight, GeographyUnit worldExtentUnit, DistanceUnit distanceUnit);
    public double GetWorldDistanceBetweenTwoScreenPoints(ScreenPointF screenPoint1, ScreenPointF screenPoint2, float screenWidth, float screenHeight, GeographyUnit mapUnit, DistanceUnit distanceUnit);
    public static double GetWorldDistanceBetweenTwoScreenPoints(RectangleShape worldExtent, float screenPoint1X, float screenPoint1Y, float screenPoint2X, float screenPoint2Y, float screenWidth, float screenHeight, GeographyUnit worldExtentUnit, DistanceUnit distanceUnit);
    public double GetCurrentScale(float screenWidth, float screenHeight, GeographyUnit mapUnit);
    public static double GetCurrentScale(RectangleShape worldExtent, float screenWidth, float screenHeight, GeographyUnit mapUnit);
    public static RectangleShape GetBoundingBoxOfItems(IEnumerable`1<BaseShape> shapes);
    public static RectangleShape GetBoundingBoxOfItems(IEnumerable`1<Feature> features);
    public GeoImage Draw(IEnumerable`1<Layer> layers, GeoImage image, GeographyUnit mapUnit);
    public GeoImage Draw(IEnumerable`1<Layer> layers, int width, int height, GeographyUnit mapUnit);
    public GeoImage DrawStaticLayers(GeoImage image, GeographyUnit mapUnit);
    public GeoImage DrawDynamicLayers(GeoImage image, GeographyUnit mapUnit);
    public GeoImage DrawAdornmentLayers(GeoImage image, GeographyUnit mapUnit);
    public GeoImage DrawStaticLayers(int width, int height, GeographyUnit mapUnit);
    public GeoImage DrawDynamicLayers(int width, int height, GeographyUnit mapUnit);
    public GeoImage DrawAdornmentLayers(int width, int height, GeographyUnit mapUnit);
    private GeoImage jRU=(IEnumerable`1<AdornmentLayer> adornmentLayers, int width, int height, GeographyUnit mapUnit);
    private GeoImage jRU=(IEnumerable`1<Layer> layers, int width, int height, GeographyUnit mapUnit, bool isToDrawBackground);
    private object jRU=(IEnumerable`1<Layer> layers, GeoImage image, GeographyUnit mapUnit, bool isToDrawBackground);
    private void jhU=();
    public void ZoomIn(int percentage);
    public static RectangleShape ZoomIn(RectangleShape worldExtent, int percentage);
    public static RectangleShape ZoomIntoCenter(RectangleShape worldExtent, int percentage, PointShape worldPoint, float screenWidth, float screenHeight);
    public static RectangleShape ZoomIntoCenter(RectangleShape worldExtent, int percentage, Feature centerFeature, float screenWidth, float screenHeight);
    public void ZoomIntoCenter(int percentage, PointShape worldPoint, float screenWidth, float screenHeight);
    public void ZoomIntoCenter(int percentage, Feature centerFeature, float screenWidth, float screenHeight);
    public static RectangleShape ZoomIntoCenter(RectangleShape worldExtent, int percentage, float screenX, float screenY, float screenWidth, float screenHeight);
    public void ZoomIntoCenter(int percentage, float screenX, float screenY, float screenWidth, float screenHeight);
    public static RectangleShape ZoomOut(RectangleShape worldExtent, int percentage);
    public void ZoomOut(int percentage);
    public static RectangleShape ZoomOutToCenter(RectangleShape worldExtent, int percentage, PointShape worldPoint, float screenWidth, float screenHeight);
    public static RectangleShape ZoomOutToCenter(RectangleShape worldExtent, int percentage, Feature centerFeature, float screenWidth, float screenHeight);
    public void ZoomOutToCenter(int percentage, PointShape worldPoint, float screenWidth, float screenHeight);
    public void ZoomOutToCenter(int percentage, Feature centerFeature, float screenWidth, float screenHeight);
    public static RectangleShape ZoomOutToCenter(RectangleShape worldExtent, int percentage, float screenX, float screenY, float screenWidth, float screenHeight);
    public void ZoomOutToCenter(int percentage, float screenX, float screenY, float screenWidth, float screenHeight);
    public static RectangleShape Pan(RectangleShape worldExtent, PanDirection direction, int percentage);
    public void Pan(PanDirection panDirection, int percentage);
    public static RectangleShape Pan(RectangleShape worldExtent, float degree, int percentage);
    public void Pan(float degree, int percentage);
    public ScreenPointF ToScreenCoordinate(double worldX, double worldY, float screenWidth, float screenHeight);
    public ScreenPointF ToScreenCoordinate(PointShape worldPoint, float screenWidth, float screenHeight);
    public ScreenPointF ToScreenCoordinate(Feature worldPointFeature, float screenWidth, float screenHeight);
    public PointShape ToWorldCoordinate(float screenX, float screenY, float screenWidth, float screenHeight);
    public PointShape ToWorldCoordinate(ScreenPointF screenPoint, float screenWidth, float screenHeight);
    public static ScreenPointF ToScreenCoordinate(RectangleShape worldExtent, double worldX, double worldY, float screenWidth, float screenHeight);
    public static ScreenPointF ToScreenCoordinate(RectangleShape worldExtent, PointShape worldPoint, float screenWidth, float screenHeight);
    public static ScreenPointF ToScreenCoordinate(RectangleShape worldExtent, Feature worldPointFeature, float screenWidth, float screenHeight);
    public static PointShape ToWorldCoordinate(RectangleShape worldExtent, float screenX, float screenY, float screenWidth, float screenHeight);
    public static PointShape ToWorldCoordinate(RectangleShape worldExtent, ScreenPointF screenPoint, float screenWidth, float screenHeight);
    public static RectangleShape SnapToZoomLevel(RectangleShape worldExtent, GeographyUnit worldExtentUnit, float screenWidth, float screenHeight, ZoomLevelSet zoomLevelSet);
    public void SnapToZoomLevel(GeographyUnit worldExtentUnit, float screenWidth, float screenHeight, ZoomLevelSet zoomLevelSet);
    public static RectangleShape ZoomToScale(double targetScale, RectangleShape worldExtent, GeographyUnit worldExtentUnit, float screenWidth, float screenHeight);
    public void ZoomToScale(double targetScale, GeographyUnit worldExtentUnit, float screenWidth, float screenHeight);
    public static string GetVersion();
    private void jxU=(Layer layer, object nativeImage);
    private void kBU=(AdornmentLayer adornmentLayer);
    public static DataTable LoadDataTable(Collection`1<Feature> features, IEnumerable`1<string> returningColumnNames);
}
public class ThinkGeo.Core.MapsCloudClient : CloudClient {
    public MapsCloudClient(string clientId, string clientSecret);
    public Stream GetRasterTile(long z, long x, long y, CloudMapProjection projection, CloudRasterMapType mapType, CloudTileSize tileSize, TileResolution tileResolution);
    [AsyncStateMachineAttribute("ThinkGeo.Core.MapsCloudClient/<GetRasterTileAsync>d__3")]
public Task`1<Stream> GetRasterTileAsync(long z, long x, long y, CloudMapProjection projection, CloudRasterMapType mapType, CloudTileSize tileSize, TileResolution tileResolution);
    public Stream GetVectorTile(long z, long x, long y, CloudMapProjection projection);
    [AsyncStateMachineAttribute("ThinkGeo.Core.MapsCloudClient/<GetVectorTileAsync>d__5")]
public Task`1<Stream> GetVectorTileAsync(long z, long x, long y, CloudMapProjection projection);
    private static string yxQ=(CloudRasterMapType mapType);
    private static string zBQ=(CloudRasterMapType mapType);
    private static string zRQ=(CloudMapProjection projection);
    private static int zhQ=(CloudTileSize tileSize);
    private static int zhQ=(TileResolution tileResolution);
}
public class ThinkGeo.Core.MapShape : object {
    [ObfuscationAttribute]
private Feature feature;
    [ObfuscationAttribute]
private ZoomLevelSet zoomLevels;
    public Feature Feature { get; public set; }
    public ZoomLevelSet ZoomLevels { get; public set; }
    public MapShape(Feature feature);
    public Feature get_Feature();
    public void set_Feature(Feature value);
    public ZoomLevelSet get_ZoomLevels();
    public void set_ZoomLevels(ZoomLevelSet value);
}
public class ThinkGeo.Core.MapShapeLayer : Layer {
    [ObfuscationAttribute]
private Dictionary`2<string, MapShape> mapShapes;
    public Dictionary`2<string, MapShape> MapShapes { get; }
    public Dictionary`2<string, MapShape> get_MapShapes();
    protected virtual void DrawCore(GeoCanvas canvas, Collection`1<SimpleCandidate> labelsInAllLayers);
}
public class ThinkGeo.Core.MapsQueryCloudClient : CloudClient {
    public MapsQueryCloudClient(string clientId, string clientSecret);
    public CloudMapsQueryResult GetFeaturesWithin(string queryLayer, BaseShape shape, CloudMapsQuerySpatialQueryOptions options);
    public CloudMapsQueryResult GetFeaturesWithin(string queryLayer, BaseShape shape, int srid, CloudMapsQuerySpatialQueryOptions options);
    public CloudMapsQueryResult GetFeaturesWithin(string queryLayer, BaseShape shape, string proj4String, CloudMapsQuerySpatialQueryOptions options);
    public CloudMapsQueryResult GetFeaturesContaining(string queryLayer, BaseShape shape, CloudMapsQuerySpatialQueryOptions options);
    public CloudMapsQueryResult GetFeaturesContaining(string queryLayer, BaseShape shape, int srid, CloudMapsQuerySpatialQueryOptions options);
    public CloudMapsQueryResult GetFeaturesContaining(string queryLayer, BaseShape shape, string proj4String, CloudMapsQuerySpatialQueryOptions options);
    public CloudMapsQueryResult GetFeaturesIntersecting(string queryLayer, BaseShape shape, CloudMapsQuerySpatialQueryOptions options);
    public CloudMapsQueryResult GetFeaturesIntersecting(string queryLayer, BaseShape shape, int srid, CloudMapsQuerySpatialQueryOptions options);
    public CloudMapsQueryResult GetFeaturesIntersecting(string queryLayer, BaseShape shape, string proj4String, CloudMapsQuerySpatialQueryOptions options);
    public CloudMapsQueryResult GetFeaturesOverlapping(string queryLayer, BaseShape shape, CloudMapsQuerySpatialQueryOptions options);
    public CloudMapsQueryResult GetFeaturesOverlapping(string queryLayer, BaseShape shape, int srid, CloudMapsQuerySpatialQueryOptions options);
    public CloudMapsQueryResult GetFeaturesOverlapping(string queryLayer, BaseShape shape, string proj4String, CloudMapsQuerySpatialQueryOptions options);
    public CloudMapsQueryResult GetFeaturesTouching(string queryLayer, BaseShape shape, CloudMapsQuerySpatialQueryOptions options);
    public CloudMapsQueryResult GetFeaturesTouching(string queryLayer, BaseShape shape, int srid, CloudMapsQuerySpatialQueryOptions options);
    public CloudMapsQueryResult GetFeaturesTouching(string queryLayer, BaseShape shape, string proj4String, CloudMapsQuerySpatialQueryOptions options);
    public CloudMapsQueryResult GetFeaturesNearest(string queryLayer, BaseShape shape, int maxResults, CloudMapsQueryNearestQueryOptions options);
    public CloudMapsQueryResult GetFeaturesNearest(string queryLayer, BaseShape shape, int srid, int maxResults, CloudMapsQueryNearestQueryOptions options);
    public CloudMapsQueryResult GetFeaturesNearest(string queryLayer, BaseShape shape, string proj4String, int maxResults, CloudMapsQueryNearestQueryOptions options);
    public CloudMapsQueryResult GetFeaturesNearest(string queryLayer, BaseShape shape, int maxResults, double searchRadius, DistanceUnit searchRadiusUnit, CloudMapsQueryNearestQueryOptions options);
    public CloudMapsQueryResult GetFeaturesNearest(string queryLayer, BaseShape shape, int srid, int maxResults, double searchRadius, DistanceUnit searchRadiusUnit, CloudMapsQueryNearestQueryOptions options);
    public CloudMapsQueryResult GetFeaturesNearest(string queryLayer, BaseShape shape, string proj4String, int maxResults, double searchRadius, DistanceUnit searchRadiusUnit, CloudMapsQueryNearestQueryOptions options);
    public CloudMapsQueryResult GetFeaturesWithinDistance(string queryLayer, BaseShape shape, double distance, DistanceUnit distanceUnit, CloudMapsQuerySpatialQueryOptions options);
    public CloudMapsQueryResult GetFeaturesWithinDistance(string queryLayer, BaseShape shape, int srid, double distance, DistanceUnit distanceUnit, CloudMapsQuerySpatialQueryOptions options);
    public CloudMapsQueryResult GetFeaturesWithinDistance(string queryLayer, BaseShape shape, string proj4String, double distance, DistanceUnit distanceUnit, CloudMapsQuerySpatialQueryOptions options);
    public CloudMapsQueryResult GetFeaturesCustom(CloudMapsQueryCustomQueryOptions options);
    public CloudMapsQueryGetLayersResult GetLayers();
    public CloudMapsQueryGetAttributesOfLayerResult GetAttributesOfLayer(string queryLayer);
    public Task`1<CloudMapsQueryResult> GetFeaturesWithinAsync(string queryLayer, BaseShape shape, CloudMapsQuerySpatialQueryOptions options);
    public Task`1<CloudMapsQueryResult> GetFeaturesWithinAsync(string queryLayer, BaseShape shape, int srid, CloudMapsQuerySpatialQueryOptions options);
    public Task`1<CloudMapsQueryResult> GetFeaturesWithinAsync(string queryLayer, BaseShape shape, string proj4String, CloudMapsQuerySpatialQueryOptions options);
    public Task`1<CloudMapsQueryResult> GetFeaturesContainingAsync(string queryLayer, BaseShape shape, CloudMapsQuerySpatialQueryOptions options);
    public Task`1<CloudMapsQueryResult> GetFeaturesContainingAsync(string queryLayer, BaseShape shape, int srid, CloudMapsQuerySpatialQueryOptions options);
    public Task`1<CloudMapsQueryResult> GetFeaturesContainingAsync(string queryLayer, BaseShape shape, string proj4String, CloudMapsQuerySpatialQueryOptions options);
    public Task`1<CloudMapsQueryResult> GetFeaturesIntersectingAsync(string queryLayer, BaseShape shape, CloudMapsQuerySpatialQueryOptions options);
    public Task`1<CloudMapsQueryResult> GetFeaturesIntersectingAsync(string queryLayer, BaseShape shape, int srid, CloudMapsQuerySpatialQueryOptions options);
    public Task`1<CloudMapsQueryResult> GetFeaturesIntersectingAsync(string queryLayer, BaseShape shape, string proj4String, CloudMapsQuerySpatialQueryOptions options);
    public Task`1<CloudMapsQueryResult> GetFeaturesOverlappingAsync(string queryLayer, BaseShape shape, CloudMapsQuerySpatialQueryOptions options);
    public Task`1<CloudMapsQueryResult> GetFeaturesOverlappingAsync(string queryLayer, BaseShape shape, int srid, CloudMapsQuerySpatialQueryOptions options);
    public Task`1<CloudMapsQueryResult> GetFeaturesOverlappingAsync(string queryLayer, BaseShape shape, string proj4String, CloudMapsQuerySpatialQueryOptions options);
    public Task`1<CloudMapsQueryResult> GetFeaturesTouchingAsync(string queryLayer, BaseShape shape, CloudMapsQuerySpatialQueryOptions options);
    public Task`1<CloudMapsQueryResult> GetFeaturesTouchingAsync(string queryLayer, BaseShape shape, int srid, CloudMapsQuerySpatialQueryOptions options);
    public Task`1<CloudMapsQueryResult> GetFeaturesTouchingAsync(string queryLayer, BaseShape shape, string proj4String, CloudMapsQuerySpatialQueryOptions options);
    public Task`1<CloudMapsQueryResult> GetFeaturesNearestAsync(string queryLayer, BaseShape shape, int maxResults, CloudMapsQueryNearestQueryOptions options);
    public Task`1<CloudMapsQueryResult> GetFeaturesNearestAsync(string queryLayer, BaseShape shape, int srid, int maxResults, CloudMapsQueryNearestQueryOptions options);
    public Task`1<CloudMapsQueryResult> GetFeaturesNearestAsync(string queryLayer, BaseShape shape, string proj4String, int maxResults, CloudMapsQueryNearestQueryOptions options);
    public Task`1<CloudMapsQueryResult> GetFeaturesNearestAsync(string queryLayer, BaseShape shape, int maxResults, double searchRadius, DistanceUnit searchRadiusUnit, CloudMapsQueryNearestQueryOptions options);
    public Task`1<CloudMapsQueryResult> GetFeaturesNearestAsync(string queryLayer, BaseShape shape, int srid, int maxResults, double searchRadius, DistanceUnit searchRadiusUnit, CloudMapsQueryNearestQueryOptions options);
    public Task`1<CloudMapsQueryResult> GetFeaturesNearestAsync(string queryLayer, BaseShape shape, string proj4String, int maxResults, double searchRadius, DistanceUnit searchRadiusUnit, CloudMapsQueryNearestQueryOptions options);
    public Task`1<CloudMapsQueryResult> GetFeaturesWithinDistanceAsync(string queryLayer, BaseShape shape, double distance, DistanceUnit distanceUnit, CloudMapsQuerySpatialQueryOptions options);
    public Task`1<CloudMapsQueryResult> GetFeaturesWithinDistanceAsync(string queryLayer, BaseShape shape, int srid, double distance, DistanceUnit distanceUnit, CloudMapsQuerySpatialQueryOptions options);
    public Task`1<CloudMapsQueryResult> GetFeaturesWithinDistanceAsync(string queryLayer, BaseShape shape, string proj4String, double distance, DistanceUnit distanceUnit, CloudMapsQuerySpatialQueryOptions options);
    public Task`1<CloudMapsQueryResult> GetFeaturesCustomAsync(CloudMapsQueryCustomQueryOptions options);
    public Task`1<CloudMapsQueryGetLayersResult> GetLayersAsync();
    public Task`1<CloudMapsQueryGetAttributesOfLayerResult> GetAttributesOfLayerAsync(string queryLayer);
    private CloudMapsQueryResult uxQ=(QueryType queryType, string queryLayer, BaseShape shape, Nullable`1<int> srid, string proj4String, CloudMapsQuerySpatialQueryOptions options);
    [AsyncStateMachineAttribute("ThinkGeo.Core.MapsQueryCloudClient/<SpatialQueryCoreAsync>d__57")]
private Task`1<CloudMapsQueryResult> vBQ=(QueryType queryType, string queryLayer, BaseShape shape, Nullable`1<int> srid, string proj4String, CloudMapsQuerySpatialQueryOptions options);
    private CloudMapsQueryResult vRQ=(string queryLayer, BaseShape shape, Nullable`1<int> srid, string proj4String, int maxResults, Nullable`1<double> searchRadius, Nullable`1<DistanceUnit> searchRadiusUnit, CloudMapsQueryNearestQueryOptions options);
    [AsyncStateMachineAttribute("ThinkGeo.Core.MapsQueryCloudClient/<GetFeaturesNearestCoreAsync>d__59")]
private Task`1<CloudMapsQueryResult> vhQ=(string queryLayer, BaseShape shape, Nullable`1<int> srid, string proj4String, int maxResults, Nullable`1<double> searchRadius, Nullable`1<DistanceUnit> searchRadiusUnit, CloudMapsQueryNearestQueryOptions options);
    private CloudMapsQueryResult vxQ=(string queryLayer, BaseShape shape, Nullable`1<int> srid, string proj4String, double distance, DistanceUnit distanceUnit, CloudMapsQuerySpatialQueryOptions options);
    [AsyncStateMachineAttribute("ThinkGeo.Core.MapsQueryCloudClient/<GetFeaturesWithinDistanceCoreAsync>d__61")]
private Task`1<CloudMapsQueryResult> wBQ=(string queryLayer, BaseShape shape, Nullable`1<int> srid, string proj4String, double distance, DistanceUnit distanceUnit, CloudMapsQuerySpatialQueryOptions options);
    private CloudMapsQueryResult wRQ=(CloudMapsQueryCustomQueryOptions options);
    [AsyncStateMachineAttribute("ThinkGeo.Core.MapsQueryCloudClient/<GetFeaturesCustomCoreAsync>d__63")]
private Task`1<CloudMapsQueryResult> whQ=(CloudMapsQueryCustomQueryOptions options);
    private CloudMapsQueryGetLayersResult wxQ=();
    [AsyncStateMachineAttribute("ThinkGeo.Core.MapsQueryCloudClient/<GetLayersCoreAsync>d__65")]
private Task`1<CloudMapsQueryGetLayersResult> xBQ=();
    private CloudMapsQueryGetAttributesOfLayerResult xRQ=(string queryLayer);
    [AsyncStateMachineAttribute("ThinkGeo.Core.MapsQueryCloudClient/<GetAttributesOfLayerCoreAsync>d__67")]
private Task`1<CloudMapsQueryGetAttributesOfLayerResult> xhQ=(string queryLayer);
    private CloudMapsQueryResult xxQ=(WebResponse response);
    private CloudMapsQueryGetLayersResult yBQ=(WebResponse response);
    private CloudMapsQueryGetAttributesOfLayerResult yRQ=(WebResponse response);
    private string txQ=(BaseShape shape, Nullable`1<int> srid, string proj4String, CloudMapsQuerySpatialQueryOptions options);
    private string txQ=(BaseShape shape, Nullable`1<int> srid, string proj4String, int maxResults, Nullable`1<double> searchRadius, Nullable`1<DistanceUnit> searchRadiusUnit, CloudMapsQueryNearestQueryOptions options);
    private string txQ=(BaseShape shape, Nullable`1<int> srid, string proj4String, double distance, DistanceUnit distanceUnit, CloudMapsQuerySpatialQueryOptions options);
    private string yhQ=(QueryType queryType);
}
public static class ThinkGeo.Core.MapUtil : object {
    public static float StandardDpi;
    public static double InchesPerFeet;
    public static double InchesPerMeter;
    public static double InchesPerMile;
    public static double InchesPerYard;
    public static double InchesPerNauticalMile;
    public static double InchesPerDecimalDegree;
    public static float PointsPerInch;
    private static Dictionary`2<string, string> QB0=;
    private static MapUtil();
    public static double GetResolutionFromScale(double scale, GeographyUnit unit, float dpi);
    public static double GetResolution(RectangleShape boundingBox, double widthInPixel, double heightInPixel);
    public static double GetScale(RectangleShape worldExtent, double screenWidth, GeographyUnit worldExtentUnit, float dpi);
    public static double GetScale(GeographyUnit mapUnit, RectangleShape boundingBox, double widthInPixel, double heightInPixel, float dpi);
    public static double GetSnappedScale(RectangleShape worldExtent, float screenWidth, GeographyUnit worldExtentUnit, ZoomLevelSet zoomLevelSet);
    public static double GetSnappedScale(double scale, ZoomLevelSet zoomLevelSet);
    public static RectangleShape CalculateExtent(PointShape worldCenter, double scale, GeographyUnit mapUnit, double mapWidth, double mapHeight);
    public static RectangleShape AdjustExtentByRestrictions(RectangleShape targetExtent, double width, double height, RectangleShape restrictExtent, double maximumScale, double minimumScale, GeographyUnit mapUnit);
    public static PointShape ToWorldCoordinate(RectangleShape currentExtent, double screenX, double screenY, double screenWidth, double screenHeight);
    public static double GetDistance(PointShape fromPoint, PointShape toPoint);
    public static int GetFloorZoomLevelIndex(double scale, ZoomLevelSet zoomLevelSet);
    public static ValueTuple`2<int, int> GetFloorCeilingZoomLevelIndex(double scale, ZoomLevelSet zoomLevelSet);
    public static int GetClosestZoomLevelIndex(double scale, ZoomLevelSet zoomLevelSet);
    public static int GetFloorZoomLevelIndex(double scale, Collection`1<double> zoomLevelScales);
    public static ValueTuple`2<int, int> GetFloorCeilingZoomLevelIndex(double scale, Collection`1<double> zoomLevelScales);
    public static int GetClosestZoomLevelIndex(double scale, Collection`1<double> zoomLevelScales);
    public static int GetSnappedZoomLevelIndex(RectangleShape extent, GeographyUnit mapUnit, Collection`1<double> zoomLevelScales, double actualWidth, double actualHeight);
    public static int GetSnappedZoomLevelIndex(double scale, ZoomLevelSet zoomLevelSet);
    public static int GetSnappedZoomLevelIndex(double scale, IEnumerable`1<double> zoomLevelScales, double minimumScale, double maximumScale);
    public static ScreenPointF GetRotatedScreenPoint(double x, double y, double rotatedAngle, ScreenPointF pivotPoint);
    public static ScreenPointF GetRotatedScreenPoint(double x, double y, double rotatedAngle, ScreenPointD pivotPoint);
    public static PointShape GetRotatedPoint(double x, double y, double rotatedAngle, PointShape pivotPoint);
    public static RectangleShape GetRotatedExtent(RectangleShape extent, double rotatedAngle, PointShape pivotPoint);
    public static AreaBaseShape GetRotatedPolygon(RectangleShape extent, double rotatedAngle, PointShape pivotPoint);
    public static RectangleShape ApplyDrawingMarginToExtent(RectangleShape worldExtent, float marginInPixel, float screenWidth, float screenHeight);
    public static RectangleShape CenterAt(RectangleShape worldExtent, PointShape worldPoint, float screenWidth, float screenHeight);
    public static RectangleShape CenterAt(RectangleShape worldExtent, Feature centerFeature, float screenWidth, float screenHeight);
    public static RectangleShape CenterAt(RectangleShape worldExtent, float screenX, float screenY, float screenWidth, float screenHeight);
    public static RectangleShape GetBoundingBoxOfItems(IEnumerable`1<BaseShape> shapes);
    public static RectangleShape GetBoundingBoxOfItems(IEnumerable`1<Feature> features);
    public static RectangleShape GetDrawingExtent(RectangleShape worldExtent, double screenWidth, double screenHeight);
    public static float GetScreenDistanceBetweenTwoWorldPoints(RectangleShape worldExtent, PointShape worldPoint1, PointShape worldPoint2, float screenWidth, float screenHeight);
    public static float GetScreenDistanceBetweenTwoWorldPoints(RectangleShape worldExtent, Feature worldPointFeature1, Feature worldPointFeature2, float screenWidth, float screenHeight);
    public static RectangleShape GetSnappedExtent(RectangleShape worldExtent, GeographyUnit worldExtentUnit, float screenWidth, float screenHeight, ZoomLevelSet zoomLevelSet);
    public static double GetWorldDistanceBetweenTwoScreenPoints(RectangleShape worldExtent, ScreenPointF screenPoint1, ScreenPointF screenPoint2, float screenWidth, float screenHeight, GeographyUnit worldExtentUnit, DistanceUnit distanceUnit);
    public static double GetWorldDistanceBetweenTwoScreenPoints(RectangleShape worldExtent, float screenPoint1X, float screenPoint1Y, float screenPoint2X, float screenPoint2Y, float screenWidth, float screenHeight, GeographyUnit worldExtentUnit, DistanceUnit distanceUnit);
    public static RectangleShape Pan(RectangleShape worldExtent, PanDirection direction, int percentage);
    public static RectangleShape Pan(RectangleShape worldExtent, float degree, int percentage);
    public static BaseShape ToScreenCoordinate(BaseShape shape, RectangleShape worldExtent, float screenWidth, float screenHeight);
    public static DrawingRectangle ToScreenCoordinate(RectangleShape worldExtent, RectangleShape targetWorldExtent, float screenWidth, float screenHeight);
    public static ScreenPointF ToScreenCoordinate(RectangleShape worldExtent, double worldX, double worldY, double screenWidth, double screenHeight);
    public static ScreenPointF ToScreenCoordinate(RectangleShape worldExtent, PointShape worldPoint, float screenWidth, float screenHeight);
    public static ScreenPointF ToScreenCoordinate(RectangleShape worldExtent, Feature worldPointFeature, float screenWidth, float screenHeight);
    public static PointShape ToWorldCoordinate(RectangleShape worldExtent, float screenX, float screenY, float screenWidth, float screenHeight);
    public static PointShape ToWorldCoordinate(RectangleShape worldExtent, ScreenPointF screenPoint, float screenWidth, float screenHeight);
    public static RectangleShape ZoomIn(RectangleShape worldExtent, int percentage);
    public static RectangleShape ZoomIntoCenter(RectangleShape worldExtent, int percentage, PointShape worldPoint, float screenWidth, float screenHeight);
    public static RectangleShape ZoomIntoCenter(RectangleShape worldExtent, int percentage, Feature centerFeature, float screenWidth, float screenHeight);
    public static RectangleShape ZoomIntoCenter(RectangleShape worldExtent, int percentage, float screenX, float screenY, float screenWidth, float screenHeight);
    public static RectangleShape ZoomOut(RectangleShape worldExtent, int percentage);
    public static RectangleShape ZoomOutToCenter(RectangleShape worldExtent, int percentage, PointShape worldPoint, float screenWidth, float screenHeight);
    public static RectangleShape ZoomOutToCenter(RectangleShape worldExtent, int percentage, Feature centerFeature, float screenWidth, float screenHeight);
    public static RectangleShape ZoomOutToCenter(RectangleShape worldExtent, int percentage, float screenX, float screenY, float screenWidth, float screenHeight);
    public static RectangleShape ZoomToScale(double targetScale, RectangleShape worldExtent, GeographyUnit worldExtentUnit, double screenWidth, double screenHeight);
    public static RectangleShape ZoomToScale(double targetScale, RectangleShape worldExtent, GeographyUnit worldExtentUnit, float screenWidth, float screenHeight, ScreenPointF offsetScreenPoint);
    public static Feature ToWorldCoordinate(PolygonShape simplyPolygon, RectangleShape currentWorldExtent, float canvasWidth, float canvasHeight);
    private static void QR0=(Byte[] sourceArray, Byte[] targetArray, long targetIndex);
    private static BaseShape Qh0=(PointShape shape, RectangleShape worldExtent, float screenWidth, float screenHeight);
    private static BaseShape Qx0=(LineShape shape, RectangleShape worldExtent, float screenWidth, float screenHeight);
    private static BaseShape RB0=(PolygonShape shape, RectangleShape worldExtent, float screenWidth, float screenHeight);
    private static BaseShape RR0=(MultipointShape shape, RectangleShape worldExtent, float screenWidth, float screenHeight);
    private static BaseShape Rh0=(MultilineShape shape, RectangleShape worldExtent, float screenWidth, float screenHeight);
    private static BaseShape Rx0=(MultipolygonShape shape, RectangleShape worldExtent, float screenWidth, float screenHeight);
    private static BaseShape SB0=(GeometryCollectionShape shape, RectangleShape worldExtent, float screenWidth, float screenHeight);
    private static PointShape SR0=(Byte[] wellKnownBinary, Int32& startIndex, RectangleShape worldExtent, float screenWidth, float screenHeight);
    private static PolygonShape Sh0=(Byte[] wellKnownBinary, Int32& startIndex, RectangleShape worldExtent, float screenWidth, float screenHeight);
    private static LineShape Sx0=(Byte[] wellKnownBinary, Int32& startIndex, RectangleShape worldExtent, float screenWidth, float screenHeight);
    private static double TB0=(Byte[] bytes, int startIndex, byte byteOrder);
    private static int TR0=(Byte[] bytes, int startIndex, byte byteOrder);
    public static string GetVersion();
    public static Collection`1<Feature> BuildFourColorColumn(string columnName, Collection`1<Feature> features);
    public static bool isSameScale(double scale1, double scale2, double epsilon);
    public static bool IsSameDouble(double double1, double double2, double epsilon);
    public static bool IsSameExtent(RectangleShape extent1, RectangleShape extent2, double epsilon);
    public static bool IsSamePoint(Vertex a, Vertex b, double epsilon);
    public static bool IsSamePoint(PointShape a, PointShape b, double epsilon);
    public static bool IsSamePoint(Vertex a, PointShape b, double epsilon);
    private static Collection`1<Collection`1<Feature>> Th0=(Collection`1<Feature> features);
    private static Int32[] Tx0=(Collection`1<Feature> features);
    public static double GetInchesPerDistanceUnit(DistanceUnit targetUnit);
    public static double GetInchesPerGeographyUnit(GeographyUnit targetUnit);
    private static double UB0=(GeographyUnit unit);
    public static AreaUnit GetAreaUnitFromDistanceUnit(DistanceUnit distanceUnit);
    public static string GetShortUnitString(DistanceUnit targetUnit, Dictionary`2<string, string> preferredDisplayUnitString);
    private static RectangleShape UR0=(RectangleShape targetExtent, RectangleShape restrictExtent, double actualWidth, double actualHeight, double maximumScale, double minimumScale, GeographyUnit mapUnit);
    private static RectangleShape Uh0=(RectangleShape targetExtent, double actualWidth, double actualHeight, double maximumScale, double minimumScale, GeographyUnit mapUnit);
    public static double GetScaleFromResolution(double resolution, GeographyUnit unit, float dpi);
    internal static float Ux0=(float point);
    public static ValueTuple`2<double, double> Rotate(double sourceX, double sourceY, double destinationX, double destinationY, double rotationAngle);
    public static ValueTuple`2<double, double> RotatePoint(double x, double y, double rotationAngle, double pivotX, double pivotY);
    public static RingShape RotateRingShape(RingShape ringShape, double rotationAngle, double pivotX, double pivotY);
    public static PolygonShape RotatePolygonShape(PolygonShape polygonShape, double rotationAngle, double pivotX, double pivotY);
    public static RectangleShape ScaleExtent(double mapWidth, double mapHeight, double resolution, double centerScreenX, double centerScreenY, double centerWorldX, double centerWorldY);
    public static double GetRotatedCanvasRadius(double pivotX, double pivotY, double canvasWidth, double canvasHeight);
    public static PointShape OffsetPointWithScreenOffset(PointShape pointShape, double xScreenOffset, double yScreenOffset, double mapRotation, double mapScale, GeographyUnit mapUnit);
    private static double VB0=(double x1, double y1, double x2, double y2);
    public static RectangleShape GetWorldExtent(GeographyUnit unit);
    public static PointShape ToWorldCoordinate(double screenX, double screenY, PointShape centerPoint, double centerScreenX, double centerScreenY, double scale, GeographyUnit mapUnit, double mapRotation);
    public static RectangleShape GetExtentFromCenterPoint(PointShape centerPoint, double canvasWidth, double canvasHeight, double scale, GeographyUnit mapUnit);
    public static ValueTuple`2<double, double> GetFloorCeilingScales(double scale, ZoomLevelSet zoomLevelSet);
    public static double GetDegreeFromPanDirection(PanDirection panDirection);
    public static double GetResolutionOfRotatedExtent(RectangleShape extent, double rotationAngle, double canvasWidth, double canvasHeight);
}
public enum ThinkGeo.Core.MaskType : Enum {
    public int value__;
    public static MaskType Default;
    public static MaskType Rectangle;
    public static MaskType RoundedCorners;
    public static MaskType RoundedEnds;
    public static MaskType Circle;
}
public abstract class ThinkGeo.Core.Matrix : object {
    [ObfuscationAttribute]
private static int MAXIMUM_CELL_COUNT;
    [ObfuscationAttribute]
private string id;
    [ObfuscationAttribute]
private double cellWidth;
    [ObfuscationAttribute]
private double cellHeight;
    [ObfuscationAttribute]
private RectangleShape boundingBox;
    [CompilerGeneratedAttribute]
private double fB0=;
    public double CellWidth { get; public set; }
    public double CellHeight { get; public set; }
    public RectangleShape BoundingBox { get; public set; }
    public string Id { get; public set; }
    internal double fx0= { get; internal set; }
    protected Matrix(string id, double cellWidth, double cellHeight, RectangleShape boundingBox);
    public double get_CellWidth();
    public void set_CellWidth(double value);
    public double get_CellHeight();
    public void set_CellHeight(double value);
    public RectangleShape get_BoundingBox();
    public void set_BoundingBox(RectangleShape value);
    public string get_Id();
    public void set_Id(string value);
    [CompilerGeneratedAttribute]
internal double fR0=();
    [CompilerGeneratedAttribute]
internal void fh0=(double value);
    public Collection`1<MatrixCell> GetAllCells();
    public MatrixCell GetCell(long row, long column);
    public MatrixCell GetCell(PointShape intersectingPoint);
    public long GetRowIndex(PointShape intersectingPoint);
    public long GetColumnIndex(PointShape intersectingPoint);
    public Collection`1<MatrixCell> GetIntersectingCells(RectangleShape worldExtent);
    public Collection`1<MatrixCell> GetContainedCells(RectangleShape worldExtent);
    public RowColumnRange GetIntersectingRowColumnRange(RectangleShape worldExtent);
    public RowColumnRange GetContainedRowColumnRange(RectangleShape worldExtent);
    public long GetRowCount();
    public long GetColumnCount();
    private RowColumnRange gB0=(RectangleShape worldExtent, bool isContains);
    protected virtual RowColumnRange GetRowColumnRangeCore(RectangleShape worldExtent, bool isContains);
    internal RowColumnRange gB0=(RectangleShape worldExtent, bool isContains, double epsilon, bool wrapWorldExtent);
}
public class ThinkGeo.Core.MatrixCell : ValueType {
    [ObfuscationAttribute]
private long row;
    [ObfuscationAttribute]
private long column;
    [ObfuscationAttribute]
private RectangleShape boundingBox;
    public long Row { get; public set; }
    public long Column { get; public set; }
    public RectangleShape BoundingBox { get; public set; }
    public MatrixCell(long row, long column, RectangleShape boundingBox);
    public long get_Row();
    public void set_Row(long value);
    public long get_Column();
    public void set_Column(long value);
    public RectangleShape get_BoundingBox();
    public void set_BoundingBox(RectangleShape value);
    public virtual string ToString();
    public virtual int GetHashCode();
    public virtual bool Equals(object obj);
    public sealed virtual int CompareTo(MatrixCell other);
    public static bool op_Equality(MatrixCell cell1, MatrixCell cell2);
    public static bool op_Inequality(MatrixCell cell1, MatrixCell cell2);
}
public enum ThinkGeo.Core.MatrixReferenceCorner : Enum {
    public int value__;
    public static MatrixReferenceCorner UpperLeft;
    public static MatrixReferenceCorner UpperRight;
    public static MatrixReferenceCorner LowerLeft;
    public static MatrixReferenceCorner LowerRight;
}
public static class ThinkGeo.Core.MaxExtents : object {
    public static RectangleShape SphericalMercator;
    public static RectangleShape ThinkGeoMaps;
    public static RectangleShape MapBoxMaps;
    public static RectangleShape BingMaps;
    public static RectangleShape HereMaps;
    public static RectangleShape GoogleMaps;
    public static RectangleShape OsmMaps;
    public static RectangleShape Feet;
    public static RectangleShape DecimalDegree;
    private static MaxExtents();
    public static RectangleShape GetDefaultMaxExtent(GeographyUnit unit);
}
public static class ThinkGeo.Core.MbStyleFilter : object {
    internal static List`1<FilterCondition> ahU=(JsonElement filterElement);
    private static List`1<FilterCondition> 4CI=(JsonElement filterElement);
    private static List`1<FilterCondition> 4SI=(JsonElement filterElement);
    private static IEnumerable`1<FilterCondition> 4iI=(JsonElement filterElement);
    private static IEnumerable`1<FilterCondition> 4yI=(JsonElement inElement);
    private static IEnumerable`1<FilterCondition> 5CI=(JsonElement filterElement);
}
public class ThinkGeo.Core.MBTilesGenerationLayerSetting : object {
    [ObfuscationAttribute]
private FeatureLayer featureLayer;
    [ObfuscationAttribute]
private Collection`1<string> columnNames;
    [ObfuscationAttribute]
private int minimumZoom;
    [ObfuscationAttribute]
private int maximumZoom;
    public FeatureLayer FeatureLayer { get; public set; }
    public Collection`1<string> ColumnNames { get; public set; }
    public int MinimumZoom { get; public set; }
    public int MaximumZoom { get; public set; }
    public MBTilesGenerationLayerSetting(FeatureLayer featureLayer, IEnumerable`1<string> columnNames, int minimumZoom, int maximumZoom);
    public FeatureLayer get_FeatureLayer();
    public void set_FeatureLayer(FeatureLayer value);
    public Collection`1<string> get_ColumnNames();
    public void set_ColumnNames(Collection`1<string> value);
    public int get_MinimumZoom();
    public void set_MinimumZoom(int value);
    public int get_MaximumZoom();
    public void set_MaximumZoom(int value);
}
public class ThinkGeo.Core.MbTilesLayer : LayerAsync {
    private SqliteConnection 8CI=;
    private string 8SI=;
    private string 8iI=;
    private RectangleShape 8yI=;
    private PointShape 9CI=;
    private int 9SI=;
    private int 9iI=;
    private int 9yI=;
    private string /CI=;
    private string /SI=;
    private string /iI=;
    private string /yI=;
    private string ACM=;
    private string ASM=;
    [CompilerGeneratedAttribute]
private string AiM=;
    [CompilerGeneratedAttribute]
private Stream AyM=;
    private ZoomLevelSet BCM=;
    [CompilerGeneratedAttribute]
private GeoColor BSM=;
    public string FilePath { get; public set; }
    public Stream StyleJsonStream { get; public set; }
    public ZoomLevelSet ZoomLevelSet { get; public set; }
    public GeoColor BackgroundColor { get; public set; }
    public bool HasBoundingBox { get; }
    public MbTilesLayer(string filePath, string styleJsonFilePath);
    public MbTilesLayer(string filePath, Stream styleJsonStream);
    [CompilerGeneratedAttribute]
public string get_FilePath();
    [CompilerGeneratedAttribute]
public void set_FilePath(string value);
    [CompilerGeneratedAttribute]
public Stream get_StyleJsonStream();
    [CompilerGeneratedAttribute]
public void set_StyleJsonStream(Stream value);
    public ZoomLevelSet get_ZoomLevelSet();
    public void set_ZoomLevelSet(ZoomLevelSet value);
    [CompilerGeneratedAttribute]
public GeoColor get_BackgroundColor();
    [CompilerGeneratedAttribute]
public void set_BackgroundColor(GeoColor value);
    [AsyncStateMachineAttribute("ThinkGeo.Core.MbTilesLayer/<OpenAsyncCore>d__33")]
protected virtual Task OpenAsyncCore(CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("ThinkGeo.Core.MbTilesLayer/<LoadMetadata>d__34")]
private Task BiM=(CancellationToken cancellationToken);
    public virtual bool get_HasBoundingBox();
    protected virtual RectangleShape GetBoundingBoxCore();
    [AsyncStateMachineAttribute("ThinkGeo.Core.MbTilesLayer/<DrawAsyncCore>d__38")]
protected virtual Task DrawAsyncCore(GeoCanvas canvas, Collection`1<SimpleCandidate> labelsInAllLayers);
    [AsyncStateMachineAttribute("ThinkGeo.Core.MbTilesLayer/<GetTileFeaturesAsync>d__39")]
private Task ByM=(ZoomLevel zoomLevel, RowColumnRange rowColumnRange, int zoom, GeoCanvas canvas);
    private static List`1<Feature> CCM=(Collection`1<VectorTile> tiles, RectangleShape currentExtent, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("ThinkGeo.Core.MbTilesLayer/<GetTiles>d__41")]
private Task`1<Collection`1<VectorTile>> CSM=(RowColumnRange rowColumnRange, int zoomLevel);
    [AsyncStateMachineAttribute("ThinkGeo.Core.MbTilesLayer/<CloseAsyncCore>d__42")]
protected virtual Task CloseAsyncCore(CancellationToken cancellationToken);
    private static ValueTuple`2<ZoomLevelSet, GeoColor> CiM=(string styleJsonString, ZoomLevelSet zoomLevelSet, string layerColumnName);
    [CompilerGeneratedAttribute]
[DebuggerHiddenAttribute]
private Task <>n__0(CancellationToken cancellationToken);
    [CompilerGeneratedAttribute]
[DebuggerHiddenAttribute]
private Task <>n__1(CancellationToken cancellationToken);
}
public class ThinkGeo.Core.MbTilesRasterLayer : LayerAsync {
    private SqliteConnection 8CI=;
    private string 8SI=;
    private string 8iI=;
    private RectangleShape 8yI=;
    private PointShape 9CI=;
    private int 9SI=;
    private int 9iI=;
    private int 9yI=;
    private string /CI=;
    private string /SI=;
    private string /iI=;
    private string /yI=;
    private string ACM=;
    [CompilerGeneratedAttribute]
private ZoomLevelSet Mx0=;
    [CompilerGeneratedAttribute]
private string AiM=;
    public ZoomLevelSet ZoomLevelSet { get; public set; }
    public string FilePath { get; public set; }
    public bool HasBoundingBox { get; }
    public MbTilesRasterLayer(string filePath);
    [CompilerGeneratedAttribute]
public ZoomLevelSet get_ZoomLevelSet();
    [CompilerGeneratedAttribute]
public void set_ZoomLevelSet(ZoomLevelSet value);
    [CompilerGeneratedAttribute]
public string get_FilePath();
    [CompilerGeneratedAttribute]
public void set_FilePath(string value);
    [AsyncStateMachineAttribute("ThinkGeo.Core.MbTilesRasterLayer/<OpenAsyncCore>d__23")]
protected virtual Task OpenAsyncCore(CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("ThinkGeo.Core.MbTilesRasterLayer/<LoadMetadata>d__24")]
private Task BiM=(CancellationToken cancellationToken);
    public virtual bool get_HasBoundingBox();
    protected virtual RectangleShape GetBoundingBoxCore();
    [AsyncStateMachineAttribute("ThinkGeo.Core.MbTilesRasterLayer/<DrawAsyncCore>d__28")]
protected virtual Task DrawAsyncCore(GeoCanvas canvas, Collection`1<SimpleCandidate> labelsInAllLayers);
    [AsyncStateMachineAttribute("ThinkGeo.Core.MbTilesRasterLayer/<GetTileFeaturesAsync>d__29")]
private Task ByM=(RowColumnRange rowColumnRange, int zoom, GeoCanvas geoCanvas);
    [AsyncStateMachineAttribute("ThinkGeo.Core.MbTilesRasterLayer/<CloseAsyncCore>d__30")]
protected virtual Task CloseAsyncCore(CancellationToken cancellationToken);
    [DebuggerHiddenAttribute]
[CompilerGeneratedAttribute]
private Task <>n__0(CancellationToken cancellationToken);
    [CompilerGeneratedAttribute]
[DebuggerHiddenAttribute]
private Task <>n__1(CancellationToken cancellationToken);
}
[ObfuscationAttribute]
internal class ThinkGeo.Core.MetersValues : ValueType {
    [ObfuscationAttribute]
private double v10;
    [ObfuscationAttribute]
private double v100;
    [ObfuscationAttribute]
private double v1000;
    [ObfuscationAttribute]
private double v20;
    [ObfuscationAttribute]
private double v200;
    [ObfuscationAttribute]
private double v30;
    [ObfuscationAttribute]
private double v300;
    [ObfuscationAttribute]
private double v40;
    [ObfuscationAttribute]
private double v400;
    [ObfuscationAttribute]
private double v50;
    [ObfuscationAttribute]
private double v500;
    public double vSA= { get; }
    public double vyA= { get; }
    public double wSA= { get; }
    public double wyA= { get; }
    public double xSA= { get; }
    public double xyA= { get; }
    public double ySA= { get; }
    public double yyA= { get; }
    public double zSA= { get; }
    public double zyA= { get; }
    public double 0SA= { get; }
    public MetersValues(int width, double extentLengthBar, DistanceUnit distanceUnit);
    public double vCA=();
    public double viA=();
    public double wCA=();
    public double wiA=();
    public double xCA=();
    public double xiA=();
    public double yCA=();
    public double yiA=();
    public double zCA=();
    public double ziA=();
    public double 0CA=();
}
[ObfuscationAttribute]
internal class ThinkGeo.Core.MilesValues : ValueType {
    [ObfuscationAttribute]
private double v01;
    [ObfuscationAttribute]
private double v02;
    [ObfuscationAttribute]
private double v03;
    [ObfuscationAttribute]
private double v04;
    [ObfuscationAttribute]
private double v05;
    [ObfuscationAttribute]
private double v1;
    [ObfuscationAttribute]
private double v10;
    [ObfuscationAttribute]
private double v100;
    [ObfuscationAttribute]
private double v1000;
    [ObfuscationAttribute]
private double v2;
    [ObfuscationAttribute]
private double v20;
    [ObfuscationAttribute]
private double v200;
    [ObfuscationAttribute]
private double v3;
    [ObfuscationAttribute]
private double v30;
    [ObfuscationAttribute]
private double v300;
    [ObfuscationAttribute]
private double v4;
    [ObfuscationAttribute]
private double v40;
    [ObfuscationAttribute]
private double v400;
    [ObfuscationAttribute]
private double v5;
    [ObfuscationAttribute]
private double v50;
    [ObfuscationAttribute]
private double v500;
    public double 4SA= { get; }
    public double 4yA= { get; }
    public double 5SA= { get; }
    public double 5yA= { get; }
    public double 6SA= { get; }
    public double 1SA= { get; }
    public double 1yA= { get; }
    public double 2SA= { get; }
    public double 2yA= { get; }
    public double 3SA= { get; }
    public double vSA= { get; }
    public double vyA= { get; }
    public double wSA= { get; }
    public double wyA= { get; }
    public double xSA= { get; }
    public double xyA= { get; }
    public double ySA= { get; }
    public double yyA= { get; }
    public double zSA= { get; }
    public double zyA= { get; }
    public double 0SA= { get; }
    public MilesValues(int width, double extentLengthBar, DistanceUnit distanceUnit);
    public double 4CA=();
    public double 4iA=();
    public double 5CA=();
    public double 5iA=();
    public double 6CA=();
    public double 1CA=();
    public double 1iA=();
    public double 2CA=();
    public double 2iA=();
    public double 3CA=();
    public double vCA=();
    public double viA=();
    public double wCA=();
    public double wiA=();
    public double xCA=();
    public double xiA=();
    public double yCA=();
    public double yiA=();
    public double zCA=();
    public double ziA=();
    public double 0CA=();
}
public class ThinkGeo.Core.MouseMovedTrackInteractiveOverlayEventArgs : EventArgs {
    [ObfuscationAttribute]
private Vertex movedVertex;
    [ObfuscationAttribute]
private Feature affectedFeature;
    public Vertex MovedVertex { get; public set; }
    public Feature AffectedFeature { get; public set; }
    public MouseMovedTrackInteractiveOverlayEventArgs(Vertex movedVertex, Feature affectedFeature);
    public Vertex get_MovedVertex();
    public void set_MovedVertex(Vertex value);
    public Feature get_AffectedFeature();
    public void set_AffectedFeature(Feature value);
}
public class ThinkGeo.Core.MovedItemGeoCollectionEventArgs : object {
    [CompilerGeneratedAttribute]
private int ghU=;
    [CompilerGeneratedAttribute]
private int gxU=;
    public int FromIndex { get; public set; }
    public int ToIndex { get; public set; }
    public MovedItemGeoCollectionEventArgs(int fromIndex, int toIndex);
    [CompilerGeneratedAttribute]
public int get_FromIndex();
    [CompilerGeneratedAttribute]
public void set_FromIndex(int value);
    [CompilerGeneratedAttribute]
public int get_ToIndex();
    [CompilerGeneratedAttribute]
public void set_ToIndex(int value);
}
[TypeConverterAttribute("ThinkGeo.Core.BaseShapeTypeConverter")]
public class ThinkGeo.Core.MultilineShape : LineBaseShape {
    [ObfuscationAttribute]
private Collection`1<LineShape> lines;
    public Collection`1<LineShape> Lines { get; }
    public MultilineShape(IEnumerable`1<LineShape> lineShapes);
    public MultilineShape(string wellKnownText);
    public MultilineShape(Byte[] wellKnownBinary);
    public Collection`1<LineShape> get_Lines();
    protected virtual RectangleShape GetBoundingBoxCore();
    protected virtual BaseShape CloneDeepCore();
    protected virtual PointShape GetCenterPointCore();
    public void Reorder(PointShape startPoint, double tolerance);
    public void Reorder(PointShape startPoint, double tolerance, GeographyUnit shapeUnit, DistanceUnit unitOfTolerance);
    protected virtual void ReorderCore(PointShape startPoint, double tolerance, GeographyUnit shapeUnit, DistanceUnit unitOfTolerance);
    protected virtual double GetLengthCore(GeographyUnit shapeUnit, DistanceUnit returningUnit);
    public PointShape GetPointOnALine(StartingPoint startingPoint, float percentageOfLine);
    public PointShape GetPointOnALine(StartingPoint startingPoint, double distance, GeographyUnit shapeUnit, DistanceUnit distanceUnit);
    protected virtual PointShape GetPointOnALineCore(StartingPoint startingPoint, double distance, GeographyUnit shapeUnit, DistanceUnit distanceUnit);
    public LineBaseShape GetLineOnALine(StartingPoint startingPoint, float startingPercentageOfTheLine, float percentageOfTheLine);
    public LineBaseShape GetLineOnALine(StartingPoint startingPoint, float percentageOfLine);
    public LineBaseShape GetLineOnALine(StartingPoint startingPoint, double startingDistance, double distance, GeographyUnit shapeUnit, DistanceUnit distanceUnit);
    protected virtual LineBaseShape GetLineOnALineCore(StartingPoint startingPoint, double startingDistance, double distance, GeographyUnit shapeUnit, DistanceUnit distanceUnit);
    public LineBaseShape GetLineOnALine(StartingPoint startingPoint, PointShape endPointShape);
    public LineBaseShape GetLineOnALine(PointShape startPointShape, PointShape endPointShape);
    private MultilineShape DRw=(PointShape startPointShape, PointShape endPointShape);
    private double Dhw=(PointShape pointShape);
    private static void HRw=(MultilineShape ResultMultiLine, Double& CumulDistEnd, LineShape LineShape, StartingPoint startingPoint, double StartingDistance, double EndingDistance, GeographyUnit shapeUnit, DistanceUnit distanceUnit);
    protected virtual void ScaleUpCore(double percentage);
    protected virtual void ScaleDownCore(double percentage);
    protected virtual BaseShape RegisterCore(PointShape fromPoint, PointShape toPoint, DistanceUnit fromUnit, GeographyUnit toUnit);
    protected virtual void TranslateByOffsetCore(double xOffsetDistance, double yOffsetDistance, GeographyUnit shapeUnit, DistanceUnit distanceUnit);
    protected virtual void TranslateByDegreeCore(double distance, double angleInDegrees, GeographyUnit shapeUnit, DistanceUnit distanceUnit);
    protected virtual void RotateCore(PointShape pivotPoint, double degreeAngle);
    protected virtual PointShape GetClosestPointToCore(BaseShape targetShape, GeographyUnit shapeUnit);
    protected virtual double GetDistanceToCore(BaseShape targetShape, GeographyUnit shapeUnit, DistanceUnit distanceUnit);
    protected virtual string GetWellKnownTextCore(RingOrder outerRingOrder);
    protected virtual WellKnownType GetWellKnownTypeCore();
    protected virtual void LoadFromWellKnownDataCore(string wellKnownText);
    protected virtual void LoadFromWellKnownDataCore(Byte[] wellKnownBinary);
    private static void Hhw=(MultilineShape fromLines, MultilineShape toLines);
    protected virtual ShapeValidationResult ValidateCore(ShapeValidationMode validationMode);
    protected virtual MultipointShape GetCrossingCore(BaseShape targetShape);
    public static bool RemoveVertex(Vertex selectedVertex, MultilineShape multilineShape);
    public bool RemoveVertex(Vertex selectedVertex);
    public MultipolygonShape ToMultiPolygonShape();
    internal void JBU=(double factor);
    private static void Hxw=(LineShape lineShape, StringBuilder wellKnownText);
    private LineShape IBw=(Vertex vertex, double Tolerance, GeographyUnit ShapesUnit, DistanceUnit ToleranceUnit);
    private bool IRw=(double tolerance, GeographyUnit shapeUnit, DistanceUnit unitOfTolerance);
    private bool Ihw=(PointShape pointShape, double tolerance, GeographyUnit shapeUnit, DistanceUnit unitOfTolerance);
    private static RectangleShape Ghw=(IEnumerable`1<Vertex> vertices);
}
public class ThinkGeo.Core.MultipleFeatureLayer : FeatureLayer {
    public Collection`1<FeatureSource> FeatureSources { get; }
    public bool HasBoundingBox { get; }
    public MultipleFeatureLayer(IEnumerable`1<FeatureSource> featureSources);
    public Collection`1<FeatureSource> get_FeatureSources();
    public virtual bool get_HasBoundingBox();
}
public class ThinkGeo.Core.MultipleFeatureSource : FeatureSource {
    [ObfuscationAttribute]
private Collection`1<FeatureSource> featureSources;
    [ObfuscationAttribute]
private Collection`1<long> featureCounts;
    public Collection`1<FeatureSource> FeatureSources { get; }
    public bool IsEditable { get; }
    public MultipleFeatureSource(IEnumerable`1<FeatureSource> featureSources);
    public Collection`1<FeatureSource> get_FeatureSources();
    public virtual bool get_IsEditable();
    protected virtual Collection`1<FeatureSourceColumn> GetColumnsCore();
    protected virtual void OpenCore();
    protected virtual void CloseCore();
    protected virtual long GetCountCore();
    protected virtual RectangleShape GetBoundingBoxCore();
    protected virtual TransactionResult CommitTransactionCore(TransactionBuffer transactions);
    protected virtual Collection`1<Feature> GetAllFeaturesCore(IEnumerable`1<string> returningColumnNames);
    protected virtual Collection`1<Feature> GetFeaturesInsideBoundingBoxCore(RectangleShape boundingBox, IEnumerable`1<string> returningColumnNames);
    protected virtual Collection`1<Feature> GetFeaturesByIdsCore(IEnumerable`1<string> ids, IEnumerable`1<string> returningColumnNames);
    protected virtual Collection`1<Feature> GetFeaturesForDrawingCore(RectangleShape boundingBox, double screenWidth, double screenHeight, IEnumerable`1<string> returningColumnNames);
    protected virtual Collection`1<Feature> GetFeaturesNearestToCore(BaseShape targetShape, GeographyUnit unitOfData, int maxItemsToFind, IEnumerable`1<string> returningColumnNames);
    protected virtual Collection`1<Feature> GetFeaturesOutsideBoundingBoxCore(RectangleShape boundingBox, IEnumerable`1<string> returningColumnNames);
    protected virtual Collection`1<Feature> GetFeaturesWithinDistanceOfCore(BaseShape targetShape, GeographyUnit unitOfData, DistanceUnit distanceUnit, double distance, IEnumerable`1<string> returningColumnNames);
    protected virtual Collection`1<Feature> SpatialQueryCore(BaseShape targetShape, QueryType queryType, IEnumerable`1<string> returningColumnNames);
}
public class ThinkGeo.Core.MultipleShapeFileFeatureLayer : FeatureLayer {
    public Collection`1<string> ShapeFiles { get; }
    public Collection`1<string> Indexes { get; }
    public string MultipleShapeFilePattern { get; public set; }
    public string IndexFilePattern { get; public set; }
    public Encoding Encoding { get; public set; }
    public bool HasBoundingBox { get; }
    public MultipleShapeFileFeatureLayer(string multipleShapeFilePattern);
    public MultipleShapeFileFeatureLayer(string multipleShapeFilePattern, string indexFilePattern);
    public MultipleShapeFileFeatureLayer(IEnumerable`1<string> shapeFiles);
    public MultipleShapeFileFeatureLayer(IEnumerable`1<string> shapeFiles, IEnumerable`1<string> indexes);
    public Collection`1<string> get_ShapeFiles();
    public Collection`1<string> get_Indexes();
    public string get_MultipleShapeFilePattern();
    public void set_MultipleShapeFilePattern(string value);
    public string get_IndexFilePattern();
    public void set_IndexFilePattern(string value);
    public Encoding get_Encoding();
    public void set_Encoding(Encoding value);
    public virtual bool get_HasBoundingBox();
    public static void BuildIndex(string multipleShapeFilePattern);
    public static void BuildIndex(string multipleShapeFilePattern, BuildIndexMode buildIndexMode);
    public static void BuildIndex(string multipleShapeFilePattern, string indexFilePattern);
    public static void BuildIndex(string multipleShapeFilePattern, string indexFilePattern, BuildIndexMode buildIndexMode);
    public static void BuildIndex(string multipleShapeFilePattern, string columnName, string regularExpression, string indexFilename);
    public static void BuildIndex(string multipleShapeFilePattern, string columnName, string regularExpression, string indexFilename, BuildIndexMode buildIndexMode);
    public static void BuildIndex(String[] multipleShapeFiles, String[] multipleShapeFileIndexes);
    public static void BuildIndex(String[] multipleShapeFiles, String[] multipleShapeFileIndexes, BuildIndexMode buildIndexMode);
    public Collection`1<string> GetShapePathFilenames();
    public Collection`1<string> GetIndexPathFilenames();
}
public class ThinkGeo.Core.MultipleShapeFileFeatureSource : FeatureSource {
    private static int gyM=;
    private static char hCM=;
    private static char hSM=;
    [ObfuscationAttribute]
private Dictionary`2<string, GeoDbf> dBaseEngines;
    [ObfuscationAttribute]
private string indexFilePattern;
    [ObfuscationAttribute]
private bool isBigMultipleIndex;
    [ObfuscationAttribute]
private string multipleShapeFilePattern;
    [ObfuscationAttribute]
private Dictionary`2<string, RtreeSpatialIndex> rTreeIndexs;
    [ObfuscationAttribute]
private Collection`1<string> shapeFiles;
    [ObfuscationAttribute]
private Collection`1<string> indexes;
    [ObfuscationAttribute]
private FileAccess shapeFileReadWriteMode;
    [ObfuscationAttribute]
private Dictionary`2<string, ShapeFile> cachedShapeFiles;
    [ObfuscationAttribute]
private Encoding encoding;
    public Collection`1<string> ShapeFiles { get; }
    public Collection`1<string> Indexes { get; }
    public string MultipleShapeFilePattern { get; public set; }
    public string IndexFilePattern { get; public set; }
    public Encoding Encoding { get; public set; }
    public bool IsEditable { get; }
    public MultipleShapeFileFeatureSource(string multipleShapeFilePattern);
    public MultipleShapeFileFeatureSource(string multipleShapeFilePattern, string indexFilePattern);
    public MultipleShapeFileFeatureSource(IEnumerable`1<string> shapeFiles);
    public MultipleShapeFileFeatureSource(IEnumerable`1<string> shapeFiles, IEnumerable`1<string> indexes);
    private void xR4=(IEnumerable`1<string> multipleShapeFiles, IEnumerable`1<string> multipleShapeFileIndexes);
    public Collection`1<string> get_ShapeFiles();
    public Collection`1<string> get_Indexes();
    public string get_MultipleShapeFilePattern();
    public void set_MultipleShapeFilePattern(string value);
    public string get_IndexFilePattern();
    public void set_IndexFilePattern(string value);
    public Encoding get_Encoding();
    public void set_Encoding(Encoding value);
    public virtual bool get_IsEditable();
    public Collection`1<string> GetShapePathFilenames();
    public Collection`1<string> GetIndexPathFilenames();
    public static void BuildIndex(string multipleShapeFilePattern);
    public static void BuildIndex(string multipleShapeFilePattern, BuildIndexMode buildIndexMode);
    public static void BuildIndex(string multipleShapeFilePattern, string indexFilePattern);
    public static void BuildIndex(string multipleShapeFilePattern, string indexFilePattern, BuildIndexMode buildIndexMode);
    public static void BuildIndex(string multipleShapeFilePattern, string columnName, string regularExpression, string indexFilename);
    public static void BuildIndex(string multipleShapeFilePattern, string columnName, string regularExpression, string indexPathFilename, BuildIndexMode buildIndexMode);
    public static void BuildIndex(String[] multipleShapeFiles, String[] multipleShapeFileIndexes);
    public static void BuildIndex(String[] multipleShapeFiles, String[] multipleShapeFileIndexes, BuildIndexMode buildIndexMode);
    private static bool hiM=(BuildIndexMode buildIndexMode, IEnumerable`1<string> idxPathFilenames);
    private static Dictionary`2<string, string> hyM=(string multipleShapeFilePattern, string indexFilePattern);
    private static void iCM=(string shapePathFilename, string idxFileName, string columnName, string regularExpression);
    private static bool iSM=(GeoDbf dbaseEngine, int recourdId, string columnName, Regex regex);
    private static void iiM=(string idxPathFilename, WellKnownType wellKnownType);
    protected virtual Collection`1<FeatureSourceColumn> GetColumnsCore();
    protected virtual void OpenCore();
    protected virtual void CloseCore();
    protected virtual TransactionResult CommitTransactionCore(TransactionBuffer transactions);
    protected virtual Collection`1<Feature> GetAllFeaturesCore(IEnumerable`1<string> returningColumnNames);
    protected virtual Collection`1<string> GetFeatureIdsCore();
    private Collection`1<string> iyM=(string shapePathFilename, string key);
    private Collection`1<Feature> jCM=(string shapePathFilename, string key, List`1<string> columnNames);
    private static Dictionary`2<string, string> jSM=(GeoDbf dBaseEngine, string id, IEnumerable`1<string> columnNames);
    protected virtual RectangleShape GetBoundingBoxCore();
    private RectangleShape jiM=(string shapePathFilename, string key);
    protected virtual long GetCountCore();
    protected virtual Collection`1<Feature> GetFeaturesByIdsCore(IEnumerable`1<string> ids, IEnumerable`1<string> returningColumnNames);
    private Feature jyM=(string originalId, string key, string recordId, List`1<string> recordNames);
    protected virtual Collection`1<Feature> GetFeaturesInsideBoundingBoxCore(RectangleShape boundingBox, IEnumerable`1<string> returningColumnNames);
    private Collection`1<Feature> kCM=(string shapePathFilename, string key, RectangleShape boundingBox, List`1<string> returningColumnNames);
    protected virtual Collection`1<Feature> GetFeaturesOutsideBoundingBoxCore(RectangleShape boundingBox, IEnumerable`1<string> returningColumnNames);
    private string kSM=(string shapefile);
    private Collection`1<Feature> kiM=(string shapePathFilename, string key, RectangleShape boundingBox, List`1<string> returningColumnNames);
    protected virtual Collection`1<Feature> GetFeaturesWithinDistanceOfCore(BaseShape targetShape, GeographyUnit unitOfData, DistanceUnit distanceUnit, double distance, IEnumerable`1<string> returningColumnNames);
    private Collection`1<Feature> kyM=(string shapeFilePathName, string key, BaseShape targetShape, GeographyUnit unitOfData, DistanceUnit distanceUnit, double distance, List`1<string> returningColumnNames);
    protected virtual Collection`1<Feature> GetFeaturesNearestToCore(BaseShape targetShape, GeographyUnit unitOfData, int maxItemsToFind, IEnumerable`1<string> returningColumnNames);
    private static String[] lCM=(string wildcardPathFilename);
    private ShapeFile lSM=(string shapePathFilename, string key);
    private GeoDbf liM=(string shapePathFilename, string key);
    private RtreeSpatialIndex lyM=(string shapePathFilename, string key);
    private static void mCM=(string pathFilename);
    private static WellKnownType cho=(ShapeFileType shapeFileType);
}
[TypeConverterAttribute("ThinkGeo.Core.BaseShapeTypeConverter")]
public class ThinkGeo.Core.MultipointShape : PointBaseShape {
    [ObfuscationAttribute]
private Collection`1<PointShape> points;
    public Collection`1<PointShape> Points { get; }
    public MultipointShape(IEnumerable`1<PointShape> points);
    public MultipointShape(IEnumerable`1<Feature> pointFeatures);
    public MultipointShape(Feature multipointFeature);
    public MultipointShape(string wellKnownText);
    public MultipointShape(Byte[] wellKnownBinary);
    public Collection`1<PointShape> get_Points();
    protected virtual BaseShape CloneDeepCore();
    protected virtual PointShape GetCenterPointCore();
    public void ScaleUp(double percentage);
    protected virtual void ScaleUpCore(double percentage);
    public void ScaleDown(double percentage);
    protected virtual void ScaleDownCore(double percentage);
    private void JBU=(float multiplicator);
    public RingShape ConvexHull();
    protected virtual RingShape ConvexHullCore();
    protected virtual BaseShape RegisterCore(PointShape fromPoint, PointShape toPoint, DistanceUnit fromUnit, GeographyUnit toUnit);
    protected virtual void TranslateByOffsetCore(double xOffsetDistance, double yOffsetDistance, GeographyUnit shapeUnit, DistanceUnit distanceUnit);
    protected virtual void TranslateByDegreeCore(double distance, double angleInDegrees, GeographyUnit shapeUnit, DistanceUnit distanceUnit);
    protected virtual void RotateCore(PointShape pivotPoint, double degreeAngle);
    protected virtual PointShape GetClosestPointToCore(BaseShape targetShape, GeographyUnit shapeUnit);
    protected virtual RectangleShape GetBoundingBoxCore();
    protected virtual double GetDistanceToCore(BaseShape targetShape, GeographyUnit shapeUnit, DistanceUnit distanceUnit);
    protected virtual string GetWellKnownTextCore(RingOrder outerRingOrder);
    protected virtual WellKnownType GetWellKnownTypeCore();
    protected virtual void LoadFromWellKnownDataCore(string wellKnownText);
    protected virtual void LoadFromWellKnownDataCore(Byte[] wellKnownBinary);
    private static void Ixw=(MultipointShape fromMultipoint, MultipointShape toMultipoint);
    protected virtual ShapeValidationResult ValidateCore(ShapeValidationMode validationMode);
    protected virtual MultipointShape GetCrossingCore(BaseShape targetShape);
    public static bool RemoveVertex(Vertex selectedVertex, MultipointShape multipointShape);
    public bool RemoveVertex(Vertex selectedVertex);
    private static RectangleShape JBw=(IEnumerable`1<PointShape> points);
}
[TypeConverterAttribute("ThinkGeo.Core.BaseShapeTypeConverter")]
public class ThinkGeo.Core.MultipolygonShape : AreaBaseShape {
    [ObfuscationAttribute]
private Collection`1<PolygonShape> polygons;
    public Collection`1<PolygonShape> Polygons { get; }
    public MultipolygonShape(IEnumerable`1<PolygonShape> polygons);
    public MultipolygonShape(string wellKnownText);
    public MultipolygonShape(Byte[] wellKnownBinary);
    public Collection`1<PolygonShape> get_Polygons();
    protected virtual BaseShape CloneDeepCore();
    protected virtual double GetPerimeterCore(GeographyUnit shapeUnit, DistanceUnit returningUnit);
    protected virtual double GetAreaCore(GeographyUnit shapeUnit, AreaUnit returningUnit);
    protected virtual void ScaleUpCore(double percentage);
    protected virtual void ScaleDownCore(double percentage);
    protected virtual BaseShape RegisterCore(PointShape fromPoint, PointShape toPoint, DistanceUnit fromUnit, GeographyUnit toUnit);
    protected virtual void TranslateByOffsetCore(double xOffsetDistance, double yOffsetDistance, GeographyUnit shapeUnit, DistanceUnit distanceUnit);
    protected virtual void TranslateByDegreeCore(double distance, double angleInDegrees, GeographyUnit shapeUnit, DistanceUnit distanceUnit);
    protected virtual void RotateCore(PointShape pivotPoint, double degreeAngle);
    protected virtual PointShape GetClosestPointToCore(BaseShape targetShape, GeographyUnit shapeUnit);
    protected virtual double GetDistanceToCore(BaseShape targetShape, GeographyUnit shapeUnit, DistanceUnit distanceUnit);
    protected virtual string GetWellKnownTextCore(RingOrder outerRingOrder);
    protected virtual WellKnownType GetWellKnownTypeCore();
    protected virtual Byte[] GetWellKnownBinaryCore(RingOrder outerRingOrder, WkbByteOrder byteOrder);
    private static void JRw=(RingShape targetRingShape, WkbByteOrder byteOrder, BinaryWriter writer);
    protected virtual void LoadFromWellKnownDataCore(string wellKnownText);
    protected virtual void LoadFromWellKnownDataCore(Byte[] wellKnownBinary);
    protected virtual RectangleShape GetBoundingBoxCore();
    private static void Jhw=(MultipolygonShape fromMultipolygon, MultipolygonShape toMultipolygon);
    protected virtual ShapeValidationResult ValidateCore(ShapeValidationMode validationMode);
    protected virtual MultipointShape GetCrossingCore(BaseShape targetShape);
    protected virtual bool ContainsCore(BaseShape targetShape);
    public static bool RemoveVertex(Vertex selectedVertex, MultipolygonShape multipolygonShape);
    public bool RemoveVertex(Vertex selectedVertex);
    public MultilineShape ToMultiLineShape();
    private static void Jxw=(RingShape targetRingShape, WkbByteOrder byteOrder, BinaryWriter writer);
    private void KBw=(string wellKnownText);
    private void KRw=(Byte[] wellKnownBinary);
    internal void JBU=(double multiplicator);
    private static RectangleShape Ghw=(IEnumerable`1<Vertex> vertices);
}
public class ThinkGeo.Core.NativeImageRasterLayer : RasterLayer {
    public bool HasBoundingBox { get; }
    public string ImagePathFilename { get; public set; }
    public NativeImageRasterLayer(string imagePathFilename);
    public NativeImageRasterLayer(string imagePathFilename, string worldfilePathFilename);
    public NativeImageRasterLayer(string imagePathFilename, RectangleShape imageExtent);
    public void add_StreamLoading(EventHandler`1<StreamLoadingEventArgs> value);
    public void remove_StreamLoading(EventHandler`1<StreamLoadingEventArgs> value);
    public virtual bool get_HasBoundingBox();
    public string get_ImagePathFilename();
    public void set_ImagePathFilename(string value);
}
public class ThinkGeo.Core.NativeImageRasterSource : RasterSource {
    [ObfuscationAttribute]
private static int smallestSizeForTemplate;
    [ObfuscationAttribute]
private GeoImage bufferBitmap;
    [ObfuscationAttribute]
private RectangleShape imageExtent;
    [ObfuscationAttribute]
private string imagePathFilename;
    [ObfuscationAttribute]
private WorldFile worldFile;
    [ObfuscationAttribute]
private string worldFilePathFilename;
    [CompilerGeneratedAttribute]
private EventHandler`1<StreamLoadingEventArgs> StreamLoading;
    public bool IsNegative { get; public set; }
    public bool IsGrayscale { get; public set; }
    public string FileName { get; }
    public string FilePath { get; }
    public string ImagePathFilename { get; public set; }
    public NativeImageRasterSource(string imagePathFilename);
    public NativeImageRasterSource(string imagePathFilename, string worldfilePathFilename);
    public NativeImageRasterSource(string imagePathFilename, RectangleShape imageExtent);
    public bool get_IsNegative();
    public void set_IsNegative(bool value);
    public bool get_IsGrayscale();
    public void set_IsGrayscale(bool value);
    public string get_FileName();
    public string get_FilePath();
    public string get_ImagePathFilename();
    public void set_ImagePathFilename(string value);
    [CompilerGeneratedAttribute]
public void add_StreamLoading(EventHandler`1<StreamLoadingEventArgs> value);
    [CompilerGeneratedAttribute]
public void remove_StreamLoading(EventHandler`1<StreamLoadingEventArgs> value);
    protected virtual void OnStreamLoading(StreamLoadingEventArgs e);
    protected virtual int GetImageWidthCore();
    protected virtual int GetImageHeightCore();
    private static WorldFile HSM=(string worldFilePath);
    private static WorldFile HiM=(Stream stream);
    protected virtual void OpenCore();
    protected virtual void CloseCore();
    protected virtual GeoImage GetImageCore(RectangleShape worldExtent, int canvasWidth, int canvasHeight);
    protected virtual RectangleShape GetBoundingBoxCore();
    private static DrawingRectangle HyM=(float bmpWidth, float bmpHeight, RectangleShape sourceRectangleInWorld, RectangleShape boundingBox);
    private RectangleShape ICM=();
}
[ObfuscationAttribute]
internal class ThinkGeo.Core.NauticalMilesValues : ValueType {
    [ObfuscationAttribute]
private double v01;
    [ObfuscationAttribute]
private double v02;
    [ObfuscationAttribute]
private double v03;
    [ObfuscationAttribute]
private double v04;
    [ObfuscationAttribute]
private double v05;
    [ObfuscationAttribute]
private double v1;
    [ObfuscationAttribute]
private double v10;
    [ObfuscationAttribute]
private double v100;
    [ObfuscationAttribute]
private double v1000;
    [ObfuscationAttribute]
private double v2;
    [ObfuscationAttribute]
private double v20;
    [ObfuscationAttribute]
private double v200;
    [ObfuscationAttribute]
private double v3;
    [ObfuscationAttribute]
private double v30;
    [ObfuscationAttribute]
private double v300;
    [ObfuscationAttribute]
private double v4;
    [ObfuscationAttribute]
private double v40;
    [ObfuscationAttribute]
private double v400;
    [ObfuscationAttribute]
private double v5;
    [ObfuscationAttribute]
private double v50;
    [ObfuscationAttribute]
private double v500;
    public double 4SA= { get; }
    public double 4yA= { get; }
    public double 5SA= { get; }
    public double 5yA= { get; }
    public double 6SA= { get; }
    public double 1SA= { get; }
    public double 1yA= { get; }
    public double 2SA= { get; }
    public double 2yA= { get; }
    public double 3SA= { get; }
    public double vSA= { get; }
    public double vyA= { get; }
    public double wSA= { get; }
    public double wyA= { get; }
    public double xSA= { get; }
    public double xyA= { get; }
    public double ySA= { get; }
    public double yyA= { get; }
    public double zSA= { get; }
    public double zyA= { get; }
    public double 0SA= { get; }
    public NauticalMilesValues(int width, double extentLengthBar, DistanceUnit distanceUnit);
    public double 4CA=();
    public double 4iA=();
    public double 5CA=();
    public double 5iA=();
    public double 6CA=();
    public double 1CA=();
    public double 1iA=();
    public double 2CA=();
    public double 2iA=();
    public double 3CA=();
    public double vCA=();
    public double viA=();
    public double wCA=();
    public double wiA=();
    public double xCA=();
    public double xiA=();
    public double yCA=();
    public double yiA=();
    public double zCA=();
    public double ziA=();
    public double 0CA=();
}
public class ThinkGeo.Core.NoaaWeatherStation : object {
    [CompilerGeneratedAttribute]
private string MiM=;
    [CompilerGeneratedAttribute]
private string lR0=;
    [CompilerGeneratedAttribute]
private string MyM=;
    [CompilerGeneratedAttribute]
private string NCM=;
    [CompilerGeneratedAttribute]
private double NSM=;
    [CompilerGeneratedAttribute]
private double NiM=;
    [CompilerGeneratedAttribute]
private double NyM=;
    [CompilerGeneratedAttribute]
private NoaaWeatherStationSiteType OCM=;
    [CompilerGeneratedAttribute]
private string OSM=;
    [CompilerGeneratedAttribute]
private string OiM=;
    [XmlElementAttribute]
public string StationId { get; public set; }
    [XmlElementAttribute]
public string Name { get; public set; }
    [XmlElementAttribute]
public string State { get; public set; }
    [XmlElementAttribute]
public string Country { get; public set; }
    [XmlElementAttribute]
public double Latitude { get; public set; }
    [XmlElementAttribute]
public double Longitude { get; public set; }
    [XmlElementAttribute]
public double Elevation { get; public set; }
    [XmlElementAttribute]
public NoaaWeatherStationSiteType SiteType { get; public set; }
    public string Description { get; public set; }
    public string Temperature { get; public set; }
    [CompilerGeneratedAttribute]
public string get_StationId();
    [CompilerGeneratedAttribute]
public void set_StationId(string value);
    [CompilerGeneratedAttribute]
public string get_Name();
    [CompilerGeneratedAttribute]
public void set_Name(string value);
    [CompilerGeneratedAttribute]
public string get_State();
    [CompilerGeneratedAttribute]
public void set_State(string value);
    [CompilerGeneratedAttribute]
public string get_Country();
    [CompilerGeneratedAttribute]
public void set_Country(string value);
    [CompilerGeneratedAttribute]
public double get_Latitude();
    [CompilerGeneratedAttribute]
public void set_Latitude(double value);
    [CompilerGeneratedAttribute]
public double get_Longitude();
    [CompilerGeneratedAttribute]
public void set_Longitude(double value);
    [CompilerGeneratedAttribute]
public double get_Elevation();
    [CompilerGeneratedAttribute]
public void set_Elevation(double value);
    [CompilerGeneratedAttribute]
public NoaaWeatherStationSiteType get_SiteType();
    [CompilerGeneratedAttribute]
public void set_SiteType(NoaaWeatherStationSiteType value);
    [CompilerGeneratedAttribute]
public string get_Description();
    [CompilerGeneratedAttribute]
public void set_Description(string value);
    [CompilerGeneratedAttribute]
public string get_Temperature();
    [CompilerGeneratedAttribute]
public void set_Temperature(string value);
    public Feature ToFeature();
    public void FillDescriptionAndTemperature();
    private static string OyM=(string celsiusString);
}
public class ThinkGeo.Core.NoaaWeatherStationFeatureLayer : FeatureLayer {
}
public class ThinkGeo.Core.NoaaWeatherStationFeatureSource : FeatureSource {
    private Dictionary`2<string, Feature> KiM=;
    private Dictionary`2<string, NoaaWeatherStation> KyM=;
    private STRtree`1<string> /R8=;
    [CompilerGeneratedAttribute]
private int uh0=;
    public int TimeoutInSeconds { get; public set; }
    [CompilerGeneratedAttribute]
public int get_TimeoutInSeconds();
    [CompilerGeneratedAttribute]
public void set_TimeoutInSeconds(int value);
    protected virtual void OpenCore();
    private static STRtree`1<string> LCM=(Dictionary`2<string, Feature> stationsCache);
    protected virtual Collection`1<Feature> GetAllFeaturesCore(IEnumerable`1<string> returningColumnNames);
    protected virtual Collection`1<FeatureSourceColumn> GetColumnsCore();
    protected virtual long GetCountCore();
    protected virtual Collection`1<Feature> GetFeaturesInsideBoundingBoxCore(RectangleShape boundingBox, IEnumerable`1<string> returningColumnNames);
    public void UpdateWeatherStations();
    public Dictionary`2<string, Feature> GetStationFeatures();
    private Dictionary`2<string, NoaaWeatherStation> LSM=();
    private void LiM=(Uri cycleUri);
    private static Collection`1<Uri> LyM=();
}
[XmlRootAttribute]
public class ThinkGeo.Core.NoaaWeatherStationResponse : object {
    [CompilerGeneratedAttribute]
private double MCM=;
    [CompilerGeneratedAttribute]
private List`1<NoaaWeatherStation> MSM=;
    [XmlElementAttribute]
public double RequestIndex { get; public set; }
    [XmlArrayAttribute("data")]
[XmlArrayItemAttribute("Station", "ThinkGeo.Core.NoaaWeatherStation")]
public List`1<NoaaWeatherStation> Stations { get; public set; }
    [CompilerGeneratedAttribute]
public double get_RequestIndex();
    [CompilerGeneratedAttribute]
public void set_RequestIndex(double value);
    [CompilerGeneratedAttribute]
public List`1<NoaaWeatherStation> get_Stations();
    [CompilerGeneratedAttribute]
public void set_Stations(List`1<NoaaWeatherStation> value);
    public static NoaaWeatherStationResponse DownloadNoaaWeatherStationResponse();
}
public class ThinkGeo.Core.NoaaWeatherStationSiteType : object {
    [CompilerGeneratedAttribute]
private string PCM=;
    [CompilerGeneratedAttribute]
private string PSM=;
    [CompilerGeneratedAttribute]
private string PiM=;
    [CompilerGeneratedAttribute]
private string PyM=;
    [CompilerGeneratedAttribute]
private string QCM=;
    [XmlElementAttribute("METAR")]
public string Metar { get; public set; }
    [XmlElementAttribute("TAF")]
public string Taf { get; public set; }
    [XmlElementAttribute("rawinsonde")]
public string Rawinsonde { get; public set; }
    [XmlElementAttribute("WFO_office")]
public string WfoOffice { get; public set; }
    [XmlElementAttribute("NEXRAD")]
public string Nexrad { get; public set; }
    [CompilerGeneratedAttribute]
public string get_Metar();
    [CompilerGeneratedAttribute]
public void set_Metar(string value);
    [CompilerGeneratedAttribute]
public string get_Taf();
    [CompilerGeneratedAttribute]
public void set_Taf(string value);
    [CompilerGeneratedAttribute]
public string get_Rawinsonde();
    [CompilerGeneratedAttribute]
public void set_Rawinsonde(string value);
    [CompilerGeneratedAttribute]
public string get_WfoOffice();
    [CompilerGeneratedAttribute]
public void set_WfoOffice(string value);
    [CompilerGeneratedAttribute]
public string get_Nexrad();
    [CompilerGeneratedAttribute]
public void set_Nexrad(string value);
    public int GetPriority();
}
public class ThinkGeo.Core.NoaaWeatherStationStyle : Style {
    private Dictionary`2<string, GeoImage> RyM=;
    protected virtual void DrawCore(IEnumerable`1<Feature> features, GeoCanvas canvas, Collection`1<SimpleCandidate> labelsInThisLayer, Collection`1<SimpleCandidate> labelsInAllLayers);
    protected virtual void DrawSampleCore(GeoCanvas canvas, DrawingRectangleF drawingExtent);
    private void SCM=();
    private static void SSM=(Feature feature, Collection`1<RectangleShape> recordsDrawn, GeoCanvas canvas, GeoImage image, double x, double y, DrawingLevel drawingLevel, float xOffset, float yOffset, float rotationAngle);
    protected virtual Collection`1<string> GetRequiredColumnNamesCore();
    protected virtual override void Finalize();
}
public class ThinkGeo.Core.NoaaWeatherWarningsFeatureLayer : FeatureLayer {
}
public class ThinkGeo.Core.NoaaWeatherWarningsFeatureSource : FeatureSource {
    private TinyGeoFeatureSource QSM=;
    private Dictionary`2<string, List`1<Dictionary`2<string, string>>> QiM=;
    protected virtual void OpenCore();
    private Dictionary`2<string, List`1<Dictionary`2<string, string>>> QyM=();
    private void RCM=(XmlNode warningEntry, XmlNamespaceManager nsmgr, TinyGeoFeatureSource countiesFeatureSource, Dictionary`2<string, List`1<Dictionary`2<string, string>>> warnings, Dictionary`2<string, string> fipsToFeatureIds);
    protected virtual void CloseCore();
    protected virtual Collection`1<FeatureSourceColumn> GetColumnsCore();
    protected virtual Collection`1<Feature> GetAllFeaturesCore(IEnumerable`1<string> returningColumnNames);
    protected virtual long GetCountCore();
    protected virtual RectangleShape GetBoundingBoxCore();
    protected virtual Collection`1<Feature> GetFeaturesInsideBoundingBoxCore(RectangleShape boundingBox, IEnumerable`1<string> returningColumnNames);
    private TinyGeoFeatureSource RSM=();
    private void RiM=(object sender, StreamLoadingEventArgs e);
}
public class ThinkGeo.Core.NoaaWeatherWarningsStyle : ValueStyle {
    protected virtual void DrawCore(IEnumerable`1<Feature> features, GeoCanvas canvas, Collection`1<SimpleCandidate> labelsInThisLayer, Collection`1<SimpleCandidate> labelsInAllLayers);
    protected virtual Collection`1<string> GetRequiredColumnNamesCore();
    private void SiM=();
}
[AttributeUsageAttribute("4124")]
public class ThinkGeo.Core.NonSerializableBaseTypeAttribute : Attribute {
}
public class ThinkGeo.Core.OgcApiFeatureLayer : FeatureLayer {
    public string Url { get; public set; }
    public int BulkSize { get; public set; }
    public string CollectionId { get; public set; }
    public int TimeoutInSeconds { get; public set; }
    public bool HasBoundingBox { get; }
    public IWebProxy WebProxy { get; public set; }
    public OgcApiFeatureLayer(string url, string collectionId, int bulkSize);
    public string get_Url();
    public void set_Url(string value);
    public int get_BulkSize();
    public void set_BulkSize(int value);
    public string get_CollectionId();
    public void set_CollectionId(string value);
    public int get_TimeoutInSeconds();
    public void set_TimeoutInSeconds(int value);
    public virtual bool get_HasBoundingBox();
    public IWebProxy get_WebProxy();
    public void set_WebProxy(IWebProxy value);
    public void add_SendingWebRequest(EventHandler`1<SendingWebRequestEventArgs> value);
    public void remove_SendingWebRequest(EventHandler`1<SendingWebRequestEventArgs> value);
    public void add_SentWebRequest(EventHandler`1<SentWebRequestEventArgs> value);
    public void remove_SentWebRequest(EventHandler`1<SentWebRequestEventArgs> value);
    public Collection`1<string> GetLayers();
}
public class ThinkGeo.Core.OgcApiFeatureSource : FeatureSource {
    private static string aSM=;
    private Collection`1<FeatureSourceColumn> aiM=;
    [ObfuscationAttribute]
private Collection`1<string> layers;
    [ObfuscationAttribute]
private WyM= ogcApiFeatureCollection;
    [CompilerGeneratedAttribute]
private EventHandler`1<SendingWebRequestEventArgs> SendingWebRequest;
    [CompilerGeneratedAttribute]
private EventHandler`1<SentWebRequestEventArgs> SentWebRequest;
    [CompilerGeneratedAttribute]
private string ayM=;
    [CompilerGeneratedAttribute]
private string bCM=;
    [CompilerGeneratedAttribute]
private int bSM=;
    [CompilerGeneratedAttribute]
private int uh0=;
    [CompilerGeneratedAttribute]
private IWebProxy ux0=;
    [CompilerGeneratedAttribute]
private EventHandler`1<RequestingDataWfsFeatureSourceEventArgs> RequestingData;
    [CompilerGeneratedAttribute]
private EventHandler`1<RequestedDataWfsFeatureSourceEventArgs> RequestedData;
    public string Url { get; public set; }
    public string CollectionId { get; public set; }
    public int BulkSize { get; public set; }
    public int TimeoutInSeconds { get; public set; }
    public IWebProxy WebProxy { get; public set; }
    public OgcApiFeatureSource(string url, string collectionId, int bulkSize);
    [CompilerGeneratedAttribute]
public void add_SendingWebRequest(EventHandler`1<SendingWebRequestEventArgs> value);
    [CompilerGeneratedAttribute]
public void remove_SendingWebRequest(EventHandler`1<SendingWebRequestEventArgs> value);
    [CompilerGeneratedAttribute]
public void add_SentWebRequest(EventHandler`1<SentWebRequestEventArgs> value);
    [CompilerGeneratedAttribute]
public void remove_SentWebRequest(EventHandler`1<SentWebRequestEventArgs> value);
    protected virtual bool CanGetBoundingBoxQuicklyCore();
    [CompilerGeneratedAttribute]
public string get_Url();
    [CompilerGeneratedAttribute]
public void set_Url(string value);
    [CompilerGeneratedAttribute]
public string get_CollectionId();
    [CompilerGeneratedAttribute]
public void set_CollectionId(string value);
    [CompilerGeneratedAttribute]
public int get_BulkSize();
    [CompilerGeneratedAttribute]
public void set_BulkSize(int value);
    [CompilerGeneratedAttribute]
public int get_TimeoutInSeconds();
    [CompilerGeneratedAttribute]
public void set_TimeoutInSeconds(int value);
    [CompilerGeneratedAttribute]
public IWebProxy get_WebProxy();
    [CompilerGeneratedAttribute]
public void set_WebProxy(IWebProxy value);
    [CompilerGeneratedAttribute]
public void add_RequestingData(EventHandler`1<RequestingDataWfsFeatureSourceEventArgs> value);
    [CompilerGeneratedAttribute]
public void remove_RequestingData(EventHandler`1<RequestingDataWfsFeatureSourceEventArgs> value);
    protected virtual void OnRequestingData(RequestingDataWfsFeatureSourceEventArgs requestingDataWfsFeatureSourceEventArgs);
    [CompilerGeneratedAttribute]
public void add_RequestedData(EventHandler`1<RequestedDataWfsFeatureSourceEventArgs> value);
    [CompilerGeneratedAttribute]
public void remove_RequestedData(EventHandler`1<RequestedDataWfsFeatureSourceEventArgs> value);
    protected virtual void OnRequestedData(RequestedDataWfsFeatureSourceEventArgs requestedDataWfsFeatureSourceEventArgs);
    protected WebResponse SendWebRequest(WebRequest webRequest);
    protected virtual WebResponse SendWebRequestCore(WebRequest webRequest);
    protected virtual void OnSendingWebRequest(SendingWebRequestEventArgs e);
    protected virtual void OnSentWebRequest(SentWebRequestEventArgs e);
    public string GetCapabilities();
    private string biM=(string requestString);
    private static void Gh4=(string requestCapabilities, string jsonString);
    private static string byM=(string requestCapabilities);
    public Collection`1<string> GetLayers();
    protected virtual void OpenCore();
    protected virtual void CloseCore();
    protected virtual RectangleShape GetBoundingBoxCore();
    protected virtual Collection`1<FeatureSourceColumn> GetColumnsCore();
    protected virtual Collection`1<Feature> GetFeaturesByIdsCore(IEnumerable`1<string> ids, IEnumerable`1<string> returningColumnNames);
    protected virtual WellKnownType GetFirstFeaturesWellKnownTypeCore();
    protected virtual Collection`1<Feature> GetAllFeaturesCore(IEnumerable`1<string> returningColumnNames);
    protected virtual Collection`1<Feature> GetFeaturesInsideBoundingBoxCore(RectangleShape boundingBox, IEnumerable`1<string> returningColumnNames);
    public string GetRequestUrlForFeatures(RectangleShape boundingBox, Nullable`1<int> limit);
    public ValueTuple`2<string, Collection`1<Feature>> GetFeatures(string requestFeaturesUrl);
    public Collection`1<string> GetSupportedCrs();
    public string GetDefaultCrs();
    private static string cCM=(string crs);
    private Collection`1<Feature> cSM=(string requestFeaturesUrl);
    protected virtual Collection`1<Feature> GetFeaturesByColumnValueCore(string columnName, string columnValue, IEnumerable`1<string> returningColumnNames);
    [CompilerGeneratedAttribute]
private bool <GetBoundingBoxCore>b__52_0(UiM= col);
    [CompilerGeneratedAttribute]
private bool <GetColumnsCore>b__53_0(UiM= c);
    [CompilerGeneratedAttribute]
private bool <GetDefaultCrs>b__61_0(UiM= col);
}
[AttributeUsageAttribute("64")]
public class ThinkGeo.Core.OnGeodeserializedAttribute : Attribute {
}
[AttributeUsageAttribute("64")]
public class ThinkGeo.Core.OnGeodeserializingAttribute : Attribute {
}
[AttributeUsageAttribute("64")]
public class ThinkGeo.Core.OnGeoserializedAttribute : Attribute {
}
[AttributeUsageAttribute("64")]
public class ThinkGeo.Core.OnGeoserializingAttribute : Attribute {
}
public class ThinkGeo.Core.OpenedFeatureSourceEventArgs : EventArgs {
}
public class ThinkGeo.Core.OpenedRasterSourceEventArgs : EventArgs {
}
public class ThinkGeo.Core.OpeningFeatureSourceEventArgs : EventArgs {
}
public class ThinkGeo.Core.OpeningRasterSourceEventArgs : EventArgs {
}
public class ThinkGeo.Core.OpenStreetMapAsyncLayer : XyzTileAsyncLayer {
    [ObfuscationAttribute]
private static int TILE_SIZE;
    [ObfuscationAttribute]
private static Uri[] DefaultUris;
    [ObfuscationAttribute]
private Collection`1<Uri> customServerUris;
    public Collection`1<Uri> CustomServerUris { get; }
    public OpenStreetMapAsyncLayer(string userAgent);
    public OpenStreetMapAsyncLayer(IWebProxy webProxy);
    public OpenStreetMapAsyncLayer(string userAgent, IWebProxy webProxy);
    private static OpenStreetMapAsyncLayer();
    [AsyncStateMachineAttribute("ThinkGeo.Core.OpenStreetMapAsyncLayer/<OpenAsyncCore>d__7")]
protected virtual Task OpenAsyncCore(CancellationToken cancellationToken);
    public Collection`1<Uri> get_CustomServerUris();
    protected virtual Task`1<string> GetImageUriAsyncCore(int zoomLevel, long x, long y, float resolutionFactor);
    [DebuggerHiddenAttribute]
[CompilerGeneratedAttribute]
private Task <>n__0(CancellationToken cancellationToken);
}
public class ThinkGeo.Core.OpenStreetMapsZoomLevelSet : ZoomLevelSet {
}
public class ThinkGeo.Core.OsmBuildingAreaStyle : BuildingAreaStyle {
    private string PzE=;
    private double QDE=;
    public string LevelColumnName { get; public set; }
    public double LevelHeightInMeters { get; public set; }
    public OsmBuildingAreaStyle(string levelColumnName);
    public OsmBuildingAreaStyle(string levelColumnName, double levelHeightInMeters);
    public string get_LevelColumnName();
    public void set_LevelColumnName(string value);
    public double get_LevelHeightInMeters();
    public void set_LevelHeightInMeters(double value);
    protected virtual Collection`1<string> GetRequiredColumnNamesCore();
    protected virtual double GetHeightInMeters(Feature feature);
}
public class ThinkGeo.Core.OsmBuildingOnlineFeatureLayer : FeatureLayer {
    public FileVectorTileCache TileCache { get; public set; }
    public void add_SendingWebRequest(EventHandler`1<SendingWebRequestEventArgs> value);
    public void remove_SendingWebRequest(EventHandler`1<SendingWebRequestEventArgs> value);
    public void add_SentWebRequest(EventHandler`1<SentWebRequestEventArgs> value);
    public void remove_SentWebRequest(EventHandler`1<SentWebRequestEventArgs> value);
    public FileVectorTileCache get_TileCache();
    public void set_TileCache(FileVectorTileCache value);
}
public class ThinkGeo.Core.OsmBuildingOnlineFeatureSource : FeatureSource {
    private static Collection`1<string> eiM=;
    private ciM= eyM=;
    [ObfuscationAttribute]
private FileVectorTileCache tileCache;
    [CompilerGeneratedAttribute]
private EventHandler`1<SendingWebRequestEventArgs> SendingWebRequest;
    [CompilerGeneratedAttribute]
private EventHandler`1<SentWebRequestEventArgs> SentWebRequest;
    public FileVectorTileCache TileCache { get; public set; }
    private static OsmBuildingOnlineFeatureSource();
    [CompilerGeneratedAttribute]
public void add_SendingWebRequest(EventHandler`1<SendingWebRequestEventArgs> value);
    [CompilerGeneratedAttribute]
public void remove_SendingWebRequest(EventHandler`1<SendingWebRequestEventArgs> value);
    [CompilerGeneratedAttribute]
public void add_SentWebRequest(EventHandler`1<SentWebRequestEventArgs> value);
    [CompilerGeneratedAttribute]
public void remove_SentWebRequest(EventHandler`1<SentWebRequestEventArgs> value);
    public FileVectorTileCache get_TileCache();
    public void set_TileCache(FileVectorTileCache value);
    protected virtual Collection`1<Feature> GetAllFeaturesCore(IEnumerable`1<string> returningColumnNames);
    protected virtual Collection`1<Feature> GetFeaturesByIdsCore(IEnumerable`1<string> ids, IEnumerable`1<string> returningColumnNames);
    protected virtual Collection`1<Feature> GetFeaturesInsideBoundingBoxCore(RectangleShape boundingBox, IEnumerable`1<string> returningColumnNames);
    internal ScreenPointF fCM=(double lon, double lat, int zoom);
    private Byte[] fSM=(string requestingUri);
    protected WebResponse SendWebRequest(WebRequest webRequest);
    protected virtual void OnSendingWebRequest(SendingWebRequestEventArgs e);
    protected virtual void OnSentWebRequest(SentWebRequestEventArgs e);
    protected virtual WebResponse SendWebRequestCore(WebRequest webRequest);
}
public enum ThinkGeo.Core.OverwriteMode : Enum {
    public int value__;
    public static OverwriteMode Overwrite;
    public static OverwriteMode DoNotOverwrite;
}
public enum ThinkGeo.Core.PanDirection : Enum {
    public int value__;
    public static PanDirection Up;
    public static PanDirection UpperRight;
    public static PanDirection Right;
    public static PanDirection LowerRight;
    public static PanDirection Down;
    public static PanDirection LowerLeft;
    public static PanDirection Left;
    public static PanDirection UpperLeft;
}
public class ThinkGeo.Core.PbfLayer : object {
    [CompilerGeneratedAttribute]
private string lR0=;
    [CompilerGeneratedAttribute]
private ulong 4xM=;
    [CompilerGeneratedAttribute]
private List`1<string> cys=;
    [CompilerGeneratedAttribute]
private ulong ViM=;
    [CompilerGeneratedAttribute]
private List`1<object> dCs=;
    [CompilerGeneratedAttribute]
private List`1<Byte[]> dSs=;
    public string Name { get; private set; }
    public ulong Version { get; private set; }
    public List`1<string> Keys { get; private set; }
    internal ulong eCs= { get; private set; }
    internal List`1<object> UCE= { get; private set; }
    internal List`1<Byte[]> fCs= { get; internal set; }
    public PbfLayer(Byte[] data);
    [CompilerGeneratedAttribute]
public string get_Name();
    [CompilerGeneratedAttribute]
private void set_Name(string value);
    [CompilerGeneratedAttribute]
public ulong get_Version();
    [CompilerGeneratedAttribute]
private void set_Version(ulong value);
    [CompilerGeneratedAttribute]
public List`1<string> get_Keys();
    [CompilerGeneratedAttribute]
private void set_Keys(List`1<string> value);
    [CompilerGeneratedAttribute]
internal ulong dis=();
    [CompilerGeneratedAttribute]
private void dys=(ulong value);
    [CompilerGeneratedAttribute]
internal List`1<object> TyE=();
    [CompilerGeneratedAttribute]
private void eSs=(List`1<object> value);
    [CompilerGeneratedAttribute]
internal List`1<Byte[]> eis=();
    [CompilerGeneratedAttribute]
internal void eys=(List`1<Byte[]> value);
    internal WSs= fSs=(int featureIndex);
    private void fis=(Byte[] data);
    private void fys=(Byte[] data);
}
public enum ThinkGeo.Core.PenBrushDrawingOrder : Enum {
    public int value__;
    public static PenBrushDrawingOrder BrushFirst;
    public static PenBrushDrawingOrder PenFirst;
}
public abstract class ThinkGeo.Core.PointBaseShape : BaseShape {
}
public abstract class ThinkGeo.Core.PointBaseStyle : Style {
    [ObfuscationAttribute]
private DrawingLevel drawingLevel;
    [ObfuscationAttribute]
private float rotationAngle;
    [ObfuscationAttribute]
private GeoPen symbolPen;
    [ObfuscationAttribute]
private float symbolSize;
    [ObfuscationAttribute]
private GeoBrush symbolBrush;
    [ObfuscationAttribute]
private float xOffsetInPixel;
    [ObfuscationAttribute]
private float yOffsetInPixel;
    [ObfuscationAttribute]
private Collection`1<PointBaseStyle> customPointStyles;
    public DrawingLevel DrawingLevel { get; public set; }
    public GeoBrush FillBrush { get; public set; }
    public GeoPen OutlinePen { get; public set; }
    public float SymbolSize { get; public set; }
    public float RotationAngle { get; public set; }
    public float XOffsetInPixel { get; public set; }
    public float YOffsetInPixel { get; public set; }
    public Collection`1<PointBaseStyle> CustomPointStyles { get; }
    protected PointBaseStyle(GeoBrush symbolBrush, int symbolSize);
    protected PointBaseStyle(GeoBrush symbolBrush, GeoPen symbolPen, int symbolSize);
    public DrawingLevel get_DrawingLevel();
    public void set_DrawingLevel(DrawingLevel value);
    public GeoBrush get_FillBrush();
    public void set_FillBrush(GeoBrush value);
    public GeoPen get_OutlinePen();
    public void set_OutlinePen(GeoPen value);
    public float get_SymbolSize();
    public void set_SymbolSize(float value);
    public float get_RotationAngle();
    public void set_RotationAngle(float value);
    public float get_XOffsetInPixel();
    public void set_XOffsetInPixel(float value);
    public float get_YOffsetInPixel();
    public void set_YOffsetInPixel(float value);
    public Collection`1<PointBaseStyle> get_CustomPointStyles();
    protected virtual void DrawSampleCore(GeoCanvas canvas, DrawingRectangleF drawingExtent);
}
public enum ThinkGeo.Core.PointLineRelationship : Enum {
    public int value__;
    public static PointLineRelationship Left;
    public static PointLineRelationship Right;
    public static PointLineRelationship OnLine;
}
[TypeConverterAttribute("ThinkGeo.Core.BaseShapeTypeConverter")]
public class ThinkGeo.Core.PointShape : PointBaseShape {
    [ObfuscationAttribute]
private double x;
    [ObfuscationAttribute]
private double y;
    [ObfuscationAttribute]
private double z;
    public double X { get; public set; }
    public double Y { get; public set; }
    public double Z { get; public set; }
    public PointShape(double x, double y);
    public PointShape(double x, double y, double z);
    public PointShape(Vertex vertex);
    public PointShape(string wellKnownText);
    public PointShape(Byte[] wellKnownBinary);
    public double get_X();
    public void set_X(double value);
    public double get_Y();
    public void set_Y(double value);
    public double get_Z();
    public void set_Z(double value);
    public bool Equal2D(PointShape targetShape);
    public bool Equal2D(Feature targetPointFeature);
    protected virtual BaseShape CloneDeepCore();
    protected virtual RectangleShape GetBoundingBoxCore();
    protected virtual BaseShape RegisterCore(PointShape fromPoint, PointShape toPoint, DistanceUnit fromUnit, GeographyUnit toUnit);
    protected virtual void TranslateByOffsetCore(double xOffsetDistance, double yOffsetDistance, GeographyUnit shapeUnit, DistanceUnit distanceUnit);
    protected virtual void TranslateByDegreeCore(double distance, double angleInDegrees, GeographyUnit shapeUnit, DistanceUnit distanceUnit);
    protected virtual void RotateCore(PointShape pivotPoint, double degreeAngle);
    protected virtual PointShape GetClosestPointToCore(BaseShape targetShape, GeographyUnit shapeUnit);
    protected virtual string GetWellKnownTextCore(RingOrder outerRingOrder);
    protected virtual WellKnownType GetWellKnownTypeCore();
    protected virtual void LoadFromWellKnownDataCore(string wellKnownText);
    protected virtual void LoadFromWellKnownDataCore(Byte[] wellKnownBinary);
    protected virtual ShapeValidationResult ValidateCore(ShapeValidationMode validationMode);
    public MultilineShape GreatCircle(PointShape pointShape);
    public MultilineShape GreatCircle(Feature pointFeature);
    protected virtual double GetDistanceToCore(BaseShape targetShape, GeographyUnit shapeUnit, DistanceUnit distanceUnit);
    protected virtual PointShape GetCenterPointCore();
    protected virtual MultipointShape GetCrossingCore(BaseShape targetShape);
    public virtual string ToString();
    protected virtual bool IsWithinCore(BaseShape targetShape);
    private double Khw=(RingShape ringShape, GeographyUnit shapeUnit, DistanceUnit distanceUnit);
    private double Kxw=(MultipolygonShape multipolygonShape, GeographyUnit shapeUnit, DistanceUnit distanceUnit);
    private double LBw=(MultipointShape targetShape, GeographyUnit shapeUnit, DistanceUnit distanceUnit);
    private double LRw=(MultilineShape targetShape, GeographyUnit shapeUnit, DistanceUnit distanceUnit);
    private double Lhw=(LineShape targetShape, GeographyUnit shapeUnit, DistanceUnit distanceUnit);
    private double Lxw=(RectangleShape rectangleShape, GeographyUnit shapeUnit, DistanceUnit distanceUnit);
    private double MBw=(PointShape targetShape, GeographyUnit shapeUnit, DistanceUnit distanceUnit);
    private double MRw=(PolygonShape polygonShape, GeographyUnit shapeUnit, DistanceUnit distanceUnit);
    private double Mhw=(PointShape toPointShape);
    internal double Mxw=(double fromPointX, double fromPointY, double toPointX, double toPointY);
    internal PointShape NBw=(double fromX, double fromY, double toX, double toY);
    private PointShape NRw=(double offset, float degree);
}
public class ThinkGeo.Core.PointStyle : PointBaseStyle {
    private static int 2Sk=;
    private static int /xQ=;
    private static int ARU=;
    private static int AhU=;
    private static int AxU=;
    private static int ABU=;
    private static double 3Ck=;
    private static int BhU=;
    private static int BBU=;
    private static int 3Sk=;
    private static int 3ik=;
    private static int 1yk=;
    private static int 2Ck=;
    [ObfuscationAttribute]
private GeoFont glyphFont;
    [ObfuscationAttribute]
private GeoImage image;
    [ObfuscationAttribute]
private double imageScale;
    [ObfuscationAttribute]
private PointSymbolType symbolType;
    [ObfuscationAttribute]
private PointType pointType;
    [ObfuscationAttribute]
private AreaStyle mask;
    [ObfuscationAttribute]
private DrawingMargin maskMargin;
    [ObfuscationAttribute]
private MaskType maskType;
    [ObfuscationAttribute]
private string glyphContent;
    private static GeoFont tTA=;
    public PointType PointType { get; public set; }
    public GeoImage Image { get; public set; }
    public double ImageScale { get; public set; }
    public GeoFont GlyphFont { get; public set; }
    public string GlyphContent { get; public set; }
    public PointSymbolType SymbolType { get; public set; }
    public AreaStyle Mask { get; public set; }
    public DrawingMargin MaskMargin { get; public set; }
    public MaskType MaskType { get; public set; }
    internal bool fBU= { get; }
    public PointStyle(GeoImage image);
    public PointStyle(GeoFont glyphFont, string glyphContent, GeoBrush fillBrush);
    public PointStyle(GeoFont glyphFont, string glyphContent, GeoBrush fillBrush, GeoPen outlinePen);
    public PointStyle(PointSymbolType symbolType, int symbolSize, GeoBrush fillBrush);
    public PointStyle(PointSymbolType symbolType, int symbolSize, GeoBrush fillBrush, GeoPen outlinePen);
    private PointStyle(GeoImage image, GeoFont glyphFont, PointType pointType, PointSymbolType pointSymbolType, GeoBrush geoBrush, GeoPen symbolPen, int symbolSize);
    private static PointStyle();
    public PointType get_PointType();
    public void set_PointType(PointType value);
    public GeoImage get_Image();
    public void set_Image(GeoImage value);
    public double get_ImageScale();
    public void set_ImageScale(double value);
    public GeoFont get_GlyphFont();
    public void set_GlyphFont(GeoFont value);
    public string get_GlyphContent();
    public void set_GlyphContent(string value);
    public PointSymbolType get_SymbolType();
    public void set_SymbolType(PointSymbolType value);
    public AreaStyle get_Mask();
    public void set_Mask(AreaStyle value);
    public DrawingMargin get_MaskMargin();
    public void set_MaskMargin(DrawingMargin value);
    public MaskType get_MaskType();
    public void set_MaskType(MaskType value);
    public static PointStyle Parse(string styleJson);
    internal static PointStyle ahU=(JObject jObject);
    public static PointStyle CreateSimplePointStyle(PointSymbolType pointStyle, GeoColor fillColor, float size);
    public static PointStyle CreateSimplePointStyle(PointSymbolType pointStyle, GeoColor fillColor, GeoColor outlineColor, float outlineWidth, float size);
    public static PointStyle CreateSimplePointStyle(PointSymbolType pointStyle, GeoColor fillColor, GeoColor outlineColor, float size);
    public static PointStyle CreateSimpleCircleStyle(GeoColor fillColor, float size);
    public static PointStyle CreateSimpleCircleStyle(GeoColor fillColor, float size, GeoColor outlineColor, float outlineWidth);
    public static PointStyle CreateSimpleCircleStyle(GeoColor fillColor, float size, GeoColor outlineColor);
    public static PointStyle CreateSimpleSquareStyle(GeoColor fillColor, float size);
    public static PointStyle CreateSimpleSquareStyle(GeoColor fillColor, float size, GeoColor outlineColor);
    public static PointStyle CreateSimpleSquareStyle(GeoColor fillColor, float size, GeoColor outlineColor, float outlineWidth);
    public static PointStyle CreateSimpleStarStyle(GeoColor fillColor, float size);
    public static PointStyle CreateSimpleStarStyle(GeoColor fillColor, float size, GeoColor outlineColor);
    public static PointStyle CreateSimpleStarStyle(GeoColor fillColor, float size, GeoColor outlineColor, float outlineWidth);
    public static PointStyle CreateSimpleTriangleStyle(GeoColor fillColor, float size);
    public static PointStyle CreateSimpleTriangleStyle(GeoColor fillColor, float size, GeoColor outlineColor);
    public static PointStyle CreateSimpleTriangleStyle(GeoColor fillColor, float size, GeoColor outlineColor, float outlineWidth);
    public static PointStyle CreateCompoundCircleStyle(GeoColor fillColor1, float size1, GeoColor outlineColor1, float outlineWidth1, GeoColor fillColor2, float size2);
    public static PointStyle CreateCompoundCircleStyle(GeoColor fillColor1, float size1, GeoColor outlineColor1, float outlineWidth1, GeoColor fillColor2, float size2, GeoColor outlineColor2, float outlineWidth2);
    public static PointStyle CreateCompoundPointStyle(PointSymbolType pointStyle1, GeoColor fillColor1, GeoColor outlineColor1, float outlineWidth1, float size1, PointSymbolType pointStyle2, GeoColor fillColor2, GeoColor outlineColor2, float outlineWidth2, float size2);
    internal virtual bool ehU=();
    protected virtual void DrawCore(IEnumerable`1<Feature> features, GeoCanvas canvas, Collection`1<SimpleCandidate> labelsInThisLayer, Collection`1<SimpleCandidate> labelsInAllLayers);
    protected virtual void DrawSampleCore(GeoCanvas canvas, DrawingRectangleF drawingExtent);
    protected void DrawSymbol(PointSymbolType symbolType, Feature feature, GeoCanvas canvas, GeoBrush geoBrush, GeoPen geoPen, float symbolSize, float rotationAngle);
    protected void DrawImage(GeoImage geoImage, Feature feature, GeoCanvas canvas, float symbolSize, float rotationAngle);
    private void 7Ck=(GeoImage image, PointShape point, GeoCanvas canvas, float symbolSize, float rotationAngle);
    private void qyA=(GeoCanvas canvas, float screenX, float screenY, float width, float height, float rotationAngle);
    protected void DrawGlyph(GeoFont glyphFont, string glyphConent, Feature pointFeature, GeoCanvas canvas, GeoBrush geoBrush, GeoPen geoPen, float symbolSize, float rotationAngle);
    private PolygonShape tjA=(Vertex[] maskAreaVertexs, Vertex pivotLowerCenterPoint, double angle, bool isStraight);
    private void tzA=(GeoFont glyphFont, string glyphConent, PointShape point, GeoCanvas canvas, GeoBrush geoBrush, GeoPen haloPen, float rotationAngle);
    private void 9Sk=(Feature feature, GeoCanvas canvas, GeoPen geoPen, GeoBrush geoBrush, float symbolSize, float rotationAngle);
    private void 6ik=(Feature feature, GeoCanvas canvas, GeoPen geoPen, GeoBrush geoBrush, float symbolSize, double rotationAngle);
    private void 8yk=(Feature feature, GeoCanvas canvas, GeoPen geoPen, GeoBrush geoBrush, float symbolSize, float rotationAngle);
    private void 8Sk=(Feature feature, GeoCanvas canvas, GeoPen geoPen, float symbolSize, float rotationAngle);
    private void uDA=(Feature feature, GeoCanvas canvas, GeoPen geoPen, GeoBrush geoBrush, float symbolSize, float rotationAngle, Action`7<double, double, GeoCanvas, GeoPen, GeoBrush, double, double> drawAction);
    private int 7ik=(Byte[] centerPointWkb, int startIndex, GeoCanvas canvas, GeoPen geoPen, GeoBrush geoBrush, double symbolSize, double rotationAngle);
    private int 9ik=(Byte[] centerPointWkb, int startIndex, GeoCanvas canvas, GeoPen geoPen, GeoBrush geoBrush, float symbolSize, float rotationAngle);
    private void uTA=(double centerWorldX, double centerWorldY, GeoCanvas canvas, GeoPen geoPen, GeoBrush fillBrush, double symbolSize, double rotationAngle);
    private void ujA=(double centerWorldX, double centerWorldY, GeoCanvas canvas, GeoPen geoPen, GeoBrush fillBrush, double symbolSize, double rotationAngle);
    private void uzA=(double centerWorldX, double centerWorldY, GeoCanvas canvas, GeoPen geoPen, GeoBrush fillBrush, double symbolSize, double rotationAngle, Double[] angles);
    private Byte[] vDA=(IEnumerable`1<PointShape> worldPoints);
    private int 8ik=(Byte[] centerPointWkb, int startIndex, GeoCanvas canvas, GeoPen geoPen, float symbolSize, float rotationAngle);
    private bool /Ck=(double screenX, double screenY, float canvasWidth, float canvasHeight);
    private static void QR0=(Byte[] sourceArray, Byte[] destinateArray, long destinateIndex);
    private static IEnumerable`1<Vertex> vTA=(Vertex startPoint, Vertex pivot, float radius);
    private static IEnumerable`1<Vertex> vjA=(Vertex startPoint, Vertex pivot, float radius);
    private static Vertex vzA=(Vertex startPoint, Vertex pivot, double angle, float radius);
    private static int FBU=(Byte[] wkb, int startIndex, byte byteOrder);
    private static double FRU=(Byte[] wkb, int startIndex, byte byteOrder);
    private static WkbShapeType wDA=(Byte[] wkb, int startIndex);
    private static GeoFont wTA=(String[] valueExpressions);
    private static GeoPen wjA=(String[] valueExpressions);
    private static GeoBrush wzA=(String[] valueExpressions);
    private static AreaStyle xDA=(String[] valueExpressions);
}
public enum ThinkGeo.Core.PointSymbolType : Enum {
    public int value__;
    public static PointSymbolType Circle;
    public static PointSymbolType Square;
    public static PointSymbolType Triangle;
    public static PointSymbolType Cross;
    public static PointSymbolType DiamondNarrow;
    public static PointSymbolType Diamond;
    public static PointSymbolType Star;
    public static PointSymbolType StarCircled;
    public static PointSymbolType CrossArrow;
    public static PointSymbolType BidirectionalArrow;
}
public enum ThinkGeo.Core.PointType : Enum {
    public int value__;
    public static PointType Symbol;
    public static PointType Image;
    public static PointType Glyph;
}
public enum ThinkGeo.Core.PolygonLabelingLocationMode : Enum {
    public int value__;
    public static PolygonLabelingLocationMode Default;
    public static PolygonLabelingLocationMode Centroid;
    public static PolygonLabelingLocationMode BoundingBoxCenter;
}
[TypeConverterAttribute("ThinkGeo.Core.BaseShapeTypeConverter")]
public class ThinkGeo.Core.PolygonShape : AreaBaseShape {
    [ObfuscationAttribute]
private RingShape outerRing;
    [ObfuscationAttribute]
private Collection`1<RingShape> innerRings;
    public RingShape OuterRing { get; public set; }
    public Collection`1<RingShape> InnerRings { get; }
    public PolygonShape(RingShape outerRing);
    public PolygonShape(RingShape outerRing, IEnumerable`1<RingShape> innerRings);
    public PolygonShape(string wellKnownText);
    public PolygonShape(Byte[] wellKnownBinary);
    public RingShape get_OuterRing();
    public void set_OuterRing(RingShape value);
    public Collection`1<RingShape> get_InnerRings();
    protected virtual WellKnownType GetWellKnownTypeCore();
    protected virtual BaseShape CloneDeepCore();
    protected virtual double GetPerimeterCore(GeographyUnit shapeUnit, DistanceUnit returningUnit);
    protected virtual double GetAreaCore(GeographyUnit shapeUnit, AreaUnit returningUnit);
    protected virtual void ScaleUpCore(double percentage);
    protected virtual void ScaleDownCore(double percentage);
    protected virtual BaseShape RegisterCore(PointShape fromPoint, PointShape toPoint, DistanceUnit fromUnit, GeographyUnit toUnit);
    protected virtual void TranslateByOffsetCore(double xOffsetDistance, double yOffsetDistance, GeographyUnit shapeUnit, DistanceUnit distanceUnit);
    protected virtual void TranslateByDegreeCore(double distance, double angleInDegrees, GeographyUnit shapeUnit, DistanceUnit distanceUnit);
    protected virtual void RotateCore(PointShape pivotPoint, double degreeAngle);
    protected virtual PointShape GetClosestPointToCore(BaseShape targetShape, GeographyUnit shapeUnit);
    protected virtual double GetDistanceToCore(BaseShape targetShape, GeographyUnit shapeUnit, DistanceUnit distanceUnit);
    protected virtual string GetWellKnownTextCore(RingOrder outerRingOrder);
    protected virtual Byte[] GetWellKnownBinaryCore(RingOrder outerRingOrder, WkbByteOrder byteOrder);
    protected virtual void LoadFromWellKnownDataCore(string wellKnownText);
    protected virtual void LoadFromWellKnownDataCore(Byte[] wellKnownBinary);
    protected virtual ShapeValidationResult ValidateCore(ShapeValidationMode validationMode);
    protected virtual RectangleShape GetBoundingBoxCore();
    protected virtual MultipointShape GetCrossingCore(BaseShape targetShape);
    public static bool RemoveVertex(Vertex selectedVertex, PolygonShape polygonShape);
    public bool RemoveVertex(Vertex selectedVertex);
    public MultilineShape ToMultiLineShape();
    internal void JBU=(double multiplicator);
    private static void Jxw=(RingShape targetRingShape, WkbByteOrder byteOrder, BinaryWriter writer);
    private static void JRw=(RingShape targetRingShape, WkbByteOrder byteOrder, BinaryWriter writer);
    private static void Nhw=(RingShape ringShape, StringBuilder wellKnownText);
    private static void Nxw=(RingShape ringShape, StringBuilder wellKnownText);
    private static void OBw=(PolygonShape targetPolygon);
    private static void ORw=(PolygonShape fromPolygon, PolygonShape toPolygon);
    internal static MultilineShape Ohw=(PolygonShape polygonShape);
    internal bool Oxw=();
}
public abstract class ThinkGeo.Core.PositionStyle : Style {
    private static Regex xTA=;
    [ObfuscationAttribute]
private bool allowLineCarriage;
    [ObfuscationAttribute]
private bool allowSpline;
    [ObfuscationAttribute]
private WellKnownType currentShapeWellKnownType;
    [ObfuscationAttribute]
private Collection`1<TextStyle> customTextStyles;
    [ObfuscationAttribute]
private string dateFormat;
    [ObfuscationAttribute]
private DrawingLevel drawingLevel;
    [ObfuscationAttribute]
private bool fittingPolygon;
    [ObfuscationAttribute]
private double fittingPolygonFactor;
    [ObfuscationAttribute]
private GeoFont font;
    [ObfuscationAttribute]
private bool forceHorizontalLabelForLine;
    [ObfuscationAttribute]
private bool forceLineCarriage;
    [ObfuscationAttribute]
private PolygonLabelingLocationMode polygonLabelingLocationMode;
    [ObfuscationAttribute]
private int gridSize;
    [ObfuscationAttribute]
private GeoPen haloPen;
    [ObfuscationAttribute]
private bool labelAllPolygonParts;
    [ObfuscationAttribute]
private bool labelAllLineParts;
    [ObfuscationAttribute]
private LabelDuplicateRule duplicateRule;
    [ObfuscationAttribute]
private LabelOverlappingRule overlappingRule;
    [ObfuscationAttribute]
private bool allowLabelNudging;
    [ObfuscationAttribute]
private Dictionary`2<string, WorldLabelingCandidate> labelPositions;
    [ObfuscationAttribute]
private AreaStyle mask;
    [ObfuscationAttribute]
private double maxAdjacentCharDeltaAngle;
    [ObfuscationAttribute]
private DrawingMargin maskMargin;
    [ObfuscationAttribute]
private MaskType maskType;
    [ObfuscationAttribute]
private string numericFormat;
    [ObfuscationAttribute]
private TextPlacement textPlacement;
    [ObfuscationAttribute]
private bool fittingLineInScreen;
    [ObfuscationAttribute]
private bool fittingPolygonInScreen;
    [ObfuscationAttribute]
private double rotationAngle;
    [ObfuscationAttribute]
private SplineType splineType;
    [ObfuscationAttribute]
private bool suppressPartialLabels;
    [ObfuscationAttribute]
private string textColumnName;
    [ObfuscationAttribute]
private string textFormat;
    [ObfuscationAttribute]
private double textLineSegmentRatio;
    [ObfuscationAttribute]
private GeoBrush textBrush;
    [ObfuscationAttribute]
private float xOffsetInPixel;
    [ObfuscationAttribute]
private float yOffsetInPixel;
    [ObfuscationAttribute]
private int maxNudgingInPixel;
    [ObfuscationAttribute]
private float nudgingIntervalInPixel;
    [ObfuscationAttribute]
private Dictionary`2<string, string> abbreviationDictionary;
    [ObfuscationAttribute]
private float bestPlacementSymbolWidth;
    [ObfuscationAttribute]
private float bestPlacementSymbolHeight;
    [ObfuscationAttribute]
private LineStyle leaderLineStyle;
    [ObfuscationAttribute]
private LabelLeaderLinesRule leaderLineRule;
    [ObfuscationAttribute]
private float leaderLineMinimumLengthInPixels;
    [ObfuscationAttribute]
private DrawingTextAlignment alignment;
    [ObfuscationAttribute]
private DrawingTextLetterCase letterCase;
    [ObfuscationAttribute]
private double maxCharAngleDelta;
    [ObfuscationAttribute]
private double minDistance;
    [ObfuscationAttribute]
private double spacing;
    [ObfuscationAttribute]
private double wrapWidth;
    [ObfuscationAttribute]
private PointStyle basePoint;
    [ObfuscationAttribute]
private string textContent;
    [ObfuscationAttribute]
private String[] tempColumnNames;
    [ObfuscationAttribute]
private bool isSplinedText;
    [ObfuscationAttribute]
private double textLetterSpacing;
    [ObfuscationAttribute]
private DrawingTextBaseline textBaseline;
    [ObfuscationAttribute]
private float textLineSpacing;
    [ObfuscationAttribute]
private bool allowOverlapping;
    [ObfuscationAttribute]
private bool drawBasePointWithoutText;
    [ObfuscationAttribute]
private bool isStyleJsonStyle;
    [CompilerGeneratedAttribute]
private EventHandler`1<FormattingPositionStyleEventArgs> Formatting;
    [CompilerGeneratedAttribute]
private EventHandler`1<FormattedPositionStyleEventArgs> Formatted;
    [ObfuscationAttribute]
private ConcurrentDictionary`2<string, DrawingRectangleF> _cachedCharSize;
    protected Dictionary`2<string, WorldLabelingCandidate> LabelPositions { get; }
    public PolygonLabelingLocationMode PolygonLabelingLocationMode { get; public set; }
    public int MaxNudgingInPixel { get; public set; }
    public float NudgingIntervalInPixel { get; public set; }
    public float BestPlacementSymbolWidth { get; public set; }
    public float BestPlacementSymbolHeight { get; public set; }
    public Dictionary`2<string, string> AbbreviationDictionary { get; public set; }
    public LineStyle LeaderLineStyle { get; public set; }
    public LabelLeaderLinesRule LeaderLineRule { get; public set; }
    public float LeaderLineMinimumLengthInPixels { get; public set; }
    protected float XOffsetInPixel { get; protected set; }
    protected float YOffsetInPixel { get; protected set; }
    public int GridSize { get; public set; }
    protected Collection`1<TextStyle> CustomTextStyles { get; }
    protected double RotationAngle { get; protected set; }
    protected bool FittingLineInScreen { get; protected set; }
    protected bool FittingPolygonInScreen { get; protected set; }
    protected string TextFormat { get; protected set; }
    protected string NumericFormat { get; protected set; }
    protected string DateFormat { get; protected set; }
    protected GeoBrush TextBrush { get; protected set; }
    protected GeoFont Font { get; protected set; }
    protected GeoPen HaloPen { get; protected set; }
    protected string TextColumnName { get; protected set; }
    protected AreaStyle Mask { get; protected set; }
    protected DrawingMargin MaskMargin { get; protected set; }
    public LabelDuplicateRule DuplicateRule { get; public set; }
    public LabelOverlappingRule OverlappingRule { get; public set; }
    public bool AllowLabelNudging { get; public set; }
    protected bool AllowSpline { get; protected set; }
    public bool AllowLineCarriage { get; public set; }
    public bool SuppressPartialLabels { get; public set; }
    public bool ForceLineCarriage { get; public set; }
    public bool FittingPolygon { get; public set; }
    public bool LabelAllPolygonParts { get; public set; }
    public bool LabelAllLineParts { get; public set; }
    protected bool ForceHorizontalLabelForLine { get; protected set; }
    public double FittingPolygonFactor { get; public set; }
    public double TextLineSegmentRatio { get; public set; }
    public TextPlacement TextPlacement { get; public set; }
    protected SplineType SplineType { get; protected set; }
    protected DrawingLevel DrawingLevel { get; protected set; }
    internal bool fBU= { get; }
    public MaskType MaskType { get; public set; }
    protected DrawingTextAlignment Alignment { get; protected set; }
    protected DrawingTextLetterCase LetterCase { get; protected set; }
    protected double MaxCharAngleDelta { get; protected set; }
    protected double MinDistance { get; protected set; }
    protected double Spacing { get; protected set; }
    protected double WrapWidth { get; protected set; }
    protected PointStyle BasePoint { get; protected set; }
    internal bool yDA= { get; internal set; }
    public string TextContent { get; public set; }
    internal double yzA= { get; internal set; }
    internal DrawingTextBaseline zjA= { get; internal set; }
    internal float 0TA= { get; internal set; }
    internal bool 1DA= { get; internal set; }
    internal bool 1zA= { get; internal set; }
    public double MaxAdjacentCharDeltaAngle { get; public set; }
    private static PositionStyle();
    [CompilerGeneratedAttribute]
public void add_Formatting(EventHandler`1<FormattingPositionStyleEventArgs> value);
    [CompilerGeneratedAttribute]
public void remove_Formatting(EventHandler`1<FormattingPositionStyleEventArgs> value);
    [CompilerGeneratedAttribute]
public void add_Formatted(EventHandler`1<FormattedPositionStyleEventArgs> value);
    [CompilerGeneratedAttribute]
public void remove_Formatted(EventHandler`1<FormattedPositionStyleEventArgs> value);
    protected Dictionary`2<string, WorldLabelingCandidate> get_LabelPositions();
    public PolygonLabelingLocationMode get_PolygonLabelingLocationMode();
    public void set_PolygonLabelingLocationMode(PolygonLabelingLocationMode value);
    public int get_MaxNudgingInPixel();
    public void set_MaxNudgingInPixel(int value);
    public float get_NudgingIntervalInPixel();
    public void set_NudgingIntervalInPixel(float value);
    public float get_BestPlacementSymbolWidth();
    public void set_BestPlacementSymbolWidth(float value);
    public float get_BestPlacementSymbolHeight();
    public void set_BestPlacementSymbolHeight(float value);
    public Dictionary`2<string, string> get_AbbreviationDictionary();
    public void set_AbbreviationDictionary(Dictionary`2<string, string> value);
    public LineStyle get_LeaderLineStyle();
    public void set_LeaderLineStyle(LineStyle value);
    public LabelLeaderLinesRule get_LeaderLineRule();
    public void set_LeaderLineRule(LabelLeaderLinesRule value);
    public float get_LeaderLineMinimumLengthInPixels();
    public void set_LeaderLineMinimumLengthInPixels(float value);
    protected float get_XOffsetInPixel();
    protected void set_XOffsetInPixel(float value);
    protected float get_YOffsetInPixel();
    protected void set_YOffsetInPixel(float value);
    public int get_GridSize();
    public void set_GridSize(int value);
    protected Collection`1<TextStyle> get_CustomTextStyles();
    protected double get_RotationAngle();
    protected void set_RotationAngle(double value);
    protected bool get_FittingLineInScreen();
    protected void set_FittingLineInScreen(bool value);
    protected bool get_FittingPolygonInScreen();
    protected void set_FittingPolygonInScreen(bool value);
    protected string get_TextFormat();
    protected void set_TextFormat(string value);
    protected string get_NumericFormat();
    protected void set_NumericFormat(string value);
    protected string get_DateFormat();
    protected void set_DateFormat(string value);
    protected GeoBrush get_TextBrush();
    protected void set_TextBrush(GeoBrush value);
    protected GeoFont get_Font();
    protected void set_Font(GeoFont value);
    protected GeoPen get_HaloPen();
    protected void set_HaloPen(GeoPen value);
    protected string get_TextColumnName();
    protected void set_TextColumnName(string value);
    protected AreaStyle get_Mask();
    protected void set_Mask(AreaStyle value);
    protected DrawingMargin get_MaskMargin();
    protected void set_MaskMargin(DrawingMargin value);
    public LabelDuplicateRule get_DuplicateRule();
    public void set_DuplicateRule(LabelDuplicateRule value);
    public LabelOverlappingRule get_OverlappingRule();
    public void set_OverlappingRule(LabelOverlappingRule value);
    public bool get_AllowLabelNudging();
    public void set_AllowLabelNudging(bool value);
    protected bool get_AllowSpline();
    protected void set_AllowSpline(bool value);
    public bool get_AllowLineCarriage();
    public void set_AllowLineCarriage(bool value);
    public bool get_SuppressPartialLabels();
    public void set_SuppressPartialLabels(bool value);
    public bool get_ForceLineCarriage();
    public void set_ForceLineCarriage(bool value);
    public bool get_FittingPolygon();
    public void set_FittingPolygon(bool value);
    public bool get_LabelAllPolygonParts();
    public void set_LabelAllPolygonParts(bool value);
    public bool get_LabelAllLineParts();
    public void set_LabelAllLineParts(bool value);
    protected bool get_ForceHorizontalLabelForLine();
    protected void set_ForceHorizontalLabelForLine(bool value);
    public double get_FittingPolygonFactor();
    public void set_FittingPolygonFactor(double value);
    public double get_TextLineSegmentRatio();
    public void set_TextLineSegmentRatio(double value);
    public TextPlacement get_TextPlacement();
    public void set_TextPlacement(TextPlacement value);
    protected SplineType get_SplineType();
    protected void set_SplineType(SplineType value);
    protected DrawingLevel get_DrawingLevel();
    protected void set_DrawingLevel(DrawingLevel value);
    internal virtual bool ehU=();
    public MaskType get_MaskType();
    public void set_MaskType(MaskType value);
    protected DrawingTextAlignment get_Alignment();
    protected void set_Alignment(DrawingTextAlignment value);
    protected DrawingTextLetterCase get_LetterCase();
    protected void set_LetterCase(DrawingTextLetterCase value);
    protected double get_MaxCharAngleDelta();
    protected void set_MaxCharAngleDelta(double value);
    protected double get_MinDistance();
    protected void set_MinDistance(double value);
    protected double get_Spacing();
    protected void set_Spacing(double value);
    protected double get_WrapWidth();
    protected void set_WrapWidth(double value);
    protected PointStyle get_BasePoint();
    protected void set_BasePoint(PointStyle value);
    internal bool xjA=();
    internal void xzA=(bool value);
    public string get_TextContent();
    public void set_TextContent(string value);
    internal double yTA=();
    internal void yjA=(double value);
    internal DrawingTextBaseline zDA=();
    internal void zTA=(DrawingTextBaseline value);
    internal float zzA=();
    internal void 0DA=(float value);
    internal bool 0jA=();
    internal void 0zA=(bool value);
    internal bool 1TA=();
    internal void 1jA=(bool value);
    public double get_MaxAdjacentCharDeltaAngle();
    public void set_MaxAdjacentCharDeltaAngle(double value);
    protected void DrawMask(LabelingCandidate labelingCandidate, GeoCanvas canvas, Collection`1<SimpleCandidate> labelsInThisLayer, Collection`1<SimpleCandidate> labelsInAllLayers);
    protected virtual void DrawCore(IEnumerable`1<Feature> features, GeoCanvas canvas, Collection`1<SimpleCandidate> labelsInThisLayer, Collection`1<SimpleCandidate> labelsInAllLayers);
    protected virtual Collection`1<string> GetRequiredColumnNamesCore();
    protected internal Collection`1<Feature> FilterFeatures(IEnumerable`1<Feature> features, GeoCanvas canvas);
    protected virtual Collection`1<Feature> FilterFeaturesCore(IEnumerable`1<Feature> features, GeoCanvas canvas);
    protected void AbbreviateText(Feature feature, GeoCanvas canvas);
    protected virtual void AbbreviateTextCore(Feature feature, GeoCanvas canvas);
    protected Collection`1<LabelingCandidate> GetLabelingCandidates(Feature feature, GeoCanvas canvas, GeoFont font, float xOffsetInPixel, float yOffsetInPixel, double rotationAngle);
    protected virtual Collection`1<LabelingCandidate> GetLabelingCandidateCore(Feature feature, GeoCanvas canvas, GeoFont font, float xOffsetInPixel, float yOffsetInPixel, double rotationAngle);
    private void 2DA=(PointShape point, GeoFont font, GeoCanvas canvas, DrawingTextBaseline textBaseline, string text, double angle);
    internal DrawingRectangleF 2TA=(GeoCanvas canvas, string text, GeoFont font);
    public string WrapText(string text, GeoFont font, GeoCanvas canvas);
    private string 2jA=(string text);
    protected bool CheckDuplicate(LabelingCandidate labelingCandidate, GeoCanvas canvas, Collection`1<SimpleCandidate> labelsInThisLayer, Collection`1<SimpleCandidate> labelsInAllLayers);
    protected virtual bool CheckDuplicateCore(LabelingCandidate labelingCandidate, GeoCanvas canvas, Collection`1<SimpleCandidate> labelsInThisLayer, Collection`1<SimpleCandidate> labelsInAllLayers);
    private static bool 2zA=(Collection`1<SimpleCandidate> labelCandidates, LabelingCandidate currentLabelCandidate);
    private static bool 3DA=(Collection`1<SimpleCandidate> labelCandidates, LabelingCandidate currentLabelCandidate, ScreenPointF ulPointF, ScreenPointF lrPointF);
    protected bool CheckOverlapping(LabelingCandidate labelingCandidate, GeoCanvas canvas, GeoFont font, float xOffsetInPixel, float yOffsetInPixel, double rotationAngle, Collection`1<SimpleCandidate> labelsInThisLayer, Collection`1<SimpleCandidate> labelsInAllLayers);
    protected virtual bool CheckOverlappingCore(LabelingCandidate labelingCandidate, GeoCanvas canvas, Collection`1<SimpleCandidate> labelsInThisLayer, Collection`1<SimpleCandidate> labelsInAllLayers);
    protected static BaseShape ConvertToScreenShape(Feature feature, GeoCanvas canvas);
    protected virtual void DrawSampleCore(GeoCanvas canvas, DrawingRectangleF drawingExtent);
    protected virtual Style CloneDeepCore();
    private bool 3TA=(Collection`1<SimpleCandidate> labelInThisLayer, Collection`1<SimpleCandidate> labelsInAllLayer, LabelingCandidate currentLabelCandidate);
    private ScreenPointF 3jA=(PointShape point);
    private FeatureLabelingCandidate 3zA=(Feature feature, GeoCanvas canvas, GeoFont font, float xOffsetInPixel, float yOffsetInPixel, double rotationAngle);
    private ScreenPointF[] 4DA=(ScreenPointF[] textPathInScreen, DrawingTextAlignment alignment, double drawingRectangleWidth, float drawingTextWidth, int drawingTextLinesCount);
    private Collection`1<LabelingCandidate> 4TA=(MultilineShape multilineShape, string text, GeoFont font, float xOffsetInPixel, float yOffsetInPixel, GeoCanvas canvas, double rotationAngle);
    private Collection`1<LabelingCandidate> 4jA=(MultilineShape multiLineShape, njA= lineLabelAdjuster, string text, GeoFont font, float xOffsetInPixel, float yOffsetInPixel, double rotationAngle, GeoCanvas canvas, RectangleShape screenExtent, bool allowLineLabelingMoving);
    private Collection`1<LabelingCandidate> 4zA=(MultilineShape multilineShape, njA= lineLabelAdjuster, string text, GeoFont font, float xOffsetInPixel, float yOffsetInPixel, double rotationAngle, GeoCanvas canvas, string labelText, double width, double height, RectangleShape screenExtent, bool allowLineLabelingMoving);
    private ValueTuple`2<LineShape, LineShape> 5DA=(LineShape lineShape);
    private LabelingCandidate 5TA=(njA= lineLabelAdjuster, string text, GeoFont font, float xOffsetInPixel, float yOffsetInPixel, GeoCanvas canvas, string labelText, double width, double height);
    private float 5jA=(GeoCanvas canvas);
    private Collection`1<LabelingCandidate> 5zA=(MultilineShape multiLineShape, njA= lineLabelAdjuster, string text, GeoFont font, float xOffsetInPixel, float yOffsetInPixel, double rotationAngle, GeoCanvas canvas, RectangleShape screenExtent, bool allowLineLabelingMoving);
    private Collection`1<LabelingCandidate> 6DA=(MultilineShape multiLineShape, njA= lineLabelAdjuster, GeoCanvas canvas, string text, string labelText, GeoFont font, float xOffsetInPixel, float yOffsetInPixel, double rotationAngle, double width, double height, RectangleShape screenExtent, bool allowLineLabelingMoving);
    private LabelingCandidate 6TA=(njA= lineLabelAdjuster, GeoCanvas canvas, string text, string labelText, double width, double height, double xOffsetInPixel, double yOffsetInPixel);
    private Collection`1<LabelingCandidate> 6jA=(MultilineShape multilineShape, string text, GeoFont font, float xOffsetInPixel, float yOffsetInPixel, GeoCanvas canvas, double rotationAngle);
    private Collection`1<LabelingCandidate> 6zA=(LineShape lineShape, double labelWidth, double lineLength, string text, GeoCanvas canvas, GeoFont font, float xOffsetInPixel, float yOffsetInPixel, double rotationAngle);
    private Collection`1<LabelingCandidate> 7DA=(LineShape lineShape, double labelWidth, double lineLength, string text, GeoCanvas canvas, GeoFont font, float xOffsetInPixel, float yOffsetInPixel, double rotationAngle);
    private static StartingPoint 7TA=(StartingPoint startingPoint);
    private LabelingCandidate 6jA=(LineShape lineShape, double lineLength, string text, GeoCanvas canvas, GeoFont font, float xOffsetInPixel, float yOffsetInPixel);
    private static ValueTuple`2<PointShape, double> 7jA=(PointShape centerPointForLabel, IGeoCanvasRotatable rotatableGeoCanvas, double angle);
    private static Collection`1<LabelInformation> 7zA=(string text, Collection`1<LabelInformation> labelInformationCollection, IGeoCanvasRotatable rotatableGeoCanvas);
    private static double 8DA=(double angle, double canvasRotationAngle);
    private static bool 8TA=(double angle);
    private DrawingRectangleF 8jA=(GeoCanvas canvas, GeoFont font, char centerText);
    private PolygonShape 8zA=(string text, GeoCanvas canvas, GeoFont font, float xOffsetInPixel, float yOffsetInPixel, DrawingRectangleF firstSize, PointShape firstPoint, PointShape secondPoint, double firstAngle, PointShape& centerPointForLabel);
    private Collection`1<DrawingRectangleF> 9DA=(string labelText, GeoCanvas canvas, GeoFont font);
    private LabelingCandidate 9TA=(Collection`1<PointShape> coordinates, string text, GeoFont font, float xOffsetInPixel, float yOffsetInPixel, GeoCanvas canvas);
    private bool 9jA=(Collection`1<PointShape> coordinates, double maxCharAngle);
    private double 9zA=(Vertex start, Vertex middle, Vertex end);
    private LabelingCandidate 6jA=(Collection`1<PointShape> coordinates, string text, GeoFont font, float xOffsetInPixel, float yOffsetInPixel, GeoCanvas canvas);
    private static bool /DA=(AreaBaseShape firstPolygon, AreaBaseShape secondPolygon);
    private static float /TA=(PolygonShape rectangleA, double angleA, PolygonShape rectangleB, double angleB);
    private static njA= /jA=(MultilineShape multilineShape, RectangleShape screenExtent, bool allowLineLabelingMoving, double rotateAngle);
    private static PolygonShape /zA=(MultipolygonShape multipolygonShape, RectangleShape screenExtent);
    private Collection`1<LabelingCandidate> ADE=(MultipointShape multipoint, string text, GeoFont font, float xOffsetInPixel, float yOffsetInPixel, GeoCanvas canvas, double rotationAngle);
    private LabelingCandidate ATE=(PointShape point, string text, GeoFont font, float xOffsetInPixel, float yOffsetInPixel, GeoCanvas canvas, double rotationAngle);
    private LabelingCandidate AjE=(PointShape point, string text, GeoFont font, float xOffsetInPixel, float yOffsetInPixel, GeoCanvas canvas, double rotationAngle);
    private LabelingCandidate AzE=(PointShape point, string text, GeoFont font, float xOffsetInPixel, float yOffsetInPixel, GeoCanvas canvas);
    private Collection`1<LabelingCandidate> BDE=(MultilineShape multilineShape, string text, GeoFont font, float xOffsetInPixel, float yOffsetInPixel, GeoCanvas canvas, double rotationAngle);
    private Collection`1<LabelingCandidate> BTE=(MultilineShape multilineShape, string text, GeoFont font, float xOffsetInPixel, float yOffsetInPixel, GeoCanvas canvas, double rotationAngle);
    private Collection`1<LabelingCandidate> BjE=(MultilineShape multilineShape, string text, GeoFont font, float xOffsetInPixel, float yOffsetInPixel, GeoCanvas canvas, double rotationAngle);
    private static LineShape BzE=(MultilineShape multilineShape);
    private Collection`1<LabelingCandidate> CDE=(LineShape line, string text, GeoFont font, float xOffsetInPixel, float yOffsetInPixel, GeoCanvas canvas, double rotationAngle);
    private Collection`1<LabelingCandidate> CTE=(MultipolygonShape multipolygonShape, string text, GeoFont font, float xOffsetInPixel, float yOffsetInPixel, GeoCanvas canvas, double rotationAngle);
    private Collection`1<LabelingCandidate> CjE=(Feature feature, GeoCanvas canvas, GeoFont font, float xOffsetInPixel, float yOffsetInPixel, double rotationAngle);
    private Collection`1<LabelingCandidate> CzE=(MultipolygonShape multipolygonShape, string text, GeoFont font, float xOffsetInPixel, float yOffsetInPixel, GeoCanvas canvas, double rotationAngle);
    internal LabelingCandidate DDE=(PolygonShape polygon, string text, GeoFont font, float xOffsetInPixel, float yOffsetInPixel, GeoCanvas canvas, double rotationAngle);
    private Collection`1<LabelingCandidate> DTE=(MultipolygonShape multipolygonShape, string text, GeoFont font, float xOffsetInPixel, float yOffsetInPixel, GeoCanvas canvas, double rotationAngle);
    private static double DjE=(Vertex fromVertex, Vertex toVertex);
    private static double rDA=(Vertex fromVertex, Vertex toVertex);
    private static double DzE=(Vertex fromVertex, Vertex toVertex);
    private String[] EDE=(PolygonShape polygon, string text, GeoFont font, GeoCanvas canvas);
    private static String[] ETE=(string text);
    private static PointShape EjE=(Vertex fromVertex, Vertex toVertex);
    private static PointShape EzE=(PointShape fromVertex, PointShape toVertex);
    private static PointShape FDE=(PointShape point, double distance, double angle);
    private PointShape FTE=(PolygonShape polygon);
    private static PointShape FjE=(PointShape upperLeftPoint, double width, double height, TextPlacement placementOfPoint);
    private PointShape FzE=(ScreenPointF centerPointBePlacemented, double width, double height, TextPlacement placementOfLabel, float xOffsetInPixel, float yOffsetInPixel, float canvasDpi, float canvasScaleFactor);
    private static PolygonShape GDE=(MultipolygonShape multipolygonShape);
    private PolygonShape GTE=(PointShape lowerLeftPoint, double width, double height);
    private PolygonShape GjE=(PointShape upperCenterPoint, double width, double height, double angle);
    private PolygonShape GzE=(PointShape lowerCenterPoint, double width, double height, double angle);
    private PolygonShape tjA=(Vertex[] maskAreaVertexs, Vertex pivotLowerCenterPoint, double angle, bool isStraight);
    private static IEnumerable`1<Vertex> vTA=(Vertex startPoint, Vertex pivot, float radius);
    private static IEnumerable`1<Vertex> vjA=(Vertex startPoint, Vertex pivot, float radius);
    private static Vertex vzA=(Vertex startPoint, Vertex pivot, double angle, float radius);
    private LabelInformation HDE=(string text, double height, PointShape centerPoint, double yOffset, double rotationAngle);
    private static BaseShape Qh0=(Feature feature, GeoCanvas canvas);
    private static BaseShape Qx0=(Feature feature, GeoCanvas canvas);
    private static BaseShape RB0=(Feature feature, GeoCanvas canvas);
    private static BaseShape RR0=(Feature feature, GeoCanvas canvas);
    private static BaseShape Rh0=(Feature feature, GeoCanvas canvas);
    private static BaseShape Rx0=(Feature feature, GeoCanvas canvas);
    private static BaseShape SB0=(Feature feature, GeoCanvas canvas);
    private static PointShape SR0=(Byte[] wellKnownBinary, Int32& startIndex, GeoCanvas canvas);
    private static PolygonShape Sh0=(Byte[] wellKnownBinary, Int32& startIndex, GeoCanvas canvas);
    private static LineShape Sx0=(Byte[] wellKnownBinary, Int32& startIndex, GeoCanvas canvas);
    private static TextPlacement HTE=(int index, TextPlacement baseOfPointPlacement);
    protected string Format(string text, BaseShape labeledShape);
    protected virtual string FormatCore(string text, BaseShape labeledShape);
    private static string HjE=(string text);
    protected virtual void OnFormatting(FormattingPositionStyleEventArgs e);
    protected virtual void OnFormatted(FormattedPositionStyleEventArgs e);
    private static void HzE=(LabelingCandidate sourceLabelingCandidate, LabelingCandidate destinateLabelingCandidate);
    private static double TB0=(Byte[] bytes, int startIndex, byte byteOrder);
    private static int TR0=(Byte[] bytes, int startIndex, byte byteOrder);
    private bool Phw=(PolygonShape polygon01, PolygonShape polygon02, bool isInThisLayer);
    private bool Phw=(RectangleShape rectangle01, RectangleShape rectangle02);
    private RectangleShape IDE=(PolygonShape polygon, bool isInThisLayer);
    private static PointShape ITE=(PolygonShape polygon);
    private static bool IjE=(PolygonShape polygon, PointShape point, RectangleShape boundingBox);
    private static bool IjE=(PolygonShape polygon, double pointX, double pointY, RectangleShape boundingBox);
    private static void IzE=(Collection`1<Vertex> crossingPoints, RingShape ringShape, double pointX, double pointY, double secondLineEndPointX);
    private static Vertex JDE=(Vertex startPoint, Vertex endPoint, double secondLineStartX, double secondLineStartY, double secondLineEndPointX);
    private static bool JTE=(Collection`1<Vertex> crossingPoints, Vertex vertex);
    private static bool sjA=(double value, double start, double end);
    private static bool JjE=(Vertex vertex);
    private static MultilineShape rjA=(LineShape line, RectangleShape rectangle);
    private static LineShape sDA=(Vertex startPoint, Vertex endPoint, RectangleShape rectangle);
    private static Vertex sTA=(Vertex startPoint, Vertex endPoint, RectangleShape rectangle);
    internal void JzE=(FeatureLabelingCandidate featureLabelingCandidate, GeoCanvas canvas, Collection`1<SimpleCandidate> labelsInThisLayer, Collection`1<SimpleCandidate> labelsInAllLayers);
    internal Collection`1<FeatureLabelingCandidate> KDE=(IEnumerable`1<Feature> features, GeoCanvas canvas);
    private Collection`1<FeatureLabelingCandidate> KTE=(IEnumerable`1<Feature> features, GeoCanvas canvas);
}
internal enum ThinkGeo.Core.PrimitiveTypeCode : Enum {
    public int value__;
    public static PrimitiveTypeCode Empty;
    public static PrimitiveTypeCode Object;
    public static PrimitiveTypeCode Char;
    public static PrimitiveTypeCode CharNullable;
    public static PrimitiveTypeCode Boolean;
    public static PrimitiveTypeCode BooleanNullable;
    public static PrimitiveTypeCode SByte;
    public static PrimitiveTypeCode SByteNullable;
    public static PrimitiveTypeCode Int16;
    public static PrimitiveTypeCode Int16Nullable;
    public static PrimitiveTypeCode UInt16;
    public static PrimitiveTypeCode UInt16Nullable;
    public static PrimitiveTypeCode Int32;
    public static PrimitiveTypeCode Int32Nullable;
    public static PrimitiveTypeCode Byte;
    public static PrimitiveTypeCode ByteNullable;
    public static PrimitiveTypeCode UInt32;
    public static PrimitiveTypeCode UInt32Nullable;
    public static PrimitiveTypeCode Int64;
    public static PrimitiveTypeCode Int64Nullable;
    public static PrimitiveTypeCode UInt64;
    public static PrimitiveTypeCode UInt64Nullable;
    public static PrimitiveTypeCode Single;
    public static PrimitiveTypeCode SingleNullable;
    public static PrimitiveTypeCode Double;
    public static PrimitiveTypeCode DoubleNullable;
    public static PrimitiveTypeCode DateTime;
    public static PrimitiveTypeCode DateTimeNullable;
    public static PrimitiveTypeCode DateTimeOffset;
    public static PrimitiveTypeCode DateTimeOffsetNullable;
    public static PrimitiveTypeCode Decimal;
    public static PrimitiveTypeCode DecimalNullable;
    public static PrimitiveTypeCode Guid;
    public static PrimitiveTypeCode GuidNullable;
    public static PrimitiveTypeCode TimeSpan;
    public static PrimitiveTypeCode TimeSpanNullable;
    public static PrimitiveTypeCode BigInteger;
    public static PrimitiveTypeCode BigIntegerNullable;
    public static PrimitiveTypeCode Uri;
    public static PrimitiveTypeCode String;
    public static PrimitiveTypeCode Bytes;
    public static PrimitiveTypeCode DBNull;
}
public enum ThinkGeo.Core.PrinterDragMode : Enum {
    public int value__;
    public static PrinterDragMode Fixed;
    public static PrinterDragMode Draggable;
}
internal static class ThinkGeo.Core.PrinterHelper : object {
    private static double feetPerMeter;
    public static double ConvertLength(double length, PrintingUnit fromUnit, PrintingUnit toUnit);
    public static double GetPointsPerGeographyUnit(GeographyUnit mapUnit);
}
public abstract class ThinkGeo.Core.PrinterLayer : Layer {
    [ObfuscationAttribute]
private RectangleShape boundingBox;
    [ObfuscationAttribute]
private AreaStyle backgroundMask;
    [ObfuscationAttribute]
private PrinterResizeMode resizeMode;
    [ObfuscationAttribute]
private PrinterDragMode dragMode;
    [ObfuscationAttribute]
private PrinterLayerSelectabilityMode selectabilityMode;
    [ObfuscationAttribute]
private bool isDrawing;
    [ObfuscationAttribute]
private RectangleShape lastBoundingBox;
    [ObfuscationAttribute]
private bool isResizing;
    public bool IsDrawing { get; public set; }
    public bool HasBoundingBox { get; }
    public AreaStyle BackgroundMask { get; public set; }
    public PrinterResizeMode ResizeMode { get; public set; }
    public PrinterDragMode DragMode { get; public set; }
    public bool IsResizing { get; public set; }
    public PrinterLayerSelectabilityMode SelectabilityMode { get; public set; }
    public bool get_IsDrawing();
    public void set_IsDrawing(bool value);
    public virtual bool get_HasBoundingBox();
    public AreaStyle get_BackgroundMask();
    public void set_BackgroundMask(AreaStyle value);
    public PrinterResizeMode get_ResizeMode();
    public void set_ResizeMode(PrinterResizeMode value);
    public PrinterDragMode get_DragMode();
    public void set_DragMode(PrinterDragMode value);
    public bool get_IsResizing();
    public void set_IsResizing(bool value);
    public PrinterLayerSelectabilityMode get_SelectabilityMode();
    public void set_SelectabilityMode(PrinterLayerSelectabilityMode value);
    protected virtual void DrawCore(GeoCanvas canvas, Collection`1<SimpleCandidate> labelsInAllLayers);
    protected virtual RectangleShape GetBoundingBoxCore();
    public RectangleShape GetDynamicBoundingBox();
    protected virtual RectangleShape GetDynamicBoundingBoxCore();
    public RectangleShape GetPosition();
    public RectangleShape GetPosition(PrintingUnit unit);
    protected virtual RectangleShape GetPositionCore(PrintingUnit unit);
    public void SetPosition(RectangleShape boundingBox);
    public void SetPosition(RectangleShape boundingBox, PrintingUnit unit);
    public void SetPosition(double width, double height, PointShape centerPoint, PrintingUnit unit);
    public void SetPosition(double width, double height, double centerPointX, double centerPointY, PrintingUnit unit);
    public void SetPosition(double width, double height, LayerAnchorLocation corner, PointShape cornerPoint, PrintingUnit unit);
    public void SetPosition(double width, double height, LayerAnchorLocation corner, double cornerPointX, double cornerPointY, PrintingUnit unit);
    protected virtual RectangleShape SetPositionCore(double width, double height, double centerPointX, double centerPointY, PrintingUnit unit);
    private RectangleShape CyA=(RectangleShape newBoundingBox);
    private RectangleShape DCA=(RectangleShape newBoundingBox, bool maintainAspectRatio, bool dragable);
    private static bool bRU=(PointShape point1, PointShape point2);
}
public enum ThinkGeo.Core.PrinterLayerSelectabilityMode : Enum {
    public int value__;
    public static PrinterLayerSelectabilityMode Selectable;
    public static PrinterLayerSelectabilityMode NonSelectable;
}
public enum ThinkGeo.Core.PrinterResizeMode : Enum {
    public int value__;
    public static PrinterResizeMode Fixed;
    public static PrinterResizeMode MaintainAspectRatio;
    public static PrinterResizeMode Resizable;
}
public enum ThinkGeo.Core.PrintingUnit : Enum {
    public int value__;
    public static PrintingUnit Millimeter;
    public static PrintingUnit Inch;
    public static PrintingUnit Meter;
    public static PrintingUnit Centimeter;
    public static PrintingUnit Point;
}
public class ThinkGeo.Core.Projection : object {
    [ObfuscationAttribute]
private string projString;
    [ObfuscationAttribute]
private int srid;
    private static object Xxo=;
    private static Dictionary`2<string, ProjectionConverter> YBo=;
    private static object VhY=;
    public int Srid { get; public set; }
    public string ProjString { get; public set; }
    public Projection(int srid);
    public Projection(string projString);
    private static Projection();
    public int get_Srid();
    public void set_Srid(int value);
    public string get_ProjString();
    public void set_ProjString(string value);
    public GeographyUnit GetUnit();
    public static string GetProjStringByEpsgSrid(int srid);
    public static int GetEpsgSridByProjString(string projString);
    public static string GetProjStringByEsriSrid(int srid);
    public static int GetEsriSridByProjString(string projString);
    public static string GetWgs84ProjString();
    public static string GetLatLongProjString();
    public static string GetDecimalDegreesProjString();
    public static string GetGoogleMapProjString();
    public static string GetBingMapProjString();
    public static string GetSphericalMercatorProjString();
    public static string GetLocalUtmZoneProjString(double latitude, double longitude);
    public static string GetLocalUtmZoneProjString(Feature feature, string projString);
    public static string GetLocalUtmZoneProjString(Feature feature, int srid);
    public static string GetLocalUtmZoneProjString(BaseShape shape, Projection projection);
    public static string GetLocalUtmZoneProjString(BaseShape shape, string projString);
    public static string GetLocalUtmZoneProjString(BaseShape shape, int srid);
    public static int GetLocalUtmZoneNumber(double latitude, double longitude);
    public static int GetLocalUtmZoneNumber(Feature feature, string projString);
    public static int GetLocalUtmZoneNumber(Feature feature, int srid);
    public static int GetLocalUtmZoneNumber(BaseShape shape, string projString);
    public static int GetLocalUtmZoneNumber(BaseShape shape, int srid);
    public static GeographyUnit GetGeographyUnitFromWkb(string wkt);
    public static GeographyUnit GetGeographyUnitFromProj(string projString);
    public static string ConvertEpsgToWkt(int srid);
    public static string ConvertProjStringToWkt(string projString);
    public static string ConvertWktToProjString(string wkt);
    private static int YRo=(double latitude, double longitude);
    public static string ConvertEpsgToProjString(int srid);
    public static int ConvertProjStringToEpsg(string projString);
    private static string Yho=(string srid, Byte[] fileBuffer);
    private static int Yxo=(string projString, Byte[] fileBuffer);
    public static GeographyUnit GetGeographyUnit(int srid);
    public static GeographyUnit GetGeographyUnit(string projString);
    private static ProjectionConverter ZBo=(string proj4ProjectionParameters);
}
public class ThinkGeo.Core.ProjectionCloudClient : CloudClient {
    public ProjectionCloudClient(string clientId, string clientSecret);
    public Feature Project(Feature feature, int fromProjectionInSrid, int toProjectionInSrid);
    public Feature Project(Feature feature, int fromProjectionInSrid, string toProjectionInProj4String);
    public Feature Project(Feature feature, string fromProjectionInProj4String, int toProjectionInSrid);
    public Feature Project(Feature feature, string fromProjectionInProj4String, string toProjectionInProj4String);
    public Task`1<Feature> ProjectAsync(Feature feature, int fromProjectionInSrid, int toProjectionInSrid);
    public Task`1<Feature> ProjectAsync(Feature feature, int fromProjectionInSrid, string toProjectionInProj4String);
    public Task`1<Feature> ProjectAsync(Feature feature, string fromProjectionInProj4String, int toProjectionInSrid);
    public Task`1<Feature> ProjectAsync(Feature feature, string fromProjectionInProj4String, string toProjectionInProj4String);
    public Collection`1<Feature> Project(IEnumerable`1<Feature> features, int fromProjectionInSrid, int toProjectionInSrid);
    public Collection`1<Feature> Project(IEnumerable`1<Feature> features, int fromProjectionInSrid, string toProjectionInProj4String);
    public Collection`1<Feature> Project(IEnumerable`1<Feature> features, string fromProjectionInProj4String, int toProjectionInSrid);
    public Collection`1<Feature> Project(IEnumerable`1<Feature> features, string fromProjectionInProj4String, string toProjectionInProj4String);
    public Task`1<Collection`1<Feature>> ProjectAsync(IEnumerable`1<Feature> features, int fromProjectionInSrid, int toProjectionInSrid);
    public Task`1<Collection`1<Feature>> ProjectAsync(IEnumerable`1<Feature> features, int fromProjectionInSrid, string toProjectionInProj4String);
    public Task`1<Collection`1<Feature>> ProjectAsync(IEnumerable`1<Feature> features, string fromProjectionInProj4String, int toProjectionInSrid);
    public Task`1<Collection`1<Feature>> ProjectAsync(IEnumerable`1<Feature> features, string fromProjectionInProj4String, string toProjectionInProj4String);
    private Feature zxQ=(Feature feature, string fromProjectionInProj4String, string toProjectionInProj4String);
    [AsyncStateMachineAttribute("ThinkGeo.Core.ProjectionCloudClient/<ProjectCoreAsync>d__19")]
private Task`1<Feature> 0BQ=(Feature feature, string fromProjectionInProj4String, string toProjectionInProj4String);
    private Collection`1<Feature> zxQ=(IEnumerable`1<Feature> features, string fromProjectionInProj4String, string toProjectionInProj4String);
    [AsyncStateMachineAttribute("ThinkGeo.Core.ProjectionCloudClient/<ProjectCoreAsync>d__21")]
private Task`1<Collection`1<Feature>> 0BQ=(IEnumerable`1<Feature> features, string fromProjectionInProj4String, string toProjectionInProj4String);
    private static Feature 0RQ=(WebResponse response);
    private static Collection`1<Feature> 0hQ=(WebResponse response);
}
public class ThinkGeo.Core.ProjectionConverter : object {
    private Txo= ZRo=;
    private Txo= Zho=;
    [ObfuscationAttribute]
private static int positionByteOrder;
    private bool Zxo=;
    [ObfuscationAttribute]
private bool canConvertRasterToExternalProjection;
    [ObfuscationAttribute]
private RectangleShape decimalDegreeBoundary;
    [ObfuscationAttribute]
private RectangleShape sphecicalMercatorBoundary;
    private Rxg= aBo=;
    [CompilerGeneratedAttribute]
private Projection aRo=;
    [CompilerGeneratedAttribute]
private Projection aho=;
    public RectangleShape DecimalDegreeBoundary { get; public set; }
    public Projection InternalProjection { get; public set; }
    public Projection ExternalProjection { get; public set; }
    public bool IsOpen { get; protected set; }
    public bool CanConvertRasterToExternalProjection { get; protected set; }
    public GeographyUnit InternalProjectionUnit { get; }
    public ProjectionConverter(string internalProjString, string externalProjString);
    public ProjectionConverter(int internalSrid, int externalSrid);
    public ProjectionConverter(string internalProjString, int externalSrid);
    public ProjectionConverter(int internalSridString, string externalProjString);
    public ProjectionConverter(Projection internalProjection, Projection externalProjection);
    public RectangleShape get_DecimalDegreeBoundary();
    public void set_DecimalDegreeBoundary(RectangleShape value);
    [CompilerGeneratedAttribute]
public Projection get_InternalProjection();
    [CompilerGeneratedAttribute]
public void set_InternalProjection(Projection value);
    [CompilerGeneratedAttribute]
public Projection get_ExternalProjection();
    [CompilerGeneratedAttribute]
public void set_ExternalProjection(Projection value);
    public bool get_IsOpen();
    protected void set_IsOpen(bool value);
    public bool get_CanConvertRasterToExternalProjection();
    protected void set_CanConvertRasterToExternalProjection(bool value);
    public virtual GeographyUnit get_InternalProjectionUnit();
    public void Open();
    public RasterProjectionResult ConvertToExternalProjection(GeoImage image, RectangleShape imageExtent, RectangleShape targetExtent, int width, int height);
    public RasterProjectionResult ConvertToExternalProjection(GeoImage image, RectangleShape imageExtent);
    public RasterProjectionResult ConvertToExternalProjection(GeoImage image, RectangleShape imageExtent, RectangleShape targetExtent);
    protected virtual RasterProjectionResult ConvertToExternalProjectionCore(GeoImage image, RectangleShape imageExtent, RectangleShape targetExtent, int width, int height);
    protected virtual void OpenCore();
    [OnGeodeserializedAttribute]
private void axo=();
    public void Close();
    protected virtual void CloseCore();
    public Vertex ConvertToExternalProjection(double x, double y);
    public BaseShape ConvertToExternalProjection(BaseShape baseShape);
    public Feature ConvertToExternalProjection(Feature feature);
    public Collection`1<Feature> ConvertToExternalProjection(IEnumerable`1<Feature> features);
    internal void bBo=(Feature feature);
    public RectangleShape ConvertToExternalProjection(RectangleShape rectangleShape);
    protected virtual Collection`1<Vertex> ConvertToExternalProjectionCore(IEnumerable`1<Vertex> verticies);
    public Collection`1<Vertex> ConvertToExternalProjection(IEnumerable`1<Vertex> vertices);
    public Vertex ConvertToInternalProjection(double x, double y);
    public BaseShape ConvertToInternalProjection(BaseShape baseShape);
    public Feature ConvertToInternalProjection(Feature feature);
    public Collection`1<Vertex> ConvertToInternalProjection(IEnumerable`1<Vertex> vertices);
    public RectangleShape ConvertToInternalProjection(RectangleShape rectangleShape);
    protected virtual Collection`1<Vertex> ConvertToInternalProjectionCore(IEnumerable`1<Vertex> verticies);
    internal void bRo=(Feature feature);
    private static Collection`1<Vertex> bho=(RectangleShape rectangleShape, int pointCountBySide);
    private RectangleShape bxo=(IEnumerable`1<Vertex> vertices);
    private Byte[] cBo=(Byte[] wellKnownBinary);
    private Byte[] cRo=(Byte[] wellKnownBinary);
    private static WellKnownType cho=(Byte[] wkb);
    private Byte[] cxo=(Byte[] wellKnownBinary);
    private Byte[] dBo=(Byte[] wellKnownBinary);
    private Byte[] dRo=(Byte[] wellKnownBinary);
    private Byte[] dho=(Byte[] wellKnownBinary);
    private Byte[] dxo=(Byte[] wellKnownBinary);
    private Byte[] eBo=(Byte[] wellKnownBinary);
    private Byte[] eRo=(Byte[] wellKnownBinary);
    private Byte[] eho=(Byte[] wellKnownBinary);
    private Byte[] exo=(Byte[] wellKnownBinary);
    private Byte[] fBo=(Byte[] wellKnownBinary);
    private Byte[] fRo=(Byte[] wellKnownBinary);
    private Byte[] fho=(Byte[] wellKnownBinary);
    private static int FBU=(Byte[] wkb, int startIndex, byte byteOrder);
    private static double FRU=(Byte[] wkb, int startIndex, byte byteOrder);
    private static Byte[] fxo=(double doubleValue, byte byteOrder);
    private Collection`1<Vertex> gBo=(IEnumerable`1<Vertex> verticies, Txo= sourceProjType, Txo= destinationProjType, bool isFromDegree, bool isToDegree);
    public static PointShape Convert(int fromSrid, int toSrid, PointShape sourcePoint);
    public static Feature Convert(int fromSrid, int toSrid, Feature feature);
    public static RectangleShape Convert(int fromSrid, int toSrid, RectangleShape rectangleShape);
    public static IEnumerable`1<Feature> Convert(int fromSrid, int toSrid, IEnumerable`1<Feature> features);
    public static IEnumerable`1<Vertex> Convert(int fromSrid, int toSrid, IEnumerable`1<Vertex> vertices);
    public static Vertex Convert(int fromSrid, int toSrid, double x, double y);
    public static PointShape Convert(int fromSrid, string toProjString, PointShape sourcePoint);
    public static Feature Convert(int fromSrid, string toProjString, Feature feature);
    public static RectangleShape Convert(int fromSrid, string toProjString, RectangleShape rectangleShape);
    public static IEnumerable`1<Feature> Convert(int fromSrid, string toProjString, IEnumerable`1<Feature> features);
    public static IEnumerable`1<Vertex> Convert(int fromSrid, string toProjString, IEnumerable`1<Vertex> vertices);
    public static Vertex Convert(int fromSrid, string toProjString, double x, double y);
    public static PointShape Convert(Projection fromProjection, Projection toProjection, PointShape sourcePoint);
    public static Feature Convert(Projection fromProjection, Projection toProjection, Feature feature);
    public static RectangleShape Convert(Projection fromProjection, Projection toProjection, RectangleShape rectangleShape);
    public static IEnumerable`1<Feature> Convert(Projection fromProjection, Projection toProjection, IEnumerable`1<Feature> features);
    public static IEnumerable`1<Vertex> Convert(Projection fromProjection, Projection toProjection, IEnumerable`1<Vertex> vertices);
    public static Vertex Convert(Projection fromProjection, Projection toProjection, double x, double y);
    public static PointShape Convert(string fromProjString, int toSrid, PointShape sourcePoint);
    public static Feature Convert(string fromProjString, int toSrid, Feature feature);
    public static RectangleShape Convert(string fromProjString, int toSrid, RectangleShape rectangleShape);
    public static IEnumerable`1<Feature> Convert(string fromProjString, int toSrid, IEnumerable`1<Feature> features);
    public static IEnumerable`1<Vertex> Convert(string fromProjString, int toSrid, IEnumerable`1<Vertex> vertices);
    public static Vertex Convert(string fromProjString, int toSrid, double x, double y);
    public static PointShape Convert(string fromProjString, string toProjString, PointShape sourcePoint);
    public static Feature Convert(string fromProjString, string toProjString, Feature feature);
    public static RectangleShape Convert(string fromProjString, string toProjString, RectangleShape rectangleShape);
    public static IEnumerable`1<Feature> Convert(string fromProjString, string toProjString, IEnumerable`1<Feature> features);
    public static IEnumerable`1<Vertex> Convert(string fromProjString, string toProjString, IEnumerable`1<Vertex> vertices);
    public static Vertex Convert(string fromProjString, string toProjString, double x, double y);
    private static void gRo=(int errorNumber);
}
public class ThinkGeo.Core.QualityFamilyAreaStyle : AreaStyle {
    [ObfuscationAttribute]
private Collection`1<AreaStyle> areaStyles;
    [ObfuscationAttribute]
private Dictionary`2<string, AreaStyle> cache;
    [ObfuscationAttribute]
private int numberOfColors;
    public int NumberOfColors { get; public set; }
    public Dictionary`2<string, AreaStyle> Cache { get; }
    public GeoColor BaseColor { get; public set; }
    public QualityFamilyAreaStyle(GeoPen outlinePen, GeoColor baseColor, int numberOfColors);
    public QualityFamilyAreaStyle(GeoPen outlinePen, GeoColor baseColor, int numberOfColors, PenBrushDrawingOrder penBrushDrawingOrder);
    public int get_NumberOfColors();
    public void set_NumberOfColors(int value);
    public Dictionary`2<string, AreaStyle> get_Cache();
    public GeoColor get_BaseColor();
    public void set_BaseColor(GeoColor value);
    public void ClearCache();
    protected virtual void DrawCore(IEnumerable`1<Feature> features, GeoCanvas canvas, Collection`1<SimpleCandidate> labelsInThisLayer, Collection`1<SimpleCandidate> labelsInAllLayers);
}
public class ThinkGeo.Core.QueryTools : object {
    [ObfuscationAttribute]
private FeatureSource featureSource;
    public bool CanExecuteSqlQuery { get; }
    public QueryTools(FeatureSource featureSource);
    public Collection`1<Feature> GetFeaturesByColumnValue(string columnName, string columnValue, ReturningColumnsType returningColumnType);
    public Collection`1<Feature> GetFeaturesByColumnValue(string columnName, string columnValue, IEnumerable`1<string> returningColumnNames);
    public Collection`1<Feature> GetFeaturesByColumnValue(string columnName, string columnValue);
    public Collection`1<Feature> GetFeaturesContaining(BaseShape targetShape, IEnumerable`1<string> returningColumnNames);
    public Collection`1<Feature> GetFeaturesContaining(BaseShape targetShape, ReturningColumnsType returningColumnNamesType);
    public Collection`1<Feature> GetFeaturesContaining(Feature targetFeature, IEnumerable`1<string> returningColumnNames);
    public Collection`1<Feature> GetFeaturesContaining(Feature targetFeature, ReturningColumnsType returningColumnNamesType);
    public Collection`1<Feature> GetFeaturesCrossing(BaseShape targetShape, IEnumerable`1<string> returningColumnNames);
    public Collection`1<Feature> GetFeaturesCrossing(BaseShape targetShape, ReturningColumnsType returningColumnNamesType);
    public Collection`1<Feature> GetFeaturesCrossing(Feature targetFeature, IEnumerable`1<string> returningColumnNames);
    public Collection`1<Feature> GetFeaturesCrossing(Feature targetFeature, ReturningColumnsType returningColumnNamesType);
    public Collection`1<Feature> GetFeaturesDisjointed(BaseShape targetShape, IEnumerable`1<string> returningColumnNames);
    public Collection`1<Feature> GetFeaturesDisjointed(BaseShape targetShape, ReturningColumnsType returningColumnNamesType);
    public Collection`1<Feature> GetFeaturesDisjointed(Feature targetFeature, IEnumerable`1<string> returningColumnNames);
    public Collection`1<Feature> GetFeaturesDisjointed(Feature targetFeature, ReturningColumnsType returningColumnNamesType);
    public Collection`1<Feature> GetFeaturesIntersecting(BaseShape targetShape, IEnumerable`1<string> returningColumnNames);
    public Collection`1<Feature> GetFeaturesIntersecting(BaseShape targetShape, ReturningColumnsType returningColumnNamesType);
    public Collection`1<Feature> GetFeaturesIntersecting(Feature targetFeature, IEnumerable`1<string> returningColumnNames);
    public Collection`1<Feature> GetFeaturesIntersecting(Feature targetFeature, ReturningColumnsType returningColumnNamesType);
    public Collection`1<Feature> GetFeaturesOverlapping(BaseShape targetShape, IEnumerable`1<string> returningColumnNames);
    public Collection`1<Feature> GetFeaturesOverlapping(BaseShape targetShape, ReturningColumnsType returningColumnNamesType);
    public Collection`1<Feature> GetFeaturesOverlapping(Feature targetFeature, IEnumerable`1<string> returningColumnNames);
    public Collection`1<Feature> GetFeaturesOverlapping(Feature targetFeature, ReturningColumnsType returningColumnNamesType);
    public Collection`1<Feature> GetFeaturesTopologicalEqual(BaseShape targetShape, IEnumerable`1<string> returningColumnNames);
    public Collection`1<Feature> GetFeaturesTopologicalEqual(BaseShape targetShape, ReturningColumnsType returningColumnNamesType);
    public Collection`1<Feature> GetFeaturesTopologicalEqual(Feature targetFeature, IEnumerable`1<string> returningColumnNames);
    public Collection`1<Feature> GetFeaturesTopologicalEqual(Feature targetFeature, ReturningColumnsType returningColumnNamesType);
    public Collection`1<Feature> GetFeaturesTouching(BaseShape targetShape, IEnumerable`1<string> returningColumnNames);
    public Collection`1<Feature> GetFeaturesTouching(BaseShape targetShape, ReturningColumnsType returningColumnNamesType);
    public Collection`1<Feature> GetFeaturesTouching(Feature targetFeature, IEnumerable`1<string> returningColumnNames);
    public Collection`1<Feature> GetFeaturesTouching(Feature targetFeature, ReturningColumnsType returningColumnNamesType);
    public Collection`1<Feature> GetFeaturesWithin(BaseShape targetShape, IEnumerable`1<string> returningColumnNames);
    public Collection`1<Feature> GetFeaturesWithin(BaseShape targetShape, ReturningColumnsType returningColumnNamesType);
    public Collection`1<Feature> GetFeaturesWithin(Feature targetFeature, IEnumerable`1<string> returningColumnNames);
    public Collection`1<Feature> GetFeaturesWithin(Feature targetFeature, ReturningColumnsType returningColumnNamesType);
    public Collection`1<Feature> GetFeaturesOutsideBoundingBox(RectangleShape boundingBox, IEnumerable`1<string> returningColumnNames);
    public Collection`1<Feature> GetFeaturesOutsideBoundingBox(RectangleShape boundingBox, ReturningColumnsType returningColumnNamesType);
    public Collection`1<Feature> GetFeaturesInsideBoundingBox(RectangleShape boundingBox, IEnumerable`1<string> returningColumnNames);
    public Collection`1<Feature> GetFeaturesInsideBoundingBox(RectangleShape boundingBox, ReturningColumnsType returningColumnNamesType);
    public Collection`1<Feature> GetFeaturesNearestTo(BaseShape targetShape, GeographyUnit unitOfData, int maxItemsToFind, IEnumerable`1<string> returningColumnNames);
    public Collection`1<Feature> GetFeaturesNearestTo(BaseShape targetShape, GeographyUnit unitOfData, int maxItemsToFind, ReturningColumnsType returningColumnNamesType);
    public Collection`1<Feature> GetFeaturesNearestTo(Feature targetFeature, GeographyUnit unitOfData, int maxItemsToFind, IEnumerable`1<string> returningColumnNames);
    public Collection`1<Feature> GetFeaturesNearestTo(Feature targetFeature, GeographyUnit unitOfData, int maxItemsToFind, ReturningColumnsType returningColumnNamesType);
    public Collection`1<Feature> GetFeaturesNearestTo(Feature targetFeature, GeographyUnit unitOfData, int maxItemsToFind, IEnumerable`1<string> returningColumnNames, double searchRadius, DistanceUnit unitOfSearchRadius);
    public Collection`1<Feature> GetFeaturesNearestTo(BaseShape targetShape, GeographyUnit unitOfData, int maxItemsToFind, IEnumerable`1<string> returningColumnNames, double searchRadius, DistanceUnit unitOfSearchRadius);
    public Collection`1<Feature> GetFeaturesWithinDistanceOf(BaseShape targetShape, GeographyUnit unitOfData, DistanceUnit distanceUnit, double distance, IEnumerable`1<string> returningColumnNames);
    public Collection`1<Feature> GetFeaturesWithinDistanceOf(BaseShape targetShape, GeographyUnit unitOfData, DistanceUnit distanceUnit, double distance, ReturningColumnsType returningColumnNamesType);
    public Collection`1<Feature> GetFeaturesWithinDistanceOf(Feature targetFeature, GeographyUnit unitOfData, DistanceUnit distanceUnit, double distance, IEnumerable`1<string> returningColumnNames);
    public Collection`1<Feature> GetFeaturesWithinDistanceOf(Feature targetFeature, GeographyUnit unitOfData, DistanceUnit distanceUnit, double distance, ReturningColumnsType returningColumnNamesType);
    public Feature GetFeatureById(string id, IEnumerable`1<string> returningColumnNames);
    public Feature GetFeatureById(string id, ReturningColumnsType returningColumnNamesType);
    public Collection`1<Feature> GetFeaturesByIds(IEnumerable`1<string> ids, IEnumerable`1<string> returningColumnNames);
    public Collection`1<Feature> GetFeaturesByIds(IEnumerable`1<string> ids, ReturningColumnsType returningColumnNamesType);
    public RectangleShape GetBoundingBoxById(string id);
    public Collection`1<RectangleShape> GetBoundingBoxesByIds(IEnumerable`1<string> ids);
    public Collection`1<FeatureSourceColumn> GetColumns();
    public long GetCount();
    public Collection`1<Feature> GetAllFeatures(IEnumerable`1<string> returningColumnNames);
    public Collection`1<Feature> GetAllFeatures(ReturningColumnsType returningColumnNamesType);
    public WellKnownType GetFirstFeaturesWellKnownType();
    public bool get_CanExecuteSqlQuery();
    public int ExecuteNonQuery(string sqlStatement);
    public object ExecuteScalar(string sqlStatement);
    public DataTable ExecuteQuery(string sqlStatement);
}
public enum ThinkGeo.Core.QueryType : Enum {
    public int value__;
    public static QueryType Disjoint;
    public static QueryType Intersects;
    public static QueryType Touches;
    public static QueryType Crosses;
    public static QueryType Within;
    public static QueryType Contains;
    public static QueryType Overlaps;
    public static QueryType TopologicalEqual;
}
public enum ThinkGeo.Core.RandomColorType : Enum {
    public int value__;
    public static RandomColorType All;
    public static RandomColorType Pastel;
    public static RandomColorType Bright;
}
public enum ThinkGeo.Core.RangeCheckingInclusion : Enum {
    public int value__;
    public static RangeCheckingInclusion IncludeValue;
    public static RangeCheckingInclusion ExcludeValue;
}
public abstract class ThinkGeo.Core.RasterLayer : Layer {
    [ObfuscationAttribute]
private double upperThreshold;
    [ObfuscationAttribute]
private double lowerThreshold;
    [ObfuscationAttribute]
private RasterSource imageSource;
    public RasterSource ImageSource { get; protected set; }
    public double UpperThreshold { get; public set; }
    public double LowerThreshold { get; public set; }
    public double ScaleFactor { get; public set; }
    public Projection Projection { get; }
    protected bool IsOpenCore { get; }
    public RasterSource get_ImageSource();
    protected void set_ImageSource(RasterSource value);
    public double get_UpperThreshold();
    public void set_UpperThreshold(double value);
    public double get_LowerThreshold();
    public void set_LowerThreshold(double value);
    public double get_ScaleFactor();
    public void set_ScaleFactor(double value);
    public virtual Projection get_Projection();
    protected virtual bool get_IsOpenCore();
    public float GetHorizontalResolution();
    public float GetVerticalResolution();
    protected virtual RectangleShape GetBoundingBoxCore();
    protected virtual void OpenCore();
    protected virtual void CloseCore();
    protected virtual bool IsDrawingNeededCore(double currentScale);
    protected virtual void DrawCore(GeoCanvas canvas, Collection`1<SimpleCandidate> labelsInAllLayers);
    private void 6R8=(GeoCanvas canvas);
    private void 6h8=(GeoCanvas canvas);
    private void 6x8=(GeoCanvas canvas);
}
public class ThinkGeo.Core.RasterProjectionResult : object {
    [ObfuscationAttribute]
private GeoImage image;
    [ObfuscationAttribute]
private RectangleShape imageExtent;
    public GeoImage Image { get; public set; }
    public RectangleShape ImageExtent { get; public set; }
    public RasterProjectionResult(GeoImage image, RectangleShape imageExtent);
    public GeoImage get_Image();
    public void set_Image(GeoImage value);
    public RectangleShape get_ImageExtent();
    public void set_ImageExtent(RectangleShape value);
}
public abstract class ThinkGeo.Core.RasterSource : object {
    [ObfuscationAttribute]
private float transparency;
    [ObfuscationAttribute]
private float redTranslation;
    [ObfuscationAttribute]
private float greenTranslation;
    [ObfuscationAttribute]
private float blueTranslation;
    [ObfuscationAttribute]
private bool isNegative;
    [ObfuscationAttribute]
private bool isGrayscale;
    private bool Zxo=;
    [ObfuscationAttribute]
private ProjectionConverter projectionConverter;
    [ObfuscationAttribute]
private Projection projection;
    [ObfuscationAttribute]
private double scaleFactor;
    [CompilerGeneratedAttribute]
private EventHandler`1<OpeningRasterSourceEventArgs> OpeningRasterSource;
    [CompilerGeneratedAttribute]
private EventHandler`1<OpenedRasterSourceEventArgs> OpenedRasterSource;
    [CompilerGeneratedAttribute]
private EventHandler`1<ClosingRasterSourceEventArgs> ClosingRasterSource;
    [CompilerGeneratedAttribute]
private EventHandler`1<ClosedRasterSourceEventArgs> ClosedRasterSource;
    [CompilerGeneratedAttribute]
private EventHandler`1<Ox4=> StatusChanged;
    public ProjectionConverter ProjectionConverter { get; public set; }
    public Projection Projection { get; protected set; }
    public float Transparency { get; public set; }
    public float BlueTranslation { get; public set; }
    public float RedTranslation { get; public set; }
    public float GreenTranslation { get; public set; }
    public bool IsNegative { get; public set; }
    public bool IsGrayscale { get; public set; }
    public double ScaleFactor { get; public set; }
    public bool IsOpen { get; protected set; }
    [CompilerGeneratedAttribute]
public void add_OpeningRasterSource(EventHandler`1<OpeningRasterSourceEventArgs> value);
    [CompilerGeneratedAttribute]
public void remove_OpeningRasterSource(EventHandler`1<OpeningRasterSourceEventArgs> value);
    [CompilerGeneratedAttribute]
public void add_OpenedRasterSource(EventHandler`1<OpenedRasterSourceEventArgs> value);
    [CompilerGeneratedAttribute]
public void remove_OpenedRasterSource(EventHandler`1<OpenedRasterSourceEventArgs> value);
    [CompilerGeneratedAttribute]
public void add_ClosingRasterSource(EventHandler`1<ClosingRasterSourceEventArgs> value);
    [CompilerGeneratedAttribute]
public void remove_ClosingRasterSource(EventHandler`1<ClosingRasterSourceEventArgs> value);
    [CompilerGeneratedAttribute]
public void add_ClosedRasterSource(EventHandler`1<ClosedRasterSourceEventArgs> value);
    [CompilerGeneratedAttribute]
public void remove_ClosedRasterSource(EventHandler`1<ClosedRasterSourceEventArgs> value);
    [CompilerGeneratedAttribute]
internal void WB4=(EventHandler`1<Ox4=> value);
    [CompilerGeneratedAttribute]
internal void WR4=(EventHandler`1<Ox4=> value);
    public ProjectionConverter get_ProjectionConverter();
    public void set_ProjectionConverter(ProjectionConverter value);
    public Projection get_Projection();
    protected void set_Projection(Projection value);
    public float get_Transparency();
    public void set_Transparency(float value);
    public float get_BlueTranslation();
    public void set_BlueTranslation(float value);
    public float get_RedTranslation();
    public void set_RedTranslation(float value);
    public float get_GreenTranslation();
    public void set_GreenTranslation(float value);
    public bool get_IsNegative();
    public void set_IsNegative(bool value);
    public bool get_IsGrayscale();
    public void set_IsGrayscale(bool value);
    public double get_ScaleFactor();
    public void set_ScaleFactor(double value);
    protected virtual void OnOpeningRasterSource(OpeningRasterSourceEventArgs e);
    internal virtual void Wx4=(Ox4= e);
    protected virtual void OnOpenedRasterSource(OpenedRasterSourceEventArgs e);
    protected virtual void OnClosingRasterSource(ClosingRasterSourceEventArgs e);
    protected virtual void OnClosedRasterSource(ClosedRasterSourceEventArgs e);
    public RasterSource CloneDeep();
    protected virtual RasterSource CloneDeepCore();
    public string GetWorldFileText();
    public static string GenerateWorldFileText(RectangleShape worldExtent, int imageWidth, int imageHeight);
    public int GetImageWidth();
    protected abstract virtual int GetImageWidthCore();
    public int GetImageHeight();
    protected abstract virtual int GetImageHeightCore();
    public float GetHorizontalResolution();
    public float GetVerticalResolution();
    public RectangleShape GetBoundingBox();
    protected abstract virtual RectangleShape GetBoundingBoxCore();
    public bool get_IsOpen();
    protected void set_IsOpen(bool value);
    public void Open();
    protected abstract virtual void OpenCore();
    public void Close();
    protected virtual void CloseCore();
    public GeoImage GetImage(RectangleShape worldExtent, int canvasWidth, int canvasHeight);
    internal GeoImage XB4=(RectangleShape boundingBox, double screenWidth, double screenHeight, RectangleShape wrappingExtent);
    internal GeoImage XR4=(RectangleShape boundingBox, double screenWidth, double screenHeight, RectangleShape wrappingExtent);
    protected abstract virtual GeoImage GetImageCore(RectangleShape worldExtent, int canvasWidth, int canvasHeight);
}
public class ThinkGeo.Core.RasterTile : Tile {
    [ObfuscationAttribute]
private GeoImage bitmap;
    [CompilerGeneratedAttribute]
private Byte[] kR0=;
    [ObsoleteAttribute("This property is obsoleted and will be removed on 14.4, please use GetImage() instead")]
public GeoImage Bitmap { get; public set; }
    public Byte[] RasterData { get; public set; }
    public RasterTile(Byte[] rasterData, int zoom, long column, long row);
    public GeoImage get_Bitmap();
    public void set_Bitmap(GeoImage value);
    [CompilerGeneratedAttribute]
public Byte[] get_RasterData();
    [CompilerGeneratedAttribute]
public void set_RasterData(Byte[] value);
    public GeoImage GetImage();
    protected virtual override void Finalize();
    public sealed virtual void Dispose();
    private void kh0=(bool disposing);
}
public abstract class ThinkGeo.Core.RasterTileCache : TileCache {
    [ObfuscationAttribute]
private GeoImageFormat imageFormat;
    [ObfuscationAttribute]
private short jpegQuality;
    private GeoImage hB0=;
    private GeoImage hR0=;
    public GeoImage NoDataTileImage { get; }
    public GeoImage LoadingTileImage { get; }
    public GeoImageFormat ImageFormat { get; public set; }
    public short JpegQuality { get; public set; }
    protected RasterTileCache(string cacheId, GeoImageFormat imageFormat);
    public GeoImage get_NoDataTileImage();
    public GeoImage get_LoadingTileImage();
    public GeoImageFormat get_ImageFormat();
    public void set_ImageFormat(GeoImageFormat value);
    public short get_JpegQuality();
    public void set_JpegQuality(short value);
    public virtual string ToString();
}
[ObsoleteAttribute("This enum is obsoleted, please use GeoImageFormat instead")]
public enum ThinkGeo.Core.RasterTileFormat : Enum {
    public int value__;
    public static RasterTileFormat Png;
    public static RasterTileFormat Jpeg;
}
internal enum ThinkGeo.Core.ReadType : Enum {
    public int value__;
    public static ReadType Read;
    public static ReadType ReadAsInt32;
    public static ReadType ReadAsInt64;
    public static ReadType ReadAsBytes;
    public static ReadType ReadAsString;
    public static ReadType ReadAsDecimal;
    public static ReadType ReadAsDateTime;
    public static ReadType ReadAsDouble;
    public static ReadType ReadAsBoolean;
}
public class ThinkGeo.Core.RebuildingShapeFileFeatureSourceEventArgs : EventArgs {
    [ObfuscationAttribute]
private long recordCount;
    [ObfuscationAttribute]
private long currentRecordIndex;
    [ObfuscationAttribute]
private Feature currentFeature;
    [ObfuscationAttribute]
private DateTime startProcessTime;
    [ObfuscationAttribute]
private bool cancel;
    [ObfuscationAttribute]
private string shapePathFilename;
    public long RecordCount { get; }
    public long CurrentRecordIndex { get; }
    public Feature CurrentFeature { get; }
    public DateTime StartProcessTime { get; }
    public bool Cancel { get; public set; }
    public string ShapePathFilename { get; }
    public RebuildingShapeFileFeatureSourceEventArgs(long recordCount, long currentRecordIndex, Feature currentFeature, DateTime startProcessTime, bool cancel);
    public RebuildingShapeFileFeatureSourceEventArgs(long recordCount, long currentRecordIndex, Feature currentFeature, DateTime startProcessTime, bool cancel, string shapePathFilename);
    public long get_RecordCount();
    public long get_CurrentRecordIndex();
    public Feature get_CurrentFeature();
    public DateTime get_StartProcessTime();
    public bool get_Cancel();
    public void set_Cancel(bool value);
    public string get_ShapePathFilename();
}
public class ThinkGeo.Core.ReceivedHttpResponseMessageEventArgs : EventArgs {
    [CompilerGeneratedAttribute]
private HttpResponseMessage 7h8=;
    public HttpResponseMessage ResponseMessage { get; public set; }
    public ReceivedHttpResponseMessageEventArgs(HttpResponseMessage responseMessage);
    [CompilerGeneratedAttribute]
public HttpResponseMessage get_ResponseMessage();
    [CompilerGeneratedAttribute]
public void set_ResponseMessage(HttpResponseMessage value);
}
[TypeConverterAttribute("ThinkGeo.Core.BaseShapeTypeConverter")]
public class ThinkGeo.Core.RectangleShape : AreaBaseShape {
    [ObfuscationAttribute]
private PointShape upperLeftPoint;
    [ObfuscationAttribute]
private PointShape lowerRightPoint;
    protected static double tolerance;
    public PointShape UpperLeftPoint { get; public set; }
    public PointShape UpperRightPoint { get; }
    public PointShape LowerRightPoint { get; public set; }
    public PointShape LowerLeftPoint { get; }
    public double Height { get; }
    public double Width { get; }
    public double MinX { get; }
    public double MaxY { get; }
    public double MaxX { get; }
    public double MinY { get; }
    public RectangleShape(PointShape upperLeftPoint, PointShape lowerRightPoint);
    public RectangleShape(double minX, double maxY, double maxX, double minY);
    public RectangleShape(string wellKnownText);
    public RectangleShape(Byte[] wellKnownBinary);
    private static RectangleShape();
    private QBw= PBw=(RectangleShape targetShape);
    private RectangleShape PRw=(RectangleShape targetShape);
    protected virtual bool IntersectsCore(BaseShape targetShape);
    public RectangleShape GetIntersection(RectangleShape targetShape);
    protected virtual WellKnownType GetWellKnownTypeCore();
    public PointShape get_UpperLeftPoint();
    public void set_UpperLeftPoint(PointShape value);
    public PointShape get_UpperRightPoint();
    public PointShape get_LowerRightPoint();
    public void set_LowerRightPoint(PointShape value);
    public PointShape get_LowerLeftPoint();
    public double get_Height();
    public double get_Width();
    public double get_MinX();
    public double get_MaxY();
    public double get_MaxX();
    public double get_MinY();
    protected virtual BaseShape CloneDeepCore();
    public PolygonShape ToPolygon();
    private bool Phw=(RectangleShape targetShape);
    public void ExpandToInclude(BaseShape targetShape);
    public void ExpandToInclude(Feature targetFeature);
    public void ExpandToInclude(IEnumerable`1<BaseShape> targetShapes);
    public void ExpandToInclude(IEnumerable`1<Feature> targetFeatures);
    protected virtual PointShape GetCenterPointCore();
    protected virtual void ExpandToIncludeCore(BaseShape targetShape);
    protected virtual double GetPerimeterCore(GeographyUnit shapeUnit, DistanceUnit returningUnit);
    protected virtual double GetAreaCore(GeographyUnit shapeUnit, AreaUnit returningUnit);
    protected virtual void ScaleUpCore(double percentage);
    protected virtual void ScaleDownCore(double percentage);
    protected virtual RectangleShape GetBoundingBoxCore();
    protected virtual BaseShape RegisterCore(PointShape fromPoint, PointShape toPoint, DistanceUnit fromUnit, GeographyUnit toUnit);
    protected virtual void TranslateByOffsetCore(double xOffsetDistance, double yOffsetDistance, GeographyUnit shapeUnit, DistanceUnit distanceUnit);
    protected virtual void TranslateByDegreeCore(double distance, double angleInDegrees, GeographyUnit shapeUnit, DistanceUnit distanceUnit);
    protected virtual PointShape GetClosestPointToCore(BaseShape targetShape, GeographyUnit shapeUnit);
    protected virtual double GetDistanceToCore(BaseShape targetShape, GeographyUnit shapeUnit, DistanceUnit distanceUnit);
    protected virtual string GetWellKnownTextCore(RingOrder outerRingOrder);
    protected virtual Byte[] GetWellKnownBinaryCore(RingOrder outerRingOrder, WkbByteOrder byteOrder);
    protected virtual void LoadFromWellKnownDataCore(string wellKnownText);
    protected virtual void LoadFromWellKnownDataCore(Byte[] wellKnownBinary);
    protected virtual bool IsDisjointedCore(BaseShape targetShape);
    private static void Pxw=(RectangleShape fromRectangle, RectangleShape toRectangle);
    protected virtual ShapeValidationResult ValidateCore(ShapeValidationMode validationMode);
    protected virtual MultipointShape GetCrossingCore(BaseShape targetShape);
    protected virtual bool ContainsCore(BaseShape targetShape);
    public virtual string ToString();
    private void JBU=(double multiplicator);
}
public class ThinkGeo.Core.RegexItem : object {
    [ObfuscationAttribute]
private string regularExpression;
    [ObfuscationAttribute]
private PointStyle defaultPointStyle;
    [ObfuscationAttribute]
private LineStyle defaultLineStyle;
    [ObfuscationAttribute]
private AreaStyle defaultAreaStyle;
    [ObfuscationAttribute]
private TextStyle defaultTextStyle;
    [ObfuscationAttribute]
private Collection`1<Style> customStyles;
    public string RegularExpression { get; public set; }
    public Collection`1<Style> CustomStyles { get; }
    public AreaStyle DefaultAreaStyle { get; public set; }
    public LineStyle DefaultLineStyle { get; public set; }
    public PointStyle DefaultPointStyle { get; public set; }
    public TextStyle DefaultTextStyle { get; public set; }
    public RegexItem(string regularExpression, AreaStyle areaStyle);
    public RegexItem(string regularExpression, LineStyle lineStyle);
    public RegexItem(string regularExpression, PointStyle pointStyle);
    public RegexItem(string regularExpression, TextStyle textStyle);
    public RegexItem(string regularExpression, Collection`1<Style> styles);
    private RegexItem(string regularExpression, AreaStyle areaStyle, LineStyle lineStyle, PointStyle pointStyle, TextStyle textStyle, Collection`1<Style> styles);
    public string get_RegularExpression();
    public void set_RegularExpression(string value);
    public Collection`1<Style> get_CustomStyles();
    public AreaStyle get_DefaultAreaStyle();
    public void set_DefaultAreaStyle(AreaStyle value);
    public LineStyle get_DefaultLineStyle();
    public void set_DefaultLineStyle(LineStyle value);
    public PointStyle get_DefaultPointStyle();
    public void set_DefaultPointStyle(PointStyle value);
    public TextStyle get_DefaultTextStyle();
    public void set_DefaultTextStyle(TextStyle value);
}
public enum ThinkGeo.Core.RegexMatching : Enum {
    public int value__;
    public static RegexMatching MatchFirstOnly;
    public static RegexMatching MatchAll;
}
public class ThinkGeo.Core.RegexStyle : Style {
    [ObfuscationAttribute]
private string columnName;
    [ObfuscationAttribute]
private Collection`1<RegexItem> regexItems;
    [ObfuscationAttribute]
private RegexMatching regexMatchingRule;
    public RegexMatching RegexMatchingRule { get; public set; }
    public string ColumnName { get; public set; }
    public Collection`1<RegexItem> RegexItems { get; }
    public RegexStyle(string columnName, Collection`1<RegexItem> regexItems);
    public RegexStyle(string columnName, Collection`1<RegexItem> regexItems, RegexMatching regexMatching);
    public RegexMatching get_RegexMatchingRule();
    public void set_RegexMatchingRule(RegexMatching value);
    public string get_ColumnName();
    public void set_ColumnName(string value);
    public Collection`1<RegexItem> get_RegexItems();
    protected virtual void DrawCore(IEnumerable`1<Feature> features, GeoCanvas canvas, Collection`1<SimpleCandidate> labelsInThisLayer, Collection`1<SimpleCandidate> labelsInAllLayers);
    protected virtual Collection`1<string> GetRequiredColumnNamesCore();
    private Collection`1<RegexItem> ZzE=(string columnValue, RegexMatching regexMatching);
    private static void RDE=(Collection`1<string> requiredFieldNames, Collection`1<string> fieldNames);
}
public class ThinkGeo.Core.RemovedGeoCollectionEventArgs : EventArgs {
    [ObfuscationAttribute]
private object item;
    [ObfuscationAttribute]
private int index;
    public object Item { get; public set; }
    public int Index { get; public set; }
    public RemovedGeoCollectionEventArgs(object item);
    public RemovedGeoCollectionEventArgs(object item, int index);
    public object get_Item();
    public void set_Item(object value);
    public int get_Index();
    public void set_Index(int value);
}
public class ThinkGeo.Core.RemovingGeoCollectionEventArgs : EventArgs {
    [ObfuscationAttribute]
private object item;
    public object Item { get; public set; }
    public RemovingGeoCollectionEventArgs(object item);
    public object get_Item();
    public void set_Item(object value);
}
public enum ThinkGeo.Core.RequestDrawingBufferTimeType : Enum {
    public int value__;
    public static RequestDrawingBufferTimeType Default;
    public static RequestDrawingBufferTimeType MinimumDelay;
    public static RequestDrawingBufferTimeType ResetDelay;
}
public class ThinkGeo.Core.RequestedDataWfsFeatureSourceEventArgs : EventArgs {
    [ObfuscationAttribute]
private string xmlResponse;
    [ObfuscationAttribute]
private string serviceUrl;
    public string XmlResponse { get; }
    public string ServiceUrl { get; }
    public RequestedDataWfsFeatureSourceEventArgs(string serviceUrl, string xmlResponse);
    public string get_XmlResponse();
    public string get_ServiceUrl();
}
public class ThinkGeo.Core.RequestedDrawingLayerEventArgs : EventArgs {
    [ObfuscationAttribute]
private TimeSpan bufferTime;
    [ObfuscationAttribute]
private RequestDrawingBufferTimeType bufferTimeType;
    [ObfuscationAttribute]
private Collection`1<RectangleShape> extentsToRefresh;
    public TimeSpan BufferTime { get; public set; }
    public RequestDrawingBufferTimeType BufferTimeType { get; public set; }
    public Collection`1<RectangleShape> ExtentsToRefresh { get; }
    public RequestedDrawingLayerEventArgs(RectangleShape extentToRefresh);
    public RequestedDrawingLayerEventArgs(IEnumerable`1<RectangleShape> extentsToRefresh);
    public RequestedDrawingLayerEventArgs(TimeSpan bufferTime);
    public RequestedDrawingLayerEventArgs(TimeSpan bufferTime, RequestDrawingBufferTimeType bufferTimeType);
    public RequestedDrawingLayerEventArgs(RectangleShape extentToRefresh, TimeSpan bufferTime);
    public RequestedDrawingLayerEventArgs(RectangleShape extentToRefresh, TimeSpan bufferTime, RequestDrawingBufferTimeType bufferTimeType);
    public RequestedDrawingLayerEventArgs(IEnumerable`1<RectangleShape> extentsToRefresh, TimeSpan bufferTime);
    public RequestedDrawingLayerEventArgs(IEnumerable`1<RectangleShape> extentsToRefresh, TimeSpan bufferTime, RequestDrawingBufferTimeType bufferTimeType);
    public TimeSpan get_BufferTime();
    public void set_BufferTime(TimeSpan value);
    public RequestDrawingBufferTimeType get_BufferTimeType();
    public void set_BufferTimeType(RequestDrawingBufferTimeType value);
    public Collection`1<RectangleShape> get_ExtentsToRefresh();
}
public class ThinkGeo.Core.RequestedImageExceptionEventArgs : EventArgs {
    [ObfuscationAttribute]
private GeoImage result;
    [ObfuscationAttribute]
private bool cancel;
    [ObsoleteAttribute("This property is obsoleted and will be removed after v14.4. Please use Exception instead.")]
[ObfuscationAttribute]
private string errorMsg;
    [ObfuscationAttribute]
private Exception exception;
    public GeoImage Result { get; public set; }
    public bool Cancel { get; public set; }
    public string ErrorMsg { get; public set; }
    public Exception Exception { get; public set; }
    [ObsoleteAttribute("This constructor is obsoleted and will be removed after v14.4.")]
public RequestedImageExceptionEventArgs(GeoImage geoImage, string errorMsg);
    public RequestedImageExceptionEventArgs(GeoImage geoImage, Exception exception);
    public GeoImage get_Result();
    public void set_Result(GeoImage value);
    public bool get_Cancel();
    public void set_Cancel(bool value);
    public string get_ErrorMsg();
    public void set_ErrorMsg(string value);
    public Exception get_Exception();
    public void set_Exception(Exception value);
}
public class ThinkGeo.Core.RequestingDataWfsFeatureSourceEventArgs : EventArgs {
    [ObfuscationAttribute]
private string serviceUrl;
    [ObfuscationAttribute]
private bool overrideResponse;
    [ObfuscationAttribute]
private string xmlResponse;
    public string ServiceUrl { get; public set; }
    public bool OverrideResponse { get; public set; }
    public string XmlResponse { get; public set; }
    public RequestingDataWfsFeatureSourceEventArgs(string serviceUrl, bool overrideResponse, string xmlResponse);
    public string get_ServiceUrl();
    public void set_ServiceUrl(string value);
    public bool get_OverrideResponse();
    public void set_OverrideResponse(bool value);
    public string get_XmlResponse();
    public void set_XmlResponse(string value);
}
public class ThinkGeo.Core.RequestingDrawingLayerEventArgs : EventArgs {
    [ObfuscationAttribute]
private TimeSpan bufferTime;
    [ObfuscationAttribute]
private RequestDrawingBufferTimeType bufferTimeType;
    [ObfuscationAttribute]
private Collection`1<RectangleShape> extentsToRefresh;
    [ObfuscationAttribute]
private bool cancel;
    public TimeSpan BufferTime { get; public set; }
    public Collection`1<RectangleShape> ExtentsToRefresh { get; }
    public RequestDrawingBufferTimeType BufferTimeType { get; public set; }
    public bool Cancel { get; public set; }
    public RequestingDrawingLayerEventArgs(RectangleShape extentToRefresh);
    public RequestingDrawingLayerEventArgs(IEnumerable`1<RectangleShape> extentsToRefresh);
    public RequestingDrawingLayerEventArgs(TimeSpan bufferTime);
    public RequestingDrawingLayerEventArgs(TimeSpan bufferTime, RequestDrawingBufferTimeType bufferTimeType);
    public RequestingDrawingLayerEventArgs(RectangleShape extentToRefresh, TimeSpan bufferTime);
    public RequestingDrawingLayerEventArgs(RectangleShape extentToRefresh, TimeSpan bufferTime, RequestDrawingBufferTimeType bufferTimeType);
    public RequestingDrawingLayerEventArgs(IEnumerable`1<RectangleShape> extentsToRefresh, TimeSpan bufferTime);
    public RequestingDrawingLayerEventArgs(IEnumerable`1<RectangleShape> extentsToRefresh, TimeSpan bufferTime, RequestDrawingBufferTimeType bufferTimeType);
    public TimeSpan get_BufferTime();
    public void set_BufferTime(TimeSpan value);
    public Collection`1<RectangleShape> get_ExtentsToRefresh();
    public RequestDrawingBufferTimeType get_BufferTimeType();
    public void set_BufferTimeType(RequestDrawingBufferTimeType value);
    public bool get_Cancel();
    public void set_Cancel(bool value);
}
public enum ThinkGeo.Core.RequestProtocol : Enum {
    public int value__;
    public static RequestProtocol Default;
    public static RequestProtocol Https;
    public static RequestProtocol Http;
}
[DebuggerNonUserCodeAttribute]
[GeneratedCodeAttribute("System.Resources.Tools.StronglyTypedResourceBuilder", "16.0.0.0")]
[ObfuscationAttribute]
[CompilerGeneratedAttribute]
internal class ThinkGeo.Core.Resources : object {
    private static ResourceManager resourceMan;
    private static CultureInfo resourceCulture;
    [EditorBrowsableAttribute("2")]
internal static ResourceManager ResourceManager { get; }
    [EditorBrowsableAttribute("2")]
internal static CultureInfo Culture { get; internal set; }
    internal static string ClientIDOrSecretInvalid { get; }
    internal static string InputMustValid { get; }
    internal static string ValueMustInRange { get; }
    internal static ResourceManager get_ResourceManager();
    internal static CultureInfo get_Culture();
    internal static void set_Culture(CultureInfo value);
    internal static string get_ClientIDOrSecretInvalid();
    internal static string get_InputMustValid();
    internal static string get_ValueMustInRange();
}
public class ThinkGeo.Core.RestrictionLayer : Layer {
    [ObfuscationAttribute]
private GeoCollection`1<Style> customStyles;
    [ObfuscationAttribute]
private Style defaultStyle;
    [ObfuscationAttribute]
private double lowerScale;
    [ObfuscationAttribute]
private RestrictionMode restrictionMode;
    [ObfuscationAttribute]
private RestrictionStyle restrictionStyle;
    [ObfuscationAttribute]
private double upperScale;
    [ObfuscationAttribute]
private GeoCollection`1<AreaBaseShape> zones;
    public double UpperScale { get; public set; }
    public double LowerScale { get; public set; }
    public GeoCollection`1<Style> CustomStyles { get; }
    public RestrictionMode RestrictionMode { get; public set; }
    public GeoCollection`1<AreaBaseShape> Zones { get; }
    public RestrictionStyle RestrictionStyle { get; public set; }
    public RestrictionLayer(IEnumerable`1<AreaBaseShape> zones);
    public RestrictionLayer(IEnumerable`1<AreaBaseShape> zones, RestrictionMode zonesToShowOrHide);
    public RestrictionLayer(IEnumerable`1<AreaBaseShape> zones, RestrictionMode zonesToShowOrHide, double upperScale, double lowerScale);
    public double get_UpperScale();
    public void set_UpperScale(double value);
    public double get_LowerScale();
    public void set_LowerScale(double value);
    public GeoCollection`1<Style> get_CustomStyles();
    public RestrictionMode get_RestrictionMode();
    public void set_RestrictionMode(RestrictionMode value);
    public GeoCollection`1<AreaBaseShape> get_Zones();
    public RestrictionStyle get_RestrictionStyle();
    public void set_RestrictionStyle(RestrictionStyle value);
    protected virtual RectangleShape GetBoundingBoxCore();
    protected virtual void DrawCore(GeoCanvas canvas, Collection`1<SimpleCandidate> labelsInAllLayers);
    private void fiM=(GeoCanvas canvas);
    private void fyM=(GeoCanvas canvas);
    private void gCM=(GeoCanvas canvas);
    private void JhU=(IEnumerable`1<Feature> features, GeoCanvas canvas);
    private static Style gSM=(Stream stream);
    private static Style giM=();
}
public enum ThinkGeo.Core.RestrictionMode : Enum {
    public int value__;
    public static RestrictionMode HideZones;
    public static RestrictionMode ShowZones;
}
public enum ThinkGeo.Core.RestrictionStyle : Enum {
    public int value__;
    public static RestrictionStyle HatchPattern;
    public static RestrictionStyle CircleWithSlashImage;
    public static RestrictionStyle UseCustomStyles;
}
public static class ThinkGeo.Core.RestrictionValidatorHelper : object {
    public static void CheckRestrictionModeIsValid(RestrictionMode restrictionMode, string parameterName);
    public static void CheckRestrictionStyleIsValid(RestrictionStyle restrictionStyle, string parameterName);
    public static void CheckRestrictionStyleIsNotConflicted(RestrictionStyle restrictionStyle, IEnumerable`1<Style> customStyles);
}
public enum ThinkGeo.Core.ReturningColumnsType : Enum {
    public int value__;
    public static ReturningColumnsType NoColumns;
    public static ReturningColumnsType AllColumns;
}
public class ThinkGeo.Core.ReverseGeocodingCloudClient : CloudClient {
    private static int 0xQ=;
    private static int pRQ=;
    public ReverseGeocodingCloudClient(string clientId, string clientSecret);
    public CloudReverseGeocodingResult SearchPointInDecimalDegree(double latitude, double longitude, double searchRadius, DistanceUnit unitOfsearchRadius);
    public CloudReverseGeocodingResult SearchPointInDecimalDegree(double latitude, double longitude, double searchRadius, DistanceUnit unitOfsearchRadius, CloudReverseGeocodingOptions options);
    public CloudReverseGeocodingResult SearchPoint(double x, double y, int pointProjectionInSrid, double searchRadius, DistanceUnit unitOfsearchRadius);
    public CloudReverseGeocodingResult SearchPoint(double x, double y, int pointProjectionInSrid, double searchRadius, DistanceUnit unitOfsearchRadius, CloudReverseGeocodingOptions options);
    public CloudReverseGeocodingResult SearchPoint(double x, double y, string pointProjectionInProj4String, double searchRadius, DistanceUnit unitOfsearchRadius);
    public CloudReverseGeocodingResult SearchPoint(double x, double y, string pointProjectionInProj4String, double searchRadius, DistanceUnit unitOfsearchRadius, CloudReverseGeocodingOptions options);
    [AsyncStateMachineAttribute("ThinkGeo.Core.ReverseGeocodingCloudClient/<SearchPointInDecimalDegreeAsync>d__10")]
public Task`1<CloudReverseGeocodingResult> SearchPointInDecimalDegreeAsync(double latitude, double longitude, double searchRadius, DistanceUnit unitOfsearchRadius);
    [AsyncStateMachineAttribute("ThinkGeo.Core.ReverseGeocodingCloudClient/<SearchPointInDecimalDegreeAsync>d__11")]
public Task`1<CloudReverseGeocodingResult> SearchPointInDecimalDegreeAsync(double latitude, double longitude, double searchRadius, DistanceUnit unitOfsearchRadius, CloudReverseGeocodingOptions options);
    [AsyncStateMachineAttribute("ThinkGeo.Core.ReverseGeocodingCloudClient/<SearchPointAsync>d__12")]
public Task`1<CloudReverseGeocodingResult> SearchPointAsync(double x, double y, int pointProjectionInSrid, double searchRadius, DistanceUnit unitOfsearchRadius);
    [AsyncStateMachineAttribute("ThinkGeo.Core.ReverseGeocodingCloudClient/<SearchPointAsync>d__13")]
public Task`1<CloudReverseGeocodingResult> SearchPointAsync(double x, double y, int pointProjectionInSrid, double searchRadius, DistanceUnit unitOfsearchRadius, CloudReverseGeocodingOptions options);
    [AsyncStateMachineAttribute("ThinkGeo.Core.ReverseGeocodingCloudClient/<SearchPointAsync>d__14")]
public Task`1<CloudReverseGeocodingResult> SearchPointAsync(double x, double y, string pointProjectionInProj4String, double searchRadius, DistanceUnit unitOfsearchRadius);
    [AsyncStateMachineAttribute("ThinkGeo.Core.ReverseGeocodingCloudClient/<SearchPointAsync>d__15")]
public Task`1<CloudReverseGeocodingResult> SearchPointAsync(double x, double y, string pointProjectionInProj4String, double searchRadius, DistanceUnit unitOfsearchRadius, CloudReverseGeocodingOptions options);
    public Collection`1<CloudReverseGeocodingResult> SearchPointsInDecimalDegree(IEnumerable`1<PointShape> points, double searchRadius, DistanceUnit unitOfsearchRadius);
    public Collection`1<CloudReverseGeocodingResult> SearchPointsInDecimalDegree(IEnumerable`1<PointShape> points, double searchRadius, DistanceUnit unitOfsearchRadius, CloudReverseGeocodingOptions options);
    public Collection`1<CloudReverseGeocodingResult> SearchPoints(IEnumerable`1<PointShape> points, int pointsProjectionInSrid, double searchRadius, DistanceUnit unitOfsearchRadius);
    public Collection`1<CloudReverseGeocodingResult> SearchPoints(IEnumerable`1<PointShape> points, int pointsProjectionInSrid, double searchRadius, DistanceUnit unitOfsearchRadius, CloudReverseGeocodingOptions options);
    public Collection`1<CloudReverseGeocodingResult> SearchPoints(IEnumerable`1<PointShape> points, string pointsProjectionInProj4String, double searchRadius, DistanceUnit unitOfsearchRadius);
    public Collection`1<CloudReverseGeocodingResult> SearchPoints(IEnumerable`1<PointShape> points, string pointsProjectionInProj4String, double searchRadius, DistanceUnit unitOfsearchRadius, CloudReverseGeocodingOptions options);
    [AsyncStateMachineAttribute("ThinkGeo.Core.ReverseGeocodingCloudClient/<SearchPointsInDecimalDegreeAsync>d__22")]
public Task`1<Collection`1<CloudReverseGeocodingResult>> SearchPointsInDecimalDegreeAsync(IEnumerable`1<PointShape> points, double searchRadius, DistanceUnit unitOfsearchRadius);
    [AsyncStateMachineAttribute("ThinkGeo.Core.ReverseGeocodingCloudClient/<SearchPointsInDecimalDegreeAsync>d__23")]
public Task`1<Collection`1<CloudReverseGeocodingResult>> SearchPointsInDecimalDegreeAsync(IEnumerable`1<PointShape> points, double searchRadius, DistanceUnit unitOfsearchRadius, CloudReverseGeocodingOptions options);
    [AsyncStateMachineAttribute("ThinkGeo.Core.ReverseGeocodingCloudClient/<SearchPointsAsync>d__24")]
public Task`1<Collection`1<CloudReverseGeocodingResult>> SearchPointsAsync(IEnumerable`1<PointShape> points, int pointsProjectionInSrid, double searchRadius, DistanceUnit unitOfsearchRadius);
    [AsyncStateMachineAttribute("ThinkGeo.Core.ReverseGeocodingCloudClient/<SearchPointsAsync>d__25")]
public Task`1<Collection`1<CloudReverseGeocodingResult>> SearchPointsAsync(IEnumerable`1<PointShape> points, int pointsProjectionInSrid, double searchRadius, DistanceUnit unitOfsearchRadius, CloudReverseGeocodingOptions options);
    [AsyncStateMachineAttribute("ThinkGeo.Core.ReverseGeocodingCloudClient/<SearchPointsAsync>d__26")]
public Task`1<Collection`1<CloudReverseGeocodingResult>> SearchPointsAsync(IEnumerable`1<PointShape> points, string pointsProjectionInProj4String, double searchRadius, DistanceUnit unitOfsearchRadius);
    [AsyncStateMachineAttribute("ThinkGeo.Core.ReverseGeocodingCloudClient/<SearchPointsAsync>d__27")]
public Task`1<Collection`1<CloudReverseGeocodingResult>> SearchPointsAsync(IEnumerable`1<PointShape> points, string pointsProjectionInProj4String, double searchRadius, DistanceUnit unitOfsearchRadius, CloudReverseGeocodingOptions options);
    public CloudReverseGeocodingResult SearchLineInDecimalDegree(LineShape line, double searchBuffer, DistanceUnit unitOfsearchBuffer);
    public CloudReverseGeocodingResult SearchLineInDecimalDegree(LineShape line, double searchBuffer, DistanceUnit unitOfsearchBuffer, CloudReverseGeocodingOptions options);
    public CloudReverseGeocodingResult SearchLine(LineShape line, int lineProjectionInSrid, double searchBuffer, DistanceUnit unitOfsearchBuffer);
    public CloudReverseGeocodingResult SearchLine(LineShape line, int lineProjectionInSrid, double searchBuffer, DistanceUnit unitOfsearchBuffer, CloudReverseGeocodingOptions options);
    public CloudReverseGeocodingResult SearchLine(LineShape line, string lineProjectionInProj4String, double searchBuffer, DistanceUnit unitOfsearchBuffer);
    public CloudReverseGeocodingResult SearchLine(LineShape line, string lineProjectionInProj4String, double searchBuffer, DistanceUnit unitOfsearchBuffer, CloudReverseGeocodingOptions options);
    [AsyncStateMachineAttribute("ThinkGeo.Core.ReverseGeocodingCloudClient/<SearchLineInDecimalDegreeAsync>d__34")]
public Task`1<CloudReverseGeocodingResult> SearchLineInDecimalDegreeAsync(LineShape line, double searchBuffer, DistanceUnit unitOfsearchBuffer);
    [AsyncStateMachineAttribute("ThinkGeo.Core.ReverseGeocodingCloudClient/<SearchLineInDecimalDegreeAsync>d__35")]
public Task`1<CloudReverseGeocodingResult> SearchLineInDecimalDegreeAsync(LineShape line, double searchBuffer, DistanceUnit unitOfsearchBuffer, CloudReverseGeocodingOptions options);
    [AsyncStateMachineAttribute("ThinkGeo.Core.ReverseGeocodingCloudClient/<SearchLineAsync>d__36")]
public Task`1<CloudReverseGeocodingResult> SearchLineAsync(LineShape line, int lineProjectionInSrid, double searchBuffer, DistanceUnit unitOfsearchBuffer);
    [AsyncStateMachineAttribute("ThinkGeo.Core.ReverseGeocodingCloudClient/<SearchLineAsync>d__37")]
public Task`1<CloudReverseGeocodingResult> SearchLineAsync(LineShape line, int lineProjectionInSrid, double searchBuffer, DistanceUnit unitOfsearchBuffer, CloudReverseGeocodingOptions options);
    [AsyncStateMachineAttribute("ThinkGeo.Core.ReverseGeocodingCloudClient/<SearchLineAsync>d__38")]
public Task`1<CloudReverseGeocodingResult> SearchLineAsync(LineShape line, string lineProjectionInProj4String, double searchBuffer, DistanceUnit unitOfsearchBuffer);
    [AsyncStateMachineAttribute("ThinkGeo.Core.ReverseGeocodingCloudClient/<SearchLineAsync>d__39")]
public Task`1<CloudReverseGeocodingResult> SearchLineAsync(LineShape line, string lineProjectionInProj4String, double searchBuffer, DistanceUnit unitOfsearchBuffer, CloudReverseGeocodingOptions options);
    public CloudReverseGeocodingResult SearchAreaInDecimalDegree(PolygonShape area);
    public CloudReverseGeocodingResult SearchAreaInDecimalDegree(PolygonShape area, CloudReverseGeocodingOptions options);
    public CloudReverseGeocodingResult SearchArea(PolygonShape area, int areaProjectionInSrid);
    public CloudReverseGeocodingResult SearchArea(PolygonShape area, int areaProjectionInSrid, CloudReverseGeocodingOptions options);
    public CloudReverseGeocodingResult SearchArea(PolygonShape area, string areaProjectionInProj4String);
    public CloudReverseGeocodingResult SearchArea(PolygonShape area, string areaProjectionInProj4String, CloudReverseGeocodingOptions options);
    [AsyncStateMachineAttribute("ThinkGeo.Core.ReverseGeocodingCloudClient/<SearchAreaInDecimalDegreeAsync>d__46")]
public Task`1<CloudReverseGeocodingResult> SearchAreaInDecimalDegreeAsync(PolygonShape area);
    [AsyncStateMachineAttribute("ThinkGeo.Core.ReverseGeocodingCloudClient/<SearchAreaInDecimalDegreeAsync>d__47")]
public Task`1<CloudReverseGeocodingResult> SearchAreaInDecimalDegreeAsync(PolygonShape area, CloudReverseGeocodingOptions options);
    [AsyncStateMachineAttribute("ThinkGeo.Core.ReverseGeocodingCloudClient/<SearchAreaAsync>d__48")]
public Task`1<CloudReverseGeocodingResult> SearchAreaAsync(PolygonShape area, int areaProjectionInSrid);
    [AsyncStateMachineAttribute("ThinkGeo.Core.ReverseGeocodingCloudClient/<SearchAreaAsync>d__49")]
public Task`1<CloudReverseGeocodingResult> SearchAreaAsync(PolygonShape area, int areaProjectionInSrid, CloudReverseGeocodingOptions options);
    [AsyncStateMachineAttribute("ThinkGeo.Core.ReverseGeocodingCloudClient/<SearchAreaAsync>d__50")]
public Task`1<CloudReverseGeocodingResult> SearchAreaAsync(PolygonShape area, string areaProjectionInProj4String);
    [AsyncStateMachineAttribute("ThinkGeo.Core.ReverseGeocodingCloudClient/<SearchAreaAsync>d__51")]
public Task`1<CloudReverseGeocodingResult> SearchAreaAsync(PolygonShape area, string areaProjectionInProj4String, CloudReverseGeocodingOptions options);
    private CloudReverseGeocodingResult 1BQ=(double x, double y, Nullable`1<int> projectionInSrid, string projectionInProj4String, double searchRadius, DistanceUnit unitOfsearchRadius, CloudReverseGeocodingOptions options);
    [AsyncStateMachineAttribute("ThinkGeo.Core.ReverseGeocodingCloudClient/<SearchPointAsync>d__53")]
private Task`1<CloudReverseGeocodingResult> 1RQ=(double x, double y, Nullable`1<int> projectionInSrid, string projectionInProj4String, double searchRadius, DistanceUnit unitOfsearchRadius, CloudReverseGeocodingOptions options);
    private Collection`1<CloudReverseGeocodingResult> 1hQ=(IEnumerable`1<PointShape> points, Nullable`1<int> projectionInSrid, string projectionInProj4String, double searchRadius, DistanceUnit unitOfsearchRadius, CloudReverseGeocodingOptions options);
    [AsyncStateMachineAttribute("ThinkGeo.Core.ReverseGeocodingCloudClient/<SearchPointsAsync>d__55")]
private Task`1<Collection`1<CloudReverseGeocodingResult>> 1xQ=(IEnumerable`1<PointShape> points, Nullable`1<int> projectionInSrid, string projectionInProj4String, double searchRadius, DistanceUnit unitOfsearchRadius, CloudReverseGeocodingOptions options);
    private CloudReverseGeocodingResult 2BQ=(LineShape line, Nullable`1<int> projectionInSrid, string projectionInProj4String, double searchBuffer, DistanceUnit unitOfsearchBuffer, CloudReverseGeocodingOptions options);
    [AsyncStateMachineAttribute("ThinkGeo.Core.ReverseGeocodingCloudClient/<SearchLineAsync>d__57")]
private Task`1<CloudReverseGeocodingResult> 2RQ=(LineShape line, Nullable`1<int> projectionInSrid, string projectionInProj4String, double searchBuffer, DistanceUnit unitOfsearchBuffer, CloudReverseGeocodingOptions options);
    private CloudReverseGeocodingResult 2hQ=(PolygonShape area, Nullable`1<int> projectionInSrid, string projectionInProj4String, CloudReverseGeocodingOptions options);
    [AsyncStateMachineAttribute("ThinkGeo.Core.ReverseGeocodingCloudClient/<SearchAreaAsync>d__59")]
private Task`1<CloudReverseGeocodingResult> 2xQ=(PolygonShape area, Nullable`1<int> projectionInSrid, string projectionInProj4String, CloudReverseGeocodingOptions options);
    private static string 3BQ=(CloudReverseGeocodingOptions options, Nullable`1<int> projectionInSrid, string projectionInProj4String, Nullable`1<double> searchRadius, Nullable`1<DistanceUnit> unitOfsearchRadius, string additionalQueryString);
    private static string 3RQ=(CloudReverseGeocodingOptions options, Nullable`1<int> projectionInSrid, string projectionInProj4String, Nullable`1<double> searchRadius, Nullable`1<DistanceUnit> unitOfsearchRadius, string wkt);
    private static CloudReverseGeocodingResult 3hQ=(WebResponse response, BaseShape queryShape);
    private static Collection`1<CloudReverseGeocodingResult> 3xQ=(WebResponse response, IEnumerable`1<PointShape> queryPoints);
}
[ObfuscationAttribute]
internal class ThinkGeo.Core.ReverseGeocodingLocationDto : object {
    [CompilerGeneratedAttribute]
private string <LocationName>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Address>k__BackingField;
    [CompilerGeneratedAttribute]
private Dictionary`2<string, string> <AddressComponents>k__BackingField;
    [CompilerGeneratedAttribute]
private Dictionary`2<string, string> <OptionalNames>k__BackingField;
    [CompilerGeneratedAttribute]
private string <LocationFeatureWellKnownText>k__BackingField;
    [CompilerGeneratedAttribute]
private string <HouseNumber>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Postcode>k__BackingField;
    [CompilerGeneratedAttribute]
private CloudLocationCategories <LocationCategory>k__BackingField;
    [CompilerGeneratedAttribute]
private Dictionary`2<string, string> <Properties>k__BackingField;
    [CompilerGeneratedAttribute]
private string <LocationType>k__BackingField;
    [CompilerGeneratedAttribute]
private double <Distance>k__BackingField;
    [CompilerGeneratedAttribute]
private string <DirectionFromQueryFeature>k__BackingField;
    public string LocationName { get; public set; }
    public string Address { get; public set; }
    public Dictionary`2<string, string> AddressComponents { get; public set; }
    public Dictionary`2<string, string> OptionalNames { get; public set; }
    public string LocationFeatureWellKnownText { get; public set; }
    public string HouseNumber { get; public set; }
    public string Postcode { get; public set; }
    public CloudLocationCategories LocationCategory { get; public set; }
    public Dictionary`2<string, string> Properties { get; public set; }
    public string LocationType { get; public set; }
    public double Distance { get; public set; }
    public string DirectionFromQueryFeature { get; public set; }
    [CompilerGeneratedAttribute]
public string get_LocationName();
    [CompilerGeneratedAttribute]
public void set_LocationName(string value);
    [CompilerGeneratedAttribute]
public string get_Address();
    [CompilerGeneratedAttribute]
public void set_Address(string value);
    [CompilerGeneratedAttribute]
public Dictionary`2<string, string> get_AddressComponents();
    [CompilerGeneratedAttribute]
public void set_AddressComponents(Dictionary`2<string, string> value);
    [CompilerGeneratedAttribute]
public Dictionary`2<string, string> get_OptionalNames();
    [CompilerGeneratedAttribute]
public void set_OptionalNames(Dictionary`2<string, string> value);
    [CompilerGeneratedAttribute]
public string get_LocationFeatureWellKnownText();
    [CompilerGeneratedAttribute]
public void set_LocationFeatureWellKnownText(string value);
    [CompilerGeneratedAttribute]
public string get_HouseNumber();
    [CompilerGeneratedAttribute]
public void set_HouseNumber(string value);
    [CompilerGeneratedAttribute]
public string get_Postcode();
    [CompilerGeneratedAttribute]
public void set_Postcode(string value);
    [CompilerGeneratedAttribute]
public CloudLocationCategories get_LocationCategory();
    [CompilerGeneratedAttribute]
public void set_LocationCategory(CloudLocationCategories value);
    [CompilerGeneratedAttribute]
public Dictionary`2<string, string> get_Properties();
    [CompilerGeneratedAttribute]
public void set_Properties(Dictionary`2<string, string> value);
    [CompilerGeneratedAttribute]
public string get_LocationType();
    [CompilerGeneratedAttribute]
public void set_LocationType(string value);
    [CompilerGeneratedAttribute]
public double get_Distance();
    [CompilerGeneratedAttribute]
public void set_Distance(double value);
    [CompilerGeneratedAttribute]
public string get_DirectionFromQueryFeature();
    [CompilerGeneratedAttribute]
public void set_DirectionFromQueryFeature(string value);
    public CloudReverseGeocodingLocation ToReverseGeocodingLocation();
}
public enum ThinkGeo.Core.RingOrder : Enum {
    public int value__;
    public static RingOrder Unknown;
    public static RingOrder Clockwise;
    public static RingOrder Counterclockwise;
}
[TypeConverterAttribute("ThinkGeo.Core.BaseShapeTypeConverter")]
public class ThinkGeo.Core.RingShape : AreaBaseShape {
    [ObfuscationAttribute]
private Collection`1<Vertex> vertices;
    public Collection`1<Vertex> Vertices { get; }
    public RingShape(IEnumerable`1<Vertex> points);
    public RingShape(string wellKnownText);
    public RingShape(Byte[] wellKnownBinary);
    protected virtual WellKnownType GetWellKnownTypeCore();
    public Collection`1<Vertex> get_Vertices();
    protected virtual BaseShape CloneDeepCore();
    public PolygonShape ToPolygon();
    protected virtual double GetPerimeterCore(GeographyUnit shapeUnit, DistanceUnit returningUnit);
    protected virtual double GetAreaCore(GeographyUnit shapeUnit, AreaUnit returningUnit);
    protected virtual void ScaleUpCore(double percentage);
    protected virtual void ScaleDownCore(double percentage);
    protected virtual RectangleShape GetBoundingBoxCore();
    protected virtual BaseShape RegisterCore(PointShape fromPoint, PointShape toPoint, DistanceUnit fromUnit, GeographyUnit toUnit);
    protected virtual void TranslateByOffsetCore(double xOffsetDistance, double yOffsetDistance, GeographyUnit shapeUnit, DistanceUnit distanceUnit);
    protected virtual void TranslateByDegreeCore(double distance, double angleInDegrees, GeographyUnit shapeUnit, DistanceUnit distanceUnit);
    protected virtual void RotateCore(PointShape pivotPoint, double degreeAngle);
    protected virtual double GetDistanceToCore(BaseShape targetShape, GeographyUnit shapeUnit, DistanceUnit distanceUnit);
    protected virtual PointShape GetClosestPointToCore(BaseShape targetShape, GeographyUnit shapeUnit);
    protected virtual string GetWellKnownTextCore(RingOrder outerRingOrder);
    protected virtual Byte[] GetWellKnownBinaryCore(RingOrder outerRingOrder, WkbByteOrder byteOrder);
    protected virtual void LoadFromWellKnownDataCore(string wellKnownText);
    protected virtual void LoadFromWellKnownDataCore(Byte[] wellKnownBinary);
    public static bool RemoveVertex(Vertex selectedVertex, RingShape ringShape);
    public bool RemoveVertex(Vertex selectedVertex);
    private static void RRw=(PolygonShape fromPolygon, RingShape toRing);
    protected virtual ShapeValidationResult ValidateCore(ShapeValidationMode validationMode);
    private static void Rhw=(RingShape ringShape);
    private void JBU=(double multiplicator);
    internal static void Rxw=(RingShape targetRingShape, double multiplicator, double centerX, double centerY);
    private void Jxw=(WkbByteOrder byteOrder, BinaryWriter writer);
    private void JRw=(WkbByteOrder byteOrder, BinaryWriter writer);
    private static void Nhw=(RingShape ringShape, StringBuilder wellKnownText);
    private static void Nxw=(RingShape ringShape, StringBuilder wellKnownText);
    public bool IsCounterClockwise();
    public void ReversePoints();
    protected virtual void ReversePointsCore();
    public bool IsSelfIntersecting();
    private static bool SBw=(Vertex Pt1, Vertex Pt2, Vertex CompPt1, Vertex CompPt2);
    private static bool SRw=(Vertex InPt1, Vertex InPt2, Vertex InCompPt1, Vertex InCompPt2);
    private static bool Shw=(double x1, double y1, double xp1, double yp1, double xp2, double yp2);
    private static bool Sxw=(double Value, double CompValue1, double CompValue2);
    private static bool TBw=(Vertex PointShape1, Vertex LinePointShape1, Vertex LinePointShape2);
    private static RectangleShape Ghw=(IEnumerable`1<Vertex> vertices);
}
public class ThinkGeo.Core.RotationProjectionConverter : ProjectionConverter {
    [ObfuscationAttribute]
private PointShape pivotCenter;
    [ObfuscationAttribute]
private double previousRotateAngle;
    [ObfuscationAttribute]
private double angle;
    [ObfuscationAttribute]
private GeographyUnit sourceUnit;
    [ObfuscationAttribute]
private bool isManualPivoit;
    [ObfuscationAttribute]
private PolygonShape previousRotationShape;
    internal PolygonShape CB8= { get; internal set; }
    internal double Cx8= { get; internal set; }
    public double Angle { get; public set; }
    public GeographyUnit InternalProjectionUnit { get; }
    public PointShape PivotCenter { get; public set; }
    public RotationProjectionConverter(double angle);
    public RotationProjectionConverter(GeographyUnit sourceUnit);
    public RotationProjectionConverter(double angle, GeographyUnit sourceUnit);
    internal PolygonShape Bh8=();
    internal void Bx8=(PolygonShape value);
    internal double CR8=();
    internal void Ch8=(double value);
    public double get_Angle();
    public void set_Angle(double value);
    public virtual GeographyUnit get_InternalProjectionUnit();
    public PointShape get_PivotCenter();
    public void set_PivotCenter(PointShape value);
    public RectangleShape GetUpdatedExtent(RectangleShape worldExtent);
    protected virtual void OpenCore();
    protected virtual Collection`1<Vertex> ConvertToExternalProjectionCore(IEnumerable`1<Vertex> verticies);
    protected virtual Collection`1<Vertex> ConvertToInternalProjectionCore(IEnumerable`1<Vertex> verticies);
    private Vertex DB8=(double x, double y, double angle);
}
[ObfuscationAttribute]
public enum ThinkGeo.Core.RouteType : Enum {
    public int value__;
    public static RouteType Fastest;
    public static RouteType Shortest;
}
public class ThinkGeo.Core.RoutingCloudClient : CloudClient {
    public RoutingCloudClient(string clientId, string clientSecret);
    public CloudRoutingGetRouteResult GetRoute(IEnumerable`1<PointShape> waypoints, CloudRoutingGetRouteOptions options);
    public CloudRoutingGetRouteResult GetRoute(IEnumerable`1<PointShape> waypoints, int srid, CloudRoutingGetRouteOptions options);
    public CloudRoutingGetRouteResult GetRoute(IEnumerable`1<PointShape> waypoints, string proj4String, CloudRoutingGetRouteOptions options);
    public Task`1<CloudRoutingGetRouteResult> GetRouteAsync(IEnumerable`1<PointShape> waypoints, CloudRoutingGetRouteOptions options);
    public Task`1<CloudRoutingGetRouteResult> GetRouteAsync(IEnumerable`1<PointShape> waypoints, int srid, CloudRoutingGetRouteOptions options);
    public Task`1<CloudRoutingGetRouteResult> GetRouteAsync(IEnumerable`1<PointShape> waypoints, string proj4String, CloudRoutingGetRouteOptions options);
    public CloudRoutingGetServiceAreaResult GetServiceArea(PointShape point, IEnumerable`1<double> serviceLimits, CloudRoutingGetServiceAreaOptions options);
    public CloudRoutingGetServiceAreaResult GetServiceArea(PointShape point, int srid, IEnumerable`1<double> serviceLimits, CloudRoutingGetServiceAreaOptions options);
    public CloudRoutingGetServiceAreaResult GetServiceArea(PointShape point, string proj4String, IEnumerable`1<double> serviceLimits, CloudRoutingGetServiceAreaOptions options);
    public CloudRoutingGetServiceAreaResult GetServiceArea(PointShape point, IEnumerable`1<TimeSpan> serviceLimits, CloudRoutingGetServiceAreaOptions options);
    public CloudRoutingGetServiceAreaResult GetServiceArea(PointShape point, int srid, IEnumerable`1<TimeSpan> serviceLimits, CloudRoutingGetServiceAreaOptions options);
    public CloudRoutingGetServiceAreaResult GetServiceArea(PointShape point, string proj4String, IEnumerable`1<TimeSpan> serviceLimits, CloudRoutingGetServiceAreaOptions options);
    public Task`1<CloudRoutingGetServiceAreaResult> GetServiceAreaAsync(PointShape point, IEnumerable`1<double> serviceLimits, CloudRoutingGetServiceAreaOptions options);
    public Task`1<CloudRoutingGetServiceAreaResult> GetServiceAreaAsync(PointShape point, int srid, IEnumerable`1<double> serviceLimits, CloudRoutingGetServiceAreaOptions options);
    public Task`1<CloudRoutingGetServiceAreaResult> GetServiceAreaAsync(PointShape point, string proj4String, IEnumerable`1<double> serviceLimits, CloudRoutingGetServiceAreaOptions options);
    public Task`1<CloudRoutingGetServiceAreaResult> GetServiceAreaAsync(PointShape point, IEnumerable`1<TimeSpan> serviceLimits, CloudRoutingGetServiceAreaOptions options);
    public Task`1<CloudRoutingGetServiceAreaResult> GetServiceAreaAsync(PointShape point, int srid, IEnumerable`1<TimeSpan> serviceLimits, CloudRoutingGetServiceAreaOptions options);
    public Task`1<CloudRoutingGetServiceAreaResult> GetServiceAreaAsync(PointShape point, string proj4String, IEnumerable`1<TimeSpan> serviceLimits, CloudRoutingGetServiceAreaOptions options);
    public CloudRoutingGetTimeCostMatrixResult GetTimeCostMatrix(IEnumerable`1<PointShape> origins, IEnumerable`1<PointShape> destinations, CloudRoutingGetCostMatrixOptions options);
    public CloudRoutingGetTimeCostMatrixResult GetTimeCostMatrix(IEnumerable`1<PointShape> origins, IEnumerable`1<PointShape> destinations, int srid, CloudRoutingGetCostMatrixOptions options);
    public CloudRoutingGetTimeCostMatrixResult GetTimeCostMatrix(IEnumerable`1<PointShape> origins, IEnumerable`1<PointShape> destinations, string proj4String, CloudRoutingGetCostMatrixOptions options);
    public Task`1<CloudRoutingGetTimeCostMatrixResult> GetTimeCostMatrixAsync(IEnumerable`1<PointShape> origins, IEnumerable`1<PointShape> destinations, CloudRoutingGetCostMatrixOptions options);
    public Task`1<CloudRoutingGetTimeCostMatrixResult> GetTimeCostMatrixAsync(IEnumerable`1<PointShape> origins, IEnumerable`1<PointShape> destinations, int srid, CloudRoutingGetCostMatrixOptions options);
    public Task`1<CloudRoutingGetTimeCostMatrixResult> GetTimeCostMatrixAsync(IEnumerable`1<PointShape> origins, IEnumerable`1<PointShape> destinations, string proj4String, CloudRoutingGetCostMatrixOptions options);
    public CloudRoutingGetDistanceCostMatrixResult GetDistanceCostMatrix(IEnumerable`1<PointShape> origins, IEnumerable`1<PointShape> destinations, CloudRoutingGetCostMatrixOptions options);
    public CloudRoutingGetDistanceCostMatrixResult GetDistanceCostMatrix(IEnumerable`1<PointShape> origins, IEnumerable`1<PointShape> destinations, int srid, CloudRoutingGetCostMatrixOptions options);
    public CloudRoutingGetDistanceCostMatrixResult GetDistanceCostMatrix(IEnumerable`1<PointShape> origins, IEnumerable`1<PointShape> destinations, string proj4String, CloudRoutingGetCostMatrixOptions options);
    public Task`1<CloudRoutingGetDistanceCostMatrixResult> GetDistanceCostMatrixAsync(IEnumerable`1<PointShape> origins, IEnumerable`1<PointShape> destinations, CloudRoutingGetCostMatrixOptions options);
    public Task`1<CloudRoutingGetDistanceCostMatrixResult> GetDistanceCostMatrixAsync(IEnumerable`1<PointShape> origins, IEnumerable`1<PointShape> destinations, int srid, CloudRoutingGetCostMatrixOptions options);
    public Task`1<CloudRoutingGetDistanceCostMatrixResult> GetDistanceCostMatrixAsync(IEnumerable`1<PointShape> origins, IEnumerable`1<PointShape> destinations, string proj4String, CloudRoutingGetCostMatrixOptions options);
    public CloudRoutingOptimizationResult GetOptimizedRoute(IEnumerable`1<PointShape> coordinates, CloudRoutingOptimizationOptions options);
    public CloudRoutingOptimizationResult GetOptimizedRoute(IEnumerable`1<PointShape> coordinates, int srid, CloudRoutingOptimizationOptions options);
    public CloudRoutingOptimizationResult GetOptimizedRoute(IEnumerable`1<PointShape> coordinates, string proj4String, CloudRoutingOptimizationOptions options);
    public Task`1<CloudRoutingOptimizationResult> GetOptimizedRouteAsync(IEnumerable`1<PointShape> coordinates, CloudRoutingOptimizationOptions options);
    public Task`1<CloudRoutingOptimizationResult> GetOptimizedRouteAsync(IEnumerable`1<PointShape> coordinates, int srid, CloudRoutingOptimizationOptions options);
    public Task`1<CloudRoutingOptimizationResult> GetOptimizedRouteAsync(IEnumerable`1<PointShape> coordinates, string proj4String, CloudRoutingOptimizationOptions options);
    private CloudRoutingGetRouteResult 4BQ=(IEnumerable`1<PointShape> waypoints, Nullable`1<int> srid, string proj4String, CloudRoutingGetRouteOptions options);
    [AsyncStateMachineAttribute("ThinkGeo.Core.RoutingCloudClient/<GetRouteCoreAsync>d__39")]
private Task`1<CloudRoutingGetRouteResult> 4RQ=(IEnumerable`1<PointShape> waypoints, Nullable`1<int> srid, string proj4String, CloudRoutingGetRouteOptions options);
    private CloudRoutingGetServiceAreaResult 4hQ=(PointShape point, Nullable`1<int> srid, string proj4String, IEnumerable`1<double> serviceLimitsDistance, IEnumerable`1<TimeSpan> serviceLimitsTime, CloudRoutingGetServiceAreaOptions options);
    [AsyncStateMachineAttribute("ThinkGeo.Core.RoutingCloudClient/<GetServiceAreaCoreAsync>d__41")]
private Task`1<CloudRoutingGetServiceAreaResult> 4xQ=(PointShape point, Nullable`1<int> srid, string proj4String, IEnumerable`1<double> serviceLimitsDistance, IEnumerable`1<TimeSpan> serviceLimitsTime, CloudRoutingGetServiceAreaOptions options);
    private CloudRoutingGetTimeCostMatrixResult 5BQ=(IEnumerable`1<PointShape> origins, IEnumerable`1<PointShape> destinations, Nullable`1<int> srid, string proj4String, CloudRoutingGetCostMatrixOptions options);
    [AsyncStateMachineAttribute("ThinkGeo.Core.RoutingCloudClient/<GetTimeCostMatrixCoreAsync>d__43")]
private Task`1<CloudRoutingGetTimeCostMatrixResult> 5RQ=(IEnumerable`1<PointShape> origins, IEnumerable`1<PointShape> destinations, Nullable`1<int> srid, string proj4String, CloudRoutingGetCostMatrixOptions options);
    private CloudRoutingGetDistanceCostMatrixResult 5hQ=(IEnumerable`1<PointShape> origins, IEnumerable`1<PointShape> destinations, Nullable`1<int> srid, string proj4String, CloudRoutingGetCostMatrixOptions options);
    [AsyncStateMachineAttribute("ThinkGeo.Core.RoutingCloudClient/<GetDistanceCostMatrixCoreAsync>d__45")]
private Task`1<CloudRoutingGetDistanceCostMatrixResult> 5xQ=(IEnumerable`1<PointShape> origins, IEnumerable`1<PointShape> destinations, Nullable`1<int> srid, string proj4String, CloudRoutingGetCostMatrixOptions options);
    private CloudRoutingOptimizationResult 6BQ=(IEnumerable`1<PointShape> coordinates, Nullable`1<int> srid, string proj4String, CloudRoutingOptimizationOptions options);
    [AsyncStateMachineAttribute("ThinkGeo.Core.RoutingCloudClient/<GetOptimizedRouteCoreAsync>d__47")]
private Task`1<CloudRoutingOptimizationResult> 6RQ=(IEnumerable`1<PointShape> coordinates, Nullable`1<int> srid, string proj4String, CloudRoutingOptimizationOptions options);
    private static CloudRoutingGetRouteResult 6hQ=(WebResponse response);
    private static CloudRoutingGetServiceAreaResult 6xQ=(WebResponse response);
    private static CloudRoutingGetTimeCostMatrixResult 7BQ=(WebResponse response);
    private static CloudRoutingGetDistanceCostMatrixResult 7RQ=(WebResponse response);
    private static CloudRoutingOptimizationResult 7hQ=(WebResponse response);
    private static string txQ=(Nullable`1<int> srid, string proj4String, CloudRoutingGetRouteOptions options);
    private static string txQ=(IEnumerable`1<double> serviceLimitsDistance, IEnumerable`1<TimeSpan> serviceLimitsTime, Nullable`1<int> srid, string proj4String, CloudRoutingGetServiceAreaOptions options);
    private static string txQ=(string costMatrixType, IEnumerable`1<PointShape> origins, IEnumerable`1<PointShape> destinations, Nullable`1<int> srid, string proj4String, CloudRoutingGetCostMatrixOptions options);
    private static string txQ=(Nullable`1<int> srid, string proj4String, CloudRoutingOptimizationOptions options);
    private static string 7xQ=(IEnumerable`1<PointShape> points);
    private static string 7xQ=(IEnumerable`1<string> items, string separator);
}
public class ThinkGeo.Core.RowColumnRange : ValueType {
    [ObfuscationAttribute]
private long minRowIndex;
    [ObfuscationAttribute]
private long maxRowIndex;
    [ObfuscationAttribute]
private long minColumnIndex;
    [ObfuscationAttribute]
private long maxColumnIndex;
    public long MinRowIndex { get; public set; }
    public long MaxRowIndex { get; public set; }
    public long MinColumnIndex { get; public set; }
    public long MaxColumnIndex { get; public set; }
    public RowColumnRange(long minRowIndex, long maxRowIndex, long minColumnIndex, long maxColumnIndex);
    public long get_MinRowIndex();
    public void set_MinRowIndex(long value);
    public long get_MaxRowIndex();
    public void set_MaxRowIndex(long value);
    public long get_MinColumnIndex();
    public void set_MinColumnIndex(long value);
    public long get_MaxColumnIndex();
    public void set_MaxColumnIndex(long value);
    public virtual int GetHashCode();
    public virtual bool Equals(object obj);
    private bool bRU=(RowColumnRange compareObj);
    public static bool op_Equality(RowColumnRange rowColumnRange1, RowColumnRange rowColumnRange2);
    public static bool op_Inequality(RowColumnRange rowColumnRange1, RowColumnRange rowColumnRange2);
}
[ObfuscationAttribute]
internal abstract class ThinkGeo.Core.RTPage : object {
    protected MemoryStream qB8=;
    [ObfuscationAttribute]
protected Byte[] arrayBuffer;
    protected Stream qR8=;
    [ObfuscationAttribute]
protected RtreeFile rTreeFile;
    [ObfuscationAttribute]
protected UInt32 pageNumber;
    [ObfuscationAttribute]
protected Gist_Ext_Id extensionId;
    protected BinaryReader qh8=;
    protected BinaryWriter qx8=;
    [ObfuscationAttribute]
protected bool isDirty;
    [ObfuscationAttribute]
public int pageSize;
    [ObfuscationAttribute]
private bool isFloat;
    internal static int rB8=;
    internal static string rR8=;
    [ObfuscationAttribute]
internal int pageHeaderSize;
    [ObfuscationAttribute]
internal int recordSetHeaderSize;
    [ObfuscationAttribute]
internal int slotSize;
    public UInt32 sB8= { get; public set; }
    public bool sh8= { get; }
    public RTPage(RtreeFile rtFile, Gist_Ext_Id extId);
    public RTPage(RtreeFile rtFile, UInt32 pageNo, Gist_Ext_Id extId);
    public RTPage(RtreeFile rtFile, UInt32 pageNo);
    public RTPage(RtreeFile rtFile);
    public virtual bool Hh8=();
    internal void QB8=();
    internal void sx8=();
    public UInt32 rh8=();
    public void rx8=(UInt32 value);
    public void tB8=();
    public Stream tR8=();
    public Gist_Ext_Id Ux8=();
    public RtreeFile th8=();
    public bool sR8=();
    public abstract virtual string LB8=();
}
[ObfuscationAttribute]
internal class ThinkGeo.Core.RtreeFile : object {
    [ObfuscationAttribute]
private HeaderPage headerPage;
    private Stream qR8=;
    private bool Zxo=;
    [ObfuscationAttribute]
private bool isReadOnly;
    [ObfuscationAttribute]
private bool isFloat;
    [ObfuscationAttribute]
private int pageSize;
    private static string tx8=;
    private static string uB8=;
    private static string uR8=;
    private static string uh8=;
    private static string ux8=;
    public int vh8= { get; public set; }
    public bool sh8= { get; }
    public int vB8=();
    public void vR8=(int value);
    public bool sR8=();
    public bool RB8=(string fileName, Gist_Ext_Id extId, Kz0= openStreamLoadingDelegate, bool isFloat);
    private void vx8=(Gist_Ext_Id extId, bool isFloat);
    public bool sB4=(string fileName, bool isReadOnly, Kz0= openStreamLoadingEvent);
    public bool QB8=();
    public bool Hh8=();
    public bool wB8=();
    public bool wR8=();
    public bool wh8=();
    public Stream tR8=();
    internal MemoryStream wx8=();
    public Gist_Ext_Id Ux8=();
    internal Ex8= xB8=();
    internal int xR8=();
    public Stream xh8=(string fileName, FileMode fileMode, FileAccess readWriteMode, Kz0= openStreamLoadingDelegate);
}
public class ThinkGeo.Core.RtreeSpatialIndex : SpatialIndex {
    [CompilerGeneratedAttribute]
private EventHandler`1<StreamLoadingEventArgs> StreamLoading;
    [ObfuscationAttribute]
private RtreeFile rTreeFile;
    [ObfuscationAttribute]
private IdsEngine idsEngine;
    [ObfuscationAttribute]
internal static double m_FillFactor;
    private static string zB8=;
    private static string zR8=;
    private static string zh8=;
    [ObfuscationAttribute]
private bool hasIdx;
    [ObfuscationAttribute]
private string pathFilename;
    [ObfuscationAttribute]
private FileAccess readWriteMode;
    public string PathFilename { get; public set; }
    public FileAccess ReadWriteMode { get; public set; }
    public RtreeSpatialIndexDataFormat DataFormat { get; }
    public bool HasIdx { get; }
    public int PageSize { get; }
    public RtreeSpatialIndex(string pathFilename);
    public RtreeSpatialIndex(string pathFilename, FileAccess readWriteMode);
    [CompilerGeneratedAttribute]
public void add_StreamLoading(EventHandler`1<StreamLoadingEventArgs> value);
    [CompilerGeneratedAttribute]
public void remove_StreamLoading(EventHandler`1<StreamLoadingEventArgs> value);
    private void zx8=(object sender, StreamLoadingEventArgs e);
    protected virtual override void Finalize();
    public sealed virtual void Dispose();
    private void kh0=(bool disposing);
    protected virtual void OnStreamLoading(StreamLoadingEventArgs e);
    public string get_PathFilename();
    public void set_PathFilename(string value);
    public FileAccess get_ReadWriteMode();
    public void set_ReadWriteMode(FileAccess value);
    public RtreeSpatialIndexDataFormat get_DataFormat();
    public void RefreshCache();
    protected virtual void DeleteCore(Feature feature);
    protected virtual void AddCore(Feature feature);
    protected virtual Collection`1<string> GetFeatureIdsIntersectingBoundingBoxCore(RectangleShape boundingBox);
    public Collection`1<string> GetFeatureIdsWithinBoundingBox(RectangleShape boundingBox);
    protected virtual Collection`1<string> GetFeatureIdsWithinBoundingBoxCore(RectangleShape boundingBox);
    public Collection`1<string> GetFeatureIdsContainingRectangleShape(RectangleShape boundingBox);
    protected virtual Collection`1<string> GetFeatureIdsContainingRectangleShapeCore(RectangleShape rectangleShape);
    public Collection`1<string> GetFeatureIdsNearestTo(PointShape pointShape, int maxReturningCount);
    protected virtual Collection`1<string> GetFeatureIdsNearestToCore(PointShape pointShape, int maxReturningCount);
    public bool get_HasIdx();
    public static RtreeSpatialIndexPageSize GetBestPageSize(int recordCount);
    public int get_PageSize();
    internal UB8= 0B8=();
    public static void CreateRectangleSpatialIndex(string pathFilename);
    public static void CreateRectangleSpatialIndex(string pathFilename, RtreeSpatialIndexPageSize pageSize);
    public static void CreateRectangleSpatialIndex(string pathFilename, RtreeSpatialIndexPageSize pageSize, RtreeSpatialIndexDataFormat dataFormat);
    public static void CreatePointSpatialIndex(string pathFilename);
    public static void CreatePointSpatialIndex(string pathFilename, RtreeSpatialIndexPageSize pageSize);
    public static void CreatePointSpatialIndex(string pathFilename, RtreeSpatialIndexPageSize pageSize, RtreeSpatialIndexDataFormat dataFormat);
    private bool 0R8=(string indexFileName, bool isFloat, RtreeSpatialIndexPageSize pageSize);
    private void 0h8=(RtreeSpatialIndexPageSize pageSize);
    private static void 0x8=(string indexFileName, bool isFloat, RtreeSpatialIndexPageSize pageSize);
    private bool 1B8=(string indexFileName, bool isFloat, RtreeSpatialIndexPageSize pageSize);
    private static void 1R8=(string indexFileName, bool isFloat, RtreeSpatialIndexPageSize pageSize);
    private bool 1h8=();
    public static bool IsRtreeSpatialIndexFileValid(string indexFileName);
    protected virtual void OpenCore();
    protected virtual void CloseCore();
    public void Flush();
    private void 1x8=(double x, double y, string pointId);
    private void 1x8=(PointShape point, string pointId);
    private void 2B8=(double x, double y);
    private void 2B8=(PointShape point);
    private void 2R8=(double upperLeftX, double upperLeftY, double lowerRightX, double lowerRightY, string rectangleId);
    private void 2R8=(RectangleShape rectangle, string rectangleId);
    private void 2h8=(double upperLeftX, double upperLeftY, double lowerRightX, double lowerRightY);
    private void 2h8=(RectangleShape rectangle);
    private Collection`1<string> 2x8=(double upperLeftX, double upperLeftY, double lowerRightX, double lowerRightY);
    private Collection`1<string> 2x8=(RectangleShape rectangle);
    private Collection`1<string> 3B8=(double upperLeftX, double upperLeftY, double lowerRightX, double lowerRightY);
    private Collection`1<string> 3B8=(RectangleShape rectangle);
    private Collection`1<string> 3R8=(double upperLeftX, double upperLeftY, double lowerRightX, double lowerRightY);
    public Collection`1<string> GetFeatureIdsIntersectingBoundingBox(RectangleShape rectangleShape, double screenWidth, double screenHeight, int simplifyPixelBufferSize, Collection`1<RectangleShape> dimensionlessBoxes);
    private Collection`1<string> 3R8=(double upperLeftX, double upperLeftY, double lowerRightX, double lowerRightY, double screenWidth, double screenHeight, int simplifyPixelBufferSize, Collection`1<RectangleShape> dimensionlessBoxes);
    private Collection`1<string> 3R8=(RectangleShape rectangle);
    private Collection`1<string> 3h8=(double x, double y, int returningRecordCount);
    private Collection`1<string> 3h8=(PointShape point, int returningRecordCount);
    private Collection`1<string> 3x8=(double x, double y, int MaxNum);
    protected virtual int GetFeatureCountCore();
    private static string 4B8=(string idxFileName);
    public RectangleShape GetBoundingBox();
    public void DeleteRecord(BaseShape shape);
    private void 2B8=(PointShape pointShape, IEnumerable`1<string> ids, IdsEngine idsEngine);
    private void 2B8=(double x, double y, IEnumerable`1<string> ids, IdsEngine idsEngine);
    private void 2h8=(RectangleShape rectangle, IEnumerable`1<string> ids, IdsEngine idsEngine);
    private void 2h8=(double upperLeftX, double upperLeftY, double lowerRightX, double lowerRightY, IEnumerable`1<string> ids, IdsEngine idsEngine);
}
public enum ThinkGeo.Core.RtreeSpatialIndexDataFormat : Enum {
    public int value__;
    public static RtreeSpatialIndexDataFormat Float;
    public static RtreeSpatialIndexDataFormat Double;
}
public enum ThinkGeo.Core.RtreeSpatialIndexPageSize : Enum {
    public int value__;
    public static RtreeSpatialIndexPageSize FourKilobytes;
    public static RtreeSpatialIndexPageSize EightKilobytes;
    public static RtreeSpatialIndexPageSize SixteenKilobytes;
    public static RtreeSpatialIndexPageSize ThirtytwoKilobytes;
}
public class ThinkGeo.Core.ScaleBarAdornmentLayer : AdornmentLayer {
    private static int nyA=;
    private static int oCA=;
    private static int oSA=;
    private static int oiA=;
    private static int oyA=;
    private static int pCA=;
    private static int pSA=;
    private static int piA=;
    private static int pyA=;
    private static int qCA=;
    [ObfuscationAttribute]
private GeoBrush barBrush;
    [ObfuscationAttribute]
private GeoBrush alternateBarBrush;
    [ObfuscationAttribute]
private Dictionary`2<string, string> displayUnitString;
    [ObfuscationAttribute]
private FeetValues feetValues;
    [ObfuscationAttribute]
private GeoFont font;
    [ObfuscationAttribute]
private int fontRatio;
    [ObfuscationAttribute]
private bool hasMask;
    [ObfuscationAttribute]
private int height;
    [ObfuscationAttribute]
private KiloMetersValues kilometersValues;
    [ObfuscationAttribute]
private UnitSystem unitFamily;
    [ObfuscationAttribute]
private GeoBrush maskBrush;
    [ObfuscationAttribute]
private GeoPen maskContour;
    [ObfuscationAttribute]
private int maxWidth;
    [ObfuscationAttribute]
private bool isMeaningfulScale;
    [ObfuscationAttribute]
private MetersValues metersValues;
    [ObfuscationAttribute]
private MilesValues milesValues;
    [ObfuscationAttribute]
private NauticalMilesValues nauticalMilesValues;
    [ObfuscationAttribute]
private string numberFormat;
    [ObfuscationAttribute]
private bool needToRefresh;
    [ObfuscationAttribute]
private ScreenPointF screenLocation;
    [ObfuscationAttribute]
private GeoColor textColor;
    [ObfuscationAttribute]
private int thickness;
    [ObfuscationAttribute]
private int width;
    [ObfuscationAttribute]
private ProjectionConverter projectionToDecimalDegrees;
    [ObfuscationAttribute]
private TextStyle textStyle;
    [ObfuscationAttribute]
private GeoPen barPen;
    public Dictionary`2<string, string> DisplayUnitString { get; }
    public UnitSystem UnitFamily { get; public set; }
    public int Thickness { get; public set; }
    public int MaxWidth { get; public set; }
    public GeoBrush BarBrush { get; public set; }
    public TextStyle TextStyle { get; public set; }
    public GeoBrush AlternateBarBrush { get; public set; }
    public GeoBrush MaskBrush { get; public set; }
    public bool HasMask { get; public set; }
    public GeoPen MaskContour { get; public set; }
    public GeoPen BarPen { get; public set; }
    public Dictionary`2<string, string> get_DisplayUnitString();
    public UnitSystem get_UnitFamily();
    public void set_UnitFamily(UnitSystem value);
    public int get_Thickness();
    public void set_Thickness(int value);
    public int get_MaxWidth();
    public void set_MaxWidth(int value);
    public GeoBrush get_BarBrush();
    public void set_BarBrush(GeoBrush value);
    public TextStyle get_TextStyle();
    public void set_TextStyle(TextStyle value);
    public GeoBrush get_AlternateBarBrush();
    public void set_AlternateBarBrush(GeoBrush value);
    public GeoBrush get_MaskBrush();
    public void set_MaskBrush(GeoBrush value);
    public bool get_HasMask();
    public void set_HasMask(bool value);
    public GeoPen get_MaskContour();
    public void set_MaskContour(GeoPen value);
    public GeoPen get_BarPen();
    public void set_BarPen(GeoPen value);
    protected virtual void OpenCore();
    protected virtual void CloseCore();
    internal void qSA=(GeoCanvas canvas, GeographyUnit mapUnit);
    private void qiA=(GeoCanvas canvas);
    private void qyA=(GeoCanvas canvas, float textWidth, int margin, Collection`1<RectangleShape> rectCollection);
    private void rCA=(GeoCanvas canvas, float textWidth, int margin, Collection`1<RectangleShape> rectCollection);
    private static double rSA=(Dictionary`2<double, double> xUnitHashTable);
    private Dictionary`2<double, double> riA=();
    private Dictionary`2<double, double> ryA=();
    private Dictionary`2<double, double> sCA=();
    private Dictionary`2<double, double> sSA=();
    private Dictionary`2<double, double> siA=();
    private static void syA=(int i, Dictionary`2<double, double> xHashTable, Double[] xValues);
    private Collection`1<RectangleShape> tCA=(Dictionary`2<double, double> hashTable);
    protected virtual void DrawCore(GeoCanvas canvas, Collection`1<SimpleCandidate> labelsInAllLayers);
}
public class ThinkGeo.Core.ScaleLineAdornmentLayer : AdornmentLayer {
    private static int tSA=;
    private static int tiA=;
    [ObfuscationAttribute]
private int bottomLengthPixel;
    [ObfuscationAttribute]
private string bottomString;
    [ObfuscationAttribute]
private Dictionary`2<string, string> displayUnitString;
    [ObfuscationAttribute]
private int scaleLineHeightInPixel;
    [ObfuscationAttribute]
private int scaleLineWidthInPixel;
    [ObfuscationAttribute]
private int topLengthPixel;
    [ObfuscationAttribute]
private string topString;
    [ObfuscationAttribute]
private ScaleLineUnitSystem unitSystem;
    [ObfuscationAttribute]
private ProjectionConverter projectionToDecimalDegrees;
    [ObfuscationAttribute]
private TextStyle textStyle;
    [ObfuscationAttribute]
private GeoPen pen;
    [ObfuscationAttribute]
private GeoPen backPen;
    public Dictionary`2<string, string> DisplayUnitString { get; }
    public ScaleLineUnitSystem UnitSystem { get; public set; }
    public TextStyle TextStyle { get; public set; }
    public GeoPen Pen { get; public set; }
    public GeoPen HaloPen { get; public set; }
    public ScaleLineAdornmentLayer(ScreenPointF startPoint);
    public ScaleLineAdornmentLayer(AdornmentLocation location);
    public Dictionary`2<string, string> get_DisplayUnitString();
    public ScaleLineUnitSystem get_UnitSystem();
    public void set_UnitSystem(ScaleLineUnitSystem value);
    protected virtual void DrawCore(GeoCanvas canvas, Collection`1<SimpleCandidate> labelsInAllLayers);
    public TextStyle get_TextStyle();
    public void set_TextStyle(TextStyle value);
    public GeoPen get_Pen();
    public void set_Pen(GeoPen value);
    public GeoPen get_HaloPen();
    public void set_HaloPen(GeoPen value);
    protected virtual void OpenCore();
    protected virtual void CloseCore();
    private void tyA=(GeoCanvas canvas);
    private void rCA=(GeoCanvas canvas, int topBarHeight, int bottomBarHeight, ScreenPointF startPointF);
    private static string uCA=(string text, GeoFont font, int lengthPixel, GeoCanvas canvas);
    private bool uSA=(GeoCanvas canvas, GeographyUnit mapUnit);
    private static int uiA=(int maxLength);
}
public enum ThinkGeo.Core.ScaleLineUnitSystem : Enum {
    public int value__;
    public static ScaleLineUnitSystem Default;
    public static ScaleLineUnitSystem MetricAndNauticalMile;
    public static ScaleLineUnitSystem NauticalMileAndImperial;
    public static ScaleLineUnitSystem ImperialAndMetric;
}
public class ThinkGeo.Core.ScaleTextAdornmentLayer : AdornmentLayer {
    private static int pCA=;
    private static int pyA=;
    [ObfuscationAttribute]
private ScaleTextScreenUnit screenUnit;
    [ObfuscationAttribute]
private DistanceUnit worldUnit;
    [ObfuscationAttribute]
private GeoFont font;
    [ObfuscationAttribute]
private GeoBrush textBrush;
    [ObfuscationAttribute]
private int width;
    [ObfuscationAttribute]
private int height;
    [ObfuscationAttribute]
private ScreenPointF screenLocation;
    [ObfuscationAttribute]
private bool needToRefresh;
    public ScaleTextScreenUnit ScreenUnit { get; public set; }
    public DistanceUnit WorldUnit { get; public set; }
    public GeoFont Font { get; public set; }
    public GeoBrush TextBrush { get; public set; }
    public ScaleTextAdornmentLayer(ScaleTextScreenUnit screenUnit, DistanceUnit worldUnit);
    public ScaleTextAdornmentLayer(ScaleTextScreenUnit screenUnit, DistanceUnit worldUnit, GeoFont font, GeoBrush textBrush);
    public ScaleTextScreenUnit get_ScreenUnit();
    public void set_ScreenUnit(ScaleTextScreenUnit value);
    public DistanceUnit get_WorldUnit();
    public void set_WorldUnit(DistanceUnit value);
    public GeoFont get_Font();
    public void set_Font(GeoFont value);
    public GeoBrush get_TextBrush();
    public void set_TextBrush(GeoBrush value);
    protected virtual void DrawCore(GeoCanvas canvas, Collection`1<SimpleCandidate> labelsInAllLayers);
    private double uyA=(double amount, ScaleTextScreenUnit fromUnit, ScaleTextScreenUnit toUnit);
    private void qSA=(GeoCanvas canvas, GeographyUnit mapUnit);
}
public enum ThinkGeo.Core.ScaleTextScreenUnit : Enum {
    public int value__;
    public static ScaleTextScreenUnit Inch;
    public static ScaleTextScreenUnit Centimeter;
}
public class ThinkGeo.Core.ScreenPoint : ValueType {
    [ObfuscationAttribute]
private int x;
    [ObfuscationAttribute]
private int y;
    public int X { get; }
    public int Y { get; }
    public ScreenPoint(int x, int y);
    public int get_X();
    public int get_Y();
    public virtual string ToString();
    public static bool op_Equality(ScreenPoint screenPoint1, ScreenPoint screenPoint2);
    public static bool op_Inequality(ScreenPoint screenPoint1, ScreenPoint screenPoint2);
    public virtual bool Equals(object obj);
    private bool bRU=(ScreenPoint compareObj);
    public virtual int GetHashCode();
}
[IsReadOnlyAttribute]
public class ThinkGeo.Core.ScreenPointD : ValueType {
    [CompilerGeneratedAttribute]
private double 0Bs=;
    [CompilerGeneratedAttribute]
private double 0Rs=;
    public double X { get; }
    public double Y { get; }
    public ScreenPointD(double x, double y);
    [CompilerGeneratedAttribute]
public double get_X();
    [CompilerGeneratedAttribute]
public double get_Y();
    public virtual string ToString();
    public static bool op_Equality(ScreenPointD p1, ScreenPointD p2);
    public static bool op_Inequality(ScreenPointD p1, ScreenPointD p2);
    public virtual bool Equals(object obj);
    private bool bRU=(ScreenPointF compareObj);
    public virtual int GetHashCode();
}
public class ThinkGeo.Core.ScreenPointF : ValueType {
    [ObfuscationAttribute]
private float x;
    [ObfuscationAttribute]
private float y;
    public float X { get; }
    public float Y { get; }
    public ScreenPointF(float x, float y);
    public float get_X();
    public float get_Y();
    public virtual string ToString();
    public static bool op_Equality(ScreenPointF screenPointF1, ScreenPointF screenPointF2);
    public static bool op_Inequality(ScreenPointF screenPointF1, ScreenPointF screenPointF2);
    public virtual bool Equals(object obj);
    private bool bRU=(ScreenPointF compareObj);
    public virtual int GetHashCode();
}
public class ThinkGeo.Core.SendingHttpRequestMessageEventArgs : EventArgs {
    [CompilerGeneratedAttribute]
private HttpRequestMessage 7x8=;
    [CompilerGeneratedAttribute]
private bool ixQ=;
    public HttpRequestMessage HttpRequestMessage { get; public set; }
    public bool Cancel { get; public set; }
    public SendingHttpRequestMessageEventArgs(HttpRequestMessage webRequest);
    public SendingHttpRequestMessageEventArgs(HttpRequestMessage webRequest, bool cancel);
    [CompilerGeneratedAttribute]
public HttpRequestMessage get_HttpRequestMessage();
    [CompilerGeneratedAttribute]
public void set_HttpRequestMessage(HttpRequestMessage value);
    [CompilerGeneratedAttribute]
public bool get_Cancel();
    [CompilerGeneratedAttribute]
public void set_Cancel(bool value);
}
public class ThinkGeo.Core.SendingWebRequestEventArgs : EventArgs {
    [ObfuscationAttribute]
private WebRequest webRequest;
    [ObfuscationAttribute]
private bool cancel;
    public WebRequest WebRequest { get; public set; }
    public bool Cancel { get; public set; }
    public SendingWebRequestEventArgs(WebRequest webRequest);
    public SendingWebRequestEventArgs(WebRequest webRequest, bool cancel);
    public WebRequest get_WebRequest();
    public void set_WebRequest(WebRequest value);
    public bool get_Cancel();
    public void set_Cancel(bool value);
}
public class ThinkGeo.Core.SentWebRequestEventArgs : EventArgs {
    [ObfuscationAttribute]
private WebResponse response;
    public WebResponse Response { get; public set; }
    public SentWebRequestEventArgs(WebResponse response);
    public WebResponse get_Response();
    public void set_Response(WebResponse value);
}
public class ThinkGeo.Core.SerializerHelper : object {
    public static T SerializeCloneDeep(object instance);
    public static Byte[] Serialize(object instance);
    public static T Deserialize(Byte[] bytes);
}
public class ThinkGeo.Core.SessionFileRasterTileCache : FileRasterTileCache {
    [ObfuscationAttribute]
private Collection`1<string> obsoleteCacheIds;
    private static object VhY=;
    private Thread jR0=;
    public SessionFileRasterTileCache(string cacheDirectory);
    public SessionFileRasterTileCache(string cacheDirectory, string cacheId);
    public SessionFileRasterTileCache(string cacheDirectory, string cacheId, GeoImageFormat imageFormat);
    private static SessionFileRasterTileCache();
    protected virtual void ClearCacheCore();
    private void jh0=();
    private Collection`1<string> jx0=();
}
public static class ThinkGeo.Core.ShapeConverter : object {
    [CompilerGeneratedAttribute]
private static EventHandler`1<ConvertedShapeToNtsGeometryShapeConverterEventArgs> ConvertedShapeToNtsGeometry;
    private static WkbByteOrder 0hs=;
    private static WKBReader 0xs=;
    private static ShapeConverter();
    [CompilerGeneratedAttribute]
public static void add_ConvertedShapeToNtsGeometry(EventHandler`1<ConvertedShapeToNtsGeometryShapeConverterEventArgs> value);
    [CompilerGeneratedAttribute]
public static void remove_ConvertedShapeToNtsGeometry(EventHandler`1<ConvertedShapeToNtsGeometryShapeConverterEventArgs> value);
    internal static BaseShape 1Bs=(Geometry targetJtsShape);
    internal static Geometry 1Rs=(BaseShape targetShape);
    internal static Geometry 1Rs=(Byte[] wkb);
    internal static void 1hs=(WkbShapeType wkbShapeType, WkbByteOrder byteOrder, BinaryWriter writer);
    internal static void 1hs=(int wkbShapeType, WkbByteOrder byteOrder, BinaryWriter writer);
    internal static void 1hs=(double value, WkbByteOrder byteOrder, BinaryWriter writer);
    internal static BaseShape 1xs=(Byte[] wkb);
    private static BaseShape 2Bs=(BinaryReader binaryReader);
    private static PointShape 2Rs=(BinaryReader binaryReader);
    private static Vertex 2hs=(BinaryReader binaryReader);
    private static LineShape 2xs=(BinaryReader binaryReader);
    private static PolygonShape 0Ro=(BinaryReader binaryReader);
    private static MultipointShape 3Bs=(BinaryReader binaryReader);
    private static MultilineShape 3Rs=(BinaryReader binaryReader);
    private static GeometryCollectionShape 3hs=(BinaryReader binaryReader);
    private static MultipolygonShape 3xs=(BinaryReader binaryReader);
    private static RingShape 4Bs=(BinaryReader binaryReader);
    private static void 4Rs=(BinaryReader binaryReader);
    private static void 4hs=(BinaryReader binaryReader, WkbShapeType wkbShapeType);
    private static int 4xs=(BinaryReader binaryReader);
    private static double 5Bs=(BinaryReader binaryReader);
    internal static Vertex 5Rs=(string oneVertexWkt);
    internal static string 5hs=(string oneVertexWkt, Vertex vertex);
}
[ObfuscationAttribute]
[ObfuscationAttribute]
internal class ThinkGeo.Core.ShapeFile : object {
    private static int mSM=;
    private static int miM=;
    private static int myM=;
    private static int nCM=;
    private static int nSM=;
    private static int OR8=;
    [ObfuscationAttribute]
private string pathFilename;
    private bool Zxo=;
    private Stream niM=;
    [ObfuscationAttribute]
private ShapeFileIndex shx;
    [CompilerGeneratedAttribute]
private EventHandler`1<StreamLoadingEventArgs> StreamLoading;
    private static Byte[] nyM=;
    private static Byte[] oCM=;
    public string oyM= { get; public set; }
    public ShapeFileIndex pSM= { get; }
    public ShapeFileType pyM= { get; }
    public ShapeFile(string pathFilename);
    private static ShapeFile();
    [CompilerGeneratedAttribute]
public void PB8=(EventHandler`1<StreamLoadingEventArgs> value);
    [CompilerGeneratedAttribute]
public void PR8=(EventHandler`1<StreamLoadingEventArgs> value);
    public string oSM=();
    public void oiM=(string value);
    public ShapeFileIndex pCM=();
    public ShapeFileType piM=();
    public virtual void Px8=(StreamLoadingEventArgs e);
    public string qCM=(int recordIndex);
    public int Ix8=();
    public static void qSM=(string pathFilename, ShapeFileType shapeType);
    private static void qiM=(string pathFilename, ShapeFileType shapeType);
    public void sB4=(FileAccess readWriteMode);
    public void QB8=();
    public RectangleShape qyM=();
    public ShapeFileType rCM=();
    public RectangleShape rSM=(int recordIndex);
    public void ZSE=(BaseShape targetShape);
    public void HR8=(int recordIndex);
    public void ZiE=(int index, BaseShape targetShape);
    public void Hh8=();
    public void Qh8=();
    public Byte[] riM=(int recordIndex);
    private Byte[] ryM=(Byte[] dataBytes, int startIndex);
    private int sCM=(BaseShape targetShape);
    private int sSM=(MultipolygonShape targetShape, Stream stream);
    private static List`1<RingShape> siM=(MultipolygonShape targetShape);
    private int syM=(MultilineShape targetShape, Stream stream);
    private int tCM=(MultipointShape targetShape, Stream stream);
    private static int tSM=(PointShape targetShape, Stream stream);
    private static Byte[] axw=(Byte[] dataBytes, int startIndex);
    private static MultipolygonShape tiM=(RingShape[] ringShapes);
    private static void tyM=(RingShape innerRing, MultipolygonShape multiPolygonShape, List`1<RectangleShape> polygonBoundingBoxes);
    private static Byte[] uCM=(MultipolygonShape multipolygon);
    private static Byte[] uSM=(PolygonShape polygonShape);
    private static Byte[] aRw=(Byte[] dataBytes, int startIndex);
    private static Byte[] uiM=(Byte[] dataBytes, int startIndex);
    private static Byte[] uyM=(Byte[] dataBytes, int startIndex);
    private static Byte[] vCM=(int partsCount, Byte[] dataBytes, int startIndex);
    private static void QR0=(Byte[] sourceArray, Byte[] destinateArray, long destinateIndex);
    private static int FBU=(Byte[] wkb, int startIndex, byte byteOrder);
    internal static int vSM=(Stream stream, WkbByteOrder byteOrder);
    internal static void viM=(int value, Stream stream, WkbByteOrder byteOrder);
    private static void vyM=(double value, Stream stream, WkbByteOrder byteOrder);
    internal static int wCM=(ShapeFileType shapeFileType);
    private static ShapeFileBoundingBox wSM=(RectangleShape rectangleShape);
    private static bool wiM=(Vertex p, RingShape ring);
    private static int wyM=(double x1, double y1, double x2, double y2);
    private static Byte[] xCM=(Byte[] dataBytes, int startIndex);
    private static void xSM=(Collection`1<SD0=> outerWkbRing, RectangleShape outerRingBoudingBox, Collection`1<SD0=> innerWkbRings, Collection`1<RectangleShape> innerRingsBoudingBoxes);
    private static bool xiM=(SD0= innerWkbRing, RectangleShape innerRingsBoudingBox, Collection`1<Collection`1<SD0=>> outerWkbRings, Collection`1<RectangleShape> outerRingBoudingBoxes);
}
[ObfuscationAttribute]
internal class ThinkGeo.Core.ShapeFileBoundingBox : object {
    private static int xyM=;
    private static int yCM=;
    [ObfuscationAttribute]
private double minX;
    [ObfuscationAttribute]
private double maxX;
    [ObfuscationAttribute]
private double minY;
    [ObfuscationAttribute]
private double maxY;
    public double yyM= { get; public set; }
    public double ziM= { get; public set; }
    public double 0SM= { get; public set; }
    public double 1CM= { get; public set; }
    public double ySM=();
    public void yiM=(double value);
    public double zCM=();
    public void zSM=(double value);
    public double zyM=();
    public void 0CM=(double value);
    public double 0iM=();
    public void 0yM=(double value);
    public static ShapeFileBoundingBox 1SM=(Stream stream);
    public void 1iM=(ShapeFileBoundingBox targetBox);
    public void 1yM=(Stream stream, bool isHeaderBoundingBox);
    private static Byte[] fxo=(double doubleValue, byte byteOrder);
    internal RectangleShape 2CM=();
}
public class ThinkGeo.Core.ShapeFileFeatureLayer : FeatureLayer {
    private static int 2SM=;
    [ObfuscationAttribute]
private int progressiveDrawingRecordsCount;
    public bool HasBoundingBox { get; }
    public bool UsingSpatialIndex { get; }
    public Encoding Encoding { get; public set; }
    public string ShapePathFilename { get; public set; }
    public string IndexPathFilename { get; public set; }
    public FileAccess ReadWriteMode { get; public set; }
    public bool RequireIndex { get; public set; }
    public int ProgressiveDrawingRecordsCount { get; public set; }
    public int SimplificationAreaInPixel { get; public set; }
    public ShapeFileFeatureLayer(string shapePathFilename);
    public ShapeFileFeatureLayer(string shapePathFilename, FileAccess readWriteMode);
    public ShapeFileFeatureLayer(string shapePathFilename, string indexPathFilename);
    public ShapeFileFeatureLayer(string shapePathFilename, string indexPathFilename, FileAccess readWriteMode);
    public ShapeFileFeatureLayer(string shapePathFilename, string indexPathFilename, FileAccess readWriteMode, Encoding encoding);
    public void add_StreamLoading(EventHandler`1<StreamLoadingEventArgs> value);
    public void remove_StreamLoading(EventHandler`1<StreamLoadingEventArgs> value);
    public virtual bool get_HasBoundingBox();
    public bool get_UsingSpatialIndex();
    public Encoding get_Encoding();
    public void set_Encoding(Encoding value);
    public string get_ShapePathFilename();
    public void set_ShapePathFilename(string value);
    public string get_IndexPathFilename();
    public void set_IndexPathFilename(string value);
    public FileAccess get_ReadWriteMode();
    public void set_ReadWriteMode(FileAccess value);
    public bool get_RequireIndex();
    public void set_RequireIndex(bool value);
    public int get_ProgressiveDrawingRecordsCount();
    public void set_ProgressiveDrawingRecordsCount(int value);
    public int get_SimplificationAreaInPixel();
    public void set_SimplificationAreaInPixel(int value);
    protected virtual LayerBase CloneDeepCore();
    public static void Rebuild(string shapePathFilename);
    public static void Rebuild(string shapePathFilename, ShapeFileSortingMode sortingMode, int sridForSorting);
    public static void CreateShapeFile(ShapeFileType shapeType, string pathFilename, IEnumerable`1<DbfColumn> databaseColumns);
    public static void CreateShapeFile(ShapeFileType shapeType, string pathFilename, IEnumerable`1<DbfColumn> databaseColumns, Encoding encoding);
    public static void CreateShapeFile(ShapeFileType shapeType, string pathFilename, IEnumerable`1<DbfColumn> databaseColumns, Encoding encoding, OverwriteMode overwriteMode);
    public static void BuildIndexFile(string pathFilename);
    public static void BuildIndexFile(string shapePathFilename, string indexPathFilename, BuildIndexMode buildIndexMode);
    public static void BuildIndexFile(string pathFilename, BuildIndexMode rebuildExistingIndexMode);
    public static void BuildIndexFile(IEnumerable`1<Feature> features, string indexPathFilename);
    public static void BuildIndexFile(IEnumerable`1<Feature> features, string indexPathFilename, ProjectionConverter projectionConverter);
    public static void BuildIndexFile(IEnumerable`1<Feature> features, string indexPathFilename, BuildIndexMode buildIndexMode);
    public static void BuildIndexFile(IEnumerable`1<Feature> features, string indexPathFilename, ProjectionConverter projectionConverter, BuildIndexMode buildIndexMode);
    public static void BuildIndexFile(string shapePathFilename, string indexPathFilename, string columnName, string regularExpression, BuildIndexMode buildIndexMode);
    public static void BuildIndexFile(string shapePathFilename, string indexPathFilename, ProjectionConverter projectionConverter, string columnName, string regularExpression, BuildIndexMode buildIndexMode);
    public static void BuildIndexFile(string shapePathFilename, string indexPathFilename, ProjectionConverter projectionConverter, string columnName, string regularExpression, BuildIndexMode buildIndexMode, Encoding encoding);
    public static void CloneShapeFileStructure(string sourceShapePathFilename, string targetShapePathFilename);
    public static void CloneShapeFileStructure(string sourceShapePathFilename, string targetShapePathFilename, OverwriteMode overwriteMode);
    public static void CloneShapeFileStructure(string sourceShapePathFilename, string targetShapePathFilename, OverwriteMode overwriteMode, Encoding encoding);
    public static void BuildRecordIdColumn(string shapeFilename, string fieldname, BuildRecordIdMode rebuildNeeded);
    public static void BuildRecordIdColumn(string shapeFilename, string fieldname, BuildRecordIdMode rebuildNeeded, int startNumber);
    public static void BuildRecordIdColumn(string shapeFilename, string fieldname, BuildRecordIdMode rebuildNeeded, int startNumber, Encoding encoding);
    public ShapeFileType GetShapeFileType();
    public static void Reproject(string sourceShapeFile, string targetShapeFile, ProjectionConverter projectionConverter, OverwriteMode overwriteMode);
    public Dictionary`2<string, string> Validate();
    public static Collection`1<DbfColumn> GetValidColumns(IEnumerable`1<DbfColumn> columns);
    public static Collection`1<DbfColumn> GetValidColumns(IEnumerable`1<DbfColumn> columns, Encoding encoding);
    public static Collection`1<string> GetValidColumnNames(IEnumerable`1<string> columnNames);
    public static Collection`1<string> GetValidColumnNames(IEnumerable`1<string> columnNames, Encoding encoding);
    protected virtual void DrawCore(GeoCanvas canvas, Collection`1<SimpleCandidate> labelsInAllLayers);
    private static BaseShape CSQ=(ShapeFileType shapeFileType, RectangleShape boundingBox);
    private void CiQ=(GeoCanvas canvas, RectangleShape marginWorldExtent, Collection`1<SimpleCandidate> labelsInThisLayer, Collection`1<SimpleCandidate> labelsInAllLayers, ZoomLevel currentZoomLevel, Collection`1<string> columnNames, ShapeFileFeatureSource shapeFileFeatureSource, Collection`1<RectangleShape> smallBoxes, Collection`1<string> ids);
    private void CyQ=(GeoCanvas canvas, RectangleShape drawingExtent, Collection`1<SimpleCandidate> labelsInAllLayers, ZoomLevel currentZoomLevel, Collection`1<string> columnNames, ShapeFileFeatureSource shapeFileFeatureSource, Collection`1<string> idsToDraw);
    private RectangleShape DCQ=(RectangleShape boundingBox);
    private bool 6SM=(int progressPercentage, object userState, int featuresToDraw, int featuresDrawn);
    private static void DSQ=(Collection`1<RectangleShape> smallBoxes, Collection`1<Feature> resultFeatures, Collection`1<string> columnNames);
    private static void DiQ=(Collection`1<RectangleShape> smallBoxes, Collection`1<Feature> resultFeatures, Collection`1<string> columnNames);
    private static void DyQ=(Collection`1<RectangleShape> smallBoxes, Collection`1<Feature> resultFeatures, Collection`1<string> columnNames);
    private void 5h8=(object sender, DrawingProgressChangedEventArgs e);
    private static BaseShape cRo=(ProjectionConverter projection, BaseShape shape);
}
public class ThinkGeo.Core.ShapeFileFeatureSource : FeatureSource {
    private static int 2SM=;
    private GeoDbf 2iM=;
    [ObfuscationAttribute]
private FileAccess readWriteMode;
    [ObfuscationAttribute]
private string indexPathFilename;
    [ObfuscationAttribute]
private bool requireIndex;
    private RtreeSpatialIndex XiE=;
    private ShapeFile 2yM=;
    private FileAccess 3CM=;
    [ObfuscationAttribute]
private string shapePathFilename;
    private Encoding rB4=;
    [ObfuscationAttribute]
private int codePage;
    [ObfuscationAttribute]
private int simplificationAreaInPixel;
    [ObfuscationAttribute]
private Collection`1<RectangleShape> simplifiedAreas;
    [CompilerGeneratedAttribute]
private EventHandler`1<StreamLoadingEventArgs> StreamLoading;
    [CompilerGeneratedAttribute]
private static EventHandler`1<BuildingIndexShapeFileFeatureSourceEventArgs> BuildingIndex;
    [CompilerGeneratedAttribute]
private static EventHandler`1<RebuildingShapeFileFeatureSourceEventArgs> Rebuilding;
    public string ShapePathFilename { get; public set; }
    public string IndexPathFilename { get; public set; }
    public FileAccess ReadWriteMode { get; public set; }
    public bool IsEditable { get; }
    public bool UsingSpatialIndex { get; }
    public bool RequireIndex { get; public set; }
    public Encoding Encoding { get; public set; }
    public int SimplificationAreaInPixel { get; public set; }
    public Collection`1<RectangleShape> SimplifiedAreas { get; }
    public ShapeFileFeatureSource(string shapePathFilename);
    public ShapeFileFeatureSource(string shapePathFilename, FileAccess readWriteMode);
    public ShapeFileFeatureSource(string shapePathFilename, string indexPathFilename);
    public ShapeFileFeatureSource(string shapePathFilename, string indexPathFilename, FileAccess readWriteMode);
    public ShapeFileFeatureSource(string shapePathFilename, string indexPathFilename, FileAccess readWriteMode, Encoding encoding);
    public string get_ShapePathFilename();
    public void set_ShapePathFilename(string value);
    public string get_IndexPathFilename();
    public void set_IndexPathFilename(string value);
    public FileAccess get_ReadWriteMode();
    public void set_ReadWriteMode(FileAccess value);
    public virtual bool get_IsEditable();
    public bool get_UsingSpatialIndex();
    public bool get_RequireIndex();
    public void set_RequireIndex(bool value);
    public Encoding get_Encoding();
    public void set_Encoding(Encoding value);
    public int get_SimplificationAreaInPixel();
    public void set_SimplificationAreaInPixel(int value);
    public Collection`1<RectangleShape> get_SimplifiedAreas();
    [CompilerGeneratedAttribute]
public void add_StreamLoading(EventHandler`1<StreamLoadingEventArgs> value);
    [CompilerGeneratedAttribute]
public void remove_StreamLoading(EventHandler`1<StreamLoadingEventArgs> value);
    [CompilerGeneratedAttribute]
public static void add_BuildingIndex(EventHandler`1<BuildingIndexShapeFileFeatureSourceEventArgs> value);
    [CompilerGeneratedAttribute]
public static void remove_BuildingIndex(EventHandler`1<BuildingIndexShapeFileFeatureSourceEventArgs> value);
    [CompilerGeneratedAttribute]
public static void add_Rebuilding(EventHandler`1<RebuildingShapeFileFeatureSourceEventArgs> value);
    [CompilerGeneratedAttribute]
public static void remove_Rebuilding(EventHandler`1<RebuildingShapeFileFeatureSourceEventArgs> value);
    protected virtual FeatureSource CloneDeepCore();
    protected virtual void OnStreamLoading(StreamLoadingEventArgs e);
    protected static void OnBuildingIndex(BuildingIndexShapeFileFeatureSourceEventArgs e);
    protected static void OnRebuilding(RebuildingShapeFileFeatureSourceEventArgs e);
    public static void Rebuild(string shapePathFilename);
    public static void Rebuild(string shapePathFilename, ShapeFileSortingMode sortingMode, int sridForSorting);
    private static void 3SM=(string shapePathFilename, ShapeFileSortingMode sortingMode, int srid);
    public static void BuildIndexFile(string shapePathFilename);
    public static void BuildIndexFile(string shapePathFilename, BuildIndexMode buildIndexMode);
    public static void BuildIndexFile(string shapePathFilename, string indexPathFilename, BuildIndexMode buildIndexMode);
    public static void BuildIndexFile(string shapePathFilename, string indexPathFilename, ProjectionConverter projectionConverter, BuildIndexMode buildIndexMode);
    public static void BuildIndexFile(string shapePathFilename, string indexPathFilename, string columnName, string regularExpression, BuildIndexMode buildIndexMode);
    public static void BuildIndexFile(string shapePathFilename, string indexPathFilename, ProjectionConverter projectionConverter, string columnName, string regularExpression, BuildIndexMode buildIndexMode);
    public static void BuildIndexFile(string shapePathFilename, string indexPathFilename, ProjectionConverter projectionConverter, string columnName, string regularExpression, BuildIndexMode buildIndexMode, Encoding encoding);
    public static void BuildIndexFile(IEnumerable`1<Feature> features, string indexPathFilename);
    public static void BuildIndexFile(IEnumerable`1<Feature> features, string indexPathFilename, ProjectionConverter projectionConverter);
    public static void BuildIndexFile(IEnumerable`1<Feature> features, string indexPathFilename, BuildIndexMode buildIndexMode);
    public static void BuildIndexFile(IEnumerable`1<Feature> features, string indexPathFilename, ProjectionConverter projectionConverter, BuildIndexMode buildIndexMode);
    private static void 3iM=(BaseShape baseShape, RtreeSpatialIndex openedRtree, ProjectionConverter openedProjection);
    public static Collection`1<DbfColumn> GetValidColumns(IEnumerable`1<DbfColumn> columns);
    public static Collection`1<DbfColumn> GetValidColumns(IEnumerable`1<DbfColumn> columns, Encoding encoding);
    public static Collection`1<string> GetValidColumnNames(IEnumerable`1<string> columnNames);
    public static Collection`1<string> GetValidColumnNames(IEnumerable`1<string> columnNames, Encoding encoding);
    public static void CreateShapeFile(ShapeFileType shapeType, string pathFilename, IEnumerable`1<DbfColumn> databaseColumns);
    public static void CreateShapeFile(ShapeFileType shapeType, string pathFilename, IEnumerable`1<DbfColumn> databaseColumns, Encoding encoding);
    public static void CreateShapeFile(ShapeFileType shapeType, string pathFilename, IEnumerable`1<DbfColumn> databaseColumns, Encoding encoding, OverwriteMode overwriteMode);
    public Collection`1<DbfColumn> GetDbfColumns();
    public static void CloneShapeFileStructure(string sourceShapePathFilename, string targetShapePathFilename);
    public static void CloneShapeFileStructure(string sourceShapePathFilename, string targetShapePathFilename, OverwriteMode overwriteMode);
    public static void CloneShapeFileStructure(string sourceShapePathFilename, string targetShapePathFilename, OverwriteMode overwriteMode, Encoding encoding);
    public Dictionary`2<string, string> Validate();
    public void AddColumnBoolean(string columnName);
    public void AddColumnDate(string columnName);
    public void AddColumnDouble(string columnName, int totalLength, int precisionLength);
    public void AddColumnInteger(string columnName, int length);
    public void AddColumnMemo(string columnName);
    public void AddColumnMemo(string columnName, int memoValueLength);
    public void AddColumnString(string columnName, int length);
    public string GetDataFromDbf(string id, string columnName);
    public Dictionary`2<string, string> GetDataFromDbf(string id);
    public Dictionary`2<string, string> GetDataFromDbf(string id, IEnumerable`1<string> returningColumnNames);
    public Dictionary`2<string, string> GetDataFromDbf(string id, ReturningColumnsType returningColumnNamesType);
    public Collection`1<Dictionary`2<string, string>> GetDataFromDbf(IEnumerable`1<string> ids);
    public Collection`1<Dictionary`2<string, string>> GetDataFromDbf(IEnumerable`1<string> ids, string columnName);
    public Collection`1<Dictionary`2<string, string>> GetDataFromDbf(IEnumerable`1<string> ids, IEnumerable`1<string> columnNames);
    public Collection`1<Dictionary`2<string, string>> GetDataFromDbf(IEnumerable`1<string> ids, ReturningColumnsType returningColumnNamesType);
    public void UpdateDbfData(string id, string columnName, string value);
    public void UpdateDbfData(string id, IEnumerable`1<string> columnNames, IEnumerable`1<string> values);
    public ShapeFileType GetShapeFileType();
    public static void BuildRecordIdColumn(string shapeFilename, string fieldname, BuildRecordIdMode rebuildNeeded);
    public static void BuildRecordIdColumn(string shapeFilename, string fieldname, BuildRecordIdMode rebuildNeeded, int startNumber);
    public static void BuildRecordIdColumn(string shapeFilename, string fieldname, BuildRecordIdMode rebuildNeeded, int startNumber, Encoding encoding);
    public static void Reproject(string sourceShapeFile, string targetShapeFile, ProjectionConverter projectionConverter, OverwriteMode overwriteMode);
    private void 3yM=(string fieldName, int startNumber, bool fieldNameFound);
    protected virtual void OpenCore();
    private void 4CM=(FileAccess rTreeFileAccess);
    private void wB4=();
    private void 4SM=();
    protected virtual void CloseCore();
    protected virtual TransactionResult CommitTransactionCore(TransactionBuffer transactions);
    private void 4iM=(TransactionBuffer transactions, TransactionResult transactionResult);
    private Collection`1<DbfColumn> 4yM=(Dictionary`2<string, FeatureSourceColumn> filteredEditColumns);
    protected virtual Collection`1<Feature> GetAllFeaturesCore(IEnumerable`1<string> returningColumnNames);
    protected virtual Collection`1<string> GetFeatureIdsCore();
    protected virtual Collection`1<FeatureSourceColumn> GetColumnsCore();
    protected virtual RectangleShape GetBoundingBoxCore();
    protected virtual RectangleShape GetBoundingBoxByIdCore(string id);
    protected virtual Collection`1<Feature> GetFeaturesOutsideBoundingBoxCore(RectangleShape boundingBox, IEnumerable`1<string> returningColumnNames);
    protected virtual Collection`1<Feature> GetFeaturesInsideBoundingBoxCore(RectangleShape boundingBox, IEnumerable`1<string> returningColumnNames);
    protected virtual Collection`1<Feature> GetFeaturesByColumnValueCore(string columnName, string columnValue, IEnumerable`1<string> returningColumnNames);
    public Collection`1<string> GetFeatureIdsForDrawing(RectangleShape boundingBox, double screenWidth, double screenHeight);
    protected virtual Collection`1<string> GetFeatureIdsForDrawingCore(RectangleShape boundingBox, double screenWidth, double screenHeight);
    protected virtual Collection`1<Feature> GetFeaturesForDrawingCore(RectangleShape boundingBox, double screenWidth, double screenHeight, IEnumerable`1<string> returningColumnNames);
    private static Byte[] 5CM=(RectangleShape rectangleShape);
    private static void 5SM=(Byte[] sourceBytes, Byte[] destinateBytes, int startIndex);
    private static bool 5iM=(PointShape upperLeftPoint, RectangleShape boundingBox, double screenFactorX, double screenFactorY);
    protected virtual Collection`1<Feature> GetFeaturesByIdsCore(IEnumerable`1<string> ids, IEnumerable`1<string> returningColumnNames);
    protected virtual long GetCountCore();
    protected virtual bool CanGetCountQuicklyCore();
    protected virtual WellKnownType GetFirstFeaturesWellKnownTypeCore();
    protected virtual Collection`1<DistinctColumnValue> GetDistinctColumnValuesCore(string columnName);
    protected virtual Collection`1<Feature> GetAllFeaturesCore(IEnumerable`1<string> returningColumnNames, int startIndex, int takeCount);
    private void 5yM=(object sender, StreamLoadingEventArgs e);
    private static void iiM=(string idxPathFilename, WellKnownType wellKnownType);
    private static void iiM=(string idxPathFilename, ShapeFileType shapeFileType);
    private void ZSE=(Feature feature);
    private Dictionary`2<string, string> 6CM=(Dictionary`2<string, string> fieldValues);
    private void HR8=(int index);
    private void ZiE=(Feature targetFeature);
    private bool 6SM=(int progressPercentage, object userState, int featuresToDraw, int featuresDrawn);
    private static void mCM=(string pathFilename);
    private static void 6iM=(string sourcePathFilename, string targetPathFilename);
    private static bool 6yM=(IEnumerable`1<string> values);
    [OnGeodeserializedAttribute]
private void GxU=();
    private void 7CM=(FeatureSourceColumn column);
    private static DbfColumnType 7SM=(string columnTypeName);
    private Collection`1<int> 7iM=();
    private void 7yM=(Action`1<int> processById);
}
[ObfuscationAttribute]
internal class ThinkGeo.Core.ShapeFileHeader : object {
    private static int 8CM=;
    private static long 8SM=;
    private static int xyM=;
    private static int yCM=;
    private static int miM=;
    [ObfuscationAttribute]
private int fileCode;
    [ObfuscationAttribute]
private int fileLength;
    [ObfuscationAttribute]
private int version;
    [ObfuscationAttribute]
private ShapeFileBoundingBox boundingBox;
    [ObfuscationAttribute]
private ShapeFileType shapeFileType;
    public int 9CM= { get; public set; }
    public ShapeFileType pyM= { get; public set; }
    public ShapeFileBoundingBox /CM= { get; public set; }
    public ShapeFileHeader(ShapeFileType shapeFileType);
    public int 8iM=();
    public void 8yM=(int value);
    public ShapeFileType piM=();
    public void 9SM=(ShapeFileType value);
    public ShapeFileBoundingBox 9iM=();
    public void 9yM=(ShapeFileBoundingBox value);
    public static ShapeFileHeader /SM=(Stream stream);
    public void /iM=(Stream targetFileStream);
    private static ShapeFileType /yM=(int value);
}
[ObfuscationAttribute]
internal class ThinkGeo.Core.ShapeFileIndex : object {
    private static int ACQ=;
    private static int ASQ=;
    private static int OR8=;
    [ObfuscationAttribute]
private string shxPathFilename;
    [ObfuscationAttribute]
private ShapeFileHeader fileHeader;
    private Stream AiQ=;
    [ObfuscationAttribute]
private long startIndex;
    [ObfuscationAttribute]
private long endIndex;
    [ObfuscationAttribute]
private Byte[] cache;
    private bool Zxo=;
    [CompilerGeneratedAttribute]
private EventHandler`1<StreamLoadingEventArgs> StreamLoading;
    public string BSQ= { get; public set; }
    public ShapeFileHeader Nh8= { get; public set; }
    public ShapeFileIndex(string shxPathFilename);
    [CompilerGeneratedAttribute]
public void PB8=(EventHandler`1<StreamLoadingEventArgs> value);
    [CompilerGeneratedAttribute]
public void PR8=(EventHandler`1<StreamLoadingEventArgs> value);
    public string AyQ=();
    public void BCQ=(string value);
    public ShapeFileHeader NB8=();
    public void NR8=(ShapeFileHeader value);
    internal virtual void Px8=(StreamLoadingEventArgs e);
    public void sB4=();
    public void sB4=(FileAccess readWriteMode);
    public void QB8=();
    public int Ix8=();
    public long BiQ=(int recordIndex);
    public void Qh8=();
    public int ByQ=(int recordIndex);
    public void ZiE=(int recordIndex, long offset, int contentLength);
    public void ZSE=(long offset, int contentLength);
    private void CCQ=(int recordIndex, long offset, int contentLength);
    public void HR8=(int recordIndex);
    public void Hh8=();
}
public enum ThinkGeo.Core.ShapeFileSortingMode : Enum {
    public int value__;
    public static ShapeFileSortingMode Default;
    public static ShapeFileSortingMode Geohash;
    public static ShapeFileSortingMode None;
}
public enum ThinkGeo.Core.ShapeFileType : Enum {
    public int value__;
    public static ShapeFileType Null;
    public static ShapeFileType Point;
    public static ShapeFileType Polyline;
    public static ShapeFileType Polygon;
    public static ShapeFileType Multipoint;
    public static ShapeFileType PointZ;
    public static ShapeFileType PolylineZ;
    public static ShapeFileType PolygonZ;
    public static ShapeFileType MultipointZ;
    public static ShapeFileType PointM;
    public static ShapeFileType PolylineM;
    public static ShapeFileType PolygonM;
    public static ShapeFileType MultipointM;
    public static ShapeFileType Multipatch;
}
public static class ThinkGeo.Core.ShapefileValidatorHelper : object {
    internal static void GCQ=(string pathFilename, string parameterName);
    internal static void GSQ=(ShapeFileBoundingBox shapeFileBoundingBox);
    public static void CheckSqlStatementIsSupported(string sqlStatement);
    public static void CheckShapeFileIsWriteable(FileAccess readWriteMode, string parameterName);
    public static void CheckShapeFileTypeIsValid(ShapeFileType shapeFileType, string parameterName);
    public static void CheckDbfColumnsAreEmpty(IEnumerable`1<DbfColumn> dbfColumns, string parameterName);
    public static void CheckShapeFileIsEditable(ShapeFileType shapeFileType, string parameterName);
    public static void CheckShapeFileTypeIsSupported(ShapeFileType shapeFileType, string parameterName);
}
public enum ThinkGeo.Core.ShapeValidationMode : Enum {
    public int value__;
    public static ShapeValidationMode Simple;
    public static ShapeValidationMode Advanced;
}
public class ThinkGeo.Core.ShapeValidationResult : ValueType {
    [ObfuscationAttribute]
private bool isValid;
    [ObfuscationAttribute]
private string validationErrors;
    public bool IsValid { get; }
    public string ValidationErrors { get; }
    public ShapeValidationResult(bool isValid, string validationErrors);
    public bool get_IsValid();
    public string get_ValidationErrors();
    public static bool op_Equality(ShapeValidationResult sourceShapeValidationResult, ShapeValidationResult targetShapeValidationResult);
    public static bool op_Inequality(ShapeValidationResult sourceShapeValidationResult, ShapeValidationResult targetShapeValidationResult);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
}
public class ThinkGeo.Core.SimpleCandidate : object {
    [ObfuscationAttribute]
private string originalText;
    [ObfuscationAttribute]
private PolygonShape simplePolygonInScreenCoordinate;
    [ObfuscationAttribute]
private bool isAllowOverlapping;
    public string OriginalText { get; public set; }
    public PolygonShape SimplePolygonInScreenCoordinate { get; public set; }
    internal bool LTE= { get; internal set; }
    public SimpleCandidate(string originalText, PolygonShape simplePolygonInScreenCoordinate);
    public string get_OriginalText();
    public void set_OriginalText(string value);
    public PolygonShape get_SimplePolygonInScreenCoordinate();
    public void set_SimplePolygonInScreenCoordinate(PolygonShape value);
    internal bool KzE=();
    internal void LDE=(bool value);
}
public class ThinkGeo.Core.SimpleFilterCondition : FilterCondition {
    private string WTE=;
    private SimpleFilterConditionType WjE=;
    private static Dictionary`2<SimpleFilterConditionType, Tuple`2<string, string>> WzE=;
    public string MatchValue { get; public set; }
    public SimpleFilterConditionType MatchType { get; public set; }
    private static SimpleFilterCondition();
    public SimpleFilterCondition(string columnName, SimpleFilterConditionType matchType, string matchValue);
    public string get_MatchValue();
    public void set_MatchValue(string value);
    public SimpleFilterConditionType get_MatchType();
    public void set_MatchType(SimpleFilterConditionType value);
    protected virtual Collection`1<Feature> GetMatchingFeaturesCore(IEnumerable`1<Feature> features);
    private void XDE=();
}
[ObfuscationAttribute]
public enum ThinkGeo.Core.SimpleFilterConditionType : Enum {
    public int value__;
    public static SimpleFilterConditionType Equal;
    public static SimpleFilterConditionType Contains;
    public static SimpleFilterConditionType StartsWith;
    public static SimpleFilterConditionType EndsWith;
    public static SimpleFilterConditionType DoesNotEqual;
    public static SimpleFilterConditionType DoesNotContain;
    public static SimpleFilterConditionType GreaterThan;
    public static SimpleFilterConditionType GreaterThanOrEqualTo;
    public static SimpleFilterConditionType LessThan;
    public static SimpleFilterConditionType LessThanOrEqualTo;
    public static SimpleFilterConditionType IsEmpty;
    public static SimpleFilterConditionType IsNotEmpty;
}
public enum ThinkGeo.Core.SimplificationType : Enum {
    public int value__;
    public static SimplificationType TopologyPreserving;
    public static SimplificationType DouglasPeucker;
}
public class ThinkGeo.Core.SkiaGeoCanvas : GeoCanvas {
    [ObfuscationAttribute]
private GeoImage[] bufferImages;
    [ObfuscationAttribute]
private NxU=[] graphicses;
    public bool SupportKeyColor { get; }
    public virtual bool get_SupportKeyColor();
    protected virtual void BeginDrawingCore(object nativeImage, RectangleShape worldExtent, GeographyUnit drawingMapUnit);
    private NxU= LxU=(int i);
    private GeoImage MBU=(int i);
    protected virtual void DrawArcCore(GeoPen pen, float x, float y, float width, float height, float startAngle, float sweepAngle, DrawingLevel drawingLevel);
    protected virtual void DrawAreaCore(IEnumerable`1<ScreenPointF[]> screenPoints, GeoPen outlinePen, GeoBrush fillBrush, DrawingLevel drawingLevel, float xOffset, float yOffset, PenBrushDrawingOrder penBrushDrawingOrder);
    protected virtual void DrawEllipseCore(ScreenPointF screenPoint, float width, float height, GeoPen outlinePen, GeoBrush fillBrush, DrawingLevel drawingLevel, float xOffset, float yOffset, PenBrushDrawingOrder penBrushDrawingOrder);
    protected virtual void DrawLineCore(IEnumerable`1<ScreenPointF> screenPoints, GeoPen linePen, DrawingLevel drawingLevel, float xOffset, float yOffset);
    protected virtual void DrawScreenImageCore(GeoImage image, float centerXInScreen, float centerYInScreen, float widthInScreen, float heightInScreen, DrawingLevel drawingLevel, float xOffset, float yOffset, float rotateAngle);
    protected virtual void DrawScreenImageWithoutScalingCore(GeoImage image, float centerXInScreen, float centerYInScreen, DrawingLevel drawingLevel, float xOffset, float yOffset, float rotateAngle);
    protected virtual void DrawTextCore(string text, GeoFont font, GeoBrush fillBrush, GeoPen haloPen, IEnumerable`1<ScreenPointF> textPathInScreen, DrawingLevel drawingLevel, float xOffset, float yOffset, DrawingTextAlignment drawingTextAlignment, float rotateAngle);
    private static void MRU=(string text, GeoFont font, GeoBrush fillBrush, GeoPen haloPen, IEnumerable`1<ScreenPointF> textPathInScreen, float xOffset, float yOffset, DrawingTextAlignment drawingTextAlignment, float rotateAngle, NxU= graphics, DrawingRectangleF rectangle);
    protected virtual void EndDrawingCore();
    private void MhU=(GeoImage geoImage);
    private void MxU=(GeoImage geoImage, GeoColor keyColor);
    protected virtual void FlushCore();
    protected virtual float GetCanvasHeightCore();
    protected virtual float GetCanvasWidthCore();
    protected virtual DrawingRectangleF MeasureTextCore(string text, GeoFont font);
    internal virtual float FhU=(GeoFont font, DrawingTextBaseline textBaseline, string text);
    internal void NBU=(GeoImage image, int srcX, int srcY, int srcWidth, int srcHeight, cRU=[] colors, DrawingLevel drawingLevel);
    internal void NRU=(ScreenPointF centerPoint, int radius, Single[] positions, GeoColor[] colors, DrawingLevel drawingLevel);
    private SKFilterQuality NhU=(DrawingQuality drawingQuality);
}
public abstract class ThinkGeo.Core.SpatialIndex : object {
    private bool Zxo=;
    [ObfuscationAttribute]
private bool canDelete;
    public bool IsOpen { get; }
    public bool CanDelete { get; protected set; }
    protected bool IsOpenCore { get; protected set; }
    public bool get_IsOpen();
    public bool get_CanDelete();
    protected void set_CanDelete(bool value);
    protected virtual bool get_IsOpenCore();
    protected virtual void set_IsOpenCore(bool value);
    public void Add(BaseShape baseShape);
    public void Add(Feature feature);
    protected abstract virtual void AddCore(Feature feature);
    public void Delete(Feature feature);
    public void Delete(BaseShape baseShape);
    protected virtual void DeleteCore(Feature feature);
    public void Close();
    protected virtual void CloseCore();
    public int GetFeatureCount();
    protected virtual int GetFeatureCountCore();
    public Collection`1<string> GetFeatureIdsIntersectingBoundingBox(RectangleShape boundingBox);
    protected abstract virtual Collection`1<string> GetFeatureIdsIntersectingBoundingBoxCore(RectangleShape boundingBox);
    public void Open();
    protected virtual void OpenCore();
}
public class ThinkGeo.Core.SphericalKrigingGridInterpolationModel : KrigingGridInterpolationModel {
    public SphericalKrigingGridInterpolationModel(IDictionary`2<PointShape, double> points);
    public SphericalKrigingGridInterpolationModel(IDictionary`2<PointShape, double> points, int numberOfRefrencedPoints);
    protected virtual double GetSemivarianceCore(double distance, EmpiricalFunctionCoefficients coefficients);
    protected virtual double GetSillSlopeCore(double distance, double range);
}
public class ThinkGeo.Core.SphericalMercatorZoomLevelSet : ZoomLevelSet {
    public SphericalMercatorZoomLevelSet(int tileSize);
    public SphericalMercatorZoomLevelSet(int tileSize, RectangleShape maxExtent);
}
public enum ThinkGeo.Core.SplineType : Enum {
    public int value__;
    public static SplineType Default;
    public static SplineType None;
    public static SplineType StandardSplining;
    public static SplineType ForceSplining;
}
public class ThinkGeo.Core.SqliteColumn : FeatureSourceColumn {
    [ObfuscationAttribute]
private SqliteColumnType columnType;
    public SqliteColumnType ColumnType { get; public set; }
    public SqliteColumn(string columnName, SqliteColumnType columnType);
    public SqliteColumnType get_ColumnType();
    public void set_ColumnType(SqliteColumnType value);
}
public enum ThinkGeo.Core.SqliteColumnType : Enum {
    public int value__;
    public static SqliteColumnType Null;
    public static SqliteColumnType Integer;
    public static SqliteColumnType Real;
    public static SqliteColumnType Text;
    public static SqliteColumnType Blob;
    public static SqliteColumnType Numeric;
}
[GeneratedCodeAttribute("System.Resources.Tools.StronglyTypedResourceBuilder", "4.0.0.0")]
[CompilerGeneratedAttribute]
[ObfuscationAttribute]
[DebuggerNonUserCodeAttribute]
internal class ThinkGeo.Core.SqliteExceptionDescription : object {
    private static ResourceManager resourceMan;
    private static CultureInfo resourceCulture;
    [EditorBrowsableAttribute("2")]
internal static ResourceManager ResourceManager { get; }
    [EditorBrowsableAttribute("2")]
internal static CultureInfo Culture { get; internal set; }
    internal static string ColumnNameNotExist { get; }
    internal static string ConnectionStringCannotBeNull { get; }
    internal static string FeatureIdColumnNotExist { get; }
    internal static string FeatureSourceCanNotExecuteSqlQuery { get; }
    internal static string FeatureSourceIsNotInTransaction { get; }
    internal static string FeatureSourceIsNotOpen { get; }
    internal static string GeometryColumnNotExist { get; }
    internal static string InvalidSrid { get; }
    internal static string ParameterIsInvalid { get; }
    internal static string ParameterIsNull { get; }
    internal static string ParameterIsNullOrEmpty { get; }
    internal static string SqliteDatabaseIsReadOnly { get; }
    internal static ResourceManager get_ResourceManager();
    internal static CultureInfo get_Culture();
    internal static void set_Culture(CultureInfo value);
    internal static string get_ColumnNameNotExist();
    internal static string get_ConnectionStringCannotBeNull();
    internal static string get_FeatureIdColumnNotExist();
    internal static string get_FeatureSourceCanNotExecuteSqlQuery();
    internal static string get_FeatureSourceIsNotInTransaction();
    internal static string get_FeatureSourceIsNotOpen();
    internal static string get_GeometryColumnNotExist();
    internal static string get_InvalidSrid();
    internal static string get_ParameterIsInvalid();
    internal static string get_ParameterIsNull();
    internal static string get_ParameterIsNullOrEmpty();
    internal static string get_SqliteDatabaseIsReadOnly();
}
public class ThinkGeo.Core.SqliteFeatureLayer : FeatureLayer {
    public bool HasBoundingBox { get; }
    public int CommandTimeout { get; public set; }
    public string ConnectionString { get; public set; }
    public string TableName { get; public set; }
    public string FeatureIdColumn { get; public set; }
    public string GeometryColumnName { get; public set; }
    public string WhereClause { get; public set; }
    public SqliteFeatureLayer(string connectionString, string tableName, string featureIdColumn, string geometryColumnName);
    public SqliteFeatureLayer(SqliteConnection connection, string tableName, string featureIdeColumn, string geometryColumnName);
    public virtual bool get_HasBoundingBox();
    public int get_CommandTimeout();
    public void set_CommandTimeout(int value);
    public string get_ConnectionString();
    public void set_ConnectionString(string value);
    public string get_TableName();
    public void set_TableName(string value);
    public string get_FeatureIdColumn();
    public void set_FeatureIdColumn(string value);
    public string get_GeometryColumnName();
    public void set_GeometryColumnName(string value);
    public WellKnownType GetFirstGeometryType();
    public string get_WhereClause();
    public void set_WhereClause(string value);
    public int ExecuteNonQuery(string sqlStatement);
}
[ObfuscationAttribute]
public class ThinkGeo.Core.SqliteFeatureSource : FeatureSource {
    private static int queryInside;
    private static int queryOutside;
    [ObfuscationAttribute]
private string connectionString;
    [ObfuscationAttribute]
private string tableName;
    [ObfuscationAttribute]
private string geometryColumn;
    [ObfuscationAttribute]
private string featureIdColumn;
    [ObfuscationAttribute]
private int commandTimeout;
    [ObfuscationAttribute]
private bool isConnectionFromUser;
    private SqliteConnection userConnection;
    private Collection`1<FeatureSourceColumn> featureSourceColumns;
    [ObfuscationAttribute]
private string whereClause;
    [ObfuscationAttribute]
private double fetchTime;
    [ObfuscationAttribute]
private int drawnFeatureCount;
    [ObfuscationAttribute]
private int totalBytesDrawn;
    [ObfuscationAttribute]
private string alternateGeometryIndexTableName;
    [ObfuscationAttribute]
private bool isEditable;
    private bool isEditableChecked;
    [CompilerGeneratedAttribute]
private EventHandler`1<ExecutingSqlStatementSqliteFeatureSourceEventArgs> ExecutingSqlStatement;
    protected bool CanExecuteSqlQueryCore { get; }
    public double FetchTime { get; public set; }
    public int DrawnFeatureCount { get; public set; }
    public int TotalBytesDrawn { get; public set; }
    public string WhereClause { get; public set; }
    public int CommandTimeout { get; public set; }
    public string GeometryColumnName { get; public set; }
    public string ConnectionString { get; public set; }
    public string TableName { get; public set; }
    public string FeatureIdColumn { get; public set; }
    public bool IsEditable { get; }
    public string AlternateGeometryIndexTableName { get; public set; }
    public SqliteFeatureSource(string connectionString, string tableName, string featureIdColumn, string geometryColumnName);
    public SqliteFeatureSource(SqliteConnection connection, string tableName, string featureIdColumn, string geometryColumnName);
    public SqliteFeatureSource(SqliteConnection connection, string tableName);
    public SqliteFeatureSource(string connectionString, string tableName);
    private SqliteFeatureSource(SqliteConnection connection, string connectionString, string tableName, string featureIdColumn, string geometryColumnName);
    [CompilerGeneratedAttribute]
public void add_ExecutingSqlStatement(EventHandler`1<ExecutingSqlStatementSqliteFeatureSourceEventArgs> value);
    [CompilerGeneratedAttribute]
public void remove_ExecutingSqlStatement(EventHandler`1<ExecutingSqlStatementSqliteFeatureSourceEventArgs> value);
    public static void CreateTable(SqliteConnection connection, string tableName, IEnumerable`1<SqliteColumn> nonGeometryColumns, GeographyUnit unit);
    public static void CreateTable(string connectionString, string tableName, IEnumerable`1<SqliteColumn> nonGeometryColumns, GeographyUnit unit);
    protected virtual void OnExecutingSqlStatement(ExecutingSqlStatementSqliteFeatureSourceEventArgs e);
    public static void CreateView(SqliteConnection connection, string viewName, string createViewSql, string featureIdColumn, GeographyUnit unit, string geometryColumnName);
    public static void CreateView(SqliteConnection connection, string viewName, string createViewSql, string featureIdColumn, GeographyUnit unit);
    public static void CreateView(string connectionString, string viewName, string createViewSql, string featureIdColumn, GeographyUnit unit);
    protected virtual bool get_CanExecuteSqlQueryCore();
    public double get_FetchTime();
    public void set_FetchTime(double value);
    public int get_DrawnFeatureCount();
    public void set_DrawnFeatureCount(int value);
    public int get_TotalBytesDrawn();
    public void set_TotalBytesDrawn(int value);
    public string get_WhereClause();
    public void set_WhereClause(string value);
    public int get_CommandTimeout();
    public void set_CommandTimeout(int value);
    public string get_GeometryColumnName();
    public void set_GeometryColumnName(string value);
    public string get_ConnectionString();
    public void set_ConnectionString(string value);
    public string get_TableName();
    public void set_TableName(string value);
    public string get_FeatureIdColumn();
    public void set_FeatureIdColumn(string value);
    public virtual bool get_IsEditable();
    public string get_AlternateGeometryIndexTableName();
    public void set_AlternateGeometryIndexTableName(string value);
    private string GetGeometryIndexTableName();
    protected virtual int ExecuteNonQueryCore(string sqlStatement);
    public static void CreateDatabase(string databasePathFilename);
    protected virtual WellKnownType GetFirstFeaturesWellKnownTypeCore();
    protected virtual void OpenCore();
    protected virtual void CloseCore();
    private bool IsView();
    protected virtual long GetCountCore();
    protected virtual Collection`1<Feature> GetFeaturesInsideBoundingBoxCore(RectangleShape boundingBox, IEnumerable`1<string> returningColumnNames);
    protected virtual Collection`1<Feature> GetFeaturesOutsideBoundingBoxCore(RectangleShape boundingBox, IEnumerable`1<string> returningColumnNames);
    protected virtual TransactionResult CommitTransactionCore(TransactionBuffer transactions);
    protected virtual Collection`1<Feature> GetAllFeaturesCore(IEnumerable`1<string> columnNames);
    public static Collection`1<string> GetColumnNames(string connectionString, string tableName);
    protected virtual Collection`1<FeatureSourceColumn> GetColumnsCore();
    protected virtual bool CanGetBoundingBoxQuicklyCore();
    protected virtual RectangleShape GetBoundingBoxCore();
    protected virtual Collection`1<Feature> GetFeaturesByIdsCore(IEnumerable`1<string> ids, IEnumerable`1<string> returningColumnNames);
    protected virtual Collection`1<Feature> GetFeaturesByColumnValueCore(string columnName, string columnValue, IEnumerable`1<string> returningColumnNames);
    protected virtual DataTable ExecuteQueryCore(string sqlStatement);
    public static Collection`1<string> GetTableNames(string connectionString);
    private string QuoteColumnName(string columnName);
    private string GetSpatialQueryCondition(int queryType, RectangleShape boundingBox);
    private string BuildSelectColumnsString(IEnumerable`1<string> columnNames);
    private Feature GetFeature(SqliteDataReader dataReader, IEnumerable`1<string> columnNames);
    public static bool CreateSpatialIndex(SqliteConnection SqliteConnection, string tableName, string geometryColumnName, int srid);
    private Feature GetFeature(SqliteDataReader dataReader);
    private string SanitizeParameterNames(string parameterName);
    private void ProcessAddBuffer(Dictionary`2<string, Feature> addBuffer, TransactionResult result, SqliteConnection connection);
    private static string ReplaceNulls(string value);
    private void ProcessDeleteBuffer(Collection`1<string> deleteBuffer, TransactionResult transactionResult, SqliteConnection connection);
    private void ProcessEditBuffer(Dictionary`2<string, Feature> editBuffer, TransactionResult transactionResult, SqliteConnection connection);
    protected virtual Collection`1<string> GetFeatureIdsCore();
    protected virtual Collection`1<string> GetFeatureIdsInsideBoundingBoxCore(RectangleShape boundingBox);
    private Collection`1<Feature> GetFeaturesByBoundingBox(BaseShape targetShape, int queryType, IEnumerable`1<string> returningColumnNames);
    private SqliteCommand GetNewCommand(string sqlStatement, ExecutingSqlStatementType sqlStatementType, SqliteConnection& connection, RectangleShape boundingBox);
}
internal class ThinkGeo.Core.SqliteRasterTileCache : RasterTileCache {
    [ObfuscationAttribute]
private string databasePathFilename;
    public string DatabasePathFilename { get; public set; }
    public string CacheId { get; public set; }
    public SqliteRasterTileCache(string databasePathFilename, string cacheId);
    public string get_DatabasePathFilename();
    public void set_DatabasePathFilename(string value);
    public virtual string get_CacheId();
    public virtual void set_CacheId(string value);
    protected virtual Tile GetTileCore(int zoom, long column, long row);
    protected virtual void ClearCacheCore();
    protected virtual void SaveTileCore(Tile tile);
    protected virtual void DeleteTileCore(Tile tile);
    private SqliteConnection GetConnection();
    private void CheckCacheId();
}
public static class ThinkGeo.Core.SqliteValidatorHelper : object {
    public static void CheckFeatureSourceIsInTransaction(bool isInTransaction);
    public static void CheckParameterIsValid(BaseShape BasheShapeToTest, string parameterName);
    public static void CheckFeatureSourceIsOpen(bool isOpen);
    public static void CheckParameterIsNotNullOrEmpty(string value, string parameterName);
    public static bool CheckIsEmptyOrNull(IEnumerable`1<string> values);
    public static void CheckFeatureSourceCanExecuteSqlQuery(bool canExecuteSqlQuery);
    public static void CheckFeatureIdAndGeometryColumn(string connectionString, string tableName, string featureIdColumn, string geometryColumnName);
}
public enum ThinkGeo.Core.StartingPoint : Enum {
    public int value__;
    public static StartingPoint FirstPoint;
    public static StartingPoint LastPoint;
}
internal enum ThinkGeo.Core.State : Enum {
    public int value__;
    public static State Start;
    public static State Complete;
    public static State Property;
    public static State ObjectStart;
    public static State Object;
    public static State ArrayStart;
    public static State Array;
    public static State Closed;
    public static State PostValue;
    public static State ConstructorStart;
    public static State Constructor;
    public static State Error;
    public static State Finished;
}
public class ThinkGeo.Core.StreamLoadingEventArgs : EventArgs {
    [ObfuscationAttribute]
private string alternateStreamName;
    private Stream 5B8=;
    [ObfuscationAttribute]
private FileMode fileMode;
    [ObfuscationAttribute]
private FileAccess readWriteMode;
    [ObfuscationAttribute]
private string streamType;
    public string AlternateStreamName { get; public set; }
    public Stream AlternateStream { get; public set; }
    public FileMode FileMode { get; public set; }
    public FileAccess ReadWriteMode { get; public set; }
    public string StreamType { get; }
    public StreamLoadingEventArgs(string alternateStreamName, string streamType);
    public StreamLoadingEventArgs(string alternateStreamName, Stream alternateStream, FileMode fileMode, FileAccess readWriteMode);
    public StreamLoadingEventArgs(string alternateStreamName, string streamType, Stream alternateStream, FileMode fileMode, FileAccess readWriteMode);
    public string get_AlternateStreamName();
    public void set_AlternateStreamName(string value);
    public Stream get_AlternateStream();
    public void set_AlternateStream(Stream value);
    public FileMode get_FileMode();
    public void set_FileMode(FileMode value);
    public FileAccess get_ReadWriteMode();
    public void set_ReadWriteMode(FileAccess value);
    public string get_StreamType();
}
internal class ThinkGeo.Core.StringBuffer : ValueType {
    [ObfuscationAttribute]
private Char[] _buffer;
    [ObfuscationAttribute]
private int _position;
    public int Position { get; public set; }
    public bool IsEmpty { get; }
    public Char[] InternalBuffer { get; }
    public StringBuffer(int initalSize);
    private StringBuffer(Char[] buffer);
    public int get_Position();
    public void set_Position(int value);
    public bool get_IsEmpty();
    public void Append(char value);
    public void Append(Char[] buffer, int startIndex, int count);
    public void Clear();
    private void EnsureSize(int appendLength);
    public virtual string ToString();
    public string ToString(int start, int length);
    public Char[] get_InternalBuffer();
}
[IsReadOnlyAttribute]
internal class ThinkGeo.Core.StringReference : ValueType {
    private Char[] _chars;
    private int _startIndex;
    private int _length;
    public Char[] Chars { get; }
    public int StartIndex { get; }
    public int Length { get; }
    public StringReference(Char[] chars, int startIndex, int length);
    public Char[] get_Chars();
    public int get_StartIndex();
    public int get_Length();
    public virtual string ToString();
}
public abstract class ThinkGeo.Core.Style : object {
    [ObfuscationAttribute]
private string name;
    [ObfuscationAttribute]
private Collection`1<string> filters;
    [ObfuscationAttribute]
private bool isActive;
    [ObfuscationAttribute]
private Collection`1<string> requiredColumnNames;
    public string Name { get; public set; }
    public bool IsActive { get; public set; }
    internal bool fBU= { get; }
    public Collection`1<string> RequiredColumnNames { get; }
    public Collection`1<string> Filters { get; }
    protected Collection`1<string> FiltersCore { get; }
    public string get_Name();
    public void set_Name(string value);
    public bool get_IsActive();
    public void set_IsActive(bool value);
    internal virtual bool ehU=();
    public Collection`1<string> get_RequiredColumnNames();
    public Collection`1<string> get_Filters();
    protected virtual Collection`1<string> get_FiltersCore();
    public Style CloneDeep();
    protected virtual Style CloneDeepCore();
    public void Draw(IEnumerable`1<Feature> features, GeoCanvas canvas, Collection`1<SimpleCandidate> labelsInThisLayer, Collection`1<SimpleCandidate> labelsInAllLayers);
    public void Draw(IEnumerable`1<BaseShape> shapes, GeoCanvas canvas, Collection`1<SimpleCandidate> labelsInThisLayer, Collection`1<SimpleCandidate> labelsInAllLayers);
    protected abstract virtual void DrawCore(IEnumerable`1<Feature> features, GeoCanvas canvas, Collection`1<SimpleCandidate> labelsInThisLayer, Collection`1<SimpleCandidate> labelsInAllLayers);
    public Collection`1<FeatureLabelingCandidate> DrawWithoutLabeling(IEnumerable`1<Feature> features, GeoCanvas canvas);
    protected virtual Collection`1<FeatureLabelingCandidate> DrawWithoutLabelingCore(IEnumerable`1<Feature> features, GeoCanvas canvas);
    public Collection`1<string> GetRequiredColumnNames();
    internal static void hjA=(string content, char start, char end, Action`1<string> oneParsed);
    protected virtual Collection`1<string> GetRequiredColumnNamesCore();
    public void DrawSample(GeoCanvas canvas, DrawingRectangleF drawingExtent);
    public void DrawSample(GeoCanvas canvas);
    protected virtual void DrawSampleCore(GeoCanvas canvas, DrawingRectangleF drawingExtent);
    public void SaveStyle(string filePathName);
    public void SaveStyle(Stream stream);
    public static Style LoadStyle(Uri styleUri);
    public static Style LoadStyle(Stream styleStream);
}
internal class ThinkGeo.Core.StyleJsonDocument : object {
    internal Dictionary`2<int, Collection`1<StyleJsonStyle>> styles;
    [CompilerGeneratedAttribute]
private Dictionary`2<int, GeoColor> <BackgroundForZooms>k__BackingField;
    [CompilerGeneratedAttribute]
private GeoColor <globalBackground>k__BackingField;
    internal static string versionKey;
    private double version;
    internal Dictionary`2<int, GeoColor> BackgroundForZooms { get; internal set; }
    internal GeoColor globalBackground { get; internal set; }
    public double Version { get; private set; }
    [CompilerGeneratedAttribute]
internal Dictionary`2<int, GeoColor> get_BackgroundForZooms();
    [CompilerGeneratedAttribute]
internal void set_BackgroundForZooms(Dictionary`2<int, GeoColor> value);
    [CompilerGeneratedAttribute]
internal GeoColor get_globalBackground();
    [CompilerGeneratedAttribute]
internal void set_globalBackground(GeoColor value);
    public double get_Version();
    private void set_Version(double value);
    public static StyleJsonDocument Load(string styleJsonPathFileName);
    public static StyleJsonDocument Load(Uri styleJsonUri);
    public static StyleJsonDocument Parse(Byte[] styleJsonBytes);
    public void ApplyStyleJsonToZoomLevel(ZoomLevelSet zoomLevelSet);
    public void ApplyBackgroundToZoomLevel(ZoomLevelSet zoomLevelSet);
}
public class ThinkGeo.Core.StyleJsonItem : object {
    private Collection`1<FilterCondition> gjE=;
    [ObfuscationAttribute]
private Style style;
    [ObfuscationAttribute]
private FilterApplyMode filterApplyMode;
    public Style Style { get; public set; }
    public Collection`1<FilterCondition> Filters { get; }
    public FilterApplyMode FilterApplyMode { get; public set; }
    public StyleJsonItem(Style style);
    public StyleJsonItem(Style style, IEnumerable`1<FilterCondition> filters);
    public Style get_Style();
    public void set_Style(Style value);
    public Collection`1<FilterCondition> get_Filters();
    public FilterApplyMode get_FilterApplyMode();
    public void set_FilterApplyMode(FilterApplyMode value);
    public Collection`1<Feature> GetMatchedFeatures(IEnumerable`1<Feature> features);
}
public class ThinkGeo.Core.StyleJsonStyle : Style {
    private Collection`1<StyleJsonItem> gzE=;
    [CompilerGeneratedAttribute]
private string hDE=;
    public string ZIndexColumn { get; public set; }
    public Collection`1<StyleJsonItem> StyleJsonItems { get; }
    public StyleJsonStyle(string zIndexColumn);
    [CompilerGeneratedAttribute]
public string get_ZIndexColumn();
    [CompilerGeneratedAttribute]
public void set_ZIndexColumn(string value);
    public Collection`1<StyleJsonItem> get_StyleJsonItems();
    private Dictionary`2<int, Dictionary`2<Style, Collection`1<Feature>>> hTE=(GeoCanvas canvas, TRw= styleJsonFeatures);
    protected virtual Collection`1<FeatureLabelingCandidate> DrawWithoutLabelingCore(IEnumerable`1<Feature> features, GeoCanvas canvas);
    protected virtual void DrawCore(IEnumerable`1<Feature> features, GeoCanvas canvas, Collection`1<SimpleCandidate> labelsInThisLayer, Collection`1<SimpleCandidate> labelsInAllLayers);
    [CompilerGeneratedAttribute]
private int <GetGroupedFeature>b__9_5(Feature f);
}
public class ThinkGeo.Core.TabDbfColumn : DbfColumn {
    [ObfuscationAttribute]
private bool buildIndex;
    [ObfuscationAttribute]
private bool uniqueIndexColumnValues;
    public bool BuildIndex { get; public set; }
    public bool UniqueIndexColumnValues { get; public set; }
    public TabDbfColumn(string columnName, DbfColumnType columnType, int length, int decimalLength, bool buildIndex, bool uniqueIndexColumnValues);
    public bool get_BuildIndex();
    public void set_BuildIndex(bool value);
    public bool get_UniqueIndexColumnValues();
    public void set_UniqueIndexColumnValues(bool value);
}
public class ThinkGeo.Core.TabFeatureLayer : FeatureLayer {
    [ObfuscationAttribute]
private TabStylingType stylingType;
    [ObfuscationAttribute]
private STRtree`1<string> rTree;
    [ObfuscationAttribute]
private Dictionary`2<string, KeyValuePair`2<Feature, IEnumerable`1<Style>>> featuresDics;
    public string TabPathFilename { get; public set; }
    public FileAccess ReadWriteMode { get; public set; }
    public bool HasBoundingBox { get; }
    public TabStylingType StylingType { get; public set; }
    public bool RequireIndex { get; public set; }
    public Encoding Encoding { get; public set; }
    public TabFeatureLayer(string tabPathFilename);
    public TabFeatureLayer(string tabPathFilename, FileAccess readWriteMode);
    public string get_TabPathFilename();
    public void set_TabPathFilename(string value);
    public FileAccess get_ReadWriteMode();
    public void set_ReadWriteMode(FileAccess value);
    public virtual bool get_HasBoundingBox();
    public TabStylingType get_StylingType();
    public void set_StylingType(TabStylingType value);
    public bool get_RequireIndex();
    public void set_RequireIndex(bool value);
    public Encoding get_Encoding();
    public void set_Encoding(Encoding value);
    protected virtual LayerBase CloneDeepCore();
    internal static WkbShapeType WRw=(Byte[] wkb, int startIndex);
    public static void CreateTabFile(string tabPathFilename, IEnumerable`1<TabDbfColumn> databaseColumns, IEnumerable`1<Feature> features);
    public static void CreateTabFile(string tabPathFilename, IEnumerable`1<TabDbfColumn> databaseColumns, IEnumerable`1<Feature> features, OverwriteMode overwriteMode);
    public static void CreateTabFile(string tabPathFilename, IEnumerable`1<TabDbfColumn> databaseColumns, IEnumerable`1<Feature> features, OverwriteMode overwriteMode, Encoding encoding);
    public static void BuildIndexFile(string tabPathFilename);
    public static void BuildIndexFile(string tabPathFilename, BuildIndexMode buildIndexMode);
    public static void BuildRecordIdColumn(string tabFileName, string fieldName, BuildRecordIdMode buildRecordIdMode);
    public static void BuildRecordIdColumn(string tabFileName, string fieldName, BuildRecordIdMode buildRecordIdMode, int startNumber);
    public static void BuildRecordIdColumn(string tabFileName, string fieldName, BuildRecordIdMode buildRecordIdMode, int startNumber, Encoding encoding);
    protected virtual void DrawCore(GeoCanvas canvas, Collection`1<SimpleCandidate> labelsInAllLayers);
    private STRtree`1<string> NSs=(Dictionary`2<Feature, IEnumerable`1<Style>> cadFeatureStyles);
}
public class ThinkGeo.Core.TabFeatureSource : FeatureSource {
    private ECU= ESs=;
    private STRtree`1<string> Eis=;
    [ObfuscationAttribute]
private RtreeSpatialIndex rTreeIndex;
    [ObfuscationAttribute]
private bool requireIndex;
    [ObfuscationAttribute]
private string tabPathFilename;
    [ObfuscationAttribute]
private FileAccess readWriteMode;
    [ObfuscationAttribute]
private Encoding encoding;
    public string TabPathFilename { get; public set; }
    public FileAccess ReadWriteMode { get; public set; }
    public Encoding Encoding { get; public set; }
    public bool IsEditable { get; }
    public bool RequireIndex { get; public set; }
    public TabFeatureSource(string tabPathFilename);
    public TabFeatureSource(string tabPathFilename, FileAccess readWriteMode);
    public string get_TabPathFilename();
    public void set_TabPathFilename(string value);
    public FileAccess get_ReadWriteMode();
    public void set_ReadWriteMode(FileAccess value);
    public Encoding get_Encoding();
    public void set_Encoding(Encoding value);
    public virtual bool get_IsEditable();
    public bool get_RequireIndex();
    public void set_RequireIndex(bool value);
    protected virtual bool CanGetCountQuicklyCore();
    protected virtual void OpenCore();
    protected virtual void CloseCore();
    protected virtual long GetCountCore();
    protected virtual Collection`1<FeatureSourceColumn> GetColumnsCore();
    protected virtual RectangleShape GetBoundingBoxCore();
    protected virtual Collection`1<string> GetFeatureIdsCore();
    protected virtual Collection`1<Feature> GetAllFeaturesCore(IEnumerable`1<string> returningColumnNames, int startIndex, int takeCount);
    protected virtual Collection`1<Feature> GetAllFeaturesCore(IEnumerable`1<string> returningColumnNames);
    protected virtual Collection`1<Feature> GetFeaturesInsideBoundingBoxCore(RectangleShape boundingBox, IEnumerable`1<string> returningColumnNames);
    internal void Eys=(GCo= proj);
    protected virtual Collection`1<Feature> GetFeaturesByColumnValueCore(string columnName, string columnValue, IEnumerable`1<string> returningColumnNames);
    protected virtual Collection`1<Feature> GetFeaturesOutsideBoundingBoxCore(RectangleShape boundingBox, IEnumerable`1<string> returningColumnNames);
    protected virtual Collection`1<Feature> GetFeaturesByIdsCore(IEnumerable`1<string> ids, IEnumerable`1<string> returningColumnNames);
    protected virtual TransactionResult CommitTransactionCore(TransactionBuffer transactions);
    private List`1<TabDbfColumn> FCs=(TransactionBuffer transactions, TransactionResult transactionResult);
    private Feature FSs=(GSg= tabFeature);
    private static PointShape Fis=(0Ck= tabPoint);
    private static MultipointShape Fys=(xSk= tabMultiPoint);
    private static LineBaseShape GCs=(FCo= tabPolyline);
    private static LineShape GSs=(pSc= tabArc);
    private static PolygonShape Gis=(gSo= tabRegion);
    private static EllipseShape Gys=(GCg= tabEllipse);
    private void 4CM=();
    private TabDbfColumn HCs=(int index);
    public static void BuildIndexFile(string tabPathFilename);
    public static void BuildIndexFile(string tabPathFilename, BuildIndexMode buildIndexMode);
    private static void aSE=(string tabPathFilename, ProjectionConverter projection, BuildIndexMode buildIndexMode);
    public static void CreateTabFile(string tabPathFilename, IEnumerable`1<TabDbfColumn> databaseColumns, IEnumerable`1<Feature> features);
    public static void CreateTabFile(string tabPathFilename, IEnumerable`1<TabDbfColumn> databaseColumns, IEnumerable`1<Feature> features, OverwriteMode overwriteMode);
    public static void CreateTabFile(string tabPathFilename, IEnumerable`1<TabDbfColumn> databaseColumns, IEnumerable`1<Feature> features, OverwriteMode overwriteMode, Encoding encoding);
    internal GCo= HSs=();
    private static void His=(string pathFilename, IEnumerable`1<TabDbfColumn> columns, IEnumerable`1<Feature> features, OverwriteMode overwriteMode, Dys= tabFileType, string mifProjection, double north, double south, double east, double west, Encoding encoding);
    private static void Hys=(ECU= mapInfoFile, TabDbfColumn column);
    private static void ICs=(ECU= mapInfoFile, Feature feature);
    private static void mCM=(string path);
    private static void 6iM=(string sourceFileName, string targetFileName);
    private static GSg= ISs=(ECU= mapInfoFile, Feature feature);
    private static GSg= Iis=(ECU= mapInfoFile, Feature feature);
    private static GSg= Iys=(ECU= mapInfoFile, Feature feature);
    private static GSg= JCs=(ECU= mapInfoFile, Feature feature);
    private static Collection`1<GSg=> JSs=(ECU= mapInfoFile, Feature feature);
    private static void Jis=(ECU= mapInfoFile, GSg= tabFeature, Feature feature);
    private static GSg= Jys=(ECU= mapInfoFile, Feature feature);
    public static void BuildRecordIdColumn(string tabFileName, string fieldName, BuildRecordIdMode buildRecordIdMode);
    public static void BuildRecordIdColumn(string tabFileName, string fieldName, BuildRecordIdMode buildRecordIdMode, int startNumber);
    public static void BuildRecordIdColumn(string tabFileName, string fieldName, BuildRecordIdMode buildRecordIdMode, int startNumber, Encoding encoding);
    internal Dictionary`2<Feature, IEnumerable`1<Style>> KCs=();
    internal void KSs=();
    public void SetEmbeddedSymbolStyle(Feature feature, PointStyle pointStyle);
    public void SetEmbeddedPenStyle(Feature feature, LineStyle lineStyle);
    public void SetEmbeddedBrushStyle(Feature feature, AreaStyle areaStyle);
    public void SetEmbeddedTextStyle(Feature feature, TextStyle textStyle);
    private int Kis=(GeoColor color);
    private Collection`1<Style> Kys=(GSg= tabFeature, Feature feature, WellKnownType wellKnownType);
    private DbfColumnType LCs=(string typeName);
}
public enum ThinkGeo.Core.TabStylingType : Enum {
    public int value__;
    public static TabStylingType EmbeddedStyling;
    public static TabStylingType StandardStyling;
}
public enum ThinkGeo.Core.TextPlacement : Enum {
    public int value__;
    public static TextPlacement Default;
    public static TextPlacement UpperLeft;
    public static TextPlacement Upper;
    public static TextPlacement UpperRight;
    public static TextPlacement Right;
    public static TextPlacement Center;
    public static TextPlacement Left;
    public static TextPlacement LowerLeft;
    public static TextPlacement Lower;
    public static TextPlacement LowerRight;
    public static TextPlacement AutoPlacement;
}
public class ThinkGeo.Core.TextStyle : PositionStyle {
    private static double XjE=;
    private static int XzE=;
    private static double YDE=;
    public float XOffsetInPixel { get; public set; }
    public float YOffsetInPixel { get; public set; }
    public bool FittingLineInScreen { get; public set; }
    public bool FittingPolygonInScreen { get; public set; }
    public Collection`1<TextStyle> CustomTextStyles { get; }
    public double RotationAngle { get; public set; }
    public string TextFormat { get; public set; }
    public string NumericFormat { get; public set; }
    public string DateFormat { get; public set; }
    public GeoBrush TextBrush { get; public set; }
    public GeoFont Font { get; public set; }
    public GeoPen HaloPen { get; public set; }
    public string TextColumnName { get; public set; }
    public AreaStyle Mask { get; public set; }
    public DrawingMargin MaskMargin { get; public set; }
    public bool ForceHorizontalLabelForLine { get; public set; }
    public SplineType SplineType { get; public set; }
    public DrawingLevel DrawingLevel { get; public set; }
    public Dictionary`2<string, WorldLabelingCandidate> LabelPositions { get; }
    public DrawingTextAlignment Alignment { get; public set; }
    public DrawingTextLetterCase LetterCase { get; public set; }
    public double MaxCharAngleDelta { get; public set; }
    public double MinDistance { get; public set; }
    public double Spacing { get; public set; }
    public double WrapWidth { get; public set; }
    public PointStyle BasePoint { get; public set; }
    public TextStyle(string textColumnName, GeoFont textFont, GeoBrush textBrush);
    public float get_XOffsetInPixel();
    public void set_XOffsetInPixel(float value);
    public float get_YOffsetInPixel();
    public void set_YOffsetInPixel(float value);
    public bool get_FittingLineInScreen();
    public void set_FittingLineInScreen(bool value);
    public bool get_FittingPolygonInScreen();
    public void set_FittingPolygonInScreen(bool value);
    public Collection`1<TextStyle> get_CustomTextStyles();
    public double get_RotationAngle();
    public void set_RotationAngle(double value);
    public string get_TextFormat();
    public void set_TextFormat(string value);
    public string get_NumericFormat();
    public void set_NumericFormat(string value);
    public string get_DateFormat();
    public void set_DateFormat(string value);
    public GeoBrush get_TextBrush();
    public void set_TextBrush(GeoBrush value);
    public GeoFont get_Font();
    public void set_Font(GeoFont value);
    public GeoPen get_HaloPen();
    public void set_HaloPen(GeoPen value);
    public string get_TextColumnName();
    public void set_TextColumnName(string value);
    public AreaStyle get_Mask();
    public void set_Mask(AreaStyle value);
    public DrawingMargin get_MaskMargin();
    public void set_MaskMargin(DrawingMargin value);
    public bool get_ForceHorizontalLabelForLine();
    public void set_ForceHorizontalLabelForLine(bool value);
    public SplineType get_SplineType();
    public void set_SplineType(SplineType value);
    public DrawingLevel get_DrawingLevel();
    public void set_DrawingLevel(DrawingLevel value);
    public Dictionary`2<string, WorldLabelingCandidate> get_LabelPositions();
    public DrawingTextAlignment get_Alignment();
    public void set_Alignment(DrawingTextAlignment value);
    public DrawingTextLetterCase get_LetterCase();
    public void set_LetterCase(DrawingTextLetterCase value);
    public double get_MaxCharAngleDelta();
    public void set_MaxCharAngleDelta(double value);
    public double get_MinDistance();
    public void set_MinDistance(double value);
    public double get_Spacing();
    public void set_Spacing(double value);
    public double get_WrapWidth();
    public void set_WrapWidth(double value);
    public PointStyle get_BasePoint();
    public void set_BasePoint(PointStyle value);
    public static TextStyle Parse(string styleJson);
    internal static TextStyle ahU=(JObject jObject);
    public static TextStyle CreateSimpleTextStyle(string textColumnName, string fontFamilyName, float fontSize, DrawingFontStyles drawingFontStyle, GeoColor fontColor);
    public static TextStyle CreateSimpleTextStyle(string textColumnName, string fontFamilyName, float fontSize, DrawingFontStyles drawingFontStyle, GeoColor fontColor, float xOffset, float yOffset);
    public static TextStyle CreateSimpleTextStyle(string textColumnName, string fontFamilyName, float fontSize, DrawingFontStyles drawingFontStyle, GeoColor fontColor, GeoColor haloPenColor, float haloPenWidth);
    public static TextStyle CreateSimpleTextStyle(string textColumnName, string fontFamilyName, float fontSize, DrawingFontStyles drawingFontStyle, GeoColor fontColor, GeoColor haloPenColor, float haloPenWidth, float xOffset, float yOffset);
    public static TextStyle CreateMaskTextStyle(string textColumnName, string fontFamilyName, float fontSize, DrawingFontStyles drawingFontStyle, GeoColor fontColor, GeoColor maskFillColor);
    public static TextStyle CreateMaskTextStyle(string textColumnName, string fontFamilyName, float fontSize, DrawingFontStyles drawingFontStyle, GeoColor fontColor, GeoColor maskFillColor, float xOffset, float yOffset);
    public static TextStyle CreateMaskTextStyle(string textColumnName, GeoFont textFont, GeoBrush textBrush, AreaStyle areaStyle, float xOffset, float yOffset);
    public static TextStyle CreateMaskTextStyle(string textColumnName, string fontFamilyName, float fontSize, DrawingFontStyles drawingFontStyle, GeoColor fontColor, GeoColor maskPenColor, float maskPenSize);
    public static TextStyle CreateMaskTextStyle(string textColumnName, string fontFamilyName, float fontSize, DrawingFontStyles drawingFontStyle, GeoColor fontColor, GeoColor maskPenColor, float maskPenSize, float xOffset, float yOffset);
    private static DrawingMargin kTI=(string expression);
    private static GeoFont kjI=(string fontExpression);
    private static GeoPen wjA=(String[] valueExpressions);
    private static GeoBrush kzI=(String[] valueExpressions);
    private static AreaStyle lDI=(String[] valueExpressions);
}
[ObfuscationAttribute]
public class ThinkGeo.Core.ThinkGeoCloudApplicationException : ApplicationException {
    [CompilerGeneratedAttribute]
private HttpStatusCode <StatusCode>k__BackingField;
    public HttpStatusCode StatusCode { get; }
    public ThinkGeoCloudApplicationException(HttpStatusCode statusCode, string message, Exception innerException);
    [CompilerGeneratedAttribute]
public HttpStatusCode get_StatusCode();
}
public class ThinkGeo.Core.ThinkGeoCloudMapsZoomLevelSet : ZoomLevelSet {
    public ThinkGeoCloudMapsZoomLevelSet(int tileSize);
}
public enum ThinkGeo.Core.ThinkGeoCloudRasterMapsMapType : Enum {
    public int value__;
    [ObsoleteAttribute("Default has been changed from Light to Light_V2_X1. Please always specify a MapType without using the default.")]
public static ThinkGeoCloudRasterMapsMapType Default;
    [ObsoleteAttribute("Light has been renamed to Light_V1_X1. Please consider upgrading to Light_V1_X2 for higher resolution or upgrading to Light_V2 for a sharper style. ")]
public static ThinkGeoCloudRasterMapsMapType Light;
    [ObsoleteAttribute("Dark has been renamed to Dark_V1_X1, please consider upgrading to Dark_V1_X2 for higher resolution or upgrading to Dark_V2 for a sharper style. ")]
public static ThinkGeoCloudRasterMapsMapType Dark;
    [ObsoleteAttribute("Hybrid has been renamed to Hybrid_V1_X1, please consider upgrading to Hybrid_V1_X2 for higher resolution or upgrading to Hybrid_V2 for a sharper style. ")]
public static ThinkGeoCloudRasterMapsMapType Hybrid;
    [ObsoleteAttribute("Aerial has been renamed to Aerial_V1_X1, please consider upgrading to Aerial_V2_X1 for a newer data set or upgrading to Aerial_V2_X2 for higher resolution.")]
public static ThinkGeoCloudRasterMapsMapType Aerial;
    [ObsoleteAttribute("TransparentBackground has been renamed to TransparentBackground_V1_X1, please consider upgrading to TransparentBackground_V1_X2 for higher resolution or upgrading to TransparentBackground_V2 for a sharper style. ")]
public static ThinkGeoCloudRasterMapsMapType TransparentBackground;
    public static ThinkGeoCloudRasterMapsMapType Light_V1_X1;
    public static ThinkGeoCloudRasterMapsMapType Light_V1_X2;
    public static ThinkGeoCloudRasterMapsMapType Light_V2_X1;
    public static ThinkGeoCloudRasterMapsMapType Light_V2_X2;
    public static ThinkGeoCloudRasterMapsMapType Dark_V1_X1;
    public static ThinkGeoCloudRasterMapsMapType Dark_V1_X2;
    public static ThinkGeoCloudRasterMapsMapType Dark_V2_X1;
    public static ThinkGeoCloudRasterMapsMapType Dark_V2_X2;
    public static ThinkGeoCloudRasterMapsMapType Hybrid_V1_X1;
    public static ThinkGeoCloudRasterMapsMapType Hybrid_V1_X2;
    public static ThinkGeoCloudRasterMapsMapType Hybrid_V2_X1;
    public static ThinkGeoCloudRasterMapsMapType Hybrid_V2_X2;
    public static ThinkGeoCloudRasterMapsMapType Aerial_V1_X1;
    public static ThinkGeoCloudRasterMapsMapType Aerial_V1_X2;
    public static ThinkGeoCloudRasterMapsMapType Aerial_V2_X1;
    public static ThinkGeoCloudRasterMapsMapType Aerial_V2_X2;
    public static ThinkGeoCloudRasterMapsMapType TransparentBackground_V1_X1;
    public static ThinkGeoCloudRasterMapsMapType TransparentBackground_V1_X2;
    public static ThinkGeoCloudRasterMapsMapType TransparentBackground_V2_X1;
    public static ThinkGeoCloudRasterMapsMapType TransparentBackground_V2_X2;
}
public enum ThinkGeo.Core.ThinkGeoCloudVectorMapsMapType : Enum {
    public int value__;
    public static ThinkGeoCloudVectorMapsMapType Default;
    public static ThinkGeoCloudVectorMapsMapType Light;
    public static ThinkGeoCloudVectorMapsMapType Dark;
    public static ThinkGeoCloudVectorMapsMapType TransparentBackground;
    public static ThinkGeoCloudVectorMapsMapType CustomizedByStyleJson;
}
public static class ThinkGeo.Core.ThinkGeoDebugger : object {
    [CompilerGeneratedAttribute]
private static ThinkGeoLogLevel VR0=;
    [CompilerGeneratedAttribute]
private static ThinkGeoLogType Vh0=;
    [CompilerGeneratedAttribute]
private static StreamWriter Vx0=;
    [CompilerGeneratedAttribute]
private static bool WB0=;
    [CompilerGeneratedAttribute]
private static bool WR0=;
    public static ThinkGeoLogLevel LogLevel { get; public set; }
    public static ThinkGeoLogType LogType { get; public set; }
    public static StreamWriter LogStreamWriter { get; public set; }
    public static bool LogToConsole { get; public set; }
    public static bool DisplayTileId { get; public set; }
    private static ThinkGeoDebugger();
    [CompilerGeneratedAttribute]
public static ThinkGeoLogLevel get_LogLevel();
    [CompilerGeneratedAttribute]
public static void set_LogLevel(ThinkGeoLogLevel value);
    [CompilerGeneratedAttribute]
public static ThinkGeoLogType get_LogType();
    [CompilerGeneratedAttribute]
public static void set_LogType(ThinkGeoLogType value);
    [CompilerGeneratedAttribute]
public static StreamWriter get_LogStreamWriter();
    [CompilerGeneratedAttribute]
public static void set_LogStreamWriter(StreamWriter value);
    [CompilerGeneratedAttribute]
public static bool get_LogToConsole();
    [CompilerGeneratedAttribute]
public static void set_LogToConsole(bool value);
    public static void Log(string message, ThinkGeoLogType logType, ThinkGeoLogLevel logLevel);
    [CompilerGeneratedAttribute]
public static bool get_DisplayTileId();
    [CompilerGeneratedAttribute]
public static void set_DisplayTileId(bool value);
}
public enum ThinkGeo.Core.ThinkGeoLicenseStatus : Enum {
    public int value__;
    public static ThinkGeoLicenseStatus None;
    public static ThinkGeoLicenseStatus SoftwareAssuranceAssemblyInvalid;
    public static ThinkGeoLicenseStatus SoftwareAssuranceNotFound;
    public static ThinkGeoLicenseStatus SoftwareAssuranceExpired;
    public static ThinkGeoLicenseStatus LicenseFileInvalid;
    public static ThinkGeoLicenseStatus EvalWithProductExpired;
    public static ThinkGeoLicenseStatus EvalWithProductCallerNotMatch;
    public static ThinkGeoLicenseStatus FullWithoutProduct;
    public static ThinkGeoLicenseStatus FullWithProductExpired;
    public static ThinkGeoLicenseStatus FullWithProductCallerNotMatch;
    public static ThinkGeoLicenseStatus RuntimeLicenseForDebug;
    public static ThinkGeoLicenseStatus FullWithoutServer;
    public static ThinkGeoLicenseStatus EvalWithProduct;
    public static ThinkGeoLicenseStatus FullWithProduct;
    public static ThinkGeoLicenseStatus FullWithServer;
}
public enum ThinkGeo.Core.ThinkGeoLogLevel : Enum {
    public int value__;
    public static ThinkGeoLogLevel All;
    public static ThinkGeoLogLevel Message;
    public static ThinkGeoLogLevel Warning;
    public static ThinkGeoLogLevel Error;
    public static ThinkGeoLogLevel None;
}
[FlagsAttribute]
public enum ThinkGeo.Core.ThinkGeoLogType : Enum {
    public int value__;
    public static ThinkGeoLogType Others;
    public static ThinkGeoLogType Rendering;
    public static ThinkGeoLogType Licensing;
    public static ThinkGeoLogType Interaction;
    public static ThinkGeoLogType PopupAndMarker;
    public static ThinkGeoLogType WebRequest;
    public static ThinkGeoLogType Caching;
    public static ThinkGeoLogType DataFetching;
    public static ThinkGeoLogType All;
}
public class ThinkGeo.Core.ThinkGeoMBTilesLayer : Layer {
    private int vys=;
    [ObfuscationAttribute]
private Uri styleJsonUri;
    [ObfuscationAttribute]
private RasterTileCache bitmapTileCache;
    private ZoomLevelSet 9x0=;
    private bool wCs=;
    [ObfuscationAttribute]
private string mbTilesPathFilename;
    private SqliteConnection wSs=;
    private bool wis=;
    [ObfuscationAttribute]
private static bool newFormat;
    private static Dictionary`2<string, Feature> wys=;
    private static object xCs=;
    private static object xSs=;
    private static object oRM=;
    private static int xis=;
    private Collection`1<VectorTile> xys=;
    private Collection`1<VectorTile> yCs=;
    private Collection`1<VectorTile> ySs=;
    private bool yis=;
    private bool yys=;
    [CompilerGeneratedAttribute]
private EventHandler`1<GeneratingTileMBTilesLayerEventArgs> GeneratingTile;
    [CompilerGeneratedAttribute]
private EventHandler`1<GeneratedTileMBTilesLayerEventArgs> GeneratedTile;
    private ProjectionConverter /R0=;
    [CompilerGeneratedAttribute]
private DrawingQuality zCs=;
    [CompilerGeneratedAttribute]
private int /x0=;
    public ProjectionConverter ProjectionConverter { get; public set; }
    public RasterTileCache BitmapTileCache { get; public set; }
    public Uri StyleJsonUri { get; public set; }
    public DrawingQuality DrawingQuality { get; public set; }
    public bool ShowDebugInfo { get; public set; }
    public int TileSize { get; public set; }
    public ThinkGeoMBTilesLayer(string mbTilesPathFilename);
    public ThinkGeoMBTilesLayer(string mbTilesPathFilename, Uri styleJsonUri);
    private static ThinkGeoMBTilesLayer();
    [CompilerGeneratedAttribute]
public void add_GeneratingTile(EventHandler`1<GeneratingTileMBTilesLayerEventArgs> value);
    [CompilerGeneratedAttribute]
public void remove_GeneratingTile(EventHandler`1<GeneratingTileMBTilesLayerEventArgs> value);
    [CompilerGeneratedAttribute]
public void add_GeneratedTile(EventHandler`1<GeneratedTileMBTilesLayerEventArgs> value);
    [CompilerGeneratedAttribute]
public void remove_GeneratedTile(EventHandler`1<GeneratedTileMBTilesLayerEventArgs> value);
    public ProjectionConverter get_ProjectionConverter();
    public void set_ProjectionConverter(ProjectionConverter value);
    public RasterTileCache get_BitmapTileCache();
    public void set_BitmapTileCache(RasterTileCache value);
    public Uri get_StyleJsonUri();
    public void set_StyleJsonUri(Uri value);
    [CompilerGeneratedAttribute]
public DrawingQuality get_DrawingQuality();
    [CompilerGeneratedAttribute]
public void set_DrawingQuality(DrawingQuality value);
    public bool get_ShowDebugInfo();
    public void set_ShowDebugInfo(bool value);
    [CompilerGeneratedAttribute]
public int get_TileSize();
    [CompilerGeneratedAttribute]
public void set_TileSize(int value);
    protected virtual void CloseCore();
    protected virtual void OpenCore();
    protected virtual RectangleShape GetBoundingBoxCore();
    public VectorTile GetTile(long zoom, long column, long row);
    public void LoadStyleJson();
    [AsyncStateMachineAttribute("ThinkGeo.Core.ThinkGeoMBTilesLayer/<DrawTileAsync>d__56")]
public Task DrawTileAsync(GeoCanvas canvas, int zoomIndex, long columnIndex, long rowIndex);
    [AsyncStateMachineAttribute("ThinkGeo.Core.ThinkGeoMBTilesLayer/<DrawTileAsync>d__57")]
internal static Task zSs=(GeoCanvas canvas, int zoomIndex, long columnIndex, long rowIndex, ZoomLevelSet zoomLevelSet, bool ShowDebugInfo, RasterTileCache BitmapTileCache, int maxZoom, List`1<string> pbfLayerNames, Uz0= getFeaturesFromPbfVectorTileAsyncDelegate, bool useLegacyLabeling, int tileSize);
    internal static Collection`1<Feature> zis=(int zoom, long column, long row, RectangleShape boundingBox, CancellationToken cancellationToken, int maxZoom, List`1<string> pbfLayerNames, VD0= getFeaturesFromPbfVectorTile);
    [AsyncStateMachineAttribute("ThinkGeo.Core.ThinkGeoMBTilesLayer/<GetFeaturesForDrawingAsync>d__59")]
internal static Task`1<Collection`1<Feature>> zys=(int zoom, long column, long row, RectangleShape boundingBox, CancellationToken cancellationToken, int maxZoom, List`1<string> pbfLayerNames, Uz0= getFeaturesFromPbfVectorTileAsync);
    internal static List`1<string> 0Cs=(ZoomLevelSet zoomLevelSet, int zoomLevelIndex);
    [AsyncStateMachineAttribute("ThinkGeo.Core.ThinkGeoMBTilesLayer/<GetFeaturesFromPbfVectorTileAsync>d__61")]
private Task`1<Collection`1<Feature>> AR4=(int zoom, long column, long row, List`1<string> pbfLayerNames, CancellationToken cancellationToken);
    protected virtual void DrawCore(GeoCanvas canvas, Collection`1<SimpleCandidate> labelsInAllLayers);
    protected virtual void OnGeneratingTile(GeneratingTileMBTilesLayerEventArgs e);
    protected virtual void OnGeneratedTile(GeneratedTileMBTilesLayerEventArgs e);
    private Collection`1<Feature> zis=(RectangleShape boundingBox, double screenWidth, CancellationToken cancellationToken);
    private Collection`1<Feature> 0Ss=(RectangleShape boundingBox, double screenWidth, CancellationToken cancellationToken);
    private string 0is=(int zoom, long minColumn, long maxColumn, long minRow, long maxRow);
    private Collection`1<VectorTile> 0ys=(string sqlStatement);
    private void 1Cs=();
    public void BeginTransaction();
    public TransactionResult CommitTransaction();
    public void WriteMetaData(string key, string value);
    public static void CreateDatabase(string mbTilesPath, bool isOverwrite);
    public void AddTile(VectorTile vectorTile);
    public void UpdateTile(VectorTile vectorTile);
    public void DeleteTile(VectorTile vectorTile);
    private static void 1Ss=(SqliteConnection connection);
    private static void 1is=(SqliteConnection connection);
    private static void 1ys=(SqliteConnection connection);
    private void 2Cs=(Collection`1<VectorTile> deleteBuffer);
    private void 2Ss=(Collection`1<VectorTile> addBuffer);
    private void 2is=(Collection`1<VectorTile> updateBuffer);
    private void 2ys=(RectangleShape boundingBox, int minZoom, int maxZoom);
    private static Collection`1<Feature> 3Cs=(FeatureLayer featureLayer, List`1<string> featureIds, IEnumerable`1<string> columnNames);
}
public class ThinkGeo.Core.ThinkGeoProductLicense : object {
    internal static string ch0=;
    internal static string cx0=;
    internal static string dB0=;
    internal static string dR0=;
    internal static string dh0=;
    internal static string dx0=;
    internal static string eB0=;
    internal static string eR0=;
    internal static string eh0=;
    private static ThinkGeoProductLicense();
    public static ThinkGeoLicenseStatus GetCoreLicenseStatus();
    public static ThinkGeoLicenseStatus GetWinformsLicenseStatus();
    public static ThinkGeoLicenseStatus GetWpfLicenseStatus();
    public static ThinkGeoLicenseStatus GetBlazorLicenseStatus();
    public static ThinkGeoLicenseStatus GetBlazorServerLicenseStatus();
    public static ThinkGeoLicenseStatus GetWebApiLicenseStatus();
    public static ThinkGeoLicenseStatus GetWebApiServerLicenseStatus();
    public static ThinkGeoLicenseStatus GetiOSLicenseStatus();
    public static ThinkGeoLicenseStatus GetAndroidLicenseStatus();
    public static ThinkGeoLicenseStatus GetXamarinFormsLicenseStatus();
    private static ThinkGeoLicenseStatus ex0=(string productId);
}
public class ThinkGeo.Core.ThinkGeoRasterMapsAsyncLayer : XyzTileAsyncLayer {
    private static int rx0=;
    private tR0= 7h0=;
    private ThinkGeoCloudRasterMapsMapType 7x0=;
    public RasterTileCache TileCache { get; public set; }
    public RasterTileCache ProjectedTileCache { get; public set; }
    public ProjectionConverter ProjectionConverterFromServerProjection { get; public set; }
    public ThinkGeoCloudRasterMapsMapType MapType { get; public set; }
    public string ClientId { get; public set; }
    public string ClientSecret { get; public set; }
    public ThinkGeoRasterMapsAsyncLayer(string clientId, string clientSecret);
    public ThinkGeoRasterMapsAsyncLayer(string clientId, string clientSecret, ThinkGeoCloudRasterMapsMapType mapType);
    public virtual RasterTileCache get_TileCache();
    public virtual void set_TileCache(RasterTileCache value);
    public virtual RasterTileCache get_ProjectedTileCache();
    public virtual void set_ProjectedTileCache(RasterTileCache value);
    public virtual ProjectionConverter get_ProjectionConverterFromServerProjection();
    public virtual void set_ProjectionConverterFromServerProjection(ProjectionConverter value);
    public ThinkGeoCloudRasterMapsMapType get_MapType();
    public void set_MapType(ThinkGeoCloudRasterMapsMapType value);
    public string get_ClientId();
    public void set_ClientId(string value);
    public string get_ClientSecret();
    public void set_ClientSecret(string value);
    [AsyncStateMachineAttribute("ThinkGeo.Core.ThinkGeoRasterMapsAsyncLayer/<OpenAsyncCore>d__24")]
protected virtual Task OpenAsyncCore(CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("ThinkGeo.Core.ThinkGeoRasterMapsAsyncLayer/<CloseAsyncCore>d__25")]
protected virtual Task CloseAsyncCore(CancellationToken cancellationToken);
    protected virtual Task`1<string> GetImageUriAsyncCore(int zoomLevel, long x, long y, float resolutionFactor);
    [AsyncStateMachineAttribute("ThinkGeo.Core.ThinkGeoRasterMapsAsyncLayer/<ThinkGeoCloudRasterMapsLayer2_SendingHttpRequest>d__27")]
private void 8B0=(object sender, SendingHttpRequestMessageEventArgs e);
    private void 6x0=();
    private string 8R0=(string cacheIdWithSuffix);
    protected virtual int GetTileScale();
    private string 8h0=();
    private string 8x0=(ThinkGeoCloudRasterMapsMapType mapType);
    private string 9B0=(ThinkGeoCloudRasterMapsMapType mapType);
    private string 9R0=(ThinkGeoCloudRasterMapsMapType mapType);
    private GeoImageFormat uBY=(ThinkGeoCloudRasterMapsMapType mapType);
    [CompilerGeneratedAttribute]
[DebuggerHiddenAttribute]
private Task <>n__0(CancellationToken cancellationToken);
    [DebuggerHiddenAttribute]
[CompilerGeneratedAttribute]
private Task <>n__1(CancellationToken cancellationToken);
}
public class ThinkGeo.Core.ThinkGeoVectorMapsAsyncLayer : WebBasedAsyncLayer {
    private static int 9h0=;
    [ObfuscationAttribute]
private Uri styleJsonUri;
    [ObfuscationAttribute]
private RasterTileCache bitmapTileCache;
    private ZoomLevelSet 9x0=;
    private tR0= 7h0=;
    private ThinkGeoCloudVectorMapsMapType 7x0=;
    private FileVectorTileCache /B0=;
    private ProjectionConverter /R0=;
    [CompilerGeneratedAttribute]
private bool /h0=;
    [CompilerGeneratedAttribute]
private int /x0=;
    private bool AB4=;
    public bool ShowDebugInfo { get; public set; }
    public int TileSize { get; public set; }
    public string ClientId { get; public set; }
    public string ClientSecret { get; public set; }
    public ThinkGeoCloudVectorMapsMapType MapType { get; public set; }
    public FileVectorTileCache VectorTileCache { get; public set; }
    public RasterTileCache BitmapTileCache { get; public set; }
    public Uri StyleJsonUri { get; public set; }
    public ProjectionConverter ProjectionConverter { get; public set; }
    public ThinkGeoVectorMapsAsyncLayer(string clientId, string clientSecret);
    public ThinkGeoVectorMapsAsyncLayer(string clientId, string clientSecret, Uri styleJsonUri);
    public ThinkGeoVectorMapsAsyncLayer(string clientId, string clientSecret, ThinkGeoCloudVectorMapsMapType mapType);
    [CompilerGeneratedAttribute]
public bool get_ShowDebugInfo();
    [CompilerGeneratedAttribute]
public void set_ShowDebugInfo(bool value);
    [CompilerGeneratedAttribute]
public int get_TileSize();
    [CompilerGeneratedAttribute]
public void set_TileSize(int value);
    public string get_ClientId();
    public void set_ClientId(string value);
    public string get_ClientSecret();
    public void set_ClientSecret(string value);
    public ThinkGeoCloudVectorMapsMapType get_MapType();
    public void set_MapType(ThinkGeoCloudVectorMapsMapType value);
    public FileVectorTileCache get_VectorTileCache();
    public void set_VectorTileCache(FileVectorTileCache value);
    public RasterTileCache get_BitmapTileCache();
    public void set_BitmapTileCache(RasterTileCache value);
    public Uri get_StyleJsonUri();
    public void set_StyleJsonUri(Uri value);
    public ProjectionConverter get_ProjectionConverter();
    public void set_ProjectionConverter(ProjectionConverter value);
    [AsyncStateMachineAttribute("ThinkGeo.Core.ThinkGeoVectorMapsAsyncLayer/<OpenAsyncCore>d__42")]
protected virtual Task OpenAsyncCore(CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("ThinkGeo.Core.ThinkGeoVectorMapsAsyncLayer/<CloseAsyncCore>d__43")]
protected virtual Task CloseAsyncCore(CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("ThinkGeo.Core.ThinkGeoVectorMapsAsyncLayer/<GetFeaturesFromPbfVectorTileAsync>d__44")]
private Task`1<Collection`1<Feature>> AR4=(int zoom, long column, long row, List`1<string> pbfLayerNames, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("ThinkGeo.Core.ThinkGeoVectorMapsAsyncLayer/<GetPbfVectorTileAsync>d__45")]
private Task`1<VectorTile> Ah4=(int zoom, long column, long row, CancellationToken cancellationToken);
    private void Ax4=();
    [AsyncStateMachineAttribute("ThinkGeo.Core.ThinkGeoVectorMapsAsyncLayer/<DrawTileAsync>d__47")]
public Task DrawTileAsync(GeoCanvas canvas, int zoomIndex, long columnIndex, long rowIndex);
    [AsyncStateMachineAttribute("ThinkGeo.Core.ThinkGeoVectorMapsAsyncLayer/<DrawAsyncCore>d__48")]
protected virtual Task DrawAsyncCore(GeoCanvas canvas, Collection`1<SimpleCandidate> labelsInAllLayers);
    private void 6x0=(ThinkGeoCloudVectorMapsMapType mapType);
    private bool 7B0=(string cacheId);
    [CompilerGeneratedAttribute]
[DebuggerHiddenAttribute]
private Task <>n__0(CancellationToken cancellationToken);
    [CompilerGeneratedAttribute]
[DebuggerHiddenAttribute]
private Task <>n__1(CancellationToken cancellationToken);
}
internal class ThinkGeo.Core.ThreadSafeStore`2 : object {
    private object _lock;
    [ObfuscationAttribute]
private Dictionary`2<TKey, TValue> _store;
    private Func`2<TKey, TValue> _creator;
    public ThreadSafeStore`2(Func`2<TKey, TValue> creator);
    public TValue Get(TKey key);
    private TValue AddValue(TKey key);
}
public enum ThinkGeo.Core.ThreadSafetyLevel : Enum {
    public int value__;
    public static ThreadSafetyLevel Unsafe;
    public static ThreadSafetyLevel Safe;
}
public class ThinkGeo.Core.ThrowingExceptionOverlayEventArgs : EventArgs {
    [CompilerGeneratedAttribute]
private Exception jhQ=;
    [CompilerGeneratedAttribute]
private string jxQ=;
    [CompilerGeneratedAttribute]
private bool kBQ=;
    public Exception Exception { get; private set; }
    public string MemberName { get; private set; }
    public bool Handled { get; public set; }
    public ThrowingExceptionOverlayEventArgs(Exception exception, string memberName);
    [CompilerGeneratedAttribute]
public Exception get_Exception();
    [CompilerGeneratedAttribute]
private void set_Exception(Exception value);
    [CompilerGeneratedAttribute]
public string get_MemberName();
    [CompilerGeneratedAttribute]
private void set_MemberName(string value);
    [CompilerGeneratedAttribute]
public bool get_Handled();
    [CompilerGeneratedAttribute]
public void set_Handled(bool value);
}
public abstract class ThinkGeo.Core.Tile : object {
    [ObfuscationAttribute]
private int zoomIndex;
    [ObfuscationAttribute]
private long cloumn;
    [ObfuscationAttribute]
private long row;
    [CompilerGeneratedAttribute]
private string kB0=;
    public int ZoomIndex { get; public set; }
    public long Column { get; public set; }
    public long Row { get; public set; }
    public string CacheId { get; public set; }
    public Tile(int zoomIndex, long column, long row);
    public int get_ZoomIndex();
    public void set_ZoomIndex(int value);
    public long get_Column();
    public void set_Column(long value);
    public long get_Row();
    public void set_Row(long value);
    [CompilerGeneratedAttribute]
public string get_CacheId();
    [CompilerGeneratedAttribute]
public void set_CacheId(string value);
    public Tile CloneDeep();
    protected virtual Tile CloneDeepCore();
}
public enum ThinkGeo.Core.TileAccessMode : Enum {
    public int value__;
    public static TileAccessMode Default;
    public static TileAccessMode ReadOnly;
    public static TileAccessMode ReadAdd;
    public static TileAccessMode ReadAddDelete;
}
public abstract class ThinkGeo.Core.TileCache : object {
    [ObfuscationAttribute]
private string cacheId;
    [ObfuscationAttribute]
private TimeSpan expirationTime;
    [ObfuscationAttribute]
private TileAccessMode tileAccessMode;
    [CompilerGeneratedAttribute]
private EventHandler`1<GottenCacheImageBitmapTileCacheEventArgs> GottenCacheTile;
    [CompilerGeneratedAttribute]
private EventHandler`1<GettingCacheImageBitmapTileCacheEventArgs> GettingCacheTile;
    public TileAccessMode TileAccessMode { get; public set; }
    public string CacheId { get; public set; }
    public TimeSpan ExpirationTime { get; public set; }
    protected TileCache(string cacheId);
    [CompilerGeneratedAttribute]
public void add_GottenCacheTile(EventHandler`1<GottenCacheImageBitmapTileCacheEventArgs> value);
    [CompilerGeneratedAttribute]
public void remove_GottenCacheTile(EventHandler`1<GottenCacheImageBitmapTileCacheEventArgs> value);
    [CompilerGeneratedAttribute]
public void add_GettingCacheTile(EventHandler`1<GettingCacheImageBitmapTileCacheEventArgs> value);
    [CompilerGeneratedAttribute]
public void remove_GettingCacheTile(EventHandler`1<GettingCacheImageBitmapTileCacheEventArgs> value);
    public TileAccessMode get_TileAccessMode();
    public void set_TileAccessMode(TileAccessMode value);
    public virtual string get_CacheId();
    public virtual void set_CacheId(string value);
    public TimeSpan get_ExpirationTime();
    public void set_ExpirationTime(TimeSpan value);
    protected virtual void OnGottenCacheTile(GottenCacheImageBitmapTileCacheEventArgs e);
    protected virtual void OnGettingCacheTile(GettingCacheImageBitmapTileCacheEventArgs e);
    [ObsoleteAttribute("This API is obsoleted, please use GetTileAsync() instead")]
public Tile GetTile(int zoom, long column, long row);
    [AsyncStateMachineAttribute("ThinkGeo.Core.TileCache/<GetTileAsync>d__22")]
public Task`1<Tile> GetTileAsync(int zoom, long column, long row, CancellationToken cancellationToken);
    [ObsoleteAttribute("This API is obsoleted, please use SaveTileAsync() instead")]
public void SaveTile(Tile tile);
    [AsyncStateMachineAttribute("ThinkGeo.Core.TileCache/<SaveTileAsync>d__24")]
public Task SaveTileAsync(Tile tile, CancellationToken cancellationToken);
    public void DeleteTile(Tile tile);
    public void ClearCache();
    protected abstract virtual void ClearCacheCore();
    [ObsoleteAttribute("This API is obsoleted, please use SaveTileAsyncCore() instead")]
protected virtual void SaveTileCore(Tile tile);
    protected abstract virtual void DeleteTileCore(Tile tile);
    protected virtual Task SaveTileAsyncCore(Tile tile, CancellationToken cancellationToken);
    protected virtual Task`1<Tile> GetTileAsyncCore(int zoom, long column, long row, CancellationToken cancellationToken);
    [ObsoleteAttribute("This API is obsoleted, please use GetTileAsync() instead")]
protected virtual Tile GetTileCore(int zoom, long column, long row);
}
public class ThinkGeo.Core.TileMatrix : Matrix {
    [ObfuscationAttribute]
private double scale;
    [ObfuscationAttribute]
private int tileWidth;
    [ObfuscationAttribute]
private int tileHeight;
    [ObfuscationAttribute]
private GeographyUnit geographyUnit;
    private static int gR0=;
    public double Scale { get; public set; }
    public int TileWidth { get; public set; }
    public int TileHeight { get; public set; }
    public GeographyUnit GeographyUnit { get; public set; }
    public TileMatrix(double scale);
    public TileMatrix(double scale, RectangleShape boundingBox, GeographyUnit geographyUnit);
    public TileMatrix(double scale, int tileWidth, int tileHeight, RectangleShape boundingBox, GeographyUnit geographyUnit);
    public double get_Scale();
    public void set_Scale(double value);
    internal void gh0=(double currentScale);
    public int get_TileWidth();
    public void set_TileWidth(int value);
    public int get_TileHeight();
    public void set_TileHeight(int value);
    public GeographyUnit get_GeographyUnit();
    public void set_GeographyUnit(GeographyUnit value);
    public static TileMatrix GetDefaultMatrix(double scale, int tileWidth, int tileHeight, GeographyUnit unit);
    private void gx0=();
    protected virtual RowColumnRange GetRowColumnRangeCore(RectangleShape worldExtent, bool isContains);
}
public enum ThinkGeo.Core.TileResolution : Enum {
    public int value__;
    public static TileResolution Default;
    public static TileResolution Standard;
    public static TileResolution High;
}
public enum ThinkGeo.Core.TileSizeMode : Enum {
    public int value__;
    public static TileSizeMode Default;
    public static TileSizeMode Small;
    public static TileSizeMode Medium;
    public static TileSizeMode DefaultX2;
}
public enum ThinkGeo.Core.TileSnappingMode : Enum {
    public int value__;
    public static TileSnappingMode NoSnapping;
    public static TileSnappingMode Snapping;
}
public class ThinkGeo.Core.TimeZoneCloudClient : CloudClient {
    private static int pRQ=;
    public TimeZoneCloudClient(string clientId, string clientSecret);
    public CloudTimeZoneResult GetTimeZoneByCoordinate(double latitude, double longitude);
    public CloudTimeZoneResult GetTimeZoneByCoordinate(double x, double y, int projectionInSrid);
    public CloudTimeZoneResult GetTimeZoneByCoordinate(double x, double y, string projectionInProj4String);
    public Task`1<CloudTimeZoneResult> GetTimeZoneByCoordinateAsync(double latitude, double longitude);
    public Task`1<CloudTimeZoneResult> GetTimeZoneByCoordinateAsync(double x, double y, int projectionInSrid);
    public Task`1<CloudTimeZoneResult> GetTimeZoneByCoordinateAsync(double x, double y, string projectionInProj4String);
    public Collection`1<string> GetAllTimeZoneNames();
    public Task`1<Collection`1<string>> GetAllTimeZoneNamesAsync();
    public Collection`1<CloudTimeZoneResult> GetAllTimeZones();
    public Task`1<Collection`1<CloudTimeZoneResult>> GetAllTimeZonesAsync();
    private CloudTimeZoneResult 8hQ=(double x, double y, Nullable`1<int> projectionInSrid, string projectionInProj4String);
    [AsyncStateMachineAttribute("ThinkGeo.Core.TimeZoneCloudClient/<GetTimeZoneByCoordinateCoreAsync>d__14")]
private Task`1<CloudTimeZoneResult> 8xQ=(double x, double y, Nullable`1<int> projectionInSrid, string projectionInProj4String);
    private Collection`1<string> 9BQ=();
    [AsyncStateMachineAttribute("ThinkGeo.Core.TimeZoneCloudClient/<GetAllTimeZoneNamesCoreAsync>d__16")]
private Task`1<Collection`1<string>> 9RQ=();
    private Collection`1<CloudTimeZoneResult> 9hQ=();
    [AsyncStateMachineAttribute("ThinkGeo.Core.TimeZoneCloudClient/<GetAllTimeZonesCoreAsync>d__18")]
private Task`1<Collection`1<CloudTimeZoneResult>> 9xQ=();
    private static CloudTimeZoneResult /BQ=(WebResponse response);
    private static Collection`1<string> /RQ=(WebResponse response);
    private static Collection`1<CloudTimeZoneResult> /hQ=(WebResponse response);
    private static string 3BQ=(Nullable`1<int> projectionInSrid, string projectionInProj4String);
}
public class ThinkGeo.Core.TinyGeoFeatureLayer : FeatureLayer {
    public bool HasBoundingBox { get; }
    public string TinyGeoPathFilename { get; public set; }
    public string Password { get; public set; }
    public TinyGeoFeatureLayer(string tinyGeoPathFilename);
    public TinyGeoFeatureLayer(string tinyGeoPathFilename, string password);
    public void add_StreamLoading(EventHandler`1<StreamLoadingEventArgs> value);
    public void remove_StreamLoading(EventHandler`1<StreamLoadingEventArgs> value);
    public virtual bool get_HasBoundingBox();
    public string get_TinyGeoPathFilename();
    public void set_TinyGeoPathFilename(string value);
    public string get_Password();
    public void set_Password(string value);
    public static void CreateTinyGeoFile(string tinyGeoPathFilename, string shapePathFilename, GeographyUnit unitOfData, ReturningColumnsType returningColumnType);
    public static void CreateTinyGeoFile(string tinyGeoPathFilename, string shapePathFilename, GeographyUnit unitOfData, ReturningColumnsType returningColumnType, double precisionInMeter);
    public static void CreateTinyGeoFile(string tinyGeoPathFilename, string shapePathFilename, GeographyUnit unitOfData, ReturningColumnsType returningColumnType, string password);
    public static void CreateTinyGeoFile(string tinyGeoPathFilename, string shapePathFilename, GeographyUnit unitOfData, ReturningColumnsType returningColumnType, string password, double precisionInMeter);
    public static void CreateTinyGeoFile(string tinyGeoPathFilename, string shapePathFilename, GeographyUnit unitOfData, IEnumerable`1<string> columnNames);
    public static void CreateTinyGeoFile(string tinyGeoPathFilename, string shapePathFilename, GeographyUnit unitOfData, IEnumerable`1<string> columnNames, double precisionInMeter);
    public static void CreateTinyGeoFile(string tinyGeoPathFilename, string shapePathFilename, GeographyUnit unitOfData, IEnumerable`1<string> columnNames, string password);
    public static void CreateTinyGeoFile(string tinyGeoPathFilename, string shapePathFilename, GeographyUnit unitOfData, IEnumerable`1<string> columnNames, string password, double precisionInMeter);
    public static void CreateTinyGeoFile(string tinyGeoPathFilename, string shapePathFilename, GeographyUnit unitOfData, IEnumerable`1<string> columnNames, string password, double precisionInMeter, Encoding shapeEncoding);
    public static void CreateTinyGeoFile(string tinyGeoPathFilename, FeatureLayer featureLayer, GeographyUnit unitOfData, IEnumerable`1<string> columnNames, string password, double precisionInMeter, Encoding shapeEncoding, WellKnownType type);
    public static double GetOptimalPrecision(string shapePathFilename, GeographyUnit unitOfData, DistanceUnit returningDistanceUnit, TinyGeoPrecisionMode precisionMode);
    public static double GetOptimalPrecision(FeatureLayer featureLayer, GeographyUnit unitOfData, DistanceUnit returningDistanceUnit, TinyGeoPrecisionMode precisionMode);
    public static void EncryptTinyGeoFile(string unencryptedTinyGeoPathFilename, string encryptedTinyGeoPathFilename, string password);
    public static void DecryptTinyGeoFile(string encryptedTinyGeoPathFilename, string decryptedTinyGeoPathFilename, string password);
    public TinyGeoFileType GetTinyGeoFileType();
}
public class ThinkGeo.Core.TinyGeoFeatureSource : FeatureSource {
    private static double vC4=;
    [ObfuscationAttribute]
private string tinyGeoFilePathName;
    private Cy4= vS4=;
    [ObfuscationAttribute]
private string password;
    [CompilerGeneratedAttribute]
private EventHandler`1<StreamLoadingEventArgs> StreamLoading;
    public string Password { get; public set; }
    public string TinyGeoPathFilename { get; public set; }
    public TinyGeoFeatureSource(string tinyGeoPathFilename);
    public TinyGeoFeatureSource(string tinyGeoPathFilename, string password);
    [CompilerGeneratedAttribute]
public void add_StreamLoading(EventHandler`1<StreamLoadingEventArgs> value);
    [CompilerGeneratedAttribute]
public void remove_StreamLoading(EventHandler`1<StreamLoadingEventArgs> value);
    protected virtual bool CanGetCountQuicklyCore();
    protected virtual bool CanGetBoundingBoxQuicklyCore();
    public string get_Password();
    public void set_Password(string value);
    public string get_TinyGeoPathFilename();
    public void set_TinyGeoPathFilename(string value);
    protected virtual void OnStreamLoading(StreamLoadingEventArgs e);
    protected virtual void OpenCore();
    protected virtual void CloseCore();
    protected virtual RectangleShape GetBoundingBoxCore();
    public TinyGeoFileType GetTinyGeoFileType();
    protected virtual Collection`1<Feature> GetAllFeaturesCore(IEnumerable`1<string> returningColumnNames);
    protected virtual Collection`1<Feature> GetFeaturesInsideBoundingBoxCore(RectangleShape boundingBox, IEnumerable`1<string> returningColumnNames);
    protected virtual Collection`1<Feature> GetAllFeaturesCore(IEnumerable`1<string> returningColumnNames, int startIndex, int takeCount);
    protected virtual Collection`1<Feature> GetFeaturesByIdsCore(IEnumerable`1<string> ids, IEnumerable`1<string> returningColumnNames);
    protected virtual Collection`1<FeatureSourceColumn> GetColumnsCore();
    public static void CreateTinyGeoFile(string tinyGeoPathFilename, string shapePathFilename, GeographyUnit unitOfData, ReturningColumnsType returningColumnType);
    public static void CreateTinyGeoFile(string tinyGeoPathFilename, string shapePathFilename, GeographyUnit unitOfData, ReturningColumnsType returningColumnType, double precisionInMeter);
    public static void CreateTinyGeoFile(string tinyGeoPathFilename, string shapePathFilename, GeographyUnit unitOfData, ReturningColumnsType returningColumnType, string password);
    public static void CreateTinyGeoFile(string tinyGeoPathFilename, string shapePathFilename, GeographyUnit unitOfData, ReturningColumnsType returningColumnType, string password, double precisionInMeter);
    public static void CreateTinyGeoFile(string tinyGeoPathFilename, string shapePathFilename, GeographyUnit unitOfData, IEnumerable`1<string> columnNames);
    public static void CreateTinyGeoFile(string tinyGeoPathFilename, string shapePathFilename, GeographyUnit unitOfData, IEnumerable`1<string> columnNames, double precisionInMeter);
    public static void CreateTinyGeoFile(string tinyGeoPathFilename, string shapePathFilename, GeographyUnit unitOfData, IEnumerable`1<string> columnNames, string password);
    public static void CreateTinyGeoFile(string tinyGeoPathFilename, string shapePathFilename, GeographyUnit unitOfData, IEnumerable`1<string> columnNames, string password, double precisionInMeter);
    public static void CreateTinyGeoFile(string tinyGeoPathFilename, string shapePathFilename, GeographyUnit unitOfData, IEnumerable`1<string> columnNames, string password, double precisionInMeter, Encoding shapeEncoding);
    public static void CreateTinyGeoFile(string tinyGeoPathFilename, FeatureLayer featureLayer, GeographyUnit unitOfData, IEnumerable`1<string> columnNames, string password, double precisionInMeter, Encoding shapeEncoding, WellKnownType type);
    public static double GetOptimalPrecision(FeatureLayer featureLayer, GeographyUnit unitOfData, DistanceUnit returningDistanceUnit, TinyGeoPrecisionMode precisionMode);
    public static double GetOptimalPrecision(string shapePathFilename, GeographyUnit unitOfData, DistanceUnit returningDistanceUnit, TinyGeoPrecisionMode precisionMode);
    public static void EncryptTinyGeoFile(string unencryptedTinyGeoPathFilename, string encryptedTinyGeoPathFilename, string password);
    public static void DecryptTinyGeoFile(string encryptedTinyGeoPathFilename, string decryptedTinyGeoPathFilename, string password);
    private void vi4=(object sender, StreamLoadingEventArgs e);
    private static void vy4=(string tinyGeoPathFilename, FeatureLayer featureLayer, IEnumerable`1<string> columnNames, string password, 4is= accuracy, Collection`1<string> ids, double extentWidthLimitation, Encoding shapeEncoding);
    private static double 8SY=(double maxFeatureWidth, GeographyUnit unit);
    private static double wC4=(4is= accuracy);
    private static double wS4=(4is= accuracy);
    private static double wi4=(4is= accuracy);
    private static double wy4=(RectangleShape rect);
    private static 4is= qy0=(Double& extentWidthLimitation, double minExtent, double precision, GeographyUnit unit);
    private static 4is= qy0=(Double& extentWidthLimitation, double minExtent, double precision, double maxExtent);
    private static int xC4=(4is= accuracy);
    private static 4is= xS4=(int number);
    private static 4is= xi4=(double distance);
}
public enum ThinkGeo.Core.TinyGeoFileType : Enum {
    public int value__;
    public static TinyGeoFileType Point;
    public static TinyGeoFileType Polyline;
    public static TinyGeoFileType Polygon;
}
public enum ThinkGeo.Core.TinyGeoPrecisionMode : Enum {
    public int value__;
    public static TinyGeoPrecisionMode AllowSplitting;
    public static TinyGeoPrecisionMode PreventSplitting;
}
public class ThinkGeo.Core.TobinBasFeatureLayer : FeatureLayer {
    [ObfuscationAttribute]
private BasAnnotationTextStylingType annotationTextStylingType;
    [ObfuscationAttribute]
private int progressiveDrawingRecordsCount;
    [ObfuscationAttribute]
private string tobinBasFilePathName;
    [ObfuscationAttribute]
private int minAnnotationFontSize;
    public string TobinBasFilePathName { get; public set; }
    public int ProgressiveDrawingRecordsCount { get; public set; }
    public int MinAnnotationFontSize { get; public set; }
    public BasAnnotationTextStylingType AnnotationTextStylingType { get; public set; }
    public bool HasBoundingBox { get; }
    public TobinBasFeatureLayer(string tobinBasFileName);
    public string get_TobinBasFilePathName();
    public void set_TobinBasFilePathName(string value);
    public int get_ProgressiveDrawingRecordsCount();
    public void set_ProgressiveDrawingRecordsCount(int value);
    public int get_MinAnnotationFontSize();
    public void set_MinAnnotationFontSize(int value);
    public BasAnnotationTextStylingType get_AnnotationTextStylingType();
    public void set_AnnotationTextStylingType(BasAnnotationTextStylingType value);
    protected virtual void OpenCore();
    protected virtual void DrawCore(GeoCanvas canvas, Collection`1<SimpleCandidate> labelsInAllLayers);
    public virtual bool get_HasBoundingBox();
    public static void BuildIndexFile(string pathFilename);
}
public class ThinkGeo.Core.TobinBasFeatureSource : FeatureSource {
    [ObfuscationAttribute]
private string tobinBasFilePathName;
    [ObfuscationAttribute]
private string indexPathFilename;
    private RtreeSpatialIndex XiE=;
    private cy8= dC8=;
    private Encoding rB4=;
    [ObfuscationAttribute]
private bool requireIndex;
    private Collection`1<Feature> hS8=;
    private SortedList`2<string, ai8=> hi8=;
    private int hy8=;
    [CompilerGeneratedAttribute]
private static EventHandler`1<BuildingIndexBasFileFeatureSourceEventArgs> BuildingIndex;
    public Collection`1<Feature> AnnotationFeatures { get; public set; }
    public Encoding Encoding { get; public set; }
    public bool RequireIndex { get; public set; }
    public string TobinBasFileName { get; public set; }
    public TobinBasFeatureSource(string tobinBasFilePathName);
    public Collection`1<Feature> get_AnnotationFeatures();
    public void set_AnnotationFeatures(Collection`1<Feature> value);
    public Encoding get_Encoding();
    public void set_Encoding(Encoding value);
    public bool get_RequireIndex();
    public void set_RequireIndex(bool value);
    public string get_TobinBasFileName();
    public void set_TobinBasFileName(string value);
    protected virtual void OpenCore();
    protected virtual void CloseCore();
    protected virtual Collection`1<FeatureSourceColumn> GetColumnsCore();
    protected virtual Collection`1<Feature> GetAllFeaturesCore(IEnumerable`1<string> returningColumnNames);
    protected virtual Collection`1<Feature> GetFeaturesInsideBoundingBoxCore(RectangleShape boundingBox, IEnumerable`1<string> returningColumnNames);
    public static void BuildIndexFile(string shapePathFilename);
    public static void BuildIndexFile(string shapePathFilename, string indexPathFilename, ProjectionConverter projectionConverter, string columnName, string regularExpression, BuildIndexMode buildIndexMode);
    public static void BuildIndexFile(string basPathFilename, string indexPathFilename, ProjectionConverter projectionConverter, string columnName, string regularExpression, BuildIndexMode buildIndexMode, Encoding encoding);
    [CompilerGeneratedAttribute]
public static void add_BuildingIndex(EventHandler`1<BuildingIndexBasFileFeatureSourceEventArgs> value);
    [CompilerGeneratedAttribute]
public static void remove_BuildingIndex(EventHandler`1<BuildingIndexBasFileFeatureSourceEventArgs> value);
    private void iC8=(ai8= entity);
    protected virtual Collection`1<Feature> GetFeaturesByIdsCore(IEnumerable`1<string> ids, IEnumerable`1<string> returningColumnNames);
    protected static void OnBuildingIndex(BuildingIndexBasFileFeatureSourceEventArgs e);
    private void 4CM=(FileAccess rTreeFileAccess);
    private static Dictionary`2<string, string> iS8=(1C4= annotation);
    private string ii8=(string p, string columnName);
    private static void mCM=(string pathFilename);
    private static void 6iM=(string sourcePathFilename, string targetPathFilename);
    private static void 3iM=(ai8= featureEntity, RtreeSpatialIndex openedRtree, ProjectionConverter openedProjection);
}
public class ThinkGeo.Core.TobinBasValidatorHelper : object {
    public static void CheckRecordLength(string Record);
    public static void CheckTobinBasFileName(string path);
}
public class ThinkGeo.Core.TopologyValidationResult : ValueType {
    [CompilerGeneratedAttribute]
private bool Wh0=;
    [CompilerGeneratedAttribute]
private Collection`1<Feature> Wx0=;
    public bool IsValid { get; }
    public Collection`1<Feature> InvalidFeatures { get; }
    public TopologyValidationResult(bool isValid, IEnumerable`1<Feature> invalidFeatures);
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public bool get_IsValid();
    [CompilerGeneratedAttribute]
[IsReadOnlyAttribute]
public Collection`1<Feature> get_InvalidFeatures();
}
public static class ThinkGeo.Core.TopologyValidator : object {
    private static string XB0=;
    public static TopologyValidationResult PolygonsMustNotOverlap(IEnumerable`1<Feature> polygonFeatures);
    public static TopologyValidationResult PolygonsMustNotHaveGaps(IEnumerable`1<Feature> polygonFeatures);
    public static TopologyValidationResult PolygonsMustContainPoint(IEnumerable`1<Feature> polygonFeatures, IEnumerable`1<Feature> pointFeatures);
    public static TopologyValidationResult PolygonsMustBeWithinPolygons(IEnumerable`1<Feature> featuresToValidateAgainst, IEnumerable`1<Feature> featuresToValidate);
    public static TopologyValidationResult PolygonBoundariesMustOverlapLines(IEnumerable`1<Feature> polygonFeatures, IEnumerable`1<Feature> lineFeatures);
    public static TopologyValidationResult PolygonsMustOverlapPolygons(IEnumerable`1<Feature> featuresToValidateAgainst, IEnumerable`1<Feature> featuresToValidate);
    public static TopologyValidationResult PolygonsMustNotOverlapPolygons(IEnumerable`1<Feature> featuresToValidateAgainst, IEnumerable`1<Feature> featuresToValidate);
    public static TopologyValidationResult PolygonsMustOverlapEachOther(IEnumerable`1<Feature> firstPolygonGroup, IEnumerable`1<Feature> secondPolygonGroup);
    public static TopologyValidationResult PolygonBoundariesMustOverlapPolygonBoundaries(IEnumerable`1<Feature> featuresToValidateAgainst, IEnumerable`1<Feature> featuresToValidate);
    public static TopologyValidationResult LinesMustFormClosedPolygon(IEnumerable`1<Feature> lineFeatures);
    public static TopologyValidationResult LinesMustNotHavePseudonodes(IEnumerable`1<Feature> lineFeatures);
    public static TopologyValidationResult LinesMustNotOverlap(IEnumerable`1<Feature> lineFeatures);
    public static TopologyValidationResult LinesMustNotSelfOverlap(IEnumerable`1<Feature> lineFeatures);
    public static TopologyValidationResult LinesMustNotIntersect(IEnumerable`1<Feature> lineFeatures);
    public static TopologyValidationResult LinesMustNotSelfIntersect(IEnumerable`1<Feature> lineFeatures);
    public static TopologyValidationResult LinesMustNotSelfIntersectOrTouch(IEnumerable`1<Feature> lineFeatures);
    public static TopologyValidationResult LinesMustBeSinglePart(IEnumerable`1<Feature> lineFeatures);
    public static TopologyValidationResult LinesMustNotOverlapLines(IEnumerable`1<Feature> featuresToValidateAgainst, IEnumerable`1<Feature> featuresToValidate);
    public static TopologyValidationResult LinesMustBeCoveredByLines(IEnumerable`1<Feature> featuresToValidateAgainst, IEnumerable`1<Feature> featuresToValidate);
    public static TopologyValidationResult LineEndPointsMustTouchPoints(IEnumerable`1<Feature> lineFeatures, IEnumerable`1<Feature> pointFeatures);
    public static TopologyValidationResult LinesMustOverlapPolygonBoundaries(IEnumerable`1<Feature> lineFeatures, IEnumerable`1<Feature> polygonFeatures);
    public static TopologyValidationResult PointsMustBeWithinPolygons(IEnumerable`1<Feature> pointFeatures, IEnumerable`1<Feature> polygonFeatures);
    public static TopologyValidationResult PointsMustTouchPolygonBoundaries(IEnumerable`1<Feature> pointFeatures, IEnumerable`1<Feature> polygonFeatures);
    public static TopologyValidationResult PointsMustTouchLineEndpoints(IEnumerable`1<Feature> pointFeatures, IEnumerable`1<Feature> lineFeatures);
    public static TopologyValidationResult PointsMustTouchLines(IEnumerable`1<Feature> pointFeatures, IEnumerable`1<Feature> lineFeatures);
    private static Collection`1<Feature> XR0=(IEnumerable`1<Feature> sourceFeatures, WellKnownType filterType1, WellKnownType filterType2);
    private static TopologyValidationResult Xh0=(IEnumerable`1<Feature> coveringFeatures, IEnumerable`1<Feature> coveredFeatures);
    private static TopologyValidationResult Xx0=(IEnumerable`1<Feature> coveringFeatures, IEnumerable`1<Feature> coveredFeatures);
    private static Collection`1<Feature> YB0=(IEnumerable`1<Feature> pointFeatures);
    private static Collection`1<Feature> YR0=(IEnumerable`1<Feature> polygonShapes);
    private static Collection`1<Feature> Yh0=(Feature item);
    private static int Yx0=(Feature lineFeature, Feature pointFeature);
    private static Collection`1<Feature> ZB0=(IEnumerable`1<Feature> lineFeatures);
    private static void ZR0=(Collection`1<Feature> results, Feature lineGeom, Feature intersectFeature);
    private static Collection`1<string> Zh0=(Feature feature1, Feature feature2);
    private static Feature Zx0=(IEnumerable`1<Feature> features);
    internal static STRtree`1<BaseShape> aB0=(IEnumerable`1<BaseShape> baseShapes);
    private static STRtree`1<Feature> aB0=(IEnumerable`1<Feature> features);
    private static PointShape[] aR0=(Feature lineFeature);
    private static bool ah0=(double start, double middle, double end);
    internal static bool ax0=(Vertex startVertex, Vertex endVertex, PointShape point);
}
public class ThinkGeo.Core.TouchMapViewEventArgs : EventArgs {
    [CompilerGeneratedAttribute]
private ScreenPointD jBQ=;
    [CompilerGeneratedAttribute]
private PointShape jRQ=;
    public ScreenPointD PointInScreenCoordinate { get; public set; }
    public PointShape PointInWorldCoordinate { get; public set; }
    public TouchMapViewEventArgs(ScreenPointD pointInScreenCoordinate, PointShape pointInWorldCoordinate);
    [CompilerGeneratedAttribute]
public ScreenPointD get_PointInScreenCoordinate();
    [CompilerGeneratedAttribute]
public void set_PointInScreenCoordinate(ScreenPointD value);
    [CompilerGeneratedAttribute]
public PointShape get_PointInWorldCoordinate();
    [CompilerGeneratedAttribute]
public void set_PointInWorldCoordinate(PointShape value);
}
public class ThinkGeo.Core.TouchMovedTrackInteractiveOverlayEventArgs : EventArgs {
    private Vertex kRQ=;
    private Feature khQ=;
    public Vertex MovedVertex { get; public set; }
    public Feature AffectedFeature { get; public set; }
    public TouchMovedTrackInteractiveOverlayEventArgs(Vertex movedVertex, Feature affectedFeature);
    public Vertex get_MovedVertex();
    public void set_MovedVertex(Vertex value);
    public Feature get_AffectedFeature();
    public void set_AffectedFeature(Feature value);
}
public class ThinkGeo.Core.TouchMovingTrackInteractiveOverlayEventArgs : EventArgs {
    [CompilerGeneratedAttribute]
private Vertex ihQ=;
    [CompilerGeneratedAttribute]
private bool ixQ=;
    public Vertex TargetVertex { get; }
    public bool Cancel { get; public set; }
    public TouchMovingTrackInteractiveOverlayEventArgs(Vertex targetVertex);
    [CompilerGeneratedAttribute]
public Vertex get_TargetVertex();
    [CompilerGeneratedAttribute]
public bool get_Cancel();
    [CompilerGeneratedAttribute]
public void set_Cancel(bool value);
}
public class ThinkGeo.Core.TrackEndedTrackInteractiveOverlayEventArgs : EventArgs {
    [ObfuscationAttribute]
private BaseShape trackShape;
    public BaseShape TrackShape { get; public set; }
    public TrackEndedTrackInteractiveOverlayEventArgs(BaseShape trackShape);
    public BaseShape get_TrackShape();
    public void set_TrackShape(BaseShape value);
}
public class ThinkGeo.Core.TrackEndingTrackInteractiveOverlayEventArgs : EventArgs {
    [ObfuscationAttribute]
private BaseShape trackShape;
    [ObfuscationAttribute]
private bool cancel;
    public BaseShape TrackShape { get; public set; }
    public bool Cancel { get; public set; }
    public TrackEndingTrackInteractiveOverlayEventArgs(BaseShape shape, bool cancel);
    public BaseShape get_TrackShape();
    public void set_TrackShape(BaseShape value);
    public bool get_Cancel();
    public void set_Cancel(bool value);
}
public enum ThinkGeo.Core.TrackMode : Enum {
    public int value__;
    public static TrackMode None;
    public static TrackMode Point;
    public static TrackMode Line;
    public static TrackMode Polygon;
    public static TrackMode Rectangle;
    public static TrackMode Square;
    public static TrackMode Circle;
    public static TrackMode Ellipse;
    public static TrackMode StraightLine;
    public static TrackMode Freehand;
    public static TrackMode Custom;
    public static TrackMode Multipoint;
}
public class ThinkGeo.Core.TrackStartedTrackInteractiveOverlayEventArgs : EventArgs {
    [ObfuscationAttribute]
private Vertex startedVertex;
    public Vertex StartedVertex { get; public set; }
    public TrackStartedTrackInteractiveOverlayEventArgs(Vertex startedVertex);
    public Vertex get_StartedVertex();
    public void set_StartedVertex(Vertex value);
}
public class ThinkGeo.Core.TrackStartingTrackInteractiveOverlayEventArgs : EventArgs {
    [ObfuscationAttribute]
private bool cancel;
    [ObfuscationAttribute]
private Vertex startingVertex;
    public bool Cancel { get; public set; }
    public Vertex StartingVertex { get; public set; }
    public TrackStartingTrackInteractiveOverlayEventArgs(Vertex startingVertex, bool cancel);
    public bool get_Cancel();
    public void set_Cancel(bool value);
    public Vertex get_StartingVertex();
    public void set_StartingVertex(Vertex value);
}
public class ThinkGeo.Core.TransactionBuffer : object {
    [ObfuscationAttribute]
private Dictionary`2<string, Feature> addBuffer;
    [ObfuscationAttribute]
private Collection`1<string> deleteBuffer;
    [ObfuscationAttribute]
private Dictionary`2<string, Feature> editBuffer;
    [ObfuscationAttribute]
private Collection`1<FeatureSourceColumn> addColumnBuffer;
    [ObfuscationAttribute]
private Collection`1<string> deleteColumnBuffer;
    [ObfuscationAttribute]
private Dictionary`2<string, FeatureSourceColumn> updateColumnBuffer;
    public Dictionary`2<string, Feature> AddBuffer { get; }
    public Collection`1<string> DeleteBuffer { get; }
    public Dictionary`2<string, Feature> EditBuffer { get; }
    public Collection`1<FeatureSourceColumn> AddColumnBuffer { get; }
    public Collection`1<string> DeleteColumnBuffer { get; }
    public Dictionary`2<string, FeatureSourceColumn> UpdateColumnBuffer { get; }
    public TransactionBuffer(Dictionary`2<string, Feature> addBuffer, Collection`1<string> deleteBuffer, Dictionary`2<string, Feature> editBuffer);
    public void Clear();
    public Dictionary`2<string, Feature> get_AddBuffer();
    public Collection`1<string> get_DeleteBuffer();
    public Dictionary`2<string, Feature> get_EditBuffer();
    public void AddFeature(Feature feature);
    public void AddFeature(BaseShape baseShape);
    public void AddFeature(BaseShape baseShape, Dictionary`2<string, string> columnValues);
    public void DeleteFeature(string featureId);
    public void EditFeature(Feature feature);
    public void EditFeature(BaseShape baseShape);
    public void EditFeature(BaseShape baseShape, Dictionary`2<string, string> columnValues);
    public Collection`1<FeatureSourceColumn> get_AddColumnBuffer();
    public void AddColumn(FeatureSourceColumn featureSourceColumn);
    public Collection`1<string> get_DeleteColumnBuffer();
    public void DeleteColumn(string columnName);
    public Dictionary`2<string, FeatureSourceColumn> get_UpdateColumnBuffer();
    public void UpdateColumn(string columnName, FeatureSourceColumn newFeatureSourceColumn);
}
public class ThinkGeo.Core.TransactionResult : object {
    [ObfuscationAttribute]
private int totalSuccessCount;
    [ObfuscationAttribute]
private int totalFailureCount;
    [ObfuscationAttribute]
private TransactionResultStatus transactionResultStatus;
    [ObfuscationAttribute]
private Dictionary`2<string, string> failureReasons;
    public int TotalSuccessCount { get; public set; }
    public int TotalFailureCount { get; public set; }
    public TransactionResultStatus TransactionResultStatus { get; public set; }
    public Dictionary`2<string, string> FailureReasons { get; }
    public TransactionResult(int totalSuccessCount, int totalFailureCount, Dictionary`2<string, string> failureReasons, TransactionResultStatus transactionResultStatus);
    public int get_TotalSuccessCount();
    public void set_TotalSuccessCount(int value);
    public int get_TotalFailureCount();
    public void set_TotalFailureCount(int value);
    public TransactionResultStatus get_TransactionResultStatus();
    public void set_TransactionResultStatus(TransactionResultStatus value);
    public Dictionary`2<string, string> get_FailureReasons();
}
public enum ThinkGeo.Core.TransactionResultStatus : Enum {
    public int value__;
    public static TransactionResultStatus Success;
    public static TransactionResultStatus Failure;
    public static TransactionResultStatus Cancel;
}
public enum ThinkGeo.Core.TransitionEffect : Enum {
    public int value__;
    public static TransitionEffect None;
    public static TransitionEffect Stretch;
}
public enum ThinkGeo.Core.UnitSystem : Enum {
    public int value__;
    public static UnitSystem Imperial;
    public static UnitSystem Metric;
    public static UnitSystem NauticalMile;
}
public static class ThinkGeo.Core.UnmanagedAssembliesHelper : object {
    public static string GetAssemblyPathFilename(string directoryName, string assemblyName);
    private static string bB0=();
    private static Collection`1<string> bR0=();
}
public class ThinkGeo.Core.UsgsDemFeatureLayer : FeatureLayer {
    public string PathFilename { get; public set; }
    public bool HasBoundingBox { get; }
    public string DataValueColumnName { get; }
    public string OriginCode { get; }
    public UsgsDemQualityLevel QualityLevel { get; }
    public int ColumnCount { get; }
    public int RowCount { get; }
    public float ResolutionX { get; }
    public float ResolutionY { get; }
    public float ResolutionZ { get; }
    public double MinElevation { get; }
    public double MaxElevation { get; }
    public DistanceUnit ElevationUnit { get; }
    public UsgsDemFeatureLayer(string pathFilename);
    public string get_PathFilename();
    public void set_PathFilename(string value);
    public virtual bool get_HasBoundingBox();
    public string get_DataValueColumnName();
    public string get_OriginCode();
    public UsgsDemQualityLevel get_QualityLevel();
    public int get_ColumnCount();
    public int get_RowCount();
    public float get_ResolutionX();
    public float get_ResolutionY();
    public float get_ResolutionZ();
    public double get_MinElevation();
    public double get_MaxElevation();
    public DistanceUnit get_ElevationUnit();
}
public class ThinkGeo.Core.UsgsDemFeatureSource : FeatureSource {
    private static string 1SE=;
    private Int16[0...,0...] iy8=;
    [ObfuscationAttribute]
private string pathFilename;
    private string jC8=;
    private UsgsDemQualityLevel jS8=;
    private int ji8=;
    private int jy8=;
    private double kC8=;
    private double kS8=;
    private RectangleShape ki8=;
    private float ky8=;
    private float lC8=;
    private float lS8=;
    private DistanceUnit li8=;
    public string PathFilename { get; public set; }
    public string OriginCode { get; }
    public UsgsDemQualityLevel QualityLevel { get; }
    public int ColumnCount { get; }
    public int RowCount { get; }
    public float ResolutionX { get; }
    public float ResolutionY { get; }
    public float ResolutionZ { get; }
    public double MinElevation { get; }
    public double MaxElevation { get; }
    public string DataValueColumnName { get; }
    public DistanceUnit ElevationUnit { get; }
    public UsgsDemFeatureSource(string pathFilename);
    private static UsgsDemFeatureSource();
    public string get_PathFilename();
    public void set_PathFilename(string value);
    public string get_OriginCode();
    public UsgsDemQualityLevel get_QualityLevel();
    public int get_ColumnCount();
    public int get_RowCount();
    public float get_ResolutionX();
    public float get_ResolutionY();
    public float get_ResolutionZ();
    public double get_MinElevation();
    public double get_MaxElevation();
    public string get_DataValueColumnName();
    public DistanceUnit get_ElevationUnit();
    protected virtual void OpenCore();
    protected virtual Collection`1<Feature> GetAllFeaturesCore(IEnumerable`1<string> returningColumnNames);
    protected virtual Collection`1<Feature> GetFeaturesInsideBoundingBoxCore(RectangleShape boundingBox, IEnumerable`1<string> returningColumnNames);
    protected virtual Collection`1<Feature> GetFeaturesForDrawingCore(RectangleShape boundingBox, double screenWidth, double screenHeight, IEnumerable`1<string> returningColumnNames);
    protected virtual RectangleShape GetBoundingBoxCore();
    private Byte[] 2CE=(double x1, double y1, double x2, double y2);
    private string ly8=(Char[] buffer, int start, int count);
    private int mC8=(Char[] buffer, int start, int count);
    private short mS8=(string value);
    private int mi8=(string value);
    private double my8=(Char[] buffer, int start, int count);
    private float nC8=(Char[] buffer, int start, int count);
}
public enum ThinkGeo.Core.UsgsDemQualityLevel : Enum {
    public int value__;
    public static UsgsDemQualityLevel Default;
    public static UsgsDemQualityLevel Level1;
    public static UsgsDemQualityLevel Level2;
    public static UsgsDemQualityLevel Level3;
    public static UsgsDemQualityLevel Level4;
}
public static class ThinkGeo.Core.ValidatorHelper : object {
    private static bool bh0=;
    public static void CheckImageIsNotNullInPointStyle(GeoImage image);
    public static void CheckDrawingLineCapIsValid(DrawingLineCap drawingLineCap, string parameterName);
    public static void CheckGeoDashCapIsValid(GeoDashCap geoDashCap, string parameterName);
    public static void CheckDrawingLineJoinIsValid(DrawingLineJoin drawingLineJoin, string parameterName);
    public static void CheckLineDashStyleIsValid(LineDashStyle lineDashStyle, string parameterName);
    public static void CheckDrawingLevelIsValid(DrawingLevel drawingLevel, string parameterName);
    public static void CheckGeoImageIsValid(GeoImage image, string parameterName, GeoCanvas canvas);
    public static void CheckIconImageAndIconFilePathAreInvalid(string iconFilePath, GeoImage iconImage);
    public static void CheckRandomColorTypeIsValid(RandomColorType colorType, string parameterName);
    public static void CheckGroupLayerIsNotEmpty(GeoCollection`1<Layer> layers);
    public static void CheckQueryTypeIsValid(QueryType queryType, string parameterName);
    public static void CheckFeatureSourceCollectionIsNotEmpty(Collection`1<FeatureSource> featureSources);
    public static void CheckBuildIndexModeIsValid(BuildIndexMode buildIndexMode, string parameterName);
    public static void CheckOverwriteModeIsValid(OverwriteMode overwriteMode, string parameterName);
    public static void CheckRebuildRecordIdModeIsValid(BuildRecordIdMode rebuildRecordIdMode, string parameterName);
    public static void CheckDbfColumnDecimalLengthIsValid(DbfColumnType columnType, int decimalLength);
    public static void CheckPanDirectionIsValid(PanDirection panDirection, string parameterName);
    public static void CheckColumnNameIsInFeature(string columnName, IEnumerable`1<Feature> features);
    public static void CheckShapeIsValidForOperation(BaseShape shape);
    public static void CheckShapeIsValid(BaseShape shape, string parameterName);
    public static void CheckFeatureIsValid(Feature feature, string parameterName);
    public static void CheckShapeValidationModeIsValid(ShapeValidationMode shapeValidationMode, string parameterName);
    public static void CheckExtentIsValid(RectangleShape extent, string parameterName);
    public static void CheckStartingPointIsValid(StartingPoint startingPoint, string parameterName);
    public static void CheckWkbByteOrderIsValid(WkbByteOrder wkbByteOrder, string parameterName);
    public static void CheckRingOrderIsValid(RingOrder ringOrder, string parameterName);
    public static void CheckFeatureIsValid(Feature feature);
    public static void CheckShapeIsAreaBaseShape(BaseShape shape);
    public static void CheckShapeIsPointShape(BaseShape shape);
    public static void CheckShapeIsMultipointShape(BaseShape shape);
    public static void CheckShapeIsLineBaseShape(BaseShape shape);
    public static void CheckSimplificationTypeIsValid(SimplificationType simplificationType, string parameterName);
    public static void CheckReturningColumnsTypeIsValid(ReturningColumnsType returningColumnsType, string parameterName);
    public static void CheckAreaUnitIsValid(AreaUnit areaUnit, string parameterName);
    public static void CheckWktIsValid(string wkt, string parameterName);
    public static void CheckBufferCapTypeIsValid(BufferCapType bufferCapType, string parameterName);
    public static void CheckDistanceUnitIsValid(DistanceUnit distanceUnit, string parameterName);
    public static void CheckPointLineIsIntersected(PointShape pointShape, string pointShapeName, LineShape lineShape, string lineShapeName, double tolerance);
    public static void CheckPointSymbolTypeIsValid(PointSymbolType symbolType, string parameterName);
    public static void CheckPointTypeIsValid(PointType pointType, string parameterName);
    public static void CheckCanParseStringToDouble(string value, string parameterName);
    public static void CheckStringIsNotNullNorWhiteSpace(string value, string parameterName);
    public static void CheckStringIsValidDecimalDegree(string value, string parameterName);
    public static void CheckObjectsAreNotAllNull(object firstObject, object secondObject, string firstParameterName, string secondParameterName);
    public static void CheckTypeIsSupport(object instance, string typeName);
    public static void CheckCanvasWidthIsLargerThanZero(double canvasWidth, string parameterName);
    public static void CheckCanvasHeightIsLargerThanZero(double canvasHeight, string parameterName);
    public static void CheckGeographyUnitIsMeter(GeographyUnit geographyUnit, string parameterName);
    public static void CheckObjectIsNotNull(object parameterObject, string parameterName);
    public static void CheckObjectIsNotNull(object parameterObject, string parameterName, string exceptionMessage);
    public static void CheckInputValueIsLargerThan(double inputValue, string parameterName, double minValue, RangeCheckingInclusion includeMinValue);
    public static void CheckDateTimeIsInRange(DateTime inputDate, string parameterName, DateTime minDate, RangeCheckingInclusion includeMinValue, DateTime maxDate, RangeCheckingInclusion includeMaxValue);
    public static void CheckAreIntegerStrings(IEnumerable`1<string> ids, string parameterName);
    public static void CheckGeoCanvasIsInDrawing(bool isDrawing);
    public static void CheckScaleIsLargerThanZero(double imageScale, string parameterName);
    public static void CheckInputValueIsLargerThanZero(double value, string parameterName);
    public static void CheckObjectIsTargetType(object objectToTest, Type targetType, string operationName);
    public static void CheckLatitudeIsInRange(double latitude, string parameterName);
    public static void CheckLongitudeIsInRange(double longitude, string parameterName);
    public static void CheckInputValueIsInRange(double inputValue, string parameterName, double minValue, RangeCheckingInclusion includeMinValue, double maxValue, RangeCheckingInclusion includeMaxValue);
    public static void CheckInputValueIsInRange(double inputValue, string parameterName, double minValue, RangeCheckingInclusion includeMinValue, double maxValue, RangeCheckingInclusion includeMaxValue, string exceptionMessage);
    public static void CheckInputValueIsInRange(double inputValue, string parameterName, double minValue, double maxValue);
    public static void CheckInputValueIsLessThan(double inputValue, string parameterName, double maxValue, RangeCheckingInclusion includeMaxValue);
    public static void CheckInputValueIsValidDecimalDegree(double value, string parameterName);
    public static void CheckInputValueIsNotNaNNorInfinity(double value, string parameterName);
    public static void CheckFeatureSourceIsOpen(bool isOpen);
    public static void CheckRtreeSpatialIndexIsOpen(bool isOpen);
    public static void CheckRasterSourceIsOpen(bool isOpen);
    public static void CheckIsFastMode(bool fastMode);
    public static void CheckStringIsNotNullNorEmpty(string value, string parameterName);
    public static void CheckWkbIsValid(Byte[] wkb, string parameterName);
    public static void CheckHtmlColorIsValid(string htmlColor, string parameterName);
    public static void CheckFeatureSourceIsEditable(bool isEditable);
    public static void CheckCanModifyColumnStructure(bool canModifyColumnStructure);
    public static void CheckSpatialIndexIsDeletable(bool isDeletable);
    public static void CheckFeatureSourceIsInTransaction(bool isInTransaction);
    public static void CheckFeatureSourceIsNotInTransaction(bool isInTransaction);
    public static void CheckImageFormatSupport(string imageFormat);
    public static void CheckFileIsExist(string pathFilename);
    public static void CheckFileIsNotExist(string pathFilename);
    public static void CheckConnectionStringIsNotNull(string connectionString);
    public static void CheckLayerIsOpened(bool isOpen);
    public static void CheckLayerIsNotOpenedNorDrawing(bool isOpenOrDrawing);
    public static void CheckGeographyUnitIsValid(GeographyUnit geographyUnit, string parameterName);
    public static void CheckProjectionConverterIsOpen(bool isOpen);
    public static void CheckImageFormatIsValid(string imageFormat, Collection`1<string> outputFormats, string exceptionMessage);
    public static void CheckItemInCollection(string item, Collection`1<string> items, string exceptionMessage);
    public static void CheckItemsInCollection(Collection`1<string> items, Collection`1<string> itemCollection, string exceptionMessage);
    public static void CheckIEnumerableIsNotNullNorEmpty(IEnumerable values, string parameterName, string exceptionMessage);
    public static void CheckLayerHasBoundingBox(bool hasBoundingBox);
    public static void CheckFeatureColumnValueContainsColon(string value, string parameterName);
    public static void CheckFeatureSourceCanExecuteSqlQuery(bool canExecuteSqlQuery);
    public static void CheckNumberIsByte(int number, string paramterName);
    public static void CheckUriIsValid(Uri uri);
    public static void CheckStreamIsWritable(Stream stream, string parameterName);
    public static void CheckStringIsNotNullNorEmptyForOperation(string value, string exceptionMessage);
    public static void CheckStatus();
    public static void CheckLongIsNotGreaterThanUInt32MaxValue(long value);
    public static void CheckScaleIsValid(double scale, string parameterName);
    public static void CheckZoomLevelSetIsValid(ZoomLevelSet zoomLevelSet, string parameterName);
    internal static void bx0=(FileAccess readWriteMode, string parameterName);
}
public class ThinkGeo.Core.ValidFeatureFilterCondition : FilterCondition {
    [ObfuscationAttribute]
private FeatureValidationType validationType;
    public FeatureValidationType ValidationType { get; public set; }
    public ValidFeatureFilterCondition(FeatureValidationType validationType);
    public FeatureValidationType get_ValidationType();
    public void set_ValidationType(FeatureValidationType value);
    internal virtual bool 3yI=(Feature feature);
}
public enum ThinkGeo.Core.ValueDrawingOrder : Enum {
    public int value__;
    public static ValueDrawingOrder Default;
    public static ValueDrawingOrder OrderByFeatures;
    public static ValueDrawingOrder OrderByValueItems;
}
public class ThinkGeo.Core.ValueItem : object {
    [ObfuscationAttribute]
private string value;
    [ObfuscationAttribute]
private PointStyle defaultPointStyle;
    [ObfuscationAttribute]
private LineStyle defaultLineStyle;
    [ObfuscationAttribute]
private AreaStyle defaultAreaStyle;
    [ObfuscationAttribute]
private TextStyle defaultTextStyle;
    [ObfuscationAttribute]
private Collection`1<Style> customStyles;
    public string Value { get; public set; }
    public AreaStyle DefaultAreaStyle { get; public set; }
    public LineStyle DefaultLineStyle { get; public set; }
    public PointStyle DefaultPointStyle { get; public set; }
    public TextStyle DefaultTextStyle { get; public set; }
    public Collection`1<Style> CustomStyles { get; }
    public ValueItem(string value, AreaStyle areaStyle);
    public ValueItem(string value, LineStyle lineStyle);
    public ValueItem(string value, PointStyle pointStyle);
    public ValueItem(string value, TextStyle textStyle);
    public ValueItem(string value, Collection`1<Style> customStyles);
    private ValueItem(string value, AreaStyle areaStyle, LineStyle lineStyle, PointStyle pointStyle, TextStyle textStyle, Collection`1<Style> styles);
    public string get_Value();
    public void set_Value(string value);
    public AreaStyle get_DefaultAreaStyle();
    public void set_DefaultAreaStyle(AreaStyle value);
    public LineStyle get_DefaultLineStyle();
    public void set_DefaultLineStyle(LineStyle value);
    public PointStyle get_DefaultPointStyle();
    public void set_DefaultPointStyle(PointStyle value);
    public TextStyle get_DefaultTextStyle();
    public void set_DefaultTextStyle(TextStyle value);
    public Collection`1<Style> get_CustomStyles();
}
public class ThinkGeo.Core.ValueStyle : Style {
    [ObfuscationAttribute]
private string columnName;
    [ObfuscationAttribute]
private Collection`1<ValueItem> valueItems;
    [ObfuscationAttribute]
private ValueDrawingOrder drawingOrder;
    public string ColumnName { get; public set; }
    public ValueDrawingOrder DrawingOrder { get; public set; }
    public Collection`1<ValueItem> ValueItems { get; }
    public ValueStyle(string columnName, Collection`1<ValueItem> valueItems);
    public string get_ColumnName();
    public void set_ColumnName(string value);
    public ValueDrawingOrder get_DrawingOrder();
    public void set_DrawingOrder(ValueDrawingOrder value);
    public Collection`1<ValueItem> get_ValueItems();
    protected virtual void DrawCore(IEnumerable`1<Feature> features, GeoCanvas canvas, Collection`1<SimpleCandidate> labelsInThisLayer, Collection`1<SimpleCandidate> labelsInAllLayers);
    protected virtual Collection`1<string> GetRequiredColumnNamesCore();
    protected virtual void DrawSampleCore(GeoCanvas canvas, DrawingRectangleF drawingExtent);
    [IteratorStateMachineAttribute("ThinkGeo.Core.ValueStyle/<GetSampleStyles>d__16")]
private IEnumerable`1<Style> QTE=();
    private static void RDE=(Collection`1<string> requiredFieldNames, Collection`1<string> fieldNames);
}
public class ThinkGeo.Core.VectorTile : Tile {
    [ObfuscationAttribute]
private Byte[] content;
    public Byte[] Content { get; public set; }
    public VectorTile(Byte[] content, int zoom, long column, long row);
    public Byte[] get_Content();
    public void set_Content(Byte[] value);
    private static RectangleShape kx0=(int zoom, long column, long row);
    internal Collection`1<Feature> lB0=();
    internal Collection`1<Feature> lB0=(List`1<string> pbfLayerNames);
    public Collection`1<PbfLayer> GetPbfLayers();
}
[DebuggerNonUserCodeAttribute]
[GeneratedCodeAttribute("System.Resources.Tools.StronglyTypedResourceBuilder", "4.0.0.0")]
[ObfuscationAttribute]
[CompilerGeneratedAttribute]
internal class ThinkGeo.Core.VectorTileExceptionDescription : object {
    private static ResourceManager resourceMan;
    private static CultureInfo resourceCulture;
    [EditorBrowsableAttribute("2")]
internal static ResourceManager ResourceManager { get; }
    [EditorBrowsableAttribute("2")]
internal static CultureInfo Culture { get; internal set; }
    internal static string CheckVarintIsInvalid { get; }
    internal static string CallViewError { get; }
    internal static string CheckWireTypeIsNotBytes { get; }
    internal static string CheckTagIsOutOfRange { get; }
    internal static string CallSkipError { get; }
    internal static string CheckWireTypeIsDefined { get; }
    internal static string CheckWireTypeIsKnown { get; }
    internal static string CheckSkipBytesIsValid { get; }
    internal static string CheckDataIsNotEmpty { get; }
    internal static string CheckDataIsZipped { get; }
    internal static string CheckVectorTileFeatureTagsIsEven { get; }
    internal static string CheckValueTypeIsValid { get; }
    internal static string DownloadFileFromNetworkError { get; }
    internal static string CheckColumnValuesAreValidInTileRange { get; }
    internal static string CheckRowValuesAreValidInTileRange { get; }
    internal static ResourceManager get_ResourceManager();
    internal static CultureInfo get_Culture();
    internal static void set_Culture(CultureInfo value);
    internal static string get_CheckVarintIsInvalid();
    internal static string get_CallViewError();
    internal static string get_CheckWireTypeIsNotBytes();
    internal static string get_CheckTagIsOutOfRange();
    internal static string get_CallSkipError();
    internal static string get_CheckWireTypeIsDefined();
    internal static string get_CheckWireTypeIsKnown();
    internal static string get_CheckSkipBytesIsValid();
    internal static string get_CheckDataIsNotEmpty();
    internal static string get_CheckDataIsZipped();
    internal static string get_CheckVectorTileFeatureTagsIsEven();
    internal static string get_CheckValueTypeIsValid();
    internal static string get_DownloadFileFromNetworkError();
    internal static string get_CheckColumnValuesAreValidInTileRange();
    internal static string get_CheckRowValuesAreValidInTileRange();
}
public class ThinkGeo.Core.Vertex : ValueType {
    [ObfuscationAttribute]
private double x;
    [ObfuscationAttribute]
private double y;
    public double X { get; public set; }
    public double Y { get; public set; }
    public Vertex(double x, double y);
    public Vertex(PointShape point);
    public double get_X();
    public void set_X(double value);
    public double get_Y();
    public void set_Y(double value);
    public virtual string ToString();
    public virtual int GetHashCode();
    public virtual bool Equals(object obj);
    private bool bRU=(Vertex compareObj);
    public Vertex Add(Vertex targetVertex);
    public static Vertex op_Addition(Vertex vertex1, Vertex vertex2);
    public static bool op_Equality(Vertex vertex1, Vertex vertex2);
    public static bool op_Inequality(Vertex vertex1, Vertex vertex2);
    public static Vertex FindMiddleVertexBetweenTwoVertices(Vertex vertex1, Vertex vertex2);
    internal void URw=(double xOffset, double yOffset, GeographyUnit shapeUnit, DistanceUnit unitOfOffset);
    internal void Uhw=(double distance, double angleInDegrees, GeographyUnit shapeUnit, DistanceUnit distanceUnit);
    internal void Uxw=(Vertex vertex, double degreeAngle);
    internal void Uxw=(PointShape pivotPoint, double degreeAngle);
    internal double VBw=(BaseShape targetShape, GeographyUnit shapeUnit, DistanceUnit distanceUnit);
    internal double VBw=(Vertex targetVertex, GeographyUnit shapeUnit, DistanceUnit distanceUnit);
    internal double VRw=(double toX, double toY);
    private PointShape NRw=(double offset, float degree);
}
public class ThinkGeo.Core.VertexAddedEditInteractiveOverlayEventArgs : EventArgs {
    [ObfuscationAttribute]
private Feature affectedFeature;
    [ObfuscationAttribute]
private Vertex addedVertex;
    public Feature AffectedFeature { get; public set; }
    public Vertex AddedVertex { get; public set; }
    public VertexAddedEditInteractiveOverlayEventArgs(Feature affectedFeature, Vertex addedVertex);
    public Feature get_AffectedFeature();
    public void set_AffectedFeature(Feature value);
    public Vertex get_AddedVertex();
    public void set_AddedVertex(Vertex value);
}
public class ThinkGeo.Core.VertexAddedTrackInteractiveOverlayEventArgs : EventArgs {
    [ObfuscationAttribute]
private Vertex addedVertex;
    [ObfuscationAttribute]
private Feature affectedFeature;
    public Vertex AddedVertex { get; public set; }
    public Feature AffectedFeature { get; public set; }
    public VertexAddedTrackInteractiveOverlayEventArgs(Vertex addedVertex, Feature affectedFeature);
    public Vertex get_AddedVertex();
    public void set_AddedVertex(Vertex value);
    public Feature get_AffectedFeature();
    public void set_AffectedFeature(Feature value);
}
public class ThinkGeo.Core.VertexAddingEditInteractiveOverlayEventArgs : EventArgs {
    [ObfuscationAttribute]
private Feature affectedFeature;
    [ObfuscationAttribute]
private Vertex addingVertex;
    [ObfuscationAttribute]
private bool cancel;
    [CompilerGeneratedAttribute]
private PointShape hxQ=;
    public Feature AffectedFeature { get; public set; }
    public Vertex AddingVertex { get; public set; }
    public bool Cancel { get; public set; }
    public PointShape TargetPointShape { get; public set; }
    public VertexAddingEditInteractiveOverlayEventArgs(bool cancel, Feature affectedFeature, Vertex addingVertex);
    public Feature get_AffectedFeature();
    public void set_AffectedFeature(Feature value);
    public Vertex get_AddingVertex();
    public void set_AddingVertex(Vertex value);
    public bool get_Cancel();
    public void set_Cancel(bool value);
    [CompilerGeneratedAttribute]
public PointShape get_TargetPointShape();
    [CompilerGeneratedAttribute]
public void set_TargetPointShape(PointShape value);
}
public class ThinkGeo.Core.VertexAddingTrackInteractiveOverlayEventArgs : EventArgs {
    [ObfuscationAttribute]
private bool cancel;
    [ObfuscationAttribute]
private Vertex addingVertex;
    [ObfuscationAttribute]
private Feature affectedFeature;
    [CompilerGeneratedAttribute]
private PointShape hxQ=;
    public bool Cancel { get; public set; }
    public Vertex AddingVertex { get; public set; }
    public Feature AffectedFeature { get; public set; }
    public PointShape TargetPointShape { get; public set; }
    public VertexAddingTrackInteractiveOverlayEventArgs(Vertex addingVertex, Feature affectedFeature, bool cancel);
    public bool get_Cancel();
    public void set_Cancel(bool value);
    public Vertex get_AddingVertex();
    public void set_AddingVertex(Vertex value);
    public Feature get_AffectedFeature();
    public void set_AffectedFeature(Feature value);
    [CompilerGeneratedAttribute]
public PointShape get_TargetPointShape();
    [CompilerGeneratedAttribute]
public void set_TargetPointShape(PointShape value);
}
public class ThinkGeo.Core.VertexMovedEditInteractiveOverlayEventArgs : EventArgs {
    [ObfuscationAttribute]
private Feature affectedFeature;
    [ObfuscationAttribute]
private Vertex movedVertex;
    public Feature AffectedFeature { get; public set; }
    public Vertex MovedVertex { get; public set; }
    public VertexMovedEditInteractiveOverlayEventArgs(Feature affectedFeature, Vertex movedVertex);
    public Feature get_AffectedFeature();
    public void set_AffectedFeature(Feature value);
    public Vertex get_MovedVertex();
    public void set_MovedVertex(Vertex value);
}
public class ThinkGeo.Core.VertexMovingEditInteractiveOverlayEventArgs : EventArgs {
    [CompilerGeneratedAttribute]
private Feature iBQ=;
    [CompilerGeneratedAttribute]
private Vertex iRQ=;
    [CompilerGeneratedAttribute]
private PointShape ihQ=;
    [CompilerGeneratedAttribute]
private bool ixQ=;
    public Feature AffectedFeature { get; public set; }
    public Vertex MovingVertex { get; public set; }
    public PointShape TargetVertex { get; public set; }
    public bool Cancel { get; public set; }
    public VertexMovingEditInteractiveOverlayEventArgs(bool cancel, Feature affectedFeature, Vertex movingVertex);
    public VertexMovingEditInteractiveOverlayEventArgs(bool cancel, Feature affectedFeature, Vertex movingVertex, PointShape targetVertex);
    [CompilerGeneratedAttribute]
public Feature get_AffectedFeature();
    [CompilerGeneratedAttribute]
public void set_AffectedFeature(Feature value);
    [CompilerGeneratedAttribute]
public Vertex get_MovingVertex();
    [CompilerGeneratedAttribute]
public void set_MovingVertex(Vertex value);
    [CompilerGeneratedAttribute]
public PointShape get_TargetVertex();
    [CompilerGeneratedAttribute]
public void set_TargetVertex(PointShape value);
    [CompilerGeneratedAttribute]
public bool get_Cancel();
    [CompilerGeneratedAttribute]
public void set_Cancel(bool value);
}
public class ThinkGeo.Core.VertexRemovedEditInteractiveOverlayEventArgs : EventArgs {
    [ObfuscationAttribute]
private Feature affectedFeature;
    [ObfuscationAttribute]
private Vertex removedVertex;
    public Feature AffectedFeature { get; public set; }
    public Vertex RemovedVertex { get; public set; }
    public VertexRemovedEditInteractiveOverlayEventArgs(Feature affectedFeature, Vertex removedVertex);
    public Feature get_AffectedFeature();
    public void set_AffectedFeature(Feature value);
    public Vertex get_RemovedVertex();
    public void set_RemovedVertex(Vertex value);
}
public class ThinkGeo.Core.VertexRemovingEditInteractiveOverlayEventArgs : EventArgs {
    [ObfuscationAttribute]
private Feature affectedFeature;
    [ObfuscationAttribute]
private Vertex removingVertex;
    [ObfuscationAttribute]
private bool cancel;
    public Feature AffectedFeature { get; public set; }
    public Vertex RemovingVertex { get; public set; }
    public bool Cancel { get; public set; }
    public VertexRemovingEditInteractiveOverlayEventArgs(bool cancel, Feature affectedFeature, Vertex removingVertex);
    public Feature get_AffectedFeature();
    public void set_AffectedFeature(Feature value);
    public Vertex get_RemovingVertex();
    public void set_RemovingVertex(Vertex value);
    public bool get_Cancel();
    public void set_Cancel(bool value);
}
public class ThinkGeo.Core.WarningMessage : object {
    public static string UseAsyncVersion;
    public static string WebRequestObsoleted;
    public static string WebRequestObsoleted2;
    public static string AttributionObsoleteMessage;
    public static string AutoRefreshOverlayObsoleteMessage;
}
public abstract class ThinkGeo.Core.WebBasedAsyncLayer : AsyncLayer {
    [CompilerGeneratedAttribute]
private EventHandler`1<SendingHttpRequestMessageEventArgs> SendingHttpRequest;
    [CompilerGeneratedAttribute]
private EventHandler`1<ReceivedHttpResponseMessageEventArgs> ReceivedHttpResponse;
    [CompilerGeneratedAttribute]
private HttpClient BB4=;
    [CompilerGeneratedAttribute]
private IWebProxy ux0=;
    [CompilerGeneratedAttribute]
private int uh0=;
    [CompilerGeneratedAttribute]
private ICredentials BR4=;
    [CompilerGeneratedAttribute]
private string Bh4=;
    protected HttpClient HttpClient { get; protected set; }
    public IWebProxy WebProxy { get; public set; }
    public int TimeoutInSeconds { get; public set; }
    public ICredentials Credentials { get; public set; }
    public string UserAgent { get; public set; }
    [CompilerGeneratedAttribute]
public void add_SendingHttpRequest(EventHandler`1<SendingHttpRequestMessageEventArgs> value);
    [CompilerGeneratedAttribute]
public void remove_SendingHttpRequest(EventHandler`1<SendingHttpRequestMessageEventArgs> value);
    [CompilerGeneratedAttribute]
public void add_ReceivedHttpResponse(EventHandler`1<ReceivedHttpResponseMessageEventArgs> value);
    [CompilerGeneratedAttribute]
public void remove_ReceivedHttpResponse(EventHandler`1<ReceivedHttpResponseMessageEventArgs> value);
    [CompilerGeneratedAttribute]
protected HttpClient get_HttpClient();
    [CompilerGeneratedAttribute]
protected void set_HttpClient(HttpClient value);
    [CompilerGeneratedAttribute]
public sealed virtual IWebProxy get_WebProxy();
    [CompilerGeneratedAttribute]
public sealed virtual void set_WebProxy(IWebProxy value);
    [CompilerGeneratedAttribute]
public sealed virtual int get_TimeoutInSeconds();
    [CompilerGeneratedAttribute]
public sealed virtual void set_TimeoutInSeconds(int value);
    [AsyncStateMachineAttribute("ThinkGeo.Core.WebBasedAsyncLayer/<OpenAsyncCore>d__18")]
protected virtual Task OpenAsyncCore(CancellationToken cancellationToken);
    [CompilerGeneratedAttribute]
public sealed virtual ICredentials get_Credentials();
    [CompilerGeneratedAttribute]
public sealed virtual void set_Credentials(ICredentials value);
    [AsyncStateMachineAttribute("ThinkGeo.Core.WebBasedAsyncLayer/<SendWebRequestAsync>d__23")]
protected Task`1<HttpResponseMessage> SendWebRequestAsync(HttpRequestMessage httpRequest, CancellationToken cancellationToken);
    [CompilerGeneratedAttribute]
public sealed virtual string get_UserAgent();
    [CompilerGeneratedAttribute]
public sealed virtual void set_UserAgent(string value);
    public Task`1<Byte[]> FetchImageAsync(HttpRequestMessage requestMessage, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("ThinkGeo.Core.WebBasedAsyncLayer/<FetchImageAsyncCore>d__29")]
protected Task`1<Byte[]> FetchImageAsyncCore(HttpRequestMessage requestMessage, CancellationToken cancellationToken);
    public Task`1<Byte[]> DownloadImageAsync(double width, double height, double scaleFactor, RectangleShape extent, GeographyUnit mapUnit, CancellationToken cancellationToken);
    protected virtual Task`1<Byte[]> DownloadImageAsyncCore(double width, double height, double scaleFactor, RectangleShape extent, GeographyUnit mapUnit, CancellationToken cancellationToken);
    protected virtual void OnSendingHttpRequestMessage(SendingHttpRequestMessageEventArgs e);
    protected virtual void OnReceivedHttpResponseMessage(ReceivedHttpResponseMessageEventArgs e);
    [CompilerGeneratedAttribute]
[DebuggerHiddenAttribute]
private Task <>n__0(CancellationToken cancellationToken);
}
public enum ThinkGeo.Core.WellKnownType : Enum {
    public int value__;
    public static WellKnownType Invalid;
    public static WellKnownType Point;
    public static WellKnownType Line;
    public static WellKnownType Polygon;
    public static WellKnownType Multipoint;
    public static WellKnownType Multiline;
    public static WellKnownType Multipolygon;
    public static WellKnownType GeometryCollection;
}
public class ThinkGeo.Core.WellPointStyle : PointBaseStyle {
    [ObfuscationAttribute]
private int wellPointIndex;
    public int WellPointIndex { get; public set; }
    public WellPointStyle(int wellPointIndex);
    public WellPointStyle(int wellPointIndex, int symbolSize, GeoBrush fillBrush);
    public WellPointStyle(int wellPointIndex, int symbolSize, GeoBrush fillBrush, GeoPen outlinePen);
    private void zTE=(Feature feature, GeoCanvas canvas, GeoBrush geoBrush, GeoPen haloPen);
    private void zjE=(Feature feature, GeoCanvas canvas, GeoBrush geoBrush, GeoPen haloPen);
    private void zzE=(Feature feature, GeoCanvas canvas, GeoBrush geoBrush, GeoPen haloPen);
    private void 0DE=(Feature feature, GeoCanvas canvas, GeoBrush geoBrush, GeoPen haloPen);
    private void 0TE=(Feature feature, GeoCanvas canvas, GeoBrush geoBrush, GeoPen haloPen);
    private void 0jE=(Feature feature, GeoCanvas canvas, GeoBrush geoBrush, GeoPen haloPen, bool useFillBrush);
    private void 0zE=(Feature feature, GeoCanvas canvas, GeoBrush geoBrush, GeoPen haloPen);
    private void 1DE=(Feature feature, GeoCanvas canvas, GeoBrush geoBrush, GeoPen haloPen, bool useFillBrush);
    private void 1TE=(Feature feature, GeoCanvas canvas, GeoBrush geoBrush, GeoPen haloPen, bool useFillBrush);
    private void 1jE=(Feature feature, GeoCanvas canvas, GeoBrush geoBrush, GeoPen haloPen, bool useFillBrush);
    private void 1zE=(Feature feature, GeoCanvas canvas, GeoBrush geoBrush, GeoPen haloPen, bool useFillBrush);
    private void 2DE=(Feature feature, GeoCanvas canvas, GeoBrush geoBrush, GeoPen haloPen, bool useFillBrush);
    private void 2TE=(Feature feature, GeoCanvas canvas, GeoBrush geoBrush, GeoPen haloPen);
    private void 2jE=(Feature feature, GeoCanvas canvas, GeoBrush geoBrush, GeoPen haloPen);
    private void 2zE=(Feature feature, GeoCanvas canvas, GeoBrush geoBrush, GeoPen haloPen);
    private void 3DE=(Feature feature, GeoCanvas canvas, GeoBrush geoBrush, GeoPen haloPen);
    private void 3TE=(Feature feature, GeoCanvas canvas, GeoBrush geoBrush, GeoPen haloPen);
    private void 3jE=(Feature feature, GeoCanvas canvas, GeoBrush geoBrush, GeoPen haloPen);
    private void 3zE=(Feature feature, GeoCanvas canvas, GeoBrush geoBrush, GeoPen haloPen);
    private void 4DE=(Feature feature, GeoCanvas canvas, GeoBrush geoBrush, GeoPen haloPen);
    private void 4TE=(Feature feature, GeoCanvas canvas, GeoBrush geoBrush, GeoPen haloPen, bool useFillBrush);
    private void 4jE=(Feature feature, GeoCanvas canvas, GeoBrush geoBrush, GeoPen haloPen);
    private void 4zE=(Feature feature, GeoCanvas canvas, GeoBrush geoBrush, GeoPen haloPen);
    private void 5DE=(Feature feature, GeoCanvas canvas, GeoBrush geoBrush, GeoPen haloPen);
    private void 5TE=(Feature feature, GeoCanvas canvas, GeoBrush geoBrush, GeoPen haloPen);
    private void 5jE=(Feature feature, GeoCanvas canvas, GeoBrush geoBrush, GeoPen haloPen);
    private void 5zE=(Feature feature, GeoCanvas canvas, GeoBrush geoBrush, GeoPen haloPen);
    private void 6DE=(Feature feature, GeoCanvas canvas, GeoBrush geoBrush, GeoPen haloPen);
    private void 6TE=(Feature feature, GeoCanvas canvas, GeoBrush geoBrush, GeoPen haloPen);
    private void 6jE=(Feature feature, GeoCanvas canvas, GeoBrush geoBrush, GeoPen haloPen);
    private void 6zE=(Feature feature, GeoCanvas canvas, GeoBrush geoBrush, GeoPen haloPen);
    private void 7DE=(Feature feature, GeoCanvas canvas, GeoBrush geoBrush, GeoPen haloPen);
    private void 7TE=(Feature feature, GeoCanvas canvas, GeoBrush geoBrush, GeoPen haloPen);
    private void 7jE=(Feature feature, GeoCanvas canvas, GeoBrush geoBrush, GeoPen haloPen);
    private void 7zE=(Feature feature, GeoCanvas canvas, GeoBrush geoBrush, GeoPen haloPen);
    private void 8DE=(Feature feature, GeoCanvas canvas, GeoBrush geoBrush, GeoPen haloPen);
    private void 8TE=(Feature feature, GeoCanvas canvas, GeoBrush geoBrush, GeoPen haloPen);
    private void 8jE=(Feature feature, GeoCanvas canvas, GeoBrush geoBrush, GeoPen haloPen);
    private void 8zE=(Feature feature, GeoCanvas canvas, GeoBrush geoBrush, GeoPen haloPen);
    private void 9DE=(Feature feature, GeoCanvas canvas, GeoBrush geoBrush, GeoPen haloPen);
    private void 9TE=(Feature feature, GeoCanvas canvas, GeoBrush geoBrush, GeoPen haloPen);
    private void 9jE=(Feature feature, GeoCanvas canvas, GeoBrush geoBrush, GeoPen haloPen);
    private void 9zE=(Feature feature, GeoCanvas canvas, GeoBrush geoBrush, GeoPen haloPen);
    private void /DE=(Feature feature, GeoCanvas canvas, GeoBrush geoBrush, GeoPen haloPen, bool useFillBrush);
    private void /TE=(Feature feature, GeoCanvas canvas, GeoBrush geoBrush, GeoPen haloPen);
    private void /jE=(Feature feature, GeoCanvas canvas, GeoBrush geoBrush, GeoPen haloPen);
    private void /zE=(Feature feature, GeoCanvas canvas, GeoBrush geoBrush, GeoPen haloPen);
    private void ADI=(Feature feature, GeoCanvas canvas, GeoBrush geoBrush, GeoPen haloPen);
    private void ATI=(Feature feature, GeoCanvas canvas, GeoBrush geoBrush, GeoPen haloPen);
    private void AjI=(Feature feature, GeoCanvas canvas, GeoBrush geoBrush, GeoPen haloPen);
    private void AzI=(Feature feature, GeoCanvas canvas, GeoBrush geoBrush, GeoPen haloPen);
    private void BDI=(Feature feature, GeoCanvas canvas, GeoBrush geoBrush, GeoPen haloPen);
    private void BTI=(Feature feature, GeoCanvas canvas, GeoBrush geoBrush, GeoPen haloPen);
    private void BjI=(Feature feature, GeoCanvas canvas, GeoBrush geoBrush, GeoPen haloPen);
    private void BzI=(Feature feature, GeoCanvas canvas, GeoBrush geoBrush, GeoPen haloPen);
    private void CDI=(Feature feature, GeoCanvas canvas, GeoBrush geoBrush, GeoPen haloPen);
    private void CTI=(Feature feature, GeoCanvas canvas, GeoBrush geoBrush, GeoPen haloPen);
    private void CjI=(Feature feature, GeoCanvas canvas, GeoBrush geoBrush, GeoPen haloPen);
    private void CzI=(Feature feature, GeoCanvas canvas, GeoBrush geoBrush, GeoPen haloPen);
    private void DDI=(Feature feature, GeoCanvas canvas, GeoBrush geoBrush, GeoPen haloPen);
    private void DTI=(Feature feature, GeoCanvas canvas, GeoBrush geoBrush, GeoPen haloPen);
    private void DjI=(Feature feature, GeoCanvas canvas, GeoBrush geoBrush, GeoPen haloPen);
    private void DzI=(Feature feature, GeoCanvas canvas, GeoBrush geoBrush, GeoPen haloPen);
    private void EDI=(Feature feature, GeoCanvas canvas, GeoBrush geoBrush, GeoPen haloPen);
    private void ETI=(Feature feature, GeoCanvas canvas, GeoBrush geoBrush, GeoPen haloPen);
    private void EjI=(Feature feature, GeoCanvas canvas, GeoBrush geoBrush, GeoPen haloPen);
    private void EzI=(Feature feature, GeoCanvas canvas, GeoBrush geoBrush, GeoPen haloPen);
    private void FDI=(Feature feature, GeoCanvas canvas, GeoBrush geoBrush, GeoPen haloPen, bool useFillBrush);
    private void FTI=(Feature feature, GeoCanvas canvas, GeoBrush geoBrush, GeoPen haloPen, bool useFillBrush);
    private void FjI=(Feature feature, GeoCanvas canvas, GeoBrush geoBrush, GeoPen haloPen);
    private void FzI=(Feature feature, GeoCanvas canvas, GeoBrush geoBrush, GeoPen haloPen);
    private void GDI=(Feature feature, GeoCanvas canvas, GeoBrush geoBrush, GeoPen haloPen);
    private void GTI=(Feature feature, GeoCanvas canvas, GeoBrush geoBrush, GeoPen haloPen);
    private void GjI=(Feature feature, GeoCanvas canvas, GeoBrush geoBrush, GeoPen haloPen);
    private void GzI=(Feature feature, GeoCanvas canvas, GeoBrush geoBrush, GeoPen haloPen);
    private void HDI=(Feature feature, GeoCanvas canvas, GeoBrush geoBrush, GeoPen haloPen);
    private void HTI=(Feature feature, GeoCanvas canvas, GeoBrush geoBrush, GeoPen haloPen);
    private void HjI=(Feature feature, GeoCanvas canvas, GeoBrush geoBrush, GeoPen haloPen);
    private void HzI=(Feature feature, GeoCanvas canvas, GeoBrush geoBrush, GeoPen haloPen);
    private void IDI=(Feature feature, GeoCanvas canvas, GeoBrush geoBrush, GeoPen haloPen);
    private void ITI=(Feature feature, GeoCanvas canvas, GeoBrush geoBrush, GeoPen haloPen);
    private void IjI=(Feature feature, GeoCanvas canvas, GeoBrush geoBrush, GeoPen haloPen);
    private void IzI=(Feature feature, GeoCanvas canvas, GeoBrush geoBrush, GeoPen haloPen);
    private void JDI=(Feature feature, GeoCanvas canvas, GeoBrush geoBrush, GeoPen haloPen);
    private void JTI=(Feature feature, GeoCanvas canvas, GeoBrush geoBrush, GeoPen haloPen);
    private void JjI=(Feature feature, GeoCanvas canvas, GeoBrush geoBrush, GeoPen haloPen);
    private void JzI=(Feature feature, GeoCanvas canvas, GeoBrush geoBrush, GeoPen haloPen);
    private void KDI=(Feature feature, GeoCanvas canvas, GeoBrush geoBrush, GeoPen haloPen);
    private void KTI=(Feature feature, GeoCanvas canvas, GeoBrush geoBrush, GeoPen haloPen);
    private void KjI=(Feature feature, GeoCanvas canvas, GeoBrush geoBrush, GeoPen haloPen);
    private void KzI=(Feature feature, GeoCanvas canvas, GeoBrush geoBrush, GeoPen haloPen);
    private void LDI=(Feature feature, GeoCanvas canvas, GeoBrush geoBrush, GeoPen haloPen);
    private void LTI=(Feature feature, GeoCanvas canvas, GeoBrush geoBrush, GeoPen haloPen);
    private void LjI=(Feature feature, GeoCanvas canvas, GeoBrush geoBrush, GeoPen haloPen);
    private void LzI=(Feature feature, GeoCanvas canvas, GeoBrush geoBrush, GeoPen haloPen);
    private void MDI=(Feature feature, GeoCanvas canvas, GeoBrush geoBrush, GeoPen haloPen);
    private void MTI=(Feature feature, GeoCanvas canvas, GeoBrush geoBrush, GeoPen haloPen);
    private void MjI=(Feature feature, GeoCanvas canvas, GeoBrush geoBrush, GeoPen haloPen);
    private void MzI=(Feature feature, GeoCanvas canvas, GeoBrush geoBrush, GeoPen haloPen);
    private void NDI=(Feature feature, GeoCanvas canvas, GeoBrush geoBrush, GeoPen haloPen);
    private void NTI=(Feature feature, GeoCanvas canvas, GeoBrush geoBrush, GeoPen haloPen);
    private void NjI=(Feature feature, GeoCanvas canvas, GeoBrush geoBrush, GeoPen haloPen);
    private void NzI=(Feature feature, GeoCanvas canvas, GeoBrush geoBrush, GeoPen haloPen);
    private void ODI=(Feature feature, GeoCanvas canvas, GeoBrush geoBrush, GeoPen haloPen);
    private void OTI=(Feature feature, GeoCanvas canvas, GeoBrush geoBrush, GeoPen haloPen);
    private void OjI=(Feature feature, GeoCanvas canvas, GeoBrush geoBrush, GeoPen haloPen);
    private void OzI=(Feature feature, GeoCanvas canvas, GeoBrush geoBrush, GeoPen haloPen);
    private void PDI=(Feature feature, GeoCanvas canvas, GeoBrush geoBrush, GeoPen haloPen);
    private void PTI=(Feature feature, GeoCanvas canvas, GeoBrush geoBrush, GeoPen haloPen);
    private void PjI=(Feature feature, GeoCanvas canvas, GeoBrush geoBrush, GeoPen haloPen);
    private void PzI=(Feature feature, GeoCanvas canvas, GeoBrush geoBrush, GeoPen haloPen);
    private void QDI=(Feature feature, GeoCanvas canvas, GeoBrush geoBrush, GeoPen haloPen);
    private void QTI=(Feature feature, GeoCanvas canvas, GeoBrush geoBrush, GeoPen haloPen);
    private void QjI=(Feature feature, GeoCanvas canvas, GeoBrush geoBrush, GeoPen haloPen);
    private void QzI=(Feature feature, GeoCanvas canvas, GeoBrush geoBrush, GeoPen haloPen);
    private void RDI=(Feature feature, GeoCanvas canvas, GeoBrush geoBrush, GeoPen haloPen, bool useFillBrush);
    private void RTI=(Feature feature, GeoCanvas canvas, GeoBrush geoBrush, GeoPen haloPen, bool useFillBrush);
    private void RjI=(Feature feature, GeoCanvas canvas, GeoBrush geoBrush, GeoPen haloPen);
    private void RzI=(Feature feature, GeoCanvas canvas, GeoBrush geoBrush, GeoPen haloPen);
    private void SDI=(Feature feature, GeoCanvas canvas, GeoBrush geoBrush, GeoPen haloPen);
    private void STI=(Feature feature, GeoCanvas canvas, GeoBrush geoBrush, GeoPen haloPen);
    private void SjI=(Feature feature, GeoCanvas canvas, GeoBrush geoBrush, GeoPen haloPen);
    private void SzI=(Feature feature, GeoCanvas canvas, GeoBrush geoBrush, GeoPen haloPen);
    private void TDI=(Feature feature, GeoCanvas canvas, GeoBrush geoBrush, GeoPen haloPen);
    private void TTI=(Feature feature, GeoCanvas canvas, GeoBrush geoBrush, GeoPen haloPen);
    private void TjI=(Feature feature, GeoCanvas canvas, GeoBrush geoBrush, GeoPen haloPen);
    private void TzI=(Feature feature, GeoCanvas canvas, GeoBrush geoBrush, GeoPen haloPen);
    private void UDI=(Feature feature, GeoCanvas canvas, GeoBrush geoBrush, GeoPen haloPen);
    private void UTI=(Feature feature, GeoCanvas canvas, GeoBrush geoBrush, GeoPen haloPen);
    private void UjI=(Feature feature, GeoCanvas canvas, GeoBrush geoBrush, GeoPen haloPen);
    private void UzI=(Feature feature, GeoCanvas canvas, GeoBrush geoBrush, GeoPen haloPen);
    private void VDI=(Feature feature, GeoCanvas canvas, GeoBrush geoBrush, GeoPen haloPen);
    private void VTI=(Feature feature, GeoCanvas canvas, GeoBrush geoBrush, GeoPen haloPen);
    private void VjI=(Feature feature, GeoCanvas canvas, GeoBrush geoBrush, GeoPen haloPen, bool useFillBrush);
    private void VzI=(Feature feature, GeoCanvas canvas, GeoBrush geoBrush, GeoPen haloPen);
    private void WDI=(Feature feature, GeoCanvas canvas, GeoBrush geoBrush, GeoPen haloPen);
    private void WTI=(Feature feature, GeoCanvas canvas, GeoBrush geoBrush, GeoPen haloPen);
    private void WjI=(Feature feature, GeoCanvas canvas, GeoBrush geoBrush, GeoPen haloPen);
    private void WzI=(Feature feature, GeoCanvas canvas, GeoBrush geoBrush, GeoPen haloPen);
    private void XDI=(Feature feature, GeoCanvas canvas, GeoBrush geoBrush, GeoPen haloPen);
    private void XTI=(Feature feature, GeoCanvas canvas, GeoBrush geoBrush, GeoPen haloPen);
    private void XjI=(Feature feature, GeoCanvas canvas, GeoBrush geoBrush, GeoPen haloPen);
    private void XzI=(Feature feature, GeoCanvas canvas, GeoBrush geoBrush, GeoPen haloPen);
    private void YDI=(Feature feature, GeoCanvas canvas, GeoBrush geoBrush, GeoPen haloPen);
    private void YTI=(Feature feature, GeoCanvas canvas, GeoBrush geoBrush, GeoPen haloPen);
    private void YjI=(Feature feature, GeoCanvas canvas, GeoBrush geoBrush, GeoPen haloPen);
    private void YzI=(Feature feature, GeoCanvas canvas, GeoBrush geoBrush, GeoPen haloPen);
    private void ZDI=(Feature feature, GeoCanvas canvas, GeoBrush geoBrush, GeoPen haloPen);
    private void ZTI=(Feature feature, GeoCanvas canvas, GeoBrush geoBrush, GeoPen haloPen);
    private void ZjI=(Feature feature, GeoCanvas canvas, GeoBrush geoBrush, GeoPen haloPen);
    private void ZzI=(Feature feature, GeoCanvas canvas, GeoBrush geoBrush, GeoPen haloPen);
    private void aDI=(Feature feature, GeoCanvas canvas, GeoBrush geoBrush, GeoPen haloPen);
    private void aTI=(Feature feature, GeoCanvas canvas, GeoBrush geoBrush, GeoPen haloPen);
    private void ajI=(Feature feature, GeoCanvas canvas, GeoBrush geoBrush, GeoPen haloPen);
    private void azI=(Feature feature, GeoCanvas canvas, GeoBrush geoBrush, GeoPen haloPen);
    private void bDI=(Feature feature, GeoCanvas canvas, GeoBrush geoBrush, GeoPen haloPen);
    private void bTI=(Feature feature, GeoCanvas canvas, GeoBrush geoBrush, GeoPen haloPen);
    private void bjI=(Feature feature, GeoCanvas canvas, GeoBrush geoBrush, GeoPen haloPen);
    private void bzI=(Feature feature, GeoCanvas canvas, GeoBrush geoBrush, GeoPen haloPen);
    private void cDI=(Feature feature, GeoCanvas canvas, GeoBrush geoBrush, GeoPen haloPen);
    private void cTI=(Feature feature, GeoCanvas canvas, GeoBrush geoBrush, GeoPen haloPen);
    private void cjI=(Feature feature, GeoCanvas canvas, GeoBrush geoBrush, GeoPen haloPen);
    private void czI=(Feature feature, GeoCanvas canvas, GeoBrush geoBrush, GeoPen haloPen);
    private void dDI=(Feature feature, GeoCanvas canvas, GeoBrush geoBrush, GeoPen haloPen);
    private void dTI=(Feature feature, GeoCanvas canvas, GeoBrush geoBrush, GeoPen haloPen);
    private void djI=(Feature feature, GeoCanvas canvas, GeoBrush geoBrush, GeoPen haloPen);
    private void dzI=(Feature feature, GeoCanvas canvas, GeoBrush geoBrush, GeoPen haloPen);
    private void eDI=(Feature feature, GeoCanvas canvas, GeoBrush geoBrush, GeoPen haloPen);
    private void eTI=(Feature feature, GeoCanvas canvas, GeoBrush geoBrush, GeoPen haloPen);
    private void ejI=(Feature feature, GeoCanvas canvas, GeoBrush geoBrush, GeoPen haloPen);
    private void ezI=(Feature feature, GeoCanvas canvas, GeoBrush geoBrush, GeoPen haloPen);
    private void fDI=(Feature feature, GeoCanvas canvas, GeoBrush geoBrush, GeoPen haloPen, bool useFillBrush);
    private void fTI=(Feature feature, GeoCanvas canvas, GeoBrush geoBrush, GeoPen haloPen);
    private void fjI=(Feature feature, GeoCanvas canvas, GeoBrush geoBrush, GeoPen haloPen, bool useFillBrush);
    private void fzI=(Feature feature, GeoCanvas canvas, GeoBrush geoBrush, GeoPen haloPen);
    private void gDI=(Feature feature, GeoCanvas canvas, GeoBrush geoBrush, GeoPen haloPen, bool useFillBrush);
    private void gTI=(Feature feature, GeoCanvas canvas, GeoBrush geoBrush, GeoPen haloPen);
    private void gjI=(Feature feature, GeoCanvas canvas, GeoBrush geoBrush, GeoPen haloPen, bool useFillBrush);
    private void gzI=(Feature feature, GeoCanvas canvas, GeoBrush geoBrush, GeoPen haloPen);
    private void hDI=(Feature feature, GeoCanvas canvas, GeoBrush geoBrush, GeoPen haloPen, bool useFillBrush);
    private void hTI=(Feature feature, GeoCanvas canvas, GeoBrush geoBrush, GeoPen haloPen);
    private void hjI=(Feature feature, GeoCanvas canvas, GeoBrush geoBrush, GeoPen haloPen, bool useFillBrush);
    private void hzI=(Feature feature, GeoCanvas canvas, GeoBrush geoBrush, GeoPen haloPen);
    private void iDI=(Feature feature, GeoCanvas canvas, GeoBrush geoBrush, GeoPen haloPen, bool useFillBrush);
    private void iTI=(Feature feature, GeoCanvas canvas, GeoBrush geoBrush, GeoPen haloPen);
    private static Feature ijI=(PointShape centerPoint, double resolutionX, double resolutionY, double radius);
    private static Feature izI=(PointShape centerPoint, double resolutionX, double resolutionY, double radius);
    private static Feature jDI=(PointShape centerPoint, double resolutionX, double resolutionY, double radius);
    private void jTI=(Feature feature, GeoCanvas canvas, GeoPen haloPen, GeoBrush geobrush, PointShape centerPoint, double resolutionX, double resolutionY, float radius, float halfRadius, bool useFillBrush);
    private void jjI=(Feature feature, GeoCanvas canvas, GeoPen haloPen, GeoBrush geoBrush, string letter);
    private void jzI=(Feature feature, GeoCanvas canvas, GeoBrush geoBrush, GeoPen haloPen);
    public int get_WellPointIndex();
    public void set_WellPointIndex(int value);
    protected virtual void DrawCore(IEnumerable`1<Feature> features, GeoCanvas canvas, Collection`1<SimpleCandidate> labelsInThisLayer, Collection`1<SimpleCandidate> labelsInAllLayers);
    protected virtual void DrawSampleCore(GeoCanvas canvas, DrawingRectangleF drawingExtent);
    private RectangleShape EhU=(DrawingRectangleF drawingRectangle, GeoCanvas canvas);
    private void kDI=(Feature feature, GeoCanvas canvas, GeoPen geoPen, GeoBrush geoBrush);
}
public class ThinkGeo.Core.WfsFeatureLayer : FeatureLayer {
    public string LastXmlResponse { get; }
    public string ServiceLocationUrl { get; public set; }
    public string TypeName { get; public set; }
    public int TimeoutInSeconds { get; public set; }
    public bool HasBoundingBox { get; }
    public IWebProxy WebProxy { get; public set; }
    public WfsFeatureLayer(string serviceLocationUrl, string typeName);
    public string get_LastXmlResponse();
    public string get_ServiceLocationUrl();
    public void set_ServiceLocationUrl(string value);
    public string get_TypeName();
    public void set_TypeName(string value);
    public int get_TimeoutInSeconds();
    public void set_TimeoutInSeconds(int value);
    public virtual bool get_HasBoundingBox();
    public IWebProxy get_WebProxy();
    public void set_WebProxy(IWebProxy value);
    public void add_SendingWebRequest(EventHandler`1<SendingWebRequestEventArgs> value);
    public void remove_SendingWebRequest(EventHandler`1<SendingWebRequestEventArgs> value);
    public void add_SentWebRequest(EventHandler`1<SentWebRequestEventArgs> value);
    public void remove_SentWebRequest(EventHandler`1<SentWebRequestEventArgs> value);
    public static string GetCapabilities(string serviceLocationUrl);
    public static string GetCapabilities(Uri serverUri);
    public static string GetCapabilities(Uri serverUri, IWebProxy webProxy);
    public static Collection`1<string> GetLayers(string serviceLocationUrl);
    public static Collection`1<string> GetLayers(Uri serverUri, IWebProxy webProxy);
    public static Collection`1<string> GetLayers(Uri serverUri);
}
public class ThinkGeo.Core.WfsFeatureSource : FeatureSource {
    private static string aSM=;
    private static string oS8=;
    private static string oi8=;
    private static Dictionary`2<string, Dictionary`2<string, string>> tC8=;
    [ObfuscationAttribute]
private string version;
    [ObfuscationAttribute]
private WfsNamespace wfsNamespace;
    [ObfuscationAttribute]
private IWebProxy webProxy;
    private Collection`1<FeatureSourceColumn> aiM=;
    private string pS8=;
    [ObfuscationAttribute]
private string lastXmlResponse;
    [ObfuscationAttribute]
private string serviceLocationUrl;
    [ObfuscationAttribute]
private int timeoutInSeconds;
    [ObfuscationAttribute]
private string typeName;
    [CompilerGeneratedAttribute]
private EventHandler`1<SendingWebRequestEventArgs> SendingWebRequest;
    [CompilerGeneratedAttribute]
private EventHandler`1<SentWebRequestEventArgs> SentWebRequest;
    [CompilerGeneratedAttribute]
private EventHandler`1<RequestingDataWfsFeatureSourceEventArgs> RequestingData;
    [CompilerGeneratedAttribute]
private EventHandler`1<RequestedDataWfsFeatureSourceEventArgs> RequestedData;
    public string ServiceLocationUrl { get; public set; }
    public WfsNamespace WfsNamespace { get; public set; }
    public string TypeName { get; public set; }
    public string LastXmlResponse { get; }
    public int TimeoutInSeconds { get; public set; }
    public IWebProxy WebProxy { get; public set; }
    public WfsFeatureSource(string serviceLocationUrl, string typeName);
    private static WfsFeatureSource();
    [CompilerGeneratedAttribute]
public void add_SendingWebRequest(EventHandler`1<SendingWebRequestEventArgs> value);
    [CompilerGeneratedAttribute]
public void remove_SendingWebRequest(EventHandler`1<SendingWebRequestEventArgs> value);
    [CompilerGeneratedAttribute]
public void add_SentWebRequest(EventHandler`1<SentWebRequestEventArgs> value);
    [CompilerGeneratedAttribute]
public void remove_SentWebRequest(EventHandler`1<SentWebRequestEventArgs> value);
    protected virtual bool CanGetBoundingBoxQuicklyCore();
    public string get_ServiceLocationUrl();
    public void set_ServiceLocationUrl(string value);
    public WfsNamespace get_WfsNamespace();
    public void set_WfsNamespace(WfsNamespace value);
    public string get_TypeName();
    public void set_TypeName(string value);
    public string get_LastXmlResponse();
    public int get_TimeoutInSeconds();
    public void set_TimeoutInSeconds(int value);
    public IWebProxy get_WebProxy();
    public void set_WebProxy(IWebProxy value);
    [CompilerGeneratedAttribute]
public void add_RequestingData(EventHandler`1<RequestingDataWfsFeatureSourceEventArgs> value);
    [CompilerGeneratedAttribute]
public void remove_RequestingData(EventHandler`1<RequestingDataWfsFeatureSourceEventArgs> value);
    protected virtual void OnRequestingData(RequestingDataWfsFeatureSourceEventArgs requestingDataWfsFeatureSourceEventArgs);
    [CompilerGeneratedAttribute]
public void add_RequestedData(EventHandler`1<RequestedDataWfsFeatureSourceEventArgs> value);
    [CompilerGeneratedAttribute]
public void remove_RequestedData(EventHandler`1<RequestedDataWfsFeatureSourceEventArgs> value);
    protected virtual void OnRequestedData(RequestedDataWfsFeatureSourceEventArgs requestedDataWfsFeatureSourceEventArgs);
    protected WebResponse SendWebRequest(WebRequest webRequest);
    protected virtual WebResponse SendWebRequestCore(WebRequest webRequest);
    protected virtual void OnSendingWebRequest(SendingWebRequestEventArgs e);
    protected virtual void OnSentWebRequest(SentWebRequestEventArgs e);
    public static string GetCapabilities(string serviceLocationUrl);
    public static string GetCapabilities(Uri serverUri);
    public static string GetCapabilities(Uri serverUri, IWebProxy webProxy);
    private static string tS8=(XmlDocument xmlDocument);
    private static void Gh4=(string requestCapabilities, XmlDocument xmlDocument);
    private static XmlDocument byM=(string requestCapabilities);
    public static Collection`1<string> GetLayers(string serviceLocationUrl);
    public static Collection`1<string> GetLayers(Uri serverUri);
    public static Collection`1<string> GetLayers(Uri serverUri, IWebProxy webProxy);
    protected virtual void OpenCore();
    protected virtual void CloseCore();
    protected virtual RectangleShape GetBoundingBoxCore();
    protected virtual Collection`1<FeatureSourceColumn> GetColumnsCore();
    private void ti8=(XmlReader reader);
    protected virtual Collection`1<Feature> GetFeaturesByIdsCore(IEnumerable`1<string> ids, IEnumerable`1<string> returningColumnNames);
    protected virtual WellKnownType GetFirstFeaturesWellKnownTypeCore();
    protected virtual Collection`1<Feature> GetAllFeaturesCore(IEnumerable`1<string> returningColumnNames);
    protected virtual Collection`1<Feature> GetFeaturesInsideBoundingBoxCore(RectangleShape boundingBox, IEnumerable`1<string> returningColumnNames);
    private Stream pi8=(RectangleShape boundingBox, IEnumerable`1<string> returningColumnNames);
    private Stream py8=(string requestString);
    private Feature aCE=(XmlReader reader, IEnumerable`1<string> columnNames);
    private static string qC8=(XmlReader reader, string shapeTypeName, string coordinatesName, string version);
    private static string qS8=(XmlReader reader, string shapeTypeName, string coordinatesName, string version);
    private static string qi8=(XmlReader reader, string shapeTypeName, string coordinatesName, string version);
    private static string qy8=(XmlReader reader, string shapeTypeName, string coordinatesName, string version);
    private static string rC8=(XmlReader reader, string shapeTypeName, string coordinatesName, string version);
    private static string rS8=(XmlReader reader, string shapeTypeName, string coordinatesName, string version);
    private static string ri8=(string tempString, string version);
    private string ry8=();
    private string sC8=(RectangleShape boundingBox);
    private static string sS8=(string shapeType);
    private bool si8=(string shapeType);
    protected virtual Collection`1<Feature> GetFeaturesByColumnValueCore(string columnName, string columnValue, IEnumerable`1<string> returningColumnNames);
    private XmlReader sy8=(Stream stream);
}
public enum ThinkGeo.Core.WfsNamespace : Enum {
    public int value__;
    public static WfsNamespace Null;
    public static WfsNamespace Ogc;
}
public class ThinkGeo.Core.WfsV2FeatureLayer : FeatureLayer {
    public string LastXmlResponse { get; }
    public string ServiceLocationUrl { get; public set; }
    public string TypeName { get; public set; }
    public int TimeoutInSeconds { get; public set; }
    public bool HasBoundingBox { get; }
    public IWebProxy WebProxy { get; public set; }
    public WfsV2FeatureLayer(string serviceLocationUrl, string typeName);
    public string get_LastXmlResponse();
    public string get_ServiceLocationUrl();
    public void set_ServiceLocationUrl(string value);
    public string get_TypeName();
    public void set_TypeName(string value);
    public int get_TimeoutInSeconds();
    public void set_TimeoutInSeconds(int value);
    public virtual bool get_HasBoundingBox();
    public IWebProxy get_WebProxy();
    public void set_WebProxy(IWebProxy value);
    public void add_SendingWebRequest(EventHandler`1<SendingWebRequestEventArgs> value);
    public void remove_SendingWebRequest(EventHandler`1<SendingWebRequestEventArgs> value);
    public void add_SentWebRequest(EventHandler`1<SentWebRequestEventArgs> value);
    public void remove_SentWebRequest(EventHandler`1<SentWebRequestEventArgs> value);
    public static string GetCapabilities(string serviceLocationUrl);
    public static string GetCapabilities(Uri serverUri);
    public static string GetCapabilities(Uri serverUri, IWebProxy webProxy);
    public static Collection`1<string> GetLayers(string serviceLocationUrl);
    public static Collection`1<string> GetLayers(Uri serverUri, IWebProxy webProxy);
    public static Collection`1<string> GetLayers(Uri serverUri);
}
public class ThinkGeo.Core.WfsV2FeatureSource : FeatureSource {
    private static string aSM=;
    private static string oS8=;
    private static string oi8=;
    private static string oy8=;
    private static string pC8=;
    [ObfuscationAttribute]
private WfsNamespace wfsNamespace;
    [ObfuscationAttribute]
private IWebProxy webProxy;
    private Collection`1<FeatureSourceColumn> aiM=;
    private string pS8=;
    [ObfuscationAttribute]
private string lastXmlResponse;
    [ObfuscationAttribute]
private string serviceLocationUrl;
    [ObfuscationAttribute]
private int timeoutInSeconds;
    [ObfuscationAttribute]
private string typeName;
    [CompilerGeneratedAttribute]
private EventHandler`1<SendingWebRequestEventArgs> SendingWebRequest;
    [CompilerGeneratedAttribute]
private EventHandler`1<SentWebRequestEventArgs> SentWebRequest;
    [CompilerGeneratedAttribute]
private EventHandler`1<RequestingDataWfsFeatureSourceEventArgs> RequestingData;
    [CompilerGeneratedAttribute]
private EventHandler`1<RequestedDataWfsFeatureSourceEventArgs> RequestedData;
    public string ServiceLocationUrl { get; public set; }
    public WfsNamespace WfsNamespace { get; public set; }
    public string TypeName { get; public set; }
    public string LastXmlResponse { get; }
    public int TimeoutInSeconds { get; public set; }
    public IWebProxy WebProxy { get; public set; }
    public WfsV2FeatureSource(string serviceLocationUrl, string typeName);
    [CompilerGeneratedAttribute]
public void add_SendingWebRequest(EventHandler`1<SendingWebRequestEventArgs> value);
    [CompilerGeneratedAttribute]
public void remove_SendingWebRequest(EventHandler`1<SendingWebRequestEventArgs> value);
    [CompilerGeneratedAttribute]
public void add_SentWebRequest(EventHandler`1<SentWebRequestEventArgs> value);
    [CompilerGeneratedAttribute]
public void remove_SentWebRequest(EventHandler`1<SentWebRequestEventArgs> value);
    protected virtual bool CanGetBoundingBoxQuicklyCore();
    public string get_ServiceLocationUrl();
    public void set_ServiceLocationUrl(string value);
    public WfsNamespace get_WfsNamespace();
    public void set_WfsNamespace(WfsNamespace value);
    public string get_TypeName();
    public void set_TypeName(string value);
    public string get_LastXmlResponse();
    public int get_TimeoutInSeconds();
    public void set_TimeoutInSeconds(int value);
    public IWebProxy get_WebProxy();
    public void set_WebProxy(IWebProxy value);
    [CompilerGeneratedAttribute]
public void add_RequestingData(EventHandler`1<RequestingDataWfsFeatureSourceEventArgs> value);
    [CompilerGeneratedAttribute]
public void remove_RequestingData(EventHandler`1<RequestingDataWfsFeatureSourceEventArgs> value);
    protected virtual void OnRequestingData(RequestingDataWfsFeatureSourceEventArgs requestingDataWfsFeatureSourceEventArgs);
    [CompilerGeneratedAttribute]
public void add_RequestedData(EventHandler`1<RequestedDataWfsFeatureSourceEventArgs> value);
    [CompilerGeneratedAttribute]
public void remove_RequestedData(EventHandler`1<RequestedDataWfsFeatureSourceEventArgs> value);
    protected virtual void OnRequestedData(RequestedDataWfsFeatureSourceEventArgs requestedDataWfsFeatureSourceEventArgs);
    protected WebResponse SendWebRequest(WebRequest webRequest);
    protected virtual WebResponse SendWebRequestCore(WebRequest webRequest);
    protected virtual void OnSendingWebRequest(SendingWebRequestEventArgs e);
    protected virtual void OnSentWebRequest(SentWebRequestEventArgs e);
    public static string GetCapabilities(string serviceLocationUrl);
    public static string GetCapabilities(Uri serverUri);
    public static XmlDocument GetCapabilities(Uri serverUri, IWebProxy webProxy);
    public static string GetCapabilitiesStringFromXml(XmlDocument xmlDocument);
    private static void Gh4=(string requestCapabilities, XmlDocument xmlDocument);
    private static XmlDocument byM=(string requestCapabilities);
    public static Collection`1<string> GetLayers(string serviceLocationUrl);
    public static Collection`1<string> GetLayers(Uri serverUri);
    public static Collection`1<string> GetLayers(Uri serverUri, IWebProxy webProxy);
    protected virtual void OpenCore();
    protected virtual void CloseCore();
    protected virtual RectangleShape GetBoundingBoxCore();
    protected virtual Collection`1<FeatureSourceColumn> GetColumnsCore();
    protected virtual Collection`1<Feature> GetFeaturesByIdsCore(IEnumerable`1<string> ids, IEnumerable`1<string> returningColumnNames);
    protected virtual WellKnownType GetFirstFeaturesWellKnownTypeCore();
    public Collection`1<string> GetSupportedCrs();
    public string GetDefaultCrs();
    protected virtual Collection`1<Feature> GetAllFeaturesCore(IEnumerable`1<string> returningColumnNames);
    protected virtual Collection`1<Feature> GetFeaturesInsideBoundingBoxCore(RectangleShape boundingBox, IEnumerable`1<string> returningColumnNames);
    public string GetRequestUrlForFeatures(RectangleShape boundingBox, int count, int startIndex);
    public ValueTuple`2<int, Collection`1<Feature>> GetFeatures(string requestUrl);
    private Stream pi8=(RectangleShape boundingBox, IEnumerable`1<string> returningColumnNames);
    private Stream py8=(string requestString);
    private Feature aCE=(XmlReader reader, IEnumerable`1<string> columnNames);
    private static string qC8=(XmlReader reader, string shapeTypeName, string coordinatesName);
    private static string qS8=(XmlReader reader, string shapeTypeName, string coordinatesName);
    private static string qi8=(XmlReader reader, string shapeTypeName, string coordinatesName);
    private static string qy8=(XmlReader reader, string shapeTypeName, string coordinatesName);
    private static string rC8=(XmlReader reader, string shapeTypeName, string coordinatesName);
    private static string rS8=(XmlReader reader, string shapeTypeName, string coordinatesName);
    private static string ri8=(string tempString);
    private string ry8=();
    private string sC8=(RectangleShape boundingBox);
    private static string sS8=(string shapeType);
    private bool si8=(string shapeType);
    protected virtual Collection`1<Feature> GetFeaturesByColumnValueCore(string columnName, string columnValue, IEnumerable`1<string> returningColumnNames);
    private XmlReader sy8=(Stream stream);
    [CompilerGeneratedAttribute]
private bool <GetSupportedCrs>b__66_1(XElement el);
    [CompilerGeneratedAttribute]
private bool <GetDefaultCrs>b__67_1(XElement el);
}
public class ThinkGeo.Core.WindBarbStyle : Style {
    [CompilerGeneratedAttribute]
private string SyM=;
    [CompilerGeneratedAttribute]
private string TCM=;
    [CompilerGeneratedAttribute]
private DrawingLevel TSM=;
    [CompilerGeneratedAttribute]
private float TiM=;
    [CompilerGeneratedAttribute]
private GeoPen TyM=;
    [CompilerGeneratedAttribute]
private GeoBrush UCM=;
    public string WindDirectionAngleColumnName { get; public set; }
    public string WindSpeedInKnotsColumnName { get; public set; }
    public DrawingLevel DrawingLevel { get; public set; }
    public float SymbolSize { get; public set; }
    public GeoPen Pen { get; public set; }
    public GeoBrush Brush { get; public set; }
    [CompilerGeneratedAttribute]
public string get_WindDirectionAngleColumnName();
    [CompilerGeneratedAttribute]
public void set_WindDirectionAngleColumnName(string value);
    [CompilerGeneratedAttribute]
public string get_WindSpeedInKnotsColumnName();
    [CompilerGeneratedAttribute]
public void set_WindSpeedInKnotsColumnName(string value);
    [CompilerGeneratedAttribute]
public DrawingLevel get_DrawingLevel();
    [CompilerGeneratedAttribute]
public void set_DrawingLevel(DrawingLevel value);
    [CompilerGeneratedAttribute]
public float get_SymbolSize();
    [CompilerGeneratedAttribute]
public void set_SymbolSize(float value);
    [CompilerGeneratedAttribute]
public GeoPen get_Pen();
    [CompilerGeneratedAttribute]
public void set_Pen(GeoPen value);
    [CompilerGeneratedAttribute]
public GeoBrush get_Brush();
    [CompilerGeneratedAttribute]
public void set_Brush(GeoBrush value);
    protected virtual void DrawCore(IEnumerable`1<Feature> features, GeoCanvas canvas, Collection`1<SimpleCandidate> labelsInThisLayer, Collection`1<SimpleCandidate> labelsInAllLayers);
    private static BaseShape USM=(GeoCanvas canvas, PointShape centerPoint, float radius, Vertex lineEnd, int lineLocation, RD0= windBarbType, float symbolSize, double angle);
}
public enum ThinkGeo.Core.WkbByteOrder : Enum {
    public int value__;
    public static WkbByteOrder LittleEndian;
    public static WkbByteOrder BigEndian;
}
public class ThinkGeo.Core.WkbFileFeatureLayer : FeatureLayer {
    [ObfuscationAttribute]
private static int turnCount;
    [ObfuscationAttribute]
private int progressiveDrawingRecordsCount;
    public FileAccess ReadWriteMode { get; public set; }
    public string WkbPathFilename { get; public set; }
    public int ProgressiveDrawingRecordsCount { get; public set; }
    public bool HasBoundingBox { get; }
    public WkbFileFeatureLayer(string wkbPathFilename);
    public WkbFileFeatureLayer(string wkbPathFilename, FileAccess readWriteMode);
    public FileAccess get_ReadWriteMode();
    public void set_ReadWriteMode(FileAccess value);
    public string get_WkbPathFilename();
    public void set_WkbPathFilename(string value);
    public int get_ProgressiveDrawingRecordsCount();
    public void set_ProgressiveDrawingRecordsCount(int value);
    public virtual bool get_HasBoundingBox();
    public static void CreateWkbFile(string pathFilename, WkbFileType wkbFileType, IEnumerable`1<FeatureSourceColumn> columns, IEnumerable`1<Feature> features);
    public WkbFileType GetWkbFileType();
    protected virtual void DrawCore(GeoCanvas canvas, Collection`1<SimpleCandidate> labelsInAllLayers);
    private void CiQ=(GeoCanvas canvas, RectangleShape marginWorldExtent, Collection`1<SimpleCandidate> labelsInAllLayers, ZoomLevel currentZoomLevel, Collection`1<string> columnNames, WkbFileFeatureSource wkbFileFeatureSource, Collection`1<RectangleShape> smallBoxes, Collection`1<string> ids);
    private void CyQ=(GeoCanvas canvas, RectangleShape drawingExtent, Collection`1<SimpleCandidate> labelsInAllLayers, ZoomLevel currentZoomLevel, Collection`1<string> columnNames, Collection`1<string> columnNamesForDrawing, WkbFileFeatureSource shapeFileFeatureSource, Collection`1<string> idsToDraw, Collection`1<string> fieldNamesOutsideOfSource);
    private bool 6SM=(int progressPercentage, object userState, int featuresToDraw, int featuresDrawn);
    private static void DSQ=(Collection`1<RectangleShape> smallBoxes, Collection`1<Feature> resultFeatures, Collection`1<string> columnNames);
    private static void DiQ=(Collection`1<RectangleShape> smallBoxes, Collection`1<Feature> resultFeatures, Collection`1<string> columnNames);
    private static void DyQ=(Collection`1<RectangleShape> smallBoxes, Collection`1<Feature> resultFeatures, Collection`1<string> columnNames);
    private void uC8=(GeoCanvas canvas, Collection`1<SimpleCandidate> labelsInAllLayers, ZoomLevel currentZoomLevel, Collection`1<string> columnNames, RectangleShape marginWorldExtent);
    private static BaseShape cRo=(ProjectionConverter projection, BaseShape shape);
}
public class ThinkGeo.Core.WkbFileFeatureSource : FeatureSource {
    [ObfuscationAttribute]
private RectangleShape boundingBox;
    [ObfuscationAttribute]
private int columnCount;
    [ObfuscationAttribute]
private Collection`1<FeatureSourceColumn> columns;
    [ObfuscationAttribute]
private int featureCount;
    [ObfuscationAttribute]
private int headerLength;
    [ObfuscationAttribute]
private FileAccess readWriteMode;
    [ObfuscationAttribute]
private RtreeSpatialIndex spatialIndex;
    [ObfuscationAttribute]
private int version;
    [ObfuscationAttribute]
private WkbFileType wkbFileType;
    [ObfuscationAttribute]
private string wkbPathFilename;
    [ObfuscationAttribute]
private BinaryReader wkbReader;
    [ObfuscationAttribute]
private BinaryWriter wkbWriter;
    [ObfuscationAttribute]
private BinaryReader wkxReader;
    [ObfuscationAttribute]
private BinaryWriter wkxWriter;
    [ObfuscationAttribute]
private static int cacheSize;
    [ObfuscationAttribute]
private long start;
    [ObfuscationAttribute]
private long end;
    [ObfuscationAttribute]
private Byte[] cache;
    [ObfuscationAttribute]
private int simplificationAreaInPixel;
    [ObfuscationAttribute]
private Collection`1<RectangleShape> simplifiedAreas;
    public int SimplificationAreaInPixel { get; public set; }
    public Collection`1<RectangleShape> SimplifiedAreas { get; }
    public FileAccess ReadWriteMode { get; public set; }
    public string WkbPathFilename { get; public set; }
    public WkbFileFeatureSource(string wkbPathFilename);
    public WkbFileFeatureSource(string wkbPathFilename, FileAccess readWriteMode);
    public int get_SimplificationAreaInPixel();
    public void set_SimplificationAreaInPixel(int value);
    public Collection`1<RectangleShape> get_SimplifiedAreas();
    public FileAccess get_ReadWriteMode();
    public void set_ReadWriteMode(FileAccess value);
    public string get_WkbPathFilename();
    public void set_WkbPathFilename(string value);
    public WkbFileType GetWkbFileType();
    protected virtual bool CanGetBoundingBoxQuicklyCore();
    protected virtual bool CanGetCountQuicklyCore();
    protected virtual void CloseCore();
    protected virtual Collection`1<Feature> GetFeaturesOutsideBoundingBoxCore(RectangleShape boundingBox, IEnumerable`1<string> returningColumnNames);
    protected virtual TransactionResult CommitTransactionCore(TransactionBuffer transactions);
    protected virtual Collection`1<Feature> GetAllFeaturesCore(IEnumerable`1<string> returningColumnNames);
    protected virtual RectangleShape GetBoundingBoxCore();
    protected virtual Collection`1<FeatureSourceColumn> GetColumnsCore();
    protected virtual long GetCountCore();
    protected virtual Collection`1<Feature> GetFeaturesByIdsCore(IEnumerable`1<string> ids, IEnumerable`1<string> returningColumnNames);
    protected virtual Collection`1<Feature> GetFeaturesInsideBoundingBoxCore(RectangleShape boundingBox, IEnumerable`1<string> returningColumnNames);
    protected virtual WellKnownType GetFirstFeaturesWellKnownTypeCore();
    protected virtual void OpenCore();
    public Collection`1<string> GetFeatureIdsForDrawing(RectangleShape boundingBox, double screenWidth, double screenHeight);
    protected virtual Collection`1<string> GetFeatureIdsForDrawingCore(RectangleShape boundingBox, double screenWidth, double screenHeight);
    protected virtual Collection`1<string> GetFeatureIdsCore();
    public static void CreateWkbFile(string pathFilename, WkbFileType wkbFileType, IEnumerable`1<FeatureSourceColumn> columns, IEnumerable`1<Feature> features);
    private static void uS8=(WkbFileType wkbFileType, string fileNameOnly, string filePath);
    private long ui8=(string id);
    private long uy8=(string id);
    private Feature vC8=(string id, IEnumerable`1<string> returningColumnNames);
    private void myg=();
}
public enum ThinkGeo.Core.WkbFileType : Enum {
    public int value__;
    public static WkbFileType Point;
    public static WkbFileType Polyline;
    public static WkbFileType Polygon;
    public static WkbFileType Hybrid;
}
public enum ThinkGeo.Core.WkbShapeType : Enum {
    public int value__;
    public static WkbShapeType Point;
    public static WkbShapeType LineString;
    public static WkbShapeType Polygon;
    public static WkbShapeType Multipoint;
    public static WkbShapeType Multiline;
    public static WkbShapeType Multipolygon;
    public static WkbShapeType GeometryCollection;
}
public class ThinkGeo.Core.WmsAsyncLayer : WebBasedAsyncLayer {
    private XmlDocument Bx4=;
    [ObfuscationAttribute]
private string _crs;
    [ObfuscationAttribute]
private String[] _exceptionFormats;
    [ObfuscationAttribute]
private RectangleShape _currentExtent;
    [ObfuscationAttribute]
private WmsOnlineResource[] _wmsRequests;
    [ObfuscationAttribute]
private bool _hasParsedCapabilities;
    [ObfuscationAttribute]
private Collection`1<string> _serverCrsCollection;
    [ObfuscationAttribute]
private Collection`1<string> _serverLayerNames;
    [ObfuscationAttribute]
private Collection`1<string> _serverOutputFormats;
    [ObfuscationAttribute]
private Collection`1<string> _serverFeatureInfoFormats;
    [ObfuscationAttribute]
private Collection`1<string> _serverStyleNames;
    [ObfuscationAttribute]
private string _version;
    [ObfuscationAttribute]
private int _height;
    [ObfuscationAttribute]
private int _width;
    private WmsServerLayer CB4=;
    private Collection`1<WmsServerLayer> CR4=;
    [ObfuscationAttribute]
private Uri _uri;
    [ObfuscationAttribute]
private WmsAxisOrder _axisOrder;
    [ObfuscationAttribute]
private string _hrefNamespace;
    [ObfuscationAttribute]
private String[] _availableHrefNamespace;
    [ObfuscationAttribute]
private bool _fastMode;
    private static object Ch4=;
    [CompilerGeneratedAttribute]
private EventHandler`1<RequestedImageExceptionEventArgs> RequestedImageException;
    [CompilerGeneratedAttribute]
private Collection`1<string> Cx4=;
    [CompilerGeneratedAttribute]
private Collection`1<string> DB4=;
    [CompilerGeneratedAttribute]
private bool DR4=;
    [CompilerGeneratedAttribute]
private string Dh4=;
    [CompilerGeneratedAttribute]
private string Dx4=;
    [CompilerGeneratedAttribute]
private Dictionary`2<string, string> 6B0=;
    [CompilerGeneratedAttribute]
private TimeSpan EB4=;
    public Collection`1<string> ActiveLayerNames { get; }
    public Collection`1<string> ActiveStyleNames { get; }
    public Uri Uri { get; public set; }
    public string Version { get; }
    public bool IsTransparent { get; public set; }
    public string OutputFormat { get; public set; }
    public string Crs { get; public set; }
    public string Exceptions { get; public set; }
    public Dictionary`2<string, string> Parameters { get; }
    public WmsAxisOrder AxisOrder { get; public set; }
    public bool FastMode { get; public set; }
    public TimeSpan CapabilitiesCacheTimeout { get; public set; }
    public bool HasBoundingBox { get; }
    public WmsAsyncLayer(Uri uri);
    public WmsAsyncLayer(Uri uri, IWebProxy webProxy);
    public WmsAsyncLayer(Uri uri, IWebProxy webProxy, string crs, WmsAxisOrder axisOrder, string version, bool fastMode);
    public WmsAsyncLayer(Collection`1<WmsServerLayer> flatWmsServerLayers);
    private static WmsAsyncLayer();
    [CompilerGeneratedAttribute]
public void add_RequestedImageException(EventHandler`1<RequestedImageExceptionEventArgs> value);
    [CompilerGeneratedAttribute]
public void remove_RequestedImageException(EventHandler`1<RequestedImageExceptionEventArgs> value);
    protected virtual void OnRequestedImageException(RequestedImageExceptionEventArgs e);
    [CompilerGeneratedAttribute]
public sealed virtual Collection`1<string> get_ActiveLayerNames();
    [CompilerGeneratedAttribute]
public sealed virtual Collection`1<string> get_ActiveStyleNames();
    public sealed virtual Uri get_Uri();
    public sealed virtual void set_Uri(Uri value);
    public sealed virtual string get_Version();
    [CompilerGeneratedAttribute]
public sealed virtual bool get_IsTransparent();
    [CompilerGeneratedAttribute]
public sealed virtual void set_IsTransparent(bool value);
    [CompilerGeneratedAttribute]
public sealed virtual string get_OutputFormat();
    [CompilerGeneratedAttribute]
public sealed virtual void set_OutputFormat(string value);
    public sealed virtual string get_Crs();
    public sealed virtual void set_Crs(string value);
    [CompilerGeneratedAttribute]
public sealed virtual string get_Exceptions();
    [CompilerGeneratedAttribute]
public sealed virtual void set_Exceptions(string value);
    [CompilerGeneratedAttribute]
public sealed virtual Dictionary`2<string, string> get_Parameters();
    public sealed virtual WmsAxisOrder get_AxisOrder();
    public sealed virtual void set_AxisOrder(WmsAxisOrder value);
    public sealed virtual bool get_FastMode();
    public sealed virtual void set_FastMode(bool value);
    [CompilerGeneratedAttribute]
public sealed virtual TimeSpan get_CapabilitiesCacheTimeout();
    [CompilerGeneratedAttribute]
public sealed virtual void set_CapabilitiesCacheTimeout(TimeSpan value);
    public virtual bool get_HasBoundingBox();
    public Collection`1<WmsServerLayer> GetServerLayers();
    public Collection`1<string> GetServerStyleNames();
    public Collection`1<string> GetServerOutputFormats();
    public Collection`1<string> GetServerCrsCollection();
    public Collection`1<string> GetServerExceptionFormats();
    public string GetServiceVersion();
    public string GetServiceBaseUrl();
    public Collection`1<string> GetServerFeatureInfoFormats();
    public string GetServerCapabilitiesXml();
    public string GetRequestUrl(RectangleShape worldExtent, int canvasWidth, int canvasHeight);
    protected virtual string GetRequestUrlCore(RectangleShape worldExtent, int canvasWidth, int canvasHeight);
    [AsyncStateMachineAttribute("ThinkGeo.Core.WmsAsyncLayer/<OpenAsyncCore>d__83")]
protected virtual Task OpenAsyncCore(CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("ThinkGeo.Core.WmsAsyncLayer/<CloseAsyncCore>d__84")]
protected virtual Task CloseAsyncCore(CancellationToken cancellationToken);
    protected virtual RectangleShape GetBoundingBoxCore();
    [AsyncStateMachineAttribute("ThinkGeo.Core.WmsAsyncLayer/<DrawAsyncCore>d__86")]
protected virtual Task DrawAsyncCore(GeoCanvas canvas, Collection`1<SimpleCandidate> labelsInAllLayers);
    private bool cB0=();
    private static int ER4=(string texts, int fontSize);
    private static string nhQ=(XmlDocument xmlDocument);
    private static string Eh4=(string message, int width);
    private WmsOnlineResource Ex4=();
    private void FB4=();
    private void FR4=(WmsServerLayer serverLayer);
    private void Fh4=(WmsServerLayer serverLayer);
    private void Fx4=(WmsServerLayer serverLayer);
    private void GB4=(WmsServerLayer layer);
    [AsyncStateMachineAttribute("ThinkGeo.Core.WmsAsyncLayer/<ProcessCapabilitiesAsync>d__97")]
private Task GR4=(string url, CancellationToken cancellationToken);
    private static void Gh4=(string requestCapabilities, XmlDocument xmlDocument);
    [AsyncStateMachineAttribute("ThinkGeo.Core.WmsAsyncLayer/<GetCacheXmlAsync>d__99")]
private Task`1<XmlDocument> Gx4=(string requestCapabilities);
    [AsyncStateMachineAttribute("ThinkGeo.Core.WmsAsyncLayer/<GetRemoteXmlAsync>d__100")]
private Task`1<XmlDocument> HB4=(string requestCapabilities, IWebProxy proxy, ICredentials credentials, CancellationToken cancellationToken);
    private void HR4=(XmlDocument xmlDocument, XmlNamespaceManager namespaceManager);
    private static string Hh4=(XmlNode node, string nodeName, XmlNamespaceManager namespaceManager);
    private void Hx4=(XmlNode nodeCapability, XmlNamespaceManager namespaceManager);
    private void IB4=(XmlNode xmlRequestNode, XmlNamespaceManager namespaceManager);
    private WmsServerLayer IR4=(XmlNode xmlLayer, XmlNamespaceManager namespaceManager);
    private XmlAttribute Ih4=(XmlNode xmlNode);
    private RectangleShape Ix4=(XmlNode xmlLayer, XmlNamespaceManager namespaceManager);
    private void JB4=(XmlNode xnException, XmlNamespaceManager namespaceManager);
    private void JR4=(HttpRequestMessage httpRequestMessage);
    private static Collection`1<string> Jh4=(IEnumerable`1<string> collection);
    private static Collection`1<WmsServerLayer> Jh4=(IEnumerable`1<WmsServerLayer> collection);
    private void Jx4=(string propertyName);
    protected virtual string BuildWmsGetFeatureInfoUri(ScreenPointF screenPointF, string infoFormat, int maxFeatures);
    [AsyncStateMachineAttribute("ThinkGeo.Core.WmsAsyncLayer/<GetFeatureInfoAsync>d__114")]
public Task`1<Dictionary`2<string, Collection`1<Feature>>> GetFeatureInfoAsync(ScreenPointF screenPointF, int maxFeatures, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("ThinkGeo.Core.WmsAsyncLayer/<GetFeatureInfoAsync>d__115")]
public Task`1<Dictionary`2<string, Collection`1<Feature>>> GetFeatureInfoAsync(ScreenPointF screenPointF, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("ThinkGeo.Core.WmsAsyncLayer/<GetFeatureInfoAsync>d__116")]
public Task`1<Dictionary`2<string, Collection`1<Feature>>> GetFeatureInfoAsync(ScreenPointF screenPointF, string infoFormat, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("ThinkGeo.Core.WmsAsyncLayer/<GetFeatureInfo>d__117")]
public Task`1<Dictionary`2<string, Collection`1<Feature>>> GetFeatureInfo(ScreenPointF screenPointF, int maxFeatures, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("ThinkGeo.Core.WmsAsyncLayer/<GetFeatureInfoAsync>d__118")]
public Task`1<Dictionary`2<string, Collection`1<Feature>>> GetFeatureInfoAsync(ScreenPointF screenPointF, string infoFormat, int maxFeatures, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("ThinkGeo.Core.WmsAsyncLayer/<GetFeatureInfoAsyncCore>d__119")]
protected virtual Task`1<Dictionary`2<string, Collection`1<Feature>>> GetFeatureInfoAsyncCore(ScreenPointF screenPointF, string infoFormat, int maxFeatures, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("ThinkGeo.Core.WmsAsyncLayer/<DownloadImageAsyncCore>d__120")]
protected virtual Task`1<Byte[]> DownloadImageAsyncCore(double width, double height, double scaleFactor, RectangleShape extent, GeographyUnit mapUnit, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("ThinkGeo.Core.WmsAsyncLayer/<HandleResponseAsync>d__121")]
internal Task`1<Dictionary`2<string, Collection`1<Feature>>> KB4=(HttpRequestMessage request, CancellationToken cancellationToken);
    internal Dictionary`2<string, Collection`1<Feature>> KR4=(XmlDocument xmlDocument);
    [DebuggerHiddenAttribute]
[CompilerGeneratedAttribute]
private Task <>n__0(CancellationToken cancellationToken);
    [CompilerGeneratedAttribute]
[DebuggerHiddenAttribute]
private Task <>n__1(CancellationToken cancellationToken);
}
public enum ThinkGeo.Core.WmsAxisOrder : Enum {
    public int value__;
    public static WmsAxisOrder Default;
    public static WmsAxisOrder XY;
    public static WmsAxisOrder YX;
}
public class ThinkGeo.Core.WmsLayerStyle : object {
    public WmsStyleLegend LengendUrl;
    public WmsOnlineResource StyleSheetUrl;
    [ObfuscationAttribute]
private string mAbstract;
    [ObfuscationAttribute]
private string name;
    [ObfuscationAttribute]
private string title;
    public string Title { get; public set; }
    public string Name { get; public set; }
    unknown string Abstract {public set; }
    public WmsLayerStyle(string name);
    public WmsLayerStyle(string name, string title);
    public string get_Title();
    public void set_Title(string value);
    public string get_Name();
    public void set_Name(string value);
    public void set_Abstract(string value);
}
[ObfuscationAttribute]
public class ThinkGeo.Core.WmsOnlineResource : ValueType {
    [ObfuscationAttribute]
private string onlineResource;
    [ObfuscationAttribute]
private string type;
    public string Type { get; public set; }
    public string OnlineResource { get; public set; }
    public WmsOnlineResource(string onlineResource, string type);
    public string get_Type();
    public void set_Type(string value);
    public string get_OnlineResource();
    public void set_OnlineResource(string value);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
}
public class ThinkGeo.Core.WmsServerLayer : object {
    [ObfuscationAttribute]
private RectangleShape boudingBox;
    [ObfuscationAttribute]
private int cascaded;
    [ObfuscationAttribute]
private WmsServerLayer[] childLayers;
    [ObfuscationAttribute]
private String[] crs;
    [ObfuscationAttribute]
private int fixedHeight;
    [ObfuscationAttribute]
private int fixedWidth;
    [ObfuscationAttribute]
private String[] keyWords;
    [ObfuscationAttribute]
private string mAbstract;
    [ObfuscationAttribute]
private double maxScale;
    [ObfuscationAttribute]
private double minScale;
    [ObfuscationAttribute]
private string name;
    [ObfuscationAttribute]
private bool noSubsets;
    [ObfuscationAttribute]
private bool opaque;
    [ObfuscationAttribute]
private bool queryable;
    [ObfuscationAttribute]
private WmsLayerStyle[] styles;
    [ObfuscationAttribute]
private string title;
    public int Cascaded { get; public set; }
    public double MinScale { get; public set; }
    public double MaxScale { get; public set; }
    public string Title { get; public set; }
    public string Name { get; public set; }
    public string Abstract { get; public set; }
    public bool Queryable { get; public set; }
    public bool Opaque { get; public set; }
    public bool NoSubsets { get; public set; }
    public int FixedWidth { get; public set; }
    public int FixedHeight { get; public set; }
    public String[] KeyWords { get; public set; }
    public WmsLayerStyle[] Styles { get; public set; }
    public String[] Crs { get; public set; }
    public WmsServerLayer[] ChildLayers { get; public set; }
    public RectangleShape BoudingBox { get; public set; }
    public int get_Cascaded();
    public void set_Cascaded(int value);
    public double get_MinScale();
    public void set_MinScale(double value);
    public double get_MaxScale();
    public void set_MaxScale(double value);
    public string get_Title();
    public void set_Title(string value);
    public string get_Name();
    public void set_Name(string value);
    public string get_Abstract();
    public void set_Abstract(string value);
    public bool get_Queryable();
    public void set_Queryable(bool value);
    public bool get_Opaque();
    public void set_Opaque(bool value);
    public bool get_NoSubsets();
    public void set_NoSubsets(bool value);
    public int get_FixedWidth();
    public void set_FixedWidth(int value);
    public int get_FixedHeight();
    public void set_FixedHeight(int value);
    public String[] get_KeyWords();
    public void set_KeyWords(String[] value);
    public WmsLayerStyle[] get_Styles();
    public void set_Styles(WmsLayerStyle[] value);
    public String[] get_Crs();
    public void set_Crs(String[] value);
    public WmsServerLayer[] get_ChildLayers();
    public void set_ChildLayers(WmsServerLayer[] value);
    public RectangleShape get_BoudingBox();
    public void set_BoudingBox(RectangleShape value);
    public WmsServerLayer Clone();
}
public class ThinkGeo.Core.WmsStyleLegend : ValueType {
    [ObfuscationAttribute]
private int height;
    [ObfuscationAttribute]
private int width;
    public WmsOnlineResource OnlineResource;
    unknown int Width {public set; }
    unknown int Height {public set; }
    public void set_Width(int value);
    public void set_Height(int value);
}
public enum ThinkGeo.Core.WmsTileType : Enum {
    public int value__;
    public static WmsTileType Default;
    public static WmsTileType MultiTile;
    public static WmsTileType SingleTile;
}
public static class ThinkGeo.Core.WmsUtil : object {
    public static string VERSION_1_3_0;
    public static string VERSION_1_1_1;
    public static string GetMap;
    private static WmsUtil();
    public static WmsAxisOrder GetAxisOrder(WmsAxisOrder axisOrder, string wmsVersion, string crs);
    public static WmsOnlineResource GetBaseUrl(WmsOnlineResource[] wmsRequests);
    public static string GetRequestUrl(IWmsEntity wmsRasterSource, string baseUrl, RectangleShape worldExtent, int canvasWidth, int canvasHeight);
    private static bool cB0=(string version);
    private static Dictionary`2<string, string> cR0=(string query);
}
public class ThinkGeo.Core.WmtsAsyncLayer : XyzTileAsyncLayer {
    [ObfuscationAttribute]
private Collection`1<Uri> serverUris;
    [ObfuscationAttribute]
private Uri serverUri;
    [ObfuscationAttribute]
private Dictionary`2<string, WmtsTileMatrixSet> tileMatrixSets;
    [ObfuscationAttribute]
private Collection`1<WmtsServerLayer> wmtsServerLayers;
    [ObfuscationAttribute]
private string activeLayerName;
    [ObfuscationAttribute]
private string activeStyleName;
    [ObfuscationAttribute]
private WmtsServerEncodingType wmtsServerEncodingType;
    [ObfuscationAttribute]
private string tileMatrixSetName;
    [ObfuscationAttribute]
private Dictionary`2<string, string> parameters;
    [ObfuscationAttribute]
private string outputFormat;
    [ObfuscationAttribute]
private double lowerScale;
    [ObfuscationAttribute]
private double upperScale;
    [ObfuscationAttribute]
private XmlDocument xmlDoc;
    [ObfuscationAttribute]
private TimeSpan capabilitesCacheTimeout;
    [ObfuscationAttribute]
private double wmtsConversionFactorForMeter;
    [ObfuscationAttribute]
private Dictionary`2<string, string> dimensions;
    [ObfuscationAttribute]
private WmtsAxisOrder axisOrder;
    [ObfuscationAttribute]
private RasterTileCache projectedTileCache;
    [ObfuscationAttribute]
private bool isCacheOnly;
    [ObfuscationAttribute]
private Dictionary`2<WmtsServerEncodingType, string> getTileEncodingTypes;
    [ObsoleteAttribute("This property is obsoleted and will be removed after v14.4. Please use ServerUri instead.")]
public Collection`1<Uri> ServerUris { get; }
    public Uri ServerUri { get; public set; }
    private Dictionary`2<string, string> LB4= { get; private set; }
    public TimeSpan CapabilitesCacheTimeout { get; public set; }
    public string ActiveLayerName { get; public set; }
    public WmtsServerEncodingType WmtsServerEncodingType { get; public set; }
    public Collection`1<WmtsServerLayer> WmtsServerLayers { get; public set; }
    public string ActiveStyleName { get; public set; }
    public Dictionary`2<string, string> Parameters { get; }
    public string OutputFormat { get; public set; }
    public double LowerScale { get; public set; }
    public double UpperScale { get; public set; }
    public string TileMatrixSetName { get; public set; }
    public WmtsAxisOrder AxisOrder { get; public set; }
    [ObsoleteAttribute("This property is obsoleted and will be removed after v14.3. Please use ProjectionConverterFromServerProjection instead. ")]
public ProjectionConverter ProjectionConverter { get; public set; }
    public RasterTileCache ProjectedTileCache { get; public set; }
    public bool IsCacheOnly { get; public set; }
    public Dictionary`2<string, WmtsTileMatrixSet> TileMatrixSets { get; }
    public bool HasBoundingBox { get; }
    public WmtsAsyncLayer(Uri serverUri);
    public WmtsAsyncLayer(Uri serverUri, IWebProxy webProxy);
    public WmtsAsyncLayer(Uri serverUri, IWebProxy webProxy, WmtsServerEncodingType wmtsServerEncodingType);
    public Collection`1<Uri> get_ServerUris();
    public Uri get_ServerUri();
    public void set_ServerUri(Uri value);
    private Dictionary`2<string, string> Kh4=();
    private void Kx4=(Dictionary`2<string, string> value);
    public TimeSpan get_CapabilitesCacheTimeout();
    public void set_CapabilitesCacheTimeout(TimeSpan value);
    public string get_ActiveLayerName();
    public void set_ActiveLayerName(string value);
    public WmtsServerEncodingType get_WmtsServerEncodingType();
    public void set_WmtsServerEncodingType(WmtsServerEncodingType value);
    public Collection`1<WmtsServerLayer> get_WmtsServerLayers();
    public void set_WmtsServerLayers(Collection`1<WmtsServerLayer> value);
    public string get_ActiveStyleName();
    public void set_ActiveStyleName(string value);
    public Dictionary`2<string, string> get_Parameters();
    public string get_OutputFormat();
    public void set_OutputFormat(string value);
    public double get_LowerScale();
    public void set_LowerScale(double value);
    public double get_UpperScale();
    public void set_UpperScale(double value);
    public string get_TileMatrixSetName();
    public void set_TileMatrixSetName(string value);
    public WmtsAxisOrder get_AxisOrder();
    public void set_AxisOrder(WmtsAxisOrder value);
    public ProjectionConverter get_ProjectionConverter();
    public void set_ProjectionConverter(ProjectionConverter value);
    public RasterTileCache get_ProjectedTileCache();
    public void set_ProjectedTileCache(RasterTileCache value);
    public bool get_IsCacheOnly();
    public void set_IsCacheOnly(bool value);
    public Dictionary`2<string, WmtsTileMatrixSet> get_TileMatrixSets();
    [AsyncStateMachineAttribute("ThinkGeo.Core.WmtsAsyncLayer/<OpenAsyncCore>d__75")]
protected virtual Task OpenAsyncCore(CancellationToken cancellationToken);
    public virtual bool get_HasBoundingBox();
    public RectangleShape GetWGS84BoundingBox();
    protected virtual RectangleShape GetBoundingBoxCore();
    public Collection`1<Uri> GetRequestUris(RectangleShape requestExtent, int canvasWidth, int canvasHeight);
    protected virtual Collection`1<Uri> GetRequestUrisCore(RectangleShape requestExtent, int canvasWidth, int canvasHeight);
    public string GetServerCapabilitiesXml();
    public Collection`1<string> GetServerLayerNames();
    public Collection`1<string> GetServerLayerStyles();
    public Collection`1<string> GetServerTileMatrixSetNames();
    public Collection`1<WmtsServerEncodingType> GetServerEncodingType();
    public Collection`1<string> GetLayerOutputFormats(string layerName);
    protected virtual Task CloseAsyncCore(CancellationToken cancellationToken);
    private Uri qR0=();
    private Tuple`2<string, string> LR4=();
    [AsyncStateMachineAttribute("ThinkGeo.Core.WmtsAsyncLayer/<GetCapabilitiesAsync>d__91")]
private Task Lh4=(CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("ThinkGeo.Core.WmtsAsyncLayer/<LoadCapabilities>d__92")]
private Task`1<bool> Lx4=(string kvpUrl, CancellationToken cancellationToken);
    public bool RemoveCachedCapability();
    private string MB4=();
    private void HR4=(XmlElement element, XmlNamespaceManager namespaceManager);
    private void MR4=(XmlNode operationTileNode, XmlNamespaceManager namespaceManager);
    public ZoomLevelSet GetZoomLevelSet(string tileMatrixSetName);
    public TileMatrix GetTileMatrix(string tileMatrixSetName, double scale);
    private void Mh4=(XmlNode node, XmlNamespaceManager namespaceManager);
    private void Mx4=(T& left, T& top);
    private void NB4=(XmlNode node, XmlNamespaceManager namespaceManager);
    [AsyncStateMachineAttribute("ThinkGeo.Core.WmtsAsyncLayer/<DrawAsyncCore>d__102")]
protected virtual Task DrawAsyncCore(GeoCanvas canvas, Collection`1<SimpleCandidate> labelsInAllLayers);
    private int NR4=(double newWidth, RectangleShape newTileExtent, GeographyUnit mapUnit);
    protected virtual void DrawExceptionCore(GeoCanvas canvas, Exception e);
    private string Nh4=(WmtsServerLayer serverLayer, string zoomLevel, long y, long x, string tileMatrixSetName, int resourceURLIndex);
    public string GetRequestUri(long x, long y, int zoomLevel);
    private string Nx4=(string requestString);
    [AsyncStateMachineAttribute("ThinkGeo.Core.WmtsAsyncLayer/<GetCloudRasterTileInfoAsync>d__108")]
private Task`1<CloudRasterTileInfo> OB4=(MatrixCell cell, int zoomLevelIndex, int tileSize, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("ThinkGeo.Core.WmtsAsyncLayer/<GetTileAsync>d__109")]
private Task`1<RasterTile> OR4=(int zoomLevel, long x, long y, CancellationToken cancellationToken);
    protected virtual Task`1<string> GetImageUriAsyncCore(int zoomLevel, long x, long y, float resolutionFactor);
    [DebuggerHiddenAttribute]
[CompilerGeneratedAttribute]
private Task <>n__0(CancellationToken cancellationToken);
    [CompilerGeneratedAttribute]
private bool <GetWGS84BoundingBox>b__78_0(WmtsServerLayer l);
    [CompilerGeneratedAttribute]
private bool <GetBoundingBoxCore>b__79_0(WmtsServerLayer l);
    [CompilerGeneratedAttribute]
private bool <GetRequestUri>b__106_1(WmtsServerLayer l);
}
public enum ThinkGeo.Core.WmtsAxisOrder : Enum {
    public int value__;
    public static WmtsAxisOrder XY;
    public static WmtsAxisOrder YX;
}
public class ThinkGeo.Core.WmtsDimension : object {
    [ObfuscationAttribute]
private string defaultValue;
    [ObfuscationAttribute]
private string identifier;
    [ObfuscationAttribute]
private Collection`1<string> values;
    public string DefaultValue { get; public set; }
    public string Identifier { get; public set; }
    public Collection`1<string> Values { get; }
    public string get_DefaultValue();
    public void set_DefaultValue(string value);
    public string get_Identifier();
    public void set_Identifier(string value);
    public Collection`1<string> get_Values();
}
public class ThinkGeo.Core.WmtsRowColumnRange : object {
    [ObfuscationAttribute]
private double minTileRow;
    [ObfuscationAttribute]
private double maxTileRow;
    [ObfuscationAttribute]
private double minTileColumn;
    [ObfuscationAttribute]
private double maxTileColumn;
    [ObfuscationAttribute]
private string id;
    public double MinTileRow { get; }
    public double MaxTileRow { get; }
    public double MinTileColumn { get; }
    public double MaxTileColumn { get; }
    public string Id { get; }
    public WmtsRowColumnRange(string id, double minTileRow, double maxTileRow, double minTileColumn, double maxTileColumn);
    public double get_MinTileRow();
    public double get_MaxTileRow();
    public double get_MinTileColumn();
    public double get_MaxTileColumn();
    public string get_Id();
}
public enum ThinkGeo.Core.WmtsServerEncodingType : Enum {
    public int value__;
    public static WmtsServerEncodingType Kvp;
    public static WmtsServerEncodingType Restful;
    public static WmtsServerEncodingType Unknown;
}
public class ThinkGeo.Core.WmtsServerLayer : object {
    [ObfuscationAttribute]
private string name;
    [ObfuscationAttribute]
private RectangleShape wgs84BoundingBox;
    [ObfuscationAttribute]
private RectangleShape boundingBox;
    [ObfuscationAttribute]
private string style;
    [ObfuscationAttribute]
private Collection`1<string> formats;
    [ObfuscationAttribute]
private String[] infoFormats;
    [ObfuscationAttribute]
private String[] tileMatrixLinkNames;
    [ObfuscationAttribute]
private Collection`1<WmtsRowColumnRange> rowColumnRange;
    [ObfuscationAttribute]
private WmtsURLTemplate[] resourceURL;
    [ObfuscationAttribute]
private WmtsDimension[] dimension;
    public string Name { get; public set; }
    public RectangleShape WGS84BoundingBox { get; public set; }
    public RectangleShape BoundingBox { get; public set; }
    public string Style { get; public set; }
    public Collection`1<string> Formats { get; public set; }
    public Collection`1<WmtsRowColumnRange> RowColumnRange { get; public set; }
    public String[] InfoFormats { get; public set; }
    public String[] TileMatrixLinkNames { get; public set; }
    public WmtsDimension[] Dimension { get; public set; }
    public WmtsURLTemplate[] ResourceURL { get; public set; }
    public string get_Name();
    public void set_Name(string value);
    public RectangleShape get_WGS84BoundingBox();
    public void set_WGS84BoundingBox(RectangleShape value);
    public RectangleShape get_BoundingBox();
    public void set_BoundingBox(RectangleShape value);
    public string get_Style();
    public void set_Style(string value);
    public Collection`1<string> get_Formats();
    public void set_Formats(Collection`1<string> value);
    public Collection`1<WmtsRowColumnRange> get_RowColumnRange();
    public void set_RowColumnRange(Collection`1<WmtsRowColumnRange> value);
    public String[] get_InfoFormats();
    public void set_InfoFormats(String[] value);
    public String[] get_TileMatrixLinkNames();
    public void set_TileMatrixLinkNames(String[] value);
    public WmtsDimension[] get_Dimension();
    public void set_Dimension(WmtsDimension[] value);
    public WmtsURLTemplate[] get_ResourceURL();
    public void set_ResourceURL(WmtsURLTemplate[] value);
}
[ObsoleteAttribute("This type is obsoleted and will be removed after v14.4. Please use WmtsServerEncodingType instead")]
public enum ThinkGeo.Core.WmtsSeverEncodingType : Enum {
    public int value__;
    public static WmtsSeverEncodingType Kvp;
    public static WmtsSeverEncodingType Restful;
    [ObsoleteAttribute("This property is obsoleted and will be removed after v14.4. In most cases, you don't need to specify the WmtsServerEncodingType.")]
public static WmtsSeverEncodingType KvpRestful;
    public static WmtsSeverEncodingType Unknown;
}
public class ThinkGeo.Core.WmtsTileMatrixSet : object {
    [ObfuscationAttribute]
private string id;
    [ObfuscationAttribute]
private string crs;
    [ObfuscationAttribute]
private RectangleShape boundingBox;
    [ObfuscationAttribute]
private Collection`1<TileMatrix> tileMatrices;
    public Collection`1<TileMatrix> TileMatrices { get; }
    public string Id { get; public set; }
    public string Crs { get; public set; }
    public RectangleShape BoundingBox { get; public set; }
    public WmtsTileMatrixSet(string id, string crs);
    public Collection`1<TileMatrix> get_TileMatrices();
    public string get_Id();
    public void set_Id(string value);
    public string get_Crs();
    public void set_Crs(string value);
    public RectangleShape get_BoundingBox();
    public void set_BoundingBox(RectangleShape value);
}
public class ThinkGeo.Core.WmtsURLTemplate : object {
    [ObfuscationAttribute]
private string format;
    [ObfuscationAttribute]
private string resourceType;
    [ObfuscationAttribute]
private string template;
    public string Format { get; public set; }
    public string ResourceType { get; public set; }
    public string Template { get; public set; }
    public string get_Format();
    public void set_Format(string value);
    public string get_ResourceType();
    public void set_ResourceType(string value);
    public string get_Template();
    public void set_Template(string value);
}
public class ThinkGeo.Core.WorldFile : object {
    [ObfuscationAttribute]
private float horizontalResolution;
    [ObfuscationAttribute]
private float rotationRow;
    [ObfuscationAttribute]
private float rotationColumn;
    [ObfuscationAttribute]
private float verticalResolution;
    [ObfuscationAttribute]
private float upperLeftX;
    [ObfuscationAttribute]
private float upperLeftY;
    public float HorizontalResolution { get; }
    public float RotationRow { get; }
    public float RotationColumn { get; }
    public float VerticalResolution { get; }
    public float UpperLeftX { get; }
    public float UpperLeftY { get; }
    public WorldFile(string worldFileText);
    public WorldFile(RectangleShape worldExtent, float imageWidth, float imageHeight);
    public WorldFile(double horizontalResolution, double rotationRow, double rotationColumn, double verticalResolution, double upperLeftX, double upperLeftY);
    public WorldFile(float horizontalResolution, float rotationRow, float rotationColumn, float verticalResolution, float upperLeftX, float upperLeftY);
    public float get_HorizontalResolution();
    public float get_RotationRow();
    public float get_RotationColumn();
    public float get_VerticalResolution();
    public float get_UpperLeftX();
    public float get_UpperLeftY();
    public RectangleShape GetBoundingBox(float width, float height);
    public void Save(string pathFilename);
}
public class ThinkGeo.Core.WorldLabelingCandidate : LabelingCandidate {
    [ObfuscationAttribute]
private PointShape centerPointInWorldCoordinates;
    public PointShape CenterPointInWorldCoordinates { get; public set; }
    public WorldLabelingCandidate(string originalText);
    public WorldLabelingCandidate(string originalText, PointShape centerPointInWorldCoordinates);
    public PointShape get_CenterPointInWorldCoordinates();
    public void set_CenterPointInWorldCoordinates(PointShape value);
}
public enum ThinkGeo.Core.WrappingMode : Enum {
    public int value__;
    public static WrappingMode None;
    public static WrappingMode WrapDateline;
}
public enum ThinkGeo.Core.WrappingWorldDirection : Enum {
    public int value__;
    public static WrappingWorldDirection West;
    public static WrappingWorldDirection East;
}
internal class ThinkGeo.Core.XmlGeoSerializationFormatter : GeoSerializationFormatter {
    protected virtual void SaveCore(GeoObjectModel model, Stream stream);
    protected virtual GeoObjectModel LoadCore(Stream stream);
    private void Save(GeoObjectNode node, XmlWriter xmlWriter);
    private static void RemoveRedundant(GeoObjectNode node);
    private static GeoObjectNode Load(XmlReader xmlReader);
}
public abstract class ThinkGeo.Core.XyzTileAsyncLayer : WebBasedAsyncLayer {
    [ObfuscationAttribute]
private RasterTileCache tileCache;
    [ObfuscationAttribute]
private RasterTileCache projectedTileCache;
    [ObfuscationAttribute]
private ProjectionConverter projectionConverterFromServerProjection;
    [ObfuscationAttribute]
private int cloudTileWidth;
    [ObfuscationAttribute]
private int cloudTileHeight;
    [ObfuscationAttribute]
private RectangleShape maxExtent;
    [ObfuscationAttribute]
private GeographyUnit cloudTileMapUnit;
    public int TileWidth { get; protected set; }
    public int TileHeight { get; protected set; }
    public GeographyUnit MapUnit { get; protected set; }
    public RectangleShape MaxExtent { get; protected set; }
    public RasterTileCache TileCache { get; public set; }
    public RasterTileCache ProjectedTileCache { get; public set; }
    public ProjectionConverter ProjectionConverterFromServerProjection { get; public set; }
    public XyzTileAsyncLayer(int tileSize, GeographyUnit mapUnit, RectangleShape maxExtent);
    public int get_TileWidth();
    protected void set_TileWidth(int value);
    public int get_TileHeight();
    protected void set_TileHeight(int value);
    public GeographyUnit get_MapUnit();
    protected void set_MapUnit(GeographyUnit value);
    public RectangleShape get_MaxExtent();
    protected void set_MaxExtent(RectangleShape value);
    public virtual RasterTileCache get_TileCache();
    public virtual void set_TileCache(RasterTileCache value);
    public virtual RasterTileCache get_ProjectedTileCache();
    public virtual void set_ProjectedTileCache(RasterTileCache value);
    public virtual ProjectionConverter get_ProjectionConverterFromServerProjection();
    public virtual void set_ProjectionConverterFromServerProjection(ProjectionConverter value);
    [AsyncStateMachineAttribute("ThinkGeo.Core.XyzTileAsyncLayer/<GetImageUriAsync>d__30")]
public Task`1<string> GetImageUriAsync(int zoomLevel, long x, long y, float resolutionFactor);
    protected abstract virtual Task`1<string> GetImageUriAsyncCore(int zoomLevel, long x, long y, float resolutionFactor);
    protected virtual Task OpenAsyncCore(CancellationToken cancellationToken);
    protected virtual Task CloseAsyncCore(CancellationToken cancellationToken);
    protected virtual int GetTileScale();
    [AsyncStateMachineAttribute("ThinkGeo.Core.XyzTileAsyncLayer/<DrawAsyncCore>d__35")]
protected virtual Task DrawAsyncCore(GeoCanvas canvas, Collection`1<SimpleCandidate> labelsInAllLayers);
    private static Dictionary`2<ValueTuple`2<long, long>, MatrixCell> Oh4=(TileMatrix tileMatrix, RectangleShape requestedExtent, WrappingMode wrapDateline);
    protected virtual RectangleShape GetBoundingBoxCore();
    [AsyncStateMachineAttribute("ThinkGeo.Core.XyzTileAsyncLayer/<GetTileAsync>d__38")]
private Task`1<RasterTile> OR4=(int zoomLevel, long x, long y, float resolutionFactor, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("ThinkGeo.Core.XyzTileAsyncLayer/<GetCloudRasterTileInfoAsync>d__39")]
private Task`1<CloudRasterTileInfo> OB4=(MatrixCell cell, int zoomLevelIndex, float scaleFactor, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("ThinkGeo.Core.XyzTileAsyncLayer/<DownloadImageAsync>d__40")]
public Task`1<Byte[]> DownloadImageAsync(int zoomLevelIndex, long column, long row, float scaleFactor, CancellationToken cancellationToken);
}
public class ThinkGeo.Core.ZoomLevel : object {
    [ObfuscationAttribute]
private string name;
    [ObfuscationAttribute]
private double scale;
    [ObfuscationAttribute]
private bool isActive;
    [ObfuscationAttribute]
private ApplyUntilZoomLevel applyUntilZoomLevel;
    [ObfuscationAttribute]
private TextStyle defaultTextStyle;
    [ObfuscationAttribute]
private AreaStyle defaultAreaStyle;
    [ObfuscationAttribute]
private LineStyle defaultLineStyle;
    [ObfuscationAttribute]
private PointStyle defaultPointStyle;
    [ObfuscationAttribute]
private Collection`1<Style> customStyles;
    [ObfuscationAttribute]
private GeoColor backgroundColor;
    [ObfuscationAttribute]
private bool useLegacyLabeling;
    public bool IsActive { get; public set; }
    public double Scale { get; public set; }
    public AreaStyle DefaultAreaStyle { get; public set; }
    public LineStyle DefaultLineStyle { get; public set; }
    public PointStyle DefaultPointStyle { get; public set; }
    public TextStyle DefaultTextStyle { get; public set; }
    public ApplyUntilZoomLevel ApplyUntilZoomLevel { get; public set; }
    public string Name { get; public set; }
    public Collection`1<Style> CustomStyles { get; }
    internal GeoColor 8h8= { get; internal set; }
    public bool UseLegacyLabeling { get; public set; }
    internal bool fBU= { get; }
    public ZoomLevel(double scale);
    public bool get_IsActive();
    public void set_IsActive(bool value);
    public double get_Scale();
    public void set_Scale(double value);
    public AreaStyle get_DefaultAreaStyle();
    public void set_DefaultAreaStyle(AreaStyle value);
    public LineStyle get_DefaultLineStyle();
    public void set_DefaultLineStyle(LineStyle value);
    public PointStyle get_DefaultPointStyle();
    public void set_DefaultPointStyle(PointStyle value);
    public TextStyle get_DefaultTextStyle();
    public void set_DefaultTextStyle(TextStyle value);
    public ApplyUntilZoomLevel get_ApplyUntilZoomLevel();
    public void set_ApplyUntilZoomLevel(ApplyUntilZoomLevel value);
    public string get_Name();
    public void set_Name(string value);
    public Collection`1<Style> get_CustomStyles();
    internal GeoColor 8B8=();
    internal void 8R8=(GeoColor value);
    public bool get_UseLegacyLabeling();
    public void set_UseLegacyLabeling(bool value);
    public Collection`1<string> GetRequiredColumnNames();
    public void Draw(GeoCanvas canvas, IEnumerable`1<Feature> features, Collection`1<SimpleCandidate> currentLayerLabels, Collection`1<SimpleCandidate> allLayerLabels);
    public void Draw(GeoCanvas canvas, IEnumerable`1<BaseShape> shapes, Collection`1<SimpleCandidate> currentLayerLabels, Collection`1<SimpleCandidate> allLayerLabels);
    public bool HasValidStyles();
    protected virtual void DrawCore(GeoCanvas canvas, IEnumerable`1<Feature> features, Collection`1<SimpleCandidate> currentLayerLabels, Collection`1<SimpleCandidate> allLayerLabels);
    internal bool ehU=();
    private static void 8x8=(Style style, Collection`1<string> columnNames);
    private static Collection`1<Collection`1<Feature>> 9B8=(IEnumerable`1<Feature> allFeatures);
}
public class ThinkGeo.Core.ZoomLevelSet : object {
    private static int 9R8=;
    private static float 9h8=;
    [ObfuscationAttribute]
private string name;
    [ObfuscationAttribute]
private ZoomLevel zoomLevel01;
    [ObfuscationAttribute]
private ZoomLevel zoomLevel02;
    [ObfuscationAttribute]
private ZoomLevel zoomLevel03;
    [ObfuscationAttribute]
private ZoomLevel zoomLevel04;
    [ObfuscationAttribute]
private ZoomLevel zoomLevel05;
    [ObfuscationAttribute]
private ZoomLevel zoomLevel06;
    [ObfuscationAttribute]
private ZoomLevel zoomLevel07;
    [ObfuscationAttribute]
private ZoomLevel zoomLevel08;
    [ObfuscationAttribute]
private ZoomLevel zoomLevel09;
    [ObfuscationAttribute]
private ZoomLevel zoomLevel10;
    [ObfuscationAttribute]
private ZoomLevel zoomLevel11;
    [ObfuscationAttribute]
private ZoomLevel zoomLevel12;
    [ObfuscationAttribute]
private ZoomLevel zoomLevel13;
    [ObfuscationAttribute]
private ZoomLevel zoomLevel14;
    [ObfuscationAttribute]
private ZoomLevel zoomLevel15;
    [ObfuscationAttribute]
private ZoomLevel zoomLevel16;
    [ObfuscationAttribute]
private ZoomLevel zoomLevel17;
    [ObfuscationAttribute]
private ZoomLevel zoomLevel18;
    [ObfuscationAttribute]
private ZoomLevel zoomLevel19;
    [ObfuscationAttribute]
private ZoomLevel zoomLevel20;
    [ObfuscationAttribute]
private Collection`1<ZoomLevel> customZoomLevels;
    [CompilerGeneratedAttribute]
private int /x0=;
    [CompilerGeneratedAttribute]
private RectangleShape PB0=;
    public int TileSize { get; public set; }
    public RectangleShape MaxExtent { get; public set; }
    public string Name { get; public set; }
    public Collection`1<ZoomLevel> CustomZoomLevels { get; }
    public ZoomLevel ZoomLevel01 { get; }
    public ZoomLevel ZoomLevel02 { get; }
    public ZoomLevel ZoomLevel03 { get; }
    public ZoomLevel ZoomLevel04 { get; }
    public ZoomLevel ZoomLevel05 { get; }
    public ZoomLevel ZoomLevel06 { get; }
    public ZoomLevel ZoomLevel07 { get; }
    public ZoomLevel ZoomLevel08 { get; }
    public ZoomLevel ZoomLevel09 { get; }
    public ZoomLevel ZoomLevel10 { get; }
    public ZoomLevel ZoomLevel11 { get; }
    public ZoomLevel ZoomLevel12 { get; }
    public ZoomLevel ZoomLevel13 { get; }
    public ZoomLevel ZoomLevel14 { get; }
    public ZoomLevel ZoomLevel15 { get; }
    public ZoomLevel ZoomLevel16 { get; }
    public ZoomLevel ZoomLevel17 { get; }
    public ZoomLevel ZoomLevel18 { get; }
    public ZoomLevel ZoomLevel19 { get; }
    public ZoomLevel ZoomLevel20 { get; }
    public ZoomLevelSet(int tileSize);
    public ZoomLevelSet(int tileSize, RectangleShape maxExtent);
    public ZoomLevelSet(int tileSize, RectangleShape maxExtent, GeographyUnit maxExtentUnit);
    [CompilerGeneratedAttribute]
public int get_TileSize();
    [CompilerGeneratedAttribute]
public void set_TileSize(int value);
    [CompilerGeneratedAttribute]
public RectangleShape get_MaxExtent();
    [CompilerGeneratedAttribute]
public void set_MaxExtent(RectangleShape value);
    public string get_Name();
    public void set_Name(string value);
    public Collection`1<ZoomLevel> get_CustomZoomLevels();
    public ZoomLevel get_ZoomLevel01();
    public ZoomLevel get_ZoomLevel02();
    public ZoomLevel get_ZoomLevel03();
    public ZoomLevel get_ZoomLevel04();
    public ZoomLevel get_ZoomLevel05();
    public ZoomLevel get_ZoomLevel06();
    public ZoomLevel get_ZoomLevel07();
    public ZoomLevel get_ZoomLevel08();
    public ZoomLevel get_ZoomLevel09();
    public ZoomLevel get_ZoomLevel10();
    public ZoomLevel get_ZoomLevel11();
    public ZoomLevel get_ZoomLevel12();
    public ZoomLevel get_ZoomLevel13();
    public ZoomLevel get_ZoomLevel14();
    public ZoomLevel get_ZoomLevel15();
    public ZoomLevel get_ZoomLevel16();
    public ZoomLevel get_ZoomLevel17();
    public ZoomLevel get_ZoomLevel18();
    public ZoomLevel get_ZoomLevel19();
    public ZoomLevel get_ZoomLevel20();
    public void Load(string styleJsonPath);
    public void Load(Uri styleJsonUri);
    public ZoomLevel GetZoomLevel(RectangleShape extent, double screenWidth, GeographyUnit mapUnit);
    public ZoomLevel GetZoomLevel(RectangleShape extent, double screenWidth, GeographyUnit mapUnit, float dpi);
    public ZoomLevel GetZoomLevelForDrawing(RectangleShape extent, double screenWidth, GeographyUnit mapUnit, float dpi);
    public ZoomLevel GetZoomLevelForDrawing(double currentScale);
    public ZoomLevel GetZoomLevelForDrawing(RectangleShape extent, double screenWidth, GeographyUnit mapUnit);
    public Collection`1<ZoomLevel> GetZoomLevels();
    public static double GetLowerZoomLevelScale(double currentScale, ZoomLevelSet zoomLevelSet);
    public static double GetHigherZoomLevelScale(double currentScale, ZoomLevelSet zoomLevelSet);
    private double 9x8=(ZoomLevel zoomLevel);
    public ZoomLevel GetDefaultZoomLevelByIndex(int zoomLevelIndex);
}
public enum ThinkGeo.Core.ZoomLevelSnappingMode : Enum {
    public int value__;
    public static ZoomLevelSnappingMode Default;
    public static ZoomLevelSnappingMode SnapUp;
    public static ZoomLevelSnappingMode SnapDown;
    public static ZoomLevelSnappingMode SnapToClosest;
    public static ZoomLevelSnappingMode None;
}
public enum ThinkGeo.Core.ZoomSnapDirection : Enum {
    public int value__;
    public static ZoomSnapDirection UpperScale;
    public static ZoomSnapDirection LowerScale;
}
