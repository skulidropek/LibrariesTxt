internal class HRU=./B8= : ValueType {
    public UInt32 /R8=;
    public ushort /h8=;
    public ushort 3x8=;
    public bool pBw=(BinaryReader r);
    public bool shw=(BinaryWriter w);
    public virtual string ToString();
}
internal class HRU=./Bk= : jBo= {
    internal double thc=;
    internal double txc=;
    internal double QRk=;
    internal double Qhk=;
    internal /Bk=(string id, string desc);
    private void 9xg=();
    internal virtual whg= /Bg=(whg= pjConsts, Int32& pj_Error);
    internal virtual void Axk=(mhg= lp, whg= pjConsts, TRg= fac, Int32& pj_Error);
    internal virtual mhg= ARk=(mRo= xy, whg= pjConsts, Int32& pj_Error);
    internal virtual mRo= Ahk=(mhg= lp, whg= pjConsts, Int32& pj_Error);
}
internal class HRU=./Co= : CyU= {
    private ySg= /So=;
    private string /io=;
    private int /yo=;
    private ySg= ACs=;
    private string ASs=;
    private int Ais=;
    private CCk= Ays=;
    private int BCs=;
    private Int32[] BSs=;
    private Int32[] Bis=;
    private PCc= HiY=;
    private void Bys=();
    private Byte[] CCs=(iSg= poFeature, int nFieldNo, vig= eType, int nIndexNo);
    public int Lh8=(string pszViewName, ySg= poMainTable, ySg= poRelTable, string pszMainFieldName, string pszRelFieldName, List`1<string> papszSelectedFields);
    public int CSs=();
    public PCc= Cis=();
    public vig= Cys=(int nFieldId);
    public iSg= 0CE=(int nFeatureId);
    public int DCs=(iSg= poFeature, int nFeatureIds);
    public int DSs=(PCc= poFeatureDefn);
    public int Dis=(string pszName, vig= eMapInfoType, int nWidth, int nPrecision, bool bIndexed, bool bUnique);
    public int Dys=(int nFieldId);
    public bool ECs=(int nFieldId);
    public bool ESs=(int nFieldId);
    public string Eis=();
    public string Eys=();
}
internal enum HRU=./CQ= : Enum {
    public int value__;
    public static /CQ= /SQ=;
    public static /CQ= /iQ=;
    public static /CQ= /yQ=;
    public static /CQ= ACU=;
    public static /CQ= ASU=;
    public static /CQ= AiU=;
    public static /CQ= AyU=;
    public static /CQ= BCU=;
    public static /CQ= BSU=;
}
internal enum HRU=./CY= : Enum {
    public int value__;
    public static /CY= /SY=;
    public static /CY= /iY=;
    public static /CY= /yY=;
    public static /CY= ACc=;
    public static /CY= ASc=;
    public static /CY= Aic=;
    public static /CY= Ayc=;
    public static /CY= BCc=;
    public static /CY= BSc=;
    public static /CY= Bic=;
    public static /CY= Byc=;
    public static /CY= CCc=;
    public static /CY= CSc=;
    public static /CY= Cic=;
    public static /CY= Cyc=;
    public static /CY= DCc=;
    public static /CY= DSc=;
    public static /CY= Dic=;
    public static /CY= Dyc=;
    public static /CY= ECc=;
    public static /CY= ESc=;
}
internal class HRU=./hk= : jBo= {
    internal double QRk=;
    internal /hk=(string id, string desc);
    private void 9xg=();
    internal virtual whg= /Bg=(whg= pjConsts, Int32& pj_Error);
    internal virtual void Axk=(mhg= lp, whg= pjConsts, TRg= fac, Int32& pj_Error);
    internal virtual mhg= ARk=(mRo= xy, whg= pjConsts, Int32& pj_Error);
    internal virtual mRo= Ahk=(mhg= lp, whg= pjConsts, Int32& pj_Error);
}
internal class HRU=./hs= : object {
    internal static UInt32 /xs=;
    internal static UInt32 ABw=;
    internal static UInt32 ARw=;
    internal static UInt32 Ahw=;
    internal static UInt32 Axw=;
    internal static UInt32 BBw=;
    internal static UInt32 BRw=;
    internal static UInt32 Bhw=;
    internal static UInt32 Bxw=;
    internal static UInt32 CBw=;
    private static double XhY=;
    private static double CRw=;
    private static double vhs=;
    private static double WRs=;
    private static double Whs=;
    private static double Wxs=;
    private static double XBs=;
    private double Chw=;
    private double Cxw=;
    private long DBw=;
    public /hs=(long _override);
    public bool DRw=(long _override);
    internal long Dhw=(double a, double f, long _override);
    internal void Dxw=(Double& a, Double& f, Int64& _override);
    internal long EBw=(double Latitude, double Longitude, Int32& Zone, Char& Hemisphere, Double& Easting, Double& Northing);
    internal long ERw=(int Zone, char Hemisphere, double Easting, double Northing, Double& Latitude, Double& Longitude);
}
internal class HRU=./jE= : 5TE= {
    private static string 9TE=;
    private static string 9jE=;
    public virtual StyleJsonDocument kxU=(JObject jsonObject);
    protected static List`1<JToken> /DE=(JObject jsonObject);
    protected static List`1<ValueTuple`2<int, JObject>> /TE=(JObject jObject);
}
internal class HRU=./Rk= : jBo= {
    internal /Rk=(string id, string desc);
    private void 9xg=();
    internal virtual whg= /Bg=(whg= pjConsts, Int32& pj_Error);
    internal virtual void Axk=(mhg= lp, whg= pjConsts, TRg= fac, Int32& pj_Error);
    internal virtual mhg= ARk=(mRo= xy, whg= pjConsts, Int32& pj_Error);
    internal virtual mRo= Ahk=(mhg= lp, whg= pjConsts, Int32& pj_Error);
}
internal class HRU=./x8= : 6B8= {
    protected BCA= ACA=;
    public BCA= AyA= { get; public set; }
    public /x8=(9B8= rh, BCA= rt, int idx);
    public BCA= ASA=();
    public void AiA=(BCA= value);
    internal virtual bool pBw=(BinaryReader r, bool isFloat);
    internal virtual bool shw=(BinaryWriter w, bool isFloat);
    internal virtual bool vh8=(BCA= rect);
    internal virtual bool vR8=(BCA= rect);
    internal virtual bool vx8=(BCA= rect);
    internal virtual int lR8=(bool isFloat);
    internal virtual BCA= 5h8=();
    internal virtual double 5x8=();
    public virtual string ToString();
}
internal class HRU=./xk= : jBo= {
    internal double QRk=;
    internal /xk=(string id, string desc);
    private void 9xg=();
    internal virtual whg= /Bg=(whg= pjConsts, Int32& pj_Error);
    internal virtual void Axk=(mhg= lp, whg= pjConsts, TRg= fac, Int32& pj_Error);
    internal virtual mhg= ARk=(mRo= xy, whg= pjConsts, Int32& pj_Error);
    internal virtual mRo= Ahk=(mhg= lp, whg= pjConsts, Int32& pj_Error);
}
internal class HRU=./zE= : FilterCondition {
    private static string dyM=;
    private static string eCM=;
    private static string eSM=;
    private static char eiM=;
    [CompilerGeneratedAttribute]
private Regex eyM=;
    [CompilerGeneratedAttribute]
private String[] fCM=;
    [CompilerGeneratedAttribute]
private String[] fSM=;
    public Regex gCM= { get; public set; }
    public String[] gyM= { get; public set; }
    public String[] hiM= { get; public set; }
    internal /zE=(string columnName, string operation, string expression);
    [CompilerGeneratedAttribute]
public Regex fiM=();
    [CompilerGeneratedAttribute]
public void fyM=(Regex value);
    [CompilerGeneratedAttribute]
public String[] gSM=();
    [CompilerGeneratedAttribute]
public void giM=(String[] value);
    [CompilerGeneratedAttribute]
public String[] hCM=();
    [CompilerGeneratedAttribute]
public void hSM=(String[] value);
    internal virtual bool TSM=(KeyValuePair`2<string, string> v);
    internal virtual bool TSM=(Feature feature);
}
internal enum HRU=.0C8= : Enum {
    public int value__;
    public static 0C8= vC8=;
    public static 0C8= vS8=;
    public static 0C8= 0S8=;
    public static 0C8= 0i8=;
    public static 0C8= 0y8=;
    public static 0C8= 1C8=;
    public static 0C8= 1S8=;
    public static 0C8= vi8=;
    public static 0C8= vy8=;
    public static 0C8= 1i8=;
    public static 0C8= 1y8=;
    public static 0C8= 2C8=;
    public static 0C8= 2S8=;
}
internal class HRU=.0hU= : object {
    internal static string 0xU=;
    private static Dictionary`2<string, 3xU=> 1BU=;
    internal static String[] 1RU=(string fileName, string keyFieldName, string value, zhU= criteria, IFormatProvider provider);
    internal static int 1hU=(string fileName, string keyFieldName);
    internal static string 1xU=(string baseName);
    internal static string 2BU=(string fileName, string keyFieldName, string keyFieldValue, zhU= criteria, string targetField, IFormatProvider provider);
    internal static String[] 2RU=(string fileName);
    private static string 2hU=(string baseName);
    internal static String[] 2xU=(string csvFileName, String[] columnNames);
    private static List`1<string> 3BU=(string recordLine);
    private static 3xU= 3RU=(string fileName);
    private static DataTable 3hU=(string fileName);
}
internal enum HRU=.0iY= : Enum {
    public int value__;
    public static 0iY= 0yY=;
    public static 0iY= 1CY=;
    public static 0iY= 1SY=;
    public static 0iY= 1iY=;
}
internal class HRU=.1Cc= : 3Cc= {
    public tSc=[] 1Sc=;
    private uCc=[] wCc=;
    public virtual int kxU=();
    public string wyc=(Int32& bDefault);
    public string 0Sc=(Int32& bDefault);
    public double 1ic=(Int32& bDefault);
    public string xCc=(6yY= eParam, Int32& bValueIsNull);
    public double 0yc=(6yY= eParam, Int32& bValueIsNull);
}
internal class HRU=.1Ck= : object {
    public int jCQ=;
    public int jiQ=;
    public int jSQ=;
    public int jyQ=;
    public int OCg=;
}
internal static class HRU=.1CQ= : object {
    public static bool 1SQ=;
    public static LocalDataStoreSlot 1iQ=;
    public static object 1yQ=(int nIndex);
    public static void 2CQ=(int nIndex, object pData, bool bFreeOnExit);
    public static Object[] 2SQ=();
}
internal class HRU=.1CU= : object {
    public iCo= 1SU=;
    public double 1iU=;
    public double 1yU=;
    public double 2CU=;
    public double 2SU=;
    public 1CU=(iCo= sProj, double dXMin, double dYMin, double dXMax, double dYMax);
}
internal class HRU=.1h8= : object {
    public double 1x8=;
    public tR8= 2B8=;
    public 1h8=(double minDist, tR8= node);
    public sealed virtual int CompareTo(object rhs);
}
internal class HRU=.1hw= : object {
    public static int 1xw=;
    private static int 1Rw=;
    private int 2Bw=;
    private uhw= 2Rw=;
    private uhw= 2hw=;
    private TextReader 2xw=;
    private uhw= 3Bw=;
    private uhw= 3Rw=;
    private 7Rw= 3hw=;
    public TextReader 4Rw= { get; public set; }
    public 7Rw= 4xw= { get; }
    public 1hw=(TextReader sr);
    public 1hw=(string str);
    private static 1hw=();
    public TextReader 3xw=();
    public void 4Bw=(TextReader value);
    public 7Rw= 4hw=();
    private void 5Bw=();
    private 3T4= 5Rw=(byte ctype, int c);
    private 3T4= 5Rw=(byte ctype, int c, 3T4= excludeState);
    private int 5hw=();
    public bool 5xw=(IB0=& token);
    private bool 6Bw=(uhw= sb, bool allowPlus, Char& thisChar);
    public bool 6Rw=(List`1<IB0=> tokens);
    public bool 6hw=(TextReader tr, List`1<IB0=> tokens);
    public bool 6xw=(string str, List`1<IB0=> tokens);
    public bool 7Bw=(Stream s, List`1<IB0=> tokens);
}
internal class HRU=.1Sk= : CSo= {
    public int 1ik=;
    public int 1yk=;
    public int 2Ck=;
    public int 2Sk=;
    public int 2ik=;
    public int 2yk=;
    public byte 3Ck=;
    public virtual int 3Sk=(7Ck= poObjBlock);
    public virtual int 3ik=(7Ck= poObjBlock);
}
internal class HRU=.1yc= : object {
    private String[] 2Cc=;
    public string 2Sc=(string pszName);
    public int 2ic=(string pszName);
    public string 2yc=(string pszStyleString);
}
internal enum HRU=.1yY= : Enum {
    public int value__;
    public static 1yY= 2CY=;
    public static 1yY= 2SY=;
    public static 1yY= 2iY=;
    public static 1yY= 2yY=;
    public static 1yY= 3CY=;
    public static 1yY= 3SY=;
    public static 1yY= 3iY=;
    public static 1yY= 3yY=;
    public static 1yY= 4CY=;
}
internal class HRU=.2Bk= : jBo= {
    internal double 2Rk=;
    internal double 2hk=;
    internal double 2xk=;
    internal double 3Bk=;
    internal double 3Rk=;
    internal double 3hk=;
    internal 2Bk=(string id, string desc);
    private void 9xg=();
    internal virtual whg= /Bg=(whg= pjConsts, Int32& pj_Error);
    internal virtual void Axk=(mhg= lp, whg= pjConsts, TRg= fac, Int32& pj_Error);
    internal virtual mhg= ARk=(mRo= xy, whg= pjConsts, Int32& pj_Error);
    internal virtual mRo= Ahk=(mhg= lp, whg= pjConsts, Int32& pj_Error);
}
internal class HRU=.2i0= : object {
    private double /yw=;
    [CompilerGeneratedAttribute]
private int 2y0=;
    [CompilerGeneratedAttribute]
private byte 3C0=;
    [CompilerGeneratedAttribute]
private int 3S0=;
    [CompilerGeneratedAttribute]
private int 3i0=;
    [CompilerGeneratedAttribute]
private ushort 3y0=;
    [CompilerGeneratedAttribute]
private ushort 4C0=;
    public int 4y0= { get; private set; }
    public byte 5i0= { get; private set; }
    public int 6S0= { get; private set; }
    public int 7C0= { get; private set; }
    public ushort 7y0= { get; private set; }
    public ushort 8i0= { get; private set; }
    public 2i0=(double extentWidthLimitation);
    [CompilerGeneratedAttribute]
private void 4i0=(int value);
    [CompilerGeneratedAttribute]
public int 4S0=();
    [CompilerGeneratedAttribute]
private void 5S0=(byte value);
    [CompilerGeneratedAttribute]
public byte 5C0=();
    [CompilerGeneratedAttribute]
private void 6C0=(int value);
    [CompilerGeneratedAttribute]
public int 5y0=();
    [CompilerGeneratedAttribute]
private void 6y0=(int value);
    [CompilerGeneratedAttribute]
public int 6i0=();
    [CompilerGeneratedAttribute]
private void 7i0=(ushort value);
    [CompilerGeneratedAttribute]
public ushort 7S0=();
    [CompilerGeneratedAttribute]
private void 8S0=(ushort value);
    [CompilerGeneratedAttribute]
public ushort 8C0=();
    public void gC0=(int featureDataOffset, byte objectType, nC0= subdivision);
}
internal class HRU=.2i4= : object {
    private int 2y4=;
    private int vC4=;
    private int 0RM=;
    public int ei4= { get; }
    public int /i0= { get; }
    public int AS4= { get; }
    public int eC4=();
    public int /C0=();
    public int /y0=();
    public void pBw=(Stream stream, int rgnOffset);
}
internal class HRU=.2i8= : object {
    private Collection`1<SC8=> 2y8=;
    private Dictionary`2<string, string> 1CM=;
    private BaseShape 3C8=;
    private long SSA=;
    public long Wy8= { get; public set; }
    public string gxQ= { get; public set; }
    public Collection`1<SC8=> 3i8= { get; }
    public Dictionary`2<string, string> ZiA= { get; }
    public BaseShape 4S8= { get; public set; }
    public long WS8=();
    public void Wi8=(long value);
    public string gRQ=();
    public void ghQ=(string value);
    public Collection`1<SC8=> 3S8=();
    public Dictionary`2<string, string> ZSA=();
    private RectangleShape 4i8=();
    public BaseShape 3y8=();
    public void 4C8=(BaseShape value);
}
internal enum HRU=.2ig= : Enum {
    public int value__;
    public static 2ig= 2yg=;
    public static 2ig= 3Cg=;
    public static 2ig= 3Sg=;
    public static 2ig= 3ig=;
    public static 2ig= 3yg=;
}
internal static class HRU=.2iQ= : object {
    public static int 2yQ=;
    [ThreadStaticAttribute]
public static List`1<string> 3CQ=;
    [ThreadStaticAttribute]
public static int 3SQ=;
    private static 2iQ=();
    public static List`1<string> 3iQ=(List`1<string> papszStrList, string pszNewString);
    public static int 3yQ=(List`1<string> papszStrList);
    public static string 4CQ=(List`1<string> papszStrList, int iField);
    public static string 4SQ=(List`1<string> papszStrList, string pszName);
    public static void 4iQ=(List`1<string> papszStrList);
    public static int Jxc=(List`1<string> papszList, string pszTarget);
    public static List`1<string> 4yQ=(string pszString);
    public static List`1<string> 5CQ=(string pszString, string pszDelimiters, bool bHonourStrings, bool bAllowEmptyTokens);
    public static List`1<string> 5SQ=(string pszString, string pszDelimiters, int nCSLTFlags);
    public static string 5iQ=(string fmt, Object[] vaList);
    public static string 5yQ=(int nBytes, Byte[] pabyData);
}
internal class HRU=.2iU= : object {
    public int 2yU=;
    public string 3CU=;
    public int 3SU=;
    public double 3iU=;
    public double 3yU=;
    public double 4CU=;
    public double 4SU=;
    public double 4iU=;
    public double 4yU=;
    public double 5CU=;
    public double 5SU=;
    public 2iU=(int nMapInfoDatumID, string pszOGCDatumName, int nEllipsoid, double dfShiftX, double dfShiftY, double dfShiftZ, double dfDatumParm0, double dfDatumParm1, double dfDatumParm2, double dfDatumParm3, double dfDatumParm4);
}
internal class HRU=.2iw= : object {
    private int 2yw=;
    private bool 3Cw=;
    [CompilerGeneratedAttribute]
private Py0= 3Sw=;
    [CompilerGeneratedAttribute]
private int 3iw=;
    [CompilerGeneratedAttribute]
private 8iw= 3yw=;
    [CompilerGeneratedAttribute]
private ushort vCw=;
    [CompilerGeneratedAttribute]
private ushort 4Cw=;
    public Py0= 4yw= { get; public set; }
    public int 5iw= { get; private set; }
    public 8iw= 6Sw= { get; public set; }
    public ushort wyw= { get; public set; }
    public ushort 7Cw= { get; public set; }
    public 2iw=(RectangleShape box);
    public 2iw=(Py0= saver);
    [CompilerGeneratedAttribute]
public void 4iw=(Py0= value);
    [CompilerGeneratedAttribute]
public Py0= 4Sw=();
    [CompilerGeneratedAttribute]
private void 5Sw=(int value);
    [CompilerGeneratedAttribute]
public int 5Cw=();
    [CompilerGeneratedAttribute]
public 8iw= 5yw=();
    [CompilerGeneratedAttribute]
public void 6Cw=(8iw= value);
    [CompilerGeneratedAttribute]
public void wiw=(ushort value);
    [CompilerGeneratedAttribute]
public ushort wSw=();
    [CompilerGeneratedAttribute]
public void 6yw=(ushort value);
    [CompilerGeneratedAttribute]
public ushort 6iw=();
    public double 7Sw=(2iw= pREntry, bool isLeaf);
    private double 7iw=(2iw= pREntry, bool isLeaf);
    private double 7yw=(2iw= pREntry);
    public void 8Cw=(8iw= childNode);
    public void 8Sw=(int nodeIndex, int entryIndex, List`1& rTree);
}
internal class HRU=.2R8= : ValueType {
    public UInt32 2h8=;
    public ushort 2x8=;
    public ushort 3B8=;
    public ushort 3R8=;
    public ushort 3h8=;
    public UInt32 3x8=;
    public void Lh8=();
    public bool pBw=(BinaryReader r);
    public bool shw=(BinaryWriter w);
    public virtual string ToString();
}
internal class HRU=.3Bg= : object {
    private exo= 3Rg=;
    private Dictionary`2<string, exo=> 3hg=;
    internal exo= 4Bg= { get; }
    internal 3Bg=(Dictionary`2<string, string> args, Dictionary`2<string, exo=> pj_Datums_List);
    private string 4Rg=(Dictionary`2<string, string> args);
    private void 4hg=(string datumID);
    internal exo= 3xg=();
}
internal class HRU=.3C4= : object {
    [CompilerGeneratedAttribute]
private int XC0=;
    [CompilerGeneratedAttribute]
private List`1<Si4=> Wy0=;
    [CompilerGeneratedAttribute]
private string 3S4=;
    public int ZC0= { get; public set; }
    public List`1<Si4=> YS0= { get; public set; }
    public string 4C4= { get; public set; }
    [CompilerGeneratedAttribute]
public int Yi0=();
    [CompilerGeneratedAttribute]
public void Yy0=(int value);
    [CompilerGeneratedAttribute]
public List`1<Si4=> Xy0=();
    [CompilerGeneratedAttribute]
public void YC0=(List`1<Si4=> value);
    [CompilerGeneratedAttribute]
public string 3i4=();
    [CompilerGeneratedAttribute]
public void 3y4=(string value);
}
internal abstract class HRU=.3Cc= : object {
    private int 3Sc=;
    private double 3ic=;
    private xCY= 3yc=;
    private yyY= 4Cc=;
    private string KSc=;
    public 3Cc=(yyY= eClassId);
    public abstract virtual int kxU=();
    public int kxU=(tSc=[] pasStyle, uCc=[] pasValue, int nCount);
    public void 4Sc=();
    public int 4ic=();
    public void 4yc=();
    public yyY= Yic=();
    public void 5Cc=(string pszString);
    public void 5Sc=(xCY= eUnit, double dfScale);
    public xCY= 5ic=();
    public void Oyc=(string pszStyleString);
    public string xCc=(tSc= sStyleParam, uCc= sStyleValue, Int32& bValueIsNull);
    public double 0yc=(tSc= sStyleParam, uCc= sStyleValue, Int32& bValueIsNull);
    public void 5yc=(tSc= sStyleParam, uCc= sStyleValue, string pszParamString);
    public double 6Cc=(double dfValue, xCY= eInputUnit);
    public int 6Cc=(int nValue, xCY= eUnit);
}
internal class HRU=.3hs= : object {
    private static UInt32 3xs=;
    private static UInt32 4Bs=;
    private static UInt32 4Rs=;
    private static UInt32 4hs=;
    private static UInt32 4xs=;
    private static UInt32 5Bs=;
    private static UInt32 5Rs=;
    private static UInt32 5hs=;
    private static double XhY=;
    private static double vRs=;
    private static double vhs=;
    private static double 5xs=;
    private static double 6Bs=;
    private static double 6Rs=;
    private static double YBs=;
    private static double YRs=;
    private double 6hs=;
    private double 6xs=;
    private double 7Bs=;
    private double 7Rs=;
    private double 7hs=;
    private double 7xs=;
    private double 8Bs=;
    private double 8Rs=;
    private double 8hs=;
    private double 8xs=;
    internal long 9Bs=(double a, double f);
    internal void 9Rs=(Double& a, Double& f);
    public bool 9hs=(double Latitude, double Longitude, Char& Hemisphere, Double& Easting, Double& Northing);
    internal long 9xs=(double Latitude, double Longitude, Char& Hemisphere, Double& Easting, Double& Northing);
    public bool /Bs=(char Hemisphere, double Easting, double Northing, Double& Latitude, Double& Longitude);
    internal long /Rs=(char Hemisphere, double Easting, double Northing, Double& Latitude, Double& Longitude);
}
internal class HRU=.3SE= : object {
    private int 3iE=;
    private int 3yE=;
    private float 4CE=;
    private float 4SE=;
    private GeoImage 4iE=;
    public int 5SE= { get; public set; }
    public int 6CE= { get; public set; }
    public float 6iE= { get; }
    public float 7CE= { get; }
    public GeoImage 7iE= { get; }
    public 3SE=(int screenStartX, int screenStartY, float screenStartPositionX, float screenStartPositionY, GeoImage drawingWholeGeoImage);
    public int 4yE=();
    public void 5CE=(int value);
    public int 5iE=();
    public void 5yE=(int value);
    public float 6SE=();
    public float 6yE=();
    public GeoImage 7SE=();
}
internal class HRU=.3xk= : jBo= {
    internal double 4Bk=;
    internal double Rhk=;
    internal double gxc=;
    internal double 4Rk=;
    internal double 4hk=;
    internal double bBk=;
    internal double 4xk=;
    internal double 5Bk=;
    internal double 5Rk=;
    internal double 5hk=;
    internal double 5xk=;
    internal 3xk=(string id, string desc);
    private void 9xg=();
    internal virtual whg= /Bg=(whg= pjConsts, Int32& pj_Error);
    internal virtual void Axk=(mhg= lp, whg= pjConsts, TRg= fac, Int32& pj_Error);
    internal virtual mhg= ARk=(mRo= xy, whg= pjConsts, Int32& pj_Error);
    internal virtual mRo= Ahk=(mhg= lp, whg= pjConsts, Int32& pj_Error);
}
internal class HRU=.3xU= : object {
    internal DataTable 4BU=;
    internal string 4RU=;
    internal int 4hU=;
}
internal class HRU=.3yA= : ValueType {
    public bool 4CA=;
    public bool 4SA=;
    public bool 4iA=;
    public bool 4yA=;
    public bool 5CA=;
    public bool 5SA=;
    public bool 5iA=;
    public string 5yA=;
    public bool 3CA=;
    public int 6CA=;
}
internal class HRU=.3yk= : ECo= {
    public int 4Ck=;
    public int 4Sk=;
    public int 4ik=;
    public int jyg=;
    public int kCg=;
    public int 4yk=;
    public int 5Ck=;
    public int 5Sk=;
    public byte 5ik=;
    public byte 5yk=;
    public byte 6Ck=;
    public byte 6Sk=;
    public virtual int 3Sk=(7Ck= poObjBlock);
    public virtual int 3ik=(7Ck= poObjBlock);
    private int ECU=(int nGenoType);
}
internal class HRU=.4B8= : 6B8= {
    private LiA= 4R8=;
    internal LiA= 5B8= { get; internal set; }
    internal 4B8=(9B8= rh, LiA= pt, int idx);
    public virtual string ToString();
    internal LiA= 4h8=();
    internal void 4x8=(LiA= value);
    internal virtual LiA= 5R8=();
    internal virtual bool pBw=(BinaryReader r, bool isFloat);
    internal virtual bool shw=(BinaryWriter w, bool isFloat);
    internal virtual bool vh8=(BCA= rect);
    internal virtual bool vR8=(BCA= rect);
    internal virtual bool vx8=(BCA= rect);
    internal virtual int lR8=(bool isFloat);
    internal virtual BCA= 5h8=();
    internal virtual double 5x8=();
}
internal class HRU=.4Cg= : object {
    public int PSc=;
    public string 4Sg=;
    public 4Cg=(int nRefCount, string szFontName);
}
internal class HRU=.4i4= : object {
    [CompilerGeneratedAttribute]
private int 4y4=;
    [CompilerGeneratedAttribute]
private int 5C4=;
    [CompilerGeneratedAttribute]
private byte 5S4=;
    [CompilerGeneratedAttribute]
private int 3S0=;
    [CompilerGeneratedAttribute]
private int 3i0=;
    [CompilerGeneratedAttribute]
private long 3y0=;
    [CompilerGeneratedAttribute]
private long 4C0=;
    [CompilerGeneratedAttribute]
private byte 5i4=;
    [CompilerGeneratedAttribute]
private int Oi4=;
    [CompilerGeneratedAttribute]
private int Oy4=;
    [CompilerGeneratedAttribute]
private int PC4=;
    [CompilerGeneratedAttribute]
private int PS4=;
    public int 6S4= { get; public set; }
    public int 7C4= { get; public set; }
    public byte 7y4= { get; public set; }
    public int 6S0= { get; public set; }
    public int 7C0= { get; public set; }
    public long 7y0= { get; public set; }
    public long 8i0= { get; public set; }
    public byte 8i4= { get; public set; }
    public int QC4= { get; public set; }
    public int Qy4= { get; public set; }
    public int Ri4= { get; public set; }
    public int SS4= { get; public set; }
    [CompilerGeneratedAttribute]
public int 5y4=();
    [CompilerGeneratedAttribute]
public void 6C4=(int value);
    [CompilerGeneratedAttribute]
public int 6i4=();
    [CompilerGeneratedAttribute]
public void 6y4=(int value);
    [CompilerGeneratedAttribute]
public byte 7S4=();
    [CompilerGeneratedAttribute]
public void 7i4=(byte value);
    [CompilerGeneratedAttribute]
public int 5y0=();
    [CompilerGeneratedAttribute]
public void 6C0=(int value);
    [CompilerGeneratedAttribute]
public int 6i0=();
    [CompilerGeneratedAttribute]
public void 6y0=(int value);
    [CompilerGeneratedAttribute]
public long 7S0=();
    [CompilerGeneratedAttribute]
public void 7i0=(long value);
    [CompilerGeneratedAttribute]
public long 8C0=();
    [CompilerGeneratedAttribute]
public void 8S0=(long value);
    [CompilerGeneratedAttribute]
public byte 8C4=();
    [CompilerGeneratedAttribute]
public void 8S4=(byte value);
    [CompilerGeneratedAttribute]
public int Pi4=();
    [CompilerGeneratedAttribute]
public void Py4=(int value);
    [CompilerGeneratedAttribute]
public int QS4=();
    [CompilerGeneratedAttribute]
public void Qi4=(int value);
    [CompilerGeneratedAttribute]
public int RC4=();
    [CompilerGeneratedAttribute]
public void RS4=(int value);
    [CompilerGeneratedAttribute]
public int Ry4=();
    [CompilerGeneratedAttribute]
public void SC4=(int value);
    public bool wy4=(OS4= range);
}
internal class HRU=.4ig= : RCo= {
    protected double 4yg=;
    protected short 5Cg=;
    private sig= 5Sg=;
    private static int 9CQ=;
    private static int 9SQ=;
    private static int 9iQ=;
    private static int 9yQ=;
    internal sig= 5yg= { get; }
    public int oyU= { get; public set; }
    public 4Cg= piU= { get; public set; }
    public 4ig=(PCc= poDefnIn);
    internal sig= 5ig=();
    public virtual pCg= Iig=();
    public virtual iSg= JCg=(PCc= poNewDefn);
    public virtual int JSg=(Wyk= poMapFile, CSo= poObjHdr, bool bCoordBlockDataOnly, Nik=& ppoCoordBlock);
    public virtual int Jig=(Wyk= poMapFile, CSo= poObjHdr, bool bCoordBlockDataOnly, Nik=& ppoCoordBlock);
    public virtual int Jyg=(6yU= fp);
    public virtual int KCg=(6yU= fp);
    public virtual string Oic=();
    public int 6Cg=();
    public void 6Sg=(int nStyle);
    public int 6ig=();
    public void 6yg=(int nStyle);
    public double 7Cg=();
    public void 7Sg=(double dAngle);
    public virtual int oSU=();
    public virtual void oiU=(int value);
    public virtual 4Cg= pCU=();
    public virtual void pSU=(4Cg= value);
    public virtual int pyU=();
    public virtual 4Cg= qCU=();
    public virtual string qSU=();
    public virtual void qiU=(string pszName);
    public virtual void qyU=(Stream fpOut);
}
internal class HRU=.4jE= : FilterCondition {
    private string TCM=;
    internal 4jE=(string columnName, string operation, string expression);
    internal virtual bool TSM=(KeyValuePair`2<string, string> value);
    internal virtual bool TSM=(Feature feature);
    private bool 4zE=(string parameter, Double& value);
    private bool 5DE=(string inputValue, Double& filterValue);
}
internal class HRU=.4S4= : object {
    [CompilerGeneratedAttribute]
private List`1<3C4=> Wy0=;
    [CompilerGeneratedAttribute]
private List`1<3C4=> ni0=;
    [CompilerGeneratedAttribute]
private List`1<3C4=> ny0=;
    [CompilerGeneratedAttribute]
private int 3S0=;
    [CompilerGeneratedAttribute]
private int 3i0=;
    [CompilerGeneratedAttribute]
private int Oi4=;
    [CompilerGeneratedAttribute]
private int Oy4=;
    [CompilerGeneratedAttribute]
private int PC4=;
    [CompilerGeneratedAttribute]
private int PS4=;
    public List`1<3C4=> YS0= { get; public set; }
    public List`1<3C4=> qC0= { get; public set; }
    public List`1<3C4=> qy0= { get; public set; }
    public int 6S0= { get; public set; }
    public int 7C0= { get; public set; }
    public int QC4= { get; public set; }
    public int Qy4= { get; public set; }
    public int Ri4= { get; public set; }
    public int SS4= { get; public set; }
    [CompilerGeneratedAttribute]
public List`1<3C4=> Xy0=();
    [CompilerGeneratedAttribute]
public void YC0=(List`1<3C4=> value);
    [CompilerGeneratedAttribute]
public List`1<3C4=> pi0=();
    [CompilerGeneratedAttribute]
public void py0=(List`1<3C4=> value);
    [CompilerGeneratedAttribute]
public List`1<3C4=> qS0=();
    [CompilerGeneratedAttribute]
public void qi0=(List`1<3C4=> value);
    [CompilerGeneratedAttribute]
public int 5y0=();
    [CompilerGeneratedAttribute]
public void 6C0=(int value);
    [CompilerGeneratedAttribute]
public int 6i0=();
    [CompilerGeneratedAttribute]
public void 6y0=(int value);
    [CompilerGeneratedAttribute]
public int Pi4=();
    [CompilerGeneratedAttribute]
public void Py4=(int value);
    [CompilerGeneratedAttribute]
public int QS4=();
    [CompilerGeneratedAttribute]
public void Qi4=(int value);
    [CompilerGeneratedAttribute]
public int RC4=();
    [CompilerGeneratedAttribute]
public void RS4=(int value);
    [CompilerGeneratedAttribute]
public int Ry4=();
    [CompilerGeneratedAttribute]
public void SC4=(int value);
    public bool wy4=(OS4= range);
}
internal class HRU=.4SM= : object {
    public Collection`1<Feature> 4iM=(string FeatureCollectionString);
    private void 4yM=(JObject joFeature, Feature& feature);
    private Feature 5CM=(JObject joFeature);
    private PointShape 5SM=(JArray PointCoordinates);
    private LineShape 5iM=(JArray LineCoordinates);
    private PolygonShape 5yM=(JArray PolygonCoordinates);
    private MultipolygonShape 6CM=(JArray MultipolygonCoordinates);
}
internal enum HRU=.4SY= : Enum {
    public int value__;
    public static 4SY= 4iY=;
    public static 4SY= 4yY=;
    public static 4SY= 5CY=;
    public static 4SY= 5SY=;
    public static 4SY= 5iY=;
    public static 4SY= 5yY=;
    public static 4SY= 6CY=;
    public static 4SY= 6SY=;
    public static 4SY= 6iY=;
}
internal class HRU=.4xg= : object {
    private fho= 5Bg=;
    private exo= 5Rg=;
    private Dictionary`2<string, fho=> 5hg=;
    private whg= 5xg=;
    private Dictionary`2<string, string> 6Bg=;
    internal whg= 6hg= { get; }
    internal 4xg=(Dictionary`2<string, string> argList, exo= datums, whg= pj_consts, Dictionary`2<string, fho=> pj_Ellps_List, Int32& pj_Error);
    private void 6xg=(Dictionary`2<string, string> paras, string ellpsID, Int32& pj_Error);
    internal whg= 6Rg=();
}
internal static class HRU=.4xU= : object {
    internal static string 5BU=(string esriWkt, IFormatProvider provider);
    internal static string 5RU=(string proj4, IFormatProvider provider);
    private static void 5hU=();
}
internal class HRU=.4y8= : object {
    private BinaryReader 5C8=;
    public 4y8=(string basFile, FileAccess access);
    public Collection`1<string> ji4=();
    public 2i8= 5S8=(long offset);
    public Collection`1<2i8=> 5i8=();
    public void pR8=();
}
internal class HRU=.5iU= : object {
    public int 5yU=;
    public string 6CU=;
    public double 6SU=;
    public double 6iU=;
    public 5iU=(int nMapInfoId, string pszMapinfoName, double dfA, double dfInvFlattening);
}
internal abstract class HRU=.5TE= : object {
    protected static string 5jE=;
    protected static string 5zE=;
    protected static string 6DE=;
    protected static string 6TE=;
    protected static string 6jE=;
    protected static string 6zE=;
    protected static string 7DE=;
    protected static string 7TE=;
    protected static string 7jE=;
    protected static Dictionary`2<string, FilterCondition> 7zE=;
    public abstract virtual StyleJsonDocument kxU=(JObject jsonObject);
    protected static Dictionary`2<int, GeoColor> 8DE=(JObject jsonObject);
    protected static string 8TE=(string styleNodeFilter, string filter);
    protected static Style 8jE=(JObject propertyObject, FilterApplyMode& styleFilterApplyMode);
    protected static void 8zE=(JToken jToken, Dictionary`2<string, string> variables);
}
internal enum HRU=.5xU= : Enum {
    public int value__;
    public static 5xU= 6BU=;
    public static 5xU= 6RU=;
    public static 5xU= 6hU=;
    public static 5xU= 6xU=;
    public static 5xU= 7BU=;
    public static 5xU= 7RU=;
    public static 5xU= 7hU=;
}
internal static class HRU=.5y8= : object {
    public static 2i8= 4iM=(VS8= entity);
    private static void 6C8=(2i8= featureEntity, hy8= header);
    private static void 6S8=(2i8= featureEntiye, Collection`1<dy8=> coordinates);
    private static void 6i8=(2i8= featureEntity, Collection`1<aC8=> annotations);
}
internal abstract class HRU=.6B8= : object {
    internal 9B8= 6R8=;
    internal UInt32 0BM=;
    internal static int 6h8=;
    internal static int 6x8=;
    internal 9B8= 7h8= { get; internal set; }
    public UInt32 rxM= { get; public set; }
    public static 6B8= 8B8=(Gist_Ext_Id extId);
    internal 9B8= 7B8=();
    internal void 7R8=(9B8= value);
    public UInt32 rhM=();
    public void 7x8=(UInt32 value);
    internal UInt32 8R8=();
    internal abstract virtual BCA= 5h8=();
    internal virtual LiA= 5R8=();
    internal abstract virtual bool pBw=(BinaryReader r, bool isFloat);
    internal abstract virtual bool shw=(BinaryWriter w, bool isFloat);
    internal abstract virtual bool vh8=(BCA= rect);
    internal abstract virtual bool vR8=(BCA= rect);
    internal abstract virtual bool vx8=(BCA= rect);
    internal abstract virtual int lR8=(bool isFloat);
    internal abstract virtual double 5x8=();
}
internal class HRU=.6Bk= : jBo= {
    internal double 6Rk=;
    internal double Zhk=;
    internal double 6hk=;
    internal double 8xg=;
    internal double 6xk=;
    internal double 9Bg=;
    internal double 7Bk=;
    internal double 7Rk=;
    internal double 7hk=;
    internal double 7xk=;
    internal double 3Rk=;
    internal double 3hk=;
    internal double 8Bk=;
    internal double 8Rk=;
    internal double 8hk=;
    internal int 9hg=;
    internal int hhk=;
    internal 6Bk=(string id, string desc);
    private void 9xg=();
    internal virtual whg= /Bg=(whg= pjConsts, Int32& pj_Error);
    internal virtual void Axk=(mhg= lp, whg= pjConsts, TRg= fac, Int32& pj_Error);
    internal virtual mhg= ARk=(mRo= xy, whg= pjConsts, Int32& pj_Error);
    internal virtual mRo= Ahk=(mhg= lp, whg= pjConsts, Int32& pj_Error);
}
internal static class HRU=.6CQ= : object {
    public static FileAttributes 6SQ=(string pszFilename);
    public static long 6iQ=(Stream fp);
    public static string 6yQ=(string pszBuffer, int nBufferSize, Stream fp, Encoding encoding);
    public static long 7CQ=(Stream fp, long nOffset, int nWhence);
    public static Stream 7SQ=(string pszFilename, FileAccess pszAccess, FileShare fileShare);
    public static void 7iQ=(Stream fp);
    public static void 7yQ=(Stream fp);
    public static int 8CQ=(Byte[] pBuffer, int nSize, int nCount, Stream fp);
    public static int 8SQ=(Byte[] pBuffer, int nSize, int nCount, Stream fp);
    public static bool 8iQ=(Stream fp);
}
internal class HRU=.6ik= : Iio= {
    public byte TCg=;
    public byte Syg=;
    public byte 6yk=;
    public virtual int 3Sk=(7Ck= poObjBlock);
    public virtual int 3ik=(7Ck= poObjBlock);
}
internal enum HRU=.6SA= : Enum {
    public int value__;
    public static 6SA= 6iA=;
    public static 6SA= 6yA=;
    public static 6SA= 7CA=;
    public static 6SA= 7SA=;
    public static 6SA= 7iA=;
    public static 6SA= 7yA=;
    public static 6SA= 8CA=;
    public static 6SA= 5iA=;
}
internal class HRU=.6Sc= : 3Cc= {
    public tSc=[] 6ic=;
    private uCc=[] wCc=;
    public virtual int kxU=();
}
internal class HRU=.6y8= : object {
    public static Vertex 7C8=(string latlonString);
    public static string 7S8=(Vertex vertex);
    public static Vertex 7i8=(string XY18String);
    public static string 7y8=(Vertex vertex);
    public static Vertex 8C8=(string XY20String);
    public static string 8S8=(Vertex vertex);
    public static DateTime 8i8=(string YYMMDDString);
    public static string 8y8=(DateTime datetime);
    public static float 9C8=(string textAngle);
}
internal class HRU=.6yc= : object {
    public static T[] 7Cc=(T[] srcArray, int destLength);
    public static void 7Sc=(String& pszTarget, double x, double y, double z, int nDimension);
    public static void 7ic=(Char[] pszTarget);
    public static bool 7yc=(string pszInput, Sic= psField, int nOptions);
    public static void 8Cc=(String& pszStrBuf, double dfValue);
}
internal class HRU=.6yU= : object {
    private Stream 7CU=;
    private string 7SU=;
    private static int 7iU=;
    private Char[] 7yU=;
    private Char[] 8CU=;
    private string 8SU=;
    private FSg= 8iU=;
    private double 8yU=;
    private double 9CU=;
    private double 9SU=;
    private double 9iU=;
    private Encoding FR8=;
    protected virtual override void Finalize();
    public sealed virtual void Dispose();
    protected void 1x0=(bool isDispose);
    public void pR8=();
    public int GR8=(string pszFname, FileAccess pszAccess);
    public string 9yU=();
    public string /CU=();
    public int /SU=();
    public void /iU=(string pszLine);
    public string /yU=();
    public void ACY=(string pszFormat, Object[] vaList);
    public bool ASY=(string pszString);
    public void AiY=(double dfXMul, double dfYMul, double dfXTran, double dfYTran);
    public double AyY=(double dfX);
    public double BCY=(double dfY);
    public double BSY=();
    public string BiY=();
    public void ByY=(string pszDelimiter);
    public void CCY=(bool bEof);
}
internal enum HRU=.6yY= : Enum {
    public int value__;
    public static 6yY= 7CY=;
    public static 6yY= 7SY=;
    public static 6yY= 7iY=;
    public static 6yY= 7yY=;
    public static 6yY= 8CY=;
    public static 6yY= 8SY=;
    public static 6yY= 8iY=;
    public static 6yY= 8yY=;
    public static 6yY= 9CY=;
    public static 6yY= 9SY=;
    public static 6yY= 9iY=;
    public static 6yY= 9yY=;
}
internal class HRU=.7Bg= : jBo= {
    internal double 7Rg=;
    internal double gxc=;
    internal double 7hg=;
    internal double 7xg=;
    internal double 8Bg=;
    internal double 8Rg=;
    internal double 8hg=;
    internal double 8xg=;
    internal double 9Bg=;
    internal Double[] 9Rg=;
    internal int 9hg=;
    private double Zxc=;
    internal 7Bg=(string id, string desc);
    private void 9xg=();
    internal virtual whg= /Bg=(whg= pjConsts, Int32& pj_Error);
    internal mRo= /Rg=(mhg= lp, whg= pjConsts);
    internal mhg= /hg=(mRo= xy, whg= pjConsts);
    internal void /xg=(mhg= lp, whg= pjConsts, TRg= factors);
    internal void ABk=(whg= pjConsts);
    internal virtual mhg= ARk=(mRo= xy, whg= pjConsts, Int32& pj_Error);
    internal virtual mRo= Ahk=(mhg= lp, whg= pjConsts, Int32& pj_Error);
    internal virtual void Axk=(mhg= lp, whg= pjConsts, TRg= fac, Int32& pj_Error);
    private double QRc=(double sinphi, double e, double one_es, Int32& pj_Error);
    private double BBk=(double qs, double Te, double Tone_es, Int32& pj_Error);
}
internal class HRU=.7Ck= : zSo= {
    public static int 7Sk=;
    protected int OCk=;
    protected int 7ik=;
    protected int 7yk=;
    protected int 8Ck=;
    protected int 8Sk=;
    protected int Oyk=;
    protected int PCk=;
    protected int PSk=;
    protected int Pik=;
    protected int 8ik=;
    protected int 8yk=;
    protected int 9Ck=;
    public 7Ck=(FSg= eAccessMode);
    public virtual int CommitToFile();
    public virtual int InitBlockFromData(Byte[] pabyBuf, int nBlockSize, int nSizeUsed, bool bMakeCopy, Stream fsSrc, int nOffset);
    public virtual int InitNewBlock(Stream fsSrc, int nBlockSize, int nFileOffset);
    public virtual int GetBlockClass();
    public int Ryk=(bool bCompressed, Int32& nX, Int32& nY);
    public int TSk=(int nX, int nY, bool bCompressed);
    public int 9Sk=(int nXMin, int nYMin, int nXMax, int nYMax, bool bCompressed);
    public int ISg=(int nX, int nY);
    public int 9ik=(CSo= poObjHdr);
    public int 9yk=(CSo= poObjHdr);
    public void /Ck=(int nNewBlockAddress);
    public int /Sk=();
    public int /ik=();
    public void nCg=(Int32& nXMin, Int32& nYMin, Int32& nXMax, Int32& nYMax);
    public void myg=(int nXMin, int nYMin, int nXMax, int nYMax);
    public void /SU=();
    public int /yk=(mSk= poHeader);
    public int ACo=();
    public int ASo=();
    public int Aio=();
}
internal enum HRU=.7ig= : Enum {
    public int value__;
    public static 7ig= 7yg=;
    public static 7ig= 8Cg=;
    public static 7ig= 8Sg=;
    public static 7ig= 8ig=;
    public static 7ig= 8yg=;
    public static 7ig= 9Cg=;
    public static 7ig= 9Sg=;
    public static 7ig= 9ig=;
    public static 7ig= 9yg=;
    public static 7ig= /Cg=;
    public static 7ig= /Sg=;
    public static 7ig= /ig=;
    public static 7ig= /yg=;
}
internal class HRU=.7Rw= : object {
    private Byte[] 7hw=;
    private bool 7xw=;
    private bool 8Bw=;
    private bool 8Rw=;
    private bool 8hw=;
    private bool 8xw=;
    private bool 9Bw=;
    private bool 9Rw=;
    private bool 9hw=;
    public Byte[] /Bw= { get; }
    public bool /xw= { get; public set; }
    public bool Ah0= { get; public set; }
    public bool BR0= { get; public set; }
    public bool CB0= { get; public set; }
    public bool Cx0= { get; public set; }
    public bool Dh0= { get; public set; }
    public bool ER0= { get; public set; }
    public bool FB0= { get; public set; }
    public Byte[] 9xw=();
    public bool /Rw=();
    public void /hw=(bool value);
    public bool AB0=();
    public void AR0=(bool value);
    public bool Ax0=();
    public void BB0=(bool value);
    public bool Bh0=();
    public void Bx0=(bool value);
    public bool CR0=();
    public void Ch0=(bool value);
    public bool DB0=();
    public void DR0=(bool value);
    public bool Dx0=();
    public void EB0=(bool value);
    public bool Eh0=();
    public void Ex0=(bool value);
    public bool FR0=();
    public void Fh0=();
    public void Fx0=(int c);
    public void GB0=(int startChar, int endChar);
    public void GB0=(string s);
    public void GR0=(int c);
    public void Gh0=(int startChar, int endChar);
    public void Gx0=(int startChar, int endChar);
    public void HB0=(int c);
    public void HR0=(int c);
    public void Hh0=(int c);
    public bool Hx0=(byte ctype, zhw= type);
    public bool Hx0=(char c, zhw= type);
    public bool Hx0=(int c, zhw= type);
}
internal class HRU=.7So= : 8So= {
    private static int 9CQ=;
    private static int 9SQ=;
    private static int 9iQ=;
    private static int 9yQ=;
    public bool 7io=;
    public double 7yo=;
    public double 8Co=;
    public 7So=(PCc= poDefnIn);
    public virtual int ISg=(Wyk= poMapFile);
    public virtual pCg= Iig=();
    public virtual int Iyg=(Wyk= poMapFile);
    public virtual iSg= JCg=(PCc= poNewDefn);
    public virtual int JSg=(Wyk= poMapFile, CSo= poObjHdr, bool bCoordBlockDataOnly, Nik=& ppoCoordBlock);
    public virtual int Jig=(Wyk= poMapFile, CSo= poObjHdr, bool bCoordBlockDataOnly, Nik=& ppoCoordBlock);
    public virtual int Jyg=(6yU= fp);
    public virtual int KCg=(6yU= fp);
    public virtual string Oic=();
    public virtual void KSg=(Stream fsOut);
}
internal class HRU=.7xU= : object {
    internal static string 8BU=;
    internal static string 8RU=;
    internal static string 8hU=;
    internal static string 8xU=;
    internal static string 9BU=;
    internal static string 9RU=;
    internal static string 9hU=;
    internal static string 9xU=;
    internal static string /BU=;
    internal static string /RU=;
    internal static string /hU=;
    internal static string /xU=;
    internal static string ABY=;
    internal static string ARY=;
    internal static string AhY=;
    internal static string AxY=;
    internal static string BBY=;
    internal static string BRY=;
    internal static string BhY=;
    internal static string BxY=;
    internal static string CBY=;
    internal static string CRY=;
    internal static string ChY=;
    internal static string CxY=;
    internal static string DBY=;
    internal static string DRY=;
    internal static string DhY=;
    internal static string DxY=;
    internal static string EBY=;
    internal static string ERY=;
    internal static string EhY=;
    internal static string ExY=;
    internal static string FBY=;
    internal static string FRY=;
    internal static string FhY=;
    internal static string FxY=;
    internal static string GBY=;
    internal static string GRY=;
    internal static string GhY=;
    internal static string GxY=;
    internal static string HBY=;
    internal static string HRY=;
    internal static string HhY=;
    internal static string HxY=;
    internal static string IBY=;
    internal static string IRY=;
    internal static string IhY=;
    internal static string IxY=;
    internal static string JBY=;
    internal static string JRY=;
    internal static string JhY=;
    internal static string JxY=;
    internal static string KBY=;
    internal static string KRY=;
    internal static string KhY=;
    internal static string KxY=;
    internal static string LBY=;
    internal static string LRY=;
    internal static string LhY=;
    internal static string LxY=;
    internal static string MBY=;
    internal static string MRY=;
    internal static string MhY=;
    internal static string MxY=;
    internal static string NBY=;
    internal static string NRY=;
    internal static string NhY=;
    internal static string NxY=;
    internal static string OBY=;
    internal static string ORY=;
    internal static string OhY=;
    internal static string OxY=;
    internal static string PBY=;
    internal static string PRY=;
    internal static string PhY=;
    internal static string PxY=;
    internal static string QBY=;
    internal static string QRY=;
    internal static string QhY=;
    internal static string QxY=;
    internal static string RBY=;
    internal static string RRY=;
    internal static string RhY=;
    internal static string RxY=;
    internal static string SBY=;
    internal static string SRY=;
    internal static string ShY=;
    internal static string SxY=;
    internal static string TBY=;
    internal static string TRY=;
    internal static string ThY=;
    internal static string TxY=;
    internal static string UBY=;
    internal static string URY=;
    internal static string UhY=;
    internal static string UxY=;
    internal static string VBY=;
    internal static string VRY=;
    internal static string VhY=;
    internal static string VxY=;
    internal static string WBY=;
    internal static string WRY=;
    internal static string WhY=;
    internal static double WxY=;
    internal static double XBY=;
}
internal enum HRU=.7yE= : Enum {
    public int value__;
    public static 7yE= 8CE=;
    public static 7yE= 8SE=;
    public static 7yE= 8iE=;
}
internal class HRU=.8CI= : object {
    private static double 8SI=;
    public static OSM= 8iI=(GridCell[0...,0...] gridPoints, double level, double noDataValue);
    private static Collection`1<Collection`1<GridCell>> 8yI=(double level, wiI= functionGrid);
    private static Collection`1<Collection`1<GridCell>> 9CI=(double level, wiI= functionGrid);
    private static Collection`1<Collection`1<GridCell>> 9SI=(double level, wiI= functionGrid);
    private static Collection`1<GridCell> 9iI=(int leftTopGridIndexX, int leftTopGridIndexY, GridCell enterPoint, LiM= enterDirection, wiI= functionGrid);
}
internal class HRU=.8Cs= : object {
    private Byte[] vBw=;
    private ulong SiA=;
    private ulong 8Ss=;
    [CompilerGeneratedAttribute]
private int 8is=;
    [CompilerGeneratedAttribute]
private ulong 8ys=;
    [CompilerGeneratedAttribute]
private wys= 9Cs=;
    public int 9ys= { get; private set; }
    public ulong pxM= { get; private set; }
    public wys= /ys= { get; private set; }
    public 8Cs=(Byte[] tileBuffer);
    [CompilerGeneratedAttribute]
public int 9Ss=();
    [CompilerGeneratedAttribute]
private void 9is=(int value);
    [CompilerGeneratedAttribute]
public ulong phM=();
    [CompilerGeneratedAttribute]
private void /Cs=(ulong value);
    [CompilerGeneratedAttribute]
public wys= /Ss=();
    [CompilerGeneratedAttribute]
private void /is=(wys= value);
    public long ACw=();
    public Byte[] ASw=();
    public List`1<UInt32> Aiw=();
    public double Ayw=();
    public float BCw=();
    public string BSw=(ulong length);
    public bool Biw=();
    public ulong Byw=();
    private void CCw=(ulong skip);
}
internal class HRU=.8h8= : object {
    public double 1x8=;
    public 6B8= 8x8=;
    public 8h8=(double minDist, 6B8= record);
    public sealed virtual int CompareTo(object rhs);
}
internal class HRU=.8iw= : object {
    private int 8yw=;
    private int 9Cw=;
    private int 9Sw=;
    private double 9iw=;
    private double 9yw=;
    private double /Cw=;
    private double wRk=;
    private 2iw= /Sw=;
    private 2iw= /iw=;
    private double /yw=;
    [CompilerGeneratedAttribute]
private VCw= zCM=;
    [CompilerGeneratedAttribute]
private RectangleShape AC0=;
    [CompilerGeneratedAttribute]
private int AS0=;
    [CompilerGeneratedAttribute]
private int Ai0=;
    [CompilerGeneratedAttribute]
private bool Ay0=;
    [CompilerGeneratedAttribute]
private int BC0=;
    [CompilerGeneratedAttribute]
private List`1<2iw=> BS0=;
    [CompilerGeneratedAttribute]
private List`1<2iw=> Bi0=;
    [CompilerGeneratedAttribute]
private int By0=;
    [CompilerGeneratedAttribute]
private int CC0=;
    public VCw= xiw= { get; private set; }
    public RectangleShape Cy0= { get; public set; }
    public int Di0= { get; private set; }
    public int ES0= { get; private set; }
    public bool FC0= { get; private set; }
    public int Fy0= { get; private set; }
    public List`1<2iw=> Gi0= { get; private set; }
    public List`1<2iw=> HS0= { get; public set; }
    public int IC0= { get; private set; }
    public int Iy0= { get; public set; }
    public 8iw=(VCw= nType, int nMax, int nMin, int depth, double extentWidthLimitation, int accuracy);
    [CompilerGeneratedAttribute]
private void xSw=(VCw= value);
    [CompilerGeneratedAttribute]
public VCw= xCw=();
    [CompilerGeneratedAttribute]
public RectangleShape CS0=();
    [CompilerGeneratedAttribute]
public void Ci0=(RectangleShape value);
    [CompilerGeneratedAttribute]
private void DS0=(int value);
    [CompilerGeneratedAttribute]
public int DC0=();
    [CompilerGeneratedAttribute]
private void EC0=(int value);
    [CompilerGeneratedAttribute]
public int Dy0=();
    [CompilerGeneratedAttribute]
private void Ey0=(bool value);
    [CompilerGeneratedAttribute]
public bool Ei0=();
    [CompilerGeneratedAttribute]
private void Fi0=(int value);
    [CompilerGeneratedAttribute]
public int FS0=();
    [CompilerGeneratedAttribute]
private void GS0=(List`1<2iw=> value);
    [CompilerGeneratedAttribute]
public List`1<2iw=> GC0=();
    [CompilerGeneratedAttribute]
public List`1<2iw=> Gy0=();
    [CompilerGeneratedAttribute]
public void HC0=(List`1<2iw=> value);
    [CompilerGeneratedAttribute]
private void Hy0=(int value);
    [CompilerGeneratedAttribute]
public int Hi0=();
    [CompilerGeneratedAttribute]
public void Ii0=(int value);
    [CompilerGeneratedAttribute]
public int IS0=();
    public void aCI=(2iw= value);
    public bool JC0=(2iw= value);
    public 8iw= JS0=();
    public void cx8=(2iw= DesEntry, List`1& RTree, bool isLeaf);
    public 2iw= Ji0=(2iw= DesEntry, bool isLeaf);
    public RectangleShape Jy0=();
    public void KC0=(int NodeIndex, int EntryIndex);
    public void KS0=(int index, List`1& RTree);
    private void uR8=();
    private void Ki0=(List`1<2iw=> TempAllEntrys, bool isLeaf);
    private 2iw= yB8=(List`1<2iw=> SelectEntrys, bool isLeaf);
}
internal class HRU=.8SA= : ValueType {
    public string 8iA=;
    public string 8yA=;
    public string 9CA=;
}
internal class HRU=.8Sc= : object {
    private string uSc=;
    private 8Sc=[] 8ic=;
    private 8Sc= 8yc=;
    private int 9Cc=;
    public 8Sc=[] 9yc= { get; public set; }
    public 8Sc=(string pszValueIn);
    public 8Sc=[] 9Sc=();
    public void 9ic=(8Sc=[] value);
    private int Ixc=();
    public int /Cc=();
    public 8Sc= 8R8=(int iChild);
    public 8Sc= Hxc=(string pszName);
    public void /Sc=(8Sc= poNew, int iChild);
    public void /ic=(8Sc= poNew);
    public int IBc=(string pszValue);
    public void /yc=(int iChild);
    public string ACg=();
    public void ASg=(string pszNewValue);
    public 8Sc= Ihc=();
    public qiY= bSc=(String& ppszResult);
}
internal class HRU=.8So= : iSg= {
    private bool ISo=;
    private bool Oio=;
    private double HSg=;
    private double Hig=;
    private tig= 8io=;
    private oCg= 8yo=;
    public Pyo= ryU= { get; public set; }
    public OSg= jyU= { get; public set; }
    public int siU= { get; public set; }
    public int kiU= { get; public set; }
    public 8So=(PCc= poDefnIn);
    private int 9Co=(Uik=[]& ppasSecHdrs, Wyk= poMAPFile, bool bFlag);
    private int 9So=(nic= poPolygon, Uik=[]& pasSecHdrs, Wyk= poMapFile, Int32& iLastRing);
    public virtual pCg= Iig=();
    public virtual int Iyg=(Wyk= poMapFile);
    public virtual iSg= JCg=(PCc= poNewDefn);
    public int 9io=();
    public gic= 9yo=(int nRequestedRingIndex);
    public virtual int JSg=(Wyk= poMapFile, CSo= poObjHdr, bool bCoordBlockDataOnly, Nik=& ppoCoordBlock);
    public virtual int Jig=(Wyk= poMapFile, CSo= poObjHdr, bool bCoordBlockDataOnly, Nik=& ppoCoordBlock);
    public virtual int Jyg=(6yU= fp);
    public virtual int KCg=(6yU= fp);
    public virtual string Oic=();
    public virtual void KSg=(Stream fsOut);
    public int PSo=(Double& dX, Double& dY);
    public void Pio=(double dX, double dY);
    public virtual int kyU=();
    public virtual OSg= lCU=();
    public virtual int lSU=();
    public virtual int liU=();
    public virtual byte lyU=();
    public virtual byte mCU=();
    public virtual void mSU=(int clr);
    public virtual void miU=(int clr);
    public virtual void myU=(byte val);
    public virtual void nCU=(byte val);
    public virtual string nSU=();
    public virtual void niU=(string pszStyleString);
    public virtual void nyU=(Stream fpOut);
    public virtual int syU=();
    public virtual Pyo= tCU=();
    public virtual byte tSU=();
    public virtual double tiU=();
    public virtual int tyU=();
    public virtual byte uCU=();
    public virtual int uSU=();
    public virtual string uiU=();
    public virtual void uyU=(byte val);
    public virtual void vCU=(double val);
    public virtual void vSU=(int val);
    public virtual void viU=(byte val);
    public virtual void vyU=(int clr);
    public virtual void wCU=(string pszStyleString);
    public virtual void wSU=(Stream fpOut);
    public sealed virtual void riU=(Pyo= value);
    public sealed virtual Pyo= rSU=();
    public sealed virtual void jiU=(OSg= value);
    public sealed virtual OSg= jSU=();
    public sealed virtual int sCU=();
    public sealed virtual void sSU=(int value);
    public sealed virtual int kCU=();
    public sealed virtual void kSU=(int value);
}
internal class HRU=.8xk= : jBo= {
    internal int IRk=;
    internal int Ihk=;
    internal 8xk=(string id, string desc);
    private void 9xg=();
    internal virtual whg= /Bg=(whg= pjConsts, Int32& pj_Error);
    internal virtual void Axk=(mhg= lp, whg= pjConsts, TRg= fac, Int32& pj_Error);
    internal virtual mhg= ARk=(mRo= xy, whg= pjConsts, Int32& pj_Error);
    internal virtual mRo= Ahk=(mhg= lp, whg= pjConsts, Int32& pj_Error);
}
internal class HRU=.8y0= : object {
    [CompilerGeneratedAttribute]
private UInt32 9C0=;
    [CompilerGeneratedAttribute]
private UInt32 9S0=;
    [CompilerGeneratedAttribute]
private List`1<string> 9i0=;
    [CompilerGeneratedAttribute]
private Dictionary`2<string, int> 9y0=;
    public UInt32 /i0= { get; private set; }
    public UInt32 AS4= { get; private set; }
    public List`1<string> BC4= { get; public set; }
    public Dictionary`2<string, int> By4= { get; private set; }
    [CompilerGeneratedAttribute]
public UInt32 /C0=();
    [CompilerGeneratedAttribute]
private void /S0=(UInt32 value);
    [CompilerGeneratedAttribute]
public UInt32 /y0=();
    [CompilerGeneratedAttribute]
private void AC4=(UInt32 value);
    [CompilerGeneratedAttribute]
public void Ay4=(List`1<string> value);
    [CompilerGeneratedAttribute]
public List`1<string> Ai4=();
    [CompilerGeneratedAttribute]
public Dictionary`2<string, int> BS4=();
    [CompilerGeneratedAttribute]
private void Bi4=(Dictionary`2<string, int> value);
    public void CC4=(List`1<string> lbls, Encoding encoding);
    private void CS4=(List`1<string> lbls, Encoding encoding);
}
internal class HRU=.8y4= : object {
    private ci4= 9C4=;
    private Bi8= xS4=;
    private DC8= 9S4=;
    private xC4= 9i4=;
    private 2i4= xi4=;
    private ui4= 9y4=;
    private ty4= xy4=;
    private Stream iC4=;
    private double /yw=;
    private string 0Cw=;
    [CompilerGeneratedAttribute]
private int BC0=;
    public Bi8= /S4= { get; }
    public DC8= /y4= { get; }
    public xC4= AS8= { get; }
    public int Fy0= { get; public set; }
    public 8y4=(ci4= info, Stream stream, string password, double extentWidthLimitation);
    public Bi8= /C4=();
    public DC8= /i4=();
    public xC4= AC8=();
    [CompilerGeneratedAttribute]
public int FS0=();
    [CompilerGeneratedAttribute]
public void Fi0=(int value);
    public void Ai8=(bool isEncrypted);
    public void Ay8=();
    public void BC8=(Encoding encoding);
    public List`1<Feature> BS8=(OS4= range, int index, Dictionary`2<string, int> returningColumns, zyw= encryptor);
    public List`1<Feature> BS8=(IEnumerable`1<string> featureIds, Dictionary`2<string, int> returningColumns, zyw= encryptor);
}
internal enum HRU=.8yQ= : Enum {
    public int value__;
    public static 8yQ= 9CQ=;
    public static 8yQ= 9SQ=;
    public static 8yQ= 9iQ=;
    public static 8yQ= 9yQ=;
}
internal class HRU=.9B8= : ValueType {
    public ushort 9R8=;
    public ushort 9h8=;
    public UInt32 9x8=;
    public static int lR8=();
    public bool pBw=(BinaryReader r);
    public bool shw=(BinaryWriter w);
    public virtual string ToString();
}
internal class HRU=.9Bk= : jBo= {
    internal double Bhk=;
    internal double Bxk=;
    internal int DRk=;
    internal 9Bk=(string id, string desc);
    private void 9xg=();
    internal virtual whg= /Bg=(whg= pjConsts, Int32& pj_Error);
    internal virtual void Axk=(mhg= lp, whg= pjConsts, TRg= fac, Int32& pj_Error);
    internal virtual mhg= ARk=(mRo= xy, whg= pjConsts, Int32& pj_Error);
    internal virtual mRo= Ahk=(mhg= lp, whg= pjConsts, Int32& pj_Error);
}
internal class HRU=.9DE= : 5TE= {
    private static string 9TE=;
    private static string 9jE=;
    private static string 9zE=;
    public virtual StyleJsonDocument kxU=(JObject jsonObject);
    protected static List`1<JToken> /DE=(JObject jsonObject);
    protected static List`1<ValueTuple`2<int, JObject>> /TE=(JObject jObject);
}
internal class HRU=.9hk= : jBo= {
    private double 9xk=;
    private Double[] 9Rg=;
    internal 9hk=(string id, string desc);
    private void 9xg=();
    internal virtual whg= /Bg=(whg= pjConsts, Int32& pj_Error);
    internal virtual void Axk=(mhg= lp, whg= pjConsts, TRg= fac, Int32& pj_Error);
    internal virtual mhg= ARk=(mRo= xy, whg= pjConsts, Int32& pj_Error);
    internal virtual mRo= Ahk=(mhg= lp, whg= pjConsts, Int32& pj_Error);
    private mRo= Exk=(mhg= lp, whg= pjConsts, Int32& pj_Error);
    private mRo= ERk=(mhg= lp, whg= pjConsts, Int32& pj_Error);
    private mhg= EBk=(mRo= xy, whg= pjConsts, Int32& pj_Error);
    private mhg= Dhk=(mRo= xy, whg= pjConsts, Int32& pj_Error);
}
internal class HRU=.9Rk= : jBo= {
    internal double gxc=;
    internal double Sxk=;
    internal double TBk=;
    internal double TRk=;
    internal double Thk=;
    internal double Txk=;
    internal 9Rk=(string id, string desc);
    private void 9xg=();
    internal virtual whg= /Bg=(whg= pjConsts, Int32& pj_Error);
    internal virtual void Axk=(mhg= lp, whg= pjConsts, TRg= fac, Int32& pj_Error);
    internal virtual mhg= ARk=(mRo= xy, whg= pjConsts, Int32& pj_Error);
    internal virtual mRo= Ahk=(mhg= lp, whg= pjConsts, Int32& pj_Error);
    private int UBk=(whg= pjConsts, Double[] del, Int32& pj_Error);
}
internal class HRU=.9yI= : object {
    private int mho=;
    private int mxo=;
    public int /iI= { get; public set; }
    public int ASM= { get; public set; }
    public 9yI=(int x, int y);
    public int /CI=();
    public void /SI=(int value);
    public int /yI=();
    public void ACM=(int value);
}
internal class HRU=.aBo= : jBo= {
    internal double gxc=;
    internal double Sxk=;
    internal double TBk=;
    internal double TRk=;
    internal double Thk=;
    internal double Txk=;
    internal aBo=(string id, string desc);
    private void 9xg=();
    internal virtual whg= /Bg=(whg= pjConsts, Int32& pj_Error);
    internal virtual void Axk=(mhg= lp, whg= pjConsts, TRg= fac, Int32& pj_Error);
    internal virtual mhg= ARk=(mRo= xy, whg= pjConsts, Int32& pj_Error);
    internal virtual mRo= Ahk=(mhg= lp, whg= pjConsts, Int32& pj_Error);
    private int UBk=(whg= pjConsts, Double[] del, Int32& pj_Error);
}
internal class HRU=.ABo= : jBo= {
    internal double thc=;
    internal double txc=;
    internal ABo=(string id, string desc);
    private void 9xg=();
    internal virtual whg= /Bg=(whg= pjConsts, Int32& pj_Error);
    internal virtual void Axk=(mhg= lp, whg= pjConsts, TRg= fac, Int32& pj_Error);
    internal virtual mhg= ARk=(mRo= xy, whg= pjConsts, Int32& pj_Error);
    internal virtual mRo= Ahk=(mhg= lp, whg= pjConsts, Int32& pj_Error);
}
internal class HRU=.aC8= : object {
    private string aS8=;
    private string ai8=;
    private string ay8=;
    private string PC8=;
    private string PS8=;
    private string Pi8=;
    private string bC8=;
    private string bS8=;
    public string cC8= { get; public set; }
    public string cy8= { get; public set; }
    public string QS8= { get; public set; }
    public string RC8= { get; public set; }
    public string Ry8= { get; public set; }
    public string 4C4= { get; public set; }
    public string di8= { get; public set; }
    public string bi8=();
    public void by8=(string value);
    public string cS8=();
    public void ci8=(string value);
    public string Py8=();
    public void QC8=(string value);
    public string Qi8=();
    public void Qy8=(string value);
    public string RS8=();
    public void Ri8=(string value);
    public string 3i4=();
    public void 3y4=(string value);
    public string dC8=();
    public void dS8=(string value);
    public void pBw=(BinaryReader reader);
}
internal class HRU=.ACk= : object {
    public static List`1<2iU=> ASk=;
    public static List`1<5iU=> Aik=;
    private static ACk=();
}
internal class HRU=.ahk= : jBo= {
    internal double axk=;
    internal double Rhk=;
    internal double bBk=;
    internal ahk=(string id, string desc);
    private void 9xg=();
    internal virtual whg= /Bg=(whg= pjConsts, Int32& pj_Error);
    internal virtual void Axk=(mhg= lp, whg= pjConsts, TRg= fac, Int32& pj_Error);
    internal virtual mhg= ARk=(mRo= xy, whg= pjConsts, Int32& pj_Error);
    internal virtual mRo= Ahk=(mhg= lp, whg= pjConsts, Int32& pj_Error);
}
internal class HRU=.aho= : jBo= {
    internal aho=(string id, string desc);
    private void 9xg=();
    internal virtual whg= /Bg=(whg= pjConsts, Int32& pj_Error);
    internal virtual void Axk=(mhg= lp, whg= pjConsts, TRg= fac, Int32& pj_Error);
    internal virtual mhg= ARk=(mRo= xy, whg= pjConsts, Int32& pj_Error);
    internal virtual mRo= Ahk=(mhg= lp, whg= pjConsts, Int32& pj_Error);
}
internal class HRU=.Aho= : jBo= {
    internal double QRk=;
    internal double Qhk=;
    internal Aho=(string id, string desc);
    private void 9xg=();
    internal virtual whg= /Bg=(whg= pjConsts, Int32& pj_Error);
    internal virtual void Axk=(mhg= lp, whg= pjConsts, TRg= fac, Int32& pj_Error);
    internal virtual mhg= ARk=(mRo= xy, whg= pjConsts, Int32& pj_Error);
    internal virtual mRo= Ahk=(mhg= lp, whg= pjConsts, Int32& pj_Error);
}
internal class HRU=.Aig= : object {
    public static string Ayg=;
    public static string BCg=;
    public static string BSg=;
    public static string Big=;
    public static string Byg=;
    public static string CCg=;
    public static string CSg=;
    public static string Cig=;
    public static string Cyg=;
    public static string DCg=;
    public static string DSg=;
    public static string Dig=;
    public static string Dyg=;
    public static string ECg=;
}
internal class HRU=.AiM= : HCM= {
    private 9yI= AyM=;
    private 9yI= BCM=;
    private 9yI= BSM=;
    private 9yI= BiM=;
    public 9yI= CSM= { get; public set; }
    public 9yI= DCM= { get; public set; }
    public 9yI= DyM= { get; public set; }
    public 9yI= EiM= { get; public set; }
    public 9yI= ByM=();
    public void CCM=(9yI= value);
    public 9yI= CiM=();
    public void CyM=(9yI= value);
    public 9yI= DSM=();
    public void DiM=(9yI= value);
    public 9yI= ECM=();
    public void ESM=(9yI= value);
}
internal class HRU=.aRo= : jBo= {
    internal double gxc=;
    internal double txc=;
    internal aRo=(string id, string desc);
    private void 9xg=();
    internal virtual whg= /Bg=(whg= pjConsts, Int32& pj_Error);
    internal virtual void Axk=(mhg= lp, whg= pjConsts, TRg= fac, Int32& pj_Error);
    internal virtual mhg= ARk=(mRo= xy, whg= pjConsts, Int32& pj_Error);
    internal virtual mRo= Ahk=(mhg= lp, whg= pjConsts, Int32& pj_Error);
}
internal class HRU=.ARo= : jBo= {
    internal double QRk=;
    internal double Qhk=;
    internal ARo=(string id, string desc);
    private void 9xg=();
    internal virtual whg= /Bg=(whg= pjConsts, Int32& pj_Error);
    internal virtual void Axk=(mhg= lp, whg= pjConsts, TRg= fac, Int32& pj_Error);
    internal virtual mhg= ARk=(mRo= xy, whg= pjConsts, Int32& pj_Error);
    internal virtual mRo= Ahk=(mhg= lp, whg= pjConsts, Int32& pj_Error);
}
internal static class HRU=.ARs= : object {
    private static Dictionary`2<string, Type> Ahs=;
    private static string Axs=;
    private static FBs= BBs=;
    public static string BRs=;
    public static string Bhs=;
    public static string Bxs=;
    public static string CBs=;
    public static string CRs=;
    public static string Chs=;
    public static string Cxs=;
    public static Dictionary`2<string, Type> DRs= { get; }
    private static ARs=();
    public static Dictionary`2<string, Type> DBs=();
    public static string Dhs=(object targetObject);
    public static object Dxs=(string geoJson);
    public static GeoJsonObject EBs=(object targetObject);
    private static object ERs=(GeoJsonObject geoJsonObject);
    private static PolygonShape Ehs=(Collection`1<Collection`1<Double[]>> rings);
    private static RingShape Exs=(Collection`1<Double[]> ring);
}
internal class HRU=.ASI= : object {
    private int AiI=;
    private int AyI=;
    private int BCI=;
    private double BSI=;
    [CompilerGeneratedAttribute]
private GeoImage BiI=;
    public int CCI= { get; }
    public int CiI= { get; }
    public int DCI= { get; }
    public double DiI= { get; }
    public GeoImage ESI= { get; public set; }
    public ASI=(int column, int row, int zoomLevelNumber, double scale);
    public int ByI=();
    public int CSI=();
    public int CyI=();
    public double DSI=();
    [CompilerGeneratedAttribute]
public GeoImage DyI=();
    [CompilerGeneratedAttribute]
public void ECI=(GeoImage value);
}
[ExtensionAttribute]
internal static class HRU=.ax0= : object {
    [ExtensionAttribute]
internal static T bB0=(JObject jObject, string key, Func`2<string, T> converter);
    [ExtensionAttribute]
internal static T bB0=(JObject jObject, String[] keys, Func`2<String[], T> converter);
    [ExtensionAttribute]
internal static Nullable`1<T> bR0=(string s);
    [ExtensionAttribute]
internal static bool bh0=(GeoBrush geoBrush);
    [ExtensionAttribute]
internal static bool bh0=(GeoPen geoPen);
    [AsyncStateMachineAttribute("HRU=.ax0=/8T4=")]
[ExtensionAttribute]
public static Task`1<WebResponse> bx0=(WebRequest request, CancellationToken cancellationToken);
}
internal class HRU=.axo= : jBo= {
    internal double thc=;
    internal axo=(string id, string desc);
    private void 9xg=();
    internal virtual whg= /Bg=(whg= pjConsts, Int32& pj_Error);
    internal virtual void Axk=(mhg= lp, whg= pjConsts, TRg= fac, Int32& pj_Error);
    internal virtual mhg= ARk=(mRo= xy, whg= pjConsts, Int32& pj_Error);
    internal virtual mRo= Ahk=(mhg= lp, whg= pjConsts, Int32& pj_Error);
}
internal class HRU=.Axo= : jBo= {
    internal double thc=;
    internal double txc=;
    internal double QRk=;
    internal double Qhk=;
    internal double GBg=;
    internal Axo=(string id, string desc);
    private void 9xg=();
    internal virtual whg= /Bg=(whg= pjConsts, Int32& pj_Error);
    internal virtual void Axk=(mhg= lp, whg= pjConsts, TRg= fac, Int32& pj_Error);
    internal virtual mhg= ARk=(mRo= xy, whg= pjConsts, Int32& pj_Error);
    internal virtual mRo= Ahk=(mhg= lp, whg= pjConsts, Int32& pj_Error);
}
internal class HRU=.Ayk= : CyU= {
    private string 8SU=;
    private Stream Wyg=;
    private FSg= 8iU=;
    private zSo= BCk=;
    private int Lyg=;
    private int BSk=;
    public int GR8=(string pszFname, FileAccess pszAccess);
    public int pR8=();
    public int Bik=(int nObjId);
    public int Byk=(int nObjId, int nObjPtr);
    public sealed virtual void Dispose();
}
internal class HRU=.Ayo= : Iio= {
    public byte BCo=;
    public short 5Cg=;
    public byte BSo=;
    public byte Bio=;
    public byte Byo=;
    public short CCo=;
    public byte 6yk=;
    public virtual int 3Sk=(7Ck= poObjBlock);
    public virtual int 3ik=(7Ck= poObjBlock);
}
internal class HRU=.BB4= : object {
    [ObfuscationAttribute]
private int baseUriIndex;
    private static int BR4=;
    private static string vhQ=;
    private Timer vxQ=;
    [ObfuscationAttribute]
private Collection`1<Uri> baseUris;
    private bool Bh4=;
    [CompilerGeneratedAttribute]
private string Bx4=;
    [CompilerGeneratedAttribute]
private string CB4=;
    [CompilerGeneratedAttribute]
private double CR4=;
    [CompilerGeneratedAttribute]
private IWebProxy Ch4=;
    [CompilerGeneratedAttribute]
private string Cx4=;
    public Collection`1<Uri> DR4= { get; }
    public string EB4= { get; public set; }
    public string Ex4= { get; public set; }
    public double Fh4= { get; public set; }
    public IWebProxy GR4= { get; public set; }
    public string HB4= { get; public set; }
    public BB4=(string clientId, string clientSecret);
    [AsyncStateMachineAttribute("HRU=.BB4=/LD8=")]
public Task HR4=();
    public Collection`1<Uri> DB4=();
    [CompilerGeneratedAttribute]
public string Dh4=();
    [CompilerGeneratedAttribute]
public void Dx4=(string value);
    [CompilerGeneratedAttribute]
public string ER4=();
    [CompilerGeneratedAttribute]
public void Eh4=(string value);
    [CompilerGeneratedAttribute]
public double FB4=();
    [CompilerGeneratedAttribute]
public void FR4=(double value);
    [CompilerGeneratedAttribute]
public IWebProxy Fx4=();
    [CompilerGeneratedAttribute]
public void GB4=(IWebProxy value);
    [CompilerGeneratedAttribute]
public string Gh4=();
    [CompilerGeneratedAttribute]
public void Gx4=(string value);
    [AsyncStateMachineAttribute("HRU=.BB4=/Jz8=")]
public Task`1<HttpRequestMessage> Hh4=(string apiPath, HttpMethod method);
    private HttpRequestMessage Hx4=(string apiPath, StringContent content);
    [AsyncStateMachineAttribute("HRU=.BB4=/KD8=")]
public Task`1<string> IB4=();
    public virtual void 1x0=();
    private string IR4=();
    [AsyncStateMachineAttribute("HRU=.BB4=/LT8=")]
private void Ih4=();
    [CompilerGeneratedAttribute]
private void Ix4=(object _);
}
internal class HRU=.bBo= : jBo= {
    internal double thc=;
    internal double txc=;
    internal double uRc=;
    internal bBo=(string id, string desc);
    private void 9xg=();
    internal virtual whg= /Bg=(whg= pjConsts, Int32& pj_Error);
    internal virtual void Axk=(mhg= lp, whg= pjConsts, TRg= fac, Int32& pj_Error);
    internal virtual mhg= ARk=(mRo= xy, whg= pjConsts, Int32& pj_Error);
    internal virtual mRo= Ahk=(mhg= lp, whg= pjConsts, Int32& pj_Error);
    private whg= uRk=(whg= pjConsts, double p, Int32& pj_Error);
}
internal class HRU=.BBo= : jBo= {
    internal double thc=;
    internal double txc=;
    internal double QRk=;
    internal double Qhk=;
    internal double GBg=;
    internal BBo=(string id, string desc);
    private void 9xg=();
    internal virtual whg= /Bg=(whg= pjConsts, Int32& pj_Error);
    internal virtual void Axk=(mhg= lp, whg= pjConsts, TRg= fac, Int32& pj_Error);
    internal virtual mhg= ARk=(mRo= xy, whg= pjConsts, Int32& pj_Error);
    internal virtual mRo= Ahk=(mhg= lp, whg= pjConsts, Int32& pj_Error);
}
internal class HRU=.bC0= : object {
    private List`1<IC4=> bS0=;
    private int bi0=;
    private int by0=;
    private double /yw=;
    [CompilerGeneratedAttribute]
private List`1<nyw=> Wy0=;
    [CompilerGeneratedAttribute]
private byte cC0=;
    [CompilerGeneratedAttribute]
private int XC0=;
    [CompilerGeneratedAttribute]
private short XS0=;
    [CompilerGeneratedAttribute]
private short Xi0=;
    [CompilerGeneratedAttribute]
private int cS0=;
    [CompilerGeneratedAttribute]
private byte ci0=;
    [CompilerGeneratedAttribute]
private sSw= cy0=;
    [CompilerGeneratedAttribute]
private string lCw=;
    [CompilerGeneratedAttribute]
private ushort lSw=;
    public List`1<nyw=> YS0= { get; public set; }
    public byte di0= { get; private set; }
    public int ZC0= { get; private set; }
    public short Zy0= { get; private set; }
    public short ai0= { get; private set; }
    public int eS0= { get; private set; }
    public byte fC0= { get; private set; }
    public sSw= fy0= { get; private set; }
    public string myw= { get; public set; }
    public ushort niw= { get; public set; }
    public bC0=(double extentWidthLimitation);
    [CompilerGeneratedAttribute]
public void YC0=(List`1<nyw=> value);
    [CompilerGeneratedAttribute]
public List`1<nyw=> Xy0=();
    [CompilerGeneratedAttribute]
private void dS0=(byte value);
    [CompilerGeneratedAttribute]
public byte dC0=();
    [CompilerGeneratedAttribute]
private void Yy0=(int value);
    [CompilerGeneratedAttribute]
public int Yi0=();
    [CompilerGeneratedAttribute]
private void Zi0=(short value);
    [CompilerGeneratedAttribute]
public short ZS0=();
    [CompilerGeneratedAttribute]
private void aS0=(short value);
    [CompilerGeneratedAttribute]
public short aC0=();
    [CompilerGeneratedAttribute]
private void eC0=(int value);
    [CompilerGeneratedAttribute]
public int dy0=();
    [CompilerGeneratedAttribute]
private void ey0=(byte value);
    [CompilerGeneratedAttribute]
public byte ei0=();
    [CompilerGeneratedAttribute]
private void fi0=(sSw= value);
    [CompilerGeneratedAttribute]
public sSw= fS0=();
    [CompilerGeneratedAttribute]
public void miw=(string value);
    [CompilerGeneratedAttribute]
public string mSw=();
    [CompilerGeneratedAttribute]
public ushort nCw=();
    [CompilerGeneratedAttribute]
public void nSw=(ushort value);
    public void gC0=(double LoCenter, double LaCenter, byte BitsPerCoord, Dictionary`2<string, int> lblDictionary);
    private void gS0=();
    private void gi0=();
}
internal class HRU=.BCA= : ValueType {
    public LiA= BSA=;
    public LiA= BiA=;
    public BCA=(double x1, double y1, double x2, double y2);
    public double ByA=(LiA= p);
    public void CCA=();
    public static int lR8=(bool isFloat);
    public bool pBw=(BinaryReader r, bool isFloat);
    public bool shw=(BinaryWriter w, bool isFloat);
    public bool vR8=(BCA= testRect);
    public bool vR8=(LiA= testPoint);
    public bool vh8=(BCA= testRect);
    public bool vx8=(BCA= testRect);
    public double CSA=();
    public double CiA=();
    public double 5x8=();
    public bool CyA=(BCA= testRt);
    public DrawingRectangleF DCA=();
    public BCA= DSA=(BCA= rt);
    public double DiA=(BCA= rt);
    public virtual string ToString();
}
internal class HRU=.bhk= : jBo= {
    internal double bxk=;
    internal double cBk=;
    internal double cRk=;
    internal double chk=;
    internal double cxk=;
    internal double dBk=;
    internal double dRk=;
    internal double dhk=;
    internal double mRc=;
    internal double dxk=;
    internal double eBk=;
    internal double eRk=;
    internal Double[] 9Rg=;
    internal int DRk=;
    internal bhk=(string id, string desc);
    private void 9xg=();
    internal virtual whg= /Bg=(whg= pjConsts, Int32& pj_Error);
    internal virtual void Axk=(mhg= lp, whg= pjConsts, TRg= fac, Int32& pj_Error);
    internal virtual mhg= ARk=(mRo= xy, whg= pjConsts, Int32& pj_Error);
    internal virtual mRo= Ahk=(mhg= lp, whg= pjConsts, Int32& pj_Error);
    internal int UBk=(whg= pjConsts, Double[] del, Double[] sig, Int32& pj_Error);
    private mRo= ehk=(mhg= lp, whg= pjConsts, Double[] yc, Int32& pj_Error);
}
internal class HRU=.bho= : jBo= {
    internal double thc=;
    internal double txc=;
    internal double QRk=;
    internal double Qhk=;
    internal bho=(string id, string desc);
    private void 9xg=();
    internal virtual whg= /Bg=(whg= pjConsts, Int32& pj_Error);
    internal virtual void Axk=(mhg= lp, whg= pjConsts, TRg= fac, Int32& pj_Error);
    internal virtual mhg= ARk=(mRo= xy, whg= pjConsts, Int32& pj_Error);
    internal virtual mRo= Ahk=(mhg= lp, whg= pjConsts, Int32& pj_Error);
}
internal class HRU=.Bi8= : object {
    private List`1<4i4=> By8=;
    private DC8= 9S4=;
    private Stream iC4=;
    public List`1<4i4=> CS8= { get; }
    public Bi8=(DC8= header, Stream stream);
    public List`1<4i4=> CC8=();
    public void Ci8=();
    private void Cy8=();
}
internal class HRU=.BiU= : MulticastDelegate {
    public BiU=(object object, IntPtr method);
    public virtual void Invoke(niQ= errEnum, int tempInt, string errorInfo);
    public virtual IAsyncResult BeginInvoke(niQ= errEnum, int tempInt, string errorInfo, AsyncCallback callback, object object);
    public virtual void EndInvoke(IAsyncResult result);
}
internal class HRU=.bRk= : jBo= {
    internal bRk=(string id, string desc);
    private void 9xg=();
    internal virtual whg= /Bg=(whg= pjConsts, Int32& pj_Error);
    internal virtual void Axk=(mhg= lp, whg= pjConsts, TRg= fac, Int32& pj_Error);
    internal virtual mhg= ARk=(mRo= xy, whg= pjConsts, Int32& pj_Error);
    internal virtual mRo= Ahk=(mhg= lp, whg= pjConsts, Int32& pj_Error);
}
internal class HRU=.BRk= : jBo= {
    internal double Bhk=;
    internal double Bxk=;
    internal Double[] 9Rg=;
    internal double CBk=;
    internal double CRk=;
    internal double Chk=;
    internal double Cxk=;
    internal double DBk=;
    internal int DRk=;
    private static double Zxc=;
    internal BRk=(string id, string desc);
    private static BRk=();
    private void 9xg=();
    internal virtual whg= /Bg=(whg= pjConsts, Int32& pj_Error);
    private mhg= Dhk=(mRo= xy, whg= pjConsts, Int32& pj_Error);
    private mhg= Dxk=(mRo= xy, whg= pjConsts, Int32& pj_Error);
    private mhg= EBk=(mRo= xy, whg= pjConsts, Int32& pj_Error);
    private mRo= ERk=(mhg= lp, whg= pjConsts, Int32& pj_Error);
    private mRo= Ehk=(mhg= lp, whg= pjConsts, Int32& pj_Error);
    private mRo= Exk=(mhg= lp, whg= pjConsts, Int32& pj_Error);
    internal virtual void Axk=(mhg= lp, whg= pjConsts, TRg= fac, Int32& pj_Error);
    internal virtual mhg= ARk=(mRo= xy, whg= pjConsts, Int32& pj_Error);
    internal virtual mRo= Ahk=(mhg= lp, whg= pjConsts, Int32& pj_Error);
}
internal class HRU=.bRo= : jBo= {
    internal double thc=;
    internal double txc=;
    internal double uRc=;
    internal bRo=(string id, string desc);
    private void 9xg=();
    internal virtual whg= /Bg=(whg= pjConsts, Int32& pj_Error);
    internal virtual void Axk=(mhg= lp, whg= pjConsts, TRg= fac, Int32& pj_Error);
    internal virtual mhg= ARk=(mRo= xy, whg= pjConsts, Int32& pj_Error);
    internal virtual mRo= Ahk=(mhg= lp, whg= pjConsts, Int32& pj_Error);
    private whg= uRk=(whg= pjConsts, double p, Int32& pj_Error);
}
internal class HRU=.BRo= : ValueType {
    internal float Bho=;
    internal float Thk=;
    internal float Txk=;
    internal float pRk=;
    internal BRo=(float c0, float c1, float c2, float c3);
}
internal static class HRU=.BTI= : object {
    internal static string BjI=;
    internal static string BzI=;
    internal static string CDI=;
    internal static string CTI=;
    internal static string CjI=;
    internal static string CzI=;
    internal static string DDI=;
    internal static string DTI=;
    internal static string DjI=;
    internal static string DzI=;
    internal static String[] EDI=;
    internal static String[] ETI=;
    internal static String[] EjI=;
    internal static String[] EzI=;
    private static BTI=();
}
internal class HRU=.bxo= : jBo= {
    internal bxo=(string id, string desc);
    private void 9xg=();
    internal virtual whg= /Bg=(whg= pjConsts, Int32& pj_Error);
    internal virtual void Axk=(mhg= lp, whg= pjConsts, TRg= fac, Int32& pj_Error);
    internal virtual mhg= ARk=(mRo= xy, whg= pjConsts, Int32& pj_Error);
    internal virtual mRo= Ahk=(mhg= lp, whg= pjConsts, Int32& pj_Error);
}
internal class HRU=.Bxo= : jBo= {
    internal BRo=[] CBo=;
    internal BRo=[] CRo=;
    internal Bxo=(string id, string desc);
    private void 9xg=();
    internal virtual whg= /Bg=(whg= pjConsts, Int32& pj_Error);
    internal virtual void Axk=(mhg= lp, whg= pjConsts, TRg= fac, Int32& pj_Error);
    internal virtual mhg= ARk=(mRo= xy, whg= pjConsts, Int32& pj_Error);
    internal virtual mRo= Ahk=(mhg= lp, whg= pjConsts, Int32& pj_Error);
}
internal class HRU=.bys= : ValueType {
    public double mho=;
    public double mxo=;
}
internal enum HRU=.ByU= : Enum {
    public int value__;
    public static ByU= CCU=;
    public static ByU= CSU=;
    public static ByU= CiU=;
}
internal class HRU=.cBo= : jBo= {
    internal double GRk=;
    internal cBo=(string id, string desc);
    private void 9xg=();
    internal virtual whg= /Bg=(whg= pjConsts, Int32& pj_Error);
    internal virtual void Axk=(mhg= lp, whg= pjConsts, TRg= fac, Int32& pj_Error);
    internal virtual mhg= ARk=(mRo= xy, whg= pjConsts, Int32& pj_Error);
    internal virtual mRo= Ahk=(mhg= lp, whg= pjConsts, Int32& pj_Error);
}
internal class HRU=.CCk= : CyU= {
    private string 8SU=;
    private Stream Wyg=;
    private FSg= 8iU=;
    private Lig= CSk=;
    private int Cik=;
    private FSk=[] Cyk=;
    private Byte[][] DCk=;
    private static int DSk=;
    private int Dik=(int nIndexNumber);
    private int Dyk=();
    private int Qx8=();
    public int GR8=(string pszFname, FileAccess pszAccess, bool bTestOpenNoError);
    public int pR8=();
    public int ECk=(int nIndexNumber, vig= eType);
    public Byte[] ESk=(int nIndexNumber, int nValue);
    public Byte[] ESk=(int nIndexNumber, string pszStr);
    public Byte[] ESk=(int nIndexNumber, double dValue);
    public int Eik=(int nIndexNumber, Byte[] pKeyValue);
    public int Eyk=(vig= eType, int nFieldSize);
    public int FCk=(int nIndexNumber, Byte[] pKeyValue, int nRecordNo);
    public sealed virtual void Dispose();
}
internal class HRU=.cCs= : gCU= {
    private string 8SU=;
    private FSg= 8iU=;
    private List`1<string> yig=;
    private string cSs=;
    private List`1<string> cis=;
    private List`1<ySg=> cys=;
    private int dCs=;
    private int dSs=;
    private List`1<string> dis=;
    private List`1<string> dys=;
    private /Co= eCs=;
    private bool eSs=;
    private int HCs=(string pszFname, bool bTestOpenNoError);
    private int eis=(string pszFname);
    private int eys=(string pszDatasetPath, bool bTestOpenNoError);
    private int 1yg=();
    public virtual int Close();
    public virtual int GetFeatureCount(bool bForce);
    public virtual void ResetReading();
    public virtual int Open(string pszFname, FileAccess pszAccess, bool bTestOpenNoError);
    public virtual int SetQuickSpatialIndexMode(bool bQuickSpatialIndexMode);
    public virtual int GetNextFeatureId(int nPrevId);
    public virtual iSg= GetFeatureRef(int nFeatureId);
    public virtual int SetFeature(iSg= poFeature, int nFeatureId);
    public virtual PCc= GetLayerDefn();
    public virtual int SetFeatureDefn(PCc= poFeatureDefn, List`1<vig=> paeMapInfoNativeFieldTypes);
    public virtual vig= GetNativeFieldType(int nFieldId);
    public virtual int AddFieldNative(string pszName, vig= eMapInfoType, int nWidth, int nPrecision, bool bIndexed, bool bUnique);
    public virtual int SetFieldIndexed(int nFieldId);
    public virtual bool IsFieldIndexed(int nFieldId);
    public virtual bool IsFieldUnique(int nFieldId);
    public virtual int GetBounds(Double& dXMin, Double& dYMin, Double& dXMax, Double& dYMax, bool bForce);
    public virtual qiY= GetExtent(Hyc= psExtent, bool bForce);
    public virtual int GetFeatureCountByType(Int32& numPoints, Int32& numLines, Int32& numRegions, Int32& numTexts, bool bForce);
    public virtual qSc= GetSpatialRef();
    public virtual int SetSpatialRef(qSc= poSpatialRef);
    public virtual int SetBounds(double dXMin, double dYMin, double dXMax, double dYMax);
    public virtual bool TestCapability(string pszCap);
}
internal class HRU=.ch8= : tR8= {
    public ch8=(dB8= page);
    internal virtual bool cx8=(6B8= insertRec, tR8=[]& nodeList);
}
internal class HRU=.cho= : jBo= {
    internal double GRk=;
    internal int DRk=;
    internal cho=(string id, string desc);
    private void 9xg=();
    internal virtual whg= /Bg=(whg= pjConsts, Int32& pj_Error);
    internal virtual void Axk=(mhg= lp, whg= pjConsts, TRg= fac, Int32& pj_Error);
    internal virtual mhg= ARk=(mRo= xy, whg= pjConsts, Int32& pj_Error);
    internal virtual mRo= Ahk=(mhg= lp, whg= pjConsts, Int32& pj_Error);
}
internal class HRU=.Cho= : ValueType {
    internal int Cxo=;
    internal double zBg=;
    internal double DBo=;
    internal Double[] pBk=;
    public Cho=(int nb, double es, double E, Double[] b);
}
internal class HRU=.ci4= : object {
    [CompilerGeneratedAttribute]
private string uC0=;
    [CompilerGeneratedAttribute]
private int cy4=;
    [CompilerGeneratedAttribute]
private int dC4=;
    [CompilerGeneratedAttribute]
private int XC0=;
    public string wC0= { get; public set; }
    public int dy4= { get; public set; }
    public int ei4= { get; public set; }
    public int ZC0= { get; public set; }
    [CompilerGeneratedAttribute]
public string vi0=();
    [CompilerGeneratedAttribute]
public void vy0=(string value);
    [CompilerGeneratedAttribute]
public int dS4=();
    [CompilerGeneratedAttribute]
public void di4=(int value);
    [CompilerGeneratedAttribute]
public int eC4=();
    [CompilerGeneratedAttribute]
public void eS4=(int value);
    [CompilerGeneratedAttribute]
public int Yi0=();
    [CompilerGeneratedAttribute]
public void Yy0=(int value);
}
internal class HRU=.Ci4= : object {
    private double /yw=;
    private Encoding FR8=;
    [CompilerGeneratedAttribute]
private List`1<string> Cy4=;
    [CompilerGeneratedAttribute]
private FeatureLayer DC4=;
    [CompilerGeneratedAttribute]
private int DS4=;
    [CompilerGeneratedAttribute]
private Collection`1<string> Di4=;
    public List`1<string> ES4= { get; public set; }
    public FeatureLayer FC4= { get; public set; }
    public int Fy4= { get; private set; }
    public Collection`1<string> Gi4= { get; private set; }
    public double HC4= { get; }
    public Encoding Hi4= { get; }
    public Ci4=(FeatureLayer featureLayer, IEnumerable`1<string> columnNames, Viw= accuracy, Collection`1<string> ids, double extentWidthLimitation, Encoding encoding);
    [CompilerGeneratedAttribute]
public List`1<string> Dy4=();
    [CompilerGeneratedAttribute]
public void EC4=(List`1<string> value);
    [CompilerGeneratedAttribute]
public FeatureLayer Ei4=();
    [CompilerGeneratedAttribute]
public void Ey4=(FeatureLayer value);
    [CompilerGeneratedAttribute]
public int FS4=();
    [CompilerGeneratedAttribute]
private void Fi4=(int value);
    [CompilerGeneratedAttribute]
public Collection`1<string> GC4=();
    [CompilerGeneratedAttribute]
private void GS4=(Collection`1<string> value);
    public double Gy4=();
    public Encoding HS4=();
    private static int Hy4=(Viw= accuracy);
}
internal class HRU=.Ciw= : ValueType {
    [CompilerGeneratedAttribute]
private int Cyw=;
    [CompilerGeneratedAttribute]
private int DCw=;
    [CompilerGeneratedAttribute]
private int DSw=;
    [CompilerGeneratedAttribute]
private int Diw=;
    public int ESw= { get; public set; }
    public int FCw= { get; public set; }
    public int Fyw= { get; public set; }
    public int Giw= { get; public set; }
    [yhM=]
[CompilerGeneratedAttribute]
public int Dyw=();
    [CompilerGeneratedAttribute]
public void ECw=(int value);
    [yhM=]
[CompilerGeneratedAttribute]
public int Eiw=();
    [CompilerGeneratedAttribute]
public void Eyw=(int value);
    [CompilerGeneratedAttribute]
[yhM=]
public int FSw=();
    [CompilerGeneratedAttribute]
public void Fiw=(int value);
    [CompilerGeneratedAttribute]
[yhM=]
public int GCw=();
    [CompilerGeneratedAttribute]
public void GSw=(int value);
    public virtual string ToString();
}
internal class HRU=.cRo= : jBo= {
    internal double GRk=;
    internal cRo=(string id, string desc);
    private void 9xg=();
    internal virtual whg= /Bg=(whg= pjConsts, Int32& pj_Error);
    internal virtual void Axk=(mhg= lp, whg= pjConsts, TRg= fac, Int32& pj_Error);
    internal virtual mhg= ARk=(mRo= xy, whg= pjConsts, Int32& pj_Error);
    internal virtual mRo= Ahk=(mhg= lp, whg= pjConsts, Int32& pj_Error);
}
internal class HRU=.CSo= : HSU= {
    public byte Cio=;
    public int Cyo=;
    public int Oyk=;
    public int PCk=;
    public int PSk=;
    public int Pik=;
    public static CSo= DCo=(byte nNewObjType, int nId);
    public static CSo= DSo=(7Ck= poObjBlock, mSk= poHeader);
    public bool Dio=();
    public int Dyo=(7Ck= poObjBlock);
    public void myg=(int nMinX, int nMinY, int nMaxX, int nMaxY);
    public virtual int 3Sk=(7Ck= poObjBlock);
    public virtual int 3ik=(7Ck= poObjBlock);
}
internal class HRU=.CSw= : ValueType {
    [CompilerGeneratedAttribute]
private int Ehw=;
    [CompilerGeneratedAttribute]
private int Exw=;
    public int /iI= { get; public set; }
    public int ASM= { get; public set; }
    public CSw=(int x, int y);
    [yhM=]
[CompilerGeneratedAttribute]
public int /CI=();
    [CompilerGeneratedAttribute]
public void /SI=(int value);
    [CompilerGeneratedAttribute]
[yhM=]
public int /yI=();
    [CompilerGeneratedAttribute]
public void ACM=(int value);
    public virtual bool Equals(object obj);
    private bool lhU=(CSw= pointI);
    public static bool 3hM=(CSw= a, CSw= b);
    public static bool 3xM=(CSw= a, CSw= b);
    public virtual int GetHashCode();
}
internal class HRU=.CSY= : gCU= {
    private string 8SU=;
    private FSg= 8iU=;
    private int CiY=;
    private string 7SU=;
    private string CyY=;
    private string DCY=;
    private string DSY=;
    private List`1<vig=> DiY=;
    private List`1<bool> DyY=;
    private List`1<bool> ECY=;
    private double 8yU=;
    private double 9CU=;
    private double 9SU=;
    private double 9iU=;
    private double ESY=;
    private double EiY=;
    private double EyY=;
    private double FCY=;
    private int FSY=;
    private Hyc= FiY=;
    private int FyY=;
    private int GCY=;
    private int GSY=;
    private int GiY=;
    private int GyY=;
    private 6yU= HCY=;
    private 6yU= HSY=;
    private PCc= HiY=;
    private qSc= HyY=;
    private int ICY=;
    private int ISY=;
    private bool IiY=;
    private bool IyY=;
    private int JCY=();
    private void JSY=();
    private int JiY=(string pszLine);
    private int JyY=(int nFeatureId);
    private int KCY=();
    private int KSY=();
    private void KiY=(double dfX, double dfY);
    public virtual int Close();
    public virtual 2ig= GetFileClass();
    public virtual int Open(string pszFname, FileAccess pszAccess, bool bTestOpenNoError);
    public virtual string GetTableName();
    public virtual bool TestCapability(string pszCap);
    public virtual int GetFeatureCount(bool bForce);
    public virtual void ResetReading();
    public virtual qiY= GetExtent(Hyc= psExtent, bool bForce);
    public virtual int GetNextFeatureId(int nPrevId);
    public virtual iSg= GetFeatureRef(int nFeatureId);
    public virtual PCc= GetLayerDefn();
    public virtual vig= GetNativeFieldType(int nFieldId);
    public virtual int GetBounds(Double& dXMin, Double& dYMin, Double& dXMax, Double& dYMax, bool bForce);
    public virtual qSc= GetSpatialRef();
    public virtual int GetFeatureCountByType(Int32& numPoints, Int32& numLines, Int32& numRegions, Int32& numTexts, bool bForce);
    public virtual bool IsFieldIndexed(int nFieldId);
    public virtual bool IsFieldUnique(int nFieldId);
    public virtual int SetBounds(double dXMin, double dYMin, double dXMax, double dYMax);
    public virtual int SetFeatureDefn(PCc= poFeatureDefn, List`1<vig=> paeMapInfoNativeFieldTypes);
    public virtual int AddFieldNative(string pszName, vig= eMapInfoType, int nWidth, int nPrecision, bool bIndexed, bool bUnique);
    public virtual int SetSpatialRef(qSc= poSpatialRef);
    public virtual int SetFeature(iSg= poFeature, int nFeatureId);
    public virtual int SetFieldIndexed(int nFieldId);
    public virtual int GetProjInfo(iCo= poPI);
    public virtual int SetProjInfo(iCo= poPI);
    public virtual int SetMIFCoordSys(string pszMIFCoordSys);
    public void 1x0=();
    private sealed virtual override void System.IDisposable.Dispose();
}
internal class HRU=.cxo= : object {
    private jBo= dBo=;
    private Dictionary`2<string, string> dRo=;
    internal jBo= dxo= { get; }
    internal cxo=(Dictionary`2<string, string> proj_List);
    private string eBo=(Dictionary`2<string, string> args);
    internal void eRo=(Dictionary`2<string, string> args);
    internal jBo= dho=();
    private bool eho=(string projID);
}
internal class HRU=.CyU= : HSU= {
    public static zSo= DCU=(Stream fsSrc, int nOffset, int nSize, bool bHardBlockSize, FSg= eAccessMode);
    public static int DSU=(Char[] charArray);
    public static Char[] DiU=(Char[] szCharSet, Char[] szCharSetToBeFound);
    public static int DyU=(Char[] numCharArray);
    public static int ECU=(int nGeomType);
    public static bool ESU=(int numSegments, int umVerticesTotal);
    public static int EiU=(double dX);
    public static byte EyU=(int color);
    public static byte FCU=(int color);
    public static byte FSU=(int color);
    public static bool FiU=(string charArray1, string charArray2, int count);
    public static bool FyU=(string charArray1, string charArray2);
    public static T[] GCU=(T[] srcArray, int destLength);
    public static void GSU=(Double& min, Double& max);
    public static void GSU=(Int32& min, Int32& max);
    public static string GiU=(vig= type);
    public static ryY= GyU=(int x);
    public static bool HCU=(T[] src, int indexSrc, T[] dest, int indexDest, int count);
}
internal class HRU=.dB8= : sR8= {
    public dB8=(RtreeFile rtFile, UInt32 pageNo, Gist_Ext_Id extId);
    public dB8=(RtreeFile rtFile, Gist_Ext_Id extId);
    internal virtual 6B8= dR8=();
    internal virtual int dh8=();
    internal virtual bool dx8=(lB8= ent, int idx);
}
internal class HRU=.DC8= : object {
    private int fC4=;
    private int fi4=;
    private int fS4=;
    private int fy4=;
    private byte 8yw=;
    private ushort DS8=;
    public int 0C0= { get; }
    public int 0y0= { get; }
    public int 1i0= { get; }
    public int 2S0= { get; }
    public byte kC0= { get; }
    public ushort Iy0= { get; }
    public int zi0=();
    public int 0S0=();
    public int 1C0=();
    public int 1y0=();
    public byte ji0=();
    public ushort IS0=();
    public void pBw=(Stream stream, int treOffset);
}
internal class HRU=.dCc= : Zyc= {
    private int dSc=;
    private Zyc=[] dic=;
    public virtual string byc=();
    public virtual ryY= bic=();
    public virtual Zyc= aic=();
    public virtual qiY= bSc=(String& ppszDstText);
    public virtual void ayc=(Hyc= psEnvelope);
    public int dyc=();
    public Zyc= eCc=(int i);
    public virtual qiY= eSc=(Zyc= poNewGeom);
    public virtual qiY= eic=(Zyc= poNewGeom);
    public virtual qiY= eyc=(int iGeom, int bDelete);
}
internal class HRU=.Di8= : object {
    private jCw= Dy8=;
    private string Ly4=;
    public Di8=(string tGeoFilePathName);
    public void Qx8=(List`1<ti0=> shifterTGeoFATs, Ci4= tGeoParameters, double extentWidthLimitation, TinyGeoFileType type);
    private void EC8=(ti0= shifterTGeoFAT, int startPart, Encoding encoding);
    public void ES8=(string rgnTempPath);
    public void Ei8=(string treTempPath);
    public void Ey8=(string lblTempPath);
    public void pR8=();
}
internal enum HRU=.diY= : Enum {
    public int value__;
    public static diY= dyY=;
    public static diY= eCY=;
    public static diY= eSY=;
    public static diY= eiY=;
    public static diY= eyY=;
    public static diY= fCY=;
    public static diY= fSY=;
    public static diY= fiY=;
    public static diY= fyY=;
    public static diY= gCY=;
    public static diY= gSY=;
    public static diY= giY=;
}
internal class HRU=.DRo= : jBo= {
    internal double Dho=;
    internal double Dxo=;
    internal double EBo=;
    internal double ERo=;
    internal double Eho=;
    internal double Exo=;
    internal double FBo=;
    internal double FRo=;
    internal double Fho=;
    internal double Fxo=;
    internal double GBo=;
    internal double GRo=;
    internal double Gho=;
    internal double Gxo=;
    internal double HBo=;
    internal double mBc=;
    internal double mRc=;
    internal double mhc=;
    internal double mxc=;
    internal double nBc=;
    internal double HRo=;
    internal double Hho=;
    internal double Hxo=;
    internal double rhc=;
    internal double IBo=;
    internal double IRo=;
    internal double Iho=;
    internal double rxc=;
    internal double Ixo=;
    internal double JBo=;
    internal double JRo=;
    internal double Jho=;
    internal double Jxo=;
    internal double KBo=;
    internal Cho= 9Rg=;
    private int dBc=;
    internal DRo=(string id, string desc);
    private void 9xg=();
    internal virtual whg= /Bg=(whg= pjConsts, Int32& pj_Error);
    internal virtual void Axk=(mhg= lp, whg= pjConsts, TRg= fac, Int32& pj_Error);
    internal virtual mhg= ARk=(mRo= xy, whg= pjConsts, Int32& pj_Error);
    internal virtual mRo= Ahk=(mhg= lp, whg= pjConsts, Int32& pj_Error);
    private Cho= KRo=(double es);
    private double Kho=(double phi, double sphi, double cphi, Cho= b, Int32& pj_Error);
    private double Kxo=(double dist, Cho= b, Int32& pj_Error);
}
internal class HRU=.dSM= : FilterCondition {
    private bool diM=;
    private static string dyM=;
    private static string eCM=;
    private static string eSM=;
    private static char eiM=;
    [CompilerGeneratedAttribute]
private Regex eyM=;
    [CompilerGeneratedAttribute]
private String[] fCM=;
    [CompilerGeneratedAttribute]
private String[] fSM=;
    public Regex gCM= { get; public set; }
    public String[] gyM= { get; public set; }
    public String[] hiM= { get; public set; }
    internal dSM=(string columnName, string operation, string expression);
    [CompilerGeneratedAttribute]
public Regex fiM=();
    [CompilerGeneratedAttribute]
public void fyM=(Regex value);
    [CompilerGeneratedAttribute]
public String[] gSM=();
    [CompilerGeneratedAttribute]
public void giM=(String[] value);
    [CompilerGeneratedAttribute]
public String[] hCM=();
    [CompilerGeneratedAttribute]
public void hSM=(String[] value);
    internal virtual bool TSM=(KeyValuePair`2<string, string> v);
    internal virtual bool TSM=(Feature feature);
}
internal class HRU=.dy8= : object {
    private string aS8=;
    private string eC8=;
    private string eS8=;
    private string ei8=;
    private string ey8=;
    private string fC8=;
    private string fS8=;
    private string fi8=;
    public bool gC8= { get; }
    public string gy8= { get; public set; }
    public string hi8= { get; public set; }
    public bool fy8=();
    public string gS8=();
    public void gi8=(string value);
    public string hC8=();
    public void hS8=(string value);
    public void pBw=(BinaryReader reader);
}
internal class HRU=.eB8= : RTPage {
    protected 2R8= eR8=;
    protected /B8= eh8=;
    protected int ex8=;
    protected static int fB8=;
    protected static string fR8=;
    public 2R8= gB8= { get; public set; }
    public eB8=(RtreeFile rtFile, UInt32 pageNo, Gist_Ext_Id extId);
    public eB8=(RtreeFile rtFile, Gist_Ext_Id extId);
    internal virtual bool gR8=(6B8= rec);
    internal virtual void gh8=(int idx);
    public virtual bool gx8=();
    public 2R8= fh8=();
    public void fx8=(2R8= value);
    internal ushort hB8=();
    internal void hR8=(ushort level);
    internal void hh8=(UInt32 pageNo);
    internal void hx8=();
    public int iB8=();
    public bool iR8=();
    public bool ih8=();
    public bool ix8=();
    public bool jB8=();
    public virtual 6B8= jR8=();
    public virtual 6B8= jh8=();
    public bool jx8=();
    public virtual 6B8= kB8=(int idx);
    internal virtual int dh8=();
    public virtual string kR8=();
    public virtual BCA= kh8=();
    public UInt32 kx8=();
    internal virtual bool dx8=(lB8= ent, int idx);
}
[DefaultMemberAttribute("Item")]
internal class HRU=.eCE= : tCE= {
    private static hiE= ViE=;
    private eiE= WSE=;
    public eiE= aSE= { get; }
    public string xhw= { get; public set; }
    public eCE=(eiE= headerRecord);
    public eCE=(eiE= headerRecord, String[] values);
    public eCE=(eiE= headerRecord, bool readOnly, String[] values);
    public eCE=(eiE= headerRecord, IEnumerable`1<string> values);
    public eCE=(eiE= headerRecord, bool readOnly, IEnumerable`1<string> values);
    internal eCE=(eiE= headerRecord, IList`1<string> values);
    private static eCE=();
    public eiE= ZyE=();
    public string xBw=(string columnName);
    public void xRw=(string columnName, string value);
    public string eSE=(string columnName);
    public sealed virtual bool Equals(eCE= other);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
}
internal class HRU=.ECo= : CSo= {
    public int ESo=;
    public int Eio=;
}
internal class HRU=.eiA= : object {
    private static double eyA=;
    private static int fCA=;
    private static int fSA=;
    private static int fiA=;
    private static int fyA=;
    private static int gCA=;
    private static float gSA=;
    private static float giA=;
    private static float gyA=;
    private static int hCA=;
    private static int hSA=;
    private static double XhY=;
    private static double hiA=;
    private static double hyA=;
    private Double[] iCA=;
    private Double[] iSA=;
    private Double[] iiA=;
    private Double[] iyA=;
    private Int32[] jCA=;
    private Int32[] jSA=;
    private Int32[] jiA=;
    private Int32[] jyA=;
    private String[] kCA=;
    private Single[] kSA=;
    private Single[] kiA=;
    private Single[] kyA=;
    private Single[] lCA=;
    private Single[] lSA=;
    private int liA=;
    private int lyA=;
    private int mCA=;
    private int mSA=;
    private int miA=;
    private int myA=;
    private float nCA=;
    private float nSA=;
    private float niA=;
    private float nyA=;
    private float oCA=;
    private double oSA=;
    private double oiA=;
    private double oyA=;
    private double pCA=;
    private double CBo=;
    private double CRo=;
    private double pSA=;
    private double GBg=;
    private double hBc=;
    private double piA=;
    private double pyA=;
    private double qCA=;
    private double qSA=;
    private double qiA=;
    private double qyA=;
    private double rCA=;
    private double rSA=;
    private double riA=;
    private double ryA=;
    private double sCA=;
    private double sSA=;
    private double siA=;
    private double syA=;
    private double tCA=;
    private double tSA=;
    private double tiA=;
    private double tyA=;
    private 3yA= uCA=;
    public double uyA= { get; public set; }
    public double viA= { get; public set; }
    public double wCA= { get; }
    public float wyA= { get; public set; }
    public double uSA=();
    public void uiA=(double value);
    public double vCA=();
    public void vSA=(double value);
    public double vyA=();
    public float wSA=();
    public void wiA=(float value);
    private void xCA=(3yA= Msg, string Caller);
    private void xSA=(Stream magneticFieldStream);
    private static double xiA=(DateTime myDate);
    public void xyA=(string magneticFieldFilePathName, DateTime thisDate, double Lat, double Lon, float Elevation, zSA=& Result);
    public void xyA=(Stream magneticFieldStream, DateTime thisDate, double Lat, double Lon, float Elevation, zSA=& Result);
    private int yCA=(Stream magneticFieldStream, int iflag, long StartRec, int nMax_of_GH, int GH);
    private int ySA=(double mYear, double dTe1, int nMax1, int nMax2, int GH);
    private int yiA=(double mYear, double dte1, int nmax1, double dte2, int nmax2, int gh);
    private int yyA=(int IDGDC, double fLat, double fLon, float Elev, int nMax, int gh, int iExt, float Ext1, float Ext2, float Ext3);
    private int zCA=(int GH);
}
internal enum HRU=.Eic= : Enum {
    public int value__;
    public static Eic= Eyc=;
    public static Eic= FCc=;
    public static Eic= FSc=;
    public static Eic= Fic=;
    public static Eic= Fyc=;
    public static Eic= GCc=;
    public static Eic= GSc=;
    public static Eic= Gic=;
}
[DefaultMemberAttribute("Item")]
internal class HRU=.eiE= : tCE= {
    private static hiE= ViE=;
    private IDictionary`2<string, int> eyE=;
    public int xhw= { get; }
    public string Item { get; public set; }
    public eiE=(String[] columnNames);
    public eiE=(bool readOnly, String[] columnNames);
    public eiE=(IEnumerable`1<string> columnNames);
    public eiE=(bool readOnly, IEnumerable`1<string> columnNames);
    internal eiE=(IList`1<string> columnNames);
    private static eiE=();
    public int xBw=(string columnName);
    public Nullable`1<int> fCE=(string columnName);
    public virtual string get_Item(int index);
    public virtual void set_Item(int index, string value);
    public virtual void Add(string value);
    public virtual void Insert(int index, string value);
    public virtual void Clear();
    public virtual bool Remove(string value);
    public virtual void RemoveAt(int index);
    private void fSE=(int startIndex, bool checkForDuplicates);
}
internal enum HRU=.ESg= : Enum {
    public int value__;
    public static ESg= Eig=;
    public static ESg= Eyg=;
    public static ESg= FCg=;
}
internal class HRU=.ETA= : object {
    private String[] EjA=;
    private int EzA=;
    public ETA=(TextReader reader, Char[] delimiter);
    public string FDA=();
}
internal class HRU=.exk= : jBo= {
    internal double thc=;
    internal double txc=;
    internal double uRc=;
    internal int Uxk=;
    internal exk=(string id, string desc);
    private void 9xg=();
    internal virtual whg= /Bg=(whg= pjConsts, Int32& pj_Error);
    internal virtual void Axk=(mhg= lp, whg= pjConsts, TRg= fac, Int32& pj_Error);
    internal virtual mhg= ARk=(mRo= xy, whg= pjConsts, Int32& pj_Error);
    internal virtual mRo= Ahk=(mhg= lp, whg= pjConsts, Int32& pj_Error);
}
internal class HRU=.exo= : object {
    internal string fBo=;
    internal string fRo=;
    internal exo=(string id, string defn, string ellipse_id);
}
internal class HRU=.ey4= : object {
    private double yS0=;
    private double fC4=;
    private double fS4=;
    private double fi4=;
    private double fy4=;
    private long gC4=;
    private long gS4=;
    private long gi4=;
    private long gy4=;
    private string Ly4=;
    private List`1<uiw=> hC4=;
    private List`1<8y4=> hS4=;
    private qi4= hi4=;
    private pi4= hy4=;
    private Stream iC4=;
    private BinaryReader iS4=;
    private double /yw=;
    private string 0Cw=;
    [CompilerGeneratedAttribute]
private EventHandler`1<StreamLoadingEventArgs> Eh8=;
    public ey4=(string tGeoFilePathName);
    [CompilerGeneratedAttribute]
public void oR8=(EventHandler`1<StreamLoadingEventArgs> value);
    [CompilerGeneratedAttribute]
public void oh8=(EventHandler`1<StreamLoadingEventArgs> value);
    public void GR8=(bool isEncrypted, string password);
    public TinyGeoFileType ii4=();
    private String[] iy4=(bool isEncrypted);
    public void jC4=(bool isEncrypted);
    private void jS4=();
    public RectangleShape rBo=();
    public Collection`1<FeatureSourceColumn> ji4=();
    public void jy4=(string targetFile);
    public void mxQ=(string targetFile);
    private void kC4=(string targetFile);
    private void kS4=(string targetFile);
    private void ki4=(string targetFile);
    private void ky4=(string targetFile);
    private void lC4=(string targetFile);
    private void lS4=(string targetFile);
    private void li4=(string targetFile);
    private void ly4=(string targetFile);
    private void mC4=(string targetFile);
    private void mS4=(string targetFile, USw= encryptMode);
    private List`1<uiw=> mi4=(uiw= node);
    private List`1<uiw=> my4=(RectangleShape box, uiw= node);
    public void nC4=();
    public List`1<Feature> nS4=(IEnumerable`1<string> ids, IEnumerable`1<string> returningColumnNames);
    public List`1<Feature> nS4=(RectangleShape box, IEnumerable`1<string> returningColumnNames, int startIndex, int takeCount);
    public List`1<Feature> nS4=(RectangleShape box, IEnumerable`1<string> returningColumnNames);
    private OS4= ni4=(RectangleShape rect);
    private Dictionary`2<string, int> ny4=(IEnumerable`1<string> returningColumnNames);
    public void pB8=(StreamLoadingEventArgs e);
    private void oC4=(List`1<8iw=> rtree);
    public String[] oS4=(bool isEncrypted);
    public void oi4=();
    public void oy4=(Int32[] select, bool isEncrypted);
    public void oy4=(bool isEncrypted);
    private void pC4=(bool isEncrypted);
    public List`1<Feature> pS4=(OS4= range, List`1<uiw=> queryIndeces, Dictionary`2<string, int> returningColumns, int startIndex, int takeCount);
    public List`1<Feature> pS4=(IEnumerable`1<string> ids, Dictionary`2<string, int> returningColumns);
    public void pR8=();
}
internal class HRU=.Eyo= : CSo= {
    public int FCo=;
    public int FSo=;
    public int Fio=;
    public int Fyo=;
    public byte 3Ck=;
    public virtual int 3Sk=(7Ck= poObjBlock);
    public virtual int 3ik=(7Ck= poObjBlock);
}
internal class HRU=.EzE= : object {
    public sealed virtual int Compare(FeatureLabelingCandidate x, FeatureLabelingCandidate y);
}
internal class HRU=.fBk= : jBo= {
    internal double thc=;
    internal double txc=;
    internal double QRk=;
    internal double Qhk=;
    internal fBk=(string id, string desc);
    private void 9xg=();
    internal virtual whg= /Bg=(whg= pjConsts, Int32& pj_Error);
    internal virtual void Axk=(mhg= lp, whg= pjConsts, TRg= fac, Int32& pj_Error);
    internal virtual mhg= ARk=(mRo= xy, whg= pjConsts, Int32& pj_Error);
    internal virtual mRo= Ahk=(mhg= lp, whg= pjConsts, Int32& pj_Error);
}
internal class HRU=.FBk= : jBo= {
    internal double FRk=;
    internal double Bhk=;
    internal double Bxk=;
    internal double Fhk=;
    internal int DRk=;
    internal int Fxk=;
    internal FBk=(string id, string desc);
    private void 9xg=();
    internal virtual whg= /Bg=(whg= pjConsts, Int32& pj_Error);
    internal virtual void Axk=(mhg= lp, whg= pjConsts, TRg= fac, Int32& pj_Error);
    internal virtual mhg= ARk=(mRo= xy, whg= pjConsts, Int32& pj_Error);
    internal virtual mRo= Ahk=(mhg= lp, whg= pjConsts, Int32& pj_Error);
}
internal class HRU=.FBs= : object {
    private static FBs= FRs=;
    private GeoJsonSerializeStrategy Fhs=;
    public static FBs= GBs= { get; }
    public GeoJsonSerializeStrategy Gxs= { get; public set; }
    public static FBs= Fxs=();
    public GeoJsonSerializeStrategy GRs=();
    public void Ghs=(GeoJsonSerializeStrategy value);
    public string HBs=(XElement xElement);
    public string HRs=(object obj);
    public XElement Hhs=(object obj);
    public XElement Hxs=(string json);
    public XElement Hxs=(string json, Encoding encoding);
    public T IBs=(XElement xElement);
    public T IRs=(string json, Encoding encoding);
    private static string Ihs=(XElement element);
    private static XAttribute Ixs=(GeoJsonType type);
    private object JBs=(object obj);
    private IEnumerable`1<XElement> JRs=(object obj);
    private static string Jhs=(PropertyInfo property);
    private IEnumerable`1<XElement> Jxs=(T obj);
    private GeoJsonType KBs=(object obj);
    [CompilerGeneratedAttribute]
private XElement KRs=(object o);
}
internal class HRU=.FC8= : object {
    private jCw= FS8=;
    private int Fi8=;
    private int 0RM=;
    public FC8=(string outPut);
    public void Ey8=(8y0= lblPara, Encoding encoding);
    public void pR8=();
    public void Fy8=();
}
internal abstract class HRU=.fCc= : object {
    protected bool fSc=;
    protected Zyc= fic=;
    protected Hyc= fyc=;
    protected bool gCc=(Zyc= poGeometry);
    protected bool gSc=(Zyc= poFilter);
    public virtual void SetSpatialFilter(Zyc= poGeomIn);
    public abstract virtual void ResetReading();
    public virtual JCc= GetNextFeature();
    public virtual JCc= GetFeature(long nFID);
    public virtual qiY= CreateFeature(JCc= poFeature);
    public abstract virtual PCc= GetLayerDefn();
    public virtual qSc= GetSpatialRef();
    public virtual int GetFeatureCount(bool bForce);
    public virtual qiY= GetExtent(Hyc= psExtent, bool bForce);
    public abstract virtual bool TestCapability(string pszCap);
}
internal enum HRU=.fCs= : Enum {
    public byte value__;
    public static fCs= RSU=;
    public static fCs= RiU=;
    public static fCs= RyU=;
    public static fCs= SCU=;
    public static fCs= SSU=;
    public static fCs= SiU=;
    public static fCs= SyU=;
    public static fCs= TCU=;
    public static fCs= TSU=;
    public static fCs= TiU=;
    public static fCs= TyU=;
    public static fCs= UCU=;
    public static fCs= USU=;
    public static fCs= UiU=;
    public static fCs= UyU=;
    public static fCs= VCU=;
    public static fCs= VSU=;
    public static fCs= ViU=;
    public static fCs= VyU=;
    public static fCs= WCU=;
    public static fCs= WSU=;
    public static fCs= WiU=;
    public static fCs= WyU=;
    public static fCs= XCU=;
    public static fCs= XSU=;
    public static fCs= XiU=;
    public static fCs= XyU=;
    public static fCs= YCU=;
    public static fCs= YSU=;
    public static fCs= YiU=;
    public static fCs= YyU=;
    public static fCs= ZCU=;
    public static fCs= ZSU=;
    public static fCs= ZiU=;
    public static fCs= ZyU=;
    public static fCs= aCU=;
    public static fCs= aSU=;
    public static fCs= aiU=;
    public static fCs= ayU=;
    public static fCs= bCU=;
    public static fCs= bSU=;
    public static fCs= biU=;
    public static fCs= byU=;
}
internal class HRU=.FCs= : gCU= {
    private string 8SU=;
    private string FSs=;
    private PCc= Fis=;
    private ySg= Fys=;
    private int GCs=;
    private int GSs=;
    private ySg= Gis=;
    private bool Gys=;
    private int HCs=(string pszFname, bool bTestOpenNoError);
    private int HSs=(iSg= poIndexFeature, bool bTestOpenNoError);
    private int HSs=(int nTableId, bool bTestOpenNoError);
    private int His=(bool bTestOpenNoError);
    private int Hys=(int nTableId, int nBaseFeatureId);
    private int ICs=(int nEncodedFeatureId);
    private int ISs=(int nEncodedFeatureId);
    public virtual int Close();
    public virtual 2ig= GetFileClass();
    public virtual int Open(string pszFname, FileAccess pszAccess, bool bTestOpenNoError);
    public virtual string GetTableName();
    public virtual void SetSpatialFilter(Zyc= poGeomIn);
    public virtual void ResetReading();
    public virtual bool TestCapability(string pszCap);
    public virtual int GetFeatureCount(bool bForce);
    public virtual qiY= GetExtent(Hyc= psExtent, bool bForce);
    public virtual int GetNextFeatureId(int nPrevId);
    public virtual iSg= GetFeatureRef(int nFeatureId);
    public virtual PCc= GetLayerDefn();
    public virtual vig= GetNativeFieldType(int nFieldId);
    public virtual int GetBounds(Double& dXMin, Double& dYMin, Double& dXMax, Double& dYMax, bool bForce);
    public virtual qSc= GetSpatialRef();
    public virtual int GetFeatureCountByType(Int32& numPoints, Int32& numLines, Int32& numRegions, Int32& numTexts, bool bForce);
    public virtual bool IsFieldIndexed(int nFieldId);
    public virtual bool IsFieldUnique(int nFieldId);
    public virtual int SetBounds(double dXMin, double dYMin, double dXMax, double dYMax);
    public virtual int SetFeatureDefn(PCc= poFeatureDefn, List`1<vig=> paeMapInfoNativeFieldTypes);
    public virtual int AddFieldNative(string pszName, vig= eMapInfoType, int nWidth, int nPrecision, bool bIndexed, bool bUnique);
    public virtual int SetSpatialRef(qSc= poSpatialRef);
    public virtual int SetFeature(iSg= poFeature, int nFeatureId);
    public virtual int SetFieldIndexed(int nFieldId);
    public virtual int GetProjInfo(iCo= poPI);
    public virtual int SetProjInfo(iCo= poPI);
    public virtual int SetMIFCoordSys(string pszMIFCoordSys);
}
internal class HRU=.FDE= : object {
    private double FTE=;
    private double FjE=;
    private PointShape FzE=;
    public PointShape GTE= { get; }
    public double GzE= { get; }
    public double HTE= { get; }
    public FDE=(PointShape midLinePoint, double lineSegmentLength, double angle);
    public PointShape GDE=();
    public double GjE=();
    public double HDE=();
}
internal static class HRU=.FDI= : object {
    internal static String[] FTI=;
    internal static String[] FjI=;
    private static FDI=();
}
internal static class HRU=.FDM= : object {
    [CompilerGeneratedAttribute]
private static string FTM=;
    private static OzM= FjM=;
    private static OzM= FzM=;
    private static OzM= GDM=;
    private static string GTM=;
    private static string GjM=;
    private static string rDA=;
    internal static string GzM=;
    private static string HDM=;
    private static Guid[] HTM=;
    private static OzM= HjM=;
    private static object HzM=;
    private static Nullable`1<bool> IDM=;
    private static Nullable`1<bool> ITM=;
    public static string JDM= { get; public set; }
    public static OzM= JjM= { get; }
    private static FDM=();
    [CompilerGeneratedAttribute]
public static string IjM=();
    [CompilerGeneratedAttribute]
public static void IzM=(string value);
    public static void JzM=(Dictionary`2<string, Collection`1<string>> licenseContents);
    public static OzM= JTM=();
    private static OzM= KDM=();
    internal static bool KTM=();
    private static OzM= KjM=(bool needToShowProductCenter);
    private static void KzM=(string uri);
    private static OzM= LDM=();
    private static string LTM=(KxQ= currentNode);
    internal static Guid LjM=();
    private static Guid LzM=();
    private static Guid MDM=();
    private static bool MTM=(Guid productId);
    [IteratorStateMachineAttribute("HRU=.FDM=/uUA=")]
private static IEnumerable`1<string> MjM=();
    internal static KxQ= MzM=(Assembly assembly);
    internal static KxQ= NDM=(Assembly assembly);
    public static bool NTM=();
    public static bool NjM=();
    internal static KxQ= MzM=(Guid productId);
    private static KxQ= NzM=(Guid productId);
    private static int ODM=(KxQ= productNode);
    private static Guid OTM=();
    private static Guid OjM=(Assembly assembly);
}
internal class HRU=.fhk= : jBo= {
    internal double fxk=;
    internal double gBk=;
    internal double gRk=;
    internal double QRk=;
    internal double FRg=;
    internal double ghk=;
    internal double gxk=;
    internal double hBk=;
    internal double hRk=;
    internal int hhk=;
    internal fhk=(string id, string desc);
    private void 9xg=();
    internal virtual whg= /Bg=(whg= pjConsts, Int32& pj_Error);
    internal virtual void Axk=(mhg= lp, whg= pjConsts, TRg= fac, Int32& pj_Error);
    internal virtual mhg= ARk=(mRo= xy, whg= pjConsts, Int32& pj_Error);
    internal virtual mRo= Ahk=(mhg= lp, whg= pjConsts, Int32& pj_Error);
}
internal class HRU=.fho= : object {
    internal string fxo=;
    internal string gBo=;
    internal fho=(string id, string major, string ell, string name);
}
internal static class HRU=.fiE= : object {
    [DebuggerHiddenAttribute]
public static void fyE=(T arg, string argName);
    [DebuggerHiddenAttribute]
public static void fyE=(Nullable`1<T> arg, string argName);
    [DebuggerHiddenAttribute]
public static void gCE=(T arg, string argName);
    [DebuggerHiddenAttribute]
public static void fyE=(IEnumerable`1<T> arg, string argName, bool assertContentsNotNull);
    [DebuggerHiddenAttribute]
public static void gSE=(string arg, string argName);
    [DebuggerHiddenAttribute]
public static void gSE=(IEnumerable arg, string argName);
    [DebuggerHiddenAttribute]
public static void gSE=(ICollection arg, string argName);
    [DebuggerHiddenAttribute]
public static void giE=(string arg, string argName);
    [DebuggerHiddenAttribute]
public static void gyE=(TEnum enumValue, string argName);
    [DebuggerHiddenAttribute]
public static void gyE=(TEnum enumValue, string argName, TEnum[] validValues);
    private static bool hCE=(string arg);
    private static IEnumerable`1<T> hSE=();
}
internal class HRU=.fRk= : jBo= {
    internal double thc=;
    internal fRk=(string id, string desc);
    private void 9xg=();
    internal virtual whg= /Bg=(whg= pjConsts, Int32& pj_Error);
    internal virtual void Axk=(mhg= lp, whg= pjConsts, TRg= fac, Int32& pj_Error);
    internal virtual mhg= ARk=(mRo= xy, whg= pjConsts, Int32& pj_Error);
    internal virtual mRo= Ahk=(mhg= lp, whg= pjConsts, Int32& pj_Error);
}
internal enum HRU=.FSg= : Enum {
    public int value__;
    public static FSg= Fig=;
    public static FSg= Fyg=;
    public static FSg= GCg=;
}
internal class HRU=.FSk= : CyU= {
    private Stream Wyg=;
    private FSg= 8iU=;
    private FSk= Fik=;
    private FSk= Fyk=;
    private Lig= GCk=;
    private int GSk=;
    private int Gik=;
    private vig= Gyk=;
    private bool HCk=;
    private int HSk=;
    private int Hik=;
    private zSo= Hyk=;
    private int ICk=;
    private int ISk=;
    private int Iik=;
    public FSk=(FSg= eAccessMode);
    private int Iyk=(int nNewNodePtr);
    private int JCk=(int nEntryNo, Byte[] pKeyValue);
    private int JSk=(Byte[] pKeyValue, int nEntryNo);
    private int Jik=(Byte[] pKeyValue, int nRecordNo, bool bInsertAfterCurChild, bool bMakeNewEntryCurChild);
    private int Jyk=(int numEntries, Byte[] pBuf, int nCurIndexEntry, FSk= poCurChild);
    public int KCk=(Stream fs, int nBlockPtr, int nKeyLength, int nSubTreeDepth, bool bUnique, Lig= poBlockMgr, FSk= poParentNode, int nPrevNodePtr, int nNextNodePtr);
    public int KSk=(vig= eType);
    public int Kik=();
    public int Kyk=();
    public int LCk=();
    public int LSk=();
    public int Lik=();
    public int Eik=(Byte[] pKeyValue);
    public int Lyk=();
    public int FCk=(Byte[] pKeyValue, int nRecordNo, bool bAddInThisNodeOnly, bool bInsertAfterCurChild, bool bMakeNewEntryCurChild);
    public int cx8=();
    public int MCk=();
    public Byte[] MSk=();
    public int Mik=(Byte[] pKeyValue, int nRecordNo);
    public int Myk=(Byte[] pKeyValue1, int nRecordNo1, Byte[] pKeyValue2, int nRecordNo2, int nNewCurChildNo);
    public int NCk=(int nPrevNodePtr);
    public int NSk=(int nNextNodePtr);
}
internal enum HRU=.fSs= : Enum {
    public int value__;
    public static fSs= siQ=;
    public static fSs= fis=;
    public static fSs= sSQ=;
}
internal class HRU=.Fxc= : object {
    internal static String[] GBc=;
    internal static String[] GRc=;
    internal static String[] Ghc=;
    internal static List`1<String[]> Gxc=;
    internal List`1<Fxc=> HBc=;
    internal Fxc= HRc=;
    internal string Hhc=;
    internal Fxc=(string nodeValue);
    private static Fxc=();
    internal Fxc= Hxc=(string nodeName);
    internal int IBc=(string nodeValue);
    internal void IRc=();
    internal Fxc= Ihc=();
    private bool Ixc=();
    internal string rBY=();
    internal void JBc=(Char[] wktCharArray, Int32& processedIndex);
    internal void JRc=(string node, String[] mappingTable, int srcIndex, int dstIndex, int stepSize);
    internal void JRc=(string node, String[] mappingTable, int srcIndex, int dstIndex, int stepSize, bool childOfHit);
    internal void Jhc=(string nodeValue);
    internal void 9BY=();
    private int Jxc=(String[] list, string target);
}
internal class HRU=.fxs= : object {
    internal static UInt32 gBs=;
    internal static UInt32 gRs=;
    internal static UInt32 ghs=;
    internal static UInt32 gxs=;
    internal static UInt32 hBs=;
    internal static UInt32 hRs=;
    internal static UInt32 hhs=;
    internal static UInt32 hxs=;
    internal static UInt32 iBs=;
    internal static UInt32 iRs=;
    private static double XhY=;
    private static double Xxc=;
    private static double ihs=;
    private static double ixs=;
    private double jBs=;
    private double jRs=;
    private double zBg=;
    private double jhs=;
    private double jxs=;
    private double kBs=;
    private double kRs=;
    private double khs=;
    private double kxs=;
    private double lBs=;
    private double lRs=;
    private double lhs=;
    private double lxs=;
    private double mBs=;
    private double mRs=;
    private double mhs=;
    public fxs=(double Latitude_of_True_Scale, double Longitude_Down_from_Pole, double False_Easting, double False_Northing);
    private double mxs=(double EsSin);
    public bool nBs=(double Latitude_of_True_Scale, double Longitude_Down_from_Pole, double False_Easting, double False_Northing);
    internal long nRs=(double a, double f, double Latitude_of_True_Scale, double Longitude_Down_from_Pole, double False_Easting, double False_Northing);
    internal long nhs=(double a, double f, double Latitude_of_True_Scale, double Longitude_Down_from_Pole, double False_Easting, double False_Northing);
    public void nxs=(Double& Latitude_of_True_Scale, Double& Longitude_Down_from_Pole, Double& False_Easting, Double& False_Northing);
    internal void oBs=(Double& a, Double& f, Double& Latitude_of_True_Scale, Double& Longitude_Down_from_Pole, Double& False_Easting, Double& False_Northing);
    public bool oRs=(double Latitude, double Longitude, Double& Easting, Double& Northing);
    internal long ohs=(double Latitude, double Longitude, Double& Easting, Double& Northing);
    public bool oxs=(double Easting, double Northing, Double& Latitude, Double& Longitude);
    internal long pBs=(double Easting, double Northing, Double& Latitude, Double& Longitude);
}
internal enum HRU=.fxw= : Enum {
    public int value__;
    public static fxw= gBw=;
    public static fxw= gRw=;
    public static fxw= ghw=;
    public static fxw= gxw=;
}
internal class HRU=.FyI= : ValueType {
    private double GCI=;
    private double GSI=;
    private double GiI=;
    private double GyI=;
    public double HiI= { get; public set; }
    public double ISI= { get; public set; }
    public double JCI= { get; public set; }
    public double JyI= { get; public set; }
    public FyI=(double maxLat, double minLat, double maxLong, double minLong);
    public double HCI=();
    public void HSI=(double value);
    public double HyI=();
    public void ICI=(double value);
    public double IiI=();
    public void IyI=(double value);
    public double JSI=();
    public void JiI=(double value);
}
internal enum HRU=.fys= : Enum {
    public int value__;
    public static fys= mSE=;
    public static fys= gCs=;
}
internal static class HRU=.FzI= : object {
    internal static string DTI=;
    internal static string DjI=;
    internal static String[] GDI=;
    internal static string GTI=;
    internal static String[] GjI=;
    private static FzI=();
}
internal class HRU=.GBk= : jBo= {
    internal double GRk=;
    internal int DRk=;
    internal GBk=(string id, string desc);
    private void 9xg=();
    internal virtual whg= /Bg=(whg= pjConsts, Int32& pj_Error);
    internal virtual void Axk=(mhg= lp, whg= pjConsts, TRg= fac, Int32& pj_Error);
    internal virtual mhg= ARk=(mRo= xy, whg= pjConsts, Int32& pj_Error);
    internal virtual mRo= Ahk=(mhg= lp, whg= pjConsts, Int32& pj_Error);
}
internal class HRU=.GC8= : object {
    private jCw= GS8=;
    private jCw= Gi8=;
    private UInt32 Gy8=;
    private int 0RM=;
    private int Fi8=;
    private bool HC8=;
    private bool HS8=;
    private bool Hi8=;
    private MemoryStream Hy8=;
    [CompilerGeneratedAttribute]
private List`1<int> IC8=;
    [CompilerGeneratedAttribute]
private List`1<byte> IS8=;
    public List`1<int> JC8= { get; private set; }
    public List`1<byte> Jy8= { get; private set; }
    public GC8=(string output);
    [CompilerGeneratedAttribute]
private void Iy8=(List`1<int> value);
    [CompilerGeneratedAttribute]
public List`1<int> Ii8=();
    [CompilerGeneratedAttribute]
private void Ji8=(List`1<byte> value);
    [CompilerGeneratedAttribute]
public List`1<byte> JS8=();
    public void Qx8=();
    public void KC8=();
    public void KS8=(WS0= rgnPoint);
    public void Ki8=(gy0= rgnLine);
    public void Ky8=(bC0= rgnGon);
    public void LC8=();
    public void pR8=();
    public void Fy8=();
}
internal class HRU=.gCI= : object {
    private Quadtree`1<object> gSI=;
    private List`1<int> 0BM=;
    public void giI=(double x, double y, int value);
    public void gyI=(double xMin, double xMax, double yMin, double yMax);
    public void hCI=();
    public List`1<int> hSI=();
    public gCI= Ihc=();
}
internal class HRU=.GCo= : ECo= {
    public int GSo=;
    public int jyg=;
    public int kCg=;
    public byte Gio=;
    public int Gyo=;
    public int HCo=;
    public virtual int 3Sk=(7Ck= poObjBlock);
    public virtual int 3ik=(7Ck= poObjBlock);
}
internal abstract class HRU=.gCU= : fCc= {
    protected int gSU=;
    protected iSg= giU=;
    protected bool gyU=;
    protected string hCU=;
    public Encoding hSU=;
    public virtual 2ig= GetFileClass();
    public abstract virtual int Open(string pszFname, FileAccess pszAccess, bool bTestOpenNoError);
    public abstract virtual int Close();
    public virtual int SetQuickSpatialIndexMode(bool bQuickSpatialIndexMode);
    public virtual string GetTableName();
    public static gCU= hiU=(string pszFname, bool bTestOpenNoError, Encoding encoding);
    public virtual int GetFeatureCount(bool bForce);
    public virtual JCc= GetNextFeature();
    public virtual JCc= GetFeature(long nFeatureId);
    public virtual qiY= CreateFeature(JCc= poFeature);
    public abstract virtual qiY= GetExtent(Hyc= psExtent, bool bForce);
    public abstract virtual int GetNextFeatureId(int nPrevId);
    public abstract virtual iSg= GetFeatureRef(int nFeatureId);
    public abstract virtual vig= GetNativeFieldType(int nFieldId);
    public abstract virtual int GetBounds(Double& dXMin, Double& dYMin, Double& dXMax, Double& YMax, bool bForce);
    public abstract virtual qSc= GetSpatialRef();
    public abstract virtual int GetFeatureCountByType(Int32& numPoints, Int32& numLines, Int32& numRegions, Int32& numTexts, bool bForce);
    public abstract virtual bool IsFieldIndexed(int nFieldId);
    public abstract virtual bool IsFieldUnique(int nFieldId);
    public abstract virtual int SetBounds(double dXMin, double dYMin, double dXMax, double dYMax);
    public virtual int SetFeatureDefn(PCc= poFeatureDefn, List`1<vig=> paeMapInfoNativeFieldTypes);
    public abstract virtual int AddFieldNative(string pszName, vig= eMapInfoType, int nWidth, int nPrecision, bool bIndexed, bool bUnique);
    public abstract virtual int SetSpatialRef(qSc= poSpatialRef);
    public abstract virtual int SetFeature(iSg= poFeature, int nFeatureId);
    public abstract virtual int SetFieldIndexed(int nFieldId);
    public virtual int GetProjInfo(iCo= poPI);
    public virtual int SetProjInfo(iCo= poPI);
    public virtual int SetMIFCoordSys(string pszMIFCoordSys);
}
internal class HRU=.Ghk= : jBo= {
    internal Uhc=[] Gxk=;
    internal double HBk=;
    internal double HRk=;
    internal int gxc=;
    internal Ghk=(string id, string desc);
    private void 9xg=();
    internal virtual whg= /Bg=(whg= pjConsts, Int32& pj_Error);
    internal virtual void Axk=(mhg= lp, whg= pjConsts, TRg= fac, Int32& pj_Error);
    internal virtual mhg= ARk=(mRo= xy, whg= pjConsts, Int32& pj_Error);
    internal virtual mRo= Ahk=(mhg= lp, whg= pjConsts, Int32& pj_Error);
    private mhg= EBk=(mRo= xy, whg= pjConsts, Int32& pj_Error);
    private mRo= Exk=(mhg= lp, whg= pjConsts, Int32& pj_Error);
    private Uhc= Hhk=(Uhc= z, Uhc=[] C, int n, Uhc= der);
    private Uhc= Hxk=(Uhc= z, Uhc=[] C, int n);
}
internal class HRU=.gic= : hyc= {
    public gic=(gic= poSrcRing);
    public virtual int gyc=(int b3D);
    public virtual string byc=();
    public virtual Zyc= aic=();
    public virtual int hCc=();
    public virtual void hSc=();
    public virtual double hic=();
}
internal class HRU=.gRo= : object {
    internal string gho=;
    internal string gxo=;
    internal string hBo=;
    internal long hRo=;
    internal VRc= hho=;
    internal List`1<gRo=> hxo=;
}
internal class HRU=.GSg= : iSg= {
    private double Gig=;
    private double Gyg=;
    private static int 9CQ=;
    private static int 9SQ=;
    private static int 9iQ=;
    private static int 9yQ=;
    private tig= HCg=;
    public double HSg=;
    public double Hig=;
    public double Hyg=;
    public double ICg=;
    public Pyo= ryU= { get; public set; }
    public int siU= { get; public set; }
    public GSg=(PCc= poDefnIn);
    public virtual int ISg=(Wyk= poMapFile);
    public virtual pCg= Iig=();
    public virtual int Iyg=(Wyk= poMapFile);
    public virtual iSg= JCg=(PCc= poNewDefn);
    public virtual int JSg=(Wyk= poMapFile, CSo= poObjHdr, bool bCoordBlockDataOnly, Nik=& ppoCoordBlock);
    public virtual int Jig=(Wyk= poMapFile, CSo= poObjHdr, bool bCoordBlockDataOnly, Nik=& ppoCoordBlock);
    public virtual int Jyg=(6yU= fp);
    public virtual int KCg=(6yU= fp);
    public virtual string Oic=();
    public virtual void KSg=(Stream fsOut);
    public double Kig=();
    public double Kyg=();
    public void LCg=(double dAngle);
    public void LSg=(double dAngle);
    public virtual int syU=();
    public virtual Pyo= tCU=();
    public virtual byte tSU=();
    public virtual double tiU=();
    public virtual int tyU=();
    public virtual byte uCU=();
    public virtual int uSU=();
    public virtual string uiU=();
    public sealed virtual Pyo= rSU=();
    public sealed virtual void riU=(Pyo= value);
    public virtual int sCU=();
    public virtual void sSU=(int value);
    public virtual void uyU=(byte val);
    public virtual void vCU=(double val);
    public virtual void vSU=(int val);
    public virtual void viU=(byte val);
    public virtual void vyU=(int clr);
    public virtual void wCU=(string pszStyleString);
    public virtual void wSU=(Stream fpOut);
}
internal class HRU=.gy0= : object {
    private List`1<IC4=> bS0=;
    private int bi0=;
    private int by0=;
    private double /yw=;
    [CompilerGeneratedAttribute]
private List`1<nyw=> Wy0=;
    [CompilerGeneratedAttribute]
private byte hC0=;
    [CompilerGeneratedAttribute]
private int XC0=;
    [CompilerGeneratedAttribute]
private short XS0=;
    [CompilerGeneratedAttribute]
private short Xi0=;
    [CompilerGeneratedAttribute]
private int cS0=;
    [CompilerGeneratedAttribute]
private byte ci0=;
    [CompilerGeneratedAttribute]
private sSw= cy0=;
    [CompilerGeneratedAttribute]
private string lCw=;
    [CompilerGeneratedAttribute]
private ushort lSw=;
    public List`1<nyw=> YS0= { get; public set; }
    public byte hy0= { get; private set; }
    public int ZC0= { get; private set; }
    public short Zy0= { get; private set; }
    public short ai0= { get; private set; }
    public int eS0= { get; private set; }
    public byte fC0= { get; private set; }
    public sSw= fy0= { get; private set; }
    public string myw= { get; public set; }
    public ushort niw= { get; public set; }
    public gy0=(double extentWidthLimitation);
    [CompilerGeneratedAttribute]
public void YC0=(List`1<nyw=> value);
    [CompilerGeneratedAttribute]
public List`1<nyw=> Xy0=();
    [CompilerGeneratedAttribute]
private void hi0=(byte value);
    [CompilerGeneratedAttribute]
public byte hS0=();
    [CompilerGeneratedAttribute]
private void Yy0=(int value);
    [CompilerGeneratedAttribute]
public int Yi0=();
    [CompilerGeneratedAttribute]
private void Zi0=(short value);
    [CompilerGeneratedAttribute]
public short ZS0=();
    [CompilerGeneratedAttribute]
private void aS0=(short value);
    [CompilerGeneratedAttribute]
public short aC0=();
    [CompilerGeneratedAttribute]
private void eC0=(int value);
    [CompilerGeneratedAttribute]
public int dy0=();
    [CompilerGeneratedAttribute]
private void ey0=(byte value);
    [CompilerGeneratedAttribute]
public byte ei0=();
    [CompilerGeneratedAttribute]
private void fi0=(sSw= value);
    [CompilerGeneratedAttribute]
public sSw= fS0=();
    [CompilerGeneratedAttribute]
public string mSw=();
    [CompilerGeneratedAttribute]
public void miw=(string value);
    [CompilerGeneratedAttribute]
public ushort nCw=();
    [CompilerGeneratedAttribute]
public void nSw=(ushort value);
    public void gC0=(double LoCenter, double LaCenter, byte BitsPerCoord, Dictionary`2<string, int> lblDictionary);
    private void gS0=();
    private void gi0=();
}
internal enum HRU=.Gyc= : Enum {
    public int value__;
    public static Gyc= HCc=;
    public static Gyc= HSc=;
    public static Gyc= Hic=;
}
internal static class HRU=.Gyw= : object {
    public static Byte[] HCw=(Byte[] bytes);
    public static Byte[] HSw=(Byte[] bytes);
    internal static Byte[] Hiw=(Uri styleJsonUri);
    internal static Collection`1<Feature> Hyw=(Collection`1<VectorTile> vectorTiles, List`1<string> pbfLayerNames);
    private static Byte[] ICw=(Uri styleJsonUri, Int32& count);
    private static CSw=[] ISw=(CSw=[] points, int simplificationFactor);
    internal static double Iiw=(ZoomLevelSet zoomLevelSet, int zoomLevel);
    internal static RectangleShape Iyw=(long tileX, long tileY, int zoomLevel, int tileSize);
    internal static CSw= JCw=(double pointX, double pointY, int zoomLevel, int tileSize, RectangleShape tileBoundingBox);
    internal static List`1<string> JSw=(Collection`1<string> sourceString, int startIndex, int count);
    private static void Jiw=(CSw=[] input, Ciw= tileScreenBoundingBox, List`1<int> clippedPoints, List`1<int> parts);
    private static List`1<CSw=> Jyw=(CSw=[] inputPoints, Ciw= tileScreenBoundingBox);
    private static void KCw=(CSw=[] points, int firstPoint, int lastPoint, double tolerance, List`1<int> pointIndexsToKeep);
    private static double KSw=(CSw=& a, CSw=& b, CSw=& c);
    private static double Kiw=(CSw=& a, CSw=& b, CSw=& c);
    private static double Kyw=(CSw=& a, CSw=& b);
    private static double LCw=(CSw=& a, CSw=& b, CSw=& c);
    private static CSw=[] LSw=(CSw=[] inputPoints, double tolerance);
    private static bool Liw=(IList`1<CSw=> points, int numPoints);
    private static TkA= Lyw=(double x, double y, Ciw=& tileScreenBoundingBox);
    private static bool MCw=(Double& x0, Double& y0, Double& x1, Double& y1, Ciw=& tileScreenBoundingBox, UEA=& clipState);
}
internal static class HRU=.gyY= : object {
    public static List`1<1CU=> hCY=;
    public static List`1<1CU=> hSY=;
    private static gyY=();
    public static void hiY=();
    private static void hyY=();
    private static void iCY=(Stream deCompressedStream);
    private static 1CU= iSY=(string wholeData);
    public static bool iiY=(double a, double b);
    private static byte iyY=(string byteStr);
    public static bool jCY=(iCo= psCS, Double& dXMin, Double& dYMin, Double& dXMax, Double& dYMax);
    public static int jSY=(string pszFname);
    public static int jSY=(string pszFname, Encoding encoding);
    public static void jiY=();
}
internal static class HRU=.GzI= : object {
    internal static string HDI=;
    internal static string HTI=;
    internal static string HjI=;
    internal static string HzI=;
    internal static string IDI=;
    internal static string BzI=;
    internal static string CDI=;
    internal static string ITI=;
    internal static string IjI=;
    internal static string IzI=;
    internal static string JDI=;
    internal static string JTI=;
    internal static string JjI=;
    internal static string CjI=;
    internal static string JzI=;
    internal static string KDI=;
    internal static string KTI=;
    internal static string KjI=;
    internal static string DTI=;
    internal static string DjI=;
    internal static String[] KzI=;
    internal static String[] ETI=;
    internal static string LDI=;
    internal static String[] LTI=;
    internal static string LjI=;
    internal static string LzI=;
    internal static string MDI=;
    private static GzI=();
}
internal class HRU=.hBg= : object {
    private Dictionary`2<string, fho=> hRg=;
    private Dictionary`2<string, exo=> hhg=;
    private Dictionary`2<string, iho=> hxg=;
    private Dictionary`2<string, iBo=> iBg=;
    private Dictionary`2<string, string> iRg=;
    private int ihg=;
    private void ixg=();
    private void jBg=();
    private void jRg=();
    private void jhg=();
    private void jxg=();
    internal jBo= kBg=(string args);
    internal int ZRg=(jBo= srcdefn, jBo= dstdefn, long point_count, int point_offset, jxo=[] uvList, Double[] z);
    private void kRg=(3Bg= datum, kho= unitObj, mxg= meridian, jBo= projObj, Dictionary`2<string, string> argList);
    private void khg=(exo= pjDatum, Dictionary`2<string, string> args, jBo= projObj);
    private void kxg=(jBo= projObj, string projName);
    private void lBg=(Stream stream, string keyField, jBo= projObj);
    private bool lRg=(string lineStr);
    private void lhg=(iho= pjUnit, Dictionary`2<string, string> args, jBo= projObj);
    private double lxg=(iBo= meri);
    private double mBg=(string meriDefn, Int32& pj_Error);
}
internal static class HRU=.HBU= : object {
    public static string GxU=(IEnumerable`1<string> source, string delimiter);
}
internal class HRU=.hCg= : object {
    public static int hSg=(double x0, double x, double x1);
    public static void hig=(double a, double b, double t);
    public static gic= hyg=(nic= poly, int i);
}
internal class HRU=.HCM= : object {
    private GridCell HSM=;
    private GridCell HiM=;
    private GridCell HyM=;
    private GridCell ICM=;
    public GridCell IyM= { get; public set; }
    public GridCell JiM= { get; public set; }
    public GridCell KSM= { get; public set; }
    public GridCell LCM= { get; public set; }
    public HCM=(GridCell leftBottom, GridCell bottomRight, GridCell rightTop, GridCell topLeft);
    public GridCell ISM=();
    public void IiM=(GridCell value);
    public GridCell JCM=();
    public void JSM=(GridCell value);
    public GridCell JyM=();
    public void KCM=(GridCell value);
    public GridCell KiM=();
    public void KyM=(GridCell value);
    public NCM= LSM=();
}
internal class HRU=.hCo= : 8So= {
    private bool Oio=;
    private double HSg=;
    private double Hig=;
    private bool hSo=;
    private tig= HCg=;
    private static int 9CQ=;
    private static int 9SQ=;
    private static int 9iQ=;
    private static int 9yQ=;
    public bool ISo=;
    public Pyo= ryU= { get; public set; }
    public int siU= { get; public set; }
    public hCo=(PCc= poDefnIn);
    public virtual pCg= Iig=();
    public virtual int Iyg=(Wyk= poMapFile);
    public virtual iSg= JCg=(PCc= poNewDefn);
    public int hio=();
    public hyc= hyo=(int nPartIndex);
    public virtual int JSg=(Wyk= poMapFile, CSo= poObjHdr, bool bCoordBlockDataOnly, Nik=& ppoCoordBlock);
    public virtual int Jig=(Wyk= poMapFile, CSo= poObjHdr, bool bCoordBlockDataOnly, Nik=& ppoCoordBlock);
    public virtual int Jyg=(6yU= fp);
    public virtual int KCg=(6yU= fp);
    public virtual string Oic=();
    public virtual void KSg=(Stream fsOut);
    public int PSo=(Double& dX, Double& dY);
    public void Pio=(double dX, double dY);
    public virtual int syU=();
    public virtual Pyo= tCU=();
    public virtual byte tSU=();
    public virtual double tiU=();
    public virtual int tyU=();
    public virtual byte uCU=();
    public virtual int uSU=();
    public virtual string uiU=();
    public sealed virtual Pyo= rSU=();
    public sealed virtual void riU=(Pyo= value);
    public sealed virtual int sCU=();
    public sealed virtual void sSU=(int value);
    public virtual void uyU=(byte val);
    public virtual void vCU=(double val);
    public virtual void vSU=(int val);
    public virtual void viU=(byte val);
    public virtual void vyU=(int clr);
    public virtual void wCU=(string pszStyleString);
    public virtual void wSU=(Stream fpOut);
}
internal class HRU=.hiE= : object {
    private static string hyE=;
    private static IDictionary`2<4T8=, XDocument> iCE=;
    private static object iSE=;
    private Type iiE=;
    private string iyE=;
    public hiE=(Type forType);
    public hiE=(Type forType, string resourceName);
    private hiE=(Type forType, string resourceName, int dummy);
    private static hiE=();
    [DebuggerHiddenAttribute]
public Exception jCE=(string exceptionKey, Object[] messageArgs);
    [DebuggerHiddenAttribute]
public Exception jCE=(string exceptionKey, Exception innerException, Object[] messageArgs);
    [DebuggerHiddenAttribute]
public Exception jCE=(string exceptionKey, Object[] constructorArgs, Exception innerException);
    [DebuggerHiddenAttribute]
public Exception jCE=(string exceptionKey, Object[] constructorArgs, Object[] messageArgs);
    [DebuggerHiddenAttribute]
public Exception jCE=(string exceptionKey, Object[] constructorArgs, Exception innerException, Object[] messageArgs);
    [DebuggerHiddenAttribute]
public void jSE=(bool condition, string exceptionKey, Object[] messageArgs);
    [DebuggerHiddenAttribute]
public void jSE=(bool condition, string exceptionKey, Exception innerException, Object[] messageArgs);
    [DebuggerHiddenAttribute]
public void jSE=(bool condition, string exceptionKey, Object[] constructorArgs, Exception innerException);
    [DebuggerHiddenAttribute]
public void jSE=(bool condition, string exceptionKey, Object[] constructorArgs, Object[] messageArgs);
    [DebuggerHiddenAttribute]
public void jSE=(bool condition, string exceptionKey, Object[] constructorArgs, Exception innerException, Object[] messageArgs);
    [DebuggerHiddenAttribute]
private static XDocument jiE=(Assembly assembly, string resourceName);
    private static int jyE=(Object[] arguments, ParameterInfo[] parameters);
    private static int kCE=(object argument, ParameterInfo parameter);
}
internal class HRU=.Hio= : ECo= {
    public int Hyo=;
    public int Gyo=;
    public int HCo=;
    public int jyg=;
    public int kCg=;
    public byte 3Ck=;
    public byte ICo=;
    public bool ISo=;
    public virtual int 3Sk=(7Ck= poObjBlock);
    public virtual int 3ik=(7Ck= poObjBlock);
}
internal class HRU=.HSo= : CSo= {
    public virtual int 3Sk=(7Ck= poObjBlock);
    public virtual int 3ik=(7Ck= poObjBlock);
}
internal class HRU=.HSU= : object {
    public static int HiU=;
    public static int HyU=;
    public static int ICU=;
    public static int ISU=;
    public static double XhY=;
    public static 4Cg= IiU=;
    public static OSg= IyU=;
    public static Pyo= JCU=;
    public static Iis= JSU=;
    public static int JiU=;
    public static int JyU=;
    public static int KCU=;
    public static int KSU=;
    public static int KiU=;
    public static int KyU=;
    public static int LCU=;
    public static int LSU=;
    public static int LiU=;
    public static int LyU=;
    public static int MCU=;
    public static int MSU=;
    public static int MiU=;
    public static int MyU=;
    public static int NCU=;
    public static int NSU=;
    public static int NiU=;
    public static int NyU=;
    public static int OCU=;
    public static int OSU=;
    public static int OiU=;
    public static int OyU=;
    public static int PCU=;
    public static int PSU=;
    public static int PiU=;
    public static int PyU=;
    public static int QCU=;
    public static int QSU=;
    public static int QiU=;
    public static int QyU=;
    public static int RCU=;
    public static int RSU=;
    public static int RiU=;
    public static int RyU=;
    public static int SCU=;
    public static int SSU=;
    public static int SiU=;
    public static int SyU=;
    public static int TCU=;
    public static int TSU=;
    public static int TiU=;
    public static int TyU=;
    public static int UCU=;
    public static int USU=;
    public static int UiU=;
    public static int UyU=;
    public static int VCU=;
    public static int VSU=;
    public static int ViU=;
    public static int VyU=;
    public static int WCU=;
    public static int WSU=;
    public static int WiU=;
    public static int WyU=;
    public static int XCU=;
    public static int XSU=;
    public static int XiU=;
    public static int XyU=;
    public static int YCU=;
    public static int YSU=;
    public static int YiU=;
    public static int YyU=;
    public static int ZCU=;
    public static int ZSU=;
    public static int ZiU=;
    public static int ZyU=;
    public static int aCU=;
    public static int aSU=;
    public static int aiU=;
    public static int ayU=;
    public static int bCU=;
    public static int bSU=;
    public static int biU=;
    public static int byU=;
    public static int cCU=;
    public static int cSU=;
    public static int ciU=;
    public static int cyU=;
    public static int dCU=;
    public static int dSU=;
    public static int diU=;
    public static int dyU=;
    public static int eCU=;
    public static int eSU=;
    public static int eiU=;
    public static int eyU=;
    public static int fCU=;
    public static int fSU=;
    public Byte[] fiU=;
    public static double fyU=;
    private static HSU=();
}
internal class HRU=.hxk= : jBo= {
    internal double iBk=;
    internal double iRk=;
    internal double ihk=;
    internal double ixk=;
    internal double jBk=;
    internal double NBk=;
    internal double 7xg=;
    internal double jRk=;
    internal Double[] NRk=;
    internal int DRk=;
    internal hxk=(string id, string desc);
    private void 9xg=();
    internal virtual whg= /Bg=(whg= pjConsts, Int32& pj_Error);
    internal virtual void Axk=(mhg= lp, whg= pjConsts, TRg= fac, Int32& pj_Error);
    internal virtual mhg= ARk=(mRo= xy, whg= pjConsts, Int32& pj_Error);
    internal virtual mRo= Ahk=(mhg= lp, whg= pjConsts, Int32& pj_Error);
    private mRo= Exk=(mhg= lp, whg= pjConsts, Int32& pj_Error);
    private mRo= ERk=(mhg= lp, whg= pjConsts, Int32& pj_Error);
    private mhg= EBk=(mRo= xy, whg= pjConsts, Int32& pj_Error);
    private mhg= Dhk=(mRo= xy, whg= pjConsts, Int32& pj_Error);
}
internal class HRU=.hy8= : object {
    private string aS8=;
    private string iC8=;
    private string iS8=;
    private Dictionary`2<string, string> ii8=;
    private string iy8=;
    private string jC8=;
    private string jS8=;
    private string ji8=;
    private string jy8=;
    private string kC8=;
    private Dictionary`2<string, string> kS8=;
    public Dictionary`2<string, string> ky8= { get; }
    public string li8= { get; public set; }
    public string mS8= { get; public set; }
    public Dictionary`2<string, string> my8= { get; }
    public string ni8= { get; public set; }
    public string oS8= { get; public set; }
    public string pC8= { get; public set; }
    public string py8= { get; public set; }
    public string qi8= { get; public set; }
    public string rS8= { get; public set; }
    public Dictionary`2<string, string> ki8=();
    public string lC8=();
    public void lS8=(string value);
    public string ly8=();
    public void mC8=(string value);
    public Dictionary`2<string, string> mi8=();
    public string nC8=();
    public void nS8=(string value);
    public string ny8=();
    public void oC8=(string value);
    public string oi8=();
    public void oy8=(string value);
    public string pS8=();
    public void pi8=(string value);
    public string qC8=();
    public void qS8=(string value);
    public string qy8=();
    public void rC8=(string value);
    public void pBw=(BinaryReader reader);
    private void ri8=(string NameFormatType, BinaryReader reader);
    private void ry8=(BinaryReader reader);
    private void sC8=(BinaryReader reader);
    private void sS8=(BinaryReader reader);
    private void si8=(BinaryReader reader);
    private void sy8=(BinaryReader reader);
    private void tC8=(BinaryReader reader);
    private void tS8=(BinaryReader reader);
    private bool ti8=(string col);
}
internal class HRU=.hyc= : piY= {
    protected int iCc=;
    protected qCc=[] iSc=;
    protected Double[] iic=;
    protected void iyc=();
    protected void jCc=();
    public virtual qiY= bSc=(String& ppszDstText);
    public virtual Zyc= aic=();
    public virtual void ayc=(Hyc= psEnvelope);
    public virtual void pyY=(mSc= poPoint);
    public virtual void qCY=(mSc= poPoint);
    public int jSc=();
    public void jic=(int i, mSc= poPoint);
    public double jyc=(int i);
    public double kCc=(int i);
    public double kSc=(int iVertex);
    public virtual void cCc=(int nNewDimension);
    public void kic=(int nNewPointCount);
    public void kyc=(int iPoint, double xIn, double yIn);
    public void kyc=(int iPoint, double xIn, double yIn, double zIn);
    public void lCc=(int nPointsIn, qCc=[] paoPointsIn, Double[] padfZ);
    public void lCc=(int nPointsIn, Double[] padfX, int indexX, Double[] padfY, int indexY, Double[] padfZ, int indexZ);
    public void lSc=(double x, double y);
    public virtual ryY= bic=();
    public virtual string byc=();
}
internal class HRU=.Hyc= : object {
    public double ICc=;
    public double ISc=;
    public double Iic=;
    public double Iyc=;
}
[ExtensionAttribute]
internal static class HRU=.hyQ= : object {
    [ExtensionAttribute]
public static void qRo=(ProjectionConverter projection, Feature feature);
}
internal enum HRU=.hyU= : Enum {
    public int value__;
    public static hyU= iCU=;
    public static hyU= iSU=;
    public static hyU= iiU=;
    public static hyU= iyU=;
}
internal abstract class HRU=.IB0= : object {
    private static NumberFormatInfo IR0=;
    protected int 2Bw=;
    protected object Ih0=;
    private bool Ix0=;
    private string JB0=;
    public int Jh0= { get; }
    public object KB0= { get; }
    public bool Kx0= { get; public set; }
    public string Lh0= { get; public set; }
    public string MB0= { get; }
    public IB0=(int line);
    private static IB0=();
    public int JR0=();
    public object Jx0=();
    public bool KR0=();
    public void Kh0=(bool value);
    public string LB0=();
    public void LR0=(string value);
    public virtual bool Equals(object other);
    public bool lhU=(string s);
    public bool lhU=(char c);
    public static bool 3hM=(IB0= t, object o);
    public static bool 3xM=(IB0= t, object o);
    public static bool 3hM=(IB0= t, char c);
    public static bool 3xM=(IB0= t, char c);
    public static bool 3hM=(IB0= t, string s);
    public static bool 3xM=(IB0= t, string s);
    public virtual int GetHashCode();
    public virtual string Lx0=();
    public object MR0=(Type t);
}
internal class HRU=.IBk= : jBo= {
    internal int IRk=;
    internal int Ihk=;
    internal IBk=(string id, string desc);
    private void 9xg=();
    internal virtual whg= /Bg=(whg= pjConsts, Int32& pj_Error);
    internal virtual void Axk=(mhg= lp, whg= pjConsts, TRg= fac, Int32& pj_Error);
    internal virtual mhg= ARk=(mRo= xy, whg= pjConsts, Int32& pj_Error);
    internal virtual mRo= Ahk=(mhg= lp, whg= pjConsts, Int32& pj_Error);
}
internal class HRU=.iBo= : object {
    internal string iRo=;
    internal iBo=(string id, string defn);
}
internal class HRU=.iC0= : object {
    private int iS0=;
    [CompilerGeneratedAttribute]
private int CC0=;
    [CompilerGeneratedAttribute]
private byte ii0=;
    [CompilerGeneratedAttribute]
private List`1<List`1<nC0=>> iy0=;
    [CompilerGeneratedAttribute]
private List`1<List`1<string>> jC0=;
    [CompilerGeneratedAttribute]
private List`1<RectangleShape> jS0=;
    public int Iy0= { get; private set; }
    public byte kC0= { get; private set; }
    public List`1<List`1<nC0=>> ky0= { get; private set; }
    public List`1<List`1<string>> li0= { get; private set; }
    public List`1<RectangleShape> mS0= { get; private set; }
    public iC0=(int treParameter);
    [CompilerGeneratedAttribute]
private void Ii0=(int value);
    [CompilerGeneratedAttribute]
public int IS0=();
    [CompilerGeneratedAttribute]
private void jy0=(byte value);
    [CompilerGeneratedAttribute]
public byte ji0=();
    [CompilerGeneratedAttribute]
private void ki0=(List`1<List`1<nC0=>> value);
    [CompilerGeneratedAttribute]
public List`1<List`1<nC0=>> kS0=();
    [CompilerGeneratedAttribute]
private void lS0=(List`1<List`1<string>> value);
    [CompilerGeneratedAttribute]
public List`1<List`1<string>> lC0=();
    [CompilerGeneratedAttribute]
private void mC0=(List`1<RectangleShape> value);
    [CompilerGeneratedAttribute]
public List`1<RectangleShape> ly0=();
    public void gC0=(Ky0= RTree, int accuracy);
    private void mi0=(8iw= rNode, int accuracy, Ky0= RTree);
    private void my0=(8iw= rNode, List`1<8iw=> list, Ky0= rRtee);
    private void my0=(8iw= rNode, List`1<2iw=> list);
}
internal class HRU=.IC4= : object {
    [CompilerGeneratedAttribute]
private int Ehw=;
    [CompilerGeneratedAttribute]
private int Exw=;
    public int /iI= { get; private set; }
    public int ASM= { get; private set; }
    public IC4=(int inputX, int inputY);
    [CompilerGeneratedAttribute]
private void /SI=(int value);
    [CompilerGeneratedAttribute]
public int /CI=();
    [CompilerGeneratedAttribute]
private void ACM=(int value);
    [CompilerGeneratedAttribute]
public int /yI=();
    public int IS4=();
    public int Ii4=();
}
internal class HRU=.iCg= : 8So= {
    private static int 9CQ=;
    private static int 9SQ=;
    private static int 9iQ=;
    private static int 9yQ=;
    public double HSg=;
    public double Hig=;
    public double Hyg=;
    public double ICg=;
    public iCg=(PCc= poDefnIn);
    public virtual int ISg=(Wyk= poMapFile);
    public virtual pCg= Iig=();
    public virtual int Iyg=(Wyk= poMapFile);
    public virtual iSg= JCg=(PCc= poNewDefn);
    public virtual int JSg=(Wyk= poMapFile, CSo= poObjHdr, bool bCoordBlockDataOnly, Nik=& ppoCoordBlock);
    public virtual int Jig=(Wyk= poMapFile, CSo= poObjHdr, bool bCoordBlockDataOnly, Nik=& ppoCoordBlock);
    public virtual int Jyg=(6yU= fp);
    public virtual int KCg=(6yU= fp);
    public virtual string Oic=();
    public virtual void KSg=(Stream fsOut);
}
internal class HRU=.iCo= : object {
    private byte iSo=;
    private byte iio=;
    private byte iyo=;
    private Double[] jCo=;
    private short jSo=;
    private double jio=;
    private double jyo=;
    private double kCo=;
    private Double[] kSo=;
    private byte kio=;
    private byte kyo=;
    private double lCo=;
    private double lSo=;
    private double lio=;
    private double lyo=;
    private double mCo=;
    private double mSo=;
    public byte nCo= { get; public set; }
    public byte nyo= { get; public set; }
    public byte oio= { get; public set; }
    public Double[] pSo= { get; public set; }
    public short qCo= { get; public set; }
    public double qyo= { get; public set; }
    public double rio= { get; public set; }
    public double sSo= { get; public set; }
    public Double[] tCo= { get; public set; }
    public byte tyo= { get; public set; }
    public byte uio= { get; public set; }
    public double vSo= { get; public set; }
    public double wCo= { get; public set; }
    public double wyo= { get; public set; }
    public double xio= { get; public set; }
    public double ySo= { get; public set; }
    public double zCo= { get; public set; }
    public iCo=(byte nProjId, byte nEllipsoidId, byte nUnitsId, Double[] adProjParams, short nDatumId, double dDatumShiftX, double dDatumShiftY, double dDatumShiftZ, Double[] adDatumParams);
    public byte mio=();
    public void myo=(byte value);
    public byte nSo=();
    public void nio=(byte value);
    public byte oCo=();
    public void oSo=(byte value);
    public Double[] oyo=();
    public void pCo=(Double[] value);
    public short pio=();
    public void pyo=(short value);
    public double qSo=();
    public void qio=(double value);
    public double rCo=();
    public void rSo=(double value);
    public double ryo=();
    public void sCo=(double value);
    public Double[] sio=();
    public void syo=(Double[] value);
    public byte tSo=();
    public void tio=(byte value);
    public byte uCo=();
    public void uSo=(byte value);
    public double uyo=();
    public void vCo=(double value);
    public double vio=();
    public void vyo=(double value);
    public double wSo=();
    public void wio=(double value);
    public double xCo=();
    public void xSo=(double value);
    public double xyo=();
    public void yCo=(double value);
    public double yio=();
    public void yyo=(double value);
    internal void Myg=();
}
internal enum HRU=.iCw= : Enum {
    public byte value__;
    public static iCw= iSw=;
    public static iCw= MiA=;
    public static iCw= iiw=;
    public static iCw= iyw=;
}
internal class HRU=.iho= : object {
    internal string ixo=;
    internal iho=(string id, string to_meter, string name);
}
internal class HRU=.Iio= : CSo= {
    public int Iyo=;
    public int JCo=;
    public byte Gio=;
    public virtual int 3Sk=(7Ck= poObjBlock);
    public virtual int 3ik=(7Ck= poObjBlock);
}
internal class HRU=.iiQ= : ValueType {
    public long iyQ=;
    public float jCQ=;
    public float jSQ=;
    public float jiQ=;
    public float jyQ=;
    public iiQ=(Byte[] buffer);
}
internal class HRU=.Iis= : object {
    public int PSc=;
    public short Iys=;
    public short JCs=;
    public byte JSs=;
    public int Qyo=;
    public Iis=(int nRefCount, short nSymbolNo, short nPointSize, byte _nUnknownValue_, int rgbColor);
}
internal class HRU=.iSg= : JCc= {
    protected int iig=;
    protected double ESY=;
    protected double EiY=;
    protected double EyY=;
    protected double FCY=;
    protected int iyg=;
    protected int jCg=;
    protected int jSg=;
    protected int jig=;
    protected int jyg=;
    protected int kCg=;
    public iSg=(PCc= poDefnIn);
    protected void kSg=(iSg= poDestFeature);
    public virtual int ISg=(Wyk= poMapFile);
    public static iSg= kig=(int nMapInfoType, PCc= poDefn);
    public virtual iSg= JCg=(PCc= poNewDefn);
    public virtual pCg= Iig=();
    public virtual int kyg=();
    public virtual int Iyg=(Wyk= poMapFile);
    public void lCg=(bool bDeleted);
    public virtual int lSg=(Wig= poDATFile);
    public virtual int JSg=(Wyk= poMapFile, CSo= poObjHdr, bool bCoordDataOnly, Nik=& ppoCoordBlock);
    public virtual int lig=(Wig= poDATFile, CCk= poINDFile, Int32[] panIndexNo);
    public virtual int Jig=(Wyk= poMapFile, CSo= poObjHdr, bool bCoordDataOnly, Nik=& ppoCoordBlock);
    public bool lyg=(Wyk= poMapFile);
    public void mCg=(int nMapInfoType, bool bCompr, int nComprOrgX, int nComprOrgY, int nXMin, int nYMin, int nXMax, int nYMax);
    public virtual int mSg=(6yU= fp);
    public virtual int Jyg=(6yU= fp);
    public virtual int mig=(6yU= fp);
    public virtual int KCg=(6yU= fp);
    public void myg=(double dXMin, double dYMin, double dXMax, double dYMax);
    public void nCg=(Double& dXMin, Double& dYMin, Double& dXMax, Double& dYMax);
    public void nSg=(int nXMin, int nYMin, int nXMax, int nYMax);
    public void nig=(Int32& nXMin, Int32& nYMin, Int32& nXMax, Int32& nYMax);
    public virtual void nyg=(Stream fsOut);
    public virtual void KSg=(Stream fsOut);
}
internal class HRU=.Ixk= : jBo= {
    internal Ixk=(string id, string desc);
    private void 9xg=();
    internal virtual whg= /Bg=(whg= pjConsts, Int32& pj_Error);
    internal virtual void Axk=(mhg= lp, whg= pjConsts, TRg= fac, Int32& pj_Error);
    internal virtual mhg= ARk=(mRo= xy, whg= pjConsts, Int32& pj_Error);
    internal virtual mRo= Ahk=(mhg= lp, whg= pjConsts, Int32& pj_Error);
}
internal class HRU=.Iy4= : object {
    private Di8= JC4=;
    private List`1<GC8=> JS4=;
    private List`1<LS8=> Ji4=;
    private List`1<FC8=> Jy4=;
    private Uy4= KC4=;
    private iC0= KS4=;
    private Ky0= Ki4=;
    private 8y0= Ky4=;
    private string LC4=;
    private string LS4=;
    private string Li4=;
    private string Ly4=;
    private int MC4=;
    private Ci4= MS4=;
    private TC0= Mi4=;
    private double /yw=;
    private TinyGeoFileType My4=;
    public Iy4=(Ci4= tGeoParameters, string tGeoFilePathName);
    public void NC4=();
    public void NS4=(int count);
    public void Ni4=();
    public void Ny4=(int count);
    public void OC4=();
}
internal static class HRU=.iyM= : object {
    public static string jCM=(string metarText);
    private static void jSM=(string text, StringBuilder resultStrBuffer);
    private static bool jiM=(char ch);
    private static void jyM=(string token, StringBuilder resultStrBuffer);
    private static string kCM=(string text, StringBuilder resultStrBuffer);
}
internal class HRU=.JBk= : jBo= {
    internal int IRk=;
    internal int Ihk=;
    internal JBk=(string id, string desc);
    private void 9xg=();
    internal virtual whg= /Bg=(whg= pjConsts, Int32& pj_Error);
    internal virtual void Axk=(mhg= lp, whg= pjConsts, TRg= fac, Int32& pj_Error);
    internal virtual mhg= ARk=(mRo= xy, whg= pjConsts, Int32& pj_Error);
    internal virtual mRo= Ahk=(mhg= lp, whg= pjConsts, Int32& pj_Error);
}
internal abstract class HRU=.jBo= : object {
    internal whg= jRo=;
    internal string exQ=;
    internal string jho=;
    internal abstract virtual whg= /Bg=(whg= pjConsts, Int32& pj_Error);
    internal abstract virtual mhg= ARk=(mRo= xy, whg= pjConsts, Int32& pj_Error);
    internal abstract virtual mRo= Ahk=(mhg= lp, whg= pjConsts, Int32& pj_Error);
    internal abstract virtual void Axk=(mhg= lp, whg= pjConsts, TRg= fac, Int32& pj_Error);
}
internal class HRU=.jBw= : object {
    private Dictionary`2<KeyValuePair`2<string, string>, IEnumerable`1<Feature>> jRw=;
    public Dictionary`2<KeyValuePair`2<string, string>, IEnumerable`1<Feature>> jxw= { get; }
    public jBw=(IEnumerable`1<Feature> features, string columnName);
    public Dictionary`2<KeyValuePair`2<string, string>, IEnumerable`1<Feature>> jhw=();
    public sealed virtual IEnumerator`1<Feature> GetEnumerator();
    [IteratorStateMachineAttribute("HRU=.jBw=/3D4=")]
private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
}
internal class HRU=.JCc= : CyU= {
    private long JSc=;
    private PCc= Jic=;
    private Zyc= Jyc=;
    private List`1<Sic=> KCc=;
    protected string KSc=;
    protected string Kic=;
    public JCc=(PCc= poDefnIn);
    public PCc= Kyc=();
    public qiY= LCc=(Zyc= poGeomIn);
    public qiY= LSc=(Zyc= poGeomIn);
    public Zyc= Lic=();
    public JCc= Ihc=();
    public int Lyc=();
    public Wyc= MCc=(int iField);
    public int MSc=(string pszName);
    public bool Mic=(int iField);
    public Sic= Myc=(int i);
    public int NCc=(int iField);
    public double NSc=(int iField);
    public string Nic=(int iField);
    public string Nic=(string pszFName);
    public void Nyc=(int iField, int nValue);
    public void Nyc=(int iField, double dfValue);
    public void Nyc=(int iField, string pszValue);
    public void Nyc=(int iField, Sic= puValue);
    public long OCc=();
    public virtual qiY= OSc=(long nFID);
    public virtual string Oic=();
    public virtual void Oyc=(string pszString);
}
internal interface HRU=.jCU= {
    public OSg= jyU= { get; public set; }
    public int kiU= { get; public set; }
    public abstract virtual int kyU=();
    public abstract virtual OSg= lCU=();
    public abstract virtual int lSU=();
    public abstract virtual int liU=();
    public abstract virtual byte lyU=();
    public abstract virtual byte mCU=();
    public abstract virtual void mSU=(int clr);
    public abstract virtual void miU=(int clr);
    public abstract virtual void myU=(byte val);
    public abstract virtual void nCU=(byte val);
    public abstract virtual string nSU=();
    public abstract virtual void niU=(string pszStyleString);
    public abstract virtual void nyU=(Stream fpOut);
    public abstract virtual OSg= jSU=();
    public abstract virtual void jiU=(OSg= value);
    public abstract virtual int kCU=();
    public abstract virtual void kSU=(int value);
}
internal class HRU=.jCw= : BinaryWriter {
    public jCw=(Stream output);
    public void jSw=(byte Value, int length);
}
internal class HRU=.jhk= : jBo= {
    internal double jxk=;
    internal double kBk=;
    internal double LRk=;
    internal jhk=(string id, string desc);
    private void 9xg=();
    internal virtual whg= /Bg=(whg= pjConsts, Int32& pj_Error);
    internal virtual void Axk=(mhg= lp, whg= pjConsts, TRg= fac, Int32& pj_Error);
    internal virtual mhg= ARk=(mRo= xy, whg= pjConsts, Int32& pj_Error);
    internal virtual mRo= Ahk=(mhg= lp, whg= pjConsts, Int32& pj_Error);
}
internal class HRU=.jiI= : ValueType {
    public byte jyI=;
    public int CBo=;
    public int CRo=;
    public jiI=(int x, int y, byte intensity);
}
internal enum HRU=.Jis= : Enum {
    public int value__;
    public static Jis= Jys=;
    public static Jis= KCs=;
    public static Jis= KSs=;
}
internal static class HRU=.jiw= : object {
    public static MultilineShape jyw=(LineShape lineShap, double ratio);
    public static MultilineShape jyw=(MultilineShape multiLineShape, double ratio);
    private static List`1<rCw=> kCw=(List`1<rCw=> points, double ratio);
    private static void kSw=(List`1<rCw=> value);
}
internal class HRU=.jR4= : EventArgs {
    private bool jh4=;
    internal bool kR4= { get; internal set; }
    internal bool jx4=();
    internal void kB4=(bool value);
}
internal class HRU=.JRk= : jBo= {
    internal int Jhk=;
    internal JRk=(string id, string desc);
    private void 9xg=();
    internal virtual whg= /Bg=(whg= pjConsts, Int32& pj_Error);
    internal virtual void Axk=(mhg= lp, whg= pjConsts, TRg= fac, Int32& pj_Error);
    internal virtual mhg= ARk=(mRo= xy, whg= pjConsts, Int32& pj_Error);
    internal virtual mRo= Ahk=(mhg= lp, whg= pjConsts, Int32& pj_Error);
}
internal class HRU=.JSo= : CSo= {
    public int Jio=;
    public int Jyo=;
    public byte 3Ck=;
    public byte ICo=;
    public virtual int 3Sk=(7Ck= poObjBlock);
    public virtual int 3ik=(7Ck= poObjBlock);
}
internal class HRU=.Jxk= : jBo= {
    internal Jxk=(string id, string desc);
    private void 9xg=();
    internal virtual whg= /Bg=(whg= pjConsts, Int32& pj_Error);
    internal virtual void Axk=(mhg= lp, whg= pjConsts, TRg= fac, Int32& pj_Error);
    internal virtual mhg= ARk=(mRo= xy, whg= pjConsts, Int32& pj_Error);
    internal virtual mRo= Ahk=(mhg= lp, whg= pjConsts, Int32& pj_Error);
}
internal class HRU=.jxo= : ValueType {
    internal double kBo=;
    internal double kRo=;
}
internal class HRU=.jyY= : object {
    public static double kCY=(List`1<string> papszFields, int iField, double dfDefault);
    public static qSc= kSY=(string pszCoordSys);
    public static string kiY=(qSc= poSR);
    public static bool kyY=(string pszCoordSys, Double& dXMin, Double& dYMin, Double& dXMax, Double& dYMax);
}
internal class HRU=.KBc= : ValueType {
    internal string KRc=;
    internal string Khc=;
    internal int Kxc=;
    internal int LBc=;
}
internal class HRU=.KBk= : jBo= {
    internal double 8xg=;
    internal double KRk=;
    internal double Khk=;
    internal double CBk=;
    internal Double[] 9Rg=;
    internal KBk=(string id, string desc);
    private void 9xg=();
    internal virtual whg= /Bg=(whg= pjConsts, Int32& pj_Error);
    internal virtual void Axk=(mhg= lp, whg= pjConsts, TRg= fac, Int32& pj_Error);
    private mRo= Exk=(mhg= lp, whg= pjConsts, Int32& pj_Error);
    private mRo= ERk=(mhg= lp, whg= pjConsts, Int32& pj_Error);
    private mhg= EBk=(mRo= xy, whg= pjConsts, Int32& pj_Error);
    private mhg= Dhk=(mRo= xy, whg= pjConsts, Int32& pj_Error);
    internal virtual mhg= ARk=(mRo= xy, whg= pjConsts, Int32& pj_Error);
    internal virtual mRo= Ahk=(mhg= lp, whg= pjConsts, Int32& pj_Error);
}
internal class HRU=.KCo= : ECo= {
    public short KSo=;
    public int CCo=;
    public short 5Cg=;
    public byte Kio=;
    public byte Kyo=;
    public byte LCo=;
    public byte LSo=;
    public byte Lio=;
    public byte Lyo=;
    public int MCo=;
    public int MSo=;
    public int Mio=;
    public byte 6yk=;
    public byte 3Ck=;
    public virtual int 3Sk=(7Ck= poObjBlock);
    public virtual int 3ik=(7Ck= poObjBlock);
}
internal class HRU=.kCQ= : ValueType {
    public long iyQ=;
    public int jCQ=;
    public int jSQ=;
    public int jiQ=;
    public int jyQ=;
    public kCQ=(Byte[] buffer);
}
internal class HRU=.khk= : jBo= {
    internal khk=(string id, string desc);
    private void 9xg=();
    internal virtual whg= /Bg=(whg= pjConsts, Int32& pj_Error);
    internal virtual void Axk=(mhg= lp, whg= pjConsts, TRg= fac, Int32& pj_Error);
    internal virtual mhg= ARk=(mRo= xy, whg= pjConsts, Int32& pj_Error);
    internal virtual mRo= Ahk=(mhg= lp, whg= pjConsts, Int32& pj_Error);
}
internal class HRU=.kho= : object {
    internal iho= kxo=;
    internal Dictionary`2<string, iho=> lBo=;
    internal iho= lho= { get; }
    internal kho=(Dictionary`2<string, string> args, Dictionary`2<string, iho=> pj_Units_List);
    private string lxo=(Dictionary`2<string, string> args);
    private void mBo=(string unitID);
    internal iho= lRo=();
}
internal class HRU=.Khs= : object {
    public static double Kxs=(double rad);
    public static double LBs=(double degree);
    public static float LRs=(Byte[] bs, int startIndex);
}
[ExtensionAttribute]
internal static class HRU=.kiE= : object {
    [DebuggerHiddenAttribute]
[ExtensionAttribute]
public static void kyE=(EventHandler handler, object sender);
    [DebuggerHiddenAttribute]
[ExtensionAttribute]
public static void kyE=(EventHandler`1<T> handler, object sender, T e);
    [ExtensionAttribute]
[DebuggerHiddenAttribute]
public static void kyE=(EventHandler`1<T> handler, object sender, Func`1<T> createEventArguments);
    [ExtensionAttribute]
[DebuggerHiddenAttribute]
public static void kyE=(Delegate handler, object sender, EventArgs e);
    [ExtensionAttribute]
[DebuggerHiddenAttribute]
public static void lCE=(EventHandler handler, object sender, AsyncCallback callback, object asyncState);
    [ExtensionAttribute]
[DebuggerHiddenAttribute]
public static void lCE=(EventHandler`1<T> handler, object sender, T e, AsyncCallback callback, object asyncState);
    [ExtensionAttribute]
[DebuggerHiddenAttribute]
public static void lCE=(EventHandler`1<T> handler, object sender, Func`1<T> createEventArguments, AsyncCallback callback, object asyncState);
    [ExtensionAttribute]
[DebuggerHiddenAttribute]
public static void lCE=(Delegate handler, object sender, EventArgs e, AsyncCallback callback, object asyncState);
}
internal class HRU=.Kis= : iSg= {
    protected Char[] Kys=;
    protected double 4yg=;
    protected double LCs=;
    protected double LSs=;
    protected double Lis=;
    protected double Lys=;
    protected bool MCs=;
    protected int MSs=;
    protected int Mis=;
    protected short KSo=;
    protected short 5Cg=;
    private sig= TSg=;
    private tig= HCg=;
    private static 4Cg= tSg=;
    private static int 9CQ=;
    private static int 9SQ=;
    private static int 9iQ=;
    private static int 9yQ=;
    public Pyo= ryU= { get; public set; }
    public int siU= { get; public set; }
    public int oyU= { get; public set; }
    public 4Cg= piU= { get; public set; }
    public Kis=(PCc= poDefnIn);
    private static Kis=();
    protected string Mys=();
    public virtual int ISg=(Wyk= poMapFile);
    public virtual pCg= Iig=();
    public virtual int Iyg=(Wyk= poMapFile);
    public virtual iSg= JCg=(PCc= poNewDefn);
    public virtual int JSg=(Wyk= poMapFile, CSo= poObjHdr, bool bCoordBlockDataOnly, Nik=& ppoCoordBlock);
    public virtual int Jig=(Wyk= poMapFile, CSo= poObjHdr, bool bCoordBlockDataOnly, Nik=& ppoCoordBlock);
    public virtual int Jyg=(6yU= fp);
    public virtual int KCg=(6yU= fp);
    public virtual string Oic=();
    public virtual void KSg=(Stream fsOut);
    public Char[] NCs=();
    public double NSs=();
    public double Nis=();
    public double Nys=();
    public int OCs=();
    public int OSs=();
    public void Ois=(Double& dX, Double& dY);
    public Sys= Oys=();
    public Uys= PCs=();
    public Tys= PSs=();
    public bool Pis=(7ig= eStyleToQuery);
    public void Pys=(Char[] pszNewStr);
    public void QCs=(double dAngle);
    public void QSs=(double dHeight);
    public void Qis=(double dWidth);
    public void Qys=(int rgbColor);
    public void RCs=(int rgbColor);
    public void RSs=(double dX, double dY);
    public void Ris=(Sys= eJustification);
    public void Rys=(Uys= eSpacing);
    public void SCs=(Tys= eLineType);
    public void SSs=(7ig= eStyleToToggle, bool bStyleOn);
    public int 6Cg=();
    public void 6Sg=(int nStyle, bool bBGColorSet);
    public bool Sis=();
    public int 6ig=();
    public void 6yg=(int nStyle);
    public virtual int syU=();
    public virtual Pyo= tCU=();
    public virtual byte tSU=();
    public virtual double tiU=();
    public virtual int tyU=();
    public virtual byte uCU=();
    public virtual int uSU=();
    public virtual string uiU=();
    public sealed virtual Pyo= rSU=();
    public sealed virtual void riU=(Pyo= value);
    public virtual int sCU=();
    public virtual void sSU=(int value);
    public virtual void uyU=(byte val);
    public virtual void vCU=(double val);
    public virtual void vSU=(int val);
    public virtual void viU=(byte val);
    public virtual void vyU=(int clr);
    public virtual void wCU=(string pszStyleString);
    public virtual void wSU=(Stream fpOut);
    public virtual int oSU=();
    public virtual void oiU=(int value);
    public virtual 4Cg= pCU=();
    public virtual void pSU=(4Cg= value);
    public virtual int pyU=();
    public virtual 4Cg= qCU=();
    public virtual string qSU=();
    public virtual void qiU=(string pszName);
    public virtual void qyU=(Stream fpOut);
}
internal class HRU=.kiw= : object {
    [CompilerGeneratedAttribute]
private int kyw=;
    [CompilerGeneratedAttribute]
private string lCw=;
    [CompilerGeneratedAttribute]
private ushort lSw=;
    public int mCw= { get; private set; }
    public string myw= { get; public set; }
    public ushort niw= { get; public set; }
    public kiw=(int index, string lable, ushort fclass);
    [CompilerGeneratedAttribute]
private void lyw=(int value);
    [CompilerGeneratedAttribute]
public int liw=();
    [CompilerGeneratedAttribute]
public string mSw=();
    [CompilerGeneratedAttribute]
public void miw=(string value);
    [CompilerGeneratedAttribute]
public ushort nCw=();
    [CompilerGeneratedAttribute]
public void nSw=(ushort value);
}
internal class HRU=.kRk= : jBo= {
    internal kRk=(string id, string desc);
    private void 9xg=();
    internal virtual whg= /Bg=(whg= pjConsts, Int32& pj_Error);
    internal virtual void Axk=(mhg= lp, whg= pjConsts, TRg= fac, Int32& pj_Error);
    internal virtual mhg= ARk=(mRo= xy, whg= pjConsts, Int32& pj_Error);
    internal virtual mRo= Ahk=(mhg= lp, whg= pjConsts, Int32& pj_Error);
}
[ExtensionAttribute]
internal static class HRU=.kSE= : object {
    [ExtensionAttribute]
[DebuggerHiddenAttribute]
public static void fyE=(T arg, string argName);
    [ExtensionAttribute]
[DebuggerHiddenAttribute]
public static void fyE=(Nullable`1<T> arg, string argName);
    [DebuggerHiddenAttribute]
[ExtensionAttribute]
public static void gCE=(T arg, string argName);
    [DebuggerHiddenAttribute]
[ExtensionAttribute]
public static void fyE=(IEnumerable`1<T> arg, string argName, bool assertContentsNotNull);
    [DebuggerHiddenAttribute]
[ExtensionAttribute]
public static void gSE=(string arg, string argName);
    [DebuggerHiddenAttribute]
[ExtensionAttribute]
public static void gSE=(IEnumerable arg, string argName);
    [ExtensionAttribute]
[DebuggerHiddenAttribute]
public static void gSE=(ICollection arg, string argName);
    [DebuggerHiddenAttribute]
[ExtensionAttribute]
public static void giE=(string arg, string argName);
    [DebuggerHiddenAttribute]
[ExtensionAttribute]
public static void gyE=(TEnum enumValue, string argName);
    [DebuggerHiddenAttribute]
[ExtensionAttribute]
public static void gyE=(TEnum enumValue, string argName, TEnum[] validValues);
}
[ExtensionAttribute]
internal static class HRU=.kSM= : object {
    [ExtensionAttribute]
public static string kiM=(string input, int startIndex, int length);
    public static int kyM=(string input);
}
internal class HRU=.kSQ= : object {
    private short kiQ=;
    public short kyQ=;
    public iiQ=[] lCQ=;
    public float jCQ=;
    public float jSQ=;
    public float jiQ=;
    public float jyQ=;
    public kSQ=(Byte[] buffer);
}
internal class HRU=.kxk= : jBo= {
    internal kxk=(string id, string desc);
    private void 9xg=();
    internal virtual void Axk=(mhg= lp, whg= pjConsts, TRg= fac, Int32& pj_Error);
    internal virtual whg= /Bg=(whg= pjConsts, Int32& pj_Error);
    internal virtual mhg= ARk=(mRo= xy, whg= pjConsts, Int32& pj_Error);
    internal virtual mRo= Ahk=(mhg= lp, whg= pjConsts, Int32& pj_Error);
}
internal class HRU=.Kxk= : jBo= {
    internal double LBk=;
    internal double gxc=;
    internal double vxg=;
    internal double LRk=;
    internal double 7hg=;
    internal double Uxc=;
    internal double 7xg=;
    internal double Lhk=;
    internal double Lxk=;
    internal double MBk=;
    internal Double[] 9Rg=;
    internal Kxk=(string id, string desc);
    private void 9xg=();
    internal virtual whg= /Bg=(whg= pjConsts, Int32& pj_Error);
    internal virtual void Axk=(mhg= lp, whg= pjConsts, TRg= fac, Int32& pj_Error);
    private mRo= Exk=(mhg= lp, whg= pjConsts, Int32& pj_Error);
    private mRo= ERk=(mhg= lp, whg= pjConsts, Int32& pj_Error);
    private mhg= EBk=(mRo= xy, whg= pjConsts, Int32& pj_Error);
    private mhg= Dhk=(mRo= xy, whg= pjConsts, Int32& pj_Error);
    internal virtual mhg= ARk=(mRo= xy, whg= pjConsts, Int32& pj_Error);
    internal virtual mRo= Ahk=(mhg= lp, whg= pjConsts, Int32& pj_Error);
}
internal class HRU=.Ky0= : object {
    private double /yw=;
    private int 8yw=;
    private int 9Sw=;
    public List`1<8iw=> LC0=;
    [CompilerGeneratedAttribute]
private int LS0=;
    [CompilerGeneratedAttribute]
private int By0=;
    [CompilerGeneratedAttribute]
private int Li0=;
    [CompilerGeneratedAttribute]
private Dictionary`2<int, List`1<int>> Ly0=;
    public int Mi0= { get; private set; }
    public int IC0= { get; private set; }
    public int NS0= { get; public set; }
    public Dictionary`2<int, List`1<int>> OC0= { get; private set; }
    public Ky0=(int nMax, int nMin, int accuray, double extentWidthLimitation);
    [CompilerGeneratedAttribute]
private void MS0=(int value);
    [CompilerGeneratedAttribute]
public int MC0=();
    [CompilerGeneratedAttribute]
private void Hy0=(int value);
    [CompilerGeneratedAttribute]
public int Hi0=();
    [CompilerGeneratedAttribute]
public void NC0=(int value);
    [CompilerGeneratedAttribute]
public int My0=();
    [CompilerGeneratedAttribute]
private void Ny0=(Dictionary`2<int, List`1<int>> value);
    [CompilerGeneratedAttribute]
public Dictionary`2<int, List`1<int>> Ni0=();
    public void OS0=(int max);
    public void Oi0=();
    public void Oy0=();
    public int PC0=(8iw= rNode);
    public void PS0=();
    public void giI=(Py0= Info);
    public void giI=(2iw= ceaterEntry);
    private int Pi0=(2iw= DesEntry);
    private bool yx8=(int OriginalNode, bool DoSplit);
}
internal class HRU=.KyY= : object {
    public static int LCY=;
    public static KyY= LSY=;
    private static KyY=();
    public int LiY=();
    public int LyY=();
    public gCU= MCY=(string pszFilename, Encoding encoding);
    public void MSY=(gCU= handle);
    public gCU= MiY=(string filename, string mif_or_tab, string mif_projection, double north, double south, double east, double west, Encoding encoding);
    public int MyY=(gCU= dataset);
    public int NCY=(gCU= dataset, string field_name, vig= field_type, int width, int precision, bool indexed, bool unique);
    public void NSY=(iSg= feature);
    public int NiY=(gCU= handle, int last_feature_id);
    public iSg= NyY=(gCU= handle, int feature_id);
    public bool OCY=(gCU= handle, iSg= feature);
    public iSg= OSY=(gCU= handle, int feature_type);
    public void OiY=(iSg= feature, int field_index, string field_value);
    public void OyY=(iSg= feature, int part, int vertex_count, Double[] x, Double[] y);
    public void PCY=(iSg= feature, double center_x, double center_y, double x_radius, double y_radius, double start_angle, double end_angle);
    public void PSY=(iSg= feature, String& text);
    public string PiY=(iSg= feature);
    public int PyY=(iSg= feature, String& text, int l);
    public void QCY=(iSg= feature, double angle, double height, double width, int fg_color, int bg_color, int justification, int spacing, int linetype);
    public void QSY=(iCo= projInfo, Int32& nProjId, Int32& nEllipsoidId, Int32& nUnitsId, Double[] adProjParams);
    public double QiY=(iSg= feature);
    public double QyY=(iSg= feature);
    public double RCY=(iSg= feature);
    public int RSY=(iSg= feature);
    public int RiY=(iSg= feature);
    public int RyY=(iSg= feature);
    public int SCY=(iSg= feature);
    public int SSY=(iSg= feature);
    public void SiY=(iSg= feature, string fontname);
    public string SyY=(iSg= feature);
    public void TCY=(iSg= feature, int fg_color, int bg_color, int pattern, int transparent);
    public int TSY=(iSg= feature);
    public int TiY=(iSg= feature);
    public int TyY=(iSg= feature);
    public int UCY=(iSg= feature);
    public void USY=(iSg= feature, int width, int pattern, int color);
    public int UiY=(iSg= feature);
    public int UyY=(iSg= feature);
    public int VCY=(iSg= feature);
    public void VSY=(iSg= feature, int symbol_no, int symbol_size, int symbol_color);
    public int ViY=(iSg= feature);
    public int VyY=(iSg= feature);
    public int WCY=(iSg= feature);
    public int WSY=(iSg= feature);
    public double WiY=(iSg= feature, int part, int vertex);
    public int WyY=(gCU= handle);
    public int XCY=(gCU= handle);
    public int XSY=(gCU= handle, int field);
    public string XiY=(gCU= handle, int field);
    public int XyY=(gCU= handle, int field);
    public int YCY=(gCU= handle, int field);
    public string YSY=(gCU= dataset);
    public string YiY=(gCU= dataset);
    public void YyY=(iCo= projInfo, int nProjId, int nEllipsoidId, int nUnitsId, Double[] adProjParams);
    public void ZCY=(iCo= projInfo, Double& dDatumShiftX, Double& dDatumShiftY, Double& dDatumShiftZ, Double[]& adDatumParams);
    public void ZSY=(iCo= projInfo, double dDatumShiftX, double dDatumShiftY, double dDatumShiftZ, Double[] adDatumParams);
    public int ZiY=(iCo= projInfo, Int32& nAffineUnits, Double[]& adAffineParams);
    public void ZyY=(iCo= projInfo, int nAffineUnits, Double[] adAffineParams);
    public int aCY=(gCU= dataset, String& coordsys, int length);
    public int aSY=(gCU= dataset, String& coordsys, int length);
    public int aiY=(string filename);
    public int ayY=(iSg= feature, iSg= region, int make_copy);
    public int bCY=(iSg= feature, iSg= polyline, int make_copy);
    public int bSY=(iSg= feature, iSg= multipoint, int make_copy);
    public string biY=(iSg= feature, int field);
    public bool byY=(gCU= handle, int field);
    public bool cCY=(gCU= handle, int field);
    public int cSY=(iSg= feature, int field, String& value, int l);
    public double ciY=(iSg= feature, int field);
    public iCo= cyY=(gCU= dataset);
    public int dCY=(gCU= dataset, iCo= projinfo);
    public string dSY=(gCU= file, int columnNum, int recordNum);
}
internal class HRU=.lB8= : /x8= {
    internal lB8=(9B8= rh, BCA= rt);
    public virtual string ToString();
    internal virtual int lR8=(bool isFloat);
    internal virtual bool pBw=(BinaryReader r, bool isFloat);
    internal virtual bool shw=(BinaryWriter w, bool isFloat);
}
internal class HRU=.lBk= : jBo= {
    internal lBk=(string id, string desc);
    private void 9xg=();
    internal virtual void Axk=(mhg= lp, whg= pjConsts, TRg= fac, Int32& pj_Error);
    internal virtual whg= /Bg=(whg= pjConsts, Int32& pj_Error);
    internal virtual mhg= ARk=(mRo= xy, whg= pjConsts, Int32& pj_Error);
    internal virtual mRo= Ahk=(mhg= lp, whg= pjConsts, Int32& pj_Error);
}
internal class HRU=.LBo= : jBo= {
    internal double 8xg=;
    internal double LRo=;
    internal double Lho=;
    internal int DRk=;
    internal LBo=(string id, string desc);
    private void 9xg=();
    internal virtual whg= /Bg=(whg= pjConsts, Int32& pj_Error);
    internal virtual void Axk=(mhg= lp, whg= pjConsts, TRg= fac, Int32& pj_Error);
    internal virtual mhg= ARk=(mRo= xy, whg= pjConsts, Int32& pj_Error);
    internal virtual mRo= Ahk=(mhg= lp, whg= pjConsts, Int32& pj_Error);
}
internal class HRU=.lCY= : object {
    public static double XhY=;
    public static MkA=[] lSY=;
    private static lCY=();
    public static int liY=(hyc= poLine, int numPoints, double dCenterX, double dCenterY, double dXRadius, double dYRadius, double dStartAngle, double dEndAngle);
    public static int lyY=(hyc= poRing);
    public static bool mCY=(String& pszFname);
    public static string mSY=(string pszFname);
    public static List`1<string> miY=(string pszFname, Encoding encoding);
    public static string myY=(String& pszString, bool bSrcIsConst);
    public static string nCY=(string pszString);
    public static string nSY=(string pszSrcName);
    public static string niY=(int nId);
    public static int nyY=(string pszName);
    public static bool kyY=(string pszCoordSys, Double& dXMin, Double& dYMin, Double& dXMax, Double& dYMax);
    public static int oCY=(string pszCoordSys, iCo= psProj);
}
internal class HRU=.lhk= : jBo= {
    internal Double[] 9Rg=;
    internal double lxk=;
    internal double mBk=;
    internal double mRk=;
    internal double FRg=;
    internal lhk=(string id, string desc);
    private void 9xg=();
    internal virtual whg= /Bg=(whg= pjConsts, Int32& pj_Error);
    internal virtual void Axk=(mhg= lp, whg= pjConsts, TRg= fac, Int32& pj_Error);
    internal virtual mhg= ARk=(mRo= xy, whg= pjConsts, Int32& pj_Error);
    internal virtual mRo= Ahk=(mhg= lp, whg= pjConsts, Int32& pj_Error);
    private static double mhk=(double S, double C);
    private static double mxk=(double S, double C);
}
internal class HRU=.Lhs= : object {
    private static UInt32 Lxs=;
    private static UInt32 MBs=;
    private static UInt32 MRs=;
    private static UInt32 Mhs=;
    private static UInt32 Mxs=;
    private static UInt32 NBs=;
    private static UInt32 NRs=;
    private static UInt32 Nhs=;
    private static UInt32 Nxs=;
    private static UInt32 OBs=;
    private static UInt32 ORs=;
    private static double 1hc=;
    private static double 1xc=;
    private static int Ohs=;
    private static int Oxs=;
    private static int PBs=;
    private static int PRs=;
    private static int Phs=;
    private static int Pxs=;
    private static int QBs=;
    private static int QRs=;
    private static int Qhs=;
    private static int Qxs=;
    private static int RBs=;
    private static int RRs=;
    private static int Rhs=;
    private static int Rxs=;
    private static int SBs=;
    private static int SRs=;
    private static int Shs=;
    private static int Sxs=;
    private static int TBs=;
    private static int TRs=;
    private static int Ths=;
    private static int Txs=;
    private static int UBs=;
    private static int URs=;
    private static int Uhs=;
    private static int Uxs=;
    private static int VBs=;
    private static double VRs=;
    private static double Vhs=;
    private static bool Vxs=;
    private static bool WBs=;
    private static double XhY=;
    private static double Xxc=;
    private static double WRs=;
    private static double Whs=;
    private static double Wxs=;
    private static double XBs=;
    private static double XRs=;
    private static double Xhs=;
    private static double Xxs=;
    private static double YBs=;
    private static double YRs=;
    private double Yhs=;
    private double Yxs=;
    private double ZBs=;
    private string ZRs=;
    private static string Zhs=;
    private static string Zxs=;
    private static string aBs=;
    private static string aRs=;
    internal static yj4=[] ahs=;
    private static zz4=[] axs=;
    private static Lhs=();
    public bool bBs=(string mgrs, Double& Latitude, Double& Longitude);
    public bool bRs=(double Latitude, double Longitude, String& mgrs);
    private long bhs=(int letter, Double& min_northing);
    private long bxs=(long letter, Double& north, Double& south);
    private long cBs=(double latitude, Int32& letter);
    private long cRs=(string MGRS, Boolean& zone_exists);
    private long chs=(double _value);
    private long cxs=(String& MGRS, int Zone, Int32[] Letters, double Easting, double Northing, int Precision);
    private long dBs=(string MGRS, Int32& Zone, Int32[]& Letters, Double& Easting, Double& Northing, Int32& Precision);
    private void dRs=(int zone, Int32& ltr2_low_value, Int32& ltr2_high_value, Double& false_northing);
    internal long dhs=(int Zone, double Latitude, double Easting, double Northing, int Precision, String& MGRS);
    public long dxs=(double a, double f, string Ellipsoid_Code);
    private void eBs=(Double& a, Double& f, String& Ellipsoid_Code);
    internal long eRs=(double Latitude, double Longitude, int Precision, String& MGRS);
    internal long ehs=(string MGRS, Double& Latitude, Double& Longitude);
    internal long exs=(int Zone, char Hemisphere, double Easting, double Northing, int Precision, String& MGRS);
    internal long fBs=(string MGRS, Int32& Zone, Char& Hemisphere, Double& Easting, Double& Northing);
    internal long fRs=(char Hemisphere, double Easting, double Northing, int Precision, String& MGRS);
    internal long fhs=(string MGRS, Char& Hemisphere, Double& Easting, Double& Northing);
}
internal class HRU=.lhw= : BinaryWriter {
    public lhw=(Stream output);
    public lhw=(Stream output, Encoding encoding);
    public virtual void Write(short value);
    public virtual void Write(ushort value);
    public virtual void Write(int value);
    public virtual void Write(UInt32 value);
    public virtual void Write(long value);
    public virtual void Write(ulong value);
    public virtual void Write(float value);
    public virtual void Write(double value);
}
internal class HRU=.LiA= : ValueType {
    public double CBo=;
    public double CRo=;
    private static int LyA=;
    public LiA=(double x, double y);
    public bool CyA=(LiA= pt);
    public static int lR8=(bool isFloat);
    public bool pBw=(BinaryReader r, bool isFloat);
    public bool shw=(BinaryWriter w, bool isFloat);
    public virtual string ToString();
}
internal class HRU=.lic= : dCc= {
    public virtual string byc=();
    public virtual ryY= bic=();
    public virtual Zyc= aic=();
    public virtual qiY= bSc=(String& ppszDstText);
    public virtual qiY= eic=(Zyc= poNewGeom);
}
internal class HRU=.Lig= : object {
    protected int Lyg=;
    protected int MCg=;
    protected Nyg= MSg=;
    public int Mig=();
    public void Myg=();
    public void NCg=(int nBlockPtr);
    public int NSg=();
    public int Nig=();
}
internal enum HRU=.LiM= : Enum {
    public int value__;
    public static LiM= LyM=;
    public static LiM= MCM=;
    public static LiM= MSM=;
    public static LiM= MiM=;
    public static LiM= MyM=;
}
internal static class HRU=.liQ= : object {
    public static List`1 modreq(System.Runtime.CompilerServices.IsVolatile) lyQ=;
    public static Boolean modreq(System.Runtime.CompilerServices.IsVolatile) mCQ=;
    public static string mSQ=(string pszBuffer, int nBufferSize, Stream fp, Encoding encoding);
    public static string miQ=(int nRequiredSize);
    public static string myQ=(Stream fp, Encoding encoding);
    public static long nCQ=(string pszString, int nMaxLength);
    public static string nSQ=(string pszKey, string pszDefault);
}
internal class HRU=.LRc= : object {
    private string Lhc=;
    private string Lxc=;
    private XmlDocument MBc=;
    private XmlNodeList MRc=;
    internal XmlNodeList Mxc= { get; }
    internal LRc=(string baseInfoFile, string xmlPath);
    internal XmlNodeList Mhc=();
    private bool NBc=();
    internal XmlNode NRc=(string xmlKeyField, string xmlKeyWord);
}
internal class HRU=.lRk= : jBo= {
    internal double 8xg=;
    internal double 9Bg=;
    internal double gxc=;
    internal double 8hg=;
    internal double 8Rg=;
    internal double 7hg=;
    internal int 9hg=;
    internal lRk=(string id, string desc);
    private void 9xg=();
    internal virtual whg= /Bg=(whg= pjConsts, Int32& pj_Error);
    internal virtual void Axk=(mhg= lp, whg= pjConsts, TRg= fac, Int32& pj_Error);
    internal virtual mhg= ARk=(mRo= xy, whg= pjConsts, Int32& pj_Error);
    internal virtual mRo= Ahk=(mhg= lp, whg= pjConsts, Int32& pj_Error);
}
internal class HRU=.lRw= : BinaryReader {
    public lRw=(Stream stream);
    public lRw=(Stream input, Encoding encoding);
    public virtual short ReadInt16();
    public virtual ushort ReadUInt16();
    public virtual int ReadInt32();
    public virtual UInt32 ReadUInt32();
    public virtual long ReadInt64();
    public virtual ulong ReadUInt64();
    public virtual float ReadSingle();
    public virtual double ReadDouble();
}
internal class HRU=.LS8= : object {
    private jCw= Dy8=;
    private int 0RM=;
    private int Fi8=;
    public LS8=(string path);
    public void pR8=();
    public void Fy8=();
    public void Qx8=(yC0= HeaderPrama, int count, byte accuray);
    public void Li8=(2i0= SubdivisionPrama);
    public void Ly8=();
}
internal static class HRU=.lSE= : object {
    public static char liE=;
    public static char lyE=;
    public static char mCE=;
    public static char mSE=;
    public static char miE=;
    public static char myE=;
    public static Encoding nCE=;
    private static lSE=();
}
internal class HRU=.lSI= : object {
    [CompilerGeneratedAttribute]
private long liI=;
    [CompilerGeneratedAttribute]
private long lyI=;
    [CompilerGeneratedAttribute]
private GridCell[0...,0...] mCI=;
    [CompilerGeneratedAttribute]
private GridInterpolationModel mSI=;
    [CompilerGeneratedAttribute]
private RectangleShape miI=;
    [CompilerGeneratedAttribute]
private GridDefinition myI=;
    [CompilerGeneratedAttribute]
private ManualResetEvent nCI=;
    public long nyI= { get; public set; }
    public long oiI= { get; public set; }
    public GridCell[0...,0...] pSI= { get; public set; }
    public GridInterpolationModel qCI= { get; public set; }
    public RectangleShape qyI= { get; public set; }
    public GridDefinition riI= { get; public set; }
    public ManualResetEvent sSI= { get; public set; }
    public lSI=(long x, long y, RectangleShape cellExtent, GridCell[0...,0...] cells, GridInterpolationModel model, GridDefinition definition, ManualResetEvent finished);
    [CompilerGeneratedAttribute]
public long nSI=();
    [CompilerGeneratedAttribute]
public void niI=(long value);
    [CompilerGeneratedAttribute]
public long oCI=();
    [CompilerGeneratedAttribute]
public void oSI=(long value);
    [CompilerGeneratedAttribute]
public GridCell[0...,0...] oyI=();
    [CompilerGeneratedAttribute]
public void pCI=(GridCell[0...,0...] value);
    [CompilerGeneratedAttribute]
public GridInterpolationModel piI=();
    [CompilerGeneratedAttribute]
public void pyI=(GridInterpolationModel value);
    [CompilerGeneratedAttribute]
public RectangleShape qSI=();
    [CompilerGeneratedAttribute]
public void qiI=(RectangleShape value);
    [CompilerGeneratedAttribute]
public GridDefinition rCI=();
    [CompilerGeneratedAttribute]
public void rSI=(GridDefinition value);
    [CompilerGeneratedAttribute]
public ManualResetEvent ryI=();
    [CompilerGeneratedAttribute]
public void sCI=(ManualResetEvent value);
}
internal class HRU=.lSQ= : object {
    private short kiQ=;
    public short kyQ=;
    public kCQ=[] lCQ=;
    public int jCQ=;
    public int jSQ=;
    public int jiQ=;
    public int jyQ=;
    public lSQ=(Byte[] buffer);
}
[ExtensionAttribute]
internal static class HRU=.LTA= : object {
    [ExtensionAttribute]
internal static void pR8=(XmlReader reader);
}
internal class HRU=.Lxo= : jBo= {
    internal Double[] 9Rg=;
    internal double Rhk=;
    internal double gxc=;
    internal double thc=;
    internal double txc=;
    internal Lxo=(string id, string desc);
    private void 9xg=();
    internal virtual whg= /Bg=(whg= pjConsts, Int32& pj_Error);
    internal virtual void Axk=(mhg= lp, whg= pjConsts, TRg= fac, Int32& pj_Error);
    internal virtual mhg= ARk=(mRo= xy, whg= pjConsts, Int32& pj_Error);
    internal virtual mRo= Ahk=(mhg= lp, whg= pjConsts, Int32& pj_Error);
    private mRo= Exk=(mhg= lp, whg= pjConsts, Int32& pj_Error);
    private mRo= ERk=(mhg= lp, whg= pjConsts, Int32& pj_Error);
    private mhg= EBk=(mRo= xy, whg= pjConsts, Int32& pj_Error);
    private mhg= Dhk=(mRo= xy, whg= pjConsts, Int32& pj_Error);
}
internal static class HRU=.lxw= : object {
    public static WkbShapeType mBw=(Byte[] wkb, int startIndex);
    internal static byte mRw=(WkbByteOrder byteOrder);
    internal static WkbByteOrder mhw=(byte content);
    internal static WellKnownType mxw=(Byte[] wkb);
    internal static RectangleShape nBw=(Byte[] wkb);
    private static RectangleShape nRw=(Byte[] wkb);
    private static RectangleShape nhw=(Byte[] wkb);
    private static RectangleShape nxw=(Byte[] wkb);
    private static RectangleShape oBw=(Byte[] wkb);
    private static RectangleShape oRw=(Byte[] wkb);
    private static RectangleShape ohw=(Byte[] wkb);
}
internal class HRU=.lyc= : dCc= {
    public virtual string byc=();
    public virtual ryY= bic=();
    public virtual Zyc= aic=();
    public virtual qiY= bSc=(String& ppszDstText);
    public virtual qiY= eic=(Zyc= poNewGeom);
}
internal class HRU=.MBo= : jBo= {
    internal double MRo=;
    internal double 7hg=;
    internal double Mho=;
    internal double Mxo=;
    internal double NBo=;
    internal double NRo=;
    internal MBo=(string id, string desc);
    private void 9xg=();
    internal virtual whg= /Bg=(whg= pjConsts, Int32& pj_Error);
    internal virtual void Axk=(mhg= lp, whg= pjConsts, TRg= fac, Int32& pj_Error);
    internal virtual mhg= ARk=(mRo= xy, whg= pjConsts, Int32& pj_Error);
    internal virtual mRo= Ahk=(mhg= lp, whg= pjConsts, Int32& pj_Error);
}
internal enum HRU=.MCA= : Enum {
    public int value__;
    public static MCA= MSA=;
    public static MCA= MiA=;
}
internal class HRU=.mCc= : dCc= {
    public virtual string byc=();
    public virtual ryY= bic=();
    public virtual Zyc= aic=();
    public virtual qiY= bSc=(String& ppszDstText);
    public virtual qiY= eic=(Zyc= poNewGeom);
}
internal class HRU=.Mh0= : IB0= {
    public string MB0= { get; }
    public Mh0=(int line);
    public virtual string ToString();
    public virtual bool Equals(object other);
    public virtual string Lx0=();
    public virtual int GetHashCode();
}
internal class HRU=.mhg= : ValueType {
    internal double Uxg=;
    internal double VBg=;
}
internal class HRU=.mRg= : ValueType {
    internal int Uxg=;
    internal int VBg=;
}
internal class HRU=.MRk= : jBo= {
    internal double Mhk=;
    internal MRk=(string id, string desc);
    private void 9xg=();
    internal virtual whg= /Bg=(whg= pjConsts, Int32& pj_Error);
    internal virtual void Axk=(mhg= lp, whg= pjConsts, TRg= fac, Int32& pj_Error);
    internal virtual mhg= ARk=(mRo= xy, whg= pjConsts, Int32& pj_Error);
    internal virtual mRo= Ahk=(mhg= lp, whg= pjConsts, Int32& pj_Error);
}
internal class HRU=.mRo= : object {
    internal double mho=;
    internal double mxo=;
}
internal class HRU=.mSc= : Zyc= {
    private double mho=;
    private double mxo=;
    private double mic=;
    public mSc=(double xIn, double yIn);
    public mSc=(double xIn, double yIn, double zIn);
    public virtual qiY= bSc=(String& ppszDstText);
    public virtual Zyc= aic=();
    public virtual void ayc=(Hyc= psEnvelope);
    public double jyc=();
    public double kCc=();
    public double kSc=();
    public virtual void cCc=(int nNewDimension);
    public void myc=(double xIn);
    public void nCc=(double yIn);
    public void nSc=(double zIn);
    public virtual string byc=();
    public virtual ryY= bic=();
}
internal class HRU=.mSk= : zSo= {
    protected iCo= mik=;
    public short myk=;
    public double nCk=;
    public int iyg=;
    public int jCg=;
    public int jSg=;
    public int jig=;
    public bool nSk=;
    public int nik=;
    public int nyk=;
    public int oCk=;
    public int oSk=;
    public int oik=;
    public int oyk=;
    public int pCk=;
    public int pSk=;
    public byte pik=;
    public byte pyk=;
    public byte qCk=;
    public byte qSk=;
    public byte qik=;
    public byte qyk=;
    public byte rCk=;
    public byte rSk=;
    public byte rik=;
    public byte ryk=;
    public short sCk=;
    public double sSk=;
    public double sik=;
    public double syk=;
    public double tCk=;
    public mSk=(FSg= eAccessMode);
    public virtual int CommitToFile();
    public virtual int InitBlockFromData(Byte[] pabyBuf, int nBlockSize, int nSizeUsed, bool bMakeCopy, Stream fsSrc, int nOffset);
    public virtual int InitNewBlock(Stream fsSrc, int nBlockSize, int nFileOffset);
    public virtual int GetBlockClass();
    public int eSk=(int nX, int nY, Double& dX, Double& dY);
    public int eik=(double dX, double dY, Int32& nX, Int32& nY, bool bIgnoreOverflow);
    public int eyk=(int nX, int nY, Double& dX, Double& dY);
    public int fCk=(double dX, double dY, Int32& nX, Int32& nY);
    public int gCk=(double dXMin, double dYMin, double dXMax, double dYMax);
    public int tSk=(int nObjType);
    public bool tik=(int nObjType);
    public int tyk=(iCo= psProjInfo);
    public int uCk=(iCo= psProjInfo);
}
internal static class HRU=.MTI= : object {
    public static Feature MjI=(PointShape centerPoint, double resolutionX, double resolutionY, float halfRadius);
    public static Feature MzI=(PointShape centerPoint, double resolutionX, double resolutionY, float halfRadius);
    public static Feature NDI=(PointShape centerPoint, double resolutionX, double resolutionY, float halfRadius);
    public static Feature NTI=(PointShape centerPoint, double resolutionX, double resolutionY, float halfRadius);
    public static LineShape NjI=(PointShape centerPoint, double resolutionX, double radius);
    public static LineShape NzI=(PointShape centerPoint, double resolutionX, double radius);
    public static LineShape ODI=(PointShape centerPoint, double resolutionX, double radius);
    public static LineShape OTI=(PointShape centerPoint, double resolutionX, double radius);
    public static RectangleShape OjI=(PointShape centerPoint, double resolutionX, double resolutionY, double radius);
    public static RectangleShape OzI=(PointShape centerPoint, double resolutionX, double resolutionY, float radius);
    public static LineShape PDI=(RectangleShape bigRectangleShape);
    public static LineShape PTI=(RectangleShape bigRectangleShape);
    public static LineShape PjI=(RectangleShape bigRectangleShape, RectangleShape smallRectangleShape);
    public static LineShape PzI=(RectangleShape bigRectangleShape, RectangleShape smallRectangleShape);
    public static LineShape QDI=(PointShape centerPoint, double resolutionY, float radius, float halfRadius);
    public static LineShape QTI=(PointShape centerPoint, double resolutionY, float radius, float halfRadius);
    public static LineShape QjI=(PointShape centerPoint, double resolutionX, float radius, float halfRadius);
    public static LineShape QzI=(PointShape centerPoint, double resolutionX, float radius, float halfRadius);
    public static LineShape RDI=(RectangleShape bigRectangleShape, RectangleShape smallRectangleShape);
    public static LineShape RTI=(RectangleShape bigRectangleShape, RectangleShape smallRectangleShape);
    public static Feature RjI=(double resolutionX, double resolutionY, float radius, RectangleShape biggerRectangleShape);
    public static Feature RzI=(double resolutionX, double resolutionY, float radius, RectangleShape smallRectangleShape);
    public static Feature SDI=(double resolutionX, double resolutionY, float radius, RectangleShape smallRectangleShape);
    public static Feature STI=(double resolutionX, double resolutionY, float radius, RectangleShape smallRectangleShape);
    public static Feature SjI=(PointShape topPoint, double resolutionX, double resolutionY, float radius);
    public static Feature SzI=(PointShape topPoint, double resolutionX, double resolutionY, float radius);
}
internal class HRU=.Mx0= : IB0= {
    public string MB0= { get; }
    public Mx0=(int line);
    public virtual string ToString();
    public virtual bool Equals(object other);
    public virtual string Lx0=();
    public virtual int GetHashCode();
}
internal class HRU=.mxg= : object {
    private iBo= nBg=;
    private Dictionary`2<string, iBo=> nRg=;
    internal iBo= nxg= { get; }
    internal mxg=(Dictionary`2<string, string> args, Dictionary`2<string, iBo=> meridiansList, Int32& pj_Error);
    private static string oBg=(Dictionary`2<string, string> args);
    private void oRg=(string id, Int32& pj_Error);
    internal iBo= nhg=();
}
internal class HRU=.Mxk= : jBo= {
    internal double NBk=;
    internal Double[] NRk=;
    internal Mxk=(string id, string desc);
    private void 9xg=();
    internal virtual whg= /Bg=(whg= pjConsts, Int32& pj_Error);
    internal virtual void Axk=(mhg= lp, whg= pjConsts, TRg= fac, Int32& pj_Error);
    private mhg= EBk=(mRo= xy, whg= pjConsts, Int32& pj_Error);
    private mhg= Dhk=(mRo= xy, whg= pjConsts, Int32& pj_Error);
    private mRo= Exk=(mhg= lp, whg= pjConsts, Int32& pj_Error);
    private mRo= ERk=(mhg= lp, whg= pjConsts, Int32& pj_Error);
    internal virtual mhg= ARk=(mRo= xy, whg= pjConsts, Int32& pj_Error);
    internal virtual mRo= Ahk=(mhg= lp, whg= pjConsts, Int32& pj_Error);
}
internal class HRU=.mxU= : object {
    private GeoColor nBU=;
    private GeoColor nRU=;
    public GeoColor oBU= { get; public set; }
    public GeoColor oxU= { get; public set; }
    public GeoColor nhU=();
    public void nxU=(GeoColor value);
    public GeoColor oRU=();
    public void ohU=(GeoColor value);
}
internal class HRU=.Myo= : zSo= {
    public static int NCo=;
    public Encoding FR8=;
    protected int OCk=;
    protected int NSo=;
    protected int Oik=;
    protected Lig= GCk=;
    public Myo=(FSg= eAccessMode);
    public virtual int InitBlockFromData(Byte[] pabyBuf, int nBlockSize, int nSizeUsed, bool bMakeCopy, Stream fsSrc, int nOffset);
    public virtual int InitNewBlock(Stream fsSrc, int nBlockSize, int nFileOffset);
    public virtual int CommitToFile();
    public virtual int GetBlockClass();
    public void RSk=(Lig= poBlockManager);
    public virtual int ReadBytes(int numBytes, Byte[] pabyDstBuf);
    public virtual int WriteBytes(int nBytesToWrite, Byte[] pBuf);
    public void Nio=(int nNextCoordBlockAddress);
    public bool Nyo=();
    public int Tik=();
    public int OCo=(int nToolType);
}
internal static class HRU=.MzA= : object {
    internal static GeoImage NDA=(int tileWidth, int tileHeight, RowColumnRange rowColumnRange, List`1<CloudRasterTileInfo> cloudTileInfos);
    internal static ValueTuple`2<GeoImage, RectangleShape> NDA=(int tileWidth, int tileHeight, RowColumnRange rowColumnRange, long widthInMatrix, double widthInWorld, Dictionary`2<ValueTuple`2<long, long>, CloudRasterTileInfo> cloudTileInfos, WrappingMode wrappingMode);
    private static void NTA=(int tileWidth, int tileHeight, RowColumnRange rowColumnRange, long widthInMatrix, double widthInWorld, Dictionary`2<ValueTuple`2<long, long>, CloudRasterTileInfo> cloudTileInfos, WrappingMode wrappingMode, long i, long j, GeoImage cloudImage, List`1<RectangleShape> boxes);
    [AsyncStateMachineAttribute("HRU=.MzA=/fUA=")]
internal static Task NjA=(RasterTileCache projectedTileCache, GeoImage cloudImage, RectangleShape cloudImageExtent, TileMatrix canvasTileMatrix, int zoomIndex, CancellationToken cancellationToken);
    private static List`1<RasterTile> NzA=(GeoImage geoImage, RectangleShape imageExtent, TileMatrix tileMatrix, int zoomLevel);
}
internal abstract class HRU=.NB0= : IB0= {
    public string MB0= { get; }
    public NB0=(string s);
    public NB0=(string s, int line);
    public virtual string ToString();
    public virtual string Lx0=();
    public virtual int GetHashCode();
}
internal class HRU=.nB8= : object {
    internal static bool nR8=(Double& left, Double& bottom, Double& right, Double& top);
    internal static void gh4=(Double& a, Double& b);
}
internal class HRU=.nBk= : jBo= {
    internal double 7Rg=;
    internal double gxc=;
    internal double 7hg=;
    internal double 7xg=;
    internal double 8Bg=;
    internal double 8Rg=;
    internal double 8hg=;
    internal double 8xg=;
    internal double 9Bg=;
    internal Double[] 9Rg=;
    internal int 9hg=;
    private double Zxc=;
    internal nBk=(string id, string desc);
    private void 9xg=();
    internal virtual whg= /Bg=(whg= pjConsts, Int32& pj_Error);
    internal mRo= /Rg=(mhg= lp, whg= pjConsts);
    internal mhg= /hg=(mRo= xy, whg= pjConsts);
    internal void /xg=(mhg= lp, whg= pjConsts, TRg= factors);
    internal void ABk=(whg= pjConsts);
    internal virtual mhg= ARk=(mRo= xy, whg= pjConsts, Int32& pj_Error);
    internal virtual mRo= Ahk=(mhg= lp, whg= pjConsts, Int32& pj_Error);
    internal virtual void Axk=(mhg= lp, whg= pjConsts, TRg= fac, Int32& pj_Error);
    private double QRc=(double sinphi, double e, double one_es, Int32& pj_Error);
    private double BBk=(double qs, double Te, double Tone_es, Int32& pj_Error);
}
internal class HRU=.nC0= : object {
    [CompilerGeneratedAttribute]
private byte ii0=;
    [CompilerGeneratedAttribute]
private List`1<kiw=> nS0=;
    [CompilerGeneratedAttribute]
private List`1<kiw=> ni0=;
    [CompilerGeneratedAttribute]
private List`1<kiw=> ny0=;
    [CompilerGeneratedAttribute]
private double oC0=;
    [CompilerGeneratedAttribute]
private double oS0=;
    [CompilerGeneratedAttribute]
private RectangleShape oi0=;
    public byte kC0= { get; private set; }
    public List`1<kiw=> pS0= { get; private set; }
    public List`1<kiw=> qC0= { get; private set; }
    public List`1<kiw=> qy0= { get; private set; }
    public double ri0= { get; private set; }
    public double sS0= { get; private set; }
    public RectangleShape tC0= { get; private set; }
    public nC0=(byte accuracy);
    [CompilerGeneratedAttribute]
private void jy0=(byte value);
    [CompilerGeneratedAttribute]
public byte ji0=();
    [CompilerGeneratedAttribute]
private void pC0=(List`1<kiw=> value);
    [CompilerGeneratedAttribute]
public List`1<kiw=> oy0=();
    [CompilerGeneratedAttribute]
private void py0=(List`1<kiw=> value);
    [CompilerGeneratedAttribute]
public List`1<kiw=> pi0=();
    [CompilerGeneratedAttribute]
private void qi0=(List`1<kiw=> value);
    [CompilerGeneratedAttribute]
public List`1<kiw=> qS0=();
    [CompilerGeneratedAttribute]
private void rS0=(double value);
    [CompilerGeneratedAttribute]
public double rC0=();
    [CompilerGeneratedAttribute]
private void sC0=(double value);
    [CompilerGeneratedAttribute]
public double ry0=();
    [CompilerGeneratedAttribute]
private void sy0=(RectangleShape value);
    [CompilerGeneratedAttribute]
public RectangleShape si0=();
    public void gC0=(8iw= RTreeLeaf, RectangleShape Box, List`1<string> lblDatas, bool addLblDatas);
    private void tS0=(RectangleShape box);
}
internal class HRU=.NCM= : object {
    private double NSM=;
    private double NiM=;
    private double NyM=;
    private double OCM=;
    public double LCM= { get; public set; }
    public double KSM= { get; public set; }
    public double JiM= { get; public set; }
    public double IyM= { get; public set; }
    public void KyM=(double value);
    public double KiM=();
    public void KCM=(double value);
    public double JyM=();
    public void JSM=(double value);
    public double JCM=();
    public void IiM=(double value);
    public double ISM=();
}
internal class HRU=.Nh0= : NB0= {
    public Nh0=(string s);
    public Nh0=(string s, int line);
}
internal static class HRU=.Nhc= : object {
    private static double Nxc=;
    private static Nhc=();
    internal static double OBc=(double lon, Int32& pj_Error);
    internal static double ORc=(double phi, double sphi, double cphi, Double[] en);
    internal static double Ohc=(double v, Int32& pj_Error);
    internal static double Oxc=(double arg, double es, Double[] en, Int32& pj_Error);
    internal static Double[] PBc=(double es);
    internal static Double[] PRc=(double es);
    internal static double Phc=(double beta, Double[] APA, Int32& pj_Error);
    internal static double Pxc=(double n, double d, Int32& pj_Error);
    internal static double QBc=(double v, Int32& pj_Error);
    internal static double QRc=(double sinphi, double e, double one_es, Int32& pj_Error);
    internal static double Qhc=(double v, Int32& pj_Error);
    internal static double Qxc=(double sinphi, double cosphi, double es, Int32& pj_Error);
    internal static double RBc=(double phi, double sinphi, double e, Int32& pj_Error);
    internal static double RRc=(double ts, double e, Int32& pj_Error);
    internal static vhg= Rhc=(Dictionary`2<string, string> paras, string param, Int32& pj_Error);
    internal static double Rxc=(string p, Int32& pj_Error);
    internal static double SBc=(string handleStr, String& tempStr);
    internal static string SRc=(string lineStr);
    internal static Stream Shc=(string filePath, FileAccess readWriteMode);
    internal static bool Sxc=();
    internal static void TBc=(Byte[] data, int offsetIndex, int wordSize, int wordCount);
    internal static string TRc=(Byte[] characters, int index, int count);
    internal static int Thc=(Byte[] byteArray, int index, int count, Int32& pj_Error);
    internal static double Txc=(Byte[] byteArray, int index, int count);
    internal static void UBc=(double x, Int32& pj_Error);
    internal static string URc=(string param);
}
internal class HRU=.nhk= : jBo= {
    internal nhk=(string id, string desc);
    private void 9xg=();
    internal virtual void Axk=(mhg= lp, whg= pjConsts, TRg= fac, Int32& pj_Error);
    internal virtual whg= /Bg=(whg= pjConsts, Int32& pj_Error);
    internal virtual mhg= ARk=(mRo= xy, whg= pjConsts, Int32& pj_Error);
    internal virtual mRo= Ahk=(mhg= lp, whg= pjConsts, Int32& pj_Error);
}
internal class HRU=.Nhk= : jBo= {
    internal mRo= Nxk=;
    internal double OBk=;
    internal double ORk=;
    internal double Ohk=;
    internal Nhk=(string id, string desc);
    private void 9xg=();
    internal virtual whg= /Bg=(whg= pjConsts, Int32& pj_Error);
    internal virtual void Axk=(mhg= lp, whg= pjConsts, TRg= fac, Int32& pj_Error);
    internal virtual mhg= ARk=(mRo= xy, whg= pjConsts, Int32& pj_Error);
    internal virtual mRo= Ahk=(mhg= lp, whg= pjConsts, Int32& pj_Error);
}
internal class HRU=.Nho= : jBo= {
    internal double Nxo=;
    internal double OBo=;
    internal double ORo=;
    internal double Oho=;
    internal int DRk=;
    internal Nho=(string id, string desc);
    private void 9xg=();
    internal virtual whg= /Bg=(whg= pjConsts, Int32& pj_Error);
    internal virtual void Axk=(mhg= lp, whg= pjConsts, TRg= fac, Int32& pj_Error);
    internal virtual mhg= ARk=(mRo= xy, whg= pjConsts, Int32& pj_Error);
    internal virtual mRo= Ahk=(mhg= lp, whg= pjConsts, Int32& pj_Error);
    private double Oxo=(double phit, double sinphi, double eccen, Int32& pj_Error);
    private mRo= Exk=(mhg= lp, whg= pjConsts, Int32& pj_Error);
    private mRo= ERk=(mhg= lp, whg= pjConsts, Int32& pj_Error);
    private mhg= EBk=(mRo= xy, whg= pjConsts, Int32& pj_Error);
    private mhg= Dhk=(mRo= xy, whg= pjConsts, Int32& pj_Error);
}
internal class HRU=.nic= : Zyc= {
    private int nyc=;
    private gic=[] oCc=;
    public virtual string byc=();
    public virtual ryY= bic=();
    public virtual Zyc= aic=();
    public virtual qiY= bSc=(String& ppszDstText);
    public virtual void ayc=(Hyc= psEnvelope);
    public virtual void cCc=(int nNewDimension);
    public void oSc=(gic= poNewRing);
    public void oic=(gic= poNewRing);
    public gic= oyc=();
    public int pCc=();
    public gic= pSc=(int iRing);
}
internal class HRU=.Nik= : zSo= {
    private static int Nyk=;
    protected int OCk=;
    protected int OSk=;
    protected int Oik=;
    protected int jyg=;
    protected int kCg=;
    protected int Oyk=;
    protected int PCk=;
    protected int PSk=;
    protected int Pik=;
    protected Lig= GCk=;
    protected int Pyk=;
    protected int QCk=;
    protected int QSk=;
    protected int Qik=;
    protected int Qyk=;
    protected int RCk=;
    public Nik=(FSg= eAccessMode);
    public virtual int InitBlockFromData(Byte[] pabyBuf, int nBlockSize, int nSizeUsed, bool bMakeCopy, Stream fsSrc, int nOffset);
    public virtual int InitNewBlock(Stream fsSrc, int nBlockSize, int nFileOffset);
    public virtual int CommitToFile();
    public virtual int GetBlockClass();
    public void RSk=(Lig= poBlockManager);
    public virtual int ReadBytes(int numBytes, Byte[] pabyDstBuf);
    public virtual int WriteBytes(int nBytesToWrite, Byte[] pabySrcBuf);
    public void Rik=(int nX, int nY);
    public int Ryk=(bool bCompressed, Int32& nX, Int32& nY);
    public int SCk=(bool bCompressed, int numCoordPairs, Int32[] panXY);
    public int SSk=(bool bCompressed, int nVersion, int numSections, Uik=[] pasHdrs, Int32& numVerticesTotal);
    public int Sik=(int nVersion, int numSections, Uik=[] pasHdrs, bool bCompressed);
    public void Syk=(int nNextCoordBlockAddress);
    public int TCk=();
    public int TSk=(int nX, int nY, bool bCompressed);
    public int Tik=();
    public void Tyk=();
    public void UCk=();
    public int USk=();
}
internal enum HRU=.niQ= : Enum {
    public int value__;
    public static niQ= nyQ=;
    public static niQ= oCQ=;
    public static niQ= oSQ=;
    public static niQ= oiQ=;
    public static niQ= oyQ=;
    public static niQ= pCQ=;
    public static niQ= pSQ=;
}
internal class HRU=.NR0= : NB0= {
    public NR0=(string s);
    public NR0=(string s, int line);
}
internal class HRU=.nRk= : jBo= {
    internal Uhc=[] Gxk=;
    internal double HBk=;
    internal double HRk=;
    internal int gxc=;
    internal nRk=(string id, string desc);
    private void 9xg=();
    internal virtual whg= /Bg=(whg= pjConsts, Int32& pj_Error);
    internal virtual void Axk=(mhg= lp, whg= pjConsts, TRg= fac, Int32& pj_Error);
    internal virtual mhg= ARk=(mRo= xy, whg= pjConsts, Int32& pj_Error);
    internal virtual mRo= Ahk=(mhg= lp, whg= pjConsts, Int32& pj_Error);
    private mhg= EBk=(mRo= xy, whg= pjConsts, Int32& pj_Error);
    private mRo= Exk=(mhg= lp, whg= pjConsts, Int32& pj_Error);
    private Uhc= Hhk=(Uhc= z, Uhc=[] C, int n, Uhc= der);
    private Uhc= Hxk=(Uhc= z, Uhc=[] C, int n);
}
internal class HRU=.nSE= : object {
    public static int niE=;
    private static hiE= ViE=;
    private TextReader nyE=;
    private Char[] vBw=;
    private 6D8= oCE=;
    private 7D8= oSE=;
    private int oiE=;
    private int oyE=;
    private int pCE=;
    private int pSE=;
    private bool piE=;
    private bool pyE=;
    private char qCE=;
    private Nullable`1<char> qSE=;
    public TextReader 4Rw= { get; }
    public bool XSE= { get; public set; }
    public bool YCE= { get; public set; }
    public char YyE= { get; public set; }
    public Nullable`1<char> ZiE= { get; public set; }
    public bool bSE= { get; }
    private bool qyE= { get; }
    public nSE=(TextReader reader);
    private static nSE=();
    public TextReader 3xw=();
    public bool WyE=();
    public void XCE=(bool value);
    public bool XiE=();
    public void XyE=(bool value);
    public char YSE=();
    public void YiE=(char value);
    public Nullable`1<char> ZCE=();
    public void ZSE=(Nullable`1<char> value);
    public bool bCE=();
    private bool qiE=();
    public int ciE=(int skip);
    public int rCE=(eiE= headerRecord, eCE=[] buffer, int offset, int count);
    private static bool rSE=(char ch);
    private void riE=();
    private bool ryE=(char ch);
    private bool sCE=();
    private bool sSE=();
}
internal static class HRU=.nSs= : object {
    internal static void nis=(bool isEditable);
    internal static void nys=(bool isOpen);
    internal static void oCs=(bool isInTransaction);
    internal static void oSs=(bool isInTransaction);
    internal static void ois=(int value);
    internal static void oys=(string contractId);
    internal static void pCs=(int symbolNumber, string parameterName);
}
internal class HRU=.Nx0= : NB0= {
    public Nx0=(string s);
    public Nx0=(string s, int line);
}
internal class HRU=.nxk= : jBo= {
    internal nxk=(string id, string desc);
    private void 9xg=();
    internal virtual void Axk=(mhg= lp, whg= pjConsts, TRg= fac, Int32& pj_Error);
    internal virtual whg= /Bg=(whg= pjConsts, Int32& pj_Error);
    internal virtual mhg= ARk=(mRo= xy, whg= pjConsts, Int32& pj_Error);
    internal virtual mRo= Ahk=(mhg= lp, whg= pjConsts, Int32& pj_Error);
}
internal class HRU=.Nyg= : object {
    public int OCg=;
    public Nyg= zCQ=;
}
internal class HRU=.nyw= : object {
    [CompilerGeneratedAttribute]
private Vertex oCw=;
    [CompilerGeneratedAttribute]
private string lCw=;
    [CompilerGeneratedAttribute]
private List`1<int> oSw=;
    [CompilerGeneratedAttribute]
private bool oiw=;
    public Vertex pSw= { get; public set; }
    public string myw= { get; public set; }
    public List`1<int> qCw= { get; public set; }
    public bool qyw= { get; public set; }
    [CompilerGeneratedAttribute]
public Vertex oyw=();
    [CompilerGeneratedAttribute]
public void pCw=(Vertex value);
    [CompilerGeneratedAttribute]
public string mSw=();
    [CompilerGeneratedAttribute]
public void miw=(string value);
    [CompilerGeneratedAttribute]
public List`1<int> piw=();
    [CompilerGeneratedAttribute]
public void pyw=(List`1<int> value);
    [CompilerGeneratedAttribute]
public void qiw=(bool value);
    [CompilerGeneratedAttribute]
public bool qSw=();
    public virtual string ToString();
}
internal class HRU=.nzE= : ValueType {
    internal int mho=;
    internal int mxo=;
    public nzE=(int x, int y);
}
internal class HRU=.OB0= : NB0= {
    public OB0=(string s);
    public OB0=(string s, int line);
}
internal class HRU=.oBk= : jBo= {
    internal double 8xg=;
    internal double GRk=;
    internal double oRk=;
    internal oBk=(string id, string desc);
    private void 9xg=();
    internal virtual whg= /Bg=(whg= pjConsts, Int32& pj_Error);
    internal virtual void Axk=(mhg= lp, whg= pjConsts, TRg= fac, Int32& pj_Error);
    internal virtual mhg= ARk=(mRo= xy, whg= pjConsts, Int32& pj_Error);
    internal virtual mRo= Ahk=(mhg= lp, whg= pjConsts, Int32& pj_Error);
}
internal class HRU=.oCg= : object {
    protected int oSg=;
    protected OSg= oig=;
    private static OSg= oyg=;
    public OSg= jyU= { get; public set; }
    public int kiU= { get; public set; }
    public virtual int kyU=();
    public virtual OSg= lCU=();
    public virtual int lSU=();
    public virtual int liU=();
    public virtual byte lyU=();
    public virtual byte mCU=();
    public virtual void mSU=(int clr);
    public virtual void miU=(int clr);
    public virtual void myU=(byte val);
    public virtual void nCU=(byte val);
    public virtual string nSU=();
    public virtual void niU=(string pszStyleString);
    public virtual void nyU=(Stream fpOut);
    public sealed virtual OSg= jSU=();
    public sealed virtual void jiU=(OSg= value);
    public sealed virtual int kCU=();
    public sealed virtual void kSU=(int value);
}
internal interface HRU=.oCU= {
    public int oyU= { get; public set; }
    public 4Cg= piU= { get; public set; }
    public abstract virtual int oSU=();
    public abstract virtual void oiU=(int value);
    public abstract virtual 4Cg= pCU=();
    public abstract virtual void pSU=(4Cg= value);
    public abstract virtual int pyU=();
    public abstract virtual 4Cg= qCU=();
    public abstract virtual string qSU=();
    public abstract virtual void qiU=(string pszName);
    public abstract virtual void qyU=(Stream fpOut);
}
internal class HRU=.ODA= : object {
    public static string OTA=;
    public static string OjA=;
    public static string OzA=;
    public static string PDA=;
    public static string PTA=;
    public static string PjA=;
    public static string PzA=;
    public static string QDA=;
    public static string QTA=;
    public static string QjA=;
    public static string QzA=;
    public static string RDA=;
    public static string RTA=;
    public static string RjA=;
    public static string RzA=;
    public static string SDA=;
    public static string STA=;
    public static string SjA=;
    public static string SzA=;
    public static string TDA=;
    public static string TTA=;
    public static string TjA=;
    public static string TzA=;
    public static string UDA=;
    public static string UTA=;
    public static string UjA=;
    public static string UzA=;
    public static string VDA=;
    public static string VTA=;
    public static string VjA=;
    public static string VzA=;
    public static string WDA=;
    public static string WTA=;
    public static string WjA=;
    public static string WzA=;
    public static string XDA=;
    public static string XTA=;
    public static string XjA=;
    public static string XzA=;
    public static string YDA=;
    public static string YTA=;
    public static string YjA=;
    public static string YzA=;
    public static string ZDA=;
    public static string ZTA=;
    public static string ZjA=;
    public static string ZzA=;
    public static string aDA=;
    public static string aTA=;
    public static string ajA=;
    public static string azA=;
    public static string bDA=;
    public static string bTA=;
    public static string bjA=;
    public static string bzA=;
    public static string cDA=;
    public static string cTA=;
    public static string cjA=;
    public static string czA=;
    public static string dDA=;
    public static string dTA=;
    public static string djA=;
    public static string dzA=;
    public static string eDA=;
    public static string eTA=;
    public static string ejA=;
    public static string ezA=;
    public static string fDA=;
    public static string fTA=;
    public static string fjA=;
    public static string fzA=;
    public static string gDA=;
    public static string gTA=;
    public static string gjA=;
    public static string gzA=;
    public static string hDA=;
    public static string hTA=;
    public static string hjA=;
    public static string hzA=;
    public static string iDA=;
    public static string iTA=;
    public static string ijA=;
    public static string izA=;
    public static string jDA=;
    public static string jTA=;
    public static string jjA=;
    public static string jzA=;
    public static string kDA=;
    public static string kTA=;
    public static string kjA=;
    public static string kzA=;
    public static string lDA=;
    public static string lTA=;
    public static string ljA=;
    public static string lzA=;
    public static string mDA=;
    public static string mTA=;
    public static string mjA=;
    public static string mzA=;
    public static string nDA=;
    public static string nTA=;
    public static string njA=;
    public static string nzA=;
    public static string oDA=;
    public static string vCs=;
    public static string oTA=;
    public static string ojA=;
    public static string ozA=;
    public static string pDA=;
    public static string pTA=;
    public static string pjA=;
    public static string pzA=;
    public static string qDA=;
    public static string qTA=;
    public static string qjA=;
    public static string qzA=;
    public static string rDA=;
    public static string rTA=;
    public static string rjA=;
    public static string rzA=;
    public static string sDA=;
    public static string sTA=;
    public static string sjA=;
    public static string szA=;
    public static string tDA=;
    public static string tTA=;
    public static string tjA=;
    public static string tzA=;
    public static string uDA=;
    public static string uTA=;
    public static string ujA=;
    public static string uzA=;
    public static string vDA=;
    public static string vTA=;
    public static string vjA=;
    public static string vzA=;
    public static string wDA=;
    public static string wTA=;
    public static string wjA=;
    public static string wzA=;
    public static string xDA=;
    public static string xTA=;
    private static Assembly xjA=;
    public static string yDA= { get; }
    public static string yjA= { get; }
    public static string zDA= { get; }
    public static string zjA= { get; }
    public static string 0DA= { get; }
    public static string 0jA= { get; }
    public static Byte[] 1DA= { get; }
    public static Byte[] 1jA= { get; }
    public static Byte[] 2DA= { get; }
    public static Byte[] 2jA= { get; }
    public static Byte[] 3DA= { get; }
    public static Byte[] 3jA= { get; }
    public static Byte[] 4DA= { get; }
    public static Byte[] 4jA= { get; }
    public static Byte[] 5DA= { get; }
    public static Byte[] 5jA= { get; }
    public static Byte[] 6DA= { get; }
    public static Byte[] 6jA= { get; }
    public static Byte[] 7DA= { get; }
    public static Byte[] 7jA= { get; }
    public static Byte[] 8DA= { get; }
    public static Byte[] 8jA= { get; }
    public static Byte[] 9DA= { get; }
    public static Byte[] 9jA= { get; }
    private static ODA=();
    public static string xzA=();
    public static string yTA=();
    public static string yzA=();
    public static string zTA=();
    public static string zzA=();
    public static string 0TA=();
    public static Byte[] 0zA=();
    public static Byte[] 1TA=();
    public static Byte[] 1zA=();
    public static Byte[] 2TA=();
    public static Byte[] 2zA=();
    public static Byte[] 3TA=();
    public static Byte[] 3zA=();
    public static Byte[] 4TA=();
    public static Byte[] 4zA=();
    public static Byte[] 5TA=();
    public static Byte[] 5zA=();
    public static Byte[] 6TA=();
    public static Byte[] 6zA=();
    public static Byte[] 7TA=();
    public static Byte[] 7zA=();
    public static Byte[] 8TA=();
    public static Byte[] 8zA=();
    public static Byte[] 9TA=();
    public static Byte[] 7xM=(string resourceName);
    public static string BSw=(string resourceName);
    public static Byte[] 9zA=(Stream stream);
}
internal class HRU=.Oh0= : IB0= {
    public string MB0= { get; }
    public Oh0=(string s);
    public Oh0=(float f);
    public Oh0=(double d);
    public Oh0=(string s, int line);
    public Oh0=(double f, int line);
    public virtual string ToString();
    public virtual int GetHashCode();
    public virtual string Lx0=();
    public virtual bool Equals(object other);
}
internal class HRU=.ohg= : object {
    internal static double XhY=;
    internal static double oxg=(double d);
    internal static double pBg=(double x, double y);
    internal static double pRg=(double d, Int32& pj_Error);
    internal static double phg=(double d, Int32& pj_Error);
    internal static double pxg=(double d, Int32& pj_Error);
    internal static double qBg=(double d, Int32& pj_Error);
    internal static double qRg=(double d, Int32& pj_Error);
    internal static double qhg=(double d, Int32& pj_Error);
    internal static double qxg=(double y, double x, Int32& pj_Error);
    internal static double rBg=(double d, Int32& pj_Error);
    internal static double rRg=(double d, Int32& pj_Error);
    internal static double rhg=(double d, Int32& pj_Error);
    internal static double rxg=(double x, double y, Int32& pj_Error);
    internal static double sBg=(double d, Int32& pj_Error);
    internal static double sRg=(double d, Int32& pj_Error);
    internal static double shg=(double d, Int32& pj_Error);
}
internal class HRU=.ohk= : jBo= {
    internal double Lxk=;
    internal double oxk=;
    internal double pBk=;
    internal double Thk=;
    internal double pRk=;
    internal double phk=;
    internal double vxg=;
    internal double pxk=;
    internal double axk=;
    internal double qBk=;
    internal double qRk=;
    internal double qhk=;
    internal double qxk=;
    internal double rBk=;
    internal double rRk=;
    internal ohk=(string id, string desc);
    private void 9xg=();
    internal virtual whg= /Bg=(whg= pjConsts, Int32& pj_Error);
    internal virtual void Axk=(mhg= lp, whg= pjConsts, TRg= fac, Int32& pj_Error);
    internal virtual mhg= ARk=(mRo= xy, whg= pjConsts, Int32& pj_Error);
    internal virtual mRo= Ahk=(mhg= lp, whg= pjConsts, Int32& pj_Error);
    private void rhk=(double lam, double mult, whg= pjConsts, Int32& pj_Error);
}
internal class HRU=.OR0= : IB0= {
    public string MB0= { get; }
    public OR0=(string s, int line);
    public OR0=(char c);
    public OR0=(char c, int line);
    public virtual string ToString();
    public virtual int GetHashCode();
    public virtual string Lx0=();
    public virtual bool Equals(object other);
}
internal class HRU=.OS4= : ValueType {
    [CompilerGeneratedAttribute]
private int Oi4=;
    [CompilerGeneratedAttribute]
private int Oy4=;
    [CompilerGeneratedAttribute]
private int PC4=;
    [CompilerGeneratedAttribute]
private int PS4=;
    public int QC4= { get; public set; }
    public int Qy4= { get; public set; }
    public int Ri4= { get; public set; }
    public int SS4= { get; public set; }
    [CompilerGeneratedAttribute]
[yhM=]
public int Pi4=();
    [CompilerGeneratedAttribute]
public void Py4=(int value);
    [yhM=]
[CompilerGeneratedAttribute]
public int QS4=();
    [CompilerGeneratedAttribute]
public void Qi4=(int value);
    [CompilerGeneratedAttribute]
[yhM=]
public int RC4=();
    [CompilerGeneratedAttribute]
public void RS4=(int value);
    [yhM=]
[CompilerGeneratedAttribute]
public int Ry4=();
    [CompilerGeneratedAttribute]
public void SC4=(int value);
}
internal class HRU=.OSg= : object {
    public int PSc=;
    public byte Oig=;
    public byte Oyg=;
    public int PCg=;
    public int PSg=;
    public OSg=(int nRefCount, byte nFillPattern, byte bTransparentFill, int rgbFGColor, int rgbBGColor);
}
internal class HRU=.OSM= : object {
    private List`1<Collection`1<GridCell>> OiM=;
    private double OyM=;
    public List`1<Collection`1<GridCell>> PSM= { get; }
    public double QCM= { get; public set; }
    public List`1<Collection`1<GridCell>> PCM=();
    public void PyM=(double value);
    public double PiM=();
}
internal class HRU=.OSo= : RCo= {
    private bool Oio=;
    private double HSg=;
    private double Hig=;
    private static int 9CQ=;
    private static int 9SQ=;
    private static int 9iQ=;
    private static int 9yQ=;
    public OSo=(PCc= poDefnIn);
    public virtual pCg= Iig=();
    public virtual int Iyg=(Wyk= poMapFile);
    public virtual iSg= JCg=(PCc= poNewDefn);
    public int Oyo=(int i, Double& dX, Double& dY);
    public int PCo=();
    public int PSo=(Double& dX, Double& dY);
    public void Pio=(double dX, double dY);
    public virtual int JSg=(Wyk= poMapFile, CSo= poObjHdr, bool bCoordBlockDataOnly, Nik=& ppoCoordBlock);
    public virtual int Jig=(Wyk= poMapFile, CSo= poObjHdr, bool bCoordBlockDataOnly, Nik=& ppoCoordBlock);
    public virtual int Jyg=(6yU= fp);
    public virtual int KCg=(6yU= fp);
    public virtual void KSg=(Stream fsOut);
}
internal class HRU=.oSY= : object {
    public int oiY=;
    public qiY= oyY=(nic= poPoly, mSc= poLabelPoint);
    private bool pCY=(mSc= poPoint, nic= poPoly);
    private bool pSY=(mSc= poPoint, hyc= poRing);
}
internal class HRU=.Ox0= : IB0= {
    public string MB0= { get; }
    public Ox0=(int i);
    public Ox0=(long i);
    public Ox0=(string s);
    public Ox0=(string s, int line);
    public Ox0=(int i, int line);
    public Ox0=(long l, int line);
    public static Ox0= PB0=(string s, int lineNumber);
    private void kxU=(string s);
    public virtual string ToString();
    public virtual int GetHashCode();
    public virtual string Lx0=();
    public virtual bool Equals(object other);
}
internal class HRU=.Oxk= : jBo= {
    internal Oxk=(string id, string desc);
    private void 9xg=();
    internal virtual whg= /Bg=(whg= pjConsts, Int32& pj_Error);
    internal virtual void Axk=(mhg= lp, whg= pjConsts, TRg= fac, Int32& pj_Error);
    internal virtual mhg= ARk=(mRo= xy, whg= pjConsts, Int32& pj_Error);
    internal virtual mRo= Ahk=(mhg= lp, whg= pjConsts, Int32& pj_Error);
}
internal class HRU=.oxw= : object {
    public BaseShape pBw=(Byte[] data);
    public static WkbShapeType mBw=(Byte[] wkb, int startIndex);
    public virtual BaseShape pBw=(Stream stream);
    protected BaseShape pBw=(BinaryReader reader);
    protected WkbByteOrder pRw=(BinaryReader reader);
    protected Vertex phw=(BinaryReader reader);
    protected RingShape pxw=(BinaryReader reader);
    protected PointShape qBw=(BinaryReader reader);
    protected LineShape qRw=(BinaryReader reader);
    protected PolygonShape qhw=(BinaryReader reader);
    protected MultipointShape qxw=(BinaryReader reader);
    protected MultilineShape rBw=(BinaryReader reader);
    protected MultipolygonShape rRw=(BinaryReader reader);
    protected GeometryCollectionShape rhw=(BinaryReader reader);
}
internal class HRU=.Oy8= : object {
    private float PC8=;
    private float PS8=;
    private int Pi8=;
    public float QS8= { get; public set; }
    public float RC8= { get; public set; }
    public int Ry8= { get; public set; }
    public float Py8=();
    public void QC8=(float value);
    public float Qi8=();
    public void Qy8=(float value);
    public int RS8=();
    public void Ri8=(int value);
}
internal class HRU=.OzM= : object {
    private string OxQ=;
    private Exception PDM=;
    private bool PTM=;
    private ThinkGeoLicenseStatus OhQ=;
    private static int PjM=;
    private bool PzM=;
    private double QDM=;
    private int QTM=;
    [CompilerGeneratedAttribute]
private DateTime QjM=;
    [CompilerGeneratedAttribute]
private DateTime QzM=;
    public bool RTM= { get; }
    public string ZhQ= { get; public set; }
    public Exception SDM= { get; public set; }
    public bool SzM= { get; public set; }
    internal ThinkGeoLicenseStatus YxQ= { get; internal set; }
    internal bool TTM= { get; }
    internal DateTime UDM= { get; internal set; }
    private DateTime UzM= { get; private set; }
    internal double VjM= { get; internal set; }
    public bool RDM=();
    public string ZBQ=();
    public void ZRQ=(string value);
    public Exception RjM=();
    public void RzM=(Exception value);
    public bool STM=();
    public void SjM=(bool value);
    internal ThinkGeoLicenseStatus YRQ=();
    internal void YhQ=(ThinkGeoLicenseStatus value);
    internal bool TDM=();
    [CompilerGeneratedAttribute]
internal DateTime TjM=();
    [CompilerGeneratedAttribute]
internal void TzM=(DateTime value);
    [CompilerGeneratedAttribute]
private DateTime UTM=();
    [CompilerGeneratedAttribute]
private void UjM=(DateTime value);
    internal double VDM=();
    internal void VTM=(double value);
    private bool VzM=();
}
internal class HRU=.PBk= : jBo= {
    internal PBk=(string id, string desc);
    private void 9xg=();
    internal virtual whg= /Bg=(whg= pjConsts, Int32& pj_Error);
    internal virtual void Axk=(mhg= lp, whg= pjConsts, TRg= fac, Int32& pj_Error);
    internal virtual mhg= ARk=(mRo= xy, whg= pjConsts, Int32& pj_Error);
    internal virtual mRo= Ahk=(mhg= lp, whg= pjConsts, Int32& pj_Error);
}
internal class HRU=.PBo= : ValueType {
    internal double FRg=;
    internal double MRo=;
    internal double zRg=;
    internal double PRo=;
}
internal class HRU=.PCc= : object {
    private int PSc=;
    private int Pic=;
    private List`1<Wyc=> Pyc=;
    private ryY= QCc=;
    private string QSc=;
    public PCc=(string pszName);
    public string Qic=();
    public int Lyc=();
    public Wyc= Qyc=(int iField);
    public int MSc=(string pszFieldName);
    public void RCc=(Wyc= poNewDefn);
    public ryY= RSc=();
    public void Ric=(ryY= eNewType);
    public int Ryc=();
    public int SCc=();
    public void SSc=();
}
internal enum HRU=.pCg= : Enum {
    public int value__;
    public static pCg= pSg=;
    public static pCg= pig=;
    public static pCg= pyg=;
    public static pCg= qCg=;
    public static pCg= qSg=;
    public static pCg= qig=;
    public static pCg= qyg=;
    public static pCg= rCg=;
    public static pCg= rSg=;
    public static pCg= rig=;
    public static pCg= ryg=;
    public static pCg= sCg=;
    public static pCg= sSg=;
}
internal class HRU=.Phk= : jBo= {
    internal Phk=(string id, string desc);
    private void 9xg=();
    internal virtual whg= /Bg=(whg= pjConsts, Int32& pj_Error);
    internal virtual void Axk=(mhg= lp, whg= pjConsts, TRg= fac, Int32& pj_Error);
    internal virtual mhg= ARk=(mRo= xy, whg= pjConsts, Int32& pj_Error);
    internal virtual mRo= Ahk=(mhg= lp, whg= pjConsts, Int32& pj_Error);
}
internal class HRU=.Pho= : jBo= {
    internal int dBc=;
    internal Double[] Pxo=;
    internal double QBo=;
    internal double QRo=;
    internal double Qho=;
    internal PBo=[] 9Rg=;
    internal Pho=(string id, string desc);
    private void 9xg=();
    internal virtual whg= /Bg=(whg= pjConsts, Int32& pj_Error);
    internal virtual void Axk=(mhg= lp, whg= pjConsts, TRg= fac, Int32& pj_Error);
    internal virtual mhg= ARk=(mRo= xy, whg= pjConsts, Int32& pj_Error);
    internal virtual mRo= Ahk=(mhg= lp, whg= pjConsts, Int32& pj_Error);
    private double Qxo=(double esinp, double exp, Int32& pj_Error);
    private PBo= RBo=(double e, double phi0, Double[] chi, Double[] rc, Int32& pj_Error);
    private mhg= RRo=(mhg= slp, PBo=[] en, Int32& pj_Error);
    private mhg= Rho=(mhg= elp, PBo=[] en, Int32& pj_Error);
}
internal class HRU=.pi4= : object {
    private List`1<ci4=> py4=;
    private zyw= 0Sw=;
    public List`1<ci4=> qS4= { get; }
    public List`1<ci4=> qC4=();
    public void pBw=(Stream stream, int endOffset, bool isEncrypted, Encoding encoding, int columnNameBlockCount, string password);
}
internal class HRU=.pic= : object {
    public static void pyc=(String& destString, int index, string srcString);
    public static void HCU=(T[] dest, int indexDest, T[] src, int indexSrc, int count);
    public static T[] GCU=(T[] srcArray, int destLength);
    public static int DSU=(String& stringDst, int index);
    public static int DSU=(string charArray);
    public static string DiU=(string strOgr, string strSub);
    public static bool FiU=(string string1, string string2, int count);
    public static bool FyU=(string string1, string string2);
}
internal class HRU=.Pig= : iSg= {
    private 8So= Pyg=;
    private hCo= QCg=;
    private OSo= QSg=;
    private uig= Qig=;
    private static int 9CQ=;
    private static int 9SQ=;
    private static int 9iQ=;
    private static int 9yQ=;
    public int xSU= { get; public set; }
    public Iis= yCU= { get; public set; }
    public Pig=(PCc= poDefnIn);
    private void Qyg=();
    private int RCg=(Nik= poCoordBlock, bool bComprCoord, int nComprOrgX, int nComprOrgY, Int32& pnMinX, Int32& pnMinY, Int32& pnMaxX, Int32& pnMaxY, Int32& pnLabelX, Int32& pnLabelY);
    private int RSg=(Nik= poCoordBlock, bool bComprCoord, int nMinX, int nMinY, int nMaxX, int nMaxY, int nLabelX, int nLabelY);
    private int Rig=(bool bSyncRegion, bool bSyncPline, bool bSyncMpoint);
    public virtual pCg= Iig=();
    public virtual int Iyg=(Wyk= poMapFile);
    public virtual iSg= JCg=(PCc= poNewDefn);
    public virtual int JSg=(Wyk= poMapFile, CSo= poObjHdr, bool bCoordDataOnly, Nik=& ppoCoordBlock);
    public virtual int Jig=(Wyk= poMapFile, CSo= poObjHdr, bool bCoordBlockDataOnly, Nik=& ppoCoordBlock);
    public virtual int Jyg=(6yU= fp);
    public virtual int KCg=(6yU= fp);
    public virtual string Oic=();
    public virtual void KSg=(Stream fsOut);
    public int Ryg=(8So= poRegion);
    public int SCg=(hCo= poPline);
    public int SSg=(OSo= poMpoint);
    public virtual int wyU=();
    public virtual void xCU=(int value);
    public virtual Iis= xiU=();
    public virtual void xyU=(Iis= value);
    public virtual int ySU=();
    public virtual Iis= yiU=();
    public virtual short yyU=();
    public virtual short zCU=();
    public virtual int zSU=();
    public virtual void ziU=(short val);
    public virtual void zyU=(short val);
    public virtual void 0CU=(int clr);
    public virtual string 0SU=(double dfAngle);
    public virtual void 0iU=(string pszStyleString);
    public virtual void 0yU=(Stream fpOut);
}
internal enum HRU=.piQ= : Enum {
    public int value__;
    public static piQ= pyQ=;
    public static piQ= qCQ=;
    public static piQ= qSQ=;
    public static piQ= qiQ=;
    public static piQ= qyQ=;
    public static piQ= rCQ=;
    public static piQ= rSQ=;
    public static piQ= riQ=;
    public static piQ= ryQ=;
    public static piQ= sCQ=;
    public static piQ= sSQ=;
    public static piQ= siQ=;
}
internal abstract class HRU=.piY= : Zyc= {
    public abstract virtual void pyY=(mSc= ogrPoint);
    public abstract virtual void qCY=(mSc= ogrPoint);
    public virtual int qSY=();
}
internal enum HRU=.PR0= : Enum {
    public int value__;
    public static PR0= Ph0=;
    public static PR0= Px0=;
    public static PR0= QB0=;
    public static PR0= QR0=;
}
internal class HRU=.PRk= : jBo= {
    internal PRk=(string id, string desc);
    private void 9xg=();
    internal virtual whg= /Bg=(whg= pjConsts, Int32& pj_Error);
    internal virtual void Axk=(mhg= lp, whg= pjConsts, TRg= fac, Int32& pj_Error);
    internal virtual mhg= ARk=(mRo= xy, whg= pjConsts, Int32& pj_Error);
    internal virtual mRo= Ahk=(mhg= lp, whg= pjConsts, Int32& pj_Error);
}
internal class HRU=.pRs= : object {
    protected long phs=;
    public virtual long pxs=();
}
internal static class HRU=.PSI= : object {
    public static string PiI=(string degreesMinutesSeconds);
}
internal class HRU=.Pxk= : jBo= {
    internal mRo= Nxk=;
    internal double OBk=;
    internal double ORk=;
    internal double Ohk=;
    internal Pxk=(string id, string desc);
    private void 9xg=();
    internal virtual whg= /Bg=(whg= pjConsts, Int32& pj_Error);
    internal virtual void Axk=(mhg= lp, whg= pjConsts, TRg= fac, Int32& pj_Error);
    internal virtual mhg= ARk=(mRo= xy, whg= pjConsts, Int32& pj_Error);
    internal virtual mRo= Ahk=(mhg= lp, whg= pjConsts, Int32& pj_Error);
}
internal class HRU=.Py0= : object {
    [CompilerGeneratedAttribute]
private ushort QC0=;
    [CompilerGeneratedAttribute]
private string QS0=;
    [CompilerGeneratedAttribute]
private WellKnownType zCM=;
    [CompilerGeneratedAttribute]
private RectangleShape Qi0=;
    [CompilerGeneratedAttribute]
private int kyw=;
    public ushort RS0= { get; private set; }
    public string SC0= { get; public set; }
    public WellKnownType xiw= { get; private set; }
    public RectangleShape Sy0= { get; public set; }
    public int mCw= { get; private set; }
    public Py0=(RectangleShape box);
    public Py0=(RectangleShape box, WellKnownType objType, int objIndex, string lable, ushort fclass);
    [CompilerGeneratedAttribute]
private void RC0=(ushort value);
    [CompilerGeneratedAttribute]
public ushort Qy0=();
    [CompilerGeneratedAttribute]
public void Ry0=(string value);
    [CompilerGeneratedAttribute]
public string Ri0=();
    [CompilerGeneratedAttribute]
private void xSw=(WellKnownType value);
    [CompilerGeneratedAttribute]
public WellKnownType xCw=();
    [CompilerGeneratedAttribute]
public void Si0=(RectangleShape value);
    [CompilerGeneratedAttribute]
public RectangleShape SS0=();
    [CompilerGeneratedAttribute]
private void lyw=(int value);
    [CompilerGeneratedAttribute]
public int liw=();
}
internal enum HRU=.PyI= : Enum {
    public int value__;
    public static PyI= QCI=;
    public static PyI= QSI=;
}
internal class HRU=.Pyo= : object {
    public int PSc=;
    public byte QCo=;
    public byte QSo=;
    public int Qio=;
    public int Qyo=;
    public Pyo=(int nRefCount, byte nPixelWidth, byte nLinePattern, int nPointWidth, int rgbColor);
}
internal class HRU=.QBk= : jBo= {
    internal double thc=;
    internal double txc=;
    internal double QRk=;
    internal double Qhk=;
    internal QBk=(string id, string desc);
    private void 9xg=();
    internal virtual whg= /Bg=(whg= pjConsts, Int32& pj_Error);
    internal virtual void Axk=(mhg= lp, whg= pjConsts, TRg= fac, Int32& pj_Error);
    internal virtual mhg= ARk=(mRo= xy, whg= pjConsts, Int32& pj_Error);
    internal virtual mRo= Ahk=(mhg= lp, whg= pjConsts, Int32& pj_Error);
}
internal class HRU=.qBs= : object {
    private double qRs=;
    private double qhs=;
    public double rRs= { get; public set; }
    public double sBs= { get; public set; }
    public qBs=(double easting, double northing);
    public double qxs=();
    public void rBs=(double value);
    public double rhs=();
    public void rxs=(double value);
    public virtual string ToString();
}
internal class HRU=.qCc= : object {
    public double mho=;
    public double mxo=;
}
internal class HRU=.Qh0= : object {
    private int Qx0=;
    public BaseShape pBw=(string wellKnownText);
    public BaseShape pBw=(TextReader reader);
    private Vertex[] RB0=(IList tokens, bool skipExtraParenthesis);
    private Vertex RR0=(IList tokens, bool skipExtraParenthesis);
    private bool Rh0=(IList tokens, string stringValue);
    private bool Rx0=(IList tokens);
    private double SB0=(IList tokens);
    private string SR0=(IList tokens);
    private string Sh0=(IList tokens);
    private string Sx0=(IList tokens);
    private string TB0=(IList tokens);
    private BaseShape TR0=(IList tokens);
    private PointShape Th0=(IList tokens);
    private LineShape Tx0=(IList tokens);
    private RingShape UB0=(IList tokens);
    private MultipointShape UR0=(IList tokens);
    private IEnumerable`1<PointShape> Uh0=(Vertex[] coordinates);
    private PolygonShape Ux0=(IList tokens);
    private MultilineShape VB0=(IList tokens);
    private MultipolygonShape VR0=(IList tokens);
    private GeometryCollectionShape Vh0=(IList tokens);
}
internal class HRU=.qi4= : object {
    private List`1<string> qy4=;
    private int rC4=;
    private int rS4=;
    private double /yw=;
    private Encoding FR8=;
    private int ri4=;
    private TinyGeoFileType My4=;
    public List`1<string> sC4= { get; }
    public int si4= { get; }
    public int tC4= { get; }
    public double HC4= { get; }
    public int ti4= { get; }
    public Encoding Hi4= { get; }
    public TinyGeoFileType Yy4= { get; }
    public List`1<string> ry4=();
    public int sS4=();
    public int sy4=();
    public double Gy4=();
    public int tS4=();
    public Encoding HS4=();
    public TinyGeoFileType Yi4=();
    public void pBw=(Stream stream, bool isEncrypted, string password);
}
internal enum HRU=.qiY= : Enum {
    public int value__;
    public static qiY= qyY=;
    public static qiY= KyU=;
    public static qiY= LCU=;
    public static qiY= LSU=;
    public static qiY= LiU=;
    public static qiY= LyU=;
    public static qiY= MCU=;
    public static qiY= MSU=;
    public static qiY= MiU=;
}
internal class HRU=.qSc= : object {
    private double qic=;
    private double qyc=;
    private double rCc=;
    private 8Sc= rSc=;
    private int PSc=;
    private int ric=;
    private void 8xY=();
    public int Ryc=();
    public int SCc=();
    public qSc= Ihc=();
    public qiY= wBY=(double dfCenterLat, double dfCenterLong, double dfScale, double dfFalseEasting, double dfFalseNorthing);
    public qiY= xBY=(double dfStdP1, double dfStdP2, double dfCenterLat, double dfCenterLong, double dfFalseEasting, double dfFalseNorthing);
    public qiY= xRY=(double dfCenterLat, double dfCenterLong, double dfFalseEasting, double dfFalseNorthing);
    public qiY= xxY=(double dfStdP1, double dfCentralMeridian, double dfFalseEasting, double dfFalseNorthing);
    public qiY= yBY=(double dfCenterLat, double dfCenterLong, double dfFalseEasting, double dfFalseNorthing);
    public qiY= yRY=(double dfStdP1, double dfStdP2, double dfCenterLat, double dfCenterLong, double dfFalseEasting, double dfFalseNorthing);
    public qiY= ryc=(double dfCentralMeridian, double dfFalseEasting, double dfFalseNorthing);
    public qiY= sCc=(double dfCentralMeridian, double dfFalseEasting, double dfFalseNorthing);
    public qiY= zRY=(double dfCentralMeridian, double dfFalseEasting, double dfFalseNorthing);
    public qiY= 0hY=(double dfCenterLat, double dfCenterLong, double dfAzimuth, double dfRectToSkew, double dfScale, double dfFalseEasting, double dfFalseNorthing);
    public qiY= 1RY=(double dfCenterLat, double dfCenterLong, double dfFalseEasting, double dfFalseNorthing);
    public qiY= 1hY=(double dfStdP1, double dfStdP2, double dfCenterLat, double dfCenterLong, double dfFalseEasting, double dfFalseNorthing);
    public qiY= 2BY=(double dfStdP1, double dfStdP2, double dfCenterLat, double dfCenterLong, double dfFalseEasting, double dfFalseNorthing);
    public qiY= 2RY=(double dfCenterLat, double dfCenterLong, double dfFalseEasting, double dfFalseNorthing);
    public qiY= 2hY=(double dfCenterLat, double dfCenterLong, double dfScale, double dfFalseEasting, double dfFalseNorthing);
    public qiY= 3BY=(double dfCentralMeridian, double dfFalseEasting, double dfFalseNorthing);
    public qiY= 3RY=(double dfCenterLat, double dfCenterLong, double dfFalseEasting, double dfFalseNorthing);
    public qiY= 4BY=(double dfCenterLat, double dfCenterLong, double dfFalseEasting, double dfFalseNorthing);
    public qiY= 4hY=(double dfCenterLong, double dfFalseEasting, double dfFalseNorthing);
    public qiY= 4xY=(double dfCenterLong, double dfFalseEasting, double dfFalseNorthing);
    public qiY= 5BY=(double dfOriginLat, double dfCMeridian, double dfScale, double dfFalseEasting, double dfFalseNorthing);
    public qiY= 5RY=(double dfLatitudeOfOrigin, double dfCentralMeridian, double dfFalseEasting, double dfFalseNorthing);
    public qiY= sSc=(string pszVariantName, double dfCenterLat, double dfCenterLong, double dfScale, double dfFalseEasting, double dfFalseNorthing);
    public qiY= bSc=(String& ppszResult);
    public static int 8RY=(string pszParameterName);
    public qiY= 8BY=(double dfDX, double dfDY, double dfDZ, double dfEX, double dfEY, double dfEZ, double dfPPM);
    public 8Sc= NyA=();
    public void sic=(8Sc= poNewRoot);
    public 8Sc= qhY=(string pszNodePath);
    public string qxY=(string pszNodeName, int iAttr);
    public qiY= rhY=(string pszNodePath, string pszNewNodeValue);
    public qiY= sRY=(string pszUnitsName, double dfInMeters);
    public double shY=(String& ppszName);
    public double sBY=(String& ppszName);
    public double sxY=(String& ppszName);
    public void axU=();
    public qiY= tBY=(string pszGeogName, string pszDatumName, string pszSpheroidName, double dfSemiMajor, double dfInvFlattening, string pszPMName, double dfPMOffset, string pszAngularUnits, double dfConvertToRadians);
    public qiY= uxY=(string pszParmName, double dfValue);
    public double vRY=(string pszName, double dfDefaultValue, qiY=& pnErr);
    public double vRY=(string pszName, double dfDefaultValue);
    public qiY= vxY=(string pszName, double dfValue);
    public static int 8hY=(string pszParameterName);
    public qiY= syc=(string pszName);
    public qiY= uhY=(string pszProjection);
}
internal static class HRU=.QSM= : object {
    public static double QiM=(NCM= rectangle);
    public static double QyM=(NCM= rectangle);
    public static double RCM=(NCM= rectangle);
    public static double RSM=(NCM= rectangle);
    public static double RiM=(NCM= rectangle);
    public static NCM= RyM=(NCM= rectangle);
    public static NCM= SCM=(NCM= rectangle);
    public static NCM= SSM=(NCM= rectangle);
    public static NCM= SiM=(NCM= rectangle);
}
internal enum HRU=.qSs= : Enum {
    public int value__;
    public static qSs= qis=;
    public static qSs= qys=;
    public static qSs= rCs=;
}
internal class HRU=.qx8= : tR8= {
    public qx8=(sR8= page);
    internal virtual int rB8=(ArrayList& al);
    internal virtual int rB8=(ArrayList& al, double resolution, int simplifyPixelBufferSize, Collection`1<RectangleShape> smallBoxes);
    internal virtual int wx4=(BCA= rt, ArrayList& al);
    internal virtual int rR8=(BCA= rt, ArrayList& al);
    internal virtual int rh8=(BCA= rt, ArrayList& al);
    internal virtual int rh8=(BCA= rt, ArrayList& al, double resolution, int simplifyPixelBufferSize, Collection`1<RectangleShape> smallBoxes);
    internal virtual bool gR8=(6B8= rec, tR8=[]& nodeList);
    internal virtual bool cx8=(6B8= insertRec, tR8=[]& nodeList);
    internal virtual bool rx8=(6B8= delRec, Int32& idx, qx8=& leafToDel);
    internal virtual void sB8=(6B8= delRec, Collection`1<LeafRecordWrapper> leaves, IdsEngine idsEngine);
}
internal class HRU=.Qxk= : jBo= {
    internal Qxk=(string id, string desc);
    private void 9xg=();
    internal virtual whg= /Bg=(whg= pjConsts, Int32& pj_Error);
    internal virtual void Axk=(mhg= lp, whg= pjConsts, TRg= fac, Int32& pj_Error);
    internal virtual mhg= ARk=(mRo= xy, whg= pjConsts, Int32& pj_Error);
    internal virtual mRo= Ahk=(mhg= lp, whg= pjConsts, Int32& pj_Error);
}
internal class HRU=.RBk= : jBo= {
    internal RBk=(string id, string desc);
    private void 9xg=();
    internal virtual whg= /Bg=(whg= pjConsts, Int32& pj_Error);
    internal virtual void Axk=(mhg= lp, whg= pjConsts, TRg= fac, Int32& pj_Error);
    internal virtual mhg= ARk=(mRo= xy, whg= pjConsts, Int32& pj_Error);
    internal virtual mRo= Ahk=(mhg= lp, whg= pjConsts, Int32& pj_Error);
}
internal class HRU=.RCo= : 8So= {
    private static int 9CQ=;
    private static int 9SQ=;
    private static int 9iQ=;
    private static int 9yQ=;
    private uig= RSo=;
    public uig= Ryo= { get; }
    public int xSU= { get; public set; }
    public Iis= yCU= { get; public set; }
    public RCo=(PCc= poDefnIn);
    public uig= Rio=();
    public virtual pCg= Iig=();
    public virtual int Iyg=(Wyk= poMapFile);
    public virtual iSg= JCg=(PCc= poNewDefn);
    public double SCo=();
    public double SSo=();
    public virtual int JSg=(Wyk= poMapFile, CSo= poObjHdr, bool bCoordBlockDataOnly, Nik=& ppoCoordBlock);
    public virtual int Jig=(Wyk= poMapFile, CSo= poObjHdr, bool bCoordBlockDataOnly, Nik=& ppoCoordBlock);
    public virtual int Jyg=(6yU= fp);
    public virtual int KCg=(6yU= fp);
    public virtual string Oic=();
    public virtual void KSg=(Stream fsOut);
    public virtual int wyU=();
    public virtual void xCU=(int value);
    public virtual Iis= xiU=();
    public virtual void xyU=(Iis= value);
    public virtual int ySU=();
    public virtual Iis= yiU=();
    public virtual short yyU=();
    public virtual short zCU=();
    public virtual int zSU=();
    public virtual void ziU=(short val);
    public virtual void zyU=(short val);
    public virtual void 0CU=(int clr);
    public virtual string 0SU=(double dfAngle);
    public virtual void 0iU=(string pszStyleString);
    public virtual void 0yU=(Stream fpOut);
}
internal interface HRU=.rCU= {
    public Pyo= ryU= { get; public set; }
    public int siU= { get; public set; }
    public abstract virtual int syU=();
    public abstract virtual Pyo= tCU=();
    public abstract virtual byte tSU=();
    public abstract virtual double tiU=();
    public abstract virtual int tyU=();
    public abstract virtual byte uCU=();
    public abstract virtual int uSU=();
    public abstract virtual string uiU=();
    public abstract virtual Pyo= rSU=();
    public abstract virtual void riU=(Pyo= value);
    public abstract virtual void sSU=(int value);
    public abstract virtual int sCU=();
    public abstract virtual void uyU=(byte val);
    public abstract virtual void vCU=(double val);
    public abstract virtual void vSU=(int val);
    public abstract virtual void viU=(byte val);
    public abstract virtual void vyU=(int clr);
    public abstract virtual void wCU=(string pszStyleString);
    public abstract virtual void wSU=(Stream fpOut);
}
internal class HRU=.rCw= : object {
    [CompilerGeneratedAttribute]
private bool rSw=;
    [CompilerGeneratedAttribute]
private Vertex oCw=;
    public bool sCw= { get; public set; }
    public Vertex pSw= { get; public set; }
    public rCw=(double x, double y);
    public rCw=(Vertex vertex);
    [CompilerGeneratedAttribute]
public void ryw=(bool value);
    [CompilerGeneratedAttribute]
public bool riw=();
    [CompilerGeneratedAttribute]
public Vertex oyw=();
    [CompilerGeneratedAttribute]
public void pCw=(Vertex value);
}
internal enum HRU=.rCY= : Enum {
    public int value__;
    public static rCY= rSY=;
    public static rCY= riY=;
}
internal class HRU=.RRg= : object {
    internal jBo= Rhg=(string projID, string desc, Dictionary`2<string, string> pj_List);
}
internal class HRU=.RRk= : jBo= {
    internal Double[] 9Rg=;
    internal double Rhk=;
    internal double gxc=;
    internal double thc=;
    internal double txc=;
    internal RRk=(string id, string desc);
    private void 9xg=();
    internal virtual whg= /Bg=(whg= pjConsts, Int32& pj_Error);
    internal virtual void Axk=(mhg= lp, whg= pjConsts, TRg= fac, Int32& pj_Error);
    internal virtual mhg= ARk=(mRo= xy, whg= pjConsts, Int32& pj_Error);
    internal virtual mRo= Ahk=(mhg= lp, whg= pjConsts, Int32& pj_Error);
}
internal static class HRU=.RRU= : object {
    public static SKBitmap RhU=(Stream stream);
    public static SKBitmap RhU=(Byte[] bytes);
    public static SKBitmap RhU=(string pathFilename);
    public static SKBitmap RhU=(int width, int height);
    public static SKBitmap RhU=(int width, int height, GeoColorType colorType, GeoAlphaType alphaType);
    public static int RxU=(object image);
    public static int SBU=(object image);
    public static void SRU=(object image, float opacityFactor);
    public static Stream ShU=(object image, GeoImageFormat imageFormat, int quality);
    public static Byte[] SxU=(object image, GeoImageFormat imageFormat, int quality);
    public static void TBU=(object image, string fileName, GeoImageFormat imageFormat, int quality);
    public static void TBU=(object image, Stream stream, GeoImageFormat imageFormat, int quality);
    public static SKBitmap TRU=(object image, int width, int height);
    public static SKBitmap ThU=(object image, DrawingRectangle srcRect, bool extendCanvasIfCutRectLargerThanImage);
    public static void TxU=(object destImage, GeoImage srcImage, float pointX, float pointY);
    public static GeoImage QRU=(GeoImage image, bool isGrayscale, bool isNegative, float transparency, float redTranslation, float greenTranslation, float blueTranslation);
    public static GeoImage QhU=(GeoImage image, Dictionary`2<GeoColor, GeoColor> colorMappings);
    public static void UBU=(object image, GeoColor[] pixels);
    public static IntPtr URU=(object image);
    private static SKData UhU=(SKBitmap bitmap, GeoImageFormat imageFormat, int quality);
    private static SKEncodedImageFormat UxU=(GeoImageFormat imageFormat);
    private static Single[][] VBU=(bool isGrayscale, bool isNegative, float transparency, float redTranslation, float greenTranslation, float blueTranslation);
    private static Single[][] VRU=(float transparency);
    private static Single[][] VhU=(float transparency);
    private static Single[][] VxU=(float redTranslation, float greenTranslation, float blueTranslation, float transparency);
}
internal enum HRU=.rSs= : Enum {
    public int value__;
    public static rSs= CBs=;
    public static rSs= ris=;
    public static rSs= rys=;
    public static rSs= sCs=;
    public static rSs= sSs=;
}
internal enum HRU=.Rxg= : Enum {
    public int value__;
    public static Rxg= SBg=;
    public static Rxg= SRg=;
    public static Rxg= Shg=;
    public static Rxg= Sxg=;
    public static Rxg= TBg=;
}
internal class HRU=.rxk= : jBo= {
    internal rxk=(string id, string desc);
    private void 9xg=();
    internal virtual whg= /Bg=(whg= pjConsts, Int32& pj_Error);
    internal virtual void Axk=(mhg= lp, whg= pjConsts, TRg= fac, Int32& pj_Error);
    internal virtual mhg= ARk=(mRo= xy, whg= pjConsts, Int32& pj_Error);
    internal virtual mRo= Ahk=(mhg= lp, whg= pjConsts, Int32& pj_Error);
}
internal class HRU=.Rxk= : jBo= {
    internal double SBk=;
    internal Rxk=(string id, string desc);
    private void 9xg=();
    internal virtual void Axk=(mhg= lp, whg= pjConsts, TRg= fac, Int32& pj_Error);
    internal virtual whg= /Bg=(whg= pjConsts, Int32& pj_Error);
    internal virtual mhg= ARk=(mRo= xy, whg= pjConsts, Int32& pj_Error);
    internal virtual mRo= Ahk=(mhg= lp, whg= pjConsts, Int32& pj_Error);
}
internal class HRU=.Rxo= : jBo= {
    internal double Mhk=;
    internal Rxo=(string id, string desc);
    private void 9xg=();
    internal virtual whg= /Bg=(whg= pjConsts, Int32& pj_Error);
    internal virtual void Axk=(mhg= lp, whg= pjConsts, TRg= fac, Int32& pj_Error);
    internal virtual mhg= ARk=(mRo= xy, whg= pjConsts, Int32& pj_Error);
    internal virtual mRo= Ahk=(mhg= lp, whg= pjConsts, Int32& pj_Error);
}
internal class HRU=.rxw= : object {
    protected static int sBw=;
    protected WkbByteOrder sRw=;
    public rxw=(WkbByteOrder encodingType);
    public virtual Byte[] shw=(BaseShape geometry);
    public virtual void shw=(BaseShape geometry, Stream stream);
    protected void shw=(BaseShape geometry, BinaryWriter writer);
    protected void sxw=(BinaryWriter writer);
    protected void shw=(Vertex coordinate, BinaryWriter writer);
    protected void shw=(PointShape point, BinaryWriter writer);
    protected void shw=(LineShape lineString, BinaryWriter writer);
    protected void shw=(RingShape ring, BinaryWriter writer);
    protected void shw=(PolygonShape polygon, BinaryWriter writer);
    protected void shw=(MultipointShape multiPoint, BinaryWriter writer);
    protected void shw=(MultilineShape multiLineString, BinaryWriter writer);
    protected void shw=(MultipolygonShape multiPolygon, BinaryWriter writer);
    protected void shw=(GeometryCollectionShape geomCollection, BinaryWriter writer);
    protected Byte[] 7xM=(BaseShape geometry);
    protected virtual int tBw=(BaseShape geometry);
    protected int tBw=(GeometryCollectionShape geometry);
    protected int tBw=(MultipolygonShape geometry);
    protected int tBw=(MultilineShape geometry);
    protected int tBw=(MultipointShape geometry);
    protected int tBw=(PolygonShape geometry);
    protected int tBw=(LineShape geometry);
    protected int tBw=(PointShape geometry);
    private static int tRw=(PolygonShape polygon);
    [CompilerGeneratedAttribute]
private int thw=(BaseShape geom);
    [CompilerGeneratedAttribute]
private int txw=(PolygonShape geom);
    [CompilerGeneratedAttribute]
private int uBw=(LineShape geom);
    [CompilerGeneratedAttribute]
private int uRw=(PointShape geom);
}
internal enum HRU=.ryY= : Enum {
    public UInt32 value__;
    public static ryY= sCY=;
    public static ryY= sSY=;
    public static ryY= siY=;
    public static ryY= syY=;
    public static ryY= tCY=;
    public static ryY= tSY=;
    public static ryY= tiY=;
    public static ryY= tyY=;
    public static ryY= uCY=;
    public static ryY= uSY=;
    public static ryY= uiY=;
    public static ryY= uyY=;
    public static ryY= vCY=;
    public static ryY= vSY=;
    public static ryY= viY=;
    public static ryY= vyY=;
    public static ryY= wCY=;
}
internal class HRU=.sBk= : jBo= {
    internal sBk=(string id, string desc);
    private void 9xg=();
    internal virtual whg= /Bg=(whg= pjConsts, Int32& pj_Error);
    internal virtual void Axk=(mhg= lp, whg= pjConsts, TRg= fac, Int32& pj_Error);
    internal virtual mhg= ARk=(mRo= xy, whg= pjConsts, Int32& pj_Error);
    internal virtual mRo= Ahk=(mhg= lp, whg= pjConsts, Int32& pj_Error);
}
internal class HRU=.SBo= : jBo= {
    internal double SRo=;
    internal SBo=(string id, string desc);
    private void 9xg=();
    internal virtual whg= /Bg=(whg= pjConsts, Int32& pj_Error);
    internal virtual void Axk=(mhg= lp, whg= pjConsts, TRg= fac, Int32& pj_Error);
    internal virtual mhg= ARk=(mRo= xy, whg= pjConsts, Int32& pj_Error);
    internal virtual mRo= Ahk=(mhg= lp, whg= pjConsts, Int32& pj_Error);
}
internal class HRU=.SC8= : object {
    [CompilerGeneratedAttribute]
private string SS8=;
    [CompilerGeneratedAttribute]
private PointShape Si8=;
    [CompilerGeneratedAttribute]
private Oy8= Sy8=;
    public string Ti8= { get; public set; }
    public PointShape US8= { get; public set; }
    public Oy8= VC8= { get; public set; }
    [CompilerGeneratedAttribute]
public string TC8=();
    [CompilerGeneratedAttribute]
public void TS8=(string value);
    [CompilerGeneratedAttribute]
public PointShape Ty8=();
    [CompilerGeneratedAttribute]
public void UC8=(PointShape value);
    [CompilerGeneratedAttribute]
public Oy8= Ui8=();
    [CompilerGeneratedAttribute]
public void Uy8=(Oy8= value);
}
internal class HRU=.SCA= : ValueType {
    public ushort SSA=;
    public ushort SiA=;
    public bool pBw=(BinaryReader r);
    public bool shw=(BinaryWriter w);
    public virtual string ToString();
}
internal class HRU=.shk= : jBo= {
    internal shk=(string id, string desc);
    private void 9xg=();
    internal virtual whg= /Bg=(whg= pjConsts, Int32& pj_Error);
    internal virtual void Axk=(mhg= lp, whg= pjConsts, TRg= fac, Int32& pj_Error);
    internal virtual mhg= ARk=(mRo= xy, whg= pjConsts, Int32& pj_Error);
    internal virtual mRo= Ahk=(mhg= lp, whg= pjConsts, Int32& pj_Error);
}
internal class HRU=.Shk= : jBo= {
    internal double gxc=;
    internal double Sxk=;
    internal double TBk=;
    internal double TRk=;
    internal double Thk=;
    internal double Txk=;
    internal Shk=(string id, string desc);
    private void 9xg=();
    internal virtual whg= /Bg=(whg= pjConsts, Int32& pj_Error);
    internal virtual void Axk=(mhg= lp, whg= pjConsts, TRg= fac, Int32& pj_Error);
    internal virtual mhg= ARk=(mRo= xy, whg= pjConsts, Int32& pj_Error);
    internal virtual mRo= Ahk=(mhg= lp, whg= pjConsts, Int32& pj_Error);
    private int UBk=(whg= pjConsts, Double[] del, Int32& pj_Error);
}
internal class HRU=.Sho= : jBo= {
    internal double gxc=;
    internal double Sxk=;
    internal double TBk=;
    internal double TRk=;
    internal double Thk=;
    internal double Txk=;
    internal Sho=(string id, string desc);
    private void 9xg=();
    internal virtual whg= /Bg=(whg= pjConsts, Int32& pj_Error);
    internal virtual void Axk=(mhg= lp, whg= pjConsts, TRg= fac, Int32& pj_Error);
    internal virtual mhg= ARk=(mRo= xy, whg= pjConsts, Int32& pj_Error);
    internal virtual mRo= Ahk=(mhg= lp, whg= pjConsts, Int32& pj_Error);
    private int UBk=(whg= pjConsts, Double[] del, Int32& pj_Error);
}
internal class HRU=.Si4= : object {
    [CompilerGeneratedAttribute]
private int Sy4=;
    [CompilerGeneratedAttribute]
private int TC4=;
    public int Ty4= { get; public set; }
    public int Ui4= { get; public set; }
    public Si4=(int x, int y);
    [CompilerGeneratedAttribute]
public int TS4=();
    [CompilerGeneratedAttribute]
public void Ti4=(int value);
    [CompilerGeneratedAttribute]
public int UC4=();
    [CompilerGeneratedAttribute]
public void US4=(int value);
    public virtual string ToString();
}
internal class HRU=.Sic= : object {
    public bool Syc=;
    public int 0RU=;
    public double TCc=;
    public string TSc=;
    public List`1<int> Tic=;
    public List`1<double> Tyc=;
    public List`1<string> UCc=;
    public List`1<byte> USc=;
    public Uyc= Uic=;
    public object Ihc=();
}
[DefaultMemberAttribute("Item")]
internal class HRU=.siE= : object {
    private IDictionary`2<TKey, TValue> syE=;
    public int Count { get; }
    public bool IsReadOnly { get; }
    public ICollection`1<TKey> Keys { get; }
    public ICollection`1<TValue> Values { get; }
    public TValue Item { get; public set; }
    public siE=(IDictionary`2<TKey, TValue> underlyingDictionary);
    public sealed virtual int get_Count();
    public sealed virtual bool get_IsReadOnly();
    public sealed virtual ICollection`1<TKey> get_Keys();
    public sealed virtual ICollection`1<TValue> get_Values();
    public sealed virtual TValue get_Item(TKey key);
    public sealed virtual void set_Item(TKey key, TValue value);
    public sealed virtual void Add(TKey key, TValue value);
    public sealed virtual void Add(KeyValuePair`2<TKey, TValue> item);
    public sealed virtual void Clear();
    public sealed virtual bool ContainsKey(TKey key);
    public sealed virtual bool Remove(TKey key);
    public sealed virtual bool TryGetValue(TKey key, TValue& value);
    public sealed virtual bool Contains(KeyValuePair`2<TKey, TValue> item);
    public sealed virtual void CopyTo(KeyValuePair`2[] array, int arrayIndex);
    public sealed virtual bool Remove(KeyValuePair`2<TKey, TValue> item);
    public sealed virtual IEnumerator`1<KeyValuePair`2<TKey, TValue>> GetEnumerator();
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
}
internal class HRU=.sig= : object {
    protected int syg=;
    protected 4Cg= tCg=;
    private static 4Cg= tSg=;
    public int oyU= { get; public set; }
    public 4Cg= piU= { get; public set; }
    private static sig=();
    public virtual int pyU=();
    public virtual 4Cg= qCU=();
    public virtual string qSU=();
    public virtual void qiU=(string pszName);
    public virtual void qyU=(Stream fpOut);
    public virtual int oSU=();
    public virtual void oiU=(int value);
    public virtual 4Cg= pCU=();
    public virtual void pSU=(4Cg= value);
}
internal class HRU=.Sig= : RCo= {
    protected byte Syg=;
    public byte TCg=;
    private static int 9CQ=;
    private static int 9SQ=;
    private static int 9iQ=;
    private static int 9yQ=;
    private sig= TSg=;
    public int oyU= { get; public set; }
    public 4Cg= piU= { get; public set; }
    public Sig=(PCc= poDefnIn);
    public virtual pCg= Iig=();
    public virtual iSg= JCg=(PCc= poNewDefn);
    public virtual int JSg=(Wyk= poMapFile, CSo= poObjHdr, bool bCoordBlockDataOnly, Nik=& ppoCoordBlock);
    public virtual int Jig=(Wyk= poMapFile, CSo= poObjHdr, bool bCoordBlockDataOnly, Nik=& ppoCoordBlock);
    public virtual int Jyg=(6yU= fp);
    public virtual int KCg=(6yU= fp);
    public virtual string Oic=();
    public byte Tig=();
    public void Tyg=(byte nStyle);
    public virtual int oSU=();
    public virtual void oiU=(int value);
    public virtual 4Cg= pCU=();
    public virtual void pSU=(4Cg= value);
    public virtual int pyU=();
    public virtual 4Cg= qCU=();
    public virtual string qSU=();
    public virtual void qiU=(string pszName);
    public virtual void qyU=(Stream fpOut);
}
internal class HRU=.Sio= : PointBaseStyle {
    private static int Syo=;
    private static int TCo=;
    private static int TSo=;
    private static int Tio=;
    private static int Tyo=;
    private static int JxU=;
    private static int KRU=;
    private static int KhU=;
    private static int KxU=;
    private static int KBU=;
    private static double UCo=;
    private static int LhU=;
    private static int LBU=;
    private static int USo=;
    private static int Uio=;
    private static int Uyo=;
    [ObfuscationAttribute]
private int symbolNumber;
    [ObfuscationAttribute]
private GeoBrush characterBrush;
    [ObfuscationAttribute]
private GeoFont characterFont;
    [ObfuscationAttribute]
private int characterIndex;
    [ObfuscationAttribute]
private GeoImage image;
    [ObfuscationAttribute]
private double imageScale;
    [ObfuscationAttribute]
private PointType pointType;
    [ObfuscationAttribute]
private Dictionary`2<float, GeoFont> wingdingsFontCache;
    public int Vio= { get; public set; }
    public Sio=(GeoImage image, GeoFont characterFont, int characterIndex, GeoSolidBrush characterSolidBrush, PointType pointType, int symbolNumber, GeoSolidBrush symbolSolidBrush, GeoPen symbolPen, int symbolSize);
    public int VCo=();
    public void VSo=(int value);
    protected virtual void DrawCore(IEnumerable`1<Feature> features, GeoCanvas canvas, Collection`1<SimpleCandidate> labelsInThisLayer, Collection`1<SimpleCandidate> labelsInAllLayers);
    private void Vyo=(Feature feature, GeoCanvas canvas, GeoPen geoPen, GeoBrush geoBrush);
    private void WCo=(Feature feature, GeoCanvas canvas, GeoPen geoPen, GeoBrush geoBrush);
    private void WSo=(Feature feature, GeoCanvas canvas, GeoPen geoPen, GeoBrush geoBrush);
    private void Wio=(Feature feature, GeoCanvas canvas, GeoPen geoPen, GeoBrush geoBrush);
    private void Wyo=(Feature feature, GeoCanvas canvas, GeoPen geoPen, GeoBrush geoBrush);
    private void XCo=(Feature feature, GeoCanvas canvas, GeoPen geoPen, GeoBrush geoBrush, int pixelOffset);
    private GeoFont XSo=();
    private void Xio=(Feature feature, GeoCanvas canvas, GeoPen geoPen, GeoBrush geoBrush);
    private void Xyo=(Feature feature, GeoCanvas canvas, GeoPen geoPen, GeoBrush geoBrush, int pixelOffset);
    private void YCo=(PointShape point, GeoCanvas canvas);
    private int YSo=(Byte[] centerPointWkb, int startIndex, GeoCanvas canvas, GeoPen geoPen, GeoBrush geoBrush, int pixelOffset);
    private int Yio=(Byte[] centerPointWkb, int startIndex, GeoCanvas canvas, GeoPen geoPen, GeoBrush geoBrush);
    private static int PRU=(Byte[] wkb, int startIndex, byte byteOrder);
    private void Yyo=(int indexOfCharacter, Feature feature, GeoCanvas canvas, GeoBrush geoBrush, GeoPen haloPen);
    private void ZCo=(int indexOfCharacter, PointShape point, GeoCanvas canvas, GeoBrush geoBrush, GeoPen haloPen);
    private void ZSo=(Feature feature, GeoCanvas canvas, GeoPen geoPen);
    private int Zio=(Byte[] centerPointWkb, int startIndex, GeoCanvas canvas, GeoPen geoPen);
    private void Zyo=(Feature feature, GeoCanvas canvas, GeoPen geoPen, GeoBrush geoBrush);
    private void aCo=(Feature feature, GeoCanvas canvas, GeoPen geoPen, GeoBrush geoBrush, int pixelOffset);
    private void aSo=(Feature feature, GeoCanvas canvas, GeoPen geoPen, GeoBrush geoBrush);
    private int aio=(Byte[] centerPointWkb, int startIndex, GeoCanvas canvas, GeoPen geoPen, GeoBrush geoBrush);
    private int ayo=(Byte[] centerPointWkb, int startIndex, GeoCanvas canvas, GeoPen geoPen, GeoBrush geoBrush, int pixelOffset);
    private static double PhU=(Byte[] wkb, int startIndex, byte byteOrder);
    private bool bCo=(double screenX, double screenY, float canvasWidth, float canvasHeight);
    private static void hB0=(Byte[] sourceArray, Byte[] destinateArray, long destinateIndex);
    private void bSo=(Feature feature, GeoCanvas canvas);
    private void bio=(Feature feature, GeoCanvas canvas, GeoPen geoPen, GeoBrush geoBrush, float widthScale, float heightScale);
    private void byo=(Feature feature, GeoCanvas canvas, GeoPen geoPen, GeoBrush geoBrush);
    private void cCo=(Feature feature, GeoCanvas canvas, GeoPen geoPen, GeoBrush geoBrush);
    private void cSo=(Feature feature, GeoCanvas canvas, GeoPen geoPen, GeoBrush geoBrush, ScreenPointF[] points);
    private void cio=(Feature feature, GeoCanvas canvas, GeoPen geoPen, ScreenPointF[] points);
    private void cyo=(Feature feature, GeoCanvas canvas, GeoPen geoPen, GeoBrush geoBrush);
    private void dCo=(Feature feature, GeoCanvas canvas, GeoPen geoPen, GeoBrush geoBrush);
    private void dSo=(Feature feature, GeoCanvas canvas, GeoPen geoPen, GeoBrush geoBrush);
    private void dio=(Feature feature, GeoCanvas canvas, GeoPen geoPen, GeoBrush geoBrush);
    private void dyo=(String[] pointsCollection, Feature feature, GeoCanvas canvas, GeoPen geoPen, GeoBrush geoBrush);
    private void eCo=(Feature feature, GeoCanvas canvas, GeoPen geoPen, GeoBrush geoBrush);
    private void eSo=(Feature feature, GeoCanvas canvas, GeoPen geoPen, GeoBrush geoBrush);
    private void eio=(Feature feature, GeoCanvas canvas, GeoPen geoPen, GeoBrush geoBrush);
    private void eyo=(Feature feature, GeoCanvas canvas, GeoPen geoPen, GeoBrush geoBrush);
    private void fCo=(Feature feature, GeoCanvas canvas, GeoPen geoPen, GeoBrush geoBrush);
    private void fSo=(Feature feature, GeoCanvas canvas, GeoPen geoPen, GeoBrush geoBrush);
    private void fio=(Feature feature, GeoCanvas canvas, GeoPen geoPen, GeoBrush geoBrush);
    private void fyo=(Feature feature, GeoCanvas canvas, GeoPen geoPen, GeoBrush geoBrush);
    private void gCo=(Feature feature, GeoCanvas canvas, GeoPen geoPen, GeoBrush geoBrush);
    private void gSo=(Feature feature, GeoCanvas canvas, GeoPen geoPen, GeoBrush geoBrush);
    private void gio=(Feature feature, GeoCanvas canvas, GeoPen geoPen, GeoBrush geoBrush);
    private void gyo=(Feature feature, GeoCanvas canvas, GeoPen geoPen, GeoBrush geoBrush);
}
internal enum HRU=.sis= : Enum {
    public int value__;
    public static sis= sys=;
    public static sis= tCs=;
    public static sis= tSs=;
    public static sis= tis=;
    public static sis= tys=;
    public static sis= uCs=;
}
internal class HRU=.sR8= : eB8= {
    private static int sh8=;
    public sR8=(RtreeFile rtFile, UInt32 pageNo, Gist_Ext_Id extId);
    public sR8=(RtreeFile rtFile, Gist_Ext_Id extId);
    internal virtual 6B8= dR8=();
    public virtual 6B8= kB8=(int idx);
    public virtual 6B8= jR8=();
    public virtual 6B8= jh8=();
    internal virtual bool gR8=(6B8= rec);
    private bool sx8=();
    internal bool tB8=(6B8= rec);
    internal virtual void gh8=(int idx);
    internal virtual int dh8=();
    public virtual BCA= kh8=();
    public virtual string kR8=();
}
internal class HRU=.sRk= : jBo= {
    internal Double[] 9Rg=;
    internal double Rhk=;
    internal double gxc=;
    internal double thc=;
    internal double txc=;
    internal sRk=(string id, string desc);
    private void 9xg=();
    internal virtual whg= /Bg=(whg= pjConsts, Int32& pj_Error);
    internal virtual void Axk=(mhg= lp, whg= pjConsts, TRg= fac, Int32& pj_Error);
    internal virtual mhg= ARk=(mRo= xy, whg= pjConsts, Int32& pj_Error);
    internal virtual mRo= Ahk=(mhg= lp, whg= pjConsts, Int32& pj_Error);
}
internal class HRU=.SRk= : jBo= {
    internal double 8xg=;
    internal double 9Bg=;
    internal double gxc=;
    internal double 8hg=;
    internal double 8Rg=;
    internal double 7hg=;
    internal Double[] 9Rg=;
    internal int 9hg=;
    internal SRk=(string id, string desc);
    private void 9xg=();
    internal virtual whg= /Bg=(whg= pjConsts, Int32& pj_Error);
    internal virtual void Axk=(mhg= lp, whg= pjConsts, TRg= fac, Int32& pj_Error);
    internal virtual mhg= ARk=(mRo= xy, whg= pjConsts, Int32& pj_Error);
    internal virtual mRo= Ahk=(mhg= lp, whg= pjConsts, Int32& pj_Error);
}
internal class HRU=.sRs= : pRs= {
    internal static UInt32 shs=;
    internal static UInt32 sxs=;
    internal static UInt32 tBs=;
    internal static UInt32 tRs=;
    internal static UInt32 ths=;
    internal static UInt32 txs=;
    internal static UInt32 uBs=;
    internal static UInt32 uRs=;
    internal static UInt32 uhs=;
    internal static UInt32 uxs=;
    internal static UInt32 vBs=;
    internal static double XhY=;
    internal static double vRs=;
    internal static double vhs=;
    internal static double vxs=;
    internal static double wBs=;
    internal static double wRs=;
    private double whs=;
    private double wxs=;
    private double xBs=;
    private double xRs=;
    private double xhs=;
    private double xxs=;
    private double yBs=;
    private double yRs=;
    private double yhs=;
    private double yxs=;
    private double zBs=;
    private double zRs=;
    private double zhs=;
    private double zxs=;
    private double 0Bs=;
    private double 0Rs=;
    public sRs=(double originLatitude, double centralMeridian, double falseEasting, double falseNorthing, double Scale);
    private double 0hs=(double Latitude);
    private double 0xs=(double Latitude);
    private double 1Bs=(double Latitude);
    private double 1Rs=(double Latitude);
    public virtual long pxs=();
    public bool 1hs=(double Origin_Latitude, double Central_Meridian, double False_Easting, double False_Northing, double Scale);
    internal long 1xs=(double a, double f, double Origin_Latitude, double Central_Meridian, double False_Easting, double False_Northing, double Scale_Factor);
    public void 2Bs=(Double& Origin_Latitude, Double& Central_Meridian, Double& False_Easting, Double& False_Northing, Double& Scale_Factor);
    internal void 2Rs=(Double& a, Double& f, Double& Origin_Latitude, Double& Central_Meridian, Double& False_Easting, Double& False_Northing, Double& Scale_Factor);
    public bool 2hs=(double Latitude, double Longitude, Double& Easting, Double& Northing);
    internal long 2xs=(double Latitude, double Longitude, Double& Easting, Double& Northing);
    public bool 3Bs=(qBs= trmct, Double& Latitude, Double& Longitude);
    public bool 3Bs=(double Easting, double Northing, Double& Latitude, Double& Longitude);
    internal long 3Rs=(double Easting, double Northing, Double& Latitude, Double& Longitude);
}
internal class HRU=.sSw= : object {
    private int siw=;
    private byte syw=;
    [CompilerGeneratedAttribute]
private List`1<byte> tCw=;
    public List`1<byte> tyw= { get; private set; }
    [CompilerGeneratedAttribute]
private void tiw=(List`1<byte> value);
    [CompilerGeneratedAttribute]
public List`1<byte> tSw=();
    public void uCw=(int input);
    public void uSw=();
}
internal class HRU=.sxg= : object {
    private string tBg=;
    private VRc= tRg=;
    private Stream thg=;
    internal VRc= uRg= { get; internal set; }
    internal sxg=(string name);
    internal sxg=(Stream fs);
    private void uhg=(string name);
    internal VRc= txg=();
    internal void uBg=(VRc= value);
    internal VRc= uxg=();
    private int vBg=(object obj);
    internal bool vRg=(VRc= ct);
    public sealed virtual void Dispose();
}
internal class HRU=.sxk= : jBo= {
    internal double thc=;
    internal double txc=;
    internal double uRc=;
    internal int Uxk=;
    internal sxk=(string id, string desc);
    private void 9xg=();
    internal virtual whg= /Bg=(whg= pjConsts, Int32& pj_Error);
    internal virtual void Axk=(mhg= lp, whg= pjConsts, TRg= fac, Int32& pj_Error);
    internal virtual mhg= ARk=(mRo= xy, whg= pjConsts, Int32& pj_Error);
    internal virtual mRo= Ahk=(mhg= lp, whg= pjConsts, Int32& pj_Error);
}
internal class HRU=.Sxo= : jBo= {
    private double TBo=;
    private double 9xk=;
    private Double[] 9Rg=;
    internal Sxo=(string id, string desc);
    private void 9xg=();
    internal virtual whg= /Bg=(whg= pjConsts, Int32& pj_Error);
    internal virtual void Axk=(mhg= lp, whg= pjConsts, TRg= fac, Int32& pj_Error);
    internal virtual mhg= ARk=(mRo= xy, whg= pjConsts, Int32& pj_Error);
    internal virtual mRo= Ahk=(mhg= lp, whg= pjConsts, Int32& pj_Error);
    private mRo= Exk=(mhg= lp, whg= pjConsts, Int32& pj_Error);
    private mRo= ERk=(mhg= lp, whg= pjConsts, Int32& pj_Error);
    private mhg= EBk=(mRo= xy, whg= pjConsts, Int32& pj_Error);
    private mhg= Dhk=(mRo= xy, whg= pjConsts, Int32& pj_Error);
}
internal class HRU=.syI= : object {
    private int tCI=;
    public LiM= tSI=(NCM= destRect, LiM= enterDirection, double enterValue);
    private static int tiI=(NCM= diffValueRect);
    private LiM= tyI=(NCM= destRect, double enterValue);
    private LiM= uCI=(NCM= destRect, double enterValue);
    private LiM= uSI=(NCM= destRect, double enterValue);
    private LiM= uiI=(NCM= destRect, double enterValue);
    private LiM= uyI=(NCM= destRect, LiM= enterDirection, double enterValue);
    private LiM= vCI=(NCM= destRect, LiM= enterDirection, double enterValue);
    private LiM= vSI=(NCM= destRect, LiM= enterDirection, double enterValue);
    private LiM= viI=(NCM= destRect, LiM= enterDirection, double enterValue);
    private LiM= vyI=(NCM= destRect, LiM= enterDirection, double enterValue);
    private static bool wCI=(LiM= enterDir, LiM= exitDir);
    private static LiM= wSI=(LiM= enterDirection);
}
internal class HRU=.SyM= : FilterCondition {
    private bool TCM=;
    internal SyM=(string columnName, bool operation);
    internal virtual bool TSM=(KeyValuePair`2<string, string> v);
    internal virtual bool TSM=(Feature feature);
}
internal static class HRU=.syQ= : object {
    public static BiU= tCQ=;
    public static bool tSQ=;
    public static Stream tiQ=;
    public static StackTrace tyQ=;
    public static StackFrame uCQ=;
    private static syQ=();
    public static void uSQ=(niQ= eErrClass, int nError, string pszErrorMsg);
    public static void uiQ=(niQ= eErrClass, int nError, string pszErrorMsg);
    public static BiU= uyQ=(BiU= pfnErrorHandlerNew);
    public static void vCQ=(BiU= pfnErrorHandlerNew);
    public static void vSQ=();
    public static xiQ= viQ=();
    public static void vyQ=(niQ= eErrClass, int err_no, string fmt, Object[] valist);
    private static void wCQ=(niQ= eErrClass, int err_no, string fmt, Object[] valist);
    public static void wSQ=(string pszCategory, string pszFormat, Object[] list);
    public static void wiQ=();
    public static int wyQ=();
    public static niQ= xCQ=();
    public static void xSQ=(string pszExpression, string pszFile, int iLine);
}
internal enum HRU=.Sys= : Enum {
    public int value__;
    public static Sys= TCs=;
    public static Sys= TSs=;
    public static Sys= Tis=;
}
internal class HRU=.tBk= : jBo= {
    internal tBk=(string id, string desc);
    private void 9xg=();
    internal virtual whg= /Bg=(whg= pjConsts, Int32& pj_Error);
    private double Qxc=(double sinphi, double cosphi, double es, Int32& pj_Error);
    internal virtual void Axk=(mhg= lp, whg= pjConsts, TRg= fac, Int32& pj_Error);
    internal virtual mhg= ARk=(mRo= xy, whg= pjConsts, Int32& pj_Error);
    internal virtual mRo= Ahk=(mhg= lp, whg= pjConsts, Int32& pj_Error);
    private mRo= Exk=(mhg= lp, whg= pjConsts, Int32& pj_Error);
    private mRo= ERk=(mhg= lp, whg= pjConsts, Int32& pj_Error);
    private mhg= EBk=(mRo= xy, whg= pjConsts, Int32& pj_Error);
    private mhg= Dhk=(mRo= xy, whg= pjConsts, Int32& pj_Error);
    private double tRk=(double phi, double sinphi, double e, Int32& pj_Error);
    private double RRc=(double ts, double e, Int32& pj_Error);
}
internal class HRU=.TC0= : object {
    [CompilerGeneratedAttribute]
private double TS0=;
    [CompilerGeneratedAttribute]
private int Ti0=;
    [CompilerGeneratedAttribute]
private int Ty0=;
    public double Ui0= { get; public set; }
    public int VS0= { get; public set; }
    public int WC0= { get; public set; }
    public TC0=(double splitBaseNumber, int subdivisionBaseNumber, int rTreeMaxNode);
    [CompilerGeneratedAttribute]
public void US0=(double value);
    [CompilerGeneratedAttribute]
public double UC0=();
    [CompilerGeneratedAttribute]
public void VC0=(int value);
    [CompilerGeneratedAttribute]
public int Uy0=();
    [CompilerGeneratedAttribute]
public void Vy0=(int value);
    [CompilerGeneratedAttribute]
public int Vi0=();
}
internal class HRU=.tCc= : object {
    public static string 8hU=;
    public static string ABY=;
    public static string 8xU=;
    public static string 9RU=;
    public static string /RU=;
    public static string /xU=;
    public static string CxY=;
    public static string KRY=;
    public static string EBY=;
    public static string AxY=;
    public static string LBY=;
    public static string DBY=;
    public static string ExY=;
    public static string JhY=;
    public static string JxY=;
    public static string GRY=;
    public static string KBY=;
    public static string DhY=;
    public static string DRY=;
    public static string IhY=;
    public static string QxY=;
    public static string EhY=;
    public static string GhY=;
    public static string GxY=;
    public static string HBY=;
    public static string HRY=;
    public static string BxY=;
    public static string HxY=;
    public static string ARY=;
    public static string AhY=;
    public static string ChY=;
    public static string CRY=;
    public static string NBY=;
    public static string CBY=;
    public static string FxY=;
    public static string GBY=;
    public static string BRY=;
    public static string BhY=;
    public static string FhY=;
    public static string SBY=;
    public static string SRY=;
    public static string ShY=;
    public static string SxY=;
    public static string TBY=;
    public static string TRY=;
    public static string ThY=;
    public static string TxY=;
    public static string UBY=;
    public static string URY=;
    public static string UhY=;
    public static string UxY=;
    public static string VBY=;
    public static string VRY=;
    public static string FRY=;
    public static string FBY=;
    private static tCc=();
}
[DefaultMemberAttribute("Item")]
internal abstract class HRU=.tCE= : object {
    private static char tSE=;
    private IList`1<string> oCE=;
    public string Item { get; public set; }
    public IList`1<string> tyE= { get; }
    public bool IsReadOnly { get; }
    public int Count { get; }
    protected tCE=(bool readOnly, IEnumerable`1<string> values);
    internal tCE=(IList`1<string> values);
    public virtual string get_Item(int index);
    public virtual void set_Item(int index, string value);
    public IList`1<string> tiE=();
    public sealed virtual bool get_IsReadOnly();
    public sealed virtual int get_Count();
    public string eSE=(int index);
    public virtual void Clear();
    public sealed virtual bool Contains(string value);
    public sealed virtual int IndexOf(string value);
    public virtual void Add(string value);
    public virtual void Insert(int index, string value);
    public virtual bool Remove(string value);
    public virtual void RemoveAt(int index);
    public sealed virtual void CopyTo(String[] array, int arrayIndex);
    public sealed virtual bool Equals(tCE= other);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    public sealed virtual string ToString();
    private sealed virtual override IEnumerator`1<string> System.Collections.Generic.IEnumerable<System.String>.GetEnumerator();
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
}
internal class HRU=.thk= : jBo= {
    internal thk=(string id, string desc);
    private void 9xg=();
    internal virtual whg= /Bg=(whg= pjConsts, Int32& pj_Error);
    internal virtual void Axk=(mhg= lp, whg= pjConsts, TRg= fac, Int32& pj_Error);
    internal virtual mhg= ARk=(mRo= xy, whg= pjConsts, Int32& pj_Error);
    internal virtual mRo= Ahk=(mhg= lp, whg= pjConsts, Int32& pj_Error);
}
internal class HRU=.ti0= : object {
    [CompilerGeneratedAttribute]
private string ty0=;
    [CompilerGeneratedAttribute]
private StringBuilder uC0=;
    [CompilerGeneratedAttribute]
private ushort uS0=;
    [CompilerGeneratedAttribute]
private int ui0=;
    public string vS0= { get; private set; }
    public StringBuilder wC0= { get; private set; }
    public ushort wy0= { get; private set; }
    public int xi0= { get; private set; }
    [CompilerGeneratedAttribute]
private void vC0=(string value);
    [CompilerGeneratedAttribute]
public string uy0=();
    [CompilerGeneratedAttribute]
private void vy0=(StringBuilder value);
    [CompilerGeneratedAttribute]
public StringBuilder vi0=();
    [CompilerGeneratedAttribute]
private void wi0=(ushort value);
    [CompilerGeneratedAttribute]
public ushort wS0=();
    [CompilerGeneratedAttribute]
public int xC0=();
    [CompilerGeneratedAttribute]
private void xS0=(int value);
    public void gC0=(StringBuilder name, string type);
    private StringBuilder xy0=(StringBuilder Name);
}
internal class HRU=.tig= : object {
    protected int tyg=;
    protected Pyo= uCg=;
    private static Pyo= uSg=;
    public Pyo= ryU= { get; public set; }
    public int siU= { get; public set; }
    private static tig=();
    public virtual int syU=();
    public virtual Pyo= tCU=();
    public virtual byte tSU=();
    public virtual double tiU=();
    public virtual int tyU=();
    public virtual string uiU=();
    public virtual byte uCU=();
    public virtual int uSU=();
    public virtual void uyU=(byte val);
    public virtual void vCU=(double val);
    public virtual void vSU=(int val);
    public virtual void viU=(byte val);
    public virtual void vyU=(int clr);
    public virtual void wCU=(string pszStyleString);
    public virtual void wSU=(Stream fpOut);
    public sealed virtual Pyo= rSU=();
    public sealed virtual void riU=(Pyo= value);
    public sealed virtual int sCU=();
    public sealed virtual void sSU=(int value);
}
internal class HRU=.tR8= : object {
    protected eB8= th8=;
    protected int ex8=;
    internal tR8=(eB8= page);
    internal static tR8= tx8=(eB8= dtPage);
    internal Gist_Ext_Id uB8=();
    internal bool uR8=();
    public tR8= uh8=(int index);
    internal ushort hB8=();
    internal void hR8=(ushort level);
    public UInt32 ux8=();
    internal void hh8=(UInt32 pageNo);
    internal 6B8= jR8=();
    internal 6B8= jh8=();
    internal bool jx8=();
    public int iB8=();
    internal int vB8=();
    internal BCA= kh8=();
    internal bool vR8=(BCA= rt);
    internal bool vh8=(BCA= rt);
    internal bool vx8=(BCA= rt);
    internal virtual int rB8=(ArrayList& al);
    internal virtual int rB8=(ArrayList& al, double resolution, int simplifyPixelBufferSize, Collection`1<RectangleShape> smallBoxes);
    internal ArrayList wB8=(LiA= p, tR8= nRoot, int nMax);
    private void wB8=(tR8= node, LiA= p, double nearest, int nMax, ArrayList& nodeStack, ArrayList& candidateStack, ArrayList& resuLbStack);
    private static void wR8=(ArrayList& nodeStack, tR8= node, LiA= p);
    private static void wh8=(ArrayList& candidateStack, ArrayList& resuLbStack, int nMax, double nearest);
    private static void wx8=(tR8= node, LiA= p, ArrayList& candidateStack);
    internal virtual int wx4=(BCA= rt, ArrayList& al);
    internal virtual int rR8=(BCA= rt, ArrayList& al);
    internal virtual int rh8=(BCA= rt, ArrayList& al);
    internal virtual int rh8=(BCA= rt, ArrayList& al, double resolution, int simplifyPixelBufferSize, Collection`1<RectangleShape> smallBoxes);
    internal string kR8=();
    public 6B8= kB8=(int idx);
    public bool xB8=();
    public bool xR8=();
    internal bool xh8=();
    internal ArrayList[] xx8=(ArrayList rectList);
    internal static void yB8=(BCA=[] rectArr, ArrayList& spRectList, ArrayList& leftRectList, ArrayList& rightRectList, BCA=& mbr1, BCA=& mbr2);
    internal static void yR8=(ArrayList& spRectList, ArrayList& rectList);
    internal static Int32[] yh8=(BCA=[] rtArr);
    internal static void yx8=(tR8= n, int index, bool bSplitted);
    internal static bool dx8=(tR8= n, lB8= ent, int index);
    internal int zB8=(BCA= rt);
    internal virtual bool gR8=(6B8= rec, tR8=[]& nodelist);
    internal bool zR8=(6B8= rec, tR8=[]& nodeList);
    internal bool zh8=(6B8= insertRec, tR8=[] nodeListIn, tR8=[]& nodeListOut);
    private UInt32 kx8=();
    internal virtual bool cx8=(6B8= rec, tR8=[]& nodeList);
    internal bool zx8=(tR8=[] a);
    internal void 0B8=(tR8= node);
    internal bool 0R8=(6B8= delRec);
    internal void 0R8=(6B8= delRec, IEnumerable`1<string> ids, IdsEngine idsEngine);
    internal virtual bool rx8=(6B8= rec, Int32& idx, qx8=& leafToDel);
    internal virtual void sB8=(6B8= rec, Collection`1<LeafRecordWrapper> leaves, IdsEngine idsEngine);
    private static void 0h8=(6B8= rec, tR8= subNode, Collection`1<LeafRecordWrapper> leaves, IdsEngine idsEngine);
    private static void 0x8=(6B8= rec, tR8= subNode, Collection`1<LeafRecordWrapper> leaves, IdsEngine idsEngine);
    private static bool 1B8=(6B8= rec, Int32& idx, qx8=& leafToDel, tR8= subNode);
    private static bool 1R8=(6B8= rec, Int32& idx, qx8=& leafToDel, tR8= subNode);
    internal void gh8=(int idx);
}
internal class HRU=.TRg= : object {
    internal double Thg=;
    internal double Txg=;
    internal double UBg=;
    internal int URg=;
}
internal class HRU=.TRo= : jBo= {
    internal double Tho=;
    internal double Txo=;
    internal double UBo=;
    internal double URo=;
    internal double Uho=;
    internal double Uxo=;
    internal double VBo=;
    internal double VRo=;
    internal double Vho=;
    internal double Vxo=;
    internal double WBo=;
    internal double WRo=;
    internal double Who=;
    internal double qhk=;
    internal double qRk=;
    internal double Wxo=;
    internal double Zhk=;
    internal TRo=(string id, string desc);
    private void 9xg=();
    internal virtual whg= /Bg=(whg= pjConsts, Int32& pj_Error);
    internal virtual void Axk=(mhg= lp, whg= pjConsts, TRg= fac, Int32& pj_Error);
    internal virtual mhg= ARk=(mRo= xy, whg= pjConsts, Int32& pj_Error);
    internal virtual mRo= Ahk=(mhg= lp, whg= pjConsts, Int32& pj_Error);
}
internal class HRU=.tSc= : object {
    public string tic=;
    public int tyc=;
    public 0iY= XSc=;
    public tSc=(int inParam, string pszInput, int bGeo, 0iY= ogrType);
}
internal class HRU=.txk= : jBo= {
    internal Uhc=[] Gxk=;
    internal double HBk=;
    internal double HRk=;
    internal int gxc=;
    internal txk=(string id, string desc);
    private void 9xg=();
    internal virtual whg= /Bg=(whg= pjConsts, Int32& pj_Error);
    internal virtual void Axk=(mhg= lp, whg= pjConsts, TRg= fac, Int32& pj_Error);
    internal virtual mhg= ARk=(mRo= xy, whg= pjConsts, Int32& pj_Error);
    internal virtual mRo= Ahk=(mhg= lp, whg= pjConsts, Int32& pj_Error);
    private mhg= EBk=(mRo= xy, whg= pjConsts, Int32& pj_Error);
    private mRo= Exk=(mhg= lp, whg= pjConsts, Int32& pj_Error);
    private Uhc= Hhk=(Uhc= z, Uhc=[] C, int n, Uhc= der);
    private Uhc= Hxk=(Uhc= z, Uhc=[] C, int n);
}
internal class HRU=.ty4= : object {
    private BinaryReader nyE=;
    private ui4= uC4=;
    private Stream iC4=;
    private Encoding FR8=;
    public ty4=(Stream stream, ui4= header, Encoding encoding);
    public string uS4=(int offset, zyw= encryptor);
}
internal enum HRU=.ty8= : Enum {
    public int value__;
    public static ty8= uC8=;
    public static ty8= uS8=;
    public static ty8= ui8=;
}
internal enum HRU=.Tys= : Enum {
    public int value__;
    public static Tys= UCs=;
    public static Tys= USs=;
    public static Tys= Uis=;
}
internal class HRU=.uBk= : jBo= {
    internal double thc=;
    internal double txc=;
    internal double uRc=;
    internal uBk=(string id, string desc);
    private void 9xg=();
    internal virtual whg= /Bg=(whg= pjConsts, Int32& pj_Error);
    internal virtual void Axk=(mhg= lp, whg= pjConsts, TRg= fac, Int32& pj_Error);
    internal virtual mhg= ARk=(mRo= xy, whg= pjConsts, Int32& pj_Error);
    internal virtual mRo= Ahk=(mhg= lp, whg= pjConsts, Int32& pj_Error);
    private whg= uRk=(whg= pjConsts, double p, Int32& pj_Error);
}
internal class HRU=.uCc= : object {
    public string uSc=;
    public double uic=;
    public int uyc=;
    public int vCc=;
    public xCY= vSc=;
    public uCc=(string pszInput, double dValue, int eParam, int bGeo, xCY= ogrUnit);
}
internal enum HRU=.UCg= : Enum {
    public int value__;
    public static UCg= USg=;
    public static UCg= Uig=;
    public static UCg= Uyg=;
}
internal class HRU=.Uhc= : ValueType {
    internal double Uxc=;
    internal double VBc=;
}
internal class HRU=.Uhg= : ValueType {
    internal float Uxg=;
    internal float VBg=;
}
internal class HRU=.uhk= : jBo= {
    internal double gxc=;
    internal double Sxk=;
    internal double TBk=;
    internal double TRk=;
    internal double Thk=;
    internal double Txk=;
    internal uhk=(string id, string desc);
    private void 9xg=();
    internal virtual whg= /Bg=(whg= pjConsts, Int32& pj_Error);
    internal virtual void Axk=(mhg= lp, whg= pjConsts, TRg= fac, Int32& pj_Error);
    internal virtual mhg= ARk=(mRo= xy, whg= pjConsts, Int32& pj_Error);
    internal virtual mRo= Ahk=(mhg= lp, whg= pjConsts, Int32& pj_Error);
    private int UBk=(whg= pjConsts, Double[] del, Int32& pj_Error);
}
internal class HRU=.Uhk= : jBo= {
    internal double thc=;
    internal double txc=;
    internal double uRc=;
    internal int Uxk=;
    internal Uhk=(string id, string desc);
    private void 9xg=();
    internal virtual whg= /Bg=(whg= pjConsts, Int32& pj_Error);
    internal virtual void Axk=(mhg= lp, whg= pjConsts, TRg= fac, Int32& pj_Error);
    internal virtual mhg= ARk=(mRo= xy, whg= pjConsts, Int32& pj_Error);
    internal virtual mRo= Ahk=(mhg= lp, whg= pjConsts, Int32& pj_Error);
}
[DefaultMemberAttribute("Item")]
internal class HRU=.uhw= : object {
    private int uxw=;
    private Char[] vBw=;
    private int vRw=;
    private int vhw=;
    public int wRw= { get; public set; }
    public int wxw= { get; }
    public char xhw= { get; public set; }
    public uhw=(int capacity);
    public int vxw=();
    public void wBw=(int value);
    public int whw=();
    protected void xxw=(int requestedLen);
    protected void yBw=(int requestedLength);
    protected void yRw=();
    public void yhw=(Char[] b, int len);
    public void yxw=(char c);
    public void yxw=(string s);
    public void yxw=(uhw= s);
    public void zBw=(int i);
    public void zBw=(int i, int n);
    public int zRw=(char c);
    public void axU=();
    public char xBw=(int index);
    public void xRw=(int index, char value);
    public virtual string ToString();
}
internal class HRU=.ui4= : object {
    private int uy4=;
    private int vC4=;
    private int 0RM=;
    public int ZC0= { get; }
    public int /i0= { get; }
    public int AS4= { get; }
    public int Yi0=();
    public int /C0=();
    public int /y0=();
    public void pBw=(Stream stream, int lblOffset, string password);
}
internal class HRU=.uig= : object {
    protected int uyg=;
    protected Iis= vCg=;
    private static Iis= vSg=;
    public int xSU= { get; public set; }
    public Iis= yCU= { get; public set; }
    private static uig=();
    public virtual int ySU=();
    public virtual Iis= yiU=();
    public virtual short yyU=();
    public virtual short zCU=();
    public virtual int zSU=();
    public virtual void ziU=(short val);
    public virtual void zyU=(short val);
    public virtual void 0CU=(int clr);
    public virtual string 0SU=(double dfAngle);
    public virtual void 0iU=(string pszStyleString);
    public sealed virtual void 0yU=(Stream fpOut);
    public virtual int wyU=();
    public virtual void xCU=(int value);
    public virtual Iis= xiU=();
    public virtual void xyU=(Iis= value);
}
internal class HRU=.Uik= : ValueType {
    public int Uyk=;
    public int VCk=;
    public int VSk=;
    public int Vik=;
    public int Vyk=;
    public int WCk=;
    public int WSk=;
    public int Wik=;
}
internal class HRU=.uiw= : object {
    [CompilerGeneratedAttribute]
private int uyw=;
    [CompilerGeneratedAttribute]
private int vCw=;
    [CompilerGeneratedAttribute]
private byte zCM=;
    [CompilerGeneratedAttribute]
private List`1<vS4=> vSw=;
    public int wCw= { get; private set; }
    public int wyw= { get; private set; }
    public byte xiw= { get; private set; }
    public List`1<vS4=> ySw= { get; public set; }
    public uiw=(byte type, int subFileIndex, int subdivisionIndex);
    [CompilerGeneratedAttribute]
private void vyw=(int value);
    [CompilerGeneratedAttribute]
public int viw=();
    [CompilerGeneratedAttribute]
private void wiw=(int value);
    [CompilerGeneratedAttribute]
public int wSw=();
    [CompilerGeneratedAttribute]
private void xSw=(byte value);
    [CompilerGeneratedAttribute]
public byte xCw=();
    [CompilerGeneratedAttribute]
public void yCw=(List`1<vS4=> value);
    [CompilerGeneratedAttribute]
public List`1<vS4=> xyw=();
}
internal class HRU=.URk= : jBo= {
    internal mRo= Nxk=;
    internal double OBk=;
    internal double ORk=;
    internal double Ohk=;
    internal URk=(string id, string desc);
    private void 9xg=();
    internal virtual whg= /Bg=(whg= pjConsts, Int32& pj_Error);
    internal virtual void Axk=(mhg= lp, whg= pjConsts, TRg= fac, Int32& pj_Error);
    internal virtual mhg= ARk=(mRo= xy, whg= pjConsts, Int32& pj_Error);
    internal virtual mRo= Ahk=(mhg= lp, whg= pjConsts, Int32& pj_Error);
}
[ExtensionAttribute]
internal static class HRU=.uRU= : object {
    [ExtensionAttribute]
public static void uhU=(IList`1<T> initial, IEnumerable`1<T> collection);
    [ExtensionAttribute]
public static BindingFlags uxU=(BindingFlags bindingAttr, BindingFlags flag);
    [ExtensionAttribute]
public static Type vBU=(Type type);
    [ExtensionAttribute]
public static bool vRU=(Type type);
    [ExtensionAttribute]
public static MemberTypes vhU=(MemberInfo memberInfo);
    [ExtensionAttribute]
public static bool vxU=(Type type);
}
internal class HRU=.uSk= : zSo= {
    protected int uik=;
    protected 1Ck=[] uyk=;
    protected int Oyk=;
    protected int PCk=;
    protected int PSk=;
    protected int Pik=;
    protected Lig= GCk=;
    protected uSk= vCk=;
    protected int vSk=;
    protected uSk= vik=;
    public uSk=(FSg= eAccessMode);
    protected int vyk=(1Ck= psEntry);
    protected int wCk=(1Ck= psEntry);
    protected int wSk=();
    public virtual int InitBlockFromData(Byte[] pabyBuf, int nBlockSize, int nSizeUsed, bool bMakeCopy, Stream fsSrc, int nOffset);
    public virtual int InitNewBlock(Stream fsSrc, int nBlockSize, int nFileOffset);
    public virtual int CommitToFile();
    public virtual int GetBlockClass();
    public int wik=();
    public int LSk=();
    public 1Ck= wyk=(int iIndex);
    public int FCk=(int nXMin, int nYMin, int nXMax, int nYMax, int nBlockPtr, bool bAddInThisNodeOnly);
    public int xCk=();
    public void nCg=(Int32& nXMin, Int32& nYMin, Int32& nXMax, Int32& nYMax);
    public int LCk=();
    public void RSk=(Lig= poBlockMgr);
    public void xSk=(uSk= poParent);
    public void xik=(uSk= poChild, int nChildIndex);
    public int xyk=();
    public uSk= yCk=();
    public int cx8=(int nNewEntryXMin, int nNewEntryYMin, int nNewEntryXMax, int nNewEntryYMax);
    public int MCk=(int nNewEntryXMin, int nNewEntryYMin, int nNewEntryXMax, int nNewEntryYMax);
    public void ySk=(int nXMin, int nYMin, int nXMax, int nYMax, int nBlockPtr);
    public void yik=();
    public int Jik=(int nXMin, int nYMin, int nXMax, int nYMax, int nBlockPtr);
    public int yyk=(int nXMin, int nYMin, int nXMax, int nYMax);
    private int zCk=(int paraA, int paraB);
    private int zSk=(int paraA, int paraB);
    public int zik=(int nXMin, int nYMin, int nXMax, int nYMax);
    public int zyk=(int nBlockPtr, int nXMin, int nYMin, int nXMax, int nYMax);
    public int 0Ck=(int nBlockPtr, Int32& nXMin, Int32& nYMin, Int32& nXMax, Int32& nYMax);
    private static double 0Sk=(int x1, int y1, int x2, int y2);
    public static double 0ik=(int nNodeXMin, int nNodeYMin, int nNodeXMax, int nNodeYMax, int nEntryXMin, int nEntryYMin, int nEntryXMax, int nEntryYMax);
    public static int 0yk=(1Ck=[] pasEntries, int numEntries, int nSrcCurChildIndex, int nNewEntryXMin, int nNewEntryYMin, int nNewEntryXMax, int nNewEntryYMax, Int32& nSeed1, Int32& nSeed2);
    public sealed virtual void Dispose();
}
internal enum HRU=.uSs= : Enum {
    public int value__;
    public static uSs= uis=;
}
internal enum HRU=.USw= : Enum {
    public int value__;
    public static USw= Uiw=;
    public static USw= Uyw=;
}
internal class HRU=.uxk= : jBo= {
    internal double gxc=;
    internal double Sxk=;
    internal double TBk=;
    internal double TRk=;
    internal double Thk=;
    internal double Txk=;
    internal uxk=(string id, string desc);
    private void 9xg=();
    internal virtual whg= /Bg=(whg= pjConsts, Int32& pj_Error);
    internal virtual void Axk=(mhg= lp, whg= pjConsts, TRg= fac, Int32& pj_Error);
    internal virtual mhg= ARk=(mRo= xy, whg= pjConsts, Int32& pj_Error);
    internal virtual mRo= Ahk=(mhg= lp, whg= pjConsts, Int32& pj_Error);
    private int UBk=(whg= pjConsts, Double[] del, Int32& pj_Error);
}
internal class HRU=.Uy4= : object {
    private BinaryReader VC4=;
    private BinaryReader VS4=;
    private BinaryReader Vi4=;
    private BinaryReader Vy4=;
    private BinaryReader WC4=;
    private BinaryReader WS4=;
    private Ky0= Wi4=;
    private string Wy4=;
    private int XC4=;
    private double XS4=;
    private int Xi4=;
    private List`1<string> Xy4=;
    private FeatureLayer YC4=;
    private Collection`1<string> YS4=;
    private int MC4=;
    private double /yw=;
    private TinyGeoFileType My4=;
    public TinyGeoFileType Yy4= { get; }
    public Uy4=(Ci4= tGeoParameters, TC0= parameter, string tGeoPath, int maxNode, double extentWidthLimitation);
    public TinyGeoFileType Yi4=();
    public Ky0= pSs=();
    public List`1<nyw=> ZC4=(kiw= ReadInfo);
    private static double ZS4=(Vertex source, Vertex des);
    public List`1<nyw=> qhw=(kiw= ReadInfo);
    public nyw= qBw=(kiw= ReadInfo);
    private void Zi4=();
    private static int Zy4=(IEnumerable`1<PolygonShape> polygons);
    public void aC4=();
    private static void aS4=(PointShape pointShape, BinaryWriter shapeWriter, BinaryWriter idxWriter);
    private PointShape ai4=(int index);
    private static void ay4=(LineShape lineshape, BinaryWriter shapeWriter, BinaryWriter idxWriter);
    private LineShape bC4=(int index);
    private static void bS4=(PolygonShape polygon, BinaryWriter shapeWriter, BinaryWriter idxWriter);
    private PolygonShape bi4=(int index);
    private void by4=(List`1<Py0=> savers);
    private static Collection`1<RectangleShape> cC4=(RectangleShape totalBoundingBox, double ratio);
    private static RectangleShape cS4=(double minX, double minY, double width, double height);
}
internal enum HRU=.uy8= : Enum {
    public int value__;
    public static uy8= vC8=;
    public static uy8= vS8=;
    public static uy8= vi8=;
    public static uy8= vy8=;
    public static uy8= wC8=;
    public static uy8= wS8=;
    public static uy8= wi8=;
}
internal class HRU=.Uyc= : object {
    public short VCc=;
    public byte VSc=;
    public byte Vic=;
    public byte Vyc=;
    public byte WCc=;
    public byte WSc=;
    public byte Wic=;
    public object Ihc=();
}
internal class HRU=.UyI= : Exception {
    public UyI=(string message);
}
internal static class HRU=.UyM= : object {
    internal static Style kxU=(JsonElement typeElement, JsonElement paintElement, JsonElement layoutElement, int zoomLevel);
    private static AreaStyle VCM=(JsonElement paint, int zoomLevel);
    private static LineStyle VSM=(JsonElement paint, int zoomLevel);
    private static TextStyle ViM=(JsonElement paint, JsonElement layout, int zoomLevel);
    private static string VyM=(JsonElement element, int zoomLevel);
    private static float WCM=(JsonElement element, int zoomLevel);
    private static Collection`1<float> WSM=(JsonElement element, int zoomLevel);
    private static T WiM=(JsonElement element, int zoomLevel, Func`3<JsonElement, int, T> parseMethod);
    private static T WyM=(JsonElement element, int zoomLevel, Func`3<JsonElement, int, T> parseMethod);
    public static GeoColor XCM=(JsonElement colorElement, JsonElement fillOpacityElement, int zoomLevel);
    private static string XSM=(JsonElement textFontElement);
}
internal enum HRU=.uys= : Enum {
    public int value__;
    public static uys= vCs=;
    public static uys= vSs=;
    public static uys= vis=;
    public static uys= vys=;
    public static uys= wCs=;
    public static uys= wSs=;
    public static uys= wis=;
}
internal enum HRU=.Uys= : Enum {
    public int value__;
    public static Uys= VCs=;
    public static Uys= VSs=;
    public static Uys= Vis=;
}
internal class HRU=.vBk= : jBo= {
    internal double gxc=;
    internal double Sxk=;
    internal double TBk=;
    internal double TRk=;
    internal double Thk=;
    internal double Txk=;
    internal vBk=(string id, string desc);
    private void 9xg=();
    internal virtual whg= /Bg=(whg= pjConsts, Int32& pj_Error);
    internal virtual void Axk=(mhg= lp, whg= pjConsts, TRg= fac, Int32& pj_Error);
    internal virtual mhg= ARk=(mRo= xy, whg= pjConsts, Int32& pj_Error);
    internal virtual mRo= Ahk=(mhg= lp, whg= pjConsts, Int32& pj_Error);
    private int UBk=(whg= pjConsts, Double[] del, Int32& pj_Error);
}
internal class HRU=.VBk= : jBo= {
    internal double gxc=;
    internal double CRk=;
    internal VBk=(string id, string desc);
    private void 9xg=();
    internal virtual whg= /Bg=(whg= pjConsts, Int32& pj_Error);
    internal virtual void Axk=(mhg= lp, whg= pjConsts, TRg= fac, Int32& pj_Error);
    internal virtual mhg= ARk=(mRo= xy, whg= pjConsts, Int32& pj_Error);
    internal virtual mRo= Ahk=(mhg= lp, whg= pjConsts, Int32& pj_Error);
}
internal class HRU=.VCg= : object {
    public string VSg=;
    public char Vig=;
    public byte Vyg=;
    public byte WCg=;
    public vig= WSg=;
}
internal class HRU=.VCI= : Exception {
}
internal class HRU=.vCM= : object {
    [CompilerGeneratedAttribute]
private string vSM=;
    [CompilerGeneratedAttribute]
private string viM=;
    [CompilerGeneratedAttribute]
private string oyM=;
    [CompilerGeneratedAttribute]
private List`1<ySM=> vyM=;
    [CompilerGeneratedAttribute]
private xyM= wCM=;
    [CompilerGeneratedAttribute]
private string wSM=;
    [CompilerGeneratedAttribute]
private List`1<string> wiM=;
    [CompilerGeneratedAttribute]
private string wyM=;
    [CompilerGeneratedAttribute]
private string xCM=;
    [ObfuscationAttribute]
[JsonPropertyNameAttribute("id")]
public string Id { get; public set; }
    [JsonPropertyNameAttribute("title")]
[ObfuscationAttribute]
public string Title { get; public set; }
    [JsonPropertyNameAttribute("description")]
[ObfuscationAttribute]
public string Description { get; public set; }
    [JsonPropertyNameAttribute("links")]
[ObfuscationAttribute]
public List`1<ySM=> Links { get; public set; }
    [ObfuscationAttribute]
[JsonPropertyNameAttribute("extent")]
public xyM= Extent { get; public set; }
    [JsonPropertyNameAttribute("itemType")]
[ObfuscationAttribute]
public string ItemType { get; public set; }
    [ObfuscationAttribute]
[JsonPropertyNameAttribute("crs")]
public List`1<string> Crs { get; public set; }
    [JsonPropertyNameAttribute("storageCrs")]
[ObfuscationAttribute]
public string StorageCrs { get; public set; }
    [JsonPropertyNameAttribute("storageCRS")]
[ObfuscationAttribute]
public string DefaultCrs { get; public set; }
    public vCM=(string id, string title, string description, List`1<ySM=> links, xyM= extent, string itemType, List`1<string> crs, string storageCrs);
    [CompilerGeneratedAttribute]
public string get_Id();
    [CompilerGeneratedAttribute]
public void set_Id(string value);
    [CompilerGeneratedAttribute]
public string get_Title();
    [CompilerGeneratedAttribute]
public void set_Title(string value);
    [CompilerGeneratedAttribute]
public string get_Description();
    [CompilerGeneratedAttribute]
public void set_Description(string value);
    [CompilerGeneratedAttribute]
public List`1<ySM=> get_Links();
    [CompilerGeneratedAttribute]
public void set_Links(List`1<ySM=> value);
    [CompilerGeneratedAttribute]
public xyM= get_Extent();
    [CompilerGeneratedAttribute]
public void set_Extent(xyM= value);
    [CompilerGeneratedAttribute]
public string get_ItemType();
    [CompilerGeneratedAttribute]
public void set_ItemType(string value);
    [CompilerGeneratedAttribute]
public List`1<string> get_Crs();
    [CompilerGeneratedAttribute]
public void set_Crs(List`1<string> value);
    [CompilerGeneratedAttribute]
public string get_StorageCrs();
    [CompilerGeneratedAttribute]
public void set_StorageCrs(string value);
    [CompilerGeneratedAttribute]
public string get_DefaultCrs();
    [CompilerGeneratedAttribute]
public void set_DefaultCrs(string value);
}
internal enum HRU=.VCw= : Enum {
    public int value__;
    public static VCw= ehY=;
    public static VCw= VSw=;
}
internal class HRU=.vhg= : object {
    internal bool vxg=;
    internal double wBg=;
    internal int VBc=;
    internal string wRg=;
}
internal class HRU=.vhk= : jBo= {
    internal vhk=(string id, string desc);
    private void 9xg=();
    internal virtual whg= /Bg=(whg= pjConsts, Int32& pj_Error);
    internal virtual void Axk=(mhg= lp, whg= pjConsts, TRg= fac, Int32& pj_Error);
    internal virtual mhg= ARk=(mRo= xy, whg= pjConsts, Int32& pj_Error);
    internal virtual mRo= Ahk=(mhg= lp, whg= pjConsts, Int32& pj_Error);
}
internal class HRU=.Vhk= : jBo= {
    internal Vhk=(string id, string desc);
    private void 9xg=();
    internal virtual whg= /Bg=(whg= pjConsts, Int32& pj_Error);
    internal virtual void Axk=(mhg= lp, whg= pjConsts, TRg= fac, Int32& pj_Error);
    internal virtual mhg= ARk=(mRo= xy, whg= pjConsts, Int32& pj_Error);
    internal virtual mRo= Ahk=(mhg= lp, whg= pjConsts, Int32& pj_Error);
}
internal class HRU=.vic= : 3Cc= {
    public tSc=[] vyc=;
    private uCc=[] wCc=;
    public virtual int kxU=();
    public string wSc=(Int32& bDefault);
    public string wic=(Int32& bDefault);
    public string wyc=(Int32& bDefault);
    public string xCc=(4SY= eParam, Int32& bValueIsNull);
}
internal enum HRU=.vig= : Enum {
    public int value__;
    public static vig= vyg=;
    public static vig= wCg=;
    public static vig= wSg=;
    public static vig= wig=;
    public static vig= wyg=;
    public static vig= xCg=;
    public static vig= xSg=;
    public static vig= xig=;
    public static vig= xyg=;
    public static vig= yCg=;
}
internal class HRU=.ViI= : Exception {
}
internal enum HRU=.Viw= : Enum {
    public int value__;
    public static Viw= Vyw=;
    public static Viw= WCw=;
    public static Viw= WSw=;
    public static Viw= Wiw=;
    public static Viw= Wyw=;
    public static Viw= XCw=;
    public static Viw= XSw=;
    public static Viw= Xiw=;
    public static Viw= Xyw=;
    public static Viw= YCw=;
    public static Viw= YSw=;
    public static Viw= Yiw=;
}
internal class HRU=.VRc= : object {
    internal string exQ=;
    internal mhg= Vhc=;
    internal mhg= Vxc=;
    internal mRg= WBc=;
    internal Uhg=[] WRc=;
}
internal class HRU=.VRg= : object {
    internal double Vhg=;
    internal double Vxg=;
    internal double WBg=;
    internal double WRg=;
    internal double Whg=;
    internal double Wxg=;
}
internal class HRU=.vRk= : jBo= {
    internal vRk=(string id, string desc);
    private void 9xg=();
    internal virtual whg= /Bg=(whg= pjConsts, Int32& pj_Error);
    internal virtual void Axk=(mhg= lp, whg= pjConsts, TRg= fac, Int32& pj_Error);
    internal virtual mhg= ARk=(mRo= xy, whg= pjConsts, Int32& pj_Error);
    internal virtual mRo= Ahk=(mhg= lp, whg= pjConsts, Int32& pj_Error);
}
internal class HRU=.VRk= : jBo= {
    internal VRk=(string id, string desc);
    private void 9xg=();
    internal virtual whg= /Bg=(whg= pjConsts, Int32& pj_Error);
    internal virtual void Axk=(mhg= lp, whg= pjConsts, TRg= fac, Int32& pj_Error);
    internal virtual mhg= ARk=(mRo= xy, whg= pjConsts, Int32& pj_Error);
    internal virtual mRo= Ahk=(mhg= lp, whg= pjConsts, Int32& pj_Error);
}
internal class HRU=.vS4= : object {
    private int vi4=;
    private double vy4=;
    private double wC4=;
    private double wS4=;
    private double wi4=;
    public int 5iw= { get; }
    public vS4=(int childIndex, double xMin, double yMin, double xMax, double yMax);
    public int 5Cw=();
    public bool wy4=(RectangleShape range);
}
internal class HRU=.VS8= : object {
    private long SSA=;
    private hy8= Vi8=;
    private Collection`1<dy8=> Vy8=;
    private Collection`1<aC8=> WC8=;
    public long Wy8= { get; public set; }
    internal hy8= Xi8= { get; internal set; }
    internal Collection`1<dy8=> YS8= { get; internal set; }
    internal Collection`1<aC8=> ZC8= { get; internal set; }
    public long WS8=();
    public void Wi8=(long value);
    internal hy8= XC8=();
    internal void XS8=(hy8= value);
    internal Collection`1<dy8=> Xy8=();
    internal void YC8=(Collection`1<dy8=> value);
    internal Collection`1<aC8=> Yi8=();
    internal void Yy8=(Collection`1<aC8=> value);
}
internal class HRU=.VSE= : object {
    private static hiE= ViE=;
    private nSE= VyE=;
    private bool WCE=;
    private eCE=[] vBw=;
    private eiE= WSE=;
    private long WiE=;
    private bool Bh4=;
    public bool XSE= { get; public set; }
    public bool YCE= { get; public set; }
    public char YyE= { get; public set; }
    public Nullable`1<char> ZiE= { get; public set; }
    public eiE= aSE= { get; public set; }
    public long ayE= { get; }
    public bool bSE= { get; }
    public IEnumerable`1<eCE=> byE= { get; }
    public VSE=(string pathFilename);
    public VSE=(string pathFilename, Encoding encoding);
    public VSE=(Stream stream);
    public VSE=(Stream stream, Encoding encoding);
    public VSE=(Stream stream, Encoding encoding, bool leaveOpen);
    public VSE=(TextReader textReader);
    public VSE=(TextReader textReader, bool leaveOpen);
    private static VSE=();
    public bool WyE=();
    public void XCE=(bool value);
    public bool XiE=();
    public void XyE=(bool value);
    public char YSE=();
    public void YiE=(char value);
    public Nullable`1<char> ZCE=();
    public void ZSE=(Nullable`1<char> value);
    public eiE= ZyE=();
    public void aCE=(eiE= value);
    public long aiE=();
    public bool bCE=();
    public static VSE= cCE=(string csv);
    [IteratorStateMachineAttribute("HRU=.VSE=/0z8=")]
public IEnumerable`1<eCE=> biE=();
    public bool cSE=();
    public bool cSE=(bool incrementRecordNumber);
    public int ciE=(int count);
    public int ciE=(int count, bool incrementRecordNumber);
    public eiE= cyE=();
    public eCE= dCE=();
    public int dSE=(eCE=[] buffer, int offset, int count);
    public void pR8=();
    public sealed virtual void Dispose();
    protected virtual void Dispose(bool disposing);
    private void diE=();
    private void dyE=();
}
internal class HRU=.VSI= : Exception {
}
internal class HRU=.Vx0= : object {
    public virtual string shw=(BaseShape geometry);
    public virtual void shw=(BaseShape geometry, StringBuilder writer);
    private void WB0=(BaseShape geometry, StringBuilder writer);
    private void WR0=(Vertex coordinate, StringBuilder writer);
    private void WR0=(PointShape coordinate, StringBuilder writer);
    private void Wh0=(LineShape lineString, StringBuilder writer);
    private void Wx0=(RingShape linearRing, StringBuilder writer);
    private void XB0=(PolygonShape polygon, StringBuilder writer);
    private void XR0=(MultipointShape multipoint, StringBuilder writer);
    private void Xh0=(MultilineShape multiLineString, StringBuilder writer);
    private void Xx0=(MultipolygonShape multiPolygon, StringBuilder writer);
    private void YB0=(GeometryCollectionShape geometryCollection, StringBuilder writer);
    private void YR0=(Vertex coordinate, StringBuilder writer);
    private void YR0=(PointShape coordinate, StringBuilder writer);
    private void Yh0=(Vertex coordinate, StringBuilder writer);
    private void Yh0=(PointShape coordinate, StringBuilder writer);
    private void Yx0=(LineShape lineString, StringBuilder writer);
    private void Yx0=(RingShape lineString, StringBuilder writer);
    private void ZB0=(PolygonShape polygon, StringBuilder writer);
    private void ZR0=(MultipointShape multiPoint, StringBuilder writer);
    private void Zh0=(MultilineShape multiLineString, StringBuilder writer);
    private void Zx0=(MultipolygonShape multiPolygon, StringBuilder writer);
    private void aB0=(GeometryCollectionShape geometryCollection, StringBuilder writer);
    public static IEnumerable`1<Vertex> aR0=(BaseShape shape);
}
internal class HRU=.vxk= : jBo= {
    internal vxk=(string id, string desc);
    private void 9xg=();
    internal virtual whg= /Bg=(whg= pjConsts, Int32& pj_Error);
    internal virtual void Axk=(mhg= lp, whg= pjConsts, TRg= fac, Int32& pj_Error);
    internal virtual mhg= ARk=(mRo= xy, whg= pjConsts, Int32& pj_Error);
    internal virtual mRo= Ahk=(mhg= lp, whg= pjConsts, Int32& pj_Error);
}
internal class HRU=.Vxk= : jBo= {
    private double Thg=;
    private double WBk=;
    private double WRk=;
    private double Whk=;
    private double Wxk=;
    private double XBk=;
    private double FRg=;
    internal Vxk=(string id, string desc);
    private void 9xg=();
    internal virtual whg= /Bg=(whg= pjConsts, Int32& pj_Error);
    internal virtual void Axk=(mhg= lp, whg= pjConsts, TRg= fac, Int32& pj_Error);
    private mhg= EBk=(mRo= xy, whg= pjConsts, Int32& pj_Error);
    private mhg= Dhk=(mRo= xy, whg= pjConsts, Int32& pj_Error);
    private mRo= Exk=(mhg= lp, whg= pjConsts, Int32& pj_Error);
    private mRo= ERk=(mhg= lp, whg= pjConsts, Int32& pj_Error);
    internal virtual mhg= ARk=(mRo= xy, whg= pjConsts, Int32& pj_Error);
    internal virtual mRo= Ahk=(mhg= lp, whg= pjConsts, Int32& pj_Error);
}
internal class HRU=.VyI= : Exception {
}
internal class HRU=.Vys= : CyU= {
    protected Pyo=[] WCs=;
    protected int WSs=;
    protected int Wis=;
    protected OSg=[] Wys=;
    protected int XCs=;
    protected int XSs=;
    protected 4Cg=[] Xis=;
    protected int Xys=;
    protected int YCs=;
    protected Iis=[] YSs=;
    protected int Yis=;
    protected int Yys=;
    public int ZCs=(Myo= poBlock);
    public int ZSs=(Myo= poBlock);
    public Pyo= tCU=(int nIndex);
    public int Zis=(Pyo= poNewPenDef);
    public int Zys=();
    public OSg= lCU=(int nIndex);
    public int aCs=(OSg= poNewBrushDef);
    public int aSs=();
    public 4Cg= qCU=(int nIndex);
    public int ais=(4Cg= poNewFontDef);
    public int ays=();
    public Iis= yiU=(int nIndex);
    public int bCs=(Iis= poNewSymbolDef);
    public int bSs=();
    public int bis=();
}
internal class HRU=.wBk= : jBo= {
    internal double wRk=;
    internal double Bhk=;
    internal double Bxk=;
    internal double Nxk=;
    internal double whk=;
    internal double wxk=;
    internal double xBk=;
    internal double Thg=;
    internal double xRk=;
    internal double xhk=;
    internal double xxk=;
    internal double yBk=;
    internal int DRk=;
    internal int yRk=;
    internal wBk=(string id, string desc);
    private void 9xg=();
    internal virtual whg= /Bg=(whg= pjConsts, Int32& pj_Error);
    internal virtual void Axk=(mhg= lp, whg= pjConsts, TRg= fac, Int32& pj_Error);
    internal virtual mhg= ARk=(mRo= xy, whg= pjConsts, Int32& pj_Error);
    internal virtual mRo= Ahk=(mhg= lp, whg= pjConsts, Int32& pj_Error);
}
internal class HRU=.wBU= : MulticastDelegate {
    public wBU=(object object, IntPtr method);
    public virtual TResult Invoke(T target, Object[] args);
    public virtual IAsyncResult BeginInvoke(T target, Object[] args, AsyncCallback callback, object object);
    public virtual TResult EndInvoke(IAsyncResult result);
}
internal class HRU=.WCI= : Exception {
}
internal static class HRU=.Whc= : object {
    internal static double Wxc=;
    internal static double XBc=;
    internal static double XRc=;
    internal static double Xhc=;
    internal static double Xxc=;
    internal static double YBc=;
    internal static double YRc=;
    internal static double WxY=;
    internal static double Yhc=;
    internal static double Yxc=;
    internal static double ZBc=;
    internal static double ZRc=;
    internal static double Zhc=;
    internal static double Zxc=;
    internal static double aBc=;
    internal static double aRc=;
    internal static double ahc=;
    internal static double axc=;
    internal static double bBc=;
    internal static double bRc=;
    internal static double bhc=;
    internal static double bxc=;
    internal static double cBc=;
    internal static double cRc=;
    internal static double chc=;
    internal static double cxc=;
    internal static int dBc=;
    internal static int dRc=;
    internal static int dhc=;
    internal static int dxc=;
    internal static int eBc=;
    internal static int eRc=;
    internal static int ehc=;
    internal static int exc=;
    internal static int fBc=;
    internal static double fRc=;
    internal static double fhc=;
    internal static double XhY=;
    internal static double fxc=;
    internal static double gBc=;
    internal static double gRc=;
    internal static double ghc=;
    internal static double gxc=;
    internal static double hBc=;
    internal static double hRc=;
    internal static double hhc=;
    internal static double hxc=;
    internal static double iBc=;
    internal static double iRc=;
    internal static double ihc=;
    internal static double ixc=;
    internal static double jBc=;
    internal static double jRc=;
    internal static double jhc=;
    internal static double jxc=;
    internal static double kBc=;
    internal static double kRc=;
    internal static double khc=;
    internal static int kxc=;
    internal static double lBc=;
    internal static double lRc=;
    internal static double lhc=;
    internal static double lxc=;
    internal static double mBc=;
    internal static double mRc=;
    internal static double mhc=;
    internal static double mxc=;
    internal static double nBc=;
    internal static int nRc=;
    internal static double nhc=;
    internal static double nxc=;
    internal static double oBc=;
    internal static double oRc=;
    internal static double ohc=;
    internal static double oxc=;
    internal static double pBc=;
    internal static double pRc=;
    internal static double phc=;
    internal static double pxc=;
    internal static double qBc=;
    internal static double qRc=;
    internal static double qhc=;
    internal static double qxc=;
    internal static double rBc=;
    internal static double rRc=;
    internal static double rhc=;
    internal static double rxc=;
    internal static double sBc=;
    internal static double sRc=;
    internal static double shc=;
    internal static double sxc=;
    internal static double tBc=;
    internal static double tRc=;
    internal static double thc=;
    internal static double txc=;
    internal static double uBc=;
    internal static double uRc=;
    internal static double uhc=;
    internal static int uxc=;
    internal static double vBc=;
    internal static double vRc=;
    internal static double vhc=;
    internal static double vxc=;
    internal static double wBc=;
    internal static double wRc=;
    internal static double whc=;
    internal static double wxc=;
    internal static double xBc=;
    internal static double xRc=;
    internal static double xhc=;
    internal static double xxc=;
    internal static double yBc=;
    internal static int yRc=;
    internal static int yhc=;
    internal static double yxc=;
    internal static double zBc=;
    internal static double zRc=;
    internal static double zhc=;
    internal static double zxc=;
    internal static double 0Bc=;
    internal static double 0Rc=;
    internal static double 0hc=;
    internal static double 0xc=;
    internal static double 1Bc=;
    internal static double 1Rc=;
    internal static double 1hc=;
    internal static double 1xc=;
    internal static double 2Bc=;
    internal static double 2Rc=;
    internal static double 2hc=;
    internal static double 2xc=;
    internal static double 3Bc=;
    internal static double 3Rc=;
    internal static double 3hc=;
    internal static double 3xc=;
    internal static double 4Bc=;
    internal static double 4Rc=;
    internal static double 4hc=;
    internal static double 4xc=;
    internal static byte 5Bc=;
    internal static byte 5Rc=;
    internal static byte 5hc=;
    internal static byte 5xc=;
    internal static int 6Bc=;
    internal static int 6Rc=;
    internal static double 6hc=;
    internal static double 6xc=;
    internal static double 7Bc=;
    internal static double 7Rc=;
    internal static double 7hc=;
    internal static int 7xc=;
    internal static double 8Bc=;
    internal static double 8Rc=;
    internal static double 8hc=;
    internal static double 8xc=;
    internal static double 9Bc=;
    internal static double 9Rc=;
    internal static double 9hc=;
    internal static double 9xc=;
    internal static double /Bc=;
    internal static double /Rc=;
    internal static double /hc=;
    internal static double /xc=;
    internal static int ABg=;
    internal static double ARg=;
    internal static double Ahg=;
    internal static double Axg=;
    internal static double BBg=;
    internal static double BRg=;
    internal static double Bhg=;
    internal static double Bxg=;
    internal static int CBg=;
    internal static double CRg=;
    internal static double Chg=;
    internal static int Cxg=;
    internal static int DBg=;
    internal static int DRg=;
    internal static double Dhg=;
    internal static double Dxg=;
    internal static double EBg=;
    internal static double ERg=;
    internal static double Ehg=;
    internal static int Exg=;
    internal static double FBg=;
    internal static double FRg=;
    internal static double Fhg=;
    internal static double Fxg=;
    internal static double GBg=;
    internal static double GRg=;
    internal static double Ghg=;
    internal static int Gxg=;
    internal static double HBg=;
    internal static int HRg=;
    internal static double Hhg=;
    internal static double Hxg=;
    internal static double IBg=;
    internal static double IRg=;
    internal static double Ihg=;
    internal static double Ixg=;
    internal static double JBg=;
    internal static double JRg=;
    internal static double Jhg=;
    internal static double Jxg=;
    internal static double KBg=;
    internal static double KRg=;
    internal static double Khg=;
    internal static double Kxg=;
    internal static double LBg=;
    internal static double LRg=;
    internal static double Lhg=;
    internal static double Lxg=;
    internal static double MBg=;
    internal static double MRg=;
    internal static double Mhg=;
    internal static double Mxg=;
    internal static double NBg=;
    internal static double NRg=;
    internal static double Nhg=;
    internal static double Nxg=;
    internal static long OBg=;
    internal static long ORg=;
    internal static long Ohg=;
    internal static long Oxg=;
    internal static double Nxc=;
    internal static double PBg=;
    internal static double PRg=;
    internal static int Phg=;
    internal static double Pxg=;
    internal static double QBg=;
    internal static double QRg=;
    internal static string Qhg=;
    internal static double Qxg=;
    internal static double RBg=;
    private static Whc=();
}
internal class HRU=.whg= : object {
    internal string wxg=;
    internal Dictionary`2<string, string> xBg=;
    internal bool xRg=;
    internal int xhg=;
    internal bool xxg=;
    internal bool yBg=;
    internal double yRg=;
    internal double yhg=;
    internal double yxg=;
    internal double zBg=;
    internal double zRg=;
    internal double zhg=;
    internal double zxg=;
    internal double 0Bg=;
    internal double 0Rg=;
    internal double 0hg=;
    internal double 0xg=;
    internal double 1Bg=;
    internal double 1Rg=;
    internal double 1hg=;
    internal double 1xg=;
    internal Rxg= 2Bg=;
    internal Double[] 2Rg=;
    internal double 2hg=;
    internal double 2xg=;
}
internal class HRU=.Wig= : CyU= {
    public Encoding FR8=;
    private string 8SU=;
    private Stream Wyg=;
    private FSg= 8iU=;
    private Jis= XCg=;
    private zSo= XSg=;
    private int Xig=;
    private VCg=[] Xyg=;
    private zSo= YCg=;
    private int Lyg=;
    private int YSg=;
    private int Yig=;
    private bool Yyg=;
    private int ZCg=;
    private int ZSg=;
    private bool Zig=;
    private string Zyg=;
    private static int Eyg=;
    private static int FCg=;
    private static int Eig=;
    public string dSY=(int columnNum, int recordNum);
    private int aCg=();
    private int Qx8=();
    public int GR8=(string pszFname, FileAccess pszAccess, Jis= eTableType);
    public int pR8=();
    public int aSg=();
    public vig= Hh8=(int nFieldId);
    public int aig=(int nFieldId);
    public int ayg=(int nFieldId);
    public int bCg=(int iField, string pszName, vig= eType, int nWidth, int nPrecision);
    public int bSg=(string pszName, vig= eType, int nWidth, int nPrecision);
    public int big=();
    public zSo= byg=(int nRecordId);
    public bool cCg=();
    public int cSg=();
    public string cig=(int nWidth);
    public int cyg=(int nWidth);
    public short dCg=(int nWidth);
    public double dSg=(int nWidth);
    public double dig=(int nWidth);
    public string dyg=(int nWidth);
    public string eCg=(int nWidth);
    public string eSg=(int nWidth);
    public string eig=(int nWidth);
    public int eyg=(string pszStr, int nWidth, CCk= poINDFile, int nIndexNo);
    public int fCg=(int nValue, CCk= poINDFile, int nIndexNo);
    public int fSg=(short nValue, CCk= poINDFile, int nIndexNo);
    public int fig=(float dValue, CCk= poINDFile, int nIndexNo);
    public int fyg=(double dValue, int nWidth, int nPrecision, CCk= poINDFile, int nIndexNo);
    public int gCg=(string pszValue, CCk= poINDFile, int nIndexNo);
    public int gSg=(string pszValue, CCk= poINDFile, int nIndexNo);
    public int gig=(string pszValue, CCk= poINDFile, int nIndexNo);
    public int gyg=(string pszValue, CCk= poINDFile, int nIndexNo);
    public sealed virtual void Dispose();
}
internal class HRU=.wiI= : object {
    private static double wyI=;
    public Boolean[0...,0...] xCI=;
    public Boolean[0...,0...] xSI=;
    public Boolean[0...,0...] xiI=;
    public Boolean[0...,0...] xyI=;
    private GridCell[0...,0...] yCI=;
    [CompilerGeneratedAttribute]
private int ySI=;
    [CompilerGeneratedAttribute]
private int yiI=;
    [CompilerGeneratedAttribute]
private bool yyI=;
    public int ziI= { get; private set; }
    public int 0SI= { get; private set; }
    public bool 1CI= { get; private set; }
    public wiI=(GridCell[0...,0...] grid, double noDataValue);
    [CompilerGeneratedAttribute]
public int zCI=();
    [CompilerGeneratedAttribute]
private void zSI=(int value);
    [CompilerGeneratedAttribute]
public int zyI=();
    [CompilerGeneratedAttribute]
private void 0CI=(int value);
    [CompilerGeneratedAttribute]
public bool 0iI=();
    [CompilerGeneratedAttribute]
private void 0yI=(bool value);
    public void 1SI=(int lowwerColumnIndex, int upperColumnIndex, int rowIndex);
    public void 1iI=(int lowwerRowIndex, int upperRowIndex, int ColumnIndex);
    public bool 1yI=(int lowwerColumnIndex, int upperColumnIndex, int rowIndex, double isoValue, LiM= enterDirection);
    public bool 2CI=(int lowwerRowIndex, int upperRowIndex, int ColumnIndex, double isoValue, LiM= enterDirection);
    public bool 2SI=(int lowwerColumnIndex, int upperColumnIndex, int rowIndex, double isoValue, LiM= enterDirection);
    public bool 2iI=(int lowwerRowIndex, int upperRowIndex, int ColumnIndex, double isoValue, LiM= enterDirection);
    public bool 2yI=(int lowwerColumnIndex, int upperColumnIndex, int rowIndex);
    public bool 3CI=(int lowwerRowIndex, int upperRowIndex, int ColumnIndex);
    public GridCell 3SI=(double isoValue, 9yI= enterIndex1, 9yI= enterIndex2, GridCell previousCell);
    public GridCell 3SI=(double isoValue, int pointIndexX1, int pointIndexY1, int pointIndexX2, int pointIndexY2);
    public GridCell 3iI=(int rowIndex, int columnIndex);
    public AiM= 3yI=(int leftTopIndexX, int leftTopIndexY);
    private void 4CI=(GridCell[0...,0...] grid);
    private void 4CI=(GridCell[0...,0...] grid, double noDataValue);
    private bool 4SI=(int lowwerColumnIndex, int upperColumnIndex, int rowIndex);
    private bool 4iI=(int lowwerRowIndex, int upperRowIndex, int ColumnIndex);
    private bool 4yI=(int lowwerColumnIndex, int upperColumnIndex, int rowIndex);
    private bool 5CI=(int lowwerRowIndex, int upperRowIndex, int ColumnIndex);
    private bool 5SI=(int lowwerColumnIndex, int upperColumnIndex, int rowIndex, LiM= enterDirection);
    private bool 5iI=(int lowwerRowIndex, int upperRowIndex, int ColumnIndex, LiM= enterDirection);
    private void 5yI=(int lowwerColumnIndex, int upperColumnIndex, int rowIndex);
    private void 6CI=(int lowwerRowIndex, int upperRowIndex, int ColumnIndex);
    private void 6SI=(int lowwerColumnIndex, int upperColumnIndex, int rowIndex);
    private void 6iI=(int lowwerRowIndex, int upperRowIndex, int ColumnIndex);
    private static bool 6yI=(double isoValue1, double isoValue2, double destIsoValue);
}
[DefaultMemberAttribute("Item")]
internal class HRU=.WiI= : object {
    private Double[0...,0...] WyI=;
    public double xhw= { get; public set; }
    public int XiI= { get; public set; }
    public int YSI= { get; public set; }
    public Double[0...,0...] YyI= { get; }
    public WiI=(int noRows, int noCols);
    public WiI=(Double[0...,0...] Mat);
    public double xBw=(int Row, int Col);
    public void xRw=(int Row, int Col, double value);
    public int XCI=();
    public void XSI=(int value);
    public int XyI=();
    public void YCI=(int value);
    public Double[0...,0...] YiI=();
    private static void ZCI=(Double[] Mat, Int32& Row);
    private static void ZCI=(Double[0...,0...] Mat, Int32& Row, Int32& Col);
    public static Double[0...,0...] ZSI=(Double[] Mat);
    public static Double[] ZiI=(Double[0...,0...] Mat);
    public static Double[0...,0...] ZyI=(int n);
    public static Double[0...,0...] aCI=(Double[0...,0...] Mat1, Double[0...,0...] Mat2);
    public static WiI= aCI=(WiI= Mat1, WiI= Mat2);
    public static WiI= 0xM=(WiI= Mat1, WiI= Mat2);
    public static Double[0...,0...] aSI=(Double[0...,0...] Mat1, Double[0...,0...] Mat2);
    public static WiI= aSI=(WiI= Mat1, WiI= Mat2);
    public static WiI= 1RM=(WiI= Mat1, WiI= Mat2);
    public static Double[0...,0...] aiI=(Double[0...,0...] Mat1, Double[0...,0...] Mat2);
    public static WiI= aiI=(WiI= Mat1, WiI= Mat2);
    public static WiI= 1xM=(WiI= Mat1, WiI= Mat2);
    public static double ayI=(Double[0...,0...] Mat);
    public static double ayI=(WiI= Mat);
    public static Double[0...,0...] bCI=(Double[0...,0...] Mat);
    public static WiI= bCI=(WiI= Mat);
    public static Double[0...,0...] bSI=(Double[0...,0...] Mat);
    public static WiI= bSI=(WiI= Mat);
    public static void biI=(Double[0...,0...] Mat_, Double[0...,0...]& S_, Double[0...,0...]& U_, Double[0...,0...]& V_);
    private static double byI=(double a);
    private static double cCI=(double a, double b);
    private static double cSI=(double a, double b);
    public static void biI=(WiI= Mat, WiI=& S, WiI=& U, WiI=& V);
    public static void ciI=(Double[0...,0...] Mat, Double[0...,0...]& L, Double[0...,0...]& U, Double[0...,0...]& P);
    private static void cyI=(Double[0...,0...] Mat, int Row, int toRow);
    public static void ciI=(WiI= Mat, WiI=& L, WiI=& U, WiI=& P);
    public static Double[0...,0...] dCI=(Double[0...,0...] MatA, Double[0...,0...] MatB);
    public static WiI= dCI=(WiI= MatA, WiI= MatB);
    public static int dSI=(Double[0...,0...] Mat);
    public static int dSI=(WiI= Mat);
    public static Double[0...,0...] diI=(Double[0...,0...] Mat);
    public static WiI= diI=(WiI= Mat);
    public static void dyI=(Double[0...,0...] Mat, Double[0...,0...]& d, Double[0...,0...]& v);
    private static void eCI=(double g, double h, double s, double tau, Double[0...,0...] a, int i, int j, int k, int l);
    public static void dyI=(WiI= Mat, WiI=& d, WiI=& v);
    public static Double[0...,0...] eSI=(double Value, Double[0...,0...] Mat);
    public static WiI= eSI=(double Value, WiI= Mat);
    public static WiI= 1xM=(WiI= Mat, double Value);
    public static WiI= 1xM=(double Value, WiI= Mat);
    public static Double[0...,0...] eiI=(double Value, Double[0...,0...] Mat);
    public static WiI= eiI=(double Value, WiI= Mat);
    public static WiI= 5hM=(WiI= Mat, double Value);
    public static Double[] eyI=(Double[] V1, Double[] V2);
    public static Double[0...,0...] eyI=(Double[0...,0...] V1, Double[0...,0...] V2);
    public static WiI= eyI=(WiI= V1, WiI= V2);
    public static double fCI=(Double[] V1, Double[] V2);
    public static double fCI=(Double[0...,0...] V1, Double[0...,0...] V2);
    public static double fCI=(WiI= V1, WiI= V2);
    public static double fSI=(Double[] V);
    public static double fSI=(Double[0...,0...] V);
    public static double fSI=(WiI= V);
    public static bool fiI=(Double[0...,0...] Mat1, Double[0...,0...] Mat2);
    public static bool fiI=(WiI= Mat1, WiI= Mat2);
    public static bool 3hM=(WiI= Mat1, WiI= Mat2);
    public static bool 3xM=(WiI= Mat1, WiI= Mat2);
    public virtual bool Equals(object obj);
    public static string fyI=(Double[0...,0...] Mat);
    public static string fyI=(WiI= Mat);
    public virtual string ToString();
    public virtual int GetHashCode();
}
internal interface HRU=.wiU= {
    public int xSU= { get; public set; }
    public Iis= yCU= { get; public set; }
    public abstract virtual int wyU=();
    public abstract virtual void xCU=(int value);
    public abstract virtual Iis= xiU=();
    public abstract virtual void xyU=(Iis= value);
    public abstract virtual int ySU=();
    public abstract virtual Iis= yiU=();
    public abstract virtual short yyU=();
    public abstract virtual short zCU=();
    public abstract virtual int zSU=();
    public abstract virtual void ziU=(short val);
    public abstract virtual void zyU=(short val);
    public abstract virtual void 0CU=(int clr);
    public abstract virtual string 0SU=(double dfAngle);
    public abstract virtual void 0iU=(string pszStyleString);
    public abstract virtual void 0yU=(Stream fpOut);
}
internal enum HRU=.wiY= : Enum {
    public int value__;
    public static wiY= wyY=;
}
internal class HRU=.wRU= : MulticastDelegate {
    public wRU=(object object, IntPtr method);
    public virtual object Invoke(Object[] args);
    public virtual IAsyncResult BeginInvoke(Object[] args, AsyncCallback callback, object object);
    public virtual object EndInvoke(IAsyncResult result);
}
internal class HRU=.WS0= : object {
    private int Wi0=;
    private double /yw=;
    [CompilerGeneratedAttribute]
private List`1<nyw=> Wy0=;
    [CompilerGeneratedAttribute]
private int XC0=;
    [CompilerGeneratedAttribute]
private short XS0=;
    [CompilerGeneratedAttribute]
private short Xi0=;
    public List`1<nyw=> YS0= { get; public set; }
    public int ZC0= { get; private set; }
    public short Zy0= { get; private set; }
    public short ai0= { get; private set; }
    public WS0=(double extentWidthLimitation);
    [CompilerGeneratedAttribute]
public void YC0=(List`1<nyw=> value);
    [CompilerGeneratedAttribute]
public List`1<nyw=> Xy0=();
    [CompilerGeneratedAttribute]
private void Yy0=(int value);
    [CompilerGeneratedAttribute]
public int Yi0=();
    [CompilerGeneratedAttribute]
private void Zi0=(short value);
    [CompilerGeneratedAttribute]
public short ZS0=();
    [CompilerGeneratedAttribute]
private void aS0=(short value);
    [CompilerGeneratedAttribute]
public short aC0=();
    public bool ay0=(double LoCenter, double LaCenter, int BitsPerCoord, Dictionary`2<string, int> lableDictnory);
}
internal class HRU=.WSI= : Exception {
}
internal enum HRU=.wSY= : Enum {
    public int value__;
    public static wSY= NSU=;
    public static wSY= NiU=;
    public static wSY= NyU=;
    public static wSY= OCU=;
    public static wSY= OSU=;
    public static wSY= OiU=;
    public static wSY= OyU=;
    public static wSY= PCU=;
    public static wSY= PSU=;
    public static wSY= PiU=;
    public static wSY= PyU=;
    public static wSY= QCU=;
}
internal enum HRU=.wy8= : Enum {
    public int value__;
    public static wy8= vC8=;
    public static wy8= vS8=;
    public static wy8= xC8=;
    public static wy8= xS8=;
    public static wy8= xi8=;
}
internal class HRU=.Wyc= : object {
    private string XCc=;
    private wSY= XSc=;
    private int Xic=;
    private int Xyc=;
    public Wyc=(string pszNameIn, wSY= eTypeIn);
    private void 5Bw=(string pszNameIn, wSY= eTypeIn);
    public void YCc=(string pszNameIn);
    public string YSc=();
    public wSY= Yic=();
    public static string Yyc=(wSY= eType);
    public int SBU=();
    public void ZCc=(int nWidthIn);
    public int ZSc=();
    public void Zic=(int nPrecisionIn);
}
internal class HRU=.Wyk= : CyU= {
    private static int Eyg=;
    private static int FCg=;
    private static int Eig=;
    public Encoding FR8=;
    private int XCk=;
    private Stream Wyg=;
    private FSg= 8iU=;
    private Lig= CSk=;
    private mSk= XSk=;
    private uSk= Xik=;
    private bool Xyk=;
    private Ayk= YCk=;
    private 7Ck= YSk=;
    private int Yik=;
    private int Yyk=;
    private int ZCk=;
    private Nik= ZSk=;
    private Vys= Zik=;
    private bys= Zyk=;
    private bys= aCk=;
    private int aSk=;
    private int aik=;
    private int ayk=;
    private int bCk=;
    private uSk= bSk=;
    private int bik=(bool bDeleteObjects);
    private int byk=(int nBlockPtr);
    private 7Ck= cCk=(CSo= poObjHdrToAdd, int nSizeOfObjToAdd);
    private int cSk=(CSo= poObjHdr, Nik= poSrcCoordBlock, 7Ck= poDstObjBlock, Nik= ppoDstCoordBlock);
    private int cik=(int nObjType, 7Ck= poObjBlock, Nik=& ppoCoordBlock);
    private int cyk=();
    private int dCk=();
    private int dSk=();
    private int dik=(int bFirstObject);
    private zSo= dyk=(int nFileOffset);
    public int GR8=(string pszFname, FileAccess pszAccess, bool bNoErrorMsg);
    public int pR8=();
    public int eCk=(bool bQuickSpatialIndexMode);
    public int eSk=(int nX, int nY, Double& dX, Double& dY);
    public int eik=(double dX, double dY, Int32& nX, Int32& nY, bool bIgnoreOverflow);
    public int eyk=(int nX, int nY, Double& dX, Double& dY);
    public int fCk=(double dX, double dY, Int32& nX, Int32& nY);
    public void fSk=(bys= sMin, bys= sMax);
    public void fik=(bys=& sMin, bys=& sMax);
    public void fyk=();
    public int gCk=(double dXMin, double dYMin, double dXMax, double dYMax);
    public int gSk=(int nObjId);
    public void gik=(byte nObjType);
    public int gyk=(CSo= poObjHdr);
    public int hCk=(CSo= poObjHdr);
    public int hSk=(CSo= poObjHdr);
    public int hik=(CSo= poObjHdr);
    public void hyk=();
    public int iCk=(int nPrevId);
    public int iSk=();
    public int iik=();
    public 7Ck= iyk=();
    public Nik= jCk=();
    public Nik= jSk=(int nFileOffset);
    public mSk= jik=();
    public zSo= jyk=(int nFileOffset);
    public int kCk=(int nPenIndex, Pyo= psDef);
    public int kSk=(int nBrushIndex, OSg= psDef);
    public int kik=(int nFontIndex, 4Cg= psDef);
    public int kyk=(int nSymbolIndex, Iis= psDef);
    public int lCk=(Pyo= psDef);
    public int lSk=(OSg= psDef);
    public int lik=(4Cg= psDef);
    public int lyk=(Iis= psDef);
    public int mCk=();
    public sealed virtual void Dispose();
}
internal enum HRU=.wys= : Enum {
    public int value__;
    public static wys= xCs=;
    public static wys= xSs=;
    public static wys= xis=;
    public static wys= xys=;
    public static wys= yCs=;
}
internal class HRU=.XBg= : object {
    private Int32[] XRg=;
    private int Xhg=;
    private List`1<gRo=> Xxg=;
    private string YBg=;
    private List`1<gRo=> YRg=;
    private double Yhg=;
    private double Yxg=;
    private bool ZBg=(Double[] height, bool z_is_temp, Int32& pj_Error);
    internal int ZRg=(jBo= srcdefn, jBo= dstdefn, long point_count, int point_offset, Double[] height, jxo=[] uvList, Int32& pj_Error);
    internal static Dictionary`2<string, string> Zhg=(String[] args);
    internal static void Zxg=(Dictionary`2<string, string> paras, string arg);
    internal int aBg=(jBo= srcdefn, jBo= dstdefn, long point_count, int point_offset, jxo=[] uvList, Double[] height, Int32& pj_Error);
    internal int aRg=(double a, double es, long point_count, int point_offset, jxo=[] uvList, Double[] height, Int32& pj_Error);
    private long ahg=(VRg= gi, double a, double b);
    private void axg=(VRg= gi, double x, double y, double z, jxo=[] uv, Double[] height, long io, Int32& pj_Error);
    private mhg= bBg=(mRo= xy, jBo= p, Int32& pj_Error);
    private mRo= bRg=(double phi, double lambda, double lambda0);
    private double bhg=(double phi);
    private mhg= bxg=(double x, double y, double cmeridian);
    private double cBg=(double y);
    private double cRg=(int zone);
    private double chg=(double deg);
    private double cxg=(double rad);
    private int dBg=(double lat, double lon, int zone, mRo=& xy);
    private mRo= dRg=(mhg= geodetic_loc, jBo= dstdefn, Int32& pj_Error);
    private int dhg=(jBo= dstdefn, long point_count, int point_offset, jxo=[] list, Double[] height, Int32& pj_Error);
    private int dxg=(jBo= srcdefn, long point_count, int point_offset, jxo=[] list, Double[] height, Int32& pj_Error);
    internal int eBg=(double src_a, double src_es, long point_count, int point_offset, jxo=[] list, Double[] height, Int32& pj_Error);
    private bool eRg=(VRg= gi, jxo=[] projUV, Double[] height, long io, Int32& pj_Error);
    private int ehg=(string nadgrids, int inverse, long point_count, int point_offset, jxo=[] uvList, Double[] height, Int32& pj_Error);
    private mhg= exg=(mhg= input, int inverse, VRc= ct, Int32& pj_Error);
    private mhg= fBg=(mhg= tb, VRc= ct);
    private bool fRg=(gRo= gi, Int32& pj_Error);
    private List`1<gRo=> fhg=(string nadgrids, Int32& grid_count, Int32& pj_Error);
    private bool fxg=(jBo= srcdefn, jBo= dstdefn, Int32& pj_Error);
    private int gBg=(string gridName, Int32& pj_Error);
    private void gRg=(string gridName, List`1<gRo=> giList, Int32& pj_Error);
    private void ghg=(Stream fs, gRo= gi, List`1<gRo=> giList, Int32& pj_Error);
    private void gxg=(Stream fs, gRo= gi, Int32& pj_Error);
}
internal class HRU=.XBo= : jBo= {
    internal double wRk=;
    internal double Bhk=;
    internal double Bxk=;
    internal double Nxk=;
    internal double whk=;
    internal double wxk=;
    internal double xBk=;
    internal double Thg=;
    internal double xRk=;
    internal double xhk=;
    internal double xxk=;
    internal double yBk=;
    internal int DRk=;
    internal int yRk=;
    internal XBo=(string id, string desc);
    private void 9xg=();
    internal virtual whg= /Bg=(whg= pjConsts, Int32& pj_Error);
    internal virtual void Axk=(mhg= lp, whg= pjConsts, TRg= fac, Int32& pj_Error);
    internal virtual mhg= ARk=(mRo= xy, whg= pjConsts, Int32& pj_Error);
    internal virtual mRo= Ahk=(mhg= lp, whg= pjConsts, Int32& pj_Error);
}
internal class HRU=.xC4= : object {
    private BinaryReader nyE=;
    private Bi8= xS4=;
    private 2i4= xi4=;
    private ty4= xy4=;
    private double yS0=;
    public xC4=(Stream stream, Bi8= trebody, 2i4= header, ty4= lblBody, double extentWidthLimitation);
    private List`1<Feature> yC4=(4S4= subdivision, IEnumerable`1<string> recordIndexes, Dictionary`2<string, int> returningColumns, zyw= encryptor);
    private List`1<Feature> yC4=(4S4= subdivision, OS4= range, Dictionary`2<string, int> returningColumns, zyw= encryptor);
    private Byte[] yS4=(Si4= point, int latitutde, int longitude);
    private Byte[] yi4=(List`1<Si4=> points, int latitutde, int longitude);
    private Byte[] yy4=(List`1<Si4=> points, int latitutde, int longitude);
    private void zC4=(List`1<Si4=> points, Int32& latitutde, Int32& longitude, Byte[] wkb, int startPosition);
    private static void zS4=(double latitutde, double longitude, Byte[] wkb, int startPosition, int i);
    private string zi4=(int offset, zyw= encryptor);
    public void zy4=(int index, BinaryWriter bw, string password, USw= encryptMode);
    private void 0C4=(4i4= subDefine, int nextSubAbsSubOffset, BinaryWriter bw, string password, USw= encryptMode);
    private void zy4=(iCw= shapeType, int nextSubAbsSubOffset, int rgnEndOffset, BinaryWriter bw, string password, USw= encryptMode);
    private void 0S4=(BinaryWriter bw, zyw= encryptor);
    private void 0i4=(BinaryWriter bw, zyw= encryptor);
    private void 0y4=(BinaryWriter bw, zyw= encryptor);
    private void 1C4=(BinaryWriter bw, zyw= encryptor);
    private void 1S4=(BinaryWriter bw, zyw= encryptor);
    private void 1i4=(BinaryWriter bw, zyw= encryptor);
    private static Byte[] jy4=(Byte[] inputBytes, zyw= encryptor);
    private static Byte[] mxQ=(Byte[] inputBytes, zyw= encryptor);
    private Byte[] 7xM=(int bitstreamLength);
    public List`1<Feature> 1y4=(OS4= range, int subdivisionIndex, Dictionary`2<string, int> returningColumns, zyw= encryptor);
    public List`1<Feature> 1y4=(IEnumerable`1<string> featureIds, Dictionary`2<string, int> returningColumns, zyw= encryptor);
    private 4S4= 2C4=(4i4= subDefine, int nextSubAbsSubOffset, zyw= encryptor);
    private void 2C4=(iCw= shapeType, 4S4= subdivision, int nextSubAbsSubOffset, int rgnEndOffset, byte shfitBits, zyw= encryptor);
    private static void 2S4=(byte bitstreamInfo, Byte[] bitstream, byte shiftbits, List`1<Si4=> points);
}
internal enum HRU=.xCY= : Enum {
    public int value__;
    public static xCY= xSY=;
    public static xCY= xiY=;
    public static xCY= xyY=;
    public static xCY= yCY=;
    public static xCY= ySY=;
    public static xCY= yiY=;
}
internal class HRU=.Xhk= : jBo= {
    internal double Bhk=;
    internal double Bxk=;
    internal int DRk=;
    internal Xhk=(string id, string desc);
    private void 9xg=();
    internal virtual whg= /Bg=(whg= pjConsts, Int32& pj_Error);
    internal virtual void Axk=(mhg= lp, whg= pjConsts, TRg= fac, Int32& pj_Error);
    internal virtual mhg= ARk=(mRo= xy, whg= pjConsts, Int32& pj_Error);
    internal virtual mRo= Ahk=(mhg= lp, whg= pjConsts, Int32& pj_Error);
}
internal class HRU=.Xho= : jBo= {
    internal double Rhk=;
    internal double Xxo=;
    internal double YBo=;
    internal double gxc=;
    internal Xho=(string id, string desc);
    private void 9xg=();
    internal virtual whg= /Bg=(whg= pjConsts, Int32& pj_Error);
    internal virtual void Axk=(mhg= lp, whg= pjConsts, TRg= fac, Int32& pj_Error);
    internal virtual mhg= ARk=(mRo= xy, whg= pjConsts, Int32& pj_Error);
    internal virtual mRo= Ahk=(mhg= lp, whg= pjConsts, Int32& pj_Error);
}
internal class HRU=.xiQ= : object {
    public static int pCQ=;
    public int xyQ=;
    public niQ= yCQ=;
    public yyQ= ySQ=;
    public StringBuilder yiQ=;
    private static xiQ=();
}
internal class HRU=.XRk= : jBo= {
    internal XRk=(string id, string desc);
    private void 9xg=();
    internal virtual whg= /Bg=(whg= pjConsts, Int32& pj_Error);
    internal virtual void Axk=(mhg= lp, whg= pjConsts, TRg= fac, Int32& pj_Error);
    internal virtual mhg= ARk=(mRo= xy, whg= pjConsts, Int32& pj_Error);
    internal virtual mRo= Ahk=(mhg= lp, whg= pjConsts, Int32& pj_Error);
}
internal class HRU=.XRo= : jBo= {
    internal double Nxo=;
    internal double OBo=;
    internal double ORo=;
    internal double Oho=;
    internal int DRk=;
    internal XRo=(string id, string desc);
    private void 9xg=();
    internal virtual whg= /Bg=(whg= pjConsts, Int32& pj_Error);
    internal virtual void Axk=(mhg= lp, whg= pjConsts, TRg= fac, Int32& pj_Error);
    internal virtual mhg= ARk=(mRo= xy, whg= pjConsts, Int32& pj_Error);
    internal virtual mRo= Ahk=(mhg= lp, whg= pjConsts, Int32& pj_Error);
    private double Oxo=(double phit, double sinphi, double eccen, Int32& pj_Error);
    private mRo= Exk=(mhg= lp, whg= pjConsts, Int32& pj_Error);
    private mRo= ERk=(mhg= lp, whg= pjConsts, Int32& pj_Error);
    private mhg= EBk=(mRo= xy, whg= pjConsts, Int32& pj_Error);
    private mhg= Dhk=(mRo= xy, whg= pjConsts, Int32& pj_Error);
}
internal class HRU=.XRY= : object {
    private static double XhY=;
    private static int XxY=;
    private static int YBY=;
    private static int YRY=;
    private static int YhY=;
    private static int YxY=;
    private static int ZBY=;
    private static int ZRY=;
    private static int ZhY=;
    private static int ZxY=;
    private static int aBY=;
    private static int aRY=;
    private static int ahY=;
    private static int axY=;
    private static int bBY=;
    private static int bRY=;
    private static int bhY=;
    private static int bxY=;
    private static int cBY=;
    private static int cRY=;
    private static int chY=;
    private static int cxY=;
    private static int dBY=;
    private static int dRY=;
    private static int dhY=;
    private static int dxY=;
    private static int eBY=;
    private static String[] eRY=;
    internal Fxc= ehY=;
    private bool exY=;
    private double fBY=;
    private double fRY=;
    private double fhY=;
    private IFormatProvider fxY=;
    internal static String[] gBY=;
    internal static String[] gRY=;
    internal static String[] ghY=;
    internal static String[] gxY=;
    internal static String[] hBY=;
    internal static String[] hRY=;
    internal static String[] hhY=;
    internal static String[] hxY=;
    internal static String[] iBY=;
    internal static String[] iRY=;
    internal static String[] ihY=;
    internal static String[] ixY=;
    internal static String[] jBY=;
    internal static String[] jRY=;
    internal static String[] jhY=;
    internal static String[] jxY=;
    internal static String[] kBY=;
    private static string kRY=;
    private static String[] khY=;
    private static object kxY=;
    private static List`1<KBc=> lBY=;
    internal static String[] lhY= { get; }
    internal static List`1<KBc=> mBY= { get; }
    internal XRY=(IFormatProvider inputProvider);
    private static XRY=();
    private static void mRY=(String& datum);
    private static double mhY=(string angleValue, int uomAngle, IFormatProvider provider);
    private static bool mxY=(int nUOMAngleCode, String& ppszUOMName, Double& pdfInDegrees, IFormatProvider provider);
    private static bool nBY=(int uomLengthCode, String& uomName, Double& inMeters, IFormatProvider provider);
    internal static bool nRY=(int geogCS, Double[] padTransform, IFormatProvider provider);
    private static bool nhY=(int pmCode, String& name, Double& offset, IFormatProvider provider);
    internal static bool nxY=(int code, String& refName, Int32& refDatum, String& refDatumName, Int32& refPM, Int32& refEllipsoid, Int32& refUOMAngle, Int32& refCoordSysCode, IFormatProvider provider);
    private static void oBY=(int code, String& ellipseName, Double& semiMajor, Double& invFlattening, IFormatProvider provider);
    private static bool oRY=(int pcsCode, Int32& projMethod, Int32[] parmIds, Double[] projParms, IFormatProvider provider);
    internal static bool ohY=(int pcsCode, String& epsgName, Int32& uomLengthCode, Int32& uomAngleCode, Int32& geogCS, Int32& pnTRFCode, Int32& pnCoordSysCode, IFormatProvider provider);
    private static void oxY=(XRY= srs, string targetKey, int cooridSysCode, IFormatProvider provider);
    private static double pBY=(Double[] padfProjParms, Int32[] panParmIds, int nTargetId, double dfFromGreenwich);
    internal static void pRY=(XRY= srs, int geogCS, IFormatProvider provider);
    internal static void phY=(XRY= srs, int pcsCode, IFormatProvider provider);
    private bool pxY=(int code, IFormatProvider provider);
    private bool qBY=(int code, IFormatProvider provider);
    private bool qRY=(string fileName, int code);
    private void axU=();
    internal Fxc= qhY=(string nodePath);
    private string qxY=(string nodeName);
    private string qxY=(string nodeName, int valueIndex);
    internal string rBY=();
    internal void rRY=(string wkt);
    private void rhY=(string nodePath, string nodeValue);
    private void rxY=(string name, double inRadians);
    private double sBY=(String& parameterName);
    private void sRY=(string unitName, double inMeter);
    private double shY=();
    private double shY=(String& parameterName);
    private double sxY=();
    private double sxY=(String& parameterName);
    internal void tBY=(string geogName, string datumName, string spheroidName, double semiMajor, double invFlattening, string pmName, double pmOffset);
    internal void tBY=(string geogName, string datumName, string spheroidName, double semiMajor, double invFlattening, string pmName, double pmOffset, string angularUnits, double convertToRadians);
    private void tRY=(string nameValue, IFormatProvider provider);
    private void thY=(XRY= other);
    private double txY=();
    private double uBY=();
    private double uRY=();
    private void uhY=(string projection);
    private void uxY=(string parmName, double defaultValue);
    private int vBY=(string parameterName);
    private int vBY=(string parameterName, Fxc= projCSnode);
    private double vRY=(string parameterName, double defaultValue);
    private double vRY=(string parameterName, double defaultValue, Boolean& isSucceed);
    private double vhY=(string parameterName, double defaultValue);
    private void vxY=(string name, double value);
    private void wBY=(double dfCenterLat, double dfCenterLong, double dfScale, double dfFalseEasting, double dfFalseNorthing);
    private void wRY=(double dfCenterLat, double dfCenterLong, double dfScale, double dfFalseEasting, double dfFalseNorthing);
    private void whY=(double dfLat1, double dfLong1, double dfLat2, double dfLong2, double dfFalseEasting, double dfFalseNorthing);
    private void wxY=(double dfCenterLat, double dfCenterLong, double dfFalseEasting, double dfFalseNorthing);
    private void xBY=(double dfStdP1, double dfStdP2, double dfCenterLat, double dfCenterLong, double dfFalseEasting, double dfFalseNorthing);
    private void xRY=(double dfCenterLat, double dfCenterLong, double dfFalseEasting, double dfFalseNorthing);
    private void xhY=(double stdP1, double centralMeridian, double falseEasting, double falseNorthing);
    private void xxY=(double dfStdP1, double dfCentralMeridian, double dfFalseEasting, double dfFalseNorthing);
    private void yBY=(double centerLat, double centerLong, double falseEasting, double falseNorthing);
    private void yRY=(double dfStdP1, double dfStdP2, double dfCenterLat, double dfCenterLong, double dfFalseEasting, double dfFalseNorthing);
    private void yhY=(int nVariation, double dfCentralMeridian, double dfFalseEasting, double dfFalseNorthing);
    private void yxY=(double dfCenterLat, double dfCenterLong, double dfFalseEasting, double dfFalseNorthing);
    private void zBY=(double dfCenterLat, double dfCenterLong, double dfStdParallel1, double dfFalseEasting, double dfFalseNorthing);
    private void zRY=(double dfCentralMeridian, double dfFalseEasting, double dfFalseNorthing);
    private void zhY=(double dfCentralMeridian, double dfFalseEasting, double dfFalseNorthing);
    private void zxY=(double dfCentralMeridian, double dfSatelliteHeight, double dfFalseEasting, double dfFalseNorthing);
    private void 0BY=(double dfCenterLat, double dfCenterLong, double dfScale, double dfFalseEasting, double dfFalseNorthing);
    private void 0RY=(double dfCenterLat, double dfCenterLong, double dfFalseEasting, double dfFalseNorthing);
    private void 0hY=(double dfCenterLat, double dfCenterLong, double dfAzimuth, double dfRectToSkew, double dfScale, double dfFalseEasting, double dfFalseNorthing);
    private void 0xY=(double dfLat1, double dfLat2, double dfCenterLong, double dfFalseEasting, double dfFalseNorthing);
    private void 1BY=(double dfCenterLat, double dfCenterLong, double dfAzimuth, double dfPseudoStdParallel1, double dfScale, double dfFalseEasting, double dfFalseNorthing);
    private void 1RY=(double dfCenterLat, double dfCenterLong, double dfFalseEasting, double dfFalseNorthing);
    private void 1hY=(double dfStdP1, double dfStdP2, double dfCenterLat, double dfCenterLong, double dfFalseEasting, double dfFalseNorthing);
    private void 1xY=(double dfCenterLat, double dfCenterLong, double dfScale, double dfFalseEasting, double dfFalseNorthing);
    private void 2BY=(double dfStdP1, double dfStdP2, double dfCenterLat, double dfCenterLong, double dfFalseEasting, double dfFalseNorthing);
    private void 2RY=(double dfCenterLat, double dfCenterLong, double dfFalseEasting, double dfFalseNorthing);
    private void 2hY=(double dfCenterLat, double dfCenterLong, double dfScale, double dfFalseEasting, double dfFalseNorthing);
    private void 2xY=(double dfStdP1, double dfCenterLat, double dfCenterLong, double dfFalseEasting, double dfFalseNorthing);
    private void 3BY=(double dfCentralMeridian, double dfFalseEasting, double dfFalseNorthing);
    private void 3RY=(double dfCenterLat, double dfCenterLong, double dfFalseEasting, double dfFalseNorthing);
    private void 3hY=(double dfOriginLat, double dfCMeridian, double dfScale, double dfFalseEasting, double dfFalseNorthing);
    private void 3xY=(double dfCenterLat, double dfCenterLong, double dfFalseEasting, double dfFalseNorthing);
    private void 4BY=(double dfCenterLat, double dfCenterLong, double dfFalseEasting, double dfFalseNorthing);
    private void 4RY=(double dfCenterLat, double dfCenterLong, double dfScale, double dfFalseEasting, double dfFalseNorthing);
    private void 4hY=(double dfCenterLong, double dfFalseEasting, double dfFalseNorthing);
    private void 4xY=(double dfCenterLong, double dfFalseEasting, double dfFalseNorthing);
    private void 5BY=(double dfOriginLat, double dfCMeridian, double dfScale, double dfFalseEasting, double dfFalseNorthing);
    private void 5RY=(double dfLatitudeOfOrigin, double dfCentralMeridian, double dfFalseEasting, double dfFalseNorthing);
    private void 5hY=(double dfCMeridian, double dfFalseEasting, double dfFalseNorthing);
    private void 5xY=(int nZone, int isNorth);
    private int 6BY=(Boolean& isNorth);
    private void 6RY=(int nVariation, double dfCenterLat, double dfFalseEasting, double dfFalseNorthing);
    internal void 6hY=(string targetKey, string authority, int code);
    private string 6xY=(string targetKey);
    private string 7BY=(string targetKey);
    private bool 7RY=();
    private bool 7hY=();
    private bool 7xY=();
    private void 8BY=(double x, double y, double z);
    private void 8BY=(double x, double y, double z, double eX, double eY, double eZ, double ppm);
    private bool 8RY=(string parameterName);
    private static bool 8hY=(string parameterName);
    private void 8xY=();
    private void 9BY=();
    private string 9RY=(string targetKey, string extensionName, string defaultValue);
    private void 9hY=(string targetKey, string name, string value);
    internal void 9xY=(string targetKey, string xAxisName, 5xU= xAxisOrientation, string yAxisName, 5xU= yAxisOrientation);
    private void /BY=();
    private void /RY=();
    private void /RY=(Fxc= currentNode);
    private void /hY=();
    private static double /xY=(string valueString, IFormatProvider provider);
    private static int ABc=(string valueString, IFormatProvider provider);
    private static void ARc=(String& name);
    private static void Ahc=();
    private static string Axc=(string name);
    internal void BBc=();
    internal void BRc=(string wkt);
    private void Bhc=();
    private static void Bxc=(XRY= ogr, string keyName, string newName);
    private static int CBc=(XRY= ogr, string name, string keyName, String[] mappingTable);
    private static int CRc=(XRY= ogr, string name1, string name2, String[] mappingTable, int tableStepSize, String[] keyNames, int keys);
    private static int Chc=(XRY= ogr, string projCSName, String[] mappingTable);
    private static int Cxc=(XRY= ogr, string projCSName, String[] mappingTable);
    private static int DBc=(XRY= ogr, string projectionName, String[] mappingTable);
    private static int DRc=(XRY= ogr, string projectionName, String[] mappingTable);
    private static int Dhc=(XRY= ogr, string geogcsName);
    internal static String[] lRY=();
    internal static List`1<KBc=> lxY=();
    private static string Dxc=(string datunName, int epsgDatum);
    private String[] EBc=(string proj4String);
    private static double ERc=(String[] source, string field, double defaultValue, IFormatProvider provider);
    private static string Ehc=(string value, string field);
    internal void Exc=(string proj4String);
    internal string FBc=();
    private static string FRc=(String[] source, string name);
    private static double Fhc=(string value, IFormatProvider provider);
}
internal class HRU=.xSc= : 3Cc= {
    public tSc=[] xic=;
    private uCc=[] wCc=;
    public virtual int kxU=();
}
internal class HRU=.xSM= : object {
    [CompilerGeneratedAttribute]
private List`1<ySM=> vyM=;
    [CompilerGeneratedAttribute]
private List`1<vCM=> xiM=;
    [ObfuscationAttribute]
[JsonPropertyNameAttribute("links")]
public List`1<ySM=> Links { get; public set; }
    [ObfuscationAttribute]
[JsonPropertyNameAttribute("collections")]
public List`1<vCM=> Collections { get; public set; }
    public xSM=(List`1<ySM=> links, List`1<vCM=> collections);
    [CompilerGeneratedAttribute]
public List`1<ySM=> get_Links();
    [CompilerGeneratedAttribute]
public void set_Links(List`1<ySM=> value);
    [CompilerGeneratedAttribute]
public List`1<vCM=> get_Collections();
    [CompilerGeneratedAttribute]
public void set_Collections(List`1<vCM=> value);
}
internal class HRU=.Xxk= : jBo= {
    internal Double[] 9Rg=;
    internal double Rhk=;
    internal double gxc=;
    internal double thc=;
    internal double txc=;
    internal Xxk=(string id, string desc);
    private void 9xg=();
    internal virtual whg= /Bg=(whg= pjConsts, Int32& pj_Error);
    internal virtual void Axk=(mhg= lp, whg= pjConsts, TRg= fac, Int32& pj_Error);
    internal virtual mhg= ARk=(mRo= xy, whg= pjConsts, Int32& pj_Error);
    internal virtual mRo= Ahk=(mhg= lp, whg= pjConsts, Int32& pj_Error);
}
internal enum HRU=.xy8= : Enum {
    public int value__;
    public static xy8= vC8=;
    public static xy8= vS8=;
    public static xy8= yC8=;
    public static xy8= vy8=;
    public static xy8= wC8=;
    public static xy8= wS8=;
    public static xy8= yS8=;
}
internal class HRU=.xyc= : object {
    private 1yc= yCc=;
    private string ySc=;
    public xyc=(1yc= poDataSetStyleTable);
    public bool yic=(string pszStyleString);
    public string yyc=(string pszStyleName);
    public int zCc=(string pszStyleString);
    public 3Cc= zSc=(int hPartId, string pszStyleString);
    public 3Cc= zic=(string pszStyleString);
}
internal class HRU=.xyM= : object {
    [CompilerGeneratedAttribute]
private zSM= yCM=;
    [JsonPropertyNameAttribute("spatial")]
[ObfuscationAttribute]
public zSM= Spatial { get; public set; }
    public xyM=(zSM= spatial);
    [CompilerGeneratedAttribute]
public zSM= get_Spatial();
    [CompilerGeneratedAttribute]
public void set_Spatial(zSM= value);
}
internal class HRU=.YBk= : jBo= {
    internal jBo= YRk=;
    internal jBo= Yhk=;
    internal YBk=(string id, string desc);
    internal void 9xg=();
    internal virtual whg= /Bg=(whg= pjConsts, Int32& pj_Error);
    internal virtual mhg= ARk=(mRo= xy, whg= pjConsts, Int32& pj_Error);
    internal virtual mRo= Ahk=(mhg= lp, whg= pjConsts, Int32& pj_Error);
    internal virtual void Axk=(mhg= lp, whg= pjConsts, TRg= fac, Int32& pj_Error);
}
internal class HRU=.YBU= : object {
    private static ConcurrentDictionary`2<GeoFont, SKTypeface> YRU=;
    private SKBitmap YhU=;
    private SKCanvas YxU=;
    private bool ZBU=;
    private bool ZRU=;
    private float ZhU=;
    [CompilerGeneratedAttribute]
private SKFilterQuality ZxU=;
    public SKFilterQuality ahU= { get; public set; }
    public YBU=(GeoImage image);
    private static YBU=();
    [CompilerGeneratedAttribute]
public SKFilterQuality aBU=();
    [CompilerGeneratedAttribute]
public void aRU=(SKFilterQuality value);
    public void axU=(GeoColor color);
    public void bBU=();
    public void bRU=(float dx, float dy);
    public void bhU=(float angle);
    public void TBU=();
    public void bxU=();
    public void XRU=(GeoImage image, int srcX, int srcY, int srcWidth, int srcHeight, mxU=[] colors);
    public void TxU=(GeoImage image, float x, float y);
    public void TxU=(GeoImage image, DrawingRectangleF destRect, DrawingRectangleF srcRect);
    public void TxU=(GeoImage image, float x, float y, float width, float height);
    public void cBU=(GeoImage image, float x, float y, float width, float height);
    public void cBU=(GeoImage image, float x, float y, float width, float height, float canvasWidth, float canvasHeight);
    public void TxU=(GeoImage image, DrawingRectangle destRect, DrawingRectangle srcRect, Single[][] colorMatrix);
    public void cRU=(GeoImage image, int x, int y, float canvasWidth, float canvasHeight);
    public void chU=(IEnumerable`1<ScreenPointF[]> screenPoints, GeoPen outlinePen, GeoBrush fillBrush, PenBrushDrawingOrder penBrushDrawingOrder);
    public void cxU=(ScreenPointF screenPoint, float width, float height, GeoPen outlinePen, GeoBrush fillBrush, PenBrushDrawingOrder penBrushDrawingOrder);
    public void OBU=(IEnumerable`1<ScreenPointF> screenPoints, GeoPen linePen);
    public void dBU=(GeoPen pen, float x, float y, float width, float height, float startAngle, float sweepAngle);
    public void XhU=(ScreenPointF centerPoint, int radius, Single[] positions, GeoColor[] colors);
    public void dRU=(string text, GeoFont font, GeoBrush brush, GeoPen haloPen, IEnumerable`1<ScreenPointF> textPathInScreen, DrawingTextAlignment drawingTextAlignment);
    private SKTypeface dhU=(string text, SKTypeface sKTypeface);
    private ValueTuple`2<SKTypeface, string> dxU=(string text);
    internal float PxU=(GeoFont font, DrawingTextBaseline textBaseline, string text);
    public void dRU=(string text, GeoFont font, GeoBrush brush, GeoPen haloPen, ScreenPointF point, DrawingTextAlignment drawingTextAlignment);
    public DrawingRectangleF eBU=(string text, GeoFont font);
    private SKPaint eRU=();
    private SKColor ehU=(GeoColor geoColor);
    private SKRect exU=(DrawingRectangle rect);
    private SKRect exU=(DrawingRectangleF rect);
    private SKRectI fBU=(DrawingRectangle rect);
    private SKPaint fRU=(GeoBrush geoBrush, SKPoint[] points);
    private SKPaint fhU=(GeoPen geoPen);
    private SKPaint fxU=(GeoFont font, GeoBrush brush, IEnumerable`1<ScreenPointF> points);
    private static SKTypeface gBU=(GeoFont font);
    private SKPaint fxU=(GeoFont font, GeoBrush brush, DrawingTextAlignment align, IEnumerable`1<ScreenPointF> points);
    private static SKFontStyle gRU=(DrawingFontStyles style);
    private void ghU=(GeoBrush geoBrush, SKPaint paint, IEnumerable`1<ScreenPointF> points);
    private void gxU=(string text, SKPaint paint, GeoFont geoFont);
    private SKShader hBU=(GeoHatchStyle hatchStyle, GeoColor foreColor, GeoColor backColor);
    private static void hRU=(float startX, float startY, float endX, float endY, SKPaint linePaint, SKCanvas canvas, DrawingLineCap drawingLineCap);
    private static SKPoint hhU=(float x, float y, double rotateRadian, float dx, float dy);
    private static double hxU=(float startX, float startY, float endX, float endY);
    public sealed virtual void Dispose();
}
internal class HRU=.yC0= : object {
    private double yS0=;
    [CompilerGeneratedAttribute]
private int yi0=;
    [CompilerGeneratedAttribute]
private int yy0=;
    [CompilerGeneratedAttribute]
private int zC0=;
    [CompilerGeneratedAttribute]
private int zS0=;
    public int 0C0= { get; private set; }
    public int 0y0= { get; private set; }
    public int 1i0= { get; private set; }
    public int 2S0= { get; private set; }
    public yC0=(double extentWidthLimitation);
    [CompilerGeneratedAttribute]
private void zy0=(int value);
    [CompilerGeneratedAttribute]
public int zi0=();
    [CompilerGeneratedAttribute]
private void 0i0=(int value);
    [CompilerGeneratedAttribute]
public int 0S0=();
    [CompilerGeneratedAttribute]
private void 1S0=(int value);
    [CompilerGeneratedAttribute]
public int 1C0=();
    [CompilerGeneratedAttribute]
private void 2C0=(int value);
    [CompilerGeneratedAttribute]
public int 1y0=();
    public void gC0=(RectangleShape Frontier);
}
internal class HRU=.yhk= : jBo= {
    internal Uhc=[] yxk=;
    internal Double[] zBk=;
    internal Double[] zRk=;
    internal yhk=(string id, string desc);
    private void 9xg=();
    internal virtual whg= /Bg=(whg= pjConsts, Int32& pj_Error);
    internal virtual void Axk=(mhg= lp, whg= pjConsts, TRg= fac, Int32& pj_Error);
    internal virtual mhg= ARk=(mRo= xy, whg= pjConsts, Int32& pj_Error);
    internal virtual mRo= Ahk=(mhg= lp, whg= pjConsts, Int32& pj_Error);
    private Uhc= Hhk=(Uhc= z, Uhc=[] C, int n, Uhc=& der);
    private Uhc= Hxk=(Uhc= z, Uhc=[] df, int n);
}
internal class HRU=.Yho= : jBo= {
    private double TBo=;
    private double 9xk=;
    private Double[] 9Rg=;
    internal Yho=(string id, string desc);
    private void 9xg=();
    internal virtual whg= /Bg=(whg= pjConsts, Int32& pj_Error);
    internal virtual void Axk=(mhg= lp, whg= pjConsts, TRg= fac, Int32& pj_Error);
    internal virtual mhg= ARk=(mRo= xy, whg= pjConsts, Int32& pj_Error);
    internal virtual mRo= Ahk=(mhg= lp, whg= pjConsts, Int32& pj_Error);
    private mRo= Exk=(mhg= lp, whg= pjConsts, Int32& pj_Error);
    private mRo= ERk=(mhg= lp, whg= pjConsts, Int32& pj_Error);
    private mhg= EBk=(mRo= xy, whg= pjConsts, Int32& pj_Error);
    private mhg= Dhk=(mRo= xy, whg= pjConsts, Int32& pj_Error);
}
internal enum HRU=.yi8= : Enum {
    public int value__;
    public static yi8= vC8=;
    public static yi8= vS8=;
    public static yi8= xC8=;
    public static yi8= yy8=;
    public static yi8= xi8=;
}
internal static class HRU=.yiw= : object {
    public static int yyw=(double realValue, int accuracy, double extentWidthLimitation);
    public static short zCw=(double realValue, int accuracy, double extentWidthLimitation);
    public static ushort zSw=(double realValue, int accuracy, double extentWidthLimitation);
    public static int ziw=(double realValue, int accuracy, double extentWidthLimitation);
}
internal class HRU=.YRo= : jBo= {
    internal double gxc=;
    internal double txc=;
    internal YRo=(string id, string desc);
    private void 9xg=();
    internal virtual whg= /Bg=(whg= pjConsts, Int32& pj_Error);
    internal virtual void Axk=(mhg= lp, whg= pjConsts, TRg= fac, Int32& pj_Error);
    internal virtual mhg= ARk=(mRo= xy, whg= pjConsts, Int32& pj_Error);
    internal virtual mRo= Ahk=(mhg= lp, whg= pjConsts, Int32& pj_Error);
}
internal class HRU=.ySg= : gCU= {
    private string 8SU=;
    private FSg= 8iU=;
    private List`1<string> yig=;
    private int CiY=;
    private Int32[] yyg=;
    private Jis= XCg=;
    private Wig= zCg=;
    private Wyk= zSg=;
    private CCk= zig=;
    private PCc= HiY=;
    private qSc= HyY=;
    private bool zyg=;
    private int 0Cg=;
    [CompilerGeneratedAttribute]
private object 0Sg=;
    public object 1Cg= { get; private set; }
    [CompilerGeneratedAttribute]
public object 0ig=();
    [CompilerGeneratedAttribute]
private void 0yg=(object value);
    public virtual int Close();
    private int 1Sg=(bool bTestOpenNoError);
    private int 1ig=();
    private int 1yg=();
    public virtual 2ig= GetFileClass();
    public virtual int Open(string pszFname, FileAccess pszAccess, bool bTestOpenNoError);
    public string dSY=(int columnNum, int recordNum);
    public virtual int SetQuickSpatialIndexMode(bool bQuickSpatialIndexMode);
    public virtual string GetTableName();
    public virtual void ResetReading();
    public virtual bool TestCapability(string pszCap);
    public virtual int GetFeatureCount(bool bForce);
    public virtual qiY= GetExtent(Hyc= psExtent, bool bForce);
    public virtual int GetNextFeatureId(int nPrevId);
    public virtual iSg= GetFeatureRef(int nFeatureId);
    public virtual PCc= GetLayerDefn();
    public virtual vig= GetNativeFieldType(int nFieldId);
    public virtual int GetBounds(Double& dXMin, Double& dYMin, Double& dXMax, Double& dYMax, bool bForce);
    public virtual qSc= GetSpatialRef();
    public virtual int GetFeatureCountByType(Int32& numPoints, Int32& numLines, Int32& numRegions, Int32& numTexts, bool bForce);
    public virtual bool IsFieldIndexed(int nFieldId);
    public virtual bool IsFieldUnique(int nFieldId);
    public virtual int SetBounds(double dXMin, double dYMin, double dXMax, double dYMax);
    public virtual int SetFeatureDefn(PCc= poFeatureDefn, List`1<vig=> paeMapInfoNativeFieldTypes);
    public virtual int AddFieldNative(string pszName, vig= eMapInfoType, int nWidth, int nPrecision, bool bIndexed, bool bUnique);
    public virtual int SetSpatialRef(qSc= poSpatialRef);
    public virtual int SetFeature(iSg= poFeature, int nFeatureId);
    public virtual int SetFieldIndexed(int nFieldId);
    public virtual int GetProjInfo(iCo= poPI);
    public virtual int SetProjInfo(iCo= poPI);
    public virtual int SetMIFCoordSys(string pszMIFCoordSys);
    public int 2Cg=(int nFieldId);
    public CCk= 2Sg=();
    public void 1x0=();
    private sealed virtual override void System.IDisposable.Dispose();
}
internal class HRU=.ySM= : object {
    [CompilerGeneratedAttribute]
private string yiM=;
    [CompilerGeneratedAttribute]
private string yyM=;
    [CompilerGeneratedAttribute]
private string zCM=;
    [CompilerGeneratedAttribute]
private string viM=;
    [ObfuscationAttribute]
[JsonPropertyNameAttribute("href")]
public string Href { get; public set; }
    [JsonPropertyNameAttribute("rel")]
[ObfuscationAttribute]
public string Rel { get; public set; }
    [ObfuscationAttribute]
[JsonPropertyNameAttribute("type")]
public string Type { get; public set; }
    [JsonPropertyNameAttribute("title")]
[ObfuscationAttribute]
public string Title { get; public set; }
    public ySM=(string href, string rel, string type, string title);
    [CompilerGeneratedAttribute]
public string get_Href();
    [CompilerGeneratedAttribute]
public void set_Href(string value);
    [CompilerGeneratedAttribute]
public string get_Rel();
    [CompilerGeneratedAttribute]
public void set_Rel(string value);
    [CompilerGeneratedAttribute]
public string get_Type();
    [CompilerGeneratedAttribute]
public void set_Type(string value);
    [CompilerGeneratedAttribute]
public string get_Title();
    [CompilerGeneratedAttribute]
public void set_Title(string value);
}
internal class HRU=.ySs= : object {
    private 8Cs= nyE=;
    [CompilerGeneratedAttribute]
private ulong vSM=;
    [CompilerGeneratedAttribute]
private WellKnownType yis=;
    [CompilerGeneratedAttribute]
private Dictionary`2<string, string> yys=;
    [CompilerGeneratedAttribute]
private List`1<UInt32> zCs=;
    [CompilerGeneratedAttribute]
private List`1<int> zSs=;
    public ulong gxQ= { get; public set; }
    public WellKnownType 0Cs= { get; public set; }
    public Dictionary`2<string, string> 0is= { get; }
    private List`1<UInt32> 1Ss= { get; private set; }
    private List`1<int> 2Cs= { get; private set; }
    public ySs=(Byte[] data, List`1<string> keys, List`1<object> values);
    [CompilerGeneratedAttribute]
public ulong gRQ=();
    [CompilerGeneratedAttribute]
public void ghQ=(ulong value);
    [CompilerGeneratedAttribute]
public WellKnownType zis=();
    [CompilerGeneratedAttribute]
public void zys=(WellKnownType value);
    [CompilerGeneratedAttribute]
public Dictionary`2<string, string> 0Ss=();
    [CompilerGeneratedAttribute]
private List`1<UInt32> 0ys=();
    [CompilerGeneratedAttribute]
private void 1Cs=(List`1<UInt32> value);
    [CompilerGeneratedAttribute]
private List`1<int> 1is=();
    [CompilerGeneratedAttribute]
private void 1ys=(List`1<int> value);
    private List`1<List`1<Vertex>> 2Ss=(float scale);
    public Feature 2is=(RectangleShape vectorTileWorldExtent, ulong extent);
    private void 2ys=(List`1<string> keys, List`1<object> values);
    private void 3Cs=(List`1<string> keys, List`1<object> values);
    private Vertex 3Ss=(long x, long y);
    private List`1<List`1<Vertex>> 3is=(List`1<List`1<Vertex>> geometries, RectangleShape vectorTileWorldExtent, ulong vectorTileRelativeExtent);
    private BaseShape 3ys=(List`1<List`1<Vertex>> geometries, WellKnownType shapeType);
    private BaseShape 4Cs=(List`1<List`1<Vertex>> geometries);
    private BaseShape 4Ss=(List`1<List`1<Vertex>> geometries);
    private BaseShape 4is=(List`1<List`1<Vertex>> geometries);
}
internal class HRU=.Yxk= : jBo= {
    internal Uhc=[] Gxk=;
    internal double HBk=;
    internal double HRk=;
    internal int gxc=;
    internal Yxk=(string id, string desc);
    private void 9xg=();
    internal virtual whg= /Bg=(whg= pjConsts, Int32& pj_Error);
    internal virtual void Axk=(mhg= lp, whg= pjConsts, TRg= fac, Int32& pj_Error);
    internal virtual mhg= ARk=(mRo= xy, whg= pjConsts, Int32& pj_Error);
    internal virtual mRo= Ahk=(mhg= lp, whg= pjConsts, Int32& pj_Error);
    private mhg= EBk=(mRo= xy, whg= pjConsts, Int32& pj_Error);
    private mRo= Exk=(mhg= lp, whg= pjConsts, Int32& pj_Error);
    private Uhc= Hhk=(Uhc= z, Uhc=[] C, int n, Uhc= der);
    private Uhc= Hxk=(Uhc= z, Uhc=[] C, int n);
}
internal class HRU=.yxo= : XmlGeoSerializationFormatter {
    protected virtual GeoObjectModel LoadCore(Stream stream);
    private static void zBo=(XElement xElement, Dictionary`2<string, PointType> correctStyleTypes);
    private static bool zRo=(XElement xelement, string styleName, PointType pointType);
    private static XElement zho=(XElement contentXml);
    private static XElement zxo=(XElement layerElement);
}
internal class HRU=.Yxo= : jBo= {
    internal Yxo=(string id, string desc);
    private void 9xg=();
    internal virtual whg= /Bg=(whg= pjConsts, Int32& pj_Error);
    internal virtual void Axk=(mhg= lp, whg= pjConsts, TRg= fac, Int32& pj_Error);
    internal virtual mhg= ARk=(mRo= xy, whg= pjConsts, Int32& pj_Error);
    internal virtual mRo= Ahk=(mhg= lp, whg= pjConsts, Int32& pj_Error);
}
internal class HRU=.yyQ= : object {
    public yyQ= zCQ=;
    public BiU= zSQ=;
}
internal class HRU=.Yyw= : ValueType {
    public static double ZCw=;
    public static double ZSw=;
    public static double Ziw=;
    public static double Zyw=;
    public static double aCw=;
    public static double aSw=;
    public static double aiw=;
    public static double ayw=;
    public static double bCw=;
    public static double bSw=;
    public static double biw=;
    public static double byw=;
    public static double cCw=;
    public static double cSw=;
    public static double ciw=;
    public static double cyw=;
    public static double dCw=;
    public static double dSw=;
    public static double diw=;
    public static double dyw=;
    public static double eCw=;
    public static double eSw=;
    public static double eiw=;
    public static double eyw=;
    public static double fCw=;
    public static double fSw=;
    public static double fiw=;
    public static double fyw=;
    public static double gCw=;
    public static double gSw=;
    public static double giw=;
    public static double gyw=;
    public static double hCw=;
    public static double hSw=;
    public static double hiw=;
    public static double hyw=;
    private static Yyw=();
}
internal enum HRU=.yyY= : Enum {
    public int value__;
    public static yyY= zCY=;
    public static yyY= zSY=;
    public static yyY= ziY=;
    public static yyY= zyY=;
    public static yyY= 0CY=;
    public static yyY= 0SY=;
}
internal class HRU=.ZBk= : jBo= {
    internal Uhc=[] Gxk=;
    internal double HBk=;
    internal double HRk=;
    internal int gxc=;
    internal ZBk=(string id, string desc);
    private void 9xg=();
    internal virtual whg= /Bg=(whg= pjConsts, Int32& pj_Error);
    internal virtual void Axk=(mhg= lp, whg= pjConsts, TRg= fac, Int32& pj_Error);
    internal virtual mhg= ARk=(mRo= xy, whg= pjConsts, Int32& pj_Error);
    internal virtual mRo= Ahk=(mhg= lp, whg= pjConsts, Int32& pj_Error);
    private mhg= EBk=(mRo= xy, whg= pjConsts, Int32& pj_Error);
    private mRo= Exk=(mhg= lp, whg= pjConsts, Int32& pj_Error);
    private Uhc= Hhk=(Uhc= z, Uhc=[] C, int n, Uhc= der);
    private Uhc= Hxk=(Uhc= z, Uhc=[] C, int n);
}
internal class HRU=.ZBo= : jBo= {
    internal int ZRo=;
    internal ZBo=(string id, string desc);
    private void 9xg=();
    internal virtual whg= /Bg=(whg= pjConsts, Int32& pj_Error);
    internal virtual void Axk=(mhg= lp, whg= pjConsts, TRg= fac, Int32& pj_Error);
    internal virtual mhg= ARk=(mRo= xy, whg= pjConsts, Int32& pj_Error);
    internal virtual mRo= Ahk=(mhg= lp, whg= pjConsts, Int32& pj_Error);
}
internal enum HRU=.zC8= : Enum {
    public int value__;
    public static zC8= vC8=;
    public static zC8= vS8=;
    public static zC8= zS8=;
}
internal class HRU=.zhk= : jBo= {
    internal jBo= zxk=;
    internal double 0Bk=;
    internal double 0Rk=;
    internal double 0hk=;
    internal double 0xk=;
    internal zhk=(string id, string desc);
    private void 9xg=();
    internal virtual whg= /Bg=(whg= pjConsts, Int32& pj_Error);
    internal virtual void Axk=(mhg= lp, whg= pjConsts, TRg= fac, Int32& pj_Error);
    internal virtual mhg= ARk=(mRo= xy, whg= pjConsts, Int32& pj_Error);
    internal virtual mRo= Ahk=(mhg= lp, whg= pjConsts, Int32& pj_Error);
    private mRo= 1Bk=(mhg= lp, whg= pjConsts, Int32& pj_Error);
    private mRo= 1Rk=(mhg= lp, whg= pjConsts, Int32& pj_Error);
    private mhg= 1hk=(mRo= xy, whg= pjConsts, Int32& pj_Error);
    private mhg= 1xk=(mRo= xy, whg= pjConsts, Int32& pj_Error);
}
internal class HRU=.Zho= : jBo= {
    internal int ZRo=;
    internal Zho=(string id, string desc);
    private void 9xg=();
    internal virtual whg= /Bg=(whg= pjConsts, Int32& pj_Error);
    internal virtual void Axk=(mhg= lp, whg= pjConsts, TRg= fac, Int32& pj_Error);
    internal virtual mhg= ARk=(mRo= xy, whg= pjConsts, Int32& pj_Error);
    internal virtual mRo= Ahk=(mhg= lp, whg= pjConsts, Int32& pj_Error);
}
internal enum HRU=.zhU= : Enum {
    public int value__;
    public static zhU= zxU=;
    public static zhU= 0BU=;
    public static zhU= 0RU=;
}
[FlagsAttribute]
internal enum HRU=.zhw= : Enum {
    public byte value__;
    public static zhw= zxw=;
    public static zhw= 0Bw=;
    public static zhw= 0Rw=;
    public static zhw= 0hw=;
    public static zhw= 0xw=;
    public static zhw= 1Bw=;
    public static zhw= 1Rw=;
}
internal enum HRU=.zi8= : Enum {
    public int value__;
    public static zi8= zy8=;
}
internal enum HRU=.ziQ= : Enum {
    public int value__;
    public static ziQ= zyQ=;
    public static ziQ= 0CQ=;
    public static ziQ= 0SQ=;
    public static ziQ= 0iQ=;
    public static ziQ= 0yQ=;
}
internal class HRU=.ZRk= : jBo= {
    internal double Zhk=;
    internal double Zxk=;
    internal double 7hg=;
    internal double CRk=;
    internal double 8Bg=;
    internal double aBk=;
    internal double aRk=;
    internal ZRk=(string id, string desc);
    private void 9xg=();
    internal virtual whg= /Bg=(whg= pjConsts, Int32& pj_Error);
    internal virtual void Axk=(mhg= lp, whg= pjConsts, TRg= fac, Int32& pj_Error);
    internal virtual mhg= ARk=(mRo= xy, whg= pjConsts, Int32& pj_Error);
    internal virtual mRo= Ahk=(mhg= lp, whg= pjConsts, Int32& pj_Error);
}
internal class HRU=.ZS8= : object {
    public static VS8= kxU=(BinaryReader br);
    private static hy8= Dyk=(BinaryReader br);
    private static aC8= Zi8=(BinaryReader br);
    private static dy8= phw=(BinaryReader br);
    public static DataType Yic=(BinaryReader br);
}
internal class HRU=.zSA= : ValueType {
    public double ziA=;
    public string zyA=;
    public string 0CA=;
    public string 0SA=;
    public 8SA= 0iA=;
    public 8SA= 0yA=;
    public string 1CA=;
    public string 1SA=;
    public string 1iA=;
    public string 1yA=;
    public string 2CA=;
    public string 2SA=;
    public string 2iA=;
    public string 2yA=;
    public bool 3CA=;
    public string 3SA=;
    public int 3iA=;
}
internal class HRU=.zSM= : object {
    [CompilerGeneratedAttribute]
private List`1<List`1<double>> ziM=;
    [CompilerGeneratedAttribute]
private string wiM=;
    [JsonPropertyNameAttribute("bbox")]
[ObfuscationAttribute]
public List`1<List`1<double>> Bbox { get; public set; }
    [JsonPropertyNameAttribute("crs")]
[ObfuscationAttribute]
public string Crs { get; public set; }
    public zSM=(List`1<List`1<double>> bbox, string crs);
    [CompilerGeneratedAttribute]
public List`1<List`1<double>> get_Bbox();
    [CompilerGeneratedAttribute]
public void set_Bbox(List`1<List`1<double>> value);
    [CompilerGeneratedAttribute]
public string get_Crs();
    [CompilerGeneratedAttribute]
public void set_Crs(string value);
}
internal class HRU=.zSo= : CyU= {
    protected Stream Wyg=;
    protected FSg= zio=;
    protected int zyo=;
    protected Byte[] 0Co=;
    protected int Lyg=;
    protected int 0So=;
    protected bool 0io=;
    protected int 0yo=;
    protected int 1Co=;
    protected int 1So=;
    protected bool 1io=;
    public zSo=(FSg= eAccessMode, bool bHardBlockSize);
    public virtual int ReadFromFile(Stream fsSrc, int nOffset, int nSize);
    public virtual int CommitToFile();
    public int 1yo=(int nNextBlockPtr);
    public virtual int InitBlockFromData(Byte[] pabyBuf, int nBlockSize, int nSizeUsed, bool bMakeCopy, Stream fsSrc, int nOffset);
    public virtual int InitNewBlock(Stream fsSrc, int nBlockSize, int nFileOffset);
    public int 2Co=();
    public virtual int GetBlockClass();
    public int 2So=();
    public int 2io=(int nOffset);
    public int 2yo=(int nOffset);
    public int 3Co=(int nOffset, bool bForceReadFromFile, bool bOffsetIsEndOfData);
    public void 3So=(int nOffset);
    public int 3io=();
    public int 3yo=();
    public int 4Co=();
    public virtual int ReadBytes(int numBytes, Byte[] pabyDstBuf);
    public byte 4So=();
    public short 4io=();
    public int 4yo=();
    public double 5Co=();
    public virtual int WriteBytes(int nBytesToWrite, Byte[] pabySrcBuf);
    public int 5So=(byte byValue);
    public int 5io=(short n16Value);
    public int 5yo=(int n32Value);
    public int 6Co=(double dValue);
    public int 6So=(int nBytesToWrite);
    public Byte[] 6io=();
    public int 6yo=();
    public Byte[] 7Co=();
}
internal class HRU=.Zxo= : jBo= {
    internal Zxo=(string id, string desc);
    private void 9xg=();
    internal virtual whg= /Bg=(whg= pjConsts, Int32& pj_Error);
    internal virtual void Axk=(mhg= lp, whg= pjConsts, TRg= fac, Int32& pj_Error);
    internal virtual mhg= ARk=(mRo= xy, whg= pjConsts, Int32& pj_Error);
    internal virtual mRo= Ahk=(mhg= lp, whg= pjConsts, Int32& pj_Error);
}
internal class HRU=.Zy8= : object {
}
internal class HRU=.zyc= : 3Cc= {
    public tSc=[] 0Cc=;
    private uCc=[] wCc=;
    public virtual int kxU=();
    public string 0Sc=(Int32& bDefault);
    public double CSA=(Int32& bDefault);
    public string 0ic=(Int32& bDefault);
    public string wyc=(Int32& bDefault);
    public string xCc=(1yY= eParam, Int32& bValueIsNull);
    public double 0yc=(1yY= eParam, Int32& bValueIsNull);
}
internal abstract class HRU=.Zyc= : object {
    private qSc= aCc=;
    protected int aSc=;
    public abstract virtual Zyc= aic=();
    public abstract virtual void ayc=(Hyc= psEnvelope);
    public virtual int bCc=();
    public abstract virtual qiY= bSc=(String& ppszDstText);
    public abstract virtual ryY= bic=();
    public abstract virtual string byc=();
    public virtual void cCc=(int nNewDimension);
    public void cSc=(qSc= poSR);
    public qSc= cic=();
    public virtual int cyc=(Zyc= poOtherGeom);
}
internal class HRU=.zyM= : object {
    [CompilerGeneratedAttribute]
private string zCM=;
    [CompilerGeneratedAttribute]
private JsonElement 0CM=;
    [CompilerGeneratedAttribute]
private DateTime 0SM=;
    [CompilerGeneratedAttribute]
private List`1<ySM=> vyM=;
    [CompilerGeneratedAttribute]
private int 0iM=;
    [JsonPropertyNameAttribute("type")]
[ObfuscationAttribute]
public string Type { get; public set; }
    [JsonPropertyNameAttribute("features")]
[ObfuscationAttribute]
public JsonElement Features { get; public set; }
    [JsonPropertyNameAttribute("timeStamp")]
[ObfuscationAttribute]
public DateTime TimeStamp { get; public set; }
    [JsonPropertyNameAttribute("links")]
[ObfuscationAttribute]
public List`1<ySM=> Links { get; public set; }
    [JsonPropertyNameAttribute("numberReturned")]
[ObfuscationAttribute]
public int NumberReturned { get; public set; }
    public zyM=(string type, JsonElement features, DateTime timeStamp, List`1<ySM=> links, int numberReturned);
    [CompilerGeneratedAttribute]
public string get_Type();
    [CompilerGeneratedAttribute]
public void set_Type(string value);
    [CompilerGeneratedAttribute]
public JsonElement get_Features();
    [CompilerGeneratedAttribute]
public void set_Features(JsonElement value);
    [CompilerGeneratedAttribute]
public DateTime get_TimeStamp();
    [CompilerGeneratedAttribute]
public void set_TimeStamp(DateTime value);
    [CompilerGeneratedAttribute]
public List`1<ySM=> get_Links();
    [CompilerGeneratedAttribute]
public void set_Links(List`1<ySM=> value);
    [CompilerGeneratedAttribute]
public int get_NumberReturned();
    [CompilerGeneratedAttribute]
public void set_NumberReturned(int value);
}
internal class HRU=.zyw= : object {
    private string 0Cw=;
    private ICryptoTransform 0Sw=;
    private ICryptoTransform 0iw=;
    public string 1Cw= { get; }
    public zyw=(string password);
    public string 0yw=();
    private void 1Sw=(string password);
    public Byte[] 1iw=(Byte[] inputBytes);
    public Byte[] 1yw=(Byte[] inputBytes, int offSet, int count);
    public ICryptoTransform 2Cw=(string password, int cipherMode, Byte[] providerIV, int paddingMode);
    public ICryptoTransform 2Sw=(string password, int cipherMode, Byte[] providerIV, int paddingMode);
}
[CompilerGeneratedAttribute]
internal class jD0= : object {
    internal static long jT0=;
    internal static eEE= jj0=;
    internal static ekE= jz0=;
    internal static eEE= kD0=;
    internal static iEE= kT0=;
    internal static long kj0=;
    internal static gEE= kz0=;
    internal static dEE= lD0=;
    internal static kkE= lT0=;
    internal static eEE= lj0=;
    internal static eEE= lz0=;
    internal static fUE= mD0=;
    internal static gEE= mT0=;
    internal static eEE= mj0=;
    internal static iUE= mz0=;
    internal static jkE= nD0=;
    internal static eUE= nT0=;
    internal static eEE= nj0=;
    internal static jEE= nz0=;
    internal static iUE= oD0=;
    internal static iUE= oT0=;
    internal static h0E= oj0=;
    internal static eEE= oz0=;
    internal static dUE= pD0=;
    internal static f0E= pT0=;
    internal static iUE= pj0=;
    internal static h0E= pz0=;
    internal static eEE= qD0=;
    internal static hEE= qT0=;
    internal static i0E= qj0=;
    internal static hUE= qz0=;
    internal static hUE= rD0=;
    internal static ikE= rT0=;
    internal static eEE= rj0=;
    internal static g0E= rz0=;
    internal static iUE= sD0=;
    internal static iUE= sT0=;
    internal static jUE= sj0=;
    internal static j0E= sz0=;
    internal static kEE= tD0=;
    internal static dkE= tT0=;
    internal static dUE= tj0=;
    internal static gkE= tz0=;
    internal static hEE= uD0=;
    internal static eUE= uT0=;
    internal static jUE= uj0=;
    internal static eEE= uz0=;
    internal static d0E= vD0=;
    internal static dUE= vT0=;
    internal static hEE= vj0=;
    internal static dkE= vz0=;
    internal static gUE= wD0=;
    internal static dkE= wT0=;
    internal static eUE= wj0=;
    internal static iUE= wz0=;
    internal static eEE= xD0=;
    internal static fEE= xT0=;
    internal static gkE= xj0=;
    internal static d0E= xz0=;
    internal static eEE= yD0=;
    internal static eEE= yT0=;
    internal static kUE= yj0=;
    internal static fUE= yz0=;
    internal static e0E= zD0=;
    internal static gEE= zT0=;
    internal static eUE= zj0=;
    internal static eEE= zz0=;
    internal static dkE= 0D0=;
    internal static f0E= 0T0=;
    internal static e0E= 0j0=;
    internal static hkE= 0z0=;
    internal static dkE= 1D0=;
    internal static eEE= 1T0=;
    internal static f0E= 1j0=;
    internal static eEE= 1z0=;
    internal static g0E= 2D0=;
    internal static hEE= 2T0=;
    internal static fkE= 2j0=;
    internal static dkE= 2z0=;
    internal static UInt32 3D0=(string s);
}
[CompilerGeneratedAttribute]
internal class oRM= : object {
    [DebuggerBrowsableAttribute("0")]
private <Name>j__TPar ohM=;
    [DebuggerBrowsableAttribute("0")]
private <Value>j__TPar oxM=;
    public <Name>j__TPar pRM= { get; }
    public <Value>j__TPar pxM= { get; }
    [DebuggerHiddenAttribute]
public oRM=(<Name>j__TPar Name, <Value>j__TPar Value);
    public <Name>j__TPar pBM=();
    public <Value>j__TPar phM=();
    [DebuggerHiddenAttribute]
public virtual bool Equals(object value);
    [DebuggerHiddenAttribute]
public virtual int GetHashCode();
    [DebuggerHiddenAttribute]
public virtual string ToString();
}
[CompilerGeneratedAttribute]
internal class qBM= : object {
    [DebuggerBrowsableAttribute("0")]
private <Memebers>j__TPar qRM=;
    public <Memebers>j__TPar qxM= { get; }
    [DebuggerHiddenAttribute]
public qBM=(<Memebers>j__TPar Memebers);
    public <Memebers>j__TPar qhM=();
    [DebuggerHiddenAttribute]
public virtual bool Equals(object value);
    [DebuggerHiddenAttribute]
public virtual int GetHashCode();
    [DebuggerHiddenAttribute]
public virtual string ToString();
}
[CompilerGeneratedAttribute]
internal class rBM= : object {
    [DebuggerBrowsableAttribute("0")]
private <Data>j__TPar rRM=;
    public <Data>j__TPar rxM= { get; }
    [DebuggerHiddenAttribute]
public rBM=(<Data>j__TPar Data);
    public <Data>j__TPar rhM=();
    [DebuggerHiddenAttribute]
public virtual bool Equals(object value);
    [DebuggerHiddenAttribute]
public virtual int GetHashCode();
    [DebuggerHiddenAttribute]
public virtual string ToString();
}
[CompilerGeneratedAttribute]
internal class sBM= : object {
    [DebuggerBrowsableAttribute("0")]
private <access_token>j__TPar sRM=;
    [DebuggerBrowsableAttribute("0")]
private <expires_in>j__TPar shM=;
    [DebuggerBrowsableAttribute("0")]
private <token_type>j__TPar sxM=;
    public <access_token>j__TPar tRM= { get; }
    public <expires_in>j__TPar txM= { get; }
    public <token_type>j__TPar uRM= { get; }
    [DebuggerHiddenAttribute]
public sBM=(<access_token>j__TPar access_token, <expires_in>j__TPar expires_in, <token_type>j__TPar token_type);
    public <access_token>j__TPar tBM=();
    public <expires_in>j__TPar thM=();
    public <token_type>j__TPar uBM=();
    [DebuggerHiddenAttribute]
public virtual bool Equals(object value);
    [DebuggerHiddenAttribute]
public virtual int GetHashCode();
    [DebuggerHiddenAttribute]
public virtual string ToString();
}
public class SecureTeam.Attributes.ObfuscatedByAgileDotNetAttribute : Attribute {
}
[AttributeUsageAttribute("1")]
public class System.Reflection.AssemblyTimestampAttribute : Attribute {
    [CompilerGeneratedAttribute]
private string zBM=;
    public string Timestamp { get; }
    public AssemblyTimestampAttribute(string timestamp);
    [CompilerGeneratedAttribute]
public string get_Timestamp();
}
public class ThinkGeo.Core.AddedGeoCollectionEventArgs : EventArgs {
    [ObfuscationAttribute]
private object item;
    [ObfuscationAttribute]
private string key;
    public object Item { get; public set; }
    public string Key { get; public set; }
    public AddedGeoCollectionEventArgs(object item);
    public AddedGeoCollectionEventArgs(object item, string key);
    public object get_Item();
    public void set_Item(object value);
    public string get_Key();
    public void set_Key(string value);
}
public class ThinkGeo.Core.AddingGeoCollectionEventArgs : EventArgs {
    [ObfuscationAttribute]
private object item;
    public object Item { get; public set; }
    public AddingGeoCollectionEventArgs(object item);
    public object get_Item();
    public void set_Item(object value);
}
public abstract class ThinkGeo.Core.AdornmentLayer : Layer {
    [ObfuscationAttribute]
private float xOffsetInPixel;
    [ObfuscationAttribute]
private float yOffsetInPixel;
    [ObfuscationAttribute]
private AdornmentLocation location;
    [ObfuscationAttribute]
private float width;
    [ObfuscationAttribute]
private float height;
    [ObfuscationAttribute]
private AreaStyle backgroundMask;
    public float Width { get; public set; }
    public float Height { get; public set; }
    public AreaStyle BackgroundMask { get; public set; }
    public AdornmentLocation Location { get; public set; }
    public float XOffsetInPixel { get; public set; }
    public float YOffsetInPixel { get; public set; }
    public float get_Width();
    public void set_Width(float value);
    public float get_Height();
    public void set_Height(float value);
    public AreaStyle get_BackgroundMask();
    public void set_BackgroundMask(AreaStyle value);
    public AdornmentLocation get_Location();
    public void set_Location(AdornmentLocation value);
    public float get_XOffsetInPixel();
    public void set_XOffsetInPixel(float value);
    public float get_YOffsetInPixel();
    public void set_YOffsetInPixel(float value);
    protected virtual void DrawCore(GeoCanvas canvas, Collection`1<SimpleCandidate> labelsInAllLayers);
    public virtual ScreenPointF GetDrawingLocation(GeoCanvas canvas, float adornmentWidth, float adornmentHeight);
}
public enum ThinkGeo.Core.AdornmentLocation : Enum {
    public int value__;
    public static AdornmentLocation UseOffsets;
    public static AdornmentLocation UpperLeft;
    public static AdornmentLocation UpperCenter;
    public static AdornmentLocation UpperRight;
    public static AdornmentLocation CenterLeft;
    public static AdornmentLocation Center;
    public static AdornmentLocation CenterRight;
    public static AdornmentLocation LowerLeft;
    public static AdornmentLocation LowerCenter;
    public static AdornmentLocation LowerRight;
}
public enum ThinkGeo.Core.AngleUnit : Enum {
    public int value__;
    public static AngleUnit Degrees;
    public static AngleUnit Radians;
    public static AngleUnit Gradians;
}
public enum ThinkGeo.Core.ApplyUntilZoomLevel : Enum {
    public int value__;
    public static ApplyUntilZoomLevel None;
    public static ApplyUntilZoomLevel Level01;
    public static ApplyUntilZoomLevel Level02;
    public static ApplyUntilZoomLevel Level03;
    public static ApplyUntilZoomLevel Level04;
    public static ApplyUntilZoomLevel Level05;
    public static ApplyUntilZoomLevel Level06;
    public static ApplyUntilZoomLevel Level07;
    public static ApplyUntilZoomLevel Level08;
    public static ApplyUntilZoomLevel Level09;
    public static ApplyUntilZoomLevel Level10;
    public static ApplyUntilZoomLevel Level11;
    public static ApplyUntilZoomLevel Level12;
    public static ApplyUntilZoomLevel Level13;
    public static ApplyUntilZoomLevel Level14;
    public static ApplyUntilZoomLevel Level15;
    public static ApplyUntilZoomLevel Level16;
    public static ApplyUntilZoomLevel Level17;
    public static ApplyUntilZoomLevel Level18;
    public static ApplyUntilZoomLevel Level19;
    public static ApplyUntilZoomLevel Level20;
}
public class ThinkGeo.Core.ArcGisServerRestAsyncLayer : WebBasedAsyncLayer {
    [ObfuscationAttribute]
private Dictionary`2<string, string> parameters;
    [ObfuscationAttribute]
private ArcGISServerRestLayerImageFormat imageFormat;
    [ObfuscationAttribute]
private bool enableImageFormat;
    [CompilerGeneratedAttribute]
private Uri 8R0=;
    public Uri ServerUri { get; public set; }
    public Dictionary`2<string, string> Parameters { get; }
    public ArcGISServerRestLayerImageFormat ImageFormat { get; public set; }
    public ArcGisServerRestAsyncLayer(Uri serverUri);
    public ArcGisServerRestAsyncLayer(Uri serverUri, IWebProxy webProxy);
    [CompilerGeneratedAttribute]
public Uri get_ServerUri();
    [CompilerGeneratedAttribute]
public void set_ServerUri(Uri value);
    public Dictionary`2<string, string> get_Parameters();
    public ArcGISServerRestLayerImageFormat get_ImageFormat();
    public void set_ImageFormat(ArcGISServerRestLayerImageFormat value);
    [AsyncStateMachineAttribute("ThinkGeo.Core.ArcGisServerRestAsyncLayer/DD8=")]
protected virtual Task DrawAsyncCore(GeoCanvas canvas, Collection`1<SimpleCandidate> labelsInAllLayers);
    private string 8h0=(Dictionary`2<string, string> tempDictionary);
}
public enum ThinkGeo.Core.ArcGISServerRestLayerImageFormat : Enum {
    public int value__;
    public static ArcGISServerRestLayerImageFormat Png;
    public static ArcGISServerRestLayerImageFormat Png8;
    public static ArcGISServerRestLayerImageFormat Png24;
    public static ArcGISServerRestLayerImageFormat Jpeg;
    public static ArcGISServerRestLayerImageFormat Gif;
}
public abstract class ThinkGeo.Core.AreaBaseShape : BaseShape {
    public double GetPerimeter(GeographyUnit shapeUnit, DistanceUnit returningUnit);
    protected virtual double GetPerimeterCore(GeographyUnit shapeUnit, DistanceUnit returningUnit);
    public double GetArea(GeographyUnit shapeUnit, AreaUnit returningUnit);
    protected virtual double GetAreaCore(GeographyUnit shapeUnit, AreaUnit returningUnit);
    public static AreaBaseShape ScaleUp(AreaBaseShape targetShape, double percentage);
    public static Feature ScaleUp(Feature targetFeature, double percentage);
    public void ScaleUp(double percentage);
    public double GetArea(int shapeSrid, AreaUnit returningUnit);
    public double GetArea(string shapeProjString, AreaUnit returningUnit);
    public double GetArea(Projection shapeProjection, AreaUnit returningUnit);
    public double GetArea(int shapeSrid, AreaUnit returningUnit, DistanceCalculationMode distanceCalculationMode);
    public double GetArea(string shapeProjString, AreaUnit returningUnit, DistanceCalculationMode distanceCalculationMode);
    public double GetArea(Projection shapeProjection, AreaUnit returningUnit, DistanceCalculationMode distanceCalculationMode);
    protected virtual double GetAreaCore(Projection shapeProjection, AreaUnit returningUnit, DistanceCalculationMode distanceCalculationMode);
    public double GetPerimeter(int shapeSrid, DistanceUnit returningUnit);
    public double GetPerimeter(string shapeProjString, DistanceUnit returningUnit);
    public double GetPerimeter(Projection shapeProjection, DistanceUnit returningUnit);
    public double GetPerimeter(int shapeSrid, DistanceUnit returningUnit, DistanceCalculationMode distanceCalculationMode);
    public double GetPerimeter(string shapeProjString, DistanceUnit returningUnit, DistanceCalculationMode distanceCalculationMode);
    public double GetPerimeter(Projection shapeProjection, DistanceUnit returningUnit, DistanceCalculationMode distanceCalculationMode);
    protected virtual double GetPerimeterCore(Projection shapeProjection, DistanceUnit returningUnit, DistanceCalculationMode distanceCalculationMode);
    protected virtual void ScaleUpCore(double percentage);
    public static AreaBaseShape ScaleDown(AreaBaseShape targetShape, double percentage);
    public static Feature ScaleDown(Feature targetFeature, double percentage);
    public void ScaleDown(double percentage);
    protected virtual void ScaleDownCore(double percentage);
    public RingShape GetConvexHull();
    protected virtual RingShape GetConvexHullCore();
    public MultipolygonShape GetIntersection(AreaBaseShape targetShape);
    public MultipolygonShape GetIntersection(Feature targetFeature);
    protected virtual MultipolygonShape GetIntersectionCore(AreaBaseShape targetShape);
    public virtual MultipolygonShape Union(AreaBaseShape targetShape);
    public MultipolygonShape Union(Feature targetFeature);
    protected virtual MultipolygonShape UnionCore(AreaBaseShape targetShape);
    public static MultipolygonShape Union(IEnumerable`1<Feature> targetFeatures);
    public static MultipolygonShape Union(IEnumerable`1<AreaBaseShape> areaShapes);
    private static MultipolygonShape 0Bo=(IEnumerable`1<BaseShape> areaShapes, bool isPrivate);
    private static BaseShape 0Ro=(IEnumerable`1<BaseShape> areaShapes, int count);
    public MultipolygonShape GetDifference(AreaBaseShape targetShape);
    public MultipolygonShape GetDifference(Feature targetFeature);
    protected virtual MultipolygonShape GetDifferenceCore(AreaBaseShape targetShape);
    public MultipolygonShape GetSymmetricalDifference(AreaBaseShape targetShape);
    public MultipolygonShape GetSymmetricalDifference(Feature targetFeature);
    protected virtual MultipolygonShape GetSymmetricalDifferenceCore(AreaBaseShape targetShape);
    public static Collection`1<MultipolygonShape> Split(AreaBaseShape areaToSplit, AreaBaseShape areaToSplitBy);
    public static Collection`1<Feature> Split(Feature areaToSplit, Feature areaToSplitBy);
    public static MultipolygonShape Simplify(AreaBaseShape targetShape, GeographyUnit targetShapeUnit, double tolerance, DistanceUnit toleranceUnit, SimplificationType simplificationType);
    public static MultipolygonShape Simplify(AreaBaseShape targetShape, double tolerance, SimplificationType simplificationType);
    public MultipolygonShape Simplify(GeographyUnit shapeUnit, double tolerance, DistanceUnit toleranceUnit, SimplificationType simplificationType);
    public MultipolygonShape Simplify(double tolerance, SimplificationType simplificationType);
    protected virtual MultipolygonShape SimplifyCore(double tolerance, SimplificationType simplificationType);
    private static void 0ho=(MultipolygonShape returnMultipolygon, GeometryCollection geometryCollection);
    private void TRU=(double factor);
    public static Collection`1<PolygonShape> Snap(IEnumerable`1<AreaBaseShape> shapes, GeographyUnit shapeUnit, double snappingTolerance, DistanceUnit toleranceUnit);
    private static bool 0xo=(IEnumerable`1<PolygonShape> polygonShapes, double tolerance);
    private static bool 1Bo=(Collection`1<PolygonShape> polygons, double tolerance);
    private static bool 1Ro=(IEnumerable`1<PolygonShape> polygons, PolygonShape polygon, RingShape ringShape, double tolerance, STRtree`1<BaseShape> rTree, Collection`1<Vertex> checkedVertices, double squareTolerance, Boolean& noClusterTolerance);
    private static void 1ho=(string id, Vertex vertex, IList`1<BaseShape> intersectingPolys);
    private static bool 1xo=(Vertex currentVertex, PolygonShape currentPolygonShape, int currentVertexIndex, PolygonShape closestPolygonShape, PointShape closestPoint);
    private static void 2Bo=(Vertex currentVertex, RingShape currentRing, int currentVertexIndex, RingShape closestRing, PointShape closestPoint, Boolean& updateSucceed);
    private static bool 2Ro=(PolygonShape polygonShape, PolygonShape intersectingPolygon);
    private static bool 2ho=(RingShape polygonRing, RingShape intersectingRing);
    private static bool 2Bo=(IEnumerable`1<PolygonShape> polygonShapes, RingShape ringShape, double tolerance, Collection`1<Vertex> checkedVertices, Collection`1<Vertex> updatedVertices, STRtree`1<BaseShape> rTree, Boolean& noClusterTolerance);
    private static bool 2xo=(IEnumerable`1<PolygonShape> polygonShapes, RingShape ringShape, Vertex vertex, double squareTolerance, Feature feature, Collection`1<PointShape> pendingUpdatedVertex, Collection`1<KeyValuePair`2<RingShape, int>> pendingUpdatedVertexIndex);
    private static void 3Bo=(Collection`1<KeyValuePair`2<RingShape, int>> ringsCache, Vertex newVertex);
}
public class ThinkGeo.Core.AreaFilterCondition : FilterCondition {
    [ObfuscationAttribute]
private AreaUnit caculatedAreaUnit;
    private GeographyUnit wzE=;
    public AreaUnit AreaUnit { get; public set; }
    public GeographyUnit GeographyUnit { get; public set; }
    public AreaFilterCondition(AreaUnit areaUnit);
    public AreaUnit get_AreaUnit();
    public void set_AreaUnit(AreaUnit value);
    public GeographyUnit get_GeographyUnit();
    public void set_GeographyUnit(GeographyUnit value);
    internal virtual bool TSM=(Feature feature);
}
public class ThinkGeo.Core.AreaStyle : Style {
    [ObfuscationAttribute]
private Collection`1<AreaStyle> customAreaStyles;
    [ObfuscationAttribute]
private GeoBrush fillBrush;
    [ObfuscationAttribute]
private GeoPen outlinePen;
    [ObfuscationAttribute]
private PenBrushDrawingOrder penBrushDrawingOrder;
    [ObfuscationAttribute]
private float xOffsetInPixel;
    [ObfuscationAttribute]
private float yOffsetInPixel;
    [ObfuscationAttribute]
private DrawingLevel drawingLevel;
    [CompilerGeneratedAttribute]
private AreaStyle /TA=;
    public float XOffsetInPixel { get; public set; }
    public float YOffsetInPixel { get; public set; }
    public GeoBrush FillBrush { get; public set; }
    public Collection`1<AreaStyle> CustomAreaStyles { get; }
    public GeoPen OutlinePen { get; public set; }
    public PenBrushDrawingOrder PenBrushDrawingOrder { get; public set; }
    public DrawingLevel DrawingLevel { get; public set; }
    internal AreaStyle ADE= { get; internal set; }
    internal bool phU= { get; }
    public AreaStyle(GeoBrush fillBrush);
    public AreaStyle(GeoPen outlinePen);
    public AreaStyle(GeoPen outlinePen, GeoBrush fillBrush);
    public AreaStyle(GeoPen outlinePen, GeoBrush fillBrush, PenBrushDrawingOrder penBrushDrawingOrder);
    public float get_XOffsetInPixel();
    public void set_XOffsetInPixel(float value);
    public float get_YOffsetInPixel();
    public void set_YOffsetInPixel(float value);
    public GeoBrush get_FillBrush();
    public void set_FillBrush(GeoBrush value);
    public Collection`1<AreaStyle> get_CustomAreaStyles();
    public GeoPen get_OutlinePen();
    public void set_OutlinePen(GeoPen value);
    public PenBrushDrawingOrder get_PenBrushDrawingOrder();
    public void set_PenBrushDrawingOrder(PenBrushDrawingOrder value);
    public DrawingLevel get_DrawingLevel();
    public void set_DrawingLevel(DrawingLevel value);
    [CompilerGeneratedAttribute]
internal AreaStyle /jA=();
    [CompilerGeneratedAttribute]
internal void /zA=(AreaStyle value);
    internal virtual bool pBU=();
    public static AreaStyle Parse(string styleJson);
    internal static AreaStyle kxU=(JObject jObject);
    public static AreaStyle CreateSimpleAreaStyle(GeoColor fillBrushColor);
    public static AreaStyle CreateSimpleAreaStyle(GeoColor fillBrushColor, GeoColor outlinePenColor);
    public static AreaStyle CreateSimpleAreaStyle(GeoColor fillBrushColor, GeoColor outlinePenColor, int outlinePenWidth);
    public static AreaStyle CreateSimpleAreaStyle(GeoColor fillBrushColor, GeoColor outlinePenColor, int outlinePenWidth, LineDashStyle borderStyle);
    public static AreaStyle CreateSimpleAreaStyle(GeoColor fillBrushColor, float xOffsetInPixel, float yOffsetInPixel);
    public static AreaStyle CreateSimpleAreaStyle(GeoColor fillBrushColor, GeoColor outlinePenColor, float xOffsetInPixel, float yOffsetInPixel);
    public static AreaStyle CreateSimpleAreaStyle(GeoColor fillBrushColor, GeoColor outlinePenColor, int outlinePenWidth, float xOffsetInPixel, float yOffsetInPixel);
    public static AreaStyle CreateSimpleAreaStyle(GeoColor fillBrushColor, GeoColor outlinePenColor, int outlinePenWidth, LineDashStyle borderStyle, float xOffsetInPixel, float yOffsetInPixel);
    public static AreaStyle CreateHatchStyle(GeoHatchStyle hatchStyle, GeoColor foregroundBrushColor, GeoColor backgroundBrushColor);
    public static AreaStyle CreateHatchStyle(GeoHatchStyle hatchStyle, GeoColor foregroundBrushColor, GeoColor backgroundBrushColor, GeoColor outlinePenColor);
    public static AreaStyle CreateHatchStyle(GeoHatchStyle hatchStyle, GeoColor foregroundBrushColor, GeoColor backgroundColor, GeoColor outlinePenColor, int outlinePenWidth, LineDashStyle outlineDashStyle, float xOffsetInPixel, float yOffsetInPixel);
    public static AreaStyle CreateLinearGradientStyle(GeoColor fromColor, GeoColor toColor, float angle);
    public static AreaStyle CreateLinearGradientStyle(GeoColor fromColor, GeoColor toColor, float angle, GeoColor outlinePenColor);
    public static AreaStyle CreateHueFamilyAreaStyle(GeoColor outlinePenColor, GeoColor baseColor, int numberOfColors);
    public static AreaStyle CreateHueFamilyLinearGradientAreaStyle(GeoColor outlinePenColor, GeoColor baseColor, int numberOfColors, GeoColor fromColor, GeoColor toColor, float angle);
    public static AreaStyle CreateQualityFamilyAreaStyle(GeoColor outlinePenColor, GeoColor baseColor, int numberOfColors);
    public static AreaStyle CreateQualityFamilyLinearGradientAreaStyle(GeoColor outlinePenColor, GeoColor baseColor, int numberOfColors, GeoColor fromColor, GeoColor toColor, float angle);
    protected virtual void DrawCore(IEnumerable`1<Feature> features, GeoCanvas canvas, Collection`1<SimpleCandidate> labelsInThisLayer, Collection`1<SimpleCandidate> labelsInAllLayers);
    private void ATE=(GeoCanvas canvas, Collection`1<SimpleCandidate> labelsInThisLayer, Collection`1<SimpleCandidate> labelsInAllLayers, IEnumerable`1<Feature> featureList);
    private GeoPen AjE=();
    protected virtual void DrawSampleCore(GeoCanvas canvas, DrawingRectangleF drawingExtent);
    private static List`1<Feature> AzE=(RectangleShape currentExtent, IEnumerable`1<Feature> featureList);
    private static bool BDE=(AreaBaseShape currentAreaShape);
    private static GeoPen BTE=(String[] valueExpressions);
    private static GeoBrush BjE=(String[] valueExpressions);
}
public enum ThinkGeo.Core.AreaUnit : Enum {
    public int value__;
    public static AreaUnit Acres;
    public static AreaUnit SquareMeters;
    public static AreaUnit Hectares;
    public static AreaUnit SquareFeet;
    public static AreaUnit SquareKilometers;
    public static AreaUnit SquareMiles;
    public static AreaUnit SquareUsSurveyFeet;
    public static AreaUnit SquareYards;
}
[ObsoleteAttribute("This class is obsoleted and will be removed after v14.3, please use ThinkGeo.Core.ArcGisServerRestAsyncLayer instead")]
public class ThinkGeo.Core.Async.ArcGisServerRestLayer : WebBasedLayer {
    [ObfuscationAttribute]
private Dictionary`2<string, string> parameters;
    [ObfuscationAttribute]
private ArcGISServerRestLayerImageFormat imageFormat;
    [ObfuscationAttribute]
private bool enableImageFormat;
    [CompilerGeneratedAttribute]
private Uri 8R0=;
    public Uri ServerUri { get; public set; }
    public Dictionary`2<string, string> Parameters { get; }
    public ArcGISServerRestLayerImageFormat ImageFormat { get; public set; }
    public ArcGisServerRestLayer(Uri serverUri);
    public ArcGisServerRestLayer(Uri serverUri, IWebProxy webProxy);
    [CompilerGeneratedAttribute]
public Uri get_ServerUri();
    [CompilerGeneratedAttribute]
public void set_ServerUri(Uri value);
    public Dictionary`2<string, string> get_Parameters();
    public ArcGISServerRestLayerImageFormat get_ImageFormat();
    public void set_ImageFormat(ArcGISServerRestLayerImageFormat value);
    [AsyncStateMachineAttribute("ThinkGeo.Core.Async.ArcGisServerRestLayer/DD8=")]
protected virtual Task DrawAsyncCore(GeoCanvas canvas, Collection`1<SimpleCandidate> labelsInAllLayers);
    private string 8h0=(Dictionary`2<string, string> tempDictionary);
}
[ObsoleteAttribute("This class is obsoleted and will be removed after v14.3, please use ThinkGeo.Core.BingMapsAsyncLayer instead")]
public class ThinkGeo.Core.Async.BingMapsLayer : XyzTileLayer {
    private static int /B0=;
    private static string /R0=;
    private static string /h0=;
    [ObfuscationAttribute]
private string applicationId;
    [ObfuscationAttribute]
private BingMapsMapType mapType;
    [ObfuscationAttribute]
private string imageUriTemplate;
    [ObfuscationAttribute]
private Collection`1<string> subDomains;
    [ObfuscationAttribute]
private GeoImage logo;
    [ObfuscationAttribute]
private bool isDirty;
    [ObfuscationAttribute]
private RequestProtocol httpRequestProtocol;
    public string ApplicationId { get; public set; }
    public BingMapsMapType MapType { get; public set; }
    public GeoImage Logo { get; }
    public RequestProtocol HttpRequestProtocol { get; public set; }
    public BingMapsLayer(string applicationId);
    public BingMapsLayer(string applicationId, BingMapsMapType mapType);
    private static BingMapsLayer();
    [AsyncStateMachineAttribute("ThinkGeo.Core.Async.BingMapsLayer/Iz8=")]
protected virtual Task OpenAsyncCore(CancellationToken cancellationToken);
    public string get_ApplicationId();
    public void set_ApplicationId(string value);
    public BingMapsMapType get_MapType();
    public void set_MapType(BingMapsMapType value);
    public GeoImage get_Logo();
    public RequestProtocol get_HttpRequestProtocol();
    public void set_HttpRequestProtocol(RequestProtocol value);
    [AsyncStateMachineAttribute("ThinkGeo.Core.Async.BingMapsLayer/ID8=")]
protected virtual Task DrawAsyncCore(GeoCanvas canvas, Collection`1<SimpleCandidate> labelsInAllLayers);
    [AsyncStateMachineAttribute("ThinkGeo.Core.Async.BingMapsLayer/IT8=")]
protected virtual Task`1<string> GetImageUriAsyncCore(int zoomLevel, long x, long y, float resolutionFactor);
    private static string /x0=(long tileX, long tileY, int levelOfDetail);
    [AsyncStateMachineAttribute("ThinkGeo.Core.Async.BingMapsLayer/Jj8=")]
private Task AB4=();
    [AsyncStateMachineAttribute("ThinkGeo.Core.Async.BingMapsLayer/JD8=")]
private Task`1<XmlDocument> AR4=(string xmlPath);
    [CompilerGeneratedAttribute]
[DebuggerHiddenAttribute]
private Task Ah4=(CancellationToken cancellationToken);
    [CompilerGeneratedAttribute]
[DebuggerHiddenAttribute]
private Task Ax4=(GeoCanvas canvas, Collection`1<SimpleCandidate> labelsInAllLayers);
}
[ObsoleteAttribute("This class is obsoleted and will be removed after v14.3, please use ThinkGeo.Core.GoogleMapsAsyncLayer instead")]
public class ThinkGeo.Core.Async.GoogleMapsLayer : WebBasedLayer {
    private static RectangleShape JB4=;
    [ObfuscationAttribute]
private ProjectionConverter projectionFromSphericalMercator;
    [ObfuscationAttribute]
private ProjectionConverter googleWgs84Projection;
    [ObfuscationAttribute]
private double currentRequestSphereResolution;
    [CompilerGeneratedAttribute]
private GoogleMapsPictureFormat JR4=;
    [CompilerGeneratedAttribute]
private GoogleMapsMapType Jh4=;
    [CompilerGeneratedAttribute]
private string Jx4=;
    [CompilerGeneratedAttribute]
private string Bx4=;
    [CompilerGeneratedAttribute]
private string KB4=;
    [CompilerGeneratedAttribute]
private string KR4=;
    [CompilerGeneratedAttribute]
private string Kh4=;
    [CompilerGeneratedAttribute]
private Dictionary`2<string, string> Kx4=;
    [CompilerGeneratedAttribute]
private Projection LB4=;
    public GoogleMapsPictureFormat PictureFormat { get; public set; }
    public GoogleMapsMapType MapType { get; public set; }
    public string Language { get; public set; }
    public string ClientId { get; public set; }
    public string PrivateKey { get; public set; }
    public string UriSigningSecret { get; public set; }
    public string ApiKey { get; public set; }
    public Dictionary`2<string, string> CustomParameters { get; }
    public Projection TargetProjection { get; public set; }
    public GoogleMapsLayer(string apiKey);
    public GoogleMapsLayer(string apiKey, string uriSigningSecret);
    private static GoogleMapsLayer();
    [CompilerGeneratedAttribute]
public GoogleMapsPictureFormat get_PictureFormat();
    [CompilerGeneratedAttribute]
public void set_PictureFormat(GoogleMapsPictureFormat value);
    [CompilerGeneratedAttribute]
public GoogleMapsMapType get_MapType();
    [CompilerGeneratedAttribute]
public void set_MapType(GoogleMapsMapType value);
    [CompilerGeneratedAttribute]
public string get_Language();
    [CompilerGeneratedAttribute]
public void set_Language(string value);
    [CompilerGeneratedAttribute]
public string get_ClientId();
    [CompilerGeneratedAttribute]
public void set_ClientId(string value);
    [CompilerGeneratedAttribute]
public string get_PrivateKey();
    [CompilerGeneratedAttribute]
public void set_PrivateKey(string value);
    [CompilerGeneratedAttribute]
public string get_UriSigningSecret();
    [CompilerGeneratedAttribute]
public void set_UriSigningSecret(string value);
    [CompilerGeneratedAttribute]
public string get_ApiKey();
    [CompilerGeneratedAttribute]
public void set_ApiKey(string value);
    [CompilerGeneratedAttribute]
public Dictionary`2<string, string> get_CustomParameters();
    [CompilerGeneratedAttribute]
public Projection get_TargetProjection();
    [CompilerGeneratedAttribute]
public void set_TargetProjection(Projection value);
    [AsyncStateMachineAttribute("ThinkGeo.Core.Async.GoogleMapsLayer/ND8=")]
protected virtual Task OpenAsyncCore(CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("ThinkGeo.Core.Async.GoogleMapsLayer/Lj8=")]
protected virtual Task CloseAsyncCore(CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("ThinkGeo.Core.Async.GoogleMapsLayer/Mz8=")]
protected virtual Task DrawAsyncCore(GeoCanvas canvas, Collection`1<SimpleCandidate> labelsInAllLayers);
    [AsyncStateMachineAttribute("ThinkGeo.Core.Async.GoogleMapsLayer/Lz8=")]
protected virtual Task`1<Byte[]> DownloadImageAsyncCore(double width, double height, double scaleFactor, RectangleShape extent, GeographyUnit mapUnit, CancellationToken cancellationToken);
    private RectangleShape LR4=(GeoCanvas canvas);
    private string Lh4=(double latitude, double longitude, int zoomLevelNumber, double tileWidth, double tileHeight, int scaleFactor);
    private static string Lx4=(double newWidth, double newHeight, int zoomLevelNumber, double latitude, double longitude);
    private string MB4=();
    public string GetPictureFormat();
    private string MR4=(string url);
    private string MR4=(string url, string uriSigningSecret);
    private static Byte[] Mh4=(string value);
    [CompilerGeneratedAttribute]
[DebuggerHiddenAttribute]
private Task Ah4=(CancellationToken cancellationToken);
    [CompilerGeneratedAttribute]
[DebuggerHiddenAttribute]
private Task Ax4=(CancellationToken cancellationToken);
}
[ObsoleteAttribute("This class is obsoleted and will be removed after v14.3, please use ThinkGeo.Core.HereMapsRasterTileAsyncLayer instead")]
public class ThinkGeo.Core.Async.HereMapsRasterTileLayer : XyzTileLayer {
    private static int /B0=;
    private static string Mx4=;
    private string NB4=;
    private string NR4=;
    private string Nh4=;
    [CompilerGeneratedAttribute]
private string Kh4=;
    [CompilerGeneratedAttribute]
private HereMapsRasterType Jh4=;
    [CompilerGeneratedAttribute]
private HereMapsRasterTileFormat Nx4=;
    [CompilerGeneratedAttribute]
private Dictionary`2<string, string> OB4=;
    public string ApiKey { get; public set; }
    public HereMapsRasterType MapType { get; public set; }
    public HereMapsRasterTileFormat Format { get; public set; }
    public Dictionary`2<string, string> Parameters { get; }
    public HereMapsRasterTileLayer(string apiKey);
    public HereMapsRasterTileLayer(string apiKey, HereMapsRasterType mapType);
    [CompilerGeneratedAttribute]
public string get_ApiKey();
    [CompilerGeneratedAttribute]
public void set_ApiKey(string value);
    [CompilerGeneratedAttribute]
public HereMapsRasterType get_MapType();
    [CompilerGeneratedAttribute]
public void set_MapType(HereMapsRasterType value);
    [CompilerGeneratedAttribute]
public HereMapsRasterTileFormat get_Format();
    [CompilerGeneratedAttribute]
public void set_Format(HereMapsRasterTileFormat value);
    [CompilerGeneratedAttribute]
public Dictionary`2<string, string> get_Parameters();
    protected virtual Task`1<string> GetImageUriAsyncCore(int zoomLevel, long x, long y, float resolutionFactor);
}
[ObsoleteAttribute("This class is obsoleted and will be removed after v14.3, please use ThinkGeo.Core.AsyncLayer instead")]
public abstract class ThinkGeo.Core.Async.LayerAsync : LayerBase {
    private Exception 8x0=;
    [CompilerGeneratedAttribute]
private double 9B0=;
    [CompilerGeneratedAttribute]
private double 9R0=;
    public double UpperThreshold { get; public set; }
    public double LowerThreshold { get; public set; }
    [CompilerGeneratedAttribute]
public double get_UpperThreshold();
    [CompilerGeneratedAttribute]
public void set_UpperThreshold(double value);
    [CompilerGeneratedAttribute]
public double get_LowerThreshold();
    [CompilerGeneratedAttribute]
public void set_LowerThreshold(double value);
    [AsyncStateMachineAttribute("ThinkGeo.Core.Async.LayerAsync/Hj8=")]
public Task OpenAsync(CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("ThinkGeo.Core.Async.LayerAsync/Hz8=")]
protected virtual Task OpenAsyncCore(CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("ThinkGeo.Core.Async.LayerAsync/FT8=")]
public Task CloseAsync(CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("ThinkGeo.Core.Async.LayerAsync/Fj8=")]
protected virtual Task CloseAsyncCore(CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("ThinkGeo.Core.Async.LayerAsync/Fz8=")]
public Task DrawAsync(GeoCanvas canvas, Collection`1<SimpleCandidate> labelsInAllLayers);
    [AsyncStateMachineAttribute("ThinkGeo.Core.Async.LayerAsync/HD8=")]
private Task 9h0=(GeoCanvas canvas, Collection`1<SimpleCandidate> labelsInAllLayers);
    protected abstract virtual Task DrawAsyncCore(GeoCanvas canvas, Collection`1<SimpleCandidate> labelsInAllLayers);
    private void 9x0=(object sender, DrawingProgressChangedEventArgs e);
}
[ObsoleteAttribute("This class is obsoleted and will be removed after v14.3, please use ThinkGeo.Core.MapBoxStaticTilesAsyncLayer instead")]
public class ThinkGeo.Core.Async.MapBoxStaticTilesLayer : XyzTileLayer {
    private static int /B0=;
    [ObfuscationAttribute]
private MapBoxStyleId styleId;
    [ObfuscationAttribute]
private string baseUrl;
    [ObfuscationAttribute]
private string apiVersion;
    [CompilerGeneratedAttribute]
private string OR4=;
    public string AccessToken { get; public set; }
    public MapBoxStyleId StyleId { get; public set; }
    public MapBoxStaticTilesLayer(string accessToken);
    public MapBoxStaticTilesLayer(string accessToken, MapBoxStyleId styleId);
    [CompilerGeneratedAttribute]
public string get_AccessToken();
    [CompilerGeneratedAttribute]
public void set_AccessToken(string value);
    public MapBoxStyleId get_StyleId();
    public void set_StyleId(MapBoxStyleId value);
    protected virtual Task`1<string> GetImageUriAsyncCore(int zoomLevel, long x, long y, float resolutionFactor);
    private string Oh4=();
    private void Ox4=(MapBoxStyleId id);
    private bool PB4=(string cacheId);
    private string PR4=(MapBoxStyleId id);
}
[ObsoleteAttribute("This class is obsoleted and will be removed after v14.3, please use ThinkGeo.Core.OpenStreetMapAsyncLayer instead")]
public class ThinkGeo.Core.Async.OpenStreetMapLayer : XyzTileLayer {
    [ObfuscationAttribute]
private static int TILE_SIZE;
    [ObfuscationAttribute]
private static Uri[] DefaultUris;
    [ObfuscationAttribute]
private Collection`1<Uri> customServerUris;
    public Collection`1<Uri> CustomServerUris { get; }
    public OpenStreetMapLayer(string userAgent);
    public OpenStreetMapLayer(IWebProxy webProxy);
    public OpenStreetMapLayer(string userAgent, IWebProxy webProxy);
    private static OpenStreetMapLayer();
    [AsyncStateMachineAttribute("ThinkGeo.Core.Async.OpenStreetMapLayer/NT8=")]
protected virtual Task OpenAsyncCore(CancellationToken cancellationToken);
    public Collection`1<Uri> get_CustomServerUris();
    protected virtual Task`1<string> GetImageUriAsyncCore(int zoomLevel, long x, long y, float resolutionFactor);
    [CompilerGeneratedAttribute]
[DebuggerHiddenAttribute]
private Task Ah4=(CancellationToken cancellationToken);
}
[ObsoleteAttribute("This class is obsoleted and will be removed after v14.3, please use ThinkGeo.Core.ThinkGeoRasterMapsAsyncLayer instead")]
public class ThinkGeo.Core.Async.ThinkGeoCloudRasterMapsLayer : XyzTileLayer {
    private static int /B0=;
    private BB4= Ph4=;
    private ThinkGeoCloudRasterMapsMapType Px4=;
    public RasterTileCache TileCache { get; public set; }
    public RasterTileCache ProjectedTileCache { get; public set; }
    public ProjectionConverter ProjectionConverterFromServerProjection { get; public set; }
    public ThinkGeoCloudRasterMapsMapType MapType { get; public set; }
    public string ClientId { get; public set; }
    public string ClientSecret { get; public set; }
    public ThinkGeoCloudRasterMapsLayer(string clientId, string clientSecret);
    public ThinkGeoCloudRasterMapsLayer(string clientId, string clientSecret, ThinkGeoCloudRasterMapsMapType mapType);
    public virtual RasterTileCache get_TileCache();
    public virtual void set_TileCache(RasterTileCache value);
    public virtual RasterTileCache get_ProjectedTileCache();
    public virtual void set_ProjectedTileCache(RasterTileCache value);
    public virtual ProjectionConverter get_ProjectionConverterFromServerProjection();
    public virtual void set_ProjectionConverterFromServerProjection(ProjectionConverter value);
    public ThinkGeoCloudRasterMapsMapType get_MapType();
    public void set_MapType(ThinkGeoCloudRasterMapsMapType value);
    public string get_ClientId();
    public void set_ClientId(string value);
    public string get_ClientSecret();
    public void set_ClientSecret(string value);
    [AsyncStateMachineAttribute("ThinkGeo.Core.Async.ThinkGeoCloudRasterMapsLayer/Nz8=")]
protected virtual Task OpenAsyncCore(CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("ThinkGeo.Core.Async.ThinkGeoCloudRasterMapsLayer/Nj8=")]
protected virtual Task CloseAsyncCore(CancellationToken cancellationToken);
    protected virtual Task`1<string> GetImageUriAsyncCore(int zoomLevel, long x, long y, float resolutionFactor);
    [AsyncStateMachineAttribute("ThinkGeo.Core.Async.ThinkGeoCloudRasterMapsLayer/OD8=")]
private void QB4=(object sender, SendingHttpRequestMessageEventArgs e);
    private void Ox4=();
    private string QR4=(string cacheIdWithSuffix);
    protected virtual int GetTileScale();
    private string Qh4=();
    private string Qx4=(ThinkGeoCloudRasterMapsMapType mapType);
    private string RB4=(ThinkGeoCloudRasterMapsMapType mapType);
    private string RR4=(ThinkGeoCloudRasterMapsMapType mapType);
    private GeoImageFormat 9RY=(ThinkGeoCloudRasterMapsMapType mapType);
    [CompilerGeneratedAttribute]
[DebuggerHiddenAttribute]
private Task Ah4=(CancellationToken cancellationToken);
    [CompilerGeneratedAttribute]
[DebuggerHiddenAttribute]
private Task Ax4=(CancellationToken cancellationToken);
}
[ObsoleteAttribute("This class is obsoleted and will be removed after v14.3, please use ThinkGeo.Core.ThinkGeoVectorMapsAsyncLayer instead")]
public class ThinkGeo.Core.Async.ThinkGeoCloudVectorMapsLayer : WebBasedLayer {
    private static int Rh4=;
    [ObfuscationAttribute]
private Uri styleJsonUri;
    [ObfuscationAttribute]
private RasterTileCache bitmapTileCache;
    private ZoomLevelSet Rx4=;
    private BB4= Ph4=;
    private ThinkGeoCloudVectorMapsMapType Px4=;
    private FileVectorTileCache SB4=;
    private ProjectionConverter SR4=;
    [CompilerGeneratedAttribute]
private bool Sh4=;
    [CompilerGeneratedAttribute]
private int Sx4=;
    private bool TB4=;
    public bool ShowDebugInfo { get; public set; }
    public int TileSize { get; public set; }
    public string ClientId { get; public set; }
    public string ClientSecret { get; public set; }
    public ThinkGeoCloudVectorMapsMapType MapType { get; public set; }
    public FileVectorTileCache VectorTileCache { get; public set; }
    public RasterTileCache BitmapTileCache { get; public set; }
    public Uri StyleJsonUri { get; public set; }
    public ProjectionConverter ProjectionConverter { get; public set; }
    public ThinkGeoCloudVectorMapsLayer(string clientId, string clientSecret);
    public ThinkGeoCloudVectorMapsLayer(string clientId, string clientSecret, Uri styleJsonUri);
    public ThinkGeoCloudVectorMapsLayer(string clientId, string clientSecret, ThinkGeoCloudVectorMapsMapType mapType);
    [CompilerGeneratedAttribute]
public bool get_ShowDebugInfo();
    [CompilerGeneratedAttribute]
public void set_ShowDebugInfo(bool value);
    [CompilerGeneratedAttribute]
public int get_TileSize();
    [CompilerGeneratedAttribute]
public void set_TileSize(int value);
    public string get_ClientId();
    public void set_ClientId(string value);
    public string get_ClientSecret();
    public void set_ClientSecret(string value);
    public ThinkGeoCloudVectorMapsMapType get_MapType();
    public void set_MapType(ThinkGeoCloudVectorMapsMapType value);
    public FileVectorTileCache get_VectorTileCache();
    public void set_VectorTileCache(FileVectorTileCache value);
    public RasterTileCache get_BitmapTileCache();
    public void set_BitmapTileCache(RasterTileCache value);
    public Uri get_StyleJsonUri();
    public void set_StyleJsonUri(Uri value);
    public ProjectionConverter get_ProjectionConverter();
    public void set_ProjectionConverter(ProjectionConverter value);
    [AsyncStateMachineAttribute("ThinkGeo.Core.Async.ThinkGeoCloudVectorMapsLayer/ND8=")]
protected virtual Task OpenAsyncCore(CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("ThinkGeo.Core.Async.ThinkGeoCloudVectorMapsLayer/Lj8=")]
protected virtual Task CloseAsyncCore(CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("ThinkGeo.Core.Async.ThinkGeoCloudVectorMapsLayer/WD8=")]
private Task`1<Collection`1<Feature>> TR4=(int zoom, long column, long row, List`1<string> pbfLayerNames, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("ThinkGeo.Core.Async.ThinkGeoCloudVectorMapsLayer/WT8=")]
private Task`1<VectorTile> Th4=(int zoom, long column, long row, CancellationToken cancellationToken);
    private void Tx4=();
    [AsyncStateMachineAttribute("ThinkGeo.Core.Async.ThinkGeoCloudVectorMapsLayer/VD8=")]
public Task DrawTileAsync(GeoCanvas canvas, int zoomIndex, long columnIndex, long rowIndex);
    [AsyncStateMachineAttribute("ThinkGeo.Core.Async.ThinkGeoCloudVectorMapsLayer/RD8=")]
protected virtual Task DrawAsyncCore(GeoCanvas canvas, Collection`1<SimpleCandidate> labelsInAllLayers);
    private void Ox4=(ThinkGeoCloudVectorMapsMapType mapType);
    private bool PB4=(string cacheId);
    [CompilerGeneratedAttribute]
[DebuggerHiddenAttribute]
private Task Ah4=(CancellationToken cancellationToken);
    [CompilerGeneratedAttribute]
[DebuggerHiddenAttribute]
private Task Ax4=(CancellationToken cancellationToken);
}
[ObsoleteAttribute("This class is obsoleted and will be removed after v14.3, please use ThinkGeo.Core.WebBasedAsyncLayer instead")]
public abstract class ThinkGeo.Core.Async.WebBasedLayer : LayerAsync {
    [CompilerGeneratedAttribute]
private EventHandler`1<SendingHttpRequestMessageEventArgs> UB4=;
    [CompilerGeneratedAttribute]
private EventHandler`1<ReceivedHttpResponseMessageEventArgs> UR4=;
    [CompilerGeneratedAttribute]
private HttpClient Uh4=;
    [CompilerGeneratedAttribute]
private IWebProxy Ch4=;
    [CompilerGeneratedAttribute]
private int CR4=;
    [CompilerGeneratedAttribute]
private ICredentials Ux4=;
    [CompilerGeneratedAttribute]
private string VB4=;
    protected HttpClient HttpClient { get; protected set; }
    public IWebProxy WebProxy { get; public set; }
    public int TimeoutInSeconds { get; public set; }
    public ICredentials Credentials { get; public set; }
    public string UserAgent { get; public set; }
    [CompilerGeneratedAttribute]
public void add_SendingHttpRequest(EventHandler`1<SendingHttpRequestMessageEventArgs> value);
    [CompilerGeneratedAttribute]
public void remove_SendingHttpRequest(EventHandler`1<SendingHttpRequestMessageEventArgs> value);
    [CompilerGeneratedAttribute]
public void add_ReceivedHttpResponse(EventHandler`1<ReceivedHttpResponseMessageEventArgs> value);
    [CompilerGeneratedAttribute]
public void remove_ReceivedHttpResponse(EventHandler`1<ReceivedHttpResponseMessageEventArgs> value);
    [CompilerGeneratedAttribute]
protected HttpClient get_HttpClient();
    [CompilerGeneratedAttribute]
protected void set_HttpClient(HttpClient value);
    [CompilerGeneratedAttribute]
public sealed virtual IWebProxy get_WebProxy();
    [CompilerGeneratedAttribute]
public sealed virtual void set_WebProxy(IWebProxy value);
    [CompilerGeneratedAttribute]
public sealed virtual int get_TimeoutInSeconds();
    [CompilerGeneratedAttribute]
public sealed virtual void set_TimeoutInSeconds(int value);
    [AsyncStateMachineAttribute("ThinkGeo.Core.Async.WebBasedLayer/YT8=")]
protected virtual Task OpenAsyncCore(CancellationToken cancellationToken);
    [CompilerGeneratedAttribute]
public sealed virtual ICredentials get_Credentials();
    [CompilerGeneratedAttribute]
public sealed virtual void set_Credentials(ICredentials value);
    [AsyncStateMachineAttribute("ThinkGeo.Core.Async.WebBasedLayer/Yj8=")]
protected Task`1<HttpResponseMessage> SendWebRequestAsync(HttpRequestMessage httpRequest, CancellationToken cancellationToken);
    [CompilerGeneratedAttribute]
public sealed virtual string get_UserAgent();
    [CompilerGeneratedAttribute]
public sealed virtual void set_UserAgent(string value);
    public Task`1<Byte[]> FetchImageAsync(HttpRequestMessage requestMessage, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("ThinkGeo.Core.Async.WebBasedLayer/XD8=")]
protected Task`1<Byte[]> FetchImageAsyncCore(HttpRequestMessage requestMessage, CancellationToken cancellationToken);
    public Task`1<Byte[]> DownloadImageAsync(double width, double height, double scaleFactor, RectangleShape extent, GeographyUnit mapUnit, CancellationToken cancellationToken);
    protected virtual Task`1<Byte[]> DownloadImageAsyncCore(double width, double height, double scaleFactor, RectangleShape extent, GeographyUnit mapUnit, CancellationToken cancellationToken);
    protected virtual void OnSendingHttpRequestMessage(SendingHttpRequestMessageEventArgs e);
    protected virtual void OnReceivedHttpResponseMessage(ReceivedHttpResponseMessageEventArgs e);
    [CompilerGeneratedAttribute]
[DebuggerHiddenAttribute]
private Task Ah4=(CancellationToken cancellationToken);
}
[ObsoleteAttribute("This class is obsoleted and will be removed after v14.3, please use ThinkGeo.Core.WmsAsyncLayer instead")]
public class ThinkGeo.Core.Async.WmsLayer : WebBasedLayer {
    private XmlDocument VR4=;
    [ObfuscationAttribute]
private string _crs;
    [ObfuscationAttribute]
private String[] _exceptionFormats;
    [ObfuscationAttribute]
private RectangleShape _currentExtent;
    [ObfuscationAttribute]
private WmsOnlineResource[] _wmsRequests;
    [ObfuscationAttribute]
private bool _hasParsedCapabilities;
    [ObfuscationAttribute]
private Collection`1<string> _serverCrsCollection;
    [ObfuscationAttribute]
private Collection`1<string> _serverLayerNames;
    [ObfuscationAttribute]
private Collection`1<string> _serverOutputFormats;
    [ObfuscationAttribute]
private Collection`1<string> _serverFeatureInfoFormats;
    [ObfuscationAttribute]
private Collection`1<string> _serverStyleNames;
    [ObfuscationAttribute]
private string _version;
    [ObfuscationAttribute]
private int _height;
    [ObfuscationAttribute]
private int _width;
    private WmsServerLayer Vh4=;
    private Collection`1<WmsServerLayer> Vx4=;
    [ObfuscationAttribute]
private Uri _uri;
    [ObfuscationAttribute]
private WmsAxisOrder _axisOrder;
    [ObfuscationAttribute]
private string _hrefNamespace;
    [ObfuscationAttribute]
private String[] _availableHrefNamespace;
    [ObfuscationAttribute]
private bool _fastMode;
    private static object WB4=;
    [CompilerGeneratedAttribute]
private EventHandler`1<RequestedImageExceptionEventArgs> WR4=;
    [CompilerGeneratedAttribute]
private Collection`1<string> Wh4=;
    [CompilerGeneratedAttribute]
private Collection`1<string> Wx4=;
    [CompilerGeneratedAttribute]
private bool XB4=;
    [CompilerGeneratedAttribute]
private string XR4=;
    [CompilerGeneratedAttribute]
private string Xh4=;
    [CompilerGeneratedAttribute]
private Dictionary`2<string, string> OB4=;
    [CompilerGeneratedAttribute]
private TimeSpan Xx4=;
    public Collection`1<string> ActiveLayerNames { get; }
    public Collection`1<string> ActiveStyleNames { get; }
    public Uri Uri { get; public set; }
    public string Version { get; }
    public bool IsTransparent { get; public set; }
    public string OutputFormat { get; public set; }
    public string Crs { get; public set; }
    public string Exceptions { get; public set; }
    public Dictionary`2<string, string> Parameters { get; }
    public WmsAxisOrder AxisOrder { get; public set; }
    public bool FastMode { get; public set; }
    public TimeSpan CapabilitiesCacheTimeout { get; public set; }
    public bool HasBoundingBox { get; }
    public WmsLayer(Uri uri);
    public WmsLayer(Uri uri, IWebProxy webProxy);
    public WmsLayer(Uri uri, IWebProxy webProxy, string crs, WmsAxisOrder axisOrder, string version, bool fastMode);
    public WmsLayer(Collection`1<WmsServerLayer> flatWmsServerLayers);
    private static WmsLayer();
    [CompilerGeneratedAttribute]
public void add_RequestedImageException(EventHandler`1<RequestedImageExceptionEventArgs> value);
    [CompilerGeneratedAttribute]
public void remove_RequestedImageException(EventHandler`1<RequestedImageExceptionEventArgs> value);
    protected virtual void OnRequestedImageException(RequestedImageExceptionEventArgs e);
    [CompilerGeneratedAttribute]
public sealed virtual Collection`1<string> get_ActiveLayerNames();
    [CompilerGeneratedAttribute]
public sealed virtual Collection`1<string> get_ActiveStyleNames();
    public sealed virtual Uri get_Uri();
    public sealed virtual void set_Uri(Uri value);
    public sealed virtual string get_Version();
    [CompilerGeneratedAttribute]
public sealed virtual bool get_IsTransparent();
    [CompilerGeneratedAttribute]
public sealed virtual void set_IsTransparent(bool value);
    [CompilerGeneratedAttribute]
public sealed virtual string get_OutputFormat();
    [CompilerGeneratedAttribute]
public sealed virtual void set_OutputFormat(string value);
    public sealed virtual string get_Crs();
    public sealed virtual void set_Crs(string value);
    [CompilerGeneratedAttribute]
public sealed virtual string get_Exceptions();
    [CompilerGeneratedAttribute]
public sealed virtual void set_Exceptions(string value);
    [CompilerGeneratedAttribute]
public sealed virtual Dictionary`2<string, string> get_Parameters();
    public sealed virtual WmsAxisOrder get_AxisOrder();
    public sealed virtual void set_AxisOrder(WmsAxisOrder value);
    public sealed virtual bool get_FastMode();
    public sealed virtual void set_FastMode(bool value);
    [CompilerGeneratedAttribute]
public sealed virtual TimeSpan get_CapabilitiesCacheTimeout();
    [CompilerGeneratedAttribute]
public sealed virtual void set_CapabilitiesCacheTimeout(TimeSpan value);
    public virtual bool get_HasBoundingBox();
    public Collection`1<WmsServerLayer> GetServerLayers();
    public Collection`1<string> GetServerStyleNames();
    public Collection`1<string> GetServerOutputFormats();
    public Collection`1<string> GetServerCrsCollection();
    public Collection`1<string> GetServerExceptionFormats();
    public string GetServiceVersion();
    public string GetServiceBaseUrl();
    public Collection`1<string> GetServerFeatureInfoFormats();
    public string GetServerCapabilitiesXml();
    public string GetRequestUrl(RectangleShape worldExtent, int canvasWidth, int canvasHeight);
    protected virtual string GetRequestUrlCore(RectangleShape worldExtent, int canvasWidth, int canvasHeight);
    [AsyncStateMachineAttribute("ThinkGeo.Core.Async.WmsLayer/fz8=")]
protected virtual Task OpenAsyncCore(CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("ThinkGeo.Core.Async.WmsLayer/ZT8=")]
protected virtual Task CloseAsyncCore(CancellationToken cancellationToken);
    protected virtual RectangleShape GetBoundingBoxCore();
    [AsyncStateMachineAttribute("ThinkGeo.Core.Async.WmsLayer/aj8=")]
protected virtual Task DrawAsyncCore(GeoCanvas canvas, Collection`1<SimpleCandidate> labelsInAllLayers);
    private bool sx0=();
    private static int YB4=(string texts, int fontSize);
    private static string xhQ=(XmlDocument xmlDocument);
    private static string YR4=(string message, int width);
    private WmsOnlineResource Yh4=();
    private void Yx4=();
    private void ZB4=(WmsServerLayer serverLayer);
    private void ZR4=(WmsServerLayer serverLayer);
    private void Zh4=(WmsServerLayer serverLayer);
    private void Zx4=(WmsServerLayer layer);
    [AsyncStateMachineAttribute("ThinkGeo.Core.Async.WmsLayer/gD8=")]
private Task aB4=(string url, CancellationToken cancellationToken);
    private static void aR4=(string requestCapabilities, XmlDocument xmlDocument);
    [AsyncStateMachineAttribute("ThinkGeo.Core.Async.WmsLayer/bz8=")]
private Task`1<XmlDocument> ah4=(string requestCapabilities);
    [AsyncStateMachineAttribute("ThinkGeo.Core.Async.WmsLayer/ez8=")]
private Task`1<XmlDocument> ax4=(string requestCapabilities, IWebProxy proxy, ICredentials credentials, CancellationToken cancellationToken);
    private void bB4=(XmlDocument xmlDocument, XmlNamespaceManager namespaceManager);
    private static string bR4=(XmlNode node, string nodeName, XmlNamespaceManager namespaceManager);
    private void bh4=(XmlNode nodeCapability, XmlNamespaceManager namespaceManager);
    private void bx4=(XmlNode xmlRequestNode, XmlNamespaceManager namespaceManager);
    private WmsServerLayer cB4=(XmlNode xmlLayer, XmlNamespaceManager namespaceManager);
    private XmlAttribute cR4=(XmlNode xmlNode);
    private RectangleShape ch4=(XmlNode xmlLayer, XmlNamespaceManager namespaceManager);
    private void cx4=(XmlNode xnException, XmlNamespaceManager namespaceManager);
    private void dB4=(HttpRequestMessage httpRequestMessage);
    private static Collection`1<string> dR4=(IEnumerable`1<string> collection);
    private static Collection`1<WmsServerLayer> dR4=(IEnumerable`1<WmsServerLayer> collection);
    private void dh4=(string propertyName);
    protected virtual string BuildWmsGetFeatureInfoUri(ScreenPointF screenPointF, string infoFormat, int maxFeatures);
    [AsyncStateMachineAttribute("ThinkGeo.Core.Async.WmsLayer/dT8=")]
public Task`1<Dictionary`2<string, Collection`1<Feature>>> GetFeatureInfoAsync(ScreenPointF screenPointF, int maxFeatures, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("ThinkGeo.Core.Async.WmsLayer/dj8=")]
public Task`1<Dictionary`2<string, Collection`1<Feature>>> GetFeatureInfoAsync(ScreenPointF screenPointF, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("ThinkGeo.Core.Async.WmsLayer/dz8=")]
public Task`1<Dictionary`2<string, Collection`1<Feature>>> GetFeatureInfoAsync(ScreenPointF screenPointF, string infoFormat, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("ThinkGeo.Core.Async.WmsLayer/cj8=")]
public Task`1<Dictionary`2<string, Collection`1<Feature>>> GetFeatureInfo(ScreenPointF screenPointF, int maxFeatures, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("ThinkGeo.Core.Async.WmsLayer/eT8=")]
public Task`1<Dictionary`2<string, Collection`1<Feature>>> GetFeatureInfoAsync(ScreenPointF screenPointF, string infoFormat, int maxFeatures, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("ThinkGeo.Core.Async.WmsLayer/ej8=")]
protected virtual Task`1<Dictionary`2<string, Collection`1<Feature>>> GetFeatureInfoAsyncCore(ScreenPointF screenPointF, string infoFormat, int maxFeatures, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("ThinkGeo.Core.Async.WmsLayer/Zj8=")]
protected virtual Task`1<Byte[]> DownloadImageAsyncCore(double width, double height, double scaleFactor, RectangleShape extent, GeographyUnit mapUnit, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("ThinkGeo.Core.Async.WmsLayer/fD8=")]
internal Task`1<Dictionary`2<string, Collection`1<Feature>>> dx4=(HttpRequestMessage request, CancellationToken cancellationToken);
    internal Dictionary`2<string, Collection`1<Feature>> eB4=(XmlDocument xmlDocument);
    [CompilerGeneratedAttribute]
[DebuggerHiddenAttribute]
private Task Ah4=(CancellationToken cancellationToken);
    [CompilerGeneratedAttribute]
[DebuggerHiddenAttribute]
private Task Ax4=(CancellationToken cancellationToken);
}
[ObsoleteAttribute("This class is obsoleted and will be removed after v14.3, please use ThinkGeo.Core.WmtsAsyncLayer instead")]
public class ThinkGeo.Core.Async.WmtsLayer : XyzTileLayer {
    [ObfuscationAttribute]
private Collection`1<Uri> serverUris;
    [ObfuscationAttribute]
private Uri serverUri;
    [ObfuscationAttribute]
private Dictionary`2<string, WmtsTileMatrixSet> tileMatrixSets;
    [ObfuscationAttribute]
private Collection`1<WmtsServerLayer> wmtsServerLayers;
    [ObfuscationAttribute]
private string activeLayerName;
    [ObfuscationAttribute]
private string activeStyleName;
    [ObfuscationAttribute]
private WmtsSeverEncodingType wmtsSeverEncodingType;
    [ObfuscationAttribute]
private string tileMatrixSetName;
    [ObfuscationAttribute]
private Dictionary`2<string, string> parameters;
    [ObfuscationAttribute]
private string outputFormat;
    [ObfuscationAttribute]
private double lowerScale;
    [ObfuscationAttribute]
private double upperScale;
    [ObfuscationAttribute]
private XmlDocument xmlDoc;
    [ObfuscationAttribute]
private TimeSpan capabilitesCacheTimeout;
    [ObfuscationAttribute]
private double wmtsConversionFactorForMeter;
    [ObfuscationAttribute]
private Dictionary`2<string, string> dimensions;
    [ObfuscationAttribute]
private WmtsAxisOrder axisOrder;
    [ObfuscationAttribute]
private RasterTileCache projectedTileCache;
    [ObfuscationAttribute]
private bool isCacheOnly;
    [ObfuscationAttribute]
private Dictionary`2<WmtsSeverEncodingType, string> getTileEncodingTypes;
    [ObsoleteAttribute("This property is obsoleted and will be removed after v14.4. Please use ServerUri instead.")]
public Collection`1<Uri> ServerUris { get; }
    public Uri ServerUri { get; public set; }
    private Dictionary`2<string, string> ex4= { get; private set; }
    public TimeSpan CapabilitesCacheTimeout { get; public set; }
    public string ActiveLayerName { get; public set; }
    public WmtsSeverEncodingType WmtsSeverEncodingType { get; public set; }
    public Collection`1<WmtsServerLayer> WmtsServerLayers { get; public set; }
    public string ActiveStyleName { get; public set; }
    public Dictionary`2<string, string> Parameters { get; }
    public string OutputFormat { get; public set; }
    public double LowerScale { get; public set; }
    public double UpperScale { get; public set; }
    public string TileMatrixSetName { get; public set; }
    public WmtsAxisOrder AxisOrder { get; public set; }
    [ObsoleteAttribute("This property is obsoleted and will be removed after v14.3. Please use ProjectionConverterFromServerProjection instead. ")]
public ProjectionConverter ProjectionConverter { get; public set; }
    public RasterTileCache ProjectedTileCache { get; public set; }
    public bool IsCacheOnly { get; public set; }
    public Dictionary`2<string, WmtsTileMatrixSet> TileMatrixSets { get; }
    public bool HasBoundingBox { get; }
    [ObsoleteAttribute("This constructor is obsoleted and will be removed after v14.4.")]
public WmtsLayer(IEnumerable`1<Uri> serverUris);
    [ObsoleteAttribute("This constructor is obsoleted and will be removed after v14.4.")]
public WmtsLayer(IEnumerable`1<Uri> serverUris, IWebProxy webProxy);
    [ObsoleteAttribute("This constructor is obsoleted and will be removed after v14.4.")]
public WmtsLayer(IEnumerable`1<Uri> serverUris, IWebProxy webProxy, WmtsSeverEncodingType wmtsSeverEncodingType);
    public WmtsLayer(Uri serverUri);
    public WmtsLayer(Uri serverUri, IWebProxy webProxy);
    public WmtsLayer(Uri serverUri, IWebProxy webProxy, WmtsSeverEncodingType wmtsSeverEncodingType);
    public Collection`1<Uri> get_ServerUris();
    public Uri get_ServerUri();
    public void set_ServerUri(Uri value);
    private Dictionary`2<string, string> eR4=();
    private void eh4=(Dictionary`2<string, string> value);
    public TimeSpan get_CapabilitesCacheTimeout();
    public void set_CapabilitesCacheTimeout(TimeSpan value);
    public string get_ActiveLayerName();
    public void set_ActiveLayerName(string value);
    public WmtsSeverEncodingType get_WmtsSeverEncodingType();
    public void set_WmtsSeverEncodingType(WmtsSeverEncodingType value);
    public Collection`1<WmtsServerLayer> get_WmtsServerLayers();
    public void set_WmtsServerLayers(Collection`1<WmtsServerLayer> value);
    public string get_ActiveStyleName();
    public void set_ActiveStyleName(string value);
    public Dictionary`2<string, string> get_Parameters();
    public string get_OutputFormat();
    public void set_OutputFormat(string value);
    public double get_LowerScale();
    public void set_LowerScale(double value);
    public double get_UpperScale();
    public void set_UpperScale(double value);
    public string get_TileMatrixSetName();
    public void set_TileMatrixSetName(string value);
    public WmtsAxisOrder get_AxisOrder();
    public void set_AxisOrder(WmtsAxisOrder value);
    public ProjectionConverter get_ProjectionConverter();
    public void set_ProjectionConverter(ProjectionConverter value);
    public RasterTileCache get_ProjectedTileCache();
    public void set_ProjectedTileCache(RasterTileCache value);
    public bool get_IsCacheOnly();
    public void set_IsCacheOnly(bool value);
    public Dictionary`2<string, WmtsTileMatrixSet> get_TileMatrixSets();
    [AsyncStateMachineAttribute("ThinkGeo.Core.Async.WmtsLayer/c0E=")]
protected virtual Task OpenAsyncCore(CancellationToken cancellationToken);
    public virtual bool get_HasBoundingBox();
    public RectangleShape GetWGS84BoundingBox();
    protected virtual RectangleShape GetBoundingBoxCore();
    public Collection`1<Uri> GetRequestUris(RectangleShape requestExtent, int canvasWidth, int canvasHeight);
    protected virtual Collection`1<Uri> GetRequestUrisCore(RectangleShape requestExtent, int canvasWidth, int canvasHeight);
    public string GetServerCapabilitiesXml();
    public Collection`1<string> GetServerLayerNames();
    public Collection`1<string> GetServerLayerStyles();
    public Collection`1<string> GetServerTileMatrixSetNames();
    public Collection`1<WmtsSeverEncodingType> GetServerEncodingType();
    public Collection`1<string> GetLayerOutputFormats(string layerName);
    protected virtual Task CloseAsyncCore(CancellationToken cancellationToken);
    private Uri 8h0=();
    private Tuple`2<string, string> fB4=();
    [AsyncStateMachineAttribute("ThinkGeo.Core.Async.WmtsLayer/b0E=")]
private Task fR4=(CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("ThinkGeo.Core.Async.WmtsLayer/ckE=")]
private Task`1<bool> fh4=(string kvpUrl, CancellationToken cancellationToken);
    public bool RemoveCachedCapability();
    private string fx4=();
    private void bB4=(XmlElement element, XmlNamespaceManager namespaceManager);
    private void gB4=(XmlNode operationTileNode, XmlNamespaceManager namespaceManager);
    public ZoomLevelSet GetZoomLevelSet(string tileMatrixSetName);
    public TileMatrix GetTileMatrix(string tileMatrixSetName, double scale);
    private void gR4=(XmlNode node, XmlNamespaceManager namespaceManager);
    private void gh4=(T& left, T& top);
    private void gx4=(XmlNode node, XmlNamespaceManager namespaceManager);
    [AsyncStateMachineAttribute("ThinkGeo.Core.Async.WmtsLayer/bkE=")]
protected virtual Task DrawAsyncCore(GeoCanvas canvas, Collection`1<SimpleCandidate> labelsInAllLayers);
    private int hB4=(double newWidth, RectangleShape newTileExtent, GeographyUnit mapUnit);
    protected virtual void DrawExceptionCore(GeoCanvas canvas, Exception e);
    private string hR4=(WmtsServerLayer serverLayer, string zoomLevel, long y, long x, string tileMatrixSetName, int resourceURLIndex);
    public string GetRequestUri(long x, long y, int zoomLevel);
    private string hh4=(string requestString);
    [AsyncStateMachineAttribute("ThinkGeo.Core.Async.WmtsLayer/cEE=")]
private Task`1<CloudRasterTileInfo> hx4=(MatrixCell cell, int zoomLevelIndex, int tileSize, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("ThinkGeo.Core.Async.WmtsLayer/cUE=")]
private Task`1<RasterTile> iB4=(int zoomLevel, long x, long y, CancellationToken cancellationToken);
    protected virtual Task`1<string> GetImageUriAsyncCore(int zoomLevel, long x, long y, float resolutionFactor);
    [CompilerGeneratedAttribute]
[DebuggerHiddenAttribute]
private Task Ah4=(CancellationToken cancellationToken);
    [CompilerGeneratedAttribute]
private bool iT0=(WmtsServerLayer l);
    [CompilerGeneratedAttribute]
private bool ij0=(WmtsServerLayer l);
    [CompilerGeneratedAttribute]
private bool iz0=(WmtsServerLayer l);
}
[ObsoleteAttribute("This class is obsoleted and will be removed after v14.3, please use ThinkGeo.Core.XyzTileAsyncLayer instead")]
public abstract class ThinkGeo.Core.Async.XyzTileLayer : WebBasedLayer {
    [ObfuscationAttribute]
private RasterTileCache tileCache;
    [ObfuscationAttribute]
private RasterTileCache projectedTileCache;
    [ObfuscationAttribute]
private ProjectionConverter projectionConverterFromServerProjection;
    [ObfuscationAttribute]
private int cloudTileWidth;
    [ObfuscationAttribute]
private int cloudTileHeight;
    [ObfuscationAttribute]
private RectangleShape maxExtent;
    [ObfuscationAttribute]
private GeographyUnit cloudTileMapUnit;
    public int TileWidth { get; protected set; }
    public int TileHeight { get; protected set; }
    public GeographyUnit MapUnit { get; protected set; }
    public RectangleShape MaxExtent { get; protected set; }
    public RasterTileCache TileCache { get; public set; }
    public RasterTileCache ProjectedTileCache { get; public set; }
    public ProjectionConverter ProjectionConverterFromServerProjection { get; public set; }
    public XyzTileLayer(int tileSize, GeographyUnit mapUnit, RectangleShape maxExtent);
    public int get_TileWidth();
    protected void set_TileWidth(int value);
    public int get_TileHeight();
    protected void set_TileHeight(int value);
    public GeographyUnit get_MapUnit();
    protected void set_MapUnit(GeographyUnit value);
    public RectangleShape get_MaxExtent();
    protected void set_MaxExtent(RectangleShape value);
    public virtual RasterTileCache get_TileCache();
    public virtual void set_TileCache(RasterTileCache value);
    public virtual RasterTileCache get_ProjectedTileCache();
    public virtual void set_ProjectedTileCache(RasterTileCache value);
    public virtual ProjectionConverter get_ProjectionConverterFromServerProjection();
    public virtual void set_ProjectionConverterFromServerProjection(ProjectionConverter value);
    [AsyncStateMachineAttribute("ThinkGeo.Core.Async.XyzTileLayer/tT8=")]
public Task`1<string> GetImageUriAsync(int zoomLevel, long x, long y, float resolutionFactor);
    protected abstract virtual Task`1<string> GetImageUriAsyncCore(int zoomLevel, long x, long y, float resolutionFactor);
    protected virtual Task OpenAsyncCore(CancellationToken cancellationToken);
    protected virtual Task CloseAsyncCore(CancellationToken cancellationToken);
    protected virtual int GetTileScale();
    [AsyncStateMachineAttribute("ThinkGeo.Core.Async.XyzTileLayer/pT8=")]
protected virtual Task DrawAsyncCore(GeoCanvas canvas, Collection`1<SimpleCandidate> labelsInAllLayers);
    private static Dictionary`2<ValueTuple`2<long, long>, MatrixCell> jB4=(TileMatrix tileMatrix, RectangleShape requestedExtent, WrappingMode wrapDateline);
    protected virtual RectangleShape GetBoundingBoxCore();
    [AsyncStateMachineAttribute("ThinkGeo.Core.Async.XyzTileLayer/tz8=")]
private Task`1<RasterTile> iB4=(int zoomLevel, long x, long y, float resolutionFactor, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("ThinkGeo.Core.Async.XyzTileLayer/sz8=")]
private Task`1<CloudRasterTileInfo> hx4=(MatrixCell cell, int zoomLevelIndex, float scaleFactor, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("ThinkGeo.Core.Async.XyzTileLayer/pD8=")]
public Task`1<Byte[]> DownloadImageAsync(int zoomLevelIndex, long column, long row, float scaleFactor, CancellationToken cancellationToken);
}
public abstract class ThinkGeo.Core.AsyncLayer : LayerBase {
    private Exception 8x0=;
    [CompilerGeneratedAttribute]
private double 9B0=;
    [CompilerGeneratedAttribute]
private double 9R0=;
    public double UpperThreshold { get; public set; }
    public double LowerThreshold { get; public set; }
    [CompilerGeneratedAttribute]
public double get_UpperThreshold();
    [CompilerGeneratedAttribute]
public void set_UpperThreshold(double value);
    [CompilerGeneratedAttribute]
public double get_LowerThreshold();
    [CompilerGeneratedAttribute]
public void set_LowerThreshold(double value);
    [AsyncStateMachineAttribute("ThinkGeo.Core.AsyncLayer/Hj8=")]
public Task OpenAsync(CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("ThinkGeo.Core.AsyncLayer/Hz8=")]
protected virtual Task OpenAsyncCore(CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("ThinkGeo.Core.AsyncLayer/FT8=")]
public Task CloseAsync(CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("ThinkGeo.Core.AsyncLayer/Fj8=")]
protected virtual Task CloseAsyncCore(CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("ThinkGeo.Core.AsyncLayer/Fz8=")]
public Task DrawAsync(GeoCanvas canvas, Collection`1<SimpleCandidate> labelsInAllLayers);
    [AsyncStateMachineAttribute("ThinkGeo.Core.AsyncLayer/HD8=")]
private Task 9h0=(GeoCanvas canvas, Collection`1<SimpleCandidate> labelsInAllLayers);
    protected abstract virtual Task DrawAsyncCore(GeoCanvas canvas, Collection`1<SimpleCandidate> labelsInAllLayers);
    private void 9x0=(object sender, DrawingProgressChangedEventArgs e);
}
public static class ThinkGeo.Core.AsyncLocker : object {
    private static ConcurrentDictionary`2<object, SemaphoreSlim> ah0=;
    private static AsyncLocker();
    [AsyncStateMachineAttribute("ThinkGeo.Core.AsyncLocker/7T4=")]
public static Task`1<IDisposable> LockAsync(object lockObject);
}
public class ThinkGeo.Core.BackgroundLayer : Layer {
    [ObfuscationAttribute]
private GeoBrush backgroundBrush;
    public GeoBrush BackgroundBrush { get; public set; }
    public BackgroundLayer(GeoBrush backgroundBrush);
    public GeoBrush get_BackgroundBrush();
    public void set_BackgroundBrush(GeoBrush value);
    protected virtual void DrawCore(GeoCanvas canvas, Collection`1<SimpleCandidate> labelsInAllLayers);
}
public enum ThinkGeo.Core.BasAnnotationTextStylingType : Enum {
    public int value__;
    public static BasAnnotationTextStylingType Default;
    public static BasAnnotationTextStylingType CustomStyling;
    public static BasAnnotationTextStylingType StandardStyling;
}
public abstract class ThinkGeo.Core.BaseShape : object {
    private static int 3Ro=;
    [ObfuscationAttribute]
private string id;
    [ObfuscationAttribute]
private object tag;
    public string Id { get; public set; }
    public object Tag { get; public set; }
    private static BaseShape();
    public string get_Id();
    public void set_Id(string value);
    public object get_Tag();
    public void set_Tag(object value);
    public static BaseShape CreateShapeFromWellKnownData(string wellKnownText);
    public void LoadFromWellKnownData(string wellKnownText);
    protected abstract virtual void LoadFromWellKnownDataCore(string wellKnownText);
    public string GetWellKnownText();
    public string GetGeoJson();
    protected virtual string GetGeoJsonCore();
    public string GetWellKnownText(RingOrder outerRingOrder);
    protected abstract virtual string GetWellKnownTextCore(RingOrder outerRingOrder);
    public static BaseShape CreateShapeFromWellKnownData(Byte[] wellKnownBinary);
    public static BaseShape CreateShapeFromGeoJson(string geoJson);
    public void LoadFromWellKnownData(Byte[] wellKnownBinary);
    protected virtual void LoadFromWellKnownDataCore(Byte[] wellKnownBinary);
    public Byte[] GetWellKnownBinary();
    public Byte[] GetWellKnownBinary(WkbByteOrder byteOrder);
    public Byte[] GetWellKnownBinary(RingOrder outerRingOrder);
    public Byte[] GetWellKnownBinary(RingOrder outerRingOrder, WkbByteOrder byteOrder);
    protected virtual Byte[] GetWellKnownBinaryCore(RingOrder outerRingOrder, WkbByteOrder byteOrder);
    public RectangleShape GetBoundingBox();
    protected virtual RectangleShape GetBoundingBoxCore();
    public WellKnownType GetWellKnownType();
    protected virtual WellKnownType GetWellKnownTypeCore();
    public BaseShape CloneDeep();
    protected virtual BaseShape CloneDeepCore();
    public static BaseShape TranslateByOffset(BaseShape targetShape, double xOffsetDistance, double yOffsetDistance, GeographyUnit shapeUnit, DistanceUnit distanceUnit);
    public static Feature TranslateByOffset(Feature targetFeature, double xOffsetDistance, double yOffsetDistance, GeographyUnit shapeUnit, DistanceUnit distanceUnit);
    public void TranslateByOffset(double xOffsetDistance, double yOffsetDistance, GeographyUnit shapeUnit, DistanceUnit distanceUnit);
    public void TranslateByOffset(double xOffsetDistance, double yOffsetDistance);
    protected virtual void TranslateByOffsetCore(double xOffsetDistance, double yOffsetDistance, GeographyUnit shapeUnit, DistanceUnit distanceUnit);
    public static BaseShape TranslateByDegree(BaseShape targetShape, double distance, double angleInDegrees, GeographyUnit shapeUnit, DistanceUnit distanceUnit);
    public static BaseShape TranslateByDegree(Feature targetFeature, double distance, double angleInDegrees, GeographyUnit shapeUnit, DistanceUnit distanceUnit);
    public void TranslateByDegree(double distance, double angleInDegrees, GeographyUnit shapeUnit, DistanceUnit distanceUnit);
    public void TranslateByDegree(double distance, double angleInDegrees);
    protected virtual void TranslateByDegreeCore(double distance, double angleInDegrees, GeographyUnit shapeUnit, DistanceUnit distanceUnit);
    public static BaseShape Rotate(BaseShape sourceBaseShape, PointShape pivotPoint, float degreeAngle);
    public static BaseShape Rotate(Feature targetFeature, PointShape pivotPoint, float degreeAngle);
    public void Rotate(PointShape pivotPoint, double degreeAngle);
    protected virtual void RotateCore(PointShape pivotPoint, double degreeAngle);
    public MultilineShape GetShortestLineTo(BaseShape targetShape, GeographyUnit shapeUnit);
    public MultilineShape GetShortestLineTo(Feature targetFeature, GeographyUnit shapeUnit);
    protected virtual MultilineShape GetShortestLineToCore(BaseShape targetShape, GeographyUnit shapeUnit);
    public PointShape GetClosestPointTo(BaseShape targetShape, GeographyUnit shapeUnit);
    public PointShape GetClosestPointTo(Feature targetFeature, GeographyUnit shapeUnit);
    protected virtual PointShape GetClosestPointToCore(BaseShape targetShape, GeographyUnit shapeUnit);
    public PointShape GetCenterPoint();
    protected virtual PointShape GetCenterPointCore();
    public MultipolygonShape Buffer(double distance, GeographyUnit shapeUnit, DistanceUnit distanceUnit);
    public MultipolygonShape Buffer(double distance, int quadrantSegments, GeographyUnit shapeUnit, DistanceUnit distanceUnit);
    public MultipolygonShape Buffer(double distance, int quadrantSegments, BufferCapType bufferCapType, GeographyUnit shapeUnit, DistanceUnit distanceUnit);
    protected virtual MultipolygonShape BufferCore(double distance, int quadrantSegments, BufferCapType bufferCapType, GeographyUnit shapeUnit, DistanceUnit distanceUnit);
    private MultipolygonShape 3ho=(double distance, int quadrantSegments, BufferCapType bufferCapType);
    public double GetDistanceTo(BaseShape targetShape, GeographyUnit shapeUnit, DistanceUnit distanceUnit);
    public double GetDistanceTo(Feature targetFeature, GeographyUnit shapeUnit, DistanceUnit distanceUnit);
    protected virtual double GetDistanceToCore(BaseShape targetShape, GeographyUnit shapeUnit, DistanceUnit distanceUnit);
    public BaseShape Register(PointShape fromPoint, PointShape toPoint, DistanceUnit fromUnit, GeographyUnit toUnit);
    public BaseShape Register(Feature fromPoint, Feature toPoint, DistanceUnit fromUnit, GeographyUnit toUnit);
    protected virtual BaseShape RegisterCore(PointShape fromPoint, PointShape toPoint, DistanceUnit fromUnit, GeographyUnit toUnit);
    public ShapeValidationResult Validate(ShapeValidationMode validationMode);
    protected virtual ShapeValidationResult ValidateCore(ShapeValidationMode validationMode);
    public bool IsDisjointed(BaseShape targetShape);
    public bool IsDisjointed(Feature targetFeature);
    protected virtual bool IsDisjointedCore(BaseShape targetShape);
    public bool Intersects(BaseShape targetShape);
    public bool Intersects(Feature targetFeature);
    protected virtual bool IntersectsCore(BaseShape targetShape);
    public bool Touches(BaseShape targetShape);
    public bool Touches(Feature targetFeature);
    protected virtual bool TouchesCore(BaseShape targetShape);
    public bool Crosses(BaseShape targetShape);
    public bool Crosses(Feature targetFeature);
    protected virtual bool CrossesCore(BaseShape targetShape);
    public bool IsWithin(BaseShape targetShape);
    public bool IsWithin(Feature targetFeature);
    protected virtual bool IsWithinCore(BaseShape targetShape);
    public bool Contains(BaseShape targetShape);
    public bool Contains(Feature targetFeature);
    protected virtual bool ContainsCore(BaseShape targetShape);
    public bool Overlaps(BaseShape targetShape);
    public bool Overlaps(Feature targetFeature);
    protected virtual bool OverlapsCore(BaseShape targetShape);
    public bool IsTopologicallyEqual(BaseShape targetShape);
    public bool IsTopologicallyEqual(Feature targetFeature);
    protected virtual bool IsTopologicallyEqualCore(BaseShape targetShape);
    public Feature GetFeature();
    public Feature GetFeature(IDictionary`2<string, string> columnValues);
    public MultipointShape GetCrossing(BaseShape targetShape);
    protected virtual MultipointShape GetCrossingCore(BaseShape targetShape);
    public static BaseShape ScaleTo(BaseShape baseShape, double scale);
    public void ScaleTo(double scale);
    protected virtual void ScaleToCore(double scale);
    private static EndCapStyle 3xo=(BufferCapType bufferCapStyle);
    private static ByteOrder 4Bo=(WkbByteOrder wkbByteOrder);
}
public class ThinkGeo.Core.BaseShapeTypeConverter : TypeConverter {
    public virtual bool CanConvertFrom(ITypeDescriptorContext context, Type sourceType);
    public virtual object ConvertFrom(ITypeDescriptorContext context, CultureInfo culture, object value);
}
public class ThinkGeo.Core.BingMapsAsyncLayer : XyzTileAsyncLayer {
    private static int /B0=;
    private static string /R0=;
    private static string /h0=;
    [ObfuscationAttribute]
private string applicationId;
    [ObfuscationAttribute]
private BingMapsMapType mapType;
    [ObfuscationAttribute]
private string imageUriTemplate;
    [ObfuscationAttribute]
private Collection`1<string> subDomains;
    [ObfuscationAttribute]
private GeoImage logo;
    [ObfuscationAttribute]
private bool isDirty;
    [ObfuscationAttribute]
private RequestProtocol httpRequestProtocol;
    public string ApplicationId { get; public set; }
    public BingMapsMapType MapType { get; public set; }
    public GeoImage Logo { get; }
    public RequestProtocol HttpRequestProtocol { get; public set; }
    public BingMapsAsyncLayer(string applicationId);
    public BingMapsAsyncLayer(string applicationId, BingMapsMapType mapType);
    private static BingMapsAsyncLayer();
    [AsyncStateMachineAttribute("ThinkGeo.Core.BingMapsAsyncLayer/Iz8=")]
protected virtual Task OpenAsyncCore(CancellationToken cancellationToken);
    public string get_ApplicationId();
    public void set_ApplicationId(string value);
    public BingMapsMapType get_MapType();
    public void set_MapType(BingMapsMapType value);
    public GeoImage get_Logo();
    public RequestProtocol get_HttpRequestProtocol();
    public void set_HttpRequestProtocol(RequestProtocol value);
    [AsyncStateMachineAttribute("ThinkGeo.Core.BingMapsAsyncLayer/ID8=")]
protected virtual Task DrawAsyncCore(GeoCanvas canvas, Collection`1<SimpleCandidate> labelsInAllLayers);
    [AsyncStateMachineAttribute("ThinkGeo.Core.BingMapsAsyncLayer/IT8=")]
protected virtual Task`1<string> GetImageUriAsyncCore(int zoomLevel, long x, long y, float resolutionFactor);
    private static string /x0=(long tileX, long tileY, int levelOfDetail);
    [AsyncStateMachineAttribute("ThinkGeo.Core.BingMapsAsyncLayer/Jj8=")]
private Task AB4=();
    [AsyncStateMachineAttribute("ThinkGeo.Core.BingMapsAsyncLayer/JD8=")]
private Task`1<XmlDocument> AR4=(string xmlPath);
    [DebuggerHiddenAttribute]
[CompilerGeneratedAttribute]
private Task Ah4=(CancellationToken cancellationToken);
    [DebuggerHiddenAttribute]
[CompilerGeneratedAttribute]
private Task Ax4=(GeoCanvas canvas, Collection`1<SimpleCandidate> labelsInAllLayers);
}
public enum ThinkGeo.Core.BingMapsMapType : Enum {
    public int value__;
    public static BingMapsMapType Road;
    public static BingMapsMapType AerialWithLabels;
    public static BingMapsMapType Aerial;
    public static BingMapsMapType CanvasDark;
}
public class ThinkGeo.Core.BingMapsZoomLevelSet : ZoomLevelSet {
}
public enum ThinkGeo.Core.BreakValueInclusion : Enum {
    public int value__;
    public static BreakValueInclusion IncludeValue;
    public static BreakValueInclusion ExcludeValue;
}
public enum ThinkGeo.Core.BufferCapType : Enum {
    public int value__;
    public static BufferCapType Round;
    public static BufferCapType Square;
    public static BufferCapType Butt;
}
public enum ThinkGeo.Core.BuildIndexMode : Enum {
    public int value__;
    public static BuildIndexMode DoNotRebuild;
    public static BuildIndexMode Rebuild;
}
public class ThinkGeo.Core.BuildingAreaStyle : AreaStyle {
    private static int ozE=;
    private static int pDE=;
    private int pTE=;
    private string pjE=;
    private DistanceUnit pzE=;
    private GeoBrush qDE=;
    private GeoBrush qTE=;
    private GeoBrush qjE=;
    private BuildingShadowMode qzE=;
    internal bool phU= { get; }
    public DistanceUnit HeightUnit { get; public set; }
    public string HeightColumnName { get; public set; }
    public GeoBrush LightSideBrush { get; public set; }
    public GeoBrush ShadowSideBrush { get; public set; }
    public GeoBrush RoofBrush { get; public set; }
    public BuildingShadowMode ShadowMode { get; public set; }
    public BuildingAreaStyle(string heightColumnName, DistanceUnit heightUnit);
    private static BuildingAreaStyle();
    internal virtual bool pBU=();
    public DistanceUnit get_HeightUnit();
    public void set_HeightUnit(DistanceUnit value);
    public string get_HeightColumnName();
    public void set_HeightColumnName(string value);
    public GeoBrush get_LightSideBrush();
    public void set_LightSideBrush(GeoBrush value);
    public GeoBrush get_ShadowSideBrush();
    public void set_ShadowSideBrush(GeoBrush value);
    public GeoBrush get_RoofBrush();
    public void set_RoofBrush(GeoBrush value);
    public BuildingShadowMode get_ShadowMode();
    public void set_ShadowMode(BuildingShadowMode value);
    protected virtual Collection`1<string> GetRequiredColumnNamesCore();
    protected virtual void DrawCore(IEnumerable`1<Feature> features, GeoCanvas canvas, Collection`1<SimpleCandidate> labelsInThisLayer, Collection`1<SimpleCandidate> labelsInAllLayers);
    [IteratorStateMachineAttribute("ThinkGeo.Core.BuildingAreaStyle/ikA=")]
private static IEnumerable`1<Feature> rDE=(Feature feature);
    private void rTE=(GeoCanvas canvas, PolygonShape buildingPolygon, double buildingHeight, int currentLevel, ScreenPointF screenOrigin);
    private ScreenPointF[] rjE=(GeoCanvas canvas, double buildingHeight, ScreenPointF[] footPrints, bool isCounterClockwise, ScreenPointF screenOrigin);
    protected virtual double GetHeightInMeters(Feature feature);
    private static void gh4=(T& a, T& b);
    private static int rzE=(double scale, List`1<double> zoomLevelScales);
    private static ScreenPointF sDE=(Vertex v, GeoCanvas canvas);
    private static double sTE=(GeoCanvas canvas);
    private ScreenPointF sjE=(ScreenPointF point, double scale, ScreenPointF origin);
    private static bool szE=(Vertex[] vertices);
}
public class ThinkGeo.Core.BuildingIndexBasFileFeatureSourceEventArgs : EventArgs {
    [ObfuscationAttribute]
private int recordCount;
    [ObfuscationAttribute]
private long currentRecordOffset;
    [ObfuscationAttribute]
private Feature currentFeature;
    [ObfuscationAttribute]
private DateTime startProcessTime;
    [ObfuscationAttribute]
private bool cancel;
    [ObfuscationAttribute]
private string basPathFilename;
    public int RecordCount { get; }
    public long CurrentRecordOffset { get; }
    public Feature CurrentFeature { get; }
    public DateTime StartProcessTime { get; }
    public bool Cancel { get; public set; }
    public string ShapePathFilename { get; }
    public BuildingIndexBasFileFeatureSourceEventArgs(int recordCount, long currentRecordOffset, Feature currentFeature, DateTime startProcessTime, bool cancel);
    public BuildingIndexBasFileFeatureSourceEventArgs(int recordCount, long currentRecordOffset, Feature currentFeature, DateTime startProcessTime, bool cancel, string shapePathFilename);
    public int get_RecordCount();
    public long get_CurrentRecordOffset();
    public Feature get_CurrentFeature();
    public DateTime get_StartProcessTime();
    public bool get_Cancel();
    public void set_Cancel(bool value);
    public string get_ShapePathFilename();
}
public class ThinkGeo.Core.BuildingIndexDelimitedFeatureSourceEventArgs : EventArgs {
    [ObfuscationAttribute]
private int recordCount;
    [ObfuscationAttribute]
private int currentRecordIndex;
    [ObfuscationAttribute]
private Feature currentFeature;
    [ObfuscationAttribute]
private DateTime startProcessTime;
    [ObfuscationAttribute]
private bool cancel;
    [ObfuscationAttribute]
private string delimitedPathFilename;
    public int RecordCount { get; }
    public int CurrentRecordIndex { get; }
    public Feature CurrentFeature { get; }
    public DateTime StartProcessTime { get; }
    public string DelimitedPathFilename { get; }
    public bool Cancel { get; public set; }
    public BuildingIndexDelimitedFeatureSourceEventArgs(int recordCount, int currentRecordIndex, Feature currentFeature, DateTime startProcessTime, string delimitedPathFilename);
    public int get_RecordCount();
    public int get_CurrentRecordIndex();
    public Feature get_CurrentFeature();
    public DateTime get_StartProcessTime();
    public string get_DelimitedPathFilename();
    public bool get_Cancel();
    public void set_Cancel(bool value);
}
public class ThinkGeo.Core.BuildingIndexShapeFileFeatureSourceEventArgs : EventArgs {
    [ObfuscationAttribute]
private long recordCount;
    [ObfuscationAttribute]
private long currentRecordIndex;
    [ObfuscationAttribute]
private Feature currentFeature;
    [ObfuscationAttribute]
private DateTime startProcessTime;
    [ObfuscationAttribute]
private bool cancel;
    [ObfuscationAttribute]
private string shapePathFilename;
    public long RecordCount { get; }
    public long CurrentRecordIndex { get; }
    public Feature CurrentFeature { get; }
    public DateTime StartProcessTime { get; }
    public bool Cancel { get; public set; }
    public string ShapePathFilename { get; }
    public BuildingIndexShapeFileFeatureSourceEventArgs(long recordCount, long currentRecordIndex, Feature currentFeature, DateTime startProcessTime, string shapePathFilename);
    public long get_RecordCount();
    public long get_CurrentRecordIndex();
    public Feature get_CurrentFeature();
    public DateTime get_StartProcessTime();
    public bool get_Cancel();
    public void set_Cancel(bool value);
    public string get_ShapePathFilename();
}
public enum ThinkGeo.Core.BuildingShadowMode : Enum {
    public int value__;
    public static BuildingShadowMode Perspective;
    public static BuildingShadowMode FixedDirection;
}
public enum ThinkGeo.Core.BuildRecordIdMode : Enum {
    public int value__;
    public static BuildRecordIdMode DoNotRebuild;
    public static BuildRecordIdMode Rebuild;
}
public class ThinkGeo.Core.CircularKrigingGridInterpolationModel : KrigingGridInterpolationModel {
    public CircularKrigingGridInterpolationModel(IDictionary`2<PointShape, double> points);
    public CircularKrigingGridInterpolationModel(IDictionary`2<PointShape, double> points, int numberOfReferencedPoints);
    protected virtual double GetSemivarianceCore(double distance, EmpiricalFunctionCoefficients coefficients);
    protected virtual double GetSillSlopeCore(double distance, double range);
}
public class ThinkGeo.Core.ClassBreak : object {
    [ObfuscationAttribute]
private double value;
    [ObfuscationAttribute]
private PointStyle defaultPointStyle;
    [ObfuscationAttribute]
private LineStyle defaultLineStyle;
    [ObfuscationAttribute]
private AreaStyle defaultAreaStyle;
    [ObfuscationAttribute]
private TextStyle defaultTextStyle;
    [ObfuscationAttribute]
private Collection`1<Style> customStyles;
    public double Value { get; public set; }
    public AreaStyle DefaultAreaStyle { get; public set; }
    public LineStyle DefaultLineStyle { get; public set; }
    public PointStyle DefaultPointStyle { get; public set; }
    public TextStyle DefaultTextStyle { get; public set; }
    public Collection`1<Style> CustomStyles { get; }
    public ClassBreak(double value, AreaStyle areaStyle);
    public ClassBreak(double value, PointStyle pointStyle);
    public ClassBreak(double value, LineStyle lineStyle);
    public ClassBreak(double value, TextStyle textStyle);
    public ClassBreak(double value, Collection`1<Style> customStyles);
    private ClassBreak(double value, AreaStyle areaStyle, PointStyle pointStyle, LineStyle lineStyle, TextStyle textStyle, Collection`1<Style> styles);
    public double get_Value();
    public void set_Value(double value);
    public AreaStyle get_DefaultAreaStyle();
    public void set_DefaultAreaStyle(AreaStyle value);
    public LineStyle get_DefaultLineStyle();
    public void set_DefaultLineStyle(LineStyle value);
    public PointStyle get_DefaultPointStyle();
    public void set_DefaultPointStyle(PointStyle value);
    public TextStyle get_DefaultTextStyle();
    public void set_DefaultTextStyle(TextStyle value);
    public Collection`1<Style> get_CustomStyles();
}
public enum ThinkGeo.Core.ClassBreakDrawingOrder : Enum {
    public int value__;
    public static ClassBreakDrawingOrder Default;
    public static ClassBreakDrawingOrder OrderByFeatures;
    public static ClassBreakDrawingOrder OrderByClassBreak;
}
public class ThinkGeo.Core.ClassBreakStyle : Style {
    [ObfuscationAttribute]
private BreakValueInclusion breakValueInclusion;
    [ObfuscationAttribute]
private Collection`1<ClassBreak> classBreaks;
    [ObfuscationAttribute]
private string columnName;
    [ObfuscationAttribute]
private ClassBreakDrawingOrder drawingOrder;
    [CompilerGeneratedAttribute]
private EventHandler`1<GottenFeatureValueClassBreakStyleEventArgs> tjE=;
    public string ColumnName { get; public set; }
    public BreakValueInclusion BreakValueInclusion { get; public set; }
    public Collection`1<ClassBreak> ClassBreaks { get; }
    public ClassBreakDrawingOrder DrawingOrder { get; public set; }
    public ClassBreakStyle(string columnName);
    public ClassBreakStyle(string columnName, BreakValueInclusion breakValueInclusion);
    public ClassBreakStyle(string columnName, BreakValueInclusion breakValueInclusion, Collection`1<ClassBreak> classBreaks);
    [CompilerGeneratedAttribute]
public void add_GottenFeatureValue(EventHandler`1<GottenFeatureValueClassBreakStyleEventArgs> value);
    [CompilerGeneratedAttribute]
public void remove_GottenFeatureValue(EventHandler`1<GottenFeatureValueClassBreakStyleEventArgs> value);
    protected virtual void OnGottenFeatureValue(GottenFeatureValueClassBreakStyleEventArgs e);
    public string get_ColumnName();
    public void set_ColumnName(string value);
    public BreakValueInclusion get_BreakValueInclusion();
    public void set_BreakValueInclusion(BreakValueInclusion value);
    public Collection`1<ClassBreak> get_ClassBreaks();
    public ClassBreakDrawingOrder get_DrawingOrder();
    public void set_DrawingOrder(ClassBreakDrawingOrder value);
    protected virtual void DrawCore(IEnumerable`1<Feature> features, GeoCanvas canvas, Collection`1<SimpleCandidate> labelsInThisLayer, Collection`1<SimpleCandidate> labelsInAllLayers);
    protected virtual void DrawSampleCore(GeoCanvas canvas, DrawingRectangleF drawingExtent);
    [IteratorStateMachineAttribute("ThinkGeo.Core.ClassBreakStyle/jEA=")]
private IEnumerable`1<Style> tzE=();
    private static Collection`1<ClassBreak> uDE=(Collection`1<ClassBreak> classBreaks);
    private static ClassBreak uTE=(double columnValue, BreakValueInclusion breakValueInclusion, Collection`1<ClassBreak> sortedClassBreaks);
    protected virtual Collection`1<string> GetRequiredColumnNamesCore();
    private static void ujE=(Collection`1<string> requiredFieldNames, Collection`1<string> fieldNames);
}
public static class ThinkGeo.Core.ClassBreakValidatorHelper : object {
    public static void CheckClassBreaksAreValid(IEnumerable`1<ClassBreak> classBreaks);
}
public class ThinkGeo.Core.ClearedItemsGeoCollectionEventArgs : EventArgs {
}
public class ThinkGeo.Core.ClearingItemsGeoCollectionEventArgs : EventArgs {
}
public class ThinkGeo.Core.ClosedFeatureSourceEventArgs : EventArgs {
}
public class ThinkGeo.Core.ClosedRasterSourceEventArgs : EventArgs {
}
public class ThinkGeo.Core.ClosingFeatureSourceEventArgs : EventArgs {
}
public class ThinkGeo.Core.ClosingRasterSourceEventArgs : EventArgs {
}
public abstract class ThinkGeo.Core.CloudClient : object {
    private string uBQ=;
    private int uRQ=;
    private IWebProxy uhQ=;
    private string uxQ=;
    private string vBQ=;
    private int vRQ=;
    private static string vhQ=;
    private Timer vxQ=;
    private object /BM=;
    private SemaphoreSlim wBQ=;
    [CompilerGeneratedAttribute]
private EventHandler`1<GettingAccessTokenEventArgs> wRQ=;
    [CompilerGeneratedAttribute]
private EventHandler`1<SendingWebRequestEventArgs> whQ=;
    [CompilerGeneratedAttribute]
private EventHandler`1<SentWebRequestEventArgs> wxQ=;
    [CompilerGeneratedAttribute]
private Collection`1<Uri> xBQ=;
    public int TimeoutInSeconds { get; public set; }
    public IWebProxy WebProxy { get; public set; }
    public string ClientId { get; public set; }
    public string ClientSecret { get; public set; }
    public Collection`1<Uri> BaseUris { get; }
    protected CloudClient(string clientId, string clientSecret);
    [CompilerGeneratedAttribute]
public void add_GettingAccessToken(EventHandler`1<GettingAccessTokenEventArgs> value);
    [CompilerGeneratedAttribute]
public void remove_GettingAccessToken(EventHandler`1<GettingAccessTokenEventArgs> value);
    [CompilerGeneratedAttribute]
public void add_SendingWebRequest(EventHandler`1<SendingWebRequestEventArgs> value);
    [CompilerGeneratedAttribute]
public void remove_SendingWebRequest(EventHandler`1<SendingWebRequestEventArgs> value);
    [CompilerGeneratedAttribute]
public void add_SentWebRequest(EventHandler`1<SentWebRequestEventArgs> value);
    [CompilerGeneratedAttribute]
public void remove_SentWebRequest(EventHandler`1<SentWebRequestEventArgs> value);
    public int get_TimeoutInSeconds();
    public void set_TimeoutInSeconds(int value);
    public IWebProxy get_WebProxy();
    public void set_WebProxy(IWebProxy value);
    public string get_ClientId();
    public void set_ClientId(string value);
    public string get_ClientSecret();
    public void set_ClientSecret(string value);
    [CompilerGeneratedAttribute]
public Collection`1<Uri> get_BaseUris();
    protected void AuthenticateWebRequest(WebRequest webRequest);
    [AsyncStateMachineAttribute("ThinkGeo.Core.CloudClient//z0=")]
protected Task AuthenticateWebRequestAsync(WebRequest webRequest);
    protected string GetToken();
    [AsyncStateMachineAttribute("ThinkGeo.Core.CloudClient/Bj4=")]
protected Task`1<string> GetTokenAsync();
    [AsyncStateMachineAttribute("ThinkGeo.Core.CloudClient/Bz4=")]
protected virtual Task`1<string> GetTokenCoreAsync();
    protected virtual string GetTokenCore();
    protected WebResponse SendWebRequest(WebRequest webRequest);
    [AsyncStateMachineAttribute("ThinkGeo.Core.CloudClient/CD4=")]
protected Task`1<WebResponse> SendWebRequestAsync(WebRequest webRequest);
    protected string GetNextCandidateBaseUri();
    protected virtual string GetNextCandidateBaseUriCore();
    protected virtual void OnGettingAccessToken(GettingAccessTokenEventArgs e);
    protected virtual void OnSendingWebRequest(SendingWebRequestEventArgs e);
    protected virtual void OnSentWebRequest(SentWebRequestEventArgs e);
    public virtual void Dispose();
    private void xRQ=(object state);
    private static string xhQ=(HttpWebResponse httpWebResponse);
}
[ObfuscationAttribute]
internal class ThinkGeo.Core.CloudDurationMinuteReader : CloudJsonConverter`1<object> {
    public virtual object ReadJson(CloudGeoJObject jObject, Type objectType);
    public virtual void WriteJson(CloudGeoJObject jObject, object value);
}
[ObfuscationAttribute]
public class ThinkGeo.Core.CloudElevationPointResult : ValueType {
    [CompilerGeneratedAttribute]
private double <Elevation>k__BackingField;
    [CompilerGeneratedAttribute]
private PointShape <Point>k__BackingField;
    [CompilerGeneratedAttribute]
private ThinkGeoCloudApplicationException <Exception>k__BackingField;
    public double Elevation { get; }
    public PointShape Point { get; }
    public ThinkGeoCloudApplicationException Exception { get; }
    public CloudElevationPointResult(double elevation, PointShape point, ThinkGeoCloudApplicationException exception);
    [CompilerGeneratedAttribute]
[yhM=]
public double get_Elevation();
    [yhM=]
[CompilerGeneratedAttribute]
public PointShape get_Point();
    [yhM=]
[CompilerGeneratedAttribute]
public ThinkGeoCloudApplicationException get_Exception();
}
[ObfuscationAttribute]
public class ThinkGeo.Core.CloudElevationResult : object {
    [CompilerGeneratedAttribute]
private Collection`1<CloudElevationPointResult> <ElevationPoints>k__BackingField;
    [CompilerGeneratedAttribute]
private CloudElevationPointResult <HighestElevationPoint>k__BackingField;
    [CompilerGeneratedAttribute]
private CloudElevationPointResult <LowestElevationPoint>k__BackingField;
    [CompilerGeneratedAttribute]
private double <AverageElevation>k__BackingField;
    public Collection`1<CloudElevationPointResult> ElevationPoints { get; }
    public CloudElevationPointResult HighestElevationPoint { get; }
    public CloudElevationPointResult LowestElevationPoint { get; }
    public double AverageElevation { get; }
    public CloudElevationResult(CloudElevationPointResult highestElevationPoint, CloudElevationPointResult lowestElevationPoint, double averageElevation);
    [CompilerGeneratedAttribute]
public Collection`1<CloudElevationPointResult> get_ElevationPoints();
    [CompilerGeneratedAttribute]
public CloudElevationPointResult get_HighestElevationPoint();
    [CompilerGeneratedAttribute]
public CloudElevationPointResult get_LowestElevationPoint();
    [CompilerGeneratedAttribute]
public double get_AverageElevation();
}
[ExtensionAttribute]
[ObfuscationAttribute]
internal static class ThinkGeo.Core.CloudExtensionHelper : object {
    internal static WebRequest CreateWebRequest(string baseUri, string apiPath, string method, string parameters, string body, int timeoutInSeconds, IWebProxy webProxy);
    [AsyncStateMachineAttribute("ThinkGeo.Core.CloudExtensionHelper/mj4=")]
internal static Task`1<WebRequest> CreateWebRequestAsync(string baseUri, string apiPath, string method, string parameters, string body, int timeoutInSeconds, IWebProxy webProxy);
    [ExtensionAttribute]
internal static T ReadAnonymousObject(WebResponse response, T anonymousObject);
    [ExtensionAttribute]
internal static CloudGeoJObject ReadAnonymousObject(WebResponse response);
    [ExtensionAttribute]
internal static Byte[] ReadRaw(WebResponse response);
    [ExtensionAttribute]
internal static string ReadContentAsString(WebResponse webResponse, Encoding encoding);
}
[ObfuscationAttribute]
public class ThinkGeo.Core.CloudGeocodingLocation : object {
    [CompilerGeneratedAttribute]
private PointShape <LocationPoint>k__BackingField;
    [CompilerGeneratedAttribute]
private string <LocationName>k__BackingField;
    [CompilerGeneratedAttribute]
private string <LocationType>k__BackingField;
    [CompilerGeneratedAttribute]
private RectangleShape <BoundingBox>k__BackingField;
    [CompilerGeneratedAttribute]
private BaseShape <Shape>k__BackingField;
    [CompilerGeneratedAttribute]
private Dictionary`2<string, string> <Properties>k__BackingField;
    public PointShape LocationPoint { get; public set; }
    public string LocationName { get; public set; }
    public string LocationType { get; public set; }
    public RectangleShape BoundingBox { get; public set; }
    public BaseShape Shape { get; public set; }
    public Dictionary`2<string, string> Properties { get; public set; }
    [CompilerGeneratedAttribute]
public PointShape get_LocationPoint();
    [CompilerGeneratedAttribute]
public void set_LocationPoint(PointShape value);
    [CompilerGeneratedAttribute]
public string get_LocationName();
    [CompilerGeneratedAttribute]
public void set_LocationName(string value);
    [CompilerGeneratedAttribute]
public string get_LocationType();
    [CompilerGeneratedAttribute]
public void set_LocationType(string value);
    [CompilerGeneratedAttribute]
public RectangleShape get_BoundingBox();
    [CompilerGeneratedAttribute]
public void set_BoundingBox(RectangleShape value);
    [CompilerGeneratedAttribute]
public BaseShape get_Shape();
    [CompilerGeneratedAttribute]
public void set_Shape(BaseShape value);
    [CompilerGeneratedAttribute]
public Dictionary`2<string, string> get_Properties();
    [CompilerGeneratedAttribute]
public void set_Properties(Dictionary`2<string, string> value);
}
[FlagsAttribute]
[ObfuscationAttribute]
public enum ThinkGeo.Core.CloudGeocodingLocationType : Enum {
    public int value__;
    public static CloudGeocodingLocationType Default;
    public static CloudGeocodingLocationType Country;
    public static CloudGeocodingLocationType State;
    public static CloudGeocodingLocationType County;
    public static CloudGeocodingLocationType City;
    public static CloudGeocodingLocationType Street;
    public static CloudGeocodingLocationType Address;
    public static CloudGeocodingLocationType Zipcode;
    public static CloudGeocodingLocationType Locality;
    public static CloudGeocodingLocationType Town;
    public static CloudGeocodingLocationType Neighbourhood;
    public static CloudGeocodingLocationType Place;
    public static CloudGeocodingLocationType District;
}
[ObfuscationAttribute]
public class ThinkGeo.Core.CloudGeocodingOptions : object {
    [CompilerGeneratedAttribute]
private bool <Autocomplete>k__BackingField;
    [CompilerGeneratedAttribute]
private int <MaxResults>k__BackingField;
    [CompilerGeneratedAttribute]
private RectangleShape <BBox>k__BackingField;
    [CompilerGeneratedAttribute]
private CloudGeocodingResultDetail <ResultDetail>k__BackingField;
    [CompilerGeneratedAttribute]
private CloudGeocodingSearchMode <SearchMode>k__BackingField;
    [CompilerGeneratedAttribute]
private CloudGeocodingLocationType <LocationType>k__BackingField;
    [CompilerGeneratedAttribute]
private IEnumerable`1<string> <Countries>k__BackingField;
    [CompilerGeneratedAttribute]
private IEnumerable`1<string> <Language>k__BackingField;
    [CompilerGeneratedAttribute]
private int <ResultProjectionInSrid>k__BackingField;
    [CompilerGeneratedAttribute]
private string <ResultProjectionInProj4String>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <Debug>k__BackingField;
    public bool Autocomplete { get; public set; }
    public int MaxResults { get; public set; }
    public RectangleShape BBox { get; public set; }
    public CloudGeocodingResultDetail ResultDetail { get; public set; }
    public CloudGeocodingSearchMode SearchMode { get; public set; }
    public CloudGeocodingLocationType LocationType { get; public set; }
    public IEnumerable`1<string> Countries { get; public set; }
    public IEnumerable`1<string> Language { get; public set; }
    public int ResultProjectionInSrid { get; public set; }
    public string ResultProjectionInProj4String { get; public set; }
    public bool Debug { get; public set; }
    [CompilerGeneratedAttribute]
public bool get_Autocomplete();
    [CompilerGeneratedAttribute]
public void set_Autocomplete(bool value);
    [CompilerGeneratedAttribute]
public int get_MaxResults();
    [CompilerGeneratedAttribute]
public void set_MaxResults(int value);
    [CompilerGeneratedAttribute]
public RectangleShape get_BBox();
    [CompilerGeneratedAttribute]
public void set_BBox(RectangleShape value);
    [CompilerGeneratedAttribute]
public CloudGeocodingResultDetail get_ResultDetail();
    [CompilerGeneratedAttribute]
public void set_ResultDetail(CloudGeocodingResultDetail value);
    [CompilerGeneratedAttribute]
public CloudGeocodingSearchMode get_SearchMode();
    [CompilerGeneratedAttribute]
public void set_SearchMode(CloudGeocodingSearchMode value);
    [CompilerGeneratedAttribute]
public CloudGeocodingLocationType get_LocationType();
    [CompilerGeneratedAttribute]
public void set_LocationType(CloudGeocodingLocationType value);
    [CompilerGeneratedAttribute]
public IEnumerable`1<string> get_Countries();
    [CompilerGeneratedAttribute]
public void set_Countries(IEnumerable`1<string> value);
    [CompilerGeneratedAttribute]
public IEnumerable`1<string> get_Language();
    [CompilerGeneratedAttribute]
public void set_Language(IEnumerable`1<string> value);
    [CompilerGeneratedAttribute]
public int get_ResultProjectionInSrid();
    [CompilerGeneratedAttribute]
public void set_ResultProjectionInSrid(int value);
    [CompilerGeneratedAttribute]
public string get_ResultProjectionInProj4String();
    [CompilerGeneratedAttribute]
public void set_ResultProjectionInProj4String(string value);
    [CompilerGeneratedAttribute]
public bool get_Debug();
    [CompilerGeneratedAttribute]
public void set_Debug(bool value);
}
[ObfuscationAttribute]
public class ThinkGeo.Core.CloudGeocodingResult : object {
    [CompilerGeneratedAttribute]
private Collection`1<CloudGeocodingLocation> <Locations>k__BackingField;
    [CompilerGeneratedAttribute]
private ThinkGeoCloudApplicationException <Exception>k__BackingField;
    public Collection`1<CloudGeocodingLocation> Locations { get; }
    public ThinkGeoCloudApplicationException Exception { get; }
    public CloudGeocodingResult(IEnumerable`1<CloudGeocodingLocation> locations, ThinkGeoCloudApplicationException exception);
    [CompilerGeneratedAttribute]
public Collection`1<CloudGeocodingLocation> get_Locations();
    [CompilerGeneratedAttribute]
public ThinkGeoCloudApplicationException get_Exception();
}
[ObfuscationAttribute]
public enum ThinkGeo.Core.CloudGeocodingResultDetail : Enum {
    public int value__;
    public static CloudGeocodingResultDetail Default;
    public static CloudGeocodingResultDetail Verbose;
    public static CloudGeocodingResultDetail Standard;
}
[ObfuscationAttribute]
public enum ThinkGeo.Core.CloudGeocodingSearchMode : Enum {
    public int value__;
    public static CloudGeocodingSearchMode Default;
    public static CloudGeocodingSearchMode ExactMatch;
    public static CloudGeocodingSearchMode FuzzyMatch;
}
[ObfuscationAttribute]
internal class ThinkGeo.Core.CloudGeoJObject : object {
    [ObfuscationAttribute]
private string key;
    [ObfuscationAttribute]
private object value;
    public string Key { get; public set; }
    public object Value { get; public set; }
    public CloudGeoJObject(string key, object value);
    public string get_Key();
    public void set_Key(string value);
    public object get_Value();
    public void set_Value(object value);
}
[ObfuscationAttribute]
public class ThinkGeo.Core.CloudGradeResult : object {
    [CompilerGeneratedAttribute]
private Collection`1<CloudGradeSegment> <GradeSegments>k__BackingField;
    [CompilerGeneratedAttribute]
private CloudGradeSegment <HighestGradeSegment>k__BackingField;
    [CompilerGeneratedAttribute]
private CloudGradeSegment <LowestGradeSegment>k__BackingField;
    [CompilerGeneratedAttribute]
private double <AverageGrade>k__BackingField;
    public Collection`1<CloudGradeSegment> GradeSegments { get; }
    public CloudGradeSegment HighestGradeSegment { get; }
    public CloudGradeSegment LowestGradeSegment { get; }
    public double AverageGrade { get; }
    public CloudGradeResult(CloudGradeSegment highestGradeSegment, CloudGradeSegment lowestGradeSegment, double averageGrade);
    [CompilerGeneratedAttribute]
public Collection`1<CloudGradeSegment> get_GradeSegments();
    [CompilerGeneratedAttribute]
public CloudGradeSegment get_HighestGradeSegment();
    [CompilerGeneratedAttribute]
public CloudGradeSegment get_LowestGradeSegment();
    [CompilerGeneratedAttribute]
public double get_AverageGrade();
}
[ObfuscationAttribute]
public class ThinkGeo.Core.CloudGradeSegment : ValueType {
    [CompilerGeneratedAttribute]
private double <Grade>k__BackingField;
    [CompilerGeneratedAttribute]
private LineShape <GradeLine>k__BackingField;
    [CompilerGeneratedAttribute]
private double <StartingElevation>k__BackingField;
    [CompilerGeneratedAttribute]
private double <EndingElevation>k__BackingField;
    public double Grade { get; }
    public LineShape GradeLine { get; }
    public double StartingElevation { get; }
    public double EndingElevation { get; }
    public CloudGradeSegment(double grade, LineShape gradeLine, double startingElevation, double endingElevation);
    [yhM=]
[CompilerGeneratedAttribute]
public double get_Grade();
    [CompilerGeneratedAttribute]
[yhM=]
public LineShape get_GradeLine();
    [CompilerGeneratedAttribute]
[yhM=]
public double get_StartingElevation();
    [CompilerGeneratedAttribute]
[yhM=]
public double get_EndingElevation();
}
[ObfuscationAttribute]
internal abstract class ThinkGeo.Core.CloudJsonConverter`1 : object {
    public abstract virtual T ReadJson(CloudGeoJObject jObject, Type objectType);
    public abstract virtual void WriteJson(CloudGeoJObject jObject, T value);
}
[ObfuscationAttribute]
internal class ThinkGeo.Core.CloudJsonConverterAttribute : Attribute {
    [ObfuscationAttribute]
private Type type;
    public Type Type { get; public set; }
    public CloudJsonConverterAttribute(Type type);
    public Type get_Type();
    public void set_Type(Type value);
}
[ObfuscationAttribute]
internal class ThinkGeo.Core.CloudJsonPropertyAttribute : Attribute {
    [ObfuscationAttribute]
private string name;
    public string Name { get; public set; }
    public CloudJsonPropertyAttribute(string name);
    public string get_Name();
    public void set_Name(string value);
}
[ObfuscationAttribute]
internal class ThinkGeo.Core.CloudJsonSerializer : object {
    [ObfuscationAttribute]
private static Regex jsonRegex;
    [ObfuscationAttribute]
private static Regex fieldNameRegex;
    [ObfuscationAttribute]
private static BindingFlags bindingFlags;
    [ObfuscationAttribute]
private Encoding encoding;
    [ObfuscationAttribute]
private CloudGeoJObject jObject;
    public Encoding Encoding { get; public set; }
    private static CloudJsonSerializer();
    public Encoding get_Encoding();
    public void set_Encoding(Encoding value);
    public string Serialize();
    private static string SerializeCore(CloudGeoJObject jObject);
    public CloudGeoJObject Deserialize(string json);
    public CloudGeoJObject Deserialize(Stream stream);
    private CloudGeoJObject DeserializeCore(string json);
    private string GetWholevalue(MatchCollection matches, Match currentMatch, string json, string value, Int32& i);
    public static string Serialize(CloudGeoJObject jObject);
    public static string Serialize(T obj);
    private static object SerializeCore(object obj, FieldInfo fieldInfo);
    public static T Deserialize(string json, T obj);
    private static object DeserializeCore(object jObject, Type type, Type parentType, FieldInfo field);
    private static void CreateIEnumerableObject(object result, CloudGeoJObject jObject, Type type, Type parentType, FieldInfo field);
    private static object CreateNormalObject(object jObject, object result);
    private static Collection`1<MemberInfo> GetMembers(Type type);
    private static bool IsSerializable(FieldInfo field);
    private static object CreateArray(CloudGeoJObject jObject, Type type, Type parentType, FieldInfo field);
    private static void SetValue(Array results, int rank, List`1<int> indecies, Collection`1<object> values, Int32& index);
    private static object CreateSimpleObject(CloudGeoJObject jObject, Type type);
    private static object GetSimpleTypeResult(Type type, object value);
    private static bool IsSimpleType(Type type);
}
[ObfuscationAttribute]
internal static class ThinkGeo.Core.CloudJsonSerializerUtils : object {
    internal static T DeserializeObject(string json);
    internal static T DeserializeAnonymousType(string json, T anonymousObject);
    internal static string SerializeObject(T obj);
}
[ObfuscationAttribute]
[FlagsAttribute]
public enum ThinkGeo.Core.CloudLocationCategories : Enum {
    public UInt32 value__;
    public static CloudLocationCategories None;
    public static CloudLocationCategories Common;
    public static CloudLocationCategories All;
    public static CloudLocationCategories Aeroway;
    public static CloudLocationCategories Amenity;
    public static CloudLocationCategories Barrier;
    public static CloudLocationCategories Boundary;
    public static CloudLocationCategories Building;
    public static CloudLocationCategories Education;
    public static CloudLocationCategories Entertainment;
    public static CloudLocationCategories Financial;
    public static CloudLocationCategories Healthcare;
    public static CloudLocationCategories Historic;
    public static CloudLocationCategories Leisure;
    public static CloudLocationCategories Manmade;
    public static CloudLocationCategories Natural;
    public static CloudLocationCategories Rail;
    public static CloudLocationCategories Power;
    public static CloudLocationCategories Road;
    public static CloudLocationCategories Shop;
    public static CloudLocationCategories Sport;
    public static CloudLocationCategories Sustenance;
    public static CloudLocationCategories Tourism;
    public static CloudLocationCategories Transportation;
    public static CloudLocationCategories Waterway;
    public static CloudLocationCategories Intersection;
    public static CloudLocationCategories AddressPoint;
    public static CloudLocationCategories Others;
}
[ObsoleteAttribute("This class is deprecated and will be removed after v13.3. Please use ThinkGeo Cloud Layers to display ThinkGeo Maps.")]
public class ThinkGeo.Core.CloudMapClient : object {
    [ObfuscationAttribute]
private string token;
    [ObfuscationAttribute]
private int timeoutInSeconds;
    [ObfuscationAttribute]
private IWebProxy webProxy;
    [ObfuscationAttribute]
private string clientId;
    [ObfuscationAttribute]
private string clientSecret;
    [ObfuscationAttribute]
private bool isOpen;
    [ObfuscationAttribute]
private int baseUriIndex;
    private static int BR4=;
    private static string vhQ=;
    private Timer vxQ=;
    [ObfuscationAttribute]
private Collection`1<Uri> baseUris;
    private bool Bh4=;
    public bool IsOpen { get; public set; }
    public Collection`1<Uri> Uris { get; }
    public int TimeoutInSeconds { get; public set; }
    public string ClientId { get; public set; }
    public string ClientSecret { get; public set; }
    public IWebProxy WebProxy { get; public set; }
    public CloudMapClient(string clientId, string clientSecret);
    public bool get_IsOpen();
    public void set_IsOpen(bool value);
    public void Open();
    public Collection`1<Uri> get_Uris();
    public int get_TimeoutInSeconds();
    public void set_TimeoutInSeconds(int value);
    public string get_ClientId();
    public void set_ClientId(string value);
    public string get_ClientSecret();
    public void set_ClientSecret(string value);
    public IWebProxy get_WebProxy();
    public void set_WebProxy(IWebProxy value);
    public WebRequest CreateWebRequest(string apiPath, string method, string parameters, string body, int timeoutInSeconds, IWebProxy webProxy, bool isNeedToken);
    private string pis=();
    public virtual void Dispose();
    private string IR4=();
    private void xRQ=(object state);
}
[ObfuscationAttribute]
public enum ThinkGeo.Core.CloudMapProjection : Enum {
    public int value__;
    public static CloudMapProjection SphericalMercator;
}
[ObfuscationAttribute]
public class ThinkGeo.Core.CloudMapsQueryCustomQueryOptions : object {
    [CompilerGeneratedAttribute]
private string <QueryLayer>k__BackingField;
    [CompilerGeneratedAttribute]
private CloudMapsQueryCustomQueryType <QueryType>k__BackingField;
    [CompilerGeneratedAttribute]
private BaseShape <Shape>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<int> <Srid>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Proj4String>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<double> <Distance>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<DistanceUnit> <DistanceUnit>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<double> <SearchRadius>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<DistanceUnit> <SearchRadiusUnit>k__BackingField;
    [CompilerGeneratedAttribute]
private int <MaxResults>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <ReturnFeatureAttributes>k__BackingField;
    [CompilerGeneratedAttribute]
private IEnumerable`1<string> <FeatureAttributesToReturn>k__BackingField;
    public string QueryLayer { get; public set; }
    public CloudMapsQueryCustomQueryType QueryType { get; public set; }
    [CloudJsonPropertyAttribute("wkt")]
[CloudJsonConverterAttribute("ThinkGeo.Core.CloudShapeWktConverter")]
public BaseShape Shape { get; public set; }
    public Nullable`1<int> Srid { get; public set; }
    public string Proj4String { get; public set; }
    public Nullable`1<double> Distance { get; public set; }
    public Nullable`1<DistanceUnit> DistanceUnit { get; public set; }
    public Nullable`1<double> SearchRadius { get; public set; }
    public Nullable`1<DistanceUnit> SearchRadiusUnit { get; public set; }
    public int MaxResults { get; public set; }
    public bool ReturnFeatureAttributes { get; public set; }
    public IEnumerable`1<string> FeatureAttributesToReturn { get; public set; }
    [CompilerGeneratedAttribute]
public string get_QueryLayer();
    [CompilerGeneratedAttribute]
public void set_QueryLayer(string value);
    [CompilerGeneratedAttribute]
public CloudMapsQueryCustomQueryType get_QueryType();
    [CompilerGeneratedAttribute]
public void set_QueryType(CloudMapsQueryCustomQueryType value);
    [CompilerGeneratedAttribute]
public BaseShape get_Shape();
    [CompilerGeneratedAttribute]
public void set_Shape(BaseShape value);
    [CompilerGeneratedAttribute]
public Nullable`1<int> get_Srid();
    [CompilerGeneratedAttribute]
public void set_Srid(Nullable`1<int> value);
    [CompilerGeneratedAttribute]
public string get_Proj4String();
    [CompilerGeneratedAttribute]
public void set_Proj4String(string value);
    [CompilerGeneratedAttribute]
public Nullable`1<double> get_Distance();
    [CompilerGeneratedAttribute]
public void set_Distance(Nullable`1<double> value);
    [CompilerGeneratedAttribute]
public Nullable`1<DistanceUnit> get_DistanceUnit();
    [CompilerGeneratedAttribute]
public void set_DistanceUnit(Nullable`1<DistanceUnit> value);
    [CompilerGeneratedAttribute]
public Nullable`1<double> get_SearchRadius();
    [CompilerGeneratedAttribute]
public void set_SearchRadius(Nullable`1<double> value);
    [CompilerGeneratedAttribute]
public Nullable`1<DistanceUnit> get_SearchRadiusUnit();
    [CompilerGeneratedAttribute]
public void set_SearchRadiusUnit(Nullable`1<DistanceUnit> value);
    [CompilerGeneratedAttribute]
public int get_MaxResults();
    [CompilerGeneratedAttribute]
public void set_MaxResults(int value);
    [CompilerGeneratedAttribute]
public bool get_ReturnFeatureAttributes();
    [CompilerGeneratedAttribute]
public void set_ReturnFeatureAttributes(bool value);
    [CompilerGeneratedAttribute]
public IEnumerable`1<string> get_FeatureAttributesToReturn();
    [CompilerGeneratedAttribute]
public void set_FeatureAttributesToReturn(IEnumerable`1<string> value);
}
[ObfuscationAttribute]
public enum ThinkGeo.Core.CloudMapsQueryCustomQueryType : Enum {
    public int value__;
    public static CloudMapsQueryCustomQueryType Within;
    public static CloudMapsQueryCustomQueryType Containing;
    public static CloudMapsQueryCustomQueryType Intersecting;
    public static CloudMapsQueryCustomQueryType Overlapping;
    public static CloudMapsQueryCustomQueryType Touching;
    public static CloudMapsQueryCustomQueryType Nearest;
    public static CloudMapsQueryCustomQueryType WithinDistance;
}
[ObfuscationAttribute]
public class ThinkGeo.Core.CloudMapsQueryGetAttributesOfLayerResult : object {
    [CompilerGeneratedAttribute]
private Collection`1<string> <Attributes>k__BackingField;
    [CompilerGeneratedAttribute]
private ThinkGeoCloudApplicationException <Exception>k__BackingField;
    public Collection`1<string> Attributes { get; public set; }
    public ThinkGeoCloudApplicationException Exception { get; public set; }
    [CompilerGeneratedAttribute]
public Collection`1<string> get_Attributes();
    [CompilerGeneratedAttribute]
public void set_Attributes(Collection`1<string> value);
    [CompilerGeneratedAttribute]
public ThinkGeoCloudApplicationException get_Exception();
    [CompilerGeneratedAttribute]
public void set_Exception(ThinkGeoCloudApplicationException value);
}
[ObfuscationAttribute]
public class ThinkGeo.Core.CloudMapsQueryGetLayersResult : object {
    [CompilerGeneratedAttribute]
private Collection`1<string> <QueryLayers>k__BackingField;
    [CompilerGeneratedAttribute]
private ThinkGeoCloudApplicationException <Exception>k__BackingField;
    public Collection`1<string> QueryLayers { get; public set; }
    public ThinkGeoCloudApplicationException Exception { get; public set; }
    [CompilerGeneratedAttribute]
public Collection`1<string> get_QueryLayers();
    [CompilerGeneratedAttribute]
public void set_QueryLayers(Collection`1<string> value);
    [CompilerGeneratedAttribute]
public ThinkGeoCloudApplicationException get_Exception();
    [CompilerGeneratedAttribute]
public void set_Exception(ThinkGeoCloudApplicationException value);
}
[ObfuscationAttribute]
public static class ThinkGeo.Core.CloudMapsQueryLayers : object {
    public static string Countries;
    public static string States;
    public static string Roads;
    public static string Rail;
    public static string Addresses;
    public static string Cities;
    public static string LandUse;
    public static string Places;
    public static string Pois;
    public static string Transport;
    public static string Water;
    public static string Waterways;
    public static string Buildings;
}
[ObfuscationAttribute]
public class ThinkGeo.Core.CloudMapsQueryNearestQueryOptions : object {
    [CompilerGeneratedAttribute]
private bool <ReturnFeatureAttributes>k__BackingField;
    [CompilerGeneratedAttribute]
private IEnumerable`1<string> <FeatureAttributesToReturn>k__BackingField;
    public bool ReturnFeatureAttributes { get; public set; }
    public IEnumerable`1<string> FeatureAttributesToReturn { get; public set; }
    [CompilerGeneratedAttribute]
public bool get_ReturnFeatureAttributes();
    [CompilerGeneratedAttribute]
public void set_ReturnFeatureAttributes(bool value);
    [CompilerGeneratedAttribute]
public IEnumerable`1<string> get_FeatureAttributesToReturn();
    [CompilerGeneratedAttribute]
public void set_FeatureAttributesToReturn(IEnumerable`1<string> value);
}
[ObfuscationAttribute]
public class ThinkGeo.Core.CloudMapsQueryResult : object {
    [CompilerGeneratedAttribute]
private Collection`1<Feature> <Features>k__BackingField;
    [CompilerGeneratedAttribute]
private ThinkGeoCloudApplicationException <Exception>k__BackingField;
    public Collection`1<Feature> Features { get; public set; }
    public ThinkGeoCloudApplicationException Exception { get; public set; }
    [CompilerGeneratedAttribute]
public Collection`1<Feature> get_Features();
    [CompilerGeneratedAttribute]
public void set_Features(Collection`1<Feature> value);
    [CompilerGeneratedAttribute]
public ThinkGeoCloudApplicationException get_Exception();
    [CompilerGeneratedAttribute]
public void set_Exception(ThinkGeoCloudApplicationException value);
}
[ObfuscationAttribute]
public class ThinkGeo.Core.CloudMapsQuerySpatialQueryOptions : object {
    [CompilerGeneratedAttribute]
private int <MaxResults>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <ReturnFeatureAttributes>k__BackingField;
    [CompilerGeneratedAttribute]
private IEnumerable`1<string> <FeatureAttributesToReturn>k__BackingField;
    public int MaxResults { get; public set; }
    public bool ReturnFeatureAttributes { get; public set; }
    public IEnumerable`1<string> FeatureAttributesToReturn { get; public set; }
    [CompilerGeneratedAttribute]
public int get_MaxResults();
    [CompilerGeneratedAttribute]
public void set_MaxResults(int value);
    [CompilerGeneratedAttribute]
public bool get_ReturnFeatureAttributes();
    [CompilerGeneratedAttribute]
public void set_ReturnFeatureAttributes(bool value);
    [CompilerGeneratedAttribute]
public IEnumerable`1<string> get_FeatureAttributesToReturn();
    [CompilerGeneratedAttribute]
public void set_FeatureAttributesToReturn(IEnumerable`1<string> value);
}
[ObfuscationAttribute]
public enum ThinkGeo.Core.CloudRasterMapType : Enum {
    public int value__;
    public static CloudRasterMapType Default;
    public static CloudRasterMapType Light;
    public static CloudRasterMapType Dark;
    public static CloudRasterMapType Hybrid;
    public static CloudRasterMapType Aerial;
    public static CloudRasterMapType TransparentBackground;
}
internal class ThinkGeo.Core.CloudRasterTileInfo : object {
    [ObfuscationAttribute]
private RectangleShape boundingBox;
    [ObfuscationAttribute]
private RasterTile rasterTile;
    [ObfuscationAttribute]
private Exception exception;
    public RectangleShape BoundingBox { get; public set; }
    public RasterTile RasterTile { get; public set; }
    public string TileId { get; }
    internal Exception Exception { get; internal set; }
    public CloudRasterTileInfo(RasterTile rasterTile, RectangleShape boundingBox);
    public RectangleShape get_BoundingBox();
    public void set_BoundingBox(RectangleShape value);
    public RasterTile get_RasterTile();
    public void set_RasterTile(RasterTile value);
    public string get_TileId();
    internal Exception get_Exception();
    internal void set_Exception(Exception value);
    public sealed virtual void Dispose();
    private void Dispose(bool disposing);
}
[ObfuscationAttribute]
internal class ThinkGeo.Core.CloudRequestAllTimeZoneNamesFromResponse : object {
    [CompilerGeneratedAttribute]
private Collection`1<string> <data>k__BackingField;
    [CompilerGeneratedAttribute]
private CloudRequestResponseError <error>k__BackingField;
    public Collection`1<string> data { get; public set; }
    public CloudRequestResponseError error { get; public set; }
    [CompilerGeneratedAttribute]
public Collection`1<string> get_data();
    [CompilerGeneratedAttribute]
public void set_data(Collection`1<string> value);
    [CompilerGeneratedAttribute]
public CloudRequestResponseError get_error();
    [CompilerGeneratedAttribute]
public void set_error(CloudRequestResponseError value);
}
[ObfuscationAttribute]
internal class ThinkGeo.Core.CloudRequestAllTimeZoneResponse : object {
    [CompilerGeneratedAttribute]
private CloudRequestAllTimeZoneResponseData <data>k__BackingField;
    [CompilerGeneratedAttribute]
private CloudRequestResponseError <error>k__BackingField;
    public CloudRequestAllTimeZoneResponseData data { get; public set; }
    public CloudRequestResponseError error { get; public set; }
    [CompilerGeneratedAttribute]
public CloudRequestAllTimeZoneResponseData get_data();
    [CompilerGeneratedAttribute]
public void set_data(CloudRequestAllTimeZoneResponseData value);
    [CompilerGeneratedAttribute]
public CloudRequestResponseError get_error();
    [CompilerGeneratedAttribute]
public void set_error(CloudRequestResponseError value);
}
[ObfuscationAttribute]
internal class ThinkGeo.Core.CloudRequestAllTimeZoneResponseData : object {
    public CloudRequestTimeZone[] timezones;
}
[ObfuscationAttribute]
internal class ThinkGeo.Core.CloudRequestColorResponse : object {
    [CompilerGeneratedAttribute]
private CloudRequestColorResponseData <Data>k__BackingField;
    public CloudRequestColorResponseData Data { get; public set; }
    [CompilerGeneratedAttribute]
public CloudRequestColorResponseData get_Data();
    [CompilerGeneratedAttribute]
public void set_Data(CloudRequestColorResponseData value);
}
[ObfuscationAttribute]
internal class ThinkGeo.Core.CloudRequestColorResponseData : object {
    [CompilerGeneratedAttribute]
private List`1<string> <Colors>k__BackingField;
    public List`1<string> Colors { get; public set; }
    [CompilerGeneratedAttribute]
public List`1<string> get_Colors();
    [CompilerGeneratedAttribute]
public void set_Colors(List`1<string> value);
}
[ObfuscationAttribute]
internal class ThinkGeo.Core.CloudRequestElevationResponse : object {
    [CompilerGeneratedAttribute]
private CloudRequestElevationResponseData <Data>k__BackingField;
    [CompilerGeneratedAttribute]
private CloudRequestResponseError <error>k__BackingField;
    public CloudRequestElevationResponseData Data { get; public set; }
    public CloudRequestResponseError error { get; public set; }
    [CompilerGeneratedAttribute]
public CloudRequestElevationResponseData get_Data();
    [CompilerGeneratedAttribute]
public void set_Data(CloudRequestElevationResponseData value);
    [CompilerGeneratedAttribute]
public CloudRequestResponseError get_error();
    [CompilerGeneratedAttribute]
public void set_error(CloudRequestResponseError value);
}
[ObfuscationAttribute]
internal class ThinkGeo.Core.CloudRequestElevationResponseData : object {
    [CompilerGeneratedAttribute]
private double <elevation>k__BackingField;
    public double elevation { get; public set; }
    [CompilerGeneratedAttribute]
public double get_elevation();
    [CompilerGeneratedAttribute]
public void set_elevation(double value);
}
[ObfuscationAttribute]
internal class ThinkGeo.Core.CloudRequestElevationResultOfMultiPointsResponse : object {
    [CompilerGeneratedAttribute]
private CloudRequestElevationResultOfMultiPointsResponseDataItem[] <data>k__BackingField;
    [CompilerGeneratedAttribute]
private CloudRequestElevationResultOfMultiPointsResponseLowestElevationPoint <lowestElevationPoint>k__BackingField;
    [CompilerGeneratedAttribute]
private CloudRequestElevationResultOfMultiPointsResponseHighestElevationPoint <highestElevationPoint>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<double> <averageElevation>k__BackingField;
    [CompilerGeneratedAttribute]
private CloudRequestResponseError <error>k__BackingField;
    public CloudRequestElevationResultOfMultiPointsResponseDataItem[] data { get; public set; }
    public CloudRequestElevationResultOfMultiPointsResponseLowestElevationPoint lowestElevationPoint { get; public set; }
    public CloudRequestElevationResultOfMultiPointsResponseHighestElevationPoint highestElevationPoint { get; public set; }
    public Nullable`1<double> averageElevation { get; public set; }
    public CloudRequestResponseError error { get; public set; }
    [CompilerGeneratedAttribute]
public CloudRequestElevationResultOfMultiPointsResponseDataItem[] get_data();
    [CompilerGeneratedAttribute]
public void set_data(CloudRequestElevationResultOfMultiPointsResponseDataItem[] value);
    [CompilerGeneratedAttribute]
public CloudRequestElevationResultOfMultiPointsResponseLowestElevationPoint get_lowestElevationPoint();
    [CompilerGeneratedAttribute]
public void set_lowestElevationPoint(CloudRequestElevationResultOfMultiPointsResponseLowestElevationPoint value);
    [CompilerGeneratedAttribute]
public CloudRequestElevationResultOfMultiPointsResponseHighestElevationPoint get_highestElevationPoint();
    [CompilerGeneratedAttribute]
public void set_highestElevationPoint(CloudRequestElevationResultOfMultiPointsResponseHighestElevationPoint value);
    [CompilerGeneratedAttribute]
public Nullable`1<double> get_averageElevation();
    [CompilerGeneratedAttribute]
public void set_averageElevation(Nullable`1<double> value);
    [CompilerGeneratedAttribute]
public CloudRequestResponseError get_error();
    [CompilerGeneratedAttribute]
public void set_error(CloudRequestResponseError value);
}
[ObfuscationAttribute]
internal class ThinkGeo.Core.CloudRequestElevationResultOfMultiPointsResponseDataItem : object {
    [CompilerGeneratedAttribute]
private Dictionary`2<string, String[]> <errors>k__BackingField;
    [CompilerGeneratedAttribute]
private double <elevation>k__BackingField;
    public Dictionary`2<string, String[]> errors { get; public set; }
    public double elevation { get; public set; }
    [CompilerGeneratedAttribute]
public Dictionary`2<string, String[]> get_errors();
    [CompilerGeneratedAttribute]
public void set_errors(Dictionary`2<string, String[]> value);
    [CompilerGeneratedAttribute]
public double get_elevation();
    [CompilerGeneratedAttribute]
public void set_elevation(double value);
}
[ObfuscationAttribute]
internal class ThinkGeo.Core.CloudRequestElevationResultOfMultiPointsResponseHighestElevationPoint : object {
    [CompilerGeneratedAttribute]
private double <elevation>k__BackingField;
    [CompilerGeneratedAttribute]
private string <wellKnownText>k__BackingField;
    public double elevation { get; public set; }
    public string wellKnownText { get; public set; }
    [CompilerGeneratedAttribute]
public double get_elevation();
    [CompilerGeneratedAttribute]
public void set_elevation(double value);
    [CompilerGeneratedAttribute]
public string get_wellKnownText();
    [CompilerGeneratedAttribute]
public void set_wellKnownText(string value);
}
[ObfuscationAttribute]
internal class ThinkGeo.Core.CloudRequestElevationResultOfMultiPointsResponseLowestElevationPoint : object {
    [CompilerGeneratedAttribute]
private double <elevation>k__BackingField;
    [CompilerGeneratedAttribute]
private string <wellKnownText>k__BackingField;
    public double elevation { get; public set; }
    public string wellKnownText { get; public set; }
    [CompilerGeneratedAttribute]
public double get_elevation();
    [CompilerGeneratedAttribute]
public void set_elevation(double value);
    [CompilerGeneratedAttribute]
public string get_wellKnownText();
    [CompilerGeneratedAttribute]
public void set_wellKnownText(string value);
}
[ObfuscationAttribute]
internal class ThinkGeo.Core.CloudRequestElevationResultResponse : object {
    [CompilerGeneratedAttribute]
private CloudRequestElevationResultResponseDataItem[] <data>k__BackingField;
    [CompilerGeneratedAttribute]
private CloudRequestElevationResultResponseLowestElevationPoint <lowestElevationPoint>k__BackingField;
    [CompilerGeneratedAttribute]
private CloudRequestElevationResultResponseHighestElevationPoint <highestElevationPoint>k__BackingField;
    [CompilerGeneratedAttribute]
private double <averageElevation>k__BackingField;
    [CompilerGeneratedAttribute]
private CloudRequestResponseError <error>k__BackingField;
    public CloudRequestElevationResultResponseDataItem[] data { get; public set; }
    public CloudRequestElevationResultResponseLowestElevationPoint lowestElevationPoint { get; public set; }
    public CloudRequestElevationResultResponseHighestElevationPoint highestElevationPoint { get; public set; }
    public double averageElevation { get; public set; }
    public CloudRequestResponseError error { get; public set; }
    [CompilerGeneratedAttribute]
public CloudRequestElevationResultResponseDataItem[] get_data();
    [CompilerGeneratedAttribute]
public void set_data(CloudRequestElevationResultResponseDataItem[] value);
    [CompilerGeneratedAttribute]
public CloudRequestElevationResultResponseLowestElevationPoint get_lowestElevationPoint();
    [CompilerGeneratedAttribute]
public void set_lowestElevationPoint(CloudRequestElevationResultResponseLowestElevationPoint value);
    [CompilerGeneratedAttribute]
public CloudRequestElevationResultResponseHighestElevationPoint get_highestElevationPoint();
    [CompilerGeneratedAttribute]
public void set_highestElevationPoint(CloudRequestElevationResultResponseHighestElevationPoint value);
    [CompilerGeneratedAttribute]
public double get_averageElevation();
    [CompilerGeneratedAttribute]
public void set_averageElevation(double value);
    [CompilerGeneratedAttribute]
public CloudRequestResponseError get_error();
    [CompilerGeneratedAttribute]
public void set_error(CloudRequestResponseError value);
}
[ObfuscationAttribute]
internal class ThinkGeo.Core.CloudRequestElevationResultResponseDataItem : object {
    [CompilerGeneratedAttribute]
private double <elevation>k__BackingField;
    [CompilerGeneratedAttribute]
private string <wellKnownText>k__BackingField;
    public double elevation { get; public set; }
    public string wellKnownText { get; public set; }
    [CompilerGeneratedAttribute]
public double get_elevation();
    [CompilerGeneratedAttribute]
public void set_elevation(double value);
    [CompilerGeneratedAttribute]
public string get_wellKnownText();
    [CompilerGeneratedAttribute]
public void set_wellKnownText(string value);
}
[ObfuscationAttribute]
internal class ThinkGeo.Core.CloudRequestElevationResultResponseHighestElevationPoint : object {
    [CompilerGeneratedAttribute]
private double <elevation>k__BackingField;
    [CompilerGeneratedAttribute]
private string <wellKnownText>k__BackingField;
    public double elevation { get; public set; }
    public string wellKnownText { get; public set; }
    [CompilerGeneratedAttribute]
public double get_elevation();
    [CompilerGeneratedAttribute]
public void set_elevation(double value);
    [CompilerGeneratedAttribute]
public string get_wellKnownText();
    [CompilerGeneratedAttribute]
public void set_wellKnownText(string value);
}
[ObfuscationAttribute]
internal class ThinkGeo.Core.CloudRequestElevationResultResponseLowestElevationPoint : object {
    [CompilerGeneratedAttribute]
private double <elevation>k__BackingField;
    [CompilerGeneratedAttribute]
private string <wellKnownText>k__BackingField;
    public double elevation { get; public set; }
    public string wellKnownText { get; public set; }
    [CompilerGeneratedAttribute]
public double get_elevation();
    [CompilerGeneratedAttribute]
public void set_elevation(double value);
    [CompilerGeneratedAttribute]
public string get_wellKnownText();
    [CompilerGeneratedAttribute]
public void set_wellKnownText(string value);
}
[ObfuscationAttribute]
internal class ThinkGeo.Core.CloudRequestGeocodingResultResponse : object {
    [CompilerGeneratedAttribute]
private CloudRequestGeocodingResultResponseData <data>k__BackingField;
    [CompilerGeneratedAttribute]
private CloudRequestResponseError <error>k__BackingField;
    public CloudRequestGeocodingResultResponseData data { get; public set; }
    public CloudRequestResponseError error { get; public set; }
    [CompilerGeneratedAttribute]
public CloudRequestGeocodingResultResponseData get_data();
    [CompilerGeneratedAttribute]
public void set_data(CloudRequestGeocodingResultResponseData value);
    [CompilerGeneratedAttribute]
public CloudRequestResponseError get_error();
    [CompilerGeneratedAttribute]
public void set_error(CloudRequestResponseError value);
}
[ObfuscationAttribute]
internal class ThinkGeo.Core.CloudRequestGeocodingResultResponseData : object {
    [CompilerGeneratedAttribute]
private GeocodingLocationDto[] <locations>k__BackingField;
    public GeocodingLocationDto[] locations { get; public set; }
    [CompilerGeneratedAttribute]
public GeocodingLocationDto[] get_locations();
    [CompilerGeneratedAttribute]
public void set_locations(GeocodingLocationDto[] value);
}
[ObfuscationAttribute]
internal class ThinkGeo.Core.CloudRequestGetAttributesOfLayerResultResponse : object {
    [CompilerGeneratedAttribute]
private CloudRequestGetAttributesOfLayerResultResponseData <data>k__BackingField;
    [CompilerGeneratedAttribute]
private CloudRequestResponseError <error>k__BackingField;
    public CloudRequestGetAttributesOfLayerResultResponseData data { get; public set; }
    public CloudRequestResponseError error { get; public set; }
    [CompilerGeneratedAttribute]
public CloudRequestGetAttributesOfLayerResultResponseData get_data();
    [CompilerGeneratedAttribute]
public void set_data(CloudRequestGetAttributesOfLayerResultResponseData value);
    [CompilerGeneratedAttribute]
public CloudRequestResponseError get_error();
    [CompilerGeneratedAttribute]
public void set_error(CloudRequestResponseError value);
}
[ObfuscationAttribute]
internal class ThinkGeo.Core.CloudRequestGetAttributesOfLayerResultResponseData : object {
    [CompilerGeneratedAttribute]
private List`1<string> <attributes>k__BackingField;
    public List`1<string> attributes { get; public set; }
    [CompilerGeneratedAttribute]
public List`1<string> get_attributes();
    [CompilerGeneratedAttribute]
public void set_attributes(List`1<string> value);
}
[ObfuscationAttribute]
internal class ThinkGeo.Core.CloudRequestGetDistanceCostMatrixResultResponse : object {
    [CompilerGeneratedAttribute]
private CloudRoutingDistanceCostMatrixResult <data>k__BackingField;
    [CompilerGeneratedAttribute]
private CloudRequestResponseError <error>k__BackingField;
    public CloudRoutingDistanceCostMatrixResult data { get; public set; }
    public CloudRequestResponseError error { get; public set; }
    [CompilerGeneratedAttribute]
public CloudRoutingDistanceCostMatrixResult get_data();
    [CompilerGeneratedAttribute]
public void set_data(CloudRoutingDistanceCostMatrixResult value);
    [CompilerGeneratedAttribute]
public CloudRequestResponseError get_error();
    [CompilerGeneratedAttribute]
public void set_error(CloudRequestResponseError value);
}
[ObfuscationAttribute]
internal class ThinkGeo.Core.CloudRequestGetLayersResultResponse : object {
    [CompilerGeneratedAttribute]
private CloudRequestGetLayersResultResponseData <data>k__BackingField;
    [CompilerGeneratedAttribute]
private CloudRequestResponseError <error>k__BackingField;
    public CloudRequestGetLayersResultResponseData data { get; public set; }
    public CloudRequestResponseError error { get; public set; }
    [CompilerGeneratedAttribute]
public CloudRequestGetLayersResultResponseData get_data();
    [CompilerGeneratedAttribute]
public void set_data(CloudRequestGetLayersResultResponseData value);
    [CompilerGeneratedAttribute]
public CloudRequestResponseError get_error();
    [CompilerGeneratedAttribute]
public void set_error(CloudRequestResponseError value);
}
[ObfuscationAttribute]
internal class ThinkGeo.Core.CloudRequestGetLayersResultResponseData : object {
    [CompilerGeneratedAttribute]
private List`1<string> <layers>k__BackingField;
    public List`1<string> layers { get; public set; }
    [CompilerGeneratedAttribute]
public List`1<string> get_layers();
    [CompilerGeneratedAttribute]
public void set_layers(List`1<string> value);
}
[ObfuscationAttribute]
internal class ThinkGeo.Core.CloudRequestGetProjectGeometryResultResponseData : object {
    [CompilerGeneratedAttribute]
private string <wkt>k__BackingField;
    public string wkt { get; public set; }
    [CompilerGeneratedAttribute]
public string get_wkt();
    [CompilerGeneratedAttribute]
public void set_wkt(string value);
}
[ObfuscationAttribute]
internal class ThinkGeo.Core.CloudRequestGetRouteResultResponse : object {
    [CompilerGeneratedAttribute]
private CloudRoutingRouteResult <data>k__BackingField;
    [CompilerGeneratedAttribute]
private CloudRequestResponseError <error>k__BackingField;
    public CloudRoutingRouteResult data { get; public set; }
    public CloudRequestResponseError error { get; public set; }
    [CompilerGeneratedAttribute]
public CloudRoutingRouteResult get_data();
    [CompilerGeneratedAttribute]
public void set_data(CloudRoutingRouteResult value);
    [CompilerGeneratedAttribute]
public CloudRequestResponseError get_error();
    [CompilerGeneratedAttribute]
public void set_error(CloudRequestResponseError value);
}
[ObfuscationAttribute]
internal class ThinkGeo.Core.CloudRequestGetServiceAreaResultResponse : object {
    [CompilerGeneratedAttribute]
private CloudRoutingServiceAreaResult <data>k__BackingField;
    [CompilerGeneratedAttribute]
private CloudRequestResponseError <error>k__BackingField;
    public CloudRoutingServiceAreaResult data { get; public set; }
    public CloudRequestResponseError error { get; public set; }
    [CompilerGeneratedAttribute]
public CloudRoutingServiceAreaResult get_data();
    [CompilerGeneratedAttribute]
public void set_data(CloudRoutingServiceAreaResult value);
    [CompilerGeneratedAttribute]
public CloudRequestResponseError get_error();
    [CompilerGeneratedAttribute]
public void set_error(CloudRequestResponseError value);
}
[ObfuscationAttribute]
internal class ThinkGeo.Core.CloudRequestGetTimeCostMatrixResultResponse : object {
    [CompilerGeneratedAttribute]
private CloudRoutingTimeCostMatrixResult <data>k__BackingField;
    [CompilerGeneratedAttribute]
private CloudRequestResponseError <error>k__BackingField;
    public CloudRoutingTimeCostMatrixResult data { get; public set; }
    public CloudRequestResponseError error { get; public set; }
    [CompilerGeneratedAttribute]
public CloudRoutingTimeCostMatrixResult get_data();
    [CompilerGeneratedAttribute]
public void set_data(CloudRoutingTimeCostMatrixResult value);
    [CompilerGeneratedAttribute]
public CloudRequestResponseError get_error();
    [CompilerGeneratedAttribute]
public void set_error(CloudRequestResponseError value);
}
[ObfuscationAttribute]
internal class ThinkGeo.Core.CloudRequestGradeResponse : object {
    [CompilerGeneratedAttribute]
private CloudRequestGradeResponseDataItem[] <Data>k__BackingField;
    [CompilerGeneratedAttribute]
private CloudRequestGradeResponseLowestGradeSegment <lowestGradeSegment>k__BackingField;
    [CompilerGeneratedAttribute]
private CloudRequestGradeResponseHighestGradeSegment <highestGradeSegment>k__BackingField;
    [CompilerGeneratedAttribute]
private double <averageGrade>k__BackingField;
    [CompilerGeneratedAttribute]
private CloudRequestResponseError <error>k__BackingField;
    public CloudRequestGradeResponseDataItem[] Data { get; public set; }
    public CloudRequestGradeResponseLowestGradeSegment lowestGradeSegment { get; public set; }
    public CloudRequestGradeResponseHighestGradeSegment highestGradeSegment { get; public set; }
    public double averageGrade { get; public set; }
    public CloudRequestResponseError error { get; public set; }
    [CompilerGeneratedAttribute]
public CloudRequestGradeResponseDataItem[] get_Data();
    [CompilerGeneratedAttribute]
public void set_Data(CloudRequestGradeResponseDataItem[] value);
    [CompilerGeneratedAttribute]
public CloudRequestGradeResponseLowestGradeSegment get_lowestGradeSegment();
    [CompilerGeneratedAttribute]
public void set_lowestGradeSegment(CloudRequestGradeResponseLowestGradeSegment value);
    [CompilerGeneratedAttribute]
public CloudRequestGradeResponseHighestGradeSegment get_highestGradeSegment();
    [CompilerGeneratedAttribute]
public void set_highestGradeSegment(CloudRequestGradeResponseHighestGradeSegment value);
    [CompilerGeneratedAttribute]
public double get_averageGrade();
    [CompilerGeneratedAttribute]
public void set_averageGrade(double value);
    [CompilerGeneratedAttribute]
public CloudRequestResponseError get_error();
    [CompilerGeneratedAttribute]
public void set_error(CloudRequestResponseError value);
}
[ObfuscationAttribute]
internal class ThinkGeo.Core.CloudRequestGradeResponseDataItem : object {
    [CompilerGeneratedAttribute]
private double <grade>k__BackingField;
    [CompilerGeneratedAttribute]
private string <wellKnownText>k__BackingField;
    [CompilerGeneratedAttribute]
private double <startingElevation>k__BackingField;
    [CompilerGeneratedAttribute]
private double <endingElevation>k__BackingField;
    public double grade { get; public set; }
    public string wellKnownText { get; public set; }
    public double startingElevation { get; public set; }
    public double endingElevation { get; public set; }
    [CompilerGeneratedAttribute]
public double get_grade();
    [CompilerGeneratedAttribute]
public void set_grade(double value);
    [CompilerGeneratedAttribute]
public string get_wellKnownText();
    [CompilerGeneratedAttribute]
public void set_wellKnownText(string value);
    [CompilerGeneratedAttribute]
public double get_startingElevation();
    [CompilerGeneratedAttribute]
public void set_startingElevation(double value);
    [CompilerGeneratedAttribute]
public double get_endingElevation();
    [CompilerGeneratedAttribute]
public void set_endingElevation(double value);
}
[ObfuscationAttribute]
internal class ThinkGeo.Core.CloudRequestGradeResponseHighestGradeSegment : object {
    [CompilerGeneratedAttribute]
private double <grade>k__BackingField;
    [CompilerGeneratedAttribute]
private string <wellKnownText>k__BackingField;
    [CompilerGeneratedAttribute]
private double <startingElevation>k__BackingField;
    [CompilerGeneratedAttribute]
private double <endingElevation>k__BackingField;
    public double grade { get; public set; }
    public string wellKnownText { get; public set; }
    public double startingElevation { get; public set; }
    public double endingElevation { get; public set; }
    [CompilerGeneratedAttribute]
public double get_grade();
    [CompilerGeneratedAttribute]
public void set_grade(double value);
    [CompilerGeneratedAttribute]
public string get_wellKnownText();
    [CompilerGeneratedAttribute]
public void set_wellKnownText(string value);
    [CompilerGeneratedAttribute]
public double get_startingElevation();
    [CompilerGeneratedAttribute]
public void set_startingElevation(double value);
    [CompilerGeneratedAttribute]
public double get_endingElevation();
    [CompilerGeneratedAttribute]
public void set_endingElevation(double value);
}
[ObfuscationAttribute]
internal class ThinkGeo.Core.CloudRequestGradeResponseLowestGradeSegment : object {
    [CompilerGeneratedAttribute]
private double <grade>k__BackingField;
    [CompilerGeneratedAttribute]
private string <wellKnownText>k__BackingField;
    [CompilerGeneratedAttribute]
private double <startingElevation>k__BackingField;
    [CompilerGeneratedAttribute]
private double <endingElevation>k__BackingField;
    public double grade { get; public set; }
    public string wellKnownText { get; public set; }
    public double startingElevation { get; public set; }
    public double endingElevation { get; public set; }
    [CompilerGeneratedAttribute]
public double get_grade();
    [CompilerGeneratedAttribute]
public void set_grade(double value);
    [CompilerGeneratedAttribute]
public string get_wellKnownText();
    [CompilerGeneratedAttribute]
public void set_wellKnownText(string value);
    [CompilerGeneratedAttribute]
public double get_startingElevation();
    [CompilerGeneratedAttribute]
public void set_startingElevation(double value);
    [CompilerGeneratedAttribute]
public double get_endingElevation();
    [CompilerGeneratedAttribute]
public void set_endingElevation(double value);
}
[ObfuscationAttribute]
internal class ThinkGeo.Core.CloudRequestGroupedColorResponse : object {
    [CompilerGeneratedAttribute]
private CloudRequestGroupedColorResponseDataItem[] <Data>k__BackingField;
    public CloudRequestGroupedColorResponseDataItem[] Data { get; public set; }
    [CompilerGeneratedAttribute]
public CloudRequestGroupedColorResponseDataItem[] get_Data();
    [CompilerGeneratedAttribute]
public void set_Data(CloudRequestGroupedColorResponseDataItem[] value);
}
[ObfuscationAttribute]
internal class ThinkGeo.Core.CloudRequestGroupedColorResponseDataItem : object {
    [CompilerGeneratedAttribute]
private List`1<string> <Colors>k__BackingField;
    [CompilerGeneratedAttribute]
private string <BaseColor>k__BackingField;
    public List`1<string> Colors { get; public set; }
    public string BaseColor { get; public set; }
    [CompilerGeneratedAttribute]
public List`1<string> get_Colors();
    [CompilerGeneratedAttribute]
public void set_Colors(List`1<string> value);
    [CompilerGeneratedAttribute]
public string get_BaseColor();
    [CompilerGeneratedAttribute]
public void set_BaseColor(string value);
}
[ObfuscationAttribute]
internal class ThinkGeo.Core.CloudRequestMultiGeocodingResultResponse : object {
    [CompilerGeneratedAttribute]
private CloudRequestMultiGeocodingResultResponseDataItem[] <data>k__BackingField;
    public CloudRequestMultiGeocodingResultResponseDataItem[] data { get; public set; }
    [CompilerGeneratedAttribute]
public CloudRequestMultiGeocodingResultResponseDataItem[] get_data();
    [CompilerGeneratedAttribute]
public void set_data(CloudRequestMultiGeocodingResultResponseDataItem[] value);
}
[ObfuscationAttribute]
internal class ThinkGeo.Core.CloudRequestMultiGeocodingResultResponseDataItem : object {
    [CompilerGeneratedAttribute]
private GeocodingLocationDto[] <locations>k__BackingField;
    [CompilerGeneratedAttribute]
private Dictionary`2<string, String[]> <errors>k__BackingField;
    public GeocodingLocationDto[] locations { get; public set; }
    public Dictionary`2<string, String[]> errors { get; public set; }
    [CompilerGeneratedAttribute]
public GeocodingLocationDto[] get_locations();
    [CompilerGeneratedAttribute]
public void set_locations(GeocodingLocationDto[] value);
    [CompilerGeneratedAttribute]
public Dictionary`2<string, String[]> get_errors();
    [CompilerGeneratedAttribute]
public void set_errors(Dictionary`2<string, String[]> value);
}
[ObfuscationAttribute]
internal class ThinkGeo.Core.CloudRequestOptimizationResultResponse : object {
    [CompilerGeneratedAttribute]
private CloudRoutingTspResult <data>k__BackingField;
    [CompilerGeneratedAttribute]
private CloudRequestResponseError <error>k__BackingField;
    public CloudRoutingTspResult data { get; public set; }
    public CloudRequestResponseError error { get; public set; }
    [CompilerGeneratedAttribute]
public CloudRoutingTspResult get_data();
    [CompilerGeneratedAttribute]
public void set_data(CloudRoutingTspResult value);
    [CompilerGeneratedAttribute]
public CloudRequestResponseError get_error();
    [CompilerGeneratedAttribute]
public void set_error(CloudRequestResponseError value);
}
[ObfuscationAttribute]
internal class ThinkGeo.Core.CloudRequestProjectGeometriesResultResponse : object {
    [CompilerGeneratedAttribute]
private CloudRequestProjectGeometriesResultResponseDataItem[] <data>k__BackingField;
    [CompilerGeneratedAttribute]
private CloudRequestResponseError <error>k__BackingField;
    public CloudRequestProjectGeometriesResultResponseDataItem[] data { get; public set; }
    public CloudRequestResponseError error { get; public set; }
    [CompilerGeneratedAttribute]
public CloudRequestProjectGeometriesResultResponseDataItem[] get_data();
    [CompilerGeneratedAttribute]
public void set_data(CloudRequestProjectGeometriesResultResponseDataItem[] value);
    [CompilerGeneratedAttribute]
public CloudRequestResponseError get_error();
    [CompilerGeneratedAttribute]
public void set_error(CloudRequestResponseError value);
}
[ObfuscationAttribute]
internal class ThinkGeo.Core.CloudRequestProjectGeometriesResultResponseDataItem : object {
    [CompilerGeneratedAttribute]
private string <projectedWellKnownText>k__BackingField;
    public Dictionary`2<string, String[]> errors;
    public string projectedWellKnownText { get; public set; }
    [CompilerGeneratedAttribute]
public string get_projectedWellKnownText();
    [CompilerGeneratedAttribute]
public void set_projectedWellKnownText(string value);
}
[ObfuscationAttribute]
internal class ThinkGeo.Core.CloudRequestProjectGeometryResultResponse : object {
    [CompilerGeneratedAttribute]
private CloudRequestGetProjectGeometryResultResponseData <data>k__BackingField;
    [CompilerGeneratedAttribute]
private CloudRequestResponseError <error>k__BackingField;
    public CloudRequestGetProjectGeometryResultResponseData data { get; public set; }
    public CloudRequestResponseError error { get; public set; }
    [CompilerGeneratedAttribute]
public CloudRequestGetProjectGeometryResultResponseData get_data();
    [CompilerGeneratedAttribute]
public void set_data(CloudRequestGetProjectGeometryResultResponseData value);
    [CompilerGeneratedAttribute]
public CloudRequestResponseError get_error();
    [CompilerGeneratedAttribute]
public void set_error(CloudRequestResponseError value);
}
[ObfuscationAttribute]
internal class ThinkGeo.Core.CloudRequestQueryResultResponse : object {
    [CompilerGeneratedAttribute]
private CloudRequestQueryResultResponseData <data>k__BackingField;
    [CompilerGeneratedAttribute]
private CloudRequestResponseError <error>k__BackingField;
    public CloudRequestQueryResultResponseData data { get; public set; }
    public CloudRequestResponseError error { get; public set; }
    [CompilerGeneratedAttribute]
public CloudRequestQueryResultResponseData get_data();
    [CompilerGeneratedAttribute]
public void set_data(CloudRequestQueryResultResponseData value);
    [CompilerGeneratedAttribute]
public CloudRequestResponseError get_error();
    [CompilerGeneratedAttribute]
public void set_error(CloudRequestResponseError value);
}
[ObfuscationAttribute]
internal class ThinkGeo.Core.CloudRequestQueryResultResponseData : object {
    [CompilerGeneratedAttribute]
private CloudRequestQueryResultResponseFeatureItem[] <features>k__BackingField;
    public CloudRequestQueryResultResponseFeatureItem[] features { get; public set; }
    [CompilerGeneratedAttribute]
public CloudRequestQueryResultResponseFeatureItem[] get_features();
    [CompilerGeneratedAttribute]
public void set_features(CloudRequestQueryResultResponseFeatureItem[] value);
}
[ObfuscationAttribute]
internal class ThinkGeo.Core.CloudRequestQueryResultResponseFeatureItem : object {
    [CompilerGeneratedAttribute]
private string <id>k__BackingField;
    [CompilerGeneratedAttribute]
private string <geometry>k__BackingField;
    [CompilerGeneratedAttribute]
private Dictionary`2<string, string> <attributes>k__BackingField;
    public string id { get; public set; }
    public string geometry { get; public set; }
    public Dictionary`2<string, string> attributes { get; public set; }
    [CompilerGeneratedAttribute]
public string get_id();
    [CompilerGeneratedAttribute]
public void set_id(string value);
    [CompilerGeneratedAttribute]
public string get_geometry();
    [CompilerGeneratedAttribute]
public void set_geometry(string value);
    [CompilerGeneratedAttribute]
public Dictionary`2<string, string> get_attributes();
    [CompilerGeneratedAttribute]
public void set_attributes(Dictionary`2<string, string> value);
}
[ObfuscationAttribute]
internal class ThinkGeo.Core.CloudRequestResponseError : object {
    [CompilerGeneratedAttribute]
private int <code>k__BackingField;
    [CompilerGeneratedAttribute]
private string <message>k__BackingField;
    public int code { get; public set; }
    public string message { get; public set; }
    [CompilerGeneratedAttribute]
public int get_code();
    [CompilerGeneratedAttribute]
public void set_code(int value);
    [CompilerGeneratedAttribute]
public string get_message();
    [CompilerGeneratedAttribute]
public void set_message(string value);
}
[ObfuscationAttribute]
internal class ThinkGeo.Core.CloudRequestReverseGeocoderResultArrayResponse : object {
    [CompilerGeneratedAttribute]
private CloudRequestReverseGeocoderResultArrayResponseDataItem[] <data>k__BackingField;
    [CompilerGeneratedAttribute]
private CloudRequestResponseError <error>k__BackingField;
    public CloudRequestReverseGeocoderResultArrayResponseDataItem[] data { get; public set; }
    public CloudRequestResponseError error { get; public set; }
    [CompilerGeneratedAttribute]
public CloudRequestReverseGeocoderResultArrayResponseDataItem[] get_data();
    [CompilerGeneratedAttribute]
public void set_data(CloudRequestReverseGeocoderResultArrayResponseDataItem[] value);
    [CompilerGeneratedAttribute]
public CloudRequestResponseError get_error();
    [CompilerGeneratedAttribute]
public void set_error(CloudRequestResponseError value);
}
[ObfuscationAttribute]
internal class ThinkGeo.Core.CloudRequestReverseGeocoderResultArrayResponseDataItem : object {
    public Dictionary`2<string, String[]> errors;
    [CompilerGeneratedAttribute]
private CloudRequestReverseGeocoderResultArrayResponseDataMatchLocation <bestMatchLocation>k__BackingField;
    [CompilerGeneratedAttribute]
private CloudRequestReverseGeocoderResultArrayResponseDataMatchLocation[] <nearbyLocations>k__BackingField;
    public CloudRequestReverseGeocoderResultArrayResponseDataMatchLocation bestMatchLocation { get; public set; }
    public CloudRequestReverseGeocoderResultArrayResponseDataMatchLocation[] nearbyLocations { get; public set; }
    [CompilerGeneratedAttribute]
public CloudRequestReverseGeocoderResultArrayResponseDataMatchLocation get_bestMatchLocation();
    [CompilerGeneratedAttribute]
public void set_bestMatchLocation(CloudRequestReverseGeocoderResultArrayResponseDataMatchLocation value);
    [CompilerGeneratedAttribute]
public CloudRequestReverseGeocoderResultArrayResponseDataMatchLocation[] get_nearbyLocations();
    [CompilerGeneratedAttribute]
public void set_nearbyLocations(CloudRequestReverseGeocoderResultArrayResponseDataMatchLocation[] value);
}
[ObfuscationAttribute]
internal class ThinkGeo.Core.CloudRequestReverseGeocoderResultArrayResponseDataMatchLocation : object {
    [CompilerGeneratedAttribute]
private ReverseGeocodingLocationDto <data>k__BackingField;
    public ReverseGeocodingLocationDto data { get; public set; }
    [CompilerGeneratedAttribute]
public ReverseGeocodingLocationDto get_data();
    [CompilerGeneratedAttribute]
public void set_data(ReverseGeocodingLocationDto value);
}
[ObfuscationAttribute]
internal class ThinkGeo.Core.CloudRequestReverseGeocoderResultResponse : object {
    [CompilerGeneratedAttribute]
private CloudRequestReverseGeocoderResultResponseData <data>k__BackingField;
    [CompilerGeneratedAttribute]
private CloudRequestResponseError <error>k__BackingField;
    public CloudRequestReverseGeocoderResultResponseData data { get; public set; }
    public CloudRequestResponseError error { get; public set; }
    [CompilerGeneratedAttribute]
public CloudRequestReverseGeocoderResultResponseData get_data();
    [CompilerGeneratedAttribute]
public void set_data(CloudRequestReverseGeocoderResultResponseData value);
    [CompilerGeneratedAttribute]
public CloudRequestResponseError get_error();
    [CompilerGeneratedAttribute]
public void set_error(CloudRequestResponseError value);
}
[ObfuscationAttribute]
internal class ThinkGeo.Core.CloudRequestReverseGeocoderResultResponseData : object {
    [CompilerGeneratedAttribute]
private CloudRequestReverseGeocoderResultResponseDataMatchLocation <bestMatchLocation>k__BackingField;
    [CompilerGeneratedAttribute]
private CloudRequestReverseGeocoderResultResponseDataMatchLocation[] <nearbyLocations>k__BackingField;
    public CloudRequestReverseGeocoderResultResponseDataMatchLocation bestMatchLocation { get; public set; }
    public CloudRequestReverseGeocoderResultResponseDataMatchLocation[] nearbyLocations { get; public set; }
    [CompilerGeneratedAttribute]
public CloudRequestReverseGeocoderResultResponseDataMatchLocation get_bestMatchLocation();
    [CompilerGeneratedAttribute]
public void set_bestMatchLocation(CloudRequestReverseGeocoderResultResponseDataMatchLocation value);
    [CompilerGeneratedAttribute]
public CloudRequestReverseGeocoderResultResponseDataMatchLocation[] get_nearbyLocations();
    [CompilerGeneratedAttribute]
public void set_nearbyLocations(CloudRequestReverseGeocoderResultResponseDataMatchLocation[] value);
}
[ObfuscationAttribute]
internal class ThinkGeo.Core.CloudRequestReverseGeocoderResultResponseDataMatchLocation : object {
    [CompilerGeneratedAttribute]
private ReverseGeocodingLocationDto <data>k__BackingField;
    public ReverseGeocodingLocationDto data { get; public set; }
    [CompilerGeneratedAttribute]
public ReverseGeocodingLocationDto get_data();
    [CompilerGeneratedAttribute]
public void set_data(ReverseGeocodingLocationDto value);
}
[ObfuscationAttribute]
internal class ThinkGeo.Core.CloudRequestTimeZone : object {
    [CompilerGeneratedAttribute]
private string <timezone>k__BackingField;
    [CompilerGeneratedAttribute]
private string <countryName>k__BackingField;
    [CompilerGeneratedAttribute]
private string <countryCode>k__BackingField;
    [CompilerGeneratedAttribute]
private string <comment>k__BackingField;
    [CompilerGeneratedAttribute]
private string <currentUtcTime>k__BackingField;
    [CompilerGeneratedAttribute]
private string <currentLocalTime>k__BackingField;
    [CompilerGeneratedAttribute]
private double <offsetSeconds>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <daylightSavingsActive>k__BackingField;
    [CompilerGeneratedAttribute]
private string <geometry>k__BackingField;
    public string timezone { get; public set; }
    public string countryName { get; public set; }
    public string countryCode { get; public set; }
    public string comment { get; public set; }
    public string currentUtcTime { get; public set; }
    public string currentLocalTime { get; public set; }
    public double offsetSeconds { get; public set; }
    public bool daylightSavingsActive { get; public set; }
    public string geometry { get; public set; }
    [CompilerGeneratedAttribute]
public string get_timezone();
    [CompilerGeneratedAttribute]
public void set_timezone(string value);
    [CompilerGeneratedAttribute]
public string get_countryName();
    [CompilerGeneratedAttribute]
public void set_countryName(string value);
    [CompilerGeneratedAttribute]
public string get_countryCode();
    [CompilerGeneratedAttribute]
public void set_countryCode(string value);
    [CompilerGeneratedAttribute]
public string get_comment();
    [CompilerGeneratedAttribute]
public void set_comment(string value);
    [CompilerGeneratedAttribute]
public string get_currentUtcTime();
    [CompilerGeneratedAttribute]
public void set_currentUtcTime(string value);
    [CompilerGeneratedAttribute]
public string get_currentLocalTime();
    [CompilerGeneratedAttribute]
public void set_currentLocalTime(string value);
    [CompilerGeneratedAttribute]
public double get_offsetSeconds();
    [CompilerGeneratedAttribute]
public void set_offsetSeconds(double value);
    [CompilerGeneratedAttribute]
public bool get_daylightSavingsActive();
    [CompilerGeneratedAttribute]
public void set_daylightSavingsActive(bool value);
    [CompilerGeneratedAttribute]
public string get_geometry();
    [CompilerGeneratedAttribute]
public void set_geometry(string value);
}
[ObfuscationAttribute]
internal class ThinkGeo.Core.CloudRequestTimeZoneResultResponse : object {
    [CompilerGeneratedAttribute]
private CloudRequestTimeZone <data>k__BackingField;
    [CompilerGeneratedAttribute]
private CloudRequestResponseError <error>k__BackingField;
    public CloudRequestTimeZone data { get; public set; }
    public CloudRequestResponseError error { get; public set; }
    [CompilerGeneratedAttribute]
public CloudRequestTimeZone get_data();
    [CompilerGeneratedAttribute]
public void set_data(CloudRequestTimeZone value);
    [CompilerGeneratedAttribute]
public CloudRequestResponseError get_error();
    [CompilerGeneratedAttribute]
public void set_error(CloudRequestResponseError value);
}
[ObfuscationAttribute]
internal class ThinkGeo.Core.CloudRequestTimeZoneResultResponseData : object {
    [CompilerGeneratedAttribute]
private string <timezone>k__BackingField;
    [CompilerGeneratedAttribute]
private string <countryName>k__BackingField;
    [CompilerGeneratedAttribute]
private string <countryCode>k__BackingField;
    [CompilerGeneratedAttribute]
private string <comment>k__BackingField;
    [CompilerGeneratedAttribute]
private string <currentUtcTime>k__BackingField;
    [CompilerGeneratedAttribute]
private string <currentLocalTime>k__BackingField;
    [CompilerGeneratedAttribute]
private double <offsetSeconds>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <daylightSavingsActive>k__BackingField;
    [CompilerGeneratedAttribute]
private string <geometry>k__BackingField;
    public string timezone { get; public set; }
    public string countryName { get; public set; }
    public string countryCode { get; public set; }
    public string comment { get; public set; }
    public string currentUtcTime { get; public set; }
    public string currentLocalTime { get; public set; }
    public double offsetSeconds { get; public set; }
    public bool daylightSavingsActive { get; public set; }
    public string geometry { get; public set; }
    [CompilerGeneratedAttribute]
public string get_timezone();
    [CompilerGeneratedAttribute]
public void set_timezone(string value);
    [CompilerGeneratedAttribute]
public string get_countryName();
    [CompilerGeneratedAttribute]
public void set_countryName(string value);
    [CompilerGeneratedAttribute]
public string get_countryCode();
    [CompilerGeneratedAttribute]
public void set_countryCode(string value);
    [CompilerGeneratedAttribute]
public string get_comment();
    [CompilerGeneratedAttribute]
public void set_comment(string value);
    [CompilerGeneratedAttribute]
public string get_currentUtcTime();
    [CompilerGeneratedAttribute]
public void set_currentUtcTime(string value);
    [CompilerGeneratedAttribute]
public string get_currentLocalTime();
    [CompilerGeneratedAttribute]
public void set_currentLocalTime(string value);
    [CompilerGeneratedAttribute]
public double get_offsetSeconds();
    [CompilerGeneratedAttribute]
public void set_offsetSeconds(double value);
    [CompilerGeneratedAttribute]
public bool get_daylightSavingsActive();
    [CompilerGeneratedAttribute]
public void set_daylightSavingsActive(bool value);
    [CompilerGeneratedAttribute]
public string get_geometry();
    [CompilerGeneratedAttribute]
public void set_geometry(string value);
}
[ObfuscationAttribute]
internal class ThinkGeo.Core.CloudRequestTokenResponse : object {
    [CompilerGeneratedAttribute]
private CloudRequestTokenResponseData <Data>k__BackingField;
    public CloudRequestTokenResponseData Data { get; public set; }
    [CompilerGeneratedAttribute]
public CloudRequestTokenResponseData get_Data();
    [CompilerGeneratedAttribute]
public void set_Data(CloudRequestTokenResponseData value);
}
[ObfuscationAttribute]
internal class ThinkGeo.Core.CloudRequestTokenResponseData : object {
    [CompilerGeneratedAttribute]
private string <access_token>k__BackingField;
    [CompilerGeneratedAttribute]
private int <expires_in>k__BackingField;
    [CompilerGeneratedAttribute]
private string <token_type>k__BackingField;
    public string access_token { get; public set; }
    public int expires_in { get; public set; }
    public string token_type { get; public set; }
    [CompilerGeneratedAttribute]
public string get_access_token();
    [CompilerGeneratedAttribute]
public void set_access_token(string value);
    [CompilerGeneratedAttribute]
public int get_expires_in();
    [CompilerGeneratedAttribute]
public void set_expires_in(int value);
    [CompilerGeneratedAttribute]
public string get_token_type();
    [CompilerGeneratedAttribute]
public void set_token_type(string value);
}
[ObfuscationAttribute]
public class ThinkGeo.Core.CloudReverseGeocodingLocation : object {
    [CompilerGeneratedAttribute]
private Feature <LocationFeature>k__BackingField;
    [CompilerGeneratedAttribute]
private string <LocationName>k__BackingField;
    [CompilerGeneratedAttribute]
private string <DirectionFromQueryFeature>k__BackingField;
    [CompilerGeneratedAttribute]
private double <DistanceFromQueryFeature>k__BackingField;
    [CompilerGeneratedAttribute]
private string <LocationCategory>k__BackingField;
    [CompilerGeneratedAttribute]
private string <LocationType>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Address>k__BackingField;
    [CompilerGeneratedAttribute]
private string <HouseNumber>k__BackingField;
    [CompilerGeneratedAttribute]
private Dictionary`2<string, string> <Properties>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Postcode>k__BackingField;
    [CompilerGeneratedAttribute]
private Dictionary`2<string, string> <AddressComponents>k__BackingField;
    public Feature LocationFeature { get; public set; }
    public string LocationName { get; public set; }
    public string DirectionFromQueryFeature { get; public set; }
    public double DistanceFromQueryFeature { get; public set; }
    public string LocationCategory { get; public set; }
    public string LocationType { get; public set; }
    public string Address { get; public set; }
    public string HouseNumber { get; public set; }
    public Dictionary`2<string, string> Properties { get; public set; }
    public string Postcode { get; public set; }
    public Dictionary`2<string, string> AddressComponents { get; public set; }
    [CompilerGeneratedAttribute]
public Feature get_LocationFeature();
    [CompilerGeneratedAttribute]
public void set_LocationFeature(Feature value);
    [CompilerGeneratedAttribute]
public string get_LocationName();
    [CompilerGeneratedAttribute]
public void set_LocationName(string value);
    [CompilerGeneratedAttribute]
public string get_DirectionFromQueryFeature();
    [CompilerGeneratedAttribute]
public void set_DirectionFromQueryFeature(string value);
    [CompilerGeneratedAttribute]
public double get_DistanceFromQueryFeature();
    [CompilerGeneratedAttribute]
public void set_DistanceFromQueryFeature(double value);
    [CompilerGeneratedAttribute]
public string get_LocationCategory();
    [CompilerGeneratedAttribute]
public void set_LocationCategory(string value);
    [CompilerGeneratedAttribute]
public string get_LocationType();
    [CompilerGeneratedAttribute]
public void set_LocationType(string value);
    [CompilerGeneratedAttribute]
public string get_Address();
    [CompilerGeneratedAttribute]
public void set_Address(string value);
    [CompilerGeneratedAttribute]
public string get_HouseNumber();
    [CompilerGeneratedAttribute]
public void set_HouseNumber(string value);
    [CompilerGeneratedAttribute]
public Dictionary`2<string, string> get_Properties();
    [CompilerGeneratedAttribute]
public void set_Properties(Dictionary`2<string, string> value);
    [CompilerGeneratedAttribute]
public string get_Postcode();
    [CompilerGeneratedAttribute]
public void set_Postcode(string value);
    [CompilerGeneratedAttribute]
public Dictionary`2<string, string> get_AddressComponents();
    [CompilerGeneratedAttribute]
public void set_AddressComponents(Dictionary`2<string, string> value);
}
[ObfuscationAttribute]
public class ThinkGeo.Core.CloudReverseGeocodingOptions : object {
    [CompilerGeneratedAttribute]
private string <Lang>k__BackingField;
    [CompilerGeneratedAttribute]
private int <MaxResults>k__BackingField;
    [CompilerGeneratedAttribute]
private CloudLocationCategories <LocationCategories>k__BackingField;
    [CompilerGeneratedAttribute]
private CloudReverseGeocodingResultDetail <ResultDetail>k__BackingField;
    [CompilerGeneratedAttribute]
private DistanceUnit <DistanceUnit>k__BackingField;
    [CompilerGeneratedAttribute]
private Collection`1<string> <LocationTypes>k__BackingField;
    public string Lang { get; public set; }
    public int MaxResults { get; public set; }
    public CloudLocationCategories LocationCategories { get; public set; }
    public CloudReverseGeocodingResultDetail ResultDetail { get; public set; }
    public DistanceUnit DistanceUnit { get; public set; }
    public Collection`1<string> LocationTypes { get; }
    [CompilerGeneratedAttribute]
public string get_Lang();
    [CompilerGeneratedAttribute]
public void set_Lang(string value);
    [CompilerGeneratedAttribute]
public int get_MaxResults();
    [CompilerGeneratedAttribute]
public void set_MaxResults(int value);
    [CompilerGeneratedAttribute]
public CloudLocationCategories get_LocationCategories();
    [CompilerGeneratedAttribute]
public void set_LocationCategories(CloudLocationCategories value);
    [CompilerGeneratedAttribute]
public CloudReverseGeocodingResultDetail get_ResultDetail();
    [CompilerGeneratedAttribute]
public void set_ResultDetail(CloudReverseGeocodingResultDetail value);
    [CompilerGeneratedAttribute]
public DistanceUnit get_DistanceUnit();
    [CompilerGeneratedAttribute]
public void set_DistanceUnit(DistanceUnit value);
    [CompilerGeneratedAttribute]
public Collection`1<string> get_LocationTypes();
}
[ObfuscationAttribute]
public class ThinkGeo.Core.CloudReverseGeocodingResult : object {
    [CompilerGeneratedAttribute]
private Feature <QueryFeature>k__BackingField;
    [CompilerGeneratedAttribute]
private CloudReverseGeocodingLocation <BestMatchLocation>k__BackingField;
    [CompilerGeneratedAttribute]
private Collection`1<CloudReverseGeocodingLocation> <NearbyLocations>k__BackingField;
    [CompilerGeneratedAttribute]
private ThinkGeoCloudApplicationException <Exception>k__BackingField;
    public Feature QueryFeature { get; }
    public CloudReverseGeocodingLocation BestMatchLocation { get; }
    public Collection`1<CloudReverseGeocodingLocation> NearbyLocations { get; }
    public ThinkGeoCloudApplicationException Exception { get; }
    public CloudReverseGeocodingResult(Feature queryFeature, CloudReverseGeocodingLocation bestMatchLocation, ThinkGeoCloudApplicationException exception);
    [CompilerGeneratedAttribute]
public Feature get_QueryFeature();
    [CompilerGeneratedAttribute]
public CloudReverseGeocodingLocation get_BestMatchLocation();
    [CompilerGeneratedAttribute]
public Collection`1<CloudReverseGeocodingLocation> get_NearbyLocations();
    [CompilerGeneratedAttribute]
public ThinkGeoCloudApplicationException get_Exception();
}
[ObfuscationAttribute]
public enum ThinkGeo.Core.CloudReverseGeocodingResultDetail : Enum {
    public int value__;
    public static CloudReverseGeocodingResultDetail Default;
    public static CloudReverseGeocodingResultDetail Verbose;
    public static CloudReverseGeocodingResultDetail Standard;
}
[ObfuscationAttribute]
public class ThinkGeo.Core.CloudRoutingDistanceCostMatrixResult : object {
    [CompilerGeneratedAttribute]
private Collection`1<CloudRoutingWaypoint> <Origins>k__BackingField;
    [CompilerGeneratedAttribute]
private Collection`1<CloudRoutingWaypoint> <Destinations>k__BackingField;
    [CompilerGeneratedAttribute]
private Single[0...,0...] <Distances>k__BackingField;
    public Collection`1<CloudRoutingWaypoint> Origins { get; public set; }
    public Collection`1<CloudRoutingWaypoint> Destinations { get; public set; }
    public Single[0...,0...] Distances { get; public set; }
    [CompilerGeneratedAttribute]
public Collection`1<CloudRoutingWaypoint> get_Origins();
    [CompilerGeneratedAttribute]
public void set_Origins(Collection`1<CloudRoutingWaypoint> value);
    [CompilerGeneratedAttribute]
public Collection`1<CloudRoutingWaypoint> get_Destinations();
    [CompilerGeneratedAttribute]
public void set_Destinations(Collection`1<CloudRoutingWaypoint> value);
    [CompilerGeneratedAttribute]
public Single[0...,0...] get_Distances();
    [CompilerGeneratedAttribute]
public void set_Distances(Single[0...,0...] value);
}
[ObfuscationAttribute]
public class ThinkGeo.Core.CloudRoutingGetCostMatrixOptions : object {
    [CompilerGeneratedAttribute]
private float <CoordinateSnapRadius>k__BackingField;
    [CompilerGeneratedAttribute]
private DistanceUnit <CoordinateSnapRadiusUnit>k__BackingField;
    [CompilerGeneratedAttribute]
private DistanceUnit <DistanceUnit>k__BackingField;
    public float CoordinateSnapRadius { get; public set; }
    public DistanceUnit CoordinateSnapRadiusUnit { get; public set; }
    public DistanceUnit DistanceUnit { get; public set; }
    [CompilerGeneratedAttribute]
public float get_CoordinateSnapRadius();
    [CompilerGeneratedAttribute]
public void set_CoordinateSnapRadius(float value);
    [CompilerGeneratedAttribute]
public DistanceUnit get_CoordinateSnapRadiusUnit();
    [CompilerGeneratedAttribute]
public void set_CoordinateSnapRadiusUnit(DistanceUnit value);
    [CompilerGeneratedAttribute]
public DistanceUnit get_DistanceUnit();
    [CompilerGeneratedAttribute]
public void set_DistanceUnit(DistanceUnit value);
}
[ObfuscationAttribute]
public class ThinkGeo.Core.CloudRoutingGetDistanceCostMatrixResult : object {
    [CompilerGeneratedAttribute]
private CloudRoutingDistanceCostMatrixResult <CostMatrixResult>k__BackingField;
    [CompilerGeneratedAttribute]
private ThinkGeoCloudApplicationException <Exception>k__BackingField;
    public CloudRoutingDistanceCostMatrixResult CostMatrixResult { get; public set; }
    public ThinkGeoCloudApplicationException Exception { get; public set; }
    [CompilerGeneratedAttribute]
public CloudRoutingDistanceCostMatrixResult get_CostMatrixResult();
    [CompilerGeneratedAttribute]
public void set_CostMatrixResult(CloudRoutingDistanceCostMatrixResult value);
    [CompilerGeneratedAttribute]
public ThinkGeoCloudApplicationException get_Exception();
    [CompilerGeneratedAttribute]
public void set_Exception(ThinkGeoCloudApplicationException value);
}
[ObfuscationAttribute]
public class ThinkGeo.Core.CloudRoutingGetRouteOptions : object {
    [CompilerGeneratedAttribute]
private bool <TurnByTurn>k__BackingField;
    [CompilerGeneratedAttribute]
private float <CoordinateSnapRadius>k__BackingField;
    [CompilerGeneratedAttribute]
private DistanceUnit <CoordinateSnapRadiusUnit>k__BackingField;
    [CompilerGeneratedAttribute]
private DistanceUnit <DistanceUnit>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<RouteType> <RouteType>k__BackingField;
    public bool TurnByTurn { get; public set; }
    public float CoordinateSnapRadius { get; public set; }
    public DistanceUnit CoordinateSnapRadiusUnit { get; public set; }
    public DistanceUnit DistanceUnit { get; public set; }
    public Nullable`1<RouteType> RouteType { get; public set; }
    [CompilerGeneratedAttribute]
public bool get_TurnByTurn();
    [CompilerGeneratedAttribute]
public void set_TurnByTurn(bool value);
    [CompilerGeneratedAttribute]
public float get_CoordinateSnapRadius();
    [CompilerGeneratedAttribute]
public void set_CoordinateSnapRadius(float value);
    [CompilerGeneratedAttribute]
public DistanceUnit get_CoordinateSnapRadiusUnit();
    [CompilerGeneratedAttribute]
public void set_CoordinateSnapRadiusUnit(DistanceUnit value);
    [CompilerGeneratedAttribute]
public DistanceUnit get_DistanceUnit();
    [CompilerGeneratedAttribute]
public void set_DistanceUnit(DistanceUnit value);
    [CompilerGeneratedAttribute]
public Nullable`1<RouteType> get_RouteType();
    [CompilerGeneratedAttribute]
public void set_RouteType(Nullable`1<RouteType> value);
}
[ObfuscationAttribute]
public class ThinkGeo.Core.CloudRoutingGetRouteResult : object {
    [CompilerGeneratedAttribute]
private CloudRoutingRouteResult <RouteResult>k__BackingField;
    [CompilerGeneratedAttribute]
private ThinkGeoCloudApplicationException <Exception>k__BackingField;
    public CloudRoutingRouteResult RouteResult { get; public set; }
    public ThinkGeoCloudApplicationException Exception { get; public set; }
    [CompilerGeneratedAttribute]
public CloudRoutingRouteResult get_RouteResult();
    [CompilerGeneratedAttribute]
public void set_RouteResult(CloudRoutingRouteResult value);
    [CompilerGeneratedAttribute]
public ThinkGeoCloudApplicationException get_Exception();
    [CompilerGeneratedAttribute]
public void set_Exception(ThinkGeoCloudApplicationException value);
}
[ObfuscationAttribute]
public class ThinkGeo.Core.CloudRoutingGetServiceAreaOptions : object {
    [CompilerGeneratedAttribute]
private DistanceUnit <DistanceUnit>k__BackingField;
    [CompilerGeneratedAttribute]
private float <ContourGranularity>k__BackingField;
    [CompilerGeneratedAttribute]
private float <CoordinateSnapRadius>k__BackingField;
    [CompilerGeneratedAttribute]
private DistanceUnit <CoordinateSnapRadiusUnit>k__BackingField;
    [CompilerGeneratedAttribute]
private float <GridSizeInMeters>k__BackingField;
    [CompilerGeneratedAttribute]
private CloudRoutingServiceAreaSeparationType <ServiceAreaSeparationType>k__BackingField;
    [CompilerGeneratedAttribute]
private CloudRoutingServiceAreaObjectType <ServiceAreaType>k__BackingField;
    [CompilerGeneratedAttribute]
private CloudRoutingServiceAreaTravelDirection <TravelDirection>k__BackingField;
    public DistanceUnit DistanceUnit { get; public set; }
    public float ContourGranularity { get; public set; }
    public float CoordinateSnapRadius { get; public set; }
    public DistanceUnit CoordinateSnapRadiusUnit { get; public set; }
    public float GridSizeInMeters { get; public set; }
    public CloudRoutingServiceAreaSeparationType ServiceAreaSeparationType { get; public set; }
    public CloudRoutingServiceAreaObjectType ServiceAreaType { get; public set; }
    public CloudRoutingServiceAreaTravelDirection TravelDirection { get; public set; }
    [CompilerGeneratedAttribute]
public DistanceUnit get_DistanceUnit();
    [CompilerGeneratedAttribute]
public void set_DistanceUnit(DistanceUnit value);
    [CompilerGeneratedAttribute]
public float get_ContourGranularity();
    [CompilerGeneratedAttribute]
public void set_ContourGranularity(float value);
    [CompilerGeneratedAttribute]
public float get_CoordinateSnapRadius();
    [CompilerGeneratedAttribute]
public void set_CoordinateSnapRadius(float value);
    [CompilerGeneratedAttribute]
public DistanceUnit get_CoordinateSnapRadiusUnit();
    [CompilerGeneratedAttribute]
public void set_CoordinateSnapRadiusUnit(DistanceUnit value);
    [CompilerGeneratedAttribute]
public float get_GridSizeInMeters();
    [CompilerGeneratedAttribute]
public void set_GridSizeInMeters(float value);
    [CompilerGeneratedAttribute]
public CloudRoutingServiceAreaSeparationType get_ServiceAreaSeparationType();
    [CompilerGeneratedAttribute]
public void set_ServiceAreaSeparationType(CloudRoutingServiceAreaSeparationType value);
    [CompilerGeneratedAttribute]
public CloudRoutingServiceAreaObjectType get_ServiceAreaType();
    [CompilerGeneratedAttribute]
public void set_ServiceAreaType(CloudRoutingServiceAreaObjectType value);
    [CompilerGeneratedAttribute]
public CloudRoutingServiceAreaTravelDirection get_TravelDirection();
    [CompilerGeneratedAttribute]
public void set_TravelDirection(CloudRoutingServiceAreaTravelDirection value);
}
[ObfuscationAttribute]
public class ThinkGeo.Core.CloudRoutingGetServiceAreaResult : object {
    [CompilerGeneratedAttribute]
private CloudRoutingServiceAreaResult <ServiceAreaResult>k__BackingField;
    [CompilerGeneratedAttribute]
private ThinkGeoCloudApplicationException <Exception>k__BackingField;
    public CloudRoutingServiceAreaResult ServiceAreaResult { get; public set; }
    public ThinkGeoCloudApplicationException Exception { get; public set; }
    [CompilerGeneratedAttribute]
public CloudRoutingServiceAreaResult get_ServiceAreaResult();
    [CompilerGeneratedAttribute]
public void set_ServiceAreaResult(CloudRoutingServiceAreaResult value);
    [CompilerGeneratedAttribute]
public ThinkGeoCloudApplicationException get_Exception();
    [CompilerGeneratedAttribute]
public void set_Exception(ThinkGeoCloudApplicationException value);
}
[ObfuscationAttribute]
public class ThinkGeo.Core.CloudRoutingGetTimeCostMatrixResult : object {
    [CompilerGeneratedAttribute]
private CloudRoutingTimeCostMatrixResult <CostMatrixResult>k__BackingField;
    [CompilerGeneratedAttribute]
private ThinkGeoCloudApplicationException <Exception>k__BackingField;
    public CloudRoutingTimeCostMatrixResult CostMatrixResult { get; public set; }
    public ThinkGeoCloudApplicationException Exception { get; public set; }
    [CompilerGeneratedAttribute]
public CloudRoutingTimeCostMatrixResult get_CostMatrixResult();
    [CompilerGeneratedAttribute]
public void set_CostMatrixResult(CloudRoutingTimeCostMatrixResult value);
    [CompilerGeneratedAttribute]
public ThinkGeoCloudApplicationException get_Exception();
    [CompilerGeneratedAttribute]
public void set_Exception(ThinkGeoCloudApplicationException value);
}
[ObfuscationAttribute]
public class ThinkGeo.Core.CloudRoutingOptimizationOptions : object {
    [CompilerGeneratedAttribute]
private bool <Roundtrip>k__BackingField;
    [CompilerGeneratedAttribute]
private CloudRoutingTspFixSourceCoordinate <Source>k__BackingField;
    [CompilerGeneratedAttribute]
private CloudRoutingTspFixDestinationCoordinate <Destination>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <TurnByTurn>k__BackingField;
    [CompilerGeneratedAttribute]
private float <CoordinateSnapRadius>k__BackingField;
    [CompilerGeneratedAttribute]
private DistanceUnit <CoordinateSnapRadiusUnit>k__BackingField;
    [CompilerGeneratedAttribute]
private DistanceUnit <DistanceUnit>k__BackingField;
    public bool Roundtrip { get; public set; }
    public CloudRoutingTspFixSourceCoordinate Source { get; public set; }
    public CloudRoutingTspFixDestinationCoordinate Destination { get; public set; }
    public bool TurnByTurn { get; public set; }
    public float CoordinateSnapRadius { get; public set; }
    public DistanceUnit CoordinateSnapRadiusUnit { get; public set; }
    public DistanceUnit DistanceUnit { get; public set; }
    [CompilerGeneratedAttribute]
public bool get_Roundtrip();
    [CompilerGeneratedAttribute]
public void set_Roundtrip(bool value);
    [CompilerGeneratedAttribute]
public CloudRoutingTspFixSourceCoordinate get_Source();
    [CompilerGeneratedAttribute]
public void set_Source(CloudRoutingTspFixSourceCoordinate value);
    [CompilerGeneratedAttribute]
public CloudRoutingTspFixDestinationCoordinate get_Destination();
    [CompilerGeneratedAttribute]
public void set_Destination(CloudRoutingTspFixDestinationCoordinate value);
    [CompilerGeneratedAttribute]
public bool get_TurnByTurn();
    [CompilerGeneratedAttribute]
public void set_TurnByTurn(bool value);
    [CompilerGeneratedAttribute]
public float get_CoordinateSnapRadius();
    [CompilerGeneratedAttribute]
public void set_CoordinateSnapRadius(float value);
    [CompilerGeneratedAttribute]
public DistanceUnit get_CoordinateSnapRadiusUnit();
    [CompilerGeneratedAttribute]
public void set_CoordinateSnapRadiusUnit(DistanceUnit value);
    [CompilerGeneratedAttribute]
public DistanceUnit get_DistanceUnit();
    [CompilerGeneratedAttribute]
public void set_DistanceUnit(DistanceUnit value);
}
[ObfuscationAttribute]
public class ThinkGeo.Core.CloudRoutingOptimizationResult : object {
    [CompilerGeneratedAttribute]
private CloudRoutingTspResult <TspResult>k__BackingField;
    [CompilerGeneratedAttribute]
private ThinkGeoCloudApplicationException <Exception>k__BackingField;
    public CloudRoutingTspResult TspResult { get; public set; }
    public ThinkGeoCloudApplicationException Exception { get; public set; }
    [CompilerGeneratedAttribute]
public CloudRoutingTspResult get_TspResult();
    [CompilerGeneratedAttribute]
public void set_TspResult(CloudRoutingTspResult value);
    [CompilerGeneratedAttribute]
public ThinkGeoCloudApplicationException get_Exception();
    [CompilerGeneratedAttribute]
public void set_Exception(ThinkGeoCloudApplicationException value);
}
[ObfuscationAttribute]
public class ThinkGeo.Core.CloudRoutingRoute : object {
    [CompilerGeneratedAttribute]
private double <Distance>k__BackingField;
    [CompilerGeneratedAttribute]
private TimeSpan <Duration>k__BackingField;
    [CompilerGeneratedAttribute]
private LineShape <Shape>k__BackingField;
    [CompilerGeneratedAttribute]
private Collection`1<CloudRoutingSegment> <Segments>k__BackingField;
    [CompilerGeneratedAttribute]
private Dictionary`2<string, string> <Warnings>k__BackingField;
    public double Distance { get; public set; }
    [CloudJsonConverterAttribute("ThinkGeo.Core.CloudDurationMinuteReader")]
public TimeSpan Duration { get; public set; }
    [CloudJsonConverterAttribute("ThinkGeo.Core.CloudShapeWktConverter")]
[CloudJsonPropertyAttribute("geometry")]
public LineShape Shape { get; public set; }
    public Collection`1<CloudRoutingSegment> Segments { get; public set; }
    public Dictionary`2<string, string> Warnings { get; public set; }
    [CompilerGeneratedAttribute]
public double get_Distance();
    [CompilerGeneratedAttribute]
public void set_Distance(double value);
    [CompilerGeneratedAttribute]
public TimeSpan get_Duration();
    [CompilerGeneratedAttribute]
public void set_Duration(TimeSpan value);
    [CompilerGeneratedAttribute]
public LineShape get_Shape();
    [CompilerGeneratedAttribute]
public void set_Shape(LineShape value);
    [CompilerGeneratedAttribute]
public Collection`1<CloudRoutingSegment> get_Segments();
    [CompilerGeneratedAttribute]
public void set_Segments(Collection`1<CloudRoutingSegment> value);
    [CompilerGeneratedAttribute]
public Dictionary`2<string, string> get_Warnings();
    [CompilerGeneratedAttribute]
public void set_Warnings(Dictionary`2<string, string> value);
}
[ObfuscationAttribute]
public class ThinkGeo.Core.CloudRoutingRouteResult : object {
    [CompilerGeneratedAttribute]
private Collection`1<CloudRoutingWaypoint> <Waypoints>k__BackingField;
    [CompilerGeneratedAttribute]
private Collection`1<CloudRoutingRoute> <Routes>k__BackingField;
    public Collection`1<CloudRoutingWaypoint> Waypoints { get; public set; }
    public Collection`1<CloudRoutingRoute> Routes { get; public set; }
    [CompilerGeneratedAttribute]
public Collection`1<CloudRoutingWaypoint> get_Waypoints();
    [CompilerGeneratedAttribute]
public void set_Waypoints(Collection`1<CloudRoutingWaypoint> value);
    [CompilerGeneratedAttribute]
public Collection`1<CloudRoutingRoute> get_Routes();
    [CompilerGeneratedAttribute]
public void set_Routes(Collection`1<CloudRoutingRoute> value);
}
[ObfuscationAttribute]
public class ThinkGeo.Core.CloudRoutingSegment : object {
    [CompilerGeneratedAttribute]
private double <Distance>k__BackingField;
    [CompilerGeneratedAttribute]
private TimeSpan <Duration>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Name>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Instruction>k__BackingField;
    [CompilerGeneratedAttribute]
private string <ManeuverType>k__BackingField;
    [CompilerGeneratedAttribute]
private LineShape <Shape>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Ref>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<bool> <IsToll>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<bool> <IsPrivate>k__BackingField;
    [CompilerGeneratedAttribute]
private Vertex <ManeuverLocation>k__BackingField;
    public double Distance { get; public set; }
    [CloudJsonConverterAttribute("ThinkGeo.Core.CloudDurationMinuteReader")]
public TimeSpan Duration { get; public set; }
    public string Name { get; public set; }
    public string Instruction { get; public set; }
    public string ManeuverType { get; public set; }
    [CloudJsonPropertyAttribute("geometry")]
[CloudJsonConverterAttribute("ThinkGeo.Core.CloudShapeWktConverter")]
public LineShape Shape { get; public set; }
    public string Ref { get; public set; }
    public Nullable`1<bool> IsToll { get; public set; }
    public Nullable`1<bool> IsPrivate { get; public set; }
    public Vertex ManeuverLocation { get; public set; }
    [CompilerGeneratedAttribute]
public double get_Distance();
    [CompilerGeneratedAttribute]
public void set_Distance(double value);
    [CompilerGeneratedAttribute]
public TimeSpan get_Duration();
    [CompilerGeneratedAttribute]
public void set_Duration(TimeSpan value);
    [CompilerGeneratedAttribute]
public string get_Name();
    [CompilerGeneratedAttribute]
public void set_Name(string value);
    [CompilerGeneratedAttribute]
public string get_Instruction();
    [CompilerGeneratedAttribute]
public void set_Instruction(string value);
    [CompilerGeneratedAttribute]
public string get_ManeuverType();
    [CompilerGeneratedAttribute]
public void set_ManeuverType(string value);
    [CompilerGeneratedAttribute]
public LineShape get_Shape();
    [CompilerGeneratedAttribute]
public void set_Shape(LineShape value);
    [CompilerGeneratedAttribute]
public string get_Ref();
    [CompilerGeneratedAttribute]
public void set_Ref(string value);
    [CompilerGeneratedAttribute]
public Nullable`1<bool> get_IsToll();
    [CompilerGeneratedAttribute]
public void set_IsToll(Nullable`1<bool> value);
    [CompilerGeneratedAttribute]
public Nullable`1<bool> get_IsPrivate();
    [CompilerGeneratedAttribute]
public void set_IsPrivate(Nullable`1<bool> value);
    [CompilerGeneratedAttribute]
public Vertex get_ManeuverLocation();
    [CompilerGeneratedAttribute]
public void set_ManeuverLocation(Vertex value);
}
[ObfuscationAttribute]
public enum ThinkGeo.Core.CloudRoutingServiceAreaObjectType : Enum {
    public int value__;
    public static CloudRoutingServiceAreaObjectType Polygon;
    public static CloudRoutingServiceAreaObjectType LineString;
}
[ObfuscationAttribute]
public class ThinkGeo.Core.CloudRoutingServiceAreaResult : object {
    [CompilerGeneratedAttribute]
private CloudRoutingWaypoint <Waypoint>k__BackingField;
    [CompilerGeneratedAttribute]
private Collection`1<BaseShape> <ServiceAreas>k__BackingField;
    public CloudRoutingWaypoint Waypoint { get; public set; }
    [CloudJsonConverterAttribute("ThinkGeo.Core.CloudShapeWktConverter")]
public Collection`1<BaseShape> ServiceAreas { get; public set; }
    [CompilerGeneratedAttribute]
public CloudRoutingWaypoint get_Waypoint();
    [CompilerGeneratedAttribute]
public void set_Waypoint(CloudRoutingWaypoint value);
    [CompilerGeneratedAttribute]
public Collection`1<BaseShape> get_ServiceAreas();
    [CompilerGeneratedAttribute]
public void set_ServiceAreas(Collection`1<BaseShape> value);
}
[ObfuscationAttribute]
public enum ThinkGeo.Core.CloudRoutingServiceAreaSeparationType : Enum {
    public int value__;
    public static CloudRoutingServiceAreaSeparationType Separated;
    public static CloudRoutingServiceAreaSeparationType Merged;
}
[ObfuscationAttribute]
public enum ThinkGeo.Core.CloudRoutingServiceAreaTravelDirection : Enum {
    public int value__;
    public static CloudRoutingServiceAreaTravelDirection From;
    public static CloudRoutingServiceAreaTravelDirection To;
}
[ObfuscationAttribute]
public class ThinkGeo.Core.CloudRoutingTimeCostMatrixResult : object {
    [CompilerGeneratedAttribute]
private Collection`1<CloudRoutingWaypoint> <Origins>k__BackingField;
    [CompilerGeneratedAttribute]
private Collection`1<CloudRoutingWaypoint> <Destinations>k__BackingField;
    [CompilerGeneratedAttribute]
private TimeSpan[0...,0...] <Durations>k__BackingField;
    public Collection`1<CloudRoutingWaypoint> Origins { get; public set; }
    public Collection`1<CloudRoutingWaypoint> Destinations { get; public set; }
    [CloudJsonConverterAttribute("ThinkGeo.Core.CloudDurationMinuteReader")]
public TimeSpan[0...,0...] Durations { get; public set; }
    [CompilerGeneratedAttribute]
public Collection`1<CloudRoutingWaypoint> get_Origins();
    [CompilerGeneratedAttribute]
public void set_Origins(Collection`1<CloudRoutingWaypoint> value);
    [CompilerGeneratedAttribute]
public Collection`1<CloudRoutingWaypoint> get_Destinations();
    [CompilerGeneratedAttribute]
public void set_Destinations(Collection`1<CloudRoutingWaypoint> value);
    [CompilerGeneratedAttribute]
public TimeSpan[0...,0...] get_Durations();
    [CompilerGeneratedAttribute]
public void set_Durations(TimeSpan[0...,0...] value);
}
[ObfuscationAttribute]
public enum ThinkGeo.Core.CloudRoutingTspFixDestinationCoordinate : Enum {
    public int value__;
    public static CloudRoutingTspFixDestinationCoordinate Any;
    public static CloudRoutingTspFixDestinationCoordinate Last;
}
[ObfuscationAttribute]
public enum ThinkGeo.Core.CloudRoutingTspFixSourceCoordinate : Enum {
    public int value__;
    public static CloudRoutingTspFixSourceCoordinate Any;
    public static CloudRoutingTspFixSourceCoordinate First;
}
[ObfuscationAttribute]
public class ThinkGeo.Core.CloudRoutingTspResult : object {
    [CompilerGeneratedAttribute]
private Collection`1<CloudRoutingWaypoint> <Waypoints>k__BackingField;
    [CompilerGeneratedAttribute]
private Collection`1<int> <VisitSequences>k__BackingField;
    [CompilerGeneratedAttribute]
private Collection`1<CloudRoutingRoute> <Routes>k__BackingField;
    public Collection`1<CloudRoutingWaypoint> Waypoints { get; public set; }
    public Collection`1<int> VisitSequences { get; public set; }
    public Collection`1<CloudRoutingRoute> Routes { get; public set; }
    [CompilerGeneratedAttribute]
public Collection`1<CloudRoutingWaypoint> get_Waypoints();
    [CompilerGeneratedAttribute]
public void set_Waypoints(Collection`1<CloudRoutingWaypoint> value);
    [CompilerGeneratedAttribute]
public Collection`1<int> get_VisitSequences();
    [CompilerGeneratedAttribute]
public void set_VisitSequences(Collection`1<int> value);
    [CompilerGeneratedAttribute]
public Collection`1<CloudRoutingRoute> get_Routes();
    [CompilerGeneratedAttribute]
public void set_Routes(Collection`1<CloudRoutingRoute> value);
}
[ObfuscationAttribute]
public class ThinkGeo.Core.CloudRoutingWaypoint : object {
    [CompilerGeneratedAttribute]
private Vertex <Coordinate>k__BackingField;
    [CompilerGeneratedAttribute]
private float <SnappedDistance>k__BackingField;
    public Vertex Coordinate { get; public set; }
    public float SnappedDistance { get; public set; }
    [CompilerGeneratedAttribute]
public Vertex get_Coordinate();
    [CompilerGeneratedAttribute]
public void set_Coordinate(Vertex value);
    [CompilerGeneratedAttribute]
public float get_SnappedDistance();
    [CompilerGeneratedAttribute]
public void set_SnappedDistance(float value);
}
[ObfuscationAttribute]
internal class ThinkGeo.Core.CloudShapeWktConverter : CloudJsonConverter`1<BaseShape> {
    public virtual BaseShape ReadJson(CloudGeoJObject jObject, Type objectType);
    public virtual void WriteJson(CloudGeoJObject jObject, BaseShape value);
}
[ObfuscationAttribute]
public enum ThinkGeo.Core.CloudTileSize : Enum {
    public int value__;
    public static CloudTileSize Default;
    public static CloudTileSize Small;
    public static CloudTileSize Medium;
}
[ObfuscationAttribute]
public class ThinkGeo.Core.CloudTimeZoneResult : object {
    [CompilerGeneratedAttribute]
private string <TimeZone>k__BackingField;
    [CompilerGeneratedAttribute]
private string <CountryName>k__BackingField;
    [CompilerGeneratedAttribute]
private string <CountryCode>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Comment>k__BackingField;
    [CompilerGeneratedAttribute]
private DateTime <CurrentLocalTime>k__BackingField;
    [CompilerGeneratedAttribute]
private DateTime <CurrentUtcTime>k__BackingField;
    [CompilerGeneratedAttribute]
private double <OffsetSeconds>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <DaylightSavingsActive>k__BackingField;
    [CompilerGeneratedAttribute]
private MultipolygonShape <Shape>k__BackingField;
    public string TimeZone { get; }
    public string CountryName { get; }
    public string CountryCode { get; }
    public string Comment { get; }
    public DateTime CurrentLocalTime { get; }
    public DateTime CurrentUtcTime { get; }
    public double OffsetSeconds { get; }
    public bool DaylightSavingsActive { get; }
    public MultipolygonShape Shape { get; }
    public CloudTimeZoneResult(string timezone, string countryName, string countryCode, string comment, DateTime currentLocalTime, DateTime currentUtcTime, double offsetSeconds, bool daylightSavingsActive, MultipolygonShape shape);
    [CompilerGeneratedAttribute]
public string get_TimeZone();
    [CompilerGeneratedAttribute]
public string get_CountryName();
    [CompilerGeneratedAttribute]
public string get_CountryCode();
    [CompilerGeneratedAttribute]
public string get_Comment();
    [CompilerGeneratedAttribute]
public DateTime get_CurrentLocalTime();
    [CompilerGeneratedAttribute]
public DateTime get_CurrentUtcTime();
    [CompilerGeneratedAttribute]
public double get_OffsetSeconds();
    [CompilerGeneratedAttribute]
public bool get_DaylightSavingsActive();
    [CompilerGeneratedAttribute]
public MultipolygonShape get_Shape();
}
[ObfuscationAttribute]
internal static class ThinkGeo.Core.CloudValidators : object {
    internal static void ValueInRange(string parameterName, int value, int minValue, bool includeMinValue, int maxValue, bool includeMaxValue);
    internal static void ValueInRange(string parameterName, double value, double minValue, bool includeMinValue, double maxValue, bool includeMaxValue);
    internal static void ValueInRange(string parameterName, int value, int minValue, int maxValue);
    internal static void ValueInRange(string parameterName, double value, double minValue, double maxValue);
    internal static void NotNull(object value, string paramName);
    internal static void NotNullOrEmpty(string value, string paramName);
    internal static void ItemNotNull(IEnumerable`1<T> values, string paramName);
}
public class ThinkGeo.Core.ClusterPointStyle : Style {
    [ObfuscationAttribute]
private int cellSize;
    [ObfuscationAttribute]
private TextStyle defaultTextSytle;
    [ObfuscationAttribute]
private int minimumFeaturesPerCellToCluster;
    [ObfuscationAttribute]
private bool clusterCellLinesVisible;
    [ObfuscationAttribute]
private Collection`1<Style> customStyles;
    [ObfuscationAttribute]
private PointStyle defaultPointStyle;
    [ObfuscationAttribute]
private PointStyle clusteredPointStyle;
    [CompilerGeneratedAttribute]
private EventHandler`1<DrawingClusteredFeatureClusterPointStyleEventArgs> uzE=;
    public PointStyle DefaultPointStyle { get; public set; }
    public PointStyle ClusteredPointStyle { get; public set; }
    public TextStyle DefaultTextStyle { get; public set; }
    public Collection`1<Style> CustomStyles { get; }
    public int CellSize { get; public set; }
    public bool ClusterCellLinesVisible { get; public set; }
    public int MinimumFeaturesPerCellToCluster { get; public set; }
    public ClusterPointStyle(PointStyle defaultPointStyle);
    public ClusterPointStyle(PointStyle defaultPointStyle, TextStyle defaultTextStyle);
    public ClusterPointStyle(PointStyle defaultPointStyle, TextStyle defaultTextStyle, PointStyle clusteredPointStyle);
    [CompilerGeneratedAttribute]
public void add_DrawingClusteredFeature(EventHandler`1<DrawingClusteredFeatureClusterPointStyleEventArgs> value);
    [CompilerGeneratedAttribute]
public void remove_DrawingClusteredFeature(EventHandler`1<DrawingClusteredFeatureClusterPointStyleEventArgs> value);
    public PointStyle get_DefaultPointStyle();
    public void set_DefaultPointStyle(PointStyle value);
    public PointStyle get_ClusteredPointStyle();
    public void set_ClusteredPointStyle(PointStyle value);
    public TextStyle get_DefaultTextStyle();
    public void set_DefaultTextStyle(TextStyle value);
    public Collection`1<Style> get_CustomStyles();
    public int get_CellSize();
    public void set_CellSize(int value);
    public bool get_ClusterCellLinesVisible();
    public void set_ClusterCellLinesVisible(bool value);
    public int get_MinimumFeaturesPerCellToCluster();
    public void set_MinimumFeaturesPerCellToCluster(int value);
    protected virtual void DrawCore(IEnumerable`1<Feature> features, GeoCanvas canvas, Collection`1<SimpleCandidate> labelsInThisLayer, Collection`1<SimpleCandidate> labelsInAllLayers);
    protected virtual Collection`1<string> GetRequiredColumnNamesCore();
    protected virtual void OnDrawingClusterdFeature(DrawingClusteredFeatureClusterPointStyleEventArgs e);
    private static bool vh8=(RectangleShape bbox, PointShape point);
    private static T vDE=(object obj);
}
public class ThinkGeo.Core.CollectedMapArgumentsMapViewEventArgs : EventArgs {
    [ObfuscationAttribute]
private MapArguments mapArguments;
    public MapArguments MapArguments { get; public set; }
    public CollectedMapArgumentsMapViewEventArgs(MapArguments mapArguments);
    public MapArguments get_MapArguments();
    public void set_MapArguments(MapArguments value);
}
public class ThinkGeo.Core.ColorCloudClient : CloudClient {
    public ColorCloudClient(string clientId, string clientSecret);
    public Dictionary`2<GeoColor, Collection`1<GeoColor>> GetColorsInAnalogousFamily(int numberOfColors);
    [AsyncStateMachineAttribute("ThinkGeo.Core.ColorCloudClient/CT4=")]
public Task`1<Dictionary`2<GeoColor, Collection`1<GeoColor>>> GetColorsInAnalogousFamilyAsync(int numberOfColors);
    public Dictionary`2<GeoColor, Collection`1<GeoColor>> GetColorsInAnalogousFamily(GeoColor color, int numberOfColors);
    [AsyncStateMachineAttribute("ThinkGeo.Core.ColorCloudClient/DD4=")]
public Task`1<Dictionary`2<GeoColor, Collection`1<GeoColor>>> GetColorsInAnalogousFamilyAsync(GeoColor color, int numberOfColors);
    public Dictionary`2<GeoColor, Collection`1<GeoColor>> GetColorsInComplementaryFamily(int numberOfColors);
    [AsyncStateMachineAttribute("ThinkGeo.Core.ColorCloudClient/Dj4=")]
public Task`1<Dictionary`2<GeoColor, Collection`1<GeoColor>>> GetColorsInComplementaryFamilyAsync(int numberOfColors);
    public Dictionary`2<GeoColor, Collection`1<GeoColor>> GetColorsInComplementaryFamily(GeoColor color, int numberOfColors);
    [AsyncStateMachineAttribute("ThinkGeo.Core.ColorCloudClient/Dz4=")]
public Task`1<Dictionary`2<GeoColor, Collection`1<GeoColor>>> GetColorsInComplementaryFamilyAsync(GeoColor color, int numberOfColors);
    public Dictionary`2<GeoColor, Collection`1<GeoColor>> GetColorsInContrastingFamily(int numberOfColors);
    [AsyncStateMachineAttribute("ThinkGeo.Core.ColorCloudClient/ED4=")]
public Task`1<Dictionary`2<GeoColor, Collection`1<GeoColor>>> GetColorsInContrastingFamilyAsync(int numberOfColors);
    public Dictionary`2<GeoColor, Collection`1<GeoColor>> GetColorsInContrastingFamily(GeoColor color, int numberOfColors);
    [AsyncStateMachineAttribute("ThinkGeo.Core.ColorCloudClient/ET4=")]
public Task`1<Dictionary`2<GeoColor, Collection`1<GeoColor>>> GetColorsInContrastingFamilyAsync(GeoColor color, int numberOfColors);
    public Collection`1<GeoColor> GetColorsInHueFamily(int numberOfColors);
    [AsyncStateMachineAttribute("ThinkGeo.Core.ColorCloudClient/Ej4=")]
public Task`1<Collection`1<GeoColor>> GetColorsInHueFamilyAsync(int numberOfColors);
    public Collection`1<GeoColor> GetColorsInHueFamily(GeoColor color, int numberOfColors);
    [AsyncStateMachineAttribute("ThinkGeo.Core.ColorCloudClient/Ez4=")]
public Task`1<Collection`1<GeoColor>> GetColorsInHueFamilyAsync(GeoColor color, int numberOfColors);
    public Collection`1<GeoColor> GetColorsInQualityFamily(int numberOfColors);
    [AsyncStateMachineAttribute("ThinkGeo.Core.ColorCloudClient/FD4=")]
public Task`1<Collection`1<GeoColor>> GetColorsInQualityFamilyAsync(int numberOfColors);
    public Collection`1<GeoColor> GetColorsInQualityFamily(GeoColor color, int numberOfColors);
    [AsyncStateMachineAttribute("ThinkGeo.Core.ColorCloudClient/FT4=")]
public Task`1<Collection`1<GeoColor>> GetColorsInQualityFamilyAsync(GeoColor color, int numberOfColors);
    public Dictionary`2<GeoColor, Collection`1<GeoColor>> GetColorsInTetradFamily(int numberOfColors);
    [AsyncStateMachineAttribute("ThinkGeo.Core.ColorCloudClient/Fj4=")]
public Task`1<Dictionary`2<GeoColor, Collection`1<GeoColor>>> GetColorsInTetradFamilyAsync(int numberOfColors);
    public Dictionary`2<GeoColor, Collection`1<GeoColor>> GetColorsInTetradFamily(GeoColor color, int numberOfColors);
    [AsyncStateMachineAttribute("ThinkGeo.Core.ColorCloudClient/Fz4=")]
public Task`1<Dictionary`2<GeoColor, Collection`1<GeoColor>>> GetColorsInTetradFamilyAsync(GeoColor color, int numberOfColors);
    public Dictionary`2<GeoColor, Collection`1<GeoColor>> GetColorsInTriadFamily(int numberOfColors);
    [AsyncStateMachineAttribute("ThinkGeo.Core.ColorCloudClient/GD4=")]
public Task`1<Dictionary`2<GeoColor, Collection`1<GeoColor>>> GetColorsInTriadFamilyAsync(int numberOfColors);
    public Dictionary`2<GeoColor, Collection`1<GeoColor>> GetColorsInTriadFamily(GeoColor color, int numberOfColors);
    [AsyncStateMachineAttribute("ThinkGeo.Core.ColorCloudClient/GT4=")]
public Task`1<Dictionary`2<GeoColor, Collection`1<GeoColor>>> GetColorsInTriadFamilyAsync(GeoColor color, int numberOfColors);
    private Collection`1<GeoColor> yBQ=(WebResponse response);
    private Dictionary`2<GeoColor, Collection`1<GeoColor>> yRQ=(WebResponse response);
    private Collection`1<GeoColor> yhQ=(List`1<string> result);
    private GeoColor yxQ=(string colorExpression);
    private string zBQ=(GeoColor color);
}
[ObfuscationAttribute]
internal enum ThinkGeo.Core.ColorType : Enum {
    public int value__;
    public static ColorType NonStandardColor;
    public static ColorType StandardColor;
    public static ColorType SimpleColor;
}
public enum ThinkGeo.Core.ColorWheelDirection : Enum {
    public int value__;
    public static ColorWheelDirection Clockwise;
    public static ColorWheelDirection CounterClockwise;
}
public class ThinkGeo.Core.CommittedTransactionEventArgs : EventArgs {
    [ObfuscationAttribute]
private TransactionBuffer transactionBuffer;
    public TransactionBuffer TransactionBuffer { get; public set; }
    public CommittedTransactionEventArgs(TransactionBuffer transactionBuffer);
    public TransactionBuffer get_TransactionBuffer();
    public void set_TransactionBuffer(TransactionBuffer value);
}
public class ThinkGeo.Core.CommittingTransactionEventArgs : EventArgs {
    [ObfuscationAttribute]
private TransactionBuffer transactionBuffer;
    [ObfuscationAttribute]
private bool cancel;
    public bool Cancel { get; public set; }
    public TransactionBuffer TransactionBuffer { get; public set; }
    public CommittingTransactionEventArgs(TransactionBuffer transactionBuffer);
    public bool get_Cancel();
    public void set_Cancel(bool value);
    public TransactionBuffer get_TransactionBuffer();
    public void set_TransactionBuffer(TransactionBuffer value);
}
public class ThinkGeo.Core.CompositeStyle : Style {
    [ObfuscationAttribute]
private ObservableCollection`1<Style> styles;
    [ObfuscationAttribute]
private Collection`1<string> filtersFromStyles;
    public ObservableCollection`1<Style> Styles { get; }
    protected Collection`1<string> FiltersCore { get; }
    public CompositeStyle(Style style);
    public CompositeStyle(IEnumerable`1<Style> styles);
    public ObservableCollection`1<Style> get_Styles();
    protected virtual void DrawCore(IEnumerable`1<Feature> features, GeoCanvas canvas, Collection`1<SimpleCandidate> labelsInThisLayer, Collection`1<SimpleCandidate> labelsInAllLayers);
    protected virtual void DrawSampleCore(GeoCanvas canvas, DrawingRectangleF drawingExtent);
    protected virtual Collection`1<string> GetRequiredColumnNamesCore();
    protected virtual Collection`1<string> get_FiltersCore();
}
internal class ThinkGeo.Core.ContractResolver : object {
    private static ContractResolver _instance;
    private ThreadSafeStore`2<Type, JsonContract> _contractCache;
    internal static ContractResolver Instance { get; }
    private static ContractResolver();
    internal static ContractResolver get_Instance();
    public virtual JsonContract ResolveContract(Type type);
    private JsonContract CreateContract(Type objectType);
    private IList`1<JsonProperty> CreateConstructorParameters(ConstructorInfo constructor, JsonPropertyCollection memberProperties);
    private JsonProperty CreatePropertyFromConstructorParameter(JsonProperty matchingMemberProperty, ParameterInfo parameterInfo);
    private JsonProperty MatchProperty(JsonPropertyCollection properties, string name, Type type);
    private wRU=<object> CreateParameterizedConstructor(MethodBase method);
    private ConstructorInfo GetParameterizedConstructor(Type objectType);
    private IList`1<JsonProperty> CreateProperties(Type type);
    private JsonProperty CreateProperty(MemberInfo member);
    private static bool CanSetMemberValue(MemberInfo member, bool nonPublic, bool canSetReadOnly);
    private static bool CanReadMemberValue(MemberInfo member, bool nonPublic);
    private void SetPropertySettingsFromAttributes(JsonProperty property, object attributeProvider, string name, Type declaringType, Boolean& allowNonPublicAccess);
    private List`1<MemberInfo> GetSerializableMembers(Type objectType);
    private static List`1<MemberInfo> GetFieldsAndProperties(Type type, BindingFlags bindingAttr);
    private static bool IsOverridenGenericMember(MemberInfo memberInfo, BindingFlags bindingAttr);
    public static bool IsVirtual(PropertyInfo propertyInfo);
    private static Type GetMemberUnderlyingType(MemberInfo member);
    private static IEnumerable`1<PropertyInfo> GetProperties(Type targetType, BindingFlags bindingAttr);
    private static IEnumerable`1<FieldInfo> GetFields(Type targetType, BindingFlags bindingAttr);
    private static void GetChildPrivateFields(IList`1<MemberInfo> initialFields, Type targetType, BindingFlags bindingAttr);
}
public class ThinkGeo.Core.ControlPointSelectedEditInteractiveOverlayEventArgs : EventArgs {
    [CompilerGeneratedAttribute]
private Feature qhQ=;
    public Feature SelectedFeature { get; public set; }
    public ControlPointSelectedEditInteractiveOverlayEventArgs(Feature selectedFeature);
    [CompilerGeneratedAttribute]
public Feature get_SelectedFeature();
    [CompilerGeneratedAttribute]
public void set_SelectedFeature(Feature value);
}
public class ThinkGeo.Core.ControlPointSelectingEditInteractiveOverlayEventArgs : EventArgs {
    [ObfuscationAttribute]
private PointShape targetPointShape;
    [ObfuscationAttribute]
private bool cancel;
    public PointShape TargetPointShape { get; public set; }
    public bool Cancel { get; public set; }
    public ControlPointSelectingEditInteractiveOverlayEventArgs(bool cancel, PointShape targetPointShape);
    public PointShape get_TargetPointShape();
    public void set_TargetPointShape(PointShape value);
    public bool get_Cancel();
    public void set_Cancel(bool value);
}
public static class ThinkGeo.Core.Conversion : object {
    [ObfuscationAttribute]
private static Dictionary`2<DistanceUnit, double> distanceDictionary;
    [ObfuscationAttribute]
private static Dictionary`2<AreaUnit, double> areaDictionary;
    private static Conversion();
    public static double ConvertMeasureUnits(double amount, DistanceUnit fromUnit, DistanceUnit toUnit);
    public static double ConvertMeasureUnits(double amount, AreaUnit fromUnit, AreaUnit toUnit);
    public static DistanceUnit ConvertGeographyUnitToDistanceUnit(GeographyUnit unit);
    internal static double 6ho=(double degrees);
    public static double ConvertAngleUnits(double angle, AngleUnit fromUnit, AngleUnit toUnit);
}
public class ThinkGeo.Core.ConvertedShapeToNtsGeometryShapeConverterEventArgs : object {
    [CompilerGeneratedAttribute]
private BaseShape 6xo=;
    [CompilerGeneratedAttribute]
private Geometry 7Bo=;
    public BaseShape FromShape { get; public set; }
    public Geometry ToGeometry { get; public set; }
    [CompilerGeneratedAttribute]
public BaseShape get_FromShape();
    [CompilerGeneratedAttribute]
public void set_FromShape(BaseShape value);
    [CompilerGeneratedAttribute]
public Geometry get_ToGeometry();
    [CompilerGeneratedAttribute]
public void set_ToGeometry(Geometry value);
}
internal class ThinkGeo.Core.CreatedMemberNodeGeoObjectModelerEventArgs : EventArgs {
    [ObfuscationAttribute]
private string name;
    [ObfuscationAttribute]
private object value;
    [ObfuscationAttribute]
private Type type;
    [ObfuscationAttribute]
private object owner;
    [ObfuscationAttribute]
private GeoObjectNode node;
    public string Name { get; public set; }
    public object Value { get; public set; }
    public Type Type { get; public set; }
    public object Owner { get; public set; }
    public GeoObjectNode Node { get; public set; }
    public CreatedMemberNodeGeoObjectModelerEventArgs(string name, object value, Type type, object owner, GeoObjectNode node);
    public string get_Name();
    public void set_Name(string value);
    public object get_Value();
    public void set_Value(object value);
    public Type get_Type();
    public void set_Type(Type value);
    public object get_Owner();
    public void set_Owner(object value);
    public GeoObjectNode get_Node();
    public void set_Node(GeoObjectNode value);
}
internal class ThinkGeo.Core.CreatedMemberObjectGeoObjectModelerEventArgs : EventArgs {
    [ObfuscationAttribute]
private string name;
    [ObfuscationAttribute]
private object value;
    [ObfuscationAttribute]
private Type type;
    [ObfuscationAttribute]
private object owner;
    public string Name { get; public set; }
    public object Value { get; public set; }
    public Type Type { get; public set; }
    public object Owner { get; public set; }
    public CreatedMemberObjectGeoObjectModelerEventArgs(string name, object value, Type type, object owner);
    public string get_Name();
    public void set_Name(string value);
    public object get_Value();
    public void set_Value(object value);
    public Type get_Type();
    public void set_Type(Type value);
    public object get_Owner();
    public void set_Owner(object value);
}
internal class ThinkGeo.Core.CreatingMemberNodeGeoObjectModelerEventArgs : EventArgs {
    [ObfuscationAttribute]
private string name;
    [ObfuscationAttribute]
private object value;
    [ObfuscationAttribute]
private Type type;
    [ObfuscationAttribute]
private object owner;
    public string Name { get; public set; }
    public object Value { get; public set; }
    public Type Type { get; public set; }
    public object Owner { get; public set; }
    public CreatingMemberNodeGeoObjectModelerEventArgs(string name, object value, Type type, object owner);
    public string get_Name();
    public void set_Name(string value);
    public object get_Value();
    public void set_Value(object value);
    public Type get_Type();
    public void set_Type(Type value);
    public object get_Owner();
    public void set_Owner(object value);
}
internal class ThinkGeo.Core.CreatingMemberObjectGeoObjectModelerEventArgs : EventArgs {
    [ObfuscationAttribute]
private string name;
    [ObfuscationAttribute]
private Type type;
    [ObfuscationAttribute]
private object owner;
    [ObfuscationAttribute]
private GeoObjectNode node;
    public string Name { get; public set; }
    public Type Type { get; public set; }
    public object Owner { get; public set; }
    public GeoObjectNode Node { get; public set; }
    public CreatingMemberObjectGeoObjectModelerEventArgs(string name, Type type, object owner, GeoObjectNode node);
    public string get_Name();
    public void set_Name(string value);
    public Type get_Type();
    public void set_Type(Type value);
    public object get_Owner();
    public void set_Owner(object value);
    public GeoObjectNode get_Node();
    public void set_Node(GeoObjectNode value);
}
public class ThinkGeo.Core.CreatingRequestGoogleMapsLayerEventArgs : EventArgs {
    [ObfuscationAttribute]
private Uri requestUri;
    public Uri RequestUri { get; public set; }
    public CreatingRequestGoogleMapsLayerEventArgs(Uri requestUri);
    public Uri get_RequestUri();
    public void set_RequestUri(Uri value);
}
public class ThinkGeo.Core.CustomColumnFetchEventArgs : EventArgs {
    [ObfuscationAttribute]
private string columnName;
    [ObfuscationAttribute]
private string id;
    [ObfuscationAttribute]
private string columnValue;
    public string ColumnName { get; }
    public string Id { get; }
    public string ColumnValue { get; public set; }
    public CustomColumnFetchEventArgs(string columnName, string id);
    public string get_ColumnName();
    public string get_Id();
    public string get_ColumnValue();
    public void set_ColumnValue(string value);
}
public enum ThinkGeo.Core.DatabaseConnectionMode : Enum {
    public int value__;
    public static DatabaseConnectionMode Default;
    public static DatabaseConnectionMode AutoClose;
    public static DatabaseConnectionMode KeepOpen;
}
public class ThinkGeo.Core.DateRangeFilterCondition : FilterCondition {
    [ObfuscationAttribute]
private DateTime fromDate;
    [ObfuscationAttribute]
private DateTime toDate;
    public DateTime FromDate { get; public set; }
    public DateTime ToDate { get; public set; }
    public DateRangeFilterCondition(DateTime fromDate, DateTime toDate);
    public DateTime get_FromDate();
    public void set_FromDate(DateTime value);
    public DateTime get_ToDate();
    public void set_ToDate(DateTime value);
    internal virtual bool TSM=(Feature feature);
    private bool xDE=(Feature feature);
    private bool xTE=(DateTime currentDate, string dateString);
}
public class ThinkGeo.Core.DbfColumn : FeatureSourceColumn {
    [ObfuscationAttribute]
private DbfColumnType columnType;
    [ObfuscationAttribute]
private int length;
    [ObfuscationAttribute]
private int decimalLength;
    public DbfColumnType ColumnType { get; public set; }
    public int Length { get; public set; }
    public int DecimalLength { get; public set; }
    public DbfColumn(string columnName, DbfColumnType columnType, int length, int decimalLength);
    public DbfColumnType get_ColumnType();
    public void set_ColumnType(DbfColumnType value);
    public int get_Length();
    public void set_Length(int value);
    public int get_DecimalLength();
    public void set_DecimalLength(int value);
}
internal class ThinkGeo.Core.DbfColumnInfo : ValueType {
    [ObfuscationAttribute]
private int offset;
    [ObfuscationAttribute]
private int size;
    [ObfuscationAttribute]
private int decimals;
    [ObfuscationAttribute]
private byte byteType;
    public int Offset { get; public set; }
    public int Size { get; public set; }
    public int Decimals { get; public set; }
    public byte ByteType { get; public set; }
    public int get_Offset();
    public void set_Offset(int value);
    public int get_Size();
    public void set_Size(int value);
    public int get_Decimals();
    public void set_Decimals(int value);
    public byte get_ByteType();
    public void set_ByteType(byte value);
    public virtual bool Equals(object obj);
    private bool Equals(DbfColumnInfo dbfColumnInfo);
    public virtual int GetHashCode();
    public static DbfColumnInfo op_Addition(DbfColumnInfo dbfColumnInfo1, DbfColumnInfo dbfColumnInfo2);
    public static bool op_Equality(DbfColumnInfo dbfColumnInfo1, DbfColumnInfo dbfColumnInfo2);
    public static bool op_Inequality(DbfColumnInfo dbfColumnInfo1, DbfColumnInfo dbfColumnInfo2);
}
public enum ThinkGeo.Core.DbfColumnType : Enum {
    public int value__;
    public static DbfColumnType Null;
    public static DbfColumnType Logical;
    public static DbfColumnType Memo;
    public static DbfColumnType Date;
    public static DbfColumnType DateTime;
    public static DbfColumnType IntegerInBinary;
    public static DbfColumnType DoubleInBinary;
    public static DbfColumnType Character;
    public static DbfColumnType Float;
    public static DbfColumnType Numeric;
}
public static class ThinkGeo.Core.DecimalDegreesHelper : object {
    private static double 7Ro=;
    private static double 7ho=;
    private static double 7xo=;
    private static int 8Bo=;
    public static string GetDegreesMinutesStringFromDecimalDegreePoint(Feature point, int decimals);
    public static string GetDegreesMinutesStringFromDecimalDegreePoint(Feature point);
    public static string GetDegreesMinutesStringFromDecimalDegreePoint(PointShape pointShape);
    public static string GetDegreesMinutesStringFromDecimalDegreePoint(PointShape pointShape, int decimals);
    internal static string 8Ro=(double decimalDegreesValue);
    internal static string 8Ro=(double decimalDegreesValue, int decimals);
    public static DegreesMinutesSeconds GetDegreesMinutesSecondsFromDecimalDegree(double decimalDegreesValue);
    public static string GetDegreesMinutesSecondsStringFromDecimalDegree(double decimalDegreesValue);
    public static string GetDegreesMinutesSecondsStringFromDecimalDegree(double decimalDegreesValue, int decimals);
    public static string GetDegreesMinutesSecondsStringFromDecimalDegreePoint(PointShape pointShape);
    public static string GetDegreesMinutesSecondsStringFromDecimalDegreePoint(PointShape pointShape, int decimals);
    public static string GetDegreesMinutesSecondsStringFromDecimalDegreePoint(Feature point, int decimalPlaces);
    public static string GetDegreesMinutesSecondsStringFromDecimalDegreePoint(Feature point);
    public static double GetDecimalDegreeFromDegreesMinutesSeconds(string degreesMinutesSeconds);
    public static double GetDecimalDegreeFromDegreesMinutesSeconds(DegreesMinutesSeconds degreesMinutesSeconds);
    public static double GetDecimalDegreeFromDegreesMinutesSeconds(int degrees, int minutes, double seconds);
    public static double GetDistanceFromDecimalDegrees(PointShape fromPoint, PointShape toPoint, DistanceUnit returningUnit);
    public static double GetDistanceFromDecimalDegrees(Feature fromPointFeature, Feature toPointFeature, DistanceUnit returningUnit);
    public static double GetDistanceFromDecimalDegrees(double fromLatitude, double fromLongitude, double toLatitude, double toLongitude, DistanceUnit returningUnit);
    public static double GetLongitudeDifferenceFromDistance(double distance, DistanceUnit distanceUnit, double latitude);
    public static double GetLatitudeDifferenceFromDistance(double distance, DistanceUnit distanceUnit);
    public static string ConvertToMgrs(double latitude, double longitude);
    public static PointShape ConvertFromMgrs(string mgrs);
    internal static double 8ho=(double fromLongitude, double fromLatitude, double distance, DistanceUnit distanceUnit, double degree);
    internal static double 8xo=(double fromLongitude, double fromLatitude, double distance, DistanceUnit distanceUnit, double degree);
    internal static MultilineShape 9Bo=(PointShape fromPoint, PointShape toPoint, int count);
    internal static double 9Ro=(double fromPointX, double fromPointY, double toPointX, double toPointY, PointShape pointShape, DistanceUnit lengthUnit);
    internal static PointShape 9ho=(double fromPointX, double fromPointY, double toPointX, double toPointY, PointShape pointShape);
    internal static double 9xo=(double degreeX, double degreeY, DistanceUnit distanceUnit);
    internal static double /Bo=(double degreeY, DistanceUnit distanceUnit);
}
public class ThinkGeo.Core.DegreesMinutesSeconds : ValueType {
    [ObfuscationAttribute]
private int degrees;
    [ObfuscationAttribute]
private int minutes;
    [ObfuscationAttribute]
private double seconds;
    public int Degrees { get; public set; }
    public int Minutes { get; public set; }
    public double Seconds { get; public set; }
    public DegreesMinutesSeconds(int degrees, int minutes, double seconds);
    private static double /Ro=(int degrees, int minutes, double seconds);
    public int get_Degrees();
    public void set_Degrees(int value);
    public int get_Minutes();
    public void set_Minutes(int value);
    public double get_Seconds();
    public void set_Seconds(double value);
    public virtual int GetHashCode();
    public virtual bool Equals(object obj);
    private bool lhU=(DegreesMinutesSeconds compareObj);
    public DegreesMinutesSeconds Add(DegreesMinutesSeconds targetDegreesMinutesSeconds);
    public static DegreesMinutesSeconds op_Addition(DegreesMinutesSeconds degreesMinutesSeconds1, DegreesMinutesSeconds degreesMinutesSeconds2);
    public static bool op_Equality(DegreesMinutesSeconds degreesMinutesSeconds1, DegreesMinutesSeconds degreesMinutesSeconds2);
    public static bool op_Inequality(DegreesMinutesSeconds degreesMinutesSeconds1, DegreesMinutesSeconds degreesMinutesSeconds2);
    public virtual string ToString();
    public string GetFormattedString(int decimals);
    public string GetFormattedString(DegreesMinutesSecondsFormatType formatType);
    public string GetFormattedString(DegreesMinutesSecondsFormatType formatType, int decimals);
}
public enum ThinkGeo.Core.DegreesMinutesSecondsFormatType : Enum {
    public int value__;
    public static DegreesMinutesSecondsFormatType DegreesMinutesSeconds;
    public static DegreesMinutesSecondsFormatType DegreesMinutes;
}
public enum ThinkGeo.Core.DelimitedColumnHeaderType : Enum {
    public int value__;
    public static DelimitedColumnHeaderType FirstRowAsHeader;
    public static DelimitedColumnHeaderType NoHeader;
}
public class ThinkGeo.Core.DelimitedFeatureLayer : FeatureLayer {
    [ObfuscationAttribute]
private DelimitedFeatureSource featureSource;
    public string DelimitedPathFilename { get; public set; }
    public string XColumnName { get; public set; }
    public string YColumnName { get; public set; }
    public string WellKnownTextColumnName { get; public set; }
    internal int uiE= { get; internal set; }
    internal int vSE= { get; internal set; }
    internal int wCE= { get; internal set; }
    public string Delimiter { get; public set; }
    public DelimitedSpatialColumnsType SpatialColumnType { get; public set; }
    internal DelimitedColumnHeaderType wyE= { get; internal set; }
    public Encoding Encoding { get; public set; }
    public bool RequireIndex { get; public set; }
    public bool HasBoundingBox { get; }
    public DelimitedFeatureLayer(string delimitedPathFilename, string wellKnownTextColumnName, string delimiter);
    public DelimitedFeatureLayer(string delimitedPathFilename, string xColumnName, string yColumnName, string delimiter);
    private DelimitedFeatureLayer(string delimitedPathFilename);
    public string get_DelimitedPathFilename();
    public void set_DelimitedPathFilename(string value);
    public string get_XColumnName();
    public void set_XColumnName(string value);
    public string get_YColumnName();
    public void set_YColumnName(string value);
    public string get_WellKnownTextColumnName();
    public void set_WellKnownTextColumnName(string value);
    internal int uCE=();
    internal void uSE=(int value);
    internal int uyE=();
    internal void vCE=(int value);
    internal int viE=();
    internal void vyE=(int value);
    public string get_Delimiter();
    public void set_Delimiter(string value);
    public DelimitedSpatialColumnsType get_SpatialColumnType();
    public void set_SpatialColumnType(DelimitedSpatialColumnsType value);
    internal DelimitedColumnHeaderType wSE=();
    internal void wiE=(DelimitedColumnHeaderType value);
    public Encoding get_Encoding();
    public void set_Encoding(Encoding value);
    public bool get_RequireIndex();
    public void set_RequireIndex(bool value);
    public virtual bool get_HasBoundingBox();
    public static void BuildIndexFile(string delimitedPathFilename, string xColumnName, string yColumnName, string delimiter, BuildIndexMode buildIndexMode, Encoding encoding);
    public static void BuildIndexFile(string delimitedPathFilename, string wellKnownTextColumnName, string delimiter, BuildIndexMode buildIndexMode, Encoding encoding);
    public static void BuildIndexFile(string delimitedPathFilename, string xColumnName, string yColumnName, string delimiter, BuildIndexMode buildIndexMode);
    public static void BuildIndexFile(string delimitedPathFilename, string wellKnownTextColumnName, string delimiter, BuildIndexMode buildIndexMode);
    public static void CreateDelimitedFile(string delimitedPathFilename, IEnumerable`1<string> columnNames, string delimiter, OverwriteMode overwriteMode);
    public static void CreateDelimitedFile(string delimitedPathFilename, IEnumerable`1<string> columnNames, string delimiter, OverwriteMode overwriteMode, Encoding encoding);
}
public class ThinkGeo.Core.DelimitedFeatureSource : FeatureSource {
    private static int xCE=;
    [CompilerGeneratedAttribute]
private static EventHandler`1<BuildingIndexDelimitedFeatureSourceEventArgs> xSE=;
    [ObfuscationAttribute]
private string delimitedPathFilename;
    [ObfuscationAttribute]
private string xColumnName;
    [ObfuscationAttribute]
private string yColumnName;
    [ObfuscationAttribute]
private int xColumnPosition;
    [ObfuscationAttribute]
private int yColumnPosition;
    [ObfuscationAttribute]
private string wellKnownTextColumnName;
    [ObfuscationAttribute]
private int wellKnownTextColumnPosition;
    [ObfuscationAttribute]
private string delimiter;
    [ObfuscationAttribute]
private DelimitedSpatialColumnsType spatialColumnType;
    [ObfuscationAttribute]
private DelimitedColumnHeaderType columnHeaderType;
    [ObfuscationAttribute]
private Encoding encoding;
    [ObfuscationAttribute]
private bool requireIndex;
    private RtreeSpatialIndex xiE=;
    private String[] xyE=;
    private string yCE=;
    public string DelimitedPathFilename { get; public set; }
    public string XColumnName { get; public set; }
    public string YColumnName { get; public set; }
    public string WellKnownTextColumnName { get; public set; }
    internal int uiE= { get; internal set; }
    internal int vSE= { get; internal set; }
    internal int wCE= { get; internal set; }
    public string Delimiter { get; public set; }
    public DelimitedSpatialColumnsType SpatialColumnType { get; public set; }
    internal DelimitedColumnHeaderType wyE= { get; internal set; }
    public Encoding Encoding { get; public set; }
    public bool RequireIndex { get; public set; }
    public bool IsEditable { get; }
    public DelimitedFeatureSource(string delimitedPathFilename, string xColumnName, string yColumnName, string delimiter);
    public DelimitedFeatureSource(string delimitedPathFilename, string wellKnownTextColumnName, string delimiter);
    internal DelimitedFeatureSource(string delimitedPathFilename, int xColumnPosition, int yColumnPosition, string delimiter);
    internal DelimitedFeatureSource(string delimitedPathFilename, int wellKnownTextColumnPosition, string delimiter);
    private DelimitedFeatureSource(string delimitedPathFilename, string delimiter);
    private static DelimitedFeatureSource();
    [CompilerGeneratedAttribute]
public static void add_BuildingIndex(EventHandler`1<BuildingIndexDelimitedFeatureSourceEventArgs> value);
    [CompilerGeneratedAttribute]
public static void remove_BuildingIndex(EventHandler`1<BuildingIndexDelimitedFeatureSourceEventArgs> value);
    public string get_DelimitedPathFilename();
    public void set_DelimitedPathFilename(string value);
    public string get_XColumnName();
    public void set_XColumnName(string value);
    public string get_YColumnName();
    public void set_YColumnName(string value);
    public string get_WellKnownTextColumnName();
    public void set_WellKnownTextColumnName(string value);
    internal int uCE=();
    internal void uSE=(int value);
    internal int uyE=();
    internal void vCE=(int value);
    internal int viE=();
    internal void vyE=(int value);
    public string get_Delimiter();
    public void set_Delimiter(string value);
    public DelimitedSpatialColumnsType get_SpatialColumnType();
    public void set_SpatialColumnType(DelimitedSpatialColumnsType value);
    internal DelimitedColumnHeaderType wSE=();
    internal void wiE=(DelimitedColumnHeaderType value);
    public Encoding get_Encoding();
    public void set_Encoding(Encoding value);
    public bool get_RequireIndex();
    public void set_RequireIndex(bool value);
    protected virtual void OpenCore();
    public virtual bool get_IsEditable();
    protected virtual bool CanGetCountQuicklyCore();
    protected virtual void CloseCore();
    protected virtual long GetCountCore();
    protected virtual RectangleShape GetBoundingBoxCore();
    protected virtual Collection`1<FeatureSourceColumn> GetColumnsCore();
    protected virtual Collection`1<Feature> GetFeaturesByIdsCore(IEnumerable`1<string> ids, IEnumerable`1<string> returningColumnNames);
    protected virtual Collection`1<string> GetFeatureIdsCore();
    protected virtual Collection`1<Feature> GetAllFeaturesCore(IEnumerable`1<string> returningColumnNames, int startIndex, int takeCount);
    protected virtual Collection`1<Feature> GetAllFeaturesCore(IEnumerable`1<string> returningColumnNames);
    protected virtual Collection`1<Feature> GetFeaturesInsideBoundingBoxCore(RectangleShape boundingBox, IEnumerable`1<string> returningColumnNames);
    protected virtual TransactionResult CommitTransactionCore(TransactionBuffer transactions);
    private void ySE=(Collection`1<string> deleteColumns);
    private void yiE=(List`1<string> addedColumns);
    private void yyE=(Dictionary`2<string, FeatureSourceColumn> updateColumns);
    private void zCE=();
    private void zSE=(Dictionary`2<string, Feature> addBuffer, String[] columnNames, TransactionResult transactionResult);
    private void gh8=(Collection`1<string> deleteBuffer, TransactionResult transactionResult);
    private void ziE=(Dictionary`2<string, Feature> keyValue, String[] columnNames, TransactionResult transactionResult);
    private string zyE=(Feature feature, String[] columnNames);
    private Feature 0CE=(string id, eCE= csvDataRecord);
    private static Feature 0CE=(string id, eCE= csvDataRecord, DelimitedSpatialColumnsType spatialColumnType, string xColumnName, string yColumnName, string wellKnownTextColumnName);
    public static void BuildIndexFile(string delimitedPathFilename, string xColumnName, string yColumnName, string delimiter, BuildIndexMode buildIndexMode);
    public static void BuildIndexFile(string delimitedPathFilename, string wellKnownTextColumnName, string delimiter, BuildIndexMode buildIndexMode);
    public static void BuildIndexFile(string delimitedPathFilename, string xColumnName, string yColumnName, string delimiter, BuildIndexMode buildIndexMode, Encoding encoding);
    public static void BuildIndexFile(string delimitedPathFilename, string wellKnownTextColumnName, string delimiter, BuildIndexMode buildIndexMode, Encoding encoding);
    private static void 0SE=(string delimitedPathFilename, string xColumnName, string yColumnName, string wellKnownTextColumnName, string delimiter, DelimitedSpatialColumnsType spatialColumnType, BuildIndexMode buildIndexMode, Encoding encoding);
    public static void CreateDelimitedFile(string delimitedPathFilename, IEnumerable`1<string> columnNames, string delimiter, OverwriteMode overwriteMode);
    public static void CreateDelimitedFile(string delimitedPathFilename, IEnumerable`1<string> columnNames, string delimiter, OverwriteMode overwriteMode, Encoding encoding);
    protected static void OnBuildingIndex(BuildingIndexDelimitedFeatureSourceEventArgs e);
    private void 0iE=();
    private VSE= 0yE=();
    private static VSE= 0yE=(string delimitedPathFilename, string delimiter, Encoding encoding);
}
public enum ThinkGeo.Core.DelimitedSpatialColumnsType : Enum {
    public int value__;
    public static DelimitedSpatialColumnsType XAndY;
    public static DelimitedSpatialColumnsType WellKnownText;
}
public enum ThinkGeo.Core.DistanceCalculationMode : Enum {
    public int value__;
    public static DistanceCalculationMode Default;
    public static DistanceCalculationMode LocalizedUtmZone;
    public static DistanceCalculationMode Haversine;
}
public enum ThinkGeo.Core.DistanceUnit : Enum {
    public int value__;
    public static DistanceUnit Meter;
    public static DistanceUnit Feet;
    public static DistanceUnit Kilometer;
    public static DistanceUnit Mile;
    public static DistanceUnit UsSurveyFeet;
    public static DistanceUnit Yard;
    public static DistanceUnit NauticalMile;
    public static DistanceUnit Inch;
    public static DistanceUnit Link;
    public static DistanceUnit Chain;
    public static DistanceUnit Pole;
    public static DistanceUnit Rod;
    public static DistanceUnit Furlong;
    public static DistanceUnit Vara;
    public static DistanceUnit Arpent;
}
public class ThinkGeo.Core.DistinctColumnValue : object {
    [ObfuscationAttribute]
private string columnValue;
    [ObfuscationAttribute]
private int columnValueCount;
    public string ColumnValue { get; public set; }
    public int ColumnValueCount { get; public set; }
    public DistinctColumnValue(string columnValue, int columnValueCount);
    public string get_ColumnValue();
    public void set_ColumnValue(string value);
    public int get_ColumnValueCount();
    public void set_ColumnValueCount(int value);
}
public class ThinkGeo.Core.DotDensityStyle : Style {
    private static int TSo=;
    private static int vTE=;
    [ObfuscationAttribute]
private string columnName;
    [ObfuscationAttribute]
private PointStyle customPointStyle;
    [ObfuscationAttribute]
private PointStyle defaultPointStyle;
    private Dictionary`2<string, Collection`1<Vertex>> vjE=;
    [ObfuscationAttribute]
private double pointToValueRatio;
    public PointStyle CustomPointStyle { get; public set; }
    public string ColumnName { get; public set; }
    public int PointSize { get; public set; }
    public GeoColor PointColor { get; public set; }
    public double PointToValueRatio { get; public set; }
    public Dictionary`2<string, Collection`1<Vertex>> CachedPoints { get; }
    public DotDensityStyle(string columnName, double pointToValueRatio, int pointSize, GeoColor pointColor);
    public DotDensityStyle(string columnName, double pointToValueRatio, PointStyle customPointStyle);
    private DotDensityStyle(string columnName, double pointToValueRatio, int pointSize, GeoColor pointColor, PointStyle customPointStyle);
    public PointStyle get_CustomPointStyle();
    public void set_CustomPointStyle(PointStyle value);
    public string get_ColumnName();
    public void set_ColumnName(string value);
    public int get_PointSize();
    public void set_PointSize(int value);
    public GeoColor get_PointColor();
    public void set_PointColor(GeoColor value);
    public double get_PointToValueRatio();
    public void set_PointToValueRatio(double value);
    public Dictionary`2<string, Collection`1<Vertex>> get_CachedPoints();
    protected virtual Collection`1<string> GetRequiredColumnNamesCore();
    protected virtual void DrawCore(IEnumerable`1<Feature> features, GeoCanvas canvas, Collection`1<SimpleCandidate> labelsInThisLayer, Collection`1<SimpleCandidate> labelsInAllLayers);
    private void LzE=(double worldX, double worldY, GeoCanvas canvas, Dictionary`2<string, string> columnValues, Collection`1<SimpleCandidate> labelsInThisLayer, Collection`1<SimpleCandidate> labelsInAllLayers);
    private static Collection`1<Vertex> vzE=(Feature feature, GeoCanvas canvas, int count);
    private static double wDE=(double min, double max, double initValue, Random random);
    private static void wTE=(PolygonShape polygon, GeoCanvas canvas, Collection`1<Vertex> resultDots, int count);
    private static PolygonShape wjE=(PolygonShape polygon, GeoCanvas canvas);
    private static void hB0=(Byte[] sourceArray, Byte[] destinateArray, long destinateIndex);
    private static bool lzE=(PolygonShape polygon, double pointX, double pointY, RectangleShape boundingBox);
    private static void mDE=(Collection`1<Vertex> crossingPoints, RingShape ringShape, double pointX, double pointY, double secondLineEndPointX);
    private static Vertex mTE=(Vertex startPoint, Vertex endPoint, double secondLineStartX, double secondLineStartY, double secondLineEndPointX);
    private static bool mjE=(Collection`1<Vertex> crossingPoints, Vertex vertex);
    private static bool KTE=(double value, double start, double end);
    private static bool mzE=(Vertex vertex);
}
public class ThinkGeo.Core.DrawingAdornmentLayerEventArgs : EventArgs {
    [ObfuscationAttribute]
private AdornmentLayer adornmentLayer;
    public AdornmentLayer AdornmentLayer { get; public set; }
    public DrawingAdornmentLayerEventArgs(AdornmentLayer adornmentLayer);
    public AdornmentLayer get_AdornmentLayer();
    public void set_AdornmentLayer(AdornmentLayer value);
}
public class ThinkGeo.Core.DrawingAdornmentLayersEventArgs : EventArgs {
    [ObfuscationAttribute]
private IEnumerable`1<AdornmentLayer> adornmentLayers;
    public IEnumerable`1<AdornmentLayer> AdornmentLayers { get; public set; }
    public DrawingAdornmentLayersEventArgs(IEnumerable`1<AdornmentLayer> adornmentLayers);
    public IEnumerable`1<AdornmentLayer> get_AdornmentLayers();
    public void set_AdornmentLayers(IEnumerable`1<AdornmentLayer> value);
}
[ObsoleteAttribute("Layer.Attribution (as well as Drawing Attribution) is deprecate and will be removed after v14.2. You can accomplish the similar feature by overriding layer.DrawCore/Layer.DrawAsyncCore method")]
public class ThinkGeo.Core.DrawingAttributionLayerEventArgs : EventArgs {
    [ObfuscationAttribute]
private string attribution;
    [ObfuscationAttribute]
private GeoCanvas geoCanvas;
    [ObfuscationAttribute]
private bool cancel;
    public bool Cancel { get; public set; }
    public GeoCanvas GeoCanvas { get; public set; }
    public string Attribution { get; public set; }
    public DrawingAttributionLayerEventArgs(GeoCanvas canvas, string attribution);
    public bool get_Cancel();
    public void set_Cancel(bool value);
    public GeoCanvas get_GeoCanvas();
    public void set_GeoCanvas(GeoCanvas value);
    public string get_Attribution();
    public void set_Attribution(string value);
}
public class ThinkGeo.Core.DrawingClusteredFeatureClusterPointStyleEventArgs : EventArgs {
    [ObfuscationAttribute]
private bool cancel;
    [ObfuscationAttribute]
private Feature clusteredFeature;
    [ObfuscationAttribute]
private Collection`1<Feature> clusteringFeatures;
    [ObfuscationAttribute]
private Collection`1<Style> styles;
    public bool Cancel { get; public set; }
    public Feature ClusteredFeature { get; public set; }
    public Collection`1<Feature> ClusteringFeatures { get; }
    public Collection`1<Style> Styles { get; }
    public DrawingClusteredFeatureClusterPointStyleEventArgs(Feature clusteredFeature, IEnumerable`1<Feature> clusteringFeatures, IEnumerable`1<Style> styles);
    public bool get_Cancel();
    public void set_Cancel(bool value);
    public Feature get_ClusteredFeature();
    public void set_ClusteredFeature(Feature value);
    public Collection`1<Feature> get_ClusteringFeatures();
    public Collection`1<Style> get_Styles();
}
public class ThinkGeo.Core.DrawingDirectionPointEventArgs : EventArgs {
    private Feature BzE=;
    private PointShape CDE=;
    private float CTE=;
    private float CjE=;
    private bool CzE=;
    public PointShape DirectionPoint { get; public set; }
    public Feature LineFeature { get; }
    public float SymbolSize { get; public set; }
    public float RotationAngle { get; public set; }
    public bool Cancel { get; public set; }
    public DrawingDirectionPointEventArgs(Feature lineFeature, PointShape directionPoint, float symbolSize, float rotationAngle);
    public PointShape get_DirectionPoint();
    public void set_DirectionPoint(PointShape value);
    public Feature get_LineFeature();
    public float get_SymbolSize();
    public void set_SymbolSize(float value);
    public float get_RotationAngle();
    public void set_RotationAngle(float value);
    public bool get_Cancel();
    public void set_Cancel(bool value);
}
public class ThinkGeo.Core.DrawingExceptionLayerEventArgs : EventArgs {
    [ObfuscationAttribute]
private Exception exception;
    [ObfuscationAttribute]
private GeoCanvas canvas;
    [ObfuscationAttribute]
private bool cancel;
    public Exception Exception { get; public set; }
    public GeoCanvas Canvas { get; public set; }
    public bool Cancel { get; public set; }
    public DrawingExceptionLayerEventArgs(GeoCanvas canvas, Exception exception, bool cancel);
    public Exception get_Exception();
    public void set_Exception(Exception value);
    public GeoCanvas get_Canvas();
    public void set_Canvas(GeoCanvas value);
    public bool get_Cancel();
    public void set_Cancel(bool value);
}
public enum ThinkGeo.Core.DrawingExceptionMode : Enum {
    public int value__;
    public static DrawingExceptionMode Default;
    public static DrawingExceptionMode ThrowException;
    public static DrawingExceptionMode DrawException;
}
public class ThinkGeo.Core.DrawingFeaturesEventArgs : EventArgs {
    [ObfuscationAttribute]
private Collection`1<Feature> featuresToDraw;
    [ObfuscationAttribute]
private ZoomLevel drawingZoomLevel;
    [ObfuscationAttribute]
private bool cancel;
    public Collection`1<Feature> FeaturesToDraw { get; }
    public ZoomLevel DrawingZoomLevel { get; public set; }
    public bool Cancel { get; public set; }
    public DrawingFeaturesEventArgs(IEnumerable`1<Feature> featuresToDraw);
    public DrawingFeaturesEventArgs(IEnumerable`1<Feature> featuresToDraw, ZoomLevel drawingZoomLevel);
    public Collection`1<Feature> get_FeaturesToDraw();
    public ZoomLevel get_DrawingZoomLevel();
    public void set_DrawingZoomLevel(ZoomLevel value);
    public bool get_Cancel();
    public void set_Cancel(bool value);
}
[FlagsAttribute]
public enum ThinkGeo.Core.DrawingFontStyles : Enum {
    public int value__;
    public static DrawingFontStyles Regular;
    public static DrawingFontStyles Bold;
    public static DrawingFontStyles Italic;
    public static DrawingFontStyles Underline;
    public static DrawingFontStyles Strikeout;
    public static DrawingFontStyles Black;
}
public enum ThinkGeo.Core.DrawingGraphicsUnit : Enum {
    public int value__;
    public static DrawingGraphicsUnit World;
    public static DrawingGraphicsUnit Display;
    public static DrawingGraphicsUnit Pixel;
    public static DrawingGraphicsUnit Point;
    public static DrawingGraphicsUnit Inch;
    public static DrawingGraphicsUnit Document;
    public static DrawingGraphicsUnit Millimeter;
}
public enum ThinkGeo.Core.DrawingLevel : Enum {
    public int value__;
    public static DrawingLevel LevelOne;
    public static DrawingLevel LevelTwo;
    public static DrawingLevel LevelThree;
    public static DrawingLevel LevelFour;
    public static DrawingLevel LabelLevel;
}
public enum ThinkGeo.Core.DrawingLineCap : Enum {
    public int value__;
    public static DrawingLineCap Round;
    public static DrawingLineCap AnchorMask;
    public static DrawingLineCap ArrowAnchor;
    public static DrawingLineCap Custom;
    public static DrawingLineCap DiamondAnchor;
    public static DrawingLineCap Flat;
    public static DrawingLineCap NoAnchor;
    public static DrawingLineCap RoundAnchor;
    public static DrawingLineCap Square;
    public static DrawingLineCap SquareAnchor;
    public static DrawingLineCap Triangle;
    public static DrawingLineCap Butt;
}
public enum ThinkGeo.Core.DrawingLineJoin : Enum {
    public int value__;
    public static DrawingLineJoin Bevel;
    public static DrawingLineJoin Miter;
    public static DrawingLineJoin MiterClipped;
    public static DrawingLineJoin Round;
}
public class ThinkGeo.Core.DrawingMargin : ValueType {
    [CompilerGeneratedAttribute]
private int DDE=;
    [CompilerGeneratedAttribute]
private int DTE=;
    [CompilerGeneratedAttribute]
private int DjE=;
    [CompilerGeneratedAttribute]
private int DzE=;
    public int Top { get; public set; }
    public int Right { get; public set; }
    public int Down { get; public set; }
    public int Left { get; public set; }
    public DrawingMargin(int top, int right, int down, int left);
    [yhM=]
[CompilerGeneratedAttribute]
public int get_Top();
    [CompilerGeneratedAttribute]
public void set_Top(int value);
    [yhM=]
[CompilerGeneratedAttribute]
public int get_Right();
    [CompilerGeneratedAttribute]
public void set_Right(int value);
    [CompilerGeneratedAttribute]
[yhM=]
public int get_Down();
    [CompilerGeneratedAttribute]
public void set_Down(int value);
    [CompilerGeneratedAttribute]
[yhM=]
public int get_Left();
    [CompilerGeneratedAttribute]
public void set_Left(int value);
}
public enum ThinkGeo.Core.DrawingPenAlignment : Enum {
    public int value__;
    public static DrawingPenAlignment Center;
    public static DrawingPenAlignment Inset;
    public static DrawingPenAlignment Left;
    public static DrawingPenAlignment Outset;
    public static DrawingPenAlignment Right;
}
public class ThinkGeo.Core.DrawingProgressChangedEventArgs : ProgressChangedEventArgs {
    [ObfuscationAttribute]
private bool cancel;
    [ObfuscationAttribute]
private int featuresToDraw;
    [ObfuscationAttribute]
private int featuresDrawn;
    public bool Cancel { get; public set; }
    public int FeaturesToDraw { get; }
    public int FeaturesDrawn { get; }
    public DrawingProgressChangedEventArgs(int progressPercentage, object userState);
    public DrawingProgressChangedEventArgs(int progressPercentage, object userState, int featuresToDraw, int featuresDrawn);
    public bool get_Cancel();
    public void set_Cancel(bool value);
    public int get_FeaturesToDraw();
    public int get_FeaturesDrawn();
}
public enum ThinkGeo.Core.DrawingQuality : Enum {
    public int value__;
    public static DrawingQuality Default;
    public static DrawingQuality HighQuality;
    public static DrawingQuality HighSpeed;
    public static DrawingQuality Medium;
}
public class ThinkGeo.Core.DrawingRectangle : ValueType {
    [ObfuscationAttribute]
private int centerX;
    [ObfuscationAttribute]
private int centerY;
    [ObfuscationAttribute]
private int width;
    [ObfuscationAttribute]
private int height;
    public int CenterX { get; }
    public int CenterY { get; }
    public int Width { get; }
    public int Height { get; }
    public int MinimumX { get; }
    public int MinimumY { get; }
    public int MaximumX { get; }
    public int MaximumY { get; }
    public DrawingRectangle(int centerX, int centerY, int width, int height);
    public DrawingRectangle(int anchorPointX, int anchorPointY, int width, int height, DrawingRectangleAnchorReference anchorReference);
    public int get_CenterX();
    public int get_CenterY();
    public int get_Width();
    public int get_Height();
    public int get_MinimumX();
    public int get_MinimumY();
    public int get_MaximumX();
    public int get_MaximumY();
    public static bool op_Equality(DrawingRectangle rectangleF1, DrawingRectangle rectangleF2);
    public static bool op_Inequality(DrawingRectangle rectangleF1, DrawingRectangle rectangleF2);
    public virtual bool Equals(object obj);
    private bool lhU=(DrawingRectangle obj);
    public virtual int GetHashCode();
}
public enum ThinkGeo.Core.DrawingRectangleAnchorReference : Enum {
    public int value__;
    public static DrawingRectangleAnchorReference Center;
    public static DrawingRectangleAnchorReference UpperLeft;
    public static DrawingRectangleAnchorReference UpperRight;
    public static DrawingRectangleAnchorReference LowerLeft;
    public static DrawingRectangleAnchorReference LowerRight;
}
public class ThinkGeo.Core.DrawingRectangleF : ValueType {
    [ObfuscationAttribute]
private float centerX;
    [ObfuscationAttribute]
private float centerY;
    [ObfuscationAttribute]
private float width;
    [ObfuscationAttribute]
private float height;
    public float CenterX { get; }
    public float CenterY { get; }
    public float Width { get; }
    public float Height { get; }
    public float MinimumX { get; }
    public float MinimumY { get; }
    public float MaximumX { get; }
    public float MaximumY { get; }
    public DrawingRectangleF(float centerX, float centerY, float width, float height);
    public DrawingRectangleF(float anchorPointX, float anchorPointY, float width, float height, DrawingRectangleAnchorReference anchorReference);
    public float get_CenterX();
    public float get_CenterY();
    public float get_Width();
    public float get_Height();
    public float get_MinimumX();
    public float get_MinimumY();
    public float get_MaximumX();
    public float get_MaximumY();
    public static bool op_Equality(DrawingRectangleF rectangleF1, DrawingRectangleF rectangleF2);
    public static bool op_Inequality(DrawingRectangleF rectangleF1, DrawingRectangleF rectangleF2);
    public virtual bool Equals(object obj);
    private bool lhU=(DrawingRectangleF obj);
    public virtual int GetHashCode();
}
public enum ThinkGeo.Core.DrawingTextAlignment : Enum {
    public int value__;
    public static DrawingTextAlignment Default;
    public static DrawingTextAlignment Left;
    public static DrawingTextAlignment Center;
    public static DrawingTextAlignment Right;
}
internal enum ThinkGeo.Core.DrawingTextBaseline : Enum {
    public int value__;
    public static DrawingTextBaseline Middle;
    public static DrawingTextBaseline Alphabetic;
    public static DrawingTextBaseline Top;
    public static DrawingTextBaseline Bottom;
    public static DrawingTextBaseline Hanging;
}
public enum ThinkGeo.Core.DrawingTextLetterCase : Enum {
    public int value__;
    public static DrawingTextLetterCase Default;
    public static DrawingTextLetterCase Uppercase;
    public static DrawingTextLetterCase Lowercase;
}
public class ThinkGeo.Core.DrawingWrappingFeaturesFeatureLayerEventArgs : EventArgs {
    [ObfuscationAttribute]
private Collection`1<Feature> featuresToDraw;
    public Collection`1<Feature> FeaturesToDraw { get; }
    public DrawingWrappingFeaturesFeatureLayerEventArgs(Collection`1<Feature> featuresToDraw);
    public Collection`1<Feature> get_FeaturesToDraw();
}
public class ThinkGeo.Core.DrawnAdornmentLayerEventArgs : EventArgs {
    [ObfuscationAttribute]
private AdornmentLayer adornmentLayer;
    public AdornmentLayer AdornmentLayer { get; public set; }
    public DrawnAdornmentLayerEventArgs(AdornmentLayer adornmentLayer);
    public AdornmentLayer get_AdornmentLayer();
    public void set_AdornmentLayer(AdornmentLayer value);
}
public class ThinkGeo.Core.DrawnAdornmentLayersEventArgs : EventArgs {
    [ObfuscationAttribute]
private IEnumerable`1<AdornmentLayer> adornmentLayers;
    public IEnumerable`1<AdornmentLayer> AdornmentLayers { get; public set; }
    public DrawnAdornmentLayersEventArgs(IEnumerable`1<AdornmentLayer> adornmentLayers);
    public IEnumerable`1<AdornmentLayer> get_AdornmentLayers();
    public void set_AdornmentLayers(IEnumerable`1<AdornmentLayer> value);
}
[ObsoleteAttribute("Layer.Attribution (as well as Drawing Attribution) is deprecate and will be removed after v14.2. You can accomplish the similar feature by overriding layer.DrawCore/Layer.DrawAsyncCore method")]
public class ThinkGeo.Core.DrawnAttributionLayerEventArgs : EventArgs {
    [ObfuscationAttribute]
private GeoCanvas geoCanvas;
    [ObfuscationAttribute]
private string attribution;
    public GeoCanvas GeoCanvas { get; public set; }
    [ObsoleteAttribute("Layer.Attribution (as well as Drawing Attribution) is deprecate and will be removed after v14.2. You can accomplish the similar feature by overriding layer.DrawCore/Layer.DrawAsyncCore method")]
public string Attribution { get; public set; }
    public DrawnAttributionLayerEventArgs(GeoCanvas canvas, string attribution);
    public GeoCanvas get_GeoCanvas();
    public void set_GeoCanvas(GeoCanvas value);
    public string get_Attribution();
    public void set_Attribution(string value);
}
public class ThinkGeo.Core.DrawnExceptionLayerEventArgs : EventArgs {
    [ObfuscationAttribute]
private Exception exception;
    [ObfuscationAttribute]
private GeoCanvas canvas;
    public Exception Exception { get; public set; }
    public GeoCanvas Canvas { get; public set; }
    public DrawnExceptionLayerEventArgs(GeoCanvas canvas, Exception exception);
    public Exception get_Exception();
    public void set_Exception(Exception value);
    public GeoCanvas get_Canvas();
    public void set_Canvas(GeoCanvas value);
}
public class ThinkGeo.Core.DynamicIsoLineLayer : IsoLineLayer {
    [ObfuscationAttribute]
private Dictionary`2<PointShape, double> dataPoints;
    [ObfuscationAttribute]
private GridInterpolationModel dynamicGridInterpolationModel;
    [ObfuscationAttribute]
private double noDataValue;
    [ObfuscationAttribute]
private int cellWidthInPixel;
    [ObfuscationAttribute]
private int cellHeightInPixel;
    public Dictionary`2<PointShape, double> DataPoints { get; }
    public double NoDataValue { get; public set; }
    public int CellWidthInPixel { get; public set; }
    public int CellHeightInPixel { get; public set; }
    public GridInterpolationModel DynamicGridInterpolationModel { get; public set; }
    public DynamicIsoLineLayer(IDictionary`2<PointShape, double> dataPoints);
    public DynamicIsoLineLayer(IDictionary`2<PointShape, double> dataPoints, IEnumerable`1<double> isoLineLevels);
    public DynamicIsoLineLayer(IDictionary`2<PointShape, double> dataPoints, IEnumerable`1<double> isoLineLevels, GridInterpolationModel gridInterpolationModel);
    public DynamicIsoLineLayer(IDictionary`2<PointShape, double> dataPoints, IEnumerable`1<double> isoLineLevels, GridInterpolationModel gridInterpolationModel, IsoLineType isoLineType);
    private DynamicIsoLineLayer(IDictionary`2<PointShape, double> dataPoints, IEnumerable`1<double> isoLineLevels, GridInterpolationModel gridInterpolationModel, double lowerScale, double upperScale, IsoLineType isoLineType);
    public Dictionary`2<PointShape, double> get_DataPoints();
    public double get_NoDataValue();
    public void set_NoDataValue(double value);
    public int get_CellWidthInPixel();
    public void set_CellWidthInPixel(int value);
    public int get_CellHeightInPixel();
    public void set_CellHeightInPixel(int value);
    public GridInterpolationModel get_DynamicGridInterpolationModel();
    public void set_DynamicGridInterpolationModel(GridInterpolationModel value);
    public Collection`1<Feature> GetIsoLineFeatures(RectangleShape worldExtent, double scale, GeographyUnit mapUnit);
    protected virtual Collection`1<Feature> GetFeaturesForDrawingCore(GeoCanvas canvas, Collection`1<SimpleCandidate> labelsInAllLayers);
    private static GridCell[0...,0...] siI=(GridDefinition gridDefinition, GridInterpolationModel dynamicGridInterpolationModel, double scale, float cellWithInDot, float cellHeightInDot, GeographyUnit mapUnit);
}
public class ThinkGeo.Core.EditEndedEditInteractiveOverlayEventArgs : EventArgs {
    private Feature qxQ=;
    public Feature EditedFeature { get; public set; }
    public EditEndedEditInteractiveOverlayEventArgs(Feature editedFeature);
    public Feature get_EditedFeature();
    public void set_EditedFeature(Feature value);
}
public class ThinkGeo.Core.EditTools : object {
    [ObfuscationAttribute]
private FeatureSource featureSource;
    public bool IsInTransaction { get; }
    public bool IsTransactionLive { get; public set; }
    public bool IsEditable { get; }
    public TransactionBuffer TransactionBuffer { get; public set; }
    public EditTools(FeatureSource featureSource);
    public bool get_IsInTransaction();
    public bool get_IsTransactionLive();
    public void set_IsTransactionLive(bool value);
    public bool get_IsEditable();
    public TransactionBuffer get_TransactionBuffer();
    public void set_TransactionBuffer(TransactionBuffer value);
    public void BeginTransaction();
    public string Add(BaseShape shape);
    public string Add(Feature feature);
    public string Add(BaseShape shape, Dictionary`2<string, string> columnValues);
    public void ScaleUp(string featureId, double percentage);
    public void ScaleDown(string featureId, double percentage);
    public void TranslateByDegree(string featureId, double distance, double angleInDegrees, GeographyUnit shapeUnit, DistanceUnit distanceUnit);
    public void TranslateByOffset(string featureId, double xOffset, double yOffset, GeographyUnit shapeUnit, DistanceUnit offsetUnit);
    public void Rotate(string featureId, PointShape pivotPoint, float degreeAngle);
    public void Union(string featureId, AreaBaseShape targetShape);
    public void Union(string featureId, Feature targetAreaFeature);
    public void GetDifference(string featureId, AreaBaseShape targetShape);
    public void GetDifference(string featureId, Feature targetAreaFeature);
    public void Delete(string id);
    public void Update(BaseShape shape);
    public void Update(Feature feature);
    public void Update(BaseShape shape, Dictionary`2<string, string> columnValues);
    public void RollbackTransaction();
    public TransactionResult CommitTransaction();
}
public class ThinkGeo.Core.ElevationCloudClient : CloudClient {
    private static int zRQ=;
    public ElevationCloudClient(string clientId, string clientSecret);
    public double GetElevationOfPointInDecimalDegree(double latitude, double longitude, DistanceUnit elevationUnit);
    public double GetElevationOfPoint(double x, double y, int pointProjectionInSrid, DistanceUnit elevationUnit);
    public double GetElevationOfPoint(double x, double y, string pointProjectionInProj4String, DistanceUnit elevationUnit);
    [AsyncStateMachineAttribute("ThinkGeo.Core.ElevationCloudClient/NT4=")]
public Task`1<double> GetElevationOfPointInDecimalDegreeAsync(double latitude, double longitude, DistanceUnit elevationUnit);
    [AsyncStateMachineAttribute("ThinkGeo.Core.ElevationCloudClient/MT4=")]
public Task`1<double> GetElevationOfPointAsync(double x, double y, int pointProjectionInSrid, DistanceUnit elevationUnit);
    [AsyncStateMachineAttribute("ThinkGeo.Core.ElevationCloudClient/Mz4=")]
public Task`1<double> GetElevationOfPointAsync(double x, double y, string pointProjectionInProj4String, DistanceUnit elevationUnit);
    public CloudElevationResult GetElevationOfPointsInDecimalDegree(IEnumerable`1<PointShape> points, DistanceUnit elevationUnit);
    public CloudElevationResult GetElevationOfPoints(IEnumerable`1<PointShape> points, int pointsProjectionInSrid, DistanceUnit elevationUnit);
    public CloudElevationResult GetElevationOfPoints(IEnumerable`1<PointShape> points, string pointsProjectionInProj4String, DistanceUnit elevationUnit);
    [AsyncStateMachineAttribute("ThinkGeo.Core.ElevationCloudClient/Pj4=")]
public Task`1<CloudElevationResult> GetElevationOfPointsInDecimalDegreeAsync(IEnumerable`1<PointShape> points, DistanceUnit elevationUnit);
    [AsyncStateMachineAttribute("ThinkGeo.Core.ElevationCloudClient/OD4=")]
public Task`1<CloudElevationResult> GetElevationOfPointsAsync(IEnumerable`1<PointShape> points, int pointsProjectionInSrid, DistanceUnit elevationUnit);
    [AsyncStateMachineAttribute("ThinkGeo.Core.ElevationCloudClient/Oz4=")]
public Task`1<CloudElevationResult> GetElevationOfPointsAsync(IEnumerable`1<PointShape> points, string pointsProjectionInProj4String, DistanceUnit elevationUnit);
    public CloudElevationResult GetElevationOfLineInDecimalDegree(LineBaseShape line, int numberOfSegments, DistanceUnit elevationUnit);
    public CloudElevationResult GetElevationOfLine(LineBaseShape line, int lineProjectionInSrid, int numberOfSegments, DistanceUnit elevationUnit);
    public CloudElevationResult GetElevationOfLine(LineBaseShape line, string lineProjectionInProj4String, int numberOfSegments, DistanceUnit elevationUnit);
    public CloudElevationResult GetElevationOfLineInDecimalDegree(LineBaseShape line, double intervalDistance, DistanceUnit intervalDistanceUnit, DistanceUnit elevationUnit);
    public CloudElevationResult GetElevationOfLine(LineBaseShape line, int lineProjectionInSrid, double intervalDistance, DistanceUnit intervalDistanceUnit, DistanceUnit elevationUnit);
    public CloudElevationResult GetElevationOfLine(LineBaseShape line, string lineProjectionInProj4String, double intervalDistance, DistanceUnit intervalDistanceUnit, DistanceUnit elevationUnit);
    [AsyncStateMachineAttribute("ThinkGeo.Core.ElevationCloudClient/Lj4=")]
public Task`1<CloudElevationResult> GetElevationOfLineInDecimalDegreeAsync(LineBaseShape line, int numberOfSegments, DistanceUnit elevationUnit);
    [AsyncStateMachineAttribute("ThinkGeo.Core.ElevationCloudClient/JT4=")]
public Task`1<CloudElevationResult> GetElevationOfLineAsync(LineBaseShape line, int lineProjectionInSrid, int numberOfSegments, DistanceUnit elevationUnit);
    [AsyncStateMachineAttribute("ThinkGeo.Core.ElevationCloudClient/KT4=")]
public Task`1<CloudElevationResult> GetElevationOfLineAsync(LineBaseShape line, string lineProjectionInProj4String, int numberOfSegments, DistanceUnit elevationUnit);
    [AsyncStateMachineAttribute("ThinkGeo.Core.ElevationCloudClient/Lz4=")]
public Task`1<CloudElevationResult> GetElevationOfLineInDecimalDegreeAsync(LineBaseShape line, double intervalDistance, DistanceUnit intervalDistanceUnit, DistanceUnit elevationUnit);
    [AsyncStateMachineAttribute("ThinkGeo.Core.ElevationCloudClient/Kz4=")]
public Task`1<CloudElevationResult> GetElevationOfLineAsync(LineBaseShape line, int lineProjectionInSrid, double intervalDistance, DistanceUnit intervalDistanceUnit, DistanceUnit elevationUnit);
    [AsyncStateMachineAttribute("ThinkGeo.Core.ElevationCloudClient/LD4=")]
public Task`1<CloudElevationResult> GetElevationOfLineAsync(LineBaseShape line, string lineProjectionInProj4String, double intervalDistance, DistanceUnit intervalDistanceUnit, DistanceUnit elevationUnit);
    public CloudGradeResult GetGradeOfLineInDecimalDegree(LineShape line, int numberOfSegments, DistanceUnit elevationUnit);
    public CloudGradeResult GetGradeOfLine(LineShape line, int lineProjectionInSrid, int numberOfSegments, DistanceUnit elevationUnit);
    public CloudGradeResult GetGradeOfLine(LineShape line, string lineProjectionInProj4String, int numberOfSegments, DistanceUnit elevationUnit);
    public CloudGradeResult GetGradeOfLineInDecimalDegree(LineShape line, double intervalDistance, DistanceUnit intervalDistanceUnit, DistanceUnit elevationUnit);
    public CloudGradeResult GetGradeOfLine(LineShape line, int lineProjectionInSrid, double intervalDistance, DistanceUnit intervalDistanceUnit, DistanceUnit elevationUnit);
    public CloudGradeResult GetGradeOfLine(LineShape line, string lineProjectionInProj4String, double intervalDistance, DistanceUnit intervalDistanceUnit, DistanceUnit elevationUnit);
    [AsyncStateMachineAttribute("ThinkGeo.Core.ElevationCloudClient/RD4=")]
public Task`1<CloudGradeResult> GetGradeOfLineInDecimalDegreeAsync(LineShape line, int numberOfSegments, DistanceUnit elevationUnit);
    [AsyncStateMachineAttribute("ThinkGeo.Core.ElevationCloudClient/Pz4=")]
public Task`1<CloudGradeResult> GetGradeOfLineAsync(LineShape line, int lineProjectionInSrid, double intervalDistance, DistanceUnit intervalDistanceUnit, DistanceUnit elevationUnit);
    [AsyncStateMachineAttribute("ThinkGeo.Core.ElevationCloudClient/QD4=")]
public Task`1<CloudGradeResult> GetGradeOfLineAsync(LineShape line, string lineProjectionInProj4String, double intervalDistance, DistanceUnit intervalDistanceUnit, DistanceUnit elevationUnit);
    [AsyncStateMachineAttribute("ThinkGeo.Core.ElevationCloudClient/RT4=")]
public Task`1<CloudGradeResult> GetGradeOfLineInDecimalDegreeAsync(LineShape line, double intervalDistance, DistanceUnit intervalDistanceUnit, DistanceUnit elevationUnit);
    [AsyncStateMachineAttribute("ThinkGeo.Core.ElevationCloudClient/QT4=")]
public Task`1<CloudGradeResult> GetGradeOfLineAsync(LineShape line, int lineProjectionInSrid, int numberOfSegments, DistanceUnit elevationUnit);
    [AsyncStateMachineAttribute("ThinkGeo.Core.ElevationCloudClient/Qj4=")]
public Task`1<CloudGradeResult> GetGradeOfLineAsync(LineShape line, string lineProjectionInProj4String, int numberOfSegments, DistanceUnit elevationUnit);
    public CloudElevationResult GetElevationOfAreaInDecimalDegree(AreaBaseShape area, double intervalDistance, DistanceUnit intervalDistanceUnit, DistanceUnit elevationUnit);
    public CloudElevationResult GetElevationOfArea(AreaBaseShape area, int areaProjectionInSrid, double intervalDistance, DistanceUnit intervalDistanceUnit, DistanceUnit elevationUnit);
    public CloudElevationResult GetElevationOfArea(AreaBaseShape area, string areaProjectionInProj4String, double intervalDistance, DistanceUnit intervalDistanceUnit, DistanceUnit elevationUnit);
    [AsyncStateMachineAttribute("ThinkGeo.Core.ElevationCloudClient/JD4=")]
public Task`1<CloudElevationResult> GetElevationOfAreaInDecimalDegreeAsync(AreaBaseShape area, double intervalDistance, DistanceUnit intervalDistanceUnit, DistanceUnit elevationUnit);
    [AsyncStateMachineAttribute("ThinkGeo.Core.ElevationCloudClient/Gj4=")]
public Task`1<CloudElevationResult> GetElevationOfAreaAsync(AreaBaseShape area, int areaProjectionInSrid, double intervalDistance, DistanceUnit intervalDistanceUnit, DistanceUnit elevationUnit);
    [AsyncStateMachineAttribute("ThinkGeo.Core.ElevationCloudClient/Hz4=")]
public Task`1<CloudElevationResult> GetElevationOfAreaAsync(AreaBaseShape area, string areaProjectionInProj4String, double intervalDistance, DistanceUnit intervalDistanceUnit, DistanceUnit elevationUnit);
    private double zhQ=(double x, double y, Nullable`1<int> projectionInSrid, string projectionInProj4String, DistanceUnit elevationUnit);
    [AsyncStateMachineAttribute("ThinkGeo.Core.ElevationCloudClient/MD4=")]
private Task`1<double> zxQ=(double x, double y, Nullable`1<int> projectionInSrid, string projectionInProj4String, DistanceUnit elevationUnit);
    private CloudElevationResult 0BQ=(IEnumerable`1<PointShape> points, Nullable`1<int> projectionInSrid, string projectionInProj4String, DistanceUnit elevationUnit);
    [AsyncStateMachineAttribute("ThinkGeo.Core.ElevationCloudClient/PT4=")]
private Task`1<CloudElevationResult> 0RQ=(IEnumerable`1<PointShape> points, Nullable`1<int> projectionInSrid, string projectionInProj4String, DistanceUnit elevationUnit);
    private CloudElevationResult 0hQ=(LineBaseShape line, Nullable`1<int> projectionInSrid, string projectionInProj4String, Nullable`1<int> numberOfSegments, Nullable`1<double> intervalDistance, Nullable`1<DistanceUnit> intervalDistanceUnit, DistanceUnit elevationUnit);
    [AsyncStateMachineAttribute("ThinkGeo.Core.ElevationCloudClient/LT4=")]
private Task`1<CloudElevationResult> 0xQ=(LineBaseShape line, Nullable`1<int> projectionInSrid, string projectionInProj4String, Nullable`1<int> numberOfSegments, Nullable`1<double> intervalDistance, Nullable`1<DistanceUnit> intervalDistanceUnit, DistanceUnit elevationUnit);
    private CloudGradeResult 1BQ=(LineShape line, Nullable`1<int> projectionInSrid, string projectionInProj4String, Nullable`1<int> numberOfSegments, Nullable`1<double> intervalDistance, Nullable`1<DistanceUnit> intervalDistanceUnit, DistanceUnit elevationUnit);
    [AsyncStateMachineAttribute("ThinkGeo.Core.ElevationCloudClient/Qz4=")]
private Task`1<CloudGradeResult> 1RQ=(LineShape line, Nullable`1<int> projectionInSrid, string projectionInProj4String, Nullable`1<int> numberOfSegments, Nullable`1<double> intervalDistance, Nullable`1<DistanceUnit> intervalDistanceUnit, DistanceUnit elevationUnit);
    private CloudElevationResult 1hQ=(AreaBaseShape area, Nullable`1<int> projectionInSrid, string projectionInProj4String, double intervalDistance, DistanceUnit intervalDistanceUnit, DistanceUnit elevationUnit);
    [AsyncStateMachineAttribute("ThinkGeo.Core.ElevationCloudClient/IT4=")]
private Task`1<CloudElevationResult> 1xQ=(AreaBaseShape area, Nullable`1<int> projectionInSrid, string projectionInProj4String, double intervalDistance, DistanceUnit intervalDistanceUnit, DistanceUnit elevationUnit);
    private static double 2BQ=(WebResponse response);
    private static CloudElevationResult 2RQ=(WebResponse response);
    private static CloudElevationResult 2hQ=(WebResponse response, IEnumerable`1<PointShape> queryPoints);
    private static CloudGradeResult 2xQ=(WebResponse response);
    private static string 3BQ=(string wkt, Nullable`1<int> projectionInSrid, string projectionInProj4String, Nullable`1<int> numberOfSegments, Nullable`1<double> intervalDistance, Nullable`1<DistanceUnit> intervalDistanceUnit, DistanceUnit elevationUnit);
}
[TypeConverterAttribute("ThinkGeo.Core.BaseShapeTypeConverter")]
public class ThinkGeo.Core.EllipseShape : AreaBaseShape {
    private static int Khw=;
    [ObfuscationAttribute]
private PointShape center;
    [ObfuscationAttribute]
private double width;
    [ObfuscationAttribute]
private double height;
    public double Width { get; }
    public double Height { get; }
    public PointShape Center { get; public set; }
    public EllipseShape(PointShape center, double radius);
    public EllipseShape(Feature centerPointFeature, double radius);
    public EllipseShape(PointShape center, double horizontalRadius, double verticalRadius);
    public EllipseShape(Feature centerPointFeature, double horizontalRadius, double verticalRadius);
    public EllipseShape(string wellKnownText);
    public EllipseShape(Byte[] wellKnownBinary);
    public EllipseShape(PointShape center, double radius, GeographyUnit shapeUnit, DistanceUnit unitOfRadius);
    public EllipseShape(Feature centerPointFeature, double radius, GeographyUnit shapeUnit, DistanceUnit unitOfRadius);
    public EllipseShape(PointShape center, double horizontalRadius, double verticalRadius, GeographyUnit shapeUnit, DistanceUnit unitOfRadius);
    public EllipseShape(Feature centerPointFeature, double horizontalRadius, double verticalRadius, GeographyUnit shapeUnit, DistanceUnit unitOfRadius);
    protected virtual BaseShape CloneDeepCore();
    protected virtual WellKnownType GetWellKnownTypeCore();
    public double get_Width();
    public void SetWidthByUnit(double newWidth, GeographyUnit shapeUnit, DistanceUnit unitOfWidth);
    public double GetWidthByUnit(GeographyUnit shapeUnit, DistanceUnit returningUnit);
    public double get_Height();
    public void SetHeightByUnit(double newHeight, GeographyUnit shapeUnit, DistanceUnit unitOfHeight);
    public double GetHeightByUnit(GeographyUnit shapeUnit, DistanceUnit returningUnit);
    public PointShape get_Center();
    public void set_Center(PointShape value);
    public PolygonShape ToPolygon();
    public PolygonShape ToPolygon(int vertexCountInQuarter);
    public Collection`1<PointShape> GetTangents(EllipseShape targetEllipse);
    protected virtual double GetPerimeterCore(GeographyUnit shapeUnit, DistanceUnit returningUnit);
    protected virtual double GetAreaCore(GeographyUnit shapeUnit, AreaUnit returningUnit);
    protected virtual void ScaleUpCore(double percentage);
    protected virtual void ScaleDownCore(double percentage);
    protected virtual RectangleShape GetBoundingBoxCore();
    protected virtual BaseShape RegisterCore(PointShape fromPoint, PointShape toPoint, DistanceUnit fromUnit, GeographyUnit toUnit);
    protected virtual void TranslateByOffsetCore(double xOffsetDistance, double yOffsetDistance, GeographyUnit shapeUnit, DistanceUnit distanceUnit);
    protected virtual void TranslateByDegreeCore(double distance, double angleInDegrees, GeographyUnit shapeUnit, DistanceUnit distanceUnit);
    protected virtual void RotateCore(PointShape pivotPoint, double degreeAngle);
    protected virtual PointShape GetClosestPointToCore(BaseShape targetShape, GeographyUnit shapeUnit);
    protected virtual double GetDistanceToCore(BaseShape targetShape, GeographyUnit shapeUnit, DistanceUnit distanceUnit);
    protected string GetWellKnownTextCore(int vertexCountInQuarter);
    protected virtual string GetWellKnownTextCore(RingOrder outerRingOrder);
    protected string GetWellKnownTextCore(RingOrder outerRingOrder, int vertexCountInQuarter);
    protected Byte[] GetWellKnownBinaryCore(WkbByteOrder byteOrder, int vertexCountInQuarter);
    protected virtual Byte[] GetWellKnownBinaryCore(RingOrder outerRingOrder, WkbByteOrder byteOrder);
    protected Byte[] GetWellKnownBinaryCore(RingOrder outerRingOrder, WkbByteOrder byteOrder, int vertexCountInQuarter);
    protected virtual void LoadFromWellKnownDataCore(string wellKnownText);
    protected virtual void LoadFromWellKnownDataCore(Byte[] wellKnownBinary);
    protected virtual ShapeValidationResult ValidateCore(ShapeValidationMode validationMode);
    protected virtual bool ContainsCore(BaseShape targetShape);
    protected virtual bool IntersectsCore(BaseShape targetShape);
    protected virtual MultipointShape GetCrossingCore(BaseShape targetShape);
    private void Kxw=(PointShape center, double newWidth, double newHeight, GeographyUnit shapeUnit, DistanceUnit unitOfSize);
    private PolygonShape LBw=(int quaterVertexCount);
    private void TRU=(double factor);
    private void LRw=(PointShape targetPointShape, GeographyUnit shapeUnit, DistanceUnit distanceUnit, PointShape& closestPoint, Double& minDistance);
    private void Lhw=(MultipointShape targetMultiPoint, GeographyUnit shapeUnit, DistanceUnit distanceUnit, PointShape& closestPoint, Double& minDistance);
    private void Lxw=(LineShape lineShape, GeographyUnit shapeUnit, DistanceUnit distanceUnit, PointShape& closestPoint, Double& minDistance);
    private void MBw=(MultilineShape multiLineShape, GeographyUnit shapeUnit, DistanceUnit distanceUnit, PointShape& closestPoint, Double& minDistance);
    private void MRw=(PolygonShape polygonShape, GeographyUnit shapeUnit, DistanceUnit distanceUnit, PointShape& closestPoint, Double& minDistance);
    private PointShape Mhw=(MultipolygonShape multiPolygonShape, GeographyUnit shapeUnit, DistanceUnit distanceUnit, PointShape& closestPoint, Double& minDistance);
    private void Mxw=(EllipseShape ellipseShape, GeographyUnit shapeUnit, DistanceUnit distanceUnit, PointShape& closestPoint, Double& minDistance);
    private bool NBw=(MultipointShape multiPointShape);
    private bool NRw=(LineShape lineShape);
    private bool Nhw=(MultilineShape multiLineShape);
    private bool Nxw=(RingShape ringShape);
    private bool OBw=(RectangleShape rectangleShape);
    private bool ORw=(EllipseShape ellipseShape);
    private bool Ohw=(PolygonShape polygonShape);
    private bool Oxw=(MultipolygonShape multipolygonShape);
    private bool PBw=(PointShape pointShape);
    private bool PRw=(MultipointShape multiPointShape);
    private bool Phw=(LineShape lineShape);
    private bool Pxw=(MultilineShape multiLineShape);
    private bool QBw=(RingShape ringShape);
    private bool QRw=(RectangleShape rectangleShape);
    private bool Qhw=(EllipseShape ellipseShape);
    private bool Qxw=(PolygonShape polygonShape);
    private bool RBw=(MultipolygonShape multipolygonShape);
    private Collection`1<PointShape> RRw=(EllipseShape secondEllipse);
    private bool Rhw=(PointShape pointShape);
    private bool Rhw=(double pointX, double pointY);
    private static bool Rxw=(double p, double b, double c);
    internal PointShape SBw=(PointShape pointShape);
}
public class ThinkGeo.Core.EmpiricalFunctionCoefficients : object {
    [ObfuscationAttribute]
private double range;
    [ObfuscationAttribute]
private double nugget;
    [ObfuscationAttribute]
private double sill;
    public double Range { get; public set; }
    public double Nugget { get; public set; }
    public double Sill { get; public set; }
    public EmpiricalFunctionCoefficients(double range, double sill, double nugget);
    public double get_Range();
    public void set_Range(double value);
    public double get_Nugget();
    public void set_Nugget(double value);
    public double get_Sill();
    public void set_Sill(double value);
}
public class ThinkGeo.Core.EncryptedFileRasterTileCache : FileRasterTileCache {
    public EncryptedFileRasterTileCache(string cacheDirectory);
    public EncryptedFileRasterTileCache(string cacheDirectory, string cacheId);
    protected virtual void SaveTileCore(Tile tile);
    protected virtual Tile GetTileCore(int zoom, long column, long row);
    private string yx0=(int zoom, long column, long row);
}
internal class ThinkGeo.Core.EnumInfo : object {
    public bool IsFlags;
    public UInt64[] Values;
    public String[] Names;
    public String[] ResolvedNames;
    public EnumInfo(bool isFlags, UInt64[] values, String[] names, String[] resolvedNames);
}
internal static class ThinkGeo.Core.EnumUtils : object {
    private static char EnumSeparatorChar;
    private static ThreadSafeStore`2<Type, EnumInfo> ValuesAndNamesPerEnum;
    private static EnumUtils();
    private static EnumInfo InitializeValuesAndNames(Type key);
    public static bool TryToString(Type enumType, object value, bool camelCase, String& name);
    private static ulong ToUInt64(object value);
    public static object ParseEnum(Type enumType, string value, bool disallowNumber);
    private static Nullable`1<int> MatchName(string value, String[] enumNames, String[] resolvedNames, int valueIndex, int valueSubstringLength, StringComparison comparison);
    private static Nullable`1<int> FindIndexByName(String[] enumNames, string value, int valueIndex, int valueSubstringLength, StringComparison comparison);
}
[ObfuscationAttribute]
internal static class ThinkGeo.Core.EventHelper : object {
    private static hiE= exceptionHelper;
    private static EventHelper();
    [DebuggerHiddenAttribute]
public static void Raise(EventHandler handler, object sender);
    [DebuggerHiddenAttribute]
public static void Raise(EventHandler`1<T> handler, object sender, T e);
    [DebuggerHiddenAttribute]
public static void Raise(EventHandler`1<T> handler, object sender, Func`1<T> createEventArguments);
    [DebuggerHiddenAttribute]
public static void Raise(Delegate handler, object sender, EventArgs e);
    [DebuggerHiddenAttribute]
public static void BeginRaise(EventHandler handler, object sender, AsyncCallback callback, object asyncState);
    [DebuggerHiddenAttribute]
public static void BeginRaise(EventHandler`1<T> handler, object sender, T e, AsyncCallback callback, object asyncState);
    [DebuggerHiddenAttribute]
public static void BeginRaise(EventHandler`1<T> handler, object sender, Func`1<T> createEventArguments, AsyncCallback callback, object asyncState);
    [DebuggerHiddenAttribute]
public static void BeginRaise(Delegate handler, object sender, EventArgs e, AsyncCallback callback, object asyncState);
}
public class ThinkGeo.Core.ExecutingSqlStatementSqliteFeatureSourceEventArgs : EventArgs {
    [ObfuscationAttribute]
private string sqlStatement;
    [ObfuscationAttribute]
private ExecutingSqlStatementType excutingStatementType;
    [ObfuscationAttribute]
private RectangleShape featureQueryingExtent;
    public string SqlStatement { get; public set; }
    public ExecutingSqlStatementType ExcutingSqlStatementType { get; public set; }
    public RectangleShape FeatureQueryingExtent { get; }
    public ExecutingSqlStatementSqliteFeatureSourceEventArgs(string sqlStatement);
    public ExecutingSqlStatementSqliteFeatureSourceEventArgs(string sqlStatement, ExecutingSqlStatementType sqlStatementType, RectangleShape featureQueryingExtent);
    public string get_SqlStatement();
    public void set_SqlStatement(string value);
    public ExecutingSqlStatementType get_ExcutingSqlStatementType();
    public void set_ExcutingSqlStatementType(ExecutingSqlStatementType value);
    public RectangleShape get_FeatureQueryingExtent();
}
public enum ThinkGeo.Core.ExecutingSqlStatementType : Enum {
    public int value__;
    public static ExecutingSqlStatementType GetFeaturesByIds;
    public static ExecutingSqlStatementType GetFeaturesByColumnValue;
    public static ExecutingSqlStatementType GetFeaturesOutsideBoundingBox;
    public static ExecutingSqlStatementType GetSpatialDataType;
    public static ExecutingSqlStatementType GetBoundingBox;
    public static ExecutingSqlStatementType GetAllFeatures;
    public static ExecutingSqlStatementType GetCount;
    public static ExecutingSqlStatementType GetColumns;
    public static ExecutingSqlStatementType BuildIndex;
    public static ExecutingSqlStatementType ExecuteScalar;
    public static ExecutingSqlStatementType ExecuteQuery;
    public static ExecutingSqlStatementType ExecuteNonQuery;
    public static ExecutingSqlStatementType GetFirstGeometryType;
    public static ExecutingSqlStatementType MakeAllGeometriesValid;
    public static ExecutingSqlStatementType Validate;
    public static ExecutingSqlStatementType CommitTransactionEx;
    public static ExecutingSqlStatementType GetFeaturesInsideBoundingBoxEx;
    public static ExecutingSqlStatementType Unknown;
    public static ExecutingSqlStatementType ExecuteSpatialQuery;
    public static ExecutingSqlStatementType GetFeatureIds;
    public static ExecutingSqlStatementType InsertFeature;
}
public class ThinkGeo.Core.ExponentialKrigingGridInterpolationModel : KrigingGridInterpolationModel {
    public ExponentialKrigingGridInterpolationModel(IDictionary`2<PointShape, double> points);
    public ExponentialKrigingGridInterpolationModel(IDictionary`2<PointShape, double> dataPoints, int numberOfRefrencedPoints);
    protected virtual double GetSillSlopeCore(double distance, double range);
}
[ExtensionAttribute]
public static class ThinkGeo.Core.Extension : object {
    [ExtensionAttribute]
public static string GetGeoJson(IEnumerable`1<Feature> features);
}
public class ThinkGeo.Core.Feature : object {
    private static int /ho=;
    private static string /xo=;
    [ObfuscationAttribute]
private Byte[] wellKnownBinary;
    [ObfuscationAttribute]
private string id;
    [ObfuscationAttribute]
private object tag;
    [ObfuscationAttribute]
private Dictionary`2<string, string> columnValues;
    [ObfuscationAttribute]
private RectangleShape boundingBox;
    public string Id { get; public set; }
    public object Tag { get; public set; }
    public Dictionary`2<string, string> ColumnValues { get; }
    public Feature(BaseShape baseShape);
    public Feature(Byte[] wellKnownBinary);
    public Feature(Byte[] wellKnownBinary, string id);
    public Feature(string wellKnownText);
    public Feature(string wellKnownText, string id);
    public Feature(BaseShape baseShape, IDictionary`2<string, string> columnValues);
    public Feature(BaseShape baseShape, IEnumerable`1<string> columnValues);
    public Feature(string wellKnownText, string id, IDictionary`2<string, string> columnValues);
    public Feature(string wellKnownText, string id, IEnumerable`1<string> columnValues);
    public Feature(Byte[] wellKnownBinary, string id, IEnumerable`1<string> columnValues);
    private Feature(Byte[] wellKnownBinary, string id, IEnumerable`1<string> columnValues, object tag);
    public Feature(Byte[] wellKnownBinary, string id, IDictionary`2<string, string> columnValues);
    private Feature(Byte[] wellKnownBinary, string id, IDictionary`2<string, string> columnValues, object tag);
    public Feature(Vertex vertex);
    public Feature(Vertex vertex, string id);
    public Feature(Vertex vertex, string id, IEnumerable`1<string> columnValues);
    public Feature(Vertex vertex, string id, IDictionary`2<string, string> columnValues);
    public Feature(double x, double y);
    public Feature(double x, double y, string id);
    public Feature(double x, double y, string id, IEnumerable`1<string> columnValues);
    public Feature(double x, double y, string id, IDictionary`2<string, string> columnValues);
    public Byte[] GetWellKnownBinary();
    public Byte[] GetWellKnownBinary(WkbByteOrder byteOrder);
    public Byte[] GetWellKnownBinary(RingOrder outerRingOrder);
    public Byte[] GetWellKnownBinary(RingOrder outerRingOrder, WkbByteOrder byteOrder);
    protected virtual Byte[] GetWellKnownBinaryCore(RingOrder outerRingOrder, WkbByteOrder byteOrder);
    public string get_Id();
    public void set_Id(string value);
    public object get_Tag();
    public void set_Tag(object value);
    public Dictionary`2<string, string> get_ColumnValues();
    public virtual string ToString();
    public WellKnownType GetWellKnownType();
    protected virtual WellKnownType GetWellKnownTypeCore();
    public BaseShape GetShape();
    public string GetWellKnownText();
    public string GetWellKnownText(RingOrder outerRingOrder);
    protected virtual string GetWellKnownTextCore(RingOrder outerRingOrder);
    public string GetGeoJson();
    protected virtual string GetGeoJsonCore();
    public static Feature CreateFeatureFromGeoJson(string geoJson);
    public static Collection`1<Feature> CreateFeaturesFromGeoJson(string geoJson);
    public static Feature CreateFeatureFromWellKnownData(Byte[] wellKnownBinary);
    public static Feature CreateFeatureFromWellKnownData(string wellKnownText);
    public RectangleShape GetBoundingBox();
    protected virtual RectangleShape GetBoundingBoxCore();
    public Feature CloneDeep(IEnumerable`1<string> returningColumnNames);
    private Feature ABs=(IEnumerable`1<string> returningColumnNames);
    public Feature CloneDeep(ReturningColumnsType returningColumnNamesType);
    public Feature CloneDeep();
    public static Feature Union(IEnumerable`1<Feature> targetFeatures);
    private static Byte[] 0Ro=(IEnumerable`1<Feature> targetFeatures, int count);
    public Feature Union(Feature targetFeature);
    public Feature Buffer(double distance, GeographyUnit featureUnit, DistanceUnit distanceUnit);
    public Feature Buffer(double distance, int quadrantSegments, GeographyUnit featureUnit, DistanceUnit distanceUnit);
    public Feature Buffer(double distance, int quadrantSegments, BufferCapType bufferCapType, GeographyUnit featureUnit, DistanceUnit distanceUnit);
    private Byte[] 3ho=(double distance, int quadrantSegments, BufferCapType bufferCapType);
    private static EndCapStyle 3xo=(BufferCapType bufferCapStyle);
    public bool Contains(Feature targetFeature);
    public bool Crosses(Feature targetFeature);
    public bool IsWithin(Feature targetFeature);
    public bool Intersects(Feature targetFeature);
    public bool IsDisjointed(Feature targetFeature);
    public bool IsTopologicallyEqual(Feature targetFeature);
    public bool Overlaps(Feature targetFeature);
    public bool Touches(Feature targetFeature);
    public Feature GetIntersection(Feature targetFeature);
    public Feature GetDifference(Feature targetFeature);
    public Feature GetConvexHull();
    public void SetWellKnownBinary(Byte[] wellKnownBinary);
    public string GetInvalidReason();
    public bool IsGeometryValid();
    protected virtual BaseShape GetShapeCore();
}
public class ThinkGeo.Core.FeatureCache : object {
    private Quadtree`1<string> wh4=;
    [ObfuscationAttribute]
private Collection`1<RectangleShape> cachedExtents;
    [ObfuscationAttribute]
private Dictionary`2<string, Feature> cachedFeatures;
    [ObfuscationAttribute]
private bool isActive;
    public bool IsActive { get; public set; }
    public bool get_IsActive();
    public void set_IsActive(bool value);
    public Collection`1<Feature> GetFeatures(RectangleShape worldExtent);
    protected virtual Collection`1<Feature> GetFeaturesCore(RectangleShape worldExtent);
    public void Clear();
    public void Add(RectangleShape worldExtent, Collection`1<Feature> features);
    protected virtual void AddCore(RectangleShape worldExtent, Collection`1<Feature> features);
    public void Open();
    protected virtual void OpenCore();
    public void Close();
    protected virtual void CloseCore();
    public bool IsExtentCached(RectangleShape worldExtent);
    private static bool wx4=(RectangleShape extent, RectangleShape targetExtent);
}
public class ThinkGeo.Core.FeatureDraggedEditInteractiveOverlayEventArgs : EventArgs {
    [ObfuscationAttribute]
private Feature draggedFeature;
    public Feature DraggedFeature { get; public set; }
    public FeatureDraggedEditInteractiveOverlayEventArgs(Feature draggedFeature);
    public Feature get_DraggedFeature();
    public void set_DraggedFeature(Feature value);
}
public class ThinkGeo.Core.FeatureDraggingEditInteractiveOverlayEventArgs : EventArgs {
    [ObfuscationAttribute]
private Feature draggingFeature;
    [ObfuscationAttribute]
private PointShape sourceControlPoint;
    [ObfuscationAttribute]
private PointShape targetControlPoint;
    [ObfuscationAttribute]
private bool cancel;
    public Feature DraggingFeature { get; public set; }
    public PointShape SourceControlPoint { get; public set; }
    public PointShape TargetControlPoint { get; public set; }
    public bool Cancel { get; public set; }
    public FeatureDraggingEditInteractiveOverlayEventArgs(Feature draggingFeature, bool cancel, PointShape sourceControlPoint, PointShape targetControlPoint);
    public Feature get_DraggingFeature();
    public void set_DraggingFeature(Feature value);
    public PointShape get_SourceControlPoint();
    public void set_SourceControlPoint(PointShape value);
    public PointShape get_TargetControlPoint();
    public void set_TargetControlPoint(PointShape value);
    public bool get_Cancel();
    public void set_Cancel(bool value);
}
public class ThinkGeo.Core.FeatureDroppedEditInteractiveOverlayEventArgs : EventArgs {
    [ObfuscationAttribute]
private Feature droppedFeature;
    public Feature DroppedFeature { get; public set; }
    public FeatureDroppedEditInteractiveOverlayEventArgs(Feature droppedFeature);
    public Feature get_DroppedFeature();
    public void set_DroppedFeature(Feature value);
}
public class ThinkGeo.Core.FeatureEditedEditInteractiveOverlayEventArgs : EventArgs {
    [ObfuscationAttribute]
private Feature editedFeature;
    [ObfuscationAttribute]
private Feature lastEditedFeature;
    public Feature EditedFeature { get; public set; }
    public Feature LastEditedFeature { get; }
    public FeatureEditedEditInteractiveOverlayEventArgs(Feature lastEditedFeature, Feature editedFeature);
    public Feature get_EditedFeature();
    public void set_EditedFeature(Feature value);
    public Feature get_LastEditedFeature();
}
public class ThinkGeo.Core.FeatureEditingEditInteractiveOverlayEventArgs : EventArgs {
    [ObfuscationAttribute]
private Feature editingFeature;
    public Feature EditingFeature { get; public set; }
    public FeatureEditingEditInteractiveOverlayEventArgs(Feature editingFeature);
    public Feature get_EditingFeature();
    public void set_EditingFeature(Feature value);
}
public class ThinkGeo.Core.FeatureLabelingCandidate : object {
    [ObfuscationAttribute]
private Feature feature;
    [ObfuscationAttribute]
private Collection`1<LabelingCandidate> labelingCandidates;
    [ObfuscationAttribute]
private LabelingCandidate basePointLabelingCandidate;
    [ObfuscationAttribute]
private string key;
    [ObfuscationAttribute]
private PositionStyle positionStyle;
    public Feature Feature { get; public set; }
    public Collection`1<LabelingCandidate> LabelingCandidates { get; public set; }
    public LabelingCandidate BasePointLabelingCandidate { get; public set; }
    public string Key { get; public set; }
    public PositionStyle PositionStyle { get; public set; }
    public Feature get_Feature();
    public void set_Feature(Feature value);
    public Collection`1<LabelingCandidate> get_LabelingCandidates();
    public void set_LabelingCandidates(Collection`1<LabelingCandidate> value);
    public LabelingCandidate get_BasePointLabelingCandidate();
    public void set_BasePointLabelingCandidate(LabelingCandidate value);
    public string get_Key();
    public void set_Key(string value);
    public PositionStyle get_PositionStyle();
    public void set_PositionStyle(PositionStyle value);
    public sealed virtual int CompareTo(FeatureLabelingCandidate other);
    public static void Sort(List`1<FeatureLabelingCandidate> featureLabelingCandidates, float canvasWidth, float canvasHeight);
    private static bool EDE=(double minX, double minY, double maxX, double maxY, float canvasWidth, float canvasHeight);
    private static bool ETE=(double minX, double minY, double maxX, double maxY, float canvasWidth, float canvasHeight);
    private static void EjE=(LabelingCandidate labelingCandidate, Double& minX, Double& minY, Double& maxX, Double& maxY);
}
public abstract class ThinkGeo.Core.FeatureLayer : Layer {
    [ObfuscationAttribute]
private float drawingMarginInPixel;
    [ObfuscationAttribute]
private EditTools editTools;
    [ObfuscationAttribute]
private QueryTools queryTools;
    [ObfuscationAttribute]
private FeatureSource featureSource;
    [ObfuscationAttribute]
private ZoomLevelSet zoomLevelSet;
    [ObfuscationAttribute]
private DrawingQuality drawingQuality;
    [CompilerGeneratedAttribute]
private EventHandler`1<DrawingFeaturesEventArgs> TCA=;
    [CompilerGeneratedAttribute]
private EventHandler`1<DrawingWrappingFeaturesFeatureLayerEventArgs> TSA=;
    public Projection Projection { get; }
    public EditTools EditTools { get; protected set; }
    public Collection`1<string> FeatureIdsToExclude { get; }
    public QueryTools QueryTools { get; protected set; }
    public int MaxRecordsToDraw { get; public set; }
    public FeatureSource FeatureSource { get; public set; }
    public DrawingQuality DrawingQuality { get; public set; }
    public ZoomLevelSet ZoomLevelSet { get; public set; }
    public float DrawingMarginInPixel { get; public set; }
    protected bool IsOpenCore { get; }
    [CompilerGeneratedAttribute]
public void add_DrawingFeatures(EventHandler`1<DrawingFeaturesEventArgs> value);
    [CompilerGeneratedAttribute]
public void remove_DrawingFeatures(EventHandler`1<DrawingFeaturesEventArgs> value);
    [CompilerGeneratedAttribute]
public void add_DrawingWrappingFeatures(EventHandler`1<DrawingWrappingFeaturesFeatureLayerEventArgs> value);
    [CompilerGeneratedAttribute]
public void remove_DrawingWrappingFeatures(EventHandler`1<DrawingWrappingFeaturesFeatureLayerEventArgs> value);
    protected virtual void OnDrawingFeatures(DrawingFeaturesEventArgs e);
    [ObsoleteAttribute("This API will be removed after V13.2. Please use OnDrawingFeatures instead. e.FeaturesToDraw in DrawingFeaturesEventArgs event includes the wrapping features. ")]
protected virtual void OnDrawingWrappingFeatures(DrawingWrappingFeaturesFeatureLayerEventArgs e);
    public virtual Projection get_Projection();
    public EditTools get_EditTools();
    protected void set_EditTools(EditTools value);
    public Collection`1<string> get_FeatureIdsToExclude();
    public QueryTools get_QueryTools();
    protected void set_QueryTools(QueryTools value);
    public int get_MaxRecordsToDraw();
    public void set_MaxRecordsToDraw(int value);
    public FeatureSource get_FeatureSource();
    public void set_FeatureSource(FeatureSource value);
    public DrawingQuality get_DrawingQuality();
    public void set_DrawingQuality(DrawingQuality value);
    public ZoomLevelSet get_ZoomLevelSet();
    public void set_ZoomLevelSet(ZoomLevelSet value);
    public float get_DrawingMarginInPixel();
    public void set_DrawingMarginInPixel(float value);
    protected virtual bool get_IsOpenCore();
    protected virtual void DrawCore(GeoCanvas canvas, Collection`1<SimpleCandidate> labelsInAllLayers);
    protected virtual bool IsDrawingNeededCore(double currentScale);
    protected void SetupTools();
    protected virtual void SetupToolsCore();
    protected virtual void OpenCore();
    protected virtual void CloseCore();
    protected virtual RectangleShape GetBoundingBoxCore();
    protected Collection`1<Feature> GetWrappingFeaturesForDrawing(RectangleShape drawingExtent, IEnumerable`1<string> returningColumnNames, RectangleShape wrappingExtent);
    private Collection`1<Feature> TiA=(RectangleShape drawingWorldExtent, IEnumerable`1<string> returningColumnNames, RectangleShape wrappingWorldExtent, double minRatioX, double maxRatioX);
    public double GetCeiling(double d);
    private void TyA=(object sender, DrawingProgressChangedEventArgs e);
}
public class ThinkGeo.Core.FeatureResizedEditInteractiveOverlayEventArgs : EventArgs {
    [ObfuscationAttribute]
private Feature resizedFeature;
    public Feature ResizedFeature { get; public set; }
    public FeatureResizedEditInteractiveOverlayEventArgs(Feature resizedFeature);
    public Feature get_ResizedFeature();
    public void set_ResizedFeature(Feature value);
}
public class ThinkGeo.Core.FeatureResizingEditInteractiveOverlayEventArgs : EventArgs {
    [ObfuscationAttribute]
private Feature resizingFeature;
    [ObfuscationAttribute]
private PointShape sourceControlPoint;
    [ObfuscationAttribute]
private PointShape targetControlPoint;
    [ObfuscationAttribute]
private bool cancel;
    public Feature ResizingFeature { get; public set; }
    public PointShape SourceControlPoint { get; public set; }
    public PointShape TargetControlPoint { get; public set; }
    public bool Cancel { get; public set; }
    public FeatureResizingEditInteractiveOverlayEventArgs(Feature resizingFeature, bool cancel, PointShape sourceControlPoint, PointShape targetControlPoint);
    public Feature get_ResizingFeature();
    public void set_ResizingFeature(Feature value);
    public PointShape get_SourceControlPoint();
    public void set_SourceControlPoint(PointShape value);
    public PointShape get_TargetControlPoint();
    public void set_TargetControlPoint(PointShape value);
    public bool get_Cancel();
    public void set_Cancel(bool value);
}
public class ThinkGeo.Core.FeatureRotatedEditInteractiveOverlayEventArgs : EventArgs {
    [ObfuscationAttribute]
private Feature rotatedFeature;
    public Feature RotatedFeature { get; public set; }
    public FeatureRotatedEditInteractiveOverlayEventArgs(Feature rotatedFeature);
    public Feature get_RotatedFeature();
    public void set_RotatedFeature(Feature value);
}
public class ThinkGeo.Core.FeatureRotatingEditInteractiveOverlayEventArgs : EventArgs {
    [ObfuscationAttribute]
private Feature rotatingFeature;
    [ObfuscationAttribute]
private PointShape sourceControlPoint;
    [ObfuscationAttribute]
private PointShape targetControlPoint;
    [ObfuscationAttribute]
private bool cancel;
    public Feature RotatingFeature { get; public set; }
    public PointShape SourceControlPoint { get; public set; }
    public PointShape TargetControlPoint { get; public set; }
    public bool Cancel { get; public set; }
    public FeatureRotatingEditInteractiveOverlayEventArgs(Feature rotatingFeature, bool cancel, PointShape sourceControlPoint, PointShape targetControlPoint);
    public Feature get_RotatingFeature();
    public void set_RotatingFeature(Feature value);
    public PointShape get_SourceControlPoint();
    public void set_SourceControlPoint(PointShape value);
    public PointShape get_TargetControlPoint();
    public void set_TargetControlPoint(PointShape value);
    public bool get_Cancel();
    public void set_Cancel(bool value);
}
public abstract class ThinkGeo.Core.FeatureSource : object {
    [ObfuscationAttribute]
private string id;
    [ObfuscationAttribute]
private static int maximumLoopCount;
    [ObfuscationAttribute]
private static int progressDrawingRaisingFrequency;
    [ObfuscationAttribute]
private int progressDrawingRaisedCount;
    private bool pBo=;
    [ObfuscationAttribute]
private bool isInTransaction;
    [ObfuscationAttribute]
private bool isTransactionLive;
    [ObfuscationAttribute]
private TransactionBuffer transactionBuffer;
    [ObfuscationAttribute]
private Collection`1<FeatureSourceColumn> featureSourceColumns;
    [ObfuscationAttribute]
private Collection`1<string> featureIdsToExclude;
    [ObfuscationAttribute]
private ProjectionConverter projectionConverter;
    [ObfuscationAttribute]
private Projection projection;
    [ObfuscationAttribute]
private FeatureCache geoCache;
    [ObfuscationAttribute]
private int maxRecordsToDraw;
    [ObfuscationAttribute]
private bool canModifyColumnStructure;
    [CompilerGeneratedAttribute]
private EventHandler`1<DrawingProgressChangedEventArgs> LxU=;
    [CompilerGeneratedAttribute]
private EventHandler`1<GettingColumnsFeatureSourceEventArgs> kh4=;
    [CompilerGeneratedAttribute]
private EventHandler`1<GottenColumnsFeatureSourceEventArgs> kx4=;
    [CompilerGeneratedAttribute]
private EventHandler`1<GettingFeaturesByIdsFeatureSourceEventArgs> lB4=;
    [CompilerGeneratedAttribute]
private EventHandler`1<GettingFeaturesForDrawingFeatureSourceEventArgs> lR4=;
    [CompilerGeneratedAttribute]
private EventHandler`1<CustomColumnFetchEventArgs> lh4=;
    [CompilerGeneratedAttribute]
private EventHandler`1<CommittingTransactionEventArgs> lx4=;
    [CompilerGeneratedAttribute]
private EventHandler`1<CommittedTransactionEventArgs> mB4=;
    [CompilerGeneratedAttribute]
private EventHandler`1<OpeningFeatureSourceEventArgs> mR4=;
    [CompilerGeneratedAttribute]
private EventHandler`1<OpenedFeatureSourceEventArgs> mh4=;
    [CompilerGeneratedAttribute]
private EventHandler`1<ClosingFeatureSourceEventArgs> mx4=;
    [CompilerGeneratedAttribute]
private EventHandler`1<ClosedFeatureSourceEventArgs> nB4=;
    public string Id { get; }
    public bool CanExecuteSqlQuery { get; }
    protected bool CanExecuteSqlQueryCore { get; }
    public bool IsOpen { get; }
    public Projection Projection { get; protected set; }
    protected bool IsOpenCore { get; protected set; }
    public bool CanModifyColumnStructure { get; }
    protected bool CanModifyColumnStructureCore { get; protected set; }
    protected Collection`1<FeatureSourceColumn> FeatureSourceColumns { get; }
    public bool IsInTransaction { get; }
    public bool IsTransactionLive { get; public set; }
    public bool IsEditable { get; }
    public ProjectionConverter ProjectionConverter { get; public set; }
    public FeatureCache GeoCache { get; public set; }
    public Collection`1<string> FeatureIdsToExclude { get; }
    public TransactionBuffer TransactionBuffer { get; public set; }
    public int MaxRecordsToDraw { get; public set; }
    [CompilerGeneratedAttribute]
public void add_DrawingProgressChanged(EventHandler`1<DrawingProgressChangedEventArgs> value);
    [CompilerGeneratedAttribute]
public void remove_DrawingProgressChanged(EventHandler`1<DrawingProgressChangedEventArgs> value);
    [CompilerGeneratedAttribute]
public void add_GettingColumns(EventHandler`1<GettingColumnsFeatureSourceEventArgs> value);
    [CompilerGeneratedAttribute]
public void remove_GettingColumns(EventHandler`1<GettingColumnsFeatureSourceEventArgs> value);
    [CompilerGeneratedAttribute]
public void add_GottenColumns(EventHandler`1<GottenColumnsFeatureSourceEventArgs> value);
    [CompilerGeneratedAttribute]
public void remove_GottenColumns(EventHandler`1<GottenColumnsFeatureSourceEventArgs> value);
    [CompilerGeneratedAttribute]
public void add_GettingFeaturesByIds(EventHandler`1<GettingFeaturesByIdsFeatureSourceEventArgs> value);
    [CompilerGeneratedAttribute]
public void remove_GettingFeaturesByIds(EventHandler`1<GettingFeaturesByIdsFeatureSourceEventArgs> value);
    [CompilerGeneratedAttribute]
public void add_GettingFeaturesForDrawing(EventHandler`1<GettingFeaturesForDrawingFeatureSourceEventArgs> value);
    [CompilerGeneratedAttribute]
public void remove_GettingFeaturesForDrawing(EventHandler`1<GettingFeaturesForDrawingFeatureSourceEventArgs> value);
    [CompilerGeneratedAttribute]
public void add_CustomColumnFetch(EventHandler`1<CustomColumnFetchEventArgs> value);
    [CompilerGeneratedAttribute]
public void remove_CustomColumnFetch(EventHandler`1<CustomColumnFetchEventArgs> value);
    [CompilerGeneratedAttribute]
public void add_CommittingTransaction(EventHandler`1<CommittingTransactionEventArgs> value);
    [CompilerGeneratedAttribute]
public void remove_CommittingTransaction(EventHandler`1<CommittingTransactionEventArgs> value);
    [CompilerGeneratedAttribute]
public void add_CommittedTransaction(EventHandler`1<CommittedTransactionEventArgs> value);
    [CompilerGeneratedAttribute]
public void remove_CommittedTransaction(EventHandler`1<CommittedTransactionEventArgs> value);
    [CompilerGeneratedAttribute]
public void add_OpeningFeatureSource(EventHandler`1<OpeningFeatureSourceEventArgs> value);
    [CompilerGeneratedAttribute]
public void remove_OpeningFeatureSource(EventHandler`1<OpeningFeatureSourceEventArgs> value);
    [CompilerGeneratedAttribute]
public void add_OpenedFeatureSource(EventHandler`1<OpenedFeatureSourceEventArgs> value);
    [CompilerGeneratedAttribute]
public void remove_OpenedFeatureSource(EventHandler`1<OpenedFeatureSourceEventArgs> value);
    [CompilerGeneratedAttribute]
public void add_ClosingFeatureSource(EventHandler`1<ClosingFeatureSourceEventArgs> value);
    [CompilerGeneratedAttribute]
public void remove_ClosingFeatureSource(EventHandler`1<ClosingFeatureSourceEventArgs> value);
    [CompilerGeneratedAttribute]
public void add_ClosedFeatureSource(EventHandler`1<ClosedFeatureSourceEventArgs> value);
    [CompilerGeneratedAttribute]
public void remove_ClosedFeatureSource(EventHandler`1<ClosedFeatureSourceEventArgs> value);
    protected virtual void OnGettingColumns(GettingColumnsFeatureSourceEventArgs e);
    protected virtual void OnGottenColumns(GottenColumnsFeatureSourceEventArgs e);
    protected virtual void OnCustomColumnFetch(CustomColumnFetchEventArgs e);
    protected virtual void OnCommittingTransaction(CommittingTransactionEventArgs e);
    protected virtual void OnCommittedTransaction(CommittedTransactionEventArgs e);
    protected virtual void OnOpeningFeatureSource(OpeningFeatureSourceEventArgs e);
    protected virtual void OnOpenedFeatureSource(OpenedFeatureSourceEventArgs e);
    protected virtual void OnClosingFeatureSource(ClosingFeatureSourceEventArgs e);
    protected virtual void OnClosedFeatureSource(ClosedFeatureSourceEventArgs e);
    protected virtual void OnGettingFeaturesByIds(GettingFeaturesByIdsFeatureSourceEventArgs e);
    protected virtual void OnGettingFeaturesForDrawing(GettingFeaturesForDrawingFeatureSourceEventArgs e);
    public string get_Id();
    public bool get_CanExecuteSqlQuery();
    protected virtual bool get_CanExecuteSqlQueryCore();
    public bool get_IsOpen();
    public Projection get_Projection();
    protected void set_Projection(Projection value);
    protected virtual bool get_IsOpenCore();
    protected virtual void set_IsOpenCore(bool value);
    public bool get_CanModifyColumnStructure();
    protected virtual bool get_CanModifyColumnStructureCore();
    protected virtual void set_CanModifyColumnStructureCore(bool value);
    protected Collection`1<FeatureSourceColumn> get_FeatureSourceColumns();
    public bool get_IsInTransaction();
    public bool get_IsTransactionLive();
    public void set_IsTransactionLive(bool value);
    public virtual bool get_IsEditable();
    public ProjectionConverter get_ProjectionConverter();
    public void set_ProjectionConverter(ProjectionConverter value);
    public FeatureCache get_GeoCache();
    public void set_GeoCache(FeatureCache value);
    public Collection`1<string> get_FeatureIdsToExclude();
    public TransactionBuffer get_TransactionBuffer();
    public void set_TransactionBuffer(TransactionBuffer value);
    public int get_MaxRecordsToDraw();
    public void set_MaxRecordsToDraw(int value);
    public int ExecuteNonQuery(string sqlStatement);
    protected virtual int ExecuteNonQueryCore(string sqlStatement);
    public Collection`1<Feature> GetFeaturesByColumnValue(string columnName, string columnValue, ReturningColumnsType returningColumnType);
    public Collection`1<Feature> GetFeaturesByColumnValue(string columnName, string columnValue, IEnumerable`1<string> returningColumnNames);
    private static Collection`1<Feature> nR4=(Collection`1<Feature> features, TransactionBuffer transactionBuffer, string columnName, string columnValue);
    public Collection`1<Feature> GetFeaturesByColumnValue(string columnName, string columnValue);
    protected virtual Collection`1<Feature> GetFeaturesByColumnValueCore(string columnName, string columnValue, IEnumerable`1<string> returningColumnNames);
    public object ExecuteScalar(string sqlStatement);
    protected virtual object ExecuteScalarCore(string sqlStatement);
    public DataTable ExecuteQuery(string sqlStatement);
    protected virtual DataTable ExecuteQueryCore(string sqlStatement);
    public Collection`1<FeatureSourceColumn> GetColumns();
    protected virtual Collection`1<FeatureSourceColumn> GetColumnsCore();
    public void RefreshColumns();
    public long GetCount();
    protected virtual long GetCountCore();
    public RectangleShape GetBoundingBox();
    protected virtual RectangleShape GetBoundingBoxCore();
    public FeatureSource CloneDeep();
    protected virtual FeatureSource CloneDeepCore();
    public void Open();
    protected virtual void OpenCore();
    public void Close();
    protected virtual void CloseCore();
    public void BeginTransaction();
    public string AddFeature(Feature feature);
    public string AddFeature(BaseShape shape);
    public string AddFeature(BaseShape shape, IDictionary`2<string, string> columnValues);
    public void DeleteFeature(string id);
    public void UpdateFeature(Feature feature);
    public void UpdateFeature(BaseShape shape);
    public void UpdateFeature(BaseShape shape, IDictionary`2<string, string> columnValues);
    public void RollbackTransaction();
    public TransactionResult CommitTransaction();
    protected virtual TransactionResult CommitTransactionCore(TransactionBuffer transactions);
    public void AddColumn(FeatureSourceColumn featureSourceColumn);
    public void DeleteColumn(string columnName);
    public void UpdateColumn(string columnName, FeatureSourceColumn newFeatureSourceColumn);
    public Collection`1<Feature> GetAllFeatures(IEnumerable`1<string> returningColumnNames);
    internal Collection`1<Feature> nh4=(Collection`1<Feature> sourceFeatures, Collection`1<string> fieldNamesOutsideOfSource);
    private Collection`1<Feature> nh4=(Collection`1<Feature> sourceFeatures, Collection`1<string> fieldNamesOutsideOfSource, bool forceRaiseEvent);
    private Collection`1<Feature> nx4=(Collection`1<Feature> sourceFeatures);
    public Collection`1<Feature> GetAllFeatures(ReturningColumnsType returningColumnNamesType);
    public Collection`1<string> GetFeatureIds();
    protected virtual Collection`1<string> GetFeatureIdsCore();
    protected abstract virtual Collection`1<Feature> GetAllFeaturesCore(IEnumerable`1<string> returningColumnNames);
    public Collection`1<Feature> GetFeaturesOutsideBoundingBox(RectangleShape boundingBox, IEnumerable`1<string> returningColumnNames);
    public Collection`1<Feature> GetFeaturesOutsideBoundingBox(RectangleShape boundingBox, ReturningColumnsType returningColumnNamesType);
    protected virtual Collection`1<Feature> GetFeaturesOutsideBoundingBoxCore(RectangleShape boundingBox, IEnumerable`1<string> returningColumnNames);
    public Collection`1<Feature> GetFeaturesInsideBoundingBox(RectangleShape boundingBox, IEnumerable`1<string> returningColumnNames);
    public Collection`1<Feature> GetFeaturesInsideBoundingBox(RectangleShape boundingBox, ReturningColumnsType returningColumnNamesType);
    protected virtual Collection`1<Feature> GetFeaturesInsideBoundingBoxCore(RectangleShape boundingBox, IEnumerable`1<string> returningColumnNames);
    public Collection`1<string> GetFeatureIdsInsideBoundingBox(RectangleShape boundingBox);
    protected virtual Collection`1<string> GetFeatureIdsInsideBoundingBoxCore(RectangleShape boundingBox);
    public Collection`1<Feature> GetFeaturesForDrawing(RectangleShape boundingBox, double screenWidth, double screenHeight, IEnumerable`1<string> returningColumnNames);
    internal void oB4=(RectangleShape boundingBox, Collection`1<Feature> returnFeatures, bool needUpdateProjection);
    private Feature rRo=(ProjectionConverter projection, Feature feature);
    public Collection`1<Feature> GetFeaturesForDrawing(RectangleShape boundingBox, double screenWidth, double screenHeight, ReturningColumnsType returningColumnNamesType);
    protected virtual Collection`1<Feature> GetFeaturesForDrawingCore(RectangleShape boundingBox, double screenWidth, double screenHeight, IEnumerable`1<string> returningColumnNames);
    public Collection`1<Feature> SpatialQuery(BaseShape targetShape, QueryType queryType, IEnumerable`1<string> returningColumnNames);
    public Collection`1<Feature> SpatialQuery(BaseShape targetShape, QueryType queryType, ReturningColumnsType returningColumnNamesType);
    public Collection`1<Feature> SpatialQuery(Feature feature, QueryType queryType, IEnumerable`1<string> returningColumnNames);
    public Collection`1<Feature> SpatialQuery(Feature feature, QueryType queryType, ReturningColumnsType returningColumnNamesType);
    protected virtual Collection`1<Feature> SpatialQueryCore(BaseShape targetShape, QueryType queryType, IEnumerable`1<string> returningColumnNames);
    private Collection`1<Feature> oR4=(BaseShape targetShape, IEnumerable`1<string> returningColumnNames);
    private Collection`1<Feature> oh4=(BaseShape targetShape, IEnumerable`1<string> returningColumnNames);
    private Collection`1<Feature> ox4=(BaseShape targetShape, IEnumerable`1<string> returningColumnNames);
    private Collection`1<Feature> pB4=(BaseShape targetShape, IEnumerable`1<string> returningColumnNames);
    private Collection`1<Feature> pR4=(BaseShape targetShape, IEnumerable`1<string> returningColumnNames);
    private Collection`1<Feature> ph4=(BaseShape targetShape, IEnumerable`1<string> returningColumnNames);
    private Collection`1<Feature> px4=(BaseShape targetShape, IEnumerable`1<string> returningColumnNames);
    private Collection`1<Feature> qB4=(BaseShape targetShape, IEnumerable`1<string> returningColumnNames);
    private static bool qR4=(BaseShape targetShape, BaseShape sourceShape, QueryType queryType);
    public Collection`1<Feature> GetFeaturesNearestTo(BaseShape targetShape, GeographyUnit unitOfFeatureSource, int maxItemsToFind, IEnumerable`1<string> returningColumnNames);
    public Collection`1<Feature> GetFeaturesNearestTo(BaseShape targetShape, GeographyUnit unitOfData, int maxItemsToFind, ReturningColumnsType returningColumnNamesType);
    public Collection`1<Feature> GetFeaturesNearestTo(Feature targetFeature, GeographyUnit unitOfData, int maxItemsToFind, IEnumerable`1<string> returningColumnNames);
    public Collection`1<Feature> GetFeaturesNearestTo(Feature targetFeature, GeographyUnit unitOfData, int maxItemsToFind, ReturningColumnsType returningColumnNamesType);
    public Collection`1<Feature> GetFeaturesNearestTo(BaseShape targetShape, GeographyUnit unitOfData, int maxItemsToFind, IEnumerable`1<string> returningColumnNames, double searchRadius, DistanceUnit unitOfSearchRadius);
    public Collection`1<Feature> GetFeaturesNearestTo(Feature targetFeature, GeographyUnit unitOfData, int maxItemsToFind, IEnumerable`1<string> returningColumnNames, double searchRadius, DistanceUnit unitOfSearchRadius);
    protected virtual Collection`1<Feature> GetFeaturesNearestToCore(BaseShape targetShape, GeographyUnit unitOfData, int maxItemsToFind, IEnumerable`1<string> returningColumnNames);
    internal static Collection`1<Feature> qh4=(Collection`1<Feature> possibleResults, BaseShape targetShape, GeographyUnit unitOfData, int maxItemsToFind);
    public Collection`1<Feature> GetFeaturesWithinDistanceOf(BaseShape targetShape, GeographyUnit unitOfData, DistanceUnit distanceUnit, double distance, IEnumerable`1<string> returningColumnNames);
    public Collection`1<Feature> GetFeaturesWithinDistanceOf(BaseShape targetShape, GeographyUnit unitOfData, DistanceUnit distanceUnit, double distance, ReturningColumnsType returningColumnNamesType);
    public Collection`1<Feature> GetFeaturesWithinDistanceOf(Feature targetFeature, GeographyUnit unitOfData, DistanceUnit distanceUnit, double distance, IEnumerable`1<string> returningColumnNames);
    public Collection`1<Feature> GetFeaturesWithinDistanceOf(Feature targetFeature, GeographyUnit unitOfData, DistanceUnit distanceUnit, double distance, ReturningColumnsType returningColumnNamesType);
    protected virtual Collection`1<Feature> GetFeaturesWithinDistanceOfCore(BaseShape targetShape, GeographyUnit unitOfData, DistanceUnit distanceUnit, double distance, IEnumerable`1<string> returningColumnNames);
    public Feature GetFeatureById(string id, IEnumerable`1<string> returningColumnNames);
    public Feature GetFeatureById(string id, ReturningColumnsType returningColumnNamesType);
    public Collection`1<Feature> GetFeaturesByIds(IEnumerable`1<string> ids, IEnumerable`1<string> returningColumnNames);
    public Collection`1<Feature> GetFeaturesByIds(IEnumerable`1<string> ids, ReturningColumnsType returningColumnNamesType);
    public RectangleShape GetBoundingBoxById(string id);
    public RectangleShape GetBoundingBoxByIds(IEnumerable`1<string> ids);
    public void RemoveEmptyAndExcludedFeatures(Collection`1<Feature> features);
    public Collection`1<string> GetColumnNamesOutsideFeatureSource(IEnumerable`1<string> returningColumnNames);
    public Collection`1<RectangleShape> GetBoundingBoxesByIds(IEnumerable`1<string> ids);
    protected virtual RectangleShape GetBoundingBoxByIdCore(string id);
    public WellKnownType GetFirstFeaturesWellKnownType();
    protected virtual WellKnownType GetFirstFeaturesWellKnownTypeCore();
    protected virtual Collection`1<Feature> GetFeaturesByIdsCore(IEnumerable`1<string> ids, IEnumerable`1<string> returningColumnNames);
    protected Collection`1<string> GetColumnNamesInsideFeatureSource(IEnumerable`1<string> returningColumnNames);
    protected Collection`1<string> GetReturningColumnNames(ReturningColumnsType returningColumnNamesType);
    public static string GetColumnNameAlias(string columnName, ICollection`1<string> columnNames);
    public static Collection`1<string> SplitColumnNames(IEnumerable`1<string> columnNames);
    public static DataTable ConvertToDataTable(IEnumerable`1<Feature> features, IEnumerable`1<string> columnNames);
    protected static Dictionary`2<string, string> CombineFieldValues(Dictionary`2<string, string> columnValues, IEnumerable`1<string> originalColumnNames);
    private static int qx4=(List`1<double> doubles);
    private static bool rB4=(IEnumerable`1<string> originalComlumnNames);
    private static Collection`1<string> rR4=(string multiFieldName);
    private static Collection`1<string> rh4=(string multiFieldName);
    private static Collection`1<Feature> nR4=(Collection`1<Feature> features, TransactionBuffer transactionBuffer, IEnumerable`1<string> returningIds);
    private static Dictionary`2<string, Feature> nR4=(Dictionary`2<string, Feature> features, TransactionBuffer transactionBuffer);
    private static Dictionary`2<string, Feature> rx4=(Collection`1<Feature> features);
    private static Collection`1<Feature> sB4=(Dictionary`2<string, Feature> features);
    protected virtual void OnDrawingProgressChanged(DrawingProgressChangedEventArgs e);
    internal Collection`1<string> sR4=(IEnumerable`1<string> returningColumnNames);
    [OnGeodeserializedAttribute]
private void sh4=();
    private static Collection`1<Feature> sx4=(Collection`1<Feature> features, IEnumerable`1<string> returningColumnNames);
    private static string tB4=(string columnName, ICollection`1<string> columnNames, int alias);
    public bool CanGetBoundingBoxQuickly();
    protected virtual bool CanGetBoundingBoxQuicklyCore();
    public bool CanGetCountQuickly();
    protected virtual bool CanGetCountQuicklyCore();
    public Collection`1<DistinctColumnValue> GetDistinctColumnValues(string columnName);
    protected virtual Collection`1<DistinctColumnValue> GetDistinctColumnValuesCore(string columnName);
    public Collection`1<Feature> GetAllFeatures(ReturningColumnsType returningColumnTypes, int startIndex);
    public Collection`1<Feature> GetAllFeatures(ReturningColumnsType returningColumnTypes, int startIndex, int takeCount);
    public Collection`1<Feature> GetAllFeatures(IEnumerable`1<string> returningColumnNames, int startIndex, int takeCount);
    protected virtual Collection`1<Feature> GetAllFeaturesCore(IEnumerable`1<string> returningColumnNames, int startIndex, int takeCount);
    [CompilerGeneratedAttribute]
private bool tR4=(Feature f);
    [CompilerGeneratedAttribute]
private bool th4=(Feature f);
}
public class ThinkGeo.Core.FeatureSourceColumn : object {
    [ObfuscationAttribute]
private string columnName;
    [ObfuscationAttribute]
private string typeName;
    [ObfuscationAttribute]
private int maxLength;
    public string ColumnName { get; public set; }
    public string TypeName { get; public set; }
    public int MaxLength { get; public set; }
    public FeatureSourceColumn(string columnName);
    public FeatureSourceColumn(string columnName, string typeName, int maxLength);
    public string get_ColumnName();
    public void set_ColumnName(string value);
    public string get_TypeName();
    public void set_TypeName(string value);
    public int get_MaxLength();
    public void set_MaxLength(int value);
    public virtual string ToString();
}
public enum ThinkGeo.Core.FeatureValidationType : Enum {
    public int value__;
    public static FeatureValidationType Invalid;
    public static FeatureValidationType Valid;
}
[ObfuscationAttribute]
internal class ThinkGeo.Core.FeetValues : ValueType {
    [ObfuscationAttribute]
private double v10;
    [ObfuscationAttribute]
private double v100;
    [ObfuscationAttribute]
private double v1000;
    [ObfuscationAttribute]
private double v20;
    [ObfuscationAttribute]
private double v200;
    [ObfuscationAttribute]
private double v2000;
    [ObfuscationAttribute]
private double v30;
    [ObfuscationAttribute]
private double v300;
    [ObfuscationAttribute]
private double v40;
    [ObfuscationAttribute]
private double v400;
    [ObfuscationAttribute]
private double v50;
    [ObfuscationAttribute]
private double v500;
    public double KCE= { get; }
    public double KiE= { get; }
    public double LCE= { get; }
    public double LiE= { get; }
    public double MCE= { get; }
    public double MiE= { get; }
    public double NCE= { get; }
    public double NiE= { get; }
    public double OCE= { get; }
    public double OiE= { get; }
    public double PCE= { get; }
    public double PiE= { get; }
    public FeetValues(int width, double extentLengthBar, DistanceUnit distanceUnit);
    public double JyE=();
    public double KSE=();
    public double KyE=();
    public double LSE=();
    public double LyE=();
    public double MSE=();
    public double MyE=();
    public double NSE=();
    public double NyE=();
    public double OSE=();
    public double OyE=();
    public double PSE=();
}
[ObfuscationAttribute]
internal class ThinkGeo.Core.FileHeader : ValueType {
    [ObfuscationAttribute]
public string descriptionString;
    [ObfuscationAttribute]
public UInt32 extensionId;
    [ObfuscationAttribute]
public UInt32 freePageId;
    [ObfuscationAttribute]
public string extensionName;
    [ObfuscationAttribute]
public UInt32 pageSize;
    [ObfuscationAttribute]
public bool isFloat;
    private static int lh8=;
    private static int lx8=;
    private static int mB8=;
    public void Lh8=();
    public bool pBw=(BinaryReader r);
    public bool shw=(BinaryWriter w);
    public virtual string ToString();
}
public class ThinkGeo.Core.FileRasterTileCache : RasterTileCache {
    [ObfuscationAttribute]
private static int DigitCount;
    [ObfuscationAttribute]
private string cacheDirectory;
    private static object kxY=;
    public string CacheDirectory { get; public set; }
    public FileRasterTileCache(string cacheDirectory);
    public FileRasterTileCache(string cacheDirectory, string cacheId);
    public FileRasterTileCache(string cacheDirectory, string cacheId, GeoImageFormat imageFormat);
    private static FileRasterTileCache();
    public string get_CacheDirectory();
    public void set_CacheDirectory(string value);
    protected virtual Tile GetTileCore(int zoom, long column, long row);
    [AsyncStateMachineAttribute("ThinkGeo.Core.FileRasterTileCache/AD8=")]
protected virtual Task`1<Tile> GetTileAsyncCore(int zoom, long column, long row, CancellationToken cancellationToken);
    protected virtual void SaveTileCore(Tile tile);
    [AsyncStateMachineAttribute("ThinkGeo.Core.FileRasterTileCache/BT8=")]
protected virtual Task SaveTileAsyncCore(Tile tile, CancellationToken cancellationToken);
    protected virtual void DeleteTileCore(Tile tile);
    internal bool zB0=(string tileImageFileName);
    public void ClearCache(TimeSpan tileExpiration);
    public void ClearCache(double maxSizeInMegabytes);
    public void ClearCache(TimeSpan tileExpiration, double maxSizeInMegabytes);
    public virtual string ToString();
    [IteratorStateMachineAttribute("ThinkGeo.Core.FileRasterTileCache//z4=")]
private static IEnumerable`1<string> zR0=();
    private static IEnumerable`1<FileInfo> zh0=(DirectoryInfo dirInfo);
    private static long zx0=(DirectoryInfo dirInfo);
    protected virtual void ClearCacheCore();
    private static bool 0B0=(string folder);
    private static string 0R0=(int zoom, long column, long row, string cacheId, string cacheDirectory, GeoImageFormat imageFormat);
}
public class ThinkGeo.Core.FileVectorTileCache : TileCache {
    [ObfuscationAttribute]
private string fileExtension;
    [ObfuscationAttribute]
private string cacheDirectory;
    public string CacheDirectory { get; public set; }
    public string FileExtension { get; public set; }
    public FileVectorTileCache(string cacheDirectory);
    public FileVectorTileCache(string cacheDirectory, string cacheId);
    public FileVectorTileCache(string cacheDirectory, string cacheId, string fileExtension);
    public string get_CacheDirectory();
    public void set_CacheDirectory(string value);
    public string get_FileExtension();
    public void set_FileExtension(string value);
    protected virtual void ClearCacheCore();
    protected virtual void DeleteTileCore(Tile tile);
    protected virtual Tile GetTileCore(int zoom, long column, long row);
    [AsyncStateMachineAttribute("ThinkGeo.Core.FileVectorTileCache/CD8=")]
protected virtual Task`1<Tile> GetTileAsyncCore(int zoom, long column, long row, CancellationToken cancellationToken);
    protected virtual void SaveTileCore(Tile tile);
    [AsyncStateMachineAttribute("ThinkGeo.Core.FileVectorTileCache/Cj8=")]
protected virtual Task SaveTileAsyncCore(Tile tile, CancellationToken cancellationToken);
    private static string 0R0=(int zoom, long row, long column, string cacheId, string cacheDirectory, string fileExtension);
}
public enum ThinkGeo.Core.FilterApplyMode : Enum {
    public int value__;
    public static FilterApplyMode ApplyFirst;
    public static FilterApplyMode ApplyAll;
}
public class ThinkGeo.Core.FilterCondition : object {
    internal static string xjE=;
    [ObfuscationAttribute]
private string columnName;
    [ObfuscationAttribute]
private string expression;
    [ObfuscationAttribute]
private string name;
    private Regex xzE=;
    private string yDE=;
    [ObfuscationAttribute]
private RegexOptions regexOptions;
    [ObfuscationAttribute]
private bool logical;
    [ObfuscationAttribute]
private bool isLeftBracket;
    [ObfuscationAttribute]
private bool isRightBracket;
    public string Expression { get; public set; }
    public string ColumnName { get; public set; }
    public string Name { get; public set; }
    public RegexOptions RegexOptions { get; public set; }
    public bool Logical { get; public set; }
    public bool IsLeftBracket { get; public set; }
    public bool IsRightBracket { get; public set; }
    public FilterCondition(string columnName);
    public FilterCondition(string columnName, string expression);
    private static FilterCondition();
    public string get_Expression();
    public void set_Expression(string value);
    public string get_ColumnName();
    public void set_ColumnName(string value);
    public string get_Name();
    public void set_Name(string value);
    public RegexOptions get_RegexOptions();
    public void set_RegexOptions(RegexOptions value);
    public bool get_Logical();
    public void set_Logical(bool value);
    public bool get_IsLeftBracket();
    public void set_IsLeftBracket(bool value);
    public bool get_IsRightBracket();
    public void set_IsRightBracket(bool value);
    public Collection`1<Feature> GetMatchingFeatures(IEnumerable`1<Feature> features);
    protected virtual Collection`1<Feature> GetMatchingFeaturesCore(IEnumerable`1<Feature> features);
    internal bool yTE=(Feature feature);
    internal bool yTE=(KeyValuePair`2<string, string> value);
    internal virtual bool TSM=(KeyValuePair`2<string, string> value);
    internal virtual bool TSM=(Feature feature);
    internal bool yjE=(Collection`1<string> values);
    private bool yzE=(string value, string expression);
    private static bool zDE=(Collection`1<string> columnValues, string expression, Func`4<double, double, double, bool> doubleMatchingFunc);
    private static bool zDE=(Collection`1<string> columnValues, string expression, Func`3<double, double, bool> doubleMatchingFunc);
    private static Collection`1<string> zTE=(Feature feature, string columnName);
    private static bool zjE=(IEnumerable`1<string> columnValues, Func`2<string, bool> matchFunc);
    [CompilerGeneratedAttribute]
private bool zzE=(Feature f);
    [CompilerGeneratedAttribute]
private bool 0DE=(string v);
    [CompilerGeneratedAttribute]
private bool 0TE=(string v);
}
public class ThinkGeo.Core.FilterStyle : Style {
    [ObfuscationAttribute]
private Collection`1<Style> styles;
    [ObfuscationAttribute]
private Collection`1<FilterCondition> conditions;
    public Collection`1<Style> Styles { get; }
    public Collection`1<FilterCondition> Conditions { get; }
    public Collection`1<Style> get_Styles();
    public Collection`1<FilterCondition> get_Conditions();
    protected virtual Collection`1<string> GetRequiredColumnNamesCore();
    protected virtual void DrawCore(IEnumerable`1<Feature> features, GeoCanvas canvas, Collection`1<SimpleCandidate> labelsInThisLayer, Collection`1<SimpleCandidate> labelsInAllLayers);
    protected virtual void DrawSampleCore(GeoCanvas canvas, DrawingRectangleF drawingExtent);
    private static Collection`1<string> 0jE=(string expression);
}
public class ThinkGeo.Core.FormattedPositionStyleEventArgs : EventArgs {
    [ObfuscationAttribute]
private string text;
    [ObfuscationAttribute]
private BaseShape shape;
    public string Text { get; public set; }
    public BaseShape Shape { get; public set; }
    public FormattedPositionStyleEventArgs(string text, BaseShape shape);
    public string get_Text();
    public void set_Text(string value);
    public BaseShape get_Shape();
    public void set_Shape(BaseShape value);
}
public class ThinkGeo.Core.FormattingPositionStyleEventArgs : EventArgs {
    [ObfuscationAttribute]
private string text;
    [ObfuscationAttribute]
private BaseShape shape;
    public string Text { get; public set; }
    public BaseShape Shape { get; public set; }
    public FormattingPositionStyleEventArgs(string text, BaseShape shape);
    public string get_Text();
    public void set_Text(string value);
    public BaseShape get_Shape();
    public void set_Shape(BaseShape value);
}
public class ThinkGeo.Core.GaussianKrigingGridInterpolationModel : KrigingGridInterpolationModel {
    public GaussianKrigingGridInterpolationModel(IDictionary`2<PointShape, double> points);
    public GaussianKrigingGridInterpolationModel(IDictionary`2<PointShape, double> points, int numberOfRefrencedPoints);
    protected virtual double GetSillSlopeCore(double distance, double range);
}
public class ThinkGeo.Core.GeneratedTileMBTilesLayerEventArgs : EventArgs {
    public int TileX;
    public int TileY;
    public int ZoomLevel;
    public GeneratedTileMBTilesLayerEventArgs(int tileX, int tileY, int zoomLevel);
}
public class ThinkGeo.Core.GeneratingGridFeatureSourceEventArgs : EventArgs {
    [ObfuscationAttribute]
private int gridCount;
    [ObfuscationAttribute]
private int gridIndex;
    [ObfuscationAttribute]
private DateTime startProcessTime;
    [ObfuscationAttribute]
private bool isCanceled;
    [ObfuscationAttribute]
private string gridPathFilename;
    public string GridPathFilename { get; public set; }
    public bool IsCanceled { get; public set; }
    public DateTime StartProcessTime { get; public set; }
    public int GridIndex { get; public set; }
    public int GridCount { get; public set; }
    public GeneratingGridFeatureSourceEventArgs(int gridCount, int gridIndex, DateTime startProcessTime, bool isCanceled);
    public GeneratingGridFeatureSourceEventArgs(int gridCount, int gridIndex, DateTime startProcessTime, bool isCanceled, string gridPathFilename);
    public string get_GridPathFilename();
    public void set_GridPathFilename(string value);
    public bool get_IsCanceled();
    public void set_IsCanceled(bool value);
    public DateTime get_StartProcessTime();
    public void set_StartProcessTime(DateTime value);
    public int get_GridIndex();
    public void set_GridIndex(int value);
    public int get_GridCount();
    public void set_GridCount(int value);
}
public class ThinkGeo.Core.GeneratingTileMBTilesLayerEventArgs : EventArgs {
    public int TileX;
    public int TileY;
    public int ZoomLevel;
    public bool Cancel;
    public GeneratingTileMBTilesLayerEventArgs(int tileX, int tileY, int zoomLevel);
}
public enum ThinkGeo.Core.GeoAlphaType : Enum {
    public int value__;
    public static GeoAlphaType Unknown;
    public static GeoAlphaType Opaque;
    public static GeoAlphaType Premul;
    public static GeoAlphaType Unpremul;
}
public abstract class ThinkGeo.Core.GeoBrush : object {
    [ObfuscationAttribute]
private long id;
    [ObfuscationAttribute]
private static long geoBrushIdCounter;
    public long Id { get; }
    public long get_Id();
}
public static class ThinkGeo.Core.GeoBrushes : object {
    public static GeoSolidBrush AliceBlue { get; }
    public static GeoSolidBrush AntiqueWhite { get; }
    public static GeoSolidBrush Aqua { get; }
    public static GeoSolidBrush Aquamarine { get; }
    public static GeoSolidBrush Azure { get; }
    public static GeoSolidBrush Beige { get; }
    public static GeoSolidBrush Bisque { get; }
    public static GeoSolidBrush Black { get; }
    public static GeoSolidBrush BlanchedAlmond { get; }
    public static GeoSolidBrush Blue { get; }
    public static GeoSolidBrush BlueViolet { get; }
    public static GeoSolidBrush Brown { get; }
    public static GeoSolidBrush BurlyWood { get; }
    public static GeoSolidBrush CadetBlue { get; }
    public static GeoSolidBrush Chartreuse { get; }
    public static GeoSolidBrush Chocolate { get; }
    public static GeoSolidBrush Coral { get; }
    public static GeoSolidBrush CornflowerBlue { get; }
    public static GeoSolidBrush CornSilk { get; }
    public static GeoSolidBrush Crimson { get; }
    public static GeoSolidBrush Cyan { get; }
    public static GeoSolidBrush DarkBlue { get; }
    public static GeoSolidBrush DarkCyan { get; }
    public static GeoSolidBrush DarkGoldenrod { get; }
    public static GeoSolidBrush DarkGray { get; }
    public static GeoSolidBrush DarkGreen { get; }
    public static GeoSolidBrush DarkKhaki { get; }
    public static GeoSolidBrush DarkMagenta { get; }
    public static GeoSolidBrush DarkOliveGreen { get; }
    public static GeoSolidBrush DarkOrange { get; }
    public static GeoSolidBrush DarkOrchid { get; }
    public static GeoSolidBrush DarkRed { get; }
    public static GeoSolidBrush DarkSalmon { get; }
    public static GeoSolidBrush DarkSeaGreen { get; }
    public static GeoSolidBrush DarkSlateBlue { get; }
    public static GeoSolidBrush DarkSlateGray { get; }
    public static GeoSolidBrush DarkTurquoise { get; }
    public static GeoSolidBrush DarkViolet { get; }
    public static GeoSolidBrush DeepPink { get; }
    public static GeoSolidBrush DeepSkyBlue { get; }
    public static GeoSolidBrush DimGray { get; }
    public static GeoSolidBrush DodgerBlue { get; }
    public static GeoSolidBrush Firebrick { get; }
    public static GeoSolidBrush FloralWhite { get; }
    public static GeoSolidBrush ForestGreen { get; }
    public static GeoSolidBrush Fuchsia { get; }
    public static GeoSolidBrush Gainsboro { get; }
    public static GeoSolidBrush GhostWhite { get; }
    public static GeoSolidBrush Gold { get; }
    public static GeoSolidBrush Goldenrod { get; }
    public static GeoSolidBrush Gray { get; }
    public static GeoSolidBrush Green { get; }
    public static GeoSolidBrush GreenYellow { get; }
    public static GeoSolidBrush HoneyDew { get; }
    public static GeoSolidBrush HotPink { get; }
    public static GeoSolidBrush IndianRed { get; }
    public static GeoSolidBrush Indigo { get; }
    public static GeoSolidBrush Ivory { get; }
    public static GeoSolidBrush Khaki { get; }
    public static GeoSolidBrush Lavender { get; }
    public static GeoSolidBrush LavenderBlush { get; }
    public static GeoSolidBrush LawnGreen { get; }
    public static GeoSolidBrush LemonChiffon { get; }
    public static GeoSolidBrush LightBlue { get; }
    public static GeoSolidBrush LightCoral { get; }
    public static GeoSolidBrush LightCyan { get; }
    public static GeoSolidBrush LightGoldenrodYellow { get; }
    public static GeoSolidBrush LightGray { get; }
    public static GeoSolidBrush LightGreen { get; }
    public static GeoSolidBrush LightPink { get; }
    public static GeoSolidBrush LightRed { get; }
    public static GeoSolidBrush LightSalmon { get; }
    public static GeoSolidBrush LightSeaGreen { get; }
    public static GeoSolidBrush LightSkyBlue { get; }
    public static GeoSolidBrush LightSlateGray { get; }
    public static GeoSolidBrush LightSteelBlue { get; }
    public static GeoSolidBrush LightYellow { get; }
    public static GeoSolidBrush Lime { get; }
    public static GeoSolidBrush LimeGreen { get; }
    public static GeoSolidBrush Linen { get; }
    public static GeoSolidBrush Magenta { get; }
    public static GeoSolidBrush Maroon { get; }
    public static GeoSolidBrush MediumAquamarine { get; }
    public static GeoSolidBrush MediumBlue { get; }
    public static GeoSolidBrush MediumOrchid { get; }
    public static GeoSolidBrush MediumPurple { get; }
    public static GeoSolidBrush MediumSeaGreen { get; }
    public static GeoSolidBrush MediumSlateBlue { get; }
    public static GeoSolidBrush MediumSpringGreen { get; }
    public static GeoSolidBrush MediumTurquoise { get; }
    public static GeoSolidBrush MediumVioletRed { get; }
    public static GeoSolidBrush MidnightBlue { get; }
    public static GeoSolidBrush MintCream { get; }
    public static GeoSolidBrush MistyRose { get; }
    public static GeoSolidBrush Moccasin { get; }
    public static GeoSolidBrush NavajoWhite { get; }
    public static GeoSolidBrush Navy { get; }
    public static GeoSolidBrush OldLace { get; }
    public static GeoSolidBrush Olive { get; }
    public static GeoSolidBrush OliveDrab { get; }
    public static GeoSolidBrush Orange { get; }
    public static GeoSolidBrush OrangeRed { get; }
    public static GeoSolidBrush Orchid { get; }
    public static GeoSolidBrush PaleGoldenrod { get; }
    public static GeoSolidBrush PaleGreen { get; }
    public static GeoSolidBrush PaleTurquoise { get; }
    public static GeoSolidBrush PaleVioletRed { get; }
    public static GeoSolidBrush PapayaWhip { get; }
    public static GeoSolidBrush PeachPuff { get; }
    public static GeoSolidBrush Peru { get; }
    public static GeoSolidBrush Pink { get; }
    public static GeoSolidBrush Plum { get; }
    public static GeoSolidBrush PowderBlue { get; }
    public static GeoSolidBrush Purple { get; }
    public static GeoSolidBrush Red { get; }
    public static GeoSolidBrush RosyBrown { get; }
    public static GeoSolidBrush RoyalBlue { get; }
    public static GeoSolidBrush SaddleBrown { get; }
    public static GeoSolidBrush Salmon { get; }
    public static GeoSolidBrush SandyBrown { get; }
    public static GeoSolidBrush SeaGreen { get; }
    public static GeoSolidBrush SeaShell { get; }
    public static GeoSolidBrush Sienna { get; }
    public static GeoSolidBrush Silver { get; }
    public static GeoSolidBrush SkyBlue { get; }
    public static GeoSolidBrush SlateBlue { get; }
    public static GeoSolidBrush SlateGray { get; }
    public static GeoSolidBrush Snow { get; }
    public static GeoSolidBrush SpringGreen { get; }
    public static GeoSolidBrush SteelBlue { get; }
    public static GeoSolidBrush Tan { get; }
    public static GeoSolidBrush Teal { get; }
    public static GeoSolidBrush Thistle { get; }
    public static GeoSolidBrush Tomato { get; }
    public static GeoSolidBrush Turquoise { get; }
    public static GeoSolidBrush Violet { get; }
    public static GeoSolidBrush Wheat { get; }
    public static GeoSolidBrush White { get; }
    public static GeoSolidBrush WhiteSmoke { get; }
    public static GeoSolidBrush Yellow { get; }
    public static GeoSolidBrush YellowGreen { get; }
    public static GeoSolidBrush DarkYellow { get; }
    public static GeoSolidBrush LightOrange { get; }
    public static GeoSolidBrush PaleRed { get; }
    public static GeoSolidBrush PaleBlue { get; }
    public static GeoSolidBrush PaleYellow { get; }
    public static GeoSolidBrush PaleOrange { get; }
    public static GeoSolidBrush BrightRed { get; }
    public static GeoSolidBrush BrightBlue { get; }
    public static GeoSolidBrush BrightYellow { get; }
    public static GeoSolidBrush BrightOrange { get; }
    public static GeoSolidBrush PastelRed { get; }
    public static GeoSolidBrush PastelBlue { get; }
    public static GeoSolidBrush PastelYellow { get; }
    public static GeoSolidBrush PastelGreen { get; }
    public static GeoSolidBrush PastelOrange { get; }
    public static GeoSolidBrush Copper { get; }
    public static GeoSolidBrush get_AliceBlue();
    public static GeoSolidBrush get_AntiqueWhite();
    public static GeoSolidBrush get_Aqua();
    public static GeoSolidBrush get_Aquamarine();
    public static GeoSolidBrush get_Azure();
    public static GeoSolidBrush get_Beige();
    public static GeoSolidBrush get_Bisque();
    public static GeoSolidBrush get_Black();
    public static GeoSolidBrush get_BlanchedAlmond();
    public static GeoSolidBrush get_Blue();
    public static GeoSolidBrush get_BlueViolet();
    public static GeoSolidBrush get_Brown();
    public static GeoSolidBrush get_BurlyWood();
    public static GeoSolidBrush get_CadetBlue();
    public static GeoSolidBrush get_Chartreuse();
    public static GeoSolidBrush get_Chocolate();
    public static GeoSolidBrush get_Coral();
    public static GeoSolidBrush get_CornflowerBlue();
    public static GeoSolidBrush get_CornSilk();
    public static GeoSolidBrush get_Crimson();
    public static GeoSolidBrush get_Cyan();
    public static GeoSolidBrush get_DarkBlue();
    public static GeoSolidBrush get_DarkCyan();
    public static GeoSolidBrush get_DarkGoldenrod();
    public static GeoSolidBrush get_DarkGray();
    public static GeoSolidBrush get_DarkGreen();
    public static GeoSolidBrush get_DarkKhaki();
    public static GeoSolidBrush get_DarkMagenta();
    public static GeoSolidBrush get_DarkOliveGreen();
    public static GeoSolidBrush get_DarkOrange();
    public static GeoSolidBrush get_DarkOrchid();
    public static GeoSolidBrush get_DarkRed();
    public static GeoSolidBrush get_DarkSalmon();
    public static GeoSolidBrush get_DarkSeaGreen();
    public static GeoSolidBrush get_DarkSlateBlue();
    public static GeoSolidBrush get_DarkSlateGray();
    public static GeoSolidBrush get_DarkTurquoise();
    public static GeoSolidBrush get_DarkViolet();
    public static GeoSolidBrush get_DeepPink();
    public static GeoSolidBrush get_DeepSkyBlue();
    public static GeoSolidBrush get_DimGray();
    public static GeoSolidBrush get_DodgerBlue();
    public static GeoSolidBrush get_Firebrick();
    public static GeoSolidBrush get_FloralWhite();
    public static GeoSolidBrush get_ForestGreen();
    public static GeoSolidBrush get_Fuchsia();
    public static GeoSolidBrush get_Gainsboro();
    public static GeoSolidBrush get_GhostWhite();
    public static GeoSolidBrush get_Gold();
    public static GeoSolidBrush get_Goldenrod();
    public static GeoSolidBrush get_Gray();
    public static GeoSolidBrush get_Green();
    public static GeoSolidBrush get_GreenYellow();
    public static GeoSolidBrush get_HoneyDew();
    public static GeoSolidBrush get_HotPink();
    public static GeoSolidBrush get_IndianRed();
    public static GeoSolidBrush get_Indigo();
    public static GeoSolidBrush get_Ivory();
    public static GeoSolidBrush get_Khaki();
    public static GeoSolidBrush get_Lavender();
    public static GeoSolidBrush get_LavenderBlush();
    public static GeoSolidBrush get_LawnGreen();
    public static GeoSolidBrush get_LemonChiffon();
    public static GeoSolidBrush get_LightBlue();
    public static GeoSolidBrush get_LightCoral();
    public static GeoSolidBrush get_LightCyan();
    public static GeoSolidBrush get_LightGoldenrodYellow();
    public static GeoSolidBrush get_LightGray();
    public static GeoSolidBrush get_LightGreen();
    public static GeoSolidBrush get_LightPink();
    public static GeoSolidBrush get_LightRed();
    public static GeoSolidBrush get_LightSalmon();
    public static GeoSolidBrush get_LightSeaGreen();
    public static GeoSolidBrush get_LightSkyBlue();
    public static GeoSolidBrush get_LightSlateGray();
    public static GeoSolidBrush get_LightSteelBlue();
    public static GeoSolidBrush get_LightYellow();
    public static GeoSolidBrush get_Lime();
    public static GeoSolidBrush get_LimeGreen();
    public static GeoSolidBrush get_Linen();
    public static GeoSolidBrush get_Magenta();
    public static GeoSolidBrush get_Maroon();
    public static GeoSolidBrush get_MediumAquamarine();
    public static GeoSolidBrush get_MediumBlue();
    public static GeoSolidBrush get_MediumOrchid();
    public static GeoSolidBrush get_MediumPurple();
    public static GeoSolidBrush get_MediumSeaGreen();
    public static GeoSolidBrush get_MediumSlateBlue();
    public static GeoSolidBrush get_MediumSpringGreen();
    public static GeoSolidBrush get_MediumTurquoise();
    public static GeoSolidBrush get_MediumVioletRed();
    public static GeoSolidBrush get_MidnightBlue();
    public static GeoSolidBrush get_MintCream();
    public static GeoSolidBrush get_MistyRose();
    public static GeoSolidBrush get_Moccasin();
    public static GeoSolidBrush get_NavajoWhite();
    public static GeoSolidBrush get_Navy();
    public static GeoSolidBrush get_OldLace();
    public static GeoSolidBrush get_Olive();
    public static GeoSolidBrush get_OliveDrab();
    public static GeoSolidBrush get_Orange();
    public static GeoSolidBrush get_OrangeRed();
    public static GeoSolidBrush get_Orchid();
    public static GeoSolidBrush get_PaleGoldenrod();
    public static GeoSolidBrush get_PaleGreen();
    public static GeoSolidBrush get_PaleTurquoise();
    public static GeoSolidBrush get_PaleVioletRed();
    public static GeoSolidBrush get_PapayaWhip();
    public static GeoSolidBrush get_PeachPuff();
    public static GeoSolidBrush get_Peru();
    public static GeoSolidBrush get_Pink();
    public static GeoSolidBrush get_Plum();
    public static GeoSolidBrush get_PowderBlue();
    public static GeoSolidBrush get_Purple();
    public static GeoSolidBrush get_Red();
    public static GeoSolidBrush get_RosyBrown();
    public static GeoSolidBrush get_RoyalBlue();
    public static GeoSolidBrush get_SaddleBrown();
    public static GeoSolidBrush get_Salmon();
    public static GeoSolidBrush get_SandyBrown();
    public static GeoSolidBrush get_SeaGreen();
    public static GeoSolidBrush get_SeaShell();
    public static GeoSolidBrush get_Sienna();
    public static GeoSolidBrush get_Silver();
    public static GeoSolidBrush get_SkyBlue();
    public static GeoSolidBrush get_SlateBlue();
    public static GeoSolidBrush get_SlateGray();
    public static GeoSolidBrush get_Snow();
    public static GeoSolidBrush get_SpringGreen();
    public static GeoSolidBrush get_SteelBlue();
    public static GeoSolidBrush get_Tan();
    public static GeoSolidBrush get_Teal();
    public static GeoSolidBrush get_Thistle();
    public static GeoSolidBrush get_Tomato();
    public static GeoSolidBrush get_Turquoise();
    public static GeoSolidBrush get_Violet();
    public static GeoSolidBrush get_Wheat();
    public static GeoSolidBrush get_White();
    public static GeoSolidBrush get_WhiteSmoke();
    public static GeoSolidBrush get_Yellow();
    public static GeoSolidBrush get_YellowGreen();
    public static GeoSolidBrush get_DarkYellow();
    public static GeoSolidBrush get_LightOrange();
    public static GeoSolidBrush get_PaleRed();
    public static GeoSolidBrush get_PaleBlue();
    public static GeoSolidBrush get_PaleYellow();
    public static GeoSolidBrush get_PaleOrange();
    public static GeoSolidBrush get_BrightRed();
    public static GeoSolidBrush get_BrightBlue();
    public static GeoSolidBrush get_BrightYellow();
    public static GeoSolidBrush get_BrightOrange();
    public static GeoSolidBrush get_PastelRed();
    public static GeoSolidBrush get_PastelBlue();
    public static GeoSolidBrush get_PastelYellow();
    public static GeoSolidBrush get_PastelGreen();
    public static GeoSolidBrush get_PastelOrange();
    public static GeoSolidBrush get_Copper();
}
public enum ThinkGeo.Core.GeoBrushWrapMode : Enum {
    public int value__;
    public static GeoBrushWrapMode Tile;
    public static GeoBrushWrapMode Clamp;
    public static GeoBrushWrapMode TileFlipX;
    public static GeoBrushWrapMode TileFlipY;
    public static GeoBrushWrapMode TileFlipXY;
}
public abstract class ThinkGeo.Core.GeoCanvas : object {
    private static int JxU=;
    private static int KBU=;
    private static int KRU=;
    private static int KhU=;
    private static int KxU=;
    private static int LBU=;
    private static int LRU=;
    private static int LhU=;
    [ObfuscationAttribute]
private int progressDrawingRaisingFrenquency;
    [ObfuscationAttribute]
private int progressDrawingRaisedCount;
    [ObfuscationAttribute]
private bool isDrawing;
    [ObfuscationAttribute]
private float width;
    [ObfuscationAttribute]
private float height;
    [ObfuscationAttribute]
private double worldToScreenFactorX;
    [ObfuscationAttribute]
private double worldToScreenFactorY;
    [ObfuscationAttribute]
private object nativeImage;
    [ObfuscationAttribute]
private RectangleShape currentWorldExtent;
    [ObfuscationAttribute]
private DrawingQuality drawingQuality;
    [ObfuscationAttribute]
private GeographyUnit mapUnit;
    [ObfuscationAttribute]
private float dpi;
    [ObfuscationAttribute]
private Collection`1<GeoColor> keyColors;
    [ObfuscationAttribute]
private double currentScale;
    [ObfuscationAttribute]
private float scaleFactor;
    [ObfuscationAttribute]
private CancellationToken cancellationToken;
    [ObfuscationAttribute]
private Dictionary`2<int, GeoPen> CachedScaledPen;
    [ObfuscationAttribute]
private RectangleShape clippingArea;
    [CompilerGeneratedAttribute]
private EventHandler`1<DrawingProgressChangedEventArgs> LxU=;
    [CompilerGeneratedAttribute]
private double MBU=;
    public double CurrentScale { get; }
    public double FontDisplayDensity { get; }
    public DrawingQuality DrawingQuality { get; public set; }
    public GeographyUnit MapUnit { get; }
    public float Width { get; protected set; }
    public float Height { get; protected set; }
    public RectangleShape CurrentWorldExtent { get; protected set; }
    public bool SupportKeyColor { get; }
    public Collection`1<GeoColor> KeyColors { get; }
    public object NativeImage { get; }
    public bool IsDrawing { get; protected set; }
    public float Dpi { get; public set; }
    public float ScaleFactor { get; public set; }
    public CancellationToken CancellationToken { get; public set; }
    public RectangleShape ClippingArea { get; public set; }
    private bool MhU= { get; }
    [CompilerGeneratedAttribute]
public void add_DrawingProgressChanged(EventHandler`1<DrawingProgressChangedEventArgs> value);
    [CompilerGeneratedAttribute]
public void remove_DrawingProgressChanged(EventHandler`1<DrawingProgressChangedEventArgs> value);
    public double get_CurrentScale();
    [CompilerGeneratedAttribute]
public virtual double get_FontDisplayDensity();
    public DrawingQuality get_DrawingQuality();
    public void set_DrawingQuality(DrawingQuality value);
    public GeographyUnit get_MapUnit();
    public float get_Width();
    protected void set_Width(float value);
    public float get_Height();
    protected void set_Height(float value);
    public RectangleShape get_CurrentWorldExtent();
    protected void set_CurrentWorldExtent(RectangleShape value);
    public virtual bool get_SupportKeyColor();
    public Collection`1<GeoColor> get_KeyColors();
    public object get_NativeImage();
    public bool get_IsDrawing();
    protected void set_IsDrawing(bool value);
    public virtual float get_Dpi();
    public virtual void set_Dpi(float value);
    public float get_ScaleFactor();
    public void set_ScaleFactor(float value);
    public CancellationToken get_CancellationToken();
    public void set_CancellationToken(CancellationToken value);
    public RectangleShape get_ClippingArea();
    public void set_ClippingArea(RectangleShape value);
    public void Clear(GeoBrush fillBrush);
    protected virtual void ClearCore(GeoBrush fillBrush);
    public void DrawArc(GeoPen pen, DrawingRectangleF rect, float startAngle, float sweepAngle, DrawingLevel drawingLevel);
    public void DrawArc(GeoPen pen, float x, float y, float width, float height, float startAngle, float sweepAngle, DrawingLevel drawingLevel);
    protected abstract virtual void DrawArcCore(GeoPen pen, float x, float y, float width, float height, float startAngle, float sweepAngle, DrawingLevel drawingLevel);
    public void DrawArea(Feature feature, GeoPen outlinePen, DrawingLevel drawingLevel);
    public void DrawArea(AreaBaseShape shape, GeoPen outlinePen, DrawingLevel drawingLevel);
    public void DrawArea(Feature feature, GeoBrush fillBrush, DrawingLevel drawingLevel);
    public void DrawArea(AreaBaseShape shape, GeoBrush fillBrush, DrawingLevel drawingLevel);
    public void DrawArea(Feature feature, GeoPen outlinePen, GeoBrush fillBrush, DrawingLevel drawingLevel);
    public void DrawArea(AreaBaseShape shape, GeoPen outlinePen, GeoBrush fillBrush, DrawingLevel drawingLevel);
    public void DrawArea(Feature feature, GeoPen outlinePen, GeoBrush fillBrush, DrawingLevel drawingLevel, float xOffset, float yOffset, PenBrushDrawingOrder penBrushDrawingOrder);
    public void DrawArea(AreaBaseShape shape, GeoPen outlinePen, GeoBrush fillBrush, DrawingLevel drawingLevel, float xOffset, float yOffset, PenBrushDrawingOrder penBrushDrawingOrder);
    private List`1<List`1<ScreenPointF[]>> MxU=(Byte[] areaShapeWkb, byte byteOrder);
    public void DrawArea(IEnumerable`1<ScreenPointF[]> screenPoints, GeoPen outlinePen, GeoBrush fillBrush, DrawingLevel drawingLevel, float xOffset, float yOffset, PenBrushDrawingOrder penBrushDrawingOrder);
    protected abstract virtual void DrawAreaCore(IEnumerable`1<ScreenPointF[]> screenPoints, GeoPen outlinePen, GeoBrush fillBrush, DrawingLevel drawingLevel, float xOffset, float yOffset, PenBrushDrawingOrder penBrushDrawingOrder);
    public void DrawLine(Feature feature, GeoPen linePen, DrawingLevel drawingLevel);
    public void DrawLine(LineBaseShape shape, GeoPen linePen, DrawingLevel drawingLevel);
    public void DrawLine(Feature feature, GeoPen linePen, DrawingLevel drawingLevel, float xOffset, float yOffset);
    public void DrawLine(LineBaseShape shape, GeoPen linePen, DrawingLevel drawingLevel, float xOffset, float yOffset);
    public void DrawLine(IEnumerable`1<ScreenPointF> screenPoints, GeoPen linePen, DrawingLevel drawingLevel, float xOffset, float yOffset);
    protected abstract virtual void DrawLineCore(IEnumerable`1<ScreenPointF> screenPoints, GeoPen linePen, DrawingLevel drawingLevel, float xOffset, float yOffset);
    public void DrawEllipse(Feature feature, float width, float height, GeoPen outlinePen, DrawingLevel drawingLevel);
    public void DrawEllipse(PointBaseShape shape, float width, float height, GeoPen outlinePen, DrawingLevel drawingLevel);
    public void DrawEllipse(Feature centerPointFeature, float width, float height, GeoBrush fillBrush, DrawingLevel drawingLevel);
    public void DrawEllipse(PointBaseShape shape, float width, float height, GeoBrush fillBrush, DrawingLevel drawingLevel);
    public void DrawEllipse(Feature feature, float width, float height, GeoPen outlinePen, GeoBrush fillBrush, DrawingLevel drawingLevel);
    public void DrawEllipse(PointBaseShape shape, float width, float height, GeoPen outlinePen, GeoBrush fillBrush, DrawingLevel drawingLevel);
    public void DrawEllipse(Feature feature, float width, float height, GeoPen outlinePen, GeoBrush fillBrush, DrawingLevel drawingLevel, float xOffset, float yOffset, PenBrushDrawingOrder penBrushDrawingOrder);
    public void DrawEllipse(PointBaseShape shape, float width, float height, GeoPen outlinePen, GeoBrush fillBrush, DrawingLevel drawingLevel, float xOffset, float yOffset, PenBrushDrawingOrder penBrushDrawingOrder);
    public void DrawEllipse(ScreenPointF screenPoint, float width, float height, GeoPen outlinePen, GeoBrush fillBrush, DrawingLevel drawingLevel, float xOffset, float yOffset, PenBrushDrawingOrder penBrushDrawingOrder);
    protected abstract virtual void DrawEllipseCore(ScreenPointF screenPoint, float width, float height, GeoPen outlinePen, GeoBrush fillBrush, DrawingLevel drawingLevel, float xOffset, float yOffset, PenBrushDrawingOrder penBrushDrawingOrder);
    public void DrawWorldImageWithoutScaling(GeoImage image, double centerXInWorld, double centerYInWorld, DrawingLevel drawingLevel);
    public void DrawWorldImageWithoutScaling(GeoImage image, double centerXInWorld, double centerYInWorld, DrawingLevel drawingLevel, float xOffset, float yOffset, float rotateAngle);
    public void DrawScreenImageWithoutScaling(GeoImage image, float centerXInScreen, float centerYInScreen, DrawingLevel drawingLevel, float xOffset, float yOffset, float rotateAngle);
    protected abstract virtual void DrawScreenImageWithoutScalingCore(GeoImage image, float centerXInScreen, float centerYInScreen, DrawingLevel drawingLevel, float xOffset, float yOffset, float rotateAngle);
    public void DrawWorldImage(GeoImage image, double centerXInWorld, double centerYInWorld, float widthInScreen, float heightInScreen, DrawingLevel drawingLevel);
    public void DrawWorldImage(GeoImage image, double centerXInWorld, double centerYInWorld, double imageScale, DrawingLevel drawingLevel, float xOffset, float yOffset, float rotateAngle);
    public void DrawWorldImage(GeoImage image, double centerXInWorld, double centerYInWorld, float widthInScreen, float heightInScreen, DrawingLevel drawingLevel, float xOffset, float yOffset, float rotateAngle);
    public void DrawScreenImage(GeoImage image, float centerXInScreen, float centerYInScreen, float widthInScreen, float heightInScreen, DrawingLevel drawingLevel, float xOffset, float yOffset, float rotateAngle);
    protected abstract virtual void DrawScreenImageCore(GeoImage image, float centerXInScreen, float centerYInScreen, float widthInScreen, float heightInScreen, DrawingLevel drawingLevel, float xOffset, float yOffset, float rotateAngle);
    public void DrawTextWithScreenCoordinate(string text, GeoFont font, GeoBrush fillBrush, float upperLeftXInScreen, float upperLeftYInScreen, DrawingLevel drawingLevel);
    public void DrawTextWithScreenCoordinate(string text, GeoFont font, GeoBrush fillBrush, GeoPen haloPen, float upperLeftXInScreen, float upperLeftYInScreen, DrawingLevel drawingLevel);
    public void DrawTextWithWorldCoordinate(string text, GeoFont font, GeoBrush fillBrush, double upperLeftXInWorld, double upperLeftYInWorld, DrawingLevel drawingLevel, DrawingTextAlignment drawingTextAlignment);
    public void DrawTextWithWorldCoordinate(string text, GeoFont font, GeoBrush fillBrush, GeoPen haloPen, double upperLeftXInWorld, double upperLeftYInWorld, DrawingLevel drawingLevel, DrawingTextAlignment drawingTextAlignment);
    public void DrawText(string text, GeoFont font, GeoBrush fillBrush, IEnumerable`1<ScreenPointF> textPathInScreen, DrawingLevel drawingLevel);
    public void DrawText(string text, GeoFont font, GeoBrush fillBrush, GeoPen haloPen, IEnumerable`1<ScreenPointF> textPathInScreen, DrawingLevel drawingLevel, float xOffset, float yOffset, DrawingTextAlignment drawingTextAlignment);
    public void DrawText(string text, GeoFont font, GeoBrush fillBrush, GeoPen haloPen, IEnumerable`1<ScreenPointF> textPathInScreen, DrawingLevel drawingLevel, float xOffset, float yOffset, DrawingTextAlignment drawingTextAlignment, float rotateAngle);
    protected abstract virtual void DrawTextCore(string text, GeoFont font, GeoBrush fillBrush, GeoPen haloPen, IEnumerable`1<ScreenPointF> textPathInScreen, DrawingLevel drawingLevel, float xOffset, float yOffset, DrawingTextAlignment drawingTextAlignment, float rotateAngle);
    public DrawingRectangleF MeasureText(string text, GeoFont font);
    protected abstract virtual DrawingRectangleF MeasureTextCore(string text, GeoFont font);
    public void BeginDrawing(object geoImage, RectangleShape worldExtent, GeographyUnit drawingMapUnit);
    protected abstract virtual void BeginDrawingCore(object nativeImage, RectangleShape worldExtent, GeographyUnit drawingMapUnit);
    public void EndDrawing();
    protected float GetCanvasWidth();
    protected abstract virtual float GetCanvasWidthCore();
    protected float GetCanvasHeight();
    protected abstract virtual float GetCanvasHeightCore();
    public static GeoCanvas CreateDefaultGeoCanvas();
    private void NBU=();
    private void NRU=(string waterMarkedString);
    private List`1<ScreenPointF[]> NhU=(Byte[] areaShapeWkb);
    private int NxU=(ScreenPointF[]& areaPoints, Byte[] wkb, int dataIndex, byte byteOrder);
    private int OBU=(Byte[] lineShapeWkb, int startIndex, float xOffset, float yOffset, DrawingLevel drawingLevel, GeoPen linePen);
    private void ORU=(Double& screenX, Double& screenY);
    private int OhU=(Byte[] centerPointWkb, int startIndex, float width, float height, GeoPen outlinePen, GeoBrush fillBrush, DrawingLevel drawingLevel, float xOffset, float yOffset, PenBrushDrawingOrder penBrushDrawingOrder);
    protected abstract virtual void EndDrawingCore();
    public void Flush();
    protected abstract virtual void FlushCore();
    protected virtual void OnDrawingProgressChanged(DrawingProgressChangedEventArgs e);
    public double MeasureOffset(double offsetInPixel);
    protected virtual double MeasureOffsetCore(double offsetInPixel);
    private bool MRU=();
    internal RectangleShape OxU=(DrawingRectangleF drawingRectangle);
    private GeoPen PBU=(GeoPen pen);
    private static int PRU=(Byte[] wkb, int startIndex, byte byteOrder);
    private static double PhU=(Byte[] wkb, int startIndex, byte byteOrder);
    internal virtual float PxU=(GeoFont font, DrawingTextBaseline textBaseline, string text);
}
public class ThinkGeo.Core.GeocodingCloudClient : CloudClient {
    public GeocodingCloudClient(string clientId, string clientSecret);
    public CloudGeocodingResult Search(string location);
    public CloudGeocodingResult Search(string location, CloudGeocodingOptions options);
    [AsyncStateMachineAttribute("ThinkGeo.Core.GeocodingCloudClient/Rj4=")]
public Task`1<CloudGeocodingResult> SearchAsync(string location);
    [AsyncStateMachineAttribute("ThinkGeo.Core.GeocodingCloudClient/SD4=")]
public Task`1<CloudGeocodingResult> SearchAsync(string location, CloudGeocodingOptions options);
    public Collection`1<CloudGeocodingResult> Search(IEnumerable`1<string> locations);
    public Collection`1<CloudGeocodingResult> Search(IEnumerable`1<string> locations, CloudGeocodingOptions options);
    [AsyncStateMachineAttribute("ThinkGeo.Core.GeocodingCloudClient/Sj4=")]
public Task`1<Collection`1<CloudGeocodingResult>> SearchAsync(IEnumerable`1<string> locations);
    [AsyncStateMachineAttribute("ThinkGeo.Core.GeocodingCloudClient/TD4=")]
public Task`1<Collection`1<CloudGeocodingResult>> SearchAsync(IEnumerable`1<string> locations, CloudGeocodingOptions options);
    private CloudGeocodingResult 3RQ=(string location, CloudGeocodingOptions options);
    [AsyncStateMachineAttribute("ThinkGeo.Core.GeocodingCloudClient/TT4=")]
private Task`1<CloudGeocodingResult> 3hQ=(string location, CloudGeocodingOptions options);
    private Collection`1<CloudGeocodingResult> 3RQ=(IEnumerable`1<string> locations, CloudGeocodingOptions options);
    [AsyncStateMachineAttribute("ThinkGeo.Core.GeocodingCloudClient/Tj4=")]
private Task`1<Collection`1<CloudGeocodingResult>> 3hQ=(IEnumerable`1<string> locations, CloudGeocodingOptions options);
    private static string 3xQ=(CloudGeocodingOptions options);
    private static string 4BQ=(IEnumerable`1<string> locations, CloudGeocodingOptions options);
    private static CloudGeocodingResult 4RQ=(WebResponse response);
    private static Collection`1<CloudGeocodingResult> 4hQ=(WebResponse response);
}
[ObfuscationAttribute]
public class ThinkGeo.Core.GeocodingLocationDto : object {
    [CompilerGeneratedAttribute]
private LocationPoint <LocationPoint>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Address>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Name>k__BackingField;
    [CompilerGeneratedAttribute]
private string <LocationType>k__BackingField;
    [CompilerGeneratedAttribute]
private string <BoundingBox>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Geometry>k__BackingField;
    [CompilerGeneratedAttribute]
private Dictionary`2<string, string> <Properties>k__BackingField;
    [CompilerGeneratedAttribute]
private Dictionary`2<string, string> <AddressComponents>k__BackingField;
    [CompilerGeneratedAttribute]
private string <HouseNumber>k__BackingField;
    public LocationPoint LocationPoint { get; public set; }
    public string Address { get; public set; }
    public string Name { get; public set; }
    public string LocationType { get; public set; }
    public string BoundingBox { get; public set; }
    public string Geometry { get; public set; }
    public Dictionary`2<string, string> Properties { get; public set; }
    public Dictionary`2<string, string> AddressComponents { get; public set; }
    public string HouseNumber { get; public set; }
    [CompilerGeneratedAttribute]
public LocationPoint get_LocationPoint();
    [CompilerGeneratedAttribute]
public void set_LocationPoint(LocationPoint value);
    [CompilerGeneratedAttribute]
public string get_Address();
    [CompilerGeneratedAttribute]
public void set_Address(string value);
    [CompilerGeneratedAttribute]
public string get_Name();
    [CompilerGeneratedAttribute]
public void set_Name(string value);
    [CompilerGeneratedAttribute]
public string get_LocationType();
    [CompilerGeneratedAttribute]
public void set_LocationType(string value);
    [CompilerGeneratedAttribute]
public string get_BoundingBox();
    [CompilerGeneratedAttribute]
public void set_BoundingBox(string value);
    [CompilerGeneratedAttribute]
public string get_Geometry();
    [CompilerGeneratedAttribute]
public void set_Geometry(string value);
    [CompilerGeneratedAttribute]
public Dictionary`2<string, string> get_Properties();
    [CompilerGeneratedAttribute]
public void set_Properties(Dictionary`2<string, string> value);
    [CompilerGeneratedAttribute]
public Dictionary`2<string, string> get_AddressComponents();
    [CompilerGeneratedAttribute]
public void set_AddressComponents(Dictionary`2<string, string> value);
    [CompilerGeneratedAttribute]
public string get_HouseNumber();
    [CompilerGeneratedAttribute]
public void set_HouseNumber(string value);
    public CloudGeocodingLocation ToGeocodingLocation();
}
[DefaultMemberAttribute("Item")]
public class ThinkGeo.Core.GeoCollection`1 : Collection`1<T> {
    [ObfuscationAttribute]
private Dictionary`2<string, T> dictionary;
    [ObfuscationAttribute]
private Dictionary`2<int, string> mappingCache;
    [CompilerGeneratedAttribute]
private EventHandler`1<InsertingGeoCollectionEventArgs> qRU=;
    [CompilerGeneratedAttribute]
private EventHandler`1<InsertedGeoCollectionEventArgs> qhU=;
    [CompilerGeneratedAttribute]
private EventHandler`1<RemovingGeoCollectionEventArgs> qxU=;
    [CompilerGeneratedAttribute]
private EventHandler`1<RemovedGeoCollectionEventArgs> rBU=;
    [CompilerGeneratedAttribute]
private EventHandler`1<AddingGeoCollectionEventArgs> rRU=;
    [CompilerGeneratedAttribute]
private EventHandler`1<AddedGeoCollectionEventArgs> rhU=;
    [CompilerGeneratedAttribute]
private EventHandler`1<ClearingItemsGeoCollectionEventArgs> rxU=;
    [CompilerGeneratedAttribute]
private EventHandler`1<ClearedItemsGeoCollectionEventArgs> sBU=;
    [CompilerGeneratedAttribute]
private EventHandler`1<MovedItemGeoCollectionEventArgs> sRU=;
    [CompilerGeneratedAttribute]
private NotifyCollectionChangedEventHandler shU=;
    [CompilerGeneratedAttribute]
private PropertyChangedEventHandler sxU=;
    public T Item { get; public set; }
    [CompilerGeneratedAttribute]
public void add_Inserting(EventHandler`1<InsertingGeoCollectionEventArgs> value);
    [CompilerGeneratedAttribute]
public void remove_Inserting(EventHandler`1<InsertingGeoCollectionEventArgs> value);
    [CompilerGeneratedAttribute]
public void add_Inserted(EventHandler`1<InsertedGeoCollectionEventArgs> value);
    [CompilerGeneratedAttribute]
public void remove_Inserted(EventHandler`1<InsertedGeoCollectionEventArgs> value);
    [CompilerGeneratedAttribute]
public void add_Removing(EventHandler`1<RemovingGeoCollectionEventArgs> value);
    [CompilerGeneratedAttribute]
public void remove_Removing(EventHandler`1<RemovingGeoCollectionEventArgs> value);
    [CompilerGeneratedAttribute]
public void add_Removed(EventHandler`1<RemovedGeoCollectionEventArgs> value);
    [CompilerGeneratedAttribute]
public void remove_Removed(EventHandler`1<RemovedGeoCollectionEventArgs> value);
    [CompilerGeneratedAttribute]
public void add_Adding(EventHandler`1<AddingGeoCollectionEventArgs> value);
    [CompilerGeneratedAttribute]
public void remove_Adding(EventHandler`1<AddingGeoCollectionEventArgs> value);
    [CompilerGeneratedAttribute]
public void add_Added(EventHandler`1<AddedGeoCollectionEventArgs> value);
    [CompilerGeneratedAttribute]
public void remove_Added(EventHandler`1<AddedGeoCollectionEventArgs> value);
    [CompilerGeneratedAttribute]
public void add_ClearingItems(EventHandler`1<ClearingItemsGeoCollectionEventArgs> value);
    [CompilerGeneratedAttribute]
public void remove_ClearingItems(EventHandler`1<ClearingItemsGeoCollectionEventArgs> value);
    [CompilerGeneratedAttribute]
public void add_ClearedItems(EventHandler`1<ClearedItemsGeoCollectionEventArgs> value);
    [CompilerGeneratedAttribute]
public void remove_ClearedItems(EventHandler`1<ClearedItemsGeoCollectionEventArgs> value);
    [CompilerGeneratedAttribute]
public void add_MovedItem(EventHandler`1<MovedItemGeoCollectionEventArgs> value);
    [CompilerGeneratedAttribute]
public void remove_MovedItem(EventHandler`1<MovedItemGeoCollectionEventArgs> value);
    protected virtual void OnInserting(InsertingGeoCollectionEventArgs e);
    protected virtual void OnInserted(InsertedGeoCollectionEventArgs e);
    protected virtual void OnRemoving(RemovingGeoCollectionEventArgs e);
    protected virtual void OnRemoved(RemovedGeoCollectionEventArgs e);
    protected virtual void OnAdding(AddingGeoCollectionEventArgs e);
    protected virtual void OnAdded(AddedGeoCollectionEventArgs e);
    protected virtual void OnClearingItems(ClearingItemsGeoCollectionEventArgs e);
    protected virtual void OnClearedItems(ClearedItemsGeoCollectionEventArgs e);
    protected virtual void OnMovedItem(MovedItemGeoCollectionEventArgs e);
    public T get_Item(string key);
    public void set_Item(string key, T value);
    public Collection`1<string> GetKeys();
    public void Add(string key, T item);
    public void Add(T item);
    public void Insert(int index, T item);
    protected virtual void InsertItem(int index, T item);
    public void Insert(int index, string key, T item);
    public void Remove(string key);
    protected virtual void RemoveItem(int index);
    public void MoveUp(int index);
    public void MoveUp(string key);
    public void MoveUp(T item);
    public void MoveDown(int index);
    public void MoveDown(string key);
    public void MoveDown(T item);
    public void MoveToTop(int index);
    public void MoveToTop(string key);
    public void MoveToTop(T item);
    public void MoveToBottom(int index);
    public void MoveToBottom(string key);
    public void MoveToBottom(T item);
    public void MoveTo(int fromIndex, int toIndex);
    public void MoveTo(string key, int toIndex);
    public void MoveTo(T item, int toIndex);
    public bool Contains(string key);
    protected virtual void ClearItems();
    protected virtual void SetItem(int index, T item);
    private int tBU=(string key);
    private string tRU=(T item);
    private void thU=(string key);
    [CompilerGeneratedAttribute]
public sealed virtual void add_CollectionChanged(NotifyCollectionChangedEventHandler value);
    [CompilerGeneratedAttribute]
public sealed virtual void remove_CollectionChanged(NotifyCollectionChangedEventHandler value);
    protected virtual void OnCollectionChanged(NotifyCollectionChangedEventArgs e);
    [CompilerGeneratedAttribute]
public sealed virtual void add_PropertyChanged(PropertyChangedEventHandler value);
    [CompilerGeneratedAttribute]
public sealed virtual void remove_PropertyChanged(PropertyChangedEventHandler value);
    protected virtual void OnPropertyChanged(PropertyChangedEventArgs e);
}
[DebuggerDisplayAttribute("{NameAndARGBValue}")]
public class ThinkGeo.Core.GeoColor : object {
    private static float iBU=;
    private static float iRU=;
    private static float ihU=;
    private static float ixU=;
    [ObfuscationAttribute]
private byte alphaComponent;
    [ObfuscationAttribute]
private byte redComponent;
    [ObfuscationAttribute]
private byte greenComponent;
    [ObfuscationAttribute]
private byte blueComponent;
    [ObfuscationAttribute]
private string name;
    [ObfuscationAttribute]
private ColorType colorType;
    [ObfuscationAttribute]
private static Random random;
    private static Regex jBU=;
    private static Regex jRU=;
    private static Regex jhU=;
    private static Regex jxU=;
    public bool IsTransparent { get; }
    public string HtmlColor { get; public set; }
    public string Ahsl { get; public set; }
    public string Argb { get; public set; }
    public byte A { get; public set; }
    public byte R { get; public set; }
    public byte G { get; public set; }
    public byte B { get; public set; }
    public float Hue { get; }
    public float Saturation { get; }
    public float Luminance { get; }
    [ObfuscationAttribute]
private string NameAndARGBValue { get; }
    public GeoColor(byte red, byte green, byte blue);
    public GeoColor(byte alpha, byte red, byte green, byte blue);
    public GeoColor(byte alpha, GeoColor color);
    internal GeoColor(string name, ColorType colorType, byte alpha, byte red, byte green, byte blue);
    private static GeoColor();
    public bool get_IsTransparent();
    public string get_HtmlColor();
    public void set_HtmlColor(string value);
    public string get_Ahsl();
    public void set_Ahsl(string value);
    public string get_Argb();
    public void set_Argb(string value);
    public byte get_A();
    public void set_A(byte value);
    public byte get_R();
    public void set_R(byte value);
    public byte get_G();
    public void set_G(byte value);
    public byte get_B();
    public void set_B(byte value);
    public float get_Hue();
    public float get_Saturation();
    public float get_Luminance();
    private string get_NameAndARGBValue();
    public static Collection`1<GeoColor> GetColorsInHueFamily(GeoColor baseColor, int numbersOfColors);
    private static float kBU=(float saturation, float ratio);
    private static float kRU=(float luminance, float ratio);
    public static Collection`1<GeoColor> GetColorsInQualityFamily(GeoColor baseColor, int numberOfColors);
    public static Collection`1<GeoColor> GetColorsInQualityFamily(GeoColor fromColor, GeoColor toColor, int numberOfColors, ColorWheelDirection colorWheelDirection);
    private static float khU=(float hue, float ratio);
    public static GeoColor FromArgb(byte alpha, byte red, byte green, byte blue);
    public static GeoColor FromArgb(byte alpha, GeoColor baseColor);
    public static GeoColor FromAhsl(int alpha, float hue, float saturation, float luminance);
    public static GeoColor FromOle(int oleColor);
    public static GeoColor FromHtml(string htmlColor);
    internal static GeoColor kxU=(string colorExpression);
    private static string lBU=(string htmlColor);
    private static GeoColor lRU=(string htmlColor);
    public static GeoColor GetRandomGeoColor(RandomColorType colorType);
    public static GeoColor GetRandomGeoColor(byte alpha, RandomColorType colorType);
    public static GeoColor FromWin32(int win32Color);
    public static int ToOle(GeoColor color);
    public static string ToHtml(GeoColor color);
    public static int ToWin32(GeoColor color);
    public virtual string ToString();
    public static bool op_Equality(GeoColor geoColor1, GeoColor geoColor2);
    public static bool op_Inequality(GeoColor geoColor1, GeoColor geoColor2);
    public virtual bool Equals(object obj);
    private bool lhU=(GeoColor compareObj);
    public virtual int GetHashCode();
    private static GeoColor lxU=(float hueIn0To360Format, float saturation, float luminance);
    private static byte mBU=(double v1, double v2, double vH);
    private static void mRU=(GeoColor geoColor, Single& hue, Single& saturation, Single& luminance);
    [CompilerGeneratedAttribute]
internal static Double[] mhU=(GroupCollection groups);
}
public static class ThinkGeo.Core.GeoColors : object {
    public static GeoColor Sand { get; }
    public static GeoColor Grass { get; }
    public static GeoColor Dirt { get; }
    public static GeoColor Mountains { get; }
    public static GeoColor Lake { get; }
    public static GeoColor DeepOcean { get; }
    public static GeoColor ShallowOcean { get; }
    public static GeoColor Tundra { get; }
    public static GeoColor Forest { get; }
    public static GeoColor Ice { get; }
    public static GeoColor Swamp { get; }
    public static GeoColor Road { get; }
    public static GeoColor Highway { get; }
    public static GeoColor InnerState { get; }
    public static GeoColor LocalRoad { get; }
    public static GeoColor MajorRoad { get; }
    public static GeoColor ActiveBorder { get; }
    public static GeoColor ActiveCaption { get; }
    public static GeoColor ActiveCaptionText { get; }
    public static GeoColor AppWorkspace { get; }
    public static GeoColor Control { get; }
    public static GeoColor ControlDark { get; }
    public static GeoColor ControlDarkDark { get; }
    public static GeoColor ControlLight { get; }
    public static GeoColor ControlLightLight { get; }
    public static GeoColor ControlText { get; }
    public static GeoColor Desktop { get; }
    public static GeoColor GrayText { get; }
    public static GeoColor Highlight { get; }
    public static GeoColor HighlightText { get; }
    public static GeoColor HotTrack { get; }
    public static GeoColor InactiveBorder { get; }
    public static GeoColor InactiveCaption { get; }
    public static GeoColor InactiveCaptionText { get; }
    public static GeoColor Info { get; }
    public static GeoColor InfoText { get; }
    public static GeoColor Menu { get; }
    public static GeoColor MenuText { get; }
    public static GeoColor ScrollBar { get; }
    public static GeoColor Window { get; }
    public static GeoColor WindowFrame { get; }
    public static GeoColor WindowText { get; }
    public static GeoColor Transparent { get; }
    public static GeoColor AliceBlue { get; }
    public static GeoColor AntiqueWhite { get; }
    public static GeoColor Aqua { get; }
    public static GeoColor Aquamarine { get; }
    public static GeoColor Azure { get; }
    public static GeoColor Beige { get; }
    public static GeoColor Bisque { get; }
    public static GeoColor Black { get; }
    public static GeoColor BlanchedAlmond { get; }
    public static GeoColor Blue { get; }
    public static GeoColor BlueViolet { get; }
    public static GeoColor Brown { get; }
    public static GeoColor BurlyWood { get; }
    public static GeoColor CadetBlue { get; }
    public static GeoColor Chartreuse { get; }
    public static GeoColor Chocolate { get; }
    public static GeoColor Coral { get; }
    public static GeoColor CornflowerBlue { get; }
    public static GeoColor Cornsilk { get; }
    public static GeoColor Crimson { get; }
    public static GeoColor Cyan { get; }
    public static GeoColor DarkBlue { get; }
    public static GeoColor DarkCyan { get; }
    public static GeoColor DarkGoldenrod { get; }
    public static GeoColor DarkGray { get; }
    public static GeoColor DarkGreen { get; }
    public static GeoColor DarkKhaki { get; }
    public static GeoColor DarkMagenta { get; }
    public static GeoColor DarkOliveGreen { get; }
    public static GeoColor DarkOrange { get; }
    public static GeoColor DarkOrchid { get; }
    public static GeoColor DarkRed { get; }
    public static GeoColor DarkSalmon { get; }
    public static GeoColor DarkSeaGreen { get; }
    public static GeoColor DarkSlateBlue { get; }
    public static GeoColor DarkSlateGray { get; }
    public static GeoColor DarkTurquoise { get; }
    public static GeoColor DarkViolet { get; }
    public static GeoColor DeepPink { get; }
    public static GeoColor DeepSkyBlue { get; }
    public static GeoColor DimGray { get; }
    public static GeoColor DodgerBlue { get; }
    public static GeoColor Firebrick { get; }
    public static GeoColor FloralWhite { get; }
    public static GeoColor ForestGreen { get; }
    public static GeoColor Fuchsia { get; }
    public static GeoColor Gainsboro { get; }
    public static GeoColor GhostWhite { get; }
    public static GeoColor Gold { get; }
    public static GeoColor Goldenrod { get; }
    public static GeoColor Gray { get; }
    public static GeoColor Green { get; }
    public static GeoColor GreenYellow { get; }
    public static GeoColor Honeydew { get; }
    public static GeoColor HotPink { get; }
    public static GeoColor IndianRed { get; }
    public static GeoColor Indigo { get; }
    public static GeoColor Ivory { get; }
    public static GeoColor Khaki { get; }
    public static GeoColor Lavender { get; }
    public static GeoColor LavenderBlush { get; }
    public static GeoColor LawnGreen { get; }
    public static GeoColor LemonChiffon { get; }
    public static GeoColor LightBlue { get; }
    public static GeoColor LightCoral { get; }
    public static GeoColor LightCyan { get; }
    public static GeoColor LightGoldenrodYellow { get; }
    public static GeoColor LightGray { get; }
    public static GeoColor LightGreen { get; }
    public static GeoColor LightPink { get; }
    public static GeoColor LightSalmon { get; }
    public static GeoColor LightSeaGreen { get; }
    public static GeoColor LightSkyBlue { get; }
    public static GeoColor LightSlateGray { get; }
    public static GeoColor LightSteelBlue { get; }
    public static GeoColor LightYellow { get; }
    public static GeoColor Lime { get; }
    public static GeoColor LimeGreen { get; }
    public static GeoColor Linen { get; }
    public static GeoColor Magenta { get; }
    public static GeoColor Maroon { get; }
    public static GeoColor MediumAquamarine { get; }
    public static GeoColor MediumBlue { get; }
    public static GeoColor MediumOrchid { get; }
    public static GeoColor MediumPurple { get; }
    public static GeoColor MediumSeaGreen { get; }
    public static GeoColor MediumSlateBlue { get; }
    public static GeoColor MediumSpringGreen { get; }
    public static GeoColor MediumTurquoise { get; }
    public static GeoColor MediumVioletRed { get; }
    public static GeoColor MidnightBlue { get; }
    public static GeoColor MintCream { get; }
    public static GeoColor MistyRose { get; }
    public static GeoColor Moccasin { get; }
    public static GeoColor NavajoWhite { get; }
    public static GeoColor Navy { get; }
    public static GeoColor OldLace { get; }
    public static GeoColor Olive { get; }
    public static GeoColor OliveDrab { get; }
    public static GeoColor Orange { get; }
    public static GeoColor OrangeRed { get; }
    public static GeoColor Orchid { get; }
    public static GeoColor PaleGoldenrod { get; }
    public static GeoColor PaleGreen { get; }
    public static GeoColor PaleTurquoise { get; }
    public static GeoColor PaleVioletRed { get; }
    public static GeoColor PapayaWhip { get; }
    public static GeoColor PeachPuff { get; }
    public static GeoColor Peru { get; }
    public static GeoColor Pink { get; }
    public static GeoColor Plum { get; }
    public static GeoColor PowderBlue { get; }
    public static GeoColor Purple { get; }
    public static GeoColor Red { get; }
    public static GeoColor RosyBrown { get; }
    public static GeoColor RoyalBlue { get; }
    public static GeoColor SaddleBrown { get; }
    public static GeoColor Salmon { get; }
    public static GeoColor SandyBrown { get; }
    public static GeoColor SeaGreen { get; }
    public static GeoColor SeaShell { get; }
    public static GeoColor Sienna { get; }
    public static GeoColor Silver { get; }
    public static GeoColor SkyBlue { get; }
    public static GeoColor SlateBlue { get; }
    public static GeoColor SlateGray { get; }
    public static GeoColor Snow { get; }
    public static GeoColor SpringGreen { get; }
    public static GeoColor SteelBlue { get; }
    public static GeoColor Tan { get; }
    public static GeoColor Teal { get; }
    public static GeoColor Thistle { get; }
    public static GeoColor Tomato { get; }
    public static GeoColor Turquoise { get; }
    public static GeoColor Violet { get; }
    public static GeoColor Wheat { get; }
    public static GeoColor White { get; }
    public static GeoColor WhiteSmoke { get; }
    public static GeoColor Yellow { get; }
    public static GeoColor YellowGreen { get; }
    public static GeoColor ButtonFace { get; }
    public static GeoColor ButtonHighlight { get; }
    public static GeoColor ButtonShadow { get; }
    public static GeoColor GradientActiveCaption { get; }
    public static GeoColor GradientInactiveCaption { get; }
    public static GeoColor MenuBar { get; }
    public static GeoColor MenuHighlight { get; }
    public static GeoColor DarkYellow { get; }
    public static GeoColor LightRed { get; }
    public static GeoColor LightOrange { get; }
    public static GeoColor PaleRed { get; }
    public static GeoColor PaleBlue { get; }
    public static GeoColor PaleYellow { get; }
    public static GeoColor PaleOrange { get; }
    public static GeoColor BrightRed { get; }
    public static GeoColor BrightBlue { get; }
    public static GeoColor BrightYellow { get; }
    public static GeoColor BrightGreen { get; }
    public static GeoColor BrightOrange { get; }
    public static GeoColor PastelRed { get; }
    public static GeoColor PastelBlue { get; }
    public static GeoColor PastelYellow { get; }
    public static GeoColor PastelGreen { get; }
    public static GeoColor PastelOrange { get; }
    public static GeoColor Copper { get; }
    public static GeoColor get_Sand();
    public static GeoColor get_Grass();
    public static GeoColor get_Dirt();
    public static GeoColor get_Mountains();
    public static GeoColor get_Lake();
    public static GeoColor get_DeepOcean();
    public static GeoColor get_ShallowOcean();
    public static GeoColor get_Tundra();
    public static GeoColor get_Forest();
    public static GeoColor get_Ice();
    public static GeoColor get_Swamp();
    public static GeoColor get_Road();
    public static GeoColor get_Highway();
    public static GeoColor get_InnerState();
    public static GeoColor get_LocalRoad();
    public static GeoColor get_MajorRoad();
    public static GeoColor get_ActiveBorder();
    public static GeoColor get_ActiveCaption();
    public static GeoColor get_ActiveCaptionText();
    public static GeoColor get_AppWorkspace();
    public static GeoColor get_Control();
    public static GeoColor get_ControlDark();
    public static GeoColor get_ControlDarkDark();
    public static GeoColor get_ControlLight();
    public static GeoColor get_ControlLightLight();
    public static GeoColor get_ControlText();
    public static GeoColor get_Desktop();
    public static GeoColor get_GrayText();
    public static GeoColor get_Highlight();
    public static GeoColor get_HighlightText();
    public static GeoColor get_HotTrack();
    public static GeoColor get_InactiveBorder();
    public static GeoColor get_InactiveCaption();
    public static GeoColor get_InactiveCaptionText();
    public static GeoColor get_Info();
    public static GeoColor get_InfoText();
    public static GeoColor get_Menu();
    public static GeoColor get_MenuText();
    public static GeoColor get_ScrollBar();
    public static GeoColor get_Window();
    public static GeoColor get_WindowFrame();
    public static GeoColor get_WindowText();
    public static GeoColor get_Transparent();
    public static GeoColor get_AliceBlue();
    public static GeoColor get_AntiqueWhite();
    public static GeoColor get_Aqua();
    public static GeoColor get_Aquamarine();
    public static GeoColor get_Azure();
    public static GeoColor get_Beige();
    public static GeoColor get_Bisque();
    public static GeoColor get_Black();
    public static GeoColor get_BlanchedAlmond();
    public static GeoColor get_Blue();
    public static GeoColor get_BlueViolet();
    public static GeoColor get_Brown();
    public static GeoColor get_BurlyWood();
    public static GeoColor get_CadetBlue();
    public static GeoColor get_Chartreuse();
    public static GeoColor get_Chocolate();
    public static GeoColor get_Coral();
    public static GeoColor get_CornflowerBlue();
    public static GeoColor get_Cornsilk();
    public static GeoColor get_Crimson();
    public static GeoColor get_Cyan();
    public static GeoColor get_DarkBlue();
    public static GeoColor get_DarkCyan();
    public static GeoColor get_DarkGoldenrod();
    public static GeoColor get_DarkGray();
    public static GeoColor get_DarkGreen();
    public static GeoColor get_DarkKhaki();
    public static GeoColor get_DarkMagenta();
    public static GeoColor get_DarkOliveGreen();
    public static GeoColor get_DarkOrange();
    public static GeoColor get_DarkOrchid();
    public static GeoColor get_DarkRed();
    public static GeoColor get_DarkSalmon();
    public static GeoColor get_DarkSeaGreen();
    public static GeoColor get_DarkSlateBlue();
    public static GeoColor get_DarkSlateGray();
    public static GeoColor get_DarkTurquoise();
    public static GeoColor get_DarkViolet();
    public static GeoColor get_DeepPink();
    public static GeoColor get_DeepSkyBlue();
    public static GeoColor get_DimGray();
    public static GeoColor get_DodgerBlue();
    public static GeoColor get_Firebrick();
    public static GeoColor get_FloralWhite();
    public static GeoColor get_ForestGreen();
    public static GeoColor get_Fuchsia();
    public static GeoColor get_Gainsboro();
    public static GeoColor get_GhostWhite();
    public static GeoColor get_Gold();
    public static GeoColor get_Goldenrod();
    public static GeoColor get_Gray();
    public static GeoColor get_Green();
    public static GeoColor get_GreenYellow();
    public static GeoColor get_Honeydew();
    public static GeoColor get_HotPink();
    public static GeoColor get_IndianRed();
    public static GeoColor get_Indigo();
    public static GeoColor get_Ivory();
    public static GeoColor get_Khaki();
    public static GeoColor get_Lavender();
    public static GeoColor get_LavenderBlush();
    public static GeoColor get_LawnGreen();
    public static GeoColor get_LemonChiffon();
    public static GeoColor get_LightBlue();
    public static GeoColor get_LightCoral();
    public static GeoColor get_LightCyan();
    public static GeoColor get_LightGoldenrodYellow();
    public static GeoColor get_LightGray();
    public static GeoColor get_LightGreen();
    public static GeoColor get_LightPink();
    public static GeoColor get_LightSalmon();
    public static GeoColor get_LightSeaGreen();
    public static GeoColor get_LightSkyBlue();
    public static GeoColor get_LightSlateGray();
    public static GeoColor get_LightSteelBlue();
    public static GeoColor get_LightYellow();
    public static GeoColor get_Lime();
    public static GeoColor get_LimeGreen();
    public static GeoColor get_Linen();
    public static GeoColor get_Magenta();
    public static GeoColor get_Maroon();
    public static GeoColor get_MediumAquamarine();
    public static GeoColor get_MediumBlue();
    public static GeoColor get_MediumOrchid();
    public static GeoColor get_MediumPurple();
    public static GeoColor get_MediumSeaGreen();
    public static GeoColor get_MediumSlateBlue();
    public static GeoColor get_MediumSpringGreen();
    public static GeoColor get_MediumTurquoise();
    public static GeoColor get_MediumVioletRed();
    public static GeoColor get_MidnightBlue();
    public static GeoColor get_MintCream();
    public static GeoColor get_MistyRose();
    public static GeoColor get_Moccasin();
    public static GeoColor get_NavajoWhite();
    public static GeoColor get_Navy();
    public static GeoColor get_OldLace();
    public static GeoColor get_Olive();
    public static GeoColor get_OliveDrab();
    public static GeoColor get_Orange();
    public static GeoColor get_OrangeRed();
    public static GeoColor get_Orchid();
    public static GeoColor get_PaleGoldenrod();
    public static GeoColor get_PaleGreen();
    public static GeoColor get_PaleTurquoise();
    public static GeoColor get_PaleVioletRed();
    public static GeoColor get_PapayaWhip();
    public static GeoColor get_PeachPuff();
    public static GeoColor get_Peru();
    public static GeoColor get_Pink();
    public static GeoColor get_Plum();
    public static GeoColor get_PowderBlue();
    public static GeoColor get_Purple();
    public static GeoColor get_Red();
    public static GeoColor get_RosyBrown();
    public static GeoColor get_RoyalBlue();
    public static GeoColor get_SaddleBrown();
    public static GeoColor get_Salmon();
    public static GeoColor get_SandyBrown();
    public static GeoColor get_SeaGreen();
    public static GeoColor get_SeaShell();
    public static GeoColor get_Sienna();
    public static GeoColor get_Silver();
    public static GeoColor get_SkyBlue();
    public static GeoColor get_SlateBlue();
    public static GeoColor get_SlateGray();
    public static GeoColor get_Snow();
    public static GeoColor get_SpringGreen();
    public static GeoColor get_SteelBlue();
    public static GeoColor get_Tan();
    public static GeoColor get_Teal();
    public static GeoColor get_Thistle();
    public static GeoColor get_Tomato();
    public static GeoColor get_Turquoise();
    public static GeoColor get_Violet();
    public static GeoColor get_Wheat();
    public static GeoColor get_White();
    public static GeoColor get_WhiteSmoke();
    public static GeoColor get_Yellow();
    public static GeoColor get_YellowGreen();
    public static GeoColor get_ButtonFace();
    public static GeoColor get_ButtonHighlight();
    public static GeoColor get_ButtonShadow();
    public static GeoColor get_GradientActiveCaption();
    public static GeoColor get_GradientInactiveCaption();
    public static GeoColor get_MenuBar();
    public static GeoColor get_MenuHighlight();
    public static GeoColor get_DarkYellow();
    public static GeoColor get_LightRed();
    public static GeoColor get_LightOrange();
    public static GeoColor get_PaleRed();
    public static GeoColor get_PaleBlue();
    public static GeoColor get_PaleYellow();
    public static GeoColor get_PaleOrange();
    public static GeoColor get_BrightRed();
    public static GeoColor get_BrightBlue();
    public static GeoColor get_BrightYellow();
    public static GeoColor get_BrightGreen();
    public static GeoColor get_BrightOrange();
    public static GeoColor get_PastelRed();
    public static GeoColor get_PastelBlue();
    public static GeoColor get_PastelYellow();
    public static GeoColor get_PastelGreen();
    public static GeoColor get_PastelOrange();
    public static GeoColor get_Copper();
}
public enum ThinkGeo.Core.GeoColorType : Enum {
    public int value__;
    public static GeoColorType Unknown;
    public static GeoColorType Alpha8;
    public static GeoColorType Rgb565;
    public static GeoColorType Argb4444;
    public static GeoColorType Rgba8888;
    public static GeoColorType Rgb888x;
    public static GeoColorType Bgra8888;
    public static GeoColorType Rgba1010102;
    public static GeoColorType Rgb101010x;
    public static GeoColorType Gray8;
    public static GeoColorType RgbaF16;
}
public enum ThinkGeo.Core.GeoDashCap : Enum {
    public int value__;
    public static GeoDashCap Flat;
    public static GeoDashCap Round;
    public static GeoDashCap Triangle;
    public static GeoDashCap Square;
}
public class ThinkGeo.Core.GeoDbf : object {
    private static string xB4=;
    private static string xR4=;
    private static Dictionary`2<string, string> xh4=;
    [ObfuscationAttribute]
private FileAccess readWriteMode;
    [ObfuscationAttribute]
private Dictionary`2<string, int> fieldNameCache;
    [ObfuscationAttribute]
private List`1<string> VFPSupportColumnNames;
    private static int xx4=;
    private static int yB4=;
    private static int yR4=;
    private static int yh4=;
    private static byte yx4=;
    private static byte zB4=;
    private static byte zR4=;
    private static byte zh4=;
    private static byte zx4=;
    private static byte 0B4=;
    private static byte 0R4=;
    private static byte 0h4=;
    private static byte 0x4=;
    private static byte 1B4=;
    private static byte 1R4=;
    private static byte 1h4=;
    private static byte 1x4=;
    private static byte 2B4=;
    private static byte 2R4=;
    private static byte 2h4=;
    private static byte 2x4=;
    private static byte 3B4=;
    private static byte 3R4=;
    private static byte 3h4=;
    private static byte 3x4=;
    private static int 4B4=;
    private static int 4R4=;
    private static int 4h4=;
    private static int 4x4=;
    private static int 5B4=;
    private static string 5R4=;
    private static string 5h4=;
    private static string 5x4=;
    private static string 6B4=;
    private static string 6R4=;
    private static string 6h4=;
    private static string 6x4=;
    private static string 7B4=;
    private static string 7R4=;
    private static string 7h4=;
    private static string 7x4=;
    private static string 8B4=;
    private static string 8R4=;
    private static string 8h4=;
    private static string 8x4=;
    private static string 9B4=;
    private static string 9R4=;
    private static string 9h4=;
    private static string 9x4=;
    private static string /B4=;
    private static string /R4=;
    private static string /h4=;
    private static string /x4=;
    private static string AB8=;
    private static string AR8=;
    private static string Ah8=;
    private static string Ax8=;
    private static string BB8=;
    private static string BR8=;
    private static string Bh8=;
    private static string Bx8=;
    private static string CB8=;
    private static string CR8=;
    private static string Ch8=;
    private static string Cx8=;
    private static string DB8=;
    private static string DR8=;
    private static string Dh8=;
    private static string Dx8=;
    private static string EB8=;
    private static string ER8=;
    [CompilerGeneratedAttribute]
private EventHandler`1<StreamLoadingEventArgs> Eh8=;
    [ObfuscationAttribute]
private bool needDBC;
    [ObfuscationAttribute]
private bool isOpenMemoFile;
    [ObfuscationAttribute]
private bool isUsingFPTMemoFile;
    [ObfuscationAttribute]
private string pathFilename;
    [ObfuscationAttribute]
private string dbtFileName;
    private Stream Ex8=;
    private Stream FB8=;
    [ObfuscationAttribute]
private int recordCount;
    [ObfuscationAttribute]
private int recordLength;
    [ObfuscationAttribute]
private int headerLength;
    [ObfuscationAttribute]
private int columnCount;
    [ObfuscationAttribute]
private bool isClosed;
    [ObfuscationAttribute]
private ArrayList fieldsHeader;
    [ObfuscationAttribute]
private Byte[] headerBytes;
    [ObfuscationAttribute]
private bool isCurrentRecordModified;
    [ObfuscationAttribute]
private int currentRecord;
    [ObfuscationAttribute]
private Byte[] currentRecords;
    [ObfuscationAttribute]
private ArrayList deletedItems;
    [ObfuscationAttribute]
private ArrayList originalIndexes;
    [ObfuscationAttribute]
private ArrayList newIndexes;
    [ObfuscationAttribute]
private string password;
    [ObfuscationAttribute]
private bool isFileDetached;
    [ObfuscationAttribute]
private bool haveMemoField;
    [ObfuscationAttribute]
private bool isUpdated;
    [ObfuscationAttribute]
private bool isFieldUpdated;
    [ObfuscationAttribute]
private bool isCreating;
    private Encoding FR8=;
    [ObfuscationAttribute]
private CultureInfo cultureInfo;
    [ObfuscationAttribute]
private int startPosition;
    public bool IsOpen { get; }
    public int ColumnCount { get; }
    public int RecordCount { get; }
    public string PathFilename { get; public set; }
    public FileAccess ReadWriteMode { get; public set; }
    public Encoding Encoding { get; public set; }
    public CultureInfo CultureInfo { get; public set; }
    public GeoDbf(string pathFilename);
    public GeoDbf(string pathFilename, FileAccess readWriteMode);
    public GeoDbf(string pathFilename, FileAccess readWriteMode, Encoding encoding);
    public GeoDbf(string pathFilename, FileAccess readWriteMode, Encoding encoding, CultureInfo cultureInfo);
    private static GeoDbf();
    [CompilerGeneratedAttribute]
public void add_StreamLoading(EventHandler`1<StreamLoadingEventArgs> value);
    [CompilerGeneratedAttribute]
public void remove_StreamLoading(EventHandler`1<StreamLoadingEventArgs> value);
    protected virtual void OnStreamLoading(StreamLoadingEventArgs e);
    public bool get_IsOpen();
    public int get_ColumnCount();
    public int get_RecordCount();
    public string get_PathFilename();
    public void set_PathFilename(string value);
    public FileAccess get_ReadWriteMode();
    public void set_ReadWriteMode(FileAccess value);
    public Encoding get_Encoding();
    public void set_Encoding(Encoding value);
    public CultureInfo get_CultureInfo();
    public void set_CultureInfo(CultureInfo value);
    protected virtual override void Finalize();
    public sealed virtual void Dispose();
    public static void CopyDbfHeader(string sourcePathFilename, string destinationPathFilename);
    public static void CopyDbfHeader(string sourcePathFilename, string destinationPathFilename, OverwriteMode overwriteMode);
    public static void CreateDbfFile(string dbfPathFilename, IEnumerable`1<DbfColumn> dbfColumns);
    public static void CreateDbfFile(string dbfPathFilename, IEnumerable`1<DbfColumn> dbfColumns, OverwriteMode overwriteMode);
    public static void CreateDbfFile(string dbfPathFilename, IEnumerable`1<DbfColumn> dbfColumns, OverwriteMode overwriteMode, Encoding encoding);
    public DbfColumn GetColumn(string columnName);
    public DbfColumn GetColumn(int columnNumber);
    public Dictionary`2<string, object> ReadRecord(int recordNumber);
    public bool ReadFieldAsBoolean(int recordNumber, int columnNumber);
    public bool ReadFieldAsBoolean(int recordNumber, string columnName);
    private Nullable`1<bool> Fh8=(int recordNumber, int columnNumber);
    private Nullable`1<bool> Fh8=(int recordNumber, string columnName);
    private Nullable`1<DateTime> Fx8=(int recordNumber, string columnName);
    public DateTime ReadFieldAsDateTime(int recordNumber, string columnName);
    public DateTime ReadFieldAsDateTime(int recordNumber, int columnNumber);
    public double ReadFieldAsDouble(int recordNumber, string columnName);
    public double ReadFieldAsDouble(int recordNumber, int columnNumber);
    public int ReadFieldAsInteger(int recordNumber, int columnNumber);
    public int ReadFieldAsInteger(int recordNumber, string columnName);
    public string ReadFieldAsString(int recordNumber, string columnName);
    public string ReadFieldAsString(int recordNumber, int columnNumber);
    public void WriteField(int recordNumber, string columnName, double value);
    public void WriteField(int recordNumber, int columnNumber, int value);
    public void WriteField(int recordNumber, string columnName, bool value);
    public void WriteField(int recordNumber, int columnNumber, double value);
    public void WriteField(int recordNumber, string columnName, int value);
    public void WriteField(int recordNumber, int columnNumber, string value);
    public void WriteField(int recordNumber, string columnName, string value);
    public void WriteField(int recordNumber, int columnNumber, bool value);
    public void WriteField(int recordNumber, int columnNumber, DateTime value);
    public void WriteField(int recordNumber, string columnName, DateTime value);
    public void Open();
    public void Close();
    public void Flush();
    public void Pack();
    public int GetColumnNumber(string columnName);
    public string GetColumnName(int columnNumber);
    public void DeleteRecord(int recordNumber);
    public void UpdateColumnName(int columnNumber, string newColumnName);
    public void UndeleteRecord(int recordNumber);
    public bool IsRecordDeleted(int recordNumber);
    public void AddEmptyRecord();
    public Dictionary`2<string, string> ReadRecordAsString(int recordNumber);
    public void WriteRecord(int recordNumber, IEnumerable`1<object> values);
    public static Collection`1<DbfColumn> GetValidColumns(IEnumerable`1<DbfColumn> columns);
    public static Collection`1<DbfColumn> GetValidColumns(IEnumerable`1<DbfColumn> columns, Encoding encoding);
    public static Collection`1<string> GetValidColumnNames(IEnumerable`1<string> columnNames);
    public static Collection`1<string> GetValidColumnNames(IEnumerable`1<string> columnNames, Encoding encoding);
    private static string GB8=(string baseString, int repeatNumber, Encoding encoding);
    private void GR8=(FileMode fileMode, FileAccess readWriteMode);
    public void AddStringColumn(string columnName, int length);
    public void AddIntegerColumn(string columnName, int length);
    public void AddDoubleColumn(string columnName, int length, int decimalLength);
    public void AddBooleanColumn(string columnName);
    public void AddMemoColumn(string columnName, int length);
    public void AddDateColumn(string columnName);
    internal void Gh8=(string columnName);
    public void UpdateDbcFilename(string newDbcFilename);
    public void AddColumn(string columnName, DbfColumnType columnType, int length, int decimalLength);
    private static string Gx8=(string columnName, int length);
    private bool HB8=(string columnName);
    private Collection`1<DbfColumn> HR8=();
    private DbfColumnType Hh8=(string fieldName);
    private DbfColumnType Hh8=(int fieldIndex);
    private int Hx8=(string fieldName);
    private int Hx8=(int fieldIndex);
    private int IB8=(string fieldName);
    private int IB8=(int fieldIndex);
    private string IR8=(int recordIndex, int fieldIndex);
    private static string Ih8=(Byte[] result, DbfColumnType type);
    private static string Ix8=(Byte[] result);
    private static string JB8=(Byte[] result);
    private static Byte[] JR8=(string datetime);
    private static string Jh8=(Byte[] result);
    private string IR8=(int recordIndex, string fieldName);
    private void Jx8=(int recordIndex, int fieldIndex, object value);
    private void Jx8=(int recordIndex, string fieldName, object value);
    private GeoDbf KB8=(string newPathFilename);
    private void KR8=(string fileName, FileAccess access);
    private static string Kh8=(string currentFileName);
    private static Encoding Kx8=(string ldid);
    private Stream LB8=(string fileName, FileMode fileMode, FileAccess readWriteMode);
    private Stream LR8=(string fileName, FileMode fileMode, FileAccess readWriteMode);
    private void Lh8=(string fileName, FileMode mode, FileAccess access, string strPassWord);
    private void Lx8=(string fileName, FileAccess access);
    private void MB8=();
    private void MR8=(Byte[] arrFileHeader, GeoDbf dbfFile);
    private void Mh8=(Byte[] arrHeader, GeoDbf dbfFile);
    private void Mx8=(string dbcFilePath, String[] columnNames);
    private string NB8=(int iRecord, int iField);
    private string NR8=(Byte[] bytesIn);
    private string NR8=(Byte[] bytesIn, int nIndex, int length);
    private Byte[] Nh8=(int iRecord, int iField);
    private Byte[] Nx8=(int iRecord, int iField);
    private Byte[] OB8=(int iRecord);
    private Byte[] OR8=(int iRecord);
    private string Oh8=(int iBlock);
    private string Ox8=(int iBlock);
    private void PB8=();
    private static void PR8=(Byte[]& arrUpdateBytes, int nOffset, int nWrittenBytes, int nSize, byte byteBlank);
    private void Ph8=(object value, int nOriginalBlock);
    private string Px8=(int recordNumber, int fieldIndex);
    private void QB8=(int iField, object objValue);
    private void QR8=(object Value, int nOriginalBlock);
    private void Qh8=(int iRecord);
    private void Qx8=(bool bHaveMemoField);
    private void RB8=();
    private void RR8=();
    private static string Rh8=(string dbf);
    private static void Rx8=(string strSrcDBF, string strDestDBF);
    private static string SB8=();
    private int SR8=(string FieldName, DbfColumnType type, int nWidth, int nDecimals);
    private int Sh8=(string FieldName, DbfColumnType type, int nWidth, int nDecimals);
    private void Sx8=(ArrayList DeletedArray);
    private void TB8=(ArrayList DeletedArray, ArrayList MemoFields);
    private void TR8=(Stream& fsDest, ArrayList DeletedArray);
    private void Th8=(Stream& fsDest, ArrayList DeletedBlocks);
    private void Tx8=(ArrayList memoFields);
    private void UB8=(Stream fsSrc, int iStart, int iEnd, Stream& fsDest, int iWriteTo);
    private static void UR8=(Stream fsSrc, int iStart, int iEnd, Stream& fsDest, int iWriteTo);
    private static void Uh8=(Stream fsDBT, int nDeletedBlocks);
    private int Ux8=(int OriginalValue);
    private static void VB8=(ArrayList& arrOriginal, ArrayList& arrNew, int iOriginalStart, int iOriginalEnd, int iNewStart);
    private ArrayList VR8=(ArrayList DeletedArray, ArrayList MemoFields);
    private ArrayList Vh8=();
    private void Vx8=();
    private static int WB8=(int iStart, int iEnd);
    private int WR8=(Stream fsDBT, int iBlock);
    private Byte[] Wh8=();
    private bool Wx8=(ArrayList Fields);
    private void XB8=(byte Flag);
    private void XR8=(string ErrorMsg);
    private DbfColumnInfo Xh8=(DbfColumnType type, int nWidth, int nDecimals);
    private Byte[] Xx8=(string FieldName, DbfColumnInfo Field);
    private string YB8=(int iField, DbfColumnType type, object objValue);
    private static string YR8=(object objValue, int nDecimalSize, DbfColumnType dbfColumnType, CultureInfo cultureInfo);
    private string Yh8=(string FieldName, DbfColumnType type, int nWidth, int nDecimals);
    private static int Yx8=(string strNum, CultureInfo cultureInfo);
    private static string ZB8=(string strNum);
    private static void ZR8=(Byte[]& bytes, int iStart, int intValue);
    private static int Zh8=(Byte[] bytes, int iStart);
    private static void Zx8=(Byte[]& FileHeader);
    private void aB8=(GeoDbf dbfFile, Stream& fsDest);
    private static void aR8=(Stream dbtFile, Stream& fsDest);
    private static string ah8=(string value);
    private void 1x0=(bool disposing);
}
public class ThinkGeo.Core.GeoFont : object {
    [ObfuscationAttribute]
private float size;
    [ObfuscationAttribute]
private string fontName;
    [ObfuscationAttribute]
private string fontNameLowercase;
    [ObfuscationAttribute]
private bool isBold;
    [ObfuscationAttribute]
private bool isStrikeout;
    [ObfuscationAttribute]
private bool isItalic;
    [ObfuscationAttribute]
private bool isUnderline;
    [ObfuscationAttribute]
private long id;
    [ObfuscationAttribute]
private static long geoFontIdCounter;
    [ObfuscationAttribute]
private DrawingGraphicsUnit unit;
    [ObfuscationAttribute]
private DrawingFontStyles style;
    [ObfuscationAttribute]
private bool isDefault;
    [ObfuscationAttribute]
internal static Dictionary`2<Regex, string> SpecificFontNames;
    public bool IsBold { get; public set; }
    public bool IsStrikeout { get; public set; }
    public bool IsItalic { get; public set; }
    public bool IsUnderline { get; public set; }
    public string FontName { get; public set; }
    public float Size { get; public set; }
    public DrawingFontStyles Style { get; public set; }
    public long Id { get; }
    public DrawingGraphicsUnit Unit { get; public set; }
    internal bool phU= { get; internal set; }
    public GeoFont(string fontName, float size);
    public GeoFont(string fontName, float size, DrawingFontStyles style);
    public GeoFont(string fontName, float size, DrawingFontStyles style, DrawingGraphicsUnit unit);
    private static GeoFont();
    public bool get_IsBold();
    public void set_IsBold(bool value);
    public bool get_IsStrikeout();
    public void set_IsStrikeout(bool value);
    public bool get_IsItalic();
    public void set_IsItalic(bool value);
    public bool get_IsUnderline();
    public void set_IsUnderline(bool value);
    public string get_FontName();
    public void set_FontName(string value);
    public float get_Size();
    public void set_Size(float value);
    public DrawingFontStyles get_Style();
    public void set_Style(DrawingFontStyles value);
    public long get_Id();
    public DrawingGraphicsUnit get_Unit();
    public void set_Unit(DrawingGraphicsUnit value);
    internal bool pBU=();
    internal void pRU=(bool value);
    public virtual int GetHashCode();
    public static string GetGlyphContent(int glyphIndex);
    public virtual bool Equals(object obj);
}
public enum ThinkGeo.Core.GeographyUnit : Enum {
    public int value__;
    public static GeographyUnit Unknown;
    public static GeographyUnit DecimalDegree;
    public static GeographyUnit Feet;
    public static GeographyUnit Meter;
}
public enum ThinkGeo.Core.GeohashAjacentDirection : Enum {
    public int value__;
    public static GeohashAjacentDirection Up;
    public static GeohashAjacentDirection UpperRight;
    public static GeohashAjacentDirection Right;
    public static GeohashAjacentDirection LowerRight;
    public static GeohashAjacentDirection Down;
    public static GeohashAjacentDirection LowerLeft;
    public static GeohashAjacentDirection Left;
    public static GeohashAjacentDirection UpperLeft;
}
public static class ThinkGeo.Core.GeohashHelper : object {
    private static string gCQ=;
    private static Int32[] gSQ=;
    private static String[][] giQ=;
    private static String[][] gyQ=;
    private static GeohashHelper();
    public static PointShape ConvertToPointShape(string geohash);
    public static string ConvertToGeohash(PointShape pointShapeInDecimalDegree, int precision);
    public static string ConvertToGeohash(Vertex vertexInDecimalDegree, int precision);
    public static string ConvertToGeohash(double latitude, double longitude, int precision);
    public static string GetAdjacentGeohash(double latitude, double longitude, GeohashAjacentDirection direction);
    public static string GetAdjacentGeohash(double latitude, double longitude, GeohashAjacentDirection direction, int precision);
    public static string GetAdjacentGeohash(PointShape pointShapeInDecimalDegree, GeohashAjacentDirection direction);
    public static string GetAdjacentGeohash(PointShape pointShapeInDecimalDegree, GeohashAjacentDirection direction, int precision);
    public static string GetAdjacentGeohash(Vertex vertexInDecimalDegree, GeohashAjacentDirection direction);
    public static string GetAdjacentGeohash(Vertex vertexInDecimalDegree, GeohashAjacentDirection direction, int precision);
    public static string GetAdjacentGeohash(string geohash, GeohashAjacentDirection direction);
    public static Collection`1<string> GetAdjacentGeohashes(string geohash);
    public static Collection`1<string> GetAdjacentGeohashes(PointShape pointShapeInDecimalDegree);
    public static Collection`1<string> GetAdjacentGeohashes(PointShape pointShapeInDecimalDegree, int precision);
    public static Collection`1<string> GetAdjacentGeohashes(Vertex vertexInDecimalDegree);
    public static Collection`1<string> GetAdjacentGeohashes(Vertex vertexInDecimalDegree, int precision);
    public static Collection`1<string> GetAdjacentGeohashes(double latitude, double longitude);
    public static Collection`1<string> GetAdjacentGeohashes(double latitude, double longitude, int precision);
    private static string hCQ=(string hash, MEA= direction);
    private static void hSQ=(Double[]& interval, int cd, int mask);
    private static int hiQ=(double doubleNumber);
}
public class ThinkGeo.Core.GeoHatchBrush : GeoBrush {
    [ObfuscationAttribute]
private GeoHatchStyle hatchStyle;
    [ObfuscationAttribute]
private GeoColor foregroundColor;
    [ObfuscationAttribute]
private GeoColor backgroundColor;
    public GeoHatchStyle HatchStyle { get; public set; }
    public GeoColor ForegroundColor { get; public set; }
    public GeoColor BackgroundColor { get; public set; }
    public GeoHatchBrush(GeoHatchStyle hatchStyle, GeoColor foregroundColor);
    public GeoHatchBrush(GeoHatchStyle hatchStyle, GeoColor foregroundColor, GeoColor backgroundColor);
    public GeoHatchStyle get_HatchStyle();
    public void set_HatchStyle(GeoHatchStyle value);
    public GeoColor get_ForegroundColor();
    public void set_ForegroundColor(GeoColor value);
    public GeoColor get_BackgroundColor();
    public void set_BackgroundColor(GeoColor value);
}
public enum ThinkGeo.Core.GeoHatchStyle : Enum {
    public int value__;
    public static GeoHatchStyle Horizontal;
    public static GeoHatchStyle Vertical;
    public static GeoHatchStyle ForwardDiagonal;
    public static GeoHatchStyle BackwardDiagonal;
    public static GeoHatchStyle LargeGrid;
    public static GeoHatchStyle DiagonalCross;
    public static GeoHatchStyle Percent05;
    public static GeoHatchStyle Percent10;
    public static GeoHatchStyle Percent20;
    public static GeoHatchStyle Percent25;
    public static GeoHatchStyle Percent30;
    public static GeoHatchStyle Percent40;
    public static GeoHatchStyle Percent50;
    public static GeoHatchStyle Percent60;
    public static GeoHatchStyle Percent70;
    public static GeoHatchStyle Percent75;
    public static GeoHatchStyle Percent80;
    public static GeoHatchStyle Percent90;
    public static GeoHatchStyle LightDownwardDiagonal;
    public static GeoHatchStyle LightUpwardDiagonal;
    public static GeoHatchStyle DarkDownwardDiagonal;
    public static GeoHatchStyle DarkUpwardDiagonal;
    public static GeoHatchStyle WideDownwardDiagonal;
    public static GeoHatchStyle WideUpwardDiagonal;
    public static GeoHatchStyle LightVertical;
    public static GeoHatchStyle LightHorizontal;
    public static GeoHatchStyle NarrowVertical;
    public static GeoHatchStyle NarrowHorizontal;
    public static GeoHatchStyle DarkVertical;
    public static GeoHatchStyle DarkHorizontal;
    public static GeoHatchStyle DashedDownwardDiagonal;
    public static GeoHatchStyle DashedUpwardDiagonal;
    public static GeoHatchStyle DashedHorizontal;
    public static GeoHatchStyle DashedVertical;
    public static GeoHatchStyle SmallConfetti;
    public static GeoHatchStyle LargeConfetti;
    public static GeoHatchStyle ZigZag;
    public static GeoHatchStyle Wave;
    public static GeoHatchStyle DiagonalBrick;
    public static GeoHatchStyle HorizontalBrick;
    public static GeoHatchStyle Weave;
    public static GeoHatchStyle Plaid;
    public static GeoHatchStyle Divot;
    public static GeoHatchStyle DottedGrid;
    public static GeoHatchStyle DottedDiamond;
    public static GeoHatchStyle Shingle;
    public static GeoHatchStyle Trellis;
    public static GeoHatchStyle Sphere;
    public static GeoHatchStyle SmallGrid;
    public static GeoHatchStyle SmallCheckerBoard;
    public static GeoHatchStyle LargeCheckerBoard;
    public static GeoHatchStyle OutlinedDiamond;
    public static GeoHatchStyle SolidDiamond;
    public static GeoHatchStyle Min;
    public static GeoHatchStyle Max;
    public static GeoHatchStyle Cross;
}
public class ThinkGeo.Core.GeoImage : object {
    [ObfuscationAttribute]
private float opacity;
    [ObfuscationAttribute]
private SKBitmap nativeImage;
    [ObfuscationAttribute]
private Byte[] bytes;
    [ObfuscationAttribute]
private string pathFilename;
    public string PathFilename { get; }
    public float Opacity { get; public set; }
    public int Width { get; }
    public int Height { get; }
    public SKBitmap NativeImage { get; }
    public GeoImage(int width, int height);
    public GeoImage(Stream stream);
    public GeoImage(string pathFilename);
    public GeoImage(Byte[] bytes);
    public GeoImage(SKBitmap skBitmap);
    public string get_PathFilename();
    public float get_Opacity();
    public void set_Opacity(float value);
    public int get_Width();
    public int get_Height();
    public SKBitmap get_NativeImage();
    public static GeoImage CreateCustomizedImage(int width, int height, GeoColorType colorType, GeoAlphaType alphaType);
    public Byte[] GetImageBytes(GeoImageFormat imageFormat, int imageQuality);
    public Byte[] ToBytesArray();
    public Stream GetImageStream(GeoImageFormat imageFormat, int imageQuality);
    public void Save(Stream stream, GeoImageFormat imageFormat, int quality);
    public void Save(string filePath, GeoImageFormat imageFormat, int quality);
    public sealed virtual void Dispose();
    protected virtual override void Finalize();
    protected virtual void Dispose(bool disposing);
    public void Clear(GeoColor color);
    public void SetPixels(GeoColor[] pixels);
    public IntPtr GetIntPtr();
    public GeoImage Scale(int targetWidth, int targetHeight);
    public GeoImage Crop(DrawingRectangle srcRect);
    public GeoImage Clip(DrawingRectangle clippingRectangle, int clippingWidth, int clippingHeight);
    public void DrawImage(GeoImage geoImage, float pointX, float pointY);
    public void DrawText(string text, GeoFont font, GeoBrush fillBrush, ScreenPointF[] points);
    internal GeoImage QRU=(bool isGrayscale, bool isNegative, float transparency, float redTranslation, float greenTranslation, float blueTranslation);
    internal GeoImage QhU=(Dictionary`2<GeoColor, GeoColor> colorMappings);
    [OnGeoserializingAttribute]
[OnSerializingAttribute]
private void QxU=(StreamingContext context);
    [OnGeodeserializedAttribute]
[OnDeserializedAttribute]
private void RBU=(StreamingContext context);
}
public enum ThinkGeo.Core.GeoImageFormat : Enum {
    public int value__;
    public static GeoImageFormat Png;
    public static GeoImageFormat Jpeg;
}
public class ThinkGeo.Core.GeoImageLayer : Layer {
    [ObfuscationAttribute]
private GeoImage _geoImage;
    [CompilerGeneratedAttribute]
private string VyA=;
    [CompilerGeneratedAttribute]
private PointShape fh0=;
    [CompilerGeneratedAttribute]
private double WCA=;
    [CompilerGeneratedAttribute]
private double 9B0=;
    [CompilerGeneratedAttribute]
private double 9R0=;
    public string ImagePathFilename { get; public set; }
    public PointShape CenterPoint { get; public set; }
    public double Scale { get; public set; }
    public double UpperThreshold { get; public set; }
    public double LowerThreshold { get; public set; }
    public GeoImageLayer(string imagePathFilename);
    [CompilerGeneratedAttribute]
public string get_ImagePathFilename();
    [CompilerGeneratedAttribute]
public void set_ImagePathFilename(string value);
    [CompilerGeneratedAttribute]
public PointShape get_CenterPoint();
    [CompilerGeneratedAttribute]
public void set_CenterPoint(PointShape value);
    [CompilerGeneratedAttribute]
public double get_Scale();
    [CompilerGeneratedAttribute]
public void set_Scale(double value);
    [CompilerGeneratedAttribute]
public double get_UpperThreshold();
    [CompilerGeneratedAttribute]
public void set_UpperThreshold(double value);
    [CompilerGeneratedAttribute]
public double get_LowerThreshold();
    [CompilerGeneratedAttribute]
public void set_LowerThreshold(double value);
    protected virtual RectangleShape GetBoundingBoxCore();
    protected virtual void OpenCore();
    protected virtual void CloseCore();
    protected virtual void DrawCore(GeoCanvas canvas, Collection`1<SimpleCandidate> labelsInAllLayers);
    protected virtual bool IsDrawingNeededCore(double currentScale);
}
[ObfuscationAttribute]
[DataContractAttribute]
internal class ThinkGeo.Core.GeoJsonFeature : GeoJsonObject {
    [CompilerGeneratedAttribute]
private GeoJsonObject <Geometry>k__BackingField;
    [CompilerGeneratedAttribute]
private Dictionary`2<string, string> <Properties>k__BackingField;
    [CompilerGeneratedAttribute]
private Double[] <BoundingBox>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Id>k__BackingField;
    [DataMemberAttribute]
public GeoJsonObject Geometry { get; public set; }
    [DataMemberAttribute]
public Dictionary`2<string, string> Properties { get; public set; }
    [DataMemberAttribute]
public Double[] BoundingBox { get; public set; }
    [DataMemberAttribute]
public string Id { get; public set; }
    public GeoJsonFeature(Feature feature);
    [CompilerGeneratedAttribute]
public GeoJsonObject get_Geometry();
    [CompilerGeneratedAttribute]
public void set_Geometry(GeoJsonObject value);
    [CompilerGeneratedAttribute]
public Dictionary`2<string, string> get_Properties();
    [CompilerGeneratedAttribute]
public void set_Properties(Dictionary`2<string, string> value);
    [CompilerGeneratedAttribute]
public Double[] get_BoundingBox();
    [CompilerGeneratedAttribute]
public void set_BoundingBox(Double[] value);
    [CompilerGeneratedAttribute]
public string get_Id();
    [CompilerGeneratedAttribute]
public void set_Id(string value);
}
[DataContractAttribute]
[ObfuscationAttribute]
internal class ThinkGeo.Core.GeoJsonFeatureCollection : GeoJsonObject {
    [CompilerGeneratedAttribute]
private Collection`1<GeoJsonFeature> <GeoJsonFeatures>k__BackingField;
    [CompilerGeneratedAttribute]
private Dictionary`2<string, string> <Properties>k__BackingField;
    [CompilerGeneratedAttribute]
private Double[] <BoundingBox>k__BackingField;
    [DataMemberAttribute]
public Collection`1<GeoJsonFeature> GeoJsonFeatures { get; public set; }
    [DataMemberAttribute]
public Dictionary`2<string, string> Properties { get; public set; }
    [DataMemberAttribute]
public Double[] BoundingBox { get; public set; }
    public GeoJsonFeatureCollection(IEnumerable`1<Feature> features);
    [CompilerGeneratedAttribute]
public Collection`1<GeoJsonFeature> get_GeoJsonFeatures();
    [CompilerGeneratedAttribute]
public void set_GeoJsonFeatures(Collection`1<GeoJsonFeature> value);
    [CompilerGeneratedAttribute]
public Dictionary`2<string, string> get_Properties();
    [CompilerGeneratedAttribute]
public void set_Properties(Dictionary`2<string, string> value);
    [CompilerGeneratedAttribute]
public Double[] get_BoundingBox();
    [CompilerGeneratedAttribute]
public void set_BoundingBox(Double[] value);
}
[ObfuscationAttribute]
[DataContractAttribute]
internal class ThinkGeo.Core.GeoJsonGeometryCollectionShape : GeoJsonObject {
    [CompilerGeneratedAttribute]
private Collection`1<GeoJsonObject> <Shapes>k__BackingField;
    [DataMemberAttribute]
public Collection`1<GeoJsonObject> Shapes { get; public set; }
    public GeoJsonGeometryCollectionShape(GeometryCollectionShape geometryCollection);
    [CompilerGeneratedAttribute]
public Collection`1<GeoJsonObject> get_Shapes();
    [CompilerGeneratedAttribute]
public void set_Shapes(Collection`1<GeoJsonObject> value);
}
[ObfuscationAttribute]
[DataContractAttribute]
internal class ThinkGeo.Core.GeoJsonLineStringShape : GeoJsonObject {
    [CompilerGeneratedAttribute]
private Collection`1<Double[]> <Vertices>k__BackingField;
    [DataMemberAttribute]
public Collection`1<Double[]> Vertices { get; public set; }
    public GeoJsonLineStringShape(LineShape line);
    [CompilerGeneratedAttribute]
public Collection`1<Double[]> get_Vertices();
    [CompilerGeneratedAttribute]
public void set_Vertices(Collection`1<Double[]> value);
}
[DataContractAttribute]
[ObfuscationAttribute]
internal class ThinkGeo.Core.GeoJsonMultiLineStringShape : GeoJsonObject {
    [CompilerGeneratedAttribute]
private Collection`1<Collection`1<Double[]>> <Lines>k__BackingField;
    [DataMemberAttribute]
public Collection`1<Collection`1<Double[]>> Lines { get; public set; }
    public GeoJsonMultiLineStringShape(MultilineShape multiLine);
    [CompilerGeneratedAttribute]
public Collection`1<Collection`1<Double[]>> get_Lines();
    [CompilerGeneratedAttribute]
public void set_Lines(Collection`1<Collection`1<Double[]>> value);
}
[DataContractAttribute]
[ObfuscationAttribute]
internal class ThinkGeo.Core.GeoJsonMultiPointShape : GeoJsonObject {
    [CompilerGeneratedAttribute]
private Collection`1<Double[]> <Points>k__BackingField;
    [DataMemberAttribute]
public Collection`1<Double[]> Points { get; public set; }
    public GeoJsonMultiPointShape(MultipointShape multiPoint);
    [CompilerGeneratedAttribute]
public Collection`1<Double[]> get_Points();
    [CompilerGeneratedAttribute]
public void set_Points(Collection`1<Double[]> value);
}
[DataContractAttribute]
[ObfuscationAttribute]
internal class ThinkGeo.Core.GeoJsonMultiPolygonShape : GeoJsonObject {
    [CompilerGeneratedAttribute]
private Collection`1<Collection`1<Collection`1<Double[]>>> <Polygons>k__BackingField;
    [DataMemberAttribute]
public Collection`1<Collection`1<Collection`1<Double[]>>> Polygons { get; public set; }
    public GeoJsonMultiPolygonShape(MultipolygonShape multiPolygon);
    [CompilerGeneratedAttribute]
public Collection`1<Collection`1<Collection`1<Double[]>>> get_Polygons();
    [CompilerGeneratedAttribute]
public void set_Polygons(Collection`1<Collection`1<Collection`1<Double[]>>> value);
    private static void FillRings(RingShape ring, Collection`1<Collection`1<Double[]>> polygon);
}
[ObfuscationAttribute]
[KnownTypeAttribute("ThinkGeo.Core.GeoJsonPointShape")]
[KnownTypeAttribute("ThinkGeo.Core.GeoJsonLineStringShape")]
[KnownTypeAttribute("ThinkGeo.Core.GeoJsonFeature")]
[KnownTypeAttribute("ThinkGeo.Core.GeoJsonMultiLineStringShape")]
[KnownTypeAttribute("ThinkGeo.Core.GeoJsonPolygonShape")]
[KnownTypeAttribute("ThinkGeo.Core.GeoJsonGeometryCollectionShape")]
[DataContractAttribute]
[KnownTypeAttribute("ThinkGeo.Core.GeoJsonMultiPointShape")]
[KnownTypeAttribute("ThinkGeo.Core.GeoJsonMultiPolygonShape")]
internal class ThinkGeo.Core.GeoJsonObject : object {
    [CompilerGeneratedAttribute]
private string <ObjectType>k__BackingField;
    [DataMemberAttribute]
public string ObjectType { get; public set; }
    [CompilerGeneratedAttribute]
public string get_ObjectType();
    [CompilerGeneratedAttribute]
public void set_ObjectType(string value);
}
[ObfuscationAttribute]
internal static class ThinkGeo.Core.GeoJsonObjectType : object {
    public static string Point;
    public static string LineString;
    public static string Polygon;
    public static string MultiPoint;
    public static string MultiLineString;
    public static string MultiPolygon;
    public static string GeometryCollection;
    public static string Feature;
    public static string FeatureCollection;
    private static GeoJsonObjectType();
}
[ObfuscationAttribute]
[DataContractAttribute]
internal class ThinkGeo.Core.GeoJsonPointShape : GeoJsonObject {
    [CompilerGeneratedAttribute]
private Double[] <XY>k__BackingField;
    [DataMemberAttribute]
public Double[] XY { get; public set; }
    public GeoJsonPointShape(PointShape point);
    public GeoJsonPointShape(double x, double y);
    [CompilerGeneratedAttribute]
public Double[] get_XY();
    [CompilerGeneratedAttribute]
public void set_XY(Double[] value);
}
[DataContractAttribute]
[ObfuscationAttribute]
internal class ThinkGeo.Core.GeoJsonPolygonShape : GeoJsonObject {
    [CompilerGeneratedAttribute]
private Collection`1<Collection`1<Double[]>> <Rings>k__BackingField;
    [DataMemberAttribute]
public Collection`1<Collection`1<Double[]>> Rings { get; public set; }
    public GeoJsonPolygonShape(PolygonShape polygon);
    [CompilerGeneratedAttribute]
public Collection`1<Collection`1<Double[]>> get_Rings();
    [CompilerGeneratedAttribute]
public void set_Rings(Collection`1<Collection`1<Double[]>> value);
    private void FillRings(RingShape ring);
}
[ObfuscationAttribute]
internal class ThinkGeo.Core.GeoJsonSerializeStrategy : object {
    [CompilerGeneratedAttribute]
private Func`2<object, GeoJsonType> <GetJsonType>k__BackingField;
    [CompilerGeneratedAttribute]
private Func`2<object, object> <GetJsonNode>k__BackingField;
    [CompilerGeneratedAttribute]
private Action`1<XElement> <FormalizedXml>k__BackingField;
    public Func`2<object, GeoJsonType> GetJsonType { get; public set; }
    public Func`2<object, object> GetJsonNode { get; public set; }
    public Action`1<XElement> FormalizedXml { get; public set; }
    [CompilerGeneratedAttribute]
public Func`2<object, GeoJsonType> get_GetJsonType();
    [CompilerGeneratedAttribute]
public void set_GetJsonType(Func`2<object, GeoJsonType> value);
    [CompilerGeneratedAttribute]
public Func`2<object, object> get_GetJsonNode();
    [CompilerGeneratedAttribute]
public void set_GetJsonNode(Func`2<object, object> value);
    [CompilerGeneratedAttribute]
public Action`1<XElement> get_FormalizedXml();
    [CompilerGeneratedAttribute]
public void set_FormalizedXml(Action`1<XElement> value);
    private static GeoJsonType GetJsonTypeHandler(object obj);
    private static object GetJsonNodeHandler(object obj);
    private static void FormalizedXmlHandler(XElement xElement);
}
[ObfuscationAttribute]
internal enum ThinkGeo.Core.GeoJsonType : Enum {
    public int value__;
    public static GeoJsonType unknown;
    public static GeoJsonType string;
    public static GeoJsonType number;
    public static GeoJsonType boolean;
    public static GeoJsonType object;
    public static GeoJsonType array;
    public static GeoJsonType null;
}
public class ThinkGeo.Core.GeoLinearGradientBrush : GeoBrush {
    [ObfuscationAttribute]
private GeoColor startColor;
    [ObfuscationAttribute]
private GeoColor endColor;
    [ObfuscationAttribute]
private GeoBrushWrapMode wrapMode;
    [ObfuscationAttribute]
private float directionAngle;
    public GeoColor StartColor { get; public set; }
    public GeoColor EndColor { get; public set; }
    public float DirectionAngle { get; public set; }
    public GeoBrushWrapMode WrapMode { get; public set; }
    public GeoLinearGradientBrush(GeoColor startColor, GeoColor endColor, GeoLinearGradientDirection direction);
    public GeoLinearGradientBrush(GeoColor startColor, GeoColor endColor, float directionAngle);
    private static float QBU=(GeoLinearGradientDirection direction);
    public GeoColor get_StartColor();
    public void set_StartColor(GeoColor value);
    public GeoColor get_EndColor();
    public void set_EndColor(GeoColor value);
    public float get_DirectionAngle();
    public void set_DirectionAngle(float value);
    public GeoBrushWrapMode get_WrapMode();
    public void set_WrapMode(GeoBrushWrapMode value);
}
public enum ThinkGeo.Core.GeoLinearGradientDirection : Enum {
    public int value__;
    public static GeoLinearGradientDirection LeftToRight;
    public static GeoLinearGradientDirection RightToLeft;
    public static GeoLinearGradientDirection TopToBottom;
    public static GeoLinearGradientDirection BottomToTop;
    public static GeoLinearGradientDirection UpperLeftToLowerRight;
    public static GeoLinearGradientDirection LowerRightToUpperLeft;
    public static GeoLinearGradientDirection LowerLeftToUpperRight;
    public static GeoLinearGradientDirection UpperRightToLowerLeft;
}
[TypeConverterAttribute("ThinkGeo.Core.BaseShapeTypeConverter")]
public class ThinkGeo.Core.GeometryCollectionShape : BaseShape {
    [ObfuscationAttribute]
private Collection`1<BaseShape> shapes;
    public Collection`1<BaseShape> Shapes { get; }
    public GeometryCollectionShape(IEnumerable`1<BaseShape> baseShapes);
    public GeometryCollectionShape(IEnumerable`1<Feature> features);
    public GeometryCollectionShape(string wellKnownText);
    public GeometryCollectionShape(Byte[] wellKnownBinary);
    public Collection`1<BaseShape> get_Shapes();
    protected virtual void LoadFromWellKnownDataCore(Byte[] wellKnownBinary);
    protected virtual void LoadFromWellKnownDataCore(string wellKnownText);
    protected virtual string GetWellKnownTextCore(RingOrder outerRingOrder);
    protected virtual Byte[] GetWellKnownBinaryCore(RingOrder outerRingOrder, WkbByteOrder byteOrder);
    protected virtual WellKnownType GetWellKnownTypeCore();
    private void SRw=(GeometryCollectionShape fromGeometryCollection);
    protected virtual ShapeValidationResult ValidateCore(ShapeValidationMode validationMode);
    protected virtual MultipointShape GetCrossingCore(BaseShape targetShape);
    protected virtual RectangleShape GetBoundingBoxCore();
    protected virtual double GetDistanceToCore(BaseShape targetShape, GeographyUnit shapeUnit, DistanceUnit distanceUnit);
    protected virtual PointShape GetClosestPointToCore(BaseShape targetShape, GeographyUnit shapeUnit);
    protected virtual MultilineShape GetShortestLineToCore(BaseShape targetShape, GeographyUnit shapeUnit);
    protected virtual MultipolygonShape BufferCore(double distance, int quadrantSegments, BufferCapType bufferCapType, GeographyUnit shapeUnit, DistanceUnit distanceUnit);
    protected virtual bool IsDisjointedCore(BaseShape targetShape);
    protected virtual bool IntersectsCore(BaseShape targetShape);
    protected virtual bool TouchesCore(BaseShape targetShape);
    protected virtual bool IsWithinCore(BaseShape targetShape);
    public GeometryCollectionShape GetIntersection(BaseShape targetShape);
    protected virtual GeometryCollectionShape GetIntersectionCore(BaseShape targetShape);
    public GeometryCollectionShape Union(BaseShape targetShape);
    public GeometryCollectionShape Union(IEnumerable`1<BaseShape> targetShape);
    protected virtual GeometryCollectionShape UnionCore(IEnumerable`1<BaseShape> targetShape);
    private static Collection`1<BaseShape> Shw=(GeometryCollectionShape geometryCollection);
    internal static GeometryCollectionShape Sxw=(IEnumerable`1<BaseShape> shapes);
    public GeometryCollectionShape GetDifference(BaseShape targetShape);
    protected virtual GeometryCollectionShape GetDifferenceCore(BaseShape targetShape);
    public GeometryCollectionShape GetSymmetricalDifference(BaseShape targetShape);
    protected virtual GeometryCollectionShape GetSymmetricalDifferenceCore(BaseShape targetShape);
    public RingShape GetConvexHull();
    protected virtual RingShape GetConvexHullCore();
    public GeometryCollectionShape Simplify(GeographyUnit shapeUnit, double tolerance, DistanceUnit toleranceUnit, SimplificationType simplificationType);
    public GeometryCollectionShape Simplify(double tolerance, SimplificationType simplificationType);
    protected virtual GeometryCollectionShape SimplifyCore(double tolerance, SimplificationType simplificationType);
    private static EndCapStyle 3xo=(BufferCapType bufferCapStyle);
}
public class ThinkGeo.Core.GeoObjectModel : object {
    [ObfuscationAttribute]
private string name;
    [ObfuscationAttribute]
private GeoObjectNode rootNode;
    public string Name { get; public set; }
    public GeoObjectNode RootNode { get; public set; }
    public GeoObjectModel(string name, GeoObjectNode rootNode);
    public string get_Name();
    public void set_Name(string value);
    public GeoObjectNode get_RootNode();
    public void set_RootNode(GeoObjectNode value);
}
internal class ThinkGeo.Core.GeoObjectModeler : object {
    [CompilerGeneratedAttribute]
private EventHandler`1<CreatingMemberNodeGeoObjectModelerEventArgs> CreatingMemberNode;
    [CompilerGeneratedAttribute]
private EventHandler`1<CreatedMemberNodeGeoObjectModelerEventArgs> CreatedMemberNode;
    [CompilerGeneratedAttribute]
private EventHandler`1<CreatingMemberObjectGeoObjectModelerEventArgs> CreatingMemberObject;
    [CompilerGeneratedAttribute]
private EventHandler`1<CreatedMemberObjectGeoObjectModelerEventArgs> CreatedMemberObject;
    [CompilerGeneratedAttribute]
private bool <IsGeneratingCode>k__BackingField;
    private string circularReferenceAttributeName;
    private Type[] parameterToGetConstructor;
    private Object[] parameterToInvokeConstructor;
    private Type onDeserializingAttributeType;
    private Type onDeserializedAttributeType;
    private Type onSerializingAttributeType;
    private Type onSerializedAttributeType;
    private Dictionary`2<string, Collection`1<MethodInfo>> attributedMethodInfosCache;
    private static Dictionary`2<string, string> escapeCharactors;
    [ObfuscationAttribute]
private object referencedObject;
    [ObfuscationAttribute]
private string hashCode;
    [ObfuscationAttribute]
private string referenceTypeName;
    [ObfuscationAttribute]
private Dictionary`2<object, GeoObjectNodeAndGuid> hashCodeModelDictionary;
    [ObfuscationAttribute]
private Dictionary`2<string, object> hashcodeValueDictionary;
    [ObfuscationAttribute]
private Dictionary`2<Type, object> objectsInInitialState;
    [ObfuscationAttribute]
private GeoObjectModelerMemberTypes memberTypes;
    [ObfuscationAttribute]
private GeoObjectModelerDefaultValueMode defaultValueMode;
    [ObfuscationAttribute]
private BindingFlags bindingFlags;
    [ObfuscationAttribute]
private object tmpValue;
    [ObfuscationAttribute]
private PropertyInfo tmpProperty;
    internal bool IsGeneratingCode { get; internal set; }
    private static GeoObjectModeler();
    [CompilerGeneratedAttribute]
public void add_CreatingMemberNode(EventHandler`1<CreatingMemberNodeGeoObjectModelerEventArgs> value);
    [CompilerGeneratedAttribute]
public void remove_CreatingMemberNode(EventHandler`1<CreatingMemberNodeGeoObjectModelerEventArgs> value);
    [CompilerGeneratedAttribute]
public void add_CreatedMemberNode(EventHandler`1<CreatedMemberNodeGeoObjectModelerEventArgs> value);
    [CompilerGeneratedAttribute]
public void remove_CreatedMemberNode(EventHandler`1<CreatedMemberNodeGeoObjectModelerEventArgs> value);
    [CompilerGeneratedAttribute]
public void add_CreatingMemberObject(EventHandler`1<CreatingMemberObjectGeoObjectModelerEventArgs> value);
    [CompilerGeneratedAttribute]
public void remove_CreatingMemberObject(EventHandler`1<CreatingMemberObjectGeoObjectModelerEventArgs> value);
    [CompilerGeneratedAttribute]
public void add_CreatedMemberObject(EventHandler`1<CreatedMemberObjectGeoObjectModelerEventArgs> value);
    [CompilerGeneratedAttribute]
public void remove_CreatedMemberObject(EventHandler`1<CreatedMemberObjectGeoObjectModelerEventArgs> value);
    [CompilerGeneratedAttribute]
internal bool get_IsGeneratingCode();
    [CompilerGeneratedAttribute]
internal void set_IsGeneratingCode(bool value);
    public GeoObjectModel CreateModel(object objectToModel, GeoObjectModelerMemberTypes memberTypes, BindingFlags bindingFlags, GeoObjectModelerDefaultValueMode defaultValueMode);
    public object CreateObject(GeoObjectModel model);
    protected Collection`1<MemberInfo> GetMembers(Type type, GeoObjectModelerMemberTypes memberTypes);
    protected virtual Collection`1<MemberInfo> GetMembersCore(Type type, GeoObjectModelerMemberTypes memberTypes);
    protected virtual void OnCreatingMemberNode(CreatingMemberNodeGeoObjectModelerEventArgs e);
    protected virtual void OnCreatingMemberObject(CreatingMemberObjectGeoObjectModelerEventArgs e);
    protected virtual void OnCreatedMemberNode(CreatedMemberNodeGeoObjectModelerEventArgs e);
    protected virtual void OnCreatedMemberObject(CreatedMemberObjectGeoObjectModelerEventArgs e);
    protected void CreateMemberNode(string memberName, object memberValue, Type memberType, object memberOwner, GeoObjectNode baseMemberNode);
    protected virtual void CreateMemberNodeCore(string memberName, object memberValue, Type memberType, object memberOwner, GeoObjectNode baseMemberNode);
    protected object CreateMemberObject(string memberName, Type memberType, object memberOwner, GeoObjectNode memberNode);
    protected virtual object CreateMemberObjectCore(string memberName, Type memberType, object memberOwner, GeoObjectNode memberNode);
    private GeoObjectNode CreateModelForObject(object modelSource);
    private Collection`1<MemberInfo> GetAllMembers(Type type);
    private void CreateNodeForObject(object serializationObject, GeoObjectNode baseObjectModel, string nodeName, Type parentType);
    private static void InvokeSerializingDeserializingMethods(object serializationObject, IEnumerable`1<MethodInfo> onSerializingMethods);
    private bool IsSpecialTypes(Type type);
    [IteratorStateMachineAttribute("ThinkGeo.Core.GeoObjectModeler/uz4=")]
private IEnumerable`1<MethodInfo> GetMethodsMarkedAs(Type type, Type attributeType);
    private static GeoObjectNode CreateNewNode(string name);
    private static void SetInheritAttribute(GeoObjectNode objectModel, Type type, Type parentType);
    private static void SetTypeAttribute(GeoObjectNode objectModel, Type objType);
    private static string SimplifyAssemblyQualifiedName(string name);
    private static void SetItemTypeAttribute(GeoObjectNode objectModel, Type objType);
    private bool IsCircularReferenced(object obj, GeoObjectNode objectModel);
    private void HandleCircularReferencing(object obj, GeoObjectNode objectModel, string fieldName);
    private static bool IsSimpleType(Type type);
    private static void CreateNodeForSimpleType(object serializationObject, GeoObjectNode currentModel);
    private void CreateNodeForArrayType(Array array, GeoObjectNode objectModel);
    private void CreateNodeForIEnumerableType(IEnumerable sequence, GeoObjectNode objectModel);
    private void CreateNodeForNormalType(object serializationObject, GeoObjectNode currentModel);
    private void RaiseEventAndCreateNodeForProperty(object serializationObject, GeoObjectNode currentModel, PropertyInfo property);
    private void RaiseEventAndCreateNodeForField(object serializationObject, GeoObjectNode currentModel, FieldInfo field);
    private static bool IsSerializable(FieldInfo field);
    private static bool IsSerializable(PropertyInfo property);
    private object CreateObjectFromModel(GeoObjectNode node, string typeName);
    private static string ReplaceInvalidCharacters(string name);
    private object CreateArray(GeoObjectNode node, Type type);
    private void SetValue(Array b, int rank, List`1<int> indecies, Collection`1<object> values, Int32& index);
    private void CreateIEnumerableObject(object result, GeoObjectNode node, Type type);
    private static object CreateSimpleObject(GeoObjectNode node, Type type);
    private object CreateNormalObject(GeoObjectNode node, object result);
    private static object GetSimpleTypeResult(Type type, string value);
    private Collection`1<MemberInfo> GetPrivateFieldsByType(Type type);
    private static Collection`1<MemberInfo> GetPublicPropertiesByType(Type type);
    private static bool IsSettable(PropertyInfo propertyInfo);
    private bool IsInitValue(FieldInfo fieldInfo, object ownerValue, Type ownerType);
    private bool IsInitValue(PropertyInfo propertyInfo, object ownerValue, Type ownerType);
    private object GetInitObject(Type ownerType);
    private bool AreSame(object obj1, object obj2, Type objType, bool checkProperties, bool checkFields);
    private bool FieldsSame(object obj1, object obj2, Type objType);
    private bool PropertiesSame(object obj1, object obj2, Type objType);
    private IEnumerable`1<FieldInfo> FilterFields(Type objType);
    private static IEnumerable`1<PropertyInfo> FilterProperties(Type objType);
    private bool AreIEnumerablesSame(object obj1, object obj2, bool checkProperties, bool checkFields);
}
internal enum ThinkGeo.Core.GeoObjectModelerDefaultValueMode : Enum {
    public int value__;
    public static GeoObjectModelerDefaultValueMode IncludeDefaultValues;
    public static GeoObjectModelerDefaultValueMode ExcludeDefaultValues;
}
[FlagsAttribute]
internal enum ThinkGeo.Core.GeoObjectModelerMemberTypes : Enum {
    public int value__;
    public static GeoObjectModelerMemberTypes Fields;
    public static GeoObjectModelerMemberTypes Properties;
}
public class ThinkGeo.Core.GeoObjectNode : object {
    [ObfuscationAttribute]
private string name;
    [ObfuscationAttribute]
private GeoObjectNode parent;
    [ObfuscationAttribute]
private Collection`1<GeoObjectNode> children;
    [ObfuscationAttribute]
private Dictionary`2<string, string> attributes;
    [ObfuscationAttribute]
private string actualValue;
    [ObfuscationAttribute]
private bool isDefaultValue;
    [ObfuscationAttribute]
internal bool isNonGenericSequence;
    public string Name { get; public set; }
    public GeoObjectNode Parent { get; public set; }
    public Collection`1<GeoObjectNode> Children { get; private set; }
    public Dictionary`2<string, string> Attributes { get; private set; }
    public string Value { get; public set; }
    public bool IsDefaultValue { get; public set; }
    internal bool wRo= { get; internal set; }
    internal GeoObjectNode wxo= { get; }
    internal GeoObjectNode xRo= { get; }
    public GeoObjectNode(string name);
    public string get_Name();
    public void set_Name(string value);
    public GeoObjectNode get_Parent();
    public void set_Parent(GeoObjectNode value);
    public Collection`1<GeoObjectNode> get_Children();
    private void set_Children(Collection`1<GeoObjectNode> value);
    public Dictionary`2<string, string> get_Attributes();
    private void set_Attributes(Dictionary`2<string, string> value);
    public string get_Value();
    public void set_Value(string value);
    public bool get_IsDefaultValue();
    public void set_IsDefaultValue(bool value);
    internal bool vxo=();
    internal void wBo=(bool value);
    internal GeoObjectNode who=();
    internal GeoObjectNode xBo=();
    internal void xho=(string attributeName, string attributeValue);
    internal string xxo=(string attributeName);
    internal void yBo=(string attributeName);
    public virtual string ToString();
}
[ObfuscationAttribute]
internal class ThinkGeo.Core.GeoObjectNodeAndGuid : object {
    [ObfuscationAttribute]
private GeoObjectNode node;
    [ObfuscationAttribute]
private string id;
    internal GeoObjectNode yho= { get; }
    internal string gxQ= { get; }
    public GeoObjectNodeAndGuid(GeoObjectNode node, string id);
    internal GeoObjectNode yRo=();
    internal string gRQ=();
}
public class ThinkGeo.Core.GeoPen : object {
    [ObfuscationAttribute]
private float width;
    [ObfuscationAttribute]
private float miterLimit;
    [ObfuscationAttribute]
private GeoBrush brush;
    [ObfuscationAttribute]
private GeoColor color;
    [ObfuscationAttribute]
private GeoDashCap dashCap;
    [ObfuscationAttribute]
private LineDashStyle dashStyle;
    [ObfuscationAttribute]
private DrawingLineCap startCap;
    [ObfuscationAttribute]
private DrawingLineCap endCap;
    [ObfuscationAttribute]
private DrawingLineJoin lineJoin;
    [ObfuscationAttribute]
private Collection`1<float> dashPattern;
    [ObfuscationAttribute]
private long id;
    [ObfuscationAttribute]
private static long geoPenIdCounter;
    public GeoBrush Brush { get; public set; }
    public GeoColor Color { get; public set; }
    public GeoDashCap DashCap { get; public set; }
    public Collection`1<float> DashPattern { get; }
    public LineDashStyle DashStyle { get; public set; }
    public DrawingLineCap EndCap { get; public set; }
    public DrawingLineJoin LineJoin { get; public set; }
    public float MiterLimit { get; public set; }
    public DrawingLineCap StartCap { get; public set; }
    public float Width { get; public set; }
    public long Id { get; }
    public GeoPen(GeoBrush brush);
    public GeoPen(GeoColor color);
    public GeoPen(GeoColor color, float width);
    public GeoPen(GeoBrush brush, float width);
    public void SetLineCap(DrawingLineCap startCap, DrawingLineCap endCap, GeoDashCap dashCap);
    public GeoBrush get_Brush();
    public void set_Brush(GeoBrush value);
    public GeoColor get_Color();
    public void set_Color(GeoColor value);
    public GeoDashCap get_DashCap();
    public void set_DashCap(GeoDashCap value);
    public Collection`1<float> get_DashPattern();
    public LineDashStyle get_DashStyle();
    public void set_DashStyle(LineDashStyle value);
    public DrawingLineCap get_EndCap();
    public void set_EndCap(DrawingLineCap value);
    public DrawingLineJoin get_LineJoin();
    public void set_LineJoin(DrawingLineJoin value);
    public float get_MiterLimit();
    public void set_MiterLimit(float value);
    public DrawingLineCap get_StartCap();
    public void set_StartCap(DrawingLineCap value);
    public float get_Width();
    public void set_Width(float value);
    public long get_Id();
    public GeoPen CloneDeep();
    protected virtual GeoPen CloneDeepCore();
    private void pxU=();
    private bool qBU=();
}
public static class ThinkGeo.Core.GeoPens : object {
    public static GeoPen AliceBlue { get; }
    public static GeoPen AntiqueWhite { get; }
    public static GeoPen Aqua { get; }
    public static GeoPen Aquamarine { get; }
    public static GeoPen Azure { get; }
    public static GeoPen Beige { get; }
    public static GeoPen Bisque { get; }
    public static GeoPen Black { get; }
    public static GeoPen BlanchedAlmond { get; }
    public static GeoPen Blue { get; }
    public static GeoPen BlueViolet { get; }
    public static GeoPen Brown { get; }
    public static GeoPen BurlyWood { get; }
    public static GeoPen CadetBlue { get; }
    public static GeoPen Chartreuse { get; }
    public static GeoPen Chocolate { get; }
    public static GeoPen Coral { get; }
    public static GeoPen CornflowerBlue { get; }
    public static GeoPen CornSilk { get; }
    public static GeoPen Crimson { get; }
    public static GeoPen Cyan { get; }
    public static GeoPen DarkBlue { get; }
    public static GeoPen DarkCyan { get; }
    public static GeoPen DarkGoldenrod { get; }
    public static GeoPen DarkGray { get; }
    public static GeoPen DarkGreen { get; }
    public static GeoPen DarkKhaki { get; }
    public static GeoPen DarkMagenta { get; }
    public static GeoPen DarkOliveGreen { get; }
    public static GeoPen DarkOrange { get; }
    public static GeoPen DarkOrchid { get; }
    public static GeoPen DarkRed { get; }
    public static GeoPen DarkSalmon { get; }
    public static GeoPen DarkSeaGreen { get; }
    public static GeoPen DarkSlateBlue { get; }
    public static GeoPen DarkSlateGray { get; }
    public static GeoPen DarkTurquoise { get; }
    public static GeoPen DarkViolet { get; }
    public static GeoPen DeepPink { get; }
    public static GeoPen DeepSkyBlue { get; }
    public static GeoPen DimGray { get; }
    public static GeoPen DodgerBlue { get; }
    public static GeoPen Firebrick { get; }
    public static GeoPen FloralWhite { get; }
    public static GeoPen ForestGreen { get; }
    public static GeoPen Fuchsia { get; }
    public static GeoPen Gainsboro { get; }
    public static GeoPen GhostWhite { get; }
    public static GeoPen Gold { get; }
    public static GeoPen Goldenrod { get; }
    public static GeoPen Gray { get; }
    public static GeoPen Green { get; }
    public static GeoPen GreenYellow { get; }
    public static GeoPen HoneyDew { get; }
    public static GeoPen HotPink { get; }
    public static GeoPen IndianRed { get; }
    public static GeoPen Indigo { get; }
    public static GeoPen Ivory { get; }
    public static GeoPen Khaki { get; }
    public static GeoPen Lavender { get; }
    public static GeoPen LavenderBlush { get; }
    public static GeoPen LawnGreen { get; }
    public static GeoPen LemonChiffon { get; }
    public static GeoPen LightBlue { get; }
    public static GeoPen LightCoral { get; }
    public static GeoPen LightCyan { get; }
    public static GeoPen LightGoldenrodYellow { get; }
    public static GeoPen LightGray { get; }
    public static GeoPen LightGreen { get; }
    public static GeoPen LightPink { get; }
    public static GeoPen LightRed { get; }
    public static GeoPen LightSalmon { get; }
    public static GeoPen LightSeaGreen { get; }
    public static GeoPen LightSkyBlue { get; }
    public static GeoPen LightSlateGray { get; }
    public static GeoPen LightSteelBlue { get; }
    public static GeoPen LightYellow { get; }
    public static GeoPen Lime { get; }
    public static GeoPen LimeGreen { get; }
    public static GeoPen Linen { get; }
    public static GeoPen Magenta { get; }
    public static GeoPen Maroon { get; }
    public static GeoPen MediumAquamarine { get; }
    public static GeoPen MediumBlue { get; }
    public static GeoPen MediumOrchid { get; }
    public static GeoPen MediumPurple { get; }
    public static GeoPen MediumSeaGreen { get; }
    public static GeoPen MediumSlateBlue { get; }
    public static GeoPen MediumSpringGreen { get; }
    public static GeoPen MediumTurquoise { get; }
    public static GeoPen MediumVioletRed { get; }
    public static GeoPen MidnightBlue { get; }
    public static GeoPen MintCream { get; }
    public static GeoPen MistyRose { get; }
    public static GeoPen Moccasin { get; }
    public static GeoPen NavajoWhite { get; }
    public static GeoPen Navy { get; }
    public static GeoPen OldLace { get; }
    public static GeoPen Olive { get; }
    public static GeoPen OliveDrab { get; }
    public static GeoPen Orange { get; }
    public static GeoPen OrangeRed { get; }
    public static GeoPen Orchid { get; }
    public static GeoPen PaleGoldenrod { get; }
    public static GeoPen PaleGreen { get; }
    public static GeoPen PaleTurquoise { get; }
    public static GeoPen PaleVioletRed { get; }
    public static GeoPen PapayaWhip { get; }
    public static GeoPen PeachPuff { get; }
    public static GeoPen Peru { get; }
    public static GeoPen Pink { get; }
    public static GeoPen Plum { get; }
    public static GeoPen PowderBlue { get; }
    public static GeoPen Purple { get; }
    public static GeoPen Red { get; }
    public static GeoPen RosyBrown { get; }
    public static GeoPen RoyalBlue { get; }
    public static GeoPen SaddleBrown { get; }
    public static GeoPen Salmon { get; }
    public static GeoPen SandyBrown { get; }
    public static GeoPen SeaGreen { get; }
    public static GeoPen SeaShell { get; }
    public static GeoPen Sienna { get; }
    public static GeoPen Silver { get; }
    public static GeoPen SkyBlue { get; }
    public static GeoPen SlateBlue { get; }
    public static GeoPen SlateGray { get; }
    public static GeoPen Snow { get; }
    public static GeoPen SpringGreen { get; }
    public static GeoPen SteelBlue { get; }
    public static GeoPen Tan { get; }
    public static GeoPen Teal { get; }
    public static GeoPen Thistle { get; }
    public static GeoPen Tomato { get; }
    public static GeoPen Turquoise { get; }
    public static GeoPen Violet { get; }
    public static GeoPen Wheat { get; }
    public static GeoPen White { get; }
    public static GeoPen WhiteSmoke { get; }
    public static GeoPen Yellow { get; }
    public static GeoPen YellowGreen { get; }
    public static GeoPen DarkYellow { get; }
    public static GeoPen LightOrange { get; }
    public static GeoPen PaleRed { get; }
    public static GeoPen PaleBlue { get; }
    public static GeoPen PaleYellow { get; }
    public static GeoPen PaleOrange { get; }
    public static GeoPen BrightRed { get; }
    public static GeoPen BrightBlue { get; }
    public static GeoPen BrightYellow { get; }
    public static GeoPen BrightOrange { get; }
    public static GeoPen PastelRed { get; }
    public static GeoPen PastelBlue { get; }
    public static GeoPen PastelYellow { get; }
    public static GeoPen PastelGreen { get; }
    public static GeoPen PastelOrange { get; }
    public static GeoPen Copper { get; }
    public static GeoPen get_AliceBlue();
    public static GeoPen get_AntiqueWhite();
    public static GeoPen get_Aqua();
    public static GeoPen get_Aquamarine();
    public static GeoPen get_Azure();
    public static GeoPen get_Beige();
    public static GeoPen get_Bisque();
    public static GeoPen get_Black();
    public static GeoPen get_BlanchedAlmond();
    public static GeoPen get_Blue();
    public static GeoPen get_BlueViolet();
    public static GeoPen get_Brown();
    public static GeoPen get_BurlyWood();
    public static GeoPen get_CadetBlue();
    public static GeoPen get_Chartreuse();
    public static GeoPen get_Chocolate();
    public static GeoPen get_Coral();
    public static GeoPen get_CornflowerBlue();
    public static GeoPen get_CornSilk();
    public static GeoPen get_Crimson();
    public static GeoPen get_Cyan();
    public static GeoPen get_DarkBlue();
    public static GeoPen get_DarkCyan();
    public static GeoPen get_DarkGoldenrod();
    public static GeoPen get_DarkGray();
    public static GeoPen get_DarkGreen();
    public static GeoPen get_DarkKhaki();
    public static GeoPen get_DarkMagenta();
    public static GeoPen get_DarkOliveGreen();
    public static GeoPen get_DarkOrange();
    public static GeoPen get_DarkOrchid();
    public static GeoPen get_DarkRed();
    public static GeoPen get_DarkSalmon();
    public static GeoPen get_DarkSeaGreen();
    public static GeoPen get_DarkSlateBlue();
    public static GeoPen get_DarkSlateGray();
    public static GeoPen get_DarkTurquoise();
    public static GeoPen get_DarkViolet();
    public static GeoPen get_DeepPink();
    public static GeoPen get_DeepSkyBlue();
    public static GeoPen get_DimGray();
    public static GeoPen get_DodgerBlue();
    public static GeoPen get_Firebrick();
    public static GeoPen get_FloralWhite();
    public static GeoPen get_ForestGreen();
    public static GeoPen get_Fuchsia();
    public static GeoPen get_Gainsboro();
    public static GeoPen get_GhostWhite();
    public static GeoPen get_Gold();
    public static GeoPen get_Goldenrod();
    public static GeoPen get_Gray();
    public static GeoPen get_Green();
    public static GeoPen get_GreenYellow();
    public static GeoPen get_HoneyDew();
    public static GeoPen get_HotPink();
    public static GeoPen get_IndianRed();
    public static GeoPen get_Indigo();
    public static GeoPen get_Ivory();
    public static GeoPen get_Khaki();
    public static GeoPen get_Lavender();
    public static GeoPen get_LavenderBlush();
    public static GeoPen get_LawnGreen();
    public static GeoPen get_LemonChiffon();
    public static GeoPen get_LightBlue();
    public static GeoPen get_LightCoral();
    public static GeoPen get_LightCyan();
    public static GeoPen get_LightGoldenrodYellow();
    public static GeoPen get_LightGray();
    public static GeoPen get_LightGreen();
    public static GeoPen get_LightPink();
    public static GeoPen get_LightRed();
    public static GeoPen get_LightSalmon();
    public static GeoPen get_LightSeaGreen();
    public static GeoPen get_LightSkyBlue();
    public static GeoPen get_LightSlateGray();
    public static GeoPen get_LightSteelBlue();
    public static GeoPen get_LightYellow();
    public static GeoPen get_Lime();
    public static GeoPen get_LimeGreen();
    public static GeoPen get_Linen();
    public static GeoPen get_Magenta();
    public static GeoPen get_Maroon();
    public static GeoPen get_MediumAquamarine();
    public static GeoPen get_MediumBlue();
    public static GeoPen get_MediumOrchid();
    public static GeoPen get_MediumPurple();
    public static GeoPen get_MediumSeaGreen();
    public static GeoPen get_MediumSlateBlue();
    public static GeoPen get_MediumSpringGreen();
    public static GeoPen get_MediumTurquoise();
    public static GeoPen get_MediumVioletRed();
    public static GeoPen get_MidnightBlue();
    public static GeoPen get_MintCream();
    public static GeoPen get_MistyRose();
    public static GeoPen get_Moccasin();
    public static GeoPen get_NavajoWhite();
    public static GeoPen get_Navy();
    public static GeoPen get_OldLace();
    public static GeoPen get_Olive();
    public static GeoPen get_OliveDrab();
    public static GeoPen get_Orange();
    public static GeoPen get_OrangeRed();
    public static GeoPen get_Orchid();
    public static GeoPen get_PaleGoldenrod();
    public static GeoPen get_PaleGreen();
    public static GeoPen get_PaleTurquoise();
    public static GeoPen get_PaleVioletRed();
    public static GeoPen get_PapayaWhip();
    public static GeoPen get_PeachPuff();
    public static GeoPen get_Peru();
    public static GeoPen get_Pink();
    public static GeoPen get_Plum();
    public static GeoPen get_PowderBlue();
    public static GeoPen get_Purple();
    public static GeoPen get_Red();
    public static GeoPen get_RosyBrown();
    public static GeoPen get_RoyalBlue();
    public static GeoPen get_SaddleBrown();
    public static GeoPen get_Salmon();
    public static GeoPen get_SandyBrown();
    public static GeoPen get_SeaGreen();
    public static GeoPen get_SeaShell();
    public static GeoPen get_Sienna();
    public static GeoPen get_Silver();
    public static GeoPen get_SkyBlue();
    public static GeoPen get_SlateBlue();
    public static GeoPen get_SlateGray();
    public static GeoPen get_Snow();
    public static GeoPen get_SpringGreen();
    public static GeoPen get_SteelBlue();
    public static GeoPen get_Tan();
    public static GeoPen get_Teal();
    public static GeoPen get_Thistle();
    public static GeoPen get_Tomato();
    public static GeoPen get_Turquoise();
    public static GeoPen get_Violet();
    public static GeoPen get_Wheat();
    public static GeoPen get_White();
    public static GeoPen get_WhiteSmoke();
    public static GeoPen get_Yellow();
    public static GeoPen get_YellowGreen();
    public static GeoPen get_DarkYellow();
    public static GeoPen get_LightOrange();
    public static GeoPen get_PaleRed();
    public static GeoPen get_PaleBlue();
    public static GeoPen get_PaleYellow();
    public static GeoPen get_PaleOrange();
    public static GeoPen get_BrightRed();
    public static GeoPen get_BrightBlue();
    public static GeoPen get_BrightYellow();
    public static GeoPen get_BrightOrange();
    public static GeoPen get_PastelRed();
    public static GeoPen get_PastelBlue();
    public static GeoPen get_PastelYellow();
    public static GeoPen get_PastelGreen();
    public static GeoPen get_PastelOrange();
    public static GeoPen get_Copper();
}
public abstract class ThinkGeo.Core.GeoSerializationFormatter : object {
    [ObfuscationAttribute]
private Encoding encoding;
    public Encoding Encoding { get; public set; }
    public Encoding get_Encoding();
    public void set_Encoding(Encoding value);
    public void Save(GeoObjectModel model, Stream stream);
    protected abstract virtual void SaveCore(GeoObjectModel model, Stream stream);
    public GeoObjectModel Load(Stream stream);
    protected abstract virtual GeoObjectModel LoadCore(Stream stream);
}
public class ThinkGeo.Core.GeoSerializer : object {
    [ObfuscationAttribute]
private GeoSerializationFormatter formatter;
    [ObfuscationAttribute]
private GeoObjectModeler modeler;
    [ObfuscationAttribute]
private BindingFlags bindingFlags;
    public GeoSerializationFormatter Formatter { get; public set; }
    public GeoSerializer(GeoSerializationFormatter formatter);
    public GeoSerializationFormatter get_Formatter();
    public void set_Formatter(GeoSerializationFormatter value);
    public void Serialize(object objectToSerialize, string targetPathFilename);
    public void Serialize(object objectToSerialize, Stream targetStream);
    public string Serialize(object objectToSerialize);
    public object Deserialize(string sourcePathFilename, FileAccess readWriteMode);
    public object Deserialize(Stream sourceStream);
    public object Deserialize(string sourceString);
    public object Deserialize(Uri sourceUri);
}
public class ThinkGeo.Core.GeoSolidBrush : GeoBrush {
    [ObfuscationAttribute]
private GeoColor color;
    public GeoColor Color { get; public set; }
    public GeoSolidBrush(GeoColor color);
    public GeoColor get_Color();
    public void set_Color(GeoColor value);
}
public class ThinkGeo.Core.GeoTextureBrush : GeoBrush {
    [ObfuscationAttribute]
private GeoImage geoImage;
    [ObfuscationAttribute]
private GeoBrushWrapMode geoWrapMode;
    [ObfuscationAttribute]
private DrawingRectangleF drawingRectangleF;
    public GeoImage GeoImage { get; }
    public DrawingRectangleF DrawingRectangleF { get; public set; }
    public GeoBrushWrapMode GeoWrapMode { get; public set; }
    public GeoTextureBrush(GeoImage image);
    public GeoTextureBrush(GeoImage image, DrawingRectangleF rectangleF);
    public GeoTextureBrush(GeoImage image, GeoBrushWrapMode wrapMode);
    public GeoTextureBrush(GeoImage image, GeoBrushWrapMode wrapMode, DrawingRectangleF rectangleF);
    public GeoImage get_GeoImage();
    public DrawingRectangleF get_DrawingRectangleF();
    public void set_DrawingRectangleF(DrawingRectangleF value);
    public GeoBrushWrapMode get_GeoWrapMode();
    public void set_GeoWrapMode(GeoBrushWrapMode value);
}
public class ThinkGeo.Core.GeoTiffRasterLayer : RasterLayer {
    [ObfuscationAttribute]
private DrawingQuality drawingQuality;
    public string ImagePathFilename { get; public set; }
    public bool HasBoundingBox { get; }
    public DrawingQuality DrawingQuality { get; public set; }
    public GeoTiffRasterLayer(string imagePathFilename);
    public GeoTiffRasterLayer(string imagePathFilename, string worldfilePathFilename);
    public GeoTiffRasterLayer(string imagePathFilename, RectangleShape imageWorldExtent);
    public string get_ImagePathFilename();
    public void set_ImagePathFilename(string value);
    public virtual bool get_HasBoundingBox();
    public DrawingQuality get_DrawingQuality();
    public void set_DrawingQuality(DrawingQuality value);
    protected virtual void DrawCore(GeoCanvas canvas, Collection`1<SimpleCandidate> labelsInAllLayers);
}
public class ThinkGeo.Core.GeoTiffRasterSource : RasterSource {
    [ObfuscationAttribute]
private static int pixelAmount;
    [ObfuscationAttribute]
private string imagePathFilename;
    [ObfuscationAttribute]
private WorldFile tiffWorldFile;
    [ObfuscationAttribute]
private int previousImageWidth;
    [ObfuscationAttribute]
private int previousImageHeight;
    [ObfuscationAttribute]
private int imageWidth;
    [ObfuscationAttribute]
private int imageHeight;
    [ObfuscationAttribute]
private Int32[] imageBuffer;
    [ObfuscationAttribute]
private RectangleShape imageExtent;
    private Tiff 1CE=;
    [ObfuscationAttribute]
private string worldfilePathFilename;
    [ObfuscationAttribute]
private bool tiffIsTiled;
    [ObfuscationAttribute]
private int rowNumberPerStrip;
    [ObfuscationAttribute]
private int planarConfig;
    [ObfuscationAttribute]
private Dictionary`2<short, DrawingRectangle> levelImageSize;
    [ObfuscationAttribute]
private short directoriesCount;
    [ObfuscationAttribute]
private int tileLength;
    [ObfuscationAttribute]
private int tileWidth;
    [ObfuscationAttribute]
private int tileDepth;
    [ObfuscationAttribute]
private Int64[] tileOffsets;
    [ObfuscationAttribute]
private Int64[] tileBytesCounts;
    [ObfuscationAttribute]
private short samplesPerPixel;
    [ObfuscationAttribute]
private int tilesCount;
    [ObfuscationAttribute]
private int photoMetric;
    private static object 1SE=;
    public string ImagePathFilename { get; public set; }
    public GeoTiffRasterSource(string imagePathFilename);
    public GeoTiffRasterSource(string imagePathFilename, string worldFilePathFilename);
    public GeoTiffRasterSource(string imagePathFilename, RectangleShape imageExtent);
    private static GeoTiffRasterSource();
    public string get_ImagePathFilename();
    public void set_ImagePathFilename(string value);
    protected virtual int GetImageWidthCore();
    protected virtual int GetImageHeightCore();
    protected virtual RectangleShape GetBoundingBoxCore();
    protected virtual void OpenCore();
    protected virtual void CloseCore();
    protected virtual GeoImage GetImageCore(RectangleShape worldExtent, int canvasWidth, int canvasHeight);
    private Dictionary`2<short, double> 1iE=(RectangleShape imageFullExtentInWorld);
    private Dictionary`2<short, double> 1yE=(RectangleShape imageFullExtentInWorld);
    private GeoImage 2CE=(int overlapUpLeftPointXInImage, int overlapUpLeftPointYInImage, int overlapWidthInImage, int overlapHeightInImage, int overlapWidthInScreen, int overlapHeightInScreen);
    private GeoImage 2CE=(RectangleShape worldExtent, int canvasWidth, int canvasHeight);
    private GeoImage 2SE=(int screenX, int screenY, int overlapWidth, int overlapHeight, int tempReturnWidth, int tempReturnHeight);
    private void 2iE=(object tileInfo);
    private WorldFile 2yE=();
    private void 3CE=();
}
public class ThinkGeo.Core.GettingAccessTokenEventArgs : EventArgs {
    [CompilerGeneratedAttribute]
private WebRequest xxQ=;
    [CompilerGeneratedAttribute]
private bool sBQ=;
    public WebRequest WebRequest { get; }
    public bool Cancel { get; public set; }
    public GettingAccessTokenEventArgs(WebRequest webRequest);
    public GettingAccessTokenEventArgs(WebRequest webRequest, bool cancel);
    [CompilerGeneratedAttribute]
public WebRequest get_WebRequest();
    [CompilerGeneratedAttribute]
public bool get_Cancel();
    [CompilerGeneratedAttribute]
public void set_Cancel(bool value);
}
public class ThinkGeo.Core.GettingCacheImageBitmapTileCacheEventArgs : EventArgs {
    [ObfuscationAttribute]
private RasterTile bitmapTile;
    public RasterTile BitmapTile { get; public set; }
    public GettingCacheImageBitmapTileCacheEventArgs(RasterTile bitmapTile);
    public RasterTile get_BitmapTile();
    public void set_BitmapTile(RasterTile value);
}
public class ThinkGeo.Core.GettingCacheTileFileVectorTileCacheEventArgs : EventArgs {
    [ObfuscationAttribute]
private string tilePathFilename;
    [CompilerGeneratedAttribute]
private bool sBQ=;
    [CompilerGeneratedAttribute]
private VectorTile pys=;
    public string TilePathFilename { get; }
    public bool Cancel { get; public set; }
    public VectorTile AlternativeTile { get; public set; }
    public GettingCacheTileFileVectorTileCacheEventArgs(string tilePathFilename);
    public string get_TilePathFilename();
    [CompilerGeneratedAttribute]
public bool get_Cancel();
    [CompilerGeneratedAttribute]
public void set_Cancel(bool value);
    [CompilerGeneratedAttribute]
public VectorTile get_AlternativeTile();
    [CompilerGeneratedAttribute]
public void set_AlternativeTile(VectorTile value);
}
public class ThinkGeo.Core.GettingColumnsFeatureSourceEventArgs : EventArgs {
    [ObfuscationAttribute]
private bool cancel;
    [ObfuscationAttribute]
private Collection`1<FeatureSourceColumn> featureSourceColumns;
    public Collection`1<FeatureSourceColumn> FeatureSourceColumns { get; }
    public bool Cancel { get; public set; }
    public Collection`1<FeatureSourceColumn> get_FeatureSourceColumns();
    public bool get_Cancel();
    public void set_Cancel(bool value);
}
public class ThinkGeo.Core.GettingFeaturesByIdsFeatureSourceEventArgs : EventArgs {
    [ObfuscationAttribute]
private bool cancel;
    [ObfuscationAttribute]
private Collection`1<Feature> features;
    [ObfuscationAttribute]
private Collection`1<string> ids;
    [ObfuscationAttribute]
private Collection`1<string> returningColumnNames;
    [ObfuscationAttribute]
private string filter;
    public string Filter { get; public set; }
    public bool Cancel { get; public set; }
    public Collection`1<string> ReturningColumnNames { get; }
    public Collection`1<Feature> Features { get; }
    public Collection`1<string> Ids { get; }
    public GettingFeaturesByIdsFeatureSourceEventArgs(IEnumerable`1<string> ids, IEnumerable`1<string> returningColumnNames);
    public GettingFeaturesByIdsFeatureSourceEventArgs(IEnumerable`1<string> ids, IEnumerable`1<string> returningColumnNames, string filter);
    public string get_Filter();
    public void set_Filter(string value);
    public bool get_Cancel();
    public void set_Cancel(bool value);
    public Collection`1<string> get_ReturningColumnNames();
    public Collection`1<Feature> get_Features();
    public Collection`1<string> get_Ids();
}
public class ThinkGeo.Core.GettingFeaturesForDrawingFeatureSourceEventArgs : EventArgs {
    [ObfuscationAttribute]
private bool cancel;
    [ObfuscationAttribute]
private string filter;
    [ObfuscationAttribute]
private Collection`1<Feature> features;
    [ObfuscationAttribute]
private RectangleShape worldExtent;
    [ObfuscationAttribute]
private Collection`1<string> returningColumnNames;
    public Collection`1<string> ReturningColumnNames { get; }
    public string Filter { get; }
    public RectangleShape WorldExtent { get; public set; }
    public bool Cancel { get; public set; }
    public Collection`1<Feature> Features { get; }
    public GettingFeaturesForDrawingFeatureSourceEventArgs(RectangleShape worldExtent, IEnumerable`1<string> returningColumnNames);
    public GettingFeaturesForDrawingFeatureSourceEventArgs(RectangleShape worldExtent, IEnumerable`1<string> returningColumnNames, string filter);
    public Collection`1<string> get_ReturningColumnNames();
    public string get_Filter();
    public RectangleShape get_WorldExtent();
    public void set_WorldExtent(RectangleShape value);
    public bool get_Cancel();
    public void set_Cancel(bool value);
    public Collection`1<Feature> get_Features();
}
[ObfuscationAttribute]
internal enum ThinkGeo.Core.Gist_Ext_Id : Enum {
    public int value__;
    public static Gist_Ext_Id rt_point_ext_id;
    public static Gist_Ext_Id rt_rect_ext_id;
    public static Gist_Ext_Id gist_numext;
}
public class ThinkGeo.Core.GoogleMapsAsyncLayer : WebBasedAsyncLayer {
    private static RectangleShape JB4=;
    [ObfuscationAttribute]
private ProjectionConverter projectionFromSphericalMercator;
    [ObfuscationAttribute]
private ProjectionConverter googleWgs84Projection;
    [ObfuscationAttribute]
private double currentRequestSphereResolution;
    [CompilerGeneratedAttribute]
private GoogleMapsPictureFormat JR4=;
    [CompilerGeneratedAttribute]
private GoogleMapsMapType Jh4=;
    [CompilerGeneratedAttribute]
private string Jx4=;
    [CompilerGeneratedAttribute]
private string Bx4=;
    [CompilerGeneratedAttribute]
private string KB4=;
    [CompilerGeneratedAttribute]
private string KR4=;
    [CompilerGeneratedAttribute]
private string Kh4=;
    [CompilerGeneratedAttribute]
private Dictionary`2<string, string> Kx4=;
    [CompilerGeneratedAttribute]
private Projection LB4=;
    public GoogleMapsPictureFormat PictureFormat { get; public set; }
    public GoogleMapsMapType MapType { get; public set; }
    public string Language { get; public set; }
    public string ClientId { get; public set; }
    public string PrivateKey { get; public set; }
    public string UriSigningSecret { get; public set; }
    public string ApiKey { get; public set; }
    public Dictionary`2<string, string> CustomParameters { get; }
    public Projection TargetProjection { get; public set; }
    public GoogleMapsAsyncLayer(string apiKey);
    public GoogleMapsAsyncLayer(string apiKey, string uriSigningSecret);
    private static GoogleMapsAsyncLayer();
    [CompilerGeneratedAttribute]
public GoogleMapsPictureFormat get_PictureFormat();
    [CompilerGeneratedAttribute]
public void set_PictureFormat(GoogleMapsPictureFormat value);
    [CompilerGeneratedAttribute]
public GoogleMapsMapType get_MapType();
    [CompilerGeneratedAttribute]
public void set_MapType(GoogleMapsMapType value);
    [CompilerGeneratedAttribute]
public string get_Language();
    [CompilerGeneratedAttribute]
public void set_Language(string value);
    [CompilerGeneratedAttribute]
public string get_ClientId();
    [CompilerGeneratedAttribute]
public void set_ClientId(string value);
    [CompilerGeneratedAttribute]
public string get_PrivateKey();
    [CompilerGeneratedAttribute]
public void set_PrivateKey(string value);
    [CompilerGeneratedAttribute]
public string get_UriSigningSecret();
    [CompilerGeneratedAttribute]
public void set_UriSigningSecret(string value);
    [CompilerGeneratedAttribute]
public string get_ApiKey();
    [CompilerGeneratedAttribute]
public void set_ApiKey(string value);
    [CompilerGeneratedAttribute]
public Dictionary`2<string, string> get_CustomParameters();
    [CompilerGeneratedAttribute]
public Projection get_TargetProjection();
    [CompilerGeneratedAttribute]
public void set_TargetProjection(Projection value);
    [AsyncStateMachineAttribute("ThinkGeo.Core.GoogleMapsAsyncLayer/ND8=")]
protected virtual Task OpenAsyncCore(CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("ThinkGeo.Core.GoogleMapsAsyncLayer/Lj8=")]
protected virtual Task CloseAsyncCore(CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("ThinkGeo.Core.GoogleMapsAsyncLayer/Mz8=")]
protected virtual Task DrawAsyncCore(GeoCanvas canvas, Collection`1<SimpleCandidate> labelsInAllLayers);
    [AsyncStateMachineAttribute("ThinkGeo.Core.GoogleMapsAsyncLayer/Lz8=")]
protected virtual Task`1<Byte[]> DownloadImageAsyncCore(double width, double height, double scaleFactor, RectangleShape extent, GeographyUnit mapUnit, CancellationToken cancellationToken);
    private RectangleShape LR4=(GeoCanvas canvas);
    private string Lh4=(double latitude, double longitude, int zoomLevelNumber, double tileWidth, double tileHeight, int scaleFactor);
    private static string Lx4=(double newWidth, double newHeight, int zoomLevelNumber, double latitude, double longitude);
    private string MB4=();
    public string GetPictureFormat();
    private string MR4=(string url);
    private string MR4=(string url, string uriSigningSecret);
    private static Byte[] Mh4=(string value);
    [CompilerGeneratedAttribute]
[DebuggerHiddenAttribute]
private Task Ah4=(CancellationToken cancellationToken);
    [DebuggerHiddenAttribute]
[CompilerGeneratedAttribute]
private Task Ax4=(CancellationToken cancellationToken);
}
[ObfuscationAttribute]
internal class ThinkGeo.Core.GoogleMapsLayerImageCache : object {
    [ObfuscationAttribute]
private string cacheDirectory;
    public string 9SE= { get; public set; }
    public bool 9yE= { get; }
    public string 8yE=();
    public void 9CE=(string value);
    public bool 9iE=();
    public string /CE=(GoogleMapsMapType mapType, int zoomlevel, int tileX, int tileY, GoogleMapsPictureFormat pictureFormat);
    public void /SE=(GeoImage image, GoogleMapsMapType mapType, int zoomlevel, int tileX, int tileY, GoogleMapsPictureFormat pictureFormat);
    public GeoImage /iE=(GoogleMapsMapType mapType, int zoomlevel, int tileX, int tileY, GoogleMapsPictureFormat pictureFormat);
    private static string MB4=(GoogleMapsMapType mapType);
    public static GeoImageFormat /yE=(GoogleMapsPictureFormat pictureFormat);
    public static string ACI=(GoogleMapsPictureFormat pictureFormat);
}
public enum ThinkGeo.Core.GoogleMapsMapType : Enum {
    public int value__;
    public static GoogleMapsMapType RoadMap;
    public static GoogleMapsMapType Mobile;
    public static GoogleMapsMapType Satellite;
    public static GoogleMapsMapType Terrain;
    public static GoogleMapsMapType Hybrid;
}
public enum ThinkGeo.Core.GoogleMapsPictureFormat : Enum {
    public int value__;
    public static GoogleMapsPictureFormat Jpeg;
    public static GoogleMapsPictureFormat Gif;
    public static GoogleMapsPictureFormat Png8;
    public static GoogleMapsPictureFormat Png32;
}
public class ThinkGeo.Core.GoogleMapsZoomLevelSet : ZoomLevelSet {
    public GoogleMapsZoomLevelSet(int tileSize);
}
public static class ThinkGeo.Core.GoogleMapValidators : object {
    public static void CheckGoogleMapsTypeIsValid(GoogleMapsMapType mapType, string parameterName);
}
public class ThinkGeo.Core.GottenCacheImageBitmapTileCacheEventArgs : EventArgs {
    [ObfuscationAttribute]
private Tile tile;
    public Tile Tile { get; public set; }
    public GottenCacheImageBitmapTileCacheEventArgs(Tile tile);
    public Tile get_Tile();
    public void set_Tile(Tile value);
}
public class ThinkGeo.Core.GottenColumnsFeatureSourceEventArgs : EventArgs {
    [ObfuscationAttribute]
private Collection`1<FeatureSourceColumn> featureSourceColumns;
    public Collection`1<FeatureSourceColumn> FeatureSourceColumns { get; }
    public GottenColumnsFeatureSourceEventArgs(IEnumerable`1<FeatureSourceColumn> featureSourceColumns);
    public Collection`1<FeatureSourceColumn> get_FeatureSourceColumns();
}
public class ThinkGeo.Core.GottenFeatureValueClassBreakStyleEventArgs : EventArgs {
    [ObfuscationAttribute]
private Feature feature;
    [ObfuscationAttribute]
private string columnName;
    [ObfuscationAttribute]
private double newValue;
    public double Value { get; public set; }
    public Feature Feature { get; public set; }
    public string ColumnName { get; public set; }
    public GottenFeatureValueClassBreakStyleEventArgs(Feature feature, string columnName, double value);
    public double get_Value();
    public void set_Value(double value);
    public Feature get_Feature();
    public void set_Feature(Feature value);
    public string get_ColumnName();
    public void set_ColumnName(string value);
}
public class ThinkGeo.Core.GottenTileFileVectorTileCacheEventArgs : EventArgs {
    [CompilerGeneratedAttribute]
private VectorTile qCs=;
    public VectorTile Tile { get; public set; }
    public GottenTileFileVectorTileCacheEventArgs(VectorTile tile);
    [CompilerGeneratedAttribute]
public VectorTile get_Tile();
    [CompilerGeneratedAttribute]
public void set_Tile(VectorTile value);
}
public class ThinkGeo.Core.GpxFeatureLayer : FeatureLayer {
    public string GpxPathFilename { get; public set; }
    public bool HasBoundingBox { get; }
    public GpxFeatureLayer(string gpxPathFilename);
    public string get_GpxPathFilename();
    public void set_GpxPathFilename(string value);
    public void add_StreamLoading(EventHandler`1<StreamLoadingEventArgs> value);
    public void remove_StreamLoading(EventHandler`1<StreamLoadingEventArgs> value);
    public virtual bool get_HasBoundingBox();
}
public class ThinkGeo.Core.GpxFeatureSource : FeatureSource {
    private static string EiI=;
    [CompilerGeneratedAttribute]
private EventHandler`1<StreamLoadingEventArgs> Eh8=;
    [ObfuscationAttribute]
private string gpxPathFilename;
    [ObfuscationAttribute]
private RectangleShape boundingBox;
    [ObfuscationAttribute]
private InMemoryFeatureSource source;
    [ObfuscationAttribute]
private Collection`1<Feature> segmentPoints;
    [ObfuscationAttribute]
private Dictionary`2<string, FeatureSourceColumn> tempColumns;
    [ObfuscationAttribute]
private Dictionary`2<string, string> metadata;
    public string GpxPathFilename { get; public set; }
    public GpxFeatureSource(string gpxPathFilename);
    [CompilerGeneratedAttribute]
public void add_StreamLoading(EventHandler`1<StreamLoadingEventArgs> value);
    [CompilerGeneratedAttribute]
public void remove_StreamLoading(EventHandler`1<StreamLoadingEventArgs> value);
    public string get_GpxPathFilename();
    public void set_GpxPathFilename(string value);
    protected virtual void OnStreamLoading(StreamLoadingEventArgs e);
    public Dictionary`2<string, string> GetMetadata();
    protected virtual void OpenCore();
    protected virtual void CloseCore();
    protected virtual bool CanGetCountQuicklyCore();
    protected virtual Collection`1<Feature> GetAllFeaturesCore(IEnumerable`1<string> returningColumnNames);
    protected virtual Collection`1<Feature> GetAllFeaturesCore(IEnumerable`1<string> returningColumnNames, int startIndex, int takeCount);
    protected virtual long GetCountCore();
    protected virtual Collection`1<FeatureSourceColumn> GetColumnsCore();
    protected virtual Collection`1<Feature> GetFeaturesInsideBoundingBoxCore(RectangleShape boundingBox, IEnumerable`1<string> returningColumnNames);
    protected virtual RectangleShape GetBoundingBoxCore();
    protected virtual WellKnownType GetFirstFeaturesWellKnownTypeCore();
    private Feature EyI=(XElement wayPointNode);
    private Feature FCI=(XElement routeNode);
    private Feature FSI=(XElement trackNode);
    private LineShape FiI=(XElement trackSeg);
}
public class ThinkGeo.Core.GradientStyle : Style {
    [ObfuscationAttribute]
private string columnName;
    [ObfuscationAttribute]
private GeoColor lowerColor;
    [ObfuscationAttribute]
private double lowerValue;
    [ObfuscationAttribute]
private GeoColor noDataColor;
    [ObfuscationAttribute]
private double noDataValue;
    [ObfuscationAttribute]
private GeoColor upperColor;
    [ObfuscationAttribute]
private double upperValue;
    public string ColumnName { get; public set; }
    public double LowerValue { get; public set; }
    public GeoColor LowerColor { get; public set; }
    public double UpperValue { get; public set; }
    public GeoColor UpperColor { get; public set; }
    public double NoDataValue { get; public set; }
    public GeoColor NoDataColor { get; public set; }
    public GradientStyle(string columnName, double lowerValue, GeoColor lowerColor, double upperValue, GeoColor upperColor);
    public GradientStyle(string columnName, double lowerValue, GeoColor lowerColor, double upperValue, GeoColor upperColor, double noDataValue, GeoColor noDataColor);
    public string get_ColumnName();
    public void set_ColumnName(string value);
    public double get_LowerValue();
    public void set_LowerValue(double value);
    public GeoColor get_LowerColor();
    public void set_LowerColor(GeoColor value);
    public double get_UpperValue();
    public void set_UpperValue(double value);
    public GeoColor get_UpperColor();
    public void set_UpperColor(GeoColor value);
    public double get_NoDataValue();
    public void set_NoDataValue(double value);
    public GeoColor get_NoDataColor();
    public void set_NoDataColor(GeoColor value);
    protected virtual void DrawCore(IEnumerable`1<Feature> features, GeoCanvas canvas, Collection`1<SimpleCandidate> labelsInThisLayer, Collection`1<SimpleCandidate> labelsInAllLayers);
    private GeoColor 1zE=(GeoColor lowerColor, GeoColor upperColor, double value);
    protected virtual Collection`1<string> GetRequiredColumnNamesCore();
}
public class ThinkGeo.Core.GraticuleFeatureLayer : FeatureLayer {
    [ObfuscationAttribute]
private GraticuleFeatureSource graticuleFeatureSource;
    [ObfuscationAttribute]
private LineStyle graticuleLineStyle;
    [ObfuscationAttribute]
private GeoFont graticuleTextFont;
    [ObfuscationAttribute]
private GeoBrush graticuleTextBrush;
    [ObfuscationAttribute]
private GeoPen graticuleTextHaloPen;
    public LineStyle GraticuleLineStyle { get; public set; }
    public GeoFont GraticuleTextFont { get; public set; }
    public GeoBrush GraticuleTextBrush { get; public set; }
    public WrappingMode WrappingMode { get; public set; }
    public RectangleShape WrappingExtent { get; public set; }
    public GeoPen GraticuleTextHaloPen { get; public set; }
    public GraticuleFeatureLayer(int graticuleDensity);
    public LineStyle get_GraticuleLineStyle();
    public void set_GraticuleLineStyle(LineStyle value);
    public GeoFont get_GraticuleTextFont();
    public void set_GraticuleTextFont(GeoFont value);
    public GeoBrush get_GraticuleTextBrush();
    public void set_GraticuleTextBrush(GeoBrush value);
    public WrappingMode get_WrappingMode();
    public void set_WrappingMode(WrappingMode value);
    public RectangleShape get_WrappingExtent();
    public void set_WrappingExtent(RectangleShape value);
    public GeoPen get_GraticuleTextHaloPen();
    public void set_GraticuleTextHaloPen(GeoPen value);
    protected virtual bool IsDrawingNeededCore(double currentScale);
    protected virtual void DrawCore(GeoCanvas canvas, Collection`1<SimpleCandidate> labelsInAllLayers);
}
public class ThinkGeo.Core.GraticuleFeatureSource : FeatureSource {
    [ObfuscationAttribute]
private FeatureSourceColumn graticuleLabelColumn;
    private int KCI=;
    [ObfuscationAttribute]
private WrappingMode wrappingMode;
    private Collection`1<double> KSI=;
    [ObfuscationAttribute]
private RectangleShape wrappingExtent;
    private static Collection`1<double> KiI=;
    private static Collection`1<double> KyI=;
    internal FeatureSourceColumn LSI= { get; }
    public WrappingMode WrappingMode { get; public set; }
    public RectangleShape WrappingExtent { get; public set; }
    public int GraticuleDensity { get; public set; }
    private static GraticuleFeatureSource();
    internal FeatureSourceColumn LCI=();
    public WrappingMode get_WrappingMode();
    public void set_WrappingMode(WrappingMode value);
    public RectangleShape get_WrappingExtent();
    public void set_WrappingExtent(RectangleShape value);
    public int get_GraticuleDensity();
    public void set_GraticuleDensity(int value);
    protected virtual Collection`1<FeatureSourceColumn> GetColumnsCore();
    protected virtual Collection`1<Feature> GetAllFeaturesCore(IEnumerable`1<string> returningColumnNames);
    protected virtual Collection`1<Feature> GetFeaturesForDrawingCore(RectangleShape boundingBox, double screenWidth, double screenHeight, IEnumerable`1<string> returningColumnNames);
    internal Collection`1<Feature> LiI=(RectangleShape extent, float scaleFactor);
    internal Collection`1<Feature> LyI=(RectangleShape extent, float scaleFcator);
    private Collection`1<Feature> MCI=(RectangleShape extent, double currentMinX, double currentMaxX, double currentMaxY, double currentMinY, double increment, double dividor);
    private Collection`1<Feature> MSI=(RectangleShape extent, double currentMinX, double currentMaxX, double currentMaxY, double currentMinY, double increment, double dividor);
    private Vertex MiI=(double x, double y, bool isWrappingLeft);
    private FyI= MyI=(RectangleShape extent);
    private RectangleShape NCI=(RectangleShape extent);
    private static double NSI=(Collection`1<double> values);
    private static double NiI=(Collection`1<double> values);
    private double NyI=(RectangleShape currentExtentWidth, double divisor, GeographyUnit mapUnit);
    private static string OCI=(double value, PyI= lineType, double increment);
    private static double OSI=(double number, double interval);
    private static double OiI=(double number, double interval);
    private void OyI=();
    [CompilerGeneratedAttribute]
private Feature PCI=(Feature f);
}
public class ThinkGeo.Core.GridCell : object {
    [ObfuscationAttribute]
private double centerX;
    [ObfuscationAttribute]
private double centerY;
    [ObfuscationAttribute]
private double value;
    [ObfuscationAttribute]
private double weight;
    public double CenterX { get; public set; }
    public double CenterY { get; public set; }
    public double Value { get; public set; }
    public double Weight { get; public set; }
    public GridCell(double centerX, double centerY, double value);
    public GridCell(double centerX, double centerY, double value, double weight);
    public double get_CenterX();
    public void set_CenterX(double value);
    public double get_CenterY();
    public void set_CenterY(double value);
    public double get_Value();
    public void set_Value(double value);
    public double get_Weight();
    public void set_Weight(double value);
    public virtual int GetHashCode();
}
public class ThinkGeo.Core.GridDefinition : object {
    [ObfuscationAttribute]
private RectangleShape gridExtent;
    [ObfuscationAttribute]
private Dictionary`2<PointShape, double> dataPoints;
    [ObfuscationAttribute]
private double cellSize;
    [ObfuscationAttribute]
private double noDataValue;
    [CompilerGeneratedAttribute]
private FeatureSource hiI=;
    [CompilerGeneratedAttribute]
private string hyI=;
    public FeatureSource DataPointsFeatureSource { get; public set; }
    public string DataPointsFeatureSourceColumnName { get; public set; }
    public RectangleShape GridExtent { get; public set; }
    public Dictionary`2<PointShape, double> DataPoints { get; }
    public double CellSize { get; public set; }
    public double NoDataValue { get; public set; }
    public GridDefinition(RectangleShape gridExtent, double cellSize, double noDataValue, Dictionary`2<PointShape, double> dataPoints);
    [CompilerGeneratedAttribute]
public FeatureSource get_DataPointsFeatureSource();
    [CompilerGeneratedAttribute]
public void set_DataPointsFeatureSource(FeatureSource value);
    [CompilerGeneratedAttribute]
public string get_DataPointsFeatureSourceColumnName();
    [CompilerGeneratedAttribute]
public void set_DataPointsFeatureSourceColumnName(string value);
    public RectangleShape get_GridExtent();
    public void set_GridExtent(RectangleShape value);
    public Dictionary`2<PointShape, double> get_DataPoints();
    public double get_CellSize();
    public void set_CellSize(double value);
    public double get_NoDataValue();
    public void set_NoDataValue(double value);
}
public class ThinkGeo.Core.GridFeatureLayer : FeatureLayer {
    public string PathFilename { get; public set; }
    public double CellSize { get; }
    public int NumberOfColumns { get; }
    public int NumberOfRows { get; }
    public double NoDataValue { get; }
    public bool HasBoundingBox { get; }
    public string DataValueColumnName { get; }
    public GridFeatureLayer(string gridPathFilename);
    public string get_PathFilename();
    public void set_PathFilename(string value);
    public double get_CellSize();
    public int get_NumberOfColumns();
    public int get_NumberOfRows();
    public double get_NoDataValue();
    public virtual bool get_HasBoundingBox();
    public string get_DataValueColumnName();
    protected virtual RectangleShape GetBoundingBoxCore();
    public static void GenerateGrid(GridDefinition gridDefinition, GridInterpolationModel gridInterpolationModel, Stream outputStream, Func`2<double, string> cellValueToStringFunc);
    public static GridCell[0...,0...] GenerateGridMatrix(GridDefinition gridDefinition, GridInterpolationModel gridInterpolationModel);
    public GridCell[0...,0...] GenerateGridMatrix();
    public void add_StreamLoading(EventHandler`1<StreamLoadingEventArgs> value);
    public void remove_StreamLoading(EventHandler`1<StreamLoadingEventArgs> value);
}
public class ThinkGeo.Core.GridFeatureSource : FeatureSource {
    private static string QiI=;
    [ObfuscationAttribute]
private double cellSize;
    [ObfuscationAttribute]
private Collection`1<FeatureSourceColumn> featureSourceColumns;
    [ObfuscationAttribute]
private RectangleShape gridExtent;
    [ObfuscationAttribute]
private string pathFilename;
    [ObfuscationAttribute]
private PointShape lowerLeftPoint;
    [ObfuscationAttribute]
private double noDataValue;
    [ObfuscationAttribute]
private int columnCount;
    [ObfuscationAttribute]
private int rowCount;
    [ObfuscationAttribute]
private string gridValuesString;
    [ObfuscationAttribute]
private int gridValuesDimension0Length;
    [ObfuscationAttribute]
private int gridValuesDimension1Length;
    private bool pBo=;
    private Double[0...,0...] QyI=;
    [CompilerGeneratedAttribute]
private static EventHandler`1<GeneratingGridFeatureSourceEventArgs> RCI=;
    [CompilerGeneratedAttribute]
private EventHandler`1<StreamLoadingEventArgs> Eh8=;
    private static Byte[] RSI=;
    public string PathFilename { get; public set; }
    public double CellSize { get; }
    public int NumberOfColumns { get; }
    public int NumberOfRows { get; }
    public PointShape LowerLeftPoint { get; }
    public double NoDataValue { get; }
    public bool IsEditable { get; }
    public string DataValueColumnName { get; }
    public GridFeatureSource(string gridPathFilename);
    private static GridFeatureSource();
    [CompilerGeneratedAttribute]
public static void add_GeneratingGrid(EventHandler`1<GeneratingGridFeatureSourceEventArgs> value);
    [CompilerGeneratedAttribute]
public static void remove_GeneratingGrid(EventHandler`1<GeneratingGridFeatureSourceEventArgs> value);
    [CompilerGeneratedAttribute]
public void add_StreamLoading(EventHandler`1<StreamLoadingEventArgs> value);
    [CompilerGeneratedAttribute]
public void remove_StreamLoading(EventHandler`1<StreamLoadingEventArgs> value);
    public string get_PathFilename();
    public void set_PathFilename(string value);
    public double get_CellSize();
    public int get_NumberOfColumns();
    public int get_NumberOfRows();
    public PointShape get_LowerLeftPoint();
    public double get_NoDataValue();
    public virtual bool get_IsEditable();
    public string get_DataValueColumnName();
    protected virtual void OpenCore();
    protected virtual void OnStreamLoading(StreamLoadingEventArgs e);
    protected virtual void CloseCore();
    protected virtual Collection`1<FeatureSourceColumn> GetColumnsCore();
    protected virtual TransactionResult CommitTransactionCore(TransactionBuffer transactions);
    protected virtual Collection`1<Feature> GetAllFeaturesCore(IEnumerable`1<string> returningColumnNames);
    protected virtual RectangleShape GetBoundingBoxCore();
    protected virtual long GetCountCore();
    protected virtual Collection`1<Feature> GetFeaturesForDrawingCore(RectangleShape boundingBox, double screenWidth, double screenHeight, IEnumerable`1<string> returningColumnNames);
    protected virtual Collection`1<Feature> GetFeaturesInsideBoundingBoxCore(RectangleShape boundingBox, IEnumerable`1<string> returningColumnNames);
    protected virtual Collection`1<string> GetFeatureIdsCore();
    private Byte[] RiI=(double x1, double y1, double x2, double y2);
    private static String[] RyI=(string stringToSplit);
    public static GridCell[0...,0...] GenerateGridMatrix(GridDefinition gridDefinition, GridInterpolationModel gridInterpolationModel);
    public GridCell[0...,0...] GenerateGridMatrix();
    public static GridCell[0...,0...] ReplaceNoDataValue(GridCell[0...,0...] gridMatrix, double noDataValue);
    public static GridCell[0...,0...] ReplaceNoDataValue(GridCell[0...,0...] gridMatrix, double noDataValue, GridInterpolationModel gridInterpolationModel);
    public static void GenerateGrid(GridDefinition gridDefinition, GridInterpolationModel gridInterpolationModel, Stream outputStream, Func`2<double, string> cellValueToStringFunc);
    public static void SaveGridsToStream(GridCell[0...,0...] cells, double noDataValue, Stream outputStream, Func`2<double, string> cellValueToStringFunc);
    public static void SaveGridsToGrdFile(GridCell[0...,0...] cells, double noDataValue, string outputFilePath, Func`2<double, string> cellValueToStringFunc);
    [OnGeoserializingAttribute]
private void SCI=();
    [OnGeodeserializedAttribute]
private void SSI=();
    private void SiI=();
    private static void SyI=(GeneratingGridFeatureSourceEventArgs e);
}
public abstract class ThinkGeo.Core.GridInterpolationModel : object {
    public ValueTuple`2<double, double> Interpolate(RectangleShape cellExtent, GridDefinition gridDefinition);
    protected abstract virtual ValueTuple`2<double, double> InterpolateCore(RectangleShape cellExtent, GridDefinition gridDefinition);
}
public class ThinkGeo.Core.GridIsoLineLayer : IsoLineLayer {
    [ObfuscationAttribute]
private GridFeatureSource gridFeatureSource;
    [ObfuscationAttribute]
private Collection`1<Feature> cachedIsoLines;
    [ObfuscationAttribute]
private int previousGridMatrixCount;
    [ObfuscationAttribute]
private int previousGridMatrixHashCode;
    [ObfuscationAttribute]
private int previousIsoLineLevelsCount;
    [ObfuscationAttribute]
private int previousIsoLineLevelsHashCode;
    [ObfuscationAttribute]
private string previousDataValueColumnName;
    [ObfuscationAttribute]
private string gridMatrixString;
    [ObfuscationAttribute]
private int gridMatrixDimension0Length;
    [ObfuscationAttribute]
private int gridMatrixDimension1Length;
    private bool pBo=;
    private GridCell[0...,0...] 7CI=;
    [CompilerGeneratedAttribute]
private EventHandler`1<StreamLoadingEventArgs> Eh8=;
    public string GridPathFilename { get; public set; }
    public GridIsoLineLayer(string gridPathFilename);
    public GridIsoLineLayer(string gridPathFilename, IEnumerable`1<double> isoLineLevels);
    public GridIsoLineLayer(string gridPathFilename, IEnumerable`1<double> isoLineLevels, double lowerScale, double upperScale);
    public GridIsoLineLayer(string gridPathFilename, IEnumerable`1<double> isoLineLevels, double lowerScale, double upperScale, IsoLineType isoLineType);
    [CompilerGeneratedAttribute]
public void add_StreamLoading(EventHandler`1<StreamLoadingEventArgs> value);
    [CompilerGeneratedAttribute]
public void remove_StreamLoading(EventHandler`1<StreamLoadingEventArgs> value);
    private void 7SI=(object sender, StreamLoadingEventArgs e);
    [OnGeoserializingAttribute]
private void SCI=();
    [OnGeodeserializedAttribute]
private void SSI=();
    protected virtual void OpenCore();
    public string get_GridPathFilename();
    public void set_GridPathFilename(string value);
    public Collection`1<Feature> GetIsoLineFeatures();
    protected virtual void OnStreamLoading(StreamLoadingEventArgs e);
    protected virtual Collection`1<Feature> GetFeaturesForDrawingCore(GeoCanvas canvas, Collection`1<SimpleCandidate> labelsInAllLayers);
    private bool 7iI=();
    private void 7yI=();
}
public class ThinkGeo.Core.GroupLayer : Layer {
    [ObfuscationAttribute]
private GeoCollection`1<Layer> layers;
    public GeoCollection`1<Layer> Layers { get; }
    public bool HasBoundingBox { get; }
    public GroupLayer(IEnumerable`1<Layer> layers);
    public GeoCollection`1<Layer> get_Layers();
    public virtual bool get_HasBoundingBox();
    protected virtual void OpenCore();
    protected virtual void CloseCore();
    protected virtual RectangleShape GetBoundingBoxCore();
    protected virtual void DrawCore(GeoCanvas canvas, Collection`1<SimpleCandidate> labelsInAllLayers);
}
[ObfuscationAttribute]
internal class ThinkGeo.Core.HeaderPage : RTPage {
    [ObfuscationAttribute]
private FileHeader fileHeader;
    public FileHeader mx8= { get; public set; }
    public HeaderPage(RtreeFile rtFile);
    public HeaderPage(RtreeFile rtFile, UInt32 pageNo, Gist_Ext_Id extId);
    public FileHeader mR8=();
    public void mh8=(FileHeader value);
    public bool pBw=();
    public bool shw=();
    public virtual string kR8=();
}
public class ThinkGeo.Core.HeatStyle : Style {
    [ObfuscationAttribute]
private int alpha;
    [ObfuscationAttribute]
private Collection`1<GeoColor> colorPalette;
    [ObfuscationAttribute]
private string intensityColumnName;
    [ObfuscationAttribute]
private double intensityRangeEnd;
    [ObfuscationAttribute]
private double intensityRangeStart;
    [ObfuscationAttribute]
private int pointIntensity;
    [ObfuscationAttribute]
private double pointRadius;
    [ObfuscationAttribute]
private DistanceUnit pointRadiusUnit;
    private static int kCI=;
    public int PointIntensity { get; public set; }
    public int Alpha { get; public set; }
    public double IntensityRangeStart { get; public set; }
    public double IntensityRangeEnd { get; public set; }
    public string IntensityColumnName { get; public set; }
    public double PointRadius { get; public set; }
    public DistanceUnit PointRadiusUnit { get; public set; }
    public Collection`1<GeoColor> ColorPalette { get; }
    public HeatStyle(int pointIntensity);
    public HeatStyle(int pointIntensity, int alpha);
    public HeatStyle(int pointIntensity, double pointRadius, DistanceUnit pointRadiusUnit);
    public HeatStyle(int pointIntensity, int alpha, double pointRadius, DistanceUnit pointRadiusUnit);
    public HeatStyle(string intensityColumnName, double intensityRangeStart, double intensityRangeEnd);
    public HeatStyle(int alpha, string intensityColumnName, double intensityRangeStart, double intensityRangeEnd);
    public HeatStyle(string intensityColumnName, double intensityRangeStart, double intensityRangeEnd, double pointRadius, DistanceUnit pointRadiusUnit);
    public HeatStyle(int alpha, string intensityColumnName, double intensityRangeStart, double intensityRangeEnd, double pointRadius, DistanceUnit pointRadiusUnit);
    public HeatStyle(int pointIntensity, int alpha, string intensityColumnName, double intensityRangeStart, double intensityRangeEnd, double pointRadius, DistanceUnit pointRadiusUnit, GeoColor baseColor);
    public HeatStyle(int pointIntensity, int alpha, string intensityColumnName, double intensityRangeStart, double intensityRangeEnd, double pointRadius, DistanceUnit pointRadiusUnit, GeoColor fromColor, GeoColor toColor, ColorWheelDirection colorWheelDirection);
    private static HeatStyle();
    public int get_PointIntensity();
    public void set_PointIntensity(int value);
    public int get_Alpha();
    public void set_Alpha(int value);
    public double get_IntensityRangeStart();
    public void set_IntensityRangeStart(double value);
    public double get_IntensityRangeEnd();
    public void set_IntensityRangeEnd(double value);
    public string get_IntensityColumnName();
    public void set_IntensityColumnName(string value);
    public double get_PointRadius();
    public void set_PointRadius(double value);
    public DistanceUnit get_PointRadiusUnit();
    public void set_PointRadiusUnit(DistanceUnit value);
    public Collection`1<GeoColor> get_ColorPalette();
    protected virtual void DrawCore(IEnumerable`1<Feature> features, GeoCanvas canvas, Collection`1<SimpleCandidate> labelsInThisLayer, Collection`1<SimpleCandidate> labelsInAllLayers);
    protected virtual Collection`1<string> GetRequiredColumnNamesCore();
    private float kSI=(GeoCanvas canvas);
    private static double kiI=(string value, double lowValue, double highValue);
    private static double kyI=(double degrees);
    private static mxU=[] lCI=(byte alpha, Collection`1<GeoColor> colorPalette);
}
public class ThinkGeo.Core.HereMapsRasterTileAsyncLayer : XyzTileAsyncLayer {
    private static int /B0=;
    private static string Mx4=;
    private string NB4=;
    private string NR4=;
    private string Nh4=;
    [CompilerGeneratedAttribute]
private string Kh4=;
    [CompilerGeneratedAttribute]
private HereMapsRasterType Jh4=;
    [CompilerGeneratedAttribute]
private HereMapsRasterTileFormat Nx4=;
    [CompilerGeneratedAttribute]
private Dictionary`2<string, string> OB4=;
    public string ApiKey { get; public set; }
    public HereMapsRasterType MapType { get; public set; }
    public HereMapsRasterTileFormat Format { get; public set; }
    public Dictionary`2<string, string> Parameters { get; }
    public HereMapsRasterTileAsyncLayer(string apiKey);
    public HereMapsRasterTileAsyncLayer(string apiKey, HereMapsRasterType mapType);
    [CompilerGeneratedAttribute]
public string get_ApiKey();
    [CompilerGeneratedAttribute]
public void set_ApiKey(string value);
    [CompilerGeneratedAttribute]
public HereMapsRasterType get_MapType();
    [CompilerGeneratedAttribute]
public void set_MapType(HereMapsRasterType value);
    [CompilerGeneratedAttribute]
public HereMapsRasterTileFormat get_Format();
    [CompilerGeneratedAttribute]
public void set_Format(HereMapsRasterTileFormat value);
    [CompilerGeneratedAttribute]
public Dictionary`2<string, string> get_Parameters();
    protected virtual Task`1<string> GetImageUriAsyncCore(int zoomLevel, long x, long y, float resolutionFactor);
}
public enum ThinkGeo.Core.HereMapsRasterTileFormat : Enum {
    public int value__;
    public static HereMapsRasterTileFormat Png;
    public static HereMapsRasterTileFormat Png8;
    public static HereMapsRasterTileFormat Jpg;
}
public enum ThinkGeo.Core.HereMapsRasterType : Enum {
    public int value__;
    public static HereMapsRasterType BaseMap;
    public static HereMapsRasterType Aerial;
    public static HereMapsRasterType Hybrid;
}
public class ThinkGeo.Core.HereMapsZoomLevelSet : ZoomLevelSet {
}
public class ThinkGeo.Core.HueFamilyAreaStyle : AreaStyle {
    [ObfuscationAttribute]
private Collection`1<AreaStyle> areaStyles;
    [ObfuscationAttribute]
private Dictionary`2<string, AreaStyle> cache;
    [ObfuscationAttribute]
private int numberOfColors;
    public int NumberOfColors { get; public set; }
    public Dictionary`2<string, AreaStyle> Cache { get; }
    public GeoColor BaseColor { get; public set; }
    public HueFamilyAreaStyle(GeoPen outlinePen, GeoColor baseColor, int numberOfColors);
    public HueFamilyAreaStyle(GeoPen outlinePen, GeoColor baseColor, int numberOfColors, PenBrushDrawingOrder penBrushDrawingOrder);
    public int get_NumberOfColors();
    public void set_NumberOfColors(int value);
    public Dictionary`2<string, AreaStyle> get_Cache();
    public GeoColor get_BaseColor();
    public void set_BaseColor(GeoColor value);
    public void ClearCache();
    protected virtual void DrawCore(IEnumerable`1<Feature> features, GeoCanvas canvas, Collection`1<SimpleCandidate> labelsInThisLayer, Collection`1<SimpleCandidate> labelsInAllLayers);
}
public class ThinkGeo.Core.IconStyle : TextStyle {
    [ObfuscationAttribute]
private GeoImage iconImage;
    [ObfuscationAttribute]
private double iconImageScale;
    [ObfuscationAttribute]
private string iconPathFilename;
    public string IconPathFilename { get; public set; }
    public GeoImage IconImage { get; public set; }
    public double IconImageScale { get; public set; }
    public bool SuppressPartialLabels { get; public set; }
    private bool 3DE= { get; }
    public IconStyle(string iconPathFilename, string textColumnName, GeoFont textFont, GeoBrush textBrush);
    public IconStyle(GeoImage iconImage, string textColumnName, GeoFont textFont, GeoBrush textBrush);
    public string get_IconPathFilename();
    public void set_IconPathFilename(string value);
    public GeoImage get_IconImage();
    public void set_IconImage(GeoImage value);
    public double get_IconImageScale();
    public void set_IconImageScale(double value);
    public bool get_SuppressPartialLabels();
    public void set_SuppressPartialLabels(bool value);
    private bool 2zE=();
    protected virtual void DrawSampleCore(GeoCanvas canvas, DrawingRectangleF drawingExtent);
    protected virtual void DrawCore(IEnumerable`1<Feature> features, GeoCanvas canvas, Collection`1<SimpleCandidate> labelsInThisLayer, Collection`1<SimpleCandidate> labelsInAllLayers);
    protected virtual Collection`1<LabelingCandidate> GetLabelingCandidateCore(Feature feature, GeoCanvas canvas, GeoFont font, float xOffsetInPixel, float yOffsetInPixel, double rotationAngle);
    private void 3TE=(GeoImage imageForIcon, Feature feature, GeoCanvas canvas, int imageWidth, int imageHeight, GeoFont font, float xOffsetInPixel, float yOffsetInPixel, double rotationAngle, Collection`1<SimpleCandidate> labelsInThisLayer, Collection`1<SimpleCandidate> labelsInAllLayers);
    private static RectangleShape 3jE=(PointShape centerPoint, int imageWidth, int imageHeight);
}
public class ThinkGeo.Core.IconValueItem : object {
    [ObfuscationAttribute]
private string fieldValue;
    [ObfuscationAttribute]
private string iconFilePathName;
    [ObfuscationAttribute]
private GeoImage iconImage;
    [ObfuscationAttribute]
private TextStyle textStyle;
    [ObfuscationAttribute]
private int textValueLengthMin;
    [ObfuscationAttribute]
private int textValueLengthMax;
    public TextStyle TextStyle { get; public set; }
    public string FieldValue { get; public set; }
    public string IconFilePathName { get; public set; }
    public int TextValueLengthMin { get; public set; }
    public int TextValueLengthMax { get; public set; }
    public IconValueItem(string fieldValue, string iconPathFilename, TextStyle textStyle);
    public IconValueItem(string fieldValue, GeoImage iconImage, TextStyle textStyle);
    public TextStyle get_TextStyle();
    public void set_TextStyle(TextStyle value);
    public string get_FieldValue();
    public void set_FieldValue(string value);
    public string get_IconFilePathName();
    public void set_IconFilePathName(string value);
    public int get_TextValueLengthMin();
    public void set_TextValueLengthMin(int value);
    public int get_TextValueLengthMax();
    public void set_TextValueLengthMax(int value);
    public GeoImage GetIconImage();
}
public class ThinkGeo.Core.IconValueStyle : PositionStyle {
    private static double 2DE=;
    private static int 2TE=;
    private static double 2jE=;
    [ObfuscationAttribute]
private string columnName;
    [ObfuscationAttribute]
private Dictionary`2<int, GeoImage> geoImageCache;
    [ObfuscationAttribute]
private Dictionary`2<int, int> geoImageHeightCache;
    [ObfuscationAttribute]
private Dictionary`2<int, int> geoImageWidthCache;
    [ObfuscationAttribute]
private Collection`1<IconValueItem> iconValueItems;
    [ObfuscationAttribute]
private int previousValueItemId;
    public string ColumnName { get; public set; }
    public Collection`1<IconValueItem> IconValueItems { get; }
    private bool 3DE= { get; }
    public IconValueStyle(string columnName);
    public IconValueStyle(string columnName, IEnumerable`1<IconValueItem> iconValueItems);
    public string get_ColumnName();
    public void set_ColumnName(string value);
    public Collection`1<IconValueItem> get_IconValueItems();
    private bool 2zE=();
    protected virtual void DrawCore(IEnumerable`1<Feature> features, GeoCanvas canvas, Collection`1<SimpleCandidate> labelsInThisLayer, Collection`1<SimpleCandidate> labelsInAllLayers);
    protected virtual Collection`1<string> GetRequiredColumnNamesCore();
    protected virtual Collection`1<LabelingCandidate> GetLabelingCandidateCore(Feature feature, GeoCanvas canvas, GeoFont font, float xOffsetInPixel, float yOffsetInPixel, double rotationAngle);
    private void 3TE=(Feature feature, GeoCanvas canvas, GeoFont font, GeoBrush textBrush, GeoPen haloPen, DrawingLevel drawingLevel, float xOffsetInPixel, float yOffsetInPixel, DrawingTextAlignment alignment, double rotationAngle, Collection`1<SimpleCandidate> labelsInThisLayer, Collection`1<SimpleCandidate> labelsInAllLayers);
    private static RectangleShape 3jE=(PointShape centerPoint, int imageWidth, int imageHeight);
    private int 3zE=(Feature feature, GeoCanvas canvas);
    private void 4DE=(TextStyle textStyle);
}
[ObfuscationAttribute]
internal class ThinkGeo.Core.IdsEngine : object {
    [ObfuscationAttribute]
private int recordLength;
    [ObfuscationAttribute]
private int headerLength;
    private static int 4x4=;
    private static int nh8=;
    private Stream nx8=;
    private Stream oB8=;
    [ObfuscationAttribute]
private IdsRecord idsRecord;
    [ObfuscationAttribute]
private IdsHeader idsHeader;
    [ObfuscationAttribute]
private Byte[] cache;
    [ObfuscationAttribute]
private int startIndex;
    [ObfuscationAttribute]
private int endIndex;
    [CompilerGeneratedAttribute]
private EventHandler`1<StreamLoadingEventArgs> Eh8=;
    [CompilerGeneratedAttribute]
public void oR8=(EventHandler`1<StreamLoadingEventArgs> value);
    [CompilerGeneratedAttribute]
public void oh8=(EventHandler`1<StreamLoadingEventArgs> value);
    internal virtual void pB8=(StreamLoadingEventArgs e);
    public bool GR8=(string fileName, FileAccess readWriteMode);
    public void pR8=();
    public void gx8=();
    public string ph8=(int block);
    public void px8=();
    public int qB8=(string id);
    public static void qR8=(string fileName);
    private static Byte[] qh8=(int intValue, byte byteOrder);
}
public interface ThinkGeo.Core.IGeoCanvasRotatable {
    public double RotationAngle { get; public set; }
    public double PivotX { get; public set; }
    public double PivotY { get; public set; }
    public abstract virtual double get_RotationAngle();
    public abstract virtual void set_RotationAngle(double value);
    public abstract virtual double get_PivotX();
    public abstract virtual void set_PivotX(double value);
    public abstract virtual double get_PivotY();
    public abstract virtual void set_PivotY(double value);
}
public class ThinkGeo.Core.InMemoryFeatureLayer : FeatureLayer {
    [ObfuscationAttribute]
private Collection`1<FeatureSourceColumn> featureSourceColumns;
    public Collection`1<FeatureSourceColumn> Columns { get; }
    public GeoCollection`1<Feature> InternalFeatures { get; }
    public bool HasBoundingBox { get; }
    public InMemoryFeatureLayer(IEnumerable`1<FeatureSourceColumn> featureSourceColumns);
    public InMemoryFeatureLayer(IEnumerable`1<FeatureSourceColumn> featureSourceColumns, IEnumerable`1<Feature> features);
    public InMemoryFeatureLayer(IEnumerable`1<FeatureSourceColumn> featureSourceColumns, IEnumerable`1<BaseShape> shapes);
    public Collection`1<FeatureSourceColumn> get_Columns();
    public GeoCollection`1<Feature> get_InternalFeatures();
    public virtual bool get_HasBoundingBox();
    public Collection`1<FeatureSourceColumn> GetColumns();
    protected virtual void OpenCore();
    public void BuildIndex();
    public void Clear();
}
public class ThinkGeo.Core.InMemoryFeatureSource : FeatureSource {
    private static string YyA=;
    [ObfuscationAttribute]
private Collection`1<FeatureSourceColumn> columns;
    [ObfuscationAttribute]
private GeoCollection`1<Feature> internalFeatures;
    private STRtree`1<string> ZCA=;
    internal Collection`1<FeatureSourceColumn> ZiA= { get; }
    public GeoCollection`1<Feature> InternalFeatures { get; }
    public bool IsEditable { get; }
    protected bool CanExecuteSqlQueryCore { get; }
    public InMemoryFeatureSource(IEnumerable`1<FeatureSourceColumn> featureSourceColumns);
    public InMemoryFeatureSource(IEnumerable`1<FeatureSourceColumn> featureSourceColumns, IEnumerable`1<Feature> features);
    public InMemoryFeatureSource(IEnumerable`1<FeatureSourceColumn> featureSourceColumns, IEnumerable`1<BaseShape> shapes);
    internal Collection`1<FeatureSourceColumn> ZSA=();
    public GeoCollection`1<Feature> get_InternalFeatures();
    public virtual bool get_IsEditable();
    protected virtual bool get_CanExecuteSqlQueryCore();
    private void ZyA=(IEnumerable`1<FeatureSourceColumn> featureSourceColumns, IEnumerable`1<Feature> features);
    public void BuildIndex();
    public void Clear();
    protected virtual long GetCountCore();
    protected virtual TransactionResult CommitTransactionCore(TransactionBuffer transactions);
    private void aCA=(Collection`1<FeatureSourceColumn> addBuffer, TransactionResult transactionResult);
    private void aSA=(Dictionary`2<string, Feature> addBuffer, TransactionResult transactionResult);
    private void aiA=(Collection`1<string> deleteBuffer, TransactionResult transactionResult);
    private void ayA=(Collection`1<string> deleteBuffer, TransactionResult transactionResult);
    private void bCA=(Dictionary`2<string, FeatureSourceColumn> editBuffer, TransactionResult transactionResult);
    private void bSA=(Dictionary`2<string, Feature> editBuffer, TransactionResult transactionResult);
    protected virtual Collection`1<Feature> GetAllFeaturesCore(IEnumerable`1<string> returningColumnNames);
    protected virtual Collection`1<Feature> GetAllFeaturesCore(IEnumerable`1<string> returningColumnNames, int startIndex, int takeCount);
    protected virtual Collection`1<Feature> GetFeaturesInsideBoundingBoxCore(RectangleShape boundingBox, IEnumerable`1<string> returningColumnNames);
    internal Collection`1<Feature> biA=(RectangleShape boundingBox, IEnumerable`1<string> returningColumnNames);
    protected virtual Collection`1<Feature> GetFeaturesOutsideBoundingBoxCore(RectangleShape boundingBox, IEnumerable`1<string> returningColumnNames);
    protected virtual Collection`1<FeatureSourceColumn> GetColumnsCore();
    private Collection`1<Feature> byA=(RectangleShape boundingBox, IEnumerable`1<string> returningColumnNames);
    private Collection`1<Feature> cCA=(RectangleShape extent, IEnumerable`1<string> returningColumnNames);
    private void cSA=(Feature feature, IEnumerable`1<string> returningColumnNames);
}
public class ThinkGeo.Core.InMemoryGridFeatureLayer : FeatureLayer {
    public GridCell[0...,0...] GridMatrix { get; public set; }
    public double CellSize { get; }
    public int ColumnCount { get; }
    public int RowCount { get; }
    public double NoDataValue { get; }
    public bool HasBoundingBox { get; }
    public string DataValueColumnName { get; }
    public string DataWeightColumnName { get; }
    public InMemoryGridFeatureLayer(GridCell[0...,0...] gridMatrix);
    public GridCell[0...,0...] get_GridMatrix();
    public void set_GridMatrix(GridCell[0...,0...] value);
    public double get_CellSize();
    public int get_ColumnCount();
    public int get_RowCount();
    public double get_NoDataValue();
    public virtual bool get_HasBoundingBox();
    public string get_DataValueColumnName();
    public string get_DataWeightColumnName();
    protected virtual RectangleShape GetBoundingBoxCore();
    public static void GenerateGrid(GridDefinition gridDefinition, GridInterpolationModel gridInterpolationModel, Stream outputStream, Func`2<double, string> cellValueToStringFunc);
    public static GridCell[0...,0...] GenerateGridMatrix(GridDefinition gridDefinition, GridInterpolationModel gridInterpolationModel);
    public GridCell[0...,0...] GenerateGridMatrix();
}
public class ThinkGeo.Core.InMemoryGridFeatureSource : FeatureSource {
    private static string QiI=;
    private static string jCI=;
    [ObfuscationAttribute]
private double cellSize;
    [ObfuscationAttribute]
private Collection`1<FeatureSourceColumn> featureSourceColumns;
    [ObfuscationAttribute]
private RectangleShape gridExtent;
    [ObfuscationAttribute]
private PointShape lowerLeftPoint;
    [ObfuscationAttribute]
private double noDataValue;
    [ObfuscationAttribute]
private int columnCount;
    [ObfuscationAttribute]
private int rowCount;
    [ObfuscationAttribute]
private GridCell[0...,0...] gridMatrix;
    public GridCell[0...,0...] GridMatrix { get; public set; }
    public double CellSize { get; }
    public int ColumnCount { get; }
    public int RowCount { get; }
    public PointShape LowerLeftPoint { get; }
    public double NoDataValue { get; }
    public bool IsEditable { get; }
    public string DataValueColumnName { get; }
    public string DataWeightColumnName { get; }
    public InMemoryGridFeatureSource(GridCell[0...,0...] gridMatrix);
    public GridCell[0...,0...] get_GridMatrix();
    public void set_GridMatrix(GridCell[0...,0...] value);
    public double get_CellSize();
    public int get_ColumnCount();
    public int get_RowCount();
    public PointShape get_LowerLeftPoint();
    public double get_NoDataValue();
    public virtual bool get_IsEditable();
    public string get_DataValueColumnName();
    public string get_DataWeightColumnName();
    protected virtual void OpenCore();
    protected virtual Collection`1<FeatureSourceColumn> GetColumnsCore();
    protected virtual TransactionResult CommitTransactionCore(TransactionBuffer transactions);
    protected virtual Collection`1<Feature> GetAllFeaturesCore(IEnumerable`1<string> returningColumnNames);
    protected virtual RectangleShape GetBoundingBoxCore();
    protected virtual long GetCountCore();
    protected virtual Collection`1<Feature> GetFeaturesInsideBoundingBoxCore(RectangleShape boundingBox, IEnumerable`1<string> returningColumnNames);
    public static GridCell[0...,0...] GenerateGridMatrix(GridDefinition gridDefinition, GridInterpolationModel gridInterpolationModel);
    public static void GenerateGrid(GridDefinition gridDefinition, GridInterpolationModel gridInterpolationModel, Stream outputStream, Func`2<double, string> cellValueToStringFunc);
    private void jSI=();
}
public class ThinkGeo.Core.InMemoryGridIsoLineLayer : IsoLineLayer {
    [ObfuscationAttribute]
private Collection`1<Feature> cachedIsoLines;
    [ObfuscationAttribute]
private int previousGridMatrixCount;
    [ObfuscationAttribute]
private int previousGridMatrixHashCode;
    [ObfuscationAttribute]
private int previousIsoLineLevelsCount;
    [ObfuscationAttribute]
private int previousIsoLineLevelsHashCode;
    [ObfuscationAttribute]
private string previousDataValueColumnName;
    [ObfuscationAttribute]
private string gridMatrixString;
    [ObfuscationAttribute]
private int gridMatrixDimension0Length;
    [ObfuscationAttribute]
private int gridMatrixDimension1Length;
    private GridCell[0...,0...] 7CI=;
    public GridCell[0...,0...] GridMatrix { get; public set; }
    public InMemoryGridIsoLineLayer(GridCell[0...,0...] gridMatrix);
    public InMemoryGridIsoLineLayer(GridCell[0...,0...] gridMatrix, double noDataValue);
    public InMemoryGridIsoLineLayer(GridCell[0...,0...] gridMatrix, IEnumerable`1<double> isoLineLevels);
    public InMemoryGridIsoLineLayer(GridCell[0...,0...] gridMatrix, IEnumerable`1<double> isoLineLevels, double noDataValue);
    public InMemoryGridIsoLineLayer(GridCell[0...,0...] gridMatrix, IEnumerable`1<double> isoLineLevels, double lowerScale, double upperScale);
    public InMemoryGridIsoLineLayer(GridCell[0...,0...] gridMatrix, IEnumerable`1<double> isoLineLevels, double lowerScale, double upperScale, double noDataValue);
    public InMemoryGridIsoLineLayer(GridCell[0...,0...] gridMatrix, IEnumerable`1<double> isoLineLevels, double lowerScale, double upperScale, double noDataValue, IsoLineType isoLineType);
    public GridCell[0...,0...] get_GridMatrix();
    public void set_GridMatrix(GridCell[0...,0...] value);
    [OnGeoserializingAttribute]
private void SCI=();
    [OnGeodeserializedAttribute]
private void SSI=();
    public Collection`1<Feature> GetIsoLineFeatures();
    protected virtual Collection`1<Feature> GetFeaturesForDrawingCore(GeoCanvas canvas, Collection`1<SimpleCandidate> labelsInAllLayers);
    private bool 7iI=();
    private void 7yI=();
}
public class ThinkGeo.Core.InMemoryRasterTileCache : RasterTileCache {
    [ObfuscationAttribute]
private GeoCollection`1<RasterTile> cachedTiles;
    [ObfuscationAttribute]
private int maximumTilesCount;
    public int MaximumTilesCount { get; public set; }
    public int get_MaximumTilesCount();
    public void set_MaximumTilesCount(int value);
    protected virtual Tile GetTileCore(int zoom, long column, long row);
    protected virtual void SaveTileCore(Tile tile);
    protected virtual void DeleteTileCore(Tile tile);
    protected virtual void ClearCacheCore();
}
public class ThinkGeo.Core.InsertedGeoCollectionEventArgs : EventArgs {
    [ObfuscationAttribute]
private object item;
    [ObfuscationAttribute]
private int index;
    public object Item { get; public set; }
    public int Index { get; public set; }
    public InsertedGeoCollectionEventArgs(object item);
    public InsertedGeoCollectionEventArgs(object item, int index);
    public object get_Item();
    public void set_Item(object value);
    public int get_Index();
    public void set_Index(int value);
}
public class ThinkGeo.Core.InsertingGeoCollectionEventArgs : EventArgs {
    [ObfuscationAttribute]
private object item;
    public object Item { get; public set; }
    public InsertingGeoCollectionEventArgs(object item);
    public object get_Item();
    public void set_Item(object value);
}
public class ThinkGeo.Core.InverseDistanceWeightedGridInterpolationModel : GridInterpolationModel {
    [ObfuscationAttribute]
private double power;
    [ObfuscationAttribute]
private double searchRadius;
    private static double iCI=;
    public double Power { get; public set; }
    public double SearchRadius { get; public set; }
    public InverseDistanceWeightedGridInterpolationModel(double power, double searchRadius);
    public double get_Power();
    public void set_Power(double value);
    public double get_SearchRadius();
    public void set_SearchRadius(double value);
    protected virtual ValueTuple`2<double, double> InterpolateCore(RectangleShape cellExtent, GridDefinition gridDefinition);
    private double iSI=(RectangleShape cellExtent, GridDefinition gridDefinition);
    private ValueTuple`2<double, double> iiI=(PointShape point, GridDefinition gridDefinition);
    private ValueTuple`2<double, double> iyI=(PointShape point, Dictionary`2<PointShape, double> dataPoints, double noDataValue);
}
public abstract class ThinkGeo.Core.IsoLineLayer : Layer {
    [ObfuscationAttribute]
private Collection`1<double> isoLineLevels;
    [ObfuscationAttribute]
private string dataValueColumnName;
    [ObfuscationAttribute]
private double lowerScale;
    [ObfuscationAttribute]
private double upperScale;
    [ObfuscationAttribute]
private Collection`1<Style> customStyles;
    [ObfuscationAttribute]
private IsoLineType isoLineType;
    [ObfuscationAttribute]
private double noDataValue;
    public double NoDataValue { get; public set; }
    public double UpperScale { get; public set; }
    public double LowerScale { get; public set; }
    public Collection`1<Style> CustomStyles { get; }
    public string DataValueColumnName { get; public set; }
    public Collection`1<double> IsoLineLevels { get; public set; }
    public IsoLineType IsoLineType { get; public set; }
    protected IsoLineLayer(IEnumerable`1<double> isoLineLevels);
    protected IsoLineLayer(IEnumerable`1<double> isoLineLevels, double lowerScale, double upperScale);
    protected IsoLineLayer(IEnumerable`1<double> isoLineLevels, double lowerScale, double upperScale, IsoLineType isoLineType);
    public double get_NoDataValue();
    public void set_NoDataValue(double value);
    public double get_UpperScale();
    public void set_UpperScale(double value);
    public double get_LowerScale();
    public void set_LowerScale(double value);
    public Collection`1<Style> get_CustomStyles();
    public string get_DataValueColumnName();
    public void set_DataValueColumnName(string value);
    public Collection`1<double> get_IsoLineLevels();
    public void set_IsoLineLevels(Collection`1<double> value);
    public IsoLineType get_IsoLineType();
    public void set_IsoLineType(IsoLineType value);
    protected abstract virtual Collection`1<Feature> GetFeaturesForDrawingCore(GeoCanvas canvas, Collection`1<SimpleCandidate> labelsInAllLayers);
    protected virtual void OpenCore();
    protected virtual void DrawCore(GeoCanvas canvas, Collection`1<SimpleCandidate> labelsInAllLayers);
    public static Collection`1<Feature> GetIsoFeatures(GridCell[0...,0...] gridMatrix, IEnumerable`1<double> isoLineLevels, string dataValueColumnName, IsoLineType isoLineType);
    public static Collection`1<Feature> GetIsoFeatures(GridCell[0...,0...] gridMatrix, IEnumerable`1<double> isoLineLevels, string dataValueColumnName, IsoLineType isoLineType, double noDataValue);
    private static Feature EyM=(GridCell[0...,0...] gridMatrix, string dataValueColumnName);
    public static Collection`1<Feature> GetIsoFeatures(GridFeatureSource gridFeatureSource, IEnumerable`1<double> isoLineLevels, string dataValueColumnName, IsoLineType isoLineType);
    public static Collection`1<double> GetIsoLineLevels(GridCell[0...,0...] gridMatrix, int isoLineLevelCount);
    public static Collection`1<double> GetIsoLineLevels(IEnumerable`1<double> dataValues, int isoLineLevelCount);
    public static Collection`1<double> GetIsoLineLevels(Dictionary`2<PointShape, double> dataPoints, int isoLineLevelCount);
    private static Collection`1<double> FCM=(int isoLevelCount, double minValue, double maxValue);
    private static List`1<OSM=> FSM=(GridCell[0...,0...] gridPoints, IEnumerable`1<double> levels, double noDataValue);
    private static BaseShape FiM=(GridCell[0...,0...] originalGrid, GridCell[0...,0...] extensionGrid, double noDataValue, double minValue);
    private static GridCell[0...,0...] FyM=(GridCell[0...,0...] grid, double noDataValue, Double& minValue);
    private static Collection`1<Feature> GCM=(List`1<OSM=> levelLineList, GridCell[0...,0...] grid, BaseShape gridShape, string dataValueColumnName);
    private static BaseShape GSM=(Collection`1<BaseShape> ringGeometries, Dictionary`2<BaseShape, BaseShape> geometriesDict);
    private static void GiM=(Collection`1<Feature> features, Collection`1<BaseShape> shapes, GridCell[0...,0...] grid, string dataValueColumnName);
    private static void GyM=(STRtree`1<object> rTree, Feature feature, BaseShape geometry, string dataValueColumnName);
}
public enum ThinkGeo.Core.IsoLineType : Enum {
    public int value__;
    public static IsoLineType LinesOnly;
    public static IsoLineType ClosedLinesAsPolygons;
}
public interface ThinkGeo.Core.IWmsEntity {
    public Collection`1<string> ActiveLayerNames { get; }
    public Collection`1<string> ActiveStyleNames { get; }
    public Uri Uri { get; public set; }
    public bool IsTransparent { get; public set; }
    public string OutputFormat { get; public set; }
    public IWebProxy WebProxy { get; public set; }
    public int TimeoutInSeconds { get; public set; }
    public string Crs { get; public set; }
    public ICredentials Credentials { get; public set; }
    public string Exceptions { get; public set; }
    public Dictionary`2<string, string> Parameters { get; }
    public WmsAxisOrder AxisOrder { get; public set; }
    public bool FastMode { get; public set; }
    public string Version { get; }
    public TimeSpan CapabilitiesCacheTimeout { get; public set; }
    public string UserAgent { get; public set; }
    public abstract virtual Collection`1<string> get_ActiveLayerNames();
    public abstract virtual Collection`1<string> get_ActiveStyleNames();
    public abstract virtual Uri get_Uri();
    public abstract virtual void set_Uri(Uri value);
    public abstract virtual bool get_IsTransparent();
    public abstract virtual void set_IsTransparent(bool value);
    public abstract virtual string get_OutputFormat();
    public abstract virtual void set_OutputFormat(string value);
    public abstract virtual IWebProxy get_WebProxy();
    public abstract virtual void set_WebProxy(IWebProxy value);
    public abstract virtual int get_TimeoutInSeconds();
    public abstract virtual void set_TimeoutInSeconds(int value);
    public abstract virtual string get_Crs();
    public abstract virtual void set_Crs(string value);
    public abstract virtual ICredentials get_Credentials();
    public abstract virtual void set_Credentials(ICredentials value);
    public abstract virtual string get_Exceptions();
    public abstract virtual void set_Exceptions(string value);
    public abstract virtual Dictionary`2<string, string> get_Parameters();
    public abstract virtual WmsAxisOrder get_AxisOrder();
    public abstract virtual void set_AxisOrder(WmsAxisOrder value);
    public abstract virtual bool get_FastMode();
    public abstract virtual void set_FastMode(bool value);
    public abstract virtual string get_Version();
    public abstract virtual TimeSpan get_CapabilitiesCacheTimeout();
    public abstract virtual void set_CapabilitiesCacheTimeout(TimeSpan value);
    public abstract virtual string get_UserAgent();
    public abstract virtual void set_UserAgent(string value);
}
[DefaultMemberAttribute("Item")]
internal class ThinkGeo.Core.JArray : JContainer {
    private List`1<JToken> _values;
    protected IList`1<JToken> ChildrenTokens { get; }
    internal JTokenType Type { get; }
    public JToken Item { get; public set; }
    public JToken Item { get; public set; }
    public bool IsReadOnly { get; }
    public JArray(object content);
    protected virtual IList`1<JToken> get_ChildrenTokens();
    internal virtual JTokenType get_Type();
    public virtual JToken get_Item(object key);
    public virtual void set_Item(object key, JToken value);
    public sealed virtual JToken get_Item(int index);
    public sealed virtual void set_Item(int index, JToken value);
    public sealed virtual void Insert(int index, JToken item);
    public sealed virtual void RemoveAt(int index);
    public sealed virtual IEnumerator`1<JToken> GetEnumerator();
    public sealed virtual void Add(JToken item);
    public sealed virtual void Clear();
    public sealed virtual bool Contains(JToken item);
    public sealed virtual void CopyTo(JToken[] array, int arrayIndex);
    public sealed virtual bool get_IsReadOnly();
    public sealed virtual bool Remove(JToken item);
}
internal abstract class ThinkGeo.Core.JContainer : JToken {
    private object _syncRoot;
    protected IList`1<JToken> ChildrenTokens { get; }
    public bool HasValues { get; }
    public JToken First { get; }
    public JToken Last { get; }
    private JToken System.Collections.Generic.IList<ThinkGeo.Core.JToken>.Item { get; private set; }
    private bool System.Collections.Generic.ICollection<ThinkGeo.Core.JToken>.IsReadOnly { get; }
    private bool System.Collections.IList.IsFixedSize { get; }
    private bool System.Collections.IList.IsReadOnly { get; }
    private object System.Collections.IList.Item { get; private set; }
    public int Count { get; }
    private bool System.Collections.ICollection.IsSynchronized { get; }
    private object System.Collections.ICollection.SyncRoot { get; }
    protected abstract virtual IList`1<JToken> get_ChildrenTokens();
    public virtual bool get_HasValues();
    public virtual JToken get_First();
    public virtual JToken get_Last();
    internal virtual JEnumerable`1<JToken> Children();
    public IEnumerable`1<JToken> Descendants();
    [IteratorStateMachineAttribute("ThinkGeo.Core.JContainer/qT4=")]
internal IEnumerable`1<JToken> GetDescendants(bool self);
    internal bool IsMultiContent(object content);
    internal JToken EnsureParentToken(JToken item, bool skipParentCheck);
    internal virtual int IndexOfItem(JToken item);
    internal virtual void InsertItem(int index, JToken item, bool skipParentCheck);
    internal virtual void RemoveItemAt(int index);
    internal virtual bool RemoveItem(JToken item);
    internal virtual JToken GetItem(int index);
    internal virtual void SetItem(int index, JToken item);
    internal virtual void ClearItems();
    internal virtual bool ContainsItem(JToken item);
    internal virtual void CopyItemsTo(Array array, int arrayIndex);
    internal static bool IsTokenUnchanged(JToken currentValue, JToken newValue);
    public virtual void Add(object content);
    public void AddFirst(object content);
    internal void AddInternal(int index, object content, bool skipParentCheck);
    internal static JToken CreateFromContent(object content);
    internal void ReadTokenFrom(JsonReader reader);
    internal void ReadContentFrom(JsonReader r);
    private static JProperty ReadProperty(JsonReader r, JContainer parent);
    private sealed virtual override int System.Collections.Generic.IList<ThinkGeo.Core.JToken>.IndexOf(JToken item);
    private sealed virtual override void System.Collections.Generic.IList<ThinkGeo.Core.JToken>.Insert(int index, JToken item);
    private sealed virtual override void System.Collections.Generic.IList<ThinkGeo.Core.JToken>.RemoveAt(int index);
    private sealed virtual override JToken System.Collections.Generic.IList<ThinkGeo.Core.JToken>.get_Item(int index);
    private sealed virtual override void System.Collections.Generic.IList<ThinkGeo.Core.JToken>.set_Item(int index, JToken value);
    private sealed virtual override void System.Collections.Generic.ICollection<ThinkGeo.Core.JToken>.Add(JToken item);
    private sealed virtual override void System.Collections.Generic.ICollection<ThinkGeo.Core.JToken>.Clear();
    private sealed virtual override bool System.Collections.Generic.ICollection<ThinkGeo.Core.JToken>.Contains(JToken item);
    private sealed virtual override void System.Collections.Generic.ICollection<ThinkGeo.Core.JToken>.CopyTo(JToken[] array, int arrayIndex);
    private sealed virtual override bool System.Collections.Generic.ICollection<ThinkGeo.Core.JToken>.get_IsReadOnly();
    private sealed virtual override bool System.Collections.Generic.ICollection<ThinkGeo.Core.JToken>.Remove(JToken item);
    private JToken EnsureValue(object value);
    private sealed virtual override int System.Collections.IList.Add(object value);
    private sealed virtual override void System.Collections.IList.Clear();
    private sealed virtual override bool System.Collections.IList.Contains(object value);
    private sealed virtual override int System.Collections.IList.IndexOf(object value);
    private sealed virtual override void System.Collections.IList.Insert(int index, object value);
    private sealed virtual override bool System.Collections.IList.get_IsFixedSize();
    private sealed virtual override bool System.Collections.IList.get_IsReadOnly();
    private sealed virtual override void System.Collections.IList.Remove(object value);
    private sealed virtual override void System.Collections.IList.RemoveAt(int index);
    private sealed virtual override object System.Collections.IList.get_Item(int index);
    private sealed virtual override void System.Collections.IList.set_Item(int index, object value);
    private sealed virtual override void System.Collections.ICollection.CopyTo(Array array, int index);
    public sealed virtual int get_Count();
    private sealed virtual override bool System.Collections.ICollection.get_IsSynchronized();
    private sealed virtual override object System.Collections.ICollection.get_SyncRoot();
}
[yhM=]
internal class ThinkGeo.Core.JEnumerable`1 : ValueType {
    private IEnumerable`1<T> _enumerable;
    public static JEnumerable`1<T> Empty;
    public JEnumerable`1(IEnumerable`1<T> enumerable);
    private static JEnumerable`1();
    public IEnumerator`1<T> GetEnumerator();
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
    public sealed virtual bool Equals(JEnumerable`1<T> other);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    private sealed virtual override IEnumerator`1<T> System.Collections.Generic.IEnumerable<T>.GetEnumerator();
}
[DefaultMemberAttribute("Item")]
internal class ThinkGeo.Core.JObject : JContainer {
    private List`1<JToken> properties;
    protected IList`1<JToken> ChildrenTokens { get; }
    internal JTokenType Type { get; }
    public JToken Item { get; public set; }
    public JToken Item { get; public set; }
    protected virtual IList`1<JToken> get_ChildrenTokens();
    internal virtual void InsertItem(int index, JToken item, bool skipParentCheck);
    internal virtual JTokenType get_Type();
    internal JProperty Property(string name, StringComparison comparison);
    public virtual JToken get_Item(object key);
    public virtual void set_Item(object key, JToken value);
    public JToken get_Item(string propertyName);
    public void set_Item(string propertyName, JToken value);
    public void Add(string propertyName, JToken value);
    public bool ContainsKey(string propertyName);
}
internal class ThinkGeo.Core.JProperty : JContainer {
    private List`1<JToken> _content;
    private string _name;
    protected IList`1<JToken> ChildrenTokens { get; }
    public string Name { get; }
    public JToken Value { get; public set; }
    internal JTokenType Type { get; }
    internal JProperty(string name);
    public JProperty(string name, object content);
    protected virtual IList`1<JToken> get_ChildrenTokens();
    [DebuggerStepThroughAttribute]
public string get_Name();
    [DebuggerStepThroughAttribute]
public JToken get_Value();
    public void set_Value(JToken value);
    internal virtual JToken GetItem(int index);
    internal virtual void SetItem(int index, JToken item);
    internal virtual void InsertItem(int index, JToken item, bool skipParentCheck);
    internal virtual bool ContainsItem(JToken item);
    [DebuggerStepThroughAttribute]
internal virtual JTokenType get_Type();
}
internal class ThinkGeo.Core.JsonContainerContract : JsonContract {
    [ObfuscationAttribute]
private JsonContract _itemContract;
    [ObfuscationAttribute]
private JsonContract _finalItemContract;
    internal JsonContract ItemContract { get; internal set; }
    internal JsonContainerContract(Type underlyingType);
    internal JsonContract get_ItemContract();
    internal void set_ItemContract(JsonContract value);
}
internal enum ThinkGeo.Core.JsonContainerType : Enum {
    public int value__;
    public static JsonContainerType None;
    public static JsonContainerType Object;
    public static JsonContainerType Array;
    public static JsonContainerType Constructor;
}
internal class ThinkGeo.Core.JsonContract : object {
    [ObfuscationAttribute]
private Type _createdType;
    internal bool IsNullable;
    internal bool IsConvertable;
    internal bool IsEnum;
    internal Type NonNullableUnderlyingType;
    internal ReadType InternalReadType;
    internal JsonContractType ContractType;
    internal bool IsReadOnlyOrFixedSize;
    internal bool IsSealed;
    internal bool IsInstantiable;
    [CompilerGeneratedAttribute]
private Type <UnderlyingType>k__BackingField;
    public Type UnderlyingType { get; }
    public Type CreatedType { get; public set; }
    internal JsonContract(Type underlyingType);
    [CompilerGeneratedAttribute]
public Type get_UnderlyingType();
    public Type get_CreatedType();
    public void set_CreatedType(Type value);
}
internal enum ThinkGeo.Core.JsonContractType : Enum {
    public int value__;
    public static JsonContractType None;
    public static JsonContractType Object;
    public static JsonContractType Array;
    public static JsonContractType Primitive;
    public static JsonContractType String;
    public static JsonContractType Dictionary;
    public static JsonContractType Dynamic;
    public static JsonContractType Serializable;
    public static JsonContractType Linq;
}
internal static class ThinkGeo.Core.JsonConvert : object {
    public static string True;
    public static string False;
    public static string Null;
    public static string Undefined;
    public static string PositiveInfinity;
    public static string NegativeInfinity;
    public static string NaN;
    private static JsonConvert();
    [DebuggerStepThroughAttribute]
public static object DeserializeObject(string value);
    [DebuggerStepThroughAttribute]
public static T DeserializeObject(string value);
    [DebuggerStepThroughAttribute]
public static T DeserializeAnonymousType(string value, T anonymousTypeObject);
    public static object DeserializeObject(string value, Type type);
}
internal class ThinkGeo.Core.JsonDictionaryContract : JsonContainerContract {
    public static string ConcurrentDictionaryTypeName;
    private Type _genericCollectionDefinitionType;
    private ConstructorInfo _parameterizedConstructor;
    [CompilerGeneratedAttribute]
private Type <DictionaryKeyType>k__BackingField;
    [CompilerGeneratedAttribute]
private Type <DictionaryValueType>k__BackingField;
    [CompilerGeneratedAttribute]
private JsonContract <KeyContract>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <ShouldCreateWrapper>k__BackingField;
    [CompilerGeneratedAttribute]
private wRU=<object> <OverrideCreator>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <HasParameterizedCreator>k__BackingField;
    public Type DictionaryKeyType { get; }
    public Type DictionaryValueType { get; }
    internal JsonContract KeyContract { get; internal set; }
    internal bool ShouldCreateWrapper { get; }
    public wRU=<object> OverrideCreator { get; public set; }
    public bool HasParameterizedCreator { get; public set; }
    internal bool HasParameterizedCreatorInternal { get; }
    public JsonDictionaryContract(Type underlyingType);
    [CompilerGeneratedAttribute]
public Type get_DictionaryKeyType();
    [CompilerGeneratedAttribute]
public Type get_DictionaryValueType();
    [CompilerGeneratedAttribute]
internal JsonContract get_KeyContract();
    [CompilerGeneratedAttribute]
internal void set_KeyContract(JsonContract value);
    [CompilerGeneratedAttribute]
internal bool get_ShouldCreateWrapper();
    [CompilerGeneratedAttribute]
public wRU=<object> get_OverrideCreator();
    [CompilerGeneratedAttribute]
public void set_OverrideCreator(wRU=<object> value);
    [CompilerGeneratedAttribute]
public bool get_HasParameterizedCreator();
    [CompilerGeneratedAttribute]
public void set_HasParameterizedCreator(bool value);
    internal bool get_HasParameterizedCreatorInternal();
    internal IDictionary CreateTemporaryDictionary();
}
internal class ThinkGeo.Core.JsonHelper : object {
    public static string CarriageReturnLineFeed;
    public static string Empty;
    public static char CarriageReturn;
    public static char LineFeed;
    public static char Tab;
    private static Dictionary`2<Type, PrimitiveTypeCode> TypeCodeMap;
    private static JsonHelper();
    internal static JObject Parse(string json);
    public static string ToString(object value);
    public static int ByteArrayCompare(Byte[] a1, Byte[] a2);
    public static int IntLength(ulong i);
    public static bool ApproxEquals(double d1, double d2);
    public static Char[] RentBuffer(int minSize);
    internal static bool IsEndToken(JsonToken token);
    internal static bool IsStartToken(JsonToken token);
    internal static bool IsPrimitiveToken(JsonToken token);
    public static void ArgumentNotNull(object value, string parameterName);
    public static ConstructorInfo ResolveEnumerableCollectionConstructor(Type collectionType, Type collectionItemType, Type constructorArgumentType);
    public static bool IsNullable(Type t);
    public static bool IsNullableType(Type t);
    public static bool ImplementsGenericDefinition(Type type, Type genericInterfaceDefinition, Type& implementingType);
    public static PrimitiveTypeCode GetTypeCode(Type t);
    public static PrimitiveTypeCode GetTypeCode(Type t, Boolean& isEnum);
    public static bool IsInteger(object value);
    public static bool TryHexTextToInt(Char[] text, int start, int end, Int32& value);
}
internal class ThinkGeo.Core.JsonObjectContract : JsonContainerContract {
    [ObfuscationAttribute]
private wRU=<object> _parameterizedCreator;
    private JsonPropertyCollection _creatorParameters;
    [CompilerGeneratedAttribute]
private JsonPropertyCollection <Properties>k__BackingField;
    public JsonPropertyCollection Properties { get; }
    internal wRU=<object> ParameterizedCreator { get; internal set; }
    public JsonPropertyCollection CreatorParameters { get; }
    public JsonObjectContract(Type underlyingType);
    [CompilerGeneratedAttribute]
public JsonPropertyCollection get_Properties();
    internal wRU=<object> get_ParameterizedCreator();
    internal void set_ParameterizedCreator(wRU=<object> value);
    public JsonPropertyCollection get_CreatorParameters();
}
internal class ThinkGeo.Core.JsonPrimitiveContract : JsonContract {
    [CompilerGeneratedAttribute]
private PrimitiveTypeCode <TypeCode>k__BackingField;
    private static Dictionary`2<Type, ReadType> ReadTypeMap;
    internal PrimitiveTypeCode TypeCode { get; internal set; }
    public JsonPrimitiveContract(Type underlyingType);
    private static JsonPrimitiveContract();
    [CompilerGeneratedAttribute]
internal PrimitiveTypeCode get_TypeCode();
    [CompilerGeneratedAttribute]
internal void set_TypeCode(PrimitiveTypeCode value);
}
internal class ThinkGeo.Core.JsonProperty : object {
    [ObfuscationAttribute]
private string _propertyName;
    [ObfuscationAttribute]
private Type _propertyType;
    [CompilerGeneratedAttribute]
private JsonContract <PropertyContract>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<int> <Order>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <Ignored>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <Readable>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <Writable>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <HasMemberAttribute>k__BackingField;
    internal JsonContract PropertyContract { get; internal set; }
    public string PropertyName { get; public set; }
    public Nullable`1<int> Order { get; public set; }
    public Type PropertyType { get; public set; }
    public bool Ignored { get; public set; }
    public bool Readable { get; public set; }
    public bool Writable { get; public set; }
    public bool HasMemberAttribute { get; public set; }
    [CompilerGeneratedAttribute]
internal JsonContract get_PropertyContract();
    [CompilerGeneratedAttribute]
internal void set_PropertyContract(JsonContract value);
    public string get_PropertyName();
    public void set_PropertyName(string value);
    [CompilerGeneratedAttribute]
public Nullable`1<int> get_Order();
    [CompilerGeneratedAttribute]
public void set_Order(Nullable`1<int> value);
    public Type get_PropertyType();
    public void set_PropertyType(Type value);
    [CompilerGeneratedAttribute]
public bool get_Ignored();
    [CompilerGeneratedAttribute]
public void set_Ignored(bool value);
    [CompilerGeneratedAttribute]
public bool get_Readable();
    [CompilerGeneratedAttribute]
public void set_Readable(bool value);
    [CompilerGeneratedAttribute]
public bool get_Writable();
    [CompilerGeneratedAttribute]
public void set_Writable(bool value);
    [CompilerGeneratedAttribute]
public bool get_HasMemberAttribute();
    [CompilerGeneratedAttribute]
public void set_HasMemberAttribute(bool value);
    public virtual string ToString();
}
internal class ThinkGeo.Core.JsonPropertyCollection : KeyedCollection`2<string, JsonProperty> {
    private Type _type;
    private List`1<JsonProperty> _list;
    public JsonPropertyCollection(Type type);
    protected virtual string GetKeyForItem(JsonProperty item);
    public void AddProperty(JsonProperty property);
    public JsonProperty GetClosestMatchProperty(string propertyName);
    private bool TryGetValuePrivate(string key, JsonProperty& item);
    public JsonProperty GetProperty(string propertyName, StringComparison comparisonType);
}
internal abstract class ThinkGeo.Core.JsonReader : object {
    private JsonToken _tokenType;
    private object _value;
    internal char _quoteChar;
    internal State _currentState;
    private JsonContainerType currentType;
    [ObfuscationAttribute]
private CultureInfo _culture;
    private Nullable`1<int> _maxDepth;
    private bool _hasExceededMaxDepth;
    [ObfuscationAttribute]
private string _dateFormatString;
    private List`1<JsonContainerType> _stack;
    [CompilerGeneratedAttribute]
private bool <CloseInput>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <SupportMultipleContent>k__BackingField;
    protected State CurrentState { get; }
    public bool CloseInput { get; public set; }
    public bool SupportMultipleContent { get; public set; }
    public string DateFormatString { get; public set; }
    public JsonToken TokenType { get; }
    public object Value { get; }
    public int Depth { get; }
    public CultureInfo Culture { get; public set; }
    protected State get_CurrentState();
    [CompilerGeneratedAttribute]
public bool get_CloseInput();
    [CompilerGeneratedAttribute]
public void set_CloseInput(bool value);
    [CompilerGeneratedAttribute]
public bool get_SupportMultipleContent();
    [CompilerGeneratedAttribute]
public void set_SupportMultipleContent(bool value);
    public string get_DateFormatString();
    public void set_DateFormatString(string value);
    public virtual JsonToken get_TokenType();
    public virtual object get_Value();
    public virtual int get_Depth();
    public CultureInfo get_Culture();
    public void set_Culture(CultureInfo value);
    private void Push(JsonContainerType value);
    private JsonContainerType Pop();
    private JsonContainerType Peek();
    public abstract virtual bool Read();
    public virtual Nullable`1<int> ReadAsInt32();
    internal Nullable`1<int> ReadInt32String(string s);
    public virtual string ReadAsString();
    public virtual Byte[] ReadAsBytes();
    internal Byte[] ReadArrayIntoByteArray();
    private bool ReadArrayElementIntoByteArrayReportDone(List`1<byte> buffer);
    public virtual Nullable`1<double> ReadAsDouble();
    internal Nullable`1<double> ReadDoubleString(string s);
    public virtual Nullable`1<bool> ReadAsBoolean();
    internal Nullable`1<bool> ReadBooleanString(string s);
    public virtual Nullable`1<decimal> ReadAsDecimal();
    internal Nullable`1<decimal> ReadDecimalString(string s);
    internal void ReaderReadAndAssert();
    internal Exception CreateUnexpectedEndException();
    public void Skip();
    protected void SetToken(JsonToken newToken);
    protected void SetToken(JsonToken newToken, object value);
    protected void SetToken(JsonToken newToken, object value, bool updateIndex);
    internal void SetPostValueState(bool updateIndex);
    private void ValidateEnd(JsonToken endToken);
    protected void SetStateBasedOnCurrent();
    private void SetFinished();
    private JsonContainerType GetTypeForCloseToken(JsonToken token);
    private sealed virtual override void System.IDisposable.Dispose();
    protected virtual void Dispose(bool disposing);
    public virtual void Close();
    internal void ReadAndAssert();
    internal bool ReadForType(JsonContract contract, bool hasConverter);
    internal bool ReadAndMoveToContent();
    internal bool MoveToContent();
    private JsonToken GetContentToken();
}
internal class ThinkGeo.Core.JsonSerializerInternalReader : object {
    private JsonContract GetContractSafe(Type type);
    private JsonContract GetContract(Type type);
    public object Deserialize(JsonReader reader, Type objectType);
    private JToken CreateJObject(JsonReader reader);
    private object CreateValueInternal(JsonReader reader, Type objectType, JsonContract contract, JsonProperty containerMember);
    private static bool CoerceEmptyStringToNull(Type objectType, JsonContract contract, string s);
    internal string GetExpectedDescription(JsonContract contract);
    private object CreateObject(JsonReader reader, Type objectType, JsonContract contract, JsonProperty member);
    public object CreateNewObject(JsonReader reader, JsonObjectContract objectContract, JsonProperty containerMember, Boolean& createdFromNonDefaultCreator);
    private object CreateObjectUsingCreatorWithParameters(JsonReader reader, JsonObjectContract contract, JsonProperty containerProperty, wRU=<object> creator);
    private List`1<tz4=> ResolvePropertyAndCreatorValues(JsonObjectContract contract, JsonProperty containerProperty, JsonReader reader, Type objectType);
    private object CreateValueInternal(JsonReader reader, Type objectType, JsonContract contract, JsonProperty member, JsonContainerContract containerContract, JsonProperty containerMember, object existingValue);
    private object CreateObject(JsonReader reader, Type objectType, JsonContract contract, JsonProperty member, JsonContainerContract containerContract, JsonProperty containerMember, object existingValue);
    private bool HasNoDefinedType(JsonContract contract);
    private object EnsureType(JsonReader reader, object value, CultureInfo culture, JsonContract contract, Type targetType);
    private IDictionary CreateNewDictionary(JsonDictionaryContract contract);
    private object PopulateDictionary(IDictionary dictionary, JsonReader reader, JsonDictionaryContract contract, JsonProperty containerProperty);
}
internal class ThinkGeo.Core.JsonTextReader : JsonReader {
    private static char UnicodeReplacementChar;
    [CompilerGeneratedAttribute]
private int <LargeBufferLength>k__BackingField;
    private TextReader _reader;
    private Char[] _chars;
    private int _charsUsed;
    private int _charPos;
    private int _lineStartPos;
    private int _lineNumber;
    private bool _isEndOfFile;
    private StringBuffer _stringBuffer;
    private StringReference _stringReference;
    internal int LargeBufferLength { get; internal set; }
    public JsonTextReader(TextReader reader);
    [CompilerGeneratedAttribute]
internal int get_LargeBufferLength();
    [CompilerGeneratedAttribute]
internal void set_LargeBufferLength(int value);
    private void EnsureBufferNotEmpty();
    private void SetNewLine(bool hasNextChar);
    private void OnNewLine(int pos);
    private void ParseString(char quote, ReadType readType);
    private void ParseReadString(char quote, ReadType readType);
    private static void BlockCopyChars(Char[] src, int srcOffset, Char[] dst, int dstOffset, int count);
    private void ShiftBufferIfNeeded();
    private int ReadData(bool append);
    private void PrepareBufferForReadData(bool append, int charsRequired);
    private int ReadData(bool append, int charsRequired);
    private bool EnsureChars(int relativePosition, bool append);
    private bool ReadChars(int relativePosition, bool append);
    public virtual bool Read();
    public virtual Nullable`1<int> ReadAsInt32();
    public virtual string ReadAsString();
    public virtual Byte[] ReadAsBytes();
    private object ReadStringValue(ReadType readType);
    private object FinishReadQuotedStringValue(ReadType readType);
    private Exception CreateUnexpectedCharacterException(char c);
    public virtual Nullable`1<bool> ReadAsBoolean();
    private void ProcessValueComma();
    private object ReadNumberValue(ReadType readType);
    private object FinishReadQuotedNumber(ReadType readType);
    public virtual Nullable`1<decimal> ReadAsDecimal();
    public virtual Nullable`1<double> ReadAsDouble();
    private void HandleNull();
    private void ReadFinished();
    private bool ReadNullChar();
    private void EnsureBuffer();
    private void ReadStringIntoBuffer(char quote);
    private void FinishReadStringIntoBuffer(int charPos, int initialPosition, int lastWritePosition);
    private void WriteCharToBuffer(char writeChar, int lastWritePosition, int writeToPosition);
    private char ConvertUnicode(bool enoughChars);
    private char ParseUnicode();
    private void ReadNumberIntoBuffer();
    private bool ReadNumberCharIntoBuffer(char currentChar, int charPos);
    private void ClearRecentString();
    private bool ParsePostValue(bool ignoreComments);
    private bool ParseObject();
    private bool ParseProperty();
    private bool ValidIdentifierChar(char value);
    private void ParseUnquotedProperty();
    private bool ReadUnquotedPropertyReportIfDone(char currentChar, int initialPosition);
    private bool ParseValue();
    private void ProcessLineFeed();
    private void ProcessCarriageReturn(bool append);
    private void EatWhitespace();
    private void ParseConstructor();
    private void ParseNumber(ReadType readType);
    private void ParseReadNumber(ReadType readType, char firstChar, int initialPosition);
    private void ParseComment(bool setToken);
    private void EndComment(bool setToken, int initialPosition, int endPosition);
    private bool MatchValue(string value);
    private bool MatchValue(bool enoughChars, string value);
    private bool MatchValueWithTrailingSeparator(string value);
    private bool IsSeparator(char c);
    private void ParseTrue();
    private void ParseNull();
    private void ParseUndefined();
    private void ParseFalse();
    private object ParseNumberNegativeInfinity(ReadType readType);
    private object ParseNumberNegativeInfinity(ReadType readType, bool matched);
    private object ParseNumberPositiveInfinity(ReadType readType);
    private object ParseNumberPositiveInfinity(ReadType readType, bool matched);
    private object ParseNumberNaN(ReadType readType);
    private object ParseNumberNaN(ReadType readType, bool matched);
    public virtual void Close();
}
internal enum ThinkGeo.Core.JsonToken : Enum {
    public int value__;
    public static JsonToken None;
    public static JsonToken StartObject;
    public static JsonToken StartArray;
    public static JsonToken StartConstructor;
    public static JsonToken PropertyName;
    public static JsonToken Comment;
    public static JsonToken Raw;
    public static JsonToken Integer;
    public static JsonToken Float;
    public static JsonToken String;
    public static JsonToken Boolean;
    public static JsonToken Null;
    public static JsonToken Undefined;
    public static JsonToken EndObject;
    public static JsonToken EndArray;
    public static JsonToken EndConstructor;
    public static JsonToken Date;
    public static JsonToken Bytes;
}
[DefaultMemberAttribute("Item")]
internal abstract class ThinkGeo.Core.JToken : object {
    [ObfuscationAttribute]
private JContainer _parent;
    [ObfuscationAttribute]
private JToken _previous;
    [ObfuscationAttribute]
private JToken _next;
    public JContainer Parent { get; internal set; }
    internal JTokenType Type { get; }
    public bool HasValues { get; }
    public JToken Next { get; internal set; }
    public JToken Previous { get; internal set; }
    public JToken Item { get; public set; }
    public JToken First { get; }
    public JToken Last { get; }
    [DebuggerStepThroughAttribute]
public JContainer get_Parent();
    internal void set_Parent(JContainer value);
    internal abstract virtual JTokenType get_Type();
    public abstract virtual bool get_HasValues();
    public JToken get_Next();
    internal void set_Next(JToken value);
    public JToken get_Previous();
    internal void set_Previous(JToken value);
    public virtual JToken get_Item(object key);
    public virtual void set_Item(object key, JToken value);
    public virtual JToken get_First();
    public virtual JToken get_Last();
    internal virtual JEnumerable`1<JToken> Children();
    private static JValue EnsureValue(JToken value);
    public static bool op_Explicit(JToken value);
    public static int op_Explicit(JToken value);
    public static double op_Explicit(JToken value);
    public static float op_Explicit(JToken value);
    public static string op_Explicit(JToken value);
    public static JToken op_Implicit(string value);
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
    private sealed virtual override IEnumerator`1<JToken> System.Collections.Generic.IEnumerable<ThinkGeo.Core.JToken>.GetEnumerator();
    public T ToObject();
}
internal class ThinkGeo.Core.JTokenReader : JsonReader {
    private JToken _root;
    private JToken _parent;
    private JToken _current;
    internal JToken Root { get; }
    public JTokenReader(JToken token);
    internal JToken get_Root();
    public virtual bool Read();
    private bool ReadOver(JToken t);
    private bool ReadToEnd();
    private Nullable`1<JsonToken> GetEndToken(JContainer c);
    private bool ReadInto(JContainer c);
    private bool SetEnd(JContainer c);
    private void SetToken(JToken token);
    private string SafeToString(object value);
}
internal enum ThinkGeo.Core.JTokenType : Enum {
    public int value__;
    public static JTokenType None;
    public static JTokenType Object;
    public static JTokenType Array;
    public static JTokenType Constructor;
    public static JTokenType Property;
    public static JTokenType Comment;
    public static JTokenType Integer;
    public static JTokenType Float;
    public static JTokenType String;
    public static JTokenType Boolean;
    public static JTokenType Null;
    public static JTokenType Undefined;
    public static JTokenType Date;
    public static JTokenType Raw;
    public static JTokenType Bytes;
    public static JTokenType Guid;
    public static JTokenType Uri;
    public static JTokenType TimeSpan;
}
internal class ThinkGeo.Core.JValue : JToken {
    [ObfuscationAttribute]
private JTokenType _valueType;
    [ObfuscationAttribute]
private object _value;
    public bool HasValues { get; }
    internal JTokenType Type { get; }
    public object Value { get; public set; }
    internal JValue(object value, JTokenType type);
    public JValue(string value);
    public JValue(object value);
    public virtual bool get_HasValues();
    internal static int Compare(JTokenType valueType, object objA, object objB);
    private static int CompareFloat(object objA, object objB);
    public static JValue CreateNull();
    public static JValue CreateUndefined();
    private static JTokenType GetValueType(JTokenType current, object value);
    private static JTokenType GetStringValueType(JTokenType current);
    internal virtual JTokenType get_Type();
    public object get_Value();
    public void set_Value(object value);
    private static bool ValuesEquals(JValue v1, JValue v2);
    public sealed virtual bool Equals(JValue other);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    public virtual string ToString();
    public sealed virtual string ToString(string format, IFormatProvider formatProvider);
    private sealed virtual override int System.IComparable.CompareTo(object obj);
    public sealed virtual int CompareTo(JValue obj);
}
[ObfuscationAttribute]
internal class ThinkGeo.Core.KiloMetersValues : ValueType {
    [ObfuscationAttribute]
private double v1;
    [ObfuscationAttribute]
private double v10;
    [ObfuscationAttribute]
private double v100;
    [ObfuscationAttribute]
private double v1000;
    [ObfuscationAttribute]
private double v2;
    [ObfuscationAttribute]
private double v20;
    [ObfuscationAttribute]
private double v200;
    [ObfuscationAttribute]
private double v2000;
    [ObfuscationAttribute]
private double v3;
    [ObfuscationAttribute]
private double v30;
    [ObfuscationAttribute]
private double v300;
    [ObfuscationAttribute]
private double v4;
    [ObfuscationAttribute]
private double v40;
    [ObfuscationAttribute]
private double v400;
    [ObfuscationAttribute]
private double v4000;
    [ObfuscationAttribute]
private double v5;
    [ObfuscationAttribute]
private double v50;
    [ObfuscationAttribute]
private double v500;
    public double QCE= { get; }
    public double QiE= { get; }
    public double RCE= { get; }
    public double RiE= { get; }
    public double SCE= { get; }
    public double KCE= { get; }
    public double KiE= { get; }
    public double LCE= { get; }
    public double LiE= { get; }
    public double MCE= { get; }
    public double MiE= { get; }
    public double NCE= { get; }
    public double NiE= { get; }
    public double OCE= { get; }
    public double OiE= { get; }
    public double PCE= { get; }
    public double PiE= { get; }
    public double SiE= { get; }
    public KiloMetersValues(int width, double extentLengthBar, DistanceUnit distanceUnit);
    public double PyE=();
    public double QSE=();
    public double QyE=();
    public double RSE=();
    public double RyE=();
    public double JyE=();
    public double KSE=();
    public double KyE=();
    public double LSE=();
    public double LyE=();
    public double MSE=();
    public double MyE=();
    public double NSE=();
    public double NyE=();
    public double OSE=();
    public double OyE=();
    public double PSE=();
    public double SSE=();
}
public abstract class ThinkGeo.Core.KrigingGridInterpolationModel : GridInterpolationModel {
    [ObfuscationAttribute]
private int referencingPointCount;
    [ObfuscationAttribute]
private Dictionary`2<PointShape, double> dataPoints;
    [ObfuscationAttribute]
private Double[0...,0...] pointValues;
    private gCI= TCI=;
    [ObfuscationAttribute]
private Double[] extent;
    public Dictionary`2<PointShape, double> Points { get; }
    public int NumberOfReferencedPoints { get; public set; }
    protected KrigingGridInterpolationModel(IDictionary`2<PointShape, double> points);
    protected KrigingGridInterpolationModel(IDictionary`2<PointShape, double> points, int numberOfReferencedPoints);
    public Dictionary`2<PointShape, double> get_Points();
    public int get_NumberOfReferencedPoints();
    public void set_NumberOfReferencedPoints(int value);
    public double GetSemivariance(double distance, EmpiricalFunctionCoefficients coefficients);
    public EmpiricalFunctionCoefficients GetEmpiricalFunctionCoefficients(int numberOfPoints, Double[0...,0...] distance, Double[0...,0...] semivariances, double maxRange);
    protected virtual ValueTuple`2<double, double> InterpolateCore(RectangleShape cellExtent, GridDefinition gridDefinition);
    protected virtual double GetSemivarianceCore(double distance, EmpiricalFunctionCoefficients coefficients);
    protected double GetSillSlope(double distance, double range);
    protected abstract virtual double GetSillSlopeCore(double distance, double range);
    protected virtual EmpiricalFunctionCoefficients GetEmpiricalFunctionCoefficientsCore(int points, Double[0...,0...] distance, Double[0...,0...] semivariances, double maxRange);
    private ValueTuple`2<double, double> TSI=(int nPn, double x, double y);
    private void TiI=(Dictionary`2<PointShape, double> dataPoints);
    private Double[0...,0...] TyI=(int nPn, double x, double y, gCI= quadTree);
    private Double[0...,0...] UCI=(int npoints, Double[0...,0...] cpoints, EmpiricalFunctionCoefficients& coefficients);
    private Double[0...,0...] USI=(int nPn, Double[0...,0...] mdistances, EmpiricalFunctionCoefficients coefficients);
    private static void UiI=(Double[]& a, Int32[]& b, int x);
    [OnGeodeserializedAttribute]
private void RBU=();
}
public enum ThinkGeo.Core.LabelDuplicateRule : Enum {
    public int value__;
    public static LabelDuplicateRule OneDuplicateLabelPerQuadrant;
    public static LabelDuplicateRule NoDuplicateLabels;
    public static LabelDuplicateRule UnlimitedDuplicateLabels;
}
public class ThinkGeo.Core.LabelInformation : object {
    [ObfuscationAttribute]
private ScreenPointF positionInScreenCoordinates;
    [ObfuscationAttribute]
private string text;
    [ObfuscationAttribute]
private double rotationAngle;
    public ScreenPointF PositionInScreenCoordinates { get; public set; }
    public string Text { get; public set; }
    public double RotationAngle { get; public set; }
    public LabelInformation(ScreenPointF positionInScreenCoordinates, string text, double rotationAngle);
    public ScreenPointF get_PositionInScreenCoordinates();
    public void set_PositionInScreenCoordinates(ScreenPointF value);
    public string get_Text();
    public void set_Text(string value);
    public double get_RotationAngle();
    public void set_RotationAngle(double value);
}
public class ThinkGeo.Core.LabelingCandidate : object {
    [ObfuscationAttribute]
private string originalText;
    [ObfuscationAttribute]
private PolygonShape screenArea;
    [ObfuscationAttribute]
private ScreenPointF centerPointInScreenCoordinate;
    [ObfuscationAttribute]
private Collection`1<LabelInformation> labelInformation;
    public string OriginalText { get; public set; }
    public PolygonShape ScreenArea { get; public set; }
    public ScreenPointF CenterPointInScreenCoordinate { get; public set; }
    public Collection`1<LabelInformation> LabelInformation { get; }
    public LabelingCandidate(string originalText, PolygonShape simplePolygonInScreenCoordinates, ScreenPointF centerPointInScreenCoordinate);
    public LabelingCandidate(string originalText, PolygonShape simplePolygonInScreenCoordinates, ScreenPointF centerPointInScreenCoordinate, Collection`1<LabelInformation> labelInformation);
    public string get_OriginalText();
    public void set_OriginalText(string value);
    public PolygonShape get_ScreenArea();
    public void set_ScreenArea(PolygonShape value);
    public ScreenPointF get_CenterPointInScreenCoordinate();
    public void set_CenterPointInScreenCoordinate(ScreenPointF value);
    public Collection`1<LabelInformation> get_LabelInformation();
}
public enum ThinkGeo.Core.LabelLeaderLinesRule : Enum {
    public int value__;
    public static LabelLeaderLinesRule NoLeaderLines;
    public static LabelLeaderLinesRule AllowLeaderLines;
}
public enum ThinkGeo.Core.LabelOverlappingRule : Enum {
    public int value__;
    public static LabelOverlappingRule NoOverlapping;
    public static LabelOverlappingRule AllowOverlapping;
}
public abstract class ThinkGeo.Core.Layer : LayerBase {
    private static object /BM=;
    private Exception 8x0=;
    [ObfuscationAttribute]
private string attribution;
    [CompilerGeneratedAttribute]
private EventHandler`1<DrawingAttributionLayerEventArgs> UCA=;
    [CompilerGeneratedAttribute]
private EventHandler`1<DrawnAttributionLayerEventArgs> USA=;
    [ObsoleteAttribute("Layer.Attribution (as well as Drawing Attribution) is deprecate and will be removed after v14.2. You can accomplish the similar feature by overriding layer.DrawCore/Layer.DrawAsyncCore method")]
public string Attribution { get; public set; }
    private static Layer();
    [CompilerGeneratedAttribute]
public void add_DrawingAttribution(EventHandler`1<DrawingAttributionLayerEventArgs> value);
    [CompilerGeneratedAttribute]
public void remove_DrawingAttribution(EventHandler`1<DrawingAttributionLayerEventArgs> value);
    [CompilerGeneratedAttribute]
public void add_DrawnAttribution(EventHandler`1<DrawnAttributionLayerEventArgs> value);
    [CompilerGeneratedAttribute]
public void remove_DrawnAttribution(EventHandler`1<DrawnAttributionLayerEventArgs> value);
    public string get_Attribution();
    public void set_Attribution(string value);
    [ObsoleteAttribute("Layer.Attribution (as well as Drawing Attribution) is deprecate and will be removed after v14.2. You can accomplish the similar feature by overriding layer.DrawCore/Layer.DrawAsyncCore method")]
protected virtual void OnDrawingAttribution(DrawingAttributionLayerEventArgs args);
    [ObsoleteAttribute("Layer.Attribution (as well as Drawing Attribution) is deprecate and will be removed after v14.2. You can accomplish the similar feature by overriding layer.DrawCore/Layer.DrawAsyncCore method")]
protected virtual void OnDrawnAttribution(DrawnAttributionLayerEventArgs args);
    public static Layer LoadLayer(Uri layerUri);
    public static Layer LoadLayer(Stream layerStream);
    public void Open();
    protected virtual void OpenCore();
    public void Close();
    protected virtual void CloseCore();
    public void Draw(GeoCanvas canvas, Collection`1<SimpleCandidate> labelsInAllLayers);
    private void UiA=(GeoCanvas canvas, Collection`1<SimpleCandidate> labelsInAllLayers);
    protected virtual void DrawWithColorTransformation(GeoCanvas canvas, Collection`1<SimpleCandidate> labelsInAllLayers, RectangleShape extent, float width, float height);
    protected abstract virtual void DrawCore(GeoCanvas canvas, Collection`1<SimpleCandidate> labelsInAllLayers);
    private void UyA=(GeoCanvas canvas, string attribution);
    [ObsoleteAttribute("Layer.Attribution (as well as Drawing Attribution) is deprecate and will be removed after v14.2. You can accomplish the similar feature by overriding layer.DrawCore/Layer.DrawAsyncCore method")]
protected virtual void DrawAttributionCore(GeoCanvas canvas, string attribution);
    private void 9x0=(object sender, DrawingProgressChangedEventArgs e);
}
public enum ThinkGeo.Core.LayerAnchorLocation : Enum {
    public int value__;
    public static LayerAnchorLocation UpperLeft;
    public static LayerAnchorLocation UpperRight;
    public static LayerAnchorLocation LowerRight;
    public static LayerAnchorLocation LowerLeft;
    public static LayerAnchorLocation Center;
    public static LayerAnchorLocation UpperCenter;
    public static LayerAnchorLocation LowerCenter;
    public static LayerAnchorLocation LeftCenter;
    public static LayerAnchorLocation RightCenter;
}
public abstract class ThinkGeo.Core.LayerBase : object {
    [ObfuscationAttribute]
private float redTranslation;
    [ObfuscationAttribute]
private float greenTranslation;
    [ObfuscationAttribute]
private float blueTranslation;
    [ObfuscationAttribute]
private float transparency;
    [CompilerGeneratedAttribute]
private EventHandler`1<DrawingProgressChangedEventArgs> LxU=;
    [CompilerGeneratedAttribute]
private EventHandler`1<DrawingExceptionLayerEventArgs> 2h0=;
    [CompilerGeneratedAttribute]
private EventHandler`1<DrawnExceptionLayerEventArgs> 2x0=;
    [CompilerGeneratedAttribute]
private string 3B0=;
    [CompilerGeneratedAttribute]
private bool 3R0=;
    [CompilerGeneratedAttribute]
private bool 3h0=;
    [CompilerGeneratedAttribute]
private TimeSpan 3x0=;
    [CompilerGeneratedAttribute]
private Projection 4B0=;
    [CompilerGeneratedAttribute]
private DrawingExceptionMode 4R0=;
    [CompilerGeneratedAttribute]
private GeoColor 4h0=;
    [CompilerGeneratedAttribute]
private Collection`1<GeoColor> 4x0=;
    [CompilerGeneratedAttribute]
private bool 5B0=;
    [CompilerGeneratedAttribute]
private bool 5R0=;
    [CompilerGeneratedAttribute]
private ThreadSafetyLevel 5h0=;
    [CompilerGeneratedAttribute]
private Dictionary`2<GeoColor, GeoColor> 5x0=;
    [CompilerGeneratedAttribute]
private WrappingMode 6B0=;
    [CompilerGeneratedAttribute]
private RectangleShape 6R0=;
    internal static RectangleShape 6h0=;
    internal static TimeSpan 6x0=;
    [ObfuscationAttribute]
private TimeSpan requestDrawingInterval;
    private Timer 7B0=;
    [CompilerGeneratedAttribute]
private EventHandler`1<RequestedDrawingLayerEventArgs> 7R0=;
    [CompilerGeneratedAttribute]
private EventHandler`1<RequestingDrawingLayerEventArgs> 7h0=;
    public string Name { get; public set; }
    protected bool IsOpenCore { get; protected set; }
    public bool IsOpen { get; }
    public bool IsVisible { get; public set; }
    public TimeSpan DrawingTime { get; protected set; }
    public Projection Projection { get; public set; }
    public DrawingExceptionMode DrawingExceptionMode { get; public set; }
    public GeoColor Background { get; public set; }
    public float Transparency { get; public set; }
    public float BlueTranslation { get; public set; }
    public float RedTranslation { get; public set; }
    public float GreenTranslation { get; public set; }
    public Collection`1<GeoColor> KeyColors { get; }
    public bool IsNegative { get; public set; }
    public bool IsGrayscale { get; public set; }
    public bool HasBoundingBox { get; }
    public ThreadSafetyLevel ThreadSafe { get; public set; }
    public Dictionary`2<GeoColor, GeoColor> ColorMappings { get; }
    public WrappingMode WrappingMode { get; public set; }
    public RectangleShape WrappingExtent { get; public set; }
    public TimeSpan RequestDrawingInterval { get; public set; }
    private static LayerBase();
    [CompilerGeneratedAttribute]
public void add_DrawingProgressChanged(EventHandler`1<DrawingProgressChangedEventArgs> value);
    [CompilerGeneratedAttribute]
public void remove_DrawingProgressChanged(EventHandler`1<DrawingProgressChangedEventArgs> value);
    [CompilerGeneratedAttribute]
public void add_DrawingException(EventHandler`1<DrawingExceptionLayerEventArgs> value);
    [CompilerGeneratedAttribute]
public void remove_DrawingException(EventHandler`1<DrawingExceptionLayerEventArgs> value);
    [CompilerGeneratedAttribute]
public void add_DrawnException(EventHandler`1<DrawnExceptionLayerEventArgs> value);
    [CompilerGeneratedAttribute]
public void remove_DrawnException(EventHandler`1<DrawnExceptionLayerEventArgs> value);
    [CompilerGeneratedAttribute]
public string get_Name();
    [CompilerGeneratedAttribute]
public void set_Name(string value);
    [CompilerGeneratedAttribute]
protected virtual bool get_IsOpenCore();
    [CompilerGeneratedAttribute]
protected virtual void set_IsOpenCore(bool value);
    public bool get_IsOpen();
    [CompilerGeneratedAttribute]
public bool get_IsVisible();
    [CompilerGeneratedAttribute]
public void set_IsVisible(bool value);
    [CompilerGeneratedAttribute]
public TimeSpan get_DrawingTime();
    [CompilerGeneratedAttribute]
protected void set_DrawingTime(TimeSpan value);
    [CompilerGeneratedAttribute]
public virtual Projection get_Projection();
    [CompilerGeneratedAttribute]
public virtual void set_Projection(Projection value);
    [CompilerGeneratedAttribute]
public DrawingExceptionMode get_DrawingExceptionMode();
    [CompilerGeneratedAttribute]
public void set_DrawingExceptionMode(DrawingExceptionMode value);
    [CompilerGeneratedAttribute]
public GeoColor get_Background();
    [CompilerGeneratedAttribute]
public void set_Background(GeoColor value);
    public bool IsDrawingNeeded(double currentScale);
    protected virtual bool IsDrawingNeededCore(double currentScale);
    public float get_Transparency();
    public void set_Transparency(float value);
    public float get_BlueTranslation();
    public void set_BlueTranslation(float value);
    public float get_RedTranslation();
    public void set_RedTranslation(float value);
    public float get_GreenTranslation();
    public void set_GreenTranslation(float value);
    [CompilerGeneratedAttribute]
public Collection`1<GeoColor> get_KeyColors();
    [CompilerGeneratedAttribute]
public bool get_IsNegative();
    [CompilerGeneratedAttribute]
public void set_IsNegative(bool value);
    [CompilerGeneratedAttribute]
public bool get_IsGrayscale();
    [CompilerGeneratedAttribute]
public void set_IsGrayscale(bool value);
    public virtual bool get_HasBoundingBox();
    [CompilerGeneratedAttribute]
public ThreadSafetyLevel get_ThreadSafe();
    [CompilerGeneratedAttribute]
public void set_ThreadSafe(ThreadSafetyLevel value);
    [CompilerGeneratedAttribute]
public Dictionary`2<GeoColor, GeoColor> get_ColorMappings();
    [CompilerGeneratedAttribute]
public WrappingMode get_WrappingMode();
    [CompilerGeneratedAttribute]
public void set_WrappingMode(WrappingMode value);
    [CompilerGeneratedAttribute]
public RectangleShape get_WrappingExtent();
    [CompilerGeneratedAttribute]
public void set_WrappingExtent(RectangleShape value);
    protected void DrawException(GeoCanvas canvas, Exception e);
    protected virtual void DrawExceptionCore(GeoCanvas canvas, Exception e);
    protected virtual void OnDrawingException(DrawingExceptionLayerEventArgs e);
    public RectangleShape GetBoundingBox();
    protected virtual RectangleShape GetBoundingBoxCore();
    protected virtual void OnDrawnException(DrawnExceptionLayerEventArgs e);
    protected virtual void OnDrawingProgressChanged(DrawingProgressChangedEventArgs e);
    public LayerBase CloneDeep();
    protected virtual LayerBase CloneDeepCore();
    [CompilerGeneratedAttribute]
public void add_RequestedDrawing(EventHandler`1<RequestedDrawingLayerEventArgs> value);
    [CompilerGeneratedAttribute]
public void remove_RequestedDrawing(EventHandler`1<RequestedDrawingLayerEventArgs> value);
    [CompilerGeneratedAttribute]
public void add_RequestingDrawing(EventHandler`1<RequestingDrawingLayerEventArgs> value);
    [CompilerGeneratedAttribute]
public void remove_RequestingDrawing(EventHandler`1<RequestingDrawingLayerEventArgs> value);
    public TimeSpan get_RequestDrawingInterval();
    public void set_RequestDrawingInterval(TimeSpan value);
    public void RequestDrawing();
    public void RequestDrawing(RectangleShape extentToRefresh);
    public void RequestDrawing(IEnumerable`1<RectangleShape> extentsToRefresh);
    public void RequestDrawing(TimeSpan bufferTime);
    public void RequestDrawing(TimeSpan bufferTime, RequestDrawingBufferTimeType bufferTimeType);
    public void RequestDrawing(RectangleShape extentToRefresh, TimeSpan bufferTime);
    public void RequestDrawing(RectangleShape extentToRefresh, TimeSpan bufferTime, RequestDrawingBufferTimeType bufferTimeType);
    public void RequestDrawing(IEnumerable`1<RectangleShape> extentsToRefresh, TimeSpan bufferTime);
    public void RequestDrawing(IEnumerable`1<RectangleShape> extentsToRefresh, TimeSpan bufferTime, RequestDrawingBufferTimeType bufferTimeType);
    protected void StartRequestDrawing();
    protected void StopRequestDrawing();
    protected virtual void OnRequestedDrawing(RequestedDrawingLayerEventArgs eventArgs);
    protected virtual void OnRequestingDrawing(RequestingDrawingLayerEventArgs eventArgs);
    private void 7x0=(IEnumerable`1<RectangleShape> extentsToRefresh, TimeSpan bufferTime, RequestDrawingBufferTimeType bufferTimeType);
    private void 8B0=(object sender, EventArgs e);
}
public class ThinkGeo.Core.LayerDrawingEventArgs : EventArgs {
    [ObfuscationAttribute]
private Layer currentLayer;
    [ObfuscationAttribute]
private RectangleShape worldExtent;
    [ObfuscationAttribute]
private object nativeImage;
    [ObfuscationAttribute]
private bool cancel;
    public bool Cancel { get; public set; }
    public Layer CurrentLayer { get; public set; }
    public RectangleShape WorldExtent { get; public set; }
    public object NativeImage { get; public set; }
    public LayerDrawingEventArgs(Layer currentLayer, RectangleShape worldExtent, object nativeImage);
    public bool get_Cancel();
    public void set_Cancel(bool value);
    public Layer get_CurrentLayer();
    public void set_CurrentLayer(Layer value);
    public RectangleShape get_WorldExtent();
    public void set_WorldExtent(RectangleShape value);
    public object get_NativeImage();
    public void set_NativeImage(object value);
}
public class ThinkGeo.Core.LayerDrawnEventArgs : EventArgs {
    [ObfuscationAttribute]
private Layer currentLayer;
    [ObfuscationAttribute]
private RectangleShape worldExtent;
    [ObfuscationAttribute]
private object nativeImage;
    public Layer CurrentLayer { get; public set; }
    public RectangleShape WorldExtent { get; public set; }
    public object NativeImage { get; public set; }
    public LayerDrawnEventArgs(Layer currentLayer, RectangleShape worldExtent, object nativeImage);
    public Layer get_CurrentLayer();
    public void set_CurrentLayer(Layer value);
    public RectangleShape get_WorldExtent();
    public void set_WorldExtent(RectangleShape value);
    public object get_NativeImage();
    public void set_NativeImage(object value);
}
public class ThinkGeo.Core.LayersDrawingEventArgs : EventArgs {
    [ObfuscationAttribute]
private IEnumerable`1<Layer> layers;
    [ObfuscationAttribute]
private RectangleShape worldExtent;
    [ObfuscationAttribute]
private object nativeImage;
    [ObfuscationAttribute]
private bool cancel;
    public bool Cancel { get; public set; }
    public RectangleShape WorldExtent { get; public set; }
    public object NativeImage { get; public set; }
    public IEnumerable`1<Layer> Layers { get; public set; }
    public LayersDrawingEventArgs(IEnumerable`1<Layer> layers, RectangleShape worldExtent, object nativeImage);
    public bool get_Cancel();
    public void set_Cancel(bool value);
    public RectangleShape get_WorldExtent();
    public void set_WorldExtent(RectangleShape value);
    public object get_NativeImage();
    public void set_NativeImage(object value);
    public IEnumerable`1<Layer> get_Layers();
    public void set_Layers(IEnumerable`1<Layer> value);
}
public class ThinkGeo.Core.LayersDrawnEventArgs : EventArgs {
    [ObfuscationAttribute]
private IEnumerable`1<Layer> layers;
    [ObfuscationAttribute]
private RectangleShape worldExtent;
    [ObfuscationAttribute]
private object nativeImage;
    public RectangleShape WorldExtent { get; public set; }
    public object NativeImage { get; public set; }
    public IEnumerable`1<Layer> Layers { get; public set; }
    public LayersDrawnEventArgs(IEnumerable`1<Layer> layers, RectangleShape worldExtent, object nativeImage);
    public RectangleShape get_WorldExtent();
    public void set_WorldExtent(RectangleShape value);
    public object get_NativeImage();
    public void set_NativeImage(object value);
    public IEnumerable`1<Layer> get_Layers();
    public void set_Layers(IEnumerable`1<Layer> value);
}
internal class ThinkGeo.Core.LeafRecordWrapper : object {
    [CompilerGeneratedAttribute]
private qx8= <Leaf>k__BackingField;
    [CompilerGeneratedAttribute]
private int <RecordId>k__BackingField;
    [CompilerGeneratedAttribute]
private string <FeatureId>k__BackingField;
    public qx8= Leaf { get; public set; }
    public int RecordId { get; public set; }
    public string FeatureId { get; public set; }
    public LeafRecordWrapper(qx8= leaf, int recordId, string featureId);
    [CompilerGeneratedAttribute]
public qx8= get_Leaf();
    [CompilerGeneratedAttribute]
public void set_Leaf(qx8= value);
    [CompilerGeneratedAttribute]
public int get_RecordId();
    [CompilerGeneratedAttribute]
public void set_RecordId(int value);
    [CompilerGeneratedAttribute]
public string get_FeatureId();
    [CompilerGeneratedAttribute]
public void set_FeatureId(string value);
}
public class ThinkGeo.Core.LegendAdornmentLayer : AdornmentLayer {
    [ObfuscationAttribute]
private GeoCollection`1<LegendItem> legendItems;
    [ObfuscationAttribute]
private float titleHeight;
    [ObfuscationAttribute]
private float footerHeight;
    [ObfuscationAttribute]
private float rowMaxWidth;
    [ObfuscationAttribute]
private Collection`1<LegendDrawingParameters> offsets;
    [ObfuscationAttribute]
private LegendItem title;
    [ObfuscationAttribute]
private LegendItem footer;
    [ObfuscationAttribute]
private LegendContentResizeMode contentResizeMode;
    public LegendItem Title { get; public set; }
    public LegendItem Footer { get; public set; }
    public GeoCollection`1<LegendItem> LegendItems { get; }
    public LegendContentResizeMode ContentResizeMode { get; public set; }
    public LegendItem get_Title();
    public void set_Title(LegendItem value);
    public LegendItem get_Footer();
    public void set_Footer(LegendItem value);
    public GeoCollection`1<LegendItem> get_LegendItems();
    public LegendContentResizeMode get_ContentResizeMode();
    public void set_ContentResizeMode(LegendContentResizeMode value);
    protected virtual void DrawCore(GeoCanvas canvas, Collection`1<SimpleCandidate> labelsInAllLayers);
    private void dCA=(Collection`1<SimpleCandidate> labelsInAllLayers, GeoCanvas adornmentGeoCanvas, int countPostion, LegendItem legendItem);
    private void dSA=(Collection`1<SimpleCandidate> labelsInAllLayers, GeoCanvas adornmentGeoCanvas);
    private void diA=(Collection`1<SimpleCandidate> labelsInAllLayers, GeoCanvas adornmentGeoCanvas);
    private void dyA=(float widthEnlargedRatio, float heightEnlargedRatio);
    private bool eCA=(LegendItem legendItem, string type);
}
public enum ThinkGeo.Core.LegendContentResizeMode : Enum {
    public int value__;
    public static LegendContentResizeMode Default;
    public static LegendContentResizeMode Resizable;
    public static LegendContentResizeMode Fixed;
}
public class ThinkGeo.Core.LegendDrawingParameters : ValueType {
    [ObfuscationAttribute]
private float xOffset;
    [ObfuscationAttribute]
private float yOffset;
    public float XOffset { get; public set; }
    public float YOffset { get; public set; }
    public float get_XOffset();
    public void set_XOffset(float value);
    public float get_YOffset();
    public void set_YOffset(float value);
    public virtual int GetHashCode();
    public virtual bool Equals(object obj);
    private bool lhU=(LegendDrawingParameters param);
    public static bool op_Equality(LegendDrawingParameters param1, LegendDrawingParameters param2);
    public static bool op_Inequality(LegendDrawingParameters param1, LegendDrawingParameters param2);
}
public enum ThinkGeo.Core.LegendImageJustificationMode : Enum {
    public int value__;
    public static LegendImageJustificationMode Default;
    public static LegendImageJustificationMode JustifyImageLeft;
    public static LegendImageJustificationMode JustifyImageRight;
}
public class ThinkGeo.Core.LegendItem : object {
    [ObfuscationAttribute]
private float width;
    [ObfuscationAttribute]
private float height;
    [ObfuscationAttribute]
private float imageWidth;
    [ObfuscationAttribute]
private float imageHeight;
    [ObfuscationAttribute]
private float topPadding;
    [ObfuscationAttribute]
private float bottomPadding;
    [ObfuscationAttribute]
private float leftPadding;
    [ObfuscationAttribute]
private float rightPadding;
    [ObfuscationAttribute]
private float imageTopPadding;
    [ObfuscationAttribute]
private float imageBottomPadding;
    [ObfuscationAttribute]
private float imageLeftPadding;
    [ObfuscationAttribute]
private float imageRightPadding;
    [ObfuscationAttribute]
private float textTopPadding;
    [ObfuscationAttribute]
private float textBottomPadding;
    [ObfuscationAttribute]
private float textLeftPadding;
    [ObfuscationAttribute]
private float textRightPadding;
    [ObfuscationAttribute]
private Style imageStyle;
    [ObfuscationAttribute]
private TextStyle textStyle;
    [ObfuscationAttribute]
private AreaStyle backgroundMask;
    [ObfuscationAttribute]
private AreaStyle textMask;
    [ObfuscationAttribute]
private AreaStyle imageMask;
    [ObfuscationAttribute]
private LegendImageJustificationMode imageJustificationMode;
    [ObfuscationAttribute]
private Nullable`1<float> originalFontSize;
    [ObfuscationAttribute]
private float ratio;
    public float TopPadding { get; public set; }
    public float BottomPadding { get; public set; }
    public float LeftPadding { get; public set; }
    public float RightPadding { get; public set; }
    public float ImageTopPadding { get; public set; }
    public float ImageBottomPadding { get; public set; }
    public float ImageLeftPadding { get; public set; }
    public float ImageRightPadding { get; public set; }
    public float TextTopPadding { get; public set; }
    public float TextBottomPadding { get; public set; }
    public float TextLeftPadding { get; public set; }
    public float TextRightPadding { get; public set; }
    public float Width { get; public set; }
    public float Height { get; public set; }
    public float ImageWidth { get; public set; }
    public float ImageHeight { get; public set; }
    public Style ImageStyle { get; public set; }
    public TextStyle TextStyle { get; public set; }
    public AreaStyle BackgroundMask { get; public set; }
    public AreaStyle TextMask { get; public set; }
    public AreaStyle ImageMask { get; public set; }
    public float Ratio { get; public set; }
    public LegendImageJustificationMode ImageJustificationMode { get; public set; }
    public LegendItem(int width, int height, float imageWidth, float imageHeight, Style imageStyle, TextStyle textStyle);
    public float get_TopPadding();
    public void set_TopPadding(float value);
    public float get_BottomPadding();
    public void set_BottomPadding(float value);
    public float get_LeftPadding();
    public void set_LeftPadding(float value);
    public float get_RightPadding();
    public void set_RightPadding(float value);
    public float get_ImageTopPadding();
    public void set_ImageTopPadding(float value);
    public float get_ImageBottomPadding();
    public void set_ImageBottomPadding(float value);
    public float get_ImageLeftPadding();
    public void set_ImageLeftPadding(float value);
    public float get_ImageRightPadding();
    public void set_ImageRightPadding(float value);
    public float get_TextTopPadding();
    public void set_TextTopPadding(float value);
    public float get_TextBottomPadding();
    public void set_TextBottomPadding(float value);
    public float get_TextLeftPadding();
    public void set_TextLeftPadding(float value);
    public float get_TextRightPadding();
    public void set_TextRightPadding(float value);
    public float get_Width();
    public void set_Width(float value);
    public float get_Height();
    public void set_Height(float value);
    public float get_ImageWidth();
    public void set_ImageWidth(float value);
    public float get_ImageHeight();
    public void set_ImageHeight(float value);
    public Style get_ImageStyle();
    public void set_ImageStyle(Style value);
    public TextStyle get_TextStyle();
    public void set_TextStyle(TextStyle value);
    public AreaStyle get_BackgroundMask();
    public void set_BackgroundMask(AreaStyle value);
    public AreaStyle get_TextMask();
    public void set_TextMask(AreaStyle value);
    public AreaStyle get_ImageMask();
    public void set_ImageMask(AreaStyle value);
    public float get_Ratio();
    public void set_Ratio(float value);
    public LegendImageJustificationMode get_ImageJustificationMode();
    public void set_ImageJustificationMode(LegendImageJustificationMode value);
    public void Draw(GeoCanvas adornmentGeoCanvas, Collection`1<SimpleCandidate> labelsInAllLayers, LegendDrawingParameters legendDrawingParameters);
    protected virtual void DrawCore(GeoCanvas adornmentGeoCanvas, Collection`1<SimpleCandidate> labelsInAllLayers, LegendDrawingParameters legendDrawingParameters);
    public void UpdateSizeByTextLength(GeoCanvas canvas, double zoomRatio);
    private string eSA=(int wordWrapLength);
}
public enum ThinkGeo.Core.LibTiff.Compression : Enum {
    public int value__;
    public static Compression NONE;
    public static Compression CCITTRLE;
    public static Compression CCITTFAX3;
    public static Compression CCITT_T4;
    public static Compression CCITTFAX4;
    public static Compression CCITT_T6;
    public static Compression LZW;
    public static Compression OJPEG;
    public static Compression JPEG;
    public static Compression NEXT;
    public static Compression CCITTRLEW;
    public static Compression PACKBITS;
    public static Compression THUNDERSCAN;
    public static Compression IT8CTPAD;
    public static Compression IT8LW;
    public static Compression IT8MP;
    public static Compression IT8BL;
    public static Compression PIXARFILM;
    public static Compression PIXARLOG;
    public static Compression DEFLATE;
    public static Compression ADOBE_DEFLATE;
    public static Compression DCS;
    public static Compression JBIG;
    public static Compression SGILOG;
    public static Compression SGILOG24;
    public static Compression JP2000;
}
public class ThinkGeo.Core.LibTiff.FieldValue : ValueType {
    private object 2jM=;
    public object Value { get; }
    internal FieldValue(object o);
    internal static FieldValue[] 2zM=(Object[] list);
    internal void 3DM=(object o);
    public object get_Value();
    public byte ToByte();
    public short ToShort();
    public ushort ToUShort();
    public int ToInt();
    public UInt32 ToUInt();
    public long ToLong();
    public float ToFloat();
    public double ToDouble();
    public virtual string ToString();
    public Byte[] GetBytes();
    public Byte[] ToByteArray();
    public Int16[] ToShortArray();
    public UInt16[] ToUShortArray();
    public Int32[] ToIntArray();
    public UInt32[] ToUIntArray();
    public Int64[] TolongArray();
    public Single[] ToFloatArray();
    public Double[] ToDoubleArray();
}
public enum ThinkGeo.Core.LibTiff.Orientation : Enum {
    public int value__;
    public static Orientation TOPLEFT;
    public static Orientation TOPRIGHT;
    public static Orientation BOTRIGHT;
    public static Orientation BOTLEFT;
    public static Orientation LEFTTOP;
    public static Orientation RIGHTTOP;
    public static Orientation RIGHTBOT;
    public static Orientation LEFTBOT;
}
public class ThinkGeo.Core.LibTiff.Tiff : object {
    private static TiffErrorHandler nzQ=;
    private static TiffExtendProc oDQ=;
    private static TiffFieldInfo[] oTQ=;
    private static TiffFieldInfo[] ojQ=;
    private static int ozQ=;
    private static int pDQ=;
    private static short pTQ=;
    private static short pjQ=;
    private static short pzQ=;
    private static float qDQ=;
    private static float qTQ=;
    private static float qjQ=;
    internal static int qzQ=;
    internal static 7jY= rDQ=;
    internal static bool rTQ=;
    internal static bool rjQ=;
    internal static Encoding rzQ=;
    internal string sDQ=;
    internal int 5jM=;
    internal 7jY= sTQ=;
    internal ulong sjQ=;
    internal qjY= szQ=;
    internal int tDQ=;
    internal int tTQ=;
    internal int tjQ=;
    internal int tzQ=;
    internal TiffCodec uDQ=;
    internal int uTQ=;
    internal Byte[] ujQ=;
    internal int uzQ=;
    internal int vDQ=;
    internal int vTQ=;
    internal object vjQ=;
    internal 1UA= vzQ=;
    internal TiffTagMethods wDQ=;
    private ulong wTQ=;
    private UInt64[] wjQ=;
    private int wzQ=;
    private short xDQ=;
    private BDc= xTQ=;
    private Int32[] xjQ=;
    private UInt32[] xzQ=;
    private short yDQ=;
    private ulong yTQ=;
    private ulong yjQ=;
    private short yzQ=;
    private ulong zDQ=;
    private int zTQ=;
    private bool zjQ=;
    private TiffFieldInfo[] zzQ=;
    private int 0DQ=;
    private TiffFieldInfo 0TQ=;
    private 3kA= 0jQ=;
    private TiffCodec[] 0zQ=;
    private 20A= 1DQ=;
    private TiffTagMethods 1TQ=;
    private bool 1jQ=;
    private Stream 1zQ=;
    private TiffStream jzQ=;
    private static UInt32[] 2DQ=;
    private static Int32[] 2TQ=;
    private static Int32[] 2jQ=;
    private static String[] 2zQ=;
    private static String[] 3DQ=;
    private static int 3TQ=;
    private static int 3jQ=;
    internal static int 3zQ=;
    internal static int 4DQ=;
    internal static int 4TQ=;
    internal static int 4jQ=;
    internal static int 4zQ=;
    private static Byte[] 5DQ=;
    private static Byte[] 5TQ=;
    public static string AssemblyVersion { get; }
    private static Tiff();
    private static Tiff GR8=(string fileName, string mode, TiffErrorHandler errorHandler);
    private static Tiff GR8=(string fileName, string mode, TiffErrorHandler errorHandler, TiffExtendProc extender);
    private static Tiff 5jQ=(string name, string mode, object clientData, TiffStream stream, TiffErrorHandler errorHandler);
    private static Tiff 5jQ=(string name, string mode, object clientData, TiffStream stream, TiffErrorHandler errorHandler, TiffExtendProc extender);
    private static TiffErrorHandler 5zQ=(TiffErrorHandler errorHandler);
    private static TiffExtendProc 6DQ=(TiffExtendProc extender);
    private static TiffErrorHandler 6TQ=(Tiff tif);
    private static bool 6jQ=(qjY= td);
    private static void 6zQ=(qjY= td);
    internal static ulong 7DQ=(Byte[] buffer, int offset);
    internal static int 7TQ=(Byte[] buffer, int offset);
    internal static void 7jQ=(int value, Byte[] buffer, int offset);
    internal static void 7zQ=(ulong value, Byte[] buffer, int offset);
    internal static short 8DQ=(Byte[] buffer, int offset);
    internal static void 8TQ=(Stream fd, string format, Object[] list);
    private static string 8jQ=(byte value);
    private void 8zQ=();
    internal static bool 9DQ=(TiffTag t);
    private bool 9TQ=(cjM= o);
    private static int 9jQ=(int n);
    private bool 9zQ=(TiffTag tag);
    private void /DQ=();
    private bool /TQ=(UInt64& nextdir, Int64& off);
    internal static void /jQ=(String& cpp, string cp);
    internal static void /zQ=(Int16[]& wpp, Int16[] wp, int n);
    internal static void ADU=(Int32[]& lpp, Int32[] lp, int n);
    internal static void ATU=(Int64[]& lpp, Int64[] lp, int n);
    internal static void AjU=(Single[]& fpp, Single[] fp, int n);
    internal bool AzU=(int field);
    internal void BDU=(int field);
    internal void BTU=(int field);
    private static TiffFieldInfo[] BjU=(Int32& size);
    private static TiffFieldInfo[] BzU=(Int32& size);
    private void CDU=(TiffFieldInfo[] info, int n);
    private TiffType CTU=();
    private static TiffFieldInfo CjU=(TiffTag tag, TiffType field_type);
    internal static int CzU=(TiffType type);
    private long DDU=(2jY= dir);
    private bool DTU=(qjY= td);
    private static int DjU=(int x);
    private bool DzU=(2jY=[] dir, long dircount);
    private void EDU=(string tagname);
    private int ETU=(2jY= dir);
    private static long EjU=(2jY=[] dir, ulong dircount, TiffTag tagid);
    private bool EzU=(ulong diroff);
    private ulong FDU=(ulong diroff, 2jY=[]& pdir, UInt64& nextdiroff);
    private bool FTU=(2jY= dir);
    private bool FjU=(2jY= dir, int count);
    private int FzU=(2jY= dir, Byte[] buffer);
    private int GDU=(2jY= dir, String& cp);
    private bool GTU=(2jY= dir, int num, int denom, Single& rv);
    private float GjU=(2jY= dir);
    private float GzU=(2jY= dir);
    private bool HDU=(2jY= dir, Byte[] v);
    private bool HTU=(2jY= dir, Int16[] v);
    private bool HjU=(2jY= dir);
    private bool HzU=(2jY= dir, Int32[] v);
    private bool IDU=(2jY= dir, Int64[] v);
    private bool ITU=(2jY= dir, Single[] v);
    private bool IjU=(2jY= dir, Single[] v);
    private bool IzU=(2jY= dir, Double[] v);
    private bool JDU=(2jY= dir, Double[] v);
    private bool JTU=(2jY= dir);
    private bool JjU=(2jY= dir, Int16& pl);
    private bool JzU=(2jY= dir, Int32& pl);
    private bool KDU=(2jY= dir, Double& pl);
    private bool KTU=(2jY= dir, int nstrips, Int64[]& lpp);
    private bool KTU=(2jY= dir, int nstrips, UInt64[]& lpp);
    private bool KjU=(2jY= dir);
    private void KzU=();
    internal static int LDU=(int x, int y);
    internal static int LTU=(int x, int y);
    internal static ulong LTU=(ulong x, ulong y);
    private ulong LjU=(TiffType type, int v);
    private static void LzU=(Int32[] fields, short f);
    private static bool AzU=(Int32[] fields, short f);
    private bool MDU=(TiffType type, TiffTag tag, 2jY=& dir, float v);
    private bool MTU=(2jY=[] entries, int dirOffset, TiffType type, TiffTag tag1, float v1, TiffTag tag2, float v2);
    private bool MjU=(bool done);
    private bool MzU=();
    private bool NDU=(2jY=& dir, TiffFieldInfo fip);
    private void NTU=(TiffTag tag, 2jY=& dir, int v);
    private void NjU=(TiffTag tag, 2jY=& dir, short v);
    private bool NzU=(TiffTag tag, 2jY=& dir);
    private bool ODU=(TiffType type, TiffTag tag, 2jY=& dir);
    private bool OTU=(TiffTag tag, 2jY=& dir);
    private bool OjU=(TiffTag tag, 2jY=& dir, int n, Int16[][] table);
    private bool OzU=(2jY=& dir, Byte[] cp);
    private bool PDU=(2jY=& dir, Int16[] v);
    private bool PTU=(2jY=& dir, Int32[] v);
    private bool PTU=(2jY=& dir, UInt32[] v);
    private bool PjU=(2jY=& dir, Int64[] v);
    private bool PjU=(2jY=& dir, UInt64[] v);
    private bool PzU=(2jY=& dir, Single[] v);
    private bool QDU=(2jY=& dir, Single[] v);
    private bool QTU=(2jY=& dir, Double[] v);
    private bool QjU=(TiffType type, TiffTag tag, 2jY=& dir, int n, Double[] v);
    private bool QzU=(2jY=& dir);
    private bool RDU=(2jY=& dir);
    private bool RTU=(2jY=& dir, Byte[] buffer, int count);
    private bool RTU=(2jY=& dir, Int16[] buffer, int count);
    private bool RTU=(2jY=& dir, Int64[] buffer, int count);
    private bool RTU=(2jY=& dir, Int32[] cp, int cc);
    private bool RTU=(2jY=& dir, Single[] cp, int cc);
    private bool RTU=(2jY=& dir, Double[] buffer, int count);
    private bool RjU=();
    private void 1x0=(bool disposing);
    private bool RzU=(Int64& pdiroff);
    internal static void SDU=(UInt32& lp);
    internal static UInt64[] STU=(UInt64[] buffer, int elementCount, int newElementCount);
    internal static TiffFieldInfo[] STU=(TiffFieldInfo[] buffer, int elementCount, int newElementCount);
    internal static DTc=[] STU=(DTc=[] buffer, int elementCount, int newElementCount);
    internal bool SjU=(Compression scheme);
    private void SzU=(Byte[] buffer, int offset, int count);
    private void TDU=(int magic);
    private static int TTU=(string mode, string module, FileMode& m, FileAccess& a);
    private static void TjU=(Stream fd, TiffFieldInfo fip, int value_count, object raw_data);
    private bool TzU=(Stream fd, TiffTag tag, int value_count, object raw_data);
    private static void UDU=(Stream fd, string cp);
    private int UTU=(Byte[] buf, int offset, int size);
    private long UjU=(long off, SeekOrigin whence);
    private long UzU=();
    private bool VDU=(Byte[] buf, int size);
    private bool VTU=(Int16& value);
    private bool VjU=(UInt64& dircount, bool isBigTiff);
    private bool VzU=(UInt32& value);
    private bool WDU=(UInt64& value);
    private bool WTU=(Int64& value);
    private bool WjU=(Int32& value);
    private bool WzU=(2jY=[] dir, ulong dircount, bool isBigTiff);
    private static void XDU=(2jY=[] dir, ulong dircount, Byte[] bytes, int offset, bool isBigTiff);
    private bool XTU=(BDc=& header);
    private bool XjU=(long off);
    private bool XzU=(int row, short sample);
    private int YDU=(int strip, Byte[] buf, int offset, int size, string module);
    private int YTU=(int tile, Byte[] buf, int offset, int size, string module);
    private bool YjU=(int strip);
    private bool YzU=(int tile);
    private bool ZDU=(bool tiles);
    private static void ZTU=(Byte[] buffer, int offset, int count);
    private static void ZjU=(Byte[] buffer, int offset, int count);
    private static void ZzU=(Byte[] buffer, int offset, int count);
    private static void aDU=(Byte[] buffer, int offset, int count);
    internal bool aTU=(int strip);
    internal bool ajU=(int tile);
    private int azU=(int summand1, int summand2, string where);
    private int bDU=(int nmemb, int elem_size, string where);
    internal int bTU=();
    internal int bjU=();
    private bool bzU=(string module);
    private bool cDU=(string module);
    private void cTU=();
    private bool cjU=(Byte[] buffer, int offset, int count);
    private bool czU=(BDc= header);
    private bool dDU=(2jY=[] entries, long count, bool isBigTiff);
    private bool dTU=(short value);
    private bool djU=(long value, bool isBigTiff);
    private bool dzU=(long value, bool isBigTiff);
    private bool eDU=(int value);
    private bool eTU=(long value);
    private bool ejU=(int f);
    private bool ezU=(int delta);
    private bool fDU=(int strip, Byte[] buffer, int offset, long count);
    internal bool fTU=();
    public static string GetVersion();
    public static string get_AssemblyVersion();
    public static int GetR(int abgr);
    public static int GetG(int abgr);
    public static int GetB(int abgr);
    public static int GetA(int abgr);
    public TiffCodec FindCodec(Compression scheme);
    public void RegisterCodec(TiffCodec codec);
    public void UnRegisterCodec(TiffCodec codec);
    public bool IsCodecConfigured(Compression scheme);
    public TiffCodec[] GetConfiguredCodecs();
    public static Byte[] Realloc(Byte[] array, int size);
    public static Int32[] Realloc(Int32[] array, int size);
    public static int Compare(Int16[] first, Int16[] second, int elementCount);
    public static Tiff Open(string fileName, string mode);
    public static Tiff ClientOpen(string name, string mode, object clientData, TiffStream stream);
    public void Close();
    public sealed virtual void Dispose();
    public int GetTagListCount();
    public int GetTagListEntry(int index);
    public void MergeFieldInfo(TiffFieldInfo[] info, int count);
    public TiffFieldInfo FindFieldInfo(TiffTag tag, TiffType type);
    public TiffFieldInfo FindFieldInfoByName(string name, TiffType type);
    public TiffFieldInfo FieldWithTag(TiffTag tag);
    public TiffFieldInfo FieldWithName(string name);
    public TiffTagMethods GetTagMethods();
    public TiffTagMethods SetTagMethods(TiffTagMethods methods);
    public object GetClientInfo(string name);
    public void SetClientInfo(object data, string name);
    public bool Flush();
    public bool FlushData();
    public FieldValue[] GetField(TiffTag tag);
    public FieldValue[] GetFieldDefaulted(TiffTag tag);
    public bool ReadDirectory();
    public bool ReadCustomDirectory(long offset, TiffFieldInfo[] info, int count);
    public bool ReadEXIFDirectory(long offset);
    public int ScanlineSize();
    public int RasterScanlineSize();
    public int DefaultStripSize(int estimate);
    public int StripSize();
    public int VStripSize(int rowCount);
    public long RawStripSize(int strip);
    public int ComputeStrip(int row, short plane);
    public int NumberOfStrips();
    public void DefaultTileSize(Int32& width, Int32& height);
    public int TileSize();
    public int VTileSize(int rowCount);
    public long RawTileSize(int tile);
    public int TileRowSize();
    public int ComputeTile(int x, int y, int z, short plane);
    public bool CheckTile(int x, int y, int z, short plane);
    public int NumberOfTiles();
    public object Clientdata();
    public object SetClientdata(object data);
    public int GetMode();
    public int SetMode(int mode);
    public bool IsTiled();
    public bool IsByteSwapped();
    public bool IsUpSampled();
    public bool IsMSB2LSB();
    public bool IsBigEndian();
    public TiffStream GetStream();
    public int CurrentRow();
    public short CurrentDirectory();
    public short NumberOfDirectories();
    public long CurrentDirOffset();
    public int CurrentStrip();
    public int CurrentTile();
    public void ReadBufferSetup(Byte[] buffer, int size);
    public void WriteBufferSetup(Byte[] buffer, int size);
    public bool SetupStrips();
    public bool WriteCheck(bool tiles, string method);
    public void FreeDirectory();
    public void CreateDirectory();
    public bool LastDirectory();
    public bool SetDirectory(short number);
    public bool SetSubDirectory(long offset);
    public bool UnlinkDirectory(short number);
    public bool SetField(TiffTag tag, Object[] value);
    public bool WriteDirectory();
    public bool CheckpointDirectory();
    public bool RewriteDirectory();
    public void PrintDirectory(Stream stream);
    public void PrintDirectory(Stream stream, TiffPrintFlags flags);
    public bool ReadScanline(Byte[] buffer, int row);
    public bool ReadScanline(Byte[] buffer, int row, short plane);
    public bool ReadScanline(Byte[] buffer, int offset, int row, short plane);
    public bool WriteScanline(Byte[] buffer, int row);
    public bool WriteScanline(Byte[] buffer, int row, short plane);
    public bool WriteScanline(Byte[] buffer, int offset, int row, short plane);
    public bool ReadRGBAImage(int width, int height, Int32[] raster);
    public bool ReadRGBAImage(int width, int height, Int32[] raster, bool stopOnError);
    public bool ReadRGBAImageOriented(int width, int height, Int32[] raster, Orientation orientation);
    public bool ReadRGBAImageOriented(int width, int height, Int32[] raster, Orientation orientation, bool stopOnError);
    public bool ReadRGBAStrip(int row, Int32[] raster);
    public bool ReadRGBATile(int col, int row, Int32[] raster);
    public bool RGBAImageOK(String& errorMsg);
    public string FileName();
    public string SetFileName(string name);
    public static void Error(Tiff tif, string method, string format, Object[] args);
    public static void Error(string method, string format, Object[] args);
    public static void ErrorExt(Tiff tif, object clientData, string method, string format, Object[] args);
    public static void ErrorExt(object clientData, string method, string format, Object[] args);
    public static void Warning(Tiff tif, string method, string format, Object[] args);
    public static void Warning(string method, string format, Object[] args);
    public static void WarningExt(Tiff tif, object clientData, string method, string format, Object[] args);
    public static void WarningExt(object clientData, string method, string format, Object[] args);
    public static TiffErrorHandler SetErrorHandler(TiffErrorHandler errorHandler);
    public static TiffExtendProc SetTagExtender(TiffExtendProc extender);
    public int ReadTile(Byte[] buffer, int offset, int x, int y, int z, short plane);
    public int ReadEncodedTile(int tile, Byte[] buffer, int offset, int count);
    public int ReadRawTile(int tile, Byte[] buffer, int offset, int count);
    public int WriteTile(Byte[] buffer, int x, int y, int z, short plane);
    public int WriteTile(Byte[] buffer, int offset, int x, int y, int z, short plane);
    public int ReadEncodedStrip(int strip, Byte[] buffer, int offset, int count);
    public int ReadRawStrip(int strip, Byte[] buffer, int offset, int count);
    public int WriteEncodedStrip(int strip, Byte[] buffer, int count);
    public int WriteEncodedStrip(int strip, Byte[] buffer, int offset, int count);
    public int WriteRawStrip(int strip, Byte[] buffer, int count);
    public int WriteRawStrip(int strip, Byte[] buffer, int offset, int count);
    public int WriteEncodedTile(int tile, Byte[] buffer, int count);
    public int WriteEncodedTile(int tile, Byte[] buffer, int offset, int count);
    public int WriteRawTile(int tile, Byte[] buffer, int count);
    public int WriteRawTile(int tile, Byte[] buffer, int offset, int count);
    public void SetWriteOffset(long offset);
    public static int DataWidth(TiffType type);
    public static void SwabShort(Int16& value);
    public static void SwabLong(Int32& value);
    private static void fjU=(UInt64& value);
    private static void fzU=(UInt64& value, bool isBigTiff, bool isShort);
    public static void SwabDouble(Double& value);
    public static void SwabArrayOfShort(Int16[] array, int count);
    public static void SwabArrayOfShort(Int16[] array, int offset, int count);
    public static void SwabArrayOfTriples(Byte[] array, int count);
    public static void SwabArrayOfTriples(Byte[] array, int offset, int count);
    public static void SwabArrayOfLong(Int32[] array, int count);
    public static void SwabArrayOfLong8(Int64[] array, int count);
    public static void SwabArrayOfLong(Int32[] array, int offset, int count);
    public static void SwabArrayOfLong8(Int64[] array, int offset, int count);
    public static void SwabArrayOfDouble(Double[] array, int count);
    public static void SwabArrayOfDouble(Double[] array, int offset, int count);
    public static void ReverseBits(Byte[] buffer, int count);
    public static void ReverseBits(Byte[] buffer, int offset, int count);
    public static Byte[] GetBitRevTable(bool reversed);
    public static Int32[] ByteArrayToInts(Byte[] buffer, int offset, int count);
    public static Int64[] ByteArrayToLong8(Byte[] buffer, int offset, int count);
    public static void Long8ToByteArray(Int64[] source, int srcOffset, int srcCount, Byte[] bytes, int offset);
    public static void IntsToByteArray(Int32[] source, int srcOffset, int srcCount, Byte[] bytes, int offset);
    public static Int16[] ByteArrayToShorts(Byte[] buffer, int offset, int count);
    public static void ShortsToByteArray(Int16[] source, int srcOffset, int srcCount, Byte[] bytes, int offset);
    private static Int64[] gDU=(Int32[] inputArray);
    private static UInt32[] gTU=(UInt64[] inputArray);
    private static Int32[] gTU=(Int64[] inputArray);
}
public class ThinkGeo.Core.LibTiff.TiffCodec : object {
    protected Tiff m_tif;
    protected internal Compression m_scheme;
    protected internal string m_name;
    public bool CanEncode { get; }
    public bool CanDecode { get; }
    public TiffCodec(Tiff tif, Compression scheme, string name);
    public virtual bool get_CanEncode();
    public virtual bool get_CanDecode();
    public virtual bool Init();
    public virtual bool SetupDecode();
    public virtual bool PreDecode(short plane);
    public virtual bool DecodeRow(Byte[] buffer, int offset, int count, short plane);
    public virtual bool DecodeStrip(Byte[] buffer, int offset, int count, short plane);
    public virtual bool DecodeTile(Byte[] buffer, int offset, int count, short plane);
    public virtual bool SetupEncode();
    public virtual bool PreEncode(short plane);
    public virtual bool PostEncode();
    public virtual bool EncodeRow(Byte[] buffer, int offset, int count, short plane);
    public virtual bool EncodeStrip(Byte[] buffer, int offset, int count, short plane);
    public virtual bool EncodeTile(Byte[] buffer, int offset, int count, short plane);
    public virtual void Close();
    public virtual bool Seek(int row);
    public virtual void Cleanup();
    public virtual int DefStripSize(int size);
    public virtual void DefTileSize(Int32& width, Int32& height);
    private bool 0Ds=(string method);
    private bool 0Ts=(string method);
}
public class ThinkGeo.Core.LibTiff.TiffErrorHandler : object {
    public virtual void ErrorHandler(Tiff tif, string method, string format, Object[] args);
    public virtual void ErrorHandlerExt(Tiff tif, object clientData, string method, string format, Object[] args);
    public virtual void WarningHandler(Tiff tif, string method, string format, Object[] args);
    public virtual void WarningHandlerExt(Tiff tif, object clientData, string method, string format, Object[] args);
}
public class ThinkGeo.Core.LibTiff.TiffFieldInfo : object {
    private TiffTag 0js=;
    private short 0zs=;
    private short 1Ds=;
    private TiffType 1Ts=;
    private short ETQ=;
    private bool 1js=;
    private bool 1zs=;
    private string sDQ=;
    public static short Variable;
    public static short Spp;
    public static short Variable2;
    public TiffTag Tag { get; }
    public short ReadCount { get; }
    public short WriteCount { get; }
    public TiffType Type { get; }
    public short Bit { get; }
    public bool OkToChange { get; }
    public bool PassCount { get; }
    public string Name { get; internal set; }
    public TiffFieldInfo(TiffTag tag, short readCount, short writeCount, TiffType type, short bit, bool okToChange, bool passCount, string name);
    public virtual string ToString();
    public TiffTag get_Tag();
    public short get_ReadCount();
    public short get_WriteCount();
    public TiffType get_Type();
    public short get_Bit();
    public bool get_OkToChange();
    public bool get_PassCount();
    public string get_Name();
    internal void set_Name(string value);
}
[FlagsAttribute]
public enum ThinkGeo.Core.LibTiff.TiffPrintFlags : Enum {
    public int value__;
    public static TiffPrintFlags NONE;
    public static TiffPrintFlags STRIPS;
    public static TiffPrintFlags CURVES;
    public static TiffPrintFlags COLORMAP;
    public static TiffPrintFlags JPEGQTABLES;
    public static TiffPrintFlags JPEGACTABLES;
    public static TiffPrintFlags JPEGDCTABLES;
}
public class ThinkGeo.Core.LibTiff.TiffStream : object {
    public virtual int Read(object clientData, Byte[] buffer, int offset, int count);
    public virtual void Write(object clientData, Byte[] buffer, int offset, int count);
    public virtual long Seek(object clientData, long offset, SeekOrigin origin);
    public virtual void Close(object clientData);
    public virtual long Size(object clientData);
}
public enum ThinkGeo.Core.LibTiff.TiffTag : Enum {
    public int value__;
    public static TiffTag IGNORE;
    public static TiffTag SUBFILETYPE;
    public static TiffTag OSUBFILETYPE;
    public static TiffTag IMAGEWIDTH;
    public static TiffTag IMAGELENGTH;
    public static TiffTag BITSPERSAMPLE;
    public static TiffTag COMPRESSION;
    public static TiffTag PHOTOMETRIC;
    public static TiffTag THRESHHOLDING;
    public static TiffTag CELLWIDTH;
    public static TiffTag CELLLENGTH;
    public static TiffTag FILLORDER;
    public static TiffTag DOCUMENTNAME;
    public static TiffTag IMAGEDESCRIPTION;
    public static TiffTag MAKE;
    public static TiffTag MODEL;
    public static TiffTag STRIPOFFSETS;
    public static TiffTag ORIENTATION;
    public static TiffTag SAMPLESPERPIXEL;
    public static TiffTag ROWSPERSTRIP;
    public static TiffTag STRIPBYTECOUNTS;
    public static TiffTag MINSAMPLEVALUE;
    public static TiffTag MAXSAMPLEVALUE;
    public static TiffTag XRESOLUTION;
    public static TiffTag YRESOLUTION;
    public static TiffTag PLANARCONFIG;
    public static TiffTag PAGENAME;
    public static TiffTag XPOSITION;
    public static TiffTag YPOSITION;
    public static TiffTag FREEOFFSETS;
    public static TiffTag FREEBYTECOUNTS;
    public static TiffTag GRAYRESPONSEUNIT;
    public static TiffTag GRAYRESPONSECURVE;
    public static TiffTag GROUP3OPTIONS;
    public static TiffTag T4OPTIONS;
    public static TiffTag GROUP4OPTIONS;
    public static TiffTag T6OPTIONS;
    public static TiffTag RESOLUTIONUNIT;
    public static TiffTag PAGENUMBER;
    public static TiffTag COLORRESPONSEUNIT;
    public static TiffTag TRANSFERFUNCTION;
    public static TiffTag SOFTWARE;
    public static TiffTag DATETIME;
    public static TiffTag ARTIST;
    public static TiffTag HOSTCOMPUTER;
    public static TiffTag PREDICTOR;
    public static TiffTag WHITEPOINT;
    public static TiffTag PRIMARYCHROMATICITIES;
    public static TiffTag COLORMAP;
    public static TiffTag HALFTONEHINTS;
    public static TiffTag TILEWIDTH;
    public static TiffTag TILELENGTH;
    public static TiffTag TILEOFFSETS;
    public static TiffTag TILEBYTECOUNTS;
    public static TiffTag BADFAXLINES;
    public static TiffTag CLEANFAXDATA;
    public static TiffTag CONSECUTIVEBADFAXLINES;
    public static TiffTag SUBIFD;
    public static TiffTag INKSET;
    public static TiffTag INKNAMES;
    public static TiffTag NUMBEROFINKS;
    public static TiffTag DOTRANGE;
    public static TiffTag TARGETPRINTER;
    public static TiffTag EXTRASAMPLES;
    public static TiffTag SAMPLEFORMAT;
    public static TiffTag SMINSAMPLEVALUE;
    public static TiffTag SMAXSAMPLEVALUE;
    public static TiffTag CLIPPATH;
    public static TiffTag XCLIPPATHUNITS;
    public static TiffTag YCLIPPATHUNITS;
    public static TiffTag INDEXED;
    public static TiffTag JPEGTABLES;
    public static TiffTag OPIPROXY;
    public static TiffTag JPEGPROC;
    public static TiffTag JPEGIFOFFSET;
    public static TiffTag JPEGIFBYTECOUNT;
    public static TiffTag JPEGRESTARTINTERVAL;
    public static TiffTag JPEGLOSSLESSPREDICTORS;
    public static TiffTag JPEGPOINTTRANSFORM;
    public static TiffTag JPEGQTABLES;
    public static TiffTag JPEGDCTABLES;
    public static TiffTag JPEGACTABLES;
    public static TiffTag YCBCRCOEFFICIENTS;
    public static TiffTag YCBCRSUBSAMPLING;
    public static TiffTag YCBCRPOSITIONING;
    public static TiffTag REFERENCEBLACKWHITE;
    public static TiffTag XMLPACKET;
    public static TiffTag OPIIMAGEID;
    public static TiffTag REFPTS;
    public static TiffTag REGIONTACKPOINT;
    public static TiffTag REGIONWARPCORNERS;
    public static TiffTag REGIONAFFINE;
    public static TiffTag MATTEING;
    public static TiffTag DATATYPE;
    public static TiffTag IMAGEDEPTH;
    public static TiffTag TILEDEPTH;
    public static TiffTag PIXAR_IMAGEFULLWIDTH;
    public static TiffTag PIXAR_IMAGEFULLLENGTH;
    public static TiffTag PIXAR_TEXTUREFORMAT;
    public static TiffTag PIXAR_WRAPMODES;
    public static TiffTag PIXAR_FOVCOT;
    public static TiffTag PIXAR_MATRIX_WORLDTOSCREEN;
    public static TiffTag PIXAR_MATRIX_WORLDTOCAMERA;
    public static TiffTag WRITERSERIALNUMBER;
    public static TiffTag COPYRIGHT;
    public static TiffTag RICHTIFFIPTC;
    public static TiffTag IT8SITE;
    public static TiffTag IT8COLORSEQUENCE;
    public static TiffTag IT8HEADER;
    public static TiffTag IT8RASTERPADDING;
    public static TiffTag IT8BITSPERRUNLENGTH;
    public static TiffTag IT8BITSPEREXTENDEDRUNLENGTH;
    public static TiffTag IT8COLORTABLE;
    public static TiffTag IT8IMAGECOLORINDICATOR;
    public static TiffTag IT8BKGCOLORINDICATOR;
    public static TiffTag IT8IMAGECOLORVALUE;
    public static TiffTag IT8BKGCOLORVALUE;
    public static TiffTag IT8PIXELINTENSITYRANGE;
    public static TiffTag IT8TRANSPARENCYINDICATOR;
    public static TiffTag IT8COLORCHARACTERIZATION;
    public static TiffTag IT8HCUSAGE;
    public static TiffTag IT8TRAPINDICATOR;
    public static TiffTag IT8CMYKEQUIVALENT;
    public static TiffTag FRAMECOUNT;
    public static TiffTag PHOTOSHOP;
    public static TiffTag EXIFIFD;
    public static TiffTag ICCPROFILE;
    public static TiffTag JBIGOPTIONS;
    public static TiffTag GPSIFD;
    public static TiffTag FAXRECVPARAMS;
    public static TiffTag FAXSUBADDRESS;
    public static TiffTag FAXRECVTIME;
    public static TiffTag FAXDCS;
    public static TiffTag STONITS;
    public static TiffTag FEDEX_EDR;
    public static TiffTag INTEROPERABILITYIFD;
    public static TiffTag DNGVERSION;
    public static TiffTag DNGBACKWARDVERSION;
    public static TiffTag UNIQUECAMERAMODEL;
    public static TiffTag LOCALIZEDCAMERAMODEL;
    public static TiffTag CFAPLANECOLOR;
    public static TiffTag CFALAYOUT;
    public static TiffTag LINEARIZATIONTABLE;
    public static TiffTag BLACKLEVELREPEATDIM;
    public static TiffTag BLACKLEVEL;
    public static TiffTag BLACKLEVELDELTAH;
    public static TiffTag BLACKLEVELDELTAV;
    public static TiffTag WHITELEVEL;
    public static TiffTag DEFAULTSCALE;
    public static TiffTag DEFAULTCROPORIGIN;
    public static TiffTag DEFAULTCROPSIZE;
    public static TiffTag COLORMATRIX1;
    public static TiffTag COLORMATRIX2;
    public static TiffTag CAMERACALIBRATION1;
    public static TiffTag CAMERACALIBRATION2;
    public static TiffTag REDUCTIONMATRIX1;
    public static TiffTag REDUCTIONMATRIX2;
    public static TiffTag ANALOGBALANCE;
    public static TiffTag ASSHOTNEUTRAL;
    public static TiffTag ASSHOTWHITEXY;
    public static TiffTag BASELINEEXPOSURE;
    public static TiffTag BASELINENOISE;
    public static TiffTag BASELINESHARPNESS;
    public static TiffTag BAYERGREENSPLIT;
    public static TiffTag LINEARRESPONSELIMIT;
    public static TiffTag CAMERASERIALNUMBER;
    public static TiffTag LENSINFO;
    public static TiffTag CHROMABLURRADIUS;
    public static TiffTag ANTIALIASSTRENGTH;
    public static TiffTag SHADOWSCALE;
    public static TiffTag DNGPRIVATEDATA;
    public static TiffTag MAKERNOTESAFETY;
    public static TiffTag CALIBRATIONILLUMINANT1;
    public static TiffTag CALIBRATIONILLUMINANT2;
    public static TiffTag BESTQUALITYSCALE;
    public static TiffTag RAWDATAUNIQUEID;
    public static TiffTag ORIGINALRAWFILENAME;
    public static TiffTag ORIGINALRAWFILEDATA;
    public static TiffTag ACTIVEAREA;
    public static TiffTag MASKEDAREAS;
    public static TiffTag ASSHOTICCPROFILE;
    public static TiffTag ASSHOTPREPROFILEMATRIX;
    public static TiffTag CURRENTICCPROFILE;
    public static TiffTag CURRENTPREPROFILEMATRIX;
    public static TiffTag DCSHUESHIFTVALUES;
    public static TiffTag FAXMODE;
    public static TiffTag JPEGQUALITY;
    public static TiffTag JPEGCOLORMODE;
    public static TiffTag JPEGTABLESMODE;
    public static TiffTag FAXFILLFUNC;
    public static TiffTag PIXARLOGDATAFMT;
    public static TiffTag DCSIMAGERTYPE;
    public static TiffTag DCSINTERPMODE;
    public static TiffTag DCSBALANCEARRAY;
    public static TiffTag DCSCORRECTMATRIX;
    public static TiffTag DCSGAMMA;
    public static TiffTag DCSTOESHOULDERPTS;
    public static TiffTag DCSCALIBRATIONFD;
    public static TiffTag ZIPQUALITY;
    public static TiffTag PIXARLOGQUALITY;
    public static TiffTag DCSCLIPRECTANGLE;
    public static TiffTag SGILOGDATAFMT;
    public static TiffTag SGILOGENCODE;
    public static TiffTag EXIF_EXPOSURETIME;
    public static TiffTag EXIF_FNUMBER;
    public static TiffTag EXIF_EXPOSUREPROGRAM;
    public static TiffTag EXIF_SPECTRALSENSITIVITY;
    public static TiffTag EXIF_ISOSPEEDRATINGS;
    public static TiffTag EXIF_OECF;
    public static TiffTag EXIF_EXIFVERSION;
    public static TiffTag EXIF_DATETIMEORIGINAL;
    public static TiffTag EXIF_DATETIMEDIGITIZED;
    public static TiffTag EXIF_COMPONENTSCONFIGURATION;
    public static TiffTag EXIF_COMPRESSEDBITSPERPIXEL;
    public static TiffTag EXIF_SHUTTERSPEEDVALUE;
    public static TiffTag EXIF_APERTUREVALUE;
    public static TiffTag EXIF_BRIGHTNESSVALUE;
    public static TiffTag EXIF_EXPOSUREBIASVALUE;
    public static TiffTag EXIF_MAXAPERTUREVALUE;
    public static TiffTag EXIF_SUBJECTDISTANCE;
    public static TiffTag EXIF_METERINGMODE;
    public static TiffTag EXIF_LIGHTSOURCE;
    public static TiffTag EXIF_FLASH;
    public static TiffTag EXIF_FOCALLENGTH;
    public static TiffTag EXIF_SUBJECTAREA;
    public static TiffTag EXIF_MAKERNOTE;
    public static TiffTag EXIF_USERCOMMENT;
    public static TiffTag EXIF_SUBSECTIME;
    public static TiffTag EXIF_SUBSECTIMEORIGINAL;
    public static TiffTag EXIF_SUBSECTIMEDIGITIZED;
    public static TiffTag EXIF_FLASHPIXVERSION;
    public static TiffTag EXIF_COLORSPACE;
    public static TiffTag EXIF_PIXELXDIMENSION;
    public static TiffTag EXIF_PIXELYDIMENSION;
    public static TiffTag EXIF_RELATEDSOUNDFILE;
    public static TiffTag EXIF_FLASHENERGY;
    public static TiffTag EXIF_SPATIALFREQUENCYRESPONSE;
    public static TiffTag EXIF_FOCALPLANEXRESOLUTION;
    public static TiffTag EXIF_FOCALPLANEYRESOLUTION;
    public static TiffTag EXIF_FOCALPLANERESOLUTIONUNIT;
    public static TiffTag EXIF_SUBJECTLOCATION;
    public static TiffTag EXIF_EXPOSUREINDEX;
    public static TiffTag EXIF_SENSINGMETHOD;
    public static TiffTag EXIF_FILESOURCE;
    public static TiffTag EXIF_SCENETYPE;
    public static TiffTag EXIF_CFAPATTERN;
    public static TiffTag EXIF_CUSTOMRENDERED;
    public static TiffTag EXIF_EXPOSUREMODE;
    public static TiffTag EXIF_WHITEBALANCE;
    public static TiffTag EXIF_DIGITALZOOMRATIO;
    public static TiffTag EXIF_FOCALLENGTHIN35MMFILM;
    public static TiffTag EXIF_SCENECAPTURETYPE;
    public static TiffTag EXIF_GAINCONTROL;
    public static TiffTag EXIF_CONTRAST;
    public static TiffTag EXIF_SATURATION;
    public static TiffTag EXIF_SHARPNESS;
    public static TiffTag EXIF_DEVICESETTINGDESCRIPTION;
    public static TiffTag EXIF_SUBJECTDISTANCERANGE;
    public static TiffTag EXIF_IMAGEUNIQUEID;
    public static TiffTag GEOTIFF_MODELPIXELSCALETAG;
    public static TiffTag GEOTIFF_MODELTIEPOINTTAG;
    public static TiffTag GEOTIFF_MODELTRANSFORMATIONTAG;
    public static TiffTag GEOTIFF_GEOASCIIPARAMS;
    public static TiffTag GEOKEYDIRECTORY;
}
public class ThinkGeo.Core.LibTiff.TiffTagMethods : object {
    private static short SDw=;
    private static short STw=;
    private static short Sjw=;
    private static short Szw=;
    public virtual bool SetField(Tiff tif, TiffTag tag, FieldValue[] value);
    public virtual FieldValue[] GetField(Tiff tif, TiffTag tag);
    public virtual void PrintDir(Tiff tif, Stream stream, TiffPrintFlags flags);
    private static bool TDw=(qjY= td, Int32& v, FieldValue[] ap);
    private static int TTw=(Tiff tif, int slen, string s);
    private static void Tjw=(String& cpp, string cp, int n);
}
public enum ThinkGeo.Core.LibTiff.TiffType : Enum {
    public short value__;
    public static TiffType NOTYPE;
    public static TiffType ANY;
    public static TiffType BYTE;
    public static TiffType ASCII;
    public static TiffType SHORT;
    public static TiffType LONG;
    public static TiffType RATIONAL;
    public static TiffType SBYTE;
    public static TiffType UNDEFINED;
    public static TiffType SSHORT;
    public static TiffType SLONG;
    public static TiffType SRATIONAL;
    public static TiffType FLOAT;
    public static TiffType DOUBLE;
    public static TiffType IFD;
    public static TiffType LONG8;
    public static TiffType SLONG8;
    public static TiffType IFD8;
}
public class ThinkGeo.Core.LinealKrigingGridInterpolationModel : KrigingGridInterpolationModel {
    public LinealKrigingGridInterpolationModel(IDictionary`2<PointShape, double> points);
    public LinealKrigingGridInterpolationModel(IDictionary`2<PointShape, double> points, int numberOfRefreancedPoints);
    protected virtual double GetSemivarianceCore(double distance, EmpiricalFunctionCoefficients coefficients);
    protected virtual double GetSillSlopeCore(double distance, double range);
}
public abstract class ThinkGeo.Core.LineBaseShape : BaseShape {
    public double GetLength(GeographyUnit shapeUnit, DistanceUnit returningUnit);
    protected virtual double GetLengthCore(GeographyUnit shapeUnit, DistanceUnit returningUnit);
    public static LineBaseShape ScaleUp(LineBaseShape sourceShape, double percentage);
    public static Feature ScaleUp(Feature sourceLine, double percentage);
    public void ScaleUp(double percentage);
    protected virtual void ScaleUpCore(double percentage);
    public static LineBaseShape ScaleDown(LineBaseShape sourceLineBaseShape, double percentage);
    public static Feature ScaleDown(Feature sourceLine, double percentage);
    public void ScaleDown(double percentage);
    protected virtual void ScaleDownCore(double percentage);
    public double GetLength(int shapeSrid, DistanceUnit returningUnit);
    public double GetLength(string shapeProj4ProjectionParameters, DistanceUnit returningUnit);
    public double GetLength(Projection shapeProjection, DistanceUnit returningUnit);
    public double GetLength(int shapeSrid, DistanceUnit returningUnit, DistanceCalculationMode distanceCalculationMode);
    public double GetLength(string shapeProj4ProjectionParameters, DistanceUnit returningUnit, DistanceCalculationMode distanceCalculationMode);
    public double GetLength(Projection shapeProjection, DistanceUnit returningUnit, DistanceCalculationMode distanceCalculationMode);
    protected virtual double GetLengthCore(Projection shapeProjection, DistanceUnit returningUnit, DistanceCalculationMode distanceCalculationMode);
    public RingShape ConvexHull();
    protected virtual RingShape ConvexHullCore();
    private void TRU=(double factor);
    public static MultilineShape Simplify(LineBaseShape targetShape, GeographyUnit targetShapeUnit, double tolerance, DistanceUnit toleranceUnit, SimplificationType simplificationType);
    public static MultilineShape Simplify(LineBaseShape targetShape, double tolerance, SimplificationType simplificationType);
    public MultilineShape Simplify(GeographyUnit shapeUnit, double tolerance, DistanceUnit toleranceUnit, SimplificationType simplificationType);
    public MultilineShape Simplify(double tolerance, SimplificationType simplificationType);
    protected virtual MultilineShape SimplifyCore(double tolerance, SimplificationType simplificationType);
    public MultilineShape Union(LineBaseShape targetShape);
    public static MultilineShape Union(IEnumerable`1<LineBaseShape> lineBaseShapes);
    public MultilineShape Union(Feature targetFeature);
    public static MultilineShape Union(IEnumerable`1<Feature> targetFeatures);
    protected virtual MultilineShape UnionCore(IEnumerable`1<LineBaseShape> lineBaseShapes);
    private BaseShape 0Ro=(IEnumerable`1<LineBaseShape> lineBaseShapes, int count);
    public MultilineShape GetIntersection(Feature targetFeature);
    public MultilineShape GetIntersection(AreaBaseShape targetShape);
    protected virtual MultilineShape GetIntersectionCore(AreaBaseShape targetShape);
    internal static bool 4Ro=(Vertex vertex1, Vertex vertex2, PointShape point);
    public static Collection`1<LineShape> Snap(IEnumerable`1<LineBaseShape> shapes, GeographyUnit shapeUnit, double snappingTolerance, DistanceUnit toleranceUnit);
    private static Collection`1<LineShape> 4ho=(IEnumerable`1<LineBaseShape> lineBaseShapes);
    private static bool 4xo=(IEnumerable`1<LineShape> lineShapes, double tolerance);
    private static void 5Bo=(Collection`1<LineShape> lineshapes);
    private static Collection`1<LineShape> 5Ro=(IEnumerable`1<LineShape> intersectingLines);
    private static bool 5ho=(Collection`1<LineShape> lineShapes, double tolerance);
    private static void 5xo=(Collection`1<KeyValuePair`2<LineShape, int>> linesCache, Vertex newVertex);
    private static bool 6Bo=(Vertex currentVertex, LineShape currentLineShape, int currentVertexIndex, LineShape closestLineShape, PointShape closestPoint);
    private static bool 6Ro=(LineShape lineShape, LineShape intersectingLine);
}
public enum ThinkGeo.Core.LineDashStyle : Enum {
    public int value__;
    public static LineDashStyle Solid;
    public static LineDashStyle Custom;
    public static LineDashStyle DashDot;
    public static LineDashStyle DashDotDot;
    public static LineDashStyle Dot;
    public static LineDashStyle Dash;
}
[TypeConverterAttribute("ThinkGeo.Core.BaseShapeTypeConverter")]
public class ThinkGeo.Core.LineShape : LineBaseShape {
    [ObfuscationAttribute]
private Collection`1<Vertex> vertices;
    public Collection`1<Vertex> Vertices { get; }
    public LineShape(IEnumerable`1<Vertex> points);
    public LineShape(string wellKnownText);
    public LineShape(Byte[] wellKnownBinary);
    public Collection`1<Vertex> get_Vertices();
    public void ReversePoints();
    protected virtual void ReversePointsCore();
    protected virtual BaseShape CloneDeepCore();
    public bool IsClosed();
    protected virtual bool IsClosedCore();
    protected virtual double GetLengthCore(GeographyUnit shapeUnit, DistanceUnit returningUnit);
    public PointShape GetPointOnALine(StartingPoint startingPoint, float percentageOfLine);
    public PointShape GetPointOnALine(StartingPoint startingPoint, double distance, GeographyUnit shapeUnit, DistanceUnit distanceUnit);
    protected virtual PointShape GetPointOnALineCore(StartingPoint startingPoint, double distance, GeographyUnit shapeUnit, DistanceUnit distanceUnit);
    public LineBaseShape GetLineOnALine(StartingPoint startingPoint, float startingPercentageOfTheLine, float percentageOfTheLine);
    public LineBaseShape GetLineOnALine(StartingPoint startingPoint, float percentageOfLine);
    public LineBaseShape GetLineOnALine(StartingPoint startingPoint, double startingDistance, double distance, GeographyUnit shapeUnit, DistanceUnit distanceUnit);
    protected virtual LineBaseShape GetLineOnALineCore(StartingPoint startingPoint, double startingDistance, double distance, GeographyUnit shapeUnit, DistanceUnit distanceUnit);
    public LineBaseShape GetLineOnALine(StartingPoint startingPoint, PointShape endPointShape);
    public LineBaseShape GetLineOnALine(PointShape startPointShape, PointShape endPointShape);
    public double GetSublinePercentage(PointShape sublineEndpoint, double tolerance);
    protected virtual double GetSublinePercentageCore(PointShape sublineEndpoint, double tolerance);
    public PointLineRelationship GetPointPosition(PointShape pointShape, double tolerance);
    protected virtual PointLineRelationship GetPointPositionCore(PointShape pointShape, double tolerance);
    private LineShape TBw=(PointShape startPointShape, PointShape endPointShape);
    private double TRw=(PointShape pointShape);
    protected virtual double GetDistanceToCore(BaseShape targetShape, GeographyUnit shapeUnit, DistanceUnit distanceUnit);
    protected virtual void ScaleUpCore(double percentage);
    protected virtual void ScaleDownCore(double percentage);
    protected virtual BaseShape RegisterCore(PointShape fromPoint, PointShape toPoint, DistanceUnit fromUnit, GeographyUnit toUnit);
    protected virtual void TranslateByOffsetCore(double xOffsetDistance, double yOffsetDistance, GeographyUnit shapeUnit, DistanceUnit distanceUnit);
    protected virtual void TranslateByDegreeCore(double distance, double angleInDegrees, GeographyUnit shapeUnit, DistanceUnit distanceUnit);
    protected virtual void RotateCore(PointShape pivotPoint, double degreeAngle);
    protected virtual RectangleShape GetBoundingBoxCore();
    protected virtual PointShape GetClosestPointToCore(BaseShape targetShape, GeographyUnit shapeUnit);
    protected virtual string GetWellKnownTextCore(RingOrder outerRingOrder);
    protected virtual WellKnownType GetWellKnownTypeCore();
    protected virtual PointShape GetCenterPointCore();
    protected virtual void LoadFromWellKnownDataCore(string wellKnownText);
    protected virtual void LoadFromWellKnownDataCore(Byte[] wellKnownBinary);
    private static void Thw=(LineShape fromLine, LineShape toLine);
    protected virtual ShapeValidationResult ValidateCore(ShapeValidationMode validationMode);
    protected virtual MultipointShape GetCrossingCore(BaseShape targetShape);
    public static bool RemoveVertex(Vertex selectedVertex, LineShape lineShape);
    public bool RemoveVertex(Vertex selectedVertex);
    public PolygonShape ToPolygonShape();
    private MultipointShape Txw=(BaseShape targetShape);
    private MultipointShape UBw=(BaseShape targetShape);
    private MultipointShape URw=(BaseShape targetShape);
    private static void Uhw=(Geometry result, MultipointShape resultMultiPointShape);
    internal void TRU=(double factor);
    private void Uxw=(EllipseShape ellipse, GeographyUnit shapeUnit, DistanceUnit distanceUnit, PointShape& closestPointShape, Double& minDistance);
    private void VBw=(PolygonShape polygonShape, GeographyUnit shapeUnit, DistanceUnit distanceUnit, PointShape& closestPointShape, Double& minDistance);
    private void VRw=(MultipolygonShape multiPolygonShape, GeographyUnit shapeUnit, DistanceUnit distanceUnit, PointShape& closestPointShape, Double& minDistance);
    private void LRw=(PointShape pointShape, GeographyUnit shapeUnit, DistanceUnit distanceUnit, PointShape& closestPointShape, Double& minDistance);
    private void Vhw=(MultipointShape multiPointShape, GeographyUnit shapeUnit, DistanceUnit distanceUnit, PointShape& closestPointShape, Double& minDistance);
    private void Vxw=(LineShape lineShape, GeographyUnit shapeUnit, DistanceUnit distanceUnit, PointShape& closestPointShape, Double& minDistance);
    private void WBw=(MultilineShape multilineShape, GeographyUnit shapeUnit, DistanceUnit distanceUnit, PointShape& closestPointShape, Double& minDistance);
    private static RectangleShape WRw=(IEnumerable`1<Vertex> vertices);
    private PointShape Whw=(double distance);
    private PointShape Wxw=(double distance, DistanceUnit distanceUnit);
}
public class ThinkGeo.Core.LineStyle : Style {
    [ObfuscationAttribute]
private GeoPen centerPen;
    [ObfuscationAttribute]
private Collection`1<LineStyle> customLineStyles;
    [ObfuscationAttribute]
private GeoPen innerPen;
    [ObfuscationAttribute]
private GeoPen outerPen;
    [ObfuscationAttribute]
private float xOffsetInPixel;
    [ObfuscationAttribute]
private float yOffsetInPixel;
    [ObfuscationAttribute]
private DrawingLevel outerPenDrawingLevel;
    [ObfuscationAttribute]
private DrawingLevel innerPenDrawingLevel;
    [ObfuscationAttribute]
private DrawingLevel centerPenDrawingLevel;
    [ObfuscationAttribute]
private PointStyle directionPointStyle;
    [ObfuscationAttribute]
private double directionPointInterval;
    [ObfuscationAttribute]
private double directionPointMinimumInterval;
    [CompilerGeneratedAttribute]
private EventHandler`1<DrawingDirectionPointEventArgs> HjE=;
    public float XOffsetInPixel { get; public set; }
    public float YOffsetInPixel { get; public set; }
    public Collection`1<LineStyle> CustomLineStyles { get; }
    public GeoPen OuterPen { get; public set; }
    public GeoPen InnerPen { get; public set; }
    public GeoPen CenterPen { get; public set; }
    public DrawingLevel OuterPenDrawingLevel { get; public set; }
    public DrawingLevel InnerPenDrawingLevel { get; public set; }
    public DrawingLevel CenterPenDrawingLevel { get; public set; }
    internal bool phU= { get; }
    public PointStyle DirectionPointStyle { get; public set; }
    public double DirectionPointInterval { get; public set; }
    public double DirectionPointMinimumInterval { get; public set; }
    public LineStyle(GeoPen outerPen);
    public LineStyle(GeoPen outerPen, GeoPen innerPen);
    public LineStyle(GeoPen outerPen, GeoPen innerPen, GeoPen centerPen);
    [CompilerGeneratedAttribute]
public void add_DrawingDirectionPoint(EventHandler`1<DrawingDirectionPointEventArgs> value);
    [CompilerGeneratedAttribute]
public void remove_DrawingDirectionPoint(EventHandler`1<DrawingDirectionPointEventArgs> value);
    public float get_XOffsetInPixel();
    public void set_XOffsetInPixel(float value);
    public float get_YOffsetInPixel();
    public void set_YOffsetInPixel(float value);
    public Collection`1<LineStyle> get_CustomLineStyles();
    public GeoPen get_OuterPen();
    public void set_OuterPen(GeoPen value);
    public GeoPen get_InnerPen();
    public void set_InnerPen(GeoPen value);
    public GeoPen get_CenterPen();
    public void set_CenterPen(GeoPen value);
    public DrawingLevel get_OuterPenDrawingLevel();
    public void set_OuterPenDrawingLevel(DrawingLevel value);
    public DrawingLevel get_InnerPenDrawingLevel();
    public void set_InnerPenDrawingLevel(DrawingLevel value);
    public DrawingLevel get_CenterPenDrawingLevel();
    public void set_CenterPenDrawingLevel(DrawingLevel value);
    internal virtual bool pBU=();
    public PointStyle get_DirectionPointStyle();
    public void set_DirectionPointStyle(PointStyle value);
    public double get_DirectionPointInterval();
    public void set_DirectionPointInterval(double value);
    public double get_DirectionPointMinimumInterval();
    public void set_DirectionPointMinimumInterval(double value);
    public static LineStyle Parse(string styleJson);
    internal static LineStyle kxU=(JObject jObject);
    public static LineStyle CreateSimpleLineStyle(GeoColor centerlineColor, float centerlineWidth, bool roundCap);
    public static LineStyle CreateSimpleLineStyle(GeoColor centerlineColor, float centerlineWidth, LineDashStyle centerlineDashStyle, bool roundCap);
    public static LineStyle CreateSimpleLineStyle(GeoColor innerLineColor, float innerLineWidth, GeoColor outerLineColor, float outerLineWidth, bool roundCap);
    public static LineStyle CreateSimpleLineStyle(GeoColor innerLineColor, float innerLineWidth, LineDashStyle innerLineDashStyle, GeoColor outerLineColor, float outerLineWidth, LineDashStyle outerLineDashStyle, bool roundCap);
    public static LineStyle CreateSimpleLineStyle(GeoColor centerlineColor, float centerlineWidth, GeoColor innerLineColor, float innerLineWidth, GeoColor outerLineColor, float outerLineWidth, bool roundCap);
    public static LineStyle CreateSimpleLineStyle(GeoColor centerlineColor, float centerlineWidth, LineDashStyle centerlineDashStyle, GeoColor innerLineColor, float innerLineWidth, LineDashStyle innerLineDashStyle, GeoColor outerLineColor, float outerLineWidth, LineDashStyle outerLineDashStyle, bool roundCap);
    private static LineStyle HzE=(GeoColor innerPenColor, float innerPenWidth, GeoColor outerPenColor, float outerPenWidth, GeoColor centerPenColor, float centerPenWidth, Collection`1<float> dashPattern);
    protected virtual void DrawCore(IEnumerable`1<Feature> features, GeoCanvas canvas, Collection`1<SimpleCandidate> labelsInThisLayer, Collection`1<SimpleCandidate> labelsInAllLayers);
    private void IDE=(GeoCanvas canvas, Collection`1<SimpleCandidate> labelsInThisLayer, Collection`1<SimpleCandidate> labelsInAllLayers, IEnumerable`1<Feature> featuresList);
    private void ITE=(Feature item, GeoCanvas canvas);
    private void IjE=(GeoCanvas canvas, LineShape lineShape, Feature item);
    protected virtual void OnDrawingDirectionPoint(DrawingDirectionPointEventArgs drawingDirectionPointEventArgs);
    private float IzE=(Vertex v1, Vertex v2);
    protected virtual void DrawSampleCore(GeoCanvas canvas, DrawingRectangleF drawingExtent);
    private static LineShape JDE=(RectangleShape rectangle);
    private static List`1<Feature> AzE=(RectangleShape currentExtent, IEnumerable`1<Feature> featureList);
    private static MultilineShape JTE=(LineShape line, RectangleShape rectangle);
    private static MultilineShape JjE=(MultilineShape multiline, RectangleShape rectangle);
    private static LineShape JzE=(Vertex startPoint, Vertex endPoint, RectangleShape rectangle);
    private static Vertex KDE=(Vertex startPoint, Vertex endPoint, RectangleShape rectangle);
    private static bool KTE=(double value, double start, double end);
    internal static GeoPen KjE=(String[] valueExpressions);
    private static PointStyle KzE=(String[] valueExpressions);
}
[ObfuscationAttribute]
public class ThinkGeo.Core.LocationPoint : object {
    [CompilerGeneratedAttribute]
private double <PointX>k__BackingField;
    [CompilerGeneratedAttribute]
private double <PointY>k__BackingField;
    public double PointX { get; public set; }
    public double PointY { get; public set; }
    [CompilerGeneratedAttribute]
public double get_PointX();
    [CompilerGeneratedAttribute]
public void set_PointX(double value);
    [CompilerGeneratedAttribute]
public double get_PointY();
    [CompilerGeneratedAttribute]
public void set_PointY(double value);
}
public class ThinkGeo.Core.LogoAdornmentLayer : AdornmentLayer {
    [ObfuscationAttribute]
private GeoImage image;
    public GeoImage Image { get; public set; }
    public LogoAdornmentLayer(GeoImage image);
    public GeoImage get_Image();
    public void set_Image(GeoImage value);
    protected virtual void DrawCore(GeoCanvas canvas, Collection`1<SimpleCandidate> labelsInAllLayers);
}
public class ThinkGeo.Core.MagneticDeclination : object {
    [ObfuscationAttribute]
private double magneticNorthInDegree;
    [ObfuscationAttribute]
private double gridNorthInDegree;
    [ObfuscationAttribute]
private string changedByYear;
    [ObfuscationAttribute]
private double centralMeridian;
    [ObfuscationAttribute]
private string zone;
    public double MagneticNorthInDegree { get; public set; }
    public double GridNorthInDegree { get; public set; }
    public string ChangedByYear { get; public set; }
    public double CentralMeridian { get; public set; }
    public string Zone { get; public set; }
    public MagneticDeclination(double magneticNorthInDegree, double gridNorthInDegree, string changedByYear, double centralMeridian, string zone);
    public double get_MagneticNorthInDegree();
    public void set_MagneticNorthInDegree(double value);
    public double get_GridNorthInDegree();
    public void set_GridNorthInDegree(double value);
    public string get_ChangedByYear();
    public void set_ChangedByYear(string value);
    public double get_CentralMeridian();
    public void set_CentralMeridian(double value);
    public string get_Zone();
    public void set_Zone(string value);
}
public class ThinkGeo.Core.MagneticDeclinationAdornmentLayer : AdornmentLayer {
    private static int 9SA=;
    private static int 9iA=;
    private static float 9yA=;
    private static double /CA=;
    private static double /SA=;
    private static double /iA=;
    private static double /yA=;
    [ObfuscationAttribute]
private TextStyle textStyle;
    [ObfuscationAttribute]
private LineStyle trueNorthLineStyle;
    [ObfuscationAttribute]
private LineStyle magneticNorthLineStyle;
    [ObfuscationAttribute]
private LineStyle gridNorthLineStyle;
    [ObfuscationAttribute]
private PointStyle trueNorthPointStyle;
    [ObfuscationAttribute]
private DistanceUnit elevationUnit;
    [ObfuscationAttribute]
private double elevation;
    [ObfuscationAttribute]
private DateTime sampleDateTime;
    [ObfuscationAttribute]
private string magneticFieldPathFilename;
    [ObfuscationAttribute]
private ProjectionConverter projectionToDecimalDegrees;
    [ObfuscationAttribute]
private PointShape canvasCenterPoint;
    [ObfuscationAttribute]
private int gridNorthTextLocationXoffset;
    [ObfuscationAttribute]
private int gridNorthDegreeLocationXoffset;
    [ObfuscationAttribute]
private int magneticNorthTextLocationYoffset;
    [ObfuscationAttribute]
private int gridNorthTextXOffsetInPixel;
    [ObfuscationAttribute]
private int degreeMinutesSecondsXOffsetInPixel;
    [ObfuscationAttribute]
private Stream magneticFieldFileStream;
    [CompilerGeneratedAttribute]
private EventHandler`1<StreamLoadingEventArgs> Eh8=;
    public LineStyle GridNorthLineStyle { get; public set; }
    public LineStyle TrueNorthLineStyle { get; public set; }
    public LineStyle MagneticNorthLineStyle { get; public set; }
    public TextStyle TextStyle { get; public set; }
    public PointStyle TrueNorthPointStyle { get; public set; }
    public DistanceUnit ElevationUnit { get; public set; }
    public string MagneticFieldPathFilename { get; }
    public double Elevation { get; public set; }
    public DateTime SampleDateTime { get; public set; }
    public MagneticDeclinationAdornmentLayer(ScreenPointF startPoint);
    public MagneticDeclinationAdornmentLayer(AdornmentLocation adornmentLocation);
    public MagneticDeclinationAdornmentLayer(string magneticFieldPathFilename, AdornmentLocation adornmentLocation);
    [CompilerGeneratedAttribute]
public void add_StreamLoading(EventHandler`1<StreamLoadingEventArgs> value);
    [CompilerGeneratedAttribute]
public void remove_StreamLoading(EventHandler`1<StreamLoadingEventArgs> value);
    public LineStyle get_GridNorthLineStyle();
    public void set_GridNorthLineStyle(LineStyle value);
    public LineStyle get_TrueNorthLineStyle();
    public void set_TrueNorthLineStyle(LineStyle value);
    public LineStyle get_MagneticNorthLineStyle();
    public void set_MagneticNorthLineStyle(LineStyle value);
    public TextStyle get_TextStyle();
    public void set_TextStyle(TextStyle value);
    public PointStyle get_TrueNorthPointStyle();
    public void set_TrueNorthPointStyle(PointStyle value);
    public DistanceUnit get_ElevationUnit();
    public void set_ElevationUnit(DistanceUnit value);
    public string get_MagneticFieldPathFilename();
    public double get_Elevation();
    public void set_Elevation(double value);
    public DateTime get_SampleDateTime();
    public void set_SampleDateTime(DateTime value);
    protected virtual void OnStreamLoading(StreamLoadingEventArgs e);
    public virtual ScreenPointF GetDrawingLocation(GeoCanvas canvas, float adornmentWidth, float adornmentHeight);
    public static MagneticDeclination GetMagneticDeclination(Feature pointFeature, double elevation, DistanceUnit elevationUnit, DateTime sampleDateTime);
    public static MagneticDeclination GetMagneticDeclination(Feature pointFeature, double elevation, DistanceUnit elevationUnit, DateTime sampleDateTime, string magneticFieldPathFilename);
    public static MagneticDeclination GetMagneticDeclination(Feature pointFeature, double elevation, DistanceUnit elevationUnit, DateTime sampleDateTime, Stream magneticFieldStream);
    public static MagneticDeclination GetMagneticDeclination(PointShape point, double elevation, DistanceUnit elevationUnit, DateTime sampleDateTime);
    public static MagneticDeclination GetMagneticDeclination(PointShape point, double elevation, DistanceUnit elevationUnit, DateTime sampleDateTime, string magneticFieldPathFilename);
    public static MagneticDeclination GetMagneticDeclination(PointShape point, double elevation, DistanceUnit elevationUnit, DateTime sampleDateTime, Stream magneticFieldStream);
    public static MagneticDeclination GetMagneticDeclination(double x, double y, double elevation, DistanceUnit elevationUnit, DateTime sampleDateTime);
    public static MagneticDeclination GetMagneticDeclination(double x, double y, double elevation, DistanceUnit elevationUnit, DateTime sampleDateTime, string magneticFieldPathFilename);
    public static MagneticDeclination GetMagneticDeclination(double x, double y, double elevation, DistanceUnit elevationUnit, DateTime sampleDateTime, Stream magneticFieldStream);
    protected virtual void OpenCore();
    protected virtual void CloseCore();
    protected virtual void DrawCore(GeoCanvas canvas, Collection`1<SimpleCandidate> labelsInAllLayers);
    private void ACE=(ScreenPointF startPoint, double length, GeoCanvas canvas);
    private void ASE=(ScreenPointF gridNorthLineStartPoint, double length, double offsetInDegree, GeoCanvas canvas);
    private void AiE=(ScreenPointF magneticNorthLineStartPoint, double length, double offsetInDegree, GeoCanvas canvas);
    private static double AyE=(string zoneString, int zoneNum);
    private static string BCE=(PointShape centerPoint, Int32& zoneNum);
    private static double xyA=(PointShape centerPoint, double centralMeridian);
    private static int BSE=(object Test);
    private static int BiE=(double degree);
    private static double ByE=(double offTrueNorth);
    private static ScreenPointF CCE=(double lineGradient, double lineIntercept, double centerPointX, double centerPointY, double length, bool iswest);
    private static double CSE=(double degree);
}
public class ThinkGeo.Core.MagneticNorthLineStyle : LineStyle {
    protected virtual void DrawCore(IEnumerable`1<Feature> features, GeoCanvas canvas, Collection`1<SimpleCandidate> labelsInThisLayer, Collection`1<SimpleCandidate> labelsInAllLayers);
    private static double CSE=(double degree);
    private static double ByE=(double offTrueNorth);
    private static ScreenPointF CCE=(double lineK, double lineB, double centerPointX, double centerPointY, double length, bool iswest);
}
public class ThinkGeo.Core.MapArguments : object {
    [ObfuscationAttribute]
private Collection`1<double> zoomLevelScales;
    [ObfuscationAttribute]
private Dictionary`2<string, object> customData;
    [CompilerGeneratedAttribute]
private GeographyUnit cB0=;
    [CompilerGeneratedAttribute]
private double cR0=;
    [CompilerGeneratedAttribute]
private double ch0=;
    [CompilerGeneratedAttribute]
private double cx0=;
    [CompilerGeneratedAttribute]
private double dB0=;
    [CompilerGeneratedAttribute]
private double dR0=;
    [CompilerGeneratedAttribute]
private ZoomLevelSet dh0=;
    [CompilerGeneratedAttribute]
private ScreenPointF dx0=;
    [CompilerGeneratedAttribute]
private PointShape eB0=;
    [CompilerGeneratedAttribute]
private double eR0=;
    [CompilerGeneratedAttribute]
private double eh0=;
    [CompilerGeneratedAttribute]
private double ex0=;
    [CompilerGeneratedAttribute]
private double fB0=;
    [CompilerGeneratedAttribute]
private RectangleShape fR0=;
    [CompilerGeneratedAttribute]
private PointShape fh0=;
    [CompilerGeneratedAttribute]
private RectangleShape fx0=;
    [CompilerGeneratedAttribute]
private float gB0=;
    [CompilerGeneratedAttribute]
private ZoomLevelSnappingMode gR0=;
    [CompilerGeneratedAttribute]
private bool gh0=;
    public GeographyUnit MapUnit { get; public set; }
    public double ScreenWidth { get; public set; }
    public double ScreenHeight { get; public set; }
    public double MapWidth { get; public set; }
    public double MapHeight { get; public set; }
    public double RotationAngle { get; public set; }
    public ZoomLevelSet ZoomLevelSet { get; public set; }
    public Dictionary`2<string, object> CustomData { get; }
    public ScreenPointF PivotScreenPoint { get; public set; }
    public PointShape PivotWorldPoint { get; public set; }
    public Collection`1<double> ZoomLevelScales { get; }
    public double CurrentResolution { get; public set; }
    public double CurrentScale { get; public set; }
    public double MaximumScale { get; public set; }
    public double MinimumScale { get; public set; }
    public RectangleShape CurrentExtent { get; public set; }
    public PointShape CenterPoint { get; public set; }
    public RectangleShape MaxExtent { get; public set; }
    public float ScaleFactor { get; public set; }
    public ZoomLevelSnappingMode ZoomLevelSnappingMode { get; public set; }
    public bool RotationEnabled { get; public set; }
    public MapArguments(RectangleShape currentExtent, GeographyUnit mapUnit, float screenWidth, float screenHeight);
    [CompilerGeneratedAttribute]
public GeographyUnit get_MapUnit();
    [CompilerGeneratedAttribute]
public void set_MapUnit(GeographyUnit value);
    [CompilerGeneratedAttribute]
public double get_ScreenWidth();
    [CompilerGeneratedAttribute]
public void set_ScreenWidth(double value);
    [CompilerGeneratedAttribute]
public double get_ScreenHeight();
    [CompilerGeneratedAttribute]
public void set_ScreenHeight(double value);
    [CompilerGeneratedAttribute]
public double get_MapWidth();
    [CompilerGeneratedAttribute]
public void set_MapWidth(double value);
    [CompilerGeneratedAttribute]
public double get_MapHeight();
    [CompilerGeneratedAttribute]
public void set_MapHeight(double value);
    [CompilerGeneratedAttribute]
public double get_RotationAngle();
    [CompilerGeneratedAttribute]
public void set_RotationAngle(double value);
    [CompilerGeneratedAttribute]
public ZoomLevelSet get_ZoomLevelSet();
    [CompilerGeneratedAttribute]
public void set_ZoomLevelSet(ZoomLevelSet value);
    public Dictionary`2<string, object> get_CustomData();
    [CompilerGeneratedAttribute]
public ScreenPointF get_PivotScreenPoint();
    [CompilerGeneratedAttribute]
public void set_PivotScreenPoint(ScreenPointF value);
    [CompilerGeneratedAttribute]
public PointShape get_PivotWorldPoint();
    [CompilerGeneratedAttribute]
public void set_PivotWorldPoint(PointShape value);
    public Collection`1<double> get_ZoomLevelScales();
    [CompilerGeneratedAttribute]
public double get_CurrentResolution();
    [CompilerGeneratedAttribute]
public void set_CurrentResolution(double value);
    [CompilerGeneratedAttribute]
public double get_CurrentScale();
    [CompilerGeneratedAttribute]
public void set_CurrentScale(double value);
    [CompilerGeneratedAttribute]
public double get_MaximumScale();
    [CompilerGeneratedAttribute]
public void set_MaximumScale(double value);
    [CompilerGeneratedAttribute]
public double get_MinimumScale();
    [CompilerGeneratedAttribute]
public void set_MinimumScale(double value);
    [CompilerGeneratedAttribute]
public RectangleShape get_CurrentExtent();
    [CompilerGeneratedAttribute]
public void set_CurrentExtent(RectangleShape value);
    [CompilerGeneratedAttribute]
public PointShape get_CenterPoint();
    [CompilerGeneratedAttribute]
public void set_CenterPoint(PointShape value);
    [CompilerGeneratedAttribute]
public RectangleShape get_MaxExtent();
    [CompilerGeneratedAttribute]
public void set_MaxExtent(RectangleShape value);
    [CompilerGeneratedAttribute]
public float get_ScaleFactor();
    [CompilerGeneratedAttribute]
public void set_ScaleFactor(float value);
    [CompilerGeneratedAttribute]
public ZoomLevelSnappingMode get_ZoomLevelSnappingMode();
    [CompilerGeneratedAttribute]
public void set_ZoomLevelSnappingMode(ZoomLevelSnappingMode value);
    [CompilerGeneratedAttribute]
public bool get_RotationEnabled();
    [CompilerGeneratedAttribute]
public void set_RotationEnabled(bool value);
    public PointShape ToWorldCoordinate(ScreenPointF screenCoordinate);
    public int GetSnappedZoomLevelIndex(RectangleShape extent);
    public int GetSnappedZoomLevelIndex(double scale);
    public RectangleShape GetSnappedExtent(RectangleShape extent, ZoomSnapDirection zoomSnapDirection);
}
public class ThinkGeo.Core.MapBoxStaticTilesAsyncLayer : XyzTileAsyncLayer {
    private static int /B0=;
    [ObfuscationAttribute]
private MapBoxStyleId styleId;
    [ObfuscationAttribute]
private string baseUrl;
    [ObfuscationAttribute]
private string apiVersion;
    [CompilerGeneratedAttribute]
private string OR4=;
    public string AccessToken { get; public set; }
    public MapBoxStyleId StyleId { get; public set; }
    public MapBoxStaticTilesAsyncLayer(string accessToken);
    public MapBoxStaticTilesAsyncLayer(string accessToken, MapBoxStyleId styleId);
    [CompilerGeneratedAttribute]
public string get_AccessToken();
    [CompilerGeneratedAttribute]
public void set_AccessToken(string value);
    public MapBoxStyleId get_StyleId();
    public void set_StyleId(MapBoxStyleId value);
    protected virtual Task`1<string> GetImageUriAsyncCore(int zoomLevel, long x, long y, float resolutionFactor);
    private string Oh4=();
    private void Ox4=(MapBoxStyleId id);
    private bool PB4=(string cacheId);
    private string PR4=(MapBoxStyleId id);
}
public enum ThinkGeo.Core.MapBoxStyleId : Enum {
    public int value__;
    public static MapBoxStyleId Streets;
    public static MapBoxStyleId Outdoors;
    public static MapBoxStyleId Light;
    public static MapBoxStyleId Dark;
    public static MapBoxStyleId Satellite;
    public static MapBoxStyleId SatelliteStreets;
}
public class ThinkGeo.Core.MapBoxZoomLevelSet : ZoomLevelSet {
    public MapBoxZoomLevelSet(int tileSize);
    public MapBoxZoomLevelSet(int tileSize, RectangleShape maxExtent);
}
public enum ThinkGeo.Core.MapDoubleTapMode : Enum {
    public int value__;
    public static MapDoubleTapMode Default;
    public static MapDoubleTapMode ZoomIn;
    public static MapDoubleTapMode Disabled;
}
public class ThinkGeo.Core.MapEngine : object {
    [ObfuscationAttribute]
private bool showLogo;
    [ObfuscationAttribute]
private RectangleShape currentExtent;
    [ObfuscationAttribute]
private GeoBrush backgroundFillBrush;
    [ObfuscationAttribute]
private GeoCanvas canvas;
    [ObfuscationAttribute]
private Collection`1<SimpleCandidate> labeledFeaturesInLayers;
    [ObfuscationAttribute]
private GeoCollection`1<Layer> staticLayers;
    [ObfuscationAttribute]
private GeoCollection`1<Layer> dynamicLayers;
    [ObfuscationAttribute]
private GeoCollection`1<AdornmentLayer> adornmentLayers;
    [CompilerGeneratedAttribute]
private EventHandler`1<LayersDrawingEventArgs> whU=;
    [CompilerGeneratedAttribute]
private EventHandler`1<LayersDrawnEventArgs> wxU=;
    [CompilerGeneratedAttribute]
private EventHandler`1<LayerDrawingEventArgs> xBU=;
    [CompilerGeneratedAttribute]
private EventHandler`1<LayerDrawnEventArgs> xRU=;
    [CompilerGeneratedAttribute]
private EventHandler`1<DrawingAdornmentLayersEventArgs> xhU=;
    [CompilerGeneratedAttribute]
private EventHandler`1<DrawnAdornmentLayersEventArgs> xxU=;
    [CompilerGeneratedAttribute]
private EventHandler`1<DrawingAdornmentLayerEventArgs> yBU=;
    [CompilerGeneratedAttribute]
private EventHandler`1<DrawnAdornmentLayerEventArgs> yRU=;
    public GeoCanvas Canvas { get; public set; }
    public bool ShowLogo { get; public set; }
    public GeoCollection`1<AdornmentLayer> AdornmentLayers { get; }
    public RectangleShape CurrentExtent { get; public set; }
    public GeoCollection`1<Layer> StaticLayers { get; }
    public GeoCollection`1<Layer> DynamicLayers { get; }
    public GeoBrush BackgroundFillBrush { get; public set; }
    [CompilerGeneratedAttribute]
public void add_LayersDrawing(EventHandler`1<LayersDrawingEventArgs> value);
    [CompilerGeneratedAttribute]
public void remove_LayersDrawing(EventHandler`1<LayersDrawingEventArgs> value);
    [CompilerGeneratedAttribute]
public void add_LayersDrawn(EventHandler`1<LayersDrawnEventArgs> value);
    [CompilerGeneratedAttribute]
public void remove_LayersDrawn(EventHandler`1<LayersDrawnEventArgs> value);
    [CompilerGeneratedAttribute]
public void add_LayerDrawing(EventHandler`1<LayerDrawingEventArgs> value);
    [CompilerGeneratedAttribute]
public void remove_LayerDrawing(EventHandler`1<LayerDrawingEventArgs> value);
    [CompilerGeneratedAttribute]
public void add_LayerDrawn(EventHandler`1<LayerDrawnEventArgs> value);
    [CompilerGeneratedAttribute]
public void remove_LayerDrawn(EventHandler`1<LayerDrawnEventArgs> value);
    [CompilerGeneratedAttribute]
public void add_AdornmentLayersDrawing(EventHandler`1<DrawingAdornmentLayersEventArgs> value);
    [CompilerGeneratedAttribute]
public void remove_AdornmentLayersDrawing(EventHandler`1<DrawingAdornmentLayersEventArgs> value);
    [CompilerGeneratedAttribute]
public void add_AdornmentLayersDrawn(EventHandler`1<DrawnAdornmentLayersEventArgs> value);
    [CompilerGeneratedAttribute]
public void remove_AdornmentLayersDrawn(EventHandler`1<DrawnAdornmentLayersEventArgs> value);
    [CompilerGeneratedAttribute]
public void add_AdornmentLayerDrawing(EventHandler`1<DrawingAdornmentLayerEventArgs> value);
    [CompilerGeneratedAttribute]
public void remove_AdornmentLayerDrawing(EventHandler`1<DrawingAdornmentLayerEventArgs> value);
    [CompilerGeneratedAttribute]
public void add_AdornmentLayerDrawn(EventHandler`1<DrawnAdornmentLayerEventArgs> value);
    [CompilerGeneratedAttribute]
public void remove_AdornmentLayerDrawn(EventHandler`1<DrawnAdornmentLayerEventArgs> value);
    protected virtual void OnAdornmentLayersDrawing(DrawingAdornmentLayersEventArgs e);
    protected virtual void OnAdornmentLayersDrawn(DrawnAdornmentLayersEventArgs e);
    protected virtual void OnAdornmentLayerDrawing(DrawingAdornmentLayerEventArgs e);
    protected virtual void OnAdornmentLayerDrawn(DrawnAdornmentLayerEventArgs e);
    protected virtual void OnLayersDrawing(LayersDrawingEventArgs e);
    protected virtual void OnLayersDrawn(LayersDrawnEventArgs e);
    protected virtual void OnLayerDrawing(LayerDrawingEventArgs e);
    protected virtual void OnLayerDrawn(LayerDrawnEventArgs e);
    public GeoCanvas get_Canvas();
    public void set_Canvas(GeoCanvas value);
    public bool get_ShowLogo();
    public void set_ShowLogo(bool value);
    public GeoCollection`1<AdornmentLayer> get_AdornmentLayers();
    public RectangleShape get_CurrentExtent();
    public void set_CurrentExtent(RectangleShape value);
    public GeoCollection`1<Layer> get_StaticLayers();
    public GeoCollection`1<Layer> get_DynamicLayers();
    public GeoBrush get_BackgroundFillBrush();
    public void set_BackgroundFillBrush(GeoBrush value);
    public FeatureLayer FindStaticFeatureLayer(string name);
    public RasterLayer FindStaticRasterLayer(string name);
    public FeatureLayer FindDynamicFeatureLayer(string name);
    public RasterLayer FindDynamicRasterLayer(string name);
    public RectangleShape GetDrawingExtent(float screenWidth, float screenHeight);
    public static RectangleShape GetDrawingExtent(RectangleShape worldExtent, float screenWidth, float screenHeight);
    public void OpenAllLayers();
    public void CloseAllLayers();
    public static RectangleShape CenterAt(RectangleShape worldExtent, PointShape worldPoint, float screenWidth, float screenHeight);
    public void CenterAt(PointShape worldPoint, float screenWidth, float screenHeight);
    public static RectangleShape CenterAt(RectangleShape worldExtent, Feature centerFeature, float screenWidth, float screenHeight);
    public void CenterAt(Feature centerFeature, float screenWidth, float screenHeight);
    public static RectangleShape CenterAt(RectangleShape worldExtent, float screenX, float screenY, float screenWidth, float screenHeight);
    public void CenterAt(float screenX, float screenY, float screenWidth, float screenHeight);
    public static float GetScreenDistanceBetweenTwoWorldPoints(RectangleShape worldExtent, PointShape worldPoint1, PointShape worldPoint2, float screenWidth, float screenHeight);
    public float GetScreenDistanceBetweenTwoWorldPoints(PointShape worldPoint1, PointShape worldPoint2, float screenWidth, float screenHeight);
    public float GetScreenDistanceBetweenTwoWorldPoints(Feature worldPointFeature1, Feature worldPointFeature2, float screenWidth, float screenHeight);
    public static float GetScreenDistanceBetweenTwoWorldPoints(RectangleShape worldExtent, Feature worldPointFeature1, Feature worldPointFeature2, float screenWidth, float screenHeight);
    public static double GetWorldDistanceBetweenTwoScreenPoints(RectangleShape worldExtent, ScreenPointF screenPoint1, ScreenPointF screenPoint2, float screenWidth, float screenHeight, GeographyUnit worldExtentUnit, DistanceUnit distanceUnit);
    public double GetWorldDistanceBetweenTwoScreenPoints(ScreenPointF screenPoint1, ScreenPointF screenPoint2, float screenWidth, float screenHeight, GeographyUnit mapUnit, DistanceUnit distanceUnit);
    public static double GetWorldDistanceBetweenTwoScreenPoints(RectangleShape worldExtent, float screenPoint1X, float screenPoint1Y, float screenPoint2X, float screenPoint2Y, float screenWidth, float screenHeight, GeographyUnit worldExtentUnit, DistanceUnit distanceUnit);
    public double GetCurrentScale(float screenWidth, float screenHeight, GeographyUnit mapUnit);
    public static double GetCurrentScale(RectangleShape worldExtent, float screenWidth, float screenHeight, GeographyUnit mapUnit);
    public static RectangleShape GetBoundingBoxOfItems(IEnumerable`1<BaseShape> shapes);
    public static RectangleShape GetBoundingBoxOfItems(IEnumerable`1<Feature> features);
    public GeoImage Draw(IEnumerable`1<Layer> layers, GeoImage image, GeographyUnit mapUnit);
    public GeoImage Draw(IEnumerable`1<Layer> layers, int width, int height, GeographyUnit mapUnit);
    public GeoImage DrawStaticLayers(GeoImage image, GeographyUnit mapUnit);
    public GeoImage DrawDynamicLayers(GeoImage image, GeographyUnit mapUnit);
    public GeoImage DrawAdornmentLayers(GeoImage image, GeographyUnit mapUnit);
    public GeoImage DrawStaticLayers(int width, int height, GeographyUnit mapUnit);
    public GeoImage DrawDynamicLayers(int width, int height, GeographyUnit mapUnit);
    public GeoImage DrawAdornmentLayers(int width, int height, GeographyUnit mapUnit);
    private GeoImage yhU=(IEnumerable`1<AdornmentLayer> adornmentLayers, int width, int height, GeographyUnit mapUnit);
    private GeoImage yhU=(IEnumerable`1<Layer> layers, int width, int height, GeographyUnit mapUnit, bool isToDrawBackground);
    private object yhU=(IEnumerable`1<Layer> layers, GeoImage image, GeographyUnit mapUnit, bool isToDrawBackground);
    private void yxU=();
    public void ZoomIn(int percentage);
    public static RectangleShape ZoomIn(RectangleShape worldExtent, int percentage);
    public static RectangleShape ZoomIntoCenter(RectangleShape worldExtent, int percentage, PointShape worldPoint, float screenWidth, float screenHeight);
    public static RectangleShape ZoomIntoCenter(RectangleShape worldExtent, int percentage, Feature centerFeature, float screenWidth, float screenHeight);
    public void ZoomIntoCenter(int percentage, PointShape worldPoint, float screenWidth, float screenHeight);
    public void ZoomIntoCenter(int percentage, Feature centerFeature, float screenWidth, float screenHeight);
    public static RectangleShape ZoomIntoCenter(RectangleShape worldExtent, int percentage, float screenX, float screenY, float screenWidth, float screenHeight);
    public void ZoomIntoCenter(int percentage, float screenX, float screenY, float screenWidth, float screenHeight);
    public static RectangleShape ZoomOut(RectangleShape worldExtent, int percentage);
    public void ZoomOut(int percentage);
    public static RectangleShape ZoomOutToCenter(RectangleShape worldExtent, int percentage, PointShape worldPoint, float screenWidth, float screenHeight);
    public static RectangleShape ZoomOutToCenter(RectangleShape worldExtent, int percentage, Feature centerFeature, float screenWidth, float screenHeight);
    public void ZoomOutToCenter(int percentage, PointShape worldPoint, float screenWidth, float screenHeight);
    public void ZoomOutToCenter(int percentage, Feature centerFeature, float screenWidth, float screenHeight);
    public static RectangleShape ZoomOutToCenter(RectangleShape worldExtent, int percentage, float screenX, float screenY, float screenWidth, float screenHeight);
    public void ZoomOutToCenter(int percentage, float screenX, float screenY, float screenWidth, float screenHeight);
    public static RectangleShape Pan(RectangleShape worldExtent, PanDirection direction, int percentage);
    public void Pan(PanDirection panDirection, int percentage);
    public static RectangleShape Pan(RectangleShape worldExtent, float degree, int percentage);
    public void Pan(float degree, int percentage);
    public ScreenPointF ToScreenCoordinate(double worldX, double worldY, float screenWidth, float screenHeight);
    public ScreenPointF ToScreenCoordinate(PointShape worldPoint, float screenWidth, float screenHeight);
    public ScreenPointF ToScreenCoordinate(Feature worldPointFeature, float screenWidth, float screenHeight);
    public PointShape ToWorldCoordinate(float screenX, float screenY, float screenWidth, float screenHeight);
    public PointShape ToWorldCoordinate(ScreenPointF screenPoint, float screenWidth, float screenHeight);
    public static ScreenPointF ToScreenCoordinate(RectangleShape worldExtent, double worldX, double worldY, float screenWidth, float screenHeight);
    public static ScreenPointF ToScreenCoordinate(RectangleShape worldExtent, PointShape worldPoint, float screenWidth, float screenHeight);
    public static ScreenPointF ToScreenCoordinate(RectangleShape worldExtent, Feature worldPointFeature, float screenWidth, float screenHeight);
    public static PointShape ToWorldCoordinate(RectangleShape worldExtent, float screenX, float screenY, float screenWidth, float screenHeight);
    public static PointShape ToWorldCoordinate(RectangleShape worldExtent, ScreenPointF screenPoint, float screenWidth, float screenHeight);
    public static RectangleShape SnapToZoomLevel(RectangleShape worldExtent, GeographyUnit worldExtentUnit, float screenWidth, float screenHeight, ZoomLevelSet zoomLevelSet);
    public void SnapToZoomLevel(GeographyUnit worldExtentUnit, float screenWidth, float screenHeight, ZoomLevelSet zoomLevelSet);
    public static RectangleShape ZoomToScale(double targetScale, RectangleShape worldExtent, GeographyUnit worldExtentUnit, float screenWidth, float screenHeight);
    public void ZoomToScale(double targetScale, GeographyUnit worldExtentUnit, float screenWidth, float screenHeight);
    public static string GetVersion();
    private void zBU=(Layer layer, object nativeImage);
    private void zRU=(AdornmentLayer adornmentLayer);
    public static DataTable LoadDataTable(Collection`1<Feature> features, IEnumerable`1<string> returningColumnNames);
}
public class ThinkGeo.Core.MapsCloudClient : CloudClient {
    public MapsCloudClient(string clientId, string clientSecret);
    public Stream GetRasterTile(long z, long x, long y, CloudMapProjection projection, CloudRasterMapType mapType, CloudTileSize tileSize, TileResolution tileResolution);
    [AsyncStateMachineAttribute("ThinkGeo.Core.MapsCloudClient/Xz4=")]
public Task`1<Stream> GetRasterTileAsync(long z, long x, long y, CloudMapProjection projection, CloudRasterMapType mapType, CloudTileSize tileSize, TileResolution tileResolution);
    public Stream GetVectorTile(long z, long x, long y, CloudMapProjection projection);
    [AsyncStateMachineAttribute("ThinkGeo.Core.MapsCloudClient/Yz4=")]
public Task`1<Stream> GetVectorTileAsync(long z, long x, long y, CloudMapProjection projection);
    private static string 8xQ=(CloudRasterMapType mapType);
    private static string 9BQ=(CloudRasterMapType mapType);
    private static string 9RQ=(CloudMapProjection projection);
    private static int 9hQ=(CloudTileSize tileSize);
    private static int 9hQ=(TileResolution tileResolution);
}
public class ThinkGeo.Core.MapShape : object {
    [ObfuscationAttribute]
private Feature feature;
    [ObfuscationAttribute]
private ZoomLevelSet zoomLevels;
    public Feature Feature { get; public set; }
    public ZoomLevelSet ZoomLevels { get; public set; }
    public MapShape(Feature feature);
    public Feature get_Feature();
    public void set_Feature(Feature value);
    public ZoomLevelSet get_ZoomLevels();
    public void set_ZoomLevels(ZoomLevelSet value);
}
public class ThinkGeo.Core.MapShapeLayer : Layer {
    [ObfuscationAttribute]
private Dictionary`2<string, MapShape> mapShapes;
    public Dictionary`2<string, MapShape> MapShapes { get; }
    public Dictionary`2<string, MapShape> get_MapShapes();
    protected virtual void DrawCore(GeoCanvas canvas, Collection`1<SimpleCandidate> labelsInAllLayers);
}
public class ThinkGeo.Core.MapsQueryCloudClient : CloudClient {
    public MapsQueryCloudClient(string clientId, string clientSecret);
    public CloudMapsQueryResult GetFeaturesWithin(string queryLayer, BaseShape shape, CloudMapsQuerySpatialQueryOptions options);
    public CloudMapsQueryResult GetFeaturesWithin(string queryLayer, BaseShape shape, int srid, CloudMapsQuerySpatialQueryOptions options);
    public CloudMapsQueryResult GetFeaturesWithin(string queryLayer, BaseShape shape, string proj4String, CloudMapsQuerySpatialQueryOptions options);
    public CloudMapsQueryResult GetFeaturesContaining(string queryLayer, BaseShape shape, CloudMapsQuerySpatialQueryOptions options);
    public CloudMapsQueryResult GetFeaturesContaining(string queryLayer, BaseShape shape, int srid, CloudMapsQuerySpatialQueryOptions options);
    public CloudMapsQueryResult GetFeaturesContaining(string queryLayer, BaseShape shape, string proj4String, CloudMapsQuerySpatialQueryOptions options);
    public CloudMapsQueryResult GetFeaturesIntersecting(string queryLayer, BaseShape shape, CloudMapsQuerySpatialQueryOptions options);
    public CloudMapsQueryResult GetFeaturesIntersecting(string queryLayer, BaseShape shape, int srid, CloudMapsQuerySpatialQueryOptions options);
    public CloudMapsQueryResult GetFeaturesIntersecting(string queryLayer, BaseShape shape, string proj4String, CloudMapsQuerySpatialQueryOptions options);
    public CloudMapsQueryResult GetFeaturesOverlapping(string queryLayer, BaseShape shape, CloudMapsQuerySpatialQueryOptions options);
    public CloudMapsQueryResult GetFeaturesOverlapping(string queryLayer, BaseShape shape, int srid, CloudMapsQuerySpatialQueryOptions options);
    public CloudMapsQueryResult GetFeaturesOverlapping(string queryLayer, BaseShape shape, string proj4String, CloudMapsQuerySpatialQueryOptions options);
    public CloudMapsQueryResult GetFeaturesTouching(string queryLayer, BaseShape shape, CloudMapsQuerySpatialQueryOptions options);
    public CloudMapsQueryResult GetFeaturesTouching(string queryLayer, BaseShape shape, int srid, CloudMapsQuerySpatialQueryOptions options);
    public CloudMapsQueryResult GetFeaturesTouching(string queryLayer, BaseShape shape, string proj4String, CloudMapsQuerySpatialQueryOptions options);
    public CloudMapsQueryResult GetFeaturesNearest(string queryLayer, BaseShape shape, int maxResults, CloudMapsQueryNearestQueryOptions options);
    public CloudMapsQueryResult GetFeaturesNearest(string queryLayer, BaseShape shape, int srid, int maxResults, CloudMapsQueryNearestQueryOptions options);
    public CloudMapsQueryResult GetFeaturesNearest(string queryLayer, BaseShape shape, string proj4String, int maxResults, CloudMapsQueryNearestQueryOptions options);
    public CloudMapsQueryResult GetFeaturesNearest(string queryLayer, BaseShape shape, int maxResults, double searchRadius, DistanceUnit searchRadiusUnit, CloudMapsQueryNearestQueryOptions options);
    public CloudMapsQueryResult GetFeaturesNearest(string queryLayer, BaseShape shape, int srid, int maxResults, double searchRadius, DistanceUnit searchRadiusUnit, CloudMapsQueryNearestQueryOptions options);
    public CloudMapsQueryResult GetFeaturesNearest(string queryLayer, BaseShape shape, string proj4String, int maxResults, double searchRadius, DistanceUnit searchRadiusUnit, CloudMapsQueryNearestQueryOptions options);
    public CloudMapsQueryResult GetFeaturesWithinDistance(string queryLayer, BaseShape shape, double distance, DistanceUnit distanceUnit, CloudMapsQuerySpatialQueryOptions options);
    public CloudMapsQueryResult GetFeaturesWithinDistance(string queryLayer, BaseShape shape, int srid, double distance, DistanceUnit distanceUnit, CloudMapsQuerySpatialQueryOptions options);
    public CloudMapsQueryResult GetFeaturesWithinDistance(string queryLayer, BaseShape shape, string proj4String, double distance, DistanceUnit distanceUnit, CloudMapsQuerySpatialQueryOptions options);
    public CloudMapsQueryResult GetFeaturesCustom(CloudMapsQueryCustomQueryOptions options);
    public CloudMapsQueryGetLayersResult GetLayers();
    public CloudMapsQueryGetAttributesOfLayerResult GetAttributesOfLayer(string queryLayer);
    public Task`1<CloudMapsQueryResult> GetFeaturesWithinAsync(string queryLayer, BaseShape shape, CloudMapsQuerySpatialQueryOptions options);
    public Task`1<CloudMapsQueryResult> GetFeaturesWithinAsync(string queryLayer, BaseShape shape, int srid, CloudMapsQuerySpatialQueryOptions options);
    public Task`1<CloudMapsQueryResult> GetFeaturesWithinAsync(string queryLayer, BaseShape shape, string proj4String, CloudMapsQuerySpatialQueryOptions options);
    public Task`1<CloudMapsQueryResult> GetFeaturesContainingAsync(string queryLayer, BaseShape shape, CloudMapsQuerySpatialQueryOptions options);
    public Task`1<CloudMapsQueryResult> GetFeaturesContainingAsync(string queryLayer, BaseShape shape, int srid, CloudMapsQuerySpatialQueryOptions options);
    public Task`1<CloudMapsQueryResult> GetFeaturesContainingAsync(string queryLayer, BaseShape shape, string proj4String, CloudMapsQuerySpatialQueryOptions options);
    public Task`1<CloudMapsQueryResult> GetFeaturesIntersectingAsync(string queryLayer, BaseShape shape, CloudMapsQuerySpatialQueryOptions options);
    public Task`1<CloudMapsQueryResult> GetFeaturesIntersectingAsync(string queryLayer, BaseShape shape, int srid, CloudMapsQuerySpatialQueryOptions options);
    public Task`1<CloudMapsQueryResult> GetFeaturesIntersectingAsync(string queryLayer, BaseShape shape, string proj4String, CloudMapsQuerySpatialQueryOptions options);
    public Task`1<CloudMapsQueryResult> GetFeaturesOverlappingAsync(string queryLayer, BaseShape shape, CloudMapsQuerySpatialQueryOptions options);
    public Task`1<CloudMapsQueryResult> GetFeaturesOverlappingAsync(string queryLayer, BaseShape shape, int srid, CloudMapsQuerySpatialQueryOptions options);
    public Task`1<CloudMapsQueryResult> GetFeaturesOverlappingAsync(string queryLayer, BaseShape shape, string proj4String, CloudMapsQuerySpatialQueryOptions options);
    public Task`1<CloudMapsQueryResult> GetFeaturesTouchingAsync(string queryLayer, BaseShape shape, CloudMapsQuerySpatialQueryOptions options);
    public Task`1<CloudMapsQueryResult> GetFeaturesTouchingAsync(string queryLayer, BaseShape shape, int srid, CloudMapsQuerySpatialQueryOptions options);
    public Task`1<CloudMapsQueryResult> GetFeaturesTouchingAsync(string queryLayer, BaseShape shape, string proj4String, CloudMapsQuerySpatialQueryOptions options);
    public Task`1<CloudMapsQueryResult> GetFeaturesNearestAsync(string queryLayer, BaseShape shape, int maxResults, CloudMapsQueryNearestQueryOptions options);
    public Task`1<CloudMapsQueryResult> GetFeaturesNearestAsync(string queryLayer, BaseShape shape, int srid, int maxResults, CloudMapsQueryNearestQueryOptions options);
    public Task`1<CloudMapsQueryResult> GetFeaturesNearestAsync(string queryLayer, BaseShape shape, string proj4String, int maxResults, CloudMapsQueryNearestQueryOptions options);
    public Task`1<CloudMapsQueryResult> GetFeaturesNearestAsync(string queryLayer, BaseShape shape, int maxResults, double searchRadius, DistanceUnit searchRadiusUnit, CloudMapsQueryNearestQueryOptions options);
    public Task`1<CloudMapsQueryResult> GetFeaturesNearestAsync(string queryLayer, BaseShape shape, int srid, int maxResults, double searchRadius, DistanceUnit searchRadiusUnit, CloudMapsQueryNearestQueryOptions options);
    public Task`1<CloudMapsQueryResult> GetFeaturesNearestAsync(string queryLayer, BaseShape shape, string proj4String, int maxResults, double searchRadius, DistanceUnit searchRadiusUnit, CloudMapsQueryNearestQueryOptions options);
    public Task`1<CloudMapsQueryResult> GetFeaturesWithinDistanceAsync(string queryLayer, BaseShape shape, double distance, DistanceUnit distanceUnit, CloudMapsQuerySpatialQueryOptions options);
    public Task`1<CloudMapsQueryResult> GetFeaturesWithinDistanceAsync(string queryLayer, BaseShape shape, int srid, double distance, DistanceUnit distanceUnit, CloudMapsQuerySpatialQueryOptions options);
    public Task`1<CloudMapsQueryResult> GetFeaturesWithinDistanceAsync(string queryLayer, BaseShape shape, string proj4String, double distance, DistanceUnit distanceUnit, CloudMapsQuerySpatialQueryOptions options);
    public Task`1<CloudMapsQueryResult> GetFeaturesCustomAsync(CloudMapsQueryCustomQueryOptions options);
    public Task`1<CloudMapsQueryGetLayersResult> GetLayersAsync();
    public Task`1<CloudMapsQueryGetAttributesOfLayerResult> GetAttributesOfLayerAsync(string queryLayer);
    private CloudMapsQueryResult 4xQ=(QueryType queryType, string queryLayer, BaseShape shape, Nullable`1<int> srid, string proj4String, CloudMapsQuerySpatialQueryOptions options);
    [AsyncStateMachineAttribute("ThinkGeo.Core.MapsQueryCloudClient/XT4=")]
private Task`1<CloudMapsQueryResult> 5BQ=(QueryType queryType, string queryLayer, BaseShape shape, Nullable`1<int> srid, string proj4String, CloudMapsQuerySpatialQueryOptions options);
    private CloudMapsQueryResult 5RQ=(string queryLayer, BaseShape shape, Nullable`1<int> srid, string proj4String, int maxResults, Nullable`1<double> searchRadius, Nullable`1<DistanceUnit> searchRadiusUnit, CloudMapsQueryNearestQueryOptions options);
    [AsyncStateMachineAttribute("ThinkGeo.Core.MapsQueryCloudClient/Uj4=")]
private Task`1<CloudMapsQueryResult> 5hQ=(string queryLayer, BaseShape shape, Nullable`1<int> srid, string proj4String, int maxResults, Nullable`1<double> searchRadius, Nullable`1<DistanceUnit> searchRadiusUnit, CloudMapsQueryNearestQueryOptions options);
    private CloudMapsQueryResult 5xQ=(string queryLayer, BaseShape shape, Nullable`1<int> srid, string proj4String, double distance, DistanceUnit distanceUnit, CloudMapsQuerySpatialQueryOptions options);
    [AsyncStateMachineAttribute("ThinkGeo.Core.MapsQueryCloudClient/WT4=")]
private Task`1<CloudMapsQueryResult> 6BQ=(string queryLayer, BaseShape shape, Nullable`1<int> srid, string proj4String, double distance, DistanceUnit distanceUnit, CloudMapsQuerySpatialQueryOptions options);
    private CloudMapsQueryResult 6RQ=(CloudMapsQueryCustomQueryOptions options);
    [AsyncStateMachineAttribute("ThinkGeo.Core.MapsQueryCloudClient/UT4=")]
private Task`1<CloudMapsQueryResult> 6hQ=(CloudMapsQueryCustomQueryOptions options);
    private CloudMapsQueryGetLayersResult 6xQ=();
    [AsyncStateMachineAttribute("ThinkGeo.Core.MapsQueryCloudClient/XD4=")]
private Task`1<CloudMapsQueryGetLayersResult> 7BQ=();
    private CloudMapsQueryGetAttributesOfLayerResult 7RQ=(string queryLayer);
    [AsyncStateMachineAttribute("ThinkGeo.Core.MapsQueryCloudClient/Tz4=")]
private Task`1<CloudMapsQueryGetAttributesOfLayerResult> 7hQ=(string queryLayer);
    private CloudMapsQueryResult 7xQ=(WebResponse response);
    private CloudMapsQueryGetLayersResult 8BQ=(WebResponse response);
    private CloudMapsQueryGetAttributesOfLayerResult 8RQ=(WebResponse response);
    private string 3xQ=(BaseShape shape, Nullable`1<int> srid, string proj4String, CloudMapsQuerySpatialQueryOptions options);
    private string 3xQ=(BaseShape shape, Nullable`1<int> srid, string proj4String, int maxResults, Nullable`1<double> searchRadius, Nullable`1<DistanceUnit> searchRadiusUnit, CloudMapsQueryNearestQueryOptions options);
    private string 3xQ=(BaseShape shape, Nullable`1<int> srid, string proj4String, double distance, DistanceUnit distanceUnit, CloudMapsQuerySpatialQueryOptions options);
    private string 8hQ=(QueryType queryType);
}
public static class ThinkGeo.Core.MapUtil : object {
    public static float StandardDpi;
    public static double InchesPerFeet;
    public static double InchesPerMeter;
    public static double InchesPerMile;
    public static double InchesPerYard;
    public static double InchesPerNauticalMile;
    public static double InchesPerDecimalDegree;
    public static float PointsPerInch;
    private static Dictionary`2<string, string> gx0=;
    private static MapUtil();
    public static double GetResolutionFromScale(double scale, GeographyUnit unit, float dpi);
    public static double GetResolution(RectangleShape boundingBox, double widthInPixel, double heightInPixel);
    public static double GetScale(RectangleShape worldExtent, double screenWidth, GeographyUnit worldExtentUnit, float dpi);
    public static double GetScale(GeographyUnit mapUnit, RectangleShape boundingBox, double widthInPixel, double heightInPixel, float dpi);
    public static double GetSnappedScale(RectangleShape worldExtent, float screenWidth, GeographyUnit worldExtentUnit, ZoomLevelSet zoomLevelSet);
    public static double GetSnappedScale(double scale, ZoomLevelSet zoomLevelSet);
    public static RectangleShape CalculateExtent(PointShape worldCenter, double scale, GeographyUnit mapUnit, double mapWidth, double mapHeight);
    public static RectangleShape AdjustExtentByRestrictions(RectangleShape targetExtent, double width, double height, RectangleShape restrictExtent, double maximumScale, double minimumScale, GeographyUnit mapUnit);
    public static PointShape ToWorldCoordinate(RectangleShape currentExtent, double screenX, double screenY, double screenWidth, double screenHeight);
    public static double GetDistance(PointShape fromPoint, PointShape toPoint);
    public static int GetFloorZoomLevelIndex(double scale, ZoomLevelSet zoomLevelSet);
    public static ValueTuple`2<int, int> GetFloorCeilingZoomLevelIndex(double scale, ZoomLevelSet zoomLevelSet);
    public static int GetClosestZoomLevelIndex(double scale, ZoomLevelSet zoomLevelSet);
    public static int GetFloorZoomLevelIndex(double scale, Collection`1<double> zoomLevelScales);
    public static ValueTuple`2<int, int> GetFloorCeilingZoomLevelIndex(double scale, Collection`1<double> zoomLevelScales);
    public static int GetClosestZoomLevelIndex(double scale, Collection`1<double> zoomLevelScales);
    public static int GetSnappedZoomLevelIndex(RectangleShape extent, GeographyUnit mapUnit, Collection`1<double> zoomLevelScales, double actualWidth, double actualHeight);
    public static int GetSnappedZoomLevelIndex(double scale, ZoomLevelSet zoomLevelSet);
    public static int GetSnappedZoomLevelIndex(double scale, IEnumerable`1<double> zoomLevelScales, double minimumScale, double maximumScale);
    public static ScreenPointF GetRotatedScreenPoint(double x, double y, double rotatedAngle, ScreenPointF pivotPoint);
    public static ScreenPointF GetRotatedScreenPoint(double x, double y, double rotatedAngle, ScreenPointD pivotPoint);
    public static PointShape GetRotatedPoint(double x, double y, double rotatedAngle, PointShape pivotPoint);
    public static RectangleShape GetRotatedExtent(RectangleShape extent, double rotatedAngle, PointShape pivotPoint);
    public static AreaBaseShape GetRotatedPolygon(RectangleShape extent, double rotatedAngle, PointShape pivotPoint);
    public static RectangleShape ApplyDrawingMarginToExtent(RectangleShape worldExtent, float marginInPixel, float screenWidth, float screenHeight);
    public static RectangleShape CenterAt(RectangleShape worldExtent, PointShape worldPoint, float screenWidth, float screenHeight);
    public static RectangleShape CenterAt(RectangleShape worldExtent, Feature centerFeature, float screenWidth, float screenHeight);
    public static RectangleShape CenterAt(RectangleShape worldExtent, float screenX, float screenY, float screenWidth, float screenHeight);
    public static RectangleShape GetBoundingBoxOfItems(IEnumerable`1<BaseShape> shapes);
    public static RectangleShape GetBoundingBoxOfItems(IEnumerable`1<Feature> features);
    public static RectangleShape GetDrawingExtent(RectangleShape worldExtent, double screenWidth, double screenHeight);
    public static float GetScreenDistanceBetweenTwoWorldPoints(RectangleShape worldExtent, PointShape worldPoint1, PointShape worldPoint2, float screenWidth, float screenHeight);
    public static float GetScreenDistanceBetweenTwoWorldPoints(RectangleShape worldExtent, Feature worldPointFeature1, Feature worldPointFeature2, float screenWidth, float screenHeight);
    public static RectangleShape GetSnappedExtent(RectangleShape worldExtent, GeographyUnit worldExtentUnit, float screenWidth, float screenHeight, ZoomLevelSet zoomLevelSet);
    public static double GetWorldDistanceBetweenTwoScreenPoints(RectangleShape worldExtent, ScreenPointF screenPoint1, ScreenPointF screenPoint2, float screenWidth, float screenHeight, GeographyUnit worldExtentUnit, DistanceUnit distanceUnit);
    public static double GetWorldDistanceBetweenTwoScreenPoints(RectangleShape worldExtent, float screenPoint1X, float screenPoint1Y, float screenPoint2X, float screenPoint2Y, float screenWidth, float screenHeight, GeographyUnit worldExtentUnit, DistanceUnit distanceUnit);
    public static RectangleShape Pan(RectangleShape worldExtent, PanDirection direction, int percentage);
    public static RectangleShape Pan(RectangleShape worldExtent, float degree, int percentage);
    public static BaseShape ToScreenCoordinate(BaseShape shape, RectangleShape worldExtent, float screenWidth, float screenHeight);
    public static DrawingRectangle ToScreenCoordinate(RectangleShape worldExtent, RectangleShape targetWorldExtent, float screenWidth, float screenHeight);
    public static ScreenPointF ToScreenCoordinate(RectangleShape worldExtent, double worldX, double worldY, double screenWidth, double screenHeight);
    public static ScreenPointF ToScreenCoordinate(RectangleShape worldExtent, PointShape worldPoint, float screenWidth, float screenHeight);
    public static ScreenPointF ToScreenCoordinate(RectangleShape worldExtent, Feature worldPointFeature, float screenWidth, float screenHeight);
    public static PointShape ToWorldCoordinate(RectangleShape worldExtent, float screenX, float screenY, float screenWidth, float screenHeight);
    public static PointShape ToWorldCoordinate(RectangleShape worldExtent, ScreenPointF screenPoint, float screenWidth, float screenHeight);
    public static RectangleShape ZoomIn(RectangleShape worldExtent, int percentage);
    public static RectangleShape ZoomIntoCenter(RectangleShape worldExtent, int percentage, PointShape worldPoint, float screenWidth, float screenHeight);
    public static RectangleShape ZoomIntoCenter(RectangleShape worldExtent, int percentage, Feature centerFeature, float screenWidth, float screenHeight);
    public static RectangleShape ZoomIntoCenter(RectangleShape worldExtent, int percentage, float screenX, float screenY, float screenWidth, float screenHeight);
    public static RectangleShape ZoomOut(RectangleShape worldExtent, int percentage);
    public static RectangleShape ZoomOutToCenter(RectangleShape worldExtent, int percentage, PointShape worldPoint, float screenWidth, float screenHeight);
    public static RectangleShape ZoomOutToCenter(RectangleShape worldExtent, int percentage, Feature centerFeature, float screenWidth, float screenHeight);
    public static RectangleShape ZoomOutToCenter(RectangleShape worldExtent, int percentage, float screenX, float screenY, float screenWidth, float screenHeight);
    public static RectangleShape ZoomToScale(double targetScale, RectangleShape worldExtent, GeographyUnit worldExtentUnit, double screenWidth, double screenHeight);
    public static RectangleShape ZoomToScale(double targetScale, RectangleShape worldExtent, GeographyUnit worldExtentUnit, float screenWidth, float screenHeight, ScreenPointF offsetScreenPoint);
    public static Feature ToWorldCoordinate(PolygonShape simplyPolygon, RectangleShape currentWorldExtent, float canvasWidth, float canvasHeight);
    private static void hB0=(Byte[] sourceArray, Byte[] targetArray, long targetIndex);
    private static BaseShape hR0=(PointShape shape, RectangleShape worldExtent, float screenWidth, float screenHeight);
    private static BaseShape hh0=(LineShape shape, RectangleShape worldExtent, float screenWidth, float screenHeight);
    private static BaseShape hx0=(PolygonShape shape, RectangleShape worldExtent, float screenWidth, float screenHeight);
    private static BaseShape iB0=(MultipointShape shape, RectangleShape worldExtent, float screenWidth, float screenHeight);
    private static BaseShape iR0=(MultilineShape shape, RectangleShape worldExtent, float screenWidth, float screenHeight);
    private static BaseShape ih0=(MultipolygonShape shape, RectangleShape worldExtent, float screenWidth, float screenHeight);
    private static BaseShape ix0=(GeometryCollectionShape shape, RectangleShape worldExtent, float screenWidth, float screenHeight);
    private static PointShape jB0=(Byte[] wellKnownBinary, Int32& startIndex, RectangleShape worldExtent, float screenWidth, float screenHeight);
    private static PolygonShape jR0=(Byte[] wellKnownBinary, Int32& startIndex, RectangleShape worldExtent, float screenWidth, float screenHeight);
    private static LineShape jh0=(Byte[] wellKnownBinary, Int32& startIndex, RectangleShape worldExtent, float screenWidth, float screenHeight);
    private static double jx0=(Byte[] bytes, int startIndex, byte byteOrder);
    private static int kB0=(Byte[] bytes, int startIndex, byte byteOrder);
    public static string GetVersion();
    public static Collection`1<Feature> BuildFourColorColumn(string columnName, Collection`1<Feature> features);
    public static bool isSameScale(double scale1, double scale2, double epsilon);
    public static bool IsSameDouble(double double1, double double2, double epsilon);
    public static bool IsSameExtent(RectangleShape extent1, RectangleShape extent2, double epsilon);
    public static bool IsSamePoint(Vertex a, Vertex b, double epsilon);
    public static bool IsSamePoint(PointShape a, PointShape b, double epsilon);
    public static bool IsSamePoint(Vertex a, PointShape b, double epsilon);
    private static Collection`1<Collection`1<Feature>> kR0=(Collection`1<Feature> features);
    private static Int32[] kh0=(Collection`1<Feature> features);
    public static double GetInchesPerDistanceUnit(DistanceUnit targetUnit);
    public static double GetInchesPerGeographyUnit(GeographyUnit targetUnit);
    private static double kx0=(GeographyUnit unit);
    public static AreaUnit GetAreaUnitFromDistanceUnit(DistanceUnit distanceUnit);
    public static string GetShortUnitString(DistanceUnit targetUnit, Dictionary`2<string, string> preferredDisplayUnitString);
    private static RectangleShape lB0=(RectangleShape targetExtent, RectangleShape restrictExtent, double actualWidth, double actualHeight, double maximumScale, double minimumScale, GeographyUnit mapUnit);
    private static RectangleShape lR0=(RectangleShape targetExtent, double actualWidth, double actualHeight, double maximumScale, double minimumScale, GeographyUnit mapUnit);
    public static double GetScaleFromResolution(double resolution, GeographyUnit unit, float dpi);
    internal static float lh0=(float point);
    public static ValueTuple`2<double, double> Rotate(double sourceX, double sourceY, double destinationX, double destinationY, double rotationAngle);
    public static ValueTuple`2<double, double> RotatePoint(double x, double y, double rotationAngle, double pivotX, double pivotY);
    public static RingShape RotateRingShape(RingShape ringShape, double rotationAngle, double pivotX, double pivotY);
    public static PolygonShape RotatePolygonShape(PolygonShape polygonShape, double rotationAngle, double pivotX, double pivotY);
    public static RectangleShape ScaleExtent(double mapWidth, double mapHeight, double resolution, double centerScreenX, double centerScreenY, double centerWorldX, double centerWorldY);
    public static double GetRotatedCanvasRadius(double pivotX, double pivotY, double canvasWidth, double canvasHeight);
    public static PointShape OffsetPointWithScreenOffset(PointShape pointShape, double xScreenOffset, double yScreenOffset, double mapRotation, double mapScale, GeographyUnit mapUnit);
    private static double lx0=(double x1, double y1, double x2, double y2);
    public static RectangleShape GetWorldExtent(GeographyUnit unit);
    public static PointShape ToWorldCoordinate(double screenX, double screenY, PointShape centerPoint, double centerScreenX, double centerScreenY, double scale, GeographyUnit mapUnit, double mapRotation);
    public static RectangleShape GetExtentFromCenterPoint(PointShape centerPoint, double canvasWidth, double canvasHeight, double scale, GeographyUnit mapUnit);
    public static ValueTuple`2<double, double> GetFloorCeilingScales(double scale, ZoomLevelSet zoomLevelSet);
    public static double GetDegreeFromPanDirection(PanDirection panDirection);
    public static double GetResolutionOfRotatedExtent(RectangleShape extent, double rotationAngle, double canvasWidth, double canvasHeight);
}
public enum ThinkGeo.Core.MaskType : Enum {
    public int value__;
    public static MaskType Default;
    public static MaskType Rectangle;
    public static MaskType RoundedCorners;
    public static MaskType RoundedEnds;
    public static MaskType Circle;
}
public abstract class ThinkGeo.Core.Matrix : object {
    [ObfuscationAttribute]
private static int MAXIMUM_CELL_COUNT;
    [ObfuscationAttribute]
private string id;
    [ObfuscationAttribute]
private double cellWidth;
    [ObfuscationAttribute]
private double cellHeight;
    [ObfuscationAttribute]
private RectangleShape boundingBox;
    [CompilerGeneratedAttribute]
private double vx0=;
    public double CellWidth { get; public set; }
    public double CellHeight { get; public set; }
    public RectangleShape BoundingBox { get; public set; }
    public string Id { get; public set; }
    internal double wh0= { get; internal set; }
    protected Matrix(string id, double cellWidth, double cellHeight, RectangleShape boundingBox);
    public double get_CellWidth();
    public void set_CellWidth(double value);
    public double get_CellHeight();
    public void set_CellHeight(double value);
    public RectangleShape get_BoundingBox();
    public void set_BoundingBox(RectangleShape value);
    public string get_Id();
    public void set_Id(string value);
    [CompilerGeneratedAttribute]
internal double wB0=();
    [CompilerGeneratedAttribute]
internal void wR0=(double value);
    public Collection`1<MatrixCell> GetAllCells();
    public MatrixCell GetCell(long row, long column);
    public MatrixCell GetCell(PointShape intersectingPoint);
    public long GetRowIndex(PointShape intersectingPoint);
    public long GetColumnIndex(PointShape intersectingPoint);
    public Collection`1<MatrixCell> GetIntersectingCells(RectangleShape worldExtent);
    public Collection`1<MatrixCell> GetContainedCells(RectangleShape worldExtent);
    public RowColumnRange GetIntersectingRowColumnRange(RectangleShape worldExtent);
    public RowColumnRange GetContainedRowColumnRange(RectangleShape worldExtent);
    public long GetRowCount();
    public long GetColumnCount();
    private RowColumnRange wx0=(RectangleShape worldExtent, bool isContains);
    protected virtual RowColumnRange GetRowColumnRangeCore(RectangleShape worldExtent, bool isContains);
    internal RowColumnRange wx0=(RectangleShape worldExtent, bool isContains, double epsilon, bool wrapWorldExtent);
}
public class ThinkGeo.Core.MatrixCell : ValueType {
    [ObfuscationAttribute]
private long row;
    [ObfuscationAttribute]
private long column;
    [ObfuscationAttribute]
private RectangleShape boundingBox;
    public long Row { get; public set; }
    public long Column { get; public set; }
    public RectangleShape BoundingBox { get; public set; }
    public MatrixCell(long row, long column, RectangleShape boundingBox);
    public long get_Row();
    public void set_Row(long value);
    public long get_Column();
    public void set_Column(long value);
    public RectangleShape get_BoundingBox();
    public void set_BoundingBox(RectangleShape value);
    public virtual string ToString();
    public virtual int GetHashCode();
    public virtual bool Equals(object obj);
    public sealed virtual int CompareTo(MatrixCell other);
    public static bool op_Equality(MatrixCell cell1, MatrixCell cell2);
    public static bool op_Inequality(MatrixCell cell1, MatrixCell cell2);
}
public enum ThinkGeo.Core.MatrixReferenceCorner : Enum {
    public int value__;
    public static MatrixReferenceCorner UpperLeft;
    public static MatrixReferenceCorner UpperRight;
    public static MatrixReferenceCorner LowerLeft;
    public static MatrixReferenceCorner LowerRight;
}
public static class ThinkGeo.Core.MaxExtents : object {
    public static RectangleShape SphericalMercator;
    public static RectangleShape ThinkGeoMaps;
    public static RectangleShape MapBoxMaps;
    public static RectangleShape BingMaps;
    public static RectangleShape HereMaps;
    public static RectangleShape GoogleMaps;
    public static RectangleShape OsmMaps;
    public static RectangleShape Feet;
    public static RectangleShape DecimalDegree;
    private static MaxExtents();
    public static RectangleShape GetDefaultMaxExtent(GeographyUnit unit);
}
public static class ThinkGeo.Core.MbStyleFilter : object {
    internal static List`1<FilterCondition> kxU=(JsonElement filterElement);
    private static List`1<FilterCondition> TiM=(JsonElement filterElement);
    private static List`1<FilterCondition> TyM=(JsonElement filterElement);
    private static IEnumerable`1<FilterCondition> UCM=(JsonElement filterElement);
    private static IEnumerable`1<FilterCondition> USM=(JsonElement inElement);
    private static IEnumerable`1<FilterCondition> UiM=(JsonElement filterElement);
}
public class ThinkGeo.Core.MBTilesGenerationLayerSetting : object {
    [ObfuscationAttribute]
private FeatureLayer featureLayer;
    [ObfuscationAttribute]
private Collection`1<string> columnNames;
    [ObfuscationAttribute]
private int minimumZoom;
    [ObfuscationAttribute]
private int maximumZoom;
    public FeatureLayer FeatureLayer { get; public set; }
    public Collection`1<string> ColumnNames { get; public set; }
    public int MinimumZoom { get; public set; }
    public int MaximumZoom { get; public set; }
    public MBTilesGenerationLayerSetting(FeatureLayer featureLayer, IEnumerable`1<string> columnNames, int minimumZoom, int maximumZoom);
    public FeatureLayer get_FeatureLayer();
    public void set_FeatureLayer(FeatureLayer value);
    public Collection`1<string> get_ColumnNames();
    public void set_ColumnNames(Collection`1<string> value);
    public int get_MinimumZoom();
    public void set_MinimumZoom(int value);
    public int get_MaximumZoom();
    public void set_MaximumZoom(int value);
}
public class ThinkGeo.Core.MbTilesLayer : LayerAsync {
    private SqliteConnection XiM=;
    private string XyM=;
    private string YCM=;
    private RectangleShape YSM=;
    private PointShape YiM=;
    private int YyM=;
    private int ZCM=;
    private int ZSM=;
    private string ZiM=;
    private string ZyM=;
    private string aCM=;
    private string aSM=;
    private string aiM=;
    private string ayM=;
    [CompilerGeneratedAttribute]
private string bCM=;
    [CompilerGeneratedAttribute]
private Stream bSM=;
    private ZoomLevelSet biM=;
    [CompilerGeneratedAttribute]
private GeoColor byM=;
    public string FilePath { get; public set; }
    public Stream StyleJsonStream { get; public set; }
    public ZoomLevelSet ZoomLevelSet { get; public set; }
    public GeoColor BackgroundColor { get; public set; }
    public bool HasBoundingBox { get; }
    public MbTilesLayer(string filePath, string styleJsonFilePath);
    public MbTilesLayer(string filePath, Stream styleJsonStream);
    [CompilerGeneratedAttribute]
public string get_FilePath();
    [CompilerGeneratedAttribute]
public void set_FilePath(string value);
    [CompilerGeneratedAttribute]
public Stream get_StyleJsonStream();
    [CompilerGeneratedAttribute]
public void set_StyleJsonStream(Stream value);
    public ZoomLevelSet get_ZoomLevelSet();
    public void set_ZoomLevelSet(ZoomLevelSet value);
    [CompilerGeneratedAttribute]
public GeoColor get_BackgroundColor();
    [CompilerGeneratedAttribute]
public void set_BackgroundColor(GeoColor value);
    [AsyncStateMachineAttribute("ThinkGeo.Core.MbTilesLayer/EUA=")]
protected virtual Task OpenAsyncCore(CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("ThinkGeo.Core.MbTilesLayer/DUA=")]
private Task cCM=(CancellationToken cancellationToken);
    public virtual bool get_HasBoundingBox();
    protected virtual RectangleShape GetBoundingBoxCore();
    [AsyncStateMachineAttribute("ThinkGeo.Core.MbTilesLayer/B0A=")]
protected virtual Task DrawAsyncCore(GeoCanvas canvas, Collection`1<SimpleCandidate> labelsInAllLayers);
    [AsyncStateMachineAttribute("ThinkGeo.Core.MbTilesLayer/CEA=")]
private Task cSM=(ZoomLevel zoomLevel, RowColumnRange rowColumnRange, int zoom, GeoCanvas canvas);
    private static List`1<Feature> ciM=(Collection`1<VectorTile> tiles, RectangleShape currentExtent, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("ThinkGeo.Core.MbTilesLayer/CUA=")]
private Task`1<Collection`1<VectorTile>> cyM=(RowColumnRange rowColumnRange, int zoomLevel);
    [AsyncStateMachineAttribute("ThinkGeo.Core.MbTilesLayer/BkA=")]
protected virtual Task CloseAsyncCore(CancellationToken cancellationToken);
    private static ValueTuple`2<ZoomLevelSet, GeoColor> dCM=(string styleJsonString, ZoomLevelSet zoomLevelSet, string layerColumnName);
    [CompilerGeneratedAttribute]
[DebuggerHiddenAttribute]
private Task Ah4=(CancellationToken cancellationToken);
    [CompilerGeneratedAttribute]
[DebuggerHiddenAttribute]
private Task Ax4=(CancellationToken cancellationToken);
}
public class ThinkGeo.Core.MbTilesRasterLayer : LayerAsync {
    private SqliteConnection XiM=;
    private string XyM=;
    private string YCM=;
    private RectangleShape YSM=;
    private PointShape YiM=;
    private int YyM=;
    private int ZCM=;
    private int ZSM=;
    private string ZiM=;
    private string ZyM=;
    private string aCM=;
    private string aSM=;
    private string aiM=;
    [CompilerGeneratedAttribute]
private ZoomLevelSet dh0=;
    [CompilerGeneratedAttribute]
private string bCM=;
    public ZoomLevelSet ZoomLevelSet { get; public set; }
    public string FilePath { get; public set; }
    public bool HasBoundingBox { get; }
    public MbTilesRasterLayer(string filePath);
    [CompilerGeneratedAttribute]
public ZoomLevelSet get_ZoomLevelSet();
    [CompilerGeneratedAttribute]
public void set_ZoomLevelSet(ZoomLevelSet value);
    [CompilerGeneratedAttribute]
public string get_FilePath();
    [CompilerGeneratedAttribute]
public void set_FilePath(string value);
    [AsyncStateMachineAttribute("ThinkGeo.Core.MbTilesRasterLayer/GUA=")]
protected virtual Task OpenAsyncCore(CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("ThinkGeo.Core.MbTilesRasterLayer/GEA=")]
private Task cCM=(CancellationToken cancellationToken);
    public virtual bool get_HasBoundingBox();
    protected virtual RectangleShape GetBoundingBoxCore();
    [AsyncStateMachineAttribute("ThinkGeo.Core.MbTilesRasterLayer/E0A=")]
protected virtual Task DrawAsyncCore(GeoCanvas canvas, Collection`1<SimpleCandidate> labelsInAllLayers);
    [AsyncStateMachineAttribute("ThinkGeo.Core.MbTilesRasterLayer/FEA=")]
private Task cSM=(RowColumnRange rowColumnRange, int zoom, GeoCanvas geoCanvas);
    [AsyncStateMachineAttribute("ThinkGeo.Core.MbTilesRasterLayer/EkA=")]
protected virtual Task CloseAsyncCore(CancellationToken cancellationToken);
    [DebuggerHiddenAttribute]
[CompilerGeneratedAttribute]
private Task Ah4=(CancellationToken cancellationToken);
    [CompilerGeneratedAttribute]
[DebuggerHiddenAttribute]
private Task Ax4=(CancellationToken cancellationToken);
}
[ObfuscationAttribute]
internal class ThinkGeo.Core.MetersValues : ValueType {
    [ObfuscationAttribute]
private double v10;
    [ObfuscationAttribute]
private double v100;
    [ObfuscationAttribute]
private double v1000;
    [ObfuscationAttribute]
private double v20;
    [ObfuscationAttribute]
private double v200;
    [ObfuscationAttribute]
private double v30;
    [ObfuscationAttribute]
private double v300;
    [ObfuscationAttribute]
private double v40;
    [ObfuscationAttribute]
private double v400;
    [ObfuscationAttribute]
private double v50;
    [ObfuscationAttribute]
private double v500;
    public double KCE= { get; }
    public double KiE= { get; }
    public double LCE= { get; }
    public double LiE= { get; }
    public double MCE= { get; }
    public double MiE= { get; }
    public double NCE= { get; }
    public double NiE= { get; }
    public double OCE= { get; }
    public double OiE= { get; }
    public double PCE= { get; }
    public MetersValues(int width, double extentLengthBar, DistanceUnit distanceUnit);
    public double JyE=();
    public double KSE=();
    public double KyE=();
    public double LSE=();
    public double LyE=();
    public double MSE=();
    public double MyE=();
    public double NSE=();
    public double NyE=();
    public double OSE=();
    public double OyE=();
}
[ObfuscationAttribute]
internal class ThinkGeo.Core.MilesValues : ValueType {
    [ObfuscationAttribute]
private double v01;
    [ObfuscationAttribute]
private double v02;
    [ObfuscationAttribute]
private double v03;
    [ObfuscationAttribute]
private double v04;
    [ObfuscationAttribute]
private double v05;
    [ObfuscationAttribute]
private double v1;
    [ObfuscationAttribute]
private double v10;
    [ObfuscationAttribute]
private double v100;
    [ObfuscationAttribute]
private double v1000;
    [ObfuscationAttribute]
private double v2;
    [ObfuscationAttribute]
private double v20;
    [ObfuscationAttribute]
private double v200;
    [ObfuscationAttribute]
private double v3;
    [ObfuscationAttribute]
private double v30;
    [ObfuscationAttribute]
private double v300;
    [ObfuscationAttribute]
private double v4;
    [ObfuscationAttribute]
private double v40;
    [ObfuscationAttribute]
private double v400;
    [ObfuscationAttribute]
private double v5;
    [ObfuscationAttribute]
private double v50;
    [ObfuscationAttribute]
private double v500;
    public double TCE= { get; }
    public double TiE= { get; }
    public double UCE= { get; }
    public double UiE= { get; }
    public double VCE= { get; }
    public double QCE= { get; }
    public double QiE= { get; }
    public double RCE= { get; }
    public double RiE= { get; }
    public double SCE= { get; }
    public double KCE= { get; }
    public double KiE= { get; }
    public double LCE= { get; }
    public double LiE= { get; }
    public double MCE= { get; }
    public double MiE= { get; }
    public double NCE= { get; }
    public double NiE= { get; }
    public double OCE= { get; }
    public double OiE= { get; }
    public double PCE= { get; }
    public MilesValues(int width, double extentLengthBar, DistanceUnit distanceUnit);
    public double SyE=();
    public double TSE=();
    public double TyE=();
    public double USE=();
    public double UyE=();
    public double PyE=();
    public double QSE=();
    public double QyE=();
    public double RSE=();
    public double RyE=();
    public double JyE=();
    public double KSE=();
    public double KyE=();
    public double LSE=();
    public double LyE=();
    public double MSE=();
    public double MyE=();
    public double NSE=();
    public double NyE=();
    public double OSE=();
    public double OyE=();
}
public class ThinkGeo.Core.MouseMovedTrackInteractiveOverlayEventArgs : EventArgs {
    [ObfuscationAttribute]
private Vertex movedVertex;
    [ObfuscationAttribute]
private Feature affectedFeature;
    public Vertex MovedVertex { get; public set; }
    public Feature AffectedFeature { get; public set; }
    public MouseMovedTrackInteractiveOverlayEventArgs(Vertex movedVertex, Feature affectedFeature);
    public Vertex get_MovedVertex();
    public void set_MovedVertex(Vertex value);
    public Feature get_AffectedFeature();
    public void set_AffectedFeature(Feature value);
}
public class ThinkGeo.Core.MovedItemGeoCollectionEventArgs : object {
    [CompilerGeneratedAttribute]
private int txU=;
    [CompilerGeneratedAttribute]
private int uBU=;
    public int FromIndex { get; public set; }
    public int ToIndex { get; public set; }
    public MovedItemGeoCollectionEventArgs(int fromIndex, int toIndex);
    [CompilerGeneratedAttribute]
public int get_FromIndex();
    [CompilerGeneratedAttribute]
public void set_FromIndex(int value);
    [CompilerGeneratedAttribute]
public int get_ToIndex();
    [CompilerGeneratedAttribute]
public void set_ToIndex(int value);
}
[TypeConverterAttribute("ThinkGeo.Core.BaseShapeTypeConverter")]
public class ThinkGeo.Core.MultilineShape : LineBaseShape {
    [ObfuscationAttribute]
private Collection`1<LineShape> lines;
    public Collection`1<LineShape> Lines { get; }
    public MultilineShape(IEnumerable`1<LineShape> lineShapes);
    public MultilineShape(string wellKnownText);
    public MultilineShape(Byte[] wellKnownBinary);
    public Collection`1<LineShape> get_Lines();
    protected virtual RectangleShape GetBoundingBoxCore();
    protected virtual BaseShape CloneDeepCore();
    protected virtual PointShape GetCenterPointCore();
    public void Reorder(PointShape startPoint, double tolerance);
    public void Reorder(PointShape startPoint, double tolerance, GeographyUnit shapeUnit, DistanceUnit unitOfTolerance);
    protected virtual void ReorderCore(PointShape startPoint, double tolerance, GeographyUnit shapeUnit, DistanceUnit unitOfTolerance);
    protected virtual double GetLengthCore(GeographyUnit shapeUnit, DistanceUnit returningUnit);
    public PointShape GetPointOnALine(StartingPoint startingPoint, float percentageOfLine);
    public PointShape GetPointOnALine(StartingPoint startingPoint, double distance, GeographyUnit shapeUnit, DistanceUnit distanceUnit);
    protected virtual PointShape GetPointOnALineCore(StartingPoint startingPoint, double distance, GeographyUnit shapeUnit, DistanceUnit distanceUnit);
    public LineBaseShape GetLineOnALine(StartingPoint startingPoint, float startingPercentageOfTheLine, float percentageOfTheLine);
    public LineBaseShape GetLineOnALine(StartingPoint startingPoint, float percentageOfLine);
    public LineBaseShape GetLineOnALine(StartingPoint startingPoint, double startingDistance, double distance, GeographyUnit shapeUnit, DistanceUnit distanceUnit);
    protected virtual LineBaseShape GetLineOnALineCore(StartingPoint startingPoint, double startingDistance, double distance, GeographyUnit shapeUnit, DistanceUnit distanceUnit);
    public LineBaseShape GetLineOnALine(StartingPoint startingPoint, PointShape endPointShape);
    public LineBaseShape GetLineOnALine(PointShape startPointShape, PointShape endPointShape);
    private MultilineShape TBw=(PointShape startPointShape, PointShape endPointShape);
    private double TRw=(PointShape pointShape);
    private static void XBw=(MultilineShape ResultMultiLine, Double& CumulDistEnd, LineShape LineShape, StartingPoint startingPoint, double StartingDistance, double EndingDistance, GeographyUnit shapeUnit, DistanceUnit distanceUnit);
    protected virtual void ScaleUpCore(double percentage);
    protected virtual void ScaleDownCore(double percentage);
    protected virtual BaseShape RegisterCore(PointShape fromPoint, PointShape toPoint, DistanceUnit fromUnit, GeographyUnit toUnit);
    protected virtual void TranslateByOffsetCore(double xOffsetDistance, double yOffsetDistance, GeographyUnit shapeUnit, DistanceUnit distanceUnit);
    protected virtual void TranslateByDegreeCore(double distance, double angleInDegrees, GeographyUnit shapeUnit, DistanceUnit distanceUnit);
    protected virtual void RotateCore(PointShape pivotPoint, double degreeAngle);
    protected virtual PointShape GetClosestPointToCore(BaseShape targetShape, GeographyUnit shapeUnit);
    protected virtual double GetDistanceToCore(BaseShape targetShape, GeographyUnit shapeUnit, DistanceUnit distanceUnit);
    protected virtual string GetWellKnownTextCore(RingOrder outerRingOrder);
    protected virtual WellKnownType GetWellKnownTypeCore();
    protected virtual void LoadFromWellKnownDataCore(string wellKnownText);
    protected virtual void LoadFromWellKnownDataCore(Byte[] wellKnownBinary);
    private static void XRw=(MultilineShape fromLines, MultilineShape toLines);
    protected virtual ShapeValidationResult ValidateCore(ShapeValidationMode validationMode);
    protected virtual MultipointShape GetCrossingCore(BaseShape targetShape);
    public static bool RemoveVertex(Vertex selectedVertex, MultilineShape multilineShape);
    public bool RemoveVertex(Vertex selectedVertex);
    public MultipolygonShape ToMultiPolygonShape();
    internal void TRU=(double factor);
    private static void Xhw=(LineShape lineShape, StringBuilder wellKnownText);
    private LineShape Xxw=(Vertex vertex, double Tolerance, GeographyUnit ShapesUnit, DistanceUnit ToleranceUnit);
    private bool YBw=(double tolerance, GeographyUnit shapeUnit, DistanceUnit unitOfTolerance);
    private bool YRw=(PointShape pointShape, double tolerance, GeographyUnit shapeUnit, DistanceUnit unitOfTolerance);
    private static RectangleShape WRw=(IEnumerable`1<Vertex> vertices);
}
public class ThinkGeo.Core.MultipleFeatureLayer : FeatureLayer {
    public Collection`1<FeatureSource> FeatureSources { get; }
    public bool HasBoundingBox { get; }
    public MultipleFeatureLayer(IEnumerable`1<FeatureSource> featureSources);
    public Collection`1<FeatureSource> get_FeatureSources();
    public virtual bool get_HasBoundingBox();
}
public class ThinkGeo.Core.MultipleFeatureSource : FeatureSource {
    [ObfuscationAttribute]
private Collection`1<FeatureSource> featureSources;
    [ObfuscationAttribute]
private Collection`1<long> featureCounts;
    public Collection`1<FeatureSource> FeatureSources { get; }
    public bool IsEditable { get; }
    public MultipleFeatureSource(IEnumerable`1<FeatureSource> featureSources);
    public Collection`1<FeatureSource> get_FeatureSources();
    public virtual bool get_IsEditable();
    protected virtual Collection`1<FeatureSourceColumn> GetColumnsCore();
    protected virtual void OpenCore();
    protected virtual void CloseCore();
    protected virtual long GetCountCore();
    protected virtual RectangleShape GetBoundingBoxCore();
    protected virtual TransactionResult CommitTransactionCore(TransactionBuffer transactions);
    protected virtual Collection`1<Feature> GetAllFeaturesCore(IEnumerable`1<string> returningColumnNames);
    protected virtual Collection`1<Feature> GetFeaturesInsideBoundingBoxCore(RectangleShape boundingBox, IEnumerable`1<string> returningColumnNames);
    protected virtual Collection`1<Feature> GetFeaturesByIdsCore(IEnumerable`1<string> ids, IEnumerable`1<string> returningColumnNames);
    protected virtual Collection`1<Feature> GetFeaturesForDrawingCore(RectangleShape boundingBox, double screenWidth, double screenHeight, IEnumerable`1<string> returningColumnNames);
    protected virtual Collection`1<Feature> GetFeaturesNearestToCore(BaseShape targetShape, GeographyUnit unitOfData, int maxItemsToFind, IEnumerable`1<string> returningColumnNames);
    protected virtual Collection`1<Feature> GetFeaturesOutsideBoundingBoxCore(RectangleShape boundingBox, IEnumerable`1<string> returningColumnNames);
    protected virtual Collection`1<Feature> GetFeaturesWithinDistanceOfCore(BaseShape targetShape, GeographyUnit unitOfData, DistanceUnit distanceUnit, double distance, IEnumerable`1<string> returningColumnNames);
    protected virtual Collection`1<Feature> SpatialQueryCore(BaseShape targetShape, QueryType queryType, IEnumerable`1<string> returningColumnNames);
}
public class ThinkGeo.Core.MultipleShapeFileFeatureLayer : FeatureLayer {
    public Collection`1<string> ShapeFiles { get; }
    public Collection`1<string> Indexes { get; }
    public string MultipleShapeFilePattern { get; public set; }
    public string IndexFilePattern { get; public set; }
    public Encoding Encoding { get; public set; }
    public bool HasBoundingBox { get; }
    public MultipleShapeFileFeatureLayer(string multipleShapeFilePattern);
    public MultipleShapeFileFeatureLayer(string multipleShapeFilePattern, string indexFilePattern);
    public MultipleShapeFileFeatureLayer(IEnumerable`1<string> shapeFiles);
    public MultipleShapeFileFeatureLayer(IEnumerable`1<string> shapeFiles, IEnumerable`1<string> indexes);
    public Collection`1<string> get_ShapeFiles();
    public Collection`1<string> get_Indexes();
    public string get_MultipleShapeFilePattern();
    public void set_MultipleShapeFilePattern(string value);
    public string get_IndexFilePattern();
    public void set_IndexFilePattern(string value);
    public Encoding get_Encoding();
    public void set_Encoding(Encoding value);
    public virtual bool get_HasBoundingBox();
    public static void BuildIndex(string multipleShapeFilePattern);
    public static void BuildIndex(string multipleShapeFilePattern, BuildIndexMode buildIndexMode);
    public static void BuildIndex(string multipleShapeFilePattern, string indexFilePattern);
    public static void BuildIndex(string multipleShapeFilePattern, string indexFilePattern, BuildIndexMode buildIndexMode);
    public static void BuildIndex(string multipleShapeFilePattern, string columnName, string regularExpression, string indexFilename);
    public static void BuildIndex(string multipleShapeFilePattern, string columnName, string regularExpression, string indexFilename, BuildIndexMode buildIndexMode);
    public static void BuildIndex(String[] multipleShapeFiles, String[] multipleShapeFileIndexes);
    public static void BuildIndex(String[] multipleShapeFiles, String[] multipleShapeFileIndexes, BuildIndexMode buildIndexMode);
    public Collection`1<string> GetShapePathFilenames();
    public Collection`1<string> GetIndexPathFilenames();
}
public class ThinkGeo.Core.MultipleShapeFileFeatureSource : FeatureSource {
    private static int 8iM=;
    private static char 8yM=;
    private static char 9CM=;
    [ObfuscationAttribute]
private Dictionary`2<string, GeoDbf> dBaseEngines;
    [ObfuscationAttribute]
private string indexFilePattern;
    [ObfuscationAttribute]
private bool isBigMultipleIndex;
    [ObfuscationAttribute]
private string multipleShapeFilePattern;
    [ObfuscationAttribute]
private Dictionary`2<string, RtreeSpatialIndex> rTreeIndexs;
    [ObfuscationAttribute]
private Collection`1<string> shapeFiles;
    [ObfuscationAttribute]
private Collection`1<string> indexes;
    [ObfuscationAttribute]
private FileAccess shapeFileReadWriteMode;
    [ObfuscationAttribute]
private Dictionary`2<string, ShapeFile> cachedShapeFiles;
    [ObfuscationAttribute]
private Encoding encoding;
    public Collection`1<string> ShapeFiles { get; }
    public Collection`1<string> Indexes { get; }
    public string MultipleShapeFilePattern { get; public set; }
    public string IndexFilePattern { get; public set; }
    public Encoding Encoding { get; public set; }
    public bool IsEditable { get; }
    public MultipleShapeFileFeatureSource(string multipleShapeFilePattern);
    public MultipleShapeFileFeatureSource(string multipleShapeFilePattern, string indexFilePattern);
    public MultipleShapeFileFeatureSource(IEnumerable`1<string> shapeFiles);
    public MultipleShapeFileFeatureSource(IEnumerable`1<string> shapeFiles, IEnumerable`1<string> indexes);
    private void Lh8=(IEnumerable`1<string> multipleShapeFiles, IEnumerable`1<string> multipleShapeFileIndexes);
    public Collection`1<string> get_ShapeFiles();
    public Collection`1<string> get_Indexes();
    public string get_MultipleShapeFilePattern();
    public void set_MultipleShapeFilePattern(string value);
    public string get_IndexFilePattern();
    public void set_IndexFilePattern(string value);
    public Encoding get_Encoding();
    public void set_Encoding(Encoding value);
    public virtual bool get_IsEditable();
    public Collection`1<string> GetShapePathFilenames();
    public Collection`1<string> GetIndexPathFilenames();
    public static void BuildIndex(string multipleShapeFilePattern);
    public static void BuildIndex(string multipleShapeFilePattern, BuildIndexMode buildIndexMode);
    public static void BuildIndex(string multipleShapeFilePattern, string indexFilePattern);
    public static void BuildIndex(string multipleShapeFilePattern, string indexFilePattern, BuildIndexMode buildIndexMode);
    public static void BuildIndex(string multipleShapeFilePattern, string columnName, string regularExpression, string indexFilename);
    public static void BuildIndex(string multipleShapeFilePattern, string columnName, string regularExpression, string indexPathFilename, BuildIndexMode buildIndexMode);
    public static void BuildIndex(String[] multipleShapeFiles, String[] multipleShapeFileIndexes);
    public static void BuildIndex(String[] multipleShapeFiles, String[] multipleShapeFileIndexes, BuildIndexMode buildIndexMode);
    private static bool 9SM=(BuildIndexMode buildIndexMode, IEnumerable`1<string> idxPathFilenames);
    private static Dictionary`2<string, string> 9iM=(string multipleShapeFilePattern, string indexFilePattern);
    private static void 9yM=(string shapePathFilename, string idxFileName, string columnName, string regularExpression);
    private static bool /CM=(GeoDbf dbaseEngine, int recourdId, string columnName, Regex regex);
    private static void /SM=(string idxPathFilename, WellKnownType wellKnownType);
    protected virtual Collection`1<FeatureSourceColumn> GetColumnsCore();
    protected virtual void OpenCore();
    protected virtual void CloseCore();
    protected virtual TransactionResult CommitTransactionCore(TransactionBuffer transactions);
    protected virtual Collection`1<Feature> GetAllFeaturesCore(IEnumerable`1<string> returningColumnNames);
    protected virtual Collection`1<string> GetFeatureIdsCore();
    private Collection`1<string> /iM=(string shapePathFilename, string key);
    private Collection`1<Feature> /yM=(string shapePathFilename, string key, List`1<string> columnNames);
    private static Dictionary`2<string, string> ACQ=(GeoDbf dBaseEngine, string id, IEnumerable`1<string> columnNames);
    protected virtual RectangleShape GetBoundingBoxCore();
    private RectangleShape ASQ=(string shapePathFilename, string key);
    protected virtual long GetCountCore();
    protected virtual Collection`1<Feature> GetFeaturesByIdsCore(IEnumerable`1<string> ids, IEnumerable`1<string> returningColumnNames);
    private Feature AiQ=(string originalId, string key, string recordId, List`1<string> recordNames);
    protected virtual Collection`1<Feature> GetFeaturesInsideBoundingBoxCore(RectangleShape boundingBox, IEnumerable`1<string> returningColumnNames);
    private Collection`1<Feature> AyQ=(string shapePathFilename, string key, RectangleShape boundingBox, List`1<string> returningColumnNames);
    protected virtual Collection`1<Feature> GetFeaturesOutsideBoundingBoxCore(RectangleShape boundingBox, IEnumerable`1<string> returningColumnNames);
    private string BCQ=(string shapefile);
    private Collection`1<Feature> BSQ=(string shapePathFilename, string key, RectangleShape boundingBox, List`1<string> returningColumnNames);
    protected virtual Collection`1<Feature> GetFeaturesWithinDistanceOfCore(BaseShape targetShape, GeographyUnit unitOfData, DistanceUnit distanceUnit, double distance, IEnumerable`1<string> returningColumnNames);
    private Collection`1<Feature> BiQ=(string shapeFilePathName, string key, BaseShape targetShape, GeographyUnit unitOfData, DistanceUnit distanceUnit, double distance, List`1<string> returningColumnNames);
    protected virtual Collection`1<Feature> GetFeaturesNearestToCore(BaseShape targetShape, GeographyUnit unitOfData, int maxItemsToFind, IEnumerable`1<string> returningColumnNames);
    private static String[] ByQ=(string wildcardPathFilename);
    private ShapeFile CCQ=(string shapePathFilename, string key);
    private GeoDbf CSQ=(string shapePathFilename, string key);
    private RtreeSpatialIndex CiQ=(string shapePathFilename, string key);
    private static void CyQ=(string pathFilename);
    private static WellKnownType rxo=(ShapeFileType shapeFileType);
}
[TypeConverterAttribute("ThinkGeo.Core.BaseShapeTypeConverter")]
public class ThinkGeo.Core.MultipointShape : PointBaseShape {
    [ObfuscationAttribute]
private Collection`1<PointShape> points;
    public Collection`1<PointShape> Points { get; }
    public MultipointShape(IEnumerable`1<PointShape> points);
    public MultipointShape(IEnumerable`1<Feature> pointFeatures);
    public MultipointShape(Feature multipointFeature);
    public MultipointShape(string wellKnownText);
    public MultipointShape(Byte[] wellKnownBinary);
    public Collection`1<PointShape> get_Points();
    protected virtual BaseShape CloneDeepCore();
    protected virtual PointShape GetCenterPointCore();
    public void ScaleUp(double percentage);
    protected virtual void ScaleUpCore(double percentage);
    public void ScaleDown(double percentage);
    protected virtual void ScaleDownCore(double percentage);
    private void TRU=(float multiplicator);
    public RingShape ConvexHull();
    protected virtual RingShape ConvexHullCore();
    protected virtual BaseShape RegisterCore(PointShape fromPoint, PointShape toPoint, DistanceUnit fromUnit, GeographyUnit toUnit);
    protected virtual void TranslateByOffsetCore(double xOffsetDistance, double yOffsetDistance, GeographyUnit shapeUnit, DistanceUnit distanceUnit);
    protected virtual void TranslateByDegreeCore(double distance, double angleInDegrees, GeographyUnit shapeUnit, DistanceUnit distanceUnit);
    protected virtual void RotateCore(PointShape pivotPoint, double degreeAngle);
    protected virtual PointShape GetClosestPointToCore(BaseShape targetShape, GeographyUnit shapeUnit);
    protected virtual RectangleShape GetBoundingBoxCore();
    protected virtual double GetDistanceToCore(BaseShape targetShape, GeographyUnit shapeUnit, DistanceUnit distanceUnit);
    protected virtual string GetWellKnownTextCore(RingOrder outerRingOrder);
    protected virtual WellKnownType GetWellKnownTypeCore();
    protected virtual void LoadFromWellKnownDataCore(string wellKnownText);
    protected virtual void LoadFromWellKnownDataCore(Byte[] wellKnownBinary);
    private static void Yhw=(MultipointShape fromMultipoint, MultipointShape toMultipoint);
    protected virtual ShapeValidationResult ValidateCore(ShapeValidationMode validationMode);
    protected virtual MultipointShape GetCrossingCore(BaseShape targetShape);
    public static bool RemoveVertex(Vertex selectedVertex, MultipointShape multipointShape);
    public bool RemoveVertex(Vertex selectedVertex);
    private static RectangleShape Yxw=(IEnumerable`1<PointShape> points);
}
[TypeConverterAttribute("ThinkGeo.Core.BaseShapeTypeConverter")]
public class ThinkGeo.Core.MultipolygonShape : AreaBaseShape {
    [ObfuscationAttribute]
private Collection`1<PolygonShape> polygons;
    public Collection`1<PolygonShape> Polygons { get; }
    public MultipolygonShape(IEnumerable`1<PolygonShape> polygons);
    public MultipolygonShape(string wellKnownText);
    public MultipolygonShape(Byte[] wellKnownBinary);
    public Collection`1<PolygonShape> get_Polygons();
    protected virtual BaseShape CloneDeepCore();
    protected virtual double GetPerimeterCore(GeographyUnit shapeUnit, DistanceUnit returningUnit);
    protected virtual double GetAreaCore(GeographyUnit shapeUnit, AreaUnit returningUnit);
    protected virtual void ScaleUpCore(double percentage);
    protected virtual void ScaleDownCore(double percentage);
    protected virtual BaseShape RegisterCore(PointShape fromPoint, PointShape toPoint, DistanceUnit fromUnit, GeographyUnit toUnit);
    protected virtual void TranslateByOffsetCore(double xOffsetDistance, double yOffsetDistance, GeographyUnit shapeUnit, DistanceUnit distanceUnit);
    protected virtual void TranslateByDegreeCore(double distance, double angleInDegrees, GeographyUnit shapeUnit, DistanceUnit distanceUnit);
    protected virtual void RotateCore(PointShape pivotPoint, double degreeAngle);
    protected virtual PointShape GetClosestPointToCore(BaseShape targetShape, GeographyUnit shapeUnit);
    protected virtual double GetDistanceToCore(BaseShape targetShape, GeographyUnit shapeUnit, DistanceUnit distanceUnit);
    protected virtual string GetWellKnownTextCore(RingOrder outerRingOrder);
    protected virtual WellKnownType GetWellKnownTypeCore();
    protected virtual Byte[] GetWellKnownBinaryCore(RingOrder outerRingOrder, WkbByteOrder byteOrder);
    private static void ZBw=(RingShape targetRingShape, WkbByteOrder byteOrder, BinaryWriter writer);
    protected virtual void LoadFromWellKnownDataCore(string wellKnownText);
    protected virtual void LoadFromWellKnownDataCore(Byte[] wellKnownBinary);
    protected virtual RectangleShape GetBoundingBoxCore();
    private static void ZRw=(MultipolygonShape fromMultipolygon, MultipolygonShape toMultipolygon);
    protected virtual ShapeValidationResult ValidateCore(ShapeValidationMode validationMode);
    protected virtual MultipointShape GetCrossingCore(BaseShape targetShape);
    protected virtual bool ContainsCore(BaseShape targetShape);
    public static bool RemoveVertex(Vertex selectedVertex, MultipolygonShape multipolygonShape);
    public bool RemoveVertex(Vertex selectedVertex);
    public MultilineShape ToMultiLineShape();
    private static void Zhw=(RingShape targetRingShape, WkbByteOrder byteOrder, BinaryWriter writer);
    private void Zxw=(string wellKnownText);
    private void aBw=(Byte[] wellKnownBinary);
    internal void TRU=(double multiplicator);
    private static RectangleShape WRw=(IEnumerable`1<Vertex> vertices);
}
public class ThinkGeo.Core.NativeImageRasterLayer : RasterLayer {
    public bool HasBoundingBox { get; }
    public string ImagePathFilename { get; public set; }
    public NativeImageRasterLayer(string imagePathFilename);
    public NativeImageRasterLayer(string imagePathFilename, string worldfilePathFilename);
    public NativeImageRasterLayer(string imagePathFilename, RectangleShape imageExtent);
    public void add_StreamLoading(EventHandler`1<StreamLoadingEventArgs> value);
    public void remove_StreamLoading(EventHandler`1<StreamLoadingEventArgs> value);
    public virtual bool get_HasBoundingBox();
    public string get_ImagePathFilename();
    public void set_ImagePathFilename(string value);
}
public class ThinkGeo.Core.NativeImageRasterSource : RasterSource {
    [ObfuscationAttribute]
private static int smallestSizeForTemplate;
    [ObfuscationAttribute]
private GeoImage bufferBitmap;
    [ObfuscationAttribute]
private RectangleShape imageExtent;
    [ObfuscationAttribute]
private string imagePathFilename;
    [ObfuscationAttribute]
private WorldFile worldFile;
    [ObfuscationAttribute]
private string worldFilePathFilename;
    [CompilerGeneratedAttribute]
private EventHandler`1<StreamLoadingEventArgs> Eh8=;
    public bool IsNegative { get; public set; }
    public bool IsGrayscale { get; public set; }
    public string FileName { get; }
    public string FilePath { get; }
    public string ImagePathFilename { get; public set; }
    public NativeImageRasterSource(string imagePathFilename);
    public NativeImageRasterSource(string imagePathFilename, string worldfilePathFilename);
    public NativeImageRasterSource(string imagePathFilename, RectangleShape imageExtent);
    public bool get_IsNegative();
    public void set_IsNegative(bool value);
    public bool get_IsGrayscale();
    public void set_IsGrayscale(bool value);
    public string get_FileName();
    public string get_FilePath();
    public string get_ImagePathFilename();
    public void set_ImagePathFilename(string value);
    [CompilerGeneratedAttribute]
public void add_StreamLoading(EventHandler`1<StreamLoadingEventArgs> value);
    [CompilerGeneratedAttribute]
public void remove_StreamLoading(EventHandler`1<StreamLoadingEventArgs> value);
    protected virtual void OnStreamLoading(StreamLoadingEventArgs e);
    protected virtual int GetImageWidthCore();
    protected virtual int GetImageHeightCore();
    private static WorldFile hyM=(string worldFilePath);
    private static WorldFile iCM=(Stream stream);
    protected virtual void OpenCore();
    protected virtual void CloseCore();
    protected virtual GeoImage GetImageCore(RectangleShape worldExtent, int canvasWidth, int canvasHeight);
    protected virtual RectangleShape GetBoundingBoxCore();
    private static DrawingRectangle iSM=(float bmpWidth, float bmpHeight, RectangleShape sourceRectangleInWorld, RectangleShape boundingBox);
    private RectangleShape iiM=();
}
[ObfuscationAttribute]
internal class ThinkGeo.Core.NauticalMilesValues : ValueType {
    [ObfuscationAttribute]
private double v01;
    [ObfuscationAttribute]
private double v02;
    [ObfuscationAttribute]
private double v03;
    [ObfuscationAttribute]
private double v04;
    [ObfuscationAttribute]
private double v05;
    [ObfuscationAttribute]
private double v1;
    [ObfuscationAttribute]
private double v10;
    [ObfuscationAttribute]
private double v100;
    [ObfuscationAttribute]
private double v1000;
    [ObfuscationAttribute]
private double v2;
    [ObfuscationAttribute]
private double v20;
    [ObfuscationAttribute]
private double v200;
    [ObfuscationAttribute]
private double v3;
    [ObfuscationAttribute]
private double v30;
    [ObfuscationAttribute]
private double v300;
    [ObfuscationAttribute]
private double v4;
    [ObfuscationAttribute]
private double v40;
    [ObfuscationAttribute]
private double v400;
    [ObfuscationAttribute]
private double v5;
    [ObfuscationAttribute]
private double v50;
    [ObfuscationAttribute]
private double v500;
    public double TCE= { get; }
    public double TiE= { get; }
    public double UCE= { get; }
    public double UiE= { get; }
    public double VCE= { get; }
    public double QCE= { get; }
    public double QiE= { get; }
    public double RCE= { get; }
    public double RiE= { get; }
    public double SCE= { get; }
    public double KCE= { get; }
    public double KiE= { get; }
    public double LCE= { get; }
    public double LiE= { get; }
    public double MCE= { get; }
    public double MiE= { get; }
    public double NCE= { get; }
    public double NiE= { get; }
    public double OCE= { get; }
    public double OiE= { get; }
    public double PCE= { get; }
    public NauticalMilesValues(int width, double extentLengthBar, DistanceUnit distanceUnit);
    public double SyE=();
    public double TSE=();
    public double TyE=();
    public double USE=();
    public double UyE=();
    public double PyE=();
    public double QSE=();
    public double QyE=();
    public double RSE=();
    public double RyE=();
    public double JyE=();
    public double KSE=();
    public double KyE=();
    public double LSE=();
    public double LyE=();
    public double MSE=();
    public double MyE=();
    public double NSE=();
    public double NyE=();
    public double OSE=();
    public double OyE=();
}
public class ThinkGeo.Core.NoaaWeatherStation : object {
    [CompilerGeneratedAttribute]
private string nCM=;
    [CompilerGeneratedAttribute]
private string 3B0=;
    [CompilerGeneratedAttribute]
private string nSM=;
    [CompilerGeneratedAttribute]
private string niM=;
    [CompilerGeneratedAttribute]
private double nyM=;
    [CompilerGeneratedAttribute]
private double oCM=;
    [CompilerGeneratedAttribute]
private double oSM=;
    [CompilerGeneratedAttribute]
private NoaaWeatherStationSiteType oiM=;
    [CompilerGeneratedAttribute]
private string oyM=;
    [CompilerGeneratedAttribute]
private string pCM=;
    [XmlElementAttribute]
public string StationId { get; public set; }
    [XmlElementAttribute]
public string Name { get; public set; }
    [XmlElementAttribute]
public string State { get; public set; }
    [XmlElementAttribute]
public string Country { get; public set; }
    [XmlElementAttribute]
public double Latitude { get; public set; }
    [XmlElementAttribute]
public double Longitude { get; public set; }
    [XmlElementAttribute]
public double Elevation { get; public set; }
    [XmlElementAttribute]
public NoaaWeatherStationSiteType SiteType { get; public set; }
    public string Description { get; public set; }
    public string Temperature { get; public set; }
    [CompilerGeneratedAttribute]
public string get_StationId();
    [CompilerGeneratedAttribute]
public void set_StationId(string value);
    [CompilerGeneratedAttribute]
public string get_Name();
    [CompilerGeneratedAttribute]
public void set_Name(string value);
    [CompilerGeneratedAttribute]
public string get_State();
    [CompilerGeneratedAttribute]
public void set_State(string value);
    [CompilerGeneratedAttribute]
public string get_Country();
    [CompilerGeneratedAttribute]
public void set_Country(string value);
    [CompilerGeneratedAttribute]
public double get_Latitude();
    [CompilerGeneratedAttribute]
public void set_Latitude(double value);
    [CompilerGeneratedAttribute]
public double get_Longitude();
    [CompilerGeneratedAttribute]
public void set_Longitude(double value);
    [CompilerGeneratedAttribute]
public double get_Elevation();
    [CompilerGeneratedAttribute]
public void set_Elevation(double value);
    [CompilerGeneratedAttribute]
public NoaaWeatherStationSiteType get_SiteType();
    [CompilerGeneratedAttribute]
public void set_SiteType(NoaaWeatherStationSiteType value);
    [CompilerGeneratedAttribute]
public string get_Description();
    [CompilerGeneratedAttribute]
public void set_Description(string value);
    [CompilerGeneratedAttribute]
public string get_Temperature();
    [CompilerGeneratedAttribute]
public void set_Temperature(string value);
    public Feature ToFeature();
    public void FillDescriptionAndTemperature();
    private static string pSM=(string celsiusString);
}
public class ThinkGeo.Core.NoaaWeatherStationFeatureLayer : FeatureLayer {
}
public class ThinkGeo.Core.NoaaWeatherStationFeatureSource : FeatureSource {
    private Dictionary`2<string, Feature> lCM=;
    private Dictionary`2<string, NoaaWeatherStation> lSM=;
    private STRtree`1<string> ZCA=;
    [CompilerGeneratedAttribute]
private int CR4=;
    public int TimeoutInSeconds { get; public set; }
    [CompilerGeneratedAttribute]
public int get_TimeoutInSeconds();
    [CompilerGeneratedAttribute]
public void set_TimeoutInSeconds(int value);
    protected virtual void OpenCore();
    private static STRtree`1<string> liM=(Dictionary`2<string, Feature> stationsCache);
    protected virtual Collection`1<Feature> GetAllFeaturesCore(IEnumerable`1<string> returningColumnNames);
    protected virtual Collection`1<FeatureSourceColumn> GetColumnsCore();
    protected virtual long GetCountCore();
    protected virtual Collection`1<Feature> GetFeaturesInsideBoundingBoxCore(RectangleShape boundingBox, IEnumerable`1<string> returningColumnNames);
    public void UpdateWeatherStations();
    public Dictionary`2<string, Feature> GetStationFeatures();
    private Dictionary`2<string, NoaaWeatherStation> lyM=();
    private void mCM=(Uri cycleUri);
    private static Collection`1<Uri> mSM=();
}
[XmlRootAttribute]
public class ThinkGeo.Core.NoaaWeatherStationResponse : object {
    [CompilerGeneratedAttribute]
private double miM=;
    [CompilerGeneratedAttribute]
private List`1<NoaaWeatherStation> myM=;
    [XmlElementAttribute]
public double RequestIndex { get; public set; }
    [XmlArrayAttribute("data")]
[XmlArrayItemAttribute("Station", "ThinkGeo.Core.NoaaWeatherStation")]
public List`1<NoaaWeatherStation> Stations { get; public set; }
    [CompilerGeneratedAttribute]
public double get_RequestIndex();
    [CompilerGeneratedAttribute]
public void set_RequestIndex(double value);
    [CompilerGeneratedAttribute]
public List`1<NoaaWeatherStation> get_Stations();
    [CompilerGeneratedAttribute]
public void set_Stations(List`1<NoaaWeatherStation> value);
    public static NoaaWeatherStationResponse DownloadNoaaWeatherStationResponse();
}
public class ThinkGeo.Core.NoaaWeatherStationSiteType : object {
    [CompilerGeneratedAttribute]
private string piM=;
    [CompilerGeneratedAttribute]
private string pyM=;
    [CompilerGeneratedAttribute]
private string qCM=;
    [CompilerGeneratedAttribute]
private string qSM=;
    [CompilerGeneratedAttribute]
private string qiM=;
    [XmlElementAttribute("METAR")]
public string Metar { get; public set; }
    [XmlElementAttribute("TAF")]
public string Taf { get; public set; }
    [XmlElementAttribute("rawinsonde")]
public string Rawinsonde { get; public set; }
    [XmlElementAttribute("WFO_office")]
public string WfoOffice { get; public set; }
    [XmlElementAttribute("NEXRAD")]
public string Nexrad { get; public set; }
    [CompilerGeneratedAttribute]
public string get_Metar();
    [CompilerGeneratedAttribute]
public void set_Metar(string value);
    [CompilerGeneratedAttribute]
public string get_Taf();
    [CompilerGeneratedAttribute]
public void set_Taf(string value);
    [CompilerGeneratedAttribute]
public string get_Rawinsonde();
    [CompilerGeneratedAttribute]
public void set_Rawinsonde(string value);
    [CompilerGeneratedAttribute]
public string get_WfoOffice();
    [CompilerGeneratedAttribute]
public void set_WfoOffice(string value);
    [CompilerGeneratedAttribute]
public string get_Nexrad();
    [CompilerGeneratedAttribute]
public void set_Nexrad(string value);
    public int GetPriority();
}
public class ThinkGeo.Core.NoaaWeatherStationStyle : Style {
    private Dictionary`2<string, GeoImage> sSM=;
    protected virtual void DrawCore(IEnumerable`1<Feature> features, GeoCanvas canvas, Collection`1<SimpleCandidate> labelsInThisLayer, Collection`1<SimpleCandidate> labelsInAllLayers);
    protected virtual void DrawSampleCore(GeoCanvas canvas, DrawingRectangleF drawingExtent);
    private void siM=();
    private static void syM=(Feature feature, Collection`1<RectangleShape> recordsDrawn, GeoCanvas canvas, GeoImage image, double x, double y, DrawingLevel drawingLevel, float xOffset, float yOffset, float rotationAngle);
    protected virtual Collection`1<string> GetRequiredColumnNamesCore();
    protected virtual override void Finalize();
}
public class ThinkGeo.Core.NoaaWeatherWarningsFeatureLayer : FeatureLayer {
}
public class ThinkGeo.Core.NoaaWeatherWarningsFeatureSource : FeatureSource {
    private TinyGeoFeatureSource qyM=;
    private Dictionary`2<string, List`1<Dictionary`2<string, string>>> rCM=;
    protected virtual void OpenCore();
    private Dictionary`2<string, List`1<Dictionary`2<string, string>>> rSM=();
    private void riM=(XmlNode warningEntry, XmlNamespaceManager nsmgr, TinyGeoFeatureSource countiesFeatureSource, Dictionary`2<string, List`1<Dictionary`2<string, string>>> warnings, Dictionary`2<string, string> fipsToFeatureIds);
    protected virtual void CloseCore();
    protected virtual Collection`1<FeatureSourceColumn> GetColumnsCore();
    protected virtual Collection`1<Feature> GetAllFeaturesCore(IEnumerable`1<string> returningColumnNames);
    protected virtual long GetCountCore();
    protected virtual RectangleShape GetBoundingBoxCore();
    protected virtual Collection`1<Feature> GetFeaturesInsideBoundingBoxCore(RectangleShape boundingBox, IEnumerable`1<string> returningColumnNames);
    private TinyGeoFeatureSource ryM=();
    private void sCM=(object sender, StreamLoadingEventArgs e);
}
public class ThinkGeo.Core.NoaaWeatherWarningsStyle : ValueStyle {
    protected virtual void DrawCore(IEnumerable`1<Feature> features, GeoCanvas canvas, Collection`1<SimpleCandidate> labelsInThisLayer, Collection`1<SimpleCandidate> labelsInAllLayers);
    protected virtual Collection`1<string> GetRequiredColumnNamesCore();
    private void tCM=();
}
[AttributeUsageAttribute("4124")]
public class ThinkGeo.Core.NonSerializableBaseTypeAttribute : Attribute {
}
public class ThinkGeo.Core.OgcApiFeatureLayer : FeatureLayer {
    public string Url { get; public set; }
    public int BulkSize { get; public set; }
    public string CollectionId { get; public set; }
    public int TimeoutInSeconds { get; public set; }
    public bool HasBoundingBox { get; }
    public IWebProxy WebProxy { get; public set; }
    public OgcApiFeatureLayer(string url, string collectionId, int bulkSize);
    public string get_Url();
    public void set_Url(string value);
    public int get_BulkSize();
    public void set_BulkSize(int value);
    public string get_CollectionId();
    public void set_CollectionId(string value);
    public int get_TimeoutInSeconds();
    public void set_TimeoutInSeconds(int value);
    public virtual bool get_HasBoundingBox();
    public IWebProxy get_WebProxy();
    public void set_WebProxy(IWebProxy value);
    public void add_SendingWebRequest(EventHandler`1<SendingWebRequestEventArgs> value);
    public void remove_SendingWebRequest(EventHandler`1<SendingWebRequestEventArgs> value);
    public void add_SentWebRequest(EventHandler`1<SentWebRequestEventArgs> value);
    public void remove_SentWebRequest(EventHandler`1<SentWebRequestEventArgs> value);
    public Collection`1<string> GetLayers();
}
public class ThinkGeo.Core.OgcApiFeatureSource : FeatureSource {
    private static string 0yM=;
    private Collection`1<FeatureSourceColumn> 1CM=;
    [ObfuscationAttribute]
private Collection`1<string> layers;
    [ObfuscationAttribute]
private xSM= ogcApiFeatureCollection;
    [CompilerGeneratedAttribute]
private EventHandler`1<SendingWebRequestEventArgs> whQ=;
    [CompilerGeneratedAttribute]
private EventHandler`1<SentWebRequestEventArgs> wxQ=;
    [CompilerGeneratedAttribute]
private string 1SM=;
    [CompilerGeneratedAttribute]
private string 1iM=;
    [CompilerGeneratedAttribute]
private int 1yM=;
    [CompilerGeneratedAttribute]
private int CR4=;
    [CompilerGeneratedAttribute]
private IWebProxy Ch4=;
    [CompilerGeneratedAttribute]
private EventHandler`1<RequestingDataWfsFeatureSourceEventArgs> 2CM=;
    [CompilerGeneratedAttribute]
private EventHandler`1<RequestedDataWfsFeatureSourceEventArgs> 2SM=;
    public string Url { get; public set; }
    public string CollectionId { get; public set; }
    public int BulkSize { get; public set; }
    public int TimeoutInSeconds { get; public set; }
    public IWebProxy WebProxy { get; public set; }
    public OgcApiFeatureSource(string url, string collectionId, int bulkSize);
    [CompilerGeneratedAttribute]
public void add_SendingWebRequest(EventHandler`1<SendingWebRequestEventArgs> value);
    [CompilerGeneratedAttribute]
public void remove_SendingWebRequest(EventHandler`1<SendingWebRequestEventArgs> value);
    [CompilerGeneratedAttribute]
public void add_SentWebRequest(EventHandler`1<SentWebRequestEventArgs> value);
    [CompilerGeneratedAttribute]
public void remove_SentWebRequest(EventHandler`1<SentWebRequestEventArgs> value);
    protected virtual bool CanGetBoundingBoxQuicklyCore();
    [CompilerGeneratedAttribute]
public string get_Url();
    [CompilerGeneratedAttribute]
public void set_Url(string value);
    [CompilerGeneratedAttribute]
public string get_CollectionId();
    [CompilerGeneratedAttribute]
public void set_CollectionId(string value);
    [CompilerGeneratedAttribute]
public int get_BulkSize();
    [CompilerGeneratedAttribute]
public void set_BulkSize(int value);
    [CompilerGeneratedAttribute]
public int get_TimeoutInSeconds();
    [CompilerGeneratedAttribute]
public void set_TimeoutInSeconds(int value);
    [CompilerGeneratedAttribute]
public IWebProxy get_WebProxy();
    [CompilerGeneratedAttribute]
public void set_WebProxy(IWebProxy value);
    [CompilerGeneratedAttribute]
public void add_RequestingData(EventHandler`1<RequestingDataWfsFeatureSourceEventArgs> value);
    [CompilerGeneratedAttribute]
public void remove_RequestingData(EventHandler`1<RequestingDataWfsFeatureSourceEventArgs> value);
    protected virtual void OnRequestingData(RequestingDataWfsFeatureSourceEventArgs requestingDataWfsFeatureSourceEventArgs);
    [CompilerGeneratedAttribute]
public void add_RequestedData(EventHandler`1<RequestedDataWfsFeatureSourceEventArgs> value);
    [CompilerGeneratedAttribute]
public void remove_RequestedData(EventHandler`1<RequestedDataWfsFeatureSourceEventArgs> value);
    protected virtual void OnRequestedData(RequestedDataWfsFeatureSourceEventArgs requestedDataWfsFeatureSourceEventArgs);
    protected WebResponse SendWebRequest(WebRequest webRequest);
    protected virtual WebResponse SendWebRequestCore(WebRequest webRequest);
    protected virtual void OnSendingWebRequest(SendingWebRequestEventArgs e);
    protected virtual void OnSentWebRequest(SentWebRequestEventArgs e);
    public string GetCapabilities();
    private string 2iM=(string requestString);
    private static void aR4=(string requestCapabilities, string jsonString);
    private static string 2yM=(string requestCapabilities);
    public Collection`1<string> GetLayers();
    protected virtual void OpenCore();
    protected virtual void CloseCore();
    protected virtual RectangleShape GetBoundingBoxCore();
    protected virtual Collection`1<FeatureSourceColumn> GetColumnsCore();
    protected virtual Collection`1<Feature> GetFeaturesByIdsCore(IEnumerable`1<string> ids, IEnumerable`1<string> returningColumnNames);
    protected virtual WellKnownType GetFirstFeaturesWellKnownTypeCore();
    protected virtual Collection`1<Feature> GetAllFeaturesCore(IEnumerable`1<string> returningColumnNames);
    protected virtual Collection`1<Feature> GetFeaturesInsideBoundingBoxCore(RectangleShape boundingBox, IEnumerable`1<string> returningColumnNames);
    public string GetRequestUrlForFeatures(RectangleShape boundingBox, Nullable`1<int> limit);
    public ValueTuple`2<string, Collection`1<Feature>> GetFeatures(string requestFeaturesUrl);
    public Collection`1<string> GetSupportedCrs();
    public string GetDefaultCrs();
    private static string 3CM=(string crs);
    private Collection`1<Feature> 3SM=(string requestFeaturesUrl);
    protected virtual Collection`1<Feature> GetFeaturesByColumnValueCore(string columnName, string columnValue, IEnumerable`1<string> returningColumnNames);
    [CompilerGeneratedAttribute]
private bool 3iM=(vCM= col);
    [CompilerGeneratedAttribute]
private bool 3yM=(vCM= c);
    [CompilerGeneratedAttribute]
private bool 4CM=(vCM= col);
}
[AttributeUsageAttribute("64")]
public class ThinkGeo.Core.OnGeodeserializedAttribute : Attribute {
}
[AttributeUsageAttribute("64")]
public class ThinkGeo.Core.OnGeodeserializingAttribute : Attribute {
}
[AttributeUsageAttribute("64")]
public class ThinkGeo.Core.OnGeoserializedAttribute : Attribute {
}
[AttributeUsageAttribute("64")]
public class ThinkGeo.Core.OnGeoserializingAttribute : Attribute {
}
public class ThinkGeo.Core.OpenedFeatureSourceEventArgs : EventArgs {
}
public class ThinkGeo.Core.OpenedRasterSourceEventArgs : EventArgs {
}
public class ThinkGeo.Core.OpeningFeatureSourceEventArgs : EventArgs {
}
public class ThinkGeo.Core.OpeningRasterSourceEventArgs : EventArgs {
}
public class ThinkGeo.Core.OpenStreetMapAsyncLayer : XyzTileAsyncLayer {
    [ObfuscationAttribute]
private static int TILE_SIZE;
    [ObfuscationAttribute]
private static Uri[] DefaultUris;
    [ObfuscationAttribute]
private Collection`1<Uri> customServerUris;
    public Collection`1<Uri> CustomServerUris { get; }
    public OpenStreetMapAsyncLayer(string userAgent);
    public OpenStreetMapAsyncLayer(IWebProxy webProxy);
    public OpenStreetMapAsyncLayer(string userAgent, IWebProxy webProxy);
    private static OpenStreetMapAsyncLayer();
    [AsyncStateMachineAttribute("ThinkGeo.Core.OpenStreetMapAsyncLayer/NT8=")]
protected virtual Task OpenAsyncCore(CancellationToken cancellationToken);
    public Collection`1<Uri> get_CustomServerUris();
    protected virtual Task`1<string> GetImageUriAsyncCore(int zoomLevel, long x, long y, float resolutionFactor);
    [DebuggerHiddenAttribute]
[CompilerGeneratedAttribute]
private Task Ah4=(CancellationToken cancellationToken);
}
public class ThinkGeo.Core.OpenStreetMapsZoomLevelSet : ZoomLevelSet {
}
public class ThinkGeo.Core.OsmBuildingAreaStyle : BuildingAreaStyle {
    private string tDE=;
    private double tTE=;
    public string LevelColumnName { get; public set; }
    public double LevelHeightInMeters { get; public set; }
    public OsmBuildingAreaStyle(string levelColumnName);
    public OsmBuildingAreaStyle(string levelColumnName, double levelHeightInMeters);
    public string get_LevelColumnName();
    public void set_LevelColumnName(string value);
    public double get_LevelHeightInMeters();
    public void set_LevelHeightInMeters(double value);
    protected virtual Collection`1<string> GetRequiredColumnNamesCore();
    protected virtual double GetHeightInMeters(Feature feature);
}
public class ThinkGeo.Core.OsmBuildingOnlineFeatureLayer : FeatureLayer {
    public FileVectorTileCache TileCache { get; public set; }
    public void add_SendingWebRequest(EventHandler`1<SendingWebRequestEventArgs> value);
    public void remove_SendingWebRequest(EventHandler`1<SendingWebRequestEventArgs> value);
    public void add_SentWebRequest(EventHandler`1<SentWebRequestEventArgs> value);
    public void remove_SentWebRequest(EventHandler`1<SentWebRequestEventArgs> value);
    public FileVectorTileCache get_TileCache();
    public void set_TileCache(FileVectorTileCache value);
}
public class ThinkGeo.Core.OsmBuildingOnlineFeatureSource : FeatureSource {
    private static Collection`1<string> 6SM=;
    private 4SM= 6iM=;
    [ObfuscationAttribute]
private FileVectorTileCache tileCache;
    [CompilerGeneratedAttribute]
private EventHandler`1<SendingWebRequestEventArgs> whQ=;
    [CompilerGeneratedAttribute]
private EventHandler`1<SentWebRequestEventArgs> wxQ=;
    public FileVectorTileCache TileCache { get; public set; }
    private static OsmBuildingOnlineFeatureSource();
    [CompilerGeneratedAttribute]
public void add_SendingWebRequest(EventHandler`1<SendingWebRequestEventArgs> value);
    [CompilerGeneratedAttribute]
public void remove_SendingWebRequest(EventHandler`1<SendingWebRequestEventArgs> value);
    [CompilerGeneratedAttribute]
public void add_SentWebRequest(EventHandler`1<SentWebRequestEventArgs> value);
    [CompilerGeneratedAttribute]
public void remove_SentWebRequest(EventHandler`1<SentWebRequestEventArgs> value);
    public FileVectorTileCache get_TileCache();
    public void set_TileCache(FileVectorTileCache value);
    protected virtual Collection`1<Feature> GetAllFeaturesCore(IEnumerable`1<string> returningColumnNames);
    protected virtual Collection`1<Feature> GetFeaturesByIdsCore(IEnumerable`1<string> ids, IEnumerable`1<string> returningColumnNames);
    protected virtual Collection`1<Feature> GetFeaturesInsideBoundingBoxCore(RectangleShape boundingBox, IEnumerable`1<string> returningColumnNames);
    internal ScreenPointF 6yM=(double lon, double lat, int zoom);
    private Byte[] 7CM=(string requestingUri);
    protected WebResponse SendWebRequest(WebRequest webRequest);
    protected virtual void OnSendingWebRequest(SendingWebRequestEventArgs e);
    protected virtual void OnSentWebRequest(SentWebRequestEventArgs e);
    protected virtual WebResponse SendWebRequestCore(WebRequest webRequest);
}
public enum ThinkGeo.Core.OverwriteMode : Enum {
    public int value__;
    public static OverwriteMode Overwrite;
    public static OverwriteMode DoNotOverwrite;
}
public enum ThinkGeo.Core.PanDirection : Enum {
    public int value__;
    public static PanDirection Up;
    public static PanDirection UpperRight;
    public static PanDirection Right;
    public static PanDirection LowerRight;
    public static PanDirection Down;
    public static PanDirection LowerLeft;
    public static PanDirection Left;
    public static PanDirection UpperLeft;
}
public class ThinkGeo.Core.PbfLayer : object {
    [CompilerGeneratedAttribute]
private string 3B0=;
    [CompilerGeneratedAttribute]
private ulong DRQ=;
    [CompilerGeneratedAttribute]
private List`1<string> 4ys=;
    [CompilerGeneratedAttribute]
private ulong wCM=;
    [CompilerGeneratedAttribute]
private List`1<object> 5Cs=;
    [CompilerGeneratedAttribute]
private List`1<Byte[]> 5Ss=;
    public string Name { get; private set; }
    public ulong Version { get; private set; }
    public List`1<string> Keys { get; private set; }
    internal ulong 6Cs= { get; private set; }
    internal List`1<object> tyE= { get; private set; }
    internal List`1<Byte[]> 7Cs= { get; internal set; }
    public PbfLayer(Byte[] data);
    [CompilerGeneratedAttribute]
public string get_Name();
    [CompilerGeneratedAttribute]
private void set_Name(string value);
    [CompilerGeneratedAttribute]
public ulong get_Version();
    [CompilerGeneratedAttribute]
private void set_Version(ulong value);
    [CompilerGeneratedAttribute]
public List`1<string> get_Keys();
    [CompilerGeneratedAttribute]
private void set_Keys(List`1<string> value);
    [CompilerGeneratedAttribute]
internal ulong 5is=();
    [CompilerGeneratedAttribute]
private void 5ys=(ulong value);
    [CompilerGeneratedAttribute]
internal List`1<object> tiE=();
    [CompilerGeneratedAttribute]
private void 6Ss=(List`1<object> value);
    [CompilerGeneratedAttribute]
internal List`1<Byte[]> 6is=();
    [CompilerGeneratedAttribute]
internal void 6ys=(List`1<Byte[]> value);
    internal ySs= 7Ss=(int featureIndex);
    private void 7is=(Byte[] data);
    private void 7ys=(Byte[] data);
}
public enum ThinkGeo.Core.PenBrushDrawingOrder : Enum {
    public int value__;
    public static PenBrushDrawingOrder BrushFirst;
    public static PenBrushDrawingOrder PenFirst;
}
public abstract class ThinkGeo.Core.PointBaseShape : BaseShape {
}
public abstract class ThinkGeo.Core.PointBaseStyle : Style {
    [ObfuscationAttribute]
private DrawingLevel drawingLevel;
    [ObfuscationAttribute]
private float rotationAngle;
    [ObfuscationAttribute]
private GeoPen symbolPen;
    [ObfuscationAttribute]
private float symbolSize;
    [ObfuscationAttribute]
private GeoBrush symbolBrush;
    [ObfuscationAttribute]
private float xOffsetInPixel;
    [ObfuscationAttribute]
private float yOffsetInPixel;
    [ObfuscationAttribute]
private Collection`1<PointBaseStyle> customPointStyles;
    public DrawingLevel DrawingLevel { get; public set; }
    public GeoBrush FillBrush { get; public set; }
    public GeoPen OutlinePen { get; public set; }
    public float SymbolSize { get; public set; }
    public float RotationAngle { get; public set; }
    public float XOffsetInPixel { get; public set; }
    public float YOffsetInPixel { get; public set; }
    public Collection`1<PointBaseStyle> CustomPointStyles { get; }
    protected PointBaseStyle(GeoBrush symbolBrush, int symbolSize);
    protected PointBaseStyle(GeoBrush symbolBrush, GeoPen symbolPen, int symbolSize);
    public DrawingLevel get_DrawingLevel();
    public void set_DrawingLevel(DrawingLevel value);
    public GeoBrush get_FillBrush();
    public void set_FillBrush(GeoBrush value);
    public GeoPen get_OutlinePen();
    public void set_OutlinePen(GeoPen value);
    public float get_SymbolSize();
    public void set_SymbolSize(float value);
    public float get_RotationAngle();
    public void set_RotationAngle(float value);
    public float get_XOffsetInPixel();
    public void set_XOffsetInPixel(float value);
    public float get_YOffsetInPixel();
    public void set_YOffsetInPixel(float value);
    public Collection`1<PointBaseStyle> get_CustomPointStyles();
    protected virtual void DrawSampleCore(GeoCanvas canvas, DrawingRectangleF drawingExtent);
}
public enum ThinkGeo.Core.PointLineRelationship : Enum {
    public int value__;
    public static PointLineRelationship Left;
    public static PointLineRelationship Right;
    public static PointLineRelationship OnLine;
}
[TypeConverterAttribute("ThinkGeo.Core.BaseShapeTypeConverter")]
public class ThinkGeo.Core.PointShape : PointBaseShape {
    [ObfuscationAttribute]
private double x;
    [ObfuscationAttribute]
private double y;
    [ObfuscationAttribute]
private double z;
    public double X { get; public set; }
    public double Y { get; public set; }
    public double Z { get; public set; }
    public PointShape(double x, double y);
    public PointShape(double x, double y, double z);
    public PointShape(Vertex vertex);
    public PointShape(string wellKnownText);
    public PointShape(Byte[] wellKnownBinary);
    public double get_X();
    public void set_X(double value);
    public double get_Y();
    public void set_Y(double value);
    public double get_Z();
    public void set_Z(double value);
    public bool Equal2D(PointShape targetShape);
    public bool Equal2D(Feature targetPointFeature);
    protected virtual BaseShape CloneDeepCore();
    protected virtual RectangleShape GetBoundingBoxCore();
    protected virtual BaseShape RegisterCore(PointShape fromPoint, PointShape toPoint, DistanceUnit fromUnit, GeographyUnit toUnit);
    protected virtual void TranslateByOffsetCore(double xOffsetDistance, double yOffsetDistance, GeographyUnit shapeUnit, DistanceUnit distanceUnit);
    protected virtual void TranslateByDegreeCore(double distance, double angleInDegrees, GeographyUnit shapeUnit, DistanceUnit distanceUnit);
    protected virtual void RotateCore(PointShape pivotPoint, double degreeAngle);
    protected virtual PointShape GetClosestPointToCore(BaseShape targetShape, GeographyUnit shapeUnit);
    protected virtual string GetWellKnownTextCore(RingOrder outerRingOrder);
    protected virtual WellKnownType GetWellKnownTypeCore();
    protected virtual void LoadFromWellKnownDataCore(string wellKnownText);
    protected virtual void LoadFromWellKnownDataCore(Byte[] wellKnownBinary);
    protected virtual ShapeValidationResult ValidateCore(ShapeValidationMode validationMode);
    public MultilineShape GreatCircle(PointShape pointShape);
    public MultilineShape GreatCircle(Feature pointFeature);
    protected virtual double GetDistanceToCore(BaseShape targetShape, GeographyUnit shapeUnit, DistanceUnit distanceUnit);
    protected virtual PointShape GetCenterPointCore();
    protected virtual MultipointShape GetCrossingCore(BaseShape targetShape);
    public virtual string ToString();
    protected virtual bool IsWithinCore(BaseShape targetShape);
    private double aRw=(RingShape ringShape, GeographyUnit shapeUnit, DistanceUnit distanceUnit);
    private double ahw=(MultipolygonShape multipolygonShape, GeographyUnit shapeUnit, DistanceUnit distanceUnit);
    private double axw=(MultipointShape targetShape, GeographyUnit shapeUnit, DistanceUnit distanceUnit);
    private double bBw=(MultilineShape targetShape, GeographyUnit shapeUnit, DistanceUnit distanceUnit);
    private double bRw=(LineShape targetShape, GeographyUnit shapeUnit, DistanceUnit distanceUnit);
    private double bhw=(RectangleShape rectangleShape, GeographyUnit shapeUnit, DistanceUnit distanceUnit);
    private double bxw=(PointShape targetShape, GeographyUnit shapeUnit, DistanceUnit distanceUnit);
    private double cBw=(PolygonShape polygonShape, GeographyUnit shapeUnit, DistanceUnit distanceUnit);
    private double cRw=(PointShape toPointShape);
    internal double chw=(double fromPointX, double fromPointY, double toPointX, double toPointY);
    internal PointShape cxw=(double fromX, double fromY, double toX, double toY);
    private PointShape dBw=(double offset, float degree);
}
public class ThinkGeo.Core.PointStyle : PointBaseStyle {
    private static int TSo=;
    private static int JxU=;
    private static int KRU=;
    private static int KhU=;
    private static int KxU=;
    private static int KBU=;
    private static double UCo=;
    private static int LhU=;
    private static int LBU=;
    private static int USo=;
    private static int Uio=;
    private static int Syo=;
    private static int TCo=;
    [ObfuscationAttribute]
private GeoFont glyphFont;
    [ObfuscationAttribute]
private GeoImage image;
    [ObfuscationAttribute]
private double imageScale;
    [ObfuscationAttribute]
private PointSymbolType symbolType;
    [ObfuscationAttribute]
private PointType pointType;
    [ObfuscationAttribute]
private AreaStyle mask;
    [ObfuscationAttribute]
private DrawingMargin maskMargin;
    [ObfuscationAttribute]
private MaskType maskType;
    [ObfuscationAttribute]
private string glyphContent;
    private static GeoFont LDE=;
    public PointType PointType { get; public set; }
    public GeoImage Image { get; public set; }
    public double ImageScale { get; public set; }
    public GeoFont GlyphFont { get; public set; }
    public string GlyphContent { get; public set; }
    public PointSymbolType SymbolType { get; public set; }
    public AreaStyle Mask { get; public set; }
    public DrawingMargin MaskMargin { get; public set; }
    public MaskType MaskType { get; public set; }
    internal bool phU= { get; }
    public PointStyle(GeoImage image);
    public PointStyle(GeoFont glyphFont, string glyphContent, GeoBrush fillBrush);
    public PointStyle(GeoFont glyphFont, string glyphContent, GeoBrush fillBrush, GeoPen outlinePen);
    public PointStyle(PointSymbolType symbolType, int symbolSize, GeoBrush fillBrush);
    public PointStyle(PointSymbolType symbolType, int symbolSize, GeoBrush fillBrush, GeoPen outlinePen);
    private PointStyle(GeoImage image, GeoFont glyphFont, PointType pointType, PointSymbolType pointSymbolType, GeoBrush geoBrush, GeoPen symbolPen, int symbolSize);
    private static PointStyle();
    public PointType get_PointType();
    public void set_PointType(PointType value);
    public GeoImage get_Image();
    public void set_Image(GeoImage value);
    public double get_ImageScale();
    public void set_ImageScale(double value);
    public GeoFont get_GlyphFont();
    public void set_GlyphFont(GeoFont value);
    public string get_GlyphContent();
    public void set_GlyphContent(string value);
    public PointSymbolType get_SymbolType();
    public void set_SymbolType(PointSymbolType value);
    public AreaStyle get_Mask();
    public void set_Mask(AreaStyle value);
    public DrawingMargin get_MaskMargin();
    public void set_MaskMargin(DrawingMargin value);
    public MaskType get_MaskType();
    public void set_MaskType(MaskType value);
    public static PointStyle Parse(string styleJson);
    internal static PointStyle kxU=(JObject jObject);
    public static PointStyle CreateSimplePointStyle(PointSymbolType pointStyle, GeoColor fillColor, float size);
    public static PointStyle CreateSimplePointStyle(PointSymbolType pointStyle, GeoColor fillColor, GeoColor outlineColor, float outlineWidth, float size);
    public static PointStyle CreateSimplePointStyle(PointSymbolType pointStyle, GeoColor fillColor, GeoColor outlineColor, float size);
    public static PointStyle CreateSimpleCircleStyle(GeoColor fillColor, float size);
    public static PointStyle CreateSimpleCircleStyle(GeoColor fillColor, float size, GeoColor outlineColor, float outlineWidth);
    public static PointStyle CreateSimpleCircleStyle(GeoColor fillColor, float size, GeoColor outlineColor);
    public static PointStyle CreateSimpleSquareStyle(GeoColor fillColor, float size);
    public static PointStyle CreateSimpleSquareStyle(GeoColor fillColor, float size, GeoColor outlineColor);
    public static PointStyle CreateSimpleSquareStyle(GeoColor fillColor, float size, GeoColor outlineColor, float outlineWidth);
    public static PointStyle CreateSimpleStarStyle(GeoColor fillColor, float size);
    public static PointStyle CreateSimpleStarStyle(GeoColor fillColor, float size, GeoColor outlineColor);
    public static PointStyle CreateSimpleStarStyle(GeoColor fillColor, float size, GeoColor outlineColor, float outlineWidth);
    public static PointStyle CreateSimpleTriangleStyle(GeoColor fillColor, float size);
    public static PointStyle CreateSimpleTriangleStyle(GeoColor fillColor, float size, GeoColor outlineColor);
    public static PointStyle CreateSimpleTriangleStyle(GeoColor fillColor, float size, GeoColor outlineColor, float outlineWidth);
    public static PointStyle CreateCompoundCircleStyle(GeoColor fillColor1, float size1, GeoColor outlineColor1, float outlineWidth1, GeoColor fillColor2, float size2);
    public static PointStyle CreateCompoundCircleStyle(GeoColor fillColor1, float size1, GeoColor outlineColor1, float outlineWidth1, GeoColor fillColor2, float size2, GeoColor outlineColor2, float outlineWidth2);
    public static PointStyle CreateCompoundPointStyle(PointSymbolType pointStyle1, GeoColor fillColor1, GeoColor outlineColor1, float outlineWidth1, float size1, PointSymbolType pointStyle2, GeoColor fillColor2, GeoColor outlineColor2, float outlineWidth2, float size2);
    internal virtual bool pBU=();
    protected virtual void DrawCore(IEnumerable`1<Feature> features, GeoCanvas canvas, Collection`1<SimpleCandidate> labelsInThisLayer, Collection`1<SimpleCandidate> labelsInAllLayers);
    protected virtual void DrawSampleCore(GeoCanvas canvas, DrawingRectangleF drawingExtent);
    protected void DrawSymbol(PointSymbolType symbolType, Feature feature, GeoCanvas canvas, GeoBrush geoBrush, GeoPen geoPen, float symbolSize, float rotationAngle);
    protected void DrawImage(GeoImage geoImage, Feature feature, GeoCanvas canvas, float symbolSize, float rotationAngle);
    private void YCo=(GeoImage image, PointShape point, GeoCanvas canvas, float symbolSize, float rotationAngle);
    private void FiE=(GeoCanvas canvas, float screenX, float screenY, float width, float height, float rotationAngle);
    protected void DrawGlyph(GeoFont glyphFont, string glyphConent, Feature pointFeature, GeoCanvas canvas, GeoBrush geoBrush, GeoPen geoPen, float symbolSize, float rotationAngle);
    private PolygonShape LTE=(Vertex[] maskAreaVertexs, Vertex pivotLowerCenterPoint, double angle, bool isStraight);
    private void LjE=(GeoFont glyphFont, string glyphConent, PointShape point, GeoCanvas canvas, GeoBrush geoBrush, GeoPen haloPen, float rotationAngle);
    private void aSo=(Feature feature, GeoCanvas canvas, GeoPen geoPen, GeoBrush geoBrush, float symbolSize, float rotationAngle);
    private void Xio=(Feature feature, GeoCanvas canvas, GeoPen geoPen, GeoBrush geoBrush, float symbolSize, double rotationAngle);
    private void Zyo=(Feature feature, GeoCanvas canvas, GeoPen geoPen, GeoBrush geoBrush, float symbolSize, float rotationAngle);
    private void ZSo=(Feature feature, GeoCanvas canvas, GeoPen geoPen, float symbolSize, float rotationAngle);
    private void LzE=(Feature feature, GeoCanvas canvas, GeoPen geoPen, GeoBrush geoBrush, float symbolSize, float rotationAngle, Action`7<double, double, GeoCanvas, GeoPen, GeoBrush, double, double> drawAction);
    private int Yio=(Byte[] centerPointWkb, int startIndex, GeoCanvas canvas, GeoPen geoPen, GeoBrush geoBrush, double symbolSize, double rotationAngle);
    private int aio=(Byte[] centerPointWkb, int startIndex, GeoCanvas canvas, GeoPen geoPen, GeoBrush geoBrush, float symbolSize, float rotationAngle);
    private void MDE=(double centerWorldX, double centerWorldY, GeoCanvas canvas, GeoPen geoPen, GeoBrush fillBrush, double symbolSize, double rotationAngle);
    private void MTE=(double centerWorldX, double centerWorldY, GeoCanvas canvas, GeoPen geoPen, GeoBrush fillBrush, double symbolSize, double rotationAngle);
    private void MjE=(double centerWorldX, double centerWorldY, GeoCanvas canvas, GeoPen geoPen, GeoBrush fillBrush, double symbolSize, double rotationAngle, Double[] angles);
    private Byte[] MzE=(IEnumerable`1<PointShape> worldPoints);
    private int Zio=(Byte[] centerPointWkb, int startIndex, GeoCanvas canvas, GeoPen geoPen, float symbolSize, float rotationAngle);
    private bool bCo=(double screenX, double screenY, float canvasWidth, float canvasHeight);
    private static void hB0=(Byte[] sourceArray, Byte[] destinateArray, long destinateIndex);
    private static IEnumerable`1<Vertex> NDE=(Vertex startPoint, Vertex pivot, float radius);
    private static IEnumerable`1<Vertex> NTE=(Vertex startPoint, Vertex pivot, float radius);
    private static Vertex NjE=(Vertex startPoint, Vertex pivot, double angle, float radius);
    private static int PRU=(Byte[] wkb, int startIndex, byte byteOrder);
    private static double PhU=(Byte[] wkb, int startIndex, byte byteOrder);
    private static WkbShapeType NzE=(Byte[] wkb, int startIndex);
    private static GeoFont ODE=(String[] valueExpressions);
    private static GeoPen OTE=(String[] valueExpressions);
    private static GeoBrush OjE=(String[] valueExpressions);
    private static AreaStyle OzE=(String[] valueExpressions);
}
public enum ThinkGeo.Core.PointSymbolType : Enum {
    public int value__;
    public static PointSymbolType Circle;
    public static PointSymbolType Square;
    public static PointSymbolType Triangle;
    public static PointSymbolType Cross;
    public static PointSymbolType DiamondNarrow;
    public static PointSymbolType Diamond;
    public static PointSymbolType Star;
    public static PointSymbolType StarCircled;
    public static PointSymbolType CrossArrow;
    public static PointSymbolType BidirectionalArrow;
}
public enum ThinkGeo.Core.PointType : Enum {
    public int value__;
    public static PointType Symbol;
    public static PointType Image;
    public static PointType Glyph;
}
public enum ThinkGeo.Core.PolygonLabelingLocationMode : Enum {
    public int value__;
    public static PolygonLabelingLocationMode Default;
    public static PolygonLabelingLocationMode Centroid;
    public static PolygonLabelingLocationMode BoundingBoxCenter;
}
[TypeConverterAttribute("ThinkGeo.Core.BaseShapeTypeConverter")]
public class ThinkGeo.Core.PolygonShape : AreaBaseShape {
    [ObfuscationAttribute]
private RingShape outerRing;
    [ObfuscationAttribute]
private Collection`1<RingShape> innerRings;
    public RingShape OuterRing { get; public set; }
    public Collection`1<RingShape> InnerRings { get; }
    public PolygonShape(RingShape outerRing);
    public PolygonShape(RingShape outerRing, IEnumerable`1<RingShape> innerRings);
    public PolygonShape(string wellKnownText);
    public PolygonShape(Byte[] wellKnownBinary);
    public RingShape get_OuterRing();
    public void set_OuterRing(RingShape value);
    public Collection`1<RingShape> get_InnerRings();
    protected virtual WellKnownType GetWellKnownTypeCore();
    protected virtual BaseShape CloneDeepCore();
    protected virtual double GetPerimeterCore(GeographyUnit shapeUnit, DistanceUnit returningUnit);
    protected virtual double GetAreaCore(GeographyUnit shapeUnit, AreaUnit returningUnit);
    protected virtual void ScaleUpCore(double percentage);
    protected virtual void ScaleDownCore(double percentage);
    protected virtual BaseShape RegisterCore(PointShape fromPoint, PointShape toPoint, DistanceUnit fromUnit, GeographyUnit toUnit);
    protected virtual void TranslateByOffsetCore(double xOffsetDistance, double yOffsetDistance, GeographyUnit shapeUnit, DistanceUnit distanceUnit);
    protected virtual void TranslateByDegreeCore(double distance, double angleInDegrees, GeographyUnit shapeUnit, DistanceUnit distanceUnit);
    protected virtual void RotateCore(PointShape pivotPoint, double degreeAngle);
    protected virtual PointShape GetClosestPointToCore(BaseShape targetShape, GeographyUnit shapeUnit);
    protected virtual double GetDistanceToCore(BaseShape targetShape, GeographyUnit shapeUnit, DistanceUnit distanceUnit);
    protected virtual string GetWellKnownTextCore(RingOrder outerRingOrder);
    protected virtual Byte[] GetWellKnownBinaryCore(RingOrder outerRingOrder, WkbByteOrder byteOrder);
    protected virtual void LoadFromWellKnownDataCore(string wellKnownText);
    protected virtual void LoadFromWellKnownDataCore(Byte[] wellKnownBinary);
    protected virtual ShapeValidationResult ValidateCore(ShapeValidationMode validationMode);
    protected virtual RectangleShape GetBoundingBoxCore();
    protected virtual MultipointShape GetCrossingCore(BaseShape targetShape);
    public static bool RemoveVertex(Vertex selectedVertex, PolygonShape polygonShape);
    public bool RemoveVertex(Vertex selectedVertex);
    public MultilineShape ToMultiLineShape();
    internal void TRU=(double multiplicator);
    private static void Zhw=(RingShape targetRingShape, WkbByteOrder byteOrder, BinaryWriter writer);
    private static void ZBw=(RingShape targetRingShape, WkbByteOrder byteOrder, BinaryWriter writer);
    private static void dRw=(RingShape ringShape, StringBuilder wellKnownText);
    private static void dhw=(RingShape ringShape, StringBuilder wellKnownText);
    private static void dxw=(PolygonShape targetPolygon);
    private static void eBw=(PolygonShape fromPolygon, PolygonShape toPolygon);
    internal static MultilineShape eRw=(PolygonShape polygonShape);
    internal bool ehw=();
}
public abstract class ThinkGeo.Core.PositionStyle : Style {
    private static Regex PDE=;
    [ObfuscationAttribute]
private bool allowLineCarriage;
    [ObfuscationAttribute]
private bool allowSpline;
    [ObfuscationAttribute]
private WellKnownType currentShapeWellKnownType;
    [ObfuscationAttribute]
private Collection`1<TextStyle> customTextStyles;
    [ObfuscationAttribute]
private string dateFormat;
    [ObfuscationAttribute]
private DrawingLevel drawingLevel;
    [ObfuscationAttribute]
private bool fittingPolygon;
    [ObfuscationAttribute]
private double fittingPolygonFactor;
    [ObfuscationAttribute]
private GeoFont font;
    [ObfuscationAttribute]
private bool forceHorizontalLabelForLine;
    [ObfuscationAttribute]
private bool forceLineCarriage;
    [ObfuscationAttribute]
private PolygonLabelingLocationMode polygonLabelingLocationMode;
    [ObfuscationAttribute]
private int gridSize;
    [ObfuscationAttribute]
private GeoPen haloPen;
    [ObfuscationAttribute]
private bool labelAllPolygonParts;
    [ObfuscationAttribute]
private bool labelAllLineParts;
    [ObfuscationAttribute]
private LabelDuplicateRule duplicateRule;
    [ObfuscationAttribute]
private LabelOverlappingRule overlappingRule;
    [ObfuscationAttribute]
private bool allowLabelNudging;
    [ObfuscationAttribute]
private Dictionary`2<string, WorldLabelingCandidate> labelPositions;
    [ObfuscationAttribute]
private AreaStyle mask;
    [ObfuscationAttribute]
private double maxAdjacentCharDeltaAngle;
    [ObfuscationAttribute]
private DrawingMargin maskMargin;
    [ObfuscationAttribute]
private MaskType maskType;
    [ObfuscationAttribute]
private string numericFormat;
    [ObfuscationAttribute]
private TextPlacement textPlacement;
    [ObfuscationAttribute]
private bool fittingLineInScreen;
    [ObfuscationAttribute]
private bool fittingPolygonInScreen;
    [ObfuscationAttribute]
private double rotationAngle;
    [ObfuscationAttribute]
private SplineType splineType;
    [ObfuscationAttribute]
private bool suppressPartialLabels;
    [ObfuscationAttribute]
private string textColumnName;
    [ObfuscationAttribute]
private string textFormat;
    [ObfuscationAttribute]
private double textLineSegmentRatio;
    [ObfuscationAttribute]
private GeoBrush textBrush;
    [ObfuscationAttribute]
private float xOffsetInPixel;
    [ObfuscationAttribute]
private float yOffsetInPixel;
    [ObfuscationAttribute]
private int maxNudgingInPixel;
    [ObfuscationAttribute]
private float nudgingIntervalInPixel;
    [ObfuscationAttribute]
private Dictionary`2<string, string> abbreviationDictionary;
    [ObfuscationAttribute]
private float bestPlacementSymbolWidth;
    [ObfuscationAttribute]
private float bestPlacementSymbolHeight;
    [ObfuscationAttribute]
private LineStyle leaderLineStyle;
    [ObfuscationAttribute]
private LabelLeaderLinesRule leaderLineRule;
    [ObfuscationAttribute]
private float leaderLineMinimumLengthInPixels;
    [ObfuscationAttribute]
private DrawingTextAlignment alignment;
    [ObfuscationAttribute]
private DrawingTextLetterCase letterCase;
    [ObfuscationAttribute]
private double maxCharAngleDelta;
    [ObfuscationAttribute]
private double minDistance;
    [ObfuscationAttribute]
private double spacing;
    [ObfuscationAttribute]
private double wrapWidth;
    [ObfuscationAttribute]
private PointStyle basePoint;
    [ObfuscationAttribute]
private string textContent;
    [ObfuscationAttribute]
private String[] tempColumnNames;
    [ObfuscationAttribute]
private bool isSplinedText;
    [ObfuscationAttribute]
private double textLetterSpacing;
    [ObfuscationAttribute]
private DrawingTextBaseline textBaseline;
    [ObfuscationAttribute]
private float textLineSpacing;
    [ObfuscationAttribute]
private bool allowOverlapping;
    [ObfuscationAttribute]
private bool drawBasePointWithoutText;
    [ObfuscationAttribute]
private bool isStyleJsonStyle;
    [CompilerGeneratedAttribute]
private EventHandler`1<FormattingPositionStyleEventArgs> PTE=;
    [CompilerGeneratedAttribute]
private EventHandler`1<FormattedPositionStyleEventArgs> PjE=;
    [ObfuscationAttribute]
private ConcurrentDictionary`2<string, DrawingRectangleF> _cachedCharSize;
    protected Dictionary`2<string, WorldLabelingCandidate> LabelPositions { get; }
    public PolygonLabelingLocationMode PolygonLabelingLocationMode { get; public set; }
    public int MaxNudgingInPixel { get; public set; }
    public float NudgingIntervalInPixel { get; public set; }
    public float BestPlacementSymbolWidth { get; public set; }
    public float BestPlacementSymbolHeight { get; public set; }
    public Dictionary`2<string, string> AbbreviationDictionary { get; public set; }
    public LineStyle LeaderLineStyle { get; public set; }
    public LabelLeaderLinesRule LeaderLineRule { get; public set; }
    public float LeaderLineMinimumLengthInPixels { get; public set; }
    protected float XOffsetInPixel { get; protected set; }
    protected float YOffsetInPixel { get; protected set; }
    public int GridSize { get; public set; }
    protected Collection`1<TextStyle> CustomTextStyles { get; }
    protected double RotationAngle { get; protected set; }
    protected bool FittingLineInScreen { get; protected set; }
    protected bool FittingPolygonInScreen { get; protected set; }
    protected string TextFormat { get; protected set; }
    protected string NumericFormat { get; protected set; }
    protected string DateFormat { get; protected set; }
    protected GeoBrush TextBrush { get; protected set; }
    protected GeoFont Font { get; protected set; }
    protected GeoPen HaloPen { get; protected set; }
    protected string TextColumnName { get; protected set; }
    protected AreaStyle Mask { get; protected set; }
    protected DrawingMargin MaskMargin { get; protected set; }
    public LabelDuplicateRule DuplicateRule { get; public set; }
    public LabelOverlappingRule OverlappingRule { get; public set; }
    public bool AllowLabelNudging { get; public set; }
    protected bool AllowSpline { get; protected set; }
    public bool AllowLineCarriage { get; public set; }
    public bool SuppressPartialLabels { get; public set; }
    public bool ForceLineCarriage { get; public set; }
    public bool FittingPolygon { get; public set; }
    public bool LabelAllPolygonParts { get; public set; }
    public bool LabelAllLineParts { get; public set; }
    protected bool ForceHorizontalLabelForLine { get; protected set; }
    public double FittingPolygonFactor { get; public set; }
    public double TextLineSegmentRatio { get; public set; }
    public TextPlacement TextPlacement { get; public set; }
    protected SplineType SplineType { get; protected set; }
    protected DrawingLevel DrawingLevel { get; protected set; }
    internal bool phU= { get; }
    public MaskType MaskType { get; public set; }
    protected DrawingTextAlignment Alignment { get; protected set; }
    protected DrawingTextLetterCase LetterCase { get; protected set; }
    protected double MaxCharAngleDelta { get; protected set; }
    protected double MinDistance { get; protected set; }
    protected double Spacing { get; protected set; }
    protected double WrapWidth { get; protected set; }
    protected PointStyle BasePoint { get; protected set; }
    internal bool QTE= { get; internal set; }
    public string TextContent { get; public set; }
    internal double RDE= { get; internal set; }
    internal DrawingTextBaseline RzE= { get; internal set; }
    internal float SjE= { get; internal set; }
    internal bool TTE= { get; internal set; }
    internal bool UDE= { get; internal set; }
    public double MaxAdjacentCharDeltaAngle { get; public set; }
    private static PositionStyle();
    [CompilerGeneratedAttribute]
public void add_Formatting(EventHandler`1<FormattingPositionStyleEventArgs> value);
    [CompilerGeneratedAttribute]
public void remove_Formatting(EventHandler`1<FormattingPositionStyleEventArgs> value);
    [CompilerGeneratedAttribute]
public void add_Formatted(EventHandler`1<FormattedPositionStyleEventArgs> value);
    [CompilerGeneratedAttribute]
public void remove_Formatted(EventHandler`1<FormattedPositionStyleEventArgs> value);
    protected Dictionary`2<string, WorldLabelingCandidate> get_LabelPositions();
    public PolygonLabelingLocationMode get_PolygonLabelingLocationMode();
    public void set_PolygonLabelingLocationMode(PolygonLabelingLocationMode value);
    public int get_MaxNudgingInPixel();
    public void set_MaxNudgingInPixel(int value);
    public float get_NudgingIntervalInPixel();
    public void set_NudgingIntervalInPixel(float value);
    public float get_BestPlacementSymbolWidth();
    public void set_BestPlacementSymbolWidth(float value);
    public float get_BestPlacementSymbolHeight();
    public void set_BestPlacementSymbolHeight(float value);
    public Dictionary`2<string, string> get_AbbreviationDictionary();
    public void set_AbbreviationDictionary(Dictionary`2<string, string> value);
    public LineStyle get_LeaderLineStyle();
    public void set_LeaderLineStyle(LineStyle value);
    public LabelLeaderLinesRule get_LeaderLineRule();
    public void set_LeaderLineRule(LabelLeaderLinesRule value);
    public float get_LeaderLineMinimumLengthInPixels();
    public void set_LeaderLineMinimumLengthInPixels(float value);
    protected float get_XOffsetInPixel();
    protected void set_XOffsetInPixel(float value);
    protected float get_YOffsetInPixel();
    protected void set_YOffsetInPixel(float value);
    public int get_GridSize();
    public void set_GridSize(int value);
    protected Collection`1<TextStyle> get_CustomTextStyles();
    protected double get_RotationAngle();
    protected void set_RotationAngle(double value);
    protected bool get_FittingLineInScreen();
    protected void set_FittingLineInScreen(bool value);
    protected bool get_FittingPolygonInScreen();
    protected void set_FittingPolygonInScreen(bool value);
    protected string get_TextFormat();
    protected void set_TextFormat(string value);
    protected string get_NumericFormat();
    protected void set_NumericFormat(string value);
    protected string get_DateFormat();
    protected void set_DateFormat(string value);
    protected GeoBrush get_TextBrush();
    protected void set_TextBrush(GeoBrush value);
    protected GeoFont get_Font();
    protected void set_Font(GeoFont value);
    protected GeoPen get_HaloPen();
    protected void set_HaloPen(GeoPen value);
    protected string get_TextColumnName();
    protected void set_TextColumnName(string value);
    protected AreaStyle get_Mask();
    protected void set_Mask(AreaStyle value);
    protected DrawingMargin get_MaskMargin();
    protected void set_MaskMargin(DrawingMargin value);
    public LabelDuplicateRule get_DuplicateRule();
    public void set_DuplicateRule(LabelDuplicateRule value);
    public LabelOverlappingRule get_OverlappingRule();
    public void set_OverlappingRule(LabelOverlappingRule value);
    public bool get_AllowLabelNudging();
    public void set_AllowLabelNudging(bool value);
    protected bool get_AllowSpline();
    protected void set_AllowSpline(bool value);
    public bool get_AllowLineCarriage();
    public void set_AllowLineCarriage(bool value);
    public bool get_SuppressPartialLabels();
    public void set_SuppressPartialLabels(bool value);
    public bool get_ForceLineCarriage();
    public void set_ForceLineCarriage(bool value);
    public bool get_FittingPolygon();
    public void set_FittingPolygon(bool value);
    public bool get_LabelAllPolygonParts();
    public void set_LabelAllPolygonParts(bool value);
    public bool get_LabelAllLineParts();
    public void set_LabelAllLineParts(bool value);
    protected bool get_ForceHorizontalLabelForLine();
    protected void set_ForceHorizontalLabelForLine(bool value);
    public double get_FittingPolygonFactor();
    public void set_FittingPolygonFactor(double value);
    public double get_TextLineSegmentRatio();
    public void set_TextLineSegmentRatio(double value);
    public TextPlacement get_TextPlacement();
    public void set_TextPlacement(TextPlacement value);
    protected SplineType get_SplineType();
    protected void set_SplineType(SplineType value);
    protected DrawingLevel get_DrawingLevel();
    protected void set_DrawingLevel(DrawingLevel value);
    internal virtual bool pBU=();
    public MaskType get_MaskType();
    public void set_MaskType(MaskType value);
    protected DrawingTextAlignment get_Alignment();
    protected void set_Alignment(DrawingTextAlignment value);
    protected DrawingTextLetterCase get_LetterCase();
    protected void set_LetterCase(DrawingTextLetterCase value);
    protected double get_MaxCharAngleDelta();
    protected void set_MaxCharAngleDelta(double value);
    protected double get_MinDistance();
    protected void set_MinDistance(double value);
    protected double get_Spacing();
    protected void set_Spacing(double value);
    protected double get_WrapWidth();
    protected void set_WrapWidth(double value);
    protected PointStyle get_BasePoint();
    protected void set_BasePoint(PointStyle value);
    internal bool PzE=();
    internal void QDE=(bool value);
    public string get_TextContent();
    public void set_TextContent(string value);
    internal double QjE=();
    internal void QzE=(double value);
    internal DrawingTextBaseline RTE=();
    internal void RjE=(DrawingTextBaseline value);
    internal float SDE=();
    internal void STE=(float value);
    internal bool SzE=();
    internal void TDE=(bool value);
    internal bool TjE=();
    internal void TzE=(bool value);
    public double get_MaxAdjacentCharDeltaAngle();
    public void set_MaxAdjacentCharDeltaAngle(double value);
    protected void DrawMask(LabelingCandidate labelingCandidate, GeoCanvas canvas, Collection`1<SimpleCandidate> labelsInThisLayer, Collection`1<SimpleCandidate> labelsInAllLayers);
    protected virtual void DrawCore(IEnumerable`1<Feature> features, GeoCanvas canvas, Collection`1<SimpleCandidate> labelsInThisLayer, Collection`1<SimpleCandidate> labelsInAllLayers);
    protected virtual Collection`1<string> GetRequiredColumnNamesCore();
    protected internal Collection`1<Feature> FilterFeatures(IEnumerable`1<Feature> features, GeoCanvas canvas);
    protected virtual Collection`1<Feature> FilterFeaturesCore(IEnumerable`1<Feature> features, GeoCanvas canvas);
    protected void AbbreviateText(Feature feature, GeoCanvas canvas);
    protected virtual void AbbreviateTextCore(Feature feature, GeoCanvas canvas);
    protected Collection`1<LabelingCandidate> GetLabelingCandidates(Feature feature, GeoCanvas canvas, GeoFont font, float xOffsetInPixel, float yOffsetInPixel, double rotationAngle);
    protected virtual Collection`1<LabelingCandidate> GetLabelingCandidateCore(Feature feature, GeoCanvas canvas, GeoFont font, float xOffsetInPixel, float yOffsetInPixel, double rotationAngle);
    private void UTE=(PointShape point, GeoFont font, GeoCanvas canvas, DrawingTextBaseline textBaseline, string text, double angle);
    internal DrawingRectangleF UjE=(GeoCanvas canvas, string text, GeoFont font);
    public string WrapText(string text, GeoFont font, GeoCanvas canvas);
    private string UzE=(string text);
    protected bool CheckDuplicate(LabelingCandidate labelingCandidate, GeoCanvas canvas, Collection`1<SimpleCandidate> labelsInThisLayer, Collection`1<SimpleCandidate> labelsInAllLayers);
    protected virtual bool CheckDuplicateCore(LabelingCandidate labelingCandidate, GeoCanvas canvas, Collection`1<SimpleCandidate> labelsInThisLayer, Collection`1<SimpleCandidate> labelsInAllLayers);
    private static bool VDE=(Collection`1<SimpleCandidate> labelCandidates, LabelingCandidate currentLabelCandidate);
    private static bool VTE=(Collection`1<SimpleCandidate> labelCandidates, LabelingCandidate currentLabelCandidate, ScreenPointF ulPointF, ScreenPointF lrPointF);
    protected bool CheckOverlapping(LabelingCandidate labelingCandidate, GeoCanvas canvas, GeoFont font, float xOffsetInPixel, float yOffsetInPixel, double rotationAngle, Collection`1<SimpleCandidate> labelsInThisLayer, Collection`1<SimpleCandidate> labelsInAllLayers);
    protected virtual bool CheckOverlappingCore(LabelingCandidate labelingCandidate, GeoCanvas canvas, Collection`1<SimpleCandidate> labelsInThisLayer, Collection`1<SimpleCandidate> labelsInAllLayers);
    protected static BaseShape ConvertToScreenShape(Feature feature, GeoCanvas canvas);
    protected virtual void DrawSampleCore(GeoCanvas canvas, DrawingRectangleF drawingExtent);
    protected virtual Style CloneDeepCore();
    private bool VjE=(Collection`1<SimpleCandidate> labelInThisLayer, Collection`1<SimpleCandidate> labelsInAllLayer, LabelingCandidate currentLabelCandidate);
    private ScreenPointF VzE=(PointShape point);
    private FeatureLabelingCandidate WDE=(Feature feature, GeoCanvas canvas, GeoFont font, float xOffsetInPixel, float yOffsetInPixel, double rotationAngle);
    private ScreenPointF[] WTE=(ScreenPointF[] textPathInScreen, DrawingTextAlignment alignment, double drawingRectangleWidth, float drawingTextWidth, int drawingTextLinesCount);
    private Collection`1<LabelingCandidate> WjE=(MultilineShape multilineShape, string text, GeoFont font, float xOffsetInPixel, float yOffsetInPixel, GeoCanvas canvas, double rotationAngle);
    private Collection`1<LabelingCandidate> WzE=(MultilineShape multiLineShape, FDE= lineLabelAdjuster, string text, GeoFont font, float xOffsetInPixel, float yOffsetInPixel, double rotationAngle, GeoCanvas canvas, RectangleShape screenExtent, bool allowLineLabelingMoving);
    private Collection`1<LabelingCandidate> XDE=(MultilineShape multilineShape, FDE= lineLabelAdjuster, string text, GeoFont font, float xOffsetInPixel, float yOffsetInPixel, double rotationAngle, GeoCanvas canvas, string labelText, double width, double height, RectangleShape screenExtent, bool allowLineLabelingMoving);
    private ValueTuple`2<LineShape, LineShape> XTE=(LineShape lineShape);
    private LabelingCandidate XjE=(FDE= lineLabelAdjuster, string text, GeoFont font, float xOffsetInPixel, float yOffsetInPixel, GeoCanvas canvas, string labelText, double width, double height);
    private float XzE=(GeoCanvas canvas);
    private Collection`1<LabelingCandidate> YDE=(MultilineShape multiLineShape, FDE= lineLabelAdjuster, string text, GeoFont font, float xOffsetInPixel, float yOffsetInPixel, double rotationAngle, GeoCanvas canvas, RectangleShape screenExtent, bool allowLineLabelingMoving);
    private Collection`1<LabelingCandidate> YTE=(MultilineShape multiLineShape, FDE= lineLabelAdjuster, GeoCanvas canvas, string text, string labelText, GeoFont font, float xOffsetInPixel, float yOffsetInPixel, double rotationAngle, double width, double height, RectangleShape screenExtent, bool allowLineLabelingMoving);
    private LabelingCandidate YjE=(FDE= lineLabelAdjuster, GeoCanvas canvas, string text, string labelText, double width, double height, double xOffsetInPixel, double yOffsetInPixel);
    private Collection`1<LabelingCandidate> YzE=(MultilineShape multilineShape, string text, GeoFont font, float xOffsetInPixel, float yOffsetInPixel, GeoCanvas canvas, double rotationAngle);
    private Collection`1<LabelingCandidate> ZDE=(LineShape lineShape, double labelWidth, double lineLength, string text, GeoCanvas canvas, GeoFont font, float xOffsetInPixel, float yOffsetInPixel, double rotationAngle);
    private Collection`1<LabelingCandidate> ZTE=(LineShape lineShape, double labelWidth, double lineLength, string text, GeoCanvas canvas, GeoFont font, float xOffsetInPixel, float yOffsetInPixel, double rotationAngle);
    private static StartingPoint ZjE=(StartingPoint startingPoint);
    private LabelingCandidate YzE=(LineShape lineShape, double lineLength, string text, GeoCanvas canvas, GeoFont font, float xOffsetInPixel, float yOffsetInPixel);
    private static ValueTuple`2<PointShape, double> ZzE=(PointShape centerPointForLabel, IGeoCanvasRotatable rotatableGeoCanvas, double angle);
    private static Collection`1<LabelInformation> aDE=(string text, Collection`1<LabelInformation> labelInformationCollection, IGeoCanvasRotatable rotatableGeoCanvas);
    private static double aTE=(double angle, double canvasRotationAngle);
    private static bool ajE=(double angle);
    private DrawingRectangleF azE=(GeoCanvas canvas, GeoFont font, char centerText);
    private PolygonShape bDE=(string text, GeoCanvas canvas, GeoFont font, float xOffsetInPixel, float yOffsetInPixel, DrawingRectangleF firstSize, PointShape firstPoint, PointShape secondPoint, double firstAngle, PointShape& centerPointForLabel);
    private Collection`1<DrawingRectangleF> bTE=(string labelText, GeoCanvas canvas, GeoFont font);
    private LabelingCandidate bjE=(Collection`1<PointShape> coordinates, string text, GeoFont font, float xOffsetInPixel, float yOffsetInPixel, GeoCanvas canvas);
    private bool bzE=(Collection`1<PointShape> coordinates, double maxCharAngle);
    private double cDE=(Vertex start, Vertex middle, Vertex end);
    private LabelingCandidate YzE=(Collection`1<PointShape> coordinates, string text, GeoFont font, float xOffsetInPixel, float yOffsetInPixel, GeoCanvas canvas);
    private static bool cTE=(AreaBaseShape firstPolygon, AreaBaseShape secondPolygon);
    private static float cjE=(PolygonShape rectangleA, double angleA, PolygonShape rectangleB, double angleB);
    private static FDE= czE=(MultilineShape multilineShape, RectangleShape screenExtent, bool allowLineLabelingMoving, double rotateAngle);
    private static PolygonShape dDE=(MultipolygonShape multipolygonShape, RectangleShape screenExtent);
    private Collection`1<LabelingCandidate> dTE=(MultipointShape multipoint, string text, GeoFont font, float xOffsetInPixel, float yOffsetInPixel, GeoCanvas canvas, double rotationAngle);
    private LabelingCandidate djE=(PointShape point, string text, GeoFont font, float xOffsetInPixel, float yOffsetInPixel, GeoCanvas canvas, double rotationAngle);
    private LabelingCandidate dzE=(PointShape point, string text, GeoFont font, float xOffsetInPixel, float yOffsetInPixel, GeoCanvas canvas, double rotationAngle);
    private LabelingCandidate eDE=(PointShape point, string text, GeoFont font, float xOffsetInPixel, float yOffsetInPixel, GeoCanvas canvas);
    private Collection`1<LabelingCandidate> eTE=(MultilineShape multilineShape, string text, GeoFont font, float xOffsetInPixel, float yOffsetInPixel, GeoCanvas canvas, double rotationAngle);
    private Collection`1<LabelingCandidate> ejE=(MultilineShape multilineShape, string text, GeoFont font, float xOffsetInPixel, float yOffsetInPixel, GeoCanvas canvas, double rotationAngle);
    private Collection`1<LabelingCandidate> ezE=(MultilineShape multilineShape, string text, GeoFont font, float xOffsetInPixel, float yOffsetInPixel, GeoCanvas canvas, double rotationAngle);
    private static LineShape fDE=(MultilineShape multilineShape);
    private Collection`1<LabelingCandidate> fTE=(LineShape line, string text, GeoFont font, float xOffsetInPixel, float yOffsetInPixel, GeoCanvas canvas, double rotationAngle);
    private Collection`1<LabelingCandidate> fjE=(MultipolygonShape multipolygonShape, string text, GeoFont font, float xOffsetInPixel, float yOffsetInPixel, GeoCanvas canvas, double rotationAngle);
    private Collection`1<LabelingCandidate> fzE=(Feature feature, GeoCanvas canvas, GeoFont font, float xOffsetInPixel, float yOffsetInPixel, double rotationAngle);
    private Collection`1<LabelingCandidate> gDE=(MultipolygonShape multipolygonShape, string text, GeoFont font, float xOffsetInPixel, float yOffsetInPixel, GeoCanvas canvas, double rotationAngle);
    internal LabelingCandidate gTE=(PolygonShape polygon, string text, GeoFont font, float xOffsetInPixel, float yOffsetInPixel, GeoCanvas canvas, double rotationAngle);
    private Collection`1<LabelingCandidate> gjE=(MultipolygonShape multipolygonShape, string text, GeoFont font, float xOffsetInPixel, float yOffsetInPixel, GeoCanvas canvas, double rotationAngle);
    private static double gzE=(Vertex fromVertex, Vertex toVertex);
    private static double IzE=(Vertex fromVertex, Vertex toVertex);
    private static double hDE=(Vertex fromVertex, Vertex toVertex);
    private String[] hTE=(PolygonShape polygon, string text, GeoFont font, GeoCanvas canvas);
    private static String[] hjE=(string text);
    private static PointShape hzE=(Vertex fromVertex, Vertex toVertex);
    private static PointShape iDE=(PointShape fromVertex, PointShape toVertex);
    private static PointShape iTE=(PointShape point, double distance, double angle);
    private PointShape ijE=(PolygonShape polygon);
    private static PointShape izE=(PointShape upperLeftPoint, double width, double height, TextPlacement placementOfPoint);
    private PointShape jDE=(ScreenPointF centerPointBePlacemented, double width, double height, TextPlacement placementOfLabel, float xOffsetInPixel, float yOffsetInPixel, float canvasDpi, float canvasScaleFactor);
    private static PolygonShape jTE=(MultipolygonShape multipolygonShape);
    private PolygonShape jjE=(PointShape lowerLeftPoint, double width, double height);
    private PolygonShape jzE=(PointShape upperCenterPoint, double width, double height, double angle);
    private PolygonShape kDE=(PointShape lowerCenterPoint, double width, double height, double angle);
    private PolygonShape LTE=(Vertex[] maskAreaVertexs, Vertex pivotLowerCenterPoint, double angle, bool isStraight);
    private static IEnumerable`1<Vertex> NDE=(Vertex startPoint, Vertex pivot, float radius);
    private static IEnumerable`1<Vertex> NTE=(Vertex startPoint, Vertex pivot, float radius);
    private static Vertex NjE=(Vertex startPoint, Vertex pivot, double angle, float radius);
    private LabelInformation kTE=(string text, double height, PointShape centerPoint, double yOffset, double rotationAngle);
    private static BaseShape hR0=(Feature feature, GeoCanvas canvas);
    private static BaseShape hh0=(Feature feature, GeoCanvas canvas);
    private static BaseShape hx0=(Feature feature, GeoCanvas canvas);
    private static BaseShape iB0=(Feature feature, GeoCanvas canvas);
    private static BaseShape iR0=(Feature feature, GeoCanvas canvas);
    private static BaseShape ih0=(Feature feature, GeoCanvas canvas);
    private static BaseShape ix0=(Feature feature, GeoCanvas canvas);
    private static PointShape jB0=(Byte[] wellKnownBinary, Int32& startIndex, GeoCanvas canvas);
    private static PolygonShape jR0=(Byte[] wellKnownBinary, Int32& startIndex, GeoCanvas canvas);
    private static LineShape jh0=(Byte[] wellKnownBinary, Int32& startIndex, GeoCanvas canvas);
    private static TextPlacement kjE=(int index, TextPlacement baseOfPointPlacement);
    protected string Format(string text, BaseShape labeledShape);
    protected virtual string FormatCore(string text, BaseShape labeledShape);
    private static string kzE=(string text);
    protected virtual void OnFormatting(FormattingPositionStyleEventArgs e);
    protected virtual void OnFormatted(FormattedPositionStyleEventArgs e);
    private static void lDE=(LabelingCandidate sourceLabelingCandidate, LabelingCandidate destinateLabelingCandidate);
    private static double jx0=(Byte[] bytes, int startIndex, byte byteOrder);
    private static int kB0=(Byte[] bytes, int startIndex, byte byteOrder);
    private bool fRw=(PolygonShape polygon01, PolygonShape polygon02, bool isInThisLayer);
    private bool fRw=(RectangleShape rectangle01, RectangleShape rectangle02);
    private RectangleShape lTE=(PolygonShape polygon, bool isInThisLayer);
    private static PointShape ljE=(PolygonShape polygon);
    private static bool lzE=(PolygonShape polygon, PointShape point, RectangleShape boundingBox);
    private static bool lzE=(PolygonShape polygon, double pointX, double pointY, RectangleShape boundingBox);
    private static void mDE=(Collection`1<Vertex> crossingPoints, RingShape ringShape, double pointX, double pointY, double secondLineEndPointX);
    private static Vertex mTE=(Vertex startPoint, Vertex endPoint, double secondLineStartX, double secondLineStartY, double secondLineEndPointX);
    private static bool mjE=(Collection`1<Vertex> crossingPoints, Vertex vertex);
    private static bool KTE=(double value, double start, double end);
    private static bool mzE=(Vertex vertex);
    private static MultilineShape JTE=(LineShape line, RectangleShape rectangle);
    private static LineShape JzE=(Vertex startPoint, Vertex endPoint, RectangleShape rectangle);
    private static Vertex KDE=(Vertex startPoint, Vertex endPoint, RectangleShape rectangle);
    internal void nDE=(FeatureLabelingCandidate featureLabelingCandidate, GeoCanvas canvas, Collection`1<SimpleCandidate> labelsInThisLayer, Collection`1<SimpleCandidate> labelsInAllLayers);
    internal Collection`1<FeatureLabelingCandidate> nTE=(IEnumerable`1<Feature> features, GeoCanvas canvas);
    private Collection`1<FeatureLabelingCandidate> njE=(IEnumerable`1<Feature> features, GeoCanvas canvas);
}
internal enum ThinkGeo.Core.PrimitiveTypeCode : Enum {
    public int value__;
    public static PrimitiveTypeCode Empty;
    public static PrimitiveTypeCode Object;
    public static PrimitiveTypeCode Char;
    public static PrimitiveTypeCode CharNullable;
    public static PrimitiveTypeCode Boolean;
    public static PrimitiveTypeCode BooleanNullable;
    public static PrimitiveTypeCode SByte;
    public static PrimitiveTypeCode SByteNullable;
    public static PrimitiveTypeCode Int16;
    public static PrimitiveTypeCode Int16Nullable;
    public static PrimitiveTypeCode UInt16;
    public static PrimitiveTypeCode UInt16Nullable;
    public static PrimitiveTypeCode Int32;
    public static PrimitiveTypeCode Int32Nullable;
    public static PrimitiveTypeCode Byte;
    public static PrimitiveTypeCode ByteNullable;
    public static PrimitiveTypeCode UInt32;
    public static PrimitiveTypeCode UInt32Nullable;
    public static PrimitiveTypeCode Int64;
    public static PrimitiveTypeCode Int64Nullable;
    public static PrimitiveTypeCode UInt64;
    public static PrimitiveTypeCode UInt64Nullable;
    public static PrimitiveTypeCode Single;
    public static PrimitiveTypeCode SingleNullable;
    public static PrimitiveTypeCode Double;
    public static PrimitiveTypeCode DoubleNullable;
    public static PrimitiveTypeCode DateTime;
    public static PrimitiveTypeCode DateTimeNullable;
    public static PrimitiveTypeCode DateTimeOffset;
    public static PrimitiveTypeCode DateTimeOffsetNullable;
    public static PrimitiveTypeCode Decimal;
    public static PrimitiveTypeCode DecimalNullable;
    public static PrimitiveTypeCode Guid;
    public static PrimitiveTypeCode GuidNullable;
    public static PrimitiveTypeCode TimeSpan;
    public static PrimitiveTypeCode TimeSpanNullable;
    public static PrimitiveTypeCode BigInteger;
    public static PrimitiveTypeCode BigIntegerNullable;
    public static PrimitiveTypeCode Uri;
    public static PrimitiveTypeCode String;
    public static PrimitiveTypeCode Bytes;
    public static PrimitiveTypeCode DBNull;
}
public enum ThinkGeo.Core.PrinterDragMode : Enum {
    public int value__;
    public static PrinterDragMode Fixed;
    public static PrinterDragMode Draggable;
}
internal static class ThinkGeo.Core.PrinterHelper : object {
    private static double feetPerMeter;
    public static double ConvertLength(double length, PrintingUnit fromUnit, PrintingUnit toUnit);
    public static double GetPointsPerGeographyUnit(GeographyUnit mapUnit);
}
public abstract class ThinkGeo.Core.PrinterLayer : Layer {
    [ObfuscationAttribute]
private RectangleShape boundingBox;
    [ObfuscationAttribute]
private AreaStyle backgroundMask;
    [ObfuscationAttribute]
private PrinterResizeMode resizeMode;
    [ObfuscationAttribute]
private PrinterDragMode dragMode;
    [ObfuscationAttribute]
private PrinterLayerSelectabilityMode selectabilityMode;
    [ObfuscationAttribute]
private bool isDrawing;
    [ObfuscationAttribute]
private RectangleShape lastBoundingBox;
    [ObfuscationAttribute]
private bool isResizing;
    public bool IsDrawing { get; public set; }
    public bool HasBoundingBox { get; }
    public AreaStyle BackgroundMask { get; public set; }
    public PrinterResizeMode ResizeMode { get; public set; }
    public PrinterDragMode DragMode { get; public set; }
    public bool IsResizing { get; public set; }
    public PrinterLayerSelectabilityMode SelectabilityMode { get; public set; }
    public bool get_IsDrawing();
    public void set_IsDrawing(bool value);
    public virtual bool get_HasBoundingBox();
    public AreaStyle get_BackgroundMask();
    public void set_BackgroundMask(AreaStyle value);
    public PrinterResizeMode get_ResizeMode();
    public void set_ResizeMode(PrinterResizeMode value);
    public PrinterDragMode get_DragMode();
    public void set_DragMode(PrinterDragMode value);
    public bool get_IsResizing();
    public void set_IsResizing(bool value);
    public PrinterLayerSelectabilityMode get_SelectabilityMode();
    public void set_SelectabilityMode(PrinterLayerSelectabilityMode value);
    protected virtual void DrawCore(GeoCanvas canvas, Collection`1<SimpleCandidate> labelsInAllLayers);
    protected virtual RectangleShape GetBoundingBoxCore();
    public RectangleShape GetDynamicBoundingBox();
    protected virtual RectangleShape GetDynamicBoundingBoxCore();
    public RectangleShape GetPosition();
    public RectangleShape GetPosition(PrintingUnit unit);
    protected virtual RectangleShape GetPositionCore(PrintingUnit unit);
    public void SetPosition(RectangleShape boundingBox);
    public void SetPosition(RectangleShape boundingBox, PrintingUnit unit);
    public void SetPosition(double width, double height, PointShape centerPoint, PrintingUnit unit);
    public void SetPosition(double width, double height, double centerPointX, double centerPointY, PrintingUnit unit);
    public void SetPosition(double width, double height, LayerAnchorLocation corner, PointShape cornerPoint, PrintingUnit unit);
    public void SetPosition(double width, double height, LayerAnchorLocation corner, double cornerPointX, double cornerPointY, PrintingUnit unit);
    protected virtual RectangleShape SetPositionCore(double width, double height, double centerPointX, double centerPointY, PrintingUnit unit);
    private RectangleShape ciA=(RectangleShape newBoundingBox);
    private RectangleShape cyA=(RectangleShape newBoundingBox, bool maintainAspectRatio, bool dragable);
    private static bool lhU=(PointShape point1, PointShape point2);
}
public enum ThinkGeo.Core.PrinterLayerSelectabilityMode : Enum {
    public int value__;
    public static PrinterLayerSelectabilityMode Selectable;
    public static PrinterLayerSelectabilityMode NonSelectable;
}
public enum ThinkGeo.Core.PrinterResizeMode : Enum {
    public int value__;
    public static PrinterResizeMode Fixed;
    public static PrinterResizeMode MaintainAspectRatio;
    public static PrinterResizeMode Resizable;
}
public enum ThinkGeo.Core.PrintingUnit : Enum {
    public int value__;
    public static PrintingUnit Millimeter;
    public static PrintingUnit Inch;
    public static PrintingUnit Meter;
    public static PrintingUnit Centimeter;
    public static PrintingUnit Point;
}
public class ThinkGeo.Core.Projection : object {
    [ObfuscationAttribute]
private string projString;
    [ObfuscationAttribute]
private int srid;
    private static object nBo=;
    private static Dictionary`2<string, ProjectionConverter> nRo=;
    private static object kxY=;
    public int Srid { get; public set; }
    public string ProjString { get; public set; }
    public Projection(int srid);
    public Projection(string projString);
    private static Projection();
    public int get_Srid();
    public void set_Srid(int value);
    public string get_ProjString();
    public void set_ProjString(string value);
    public GeographyUnit GetUnit();
    public static string GetProjStringByEpsgSrid(int srid);
    public static int GetEpsgSridByProjString(string projString);
    public static string GetProjStringByEsriSrid(int srid);
    public static int GetEsriSridByProjString(string projString);
    public static string GetWgs84ProjString();
    public static string GetLatLongProjString();
    public static string GetDecimalDegreesProjString();
    public static string GetGoogleMapProjString();
    public static string GetBingMapProjString();
    public static string GetSphericalMercatorProjString();
    public static string GetLocalUtmZoneProjString(double latitude, double longitude);
    public static string GetLocalUtmZoneProjString(Feature feature, string projString);
    public static string GetLocalUtmZoneProjString(Feature feature, int srid);
    public static string GetLocalUtmZoneProjString(BaseShape shape, Projection projection);
    public static string GetLocalUtmZoneProjString(BaseShape shape, string projString);
    public static string GetLocalUtmZoneProjString(BaseShape shape, int srid);
    public static int GetLocalUtmZoneNumber(double latitude, double longitude);
    public static int GetLocalUtmZoneNumber(Feature feature, string projString);
    public static int GetLocalUtmZoneNumber(Feature feature, int srid);
    public static int GetLocalUtmZoneNumber(BaseShape shape, string projString);
    public static int GetLocalUtmZoneNumber(BaseShape shape, int srid);
    public static GeographyUnit GetGeographyUnitFromWkb(string wkt);
    public static GeographyUnit GetGeographyUnitFromProj(string projString);
    public static string ConvertEpsgToWkt(int srid);
    public static string ConvertProjStringToWkt(string projString);
    public static string ConvertWktToProjString(string wkt);
    private static int nho=(double latitude, double longitude);
    public static string ConvertEpsgToProjString(int srid);
    public static int ConvertProjStringToEpsg(string projString);
    private static string nxo=(string srid, Byte[] fileBuffer);
    private static int oBo=(string projString, Byte[] fileBuffer);
    public static GeographyUnit GetGeographyUnit(int srid);
    public static GeographyUnit GetGeographyUnit(string projString);
    private static ProjectionConverter oRo=(string proj4ProjectionParameters);
}
public class ThinkGeo.Core.ProjectionCloudClient : CloudClient {
    public ProjectionCloudClient(string clientId, string clientSecret);
    public Feature Project(Feature feature, int fromProjectionInSrid, int toProjectionInSrid);
    public Feature Project(Feature feature, int fromProjectionInSrid, string toProjectionInProj4String);
    public Feature Project(Feature feature, string fromProjectionInProj4String, int toProjectionInSrid);
    public Feature Project(Feature feature, string fromProjectionInProj4String, string toProjectionInProj4String);
    public Task`1<Feature> ProjectAsync(Feature feature, int fromProjectionInSrid, int toProjectionInSrid);
    public Task`1<Feature> ProjectAsync(Feature feature, int fromProjectionInSrid, string toProjectionInProj4String);
    public Task`1<Feature> ProjectAsync(Feature feature, string fromProjectionInProj4String, int toProjectionInSrid);
    public Task`1<Feature> ProjectAsync(Feature feature, string fromProjectionInProj4String, string toProjectionInProj4String);
    public Collection`1<Feature> Project(IEnumerable`1<Feature> features, int fromProjectionInSrid, int toProjectionInSrid);
    public Collection`1<Feature> Project(IEnumerable`1<Feature> features, int fromProjectionInSrid, string toProjectionInProj4String);
    public Collection`1<Feature> Project(IEnumerable`1<Feature> features, string fromProjectionInProj4String, int toProjectionInSrid);
    public Collection`1<Feature> Project(IEnumerable`1<Feature> features, string fromProjectionInProj4String, string toProjectionInProj4String);
    public Task`1<Collection`1<Feature>> ProjectAsync(IEnumerable`1<Feature> features, int fromProjectionInSrid, int toProjectionInSrid);
    public Task`1<Collection`1<Feature>> ProjectAsync(IEnumerable`1<Feature> features, int fromProjectionInSrid, string toProjectionInProj4String);
    public Task`1<Collection`1<Feature>> ProjectAsync(IEnumerable`1<Feature> features, string fromProjectionInProj4String, int toProjectionInSrid);
    public Task`1<Collection`1<Feature>> ProjectAsync(IEnumerable`1<Feature> features, string fromProjectionInProj4String, string toProjectionInProj4String);
    private Feature 9xQ=(Feature feature, string fromProjectionInProj4String, string toProjectionInProj4String);
    [AsyncStateMachineAttribute("ThinkGeo.Core.ProjectionCloudClient/ZD4=")]
private Task`1<Feature> /BQ=(Feature feature, string fromProjectionInProj4String, string toProjectionInProj4String);
    private Collection`1<Feature> 9xQ=(IEnumerable`1<Feature> features, string fromProjectionInProj4String, string toProjectionInProj4String);
    [AsyncStateMachineAttribute("ThinkGeo.Core.ProjectionCloudClient/aD4=")]
private Task`1<Collection`1<Feature>> /BQ=(IEnumerable`1<Feature> features, string fromProjectionInProj4String, string toProjectionInProj4String);
    private static Feature /RQ=(WebResponse response);
    private static Collection`1<Feature> /hQ=(WebResponse response);
}
public class ThinkGeo.Core.ProjectionConverter : object {
    private jBo= oho=;
    private jBo= oxo=;
    [ObfuscationAttribute]
private static int positionByteOrder;
    private bool pBo=;
    [ObfuscationAttribute]
private bool canConvertRasterToExternalProjection;
    [ObfuscationAttribute]
private RectangleShape decimalDegreeBoundary;
    [ObfuscationAttribute]
private RectangleShape sphecicalMercatorBoundary;
    private hBg= pRo=;
    [CompilerGeneratedAttribute]
private Projection pho=;
    [CompilerGeneratedAttribute]
private Projection pxo=;
    public RectangleShape DecimalDegreeBoundary { get; public set; }
    public Projection InternalProjection { get; public set; }
    public Projection ExternalProjection { get; public set; }
    public bool IsOpen { get; protected set; }
    public bool CanConvertRasterToExternalProjection { get; protected set; }
    public GeographyUnit InternalProjectionUnit { get; }
    public ProjectionConverter(string internalProjString, string externalProjString);
    public ProjectionConverter(int internalSrid, int externalSrid);
    public ProjectionConverter(string internalProjString, int externalSrid);
    public ProjectionConverter(int internalSridString, string externalProjString);
    public ProjectionConverter(Projection internalProjection, Projection externalProjection);
    public RectangleShape get_DecimalDegreeBoundary();
    public void set_DecimalDegreeBoundary(RectangleShape value);
    [CompilerGeneratedAttribute]
public Projection get_InternalProjection();
    [CompilerGeneratedAttribute]
public void set_InternalProjection(Projection value);
    [CompilerGeneratedAttribute]
public Projection get_ExternalProjection();
    [CompilerGeneratedAttribute]
public void set_ExternalProjection(Projection value);
    public bool get_IsOpen();
    protected void set_IsOpen(bool value);
    public bool get_CanConvertRasterToExternalProjection();
    protected void set_CanConvertRasterToExternalProjection(bool value);
    public virtual GeographyUnit get_InternalProjectionUnit();
    public void Open();
    public RasterProjectionResult ConvertToExternalProjection(GeoImage image, RectangleShape imageExtent, RectangleShape targetExtent, int width, int height);
    public RasterProjectionResult ConvertToExternalProjection(GeoImage image, RectangleShape imageExtent);
    public RasterProjectionResult ConvertToExternalProjection(GeoImage image, RectangleShape imageExtent, RectangleShape targetExtent);
    protected virtual RasterProjectionResult ConvertToExternalProjectionCore(GeoImage image, RectangleShape imageExtent, RectangleShape targetExtent, int width, int height);
    protected virtual void OpenCore();
    [OnGeodeserializedAttribute]
private void qBo=();
    public void Close();
    protected virtual void CloseCore();
    public Vertex ConvertToExternalProjection(double x, double y);
    public BaseShape ConvertToExternalProjection(BaseShape baseShape);
    public Feature ConvertToExternalProjection(Feature feature);
    public Collection`1<Feature> ConvertToExternalProjection(IEnumerable`1<Feature> features);
    internal void qRo=(Feature feature);
    public RectangleShape ConvertToExternalProjection(RectangleShape rectangleShape);
    protected virtual Collection`1<Vertex> ConvertToExternalProjectionCore(IEnumerable`1<Vertex> verticies);
    public Collection`1<Vertex> ConvertToExternalProjection(IEnumerable`1<Vertex> vertices);
    public Vertex ConvertToInternalProjection(double x, double y);
    public BaseShape ConvertToInternalProjection(BaseShape baseShape);
    public Feature ConvertToInternalProjection(Feature feature);
    public Collection`1<Vertex> ConvertToInternalProjection(IEnumerable`1<Vertex> vertices);
    public RectangleShape ConvertToInternalProjection(RectangleShape rectangleShape);
    protected virtual Collection`1<Vertex> ConvertToInternalProjectionCore(IEnumerable`1<Vertex> verticies);
    internal void qho=(Feature feature);
    private static Collection`1<Vertex> qxo=(RectangleShape rectangleShape, int pointCountBySide);
    private RectangleShape rBo=(IEnumerable`1<Vertex> vertices);
    private Byte[] rRo=(Byte[] wellKnownBinary);
    private Byte[] rho=(Byte[] wellKnownBinary);
    private static WellKnownType rxo=(Byte[] wkb);
    private Byte[] sBo=(Byte[] wellKnownBinary);
    private Byte[] sRo=(Byte[] wellKnownBinary);
    private Byte[] sho=(Byte[] wellKnownBinary);
    private Byte[] sxo=(Byte[] wellKnownBinary);
    private Byte[] tBo=(Byte[] wellKnownBinary);
    private Byte[] tRo=(Byte[] wellKnownBinary);
    private Byte[] tho=(Byte[] wellKnownBinary);
    private Byte[] txo=(Byte[] wellKnownBinary);
    private Byte[] uBo=(Byte[] wellKnownBinary);
    private Byte[] uRo=(Byte[] wellKnownBinary);
    private Byte[] uho=(Byte[] wellKnownBinary);
    private Byte[] uxo=(Byte[] wellKnownBinary);
    private static int PRU=(Byte[] wkb, int startIndex, byte byteOrder);
    private static double PhU=(Byte[] wkb, int startIndex, byte byteOrder);
    private static Byte[] vBo=(double doubleValue, byte byteOrder);
    private Collection`1<Vertex> vRo=(IEnumerable`1<Vertex> verticies, jBo= sourceProjType, jBo= destinationProjType, bool isFromDegree, bool isToDegree);
    public static PointShape Convert(int fromSrid, int toSrid, PointShape sourcePoint);
    public static Feature Convert(int fromSrid, int toSrid, Feature feature);
    public static RectangleShape Convert(int fromSrid, int toSrid, RectangleShape rectangleShape);
    public static IEnumerable`1<Feature> Convert(int fromSrid, int toSrid, IEnumerable`1<Feature> features);
    public static IEnumerable`1<Vertex> Convert(int fromSrid, int toSrid, IEnumerable`1<Vertex> vertices);
    public static Vertex Convert(int fromSrid, int toSrid, double x, double y);
    public static PointShape Convert(int fromSrid, string toProjString, PointShape sourcePoint);
    public static Feature Convert(int fromSrid, string toProjString, Feature feature);
    public static RectangleShape Convert(int fromSrid, string toProjString, RectangleShape rectangleShape);
    public static IEnumerable`1<Feature> Convert(int fromSrid, string toProjString, IEnumerable`1<Feature> features);
    public static IEnumerable`1<Vertex> Convert(int fromSrid, string toProjString, IEnumerable`1<Vertex> vertices);
    public static Vertex Convert(int fromSrid, string toProjString, double x, double y);
    public static PointShape Convert(Projection fromProjection, Projection toProjection, PointShape sourcePoint);
    public static Feature Convert(Projection fromProjection, Projection toProjection, Feature feature);
    public static RectangleShape Convert(Projection fromProjection, Projection toProjection, RectangleShape rectangleShape);
    public static IEnumerable`1<Feature> Convert(Projection fromProjection, Projection toProjection, IEnumerable`1<Feature> features);
    public static IEnumerable`1<Vertex> Convert(Projection fromProjection, Projection toProjection, IEnumerable`1<Vertex> vertices);
    public static Vertex Convert(Projection fromProjection, Projection toProjection, double x, double y);
    public static PointShape Convert(string fromProjString, int toSrid, PointShape sourcePoint);
    public static Feature Convert(string fromProjString, int toSrid, Feature feature);
    public static RectangleShape Convert(string fromProjString, int toSrid, RectangleShape rectangleShape);
    public static IEnumerable`1<Feature> Convert(string fromProjString, int toSrid, IEnumerable`1<Feature> features);
    public static IEnumerable`1<Vertex> Convert(string fromProjString, int toSrid, IEnumerable`1<Vertex> vertices);
    public static Vertex Convert(string fromProjString, int toSrid, double x, double y);
    public static PointShape Convert(string fromProjString, string toProjString, PointShape sourcePoint);
    public static Feature Convert(string fromProjString, string toProjString, Feature feature);
    public static RectangleShape Convert(string fromProjString, string toProjString, RectangleShape rectangleShape);
    public static IEnumerable`1<Feature> Convert(string fromProjString, string toProjString, IEnumerable`1<Feature> features);
    public static IEnumerable`1<Vertex> Convert(string fromProjString, string toProjString, IEnumerable`1<Vertex> vertices);
    public static Vertex Convert(string fromProjString, string toProjString, double x, double y);
    private static void vho=(int errorNumber);
}
public class ThinkGeo.Core.QualityFamilyAreaStyle : AreaStyle {
    [ObfuscationAttribute]
private Collection`1<AreaStyle> areaStyles;
    [ObfuscationAttribute]
private Dictionary`2<string, AreaStyle> cache;
    [ObfuscationAttribute]
private int numberOfColors;
    public int NumberOfColors { get; public set; }
    public Dictionary`2<string, AreaStyle> Cache { get; }
    public GeoColor BaseColor { get; public set; }
    public QualityFamilyAreaStyle(GeoPen outlinePen, GeoColor baseColor, int numberOfColors);
    public QualityFamilyAreaStyle(GeoPen outlinePen, GeoColor baseColor, int numberOfColors, PenBrushDrawingOrder penBrushDrawingOrder);
    public int get_NumberOfColors();
    public void set_NumberOfColors(int value);
    public Dictionary`2<string, AreaStyle> get_Cache();
    public GeoColor get_BaseColor();
    public void set_BaseColor(GeoColor value);
    public void ClearCache();
    protected virtual void DrawCore(IEnumerable`1<Feature> features, GeoCanvas canvas, Collection`1<SimpleCandidate> labelsInThisLayer, Collection`1<SimpleCandidate> labelsInAllLayers);
}
public class ThinkGeo.Core.QueryTools : object {
    [ObfuscationAttribute]
private FeatureSource featureSource;
    public bool CanExecuteSqlQuery { get; }
    public QueryTools(FeatureSource featureSource);
    public Collection`1<Feature> GetFeaturesByColumnValue(string columnName, string columnValue, ReturningColumnsType returningColumnType);
    public Collection`1<Feature> GetFeaturesByColumnValue(string columnName, string columnValue, IEnumerable`1<string> returningColumnNames);
    public Collection`1<Feature> GetFeaturesByColumnValue(string columnName, string columnValue);
    public Collection`1<Feature> GetFeaturesContaining(BaseShape targetShape, IEnumerable`1<string> returningColumnNames);
    public Collection`1<Feature> GetFeaturesContaining(BaseShape targetShape, ReturningColumnsType returningColumnNamesType);
    public Collection`1<Feature> GetFeaturesContaining(Feature targetFeature, IEnumerable`1<string> returningColumnNames);
    public Collection`1<Feature> GetFeaturesContaining(Feature targetFeature, ReturningColumnsType returningColumnNamesType);
    public Collection`1<Feature> GetFeaturesCrossing(BaseShape targetShape, IEnumerable`1<string> returningColumnNames);
    public Collection`1<Feature> GetFeaturesCrossing(BaseShape targetShape, ReturningColumnsType returningColumnNamesType);
    public Collection`1<Feature> GetFeaturesCrossing(Feature targetFeature, IEnumerable`1<string> returningColumnNames);
    public Collection`1<Feature> GetFeaturesCrossing(Feature targetFeature, ReturningColumnsType returningColumnNamesType);
    public Collection`1<Feature> GetFeaturesDisjointed(BaseShape targetShape, IEnumerable`1<string> returningColumnNames);
    public Collection`1<Feature> GetFeaturesDisjointed(BaseShape targetShape, ReturningColumnsType returningColumnNamesType);
    public Collection`1<Feature> GetFeaturesDisjointed(Feature targetFeature, IEnumerable`1<string> returningColumnNames);
    public Collection`1<Feature> GetFeaturesDisjointed(Feature targetFeature, ReturningColumnsType returningColumnNamesType);
    public Collection`1<Feature> GetFeaturesIntersecting(BaseShape targetShape, IEnumerable`1<string> returningColumnNames);
    public Collection`1<Feature> GetFeaturesIntersecting(BaseShape targetShape, ReturningColumnsType returningColumnNamesType);
    public Collection`1<Feature> GetFeaturesIntersecting(Feature targetFeature, IEnumerable`1<string> returningColumnNames);
    public Collection`1<Feature> GetFeaturesIntersecting(Feature targetFeature, ReturningColumnsType returningColumnNamesType);
    public Collection`1<Feature> GetFeaturesOverlapping(BaseShape targetShape, IEnumerable`1<string> returningColumnNames);
    public Collection`1<Feature> GetFeaturesOverlapping(BaseShape targetShape, ReturningColumnsType returningColumnNamesType);
    public Collection`1<Feature> GetFeaturesOverlapping(Feature targetFeature, IEnumerable`1<string> returningColumnNames);
    public Collection`1<Feature> GetFeaturesOverlapping(Feature targetFeature, ReturningColumnsType returningColumnNamesType);
    public Collection`1<Feature> GetFeaturesTopologicalEqual(BaseShape targetShape, IEnumerable`1<string> returningColumnNames);
    public Collection`1<Feature> GetFeaturesTopologicalEqual(BaseShape targetShape, ReturningColumnsType returningColumnNamesType);
    public Collection`1<Feature> GetFeaturesTopologicalEqual(Feature targetFeature, IEnumerable`1<string> returningColumnNames);
    public Collection`1<Feature> GetFeaturesTopologicalEqual(Feature targetFeature, ReturningColumnsType returningColumnNamesType);
    public Collection`1<Feature> GetFeaturesTouching(BaseShape targetShape, IEnumerable`1<string> returningColumnNames);
    public Collection`1<Feature> GetFeaturesTouching(BaseShape targetShape, ReturningColumnsType returningColumnNamesType);
    public Collection`1<Feature> GetFeaturesTouching(Feature targetFeature, IEnumerable`1<string> returningColumnNames);
    public Collection`1<Feature> GetFeaturesTouching(Feature targetFeature, ReturningColumnsType returningColumnNamesType);
    public Collection`1<Feature> GetFeaturesWithin(BaseShape targetShape, IEnumerable`1<string> returningColumnNames);
    public Collection`1<Feature> GetFeaturesWithin(BaseShape targetShape, ReturningColumnsType returningColumnNamesType);
    public Collection`1<Feature> GetFeaturesWithin(Feature targetFeature, IEnumerable`1<string> returningColumnNames);
    public Collection`1<Feature> GetFeaturesWithin(Feature targetFeature, ReturningColumnsType returningColumnNamesType);
    public Collection`1<Feature> GetFeaturesOutsideBoundingBox(RectangleShape boundingBox, IEnumerable`1<string> returningColumnNames);
    public Collection`1<Feature> GetFeaturesOutsideBoundingBox(RectangleShape boundingBox, ReturningColumnsType returningColumnNamesType);
    public Collection`1<Feature> GetFeaturesInsideBoundingBox(RectangleShape boundingBox, IEnumerable`1<string> returningColumnNames);
    public Collection`1<Feature> GetFeaturesInsideBoundingBox(RectangleShape boundingBox, ReturningColumnsType returningColumnNamesType);
    public Collection`1<Feature> GetFeaturesNearestTo(BaseShape targetShape, GeographyUnit unitOfData, int maxItemsToFind, IEnumerable`1<string> returningColumnNames);
    public Collection`1<Feature> GetFeaturesNearestTo(BaseShape targetShape, GeographyUnit unitOfData, int maxItemsToFind, ReturningColumnsType returningColumnNamesType);
    public Collection`1<Feature> GetFeaturesNearestTo(Feature targetFeature, GeographyUnit unitOfData, int maxItemsToFind, IEnumerable`1<string> returningColumnNames);
    public Collection`1<Feature> GetFeaturesNearestTo(Feature targetFeature, GeographyUnit unitOfData, int maxItemsToFind, ReturningColumnsType returningColumnNamesType);
    public Collection`1<Feature> GetFeaturesNearestTo(Feature targetFeature, GeographyUnit unitOfData, int maxItemsToFind, IEnumerable`1<string> returningColumnNames, double searchRadius, DistanceUnit unitOfSearchRadius);
    public Collection`1<Feature> GetFeaturesNearestTo(BaseShape targetShape, GeographyUnit unitOfData, int maxItemsToFind, IEnumerable`1<string> returningColumnNames, double searchRadius, DistanceUnit unitOfSearchRadius);
    public Collection`1<Feature> GetFeaturesWithinDistanceOf(BaseShape targetShape, GeographyUnit unitOfData, DistanceUnit distanceUnit, double distance, IEnumerable`1<string> returningColumnNames);
    public Collection`1<Feature> GetFeaturesWithinDistanceOf(BaseShape targetShape, GeographyUnit unitOfData, DistanceUnit distanceUnit, double distance, ReturningColumnsType returningColumnNamesType);
    public Collection`1<Feature> GetFeaturesWithinDistanceOf(Feature targetFeature, GeographyUnit unitOfData, DistanceUnit distanceUnit, double distance, IEnumerable`1<string> returningColumnNames);
    public Collection`1<Feature> GetFeaturesWithinDistanceOf(Feature targetFeature, GeographyUnit unitOfData, DistanceUnit distanceUnit, double distance, ReturningColumnsType returningColumnNamesType);
    public Feature GetFeatureById(string id, IEnumerable`1<string> returningColumnNames);
    public Feature GetFeatureById(string id, ReturningColumnsType returningColumnNamesType);
    public Collection`1<Feature> GetFeaturesByIds(IEnumerable`1<string> ids, IEnumerable`1<string> returningColumnNames);
    public Collection`1<Feature> GetFeaturesByIds(IEnumerable`1<string> ids, ReturningColumnsType returningColumnNamesType);
    public RectangleShape GetBoundingBoxById(string id);
    public Collection`1<RectangleShape> GetBoundingBoxesByIds(IEnumerable`1<string> ids);
    public Collection`1<FeatureSourceColumn> GetColumns();
    public long GetCount();
    public Collection`1<Feature> GetAllFeatures(IEnumerable`1<string> returningColumnNames);
    public Collection`1<Feature> GetAllFeatures(ReturningColumnsType returningColumnNamesType);
    public WellKnownType GetFirstFeaturesWellKnownType();
    public bool get_CanExecuteSqlQuery();
    public int ExecuteNonQuery(string sqlStatement);
    public object ExecuteScalar(string sqlStatement);
    public DataTable ExecuteQuery(string sqlStatement);
}
public enum ThinkGeo.Core.QueryType : Enum {
    public int value__;
    public static QueryType Disjoint;
    public static QueryType Intersects;
    public static QueryType Touches;
    public static QueryType Crosses;
    public static QueryType Within;
    public static QueryType Contains;
    public static QueryType Overlaps;
    public static QueryType TopologicalEqual;
}
public enum ThinkGeo.Core.RandomColorType : Enum {
    public int value__;
    public static RandomColorType All;
    public static RandomColorType Pastel;
    public static RandomColorType Bright;
}
public enum ThinkGeo.Core.RangeCheckingInclusion : Enum {
    public int value__;
    public static RangeCheckingInclusion IncludeValue;
    public static RangeCheckingInclusion ExcludeValue;
}
public abstract class ThinkGeo.Core.RasterLayer : Layer {
    [ObfuscationAttribute]
private double upperThreshold;
    [ObfuscationAttribute]
private double lowerThreshold;
    [ObfuscationAttribute]
private RasterSource imageSource;
    public RasterSource ImageSource { get; protected set; }
    public double UpperThreshold { get; public set; }
    public double LowerThreshold { get; public set; }
    public double ScaleFactor { get; public set; }
    public Projection Projection { get; }
    protected bool IsOpenCore { get; }
    public RasterSource get_ImageSource();
    protected void set_ImageSource(RasterSource value);
    public double get_UpperThreshold();
    public void set_UpperThreshold(double value);
    public double get_LowerThreshold();
    public void set_LowerThreshold(double value);
    public double get_ScaleFactor();
    public void set_ScaleFactor(double value);
    public virtual Projection get_Projection();
    protected virtual bool get_IsOpenCore();
    public float GetHorizontalResolution();
    public float GetVerticalResolution();
    protected virtual RectangleShape GetBoundingBoxCore();
    protected virtual void OpenCore();
    protected virtual void CloseCore();
    protected virtual bool IsDrawingNeededCore(double currentScale);
    protected virtual void DrawCore(GeoCanvas canvas, Collection`1<SimpleCandidate> labelsInAllLayers);
    private void VCA=(GeoCanvas canvas);
    private void VSA=(GeoCanvas canvas);
    private void ViA=(GeoCanvas canvas);
}
public class ThinkGeo.Core.RasterProjectionResult : object {
    [ObfuscationAttribute]
private GeoImage image;
    [ObfuscationAttribute]
private RectangleShape imageExtent;
    public GeoImage Image { get; public set; }
    public RectangleShape ImageExtent { get; public set; }
    public RasterProjectionResult(GeoImage image, RectangleShape imageExtent);
    public GeoImage get_Image();
    public void set_Image(GeoImage value);
    public RectangleShape get_ImageExtent();
    public void set_ImageExtent(RectangleShape value);
}
public abstract class ThinkGeo.Core.RasterSource : object {
    [ObfuscationAttribute]
private float transparency;
    [ObfuscationAttribute]
private float redTranslation;
    [ObfuscationAttribute]
private float greenTranslation;
    [ObfuscationAttribute]
private float blueTranslation;
    [ObfuscationAttribute]
private bool isNegative;
    [ObfuscationAttribute]
private bool isGrayscale;
    private bool pBo=;
    [ObfuscationAttribute]
private ProjectionConverter projectionConverter;
    [ObfuscationAttribute]
private Projection projection;
    [ObfuscationAttribute]
private double scaleFactor;
    [CompilerGeneratedAttribute]
private EventHandler`1<OpeningRasterSourceEventArgs> tx4=;
    [CompilerGeneratedAttribute]
private EventHandler`1<OpenedRasterSourceEventArgs> uB4=;
    [CompilerGeneratedAttribute]
private EventHandler`1<ClosingRasterSourceEventArgs> uR4=;
    [CompilerGeneratedAttribute]
private EventHandler`1<ClosedRasterSourceEventArgs> uh4=;
    [CompilerGeneratedAttribute]
private EventHandler`1<jR4=> ux4=;
    public ProjectionConverter ProjectionConverter { get; public set; }
    public Projection Projection { get; protected set; }
    public float Transparency { get; public set; }
    public float BlueTranslation { get; public set; }
    public float RedTranslation { get; public set; }
    public float GreenTranslation { get; public set; }
    public bool IsNegative { get; public set; }
    public bool IsGrayscale { get; public set; }
    public double ScaleFactor { get; public set; }
    public bool IsOpen { get; protected set; }
    [CompilerGeneratedAttribute]
public void add_OpeningRasterSource(EventHandler`1<OpeningRasterSourceEventArgs> value);
    [CompilerGeneratedAttribute]
public void remove_OpeningRasterSource(EventHandler`1<OpeningRasterSourceEventArgs> value);
    [CompilerGeneratedAttribute]
public void add_OpenedRasterSource(EventHandler`1<OpenedRasterSourceEventArgs> value);
    [CompilerGeneratedAttribute]
public void remove_OpenedRasterSource(EventHandler`1<OpenedRasterSourceEventArgs> value);
    [CompilerGeneratedAttribute]
public void add_ClosingRasterSource(EventHandler`1<ClosingRasterSourceEventArgs> value);
    [CompilerGeneratedAttribute]
public void remove_ClosingRasterSource(EventHandler`1<ClosingRasterSourceEventArgs> value);
    [CompilerGeneratedAttribute]
public void add_ClosedRasterSource(EventHandler`1<ClosedRasterSourceEventArgs> value);
    [CompilerGeneratedAttribute]
public void remove_ClosedRasterSource(EventHandler`1<ClosedRasterSourceEventArgs> value);
    [CompilerGeneratedAttribute]
internal void vB4=(EventHandler`1<jR4=> value);
    [CompilerGeneratedAttribute]
internal void vR4=(EventHandler`1<jR4=> value);
    public ProjectionConverter get_ProjectionConverter();
    public void set_ProjectionConverter(ProjectionConverter value);
    public Projection get_Projection();
    protected void set_Projection(Projection value);
    public float get_Transparency();
    public void set_Transparency(float value);
    public float get_BlueTranslation();
    public void set_BlueTranslation(float value);
    public float get_RedTranslation();
    public void set_RedTranslation(float value);
    public float get_GreenTranslation();
    public void set_GreenTranslation(float value);
    public bool get_IsNegative();
    public void set_IsNegative(bool value);
    public bool get_IsGrayscale();
    public void set_IsGrayscale(bool value);
    public double get_ScaleFactor();
    public void set_ScaleFactor(double value);
    protected virtual void OnOpeningRasterSource(OpeningRasterSourceEventArgs e);
    internal virtual void vx4=(jR4= e);
    protected virtual void OnOpenedRasterSource(OpenedRasterSourceEventArgs e);
    protected virtual void OnClosingRasterSource(ClosingRasterSourceEventArgs e);
    protected virtual void OnClosedRasterSource(ClosedRasterSourceEventArgs e);
    public RasterSource CloneDeep();
    protected virtual RasterSource CloneDeepCore();
    public string GetWorldFileText();
    public static string GenerateWorldFileText(RectangleShape worldExtent, int imageWidth, int imageHeight);
    public int GetImageWidth();
    protected abstract virtual int GetImageWidthCore();
    public int GetImageHeight();
    protected abstract virtual int GetImageHeightCore();
    public float GetHorizontalResolution();
    public float GetVerticalResolution();
    public RectangleShape GetBoundingBox();
    protected abstract virtual RectangleShape GetBoundingBoxCore();
    public bool get_IsOpen();
    protected void set_IsOpen(bool value);
    public void Open();
    protected abstract virtual void OpenCore();
    public void Close();
    protected virtual void CloseCore();
    public GeoImage GetImage(RectangleShape worldExtent, int canvasWidth, int canvasHeight);
    internal GeoImage wB4=(RectangleShape boundingBox, double screenWidth, double screenHeight, RectangleShape wrappingExtent);
    internal GeoImage wR4=(RectangleShape boundingBox, double screenWidth, double screenHeight, RectangleShape wrappingExtent);
    protected abstract virtual GeoImage GetImageCore(RectangleShape worldExtent, int canvasWidth, int canvasHeight);
}
public class ThinkGeo.Core.RasterTile : Tile {
    [ObfuscationAttribute]
private GeoImage bitmap;
    [CompilerGeneratedAttribute]
private Byte[] 1h0=;
    [ObsoleteAttribute("This property is obsoleted and will be removed on 14.4, please use GetImage() instead")]
public GeoImage Bitmap { get; public set; }
    public Byte[] RasterData { get; public set; }
    public RasterTile(Byte[] rasterData, int zoom, long column, long row);
    public GeoImage get_Bitmap();
    public void set_Bitmap(GeoImage value);
    [CompilerGeneratedAttribute]
public Byte[] get_RasterData();
    [CompilerGeneratedAttribute]
public void set_RasterData(Byte[] value);
    public GeoImage GetImage();
    protected virtual override void Finalize();
    public sealed virtual void Dispose();
    private void 1x0=(bool disposing);
}
public abstract class ThinkGeo.Core.RasterTileCache : TileCache {
    [ObfuscationAttribute]
private GeoImageFormat imageFormat;
    [ObfuscationAttribute]
private short jpegQuality;
    private GeoImage xx0=;
    private GeoImage yB0=;
    public GeoImage NoDataTileImage { get; }
    public GeoImage LoadingTileImage { get; }
    public GeoImageFormat ImageFormat { get; public set; }
    public short JpegQuality { get; public set; }
    protected RasterTileCache(string cacheId, GeoImageFormat imageFormat);
    public GeoImage get_NoDataTileImage();
    public GeoImage get_LoadingTileImage();
    public GeoImageFormat get_ImageFormat();
    public void set_ImageFormat(GeoImageFormat value);
    public short get_JpegQuality();
    public void set_JpegQuality(short value);
    public virtual string ToString();
}
[ObsoleteAttribute("This enum is obsoleted, please use GeoImageFormat instead")]
public enum ThinkGeo.Core.RasterTileFormat : Enum {
    public int value__;
    public static RasterTileFormat Png;
    public static RasterTileFormat Jpeg;
}
internal enum ThinkGeo.Core.ReadType : Enum {
    public int value__;
    public static ReadType Read;
    public static ReadType ReadAsInt32;
    public static ReadType ReadAsInt64;
    public static ReadType ReadAsBytes;
    public static ReadType ReadAsString;
    public static ReadType ReadAsDecimal;
    public static ReadType ReadAsDateTime;
    public static ReadType ReadAsDouble;
    public static ReadType ReadAsBoolean;
}
public class ThinkGeo.Core.RebuildingShapeFileFeatureSourceEventArgs : EventArgs {
    [ObfuscationAttribute]
private long recordCount;
    [ObfuscationAttribute]
private long currentRecordIndex;
    [ObfuscationAttribute]
private Feature currentFeature;
    [ObfuscationAttribute]
private DateTime startProcessTime;
    [ObfuscationAttribute]
private bool cancel;
    [ObfuscationAttribute]
private string shapePathFilename;
    public long RecordCount { get; }
    public long CurrentRecordIndex { get; }
    public Feature CurrentFeature { get; }
    public DateTime StartProcessTime { get; }
    public bool Cancel { get; public set; }
    public string ShapePathFilename { get; }
    public RebuildingShapeFileFeatureSourceEventArgs(long recordCount, long currentRecordIndex, Feature currentFeature, DateTime startProcessTime, bool cancel);
    public RebuildingShapeFileFeatureSourceEventArgs(long recordCount, long currentRecordIndex, Feature currentFeature, DateTime startProcessTime, bool cancel, string shapePathFilename);
    public long get_RecordCount();
    public long get_CurrentRecordIndex();
    public Feature get_CurrentFeature();
    public DateTime get_StartProcessTime();
    public bool get_Cancel();
    public void set_Cancel(bool value);
    public string get_ShapePathFilename();
}
public class ThinkGeo.Core.ReceivedHttpResponseMessageEventArgs : EventArgs {
    [CompilerGeneratedAttribute]
private HttpResponseMessage WSA=;
    public HttpResponseMessage ResponseMessage { get; public set; }
    public ReceivedHttpResponseMessageEventArgs(HttpResponseMessage responseMessage);
    [CompilerGeneratedAttribute]
public HttpResponseMessage get_ResponseMessage();
    [CompilerGeneratedAttribute]
public void set_ResponseMessage(HttpResponseMessage value);
}
[TypeConverterAttribute("ThinkGeo.Core.BaseShapeTypeConverter")]
public class ThinkGeo.Core.RectangleShape : AreaBaseShape {
    [ObfuscationAttribute]
private PointShape upperLeftPoint;
    [ObfuscationAttribute]
private PointShape lowerRightPoint;
    protected static double tolerance;
    public PointShape UpperLeftPoint { get; public set; }
    public PointShape UpperRightPoint { get; }
    public PointShape LowerRightPoint { get; public set; }
    public PointShape LowerLeftPoint { get; }
    public double Height { get; }
    public double Width { get; }
    public double MinX { get; }
    public double MaxY { get; }
    public double MaxX { get; }
    public double MinY { get; }
    public RectangleShape(PointShape upperLeftPoint, PointShape lowerRightPoint);
    public RectangleShape(double minX, double maxY, double maxX, double minY);
    public RectangleShape(string wellKnownText);
    public RectangleShape(Byte[] wellKnownBinary);
    private static RectangleShape();
    private fxw= exw=(RectangleShape targetShape);
    private RectangleShape fBw=(RectangleShape targetShape);
    protected virtual bool IntersectsCore(BaseShape targetShape);
    public RectangleShape GetIntersection(RectangleShape targetShape);
    protected virtual WellKnownType GetWellKnownTypeCore();
    public PointShape get_UpperLeftPoint();
    public void set_UpperLeftPoint(PointShape value);
    public PointShape get_UpperRightPoint();
    public PointShape get_LowerRightPoint();
    public void set_LowerRightPoint(PointShape value);
    public PointShape get_LowerLeftPoint();
    public double get_Height();
    public double get_Width();
    public double get_MinX();
    public double get_MaxY();
    public double get_MaxX();
    public double get_MinY();
    protected virtual BaseShape CloneDeepCore();
    public PolygonShape ToPolygon();
    private bool fRw=(RectangleShape targetShape);
    public void ExpandToInclude(BaseShape targetShape);
    public void ExpandToInclude(Feature targetFeature);
    public void ExpandToInclude(IEnumerable`1<BaseShape> targetShapes);
    public void ExpandToInclude(IEnumerable`1<Feature> targetFeatures);
    protected virtual PointShape GetCenterPointCore();
    protected virtual void ExpandToIncludeCore(BaseShape targetShape);
    protected virtual double GetPerimeterCore(GeographyUnit shapeUnit, DistanceUnit returningUnit);
    protected virtual double GetAreaCore(GeographyUnit shapeUnit, AreaUnit returningUnit);
    protected virtual void ScaleUpCore(double percentage);
    protected virtual void ScaleDownCore(double percentage);
    protected virtual RectangleShape GetBoundingBoxCore();
    protected virtual BaseShape RegisterCore(PointShape fromPoint, PointShape toPoint, DistanceUnit fromUnit, GeographyUnit toUnit);
    protected virtual void TranslateByOffsetCore(double xOffsetDistance, double yOffsetDistance, GeographyUnit shapeUnit, DistanceUnit distanceUnit);
    protected virtual void TranslateByDegreeCore(double distance, double angleInDegrees, GeographyUnit shapeUnit, DistanceUnit distanceUnit);
    protected virtual PointShape GetClosestPointToCore(BaseShape targetShape, GeographyUnit shapeUnit);
    protected virtual double GetDistanceToCore(BaseShape targetShape, GeographyUnit shapeUnit, DistanceUnit distanceUnit);
    protected virtual string GetWellKnownTextCore(RingOrder outerRingOrder);
    protected virtual Byte[] GetWellKnownBinaryCore(RingOrder outerRingOrder, WkbByteOrder byteOrder);
    protected virtual void LoadFromWellKnownDataCore(string wellKnownText);
    protected virtual void LoadFromWellKnownDataCore(Byte[] wellKnownBinary);
    protected virtual bool IsDisjointedCore(BaseShape targetShape);
    private static void fhw=(RectangleShape fromRectangle, RectangleShape toRectangle);
    protected virtual ShapeValidationResult ValidateCore(ShapeValidationMode validationMode);
    protected virtual MultipointShape GetCrossingCore(BaseShape targetShape);
    protected virtual bool ContainsCore(BaseShape targetShape);
    public virtual string ToString();
    private void TRU=(double multiplicator);
}
public class ThinkGeo.Core.RegexItem : object {
    [ObfuscationAttribute]
private string regularExpression;
    [ObfuscationAttribute]
private PointStyle defaultPointStyle;
    [ObfuscationAttribute]
private LineStyle defaultLineStyle;
    [ObfuscationAttribute]
private AreaStyle defaultAreaStyle;
    [ObfuscationAttribute]
private TextStyle defaultTextStyle;
    [ObfuscationAttribute]
private Collection`1<Style> customStyles;
    public string RegularExpression { get; public set; }
    public Collection`1<Style> CustomStyles { get; }
    public AreaStyle DefaultAreaStyle { get; public set; }
    public LineStyle DefaultLineStyle { get; public set; }
    public PointStyle DefaultPointStyle { get; public set; }
    public TextStyle DefaultTextStyle { get; public set; }
    public RegexItem(string regularExpression, AreaStyle areaStyle);
    public RegexItem(string regularExpression, LineStyle lineStyle);
    public RegexItem(string regularExpression, PointStyle pointStyle);
    public RegexItem(string regularExpression, TextStyle textStyle);
    public RegexItem(string regularExpression, Collection`1<Style> styles);
    private RegexItem(string regularExpression, AreaStyle areaStyle, LineStyle lineStyle, PointStyle pointStyle, TextStyle textStyle, Collection`1<Style> styles);
    public string get_RegularExpression();
    public void set_RegularExpression(string value);
    public Collection`1<Style> get_CustomStyles();
    public AreaStyle get_DefaultAreaStyle();
    public void set_DefaultAreaStyle(AreaStyle value);
    public LineStyle get_DefaultLineStyle();
    public void set_DefaultLineStyle(LineStyle value);
    public PointStyle get_DefaultPointStyle();
    public void set_DefaultPointStyle(PointStyle value);
    public TextStyle get_DefaultTextStyle();
    public void set_DefaultTextStyle(TextStyle value);
}
public enum ThinkGeo.Core.RegexMatching : Enum {
    public int value__;
    public static RegexMatching MatchFirstOnly;
    public static RegexMatching MatchAll;
}
public class ThinkGeo.Core.RegexStyle : Style {
    [ObfuscationAttribute]
private string columnName;
    [ObfuscationAttribute]
private Collection`1<RegexItem> regexItems;
    [ObfuscationAttribute]
private RegexMatching regexMatchingRule;
    public RegexMatching RegexMatchingRule { get; public set; }
    public string ColumnName { get; public set; }
    public Collection`1<RegexItem> RegexItems { get; }
    public RegexStyle(string columnName, Collection`1<RegexItem> regexItems);
    public RegexStyle(string columnName, Collection`1<RegexItem> regexItems, RegexMatching regexMatching);
    public RegexMatching get_RegexMatchingRule();
    public void set_RegexMatchingRule(RegexMatching value);
    public string get_ColumnName();
    public void set_ColumnName(string value);
    public Collection`1<RegexItem> get_RegexItems();
    protected virtual void DrawCore(IEnumerable`1<Feature> features, GeoCanvas canvas, Collection`1<SimpleCandidate> labelsInThisLayer, Collection`1<SimpleCandidate> labelsInAllLayers);
    protected virtual Collection`1<string> GetRequiredColumnNamesCore();
    private Collection`1<RegexItem> 4TE=(string columnValue, RegexMatching regexMatching);
    private static void ujE=(Collection`1<string> requiredFieldNames, Collection`1<string> fieldNames);
}
public class ThinkGeo.Core.RemovedGeoCollectionEventArgs : EventArgs {
    [ObfuscationAttribute]
private object item;
    [ObfuscationAttribute]
private int index;
    public object Item { get; public set; }
    public int Index { get; public set; }
    public RemovedGeoCollectionEventArgs(object item);
    public RemovedGeoCollectionEventArgs(object item, int index);
    public object get_Item();
    public void set_Item(object value);
    public int get_Index();
    public void set_Index(int value);
}
public class ThinkGeo.Core.RemovingGeoCollectionEventArgs : EventArgs {
    [ObfuscationAttribute]
private object item;
    public object Item { get; public set; }
    public RemovingGeoCollectionEventArgs(object item);
    public object get_Item();
    public void set_Item(object value);
}
public enum ThinkGeo.Core.RequestDrawingBufferTimeType : Enum {
    public int value__;
    public static RequestDrawingBufferTimeType Default;
    public static RequestDrawingBufferTimeType MinimumDelay;
    public static RequestDrawingBufferTimeType ResetDelay;
}
public class ThinkGeo.Core.RequestedDataWfsFeatureSourceEventArgs : EventArgs {
    [ObfuscationAttribute]
private string xmlResponse;
    [ObfuscationAttribute]
private string serviceUrl;
    public string XmlResponse { get; }
    public string ServiceUrl { get; }
    public RequestedDataWfsFeatureSourceEventArgs(string serviceUrl, string xmlResponse);
    public string get_XmlResponse();
    public string get_ServiceUrl();
}
public class ThinkGeo.Core.RequestedDrawingLayerEventArgs : EventArgs {
    [ObfuscationAttribute]
private TimeSpan bufferTime;
    [ObfuscationAttribute]
private RequestDrawingBufferTimeType bufferTimeType;
    [ObfuscationAttribute]
private Collection`1<RectangleShape> extentsToRefresh;
    public TimeSpan BufferTime { get; public set; }
    public RequestDrawingBufferTimeType BufferTimeType { get; public set; }
    public Collection`1<RectangleShape> ExtentsToRefresh { get; }
    public RequestedDrawingLayerEventArgs(RectangleShape extentToRefresh);
    public RequestedDrawingLayerEventArgs(IEnumerable`1<RectangleShape> extentsToRefresh);
    public RequestedDrawingLayerEventArgs(TimeSpan bufferTime);
    public RequestedDrawingLayerEventArgs(TimeSpan bufferTime, RequestDrawingBufferTimeType bufferTimeType);
    public RequestedDrawingLayerEventArgs(RectangleShape extentToRefresh, TimeSpan bufferTime);
    public RequestedDrawingLayerEventArgs(RectangleShape extentToRefresh, TimeSpan bufferTime, RequestDrawingBufferTimeType bufferTimeType);
    public RequestedDrawingLayerEventArgs(IEnumerable`1<RectangleShape> extentsToRefresh, TimeSpan bufferTime);
    public RequestedDrawingLayerEventArgs(IEnumerable`1<RectangleShape> extentsToRefresh, TimeSpan bufferTime, RequestDrawingBufferTimeType bufferTimeType);
    public TimeSpan get_BufferTime();
    public void set_BufferTime(TimeSpan value);
    public RequestDrawingBufferTimeType get_BufferTimeType();
    public void set_BufferTimeType(RequestDrawingBufferTimeType value);
    public Collection`1<RectangleShape> get_ExtentsToRefresh();
}
public class ThinkGeo.Core.RequestedImageExceptionEventArgs : EventArgs {
    [ObfuscationAttribute]
private GeoImage result;
    [ObfuscationAttribute]
private bool cancel;
    [ObsoleteAttribute("This property is obsoleted and will be removed after v14.4. Please use Exception instead.")]
[ObfuscationAttribute]
private string errorMsg;
    [ObfuscationAttribute]
private Exception exception;
    public GeoImage Result { get; public set; }
    public bool Cancel { get; public set; }
    public string ErrorMsg { get; public set; }
    public Exception Exception { get; public set; }
    [ObsoleteAttribute("This constructor is obsoleted and will be removed after v14.4.")]
public RequestedImageExceptionEventArgs(GeoImage geoImage, string errorMsg);
    public RequestedImageExceptionEventArgs(GeoImage geoImage, Exception exception);
    public GeoImage get_Result();
    public void set_Result(GeoImage value);
    public bool get_Cancel();
    public void set_Cancel(bool value);
    public string get_ErrorMsg();
    public void set_ErrorMsg(string value);
    public Exception get_Exception();
    public void set_Exception(Exception value);
}
public class ThinkGeo.Core.RequestingDataWfsFeatureSourceEventArgs : EventArgs {
    [ObfuscationAttribute]
private string serviceUrl;
    [ObfuscationAttribute]
private bool overrideResponse;
    [ObfuscationAttribute]
private string xmlResponse;
    public string ServiceUrl { get; public set; }
    public bool OverrideResponse { get; public set; }
    public string XmlResponse { get; public set; }
    public RequestingDataWfsFeatureSourceEventArgs(string serviceUrl, bool overrideResponse, string xmlResponse);
    public string get_ServiceUrl();
    public void set_ServiceUrl(string value);
    public bool get_OverrideResponse();
    public void set_OverrideResponse(bool value);
    public string get_XmlResponse();
    public void set_XmlResponse(string value);
}
public class ThinkGeo.Core.RequestingDrawingLayerEventArgs : EventArgs {
    [ObfuscationAttribute]
private TimeSpan bufferTime;
    [ObfuscationAttribute]
private RequestDrawingBufferTimeType bufferTimeType;
    [ObfuscationAttribute]
private Collection`1<RectangleShape> extentsToRefresh;
    [ObfuscationAttribute]
private bool cancel;
    public TimeSpan BufferTime { get; public set; }
    public Collection`1<RectangleShape> ExtentsToRefresh { get; }
    public RequestDrawingBufferTimeType BufferTimeType { get; public set; }
    public bool Cancel { get; public set; }
    public RequestingDrawingLayerEventArgs(RectangleShape extentToRefresh);
    public RequestingDrawingLayerEventArgs(IEnumerable`1<RectangleShape> extentsToRefresh);
    public RequestingDrawingLayerEventArgs(TimeSpan bufferTime);
    public RequestingDrawingLayerEventArgs(TimeSpan bufferTime, RequestDrawingBufferTimeType bufferTimeType);
    public RequestingDrawingLayerEventArgs(RectangleShape extentToRefresh, TimeSpan bufferTime);
    public RequestingDrawingLayerEventArgs(RectangleShape extentToRefresh, TimeSpan bufferTime, RequestDrawingBufferTimeType bufferTimeType);
    public RequestingDrawingLayerEventArgs(IEnumerable`1<RectangleShape> extentsToRefresh, TimeSpan bufferTime);
    public RequestingDrawingLayerEventArgs(IEnumerable`1<RectangleShape> extentsToRefresh, TimeSpan bufferTime, RequestDrawingBufferTimeType bufferTimeType);
    public TimeSpan get_BufferTime();
    public void set_BufferTime(TimeSpan value);
    public Collection`1<RectangleShape> get_ExtentsToRefresh();
    public RequestDrawingBufferTimeType get_BufferTimeType();
    public void set_BufferTimeType(RequestDrawingBufferTimeType value);
    public bool get_Cancel();
    public void set_Cancel(bool value);
}
public enum ThinkGeo.Core.RequestProtocol : Enum {
    public int value__;
    public static RequestProtocol Default;
    public static RequestProtocol Https;
    public static RequestProtocol Http;
}
[DebuggerNonUserCodeAttribute]
[GeneratedCodeAttribute("System.Resources.Tools.StronglyTypedResourceBuilder", "16.0.0.0")]
[ObfuscationAttribute]
[CompilerGeneratedAttribute]
internal class ThinkGeo.Core.Resources : object {
    private static ResourceManager resourceMan;
    private static CultureInfo resourceCulture;
    [EditorBrowsableAttribute("2")]
internal static ResourceManager ResourceManager { get; }
    [EditorBrowsableAttribute("2")]
internal static CultureInfo Culture { get; internal set; }
    internal static string ClientIDOrSecretInvalid { get; }
    internal static string InputMustValid { get; }
    internal static string ValueMustInRange { get; }
    internal static ResourceManager get_ResourceManager();
    internal static CultureInfo get_Culture();
    internal static void set_Culture(CultureInfo value);
    internal static string get_ClientIDOrSecretInvalid();
    internal static string get_InputMustValid();
    internal static string get_ValueMustInRange();
}
public class ThinkGeo.Core.RestrictionLayer : Layer {
    [ObfuscationAttribute]
private GeoCollection`1<Style> customStyles;
    [ObfuscationAttribute]
private Style defaultStyle;
    [ObfuscationAttribute]
private double lowerScale;
    [ObfuscationAttribute]
private RestrictionMode restrictionMode;
    [ObfuscationAttribute]
private RestrictionStyle restrictionStyle;
    [ObfuscationAttribute]
private double upperScale;
    [ObfuscationAttribute]
private GeoCollection`1<AreaBaseShape> zones;
    public double UpperScale { get; public set; }
    public double LowerScale { get; public set; }
    public GeoCollection`1<Style> CustomStyles { get; }
    public RestrictionMode RestrictionMode { get; public set; }
    public GeoCollection`1<AreaBaseShape> Zones { get; }
    public RestrictionStyle RestrictionStyle { get; public set; }
    public RestrictionLayer(IEnumerable`1<AreaBaseShape> zones);
    public RestrictionLayer(IEnumerable`1<AreaBaseShape> zones, RestrictionMode zonesToShowOrHide);
    public RestrictionLayer(IEnumerable`1<AreaBaseShape> zones, RestrictionMode zonesToShowOrHide, double upperScale, double lowerScale);
    public double get_UpperScale();
    public void set_UpperScale(double value);
    public double get_LowerScale();
    public void set_LowerScale(double value);
    public GeoCollection`1<Style> get_CustomStyles();
    public RestrictionMode get_RestrictionMode();
    public void set_RestrictionMode(RestrictionMode value);
    public GeoCollection`1<AreaBaseShape> get_Zones();
    public RestrictionStyle get_RestrictionStyle();
    public void set_RestrictionStyle(RestrictionStyle value);
    protected virtual RectangleShape GetBoundingBoxCore();
    protected virtual void DrawCore(GeoCanvas canvas, Collection`1<SimpleCandidate> labelsInAllLayers);
    private void 7SM=(GeoCanvas canvas);
    private void 7iM=(GeoCanvas canvas);
    private void 7yM=(GeoCanvas canvas);
    private void TxU=(IEnumerable`1<Feature> features, GeoCanvas canvas);
    private static Style 8CM=(Stream stream);
    private static Style 8SM=();
}
public enum ThinkGeo.Core.RestrictionMode : Enum {
    public int value__;
    public static RestrictionMode HideZones;
    public static RestrictionMode ShowZones;
}
public enum ThinkGeo.Core.RestrictionStyle : Enum {
    public int value__;
    public static RestrictionStyle HatchPattern;
    public static RestrictionStyle CircleWithSlashImage;
    public static RestrictionStyle UseCustomStyles;
}
public static class ThinkGeo.Core.RestrictionValidatorHelper : object {
    public static void CheckRestrictionModeIsValid(RestrictionMode restrictionMode, string parameterName);
    public static void CheckRestrictionStyleIsValid(RestrictionStyle restrictionStyle, string parameterName);
    public static void CheckRestrictionStyleIsNotConflicted(RestrictionStyle restrictionStyle, IEnumerable`1<Style> customStyles);
}
public enum ThinkGeo.Core.ReturningColumnsType : Enum {
    public int value__;
    public static ReturningColumnsType NoColumns;
    public static ReturningColumnsType AllColumns;
}
public class ThinkGeo.Core.ReverseGeocodingCloudClient : CloudClient {
    private static int /xQ=;
    private static int zRQ=;
    public ReverseGeocodingCloudClient(string clientId, string clientSecret);
    public CloudReverseGeocodingResult SearchPointInDecimalDegree(double latitude, double longitude, double searchRadius, DistanceUnit unitOfsearchRadius);
    public CloudReverseGeocodingResult SearchPointInDecimalDegree(double latitude, double longitude, double searchRadius, DistanceUnit unitOfsearchRadius, CloudReverseGeocodingOptions options);
    public CloudReverseGeocodingResult SearchPoint(double x, double y, int pointProjectionInSrid, double searchRadius, DistanceUnit unitOfsearchRadius);
    public CloudReverseGeocodingResult SearchPoint(double x, double y, int pointProjectionInSrid, double searchRadius, DistanceUnit unitOfsearchRadius, CloudReverseGeocodingOptions options);
    public CloudReverseGeocodingResult SearchPoint(double x, double y, string pointProjectionInProj4String, double searchRadius, DistanceUnit unitOfsearchRadius);
    public CloudReverseGeocodingResult SearchPoint(double x, double y, string pointProjectionInProj4String, double searchRadius, DistanceUnit unitOfsearchRadius, CloudReverseGeocodingOptions options);
    [AsyncStateMachineAttribute("ThinkGeo.Core.ReverseGeocodingCloudClient/hj4=")]
public Task`1<CloudReverseGeocodingResult> SearchPointInDecimalDegreeAsync(double latitude, double longitude, double searchRadius, DistanceUnit unitOfsearchRadius);
    [AsyncStateMachineAttribute("ThinkGeo.Core.ReverseGeocodingCloudClient/hz4=")]
public Task`1<CloudReverseGeocodingResult> SearchPointInDecimalDegreeAsync(double latitude, double longitude, double searchRadius, DistanceUnit unitOfsearchRadius, CloudReverseGeocodingOptions options);
    [AsyncStateMachineAttribute("ThinkGeo.Core.ReverseGeocodingCloudClient/gD4=")]
public Task`1<CloudReverseGeocodingResult> SearchPointAsync(double x, double y, int pointProjectionInSrid, double searchRadius, DistanceUnit unitOfsearchRadius);
    [AsyncStateMachineAttribute("ThinkGeo.Core.ReverseGeocodingCloudClient/gj4=")]
public Task`1<CloudReverseGeocodingResult> SearchPointAsync(double x, double y, int pointProjectionInSrid, double searchRadius, DistanceUnit unitOfsearchRadius, CloudReverseGeocodingOptions options);
    [AsyncStateMachineAttribute("ThinkGeo.Core.ReverseGeocodingCloudClient/gz4=")]
public Task`1<CloudReverseGeocodingResult> SearchPointAsync(double x, double y, string pointProjectionInProj4String, double searchRadius, DistanceUnit unitOfsearchRadius);
    [AsyncStateMachineAttribute("ThinkGeo.Core.ReverseGeocodingCloudClient/hD4=")]
public Task`1<CloudReverseGeocodingResult> SearchPointAsync(double x, double y, string pointProjectionInProj4String, double searchRadius, DistanceUnit unitOfsearchRadius, CloudReverseGeocodingOptions options);
    public Collection`1<CloudReverseGeocodingResult> SearchPointsInDecimalDegree(IEnumerable`1<PointShape> points, double searchRadius, DistanceUnit unitOfsearchRadius);
    public Collection`1<CloudReverseGeocodingResult> SearchPointsInDecimalDegree(IEnumerable`1<PointShape> points, double searchRadius, DistanceUnit unitOfsearchRadius, CloudReverseGeocodingOptions options);
    public Collection`1<CloudReverseGeocodingResult> SearchPoints(IEnumerable`1<PointShape> points, int pointsProjectionInSrid, double searchRadius, DistanceUnit unitOfsearchRadius);
    public Collection`1<CloudReverseGeocodingResult> SearchPoints(IEnumerable`1<PointShape> points, int pointsProjectionInSrid, double searchRadius, DistanceUnit unitOfsearchRadius, CloudReverseGeocodingOptions options);
    public Collection`1<CloudReverseGeocodingResult> SearchPoints(IEnumerable`1<PointShape> points, string pointsProjectionInProj4String, double searchRadius, DistanceUnit unitOfsearchRadius);
    public Collection`1<CloudReverseGeocodingResult> SearchPoints(IEnumerable`1<PointShape> points, string pointsProjectionInProj4String, double searchRadius, DistanceUnit unitOfsearchRadius, CloudReverseGeocodingOptions options);
    [AsyncStateMachineAttribute("ThinkGeo.Core.ReverseGeocodingCloudClient/jT4=")]
public Task`1<Collection`1<CloudReverseGeocodingResult>> SearchPointsInDecimalDegreeAsync(IEnumerable`1<PointShape> points, double searchRadius, DistanceUnit unitOfsearchRadius);
    [AsyncStateMachineAttribute("ThinkGeo.Core.ReverseGeocodingCloudClient/jj4=")]
public Task`1<Collection`1<CloudReverseGeocodingResult>> SearchPointsInDecimalDegreeAsync(IEnumerable`1<PointShape> points, double searchRadius, DistanceUnit unitOfsearchRadius, CloudReverseGeocodingOptions options);
    [AsyncStateMachineAttribute("ThinkGeo.Core.ReverseGeocodingCloudClient/iD4=")]
public Task`1<Collection`1<CloudReverseGeocodingResult>> SearchPointsAsync(IEnumerable`1<PointShape> points, int pointsProjectionInSrid, double searchRadius, DistanceUnit unitOfsearchRadius);
    [AsyncStateMachineAttribute("ThinkGeo.Core.ReverseGeocodingCloudClient/iT4=")]
public Task`1<Collection`1<CloudReverseGeocodingResult>> SearchPointsAsync(IEnumerable`1<PointShape> points, int pointsProjectionInSrid, double searchRadius, DistanceUnit unitOfsearchRadius, CloudReverseGeocodingOptions options);
    [AsyncStateMachineAttribute("ThinkGeo.Core.ReverseGeocodingCloudClient/ij4=")]
public Task`1<Collection`1<CloudReverseGeocodingResult>> SearchPointsAsync(IEnumerable`1<PointShape> points, string pointsProjectionInProj4String, double searchRadius, DistanceUnit unitOfsearchRadius);
    [AsyncStateMachineAttribute("ThinkGeo.Core.ReverseGeocodingCloudClient/iz4=")]
public Task`1<Collection`1<CloudReverseGeocodingResult>> SearchPointsAsync(IEnumerable`1<PointShape> points, string pointsProjectionInProj4String, double searchRadius, DistanceUnit unitOfsearchRadius, CloudReverseGeocodingOptions options);
    public CloudReverseGeocodingResult SearchLineInDecimalDegree(LineShape line, double searchBuffer, DistanceUnit unitOfsearchBuffer);
    public CloudReverseGeocodingResult SearchLineInDecimalDegree(LineShape line, double searchBuffer, DistanceUnit unitOfsearchBuffer, CloudReverseGeocodingOptions options);
    public CloudReverseGeocodingResult SearchLine(LineShape line, int lineProjectionInSrid, double searchBuffer, DistanceUnit unitOfsearchBuffer);
    public CloudReverseGeocodingResult SearchLine(LineShape line, int lineProjectionInSrid, double searchBuffer, DistanceUnit unitOfsearchBuffer, CloudReverseGeocodingOptions options);
    public CloudReverseGeocodingResult SearchLine(LineShape line, string lineProjectionInProj4String, double searchBuffer, DistanceUnit unitOfsearchBuffer);
    public CloudReverseGeocodingResult SearchLine(LineShape line, string lineProjectionInProj4String, double searchBuffer, DistanceUnit unitOfsearchBuffer, CloudReverseGeocodingOptions options);
    [AsyncStateMachineAttribute("ThinkGeo.Core.ReverseGeocodingCloudClient/fj4=")]
public Task`1<CloudReverseGeocodingResult> SearchLineInDecimalDegreeAsync(LineShape line, double searchBuffer, DistanceUnit unitOfsearchBuffer);
    [AsyncStateMachineAttribute("ThinkGeo.Core.ReverseGeocodingCloudClient/fz4=")]
public Task`1<CloudReverseGeocodingResult> SearchLineInDecimalDegreeAsync(LineShape line, double searchBuffer, DistanceUnit unitOfsearchBuffer, CloudReverseGeocodingOptions options);
    [AsyncStateMachineAttribute("ThinkGeo.Core.ReverseGeocodingCloudClient/dz4=")]
public Task`1<CloudReverseGeocodingResult> SearchLineAsync(LineShape line, int lineProjectionInSrid, double searchBuffer, DistanceUnit unitOfsearchBuffer);
    [AsyncStateMachineAttribute("ThinkGeo.Core.ReverseGeocodingCloudClient/ej4=")]
public Task`1<CloudReverseGeocodingResult> SearchLineAsync(LineShape line, int lineProjectionInSrid, double searchBuffer, DistanceUnit unitOfsearchBuffer, CloudReverseGeocodingOptions options);
    [AsyncStateMachineAttribute("ThinkGeo.Core.ReverseGeocodingCloudClient/ez4=")]
public Task`1<CloudReverseGeocodingResult> SearchLineAsync(LineShape line, string lineProjectionInProj4String, double searchBuffer, DistanceUnit unitOfsearchBuffer);
    [AsyncStateMachineAttribute("ThinkGeo.Core.ReverseGeocodingCloudClient/fD4=")]
public Task`1<CloudReverseGeocodingResult> SearchLineAsync(LineShape line, string lineProjectionInProj4String, double searchBuffer, DistanceUnit unitOfsearchBuffer, CloudReverseGeocodingOptions options);
    public CloudReverseGeocodingResult SearchAreaInDecimalDegree(PolygonShape area);
    public CloudReverseGeocodingResult SearchAreaInDecimalDegree(PolygonShape area, CloudReverseGeocodingOptions options);
    public CloudReverseGeocodingResult SearchArea(PolygonShape area, int areaProjectionInSrid);
    public CloudReverseGeocodingResult SearchArea(PolygonShape area, int areaProjectionInSrid, CloudReverseGeocodingOptions options);
    public CloudReverseGeocodingResult SearchArea(PolygonShape area, string areaProjectionInProj4String);
    public CloudReverseGeocodingResult SearchArea(PolygonShape area, string areaProjectionInProj4String, CloudReverseGeocodingOptions options);
    [AsyncStateMachineAttribute("ThinkGeo.Core.ReverseGeocodingCloudClient/dT4=")]
public Task`1<CloudReverseGeocodingResult> SearchAreaInDecimalDegreeAsync(PolygonShape area);
    [AsyncStateMachineAttribute("ThinkGeo.Core.ReverseGeocodingCloudClient/dj4=")]
public Task`1<CloudReverseGeocodingResult> SearchAreaInDecimalDegreeAsync(PolygonShape area, CloudReverseGeocodingOptions options);
    [AsyncStateMachineAttribute("ThinkGeo.Core.ReverseGeocodingCloudClient/cD4=")]
public Task`1<CloudReverseGeocodingResult> SearchAreaAsync(PolygonShape area, int areaProjectionInSrid);
    [AsyncStateMachineAttribute("ThinkGeo.Core.ReverseGeocodingCloudClient/cT4=")]
public Task`1<CloudReverseGeocodingResult> SearchAreaAsync(PolygonShape area, int areaProjectionInSrid, CloudReverseGeocodingOptions options);
    [AsyncStateMachineAttribute("ThinkGeo.Core.ReverseGeocodingCloudClient/cj4=")]
public Task`1<CloudReverseGeocodingResult> SearchAreaAsync(PolygonShape area, string areaProjectionInProj4String);
    [AsyncStateMachineAttribute("ThinkGeo.Core.ReverseGeocodingCloudClient/cz4=")]
public Task`1<CloudReverseGeocodingResult> SearchAreaAsync(PolygonShape area, string areaProjectionInProj4String, CloudReverseGeocodingOptions options);
    private CloudReverseGeocodingResult ABU=(double x, double y, Nullable`1<int> projectionInSrid, string projectionInProj4String, double searchRadius, DistanceUnit unitOfsearchRadius, CloudReverseGeocodingOptions options);
    [AsyncStateMachineAttribute("ThinkGeo.Core.ReverseGeocodingCloudClient/hT4=")]
private Task`1<CloudReverseGeocodingResult> ARU=(double x, double y, Nullable`1<int> projectionInSrid, string projectionInProj4String, double searchRadius, DistanceUnit unitOfsearchRadius, CloudReverseGeocodingOptions options);
    private Collection`1<CloudReverseGeocodingResult> AhU=(IEnumerable`1<PointShape> points, Nullable`1<int> projectionInSrid, string projectionInProj4String, double searchRadius, DistanceUnit unitOfsearchRadius, CloudReverseGeocodingOptions options);
    [AsyncStateMachineAttribute("ThinkGeo.Core.ReverseGeocodingCloudClient/jD4=")]
private Task`1<Collection`1<CloudReverseGeocodingResult>> AxU=(IEnumerable`1<PointShape> points, Nullable`1<int> projectionInSrid, string projectionInProj4String, double searchRadius, DistanceUnit unitOfsearchRadius, CloudReverseGeocodingOptions options);
    private CloudReverseGeocodingResult BBU=(LineShape line, Nullable`1<int> projectionInSrid, string projectionInProj4String, double searchBuffer, DistanceUnit unitOfsearchBuffer, CloudReverseGeocodingOptions options);
    [AsyncStateMachineAttribute("ThinkGeo.Core.ReverseGeocodingCloudClient/fT4=")]
private Task`1<CloudReverseGeocodingResult> BRU=(LineShape line, Nullable`1<int> projectionInSrid, string projectionInProj4String, double searchBuffer, DistanceUnit unitOfsearchBuffer, CloudReverseGeocodingOptions options);
    private CloudReverseGeocodingResult BhU=(PolygonShape area, Nullable`1<int> projectionInSrid, string projectionInProj4String, CloudReverseGeocodingOptions options);
    [AsyncStateMachineAttribute("ThinkGeo.Core.ReverseGeocodingCloudClient/dD4=")]
private Task`1<CloudReverseGeocodingResult> BxU=(PolygonShape area, Nullable`1<int> projectionInSrid, string projectionInProj4String, CloudReverseGeocodingOptions options);
    private static string CBU=(CloudReverseGeocodingOptions options, Nullable`1<int> projectionInSrid, string projectionInProj4String, Nullable`1<double> searchRadius, Nullable`1<DistanceUnit> unitOfsearchRadius, string additionalQueryString);
    private static string CRU=(CloudReverseGeocodingOptions options, Nullable`1<int> projectionInSrid, string projectionInProj4String, Nullable`1<double> searchRadius, Nullable`1<DistanceUnit> unitOfsearchRadius, string wkt);
    private static CloudReverseGeocodingResult ChU=(WebResponse response, BaseShape queryShape);
    private static Collection`1<CloudReverseGeocodingResult> CxU=(WebResponse response, IEnumerable`1<PointShape> queryPoints);
}
[ObfuscationAttribute]
internal class ThinkGeo.Core.ReverseGeocodingLocationDto : object {
    [CompilerGeneratedAttribute]
private string <LocationName>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Address>k__BackingField;
    [CompilerGeneratedAttribute]
private Dictionary`2<string, string> <AddressComponents>k__BackingField;
    [CompilerGeneratedAttribute]
private Dictionary`2<string, string> <OptionalNames>k__BackingField;
    [CompilerGeneratedAttribute]
private string <LocationFeatureWellKnownText>k__BackingField;
    [CompilerGeneratedAttribute]
private string <HouseNumber>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Postcode>k__BackingField;
    [CompilerGeneratedAttribute]
private CloudLocationCategories <LocationCategory>k__BackingField;
    [CompilerGeneratedAttribute]
private Dictionary`2<string, string> <Properties>k__BackingField;
    [CompilerGeneratedAttribute]
private string <LocationType>k__BackingField;
    [CompilerGeneratedAttribute]
private double <Distance>k__BackingField;
    [CompilerGeneratedAttribute]
private string <DirectionFromQueryFeature>k__BackingField;
    public string LocationName { get; public set; }
    public string Address { get; public set; }
    public Dictionary`2<string, string> AddressComponents { get; public set; }
    public Dictionary`2<string, string> OptionalNames { get; public set; }
    public string LocationFeatureWellKnownText { get; public set; }
    public string HouseNumber { get; public set; }
    public string Postcode { get; public set; }
    public CloudLocationCategories LocationCategory { get; public set; }
    public Dictionary`2<string, string> Properties { get; public set; }
    public string LocationType { get; public set; }
    public double Distance { get; public set; }
    public string DirectionFromQueryFeature { get; public set; }
    [CompilerGeneratedAttribute]
public string get_LocationName();
    [CompilerGeneratedAttribute]
public void set_LocationName(string value);
    [CompilerGeneratedAttribute]
public string get_Address();
    [CompilerGeneratedAttribute]
public void set_Address(string value);
    [CompilerGeneratedAttribute]
public Dictionary`2<string, string> get_AddressComponents();
    [CompilerGeneratedAttribute]
public void set_AddressComponents(Dictionary`2<string, string> value);
    [CompilerGeneratedAttribute]
public Dictionary`2<string, string> get_OptionalNames();
    [CompilerGeneratedAttribute]
public void set_OptionalNames(Dictionary`2<string, string> value);
    [CompilerGeneratedAttribute]
public string get_LocationFeatureWellKnownText();
    [CompilerGeneratedAttribute]
public void set_LocationFeatureWellKnownText(string value);
    [CompilerGeneratedAttribute]
public string get_HouseNumber();
    [CompilerGeneratedAttribute]
public void set_HouseNumber(string value);
    [CompilerGeneratedAttribute]
public string get_Postcode();
    [CompilerGeneratedAttribute]
public void set_Postcode(string value);
    [CompilerGeneratedAttribute]
public CloudLocationCategories get_LocationCategory();
    [CompilerGeneratedAttribute]
public void set_LocationCategory(CloudLocationCategories value);
    [CompilerGeneratedAttribute]
public Dictionary`2<string, string> get_Properties();
    [CompilerGeneratedAttribute]
public void set_Properties(Dictionary`2<string, string> value);
    [CompilerGeneratedAttribute]
public string get_LocationType();
    [CompilerGeneratedAttribute]
public void set_LocationType(string value);
    [CompilerGeneratedAttribute]
public double get_Distance();
    [CompilerGeneratedAttribute]
public void set_Distance(double value);
    [CompilerGeneratedAttribute]
public string get_DirectionFromQueryFeature();
    [CompilerGeneratedAttribute]
public void set_DirectionFromQueryFeature(string value);
    public CloudReverseGeocodingLocation ToReverseGeocodingLocation();
}
public enum ThinkGeo.Core.RingOrder : Enum {
    public int value__;
    public static RingOrder Unknown;
    public static RingOrder Clockwise;
    public static RingOrder Counterclockwise;
}
[TypeConverterAttribute("ThinkGeo.Core.BaseShapeTypeConverter")]
public class ThinkGeo.Core.RingShape : AreaBaseShape {
    [ObfuscationAttribute]
private Collection`1<Vertex> vertices;
    public Collection`1<Vertex> Vertices { get; }
    public RingShape(IEnumerable`1<Vertex> points);
    public RingShape(string wellKnownText);
    public RingShape(Byte[] wellKnownBinary);
    protected virtual WellKnownType GetWellKnownTypeCore();
    public Collection`1<Vertex> get_Vertices();
    protected virtual BaseShape CloneDeepCore();
    public PolygonShape ToPolygon();
    protected virtual double GetPerimeterCore(GeographyUnit shapeUnit, DistanceUnit returningUnit);
    protected virtual double GetAreaCore(GeographyUnit shapeUnit, AreaUnit returningUnit);
    protected virtual void ScaleUpCore(double percentage);
    protected virtual void ScaleDownCore(double percentage);
    protected virtual RectangleShape GetBoundingBoxCore();
    protected virtual BaseShape RegisterCore(PointShape fromPoint, PointShape toPoint, DistanceUnit fromUnit, GeographyUnit toUnit);
    protected virtual void TranslateByOffsetCore(double xOffsetDistance, double yOffsetDistance, GeographyUnit shapeUnit, DistanceUnit distanceUnit);
    protected virtual void TranslateByDegreeCore(double distance, double angleInDegrees, GeographyUnit shapeUnit, DistanceUnit distanceUnit);
    protected virtual void RotateCore(PointShape pivotPoint, double degreeAngle);
    protected virtual double GetDistanceToCore(BaseShape targetShape, GeographyUnit shapeUnit, DistanceUnit distanceUnit);
    protected virtual PointShape GetClosestPointToCore(BaseShape targetShape, GeographyUnit shapeUnit);
    protected virtual string GetWellKnownTextCore(RingOrder outerRingOrder);
    protected virtual Byte[] GetWellKnownBinaryCore(RingOrder outerRingOrder, WkbByteOrder byteOrder);
    protected virtual void LoadFromWellKnownDataCore(string wellKnownText);
    protected virtual void LoadFromWellKnownDataCore(Byte[] wellKnownBinary);
    public static bool RemoveVertex(Vertex selectedVertex, RingShape ringShape);
    public bool RemoveVertex(Vertex selectedVertex);
    private static void hBw=(PolygonShape fromPolygon, RingShape toRing);
    protected virtual ShapeValidationResult ValidateCore(ShapeValidationMode validationMode);
    private static void hRw=(RingShape ringShape);
    private void TRU=(double multiplicator);
    internal static void hhw=(RingShape targetRingShape, double multiplicator, double centerX, double centerY);
    private void Zhw=(WkbByteOrder byteOrder, BinaryWriter writer);
    private void ZBw=(WkbByteOrder byteOrder, BinaryWriter writer);
    private static void dRw=(RingShape ringShape, StringBuilder wellKnownText);
    private static void dhw=(RingShape ringShape, StringBuilder wellKnownText);
    public bool IsCounterClockwise();
    public void ReversePoints();
    protected virtual void ReversePointsCore();
    public bool IsSelfIntersecting();
    private static bool hxw=(Vertex Pt1, Vertex Pt2, Vertex CompPt1, Vertex CompPt2);
    private static bool iBw=(Vertex InPt1, Vertex InPt2, Vertex InCompPt1, Vertex InCompPt2);
    private static bool iRw=(double x1, double y1, double xp1, double yp1, double xp2, double yp2);
    private static bool ihw=(double Value, double CompValue1, double CompValue2);
    private static bool ixw=(Vertex PointShape1, Vertex LinePointShape1, Vertex LinePointShape2);
    private static RectangleShape WRw=(IEnumerable`1<Vertex> vertices);
}
public class ThinkGeo.Core.RotationProjectionConverter : ProjectionConverter {
    [ObfuscationAttribute]
private PointShape pivotCenter;
    [ObfuscationAttribute]
private double previousRotateAngle;
    [ObfuscationAttribute]
private double angle;
    [ObfuscationAttribute]
private GeographyUnit sourceUnit;
    [ObfuscationAttribute]
private bool isManualPivoit;
    [ObfuscationAttribute]
private PolygonShape previousRotationShape;
    internal PolygonShape bR8= { get; internal set; }
    internal double cB8= { get; internal set; }
    public double Angle { get; public set; }
    public GeographyUnit InternalProjectionUnit { get; }
    public PointShape PivotCenter { get; public set; }
    public RotationProjectionConverter(double angle);
    public RotationProjectionConverter(GeographyUnit sourceUnit);
    public RotationProjectionConverter(double angle, GeographyUnit sourceUnit);
    internal PolygonShape ax8=();
    internal void bB8=(PolygonShape value);
    internal double bh8=();
    internal void bx8=(double value);
    public double get_Angle();
    public void set_Angle(double value);
    public virtual GeographyUnit get_InternalProjectionUnit();
    public PointShape get_PivotCenter();
    public void set_PivotCenter(PointShape value);
    public RectangleShape GetUpdatedExtent(RectangleShape worldExtent);
    protected virtual void OpenCore();
    protected virtual Collection`1<Vertex> ConvertToExternalProjectionCore(IEnumerable`1<Vertex> verticies);
    protected virtual Collection`1<Vertex> ConvertToInternalProjectionCore(IEnumerable`1<Vertex> verticies);
    private Vertex cR8=(double x, double y, double angle);
}
[ObfuscationAttribute]
public enum ThinkGeo.Core.RouteType : Enum {
    public int value__;
    public static RouteType Fastest;
    public static RouteType Shortest;
}
public class ThinkGeo.Core.RoutingCloudClient : CloudClient {
    public RoutingCloudClient(string clientId, string clientSecret);
    public CloudRoutingGetRouteResult GetRoute(IEnumerable`1<PointShape> waypoints, CloudRoutingGetRouteOptions options);
    public CloudRoutingGetRouteResult GetRoute(IEnumerable`1<PointShape> waypoints, int srid, CloudRoutingGetRouteOptions options);
    public CloudRoutingGetRouteResult GetRoute(IEnumerable`1<PointShape> waypoints, string proj4String, CloudRoutingGetRouteOptions options);
    public Task`1<CloudRoutingGetRouteResult> GetRouteAsync(IEnumerable`1<PointShape> waypoints, CloudRoutingGetRouteOptions options);
    public Task`1<CloudRoutingGetRouteResult> GetRouteAsync(IEnumerable`1<PointShape> waypoints, int srid, CloudRoutingGetRouteOptions options);
    public Task`1<CloudRoutingGetRouteResult> GetRouteAsync(IEnumerable`1<PointShape> waypoints, string proj4String, CloudRoutingGetRouteOptions options);
    public CloudRoutingGetServiceAreaResult GetServiceArea(PointShape point, IEnumerable`1<double> serviceLimits, CloudRoutingGetServiceAreaOptions options);
    public CloudRoutingGetServiceAreaResult GetServiceArea(PointShape point, int srid, IEnumerable`1<double> serviceLimits, CloudRoutingGetServiceAreaOptions options);
    public CloudRoutingGetServiceAreaResult GetServiceArea(PointShape point, string proj4String, IEnumerable`1<double> serviceLimits, CloudRoutingGetServiceAreaOptions options);
    public CloudRoutingGetServiceAreaResult GetServiceArea(PointShape point, IEnumerable`1<TimeSpan> serviceLimits, CloudRoutingGetServiceAreaOptions options);
    public CloudRoutingGetServiceAreaResult GetServiceArea(PointShape point, int srid, IEnumerable`1<TimeSpan> serviceLimits, CloudRoutingGetServiceAreaOptions options);
    public CloudRoutingGetServiceAreaResult GetServiceArea(PointShape point, string proj4String, IEnumerable`1<TimeSpan> serviceLimits, CloudRoutingGetServiceAreaOptions options);
    public Task`1<CloudRoutingGetServiceAreaResult> GetServiceAreaAsync(PointShape point, IEnumerable`1<double> serviceLimits, CloudRoutingGetServiceAreaOptions options);
    public Task`1<CloudRoutingGetServiceAreaResult> GetServiceAreaAsync(PointShape point, int srid, IEnumerable`1<double> serviceLimits, CloudRoutingGetServiceAreaOptions options);
    public Task`1<CloudRoutingGetServiceAreaResult> GetServiceAreaAsync(PointShape point, string proj4String, IEnumerable`1<double> serviceLimits, CloudRoutingGetServiceAreaOptions options);
    public Task`1<CloudRoutingGetServiceAreaResult> GetServiceAreaAsync(PointShape point, IEnumerable`1<TimeSpan> serviceLimits, CloudRoutingGetServiceAreaOptions options);
    public Task`1<CloudRoutingGetServiceAreaResult> GetServiceAreaAsync(PointShape point, int srid, IEnumerable`1<TimeSpan> serviceLimits, CloudRoutingGetServiceAreaOptions options);
    public Task`1<CloudRoutingGetServiceAreaResult> GetServiceAreaAsync(PointShape point, string proj4String, IEnumerable`1<TimeSpan> serviceLimits, CloudRoutingGetServiceAreaOptions options);
    public CloudRoutingGetTimeCostMatrixResult GetTimeCostMatrix(IEnumerable`1<PointShape> origins, IEnumerable`1<PointShape> destinations, CloudRoutingGetCostMatrixOptions options);
    public CloudRoutingGetTimeCostMatrixResult GetTimeCostMatrix(IEnumerable`1<PointShape> origins, IEnumerable`1<PointShape> destinations, int srid, CloudRoutingGetCostMatrixOptions options);
    public CloudRoutingGetTimeCostMatrixResult GetTimeCostMatrix(IEnumerable`1<PointShape> origins, IEnumerable`1<PointShape> destinations, string proj4String, CloudRoutingGetCostMatrixOptions options);
    public Task`1<CloudRoutingGetTimeCostMatrixResult> GetTimeCostMatrixAsync(IEnumerable`1<PointShape> origins, IEnumerable`1<PointShape> destinations, CloudRoutingGetCostMatrixOptions options);
    public Task`1<CloudRoutingGetTimeCostMatrixResult> GetTimeCostMatrixAsync(IEnumerable`1<PointShape> origins, IEnumerable`1<PointShape> destinations, int srid, CloudRoutingGetCostMatrixOptions options);
    public Task`1<CloudRoutingGetTimeCostMatrixResult> GetTimeCostMatrixAsync(IEnumerable`1<PointShape> origins, IEnumerable`1<PointShape> destinations, string proj4String, CloudRoutingGetCostMatrixOptions options);
    public CloudRoutingGetDistanceCostMatrixResult GetDistanceCostMatrix(IEnumerable`1<PointShape> origins, IEnumerable`1<PointShape> destinations, CloudRoutingGetCostMatrixOptions options);
    public CloudRoutingGetDistanceCostMatrixResult GetDistanceCostMatrix(IEnumerable`1<PointShape> origins, IEnumerable`1<PointShape> destinations, int srid, CloudRoutingGetCostMatrixOptions options);
    public CloudRoutingGetDistanceCostMatrixResult GetDistanceCostMatrix(IEnumerable`1<PointShape> origins, IEnumerable`1<PointShape> destinations, string proj4String, CloudRoutingGetCostMatrixOptions options);
    public Task`1<CloudRoutingGetDistanceCostMatrixResult> GetDistanceCostMatrixAsync(IEnumerable`1<PointShape> origins, IEnumerable`1<PointShape> destinations, CloudRoutingGetCostMatrixOptions options);
    public Task`1<CloudRoutingGetDistanceCostMatrixResult> GetDistanceCostMatrixAsync(IEnumerable`1<PointShape> origins, IEnumerable`1<PointShape> destinations, int srid, CloudRoutingGetCostMatrixOptions options);
    public Task`1<CloudRoutingGetDistanceCostMatrixResult> GetDistanceCostMatrixAsync(IEnumerable`1<PointShape> origins, IEnumerable`1<PointShape> destinations, string proj4String, CloudRoutingGetCostMatrixOptions options);
    public CloudRoutingOptimizationResult GetOptimizedRoute(IEnumerable`1<PointShape> coordinates, CloudRoutingOptimizationOptions options);
    public CloudRoutingOptimizationResult GetOptimizedRoute(IEnumerable`1<PointShape> coordinates, int srid, CloudRoutingOptimizationOptions options);
    public CloudRoutingOptimizationResult GetOptimizedRoute(IEnumerable`1<PointShape> coordinates, string proj4String, CloudRoutingOptimizationOptions options);
    public Task`1<CloudRoutingOptimizationResult> GetOptimizedRouteAsync(IEnumerable`1<PointShape> coordinates, CloudRoutingOptimizationOptions options);
    public Task`1<CloudRoutingOptimizationResult> GetOptimizedRouteAsync(IEnumerable`1<PointShape> coordinates, int srid, CloudRoutingOptimizationOptions options);
    public Task`1<CloudRoutingOptimizationResult> GetOptimizedRouteAsync(IEnumerable`1<PointShape> coordinates, string proj4String, CloudRoutingOptimizationOptions options);
    private CloudRoutingGetRouteResult DBU=(IEnumerable`1<PointShape> waypoints, Nullable`1<int> srid, string proj4String, CloudRoutingGetRouteOptions options);
    [AsyncStateMachineAttribute("ThinkGeo.Core.RoutingCloudClient/lD4=")]
private Task`1<CloudRoutingGetRouteResult> DRU=(IEnumerable`1<PointShape> waypoints, Nullable`1<int> srid, string proj4String, CloudRoutingGetRouteOptions options);
    private CloudRoutingGetServiceAreaResult DhU=(PointShape point, Nullable`1<int> srid, string proj4String, IEnumerable`1<double> serviceLimitsDistance, IEnumerable`1<TimeSpan> serviceLimitsTime, CloudRoutingGetServiceAreaOptions options);
    [AsyncStateMachineAttribute("ThinkGeo.Core.RoutingCloudClient/lj4=")]
private Task`1<CloudRoutingGetServiceAreaResult> DxU=(PointShape point, Nullable`1<int> srid, string proj4String, IEnumerable`1<double> serviceLimitsDistance, IEnumerable`1<TimeSpan> serviceLimitsTime, CloudRoutingGetServiceAreaOptions options);
    private CloudRoutingGetTimeCostMatrixResult EBU=(IEnumerable`1<PointShape> origins, IEnumerable`1<PointShape> destinations, Nullable`1<int> srid, string proj4String, CloudRoutingGetCostMatrixOptions options);
    [AsyncStateMachineAttribute("ThinkGeo.Core.RoutingCloudClient/mT4=")]
private Task`1<CloudRoutingGetTimeCostMatrixResult> ERU=(IEnumerable`1<PointShape> origins, IEnumerable`1<PointShape> destinations, Nullable`1<int> srid, string proj4String, CloudRoutingGetCostMatrixOptions options);
    private CloudRoutingGetDistanceCostMatrixResult EhU=(IEnumerable`1<PointShape> origins, IEnumerable`1<PointShape> destinations, Nullable`1<int> srid, string proj4String, CloudRoutingGetCostMatrixOptions options);
    [AsyncStateMachineAttribute("ThinkGeo.Core.RoutingCloudClient/jz4=")]
private Task`1<CloudRoutingGetDistanceCostMatrixResult> ExU=(IEnumerable`1<PointShape> origins, IEnumerable`1<PointShape> destinations, Nullable`1<int> srid, string proj4String, CloudRoutingGetCostMatrixOptions options);
    private CloudRoutingOptimizationResult FBU=(IEnumerable`1<PointShape> coordinates, Nullable`1<int> srid, string proj4String, CloudRoutingOptimizationOptions options);
    [AsyncStateMachineAttribute("ThinkGeo.Core.RoutingCloudClient/kj4=")]
private Task`1<CloudRoutingOptimizationResult> FRU=(IEnumerable`1<PointShape> coordinates, Nullable`1<int> srid, string proj4String, CloudRoutingOptimizationOptions options);
    private static CloudRoutingGetRouteResult FhU=(WebResponse response);
    private static CloudRoutingGetServiceAreaResult FxU=(WebResponse response);
    private static CloudRoutingGetTimeCostMatrixResult GBU=(WebResponse response);
    private static CloudRoutingGetDistanceCostMatrixResult GRU=(WebResponse response);
    private static CloudRoutingOptimizationResult GhU=(WebResponse response);
    private static string 3xQ=(Nullable`1<int> srid, string proj4String, CloudRoutingGetRouteOptions options);
    private static string 3xQ=(IEnumerable`1<double> serviceLimitsDistance, IEnumerable`1<TimeSpan> serviceLimitsTime, Nullable`1<int> srid, string proj4String, CloudRoutingGetServiceAreaOptions options);
    private static string 3xQ=(string costMatrixType, IEnumerable`1<PointShape> origins, IEnumerable`1<PointShape> destinations, Nullable`1<int> srid, string proj4String, CloudRoutingGetCostMatrixOptions options);
    private static string 3xQ=(Nullable`1<int> srid, string proj4String, CloudRoutingOptimizationOptions options);
    private static string GxU=(IEnumerable`1<PointShape> points);
    private static string GxU=(IEnumerable`1<string> items, string separator);
}
public class ThinkGeo.Core.RowColumnRange : ValueType {
    [ObfuscationAttribute]
private long minRowIndex;
    [ObfuscationAttribute]
private long maxRowIndex;
    [ObfuscationAttribute]
private long minColumnIndex;
    [ObfuscationAttribute]
private long maxColumnIndex;
    public long MinRowIndex { get; public set; }
    public long MaxRowIndex { get; public set; }
    public long MinColumnIndex { get; public set; }
    public long MaxColumnIndex { get; public set; }
    public RowColumnRange(long minRowIndex, long maxRowIndex, long minColumnIndex, long maxColumnIndex);
    public long get_MinRowIndex();
    public void set_MinRowIndex(long value);
    public long get_MaxRowIndex();
    public void set_MaxRowIndex(long value);
    public long get_MinColumnIndex();
    public void set_MinColumnIndex(long value);
    public long get_MaxColumnIndex();
    public void set_MaxColumnIndex(long value);
    public virtual int GetHashCode();
    public virtual bool Equals(object obj);
    private bool lhU=(RowColumnRange compareObj);
    public static bool op_Equality(RowColumnRange rowColumnRange1, RowColumnRange rowColumnRange2);
    public static bool op_Inequality(RowColumnRange rowColumnRange1, RowColumnRange rowColumnRange2);
}
[ObfuscationAttribute]
internal abstract class ThinkGeo.Core.RTPage : object {
    protected MemoryStream DyA=;
    [ObfuscationAttribute]
protected Byte[] arrayBuffer;
    protected Stream ECA=;
    [ObfuscationAttribute]
protected RtreeFile rTreeFile;
    [ObfuscationAttribute]
protected UInt32 pageNumber;
    [ObfuscationAttribute]
protected Gist_Ext_Id extensionId;
    protected BinaryReader ESA=;
    protected BinaryWriter EiA=;
    [ObfuscationAttribute]
protected bool isDirty;
    [ObfuscationAttribute]
public int pageSize;
    [ObfuscationAttribute]
private bool isFloat;
    internal static int EyA=;
    internal static string FCA=;
    [ObfuscationAttribute]
internal int pageHeaderSize;
    [ObfuscationAttribute]
internal int recordSetHeaderSize;
    [ObfuscationAttribute]
internal int slotSize;
    public UInt32 FyA= { get; public set; }
    public bool GSA= { get; }
    public RTPage(RtreeFile rtFile, Gist_Ext_Id extId);
    public RTPage(RtreeFile rtFile, UInt32 pageNo, Gist_Ext_Id extId);
    public RTPage(RtreeFile rtFile, UInt32 pageNo);
    public RTPage(RtreeFile rtFile);
    public virtual bool gx8=();
    internal void pR8=();
    internal void GiA=();
    public UInt32 FSA=();
    public void FiA=(UInt32 value);
    public void GyA=();
    public Stream HCA=();
    public Gist_Ext_Id uB8=();
    public RtreeFile HSA=();
    public bool GCA=();
    public abstract virtual string kR8=();
}
[ObfuscationAttribute]
internal class ThinkGeo.Core.RtreeFile : object {
    [ObfuscationAttribute]
private HeaderPage headerPage;
    private Stream ECA=;
    private bool pBo=;
    [ObfuscationAttribute]
private bool isReadOnly;
    [ObfuscationAttribute]
private bool isFloat;
    [ObfuscationAttribute]
private int pageSize;
    private static string HiA=;
    private static string HyA=;
    private static string ICA=;
    private static string ISA=;
    private static string IiA=;
    public int JSA= { get; public set; }
    public bool GSA= { get; }
    public int IyA=();
    public void JCA=(int value);
    public bool GCA=();
    public bool qR8=(string fileName, Gist_Ext_Id extId, vz8= openStreamLoadingDelegate, bool isFloat);
    private void JiA=(Gist_Ext_Id extId, bool isFloat);
    public bool GR8=(string fileName, bool isReadOnly, vz8= openStreamLoadingEvent);
    public bool pR8=();
    public bool gx8=();
    public bool JyA=();
    public bool KCA=();
    public bool KSA=();
    public Stream HCA=();
    internal MemoryStream KiA=();
    public Gist_Ext_Id uB8=();
    internal eB8= KyA=();
    internal int LCA=();
    public Stream LSA=(string fileName, FileMode fileMode, FileAccess readWriteMode, vz8= openStreamLoadingDelegate);
}
public class ThinkGeo.Core.RtreeSpatialIndex : SpatialIndex {
    [CompilerGeneratedAttribute]
private EventHandler`1<StreamLoadingEventArgs> Eh8=;
    [ObfuscationAttribute]
private RtreeFile rTreeFile;
    [ObfuscationAttribute]
private IdsEngine idsEngine;
    [ObfuscationAttribute]
internal static double m_FillFactor;
    private static string MyA=;
    private static string NCA=;
    private static string NSA=;
    [ObfuscationAttribute]
private bool hasIdx;
    [ObfuscationAttribute]
private string pathFilename;
    [ObfuscationAttribute]
private FileAccess readWriteMode;
    public string PathFilename { get; public set; }
    public FileAccess ReadWriteMode { get; public set; }
    public RtreeSpatialIndexDataFormat DataFormat { get; }
    public bool HasIdx { get; }
    public int PageSize { get; }
    public RtreeSpatialIndex(string pathFilename);
    public RtreeSpatialIndex(string pathFilename, FileAccess readWriteMode);
    [CompilerGeneratedAttribute]
public void add_StreamLoading(EventHandler`1<StreamLoadingEventArgs> value);
    [CompilerGeneratedAttribute]
public void remove_StreamLoading(EventHandler`1<StreamLoadingEventArgs> value);
    private void NiA=(object sender, StreamLoadingEventArgs e);
    protected virtual override void Finalize();
    public sealed virtual void Dispose();
    private void 1x0=(bool disposing);
    protected virtual void OnStreamLoading(StreamLoadingEventArgs e);
    public string get_PathFilename();
    public void set_PathFilename(string value);
    public FileAccess get_ReadWriteMode();
    public void set_ReadWriteMode(FileAccess value);
    public RtreeSpatialIndexDataFormat get_DataFormat();
    public void RefreshCache();
    protected virtual void DeleteCore(Feature feature);
    protected virtual void AddCore(Feature feature);
    protected virtual Collection`1<string> GetFeatureIdsIntersectingBoundingBoxCore(RectangleShape boundingBox);
    public Collection`1<string> GetFeatureIdsWithinBoundingBox(RectangleShape boundingBox);
    protected virtual Collection`1<string> GetFeatureIdsWithinBoundingBoxCore(RectangleShape boundingBox);
    public Collection`1<string> GetFeatureIdsContainingRectangleShape(RectangleShape boundingBox);
    protected virtual Collection`1<string> GetFeatureIdsContainingRectangleShapeCore(RectangleShape rectangleShape);
    public Collection`1<string> GetFeatureIdsNearestTo(PointShape pointShape, int maxReturningCount);
    protected virtual Collection`1<string> GetFeatureIdsNearestToCore(PointShape pointShape, int maxReturningCount);
    public bool get_HasIdx();
    public static RtreeSpatialIndexPageSize GetBestPageSize(int recordCount);
    public int get_PageSize();
    internal tR8= NyA=();
    public static void CreateRectangleSpatialIndex(string pathFilename);
    public static void CreateRectangleSpatialIndex(string pathFilename, RtreeSpatialIndexPageSize pageSize);
    public static void CreateRectangleSpatialIndex(string pathFilename, RtreeSpatialIndexPageSize pageSize, RtreeSpatialIndexDataFormat dataFormat);
    public static void CreatePointSpatialIndex(string pathFilename);
    public static void CreatePointSpatialIndex(string pathFilename, RtreeSpatialIndexPageSize pageSize);
    public static void CreatePointSpatialIndex(string pathFilename, RtreeSpatialIndexPageSize pageSize, RtreeSpatialIndexDataFormat dataFormat);
    private bool OCA=(string indexFileName, bool isFloat, RtreeSpatialIndexPageSize pageSize);
    private void OSA=(RtreeSpatialIndexPageSize pageSize);
    private static void OiA=(string indexFileName, bool isFloat, RtreeSpatialIndexPageSize pageSize);
    private bool OyA=(string indexFileName, bool isFloat, RtreeSpatialIndexPageSize pageSize);
    private static void PCA=(string indexFileName, bool isFloat, RtreeSpatialIndexPageSize pageSize);
    private bool PSA=();
    public static bool IsRtreeSpatialIndexFileValid(string indexFileName);
    protected virtual void OpenCore();
    protected virtual void CloseCore();
    public void Flush();
    private void PiA=(double x, double y, string pointId);
    private void PiA=(PointShape point, string pointId);
    private void PyA=(double x, double y);
    private void PyA=(PointShape point);
    private void QCA=(double upperLeftX, double upperLeftY, double lowerRightX, double lowerRightY, string rectangleId);
    private void QCA=(RectangleShape rectangle, string rectangleId);
    private void QSA=(double upperLeftX, double upperLeftY, double lowerRightX, double lowerRightY);
    private void QSA=(RectangleShape rectangle);
    private Collection`1<string> QiA=(double upperLeftX, double upperLeftY, double lowerRightX, double lowerRightY);
    private Collection`1<string> QiA=(RectangleShape rectangle);
    private Collection`1<string> QyA=(double upperLeftX, double upperLeftY, double lowerRightX, double lowerRightY);
    private Collection`1<string> QyA=(RectangleShape rectangle);
    private Collection`1<string> RCA=(double upperLeftX, double upperLeftY, double lowerRightX, double lowerRightY);
    public Collection`1<string> GetFeatureIdsIntersectingBoundingBox(RectangleShape rectangleShape, double screenWidth, double screenHeight, int simplifyPixelBufferSize, Collection`1<RectangleShape> dimensionlessBoxes);
    private Collection`1<string> RCA=(double upperLeftX, double upperLeftY, double lowerRightX, double lowerRightY, double screenWidth, double screenHeight, int simplifyPixelBufferSize, Collection`1<RectangleShape> dimensionlessBoxes);
    private Collection`1<string> RCA=(RectangleShape rectangle);
    private Collection`1<string> RSA=(double x, double y, int returningRecordCount);
    private Collection`1<string> RSA=(PointShape point, int returningRecordCount);
    private Collection`1<string> RiA=(double x, double y, int MaxNum);
    protected virtual int GetFeatureCountCore();
    private static string RyA=(string idxFileName);
    public RectangleShape GetBoundingBox();
    public void DeleteRecord(BaseShape shape);
    private void PyA=(PointShape pointShape, IEnumerable`1<string> ids, IdsEngine idsEngine);
    private void PyA=(double x, double y, IEnumerable`1<string> ids, IdsEngine idsEngine);
    private void QSA=(RectangleShape rectangle, IEnumerable`1<string> ids, IdsEngine idsEngine);
    private void QSA=(double upperLeftX, double upperLeftY, double lowerRightX, double lowerRightY, IEnumerable`1<string> ids, IdsEngine idsEngine);
}
public enum ThinkGeo.Core.RtreeSpatialIndexDataFormat : Enum {
    public int value__;
    public static RtreeSpatialIndexDataFormat Float;
    public static RtreeSpatialIndexDataFormat Double;
}
public enum ThinkGeo.Core.RtreeSpatialIndexPageSize : Enum {
    public int value__;
    public static RtreeSpatialIndexPageSize FourKilobytes;
    public static RtreeSpatialIndexPageSize EightKilobytes;
    public static RtreeSpatialIndexPageSize SixteenKilobytes;
    public static RtreeSpatialIndexPageSize ThirtytwoKilobytes;
}
public class ThinkGeo.Core.ScaleBarAdornmentLayer : AdornmentLayer {
    private static int CiE=;
    private static int CyE=;
    private static int DCE=;
    private static int DSE=;
    private static int DiE=;
    private static int DyE=;
    private static int ECE=;
    private static int ESE=;
    private static int EiE=;
    private static int EyE=;
    [ObfuscationAttribute]
private GeoBrush barBrush;
    [ObfuscationAttribute]
private GeoBrush alternateBarBrush;
    [ObfuscationAttribute]
private Dictionary`2<string, string> displayUnitString;
    [ObfuscationAttribute]
private FeetValues feetValues;
    [ObfuscationAttribute]
private GeoFont font;
    [ObfuscationAttribute]
private int fontRatio;
    [ObfuscationAttribute]
private bool hasMask;
    [ObfuscationAttribute]
private int height;
    [ObfuscationAttribute]
private KiloMetersValues kilometersValues;
    [ObfuscationAttribute]
private UnitSystem unitFamily;
    [ObfuscationAttribute]
private GeoBrush maskBrush;
    [ObfuscationAttribute]
private GeoPen maskContour;
    [ObfuscationAttribute]
private int maxWidth;
    [ObfuscationAttribute]
private bool isMeaningfulScale;
    [ObfuscationAttribute]
private MetersValues metersValues;
    [ObfuscationAttribute]
private MilesValues milesValues;
    [ObfuscationAttribute]
private NauticalMilesValues nauticalMilesValues;
    [ObfuscationAttribute]
private string numberFormat;
    [ObfuscationAttribute]
private bool needToRefresh;
    [ObfuscationAttribute]
private ScreenPointF screenLocation;
    [ObfuscationAttribute]
private GeoColor textColor;
    [ObfuscationAttribute]
private int thickness;
    [ObfuscationAttribute]
private int width;
    [ObfuscationAttribute]
private ProjectionConverter projectionToDecimalDegrees;
    [ObfuscationAttribute]
private TextStyle textStyle;
    [ObfuscationAttribute]
private GeoPen barPen;
    public Dictionary`2<string, string> DisplayUnitString { get; }
    public UnitSystem UnitFamily { get; public set; }
    public int Thickness { get; public set; }
    public int MaxWidth { get; public set; }
    public GeoBrush BarBrush { get; public set; }
    public TextStyle TextStyle { get; public set; }
    public GeoBrush AlternateBarBrush { get; public set; }
    public GeoBrush MaskBrush { get; public set; }
    public bool HasMask { get; public set; }
    public GeoPen MaskContour { get; public set; }
    public GeoPen BarPen { get; public set; }
    public Dictionary`2<string, string> get_DisplayUnitString();
    public UnitSystem get_UnitFamily();
    public void set_UnitFamily(UnitSystem value);
    public int get_Thickness();
    public void set_Thickness(int value);
    public int get_MaxWidth();
    public void set_MaxWidth(int value);
    public GeoBrush get_BarBrush();
    public void set_BarBrush(GeoBrush value);
    public TextStyle get_TextStyle();
    public void set_TextStyle(TextStyle value);
    public GeoBrush get_AlternateBarBrush();
    public void set_AlternateBarBrush(GeoBrush value);
    public GeoBrush get_MaskBrush();
    public void set_MaskBrush(GeoBrush value);
    public bool get_HasMask();
    public void set_HasMask(bool value);
    public GeoPen get_MaskContour();
    public void set_MaskContour(GeoPen value);
    public GeoPen get_BarPen();
    public void set_BarPen(GeoPen value);
    protected virtual void OpenCore();
    protected virtual void CloseCore();
    internal void FCE=(GeoCanvas canvas, GeographyUnit mapUnit);
    private void FSE=(GeoCanvas canvas);
    private void FiE=(GeoCanvas canvas, float textWidth, int margin, Collection`1<RectangleShape> rectCollection);
    private void FyE=(GeoCanvas canvas, float textWidth, int margin, Collection`1<RectangleShape> rectCollection);
    private static double GCE=(Dictionary`2<double, double> xUnitHashTable);
    private Dictionary`2<double, double> GSE=();
    private Dictionary`2<double, double> GiE=();
    private Dictionary`2<double, double> GyE=();
    private Dictionary`2<double, double> HCE=();
    private Dictionary`2<double, double> HSE=();
    private static void HiE=(int i, Dictionary`2<double, double> xHashTable, Double[] xValues);
    private Collection`1<RectangleShape> HyE=(Dictionary`2<double, double> hashTable);
    protected virtual void DrawCore(GeoCanvas canvas, Collection`1<SimpleCandidate> labelsInAllLayers);
}
public class ThinkGeo.Core.ScaleLineAdornmentLayer : AdornmentLayer {
    private static int ICE=;
    private static int ISE=;
    [ObfuscationAttribute]
private int bottomLengthPixel;
    [ObfuscationAttribute]
private string bottomString;
    [ObfuscationAttribute]
private Dictionary`2<string, string> displayUnitString;
    [ObfuscationAttribute]
private int scaleLineHeightInPixel;
    [ObfuscationAttribute]
private int scaleLineWidthInPixel;
    [ObfuscationAttribute]
private int topLengthPixel;
    [ObfuscationAttribute]
private string topString;
    [ObfuscationAttribute]
private ScaleLineUnitSystem unitSystem;
    [ObfuscationAttribute]
private ProjectionConverter projectionToDecimalDegrees;
    [ObfuscationAttribute]
private TextStyle textStyle;
    [ObfuscationAttribute]
private GeoPen pen;
    [ObfuscationAttribute]
private GeoPen backPen;
    public Dictionary`2<string, string> DisplayUnitString { get; }
    public ScaleLineUnitSystem UnitSystem { get; public set; }
    public TextStyle TextStyle { get; public set; }
    public GeoPen Pen { get; public set; }
    public GeoPen HaloPen { get; public set; }
    public ScaleLineAdornmentLayer(ScreenPointF startPoint);
    public ScaleLineAdornmentLayer(AdornmentLocation location);
    public Dictionary`2<string, string> get_DisplayUnitString();
    public ScaleLineUnitSystem get_UnitSystem();
    public void set_UnitSystem(ScaleLineUnitSystem value);
    protected virtual void DrawCore(GeoCanvas canvas, Collection`1<SimpleCandidate> labelsInAllLayers);
    public TextStyle get_TextStyle();
    public void set_TextStyle(TextStyle value);
    public GeoPen get_Pen();
    public void set_Pen(GeoPen value);
    public GeoPen get_HaloPen();
    public void set_HaloPen(GeoPen value);
    protected virtual void OpenCore();
    protected virtual void CloseCore();
    private void IiE=(GeoCanvas canvas);
    private void FyE=(GeoCanvas canvas, int topBarHeight, int bottomBarHeight, ScreenPointF startPointF);
    private static string IyE=(string text, GeoFont font, int lengthPixel, GeoCanvas canvas);
    private bool JCE=(GeoCanvas canvas, GeographyUnit mapUnit);
    private static int JSE=(int maxLength);
}
public enum ThinkGeo.Core.ScaleLineUnitSystem : Enum {
    public int value__;
    public static ScaleLineUnitSystem Default;
    public static ScaleLineUnitSystem MetricAndNauticalMile;
    public static ScaleLineUnitSystem NauticalMileAndImperial;
    public static ScaleLineUnitSystem ImperialAndMetric;
}
public class ThinkGeo.Core.ScaleTextAdornmentLayer : AdornmentLayer {
    private static int DyE=;
    private static int EiE=;
    [ObfuscationAttribute]
private ScaleTextScreenUnit screenUnit;
    [ObfuscationAttribute]
private DistanceUnit worldUnit;
    [ObfuscationAttribute]
private GeoFont font;
    [ObfuscationAttribute]
private GeoBrush textBrush;
    [ObfuscationAttribute]
private int width;
    [ObfuscationAttribute]
private int height;
    [ObfuscationAttribute]
private ScreenPointF screenLocation;
    [ObfuscationAttribute]
private bool needToRefresh;
    public ScaleTextScreenUnit ScreenUnit { get; public set; }
    public DistanceUnit WorldUnit { get; public set; }
    public GeoFont Font { get; public set; }
    public GeoBrush TextBrush { get; public set; }
    public ScaleTextAdornmentLayer(ScaleTextScreenUnit screenUnit, DistanceUnit worldUnit);
    public ScaleTextAdornmentLayer(ScaleTextScreenUnit screenUnit, DistanceUnit worldUnit, GeoFont font, GeoBrush textBrush);
    public ScaleTextScreenUnit get_ScreenUnit();
    public void set_ScreenUnit(ScaleTextScreenUnit value);
    public DistanceUnit get_WorldUnit();
    public void set_WorldUnit(DistanceUnit value);
    public GeoFont get_Font();
    public void set_Font(GeoFont value);
    public GeoBrush get_TextBrush();
    public void set_TextBrush(GeoBrush value);
    protected virtual void DrawCore(GeoCanvas canvas, Collection`1<SimpleCandidate> labelsInAllLayers);
    private double JiE=(double amount, ScaleTextScreenUnit fromUnit, ScaleTextScreenUnit toUnit);
    private void FCE=(GeoCanvas canvas, GeographyUnit mapUnit);
}
public enum ThinkGeo.Core.ScaleTextScreenUnit : Enum {
    public int value__;
    public static ScaleTextScreenUnit Inch;
    public static ScaleTextScreenUnit Centimeter;
}
public class ThinkGeo.Core.ScreenPoint : ValueType {
    [ObfuscationAttribute]
private int x;
    [ObfuscationAttribute]
private int y;
    public int X { get; }
    public int Y { get; }
    public ScreenPoint(int x, int y);
    public int get_X();
    public int get_Y();
    public virtual string ToString();
    public static bool op_Equality(ScreenPoint screenPoint1, ScreenPoint screenPoint2);
    public static bool op_Inequality(ScreenPoint screenPoint1, ScreenPoint screenPoint2);
    public virtual bool Equals(object obj);
    private bool lhU=(ScreenPoint compareObj);
    public virtual int GetHashCode();
}
[yhM=]
public class ThinkGeo.Core.ScreenPointD : ValueType {
    [CompilerGeneratedAttribute]
private double Ehw=;
    [CompilerGeneratedAttribute]
private double Exw=;
    public double X { get; }
    public double Y { get; }
    public ScreenPointD(double x, double y);
    [CompilerGeneratedAttribute]
public double get_X();
    [CompilerGeneratedAttribute]
public double get_Y();
    public virtual string ToString();
    public static bool op_Equality(ScreenPointD p1, ScreenPointD p2);
    public static bool op_Inequality(ScreenPointD p1, ScreenPointD p2);
    public virtual bool Equals(object obj);
    private bool lhU=(ScreenPointF compareObj);
    public virtual int GetHashCode();
}
public class ThinkGeo.Core.ScreenPointF : ValueType {
    [ObfuscationAttribute]
private float x;
    [ObfuscationAttribute]
private float y;
    public float X { get; }
    public float Y { get; }
    public ScreenPointF(float x, float y);
    public float get_X();
    public float get_Y();
    public virtual string ToString();
    public static bool op_Equality(ScreenPointF screenPointF1, ScreenPointF screenPointF2);
    public static bool op_Inequality(ScreenPointF screenPointF1, ScreenPointF screenPointF2);
    public virtual bool Equals(object obj);
    private bool lhU=(ScreenPointF compareObj);
    public virtual int GetHashCode();
}
public class ThinkGeo.Core.SendingHttpRequestMessageEventArgs : EventArgs {
    [CompilerGeneratedAttribute]
private HttpRequestMessage WiA=;
    [CompilerGeneratedAttribute]
private bool sBQ=;
    public HttpRequestMessage HttpRequestMessage { get; public set; }
    public bool Cancel { get; public set; }
    public SendingHttpRequestMessageEventArgs(HttpRequestMessage webRequest);
    public SendingHttpRequestMessageEventArgs(HttpRequestMessage webRequest, bool cancel);
    [CompilerGeneratedAttribute]
public HttpRequestMessage get_HttpRequestMessage();
    [CompilerGeneratedAttribute]
public void set_HttpRequestMessage(HttpRequestMessage value);
    [CompilerGeneratedAttribute]
public bool get_Cancel();
    [CompilerGeneratedAttribute]
public void set_Cancel(bool value);
}
public class ThinkGeo.Core.SendingWebRequestEventArgs : EventArgs {
    [ObfuscationAttribute]
private WebRequest webRequest;
    [ObfuscationAttribute]
private bool cancel;
    public WebRequest WebRequest { get; public set; }
    public bool Cancel { get; public set; }
    public SendingWebRequestEventArgs(WebRequest webRequest);
    public SendingWebRequestEventArgs(WebRequest webRequest, bool cancel);
    public WebRequest get_WebRequest();
    public void set_WebRequest(WebRequest value);
    public bool get_Cancel();
    public void set_Cancel(bool value);
}
public class ThinkGeo.Core.SentWebRequestEventArgs : EventArgs {
    [ObfuscationAttribute]
private WebResponse response;
    public WebResponse Response { get; public set; }
    public SentWebRequestEventArgs(WebResponse response);
    public WebResponse get_Response();
    public void set_Response(WebResponse value);
}
public class ThinkGeo.Core.SerializerHelper : object {
    public static T SerializeCloneDeep(object instance);
    public static Byte[] Serialize(object instance);
    public static T Deserialize(Byte[] bytes);
}
public class ThinkGeo.Core.SessionFileRasterTileCache : FileRasterTileCache {
    [ObfuscationAttribute]
private Collection`1<string> obsoleteCacheIds;
    private static object kxY=;
    private Thread 0h0=;
    public SessionFileRasterTileCache(string cacheDirectory);
    public SessionFileRasterTileCache(string cacheDirectory, string cacheId);
    public SessionFileRasterTileCache(string cacheDirectory, string cacheId, GeoImageFormat imageFormat);
    private static SessionFileRasterTileCache();
    protected virtual void ClearCacheCore();
    private void 0x0=();
    private Collection`1<string> 1B0=();
}
public static class ThinkGeo.Core.ShapeConverter : object {
    [CompilerGeneratedAttribute]
private static EventHandler`1<ConvertedShapeToNtsGeometryShapeConverterEventArgs> FBw=;
    private static WkbByteOrder FRw=;
    private static WKBReader Fhw=;
    private static ShapeConverter();
    [CompilerGeneratedAttribute]
public static void add_ConvertedShapeToNtsGeometry(EventHandler`1<ConvertedShapeToNtsGeometryShapeConverterEventArgs> value);
    [CompilerGeneratedAttribute]
public static void remove_ConvertedShapeToNtsGeometry(EventHandler`1<ConvertedShapeToNtsGeometryShapeConverterEventArgs> value);
    internal static BaseShape Fxw=(Geometry targetJtsShape);
    internal static Geometry GBw=(BaseShape targetShape);
    internal static Geometry GBw=(Byte[] wkb);
    internal static void GRw=(WkbShapeType wkbShapeType, WkbByteOrder byteOrder, BinaryWriter writer);
    internal static void GRw=(int wkbShapeType, WkbByteOrder byteOrder, BinaryWriter writer);
    internal static void GRw=(double value, WkbByteOrder byteOrder, BinaryWriter writer);
    internal static BaseShape Ghw=(Byte[] wkb);
    private static BaseShape Gxw=(BinaryReader binaryReader);
    private static PointShape HBw=(BinaryReader binaryReader);
    private static Vertex HRw=(BinaryReader binaryReader);
    private static LineShape Hhw=(BinaryReader binaryReader);
    private static PolygonShape Ehs=(BinaryReader binaryReader);
    private static MultipointShape Hxw=(BinaryReader binaryReader);
    private static MultilineShape IBw=(BinaryReader binaryReader);
    private static GeometryCollectionShape IRw=(BinaryReader binaryReader);
    private static MultipolygonShape Ihw=(BinaryReader binaryReader);
    private static RingShape Ixw=(BinaryReader binaryReader);
    private static void JBw=(BinaryReader binaryReader);
    private static void JRw=(BinaryReader binaryReader, WkbShapeType wkbShapeType);
    private static int Jhw=(BinaryReader binaryReader);
    private static double Jxw=(BinaryReader binaryReader);
    internal static Vertex KBw=(string oneVertexWkt);
    internal static string KRw=(string oneVertexWkt, Vertex vertex);
}
[ObfuscationAttribute]
[ObfuscationAttribute]
internal class ThinkGeo.Core.ShapeFile : object {
    private static int DCQ=;
    private static int DSQ=;
    private static int DiQ=;
    private static int DyQ=;
    private static int ECQ=;
    private static int nh8=;
    [ObfuscationAttribute]
private string pathFilename;
    private bool pBo=;
    private Stream ESQ=;
    [ObfuscationAttribute]
private ShapeFileIndex shx;
    [CompilerGeneratedAttribute]
private EventHandler`1<StreamLoadingEventArgs> Eh8=;
    private static Byte[] EiQ=;
    private static Byte[] EyQ=;
    public string FiQ= { get; public set; }
    public ShapeFileIndex GCQ= { get; }
    public ShapeFileType GiQ= { get; }
    public ShapeFile(string pathFilename);
    private static ShapeFile();
    [CompilerGeneratedAttribute]
public void oR8=(EventHandler`1<StreamLoadingEventArgs> value);
    [CompilerGeneratedAttribute]
public void oh8=(EventHandler`1<StreamLoadingEventArgs> value);
    public string FCQ=();
    public void FSQ=(string value);
    public ShapeFileIndex FyQ=();
    public ShapeFileType GSQ=();
    public virtual void pB8=(StreamLoadingEventArgs e);
    public string GyQ=(int recordIndex);
    public int iB8=();
    public static void HCQ=(string pathFilename, ShapeFileType shapeType);
    private static void HSQ=(string pathFilename, ShapeFileType shapeType);
    public void GR8=(FileAccess readWriteMode);
    public void pR8=();
    public RectangleShape HiQ=();
    public ShapeFileType HyQ=();
    public RectangleShape ICQ=(int recordIndex);
    public void zSE=(BaseShape targetShape);
    public void gh8=(int recordIndex);
    public void ziE=(int index, BaseShape targetShape);
    public void gx8=();
    public void px8=();
    public Byte[] ISQ=(int recordIndex);
    private Byte[] IiQ=(Byte[] dataBytes, int startIndex);
    private int IyQ=(BaseShape targetShape);
    private int JCQ=(MultipolygonShape targetShape, Stream stream);
    private static List`1<RingShape> JSQ=(MultipolygonShape targetShape);
    private int JiQ=(MultilineShape targetShape, Stream stream);
    private int JyQ=(MultipointShape targetShape, Stream stream);
    private static int KCQ=(PointShape targetShape, Stream stream);
    private static Byte[] qhw=(Byte[] dataBytes, int startIndex);
    private static MultipolygonShape KSQ=(RingShape[] ringShapes);
    private static void KiQ=(RingShape innerRing, MultipolygonShape multiPolygonShape, List`1<RectangleShape> polygonBoundingBoxes);
    private static Byte[] KyQ=(MultipolygonShape multipolygon);
    private static Byte[] LCQ=(PolygonShape polygonShape);
    private static Byte[] qBw=(Byte[] dataBytes, int startIndex);
    private static Byte[] LSQ=(Byte[] dataBytes, int startIndex);
    private static Byte[] LiQ=(Byte[] dataBytes, int startIndex);
    private static Byte[] LyQ=(int partsCount, Byte[] dataBytes, int startIndex);
    private static void hB0=(Byte[] sourceArray, Byte[] destinateArray, long destinateIndex);
    private static int PRU=(Byte[] wkb, int startIndex, byte byteOrder);
    internal static int MCQ=(Stream stream, WkbByteOrder byteOrder);
    internal static void MSQ=(int value, Stream stream, WkbByteOrder byteOrder);
    private static void MiQ=(double value, Stream stream, WkbByteOrder byteOrder);
    internal static int MyQ=(ShapeFileType shapeFileType);
    private static ShapeFileBoundingBox NCQ=(RectangleShape rectangleShape);
    private static bool NSQ=(Vertex p, RingShape ring);
    private static int NiQ=(double x1, double y1, double x2, double y2);
    private static Byte[] NyQ=(Byte[] dataBytes, int startIndex);
    private static void OCQ=(Collection`1<JEA=> outerWkbRing, RectangleShape outerRingBoudingBox, Collection`1<JEA=> innerWkbRings, Collection`1<RectangleShape> innerRingsBoudingBoxes);
    private static bool OSQ=(JEA= innerWkbRing, RectangleShape innerRingsBoudingBox, Collection`1<Collection`1<JEA=>> outerWkbRings, Collection`1<RectangleShape> outerRingBoudingBoxes);
}
[ObfuscationAttribute]
internal class ThinkGeo.Core.ShapeFileBoundingBox : object {
    private static int OiQ=;
    private static int OyQ=;
    [ObfuscationAttribute]
private double minX;
    [ObfuscationAttribute]
private double maxX;
    [ObfuscationAttribute]
private double minY;
    [ObfuscationAttribute]
private double maxY;
    public double PiQ= { get; public set; }
    public double QSQ= { get; public set; }
    public double RCQ= { get; public set; }
    public double RyQ= { get; public set; }
    public double PCQ=();
    public void PSQ=(double value);
    public double PyQ=();
    public void QCQ=(double value);
    public double QiQ=();
    public void QyQ=(double value);
    public double RSQ=();
    public void RiQ=(double value);
    public static ShapeFileBoundingBox SCQ=(Stream stream);
    public void SSQ=(ShapeFileBoundingBox targetBox);
    public void SiQ=(Stream stream, bool isHeaderBoundingBox);
    private static Byte[] vBo=(double doubleValue, byte byteOrder);
    internal RectangleShape SyQ=();
}
public class ThinkGeo.Core.ShapeFileFeatureLayer : FeatureLayer {
    private static int TCQ=;
    [ObfuscationAttribute]
private int progressiveDrawingRecordsCount;
    public bool HasBoundingBox { get; }
    public bool UsingSpatialIndex { get; }
    public Encoding Encoding { get; public set; }
    public string ShapePathFilename { get; public set; }
    public string IndexPathFilename { get; public set; }
    public FileAccess ReadWriteMode { get; public set; }
    public bool RequireIndex { get; public set; }
    public int ProgressiveDrawingRecordsCount { get; public set; }
    public int SimplificationAreaInPixel { get; public set; }
    public ShapeFileFeatureLayer(string shapePathFilename);
    public ShapeFileFeatureLayer(string shapePathFilename, FileAccess readWriteMode);
    public ShapeFileFeatureLayer(string shapePathFilename, string indexPathFilename);
    public ShapeFileFeatureLayer(string shapePathFilename, string indexPathFilename, FileAccess readWriteMode);
    public ShapeFileFeatureLayer(string shapePathFilename, string indexPathFilename, FileAccess readWriteMode, Encoding encoding);
    public void add_StreamLoading(EventHandler`1<StreamLoadingEventArgs> value);
    public void remove_StreamLoading(EventHandler`1<StreamLoadingEventArgs> value);
    public virtual bool get_HasBoundingBox();
    public bool get_UsingSpatialIndex();
    public Encoding get_Encoding();
    public void set_Encoding(Encoding value);
    public string get_ShapePathFilename();
    public void set_ShapePathFilename(string value);
    public string get_IndexPathFilename();
    public void set_IndexPathFilename(string value);
    public FileAccess get_ReadWriteMode();
    public void set_ReadWriteMode(FileAccess value);
    public bool get_RequireIndex();
    public void set_RequireIndex(bool value);
    public int get_ProgressiveDrawingRecordsCount();
    public void set_ProgressiveDrawingRecordsCount(int value);
    public int get_SimplificationAreaInPixel();
    public void set_SimplificationAreaInPixel(int value);
    protected virtual LayerBase CloneDeepCore();
    public static void Rebuild(string shapePathFilename);
    public static void Rebuild(string shapePathFilename, ShapeFileSortingMode sortingMode, int sridForSorting);
    public static void CreateShapeFile(ShapeFileType shapeType, string pathFilename, IEnumerable`1<DbfColumn> databaseColumns);
    public static void CreateShapeFile(ShapeFileType shapeType, string pathFilename, IEnumerable`1<DbfColumn> databaseColumns, Encoding encoding);
    public static void CreateShapeFile(ShapeFileType shapeType, string pathFilename, IEnumerable`1<DbfColumn> databaseColumns, Encoding encoding, OverwriteMode overwriteMode);
    public static void BuildIndexFile(string pathFilename);
    public static void BuildIndexFile(string shapePathFilename, string indexPathFilename, BuildIndexMode buildIndexMode);
    public static void BuildIndexFile(string pathFilename, BuildIndexMode rebuildExistingIndexMode);
    public static void BuildIndexFile(IEnumerable`1<Feature> features, string indexPathFilename);
    public static void BuildIndexFile(IEnumerable`1<Feature> features, string indexPathFilename, ProjectionConverter projectionConverter);
    public static void BuildIndexFile(IEnumerable`1<Feature> features, string indexPathFilename, BuildIndexMode buildIndexMode);
    public static void BuildIndexFile(IEnumerable`1<Feature> features, string indexPathFilename, ProjectionConverter projectionConverter, BuildIndexMode buildIndexMode);
    public static void BuildIndexFile(string shapePathFilename, string indexPathFilename, string columnName, string regularExpression, BuildIndexMode buildIndexMode);
    public static void BuildIndexFile(string shapePathFilename, string indexPathFilename, ProjectionConverter projectionConverter, string columnName, string regularExpression, BuildIndexMode buildIndexMode);
    public static void BuildIndexFile(string shapePathFilename, string indexPathFilename, ProjectionConverter projectionConverter, string columnName, string regularExpression, BuildIndexMode buildIndexMode, Encoding encoding);
    public static void CloneShapeFileStructure(string sourceShapePathFilename, string targetShapePathFilename);
    public static void CloneShapeFileStructure(string sourceShapePathFilename, string targetShapePathFilename, OverwriteMode overwriteMode);
    public static void CloneShapeFileStructure(string sourceShapePathFilename, string targetShapePathFilename, OverwriteMode overwriteMode, Encoding encoding);
    public static void BuildRecordIdColumn(string shapeFilename, string fieldname, BuildRecordIdMode rebuildNeeded);
    public static void BuildRecordIdColumn(string shapeFilename, string fieldname, BuildRecordIdMode rebuildNeeded, int startNumber);
    public static void BuildRecordIdColumn(string shapeFilename, string fieldname, BuildRecordIdMode rebuildNeeded, int startNumber, Encoding encoding);
    public ShapeFileType GetShapeFileType();
    public static void Reproject(string sourceShapeFile, string targetShapeFile, ProjectionConverter projectionConverter, OverwriteMode overwriteMode);
    public Dictionary`2<string, string> Validate();
    public static Collection`1<DbfColumn> GetValidColumns(IEnumerable`1<DbfColumn> columns);
    public static Collection`1<DbfColumn> GetValidColumns(IEnumerable`1<DbfColumn> columns, Encoding encoding);
    public static Collection`1<string> GetValidColumnNames(IEnumerable`1<string> columnNames);
    public static Collection`1<string> GetValidColumnNames(IEnumerable`1<string> columnNames, Encoding encoding);
    protected virtual void DrawCore(GeoCanvas canvas, Collection`1<SimpleCandidate> labelsInAllLayers);
    private static BaseShape eSQ=(ShapeFileType shapeFileType, RectangleShape boundingBox);
    private void eiQ=(GeoCanvas canvas, RectangleShape marginWorldExtent, Collection`1<SimpleCandidate> labelsInThisLayer, Collection`1<SimpleCandidate> labelsInAllLayers, ZoomLevel currentZoomLevel, Collection`1<string> columnNames, ShapeFileFeatureSource shapeFileFeatureSource, Collection`1<RectangleShape> smallBoxes, Collection`1<string> ids);
    private void eyQ=(GeoCanvas canvas, RectangleShape drawingExtent, Collection`1<SimpleCandidate> labelsInAllLayers, ZoomLevel currentZoomLevel, Collection`1<string> columnNames, ShapeFileFeatureSource shapeFileFeatureSource, Collection`1<string> idsToDraw);
    private RectangleShape fCQ=(RectangleShape boundingBox);
    private bool XSQ=(int progressPercentage, object userState, int featuresToDraw, int featuresDrawn);
    private static void fSQ=(Collection`1<RectangleShape> smallBoxes, Collection`1<Feature> resultFeatures, Collection`1<string> columnNames);
    private static void fiQ=(Collection`1<RectangleShape> smallBoxes, Collection`1<Feature> resultFeatures, Collection`1<string> columnNames);
    private static void fyQ=(Collection`1<RectangleShape> smallBoxes, Collection`1<Feature> resultFeatures, Collection`1<string> columnNames);
    private void TyA=(object sender, DrawingProgressChangedEventArgs e);
    private static BaseShape rho=(ProjectionConverter projection, BaseShape shape);
}
public class ThinkGeo.Core.ShapeFileFeatureSource : FeatureSource {
    private static int TCQ=;
    private GeoDbf TSQ=;
    [ObfuscationAttribute]
private FileAccess readWriteMode;
    [ObfuscationAttribute]
private string indexPathFilename;
    [ObfuscationAttribute]
private bool requireIndex;
    private RtreeSpatialIndex xiE=;
    private ShapeFile TiQ=;
    private FileAccess TyQ=;
    [ObfuscationAttribute]
private string shapePathFilename;
    private Encoding FR8=;
    [ObfuscationAttribute]
private int codePage;
    [ObfuscationAttribute]
private int simplificationAreaInPixel;
    [ObfuscationAttribute]
private Collection`1<RectangleShape> simplifiedAreas;
    [CompilerGeneratedAttribute]
private EventHandler`1<StreamLoadingEventArgs> Eh8=;
    [CompilerGeneratedAttribute]
private static EventHandler`1<BuildingIndexShapeFileFeatureSourceEventArgs> xSE=;
    [CompilerGeneratedAttribute]
private static EventHandler`1<RebuildingShapeFileFeatureSourceEventArgs> UCQ=;
    public string ShapePathFilename { get; public set; }
    public string IndexPathFilename { get; public set; }
    public FileAccess ReadWriteMode { get; public set; }
    public bool IsEditable { get; }
    public bool UsingSpatialIndex { get; }
    public bool RequireIndex { get; public set; }
    public Encoding Encoding { get; public set; }
    public int SimplificationAreaInPixel { get; public set; }
    public Collection`1<RectangleShape> SimplifiedAreas { get; }
    public ShapeFileFeatureSource(string shapePathFilename);
    public ShapeFileFeatureSource(string shapePathFilename, FileAccess readWriteMode);
    public ShapeFileFeatureSource(string shapePathFilename, string indexPathFilename);
    public ShapeFileFeatureSource(string shapePathFilename, string indexPathFilename, FileAccess readWriteMode);
    public ShapeFileFeatureSource(string shapePathFilename, string indexPathFilename, FileAccess readWriteMode, Encoding encoding);
    public string get_ShapePathFilename();
    public void set_ShapePathFilename(string value);
    public string get_IndexPathFilename();
    public void set_IndexPathFilename(string value);
    public FileAccess get_ReadWriteMode();
    public void set_ReadWriteMode(FileAccess value);
    public virtual bool get_IsEditable();
    public bool get_UsingSpatialIndex();
    public bool get_RequireIndex();
    public void set_RequireIndex(bool value);
    public Encoding get_Encoding();
    public void set_Encoding(Encoding value);
    public int get_SimplificationAreaInPixel();
    public void set_SimplificationAreaInPixel(int value);
    public Collection`1<RectangleShape> get_SimplifiedAreas();
    [CompilerGeneratedAttribute]
public void add_StreamLoading(EventHandler`1<StreamLoadingEventArgs> value);
    [CompilerGeneratedAttribute]
public void remove_StreamLoading(EventHandler`1<StreamLoadingEventArgs> value);
    [CompilerGeneratedAttribute]
public static void add_BuildingIndex(EventHandler`1<BuildingIndexShapeFileFeatureSourceEventArgs> value);
    [CompilerGeneratedAttribute]
public static void remove_BuildingIndex(EventHandler`1<BuildingIndexShapeFileFeatureSourceEventArgs> value);
    [CompilerGeneratedAttribute]
public static void add_Rebuilding(EventHandler`1<RebuildingShapeFileFeatureSourceEventArgs> value);
    [CompilerGeneratedAttribute]
public static void remove_Rebuilding(EventHandler`1<RebuildingShapeFileFeatureSourceEventArgs> value);
    protected virtual FeatureSource CloneDeepCore();
    protected virtual void OnStreamLoading(StreamLoadingEventArgs e);
    protected static void OnBuildingIndex(BuildingIndexShapeFileFeatureSourceEventArgs e);
    protected static void OnRebuilding(RebuildingShapeFileFeatureSourceEventArgs e);
    public static void Rebuild(string shapePathFilename);
    public static void Rebuild(string shapePathFilename, ShapeFileSortingMode sortingMode, int sridForSorting);
    private static void USQ=(string shapePathFilename, ShapeFileSortingMode sortingMode, int srid);
    public static void BuildIndexFile(string shapePathFilename);
    public static void BuildIndexFile(string shapePathFilename, BuildIndexMode buildIndexMode);
    public static void BuildIndexFile(string shapePathFilename, string indexPathFilename, BuildIndexMode buildIndexMode);
    public static void BuildIndexFile(string shapePathFilename, string indexPathFilename, ProjectionConverter projectionConverter, BuildIndexMode buildIndexMode);
    public static void BuildIndexFile(string shapePathFilename, string indexPathFilename, string columnName, string regularExpression, BuildIndexMode buildIndexMode);
    public static void BuildIndexFile(string shapePathFilename, string indexPathFilename, ProjectionConverter projectionConverter, string columnName, string regularExpression, BuildIndexMode buildIndexMode);
    public static void BuildIndexFile(string shapePathFilename, string indexPathFilename, ProjectionConverter projectionConverter, string columnName, string regularExpression, BuildIndexMode buildIndexMode, Encoding encoding);
    public static void BuildIndexFile(IEnumerable`1<Feature> features, string indexPathFilename);
    public static void BuildIndexFile(IEnumerable`1<Feature> features, string indexPathFilename, ProjectionConverter projectionConverter);
    public static void BuildIndexFile(IEnumerable`1<Feature> features, string indexPathFilename, BuildIndexMode buildIndexMode);
    public static void BuildIndexFile(IEnumerable`1<Feature> features, string indexPathFilename, ProjectionConverter projectionConverter, BuildIndexMode buildIndexMode);
    private static void UiQ=(BaseShape baseShape, RtreeSpatialIndex openedRtree, ProjectionConverter openedProjection);
    public static Collection`1<DbfColumn> GetValidColumns(IEnumerable`1<DbfColumn> columns);
    public static Collection`1<DbfColumn> GetValidColumns(IEnumerable`1<DbfColumn> columns, Encoding encoding);
    public static Collection`1<string> GetValidColumnNames(IEnumerable`1<string> columnNames);
    public static Collection`1<string> GetValidColumnNames(IEnumerable`1<string> columnNames, Encoding encoding);
    public static void CreateShapeFile(ShapeFileType shapeType, string pathFilename, IEnumerable`1<DbfColumn> databaseColumns);
    public static void CreateShapeFile(ShapeFileType shapeType, string pathFilename, IEnumerable`1<DbfColumn> databaseColumns, Encoding encoding);
    public static void CreateShapeFile(ShapeFileType shapeType, string pathFilename, IEnumerable`1<DbfColumn> databaseColumns, Encoding encoding, OverwriteMode overwriteMode);
    public Collection`1<DbfColumn> GetDbfColumns();
    public static void CloneShapeFileStructure(string sourceShapePathFilename, string targetShapePathFilename);
    public static void CloneShapeFileStructure(string sourceShapePathFilename, string targetShapePathFilename, OverwriteMode overwriteMode);
    public static void CloneShapeFileStructure(string sourceShapePathFilename, string targetShapePathFilename, OverwriteMode overwriteMode, Encoding encoding);
    public Dictionary`2<string, string> Validate();
    public void AddColumnBoolean(string columnName);
    public void AddColumnDate(string columnName);
    public void AddColumnDouble(string columnName, int totalLength, int precisionLength);
    public void AddColumnInteger(string columnName, int length);
    public void AddColumnMemo(string columnName);
    public void AddColumnMemo(string columnName, int memoValueLength);
    public void AddColumnString(string columnName, int length);
    public string GetDataFromDbf(string id, string columnName);
    public Dictionary`2<string, string> GetDataFromDbf(string id);
    public Dictionary`2<string, string> GetDataFromDbf(string id, IEnumerable`1<string> returningColumnNames);
    public Dictionary`2<string, string> GetDataFromDbf(string id, ReturningColumnsType returningColumnNamesType);
    public Collection`1<Dictionary`2<string, string>> GetDataFromDbf(IEnumerable`1<string> ids);
    public Collection`1<Dictionary`2<string, string>> GetDataFromDbf(IEnumerable`1<string> ids, string columnName);
    public Collection`1<Dictionary`2<string, string>> GetDataFromDbf(IEnumerable`1<string> ids, IEnumerable`1<string> columnNames);
    public Collection`1<Dictionary`2<string, string>> GetDataFromDbf(IEnumerable`1<string> ids, ReturningColumnsType returningColumnNamesType);
    public void UpdateDbfData(string id, string columnName, string value);
    public void UpdateDbfData(string id, IEnumerable`1<string> columnNames, IEnumerable`1<string> values);
    public ShapeFileType GetShapeFileType();
    public static void BuildRecordIdColumn(string shapeFilename, string fieldname, BuildRecordIdMode rebuildNeeded);
    public static void BuildRecordIdColumn(string shapeFilename, string fieldname, BuildRecordIdMode rebuildNeeded, int startNumber);
    public static void BuildRecordIdColumn(string shapeFilename, string fieldname, BuildRecordIdMode rebuildNeeded, int startNumber, Encoding encoding);
    public static void Reproject(string sourceShapeFile, string targetShapeFile, ProjectionConverter projectionConverter, OverwriteMode overwriteMode);
    private void UyQ=(string fieldName, int startNumber, bool fieldNameFound);
    protected virtual void OpenCore();
    private void VCQ=(FileAccess rTreeFileAccess);
    private void KR8=();
    private void VSQ=();
    protected virtual void CloseCore();
    protected virtual TransactionResult CommitTransactionCore(TransactionBuffer transactions);
    private void ViQ=(TransactionBuffer transactions, TransactionResult transactionResult);
    private Collection`1<DbfColumn> VyQ=(Dictionary`2<string, FeatureSourceColumn> filteredEditColumns);
    protected virtual Collection`1<Feature> GetAllFeaturesCore(IEnumerable`1<string> returningColumnNames);
    protected virtual Collection`1<string> GetFeatureIdsCore();
    protected virtual Collection`1<FeatureSourceColumn> GetColumnsCore();
    protected virtual RectangleShape GetBoundingBoxCore();
    protected virtual RectangleShape GetBoundingBoxByIdCore(string id);
    protected virtual Collection`1<Feature> GetFeaturesOutsideBoundingBoxCore(RectangleShape boundingBox, IEnumerable`1<string> returningColumnNames);
    protected virtual Collection`1<Feature> GetFeaturesInsideBoundingBoxCore(RectangleShape boundingBox, IEnumerable`1<string> returningColumnNames);
    protected virtual Collection`1<Feature> GetFeaturesByColumnValueCore(string columnName, string columnValue, IEnumerable`1<string> returningColumnNames);
    public Collection`1<string> GetFeatureIdsForDrawing(RectangleShape boundingBox, double screenWidth, double screenHeight);
    protected virtual Collection`1<string> GetFeatureIdsForDrawingCore(RectangleShape boundingBox, double screenWidth, double screenHeight);
    protected virtual Collection`1<Feature> GetFeaturesForDrawingCore(RectangleShape boundingBox, double screenWidth, double screenHeight, IEnumerable`1<string> returningColumnNames);
    private static Byte[] WCQ=(RectangleShape rectangleShape);
    private static void WSQ=(Byte[] sourceBytes, Byte[] destinateBytes, int startIndex);
    private static bool WiQ=(PointShape upperLeftPoint, RectangleShape boundingBox, double screenFactorX, double screenFactorY);
    protected virtual Collection`1<Feature> GetFeaturesByIdsCore(IEnumerable`1<string> ids, IEnumerable`1<string> returningColumnNames);
    protected virtual long GetCountCore();
    protected virtual bool CanGetCountQuicklyCore();
    protected virtual WellKnownType GetFirstFeaturesWellKnownTypeCore();
    protected virtual Collection`1<DistinctColumnValue> GetDistinctColumnValuesCore(string columnName);
    protected virtual Collection`1<Feature> GetAllFeaturesCore(IEnumerable`1<string> returningColumnNames, int startIndex, int takeCount);
    private void WyQ=(object sender, StreamLoadingEventArgs e);
    private static void /SM=(string idxPathFilename, WellKnownType wellKnownType);
    private static void /SM=(string idxPathFilename, ShapeFileType shapeFileType);
    private void zSE=(Feature feature);
    private Dictionary`2<string, string> XCQ=(Dictionary`2<string, string> fieldValues);
    private void gh8=(int index);
    private void ziE=(Feature targetFeature);
    private bool XSQ=(int progressPercentage, object userState, int featuresToDraw, int featuresDrawn);
    private static void CyQ=(string pathFilename);
    private static void XiQ=(string sourcePathFilename, string targetPathFilename);
    private static bool XyQ=(IEnumerable`1<string> values);
    [OnGeodeserializedAttribute]
private void RBU=();
    private void YCQ=(FeatureSourceColumn column);
    private static DbfColumnType YSQ=(string columnTypeName);
    private Collection`1<int> YiQ=();
    private void YyQ=(Action`1<int> processById);
}
[ObfuscationAttribute]
internal class ThinkGeo.Core.ShapeFileHeader : object {
    private static int ZCQ=;
    private static long ZSQ=;
    private static int OiQ=;
    private static int OyQ=;
    private static int DSQ=;
    [ObfuscationAttribute]
private int fileCode;
    [ObfuscationAttribute]
private int fileLength;
    [ObfuscationAttribute]
private int version;
    [ObfuscationAttribute]
private ShapeFileBoundingBox boundingBox;
    [ObfuscationAttribute]
private ShapeFileType shapeFileType;
    public int aCQ= { get; public set; }
    public ShapeFileType GiQ= { get; public set; }
    public ShapeFileBoundingBox bCQ= { get; public set; }
    public ShapeFileHeader(ShapeFileType shapeFileType);
    public int ZiQ=();
    public void ZyQ=(int value);
    public ShapeFileType GSQ=();
    public void aSQ=(ShapeFileType value);
    public ShapeFileBoundingBox aiQ=();
    public void ayQ=(ShapeFileBoundingBox value);
    public static ShapeFileHeader bSQ=(Stream stream);
    public void biQ=(Stream targetFileStream);
    private static ShapeFileType byQ=(int value);
}
[ObfuscationAttribute]
internal class ThinkGeo.Core.ShapeFileIndex : object {
    private static int cCQ=;
    private static int cSQ=;
    private static int nh8=;
    [ObfuscationAttribute]
private string shxPathFilename;
    [ObfuscationAttribute]
private ShapeFileHeader fileHeader;
    private Stream ciQ=;
    [ObfuscationAttribute]
private long startIndex;
    [ObfuscationAttribute]
private long endIndex;
    [ObfuscationAttribute]
private Byte[] cache;
    private bool pBo=;
    [CompilerGeneratedAttribute]
private EventHandler`1<StreamLoadingEventArgs> Eh8=;
    public string dSQ= { get; public set; }
    public ShapeFileHeader mx8= { get; public set; }
    public ShapeFileIndex(string shxPathFilename);
    [CompilerGeneratedAttribute]
public void oR8=(EventHandler`1<StreamLoadingEventArgs> value);
    [CompilerGeneratedAttribute]
public void oh8=(EventHandler`1<StreamLoadingEventArgs> value);
    public string cyQ=();
    public void dCQ=(string value);
    public ShapeFileHeader mR8=();
    public void mh8=(ShapeFileHeader value);
    internal virtual void pB8=(StreamLoadingEventArgs e);
    public void GR8=();
    public void GR8=(FileAccess readWriteMode);
    public void pR8=();
    public int iB8=();
    public long diQ=(int recordIndex);
    public void px8=();
    public int dyQ=(int recordIndex);
    public void ziE=(int recordIndex, long offset, int contentLength);
    public void zSE=(long offset, int contentLength);
    private void eCQ=(int recordIndex, long offset, int contentLength);
    public void gh8=(int recordIndex);
    public void gx8=();
}
public enum ThinkGeo.Core.ShapeFileSortingMode : Enum {
    public int value__;
    public static ShapeFileSortingMode Default;
    public static ShapeFileSortingMode Geohash;
    public static ShapeFileSortingMode None;
}
public enum ThinkGeo.Core.ShapeFileType : Enum {
    public int value__;
    public static ShapeFileType Null;
    public static ShapeFileType Point;
    public static ShapeFileType Polyline;
    public static ShapeFileType Polygon;
    public static ShapeFileType Multipoint;
    public static ShapeFileType PointZ;
    public static ShapeFileType PolylineZ;
    public static ShapeFileType PolygonZ;
    public static ShapeFileType MultipointZ;
    public static ShapeFileType PointM;
    public static ShapeFileType PolylineM;
    public static ShapeFileType PolygonM;
    public static ShapeFileType MultipointM;
    public static ShapeFileType Multipatch;
}
public static class ThinkGeo.Core.ShapefileValidatorHelper : object {
    internal static void iCQ=(string pathFilename, string parameterName);
    internal static void iSQ=(ShapeFileBoundingBox shapeFileBoundingBox);
    public static void CheckSqlStatementIsSupported(string sqlStatement);
    public static void CheckShapeFileIsWriteable(FileAccess readWriteMode, string parameterName);
    public static void CheckShapeFileTypeIsValid(ShapeFileType shapeFileType, string parameterName);
    public static void CheckDbfColumnsAreEmpty(IEnumerable`1<DbfColumn> dbfColumns, string parameterName);
    public static void CheckShapeFileIsEditable(ShapeFileType shapeFileType, string parameterName);
    public static void CheckShapeFileTypeIsSupported(ShapeFileType shapeFileType, string parameterName);
}
public enum ThinkGeo.Core.ShapeValidationMode : Enum {
    public int value__;
    public static ShapeValidationMode Simple;
    public static ShapeValidationMode Advanced;
}
public class ThinkGeo.Core.ShapeValidationResult : ValueType {
    [ObfuscationAttribute]
private bool isValid;
    [ObfuscationAttribute]
private string validationErrors;
    public bool IsValid { get; }
    public string ValidationErrors { get; }
    public ShapeValidationResult(bool isValid, string validationErrors);
    public bool get_IsValid();
    public string get_ValidationErrors();
    public static bool op_Equality(ShapeValidationResult sourceShapeValidationResult, ShapeValidationResult targetShapeValidationResult);
    public static bool op_Inequality(ShapeValidationResult sourceShapeValidationResult, ShapeValidationResult targetShapeValidationResult);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
}
public class ThinkGeo.Core.SimpleCandidate : object {
    [ObfuscationAttribute]
private string originalText;
    [ObfuscationAttribute]
private PolygonShape simplePolygonInScreenCoordinate;
    [ObfuscationAttribute]
private bool isAllowOverlapping;
    public string OriginalText { get; public set; }
    public PolygonShape SimplePolygonInScreenCoordinate { get; public set; }
    internal bool ojE= { get; internal set; }
    public SimpleCandidate(string originalText, PolygonShape simplePolygonInScreenCoordinate);
    public string get_OriginalText();
    public void set_OriginalText(string value);
    public PolygonShape get_SimplePolygonInScreenCoordinate();
    public void set_SimplePolygonInScreenCoordinate(PolygonShape value);
    internal bool oDE=();
    internal void oTE=(bool value);
}
public class ThinkGeo.Core.SimpleFilterCondition : FilterCondition {
    private string 0zE=;
    private SimpleFilterConditionType 1DE=;
    private static Dictionary`2<SimpleFilterConditionType, Tuple`2<string, string>> 1TE=;
    public string MatchValue { get; public set; }
    public SimpleFilterConditionType MatchType { get; public set; }
    private static SimpleFilterCondition();
    public SimpleFilterCondition(string columnName, SimpleFilterConditionType matchType, string matchValue);
    public string get_MatchValue();
    public void set_MatchValue(string value);
    public SimpleFilterConditionType get_MatchType();
    public void set_MatchType(SimpleFilterConditionType value);
    protected virtual Collection`1<Feature> GetMatchingFeaturesCore(IEnumerable`1<Feature> features);
    private void 1jE=();
}
[ObfuscationAttribute]
public enum ThinkGeo.Core.SimpleFilterConditionType : Enum {
    public int value__;
    public static SimpleFilterConditionType Equal;
    public static SimpleFilterConditionType Contains;
    public static SimpleFilterConditionType StartsWith;
    public static SimpleFilterConditionType EndsWith;
    public static SimpleFilterConditionType DoesNotEqual;
    public static SimpleFilterConditionType DoesNotContain;
    public static SimpleFilterConditionType GreaterThan;
    public static SimpleFilterConditionType GreaterThanOrEqualTo;
    public static SimpleFilterConditionType LessThan;
    public static SimpleFilterConditionType LessThanOrEqualTo;
    public static SimpleFilterConditionType IsEmpty;
    public static SimpleFilterConditionType IsNotEmpty;
}
public enum ThinkGeo.Core.SimplificationType : Enum {
    public int value__;
    public static SimplificationType TopologyPreserving;
    public static SimplificationType DouglasPeucker;
}
public class ThinkGeo.Core.SkiaGeoCanvas : GeoCanvas {
    [ObfuscationAttribute]
private GeoImage[] bufferImages;
    [ObfuscationAttribute]
private YBU=[] graphicses;
    public bool SupportKeyColor { get; }
    public virtual bool get_SupportKeyColor();
    protected virtual void BeginDrawingCore(object nativeImage, RectangleShape worldExtent, GeographyUnit drawingMapUnit);
    private YBU= WBU=(int i);
    private GeoImage WRU=(int i);
    protected virtual void DrawArcCore(GeoPen pen, float x, float y, float width, float height, float startAngle, float sweepAngle, DrawingLevel drawingLevel);
    protected virtual void DrawAreaCore(IEnumerable`1<ScreenPointF[]> screenPoints, GeoPen outlinePen, GeoBrush fillBrush, DrawingLevel drawingLevel, float xOffset, float yOffset, PenBrushDrawingOrder penBrushDrawingOrder);
    protected virtual void DrawEllipseCore(ScreenPointF screenPoint, float width, float height, GeoPen outlinePen, GeoBrush fillBrush, DrawingLevel drawingLevel, float xOffset, float yOffset, PenBrushDrawingOrder penBrushDrawingOrder);
    protected virtual void DrawLineCore(IEnumerable`1<ScreenPointF> screenPoints, GeoPen linePen, DrawingLevel drawingLevel, float xOffset, float yOffset);
    protected virtual void DrawScreenImageCore(GeoImage image, float centerXInScreen, float centerYInScreen, float widthInScreen, float heightInScreen, DrawingLevel drawingLevel, float xOffset, float yOffset, float rotateAngle);
    protected virtual void DrawScreenImageWithoutScalingCore(GeoImage image, float centerXInScreen, float centerYInScreen, DrawingLevel drawingLevel, float xOffset, float yOffset, float rotateAngle);
    protected virtual void DrawTextCore(string text, GeoFont font, GeoBrush fillBrush, GeoPen haloPen, IEnumerable`1<ScreenPointF> textPathInScreen, DrawingLevel drawingLevel, float xOffset, float yOffset, DrawingTextAlignment drawingTextAlignment, float rotateAngle);
    private static void WhU=(string text, GeoFont font, GeoBrush fillBrush, GeoPen haloPen, IEnumerable`1<ScreenPointF> textPathInScreen, float xOffset, float yOffset, DrawingTextAlignment drawingTextAlignment, float rotateAngle, YBU= graphics, DrawingRectangleF rectangle);
    protected virtual void EndDrawingCore();
    private void WxU=(GeoImage geoImage);
    private void XBU=(GeoImage geoImage, GeoColor keyColor);
    protected virtual void FlushCore();
    protected virtual float GetCanvasHeightCore();
    protected virtual float GetCanvasWidthCore();
    protected virtual DrawingRectangleF MeasureTextCore(string text, GeoFont font);
    internal virtual float PxU=(GeoFont font, DrawingTextBaseline textBaseline, string text);
    internal void XRU=(GeoImage image, int srcX, int srcY, int srcWidth, int srcHeight, mxU=[] colors, DrawingLevel drawingLevel);
    internal void XhU=(ScreenPointF centerPoint, int radius, Single[] positions, GeoColor[] colors, DrawingLevel drawingLevel);
    private SKFilterQuality XxU=(DrawingQuality drawingQuality);
}
public abstract class ThinkGeo.Core.SpatialIndex : object {
    private bool pBo=;
    [ObfuscationAttribute]
private bool canDelete;
    public bool IsOpen { get; }
    public bool CanDelete { get; protected set; }
    protected bool IsOpenCore { get; protected set; }
    public bool get_IsOpen();
    public bool get_CanDelete();
    protected void set_CanDelete(bool value);
    protected virtual bool get_IsOpenCore();
    protected virtual void set_IsOpenCore(bool value);
    public void Add(BaseShape baseShape);
    public void Add(Feature feature);
    protected abstract virtual void AddCore(Feature feature);
    public void Delete(Feature feature);
    public void Delete(BaseShape baseShape);
    protected virtual void DeleteCore(Feature feature);
    public void Close();
    protected virtual void CloseCore();
    public int GetFeatureCount();
    protected virtual int GetFeatureCountCore();
    public Collection`1<string> GetFeatureIdsIntersectingBoundingBox(RectangleShape boundingBox);
    protected abstract virtual Collection`1<string> GetFeatureIdsIntersectingBoundingBoxCore(RectangleShape boundingBox);
    public void Open();
    protected virtual void OpenCore();
}
public class ThinkGeo.Core.SphericalKrigingGridInterpolationModel : KrigingGridInterpolationModel {
    public SphericalKrigingGridInterpolationModel(IDictionary`2<PointShape, double> points);
    public SphericalKrigingGridInterpolationModel(IDictionary`2<PointShape, double> points, int numberOfRefrencedPoints);
    protected virtual double GetSemivarianceCore(double distance, EmpiricalFunctionCoefficients coefficients);
    protected virtual double GetSillSlopeCore(double distance, double range);
}
public class ThinkGeo.Core.SphericalMercatorZoomLevelSet : ZoomLevelSet {
    public SphericalMercatorZoomLevelSet(int tileSize);
    public SphericalMercatorZoomLevelSet(int tileSize, RectangleShape maxExtent);
}
public enum ThinkGeo.Core.SplineType : Enum {
    public int value__;
    public static SplineType Default;
    public static SplineType None;
    public static SplineType StandardSplining;
    public static SplineType ForceSplining;
}
public class ThinkGeo.Core.SqliteColumn : FeatureSourceColumn {
    [ObfuscationAttribute]
private SqliteColumnType columnType;
    public SqliteColumnType ColumnType { get; public set; }
    public SqliteColumn(string columnName, SqliteColumnType columnType);
    public SqliteColumnType get_ColumnType();
    public void set_ColumnType(SqliteColumnType value);
}
public enum ThinkGeo.Core.SqliteColumnType : Enum {
    public int value__;
    public static SqliteColumnType Null;
    public static SqliteColumnType Integer;
    public static SqliteColumnType Real;
    public static SqliteColumnType Text;
    public static SqliteColumnType Blob;
    public static SqliteColumnType Numeric;
}
[GeneratedCodeAttribute("System.Resources.Tools.StronglyTypedResourceBuilder", "4.0.0.0")]
[CompilerGeneratedAttribute]
[ObfuscationAttribute]
[DebuggerNonUserCodeAttribute]
internal class ThinkGeo.Core.SqliteExceptionDescription : object {
    private static ResourceManager resourceMan;
    private static CultureInfo resourceCulture;
    [EditorBrowsableAttribute("2")]
internal static ResourceManager ResourceManager { get; }
    [EditorBrowsableAttribute("2")]
internal static CultureInfo Culture { get; internal set; }
    internal static string ColumnNameNotExist { get; }
    internal static string ConnectionStringCannotBeNull { get; }
    internal static string FeatureIdColumnNotExist { get; }
    internal static string FeatureSourceCanNotExecuteSqlQuery { get; }
    internal static string FeatureSourceIsNotInTransaction { get; }
    internal static string FeatureSourceIsNotOpen { get; }
    internal static string GeometryColumnNotExist { get; }
    internal static string InvalidSrid { get; }
    internal static string ParameterIsInvalid { get; }
    internal static string ParameterIsNull { get; }
    internal static string ParameterIsNullOrEmpty { get; }
    internal static string SqliteDatabaseIsReadOnly { get; }
    internal static ResourceManager get_ResourceManager();
    internal static CultureInfo get_Culture();
    internal static void set_Culture(CultureInfo value);
    internal static string get_ColumnNameNotExist();
    internal static string get_ConnectionStringCannotBeNull();
    internal static string get_FeatureIdColumnNotExist();
    internal static string get_FeatureSourceCanNotExecuteSqlQuery();
    internal static string get_FeatureSourceIsNotInTransaction();
    internal static string get_FeatureSourceIsNotOpen();
    internal static string get_GeometryColumnNotExist();
    internal static string get_InvalidSrid();
    internal static string get_ParameterIsInvalid();
    internal static string get_ParameterIsNull();
    internal static string get_ParameterIsNullOrEmpty();
    internal static string get_SqliteDatabaseIsReadOnly();
}
public class ThinkGeo.Core.SqliteFeatureLayer : FeatureLayer {
    public bool HasBoundingBox { get; }
    public int CommandTimeout { get; public set; }
    public string ConnectionString { get; public set; }
    public string TableName { get; public set; }
    public string FeatureIdColumn { get; public set; }
    public string GeometryColumnName { get; public set; }
    public string WhereClause { get; public set; }
    public SqliteFeatureLayer(string connectionString, string tableName, string featureIdColumn, string geometryColumnName);
    public SqliteFeatureLayer(SqliteConnection connection, string tableName, string featureIdeColumn, string geometryColumnName);
    public virtual bool get_HasBoundingBox();
    public int get_CommandTimeout();
    public void set_CommandTimeout(int value);
    public string get_ConnectionString();
    public void set_ConnectionString(string value);
    public string get_TableName();
    public void set_TableName(string value);
    public string get_FeatureIdColumn();
    public void set_FeatureIdColumn(string value);
    public string get_GeometryColumnName();
    public void set_GeometryColumnName(string value);
    public WellKnownType GetFirstGeometryType();
    public string get_WhereClause();
    public void set_WhereClause(string value);
    public int ExecuteNonQuery(string sqlStatement);
}
[ObfuscationAttribute]
public class ThinkGeo.Core.SqliteFeatureSource : FeatureSource {
    private static int queryInside;
    private static int queryOutside;
    [ObfuscationAttribute]
private string connectionString;
    [ObfuscationAttribute]
private string tableName;
    [ObfuscationAttribute]
private string geometryColumn;
    [ObfuscationAttribute]
private string featureIdColumn;
    [ObfuscationAttribute]
private int commandTimeout;
    [ObfuscationAttribute]
private bool isConnectionFromUser;
    private SqliteConnection userConnection;
    private Collection`1<FeatureSourceColumn> featureSourceColumns;
    [ObfuscationAttribute]
private string whereClause;
    [ObfuscationAttribute]
private double fetchTime;
    [ObfuscationAttribute]
private int drawnFeatureCount;
    [ObfuscationAttribute]
private int totalBytesDrawn;
    [ObfuscationAttribute]
private string alternateGeometryIndexTableName;
    [ObfuscationAttribute]
private bool isEditable;
    private bool isEditableChecked;
    [CompilerGeneratedAttribute]
private EventHandler`1<ExecutingSqlStatementSqliteFeatureSourceEventArgs> ExecutingSqlStatement;
    protected bool CanExecuteSqlQueryCore { get; }
    public double FetchTime { get; public set; }
    public int DrawnFeatureCount { get; public set; }
    public int TotalBytesDrawn { get; public set; }
    public string WhereClause { get; public set; }
    public int CommandTimeout { get; public set; }
    public string GeometryColumnName { get; public set; }
    public string ConnectionString { get; public set; }
    public string TableName { get; public set; }
    public string FeatureIdColumn { get; public set; }
    public bool IsEditable { get; }
    public string AlternateGeometryIndexTableName { get; public set; }
    public SqliteFeatureSource(string connectionString, string tableName, string featureIdColumn, string geometryColumnName);
    public SqliteFeatureSource(SqliteConnection connection, string tableName, string featureIdColumn, string geometryColumnName);
    public SqliteFeatureSource(SqliteConnection connection, string tableName);
    public SqliteFeatureSource(string connectionString, string tableName);
    private SqliteFeatureSource(SqliteConnection connection, string connectionString, string tableName, string featureIdColumn, string geometryColumnName);
    [CompilerGeneratedAttribute]
public void add_ExecutingSqlStatement(EventHandler`1<ExecutingSqlStatementSqliteFeatureSourceEventArgs> value);
    [CompilerGeneratedAttribute]
public void remove_ExecutingSqlStatement(EventHandler`1<ExecutingSqlStatementSqliteFeatureSourceEventArgs> value);
    public static void CreateTable(SqliteConnection connection, string tableName, IEnumerable`1<SqliteColumn> nonGeometryColumns, GeographyUnit unit);
    public static void CreateTable(string connectionString, string tableName, IEnumerable`1<SqliteColumn> nonGeometryColumns, GeographyUnit unit);
    protected virtual void OnExecutingSqlStatement(ExecutingSqlStatementSqliteFeatureSourceEventArgs e);
    public static void CreateView(SqliteConnection connection, string viewName, string createViewSql, string featureIdColumn, GeographyUnit unit, string geometryColumnName);
    public static void CreateView(SqliteConnection connection, string viewName, string createViewSql, string featureIdColumn, GeographyUnit unit);
    public static void CreateView(string connectionString, string viewName, string createViewSql, string featureIdColumn, GeographyUnit unit);
    protected virtual bool get_CanExecuteSqlQueryCore();
    public double get_FetchTime();
    public void set_FetchTime(double value);
    public int get_DrawnFeatureCount();
    public void set_DrawnFeatureCount(int value);
    public int get_TotalBytesDrawn();
    public void set_TotalBytesDrawn(int value);
    public string get_WhereClause();
    public void set_WhereClause(string value);
    public int get_CommandTimeout();
    public void set_CommandTimeout(int value);
    public string get_GeometryColumnName();
    public void set_GeometryColumnName(string value);
    public string get_ConnectionString();
    public void set_ConnectionString(string value);
    public string get_TableName();
    public void set_TableName(string value);
    public string get_FeatureIdColumn();
    public void set_FeatureIdColumn(string value);
    public virtual bool get_IsEditable();
    public string get_AlternateGeometryIndexTableName();
    public void set_AlternateGeometryIndexTableName(string value);
    private string GetGeometryIndexTableName();
    protected virtual int ExecuteNonQueryCore(string sqlStatement);
    public static void CreateDatabase(string databasePathFilename);
    protected virtual WellKnownType GetFirstFeaturesWellKnownTypeCore();
    protected virtual void OpenCore();
    protected virtual void CloseCore();
    private bool IsView();
    protected virtual long GetCountCore();
    protected virtual Collection`1<Feature> GetFeaturesInsideBoundingBoxCore(RectangleShape boundingBox, IEnumerable`1<string> returningColumnNames);
    protected virtual Collection`1<Feature> GetFeaturesOutsideBoundingBoxCore(RectangleShape boundingBox, IEnumerable`1<string> returningColumnNames);
    protected virtual TransactionResult CommitTransactionCore(TransactionBuffer transactions);
    protected virtual Collection`1<Feature> GetAllFeaturesCore(IEnumerable`1<string> columnNames);
    public static Collection`1<string> GetColumnNames(string connectionString, string tableName);
    protected virtual Collection`1<FeatureSourceColumn> GetColumnsCore();
    protected virtual bool CanGetBoundingBoxQuicklyCore();
    protected virtual RectangleShape GetBoundingBoxCore();
    protected virtual Collection`1<Feature> GetFeaturesByIdsCore(IEnumerable`1<string> ids, IEnumerable`1<string> returningColumnNames);
    protected virtual Collection`1<Feature> GetFeaturesByColumnValueCore(string columnName, string columnValue, IEnumerable`1<string> returningColumnNames);
    protected virtual DataTable ExecuteQueryCore(string sqlStatement);
    public static Collection`1<string> GetTableNames(string connectionString);
    private string QuoteColumnName(string columnName);
    private string GetSpatialQueryCondition(int queryType, RectangleShape boundingBox);
    private string BuildSelectColumnsString(IEnumerable`1<string> columnNames);
    private Feature GetFeature(SqliteDataReader dataReader, IEnumerable`1<string> columnNames);
    public static bool CreateSpatialIndex(SqliteConnection SqliteConnection, string tableName, string geometryColumnName, int srid);
    private Feature GetFeature(SqliteDataReader dataReader);
    private string SanitizeParameterNames(string parameterName);
    private void ProcessAddBuffer(Dictionary`2<string, Feature> addBuffer, TransactionResult result, SqliteConnection connection);
    private static string ReplaceNulls(string value);
    private void ProcessDeleteBuffer(Collection`1<string> deleteBuffer, TransactionResult transactionResult, SqliteConnection connection);
    private void ProcessEditBuffer(Dictionary`2<string, Feature> editBuffer, TransactionResult transactionResult, SqliteConnection connection);
    protected virtual Collection`1<string> GetFeatureIdsCore();
    protected virtual Collection`1<string> GetFeatureIdsInsideBoundingBoxCore(RectangleShape boundingBox);
    private Collection`1<Feature> GetFeaturesByBoundingBox(BaseShape targetShape, int queryType, IEnumerable`1<string> returningColumnNames);
    private SqliteCommand GetNewCommand(string sqlStatement, ExecutingSqlStatementType sqlStatementType, SqliteConnection& connection, RectangleShape boundingBox);
}
internal class ThinkGeo.Core.SqliteRasterTileCache : RasterTileCache {
    [ObfuscationAttribute]
private string databasePathFilename;
    public string DatabasePathFilename { get; public set; }
    public string CacheId { get; public set; }
    public SqliteRasterTileCache(string databasePathFilename, string cacheId);
    public string get_DatabasePathFilename();
    public void set_DatabasePathFilename(string value);
    public virtual string get_CacheId();
    public virtual void set_CacheId(string value);
    protected virtual Tile GetTileCore(int zoom, long column, long row);
    protected virtual void ClearCacheCore();
    protected virtual void SaveTileCore(Tile tile);
    protected virtual void DeleteTileCore(Tile tile);
    private SqliteConnection GetConnection();
    private void CheckCacheId();
}
public static class ThinkGeo.Core.SqliteValidatorHelper : object {
    public static void CheckFeatureSourceIsInTransaction(bool isInTransaction);
    public static void CheckParameterIsValid(BaseShape BasheShapeToTest, string parameterName);
    public static void CheckFeatureSourceIsOpen(bool isOpen);
    public static void CheckParameterIsNotNullOrEmpty(string value, string parameterName);
    public static bool CheckIsEmptyOrNull(IEnumerable`1<string> values);
    public static void CheckFeatureSourceCanExecuteSqlQuery(bool canExecuteSqlQuery);
    public static void CheckFeatureIdAndGeometryColumn(string connectionString, string tableName, string featureIdColumn, string geometryColumnName);
}
public enum ThinkGeo.Core.StartingPoint : Enum {
    public int value__;
    public static StartingPoint FirstPoint;
    public static StartingPoint LastPoint;
}
internal enum ThinkGeo.Core.State : Enum {
    public int value__;
    public static State Start;
    public static State Complete;
    public static State Property;
    public static State ObjectStart;
    public static State Object;
    public static State ArrayStart;
    public static State Array;
    public static State Closed;
    public static State PostValue;
    public static State ConstructorStart;
    public static State Constructor;
    public static State Error;
    public static State Finished;
}
public class ThinkGeo.Core.StreamLoadingEventArgs : EventArgs {
    [ObfuscationAttribute]
private string alternateStreamName;
    private Stream SyA=;
    [ObfuscationAttribute]
private FileMode fileMode;
    [ObfuscationAttribute]
private FileAccess readWriteMode;
    [ObfuscationAttribute]
private string streamType;
    public string AlternateStreamName { get; public set; }
    public Stream AlternateStream { get; public set; }
    public FileMode FileMode { get; public set; }
    public FileAccess ReadWriteMode { get; public set; }
    public string StreamType { get; }
    public StreamLoadingEventArgs(string alternateStreamName, string streamType);
    public StreamLoadingEventArgs(string alternateStreamName, Stream alternateStream, FileMode fileMode, FileAccess readWriteMode);
    public StreamLoadingEventArgs(string alternateStreamName, string streamType, Stream alternateStream, FileMode fileMode, FileAccess readWriteMode);
    public string get_AlternateStreamName();
    public void set_AlternateStreamName(string value);
    public Stream get_AlternateStream();
    public void set_AlternateStream(Stream value);
    public FileMode get_FileMode();
    public void set_FileMode(FileMode value);
    public FileAccess get_ReadWriteMode();
    public void set_ReadWriteMode(FileAccess value);
    public string get_StreamType();
}
internal class ThinkGeo.Core.StringBuffer : ValueType {
    [ObfuscationAttribute]
private Char[] _buffer;
    [ObfuscationAttribute]
private int _position;
    public int Position { get; public set; }
    public bool IsEmpty { get; }
    public Char[] InternalBuffer { get; }
    public StringBuffer(int initalSize);
    private StringBuffer(Char[] buffer);
    public int get_Position();
    public void set_Position(int value);
    public bool get_IsEmpty();
    public void Append(char value);
    public void Append(Char[] buffer, int startIndex, int count);
    public void Clear();
    private void EnsureSize(int appendLength);
    public virtual string ToString();
    public string ToString(int start, int length);
    public Char[] get_InternalBuffer();
}
[yhM=]
internal class ThinkGeo.Core.StringReference : ValueType {
    private Char[] _chars;
    private int _startIndex;
    private int _length;
    public Char[] Chars { get; }
    public int StartIndex { get; }
    public int Length { get; }
    public StringReference(Char[] chars, int startIndex, int length);
    public Char[] get_Chars();
    public int get_StartIndex();
    public int get_Length();
    public virtual string ToString();
}
public abstract class ThinkGeo.Core.Style : object {
    [ObfuscationAttribute]
private string name;
    [ObfuscationAttribute]
private Collection`1<string> filters;
    [ObfuscationAttribute]
private bool isActive;
    [ObfuscationAttribute]
private Collection`1<string> requiredColumnNames;
    public string Name { get; public set; }
    public bool IsActive { get; public set; }
    internal bool phU= { get; }
    public Collection`1<string> RequiredColumnNames { get; }
    public Collection`1<string> Filters { get; }
    protected Collection`1<string> FiltersCore { get; }
    public string get_Name();
    public void set_Name(string value);
    public bool get_IsActive();
    public void set_IsActive(bool value);
    internal virtual bool pBU=();
    public Collection`1<string> get_RequiredColumnNames();
    public Collection`1<string> get_Filters();
    protected virtual Collection`1<string> get_FiltersCore();
    public Style CloneDeep();
    protected virtual Style CloneDeepCore();
    public void Draw(IEnumerable`1<Feature> features, GeoCanvas canvas, Collection`1<SimpleCandidate> labelsInThisLayer, Collection`1<SimpleCandidate> labelsInAllLayers);
    public void Draw(IEnumerable`1<BaseShape> shapes, GeoCanvas canvas, Collection`1<SimpleCandidate> labelsInThisLayer, Collection`1<SimpleCandidate> labelsInAllLayers);
    protected abstract virtual void DrawCore(IEnumerable`1<Feature> features, GeoCanvas canvas, Collection`1<SimpleCandidate> labelsInThisLayer, Collection`1<SimpleCandidate> labelsInAllLayers);
    public Collection`1<FeatureLabelingCandidate> DrawWithoutLabeling(IEnumerable`1<Feature> features, GeoCanvas canvas);
    protected virtual Collection`1<FeatureLabelingCandidate> DrawWithoutLabelingCore(IEnumerable`1<Feature> features, GeoCanvas canvas);
    public Collection`1<string> GetRequiredColumnNames();
    internal static void /DA=(string content, char start, char end, Action`1<string> oneParsed);
    protected virtual Collection`1<string> GetRequiredColumnNamesCore();
    public void DrawSample(GeoCanvas canvas, DrawingRectangleF drawingExtent);
    public void DrawSample(GeoCanvas canvas);
    protected virtual void DrawSampleCore(GeoCanvas canvas, DrawingRectangleF drawingExtent);
    public void SaveStyle(string filePathName);
    public void SaveStyle(Stream stream);
    public static Style LoadStyle(Uri styleUri);
    public static Style LoadStyle(Stream styleStream);
}
internal class ThinkGeo.Core.StyleJsonDocument : object {
    internal Dictionary`2<int, Collection`1<StyleJsonStyle>> styles;
    [CompilerGeneratedAttribute]
private Dictionary`2<int, GeoColor> <BackgroundForZooms>k__BackingField;
    [CompilerGeneratedAttribute]
private GeoColor <globalBackground>k__BackingField;
    internal static string versionKey;
    private double version;
    internal Dictionary`2<int, GeoColor> BackgroundForZooms { get; internal set; }
    internal GeoColor globalBackground { get; internal set; }
    public double Version { get; private set; }
    [CompilerGeneratedAttribute]
internal Dictionary`2<int, GeoColor> get_BackgroundForZooms();
    [CompilerGeneratedAttribute]
internal void set_BackgroundForZooms(Dictionary`2<int, GeoColor> value);
    [CompilerGeneratedAttribute]
internal GeoColor get_globalBackground();
    [CompilerGeneratedAttribute]
internal void set_globalBackground(GeoColor value);
    public double get_Version();
    private void set_Version(double value);
    public static StyleJsonDocument Load(string styleJsonPathFileName);
    public static StyleJsonDocument Load(Uri styleJsonUri);
    public static StyleJsonDocument Parse(Byte[] styleJsonBytes);
    public void ApplyStyleJsonToZoomLevel(ZoomLevelSet zoomLevelSet);
    public void ApplyBackgroundToZoomLevel(ZoomLevelSet zoomLevelSet);
}
public class ThinkGeo.Core.StyleJsonItem : object {
    private Collection`1<FilterCondition> ADI=;
    [ObfuscationAttribute]
private Style style;
    [ObfuscationAttribute]
private FilterApplyMode filterApplyMode;
    public Style Style { get; public set; }
    public Collection`1<FilterCondition> Filters { get; }
    public FilterApplyMode FilterApplyMode { get; public set; }
    public StyleJsonItem(Style style);
    public StyleJsonItem(Style style, IEnumerable`1<FilterCondition> filters);
    public Style get_Style();
    public void set_Style(Style value);
    public Collection`1<FilterCondition> get_Filters();
    public FilterApplyMode get_FilterApplyMode();
    public void set_FilterApplyMode(FilterApplyMode value);
    public Collection`1<Feature> GetMatchedFeatures(IEnumerable`1<Feature> features);
}
public class ThinkGeo.Core.StyleJsonStyle : Style {
    private Collection`1<StyleJsonItem> ATI=;
    [CompilerGeneratedAttribute]
private string AjI=;
    public string ZIndexColumn { get; public set; }
    public Collection`1<StyleJsonItem> StyleJsonItems { get; }
    public StyleJsonStyle(string zIndexColumn);
    [CompilerGeneratedAttribute]
public string get_ZIndexColumn();
    [CompilerGeneratedAttribute]
public void set_ZIndexColumn(string value);
    public Collection`1<StyleJsonItem> get_StyleJsonItems();
    private Dictionary`2<int, Dictionary`2<Style, Collection`1<Feature>>> AzI=(GeoCanvas canvas, jBw= styleJsonFeatures);
    protected virtual Collection`1<FeatureLabelingCandidate> DrawWithoutLabelingCore(IEnumerable`1<Feature> features, GeoCanvas canvas);
    protected virtual void DrawCore(IEnumerable`1<Feature> features, GeoCanvas canvas, Collection`1<SimpleCandidate> labelsInThisLayer, Collection`1<SimpleCandidate> labelsInAllLayers);
    [CompilerGeneratedAttribute]
private int BDI=(Feature f);
}
public class ThinkGeo.Core.TabDbfColumn : DbfColumn {
    [ObfuscationAttribute]
private bool buildIndex;
    [ObfuscationAttribute]
private bool uniqueIndexColumnValues;
    public bool BuildIndex { get; public set; }
    public bool UniqueIndexColumnValues { get; public set; }
    public TabDbfColumn(string columnName, DbfColumnType columnType, int length, int decimalLength, bool buildIndex, bool uniqueIndexColumnValues);
    public bool get_BuildIndex();
    public void set_BuildIndex(bool value);
    public bool get_UniqueIndexColumnValues();
    public void set_UniqueIndexColumnValues(bool value);
}
public class ThinkGeo.Core.TabFeatureLayer : FeatureLayer {
    [ObfuscationAttribute]
private TabStylingType stylingType;
    [ObfuscationAttribute]
private STRtree`1<string> rTree;
    [ObfuscationAttribute]
private Dictionary`2<string, KeyValuePair`2<Feature, IEnumerable`1<Style>>> featuresDics;
    public string TabPathFilename { get; public set; }
    public FileAccess ReadWriteMode { get; public set; }
    public bool HasBoundingBox { get; }
    public TabStylingType StylingType { get; public set; }
    public bool RequireIndex { get; public set; }
    public Encoding Encoding { get; public set; }
    public TabFeatureLayer(string tabPathFilename);
    public TabFeatureLayer(string tabPathFilename, FileAccess readWriteMode);
    public string get_TabPathFilename();
    public void set_TabPathFilename(string value);
    public FileAccess get_ReadWriteMode();
    public void set_ReadWriteMode(FileAccess value);
    public virtual bool get_HasBoundingBox();
    public TabStylingType get_StylingType();
    public void set_StylingType(TabStylingType value);
    public bool get_RequireIndex();
    public void set_RequireIndex(bool value);
    public Encoding get_Encoding();
    public void set_Encoding(Encoding value);
    protected virtual LayerBase CloneDeepCore();
    internal static WkbShapeType mBw=(Byte[] wkb, int startIndex);
    public static void CreateTabFile(string tabPathFilename, IEnumerable`1<TabDbfColumn> databaseColumns, IEnumerable`1<Feature> features);
    public static void CreateTabFile(string tabPathFilename, IEnumerable`1<TabDbfColumn> databaseColumns, IEnumerable`1<Feature> features, OverwriteMode overwriteMode);
    public static void CreateTabFile(string tabPathFilename, IEnumerable`1<TabDbfColumn> databaseColumns, IEnumerable`1<Feature> features, OverwriteMode overwriteMode, Encoding encoding);
    public static void BuildIndexFile(string tabPathFilename);
    public static void BuildIndexFile(string tabPathFilename, BuildIndexMode buildIndexMode);
    public static void BuildRecordIdColumn(string tabFileName, string fieldName, BuildRecordIdMode buildRecordIdMode);
    public static void BuildRecordIdColumn(string tabFileName, string fieldName, BuildRecordIdMode buildRecordIdMode, int startNumber);
    public static void BuildRecordIdColumn(string tabFileName, string fieldName, BuildRecordIdMode buildRecordIdMode, int startNumber, Encoding encoding);
    protected virtual void DrawCore(GeoCanvas canvas, Collection`1<SimpleCandidate> labelsInAllLayers);
    private STRtree`1<string> pSs=(Dictionary`2<Feature, IEnumerable`1<Style>> cadFeatureStyles);
}
public class ThinkGeo.Core.TabFeatureSource : FeatureSource {
    private gCU= gSs=;
    private STRtree`1<string> gis=;
    [ObfuscationAttribute]
private RtreeSpatialIndex rTreeIndex;
    [ObfuscationAttribute]
private bool requireIndex;
    [ObfuscationAttribute]
private string tabPathFilename;
    [ObfuscationAttribute]
private FileAccess readWriteMode;
    [ObfuscationAttribute]
private Encoding encoding;
    public string TabPathFilename { get; public set; }
    public FileAccess ReadWriteMode { get; public set; }
    public Encoding Encoding { get; public set; }
    public bool IsEditable { get; }
    public bool RequireIndex { get; public set; }
    public TabFeatureSource(string tabPathFilename);
    public TabFeatureSource(string tabPathFilename, FileAccess readWriteMode);
    public string get_TabPathFilename();
    public void set_TabPathFilename(string value);
    public FileAccess get_ReadWriteMode();
    public void set_ReadWriteMode(FileAccess value);
    public Encoding get_Encoding();
    public void set_Encoding(Encoding value);
    public virtual bool get_IsEditable();
    public bool get_RequireIndex();
    public void set_RequireIndex(bool value);
    protected virtual bool CanGetCountQuicklyCore();
    protected virtual void OpenCore();
    protected virtual void CloseCore();
    protected virtual long GetCountCore();
    protected virtual Collection`1<FeatureSourceColumn> GetColumnsCore();
    protected virtual RectangleShape GetBoundingBoxCore();
    protected virtual Collection`1<string> GetFeatureIdsCore();
    protected virtual Collection`1<Feature> GetAllFeaturesCore(IEnumerable`1<string> returningColumnNames, int startIndex, int takeCount);
    protected virtual Collection`1<Feature> GetAllFeaturesCore(IEnumerable`1<string> returningColumnNames);
    protected virtual Collection`1<Feature> GetFeaturesInsideBoundingBoxCore(RectangleShape boundingBox, IEnumerable`1<string> returningColumnNames);
    internal void gys=(iCo= proj);
    protected virtual Collection`1<Feature> GetFeaturesByColumnValueCore(string columnName, string columnValue, IEnumerable`1<string> returningColumnNames);
    protected virtual Collection`1<Feature> GetFeaturesOutsideBoundingBoxCore(RectangleShape boundingBox, IEnumerable`1<string> returningColumnNames);
    protected virtual Collection`1<Feature> GetFeaturesByIdsCore(IEnumerable`1<string> ids, IEnumerable`1<string> returningColumnNames);
    protected virtual TransactionResult CommitTransactionCore(TransactionBuffer transactions);
    private List`1<TabDbfColumn> hCs=(TransactionBuffer transactions, TransactionResult transactionResult);
    private Feature hSs=(iSg= tabFeature);
    private static PointShape his=(RCo= tabPoint);
    private static MultipointShape hys=(OSo= tabMultiPoint);
    private static LineBaseShape iCs=(hCo= tabPolyline);
    private static LineShape iSs=(GSg= tabArc);
    private static PolygonShape iis=(8So= tabRegion);
    private static EllipseShape iys=(iCg= tabEllipse);
    private void VCQ=();
    private TabDbfColumn jCs=(int index);
    public static void BuildIndexFile(string tabPathFilename);
    public static void BuildIndexFile(string tabPathFilename, BuildIndexMode buildIndexMode);
    private static void 0SE=(string tabPathFilename, ProjectionConverter projection, BuildIndexMode buildIndexMode);
    public static void CreateTabFile(string tabPathFilename, IEnumerable`1<TabDbfColumn> databaseColumns, IEnumerable`1<Feature> features);
    public static void CreateTabFile(string tabPathFilename, IEnumerable`1<TabDbfColumn> databaseColumns, IEnumerable`1<Feature> features, OverwriteMode overwriteMode);
    public static void CreateTabFile(string tabPathFilename, IEnumerable`1<TabDbfColumn> databaseColumns, IEnumerable`1<Feature> features, OverwriteMode overwriteMode, Encoding encoding);
    internal iCo= jSs=();
    private static void jis=(string pathFilename, IEnumerable`1<TabDbfColumn> columns, IEnumerable`1<Feature> features, OverwriteMode overwriteMode, fys= tabFileType, string mifProjection, double north, double south, double east, double west, Encoding encoding);
    private static void jys=(gCU= mapInfoFile, TabDbfColumn column);
    private static void kCs=(gCU= mapInfoFile, Feature feature);
    private static void CyQ=(string path);
    private static void XiQ=(string sourceFileName, string targetFileName);
    private static iSg= kSs=(gCU= mapInfoFile, Feature feature);
    private static iSg= kis=(gCU= mapInfoFile, Feature feature);
    private static iSg= kys=(gCU= mapInfoFile, Feature feature);
    private static iSg= lCs=(gCU= mapInfoFile, Feature feature);
    private static Collection`1<iSg=> lSs=(gCU= mapInfoFile, Feature feature);
    private static void lis=(gCU= mapInfoFile, iSg= tabFeature, Feature feature);
    private static iSg= lys=(gCU= mapInfoFile, Feature feature);
    public static void BuildRecordIdColumn(string tabFileName, string fieldName, BuildRecordIdMode buildRecordIdMode);
    public static void BuildRecordIdColumn(string tabFileName, string fieldName, BuildRecordIdMode buildRecordIdMode, int startNumber);
    public static void BuildRecordIdColumn(string tabFileName, string fieldName, BuildRecordIdMode buildRecordIdMode, int startNumber, Encoding encoding);
    internal Dictionary`2<Feature, IEnumerable`1<Style>> mCs=();
    internal void mSs=();
    public void SetEmbeddedSymbolStyle(Feature feature, PointStyle pointStyle);
    public void SetEmbeddedPenStyle(Feature feature, LineStyle lineStyle);
    public void SetEmbeddedBrushStyle(Feature feature, AreaStyle areaStyle);
    public void SetEmbeddedTextStyle(Feature feature, TextStyle textStyle);
    private int mis=(GeoColor color);
    private Collection`1<Style> mys=(iSg= tabFeature, Feature feature, WellKnownType wellKnownType);
    private DbfColumnType nCs=(string typeName);
}
public enum ThinkGeo.Core.TabStylingType : Enum {
    public int value__;
    public static TabStylingType EmbeddedStyling;
    public static TabStylingType StandardStyling;
}
public enum ThinkGeo.Core.TextPlacement : Enum {
    public int value__;
    public static TextPlacement Default;
    public static TextPlacement UpperLeft;
    public static TextPlacement Upper;
    public static TextPlacement UpperRight;
    public static TextPlacement Right;
    public static TextPlacement Center;
    public static TextPlacement Left;
    public static TextPlacement LowerLeft;
    public static TextPlacement Lower;
    public static TextPlacement LowerRight;
    public static TextPlacement AutoPlacement;
}
public class ThinkGeo.Core.TextStyle : PositionStyle {
    private static double 2DE=;
    private static int 2TE=;
    private static double 2jE=;
    public float XOffsetInPixel { get; public set; }
    public float YOffsetInPixel { get; public set; }
    public bool FittingLineInScreen { get; public set; }
    public bool FittingPolygonInScreen { get; public set; }
    public Collection`1<TextStyle> CustomTextStyles { get; }
    public double RotationAngle { get; public set; }
    public string TextFormat { get; public set; }
    public string NumericFormat { get; public set; }
    public string DateFormat { get; public set; }
    public GeoBrush TextBrush { get; public set; }
    public GeoFont Font { get; public set; }
    public GeoPen HaloPen { get; public set; }
    public string TextColumnName { get; public set; }
    public AreaStyle Mask { get; public set; }
    public DrawingMargin MaskMargin { get; public set; }
    public bool ForceHorizontalLabelForLine { get; public set; }
    public SplineType SplineType { get; public set; }
    public DrawingLevel DrawingLevel { get; public set; }
    public Dictionary`2<string, WorldLabelingCandidate> LabelPositions { get; }
    public DrawingTextAlignment Alignment { get; public set; }
    public DrawingTextLetterCase LetterCase { get; public set; }
    public double MaxCharAngleDelta { get; public set; }
    public double MinDistance { get; public set; }
    public double Spacing { get; public set; }
    public double WrapWidth { get; public set; }
    public PointStyle BasePoint { get; public set; }
    public TextStyle(string textColumnName, GeoFont textFont, GeoBrush textBrush);
    public float get_XOffsetInPixel();
    public void set_XOffsetInPixel(float value);
    public float get_YOffsetInPixel();
    public void set_YOffsetInPixel(float value);
    public bool get_FittingLineInScreen();
    public void set_FittingLineInScreen(bool value);
    public bool get_FittingPolygonInScreen();
    public void set_FittingPolygonInScreen(bool value);
    public Collection`1<TextStyle> get_CustomTextStyles();
    public double get_RotationAngle();
    public void set_RotationAngle(double value);
    public string get_TextFormat();
    public void set_TextFormat(string value);
    public string get_NumericFormat();
    public void set_NumericFormat(string value);
    public string get_DateFormat();
    public void set_DateFormat(string value);
    public GeoBrush get_TextBrush();
    public void set_TextBrush(GeoBrush value);
    public GeoFont get_Font();
    public void set_Font(GeoFont value);
    public GeoPen get_HaloPen();
    public void set_HaloPen(GeoPen value);
    public string get_TextColumnName();
    public void set_TextColumnName(string value);
    public AreaStyle get_Mask();
    public void set_Mask(AreaStyle value);
    public DrawingMargin get_MaskMargin();
    public void set_MaskMargin(DrawingMargin value);
    public bool get_ForceHorizontalLabelForLine();
    public void set_ForceHorizontalLabelForLine(bool value);
    public SplineType get_SplineType();
    public void set_SplineType(SplineType value);
    public DrawingLevel get_DrawingLevel();
    public void set_DrawingLevel(DrawingLevel value);
    public Dictionary`2<string, WorldLabelingCandidate> get_LabelPositions();
    public DrawingTextAlignment get_Alignment();
    public void set_Alignment(DrawingTextAlignment value);
    public DrawingTextLetterCase get_LetterCase();
    public void set_LetterCase(DrawingTextLetterCase value);
    public double get_MaxCharAngleDelta();
    public void set_MaxCharAngleDelta(double value);
    public double get_MinDistance();
    public void set_MinDistance(double value);
    public double get_Spacing();
    public void set_Spacing(double value);
    public double get_WrapWidth();
    public void set_WrapWidth(double value);
    public PointStyle get_BasePoint();
    public void set_BasePoint(PointStyle value);
    public static TextStyle Parse(string styleJson);
    internal static TextStyle kxU=(JObject jObject);
    public static TextStyle CreateSimpleTextStyle(string textColumnName, string fontFamilyName, float fontSize, DrawingFontStyles drawingFontStyle, GeoColor fontColor);
    public static TextStyle CreateSimpleTextStyle(string textColumnName, string fontFamilyName, float fontSize, DrawingFontStyles drawingFontStyle, GeoColor fontColor, float xOffset, float yOffset);
    public static TextStyle CreateSimpleTextStyle(string textColumnName, string fontFamilyName, float fontSize, DrawingFontStyles drawingFontStyle, GeoColor fontColor, GeoColor haloPenColor, float haloPenWidth);
    public static TextStyle CreateSimpleTextStyle(string textColumnName, string fontFamilyName, float fontSize, DrawingFontStyles drawingFontStyle, GeoColor fontColor, GeoColor haloPenColor, float haloPenWidth, float xOffset, float yOffset);
    public static TextStyle CreateMaskTextStyle(string textColumnName, string fontFamilyName, float fontSize, DrawingFontStyles drawingFontStyle, GeoColor fontColor, GeoColor maskFillColor);
    public static TextStyle CreateMaskTextStyle(string textColumnName, string fontFamilyName, float fontSize, DrawingFontStyles drawingFontStyle, GeoColor fontColor, GeoColor maskFillColor, float xOffset, float yOffset);
    public static TextStyle CreateMaskTextStyle(string textColumnName, GeoFont textFont, GeoBrush textBrush, AreaStyle areaStyle, float xOffset, float yOffset);
    public static TextStyle CreateMaskTextStyle(string textColumnName, string fontFamilyName, float fontSize, DrawingFontStyles drawingFontStyle, GeoColor fontColor, GeoColor maskPenColor, float maskPenSize);
    public static TextStyle CreateMaskTextStyle(string textColumnName, string fontFamilyName, float fontSize, DrawingFontStyles drawingFontStyle, GeoColor fontColor, GeoColor maskPenColor, float maskPenSize, float xOffset, float yOffset);
    private static DrawingMargin EDM=(string expression);
    private static GeoFont ETM=(string fontExpression);
    private static GeoPen OTE=(String[] valueExpressions);
    private static GeoBrush EjM=(String[] valueExpressions);
    private static AreaStyle EzM=(String[] valueExpressions);
}
[ObfuscationAttribute]
public class ThinkGeo.Core.ThinkGeoCloudApplicationException : ApplicationException {
    [CompilerGeneratedAttribute]
private HttpStatusCode <StatusCode>k__BackingField;
    public HttpStatusCode StatusCode { get; }
    public ThinkGeoCloudApplicationException(HttpStatusCode statusCode, string message, Exception innerException);
    [CompilerGeneratedAttribute]
public HttpStatusCode get_StatusCode();
}
public class ThinkGeo.Core.ThinkGeoCloudMapsZoomLevelSet : ZoomLevelSet {
    public ThinkGeoCloudMapsZoomLevelSet(int tileSize);
}
public enum ThinkGeo.Core.ThinkGeoCloudRasterMapsMapType : Enum {
    public int value__;
    [ObsoleteAttribute("Default has been changed from Light to Light_V2_X1. Please always specify a MapType without using the default.")]
public static ThinkGeoCloudRasterMapsMapType Default;
    [ObsoleteAttribute("Light has been renamed to Light_V1_X1. Please consider upgrading to Light_V1_X2 for higher resolution or upgrading to Light_V2 for a sharper style. ")]
public static ThinkGeoCloudRasterMapsMapType Light;
    [ObsoleteAttribute("Dark has been renamed to Dark_V1_X1, please consider upgrading to Dark_V1_X2 for higher resolution or upgrading to Dark_V2 for a sharper style. ")]
public static ThinkGeoCloudRasterMapsMapType Dark;
    [ObsoleteAttribute("Hybrid has been renamed to Hybrid_V1_X1, please consider upgrading to Hybrid_V1_X2 for higher resolution or upgrading to Hybrid_V2 for a sharper style. ")]
public static ThinkGeoCloudRasterMapsMapType Hybrid;
    [ObsoleteAttribute("Aerial has been renamed to Aerial_V1_X1, please consider upgrading to Aerial_V2_X1 for a newer data set or upgrading to Aerial_V2_X2 for higher resolution.")]
public static ThinkGeoCloudRasterMapsMapType Aerial;
    [ObsoleteAttribute("TransparentBackground has been renamed to TransparentBackground_V1_X1, please consider upgrading to TransparentBackground_V1_X2 for higher resolution or upgrading to TransparentBackground_V2 for a sharper style. ")]
public static ThinkGeoCloudRasterMapsMapType TransparentBackground;
    public static ThinkGeoCloudRasterMapsMapType Light_V1_X1;
    public static ThinkGeoCloudRasterMapsMapType Light_V1_X2;
    public static ThinkGeoCloudRasterMapsMapType Light_V2_X1;
    public static ThinkGeoCloudRasterMapsMapType Light_V2_X2;
    public static ThinkGeoCloudRasterMapsMapType Dark_V1_X1;
    public static ThinkGeoCloudRasterMapsMapType Dark_V1_X2;
    public static ThinkGeoCloudRasterMapsMapType Dark_V2_X1;
    public static ThinkGeoCloudRasterMapsMapType Dark_V2_X2;
    public static ThinkGeoCloudRasterMapsMapType Hybrid_V1_X1;
    public static ThinkGeoCloudRasterMapsMapType Hybrid_V1_X2;
    public static ThinkGeoCloudRasterMapsMapType Hybrid_V2_X1;
    public static ThinkGeoCloudRasterMapsMapType Hybrid_V2_X2;
    public static ThinkGeoCloudRasterMapsMapType Aerial_V1_X1;
    public static ThinkGeoCloudRasterMapsMapType Aerial_V1_X2;
    public static ThinkGeoCloudRasterMapsMapType Aerial_V2_X1;
    public static ThinkGeoCloudRasterMapsMapType Aerial_V2_X2;
    public static ThinkGeoCloudRasterMapsMapType TransparentBackground_V1_X1;
    public static ThinkGeoCloudRasterMapsMapType TransparentBackground_V1_X2;
    public static ThinkGeoCloudRasterMapsMapType TransparentBackground_V2_X1;
    public static ThinkGeoCloudRasterMapsMapType TransparentBackground_V2_X2;
}
public enum ThinkGeo.Core.ThinkGeoCloudVectorMapsMapType : Enum {
    public int value__;
    public static ThinkGeoCloudVectorMapsMapType Default;
    public static ThinkGeoCloudVectorMapsMapType Light;
    public static ThinkGeoCloudVectorMapsMapType Dark;
    public static ThinkGeoCloudVectorMapsMapType TransparentBackground;
    public static ThinkGeoCloudVectorMapsMapType CustomizedByStyleJson;
}
public static class ThinkGeo.Core.ThinkGeoDebugger : object {
    [CompilerGeneratedAttribute]
private static ThinkGeoLogLevel mB0=;
    [CompilerGeneratedAttribute]
private static ThinkGeoLogType mR0=;
    [CompilerGeneratedAttribute]
private static StreamWriter mh0=;
    [CompilerGeneratedAttribute]
private static bool mx0=;
    [CompilerGeneratedAttribute]
private static bool nB0=;
    public static ThinkGeoLogLevel LogLevel { get; public set; }
    public static ThinkGeoLogType LogType { get; public set; }
    public static StreamWriter LogStreamWriter { get; public set; }
    public static bool LogToConsole { get; public set; }
    public static bool DisplayTileId { get; public set; }
    private static ThinkGeoDebugger();
    [CompilerGeneratedAttribute]
public static ThinkGeoLogLevel get_LogLevel();
    [CompilerGeneratedAttribute]
public static void set_LogLevel(ThinkGeoLogLevel value);
    [CompilerGeneratedAttribute]
public static ThinkGeoLogType get_LogType();
    [CompilerGeneratedAttribute]
public static void set_LogType(ThinkGeoLogType value);
    [CompilerGeneratedAttribute]
public static StreamWriter get_LogStreamWriter();
    [CompilerGeneratedAttribute]
public static void set_LogStreamWriter(StreamWriter value);
    [CompilerGeneratedAttribute]
public static bool get_LogToConsole();
    [CompilerGeneratedAttribute]
public static void set_LogToConsole(bool value);
    public static void Log(string message, ThinkGeoLogType logType, ThinkGeoLogLevel logLevel);
    [CompilerGeneratedAttribute]
public static bool get_DisplayTileId();
    [CompilerGeneratedAttribute]
public static void set_DisplayTileId(bool value);
}
public enum ThinkGeo.Core.ThinkGeoLicenseStatus : Enum {
    public int value__;
    public static ThinkGeoLicenseStatus None;
    public static ThinkGeoLicenseStatus SoftwareAssuranceAssemblyInvalid;
    public static ThinkGeoLicenseStatus SoftwareAssuranceNotFound;
    public static ThinkGeoLicenseStatus SoftwareAssuranceExpired;
    public static ThinkGeoLicenseStatus LicenseFileInvalid;
    public static ThinkGeoLicenseStatus EvalWithProductExpired;
    public static ThinkGeoLicenseStatus EvalWithProductCallerNotMatch;
    public static ThinkGeoLicenseStatus FullWithoutProduct;
    public static ThinkGeoLicenseStatus FullWithProductExpired;
    public static ThinkGeoLicenseStatus FullWithProductCallerNotMatch;
    public static ThinkGeoLicenseStatus RuntimeLicenseForDebug;
    public static ThinkGeoLicenseStatus FullWithoutServer;
    public static ThinkGeoLicenseStatus EvalWithProduct;
    public static ThinkGeoLicenseStatus FullWithProduct;
    public static ThinkGeoLicenseStatus FullWithServer;
}
public enum ThinkGeo.Core.ThinkGeoLogLevel : Enum {
    public int value__;
    public static ThinkGeoLogLevel All;
    public static ThinkGeoLogLevel Message;
    public static ThinkGeoLogLevel Warning;
    public static ThinkGeoLogLevel Error;
    public static ThinkGeoLogLevel None;
}
[FlagsAttribute]
public enum ThinkGeo.Core.ThinkGeoLogType : Enum {
    public int value__;
    public static ThinkGeoLogType Others;
    public static ThinkGeoLogType Rendering;
    public static ThinkGeoLogType Licensing;
    public static ThinkGeoLogType Interaction;
    public static ThinkGeoLogType PopupAndMarker;
    public static ThinkGeoLogType WebRequest;
    public static ThinkGeoLogType Caching;
    public static ThinkGeoLogType DataFetching;
    public static ThinkGeoLogType All;
}
public class ThinkGeo.Core.ThinkGeoMBTilesLayer : Layer {
    private int MSw=;
    [ObfuscationAttribute]
private Uri styleJsonUri;
    [ObfuscationAttribute]
private RasterTileCache bitmapTileCache;
    private ZoomLevelSet Rx4=;
    private bool Miw=;
    [ObfuscationAttribute]
private string mbTilesPathFilename;
    private SqliteConnection Myw=;
    private bool NCw=;
    [ObfuscationAttribute]
private static bool newFormat;
    private static Dictionary`2<string, Feature> NSw=;
    private static object Niw=;
    private static object Nyw=;
    private static object /BM=;
    private static int OCw=;
    private Collection`1<VectorTile> OSw=;
    private Collection`1<VectorTile> Oiw=;
    private Collection`1<VectorTile> Oyw=;
    private bool PCw=;
    private bool PSw=;
    [CompilerGeneratedAttribute]
private EventHandler`1<GeneratingTileMBTilesLayerEventArgs> Piw=;
    [CompilerGeneratedAttribute]
private EventHandler`1<GeneratedTileMBTilesLayerEventArgs> Pyw=;
    private ProjectionConverter SR4=;
    [CompilerGeneratedAttribute]
private DrawingQuality QCw=;
    [CompilerGeneratedAttribute]
private int Sx4=;
    public ProjectionConverter ProjectionConverter { get; public set; }
    public RasterTileCache BitmapTileCache { get; public set; }
    public Uri StyleJsonUri { get; public set; }
    public DrawingQuality DrawingQuality { get; public set; }
    public bool ShowDebugInfo { get; public set; }
    public int TileSize { get; public set; }
    public ThinkGeoMBTilesLayer(string mbTilesPathFilename);
    public ThinkGeoMBTilesLayer(string mbTilesPathFilename, Uri styleJsonUri);
    private static ThinkGeoMBTilesLayer();
    [CompilerGeneratedAttribute]
public void add_GeneratingTile(EventHandler`1<GeneratingTileMBTilesLayerEventArgs> value);
    [CompilerGeneratedAttribute]
public void remove_GeneratingTile(EventHandler`1<GeneratingTileMBTilesLayerEventArgs> value);
    [CompilerGeneratedAttribute]
public void add_GeneratedTile(EventHandler`1<GeneratedTileMBTilesLayerEventArgs> value);
    [CompilerGeneratedAttribute]
public void remove_GeneratedTile(EventHandler`1<GeneratedTileMBTilesLayerEventArgs> value);
    public ProjectionConverter get_ProjectionConverter();
    public void set_ProjectionConverter(ProjectionConverter value);
    public RasterTileCache get_BitmapTileCache();
    public void set_BitmapTileCache(RasterTileCache value);
    public Uri get_StyleJsonUri();
    public void set_StyleJsonUri(Uri value);
    [CompilerGeneratedAttribute]
public DrawingQuality get_DrawingQuality();
    [CompilerGeneratedAttribute]
public void set_DrawingQuality(DrawingQuality value);
    public bool get_ShowDebugInfo();
    public void set_ShowDebugInfo(bool value);
    [CompilerGeneratedAttribute]
public int get_TileSize();
    [CompilerGeneratedAttribute]
public void set_TileSize(int value);
    protected virtual void CloseCore();
    protected virtual void OpenCore();
    protected virtual RectangleShape GetBoundingBoxCore();
    public VectorTile GetTile(long zoom, long column, long row);
    public void LoadStyleJson();
    [AsyncStateMachineAttribute("ThinkGeo.Core.ThinkGeoMBTilesLayer/YEA=")]
public Task DrawTileAsync(GeoCanvas canvas, int zoomIndex, long columnIndex, long rowIndex);
    [AsyncStateMachineAttribute("ThinkGeo.Core.ThinkGeoMBTilesLayer/YkA=")]
internal static Task QSw=(GeoCanvas canvas, int zoomIndex, long columnIndex, long rowIndex, ZoomLevelSet zoomLevelSet, bool ShowDebugInfo, RasterTileCache BitmapTileCache, int maxZoom, List`1<string> pbfLayerNames, VUA= getFeaturesFromPbfVectorTileAsyncDelegate, bool useLegacyLabeling, int tileSize);
    internal static Collection`1<Feature> Qiw=(int zoom, long column, long row, RectangleShape boundingBox, CancellationToken cancellationToken, int maxZoom, List`1<string> pbfLayerNames, VkA= getFeaturesFromPbfVectorTile);
    [AsyncStateMachineAttribute("ThinkGeo.Core.ThinkGeoMBTilesLayer/aUA=")]
internal static Task`1<Collection`1<Feature>> Qyw=(int zoom, long column, long row, RectangleShape boundingBox, CancellationToken cancellationToken, int maxZoom, List`1<string> pbfLayerNames, VUA= getFeaturesFromPbfVectorTileAsync);
    internal static List`1<string> RCw=(ZoomLevelSet zoomLevelSet, int zoomLevelIndex);
    [AsyncStateMachineAttribute("ThinkGeo.Core.ThinkGeoMBTilesLayer/bEA=")]
private Task`1<Collection`1<Feature>> TR4=(int zoom, long column, long row, List`1<string> pbfLayerNames, CancellationToken cancellationToken);
    protected virtual void DrawCore(GeoCanvas canvas, Collection`1<SimpleCandidate> labelsInAllLayers);
    protected virtual void OnGeneratingTile(GeneratingTileMBTilesLayerEventArgs e);
    protected virtual void OnGeneratedTile(GeneratedTileMBTilesLayerEventArgs e);
    private Collection`1<Feature> Qiw=(RectangleShape boundingBox, double screenWidth, CancellationToken cancellationToken);
    private Collection`1<Feature> RSw=(RectangleShape boundingBox, double screenWidth, CancellationToken cancellationToken);
    private string Riw=(int zoom, long minColumn, long maxColumn, long minRow, long maxRow);
    private Collection`1<VectorTile> Ryw=(string sqlStatement);
    private void SCw=();
    public void BeginTransaction();
    public TransactionResult CommitTransaction();
    public void WriteMetaData(string key, string value);
    public static void CreateDatabase(string mbTilesPath, bool isOverwrite);
    public void AddTile(VectorTile vectorTile);
    public void UpdateTile(VectorTile vectorTile);
    public void DeleteTile(VectorTile vectorTile);
    private static void SSw=(SqliteConnection connection);
    private static void Siw=(SqliteConnection connection);
    private static void Syw=(SqliteConnection connection);
    private void TCw=(Collection`1<VectorTile> deleteBuffer);
    private void TSw=(Collection`1<VectorTile> addBuffer);
    private void Tiw=(Collection`1<VectorTile> updateBuffer);
    private void Tyw=(RectangleShape boundingBox, int minZoom, int maxZoom);
    private static Collection`1<Feature> UCw=(FeatureLayer featureLayer, List`1<string> featureIds, IEnumerable`1<string> columnNames);
}
public class ThinkGeo.Core.ThinkGeoProductLicense : object {
    internal static string tR0=;
    internal static string th0=;
    internal static string tx0=;
    internal static string uB0=;
    internal static string uR0=;
    internal static string uh0=;
    internal static string ux0=;
    internal static string vB0=;
    internal static string vR0=;
    private static ThinkGeoProductLicense();
    public static ThinkGeoLicenseStatus GetCoreLicenseStatus();
    public static ThinkGeoLicenseStatus GetWinformsLicenseStatus();
    public static ThinkGeoLicenseStatus GetWpfLicenseStatus();
    public static ThinkGeoLicenseStatus GetBlazorLicenseStatus();
    public static ThinkGeoLicenseStatus GetBlazorServerLicenseStatus();
    public static ThinkGeoLicenseStatus GetWebApiLicenseStatus();
    public static ThinkGeoLicenseStatus GetWebApiServerLicenseStatus();
    public static ThinkGeoLicenseStatus GetiOSLicenseStatus();
    public static ThinkGeoLicenseStatus GetAndroidLicenseStatus();
    public static ThinkGeoLicenseStatus GetXamarinFormsLicenseStatus();
    private static ThinkGeoLicenseStatus vh0=(string productId);
}
public class ThinkGeo.Core.ThinkGeoRasterMapsAsyncLayer : XyzTileAsyncLayer {
    private static int /B0=;
    private BB4= Ph4=;
    private ThinkGeoCloudRasterMapsMapType Px4=;
    public RasterTileCache TileCache { get; public set; }
    public RasterTileCache ProjectedTileCache { get; public set; }
    public ProjectionConverter ProjectionConverterFromServerProjection { get; public set; }
    public ThinkGeoCloudRasterMapsMapType MapType { get; public set; }
    public string ClientId { get; public set; }
    public string ClientSecret { get; public set; }
    public ThinkGeoRasterMapsAsyncLayer(string clientId, string clientSecret);
    public ThinkGeoRasterMapsAsyncLayer(string clientId, string clientSecret, ThinkGeoCloudRasterMapsMapType mapType);
    public virtual RasterTileCache get_TileCache();
    public virtual void set_TileCache(RasterTileCache value);
    public virtual RasterTileCache get_ProjectedTileCache();
    public virtual void set_ProjectedTileCache(RasterTileCache value);
    public virtual ProjectionConverter get_ProjectionConverterFromServerProjection();
    public virtual void set_ProjectionConverterFromServerProjection(ProjectionConverter value);
    public ThinkGeoCloudRasterMapsMapType get_MapType();
    public void set_MapType(ThinkGeoCloudRasterMapsMapType value);
    public string get_ClientId();
    public void set_ClientId(string value);
    public string get_ClientSecret();
    public void set_ClientSecret(string value);
    [AsyncStateMachineAttribute("ThinkGeo.Core.ThinkGeoRasterMapsAsyncLayer/Nz8=")]
protected virtual Task OpenAsyncCore(CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("ThinkGeo.Core.ThinkGeoRasterMapsAsyncLayer/Nj8=")]
protected virtual Task CloseAsyncCore(CancellationToken cancellationToken);
    protected virtual Task`1<string> GetImageUriAsyncCore(int zoomLevel, long x, long y, float resolutionFactor);
    [AsyncStateMachineAttribute("ThinkGeo.Core.ThinkGeoRasterMapsAsyncLayer/OD8=")]
private void QB4=(object sender, SendingHttpRequestMessageEventArgs e);
    private void Ox4=();
    private string QR4=(string cacheIdWithSuffix);
    protected virtual int GetTileScale();
    private string Qh4=();
    private string Qx4=(ThinkGeoCloudRasterMapsMapType mapType);
    private string RB4=(ThinkGeoCloudRasterMapsMapType mapType);
    private string RR4=(ThinkGeoCloudRasterMapsMapType mapType);
    private GeoImageFormat 9RY=(ThinkGeoCloudRasterMapsMapType mapType);
    [CompilerGeneratedAttribute]
[DebuggerHiddenAttribute]
private Task Ah4=(CancellationToken cancellationToken);
    [DebuggerHiddenAttribute]
[CompilerGeneratedAttribute]
private Task Ax4=(CancellationToken cancellationToken);
}
public class ThinkGeo.Core.ThinkGeoVectorMapsAsyncLayer : WebBasedAsyncLayer {
    private static int Rh4=;
    [ObfuscationAttribute]
private Uri styleJsonUri;
    [ObfuscationAttribute]
private RasterTileCache bitmapTileCache;
    private ZoomLevelSet Rx4=;
    private BB4= Ph4=;
    private ThinkGeoCloudVectorMapsMapType Px4=;
    private FileVectorTileCache SB4=;
    private ProjectionConverter SR4=;
    [CompilerGeneratedAttribute]
private bool Sh4=;
    [CompilerGeneratedAttribute]
private int Sx4=;
    private bool TB4=;
    public bool ShowDebugInfo { get; public set; }
    public int TileSize { get; public set; }
    public string ClientId { get; public set; }
    public string ClientSecret { get; public set; }
    public ThinkGeoCloudVectorMapsMapType MapType { get; public set; }
    public FileVectorTileCache VectorTileCache { get; public set; }
    public RasterTileCache BitmapTileCache { get; public set; }
    public Uri StyleJsonUri { get; public set; }
    public ProjectionConverter ProjectionConverter { get; public set; }
    public ThinkGeoVectorMapsAsyncLayer(string clientId, string clientSecret);
    public ThinkGeoVectorMapsAsyncLayer(string clientId, string clientSecret, Uri styleJsonUri);
    public ThinkGeoVectorMapsAsyncLayer(string clientId, string clientSecret, ThinkGeoCloudVectorMapsMapType mapType);
    [CompilerGeneratedAttribute]
public bool get_ShowDebugInfo();
    [CompilerGeneratedAttribute]
public void set_ShowDebugInfo(bool value);
    [CompilerGeneratedAttribute]
public int get_TileSize();
    [CompilerGeneratedAttribute]
public void set_TileSize(int value);
    public string get_ClientId();
    public void set_ClientId(string value);
    public string get_ClientSecret();
    public void set_ClientSecret(string value);
    public ThinkGeoCloudVectorMapsMapType get_MapType();
    public void set_MapType(ThinkGeoCloudVectorMapsMapType value);
    public FileVectorTileCache get_VectorTileCache();
    public void set_VectorTileCache(FileVectorTileCache value);
    public RasterTileCache get_BitmapTileCache();
    public void set_BitmapTileCache(RasterTileCache value);
    public Uri get_StyleJsonUri();
    public void set_StyleJsonUri(Uri value);
    public ProjectionConverter get_ProjectionConverter();
    public void set_ProjectionConverter(ProjectionConverter value);
    [AsyncStateMachineAttribute("ThinkGeo.Core.ThinkGeoVectorMapsAsyncLayer/ND8=")]
protected virtual Task OpenAsyncCore(CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("ThinkGeo.Core.ThinkGeoVectorMapsAsyncLayer/Lj8=")]
protected virtual Task CloseAsyncCore(CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("ThinkGeo.Core.ThinkGeoVectorMapsAsyncLayer/WD8=")]
private Task`1<Collection`1<Feature>> TR4=(int zoom, long column, long row, List`1<string> pbfLayerNames, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("ThinkGeo.Core.ThinkGeoVectorMapsAsyncLayer/WT8=")]
private Task`1<VectorTile> Th4=(int zoom, long column, long row, CancellationToken cancellationToken);
    private void Tx4=();
    [AsyncStateMachineAttribute("ThinkGeo.Core.ThinkGeoVectorMapsAsyncLayer/VD8=")]
public Task DrawTileAsync(GeoCanvas canvas, int zoomIndex, long columnIndex, long rowIndex);
    [AsyncStateMachineAttribute("ThinkGeo.Core.ThinkGeoVectorMapsAsyncLayer/RD8=")]
protected virtual Task DrawAsyncCore(GeoCanvas canvas, Collection`1<SimpleCandidate> labelsInAllLayers);
    private void Ox4=(ThinkGeoCloudVectorMapsMapType mapType);
    private bool PB4=(string cacheId);
    [CompilerGeneratedAttribute]
[DebuggerHiddenAttribute]
private Task Ah4=(CancellationToken cancellationToken);
    [CompilerGeneratedAttribute]
[DebuggerHiddenAttribute]
private Task Ax4=(CancellationToken cancellationToken);
}
internal class ThinkGeo.Core.ThreadSafeStore`2 : object {
    private object _lock;
    [ObfuscationAttribute]
private Dictionary`2<TKey, TValue> _store;
    private Func`2<TKey, TValue> _creator;
    public ThreadSafeStore`2(Func`2<TKey, TValue> creator);
    public TValue Get(TKey key);
    private TValue AddValue(TKey key);
}
public enum ThinkGeo.Core.ThreadSafetyLevel : Enum {
    public int value__;
    public static ThreadSafetyLevel Unsafe;
    public static ThreadSafetyLevel Safe;
}
public class ThinkGeo.Core.ThrowingExceptionOverlayEventArgs : EventArgs {
    [CompilerGeneratedAttribute]
private Exception sxQ=;
    [CompilerGeneratedAttribute]
private string tBQ=;
    [CompilerGeneratedAttribute]
private bool tRQ=;
    public Exception Exception { get; private set; }
    public string MemberName { get; private set; }
    public bool Handled { get; public set; }
    public ThrowingExceptionOverlayEventArgs(Exception exception, string memberName);
    [CompilerGeneratedAttribute]
public Exception get_Exception();
    [CompilerGeneratedAttribute]
private void set_Exception(Exception value);
    [CompilerGeneratedAttribute]
public string get_MemberName();
    [CompilerGeneratedAttribute]
private void set_MemberName(string value);
    [CompilerGeneratedAttribute]
public bool get_Handled();
    [CompilerGeneratedAttribute]
public void set_Handled(bool value);
}
public abstract class ThinkGeo.Core.Tile : object {
    [ObfuscationAttribute]
private int zoomIndex;
    [ObfuscationAttribute]
private long cloumn;
    [ObfuscationAttribute]
private long row;
    [CompilerGeneratedAttribute]
private string 1R0=;
    public int ZoomIndex { get; public set; }
    public long Column { get; public set; }
    public long Row { get; public set; }
    public string CacheId { get; public set; }
    public Tile(int zoomIndex, long column, long row);
    public int get_ZoomIndex();
    public void set_ZoomIndex(int value);
    public long get_Column();
    public void set_Column(long value);
    public long get_Row();
    public void set_Row(long value);
    [CompilerGeneratedAttribute]
public string get_CacheId();
    [CompilerGeneratedAttribute]
public void set_CacheId(string value);
    public Tile CloneDeep();
    protected virtual Tile CloneDeepCore();
}
public enum ThinkGeo.Core.TileAccessMode : Enum {
    public int value__;
    public static TileAccessMode Default;
    public static TileAccessMode ReadOnly;
    public static TileAccessMode ReadAdd;
    public static TileAccessMode ReadAddDelete;
}
public abstract class ThinkGeo.Core.TileCache : object {
    [ObfuscationAttribute]
private string cacheId;
    [ObfuscationAttribute]
private TimeSpan expirationTime;
    [ObfuscationAttribute]
private TileAccessMode tileAccessMode;
    [CompilerGeneratedAttribute]
private EventHandler`1<GottenCacheImageBitmapTileCacheEventArgs> yR0=;
    [CompilerGeneratedAttribute]
private EventHandler`1<GettingCacheImageBitmapTileCacheEventArgs> yh0=;
    public TileAccessMode TileAccessMode { get; public set; }
    public string CacheId { get; public set; }
    public TimeSpan ExpirationTime { get; public set; }
    protected TileCache(string cacheId);
    [CompilerGeneratedAttribute]
public void add_GottenCacheTile(EventHandler`1<GottenCacheImageBitmapTileCacheEventArgs> value);
    [CompilerGeneratedAttribute]
public void remove_GottenCacheTile(EventHandler`1<GottenCacheImageBitmapTileCacheEventArgs> value);
    [CompilerGeneratedAttribute]
public void add_GettingCacheTile(EventHandler`1<GettingCacheImageBitmapTileCacheEventArgs> value);
    [CompilerGeneratedAttribute]
public void remove_GettingCacheTile(EventHandler`1<GettingCacheImageBitmapTileCacheEventArgs> value);
    public TileAccessMode get_TileAccessMode();
    public void set_TileAccessMode(TileAccessMode value);
    public virtual string get_CacheId();
    public virtual void set_CacheId(string value);
    public TimeSpan get_ExpirationTime();
    public void set_ExpirationTime(TimeSpan value);
    protected virtual void OnGottenCacheTile(GottenCacheImageBitmapTileCacheEventArgs e);
    protected virtual void OnGettingCacheTile(GettingCacheImageBitmapTileCacheEventArgs e);
    [ObsoleteAttribute("This API is obsoleted, please use GetTileAsync() instead")]
public Tile GetTile(int zoom, long column, long row);
    [AsyncStateMachineAttribute("ThinkGeo.Core.TileCache/9D4=")]
public Task`1<Tile> GetTileAsync(int zoom, long column, long row, CancellationToken cancellationToken);
    [ObsoleteAttribute("This API is obsoleted, please use SaveTileAsync() instead")]
public void SaveTile(Tile tile);
    [AsyncStateMachineAttribute("ThinkGeo.Core.TileCache/9j4=")]
public Task SaveTileAsync(Tile tile, CancellationToken cancellationToken);
    public void DeleteTile(Tile tile);
    public void ClearCache();
    protected abstract virtual void ClearCacheCore();
    [ObsoleteAttribute("This API is obsoleted, please use SaveTileAsyncCore() instead")]
protected virtual void SaveTileCore(Tile tile);
    protected abstract virtual void DeleteTileCore(Tile tile);
    protected virtual Task SaveTileAsyncCore(Tile tile, CancellationToken cancellationToken);
    protected virtual Task`1<Tile> GetTileAsyncCore(int zoom, long column, long row, CancellationToken cancellationToken);
    [ObsoleteAttribute("This API is obsoleted, please use GetTileAsync() instead")]
protected virtual Tile GetTileCore(int zoom, long column, long row);
}
public class ThinkGeo.Core.TileMatrix : Matrix {
    [ObfuscationAttribute]
private double scale;
    [ObfuscationAttribute]
private int tileWidth;
    [ObfuscationAttribute]
private int tileHeight;
    [ObfuscationAttribute]
private GeographyUnit geographyUnit;
    private static int xB0=;
    public double Scale { get; public set; }
    public int TileWidth { get; public set; }
    public int TileHeight { get; public set; }
    public GeographyUnit GeographyUnit { get; public set; }
    public TileMatrix(double scale);
    public TileMatrix(double scale, RectangleShape boundingBox, GeographyUnit geographyUnit);
    public TileMatrix(double scale, int tileWidth, int tileHeight, RectangleShape boundingBox, GeographyUnit geographyUnit);
    public double get_Scale();
    public void set_Scale(double value);
    internal void xR0=(double currentScale);
    public int get_TileWidth();
    public void set_TileWidth(int value);
    public int get_TileHeight();
    public void set_TileHeight(int value);
    public GeographyUnit get_GeographyUnit();
    public void set_GeographyUnit(GeographyUnit value);
    public static TileMatrix GetDefaultMatrix(double scale, int tileWidth, int tileHeight, GeographyUnit unit);
    private void xh0=();
    protected virtual RowColumnRange GetRowColumnRangeCore(RectangleShape worldExtent, bool isContains);
}
public enum ThinkGeo.Core.TileResolution : Enum {
    public int value__;
    public static TileResolution Default;
    public static TileResolution Standard;
    public static TileResolution High;
}
public enum ThinkGeo.Core.TileSizeMode : Enum {
    public int value__;
    public static TileSizeMode Default;
    public static TileSizeMode Small;
    public static TileSizeMode Medium;
    public static TileSizeMode DefaultX2;
}
public enum ThinkGeo.Core.TileSnappingMode : Enum {
    public int value__;
    public static TileSnappingMode NoSnapping;
    public static TileSnappingMode Snapping;
}
public class ThinkGeo.Core.TimeZoneCloudClient : CloudClient {
    private static int zRQ=;
    public TimeZoneCloudClient(string clientId, string clientSecret);
    public CloudTimeZoneResult GetTimeZoneByCoordinate(double latitude, double longitude);
    public CloudTimeZoneResult GetTimeZoneByCoordinate(double x, double y, int projectionInSrid);
    public CloudTimeZoneResult GetTimeZoneByCoordinate(double x, double y, string projectionInProj4String);
    public Task`1<CloudTimeZoneResult> GetTimeZoneByCoordinateAsync(double latitude, double longitude);
    public Task`1<CloudTimeZoneResult> GetTimeZoneByCoordinateAsync(double x, double y, int projectionInSrid);
    public Task`1<CloudTimeZoneResult> GetTimeZoneByCoordinateAsync(double x, double y, string projectionInProj4String);
    public Collection`1<string> GetAllTimeZoneNames();
    public Task`1<Collection`1<string>> GetAllTimeZoneNamesAsync();
    public Collection`1<CloudTimeZoneResult> GetAllTimeZones();
    public Task`1<Collection`1<CloudTimeZoneResult>> GetAllTimeZonesAsync();
    private CloudTimeZoneResult HhU=(double x, double y, Nullable`1<int> projectionInSrid, string projectionInProj4String);
    [AsyncStateMachineAttribute("ThinkGeo.Core.TimeZoneCloudClient/oj4=")]
private Task`1<CloudTimeZoneResult> HxU=(double x, double y, Nullable`1<int> projectionInSrid, string projectionInProj4String);
    private Collection`1<string> IBU=();
    [AsyncStateMachineAttribute("ThinkGeo.Core.TimeZoneCloudClient/oD4=")]
private Task`1<Collection`1<string>> IRU=();
    private Collection`1<CloudTimeZoneResult> IhU=();
    [AsyncStateMachineAttribute("ThinkGeo.Core.TimeZoneCloudClient/oT4=")]
private Task`1<Collection`1<CloudTimeZoneResult>> IxU=();
    private static CloudTimeZoneResult JBU=(WebResponse response);
    private static Collection`1<string> JRU=(WebResponse response);
    private static Collection`1<CloudTimeZoneResult> JhU=(WebResponse response);
    private static string CBU=(Nullable`1<int> projectionInSrid, string projectionInProj4String);
}
public class ThinkGeo.Core.TinyGeoFeatureLayer : FeatureLayer {
    public bool HasBoundingBox { get; }
    public string TinyGeoPathFilename { get; public set; }
    public string Password { get; public set; }
    public TinyGeoFeatureLayer(string tinyGeoPathFilename);
    public TinyGeoFeatureLayer(string tinyGeoPathFilename, string password);
    public void add_StreamLoading(EventHandler`1<StreamLoadingEventArgs> value);
    public void remove_StreamLoading(EventHandler`1<StreamLoadingEventArgs> value);
    public virtual bool get_HasBoundingBox();
    public string get_TinyGeoPathFilename();
    public void set_TinyGeoPathFilename(string value);
    public string get_Password();
    public void set_Password(string value);
    public static void CreateTinyGeoFile(string tinyGeoPathFilename, string shapePathFilename, GeographyUnit unitOfData, ReturningColumnsType returningColumnType);
    public static void CreateTinyGeoFile(string tinyGeoPathFilename, string shapePathFilename, GeographyUnit unitOfData, ReturningColumnsType returningColumnType, double precisionInMeter);
    public static void CreateTinyGeoFile(string tinyGeoPathFilename, string shapePathFilename, GeographyUnit unitOfData, ReturningColumnsType returningColumnType, string password);
    public static void CreateTinyGeoFile(string tinyGeoPathFilename, string shapePathFilename, GeographyUnit unitOfData, ReturningColumnsType returningColumnType, string password, double precisionInMeter);
    public static void CreateTinyGeoFile(string tinyGeoPathFilename, string shapePathFilename, GeographyUnit unitOfData, IEnumerable`1<string> columnNames);
    public static void CreateTinyGeoFile(string tinyGeoPathFilename, string shapePathFilename, GeographyUnit unitOfData, IEnumerable`1<string> columnNames, double precisionInMeter);
    public static void CreateTinyGeoFile(string tinyGeoPathFilename, string shapePathFilename, GeographyUnit unitOfData, IEnumerable`1<string> columnNames, string password);
    public static void CreateTinyGeoFile(string tinyGeoPathFilename, string shapePathFilename, GeographyUnit unitOfData, IEnumerable`1<string> columnNames, string password, double precisionInMeter);
    public static void CreateTinyGeoFile(string tinyGeoPathFilename, string shapePathFilename, GeographyUnit unitOfData, IEnumerable`1<string> columnNames, string password, double precisionInMeter, Encoding shapeEncoding);
    public static void CreateTinyGeoFile(string tinyGeoPathFilename, FeatureLayer featureLayer, GeographyUnit unitOfData, IEnumerable`1<string> columnNames, string password, double precisionInMeter, Encoding shapeEncoding, WellKnownType type);
    public static double GetOptimalPrecision(string shapePathFilename, GeographyUnit unitOfData, DistanceUnit returningDistanceUnit, TinyGeoPrecisionMode precisionMode);
    public static double GetOptimalPrecision(FeatureLayer featureLayer, GeographyUnit unitOfData, DistanceUnit returningDistanceUnit, TinyGeoPrecisionMode precisionMode);
    public static void EncryptTinyGeoFile(string unencryptedTinyGeoPathFilename, string encryptedTinyGeoPathFilename, string password);
    public static void DecryptTinyGeoFile(string encryptedTinyGeoPathFilename, string decryptedTinyGeoPathFilename, string password);
    public TinyGeoFileType GetTinyGeoFileType();
}
public class ThinkGeo.Core.TinyGeoFeatureSource : FeatureSource {
    private static double MC8=;
    [ObfuscationAttribute]
private string tinyGeoFilePathName;
    private ey4= MS8=;
    [ObfuscationAttribute]
private string password;
    [CompilerGeneratedAttribute]
private EventHandler`1<StreamLoadingEventArgs> Eh8=;
    public string Password { get; public set; }
    public string TinyGeoPathFilename { get; public set; }
    public TinyGeoFeatureSource(string tinyGeoPathFilename);
    public TinyGeoFeatureSource(string tinyGeoPathFilename, string password);
    [CompilerGeneratedAttribute]
public void add_StreamLoading(EventHandler`1<StreamLoadingEventArgs> value);
    [CompilerGeneratedAttribute]
public void remove_StreamLoading(EventHandler`1<StreamLoadingEventArgs> value);
    protected virtual bool CanGetCountQuicklyCore();
    protected virtual bool CanGetBoundingBoxQuicklyCore();
    public string get_Password();
    public void set_Password(string value);
    public string get_TinyGeoPathFilename();
    public void set_TinyGeoPathFilename(string value);
    protected virtual void OnStreamLoading(StreamLoadingEventArgs e);
    protected virtual void OpenCore();
    protected virtual void CloseCore();
    protected virtual RectangleShape GetBoundingBoxCore();
    public TinyGeoFileType GetTinyGeoFileType();
    protected virtual Collection`1<Feature> GetAllFeaturesCore(IEnumerable`1<string> returningColumnNames);
    protected virtual Collection`1<Feature> GetFeaturesInsideBoundingBoxCore(RectangleShape boundingBox, IEnumerable`1<string> returningColumnNames);
    protected virtual Collection`1<Feature> GetAllFeaturesCore(IEnumerable`1<string> returningColumnNames, int startIndex, int takeCount);
    protected virtual Collection`1<Feature> GetFeaturesByIdsCore(IEnumerable`1<string> ids, IEnumerable`1<string> returningColumnNames);
    protected virtual Collection`1<FeatureSourceColumn> GetColumnsCore();
    public static void CreateTinyGeoFile(string tinyGeoPathFilename, string shapePathFilename, GeographyUnit unitOfData, ReturningColumnsType returningColumnType);
    public static void CreateTinyGeoFile(string tinyGeoPathFilename, string shapePathFilename, GeographyUnit unitOfData, ReturningColumnsType returningColumnType, double precisionInMeter);
    public static void CreateTinyGeoFile(string tinyGeoPathFilename, string shapePathFilename, GeographyUnit unitOfData, ReturningColumnsType returningColumnType, string password);
    public static void CreateTinyGeoFile(string tinyGeoPathFilename, string shapePathFilename, GeographyUnit unitOfData, ReturningColumnsType returningColumnType, string password, double precisionInMeter);
    public static void CreateTinyGeoFile(string tinyGeoPathFilename, string shapePathFilename, GeographyUnit unitOfData, IEnumerable`1<string> columnNames);
    public static void CreateTinyGeoFile(string tinyGeoPathFilename, string shapePathFilename, GeographyUnit unitOfData, IEnumerable`1<string> columnNames, double precisionInMeter);
    public static void CreateTinyGeoFile(string tinyGeoPathFilename, string shapePathFilename, GeographyUnit unitOfData, IEnumerable`1<string> columnNames, string password);
    public static void CreateTinyGeoFile(string tinyGeoPathFilename, string shapePathFilename, GeographyUnit unitOfData, IEnumerable`1<string> columnNames, string password, double precisionInMeter);
    public static void CreateTinyGeoFile(string tinyGeoPathFilename, string shapePathFilename, GeographyUnit unitOfData, IEnumerable`1<string> columnNames, string password, double precisionInMeter, Encoding shapeEncoding);
    public static void CreateTinyGeoFile(string tinyGeoPathFilename, FeatureLayer featureLayer, GeographyUnit unitOfData, IEnumerable`1<string> columnNames, string password, double precisionInMeter, Encoding shapeEncoding, WellKnownType type);
    public static double GetOptimalPrecision(FeatureLayer featureLayer, GeographyUnit unitOfData, DistanceUnit returningDistanceUnit, TinyGeoPrecisionMode precisionMode);
    public static double GetOptimalPrecision(string shapePathFilename, GeographyUnit unitOfData, DistanceUnit returningDistanceUnit, TinyGeoPrecisionMode precisionMode);
    public static void EncryptTinyGeoFile(string unencryptedTinyGeoPathFilename, string encryptedTinyGeoPathFilename, string password);
    public static void DecryptTinyGeoFile(string encryptedTinyGeoPathFilename, string decryptedTinyGeoPathFilename, string password);
    private void Mi8=(object sender, StreamLoadingEventArgs e);
    private static void My8=(string tinyGeoPathFilename, FeatureLayer featureLayer, IEnumerable`1<string> columnNames, string password, Viw= accuracy, Collection`1<string> ids, double extentWidthLimitation, Encoding shapeEncoding);
    private static double ZSc=(double maxFeatureWidth, GeographyUnit unit);
    private static double NC8=(Viw= accuracy);
    private static double NS8=(Viw= accuracy);
    private static double Ni8=(Viw= accuracy);
    private static double Ny8=(RectangleShape rect);
    private static Viw= Hy4=(Double& extentWidthLimitation, double minExtent, double precision, GeographyUnit unit);
    private static Viw= Hy4=(Double& extentWidthLimitation, double minExtent, double precision, double maxExtent);
    private static int OC8=(Viw= accuracy);
    private static Viw= OS8=(int number);
    private static Viw= Oi8=(double distance);
}
public enum ThinkGeo.Core.TinyGeoFileType : Enum {
    public int value__;
    public static TinyGeoFileType Point;
    public static TinyGeoFileType Polyline;
    public static TinyGeoFileType Polygon;
}
public enum ThinkGeo.Core.TinyGeoPrecisionMode : Enum {
    public int value__;
    public static TinyGeoPrecisionMode AllowSplitting;
    public static TinyGeoPrecisionMode PreventSplitting;
}
public class ThinkGeo.Core.TobinBasFeatureLayer : FeatureLayer {
    [ObfuscationAttribute]
private BasAnnotationTextStylingType annotationTextStylingType;
    [ObfuscationAttribute]
private int progressiveDrawingRecordsCount;
    [ObfuscationAttribute]
private string tobinBasFilePathName;
    [ObfuscationAttribute]
private int minAnnotationFontSize;
    public string TobinBasFilePathName { get; public set; }
    public int ProgressiveDrawingRecordsCount { get; public set; }
    public int MinAnnotationFontSize { get; public set; }
    public BasAnnotationTextStylingType AnnotationTextStylingType { get; public set; }
    public bool HasBoundingBox { get; }
    public TobinBasFeatureLayer(string tobinBasFileName);
    public string get_TobinBasFilePathName();
    public void set_TobinBasFilePathName(string value);
    public int get_ProgressiveDrawingRecordsCount();
    public void set_ProgressiveDrawingRecordsCount(int value);
    public int get_MinAnnotationFontSize();
    public void set_MinAnnotationFontSize(int value);
    public BasAnnotationTextStylingType get_AnnotationTextStylingType();
    public void set_AnnotationTextStylingType(BasAnnotationTextStylingType value);
    protected virtual void OpenCore();
    protected virtual void DrawCore(GeoCanvas canvas, Collection`1<SimpleCandidate> labelsInAllLayers);
    public virtual bool get_HasBoundingBox();
    public static void BuildIndexFile(string pathFilename);
}
public class ThinkGeo.Core.TobinBasFeatureSource : FeatureSource {
    [ObfuscationAttribute]
private string tobinBasFilePathName;
    [ObfuscationAttribute]
private string indexPathFilename;
    private RtreeSpatialIndex xiE=;
    private 4y8= 5C8=;
    private Encoding FR8=;
    [ObfuscationAttribute]
private bool requireIndex;
    private Collection`1<Feature> 9S8=;
    private SortedList`2<string, 2i8=> 9i8=;
    private int 9y8=;
    [CompilerGeneratedAttribute]
private static EventHandler`1<BuildingIndexBasFileFeatureSourceEventArgs> xSE=;
    public Collection`1<Feature> AnnotationFeatures { get; public set; }
    public Encoding Encoding { get; public set; }
    public bool RequireIndex { get; public set; }
    public string TobinBasFileName { get; public set; }
    public TobinBasFeatureSource(string tobinBasFilePathName);
    public Collection`1<Feature> get_AnnotationFeatures();
    public void set_AnnotationFeatures(Collection`1<Feature> value);
    public Encoding get_Encoding();
    public void set_Encoding(Encoding value);
    public bool get_RequireIndex();
    public void set_RequireIndex(bool value);
    public string get_TobinBasFileName();
    public void set_TobinBasFileName(string value);
    protected virtual void OpenCore();
    protected virtual void CloseCore();
    protected virtual Collection`1<FeatureSourceColumn> GetColumnsCore();
    protected virtual Collection`1<Feature> GetAllFeaturesCore(IEnumerable`1<string> returningColumnNames);
    protected virtual Collection`1<Feature> GetFeaturesInsideBoundingBoxCore(RectangleShape boundingBox, IEnumerable`1<string> returningColumnNames);
    public static void BuildIndexFile(string shapePathFilename);
    public static void BuildIndexFile(string shapePathFilename, string indexPathFilename, ProjectionConverter projectionConverter, string columnName, string regularExpression, BuildIndexMode buildIndexMode);
    public static void BuildIndexFile(string basPathFilename, string indexPathFilename, ProjectionConverter projectionConverter, string columnName, string regularExpression, BuildIndexMode buildIndexMode, Encoding encoding);
    [CompilerGeneratedAttribute]
public static void add_BuildingIndex(EventHandler`1<BuildingIndexBasFileFeatureSourceEventArgs> value);
    [CompilerGeneratedAttribute]
public static void remove_BuildingIndex(EventHandler`1<BuildingIndexBasFileFeatureSourceEventArgs> value);
    private void /C8=(2i8= entity);
    protected virtual Collection`1<Feature> GetFeaturesByIdsCore(IEnumerable`1<string> ids, IEnumerable`1<string> returningColumnNames);
    protected static void OnBuildingIndex(BuildingIndexBasFileFeatureSourceEventArgs e);
    private void VCQ=(FileAccess rTreeFileAccess);
    private static Dictionary`2<string, string> /S8=(SC8= annotation);
    private string /i8=(string p, string columnName);
    private static void CyQ=(string pathFilename);
    private static void XiQ=(string sourcePathFilename, string targetPathFilename);
    private static void UiQ=(2i8= featureEntity, RtreeSpatialIndex openedRtree, ProjectionConverter openedProjection);
}
public class ThinkGeo.Core.TobinBasValidatorHelper : object {
    public static void CheckRecordLength(string Record);
    public static void CheckTobinBasFileName(string path);
}
public class ThinkGeo.Core.TopologyValidationResult : ValueType {
    [CompilerGeneratedAttribute]
private bool nR0=;
    [CompilerGeneratedAttribute]
private Collection`1<Feature> nh0=;
    public bool IsValid { get; }
    public Collection`1<Feature> InvalidFeatures { get; }
    public TopologyValidationResult(bool isValid, IEnumerable`1<Feature> invalidFeatures);
    [yhM=]
[CompilerGeneratedAttribute]
public bool get_IsValid();
    [CompilerGeneratedAttribute]
[yhM=]
public Collection`1<Feature> get_InvalidFeatures();
}
public static class ThinkGeo.Core.TopologyValidator : object {
    private static string nx0=;
    public static TopologyValidationResult PolygonsMustNotOverlap(IEnumerable`1<Feature> polygonFeatures);
    public static TopologyValidationResult PolygonsMustNotHaveGaps(IEnumerable`1<Feature> polygonFeatures);
    public static TopologyValidationResult PolygonsMustContainPoint(IEnumerable`1<Feature> polygonFeatures, IEnumerable`1<Feature> pointFeatures);
    public static TopologyValidationResult PolygonsMustBeWithinPolygons(IEnumerable`1<Feature> featuresToValidateAgainst, IEnumerable`1<Feature> featuresToValidate);
    public static TopologyValidationResult PolygonBoundariesMustOverlapLines(IEnumerable`1<Feature> polygonFeatures, IEnumerable`1<Feature> lineFeatures);
    public static TopologyValidationResult PolygonsMustOverlapPolygons(IEnumerable`1<Feature> featuresToValidateAgainst, IEnumerable`1<Feature> featuresToValidate);
    public static TopologyValidationResult PolygonsMustNotOverlapPolygons(IEnumerable`1<Feature> featuresToValidateAgainst, IEnumerable`1<Feature> featuresToValidate);
    public static TopologyValidationResult PolygonsMustOverlapEachOther(IEnumerable`1<Feature> firstPolygonGroup, IEnumerable`1<Feature> secondPolygonGroup);
    public static TopologyValidationResult PolygonBoundariesMustOverlapPolygonBoundaries(IEnumerable`1<Feature> featuresToValidateAgainst, IEnumerable`1<Feature> featuresToValidate);
    public static TopologyValidationResult LinesMustFormClosedPolygon(IEnumerable`1<Feature> lineFeatures);
    public static TopologyValidationResult LinesMustNotHavePseudonodes(IEnumerable`1<Feature> lineFeatures);
    public static TopologyValidationResult LinesMustNotOverlap(IEnumerable`1<Feature> lineFeatures);
    public static TopologyValidationResult LinesMustNotSelfOverlap(IEnumerable`1<Feature> lineFeatures);
    public static TopologyValidationResult LinesMustNotIntersect(IEnumerable`1<Feature> lineFeatures);
    public static TopologyValidationResult LinesMustNotSelfIntersect(IEnumerable`1<Feature> lineFeatures);
    public static TopologyValidationResult LinesMustNotSelfIntersectOrTouch(IEnumerable`1<Feature> lineFeatures);
    public static TopologyValidationResult LinesMustBeSinglePart(IEnumerable`1<Feature> lineFeatures);
    public static TopologyValidationResult LinesMustNotOverlapLines(IEnumerable`1<Feature> featuresToValidateAgainst, IEnumerable`1<Feature> featuresToValidate);
    public static TopologyValidationResult LinesMustBeCoveredByLines(IEnumerable`1<Feature> featuresToValidateAgainst, IEnumerable`1<Feature> featuresToValidate);
    public static TopologyValidationResult LineEndPointsMustTouchPoints(IEnumerable`1<Feature> lineFeatures, IEnumerable`1<Feature> pointFeatures);
    public static TopologyValidationResult LinesMustOverlapPolygonBoundaries(IEnumerable`1<Feature> lineFeatures, IEnumerable`1<Feature> polygonFeatures);
    public static TopologyValidationResult PointsMustBeWithinPolygons(IEnumerable`1<Feature> pointFeatures, IEnumerable`1<Feature> polygonFeatures);
    public static TopologyValidationResult PointsMustTouchPolygonBoundaries(IEnumerable`1<Feature> pointFeatures, IEnumerable`1<Feature> polygonFeatures);
    public static TopologyValidationResult PointsMustTouchLineEndpoints(IEnumerable`1<Feature> pointFeatures, IEnumerable`1<Feature> lineFeatures);
    public static TopologyValidationResult PointsMustTouchLines(IEnumerable`1<Feature> pointFeatures, IEnumerable`1<Feature> lineFeatures);
    private static Collection`1<Feature> oB0=(IEnumerable`1<Feature> sourceFeatures, WellKnownType filterType1, WellKnownType filterType2);
    private static TopologyValidationResult oR0=(IEnumerable`1<Feature> coveringFeatures, IEnumerable`1<Feature> coveredFeatures);
    private static TopologyValidationResult oh0=(IEnumerable`1<Feature> coveringFeatures, IEnumerable`1<Feature> coveredFeatures);
    private static Collection`1<Feature> ox0=(IEnumerable`1<Feature> pointFeatures);
    private static Collection`1<Feature> pB0=(IEnumerable`1<Feature> polygonShapes);
    private static Collection`1<Feature> pR0=(Feature item);
    private static int ph0=(Feature lineFeature, Feature pointFeature);
    private static Collection`1<Feature> px0=(IEnumerable`1<Feature> lineFeatures);
    private static void qB0=(Collection`1<Feature> results, Feature lineGeom, Feature intersectFeature);
    private static Collection`1<string> qR0=(Feature feature1, Feature feature2);
    private static Feature qh0=(IEnumerable`1<Feature> features);
    internal static STRtree`1<BaseShape> qx0=(IEnumerable`1<BaseShape> baseShapes);
    private static STRtree`1<Feature> qx0=(IEnumerable`1<Feature> features);
    private static PointShape[] rB0=(Feature lineFeature);
    private static bool rR0=(double start, double middle, double end);
    internal static bool rh0=(Vertex startVertex, Vertex endVertex, PointShape point);
}
public class ThinkGeo.Core.TouchMapViewEventArgs : EventArgs {
    [CompilerGeneratedAttribute]
private ScreenPointD sRQ=;
    [CompilerGeneratedAttribute]
private PointShape shQ=;
    public ScreenPointD PointInScreenCoordinate { get; public set; }
    public PointShape PointInWorldCoordinate { get; public set; }
    public TouchMapViewEventArgs(ScreenPointD pointInScreenCoordinate, PointShape pointInWorldCoordinate);
    [CompilerGeneratedAttribute]
public ScreenPointD get_PointInScreenCoordinate();
    [CompilerGeneratedAttribute]
public void set_PointInScreenCoordinate(ScreenPointD value);
    [CompilerGeneratedAttribute]
public PointShape get_PointInWorldCoordinate();
    [CompilerGeneratedAttribute]
public void set_PointInWorldCoordinate(PointShape value);
}
public class ThinkGeo.Core.TouchMovedTrackInteractiveOverlayEventArgs : EventArgs {
    private Vertex thQ=;
    private Feature txQ=;
    public Vertex MovedVertex { get; public set; }
    public Feature AffectedFeature { get; public set; }
    public TouchMovedTrackInteractiveOverlayEventArgs(Vertex movedVertex, Feature affectedFeature);
    public Vertex get_MovedVertex();
    public void set_MovedVertex(Vertex value);
    public Feature get_AffectedFeature();
    public void set_AffectedFeature(Feature value);
}
public class ThinkGeo.Core.TouchMovingTrackInteractiveOverlayEventArgs : EventArgs {
    [CompilerGeneratedAttribute]
private Vertex rxQ=;
    [CompilerGeneratedAttribute]
private bool sBQ=;
    public Vertex TargetVertex { get; }
    public bool Cancel { get; public set; }
    public TouchMovingTrackInteractiveOverlayEventArgs(Vertex targetVertex);
    [CompilerGeneratedAttribute]
public Vertex get_TargetVertex();
    [CompilerGeneratedAttribute]
public bool get_Cancel();
    [CompilerGeneratedAttribute]
public void set_Cancel(bool value);
}
public class ThinkGeo.Core.TrackEndedTrackInteractiveOverlayEventArgs : EventArgs {
    [ObfuscationAttribute]
private BaseShape trackShape;
    public BaseShape TrackShape { get; public set; }
    public TrackEndedTrackInteractiveOverlayEventArgs(BaseShape trackShape);
    public BaseShape get_TrackShape();
    public void set_TrackShape(BaseShape value);
}
public class ThinkGeo.Core.TrackEndingTrackInteractiveOverlayEventArgs : EventArgs {
    [ObfuscationAttribute]
private BaseShape trackShape;
    [ObfuscationAttribute]
private bool cancel;
    public BaseShape TrackShape { get; public set; }
    public bool Cancel { get; public set; }
    public TrackEndingTrackInteractiveOverlayEventArgs(BaseShape shape, bool cancel);
    public BaseShape get_TrackShape();
    public void set_TrackShape(BaseShape value);
    public bool get_Cancel();
    public void set_Cancel(bool value);
}
public enum ThinkGeo.Core.TrackMode : Enum {
    public int value__;
    public static TrackMode None;
    public static TrackMode Point;
    public static TrackMode Line;
    public static TrackMode Polygon;
    public static TrackMode Rectangle;
    public static TrackMode Square;
    public static TrackMode Circle;
    public static TrackMode Ellipse;
    public static TrackMode StraightLine;
    public static TrackMode Freehand;
    public static TrackMode Custom;
    public static TrackMode Multipoint;
}
public class ThinkGeo.Core.TrackStartedTrackInteractiveOverlayEventArgs : EventArgs {
    [ObfuscationAttribute]
private Vertex startedVertex;
    public Vertex StartedVertex { get; public set; }
    public TrackStartedTrackInteractiveOverlayEventArgs(Vertex startedVertex);
    public Vertex get_StartedVertex();
    public void set_StartedVertex(Vertex value);
}
public class ThinkGeo.Core.TrackStartingTrackInteractiveOverlayEventArgs : EventArgs {
    [ObfuscationAttribute]
private bool cancel;
    [ObfuscationAttribute]
private Vertex startingVertex;
    public bool Cancel { get; public set; }
    public Vertex StartingVertex { get; public set; }
    public TrackStartingTrackInteractiveOverlayEventArgs(Vertex startingVertex, bool cancel);
    public bool get_Cancel();
    public void set_Cancel(bool value);
    public Vertex get_StartingVertex();
    public void set_StartingVertex(Vertex value);
}
public class ThinkGeo.Core.TransactionBuffer : object {
    [ObfuscationAttribute]
private Dictionary`2<string, Feature> addBuffer;
    [ObfuscationAttribute]
private Collection`1<string> deleteBuffer;
    [ObfuscationAttribute]
private Dictionary`2<string, Feature> editBuffer;
    [ObfuscationAttribute]
private Collection`1<FeatureSourceColumn> addColumnBuffer;
    [ObfuscationAttribute]
private Collection`1<string> deleteColumnBuffer;
    [ObfuscationAttribute]
private Dictionary`2<string, FeatureSourceColumn> updateColumnBuffer;
    public Dictionary`2<string, Feature> AddBuffer { get; }
    public Collection`1<string> DeleteBuffer { get; }
    public Dictionary`2<string, Feature> EditBuffer { get; }
    public Collection`1<FeatureSourceColumn> AddColumnBuffer { get; }
    public Collection`1<string> DeleteColumnBuffer { get; }
    public Dictionary`2<string, FeatureSourceColumn> UpdateColumnBuffer { get; }
    public TransactionBuffer(Dictionary`2<string, Feature> addBuffer, Collection`1<string> deleteBuffer, Dictionary`2<string, Feature> editBuffer);
    public void Clear();
    public Dictionary`2<string, Feature> get_AddBuffer();
    public Collection`1<string> get_DeleteBuffer();
    public Dictionary`2<string, Feature> get_EditBuffer();
    public void AddFeature(Feature feature);
    public void AddFeature(BaseShape baseShape);
    public void AddFeature(BaseShape baseShape, Dictionary`2<string, string> columnValues);
    public void DeleteFeature(string featureId);
    public void EditFeature(Feature feature);
    public void EditFeature(BaseShape baseShape);
    public void EditFeature(BaseShape baseShape, Dictionary`2<string, string> columnValues);
    public Collection`1<FeatureSourceColumn> get_AddColumnBuffer();
    public void AddColumn(FeatureSourceColumn featureSourceColumn);
    public Collection`1<string> get_DeleteColumnBuffer();
    public void DeleteColumn(string columnName);
    public Dictionary`2<string, FeatureSourceColumn> get_UpdateColumnBuffer();
    public void UpdateColumn(string columnName, FeatureSourceColumn newFeatureSourceColumn);
}
public class ThinkGeo.Core.TransactionResult : object {
    [ObfuscationAttribute]
private int totalSuccessCount;
    [ObfuscationAttribute]
private int totalFailureCount;
    [ObfuscationAttribute]
private TransactionResultStatus transactionResultStatus;
    [ObfuscationAttribute]
private Dictionary`2<string, string> failureReasons;
    public int TotalSuccessCount { get; public set; }
    public int TotalFailureCount { get; public set; }
    public TransactionResultStatus TransactionResultStatus { get; public set; }
    public Dictionary`2<string, string> FailureReasons { get; }
    public TransactionResult(int totalSuccessCount, int totalFailureCount, Dictionary`2<string, string> failureReasons, TransactionResultStatus transactionResultStatus);
    public int get_TotalSuccessCount();
    public void set_TotalSuccessCount(int value);
    public int get_TotalFailureCount();
    public void set_TotalFailureCount(int value);
    public TransactionResultStatus get_TransactionResultStatus();
    public void set_TransactionResultStatus(TransactionResultStatus value);
    public Dictionary`2<string, string> get_FailureReasons();
}
public enum ThinkGeo.Core.TransactionResultStatus : Enum {
    public int value__;
    public static TransactionResultStatus Success;
    public static TransactionResultStatus Failure;
    public static TransactionResultStatus Cancel;
}
public enum ThinkGeo.Core.TransitionEffect : Enum {
    public int value__;
    public static TransitionEffect None;
    public static TransitionEffect Stretch;
}
public enum ThinkGeo.Core.UnitSystem : Enum {
    public int value__;
    public static UnitSystem Imperial;
    public static UnitSystem Metric;
    public static UnitSystem NauticalMile;
}
public static class ThinkGeo.Core.UnmanagedAssembliesHelper : object {
    public static string GetAssemblyPathFilename(string directoryName, string assemblyName);
    private static string rx0=();
    private static Collection`1<string> sB0=();
}
public class ThinkGeo.Core.UsgsDemFeatureLayer : FeatureLayer {
    public string PathFilename { get; public set; }
    public bool HasBoundingBox { get; }
    public string DataValueColumnName { get; }
    public string OriginCode { get; }
    public UsgsDemQualityLevel QualityLevel { get; }
    public int ColumnCount { get; }
    public int RowCount { get; }
    public float ResolutionX { get; }
    public float ResolutionY { get; }
    public float ResolutionZ { get; }
    public double MinElevation { get; }
    public double MaxElevation { get; }
    public DistanceUnit ElevationUnit { get; }
    public UsgsDemFeatureLayer(string pathFilename);
    public string get_PathFilename();
    public void set_PathFilename(string value);
    public virtual bool get_HasBoundingBox();
    public string get_DataValueColumnName();
    public string get_OriginCode();
    public UsgsDemQualityLevel get_QualityLevel();
    public int get_ColumnCount();
    public int get_RowCount();
    public float get_ResolutionX();
    public float get_ResolutionY();
    public float get_ResolutionZ();
    public double get_MinElevation();
    public double get_MaxElevation();
    public DistanceUnit get_ElevationUnit();
}
public class ThinkGeo.Core.UsgsDemFeatureSource : FeatureSource {
    private static string QiI=;
    private Int16[0...,0...] /y8=;
    [ObfuscationAttribute]
private string pathFilename;
    private string ADA=;
    private UsgsDemQualityLevel ATA=;
    private int AjA=;
    private int AzA=;
    private double BDA=;
    private double BTA=;
    private RectangleShape BjA=;
    private float BzA=;
    private float CDA=;
    private float CTA=;
    private DistanceUnit CjA=;
    public string PathFilename { get; public set; }
    public string OriginCode { get; }
    public UsgsDemQualityLevel QualityLevel { get; }
    public int ColumnCount { get; }
    public int RowCount { get; }
    public float ResolutionX { get; }
    public float ResolutionY { get; }
    public float ResolutionZ { get; }
    public double MinElevation { get; }
    public double MaxElevation { get; }
    public string DataValueColumnName { get; }
    public DistanceUnit ElevationUnit { get; }
    public UsgsDemFeatureSource(string pathFilename);
    private static UsgsDemFeatureSource();
    public string get_PathFilename();
    public void set_PathFilename(string value);
    public string get_OriginCode();
    public UsgsDemQualityLevel get_QualityLevel();
    public int get_ColumnCount();
    public int get_RowCount();
    public float get_ResolutionX();
    public float get_ResolutionY();
    public float get_ResolutionZ();
    public double get_MinElevation();
    public double get_MaxElevation();
    public string get_DataValueColumnName();
    public DistanceUnit get_ElevationUnit();
    protected virtual void OpenCore();
    protected virtual Collection`1<Feature> GetAllFeaturesCore(IEnumerable`1<string> returningColumnNames);
    protected virtual Collection`1<Feature> GetFeaturesInsideBoundingBoxCore(RectangleShape boundingBox, IEnumerable`1<string> returningColumnNames);
    protected virtual Collection`1<Feature> GetFeaturesForDrawingCore(RectangleShape boundingBox, double screenWidth, double screenHeight, IEnumerable`1<string> returningColumnNames);
    protected virtual RectangleShape GetBoundingBoxCore();
    private Byte[] RiI=(double x1, double y1, double x2, double y2);
    private string CzA=(Char[] buffer, int start, int count);
    private int DDA=(Char[] buffer, int start, int count);
    private short DTA=(string value);
    private int DjA=(string value);
    private double DzA=(Char[] buffer, int start, int count);
    private float EDA=(Char[] buffer, int start, int count);
}
public enum ThinkGeo.Core.UsgsDemQualityLevel : Enum {
    public int value__;
    public static UsgsDemQualityLevel Default;
    public static UsgsDemQualityLevel Level1;
    public static UsgsDemQualityLevel Level2;
    public static UsgsDemQualityLevel Level3;
    public static UsgsDemQualityLevel Level4;
}
public static class ThinkGeo.Core.ValidatorHelper : object {
    private static bool sR0=;
    public static void CheckImageIsNotNullInPointStyle(GeoImage image);
    public static void CheckDrawingLineCapIsValid(DrawingLineCap drawingLineCap, string parameterName);
    public static void CheckGeoDashCapIsValid(GeoDashCap geoDashCap, string parameterName);
    public static void CheckDrawingLineJoinIsValid(DrawingLineJoin drawingLineJoin, string parameterName);
    public static void CheckLineDashStyleIsValid(LineDashStyle lineDashStyle, string parameterName);
    public static void CheckDrawingLevelIsValid(DrawingLevel drawingLevel, string parameterName);
    public static void CheckGeoImageIsValid(GeoImage image, string parameterName, GeoCanvas canvas);
    public static void CheckIconImageAndIconFilePathAreInvalid(string iconFilePath, GeoImage iconImage);
    public static void CheckRandomColorTypeIsValid(RandomColorType colorType, string parameterName);
    public static void CheckGroupLayerIsNotEmpty(GeoCollection`1<Layer> layers);
    public static void CheckQueryTypeIsValid(QueryType queryType, string parameterName);
    public static void CheckFeatureSourceCollectionIsNotEmpty(Collection`1<FeatureSource> featureSources);
    public static void CheckBuildIndexModeIsValid(BuildIndexMode buildIndexMode, string parameterName);
    public static void CheckOverwriteModeIsValid(OverwriteMode overwriteMode, string parameterName);
    public static void CheckRebuildRecordIdModeIsValid(BuildRecordIdMode rebuildRecordIdMode, string parameterName);
    public static void CheckDbfColumnDecimalLengthIsValid(DbfColumnType columnType, int decimalLength);
    public static void CheckPanDirectionIsValid(PanDirection panDirection, string parameterName);
    public static void CheckColumnNameIsInFeature(string columnName, IEnumerable`1<Feature> features);
    public static void CheckShapeIsValidForOperation(BaseShape shape);
    public static void CheckShapeIsValid(BaseShape shape, string parameterName);
    public static void CheckFeatureIsValid(Feature feature, string parameterName);
    public static void CheckShapeValidationModeIsValid(ShapeValidationMode shapeValidationMode, string parameterName);
    public static void CheckExtentIsValid(RectangleShape extent, string parameterName);
    public static void CheckStartingPointIsValid(StartingPoint startingPoint, string parameterName);
    public static void CheckWkbByteOrderIsValid(WkbByteOrder wkbByteOrder, string parameterName);
    public static void CheckRingOrderIsValid(RingOrder ringOrder, string parameterName);
    public static void CheckFeatureIsValid(Feature feature);
    public static void CheckShapeIsAreaBaseShape(BaseShape shape);
    public static void CheckShapeIsPointShape(BaseShape shape);
    public static void CheckShapeIsMultipointShape(BaseShape shape);
    public static void CheckShapeIsLineBaseShape(BaseShape shape);
    public static void CheckSimplificationTypeIsValid(SimplificationType simplificationType, string parameterName);
    public static void CheckReturningColumnsTypeIsValid(ReturningColumnsType returningColumnsType, string parameterName);
    public static void CheckAreaUnitIsValid(AreaUnit areaUnit, string parameterName);
    public static void CheckWktIsValid(string wkt, string parameterName);
    public static void CheckBufferCapTypeIsValid(BufferCapType bufferCapType, string parameterName);
    public static void CheckDistanceUnitIsValid(DistanceUnit distanceUnit, string parameterName);
    public static void CheckPointLineIsIntersected(PointShape pointShape, string pointShapeName, LineShape lineShape, string lineShapeName, double tolerance);
    public static void CheckPointSymbolTypeIsValid(PointSymbolType symbolType, string parameterName);
    public static void CheckPointTypeIsValid(PointType pointType, string parameterName);
    public static void CheckCanParseStringToDouble(string value, string parameterName);
    public static void CheckStringIsNotNullNorWhiteSpace(string value, string parameterName);
    public static void CheckStringIsValidDecimalDegree(string value, string parameterName);
    public static void CheckObjectsAreNotAllNull(object firstObject, object secondObject, string firstParameterName, string secondParameterName);
    public static void CheckTypeIsSupport(object instance, string typeName);
    public static void CheckCanvasWidthIsLargerThanZero(double canvasWidth, string parameterName);
    public static void CheckCanvasHeightIsLargerThanZero(double canvasHeight, string parameterName);
    public static void CheckGeographyUnitIsMeter(GeographyUnit geographyUnit, string parameterName);
    public static void CheckObjectIsNotNull(object parameterObject, string parameterName);
    public static void CheckObjectIsNotNull(object parameterObject, string parameterName, string exceptionMessage);
    public static void CheckInputValueIsLargerThan(double inputValue, string parameterName, double minValue, RangeCheckingInclusion includeMinValue);
    public static void CheckDateTimeIsInRange(DateTime inputDate, string parameterName, DateTime minDate, RangeCheckingInclusion includeMinValue, DateTime maxDate, RangeCheckingInclusion includeMaxValue);
    public static void CheckAreIntegerStrings(IEnumerable`1<string> ids, string parameterName);
    public static void CheckGeoCanvasIsInDrawing(bool isDrawing);
    public static void CheckScaleIsLargerThanZero(double imageScale, string parameterName);
    public static void CheckInputValueIsLargerThanZero(double value, string parameterName);
    public static void CheckObjectIsTargetType(object objectToTest, Type targetType, string operationName);
    public static void CheckLatitudeIsInRange(double latitude, string parameterName);
    public static void CheckLongitudeIsInRange(double longitude, string parameterName);
    public static void CheckInputValueIsInRange(double inputValue, string parameterName, double minValue, RangeCheckingInclusion includeMinValue, double maxValue, RangeCheckingInclusion includeMaxValue);
    public static void CheckInputValueIsInRange(double inputValue, string parameterName, double minValue, RangeCheckingInclusion includeMinValue, double maxValue, RangeCheckingInclusion includeMaxValue, string exceptionMessage);
    public static void CheckInputValueIsInRange(double inputValue, string parameterName, double minValue, double maxValue);
    public static void CheckInputValueIsLessThan(double inputValue, string parameterName, double maxValue, RangeCheckingInclusion includeMaxValue);
    public static void CheckInputValueIsValidDecimalDegree(double value, string parameterName);
    public static void CheckInputValueIsNotNaNNorInfinity(double value, string parameterName);
    public static void CheckFeatureSourceIsOpen(bool isOpen);
    public static void CheckRtreeSpatialIndexIsOpen(bool isOpen);
    public static void CheckRasterSourceIsOpen(bool isOpen);
    public static void CheckIsFastMode(bool fastMode);
    public static void CheckStringIsNotNullNorEmpty(string value, string parameterName);
    public static void CheckWkbIsValid(Byte[] wkb, string parameterName);
    public static void CheckHtmlColorIsValid(string htmlColor, string parameterName);
    public static void CheckFeatureSourceIsEditable(bool isEditable);
    public static void CheckCanModifyColumnStructure(bool canModifyColumnStructure);
    public static void CheckSpatialIndexIsDeletable(bool isDeletable);
    public static void CheckFeatureSourceIsInTransaction(bool isInTransaction);
    public static void CheckFeatureSourceIsNotInTransaction(bool isInTransaction);
    public static void CheckImageFormatSupport(string imageFormat);
    public static void CheckFileIsExist(string pathFilename);
    public static void CheckFileIsNotExist(string pathFilename);
    public static void CheckConnectionStringIsNotNull(string connectionString);
    public static void CheckLayerIsOpened(bool isOpen);
    public static void CheckLayerIsNotOpenedNorDrawing(bool isOpenOrDrawing);
    public static void CheckGeographyUnitIsValid(GeographyUnit geographyUnit, string parameterName);
    public static void CheckProjectionConverterIsOpen(bool isOpen);
    public static void CheckImageFormatIsValid(string imageFormat, Collection`1<string> outputFormats, string exceptionMessage);
    public static void CheckItemInCollection(string item, Collection`1<string> items, string exceptionMessage);
    public static void CheckItemsInCollection(Collection`1<string> items, Collection`1<string> itemCollection, string exceptionMessage);
    public static void CheckIEnumerableIsNotNullNorEmpty(IEnumerable values, string parameterName, string exceptionMessage);
    public static void CheckLayerHasBoundingBox(bool hasBoundingBox);
    public static void CheckFeatureColumnValueContainsColon(string value, string parameterName);
    public static void CheckFeatureSourceCanExecuteSqlQuery(bool canExecuteSqlQuery);
    public static void CheckNumberIsByte(int number, string paramterName);
    public static void CheckUriIsValid(Uri uri);
    public static void CheckStreamIsWritable(Stream stream, string parameterName);
    public static void CheckStringIsNotNullNorEmptyForOperation(string value, string exceptionMessage);
    public static void CheckStatus();
    public static void CheckLongIsNotGreaterThanUInt32MaxValue(long value);
    public static void CheckScaleIsValid(double scale, string parameterName);
    public static void CheckZoomLevelSetIsValid(ZoomLevelSet zoomLevelSet, string parameterName);
    internal static void sh0=(FileAccess readWriteMode, string parameterName);
}
public class ThinkGeo.Core.ValidFeatureFilterCondition : FilterCondition {
    [ObfuscationAttribute]
private FeatureValidationType validationType;
    public FeatureValidationType ValidationType { get; public set; }
    public ValidFeatureFilterCondition(FeatureValidationType validationType);
    public FeatureValidationType get_ValidationType();
    public void set_ValidationType(FeatureValidationType value);
    internal virtual bool TSM=(Feature feature);
}
public enum ThinkGeo.Core.ValueDrawingOrder : Enum {
    public int value__;
    public static ValueDrawingOrder Default;
    public static ValueDrawingOrder OrderByFeatures;
    public static ValueDrawingOrder OrderByValueItems;
}
public class ThinkGeo.Core.ValueItem : object {
    [ObfuscationAttribute]
private string value;
    [ObfuscationAttribute]
private PointStyle defaultPointStyle;
    [ObfuscationAttribute]
private LineStyle defaultLineStyle;
    [ObfuscationAttribute]
private AreaStyle defaultAreaStyle;
    [ObfuscationAttribute]
private TextStyle defaultTextStyle;
    [ObfuscationAttribute]
private Collection`1<Style> customStyles;
    public string Value { get; public set; }
    public AreaStyle DefaultAreaStyle { get; public set; }
    public LineStyle DefaultLineStyle { get; public set; }
    public PointStyle DefaultPointStyle { get; public set; }
    public TextStyle DefaultTextStyle { get; public set; }
    public Collection`1<Style> CustomStyles { get; }
    public ValueItem(string value, AreaStyle areaStyle);
    public ValueItem(string value, LineStyle lineStyle);
    public ValueItem(string value, PointStyle pointStyle);
    public ValueItem(string value, TextStyle textStyle);
    public ValueItem(string value, Collection`1<Style> customStyles);
    private ValueItem(string value, AreaStyle areaStyle, LineStyle lineStyle, PointStyle pointStyle, TextStyle textStyle, Collection`1<Style> styles);
    public string get_Value();
    public void set_Value(string value);
    public AreaStyle get_DefaultAreaStyle();
    public void set_DefaultAreaStyle(AreaStyle value);
    public LineStyle get_DefaultLineStyle();
    public void set_DefaultLineStyle(LineStyle value);
    public PointStyle get_DefaultPointStyle();
    public void set_DefaultPointStyle(PointStyle value);
    public TextStyle get_DefaultTextStyle();
    public void set_DefaultTextStyle(TextStyle value);
    public Collection`1<Style> get_CustomStyles();
}
public class ThinkGeo.Core.ValueStyle : Style {
    [ObfuscationAttribute]
private string columnName;
    [ObfuscationAttribute]
private Collection`1<ValueItem> valueItems;
    [ObfuscationAttribute]
private ValueDrawingOrder drawingOrder;
    public string ColumnName { get; public set; }
    public ValueDrawingOrder DrawingOrder { get; public set; }
    public Collection`1<ValueItem> ValueItems { get; }
    public ValueStyle(string columnName, Collection`1<ValueItem> valueItems);
    public string get_ColumnName();
    public void set_ColumnName(string value);
    public ValueDrawingOrder get_DrawingOrder();
    public void set_DrawingOrder(ValueDrawingOrder value);
    public Collection`1<ValueItem> get_ValueItems();
    protected virtual void DrawCore(IEnumerable`1<Feature> features, GeoCanvas canvas, Collection`1<SimpleCandidate> labelsInThisLayer, Collection`1<SimpleCandidate> labelsInAllLayers);
    protected virtual Collection`1<string> GetRequiredColumnNamesCore();
    protected virtual void DrawSampleCore(GeoCanvas canvas, DrawingRectangleF drawingExtent);
    [IteratorStateMachineAttribute("ThinkGeo.Core.ValueStyle/sUA=")]
private IEnumerable`1<Style> tzE=();
    private static void ujE=(Collection`1<string> requiredFieldNames, Collection`1<string> fieldNames);
}
public class ThinkGeo.Core.VectorTile : Tile {
    [ObfuscationAttribute]
private Byte[] content;
    public Byte[] Content { get; public set; }
    public VectorTile(Byte[] content, int zoom, long column, long row);
    public Byte[] get_Content();
    public void set_Content(Byte[] value);
    private static RectangleShape 2B0=(int zoom, long column, long row);
    internal Collection`1<Feature> 2R0=();
    internal Collection`1<Feature> 2R0=(List`1<string> pbfLayerNames);
    public Collection`1<PbfLayer> GetPbfLayers();
}
[DebuggerNonUserCodeAttribute]
[GeneratedCodeAttribute("System.Resources.Tools.StronglyTypedResourceBuilder", "4.0.0.0")]
[ObfuscationAttribute]
[CompilerGeneratedAttribute]
internal class ThinkGeo.Core.VectorTileExceptionDescription : object {
    private static ResourceManager resourceMan;
    private static CultureInfo resourceCulture;
    [EditorBrowsableAttribute("2")]
internal static ResourceManager ResourceManager { get; }
    [EditorBrowsableAttribute("2")]
internal static CultureInfo Culture { get; internal set; }
    internal static string CheckVarintIsInvalid { get; }
    internal static string CallViewError { get; }
    internal static string CheckWireTypeIsNotBytes { get; }
    internal static string CheckTagIsOutOfRange { get; }
    internal static string CallSkipError { get; }
    internal static string CheckWireTypeIsDefined { get; }
    internal static string CheckWireTypeIsKnown { get; }
    internal static string CheckSkipBytesIsValid { get; }
    internal static string CheckDataIsNotEmpty { get; }
    internal static string CheckDataIsZipped { get; }
    internal static string CheckVectorTileFeatureTagsIsEven { get; }
    internal static string CheckValueTypeIsValid { get; }
    internal static string DownloadFileFromNetworkError { get; }
    internal static string CheckColumnValuesAreValidInTileRange { get; }
    internal static string CheckRowValuesAreValidInTileRange { get; }
    internal static ResourceManager get_ResourceManager();
    internal static CultureInfo get_Culture();
    internal static void set_Culture(CultureInfo value);
    internal static string get_CheckVarintIsInvalid();
    internal static string get_CallViewError();
    internal static string get_CheckWireTypeIsNotBytes();
    internal static string get_CheckTagIsOutOfRange();
    internal static string get_CallSkipError();
    internal static string get_CheckWireTypeIsDefined();
    internal static string get_CheckWireTypeIsKnown();
    internal static string get_CheckSkipBytesIsValid();
    internal static string get_CheckDataIsNotEmpty();
    internal static string get_CheckDataIsZipped();
    internal static string get_CheckVectorTileFeatureTagsIsEven();
    internal static string get_CheckValueTypeIsValid();
    internal static string get_DownloadFileFromNetworkError();
    internal static string get_CheckColumnValuesAreValidInTileRange();
    internal static string get_CheckRowValuesAreValidInTileRange();
}
public class ThinkGeo.Core.Vertex : ValueType {
    [ObfuscationAttribute]
private double x;
    [ObfuscationAttribute]
private double y;
    public double X { get; public set; }
    public double Y { get; public set; }
    public Vertex(double x, double y);
    public Vertex(PointShape point);
    public double get_X();
    public void set_X(double value);
    public double get_Y();
    public void set_Y(double value);
    public virtual string ToString();
    public virtual int GetHashCode();
    public virtual bool Equals(object obj);
    private bool lhU=(Vertex compareObj);
    public Vertex Add(Vertex targetVertex);
    public static Vertex op_Addition(Vertex vertex1, Vertex vertex2);
    public static bool op_Equality(Vertex vertex1, Vertex vertex2);
    public static bool op_Inequality(Vertex vertex1, Vertex vertex2);
    public static Vertex FindMiddleVertexBetweenTwoVertices(Vertex vertex1, Vertex vertex2);
    internal void kBw=(double xOffset, double yOffset, GeographyUnit shapeUnit, DistanceUnit unitOfOffset);
    internal void kRw=(double distance, double angleInDegrees, GeographyUnit shapeUnit, DistanceUnit distanceUnit);
    internal void khw=(Vertex vertex, double degreeAngle);
    internal void khw=(PointShape pivotPoint, double degreeAngle);
    internal double kxw=(BaseShape targetShape, GeographyUnit shapeUnit, DistanceUnit distanceUnit);
    internal double kxw=(Vertex targetVertex, GeographyUnit shapeUnit, DistanceUnit distanceUnit);
    internal double lBw=(double toX, double toY);
    private PointShape dBw=(double offset, float degree);
}
public class ThinkGeo.Core.VertexAddedEditInteractiveOverlayEventArgs : EventArgs {
    [ObfuscationAttribute]
private Feature affectedFeature;
    [ObfuscationAttribute]
private Vertex addedVertex;
    public Feature AffectedFeature { get; public set; }
    public Vertex AddedVertex { get; public set; }
    public VertexAddedEditInteractiveOverlayEventArgs(Feature affectedFeature, Vertex addedVertex);
    public Feature get_AffectedFeature();
    public void set_AffectedFeature(Feature value);
    public Vertex get_AddedVertex();
    public void set_AddedVertex(Vertex value);
}
public class ThinkGeo.Core.VertexAddedTrackInteractiveOverlayEventArgs : EventArgs {
    [ObfuscationAttribute]
private Vertex addedVertex;
    [ObfuscationAttribute]
private Feature affectedFeature;
    public Vertex AddedVertex { get; public set; }
    public Feature AffectedFeature { get; public set; }
    public VertexAddedTrackInteractiveOverlayEventArgs(Vertex addedVertex, Feature affectedFeature);
    public Vertex get_AddedVertex();
    public void set_AddedVertex(Vertex value);
    public Feature get_AffectedFeature();
    public void set_AffectedFeature(Feature value);
}
public class ThinkGeo.Core.VertexAddingEditInteractiveOverlayEventArgs : EventArgs {
    [ObfuscationAttribute]
private Feature affectedFeature;
    [ObfuscationAttribute]
private Vertex addingVertex;
    [ObfuscationAttribute]
private bool cancel;
    [CompilerGeneratedAttribute]
private PointShape rBQ=;
    public Feature AffectedFeature { get; public set; }
    public Vertex AddingVertex { get; public set; }
    public bool Cancel { get; public set; }
    public PointShape TargetPointShape { get; public set; }
    public VertexAddingEditInteractiveOverlayEventArgs(bool cancel, Feature affectedFeature, Vertex addingVertex);
    public Feature get_AffectedFeature();
    public void set_AffectedFeature(Feature value);
    public Vertex get_AddingVertex();
    public void set_AddingVertex(Vertex value);
    public bool get_Cancel();
    public void set_Cancel(bool value);
    [CompilerGeneratedAttribute]
public PointShape get_TargetPointShape();
    [CompilerGeneratedAttribute]
public void set_TargetPointShape(PointShape value);
}
public class ThinkGeo.Core.VertexAddingTrackInteractiveOverlayEventArgs : EventArgs {
    [ObfuscationAttribute]
private bool cancel;
    [ObfuscationAttribute]
private Vertex addingVertex;
    [ObfuscationAttribute]
private Feature affectedFeature;
    [CompilerGeneratedAttribute]
private PointShape rBQ=;
    public bool Cancel { get; public set; }
    public Vertex AddingVertex { get; public set; }
    public Feature AffectedFeature { get; public set; }
    public PointShape TargetPointShape { get; public set; }
    public VertexAddingTrackInteractiveOverlayEventArgs(Vertex addingVertex, Feature affectedFeature, bool cancel);
    public bool get_Cancel();
    public void set_Cancel(bool value);
    public Vertex get_AddingVertex();
    public void set_AddingVertex(Vertex value);
    public Feature get_AffectedFeature();
    public void set_AffectedFeature(Feature value);
    [CompilerGeneratedAttribute]
public PointShape get_TargetPointShape();
    [CompilerGeneratedAttribute]
public void set_TargetPointShape(PointShape value);
}
public class ThinkGeo.Core.VertexMovedEditInteractiveOverlayEventArgs : EventArgs {
    [ObfuscationAttribute]
private Feature affectedFeature;
    [ObfuscationAttribute]
private Vertex movedVertex;
    public Feature AffectedFeature { get; public set; }
    public Vertex MovedVertex { get; public set; }
    public VertexMovedEditInteractiveOverlayEventArgs(Feature affectedFeature, Vertex movedVertex);
    public Feature get_AffectedFeature();
    public void set_AffectedFeature(Feature value);
    public Vertex get_MovedVertex();
    public void set_MovedVertex(Vertex value);
}
public class ThinkGeo.Core.VertexMovingEditInteractiveOverlayEventArgs : EventArgs {
    [CompilerGeneratedAttribute]
private Feature rRQ=;
    [CompilerGeneratedAttribute]
private Vertex rhQ=;
    [CompilerGeneratedAttribute]
private PointShape rxQ=;
    [CompilerGeneratedAttribute]
private bool sBQ=;
    public Feature AffectedFeature { get; public set; }
    public Vertex MovingVertex { get; public set; }
    public PointShape TargetVertex { get; public set; }
    public bool Cancel { get; public set; }
    public VertexMovingEditInteractiveOverlayEventArgs(bool cancel, Feature affectedFeature, Vertex movingVertex);
    public VertexMovingEditInteractiveOverlayEventArgs(bool cancel, Feature affectedFeature, Vertex movingVertex, PointShape targetVertex);
    [CompilerGeneratedAttribute]
public Feature get_AffectedFeature();
    [CompilerGeneratedAttribute]
public void set_AffectedFeature(Feature value);
    [CompilerGeneratedAttribute]
public Vertex get_MovingVertex();
    [CompilerGeneratedAttribute]
public void set_MovingVertex(Vertex value);
    [CompilerGeneratedAttribute]
public PointShape get_TargetVertex();
    [CompilerGeneratedAttribute]
public void set_TargetVertex(PointShape value);
    [CompilerGeneratedAttribute]
public bool get_Cancel();
    [CompilerGeneratedAttribute]
public void set_Cancel(bool value);
}
public class ThinkGeo.Core.VertexRemovedEditInteractiveOverlayEventArgs : EventArgs {
    [ObfuscationAttribute]
private Feature affectedFeature;
    [ObfuscationAttribute]
private Vertex removedVertex;
    public Feature AffectedFeature { get; public set; }
    public Vertex RemovedVertex { get; public set; }
    public VertexRemovedEditInteractiveOverlayEventArgs(Feature affectedFeature, Vertex removedVertex);
    public Feature get_AffectedFeature();
    public void set_AffectedFeature(Feature value);
    public Vertex get_RemovedVertex();
    public void set_RemovedVertex(Vertex value);
}
public class ThinkGeo.Core.VertexRemovingEditInteractiveOverlayEventArgs : EventArgs {
    [ObfuscationAttribute]
private Feature affectedFeature;
    [ObfuscationAttribute]
private Vertex removingVertex;
    [ObfuscationAttribute]
private bool cancel;
    public Feature AffectedFeature { get; public set; }
    public Vertex RemovingVertex { get; public set; }
    public bool Cancel { get; public set; }
    public VertexRemovingEditInteractiveOverlayEventArgs(bool cancel, Feature affectedFeature, Vertex removingVertex);
    public Feature get_AffectedFeature();
    public void set_AffectedFeature(Feature value);
    public Vertex get_RemovingVertex();
    public void set_RemovingVertex(Vertex value);
    public bool get_Cancel();
    public void set_Cancel(bool value);
}
public class ThinkGeo.Core.WarningMessage : object {
    public static string UseAsyncVersion;
    public static string WebRequestObsoleted;
    public static string WebRequestObsoleted2;
    public static string AttributionObsoleteMessage;
    public static string AutoRefreshOverlayObsoleteMessage;
}
public abstract class ThinkGeo.Core.WebBasedAsyncLayer : AsyncLayer {
    [CompilerGeneratedAttribute]
private EventHandler`1<SendingHttpRequestMessageEventArgs> UB4=;
    [CompilerGeneratedAttribute]
private EventHandler`1<ReceivedHttpResponseMessageEventArgs> UR4=;
    [CompilerGeneratedAttribute]
private HttpClient Uh4=;
    [CompilerGeneratedAttribute]
private IWebProxy Ch4=;
    [CompilerGeneratedAttribute]
private int CR4=;
    [CompilerGeneratedAttribute]
private ICredentials Ux4=;
    [CompilerGeneratedAttribute]
private string VB4=;
    protected HttpClient HttpClient { get; protected set; }
    public IWebProxy WebProxy { get; public set; }
    public int TimeoutInSeconds { get; public set; }
    public ICredentials Credentials { get; public set; }
    public string UserAgent { get; public set; }
    [CompilerGeneratedAttribute]
public void add_SendingHttpRequest(EventHandler`1<SendingHttpRequestMessageEventArgs> value);
    [CompilerGeneratedAttribute]
public void remove_SendingHttpRequest(EventHandler`1<SendingHttpRequestMessageEventArgs> value);
    [CompilerGeneratedAttribute]
public void add_ReceivedHttpResponse(EventHandler`1<ReceivedHttpResponseMessageEventArgs> value);
    [CompilerGeneratedAttribute]
public void remove_ReceivedHttpResponse(EventHandler`1<ReceivedHttpResponseMessageEventArgs> value);
    [CompilerGeneratedAttribute]
protected HttpClient get_HttpClient();
    [CompilerGeneratedAttribute]
protected void set_HttpClient(HttpClient value);
    [CompilerGeneratedAttribute]
public sealed virtual IWebProxy get_WebProxy();
    [CompilerGeneratedAttribute]
public sealed virtual void set_WebProxy(IWebProxy value);
    [CompilerGeneratedAttribute]
public sealed virtual int get_TimeoutInSeconds();
    [CompilerGeneratedAttribute]
public sealed virtual void set_TimeoutInSeconds(int value);
    [AsyncStateMachineAttribute("ThinkGeo.Core.WebBasedAsyncLayer/YT8=")]
protected virtual Task OpenAsyncCore(CancellationToken cancellationToken);
    [CompilerGeneratedAttribute]
public sealed virtual ICredentials get_Credentials();
    [CompilerGeneratedAttribute]
public sealed virtual void set_Credentials(ICredentials value);
    [AsyncStateMachineAttribute("ThinkGeo.Core.WebBasedAsyncLayer/Yj8=")]
protected Task`1<HttpResponseMessage> SendWebRequestAsync(HttpRequestMessage httpRequest, CancellationToken cancellationToken);
    [CompilerGeneratedAttribute]
public sealed virtual string get_UserAgent();
    [CompilerGeneratedAttribute]
public sealed virtual void set_UserAgent(string value);
    public Task`1<Byte[]> FetchImageAsync(HttpRequestMessage requestMessage, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("ThinkGeo.Core.WebBasedAsyncLayer/XD8=")]
protected Task`1<Byte[]> FetchImageAsyncCore(HttpRequestMessage requestMessage, CancellationToken cancellationToken);
    public Task`1<Byte[]> DownloadImageAsync(double width, double height, double scaleFactor, RectangleShape extent, GeographyUnit mapUnit, CancellationToken cancellationToken);
    protected virtual Task`1<Byte[]> DownloadImageAsyncCore(double width, double height, double scaleFactor, RectangleShape extent, GeographyUnit mapUnit, CancellationToken cancellationToken);
    protected virtual void OnSendingHttpRequestMessage(SendingHttpRequestMessageEventArgs e);
    protected virtual void OnReceivedHttpResponseMessage(ReceivedHttpResponseMessageEventArgs e);
    [CompilerGeneratedAttribute]
[DebuggerHiddenAttribute]
private Task Ah4=(CancellationToken cancellationToken);
}
public enum ThinkGeo.Core.WellKnownType : Enum {
    public int value__;
    public static WellKnownType Invalid;
    public static WellKnownType Point;
    public static WellKnownType Line;
    public static WellKnownType Polygon;
    public static WellKnownType Multipoint;
    public static WellKnownType Multiline;
    public static WellKnownType Multipolygon;
    public static WellKnownType GeometryCollection;
}
public class ThinkGeo.Core.WellPointStyle : PointBaseStyle {
    [ObfuscationAttribute]
private int wellPointIndex;
    public int WellPointIndex { get; public set; }
    public WellPointStyle(int wellPointIndex);
    public WellPointStyle(int wellPointIndex, int symbolSize, GeoBrush fillBrush);
    public WellPointStyle(int wellPointIndex, int symbolSize, GeoBrush fillBrush, GeoPen outlinePen);
    private void TDI=(Feature feature, GeoCanvas canvas, GeoBrush geoBrush, GeoPen haloPen);
    private void TTI=(Feature feature, GeoCanvas canvas, GeoBrush geoBrush, GeoPen haloPen);
    private void TjI=(Feature feature, GeoCanvas canvas, GeoBrush geoBrush, GeoPen haloPen);
    private void TzI=(Feature feature, GeoCanvas canvas, GeoBrush geoBrush, GeoPen haloPen);
    private void UDI=(Feature feature, GeoCanvas canvas, GeoBrush geoBrush, GeoPen haloPen);
    private void UTI=(Feature feature, GeoCanvas canvas, GeoBrush geoBrush, GeoPen haloPen, bool useFillBrush);
    private void UjI=(Feature feature, GeoCanvas canvas, GeoBrush geoBrush, GeoPen haloPen);
    private void UzI=(Feature feature, GeoCanvas canvas, GeoBrush geoBrush, GeoPen haloPen, bool useFillBrush);
    private void VDI=(Feature feature, GeoCanvas canvas, GeoBrush geoBrush, GeoPen haloPen, bool useFillBrush);
    private void VTI=(Feature feature, GeoCanvas canvas, GeoBrush geoBrush, GeoPen haloPen, bool useFillBrush);
    private void VjI=(Feature feature, GeoCanvas canvas, GeoBrush geoBrush, GeoPen haloPen, bool useFillBrush);
    private void VzI=(Feature feature, GeoCanvas canvas, GeoBrush geoBrush, GeoPen haloPen, bool useFillBrush);
    private void WDI=(Feature feature, GeoCanvas canvas, GeoBrush geoBrush, GeoPen haloPen);
    private void WTI=(Feature feature, GeoCanvas canvas, GeoBrush geoBrush, GeoPen haloPen);
    private void WjI=(Feature feature, GeoCanvas canvas, GeoBrush geoBrush, GeoPen haloPen);
    private void WzI=(Feature feature, GeoCanvas canvas, GeoBrush geoBrush, GeoPen haloPen);
    private void XDI=(Feature feature, GeoCanvas canvas, GeoBrush geoBrush, GeoPen haloPen);
    private void XTI=(Feature feature, GeoCanvas canvas, GeoBrush geoBrush, GeoPen haloPen);
    private void XjI=(Feature feature, GeoCanvas canvas, GeoBrush geoBrush, GeoPen haloPen);
    private void XzI=(Feature feature, GeoCanvas canvas, GeoBrush geoBrush, GeoPen haloPen);
    private void YDI=(Feature feature, GeoCanvas canvas, GeoBrush geoBrush, GeoPen haloPen, bool useFillBrush);
    private void YTI=(Feature feature, GeoCanvas canvas, GeoBrush geoBrush, GeoPen haloPen);
    private void YjI=(Feature feature, GeoCanvas canvas, GeoBrush geoBrush, GeoPen haloPen);
    private void YzI=(Feature feature, GeoCanvas canvas, GeoBrush geoBrush, GeoPen haloPen);
    private void ZDI=(Feature feature, GeoCanvas canvas, GeoBrush geoBrush, GeoPen haloPen);
    private void ZTI=(Feature feature, GeoCanvas canvas, GeoBrush geoBrush, GeoPen haloPen);
    private void ZjI=(Feature feature, GeoCanvas canvas, GeoBrush geoBrush, GeoPen haloPen);
    private void ZzI=(Feature feature, GeoCanvas canvas, GeoBrush geoBrush, GeoPen haloPen);
    private void aDI=(Feature feature, GeoCanvas canvas, GeoBrush geoBrush, GeoPen haloPen);
    private void aTI=(Feature feature, GeoCanvas canvas, GeoBrush geoBrush, GeoPen haloPen);
    private void ajI=(Feature feature, GeoCanvas canvas, GeoBrush geoBrush, GeoPen haloPen);
    private void azI=(Feature feature, GeoCanvas canvas, GeoBrush geoBrush, GeoPen haloPen);
    private void bDI=(Feature feature, GeoCanvas canvas, GeoBrush geoBrush, GeoPen haloPen);
    private void bTI=(Feature feature, GeoCanvas canvas, GeoBrush geoBrush, GeoPen haloPen);
    private void bjI=(Feature feature, GeoCanvas canvas, GeoBrush geoBrush, GeoPen haloPen);
    private void bzI=(Feature feature, GeoCanvas canvas, GeoBrush geoBrush, GeoPen haloPen);
    private void cDI=(Feature feature, GeoCanvas canvas, GeoBrush geoBrush, GeoPen haloPen);
    private void cTI=(Feature feature, GeoCanvas canvas, GeoBrush geoBrush, GeoPen haloPen);
    private void cjI=(Feature feature, GeoCanvas canvas, GeoBrush geoBrush, GeoPen haloPen);
    private void czI=(Feature feature, GeoCanvas canvas, GeoBrush geoBrush, GeoPen haloPen);
    private void dDI=(Feature feature, GeoCanvas canvas, GeoBrush geoBrush, GeoPen haloPen);
    private void dTI=(Feature feature, GeoCanvas canvas, GeoBrush geoBrush, GeoPen haloPen);
    private void djI=(Feature feature, GeoCanvas canvas, GeoBrush geoBrush, GeoPen haloPen);
    private void dzI=(Feature feature, GeoCanvas canvas, GeoBrush geoBrush, GeoPen haloPen, bool useFillBrush);
    private void eDI=(Feature feature, GeoCanvas canvas, GeoBrush geoBrush, GeoPen haloPen);
    private void eTI=(Feature feature, GeoCanvas canvas, GeoBrush geoBrush, GeoPen haloPen);
    private void ejI=(Feature feature, GeoCanvas canvas, GeoBrush geoBrush, GeoPen haloPen);
    private void ezI=(Feature feature, GeoCanvas canvas, GeoBrush geoBrush, GeoPen haloPen);
    private void fDI=(Feature feature, GeoCanvas canvas, GeoBrush geoBrush, GeoPen haloPen);
    private void fTI=(Feature feature, GeoCanvas canvas, GeoBrush geoBrush, GeoPen haloPen);
    private void fjI=(Feature feature, GeoCanvas canvas, GeoBrush geoBrush, GeoPen haloPen);
    private void fzI=(Feature feature, GeoCanvas canvas, GeoBrush geoBrush, GeoPen haloPen);
    private void gDI=(Feature feature, GeoCanvas canvas, GeoBrush geoBrush, GeoPen haloPen);
    private void gTI=(Feature feature, GeoCanvas canvas, GeoBrush geoBrush, GeoPen haloPen);
    private void gjI=(Feature feature, GeoCanvas canvas, GeoBrush geoBrush, GeoPen haloPen);
    private void gzI=(Feature feature, GeoCanvas canvas, GeoBrush geoBrush, GeoPen haloPen);
    private void hDI=(Feature feature, GeoCanvas canvas, GeoBrush geoBrush, GeoPen haloPen);
    private void hTI=(Feature feature, GeoCanvas canvas, GeoBrush geoBrush, GeoPen haloPen);
    private void hjI=(Feature feature, GeoCanvas canvas, GeoBrush geoBrush, GeoPen haloPen);
    private void hzI=(Feature feature, GeoCanvas canvas, GeoBrush geoBrush, GeoPen haloPen);
    private void iDI=(Feature feature, GeoCanvas canvas, GeoBrush geoBrush, GeoPen haloPen);
    private void iTI=(Feature feature, GeoCanvas canvas, GeoBrush geoBrush, GeoPen haloPen);
    private void ijI=(Feature feature, GeoCanvas canvas, GeoBrush geoBrush, GeoPen haloPen);
    private void izI=(Feature feature, GeoCanvas canvas, GeoBrush geoBrush, GeoPen haloPen);
    private void jDI=(Feature feature, GeoCanvas canvas, GeoBrush geoBrush, GeoPen haloPen);
    private void jTI=(Feature feature, GeoCanvas canvas, GeoBrush geoBrush, GeoPen haloPen);
    private void jjI=(Feature feature, GeoCanvas canvas, GeoBrush geoBrush, GeoPen haloPen);
    private void jzI=(Feature feature, GeoCanvas canvas, GeoBrush geoBrush, GeoPen haloPen, bool useFillBrush);
    private void kDI=(Feature feature, GeoCanvas canvas, GeoBrush geoBrush, GeoPen haloPen, bool useFillBrush);
    private void kTI=(Feature feature, GeoCanvas canvas, GeoBrush geoBrush, GeoPen haloPen);
    private void kjI=(Feature feature, GeoCanvas canvas, GeoBrush geoBrush, GeoPen haloPen);
    private void kzI=(Feature feature, GeoCanvas canvas, GeoBrush geoBrush, GeoPen haloPen);
    private void lDI=(Feature feature, GeoCanvas canvas, GeoBrush geoBrush, GeoPen haloPen);
    private void lTI=(Feature feature, GeoCanvas canvas, GeoBrush geoBrush, GeoPen haloPen);
    private void ljI=(Feature feature, GeoCanvas canvas, GeoBrush geoBrush, GeoPen haloPen);
    private void lzI=(Feature feature, GeoCanvas canvas, GeoBrush geoBrush, GeoPen haloPen);
    private void mDI=(Feature feature, GeoCanvas canvas, GeoBrush geoBrush, GeoPen haloPen);
    private void mTI=(Feature feature, GeoCanvas canvas, GeoBrush geoBrush, GeoPen haloPen);
    private void mjI=(Feature feature, GeoCanvas canvas, GeoBrush geoBrush, GeoPen haloPen);
    private void mzI=(Feature feature, GeoCanvas canvas, GeoBrush geoBrush, GeoPen haloPen);
    private void nDI=(Feature feature, GeoCanvas canvas, GeoBrush geoBrush, GeoPen haloPen);
    private void nTI=(Feature feature, GeoCanvas canvas, GeoBrush geoBrush, GeoPen haloPen);
    private void njI=(Feature feature, GeoCanvas canvas, GeoBrush geoBrush, GeoPen haloPen);
    private void nzI=(Feature feature, GeoCanvas canvas, GeoBrush geoBrush, GeoPen haloPen);
    private void oDI=(Feature feature, GeoCanvas canvas, GeoBrush geoBrush, GeoPen haloPen);
    private void oTI=(Feature feature, GeoCanvas canvas, GeoBrush geoBrush, GeoPen haloPen);
    private void ojI=(Feature feature, GeoCanvas canvas, GeoBrush geoBrush, GeoPen haloPen);
    private void ozI=(Feature feature, GeoCanvas canvas, GeoBrush geoBrush, GeoPen haloPen);
    private void pDI=(Feature feature, GeoCanvas canvas, GeoBrush geoBrush, GeoPen haloPen);
    private void pTI=(Feature feature, GeoCanvas canvas, GeoBrush geoBrush, GeoPen haloPen);
    private void pjI=(Feature feature, GeoCanvas canvas, GeoBrush geoBrush, GeoPen haloPen);
    private void pzI=(Feature feature, GeoCanvas canvas, GeoBrush geoBrush, GeoPen haloPen);
    private void qDI=(Feature feature, GeoCanvas canvas, GeoBrush geoBrush, GeoPen haloPen);
    private void qTI=(Feature feature, GeoCanvas canvas, GeoBrush geoBrush, GeoPen haloPen);
    private void qjI=(Feature feature, GeoCanvas canvas, GeoBrush geoBrush, GeoPen haloPen);
    private void qzI=(Feature feature, GeoCanvas canvas, GeoBrush geoBrush, GeoPen haloPen);
    private void rDI=(Feature feature, GeoCanvas canvas, GeoBrush geoBrush, GeoPen haloPen);
    private void rTI=(Feature feature, GeoCanvas canvas, GeoBrush geoBrush, GeoPen haloPen);
    private void rjI=(Feature feature, GeoCanvas canvas, GeoBrush geoBrush, GeoPen haloPen);
    private void rzI=(Feature feature, GeoCanvas canvas, GeoBrush geoBrush, GeoPen haloPen);
    private void sDI=(Feature feature, GeoCanvas canvas, GeoBrush geoBrush, GeoPen haloPen);
    private void sTI=(Feature feature, GeoCanvas canvas, GeoBrush geoBrush, GeoPen haloPen);
    private void sjI=(Feature feature, GeoCanvas canvas, GeoBrush geoBrush, GeoPen haloPen);
    private void szI=(Feature feature, GeoCanvas canvas, GeoBrush geoBrush, GeoPen haloPen);
    private void tDI=(Feature feature, GeoCanvas canvas, GeoBrush geoBrush, GeoPen haloPen);
    private void tTI=(Feature feature, GeoCanvas canvas, GeoBrush geoBrush, GeoPen haloPen);
    private void tjI=(Feature feature, GeoCanvas canvas, GeoBrush geoBrush, GeoPen haloPen);
    private void tzI=(Feature feature, GeoCanvas canvas, GeoBrush geoBrush, GeoPen haloPen);
    private void uDI=(Feature feature, GeoCanvas canvas, GeoBrush geoBrush, GeoPen haloPen);
    private void uTI=(Feature feature, GeoCanvas canvas, GeoBrush geoBrush, GeoPen haloPen);
    private void ujI=(Feature feature, GeoCanvas canvas, GeoBrush geoBrush, GeoPen haloPen);
    private void uzI=(Feature feature, GeoCanvas canvas, GeoBrush geoBrush, GeoPen haloPen);
    private void vDI=(Feature feature, GeoCanvas canvas, GeoBrush geoBrush, GeoPen haloPen);
    private void vTI=(Feature feature, GeoCanvas canvas, GeoBrush geoBrush, GeoPen haloPen);
    private void vjI=(Feature feature, GeoCanvas canvas, GeoBrush geoBrush, GeoPen haloPen);
    private void vzI=(Feature feature, GeoCanvas canvas, GeoBrush geoBrush, GeoPen haloPen, bool useFillBrush);
    private void wDI=(Feature feature, GeoCanvas canvas, GeoBrush geoBrush, GeoPen haloPen, bool useFillBrush);
    private void wTI=(Feature feature, GeoCanvas canvas, GeoBrush geoBrush, GeoPen haloPen);
    private void wjI=(Feature feature, GeoCanvas canvas, GeoBrush geoBrush, GeoPen haloPen);
    private void wzI=(Feature feature, GeoCanvas canvas, GeoBrush geoBrush, GeoPen haloPen);
    private void xDI=(Feature feature, GeoCanvas canvas, GeoBrush geoBrush, GeoPen haloPen);
    private void xTI=(Feature feature, GeoCanvas canvas, GeoBrush geoBrush, GeoPen haloPen);
    private void xjI=(Feature feature, GeoCanvas canvas, GeoBrush geoBrush, GeoPen haloPen);
    private void xzI=(Feature feature, GeoCanvas canvas, GeoBrush geoBrush, GeoPen haloPen);
    private void yDI=(Feature feature, GeoCanvas canvas, GeoBrush geoBrush, GeoPen haloPen);
    private void yTI=(Feature feature, GeoCanvas canvas, GeoBrush geoBrush, GeoPen haloPen);
    private void yjI=(Feature feature, GeoCanvas canvas, GeoBrush geoBrush, GeoPen haloPen);
    private void yzI=(Feature feature, GeoCanvas canvas, GeoBrush geoBrush, GeoPen haloPen);
    private void zDI=(Feature feature, GeoCanvas canvas, GeoBrush geoBrush, GeoPen haloPen);
    private void zTI=(Feature feature, GeoCanvas canvas, GeoBrush geoBrush, GeoPen haloPen);
    private void zjI=(Feature feature, GeoCanvas canvas, GeoBrush geoBrush, GeoPen haloPen);
    private void zzI=(Feature feature, GeoCanvas canvas, GeoBrush geoBrush, GeoPen haloPen);
    private void 0DI=(Feature feature, GeoCanvas canvas, GeoBrush geoBrush, GeoPen haloPen);
    private void 0TI=(Feature feature, GeoCanvas canvas, GeoBrush geoBrush, GeoPen haloPen, bool useFillBrush);
    private void 0jI=(Feature feature, GeoCanvas canvas, GeoBrush geoBrush, GeoPen haloPen);
    private void 0zI=(Feature feature, GeoCanvas canvas, GeoBrush geoBrush, GeoPen haloPen);
    private void 1DI=(Feature feature, GeoCanvas canvas, GeoBrush geoBrush, GeoPen haloPen);
    private void 1TI=(Feature feature, GeoCanvas canvas, GeoBrush geoBrush, GeoPen haloPen);
    private void 1jI=(Feature feature, GeoCanvas canvas, GeoBrush geoBrush, GeoPen haloPen);
    private void 1zI=(Feature feature, GeoCanvas canvas, GeoBrush geoBrush, GeoPen haloPen);
    private void 2DI=(Feature feature, GeoCanvas canvas, GeoBrush geoBrush, GeoPen haloPen);
    private void 2TI=(Feature feature, GeoCanvas canvas, GeoBrush geoBrush, GeoPen haloPen);
    private void 2jI=(Feature feature, GeoCanvas canvas, GeoBrush geoBrush, GeoPen haloPen);
    private void 2zI=(Feature feature, GeoCanvas canvas, GeoBrush geoBrush, GeoPen haloPen);
    private void 3DI=(Feature feature, GeoCanvas canvas, GeoBrush geoBrush, GeoPen haloPen);
    private void 3TI=(Feature feature, GeoCanvas canvas, GeoBrush geoBrush, GeoPen haloPen);
    private void 3jI=(Feature feature, GeoCanvas canvas, GeoBrush geoBrush, GeoPen haloPen);
    private void 3zI=(Feature feature, GeoCanvas canvas, GeoBrush geoBrush, GeoPen haloPen);
    private void 4DI=(Feature feature, GeoCanvas canvas, GeoBrush geoBrush, GeoPen haloPen);
    private void 4TI=(Feature feature, GeoCanvas canvas, GeoBrush geoBrush, GeoPen haloPen);
    private void 4jI=(Feature feature, GeoCanvas canvas, GeoBrush geoBrush, GeoPen haloPen);
    private void 4zI=(Feature feature, GeoCanvas canvas, GeoBrush geoBrush, GeoPen haloPen);
    private void 5DI=(Feature feature, GeoCanvas canvas, GeoBrush geoBrush, GeoPen haloPen);
    private void 5TI=(Feature feature, GeoCanvas canvas, GeoBrush geoBrush, GeoPen haloPen);
    private void 5jI=(Feature feature, GeoCanvas canvas, GeoBrush geoBrush, GeoPen haloPen);
    private void 5zI=(Feature feature, GeoCanvas canvas, GeoBrush geoBrush, GeoPen haloPen);
    private void 6DI=(Feature feature, GeoCanvas canvas, GeoBrush geoBrush, GeoPen haloPen);
    private void 6TI=(Feature feature, GeoCanvas canvas, GeoBrush geoBrush, GeoPen haloPen);
    private void 6jI=(Feature feature, GeoCanvas canvas, GeoBrush geoBrush, GeoPen haloPen);
    private void 6zI=(Feature feature, GeoCanvas canvas, GeoBrush geoBrush, GeoPen haloPen);
    private void 7DI=(Feature feature, GeoCanvas canvas, GeoBrush geoBrush, GeoPen haloPen);
    private void 7TI=(Feature feature, GeoCanvas canvas, GeoBrush geoBrush, GeoPen haloPen);
    private void 7jI=(Feature feature, GeoCanvas canvas, GeoBrush geoBrush, GeoPen haloPen);
    private void 7zI=(Feature feature, GeoCanvas canvas, GeoBrush geoBrush, GeoPen haloPen);
    private void 8DI=(Feature feature, GeoCanvas canvas, GeoBrush geoBrush, GeoPen haloPen);
    private void 8TI=(Feature feature, GeoCanvas canvas, GeoBrush geoBrush, GeoPen haloPen);
    private void 8jI=(Feature feature, GeoCanvas canvas, GeoBrush geoBrush, GeoPen haloPen);
    private void 8zI=(Feature feature, GeoCanvas canvas, GeoBrush geoBrush, GeoPen haloPen);
    private void 9DI=(Feature feature, GeoCanvas canvas, GeoBrush geoBrush, GeoPen haloPen);
    private void 9TI=(Feature feature, GeoCanvas canvas, GeoBrush geoBrush, GeoPen haloPen);
    private void 9jI=(Feature feature, GeoCanvas canvas, GeoBrush geoBrush, GeoPen haloPen);
    private void 9zI=(Feature feature, GeoCanvas canvas, GeoBrush geoBrush, GeoPen haloPen, bool useFillBrush);
    private void /DI=(Feature feature, GeoCanvas canvas, GeoBrush geoBrush, GeoPen haloPen);
    private void /TI=(Feature feature, GeoCanvas canvas, GeoBrush geoBrush, GeoPen haloPen, bool useFillBrush);
    private void /jI=(Feature feature, GeoCanvas canvas, GeoBrush geoBrush, GeoPen haloPen);
    private void /zI=(Feature feature, GeoCanvas canvas, GeoBrush geoBrush, GeoPen haloPen, bool useFillBrush);
    private void ADM=(Feature feature, GeoCanvas canvas, GeoBrush geoBrush, GeoPen haloPen);
    private void ATM=(Feature feature, GeoCanvas canvas, GeoBrush geoBrush, GeoPen haloPen, bool useFillBrush);
    private void AjM=(Feature feature, GeoCanvas canvas, GeoBrush geoBrush, GeoPen haloPen);
    private void AzM=(Feature feature, GeoCanvas canvas, GeoBrush geoBrush, GeoPen haloPen, bool useFillBrush);
    private void BDM=(Feature feature, GeoCanvas canvas, GeoBrush geoBrush, GeoPen haloPen);
    private void BTM=(Feature feature, GeoCanvas canvas, GeoBrush geoBrush, GeoPen haloPen, bool useFillBrush);
    private void BjM=(Feature feature, GeoCanvas canvas, GeoBrush geoBrush, GeoPen haloPen);
    private void BzM=(Feature feature, GeoCanvas canvas, GeoBrush geoBrush, GeoPen haloPen, bool useFillBrush);
    private void CDM=(Feature feature, GeoCanvas canvas, GeoBrush geoBrush, GeoPen haloPen);
    private static Feature CTM=(PointShape centerPoint, double resolutionX, double resolutionY, double radius);
    private static Feature CjM=(PointShape centerPoint, double resolutionX, double resolutionY, double radius);
    private static Feature CzM=(PointShape centerPoint, double resolutionX, double resolutionY, double radius);
    private void DDM=(Feature feature, GeoCanvas canvas, GeoPen haloPen, GeoBrush geobrush, PointShape centerPoint, double resolutionX, double resolutionY, float radius, float halfRadius, bool useFillBrush);
    private void DTM=(Feature feature, GeoCanvas canvas, GeoPen haloPen, GeoBrush geoBrush, string letter);
    private void DjM=(Feature feature, GeoCanvas canvas, GeoBrush geoBrush, GeoPen haloPen);
    public int get_WellPointIndex();
    public void set_WellPointIndex(int value);
    protected virtual void DrawCore(IEnumerable`1<Feature> features, GeoCanvas canvas, Collection`1<SimpleCandidate> labelsInThisLayer, Collection`1<SimpleCandidate> labelsInAllLayers);
    protected virtual void DrawSampleCore(GeoCanvas canvas, DrawingRectangleF drawingExtent);
    private RectangleShape OxU=(DrawingRectangleF drawingRectangle, GeoCanvas canvas);
    private void DzM=(Feature feature, GeoCanvas canvas, GeoPen geoPen, GeoBrush geoBrush);
}
public class ThinkGeo.Core.WfsFeatureLayer : FeatureLayer {
    public string LastXmlResponse { get; }
    public string ServiceLocationUrl { get; public set; }
    public string TypeName { get; public set; }
    public int TimeoutInSeconds { get; public set; }
    public bool HasBoundingBox { get; }
    public IWebProxy WebProxy { get; public set; }
    public WfsFeatureLayer(string serviceLocationUrl, string typeName);
    public string get_LastXmlResponse();
    public string get_ServiceLocationUrl();
    public void set_ServiceLocationUrl(string value);
    public string get_TypeName();
    public void set_TypeName(string value);
    public int get_TimeoutInSeconds();
    public void set_TimeoutInSeconds(int value);
    public virtual bool get_HasBoundingBox();
    public IWebProxy get_WebProxy();
    public void set_WebProxy(IWebProxy value);
    public void add_SendingWebRequest(EventHandler`1<SendingWebRequestEventArgs> value);
    public void remove_SendingWebRequest(EventHandler`1<SendingWebRequestEventArgs> value);
    public void add_SentWebRequest(EventHandler`1<SentWebRequestEventArgs> value);
    public void remove_SentWebRequest(EventHandler`1<SentWebRequestEventArgs> value);
    public static string GetCapabilities(string serviceLocationUrl);
    public static string GetCapabilities(Uri serverUri);
    public static string GetCapabilities(Uri serverUri, IWebProxy webProxy);
    public static Collection`1<string> GetLayers(string serviceLocationUrl);
    public static Collection`1<string> GetLayers(Uri serverUri, IWebProxy webProxy);
    public static Collection`1<string> GetLayers(Uri serverUri);
}
public class ThinkGeo.Core.WfsFeatureSource : FeatureSource {
    private static string 0yM=;
    private static string FTA=;
    private static string FjA=;
    private static Dictionary`2<string, Dictionary`2<string, string>> KjA=;
    [ObfuscationAttribute]
private string version;
    [ObfuscationAttribute]
private WfsNamespace wfsNamespace;
    [ObfuscationAttribute]
private IWebProxy webProxy;
    private Collection`1<FeatureSourceColumn> 1CM=;
    private string GTA=;
    [ObfuscationAttribute]
private string lastXmlResponse;
    [ObfuscationAttribute]
private string serviceLocationUrl;
    [ObfuscationAttribute]
private int timeoutInSeconds;
    [ObfuscationAttribute]
private string typeName;
    [CompilerGeneratedAttribute]
private EventHandler`1<SendingWebRequestEventArgs> whQ=;
    [CompilerGeneratedAttribute]
private EventHandler`1<SentWebRequestEventArgs> wxQ=;
    [CompilerGeneratedAttribute]
private EventHandler`1<RequestingDataWfsFeatureSourceEventArgs> 2CM=;
    [CompilerGeneratedAttribute]
private EventHandler`1<RequestedDataWfsFeatureSourceEventArgs> 2SM=;
    public string ServiceLocationUrl { get; public set; }
    public WfsNamespace WfsNamespace { get; public set; }
    public string TypeName { get; public set; }
    public string LastXmlResponse { get; }
    public int TimeoutInSeconds { get; public set; }
    public IWebProxy WebProxy { get; public set; }
    public WfsFeatureSource(string serviceLocationUrl, string typeName);
    private static WfsFeatureSource();
    [CompilerGeneratedAttribute]
public void add_SendingWebRequest(EventHandler`1<SendingWebRequestEventArgs> value);
    [CompilerGeneratedAttribute]
public void remove_SendingWebRequest(EventHandler`1<SendingWebRequestEventArgs> value);
    [CompilerGeneratedAttribute]
public void add_SentWebRequest(EventHandler`1<SentWebRequestEventArgs> value);
    [CompilerGeneratedAttribute]
public void remove_SentWebRequest(EventHandler`1<SentWebRequestEventArgs> value);
    protected virtual bool CanGetBoundingBoxQuicklyCore();
    public string get_ServiceLocationUrl();
    public void set_ServiceLocationUrl(string value);
    public WfsNamespace get_WfsNamespace();
    public void set_WfsNamespace(WfsNamespace value);
    public string get_TypeName();
    public void set_TypeName(string value);
    public string get_LastXmlResponse();
    public int get_TimeoutInSeconds();
    public void set_TimeoutInSeconds(int value);
    public IWebProxy get_WebProxy();
    public void set_WebProxy(IWebProxy value);
    [CompilerGeneratedAttribute]
public void add_RequestingData(EventHandler`1<RequestingDataWfsFeatureSourceEventArgs> value);
    [CompilerGeneratedAttribute]
public void remove_RequestingData(EventHandler`1<RequestingDataWfsFeatureSourceEventArgs> value);
    protected virtual void OnRequestingData(RequestingDataWfsFeatureSourceEventArgs requestingDataWfsFeatureSourceEventArgs);
    [CompilerGeneratedAttribute]
public void add_RequestedData(EventHandler`1<RequestedDataWfsFeatureSourceEventArgs> value);
    [CompilerGeneratedAttribute]
public void remove_RequestedData(EventHandler`1<RequestedDataWfsFeatureSourceEventArgs> value);
    protected virtual void OnRequestedData(RequestedDataWfsFeatureSourceEventArgs requestedDataWfsFeatureSourceEventArgs);
    protected WebResponse SendWebRequest(WebRequest webRequest);
    protected virtual WebResponse SendWebRequestCore(WebRequest webRequest);
    protected virtual void OnSendingWebRequest(SendingWebRequestEventArgs e);
    protected virtual void OnSentWebRequest(SentWebRequestEventArgs e);
    public static string GetCapabilities(string serviceLocationUrl);
    public static string GetCapabilities(Uri serverUri);
    public static string GetCapabilities(Uri serverUri, IWebProxy webProxy);
    private static string KzA=(XmlDocument xmlDocument);
    private static void aR4=(string requestCapabilities, XmlDocument xmlDocument);
    private static XmlDocument 2yM=(string requestCapabilities);
    public static Collection`1<string> GetLayers(string serviceLocationUrl);
    public static Collection`1<string> GetLayers(Uri serverUri);
    public static Collection`1<string> GetLayers(Uri serverUri, IWebProxy webProxy);
    protected virtual void OpenCore();
    protected virtual void CloseCore();
    protected virtual RectangleShape GetBoundingBoxCore();
    protected virtual Collection`1<FeatureSourceColumn> GetColumnsCore();
    private void LDA=(XmlReader reader);
    protected virtual Collection`1<Feature> GetFeaturesByIdsCore(IEnumerable`1<string> ids, IEnumerable`1<string> returningColumnNames);
    protected virtual WellKnownType GetFirstFeaturesWellKnownTypeCore();
    protected virtual Collection`1<Feature> GetAllFeaturesCore(IEnumerable`1<string> returningColumnNames);
    protected virtual Collection`1<Feature> GetFeaturesInsideBoundingBoxCore(RectangleShape boundingBox, IEnumerable`1<string> returningColumnNames);
    private Stream GjA=(RectangleShape boundingBox, IEnumerable`1<string> returningColumnNames);
    private Stream GzA=(string requestString);
    private Feature 0CE=(XmlReader reader, IEnumerable`1<string> columnNames);
    private static string HDA=(XmlReader reader, string shapeTypeName, string coordinatesName, string version);
    private static string HTA=(XmlReader reader, string shapeTypeName, string coordinatesName, string version);
    private static string HjA=(XmlReader reader, string shapeTypeName, string coordinatesName, string version);
    private static string HzA=(XmlReader reader, string shapeTypeName, string coordinatesName, string version);
    private static string IDA=(XmlReader reader, string shapeTypeName, string coordinatesName, string version);
    private static string ITA=(XmlReader reader, string shapeTypeName, string coordinatesName, string version);
    private static string IjA=(string tempString, string version);
    private string IzA=();
    private string JDA=(RectangleShape boundingBox);
    private static string JTA=(string shapeType);
    private bool JjA=(string shapeType);
    protected virtual Collection`1<Feature> GetFeaturesByColumnValueCore(string columnName, string columnValue, IEnumerable`1<string> returningColumnNames);
    private XmlReader JzA=(Stream stream);
}
public enum ThinkGeo.Core.WfsNamespace : Enum {
    public int value__;
    public static WfsNamespace Null;
    public static WfsNamespace Ogc;
}
public class ThinkGeo.Core.WfsV2FeatureLayer : FeatureLayer {
    public string LastXmlResponse { get; }
    public string ServiceLocationUrl { get; public set; }
    public string TypeName { get; public set; }
    public int TimeoutInSeconds { get; public set; }
    public bool HasBoundingBox { get; }
    public IWebProxy WebProxy { get; public set; }
    public WfsV2FeatureLayer(string serviceLocationUrl, string typeName);
    public string get_LastXmlResponse();
    public string get_ServiceLocationUrl();
    public void set_ServiceLocationUrl(string value);
    public string get_TypeName();
    public void set_TypeName(string value);
    public int get_TimeoutInSeconds();
    public void set_TimeoutInSeconds(int value);
    public virtual bool get_HasBoundingBox();
    public IWebProxy get_WebProxy();
    public void set_WebProxy(IWebProxy value);
    public void add_SendingWebRequest(EventHandler`1<SendingWebRequestEventArgs> value);
    public void remove_SendingWebRequest(EventHandler`1<SendingWebRequestEventArgs> value);
    public void add_SentWebRequest(EventHandler`1<SentWebRequestEventArgs> value);
    public void remove_SentWebRequest(EventHandler`1<SentWebRequestEventArgs> value);
    public static string GetCapabilities(string serviceLocationUrl);
    public static string GetCapabilities(Uri serverUri);
    public static string GetCapabilities(Uri serverUri, IWebProxy webProxy);
    public static Collection`1<string> GetLayers(string serviceLocationUrl);
    public static Collection`1<string> GetLayers(Uri serverUri, IWebProxy webProxy);
    public static Collection`1<string> GetLayers(Uri serverUri);
}
public class ThinkGeo.Core.WfsV2FeatureSource : FeatureSource {
    private static string 0yM=;
    private static string FTA=;
    private static string FjA=;
    private static string FzA=;
    private static string GDA=;
    [ObfuscationAttribute]
private WfsNamespace wfsNamespace;
    [ObfuscationAttribute]
private IWebProxy webProxy;
    private Collection`1<FeatureSourceColumn> 1CM=;
    private string GTA=;
    [ObfuscationAttribute]
private string lastXmlResponse;
    [ObfuscationAttribute]
private string serviceLocationUrl;
    [ObfuscationAttribute]
private int timeoutInSeconds;
    [ObfuscationAttribute]
private string typeName;
    [CompilerGeneratedAttribute]
private EventHandler`1<SendingWebRequestEventArgs> whQ=;
    [CompilerGeneratedAttribute]
private EventHandler`1<SentWebRequestEventArgs> wxQ=;
    [CompilerGeneratedAttribute]
private EventHandler`1<RequestingDataWfsFeatureSourceEventArgs> 2CM=;
    [CompilerGeneratedAttribute]
private EventHandler`1<RequestedDataWfsFeatureSourceEventArgs> 2SM=;
    public string ServiceLocationUrl { get; public set; }
    public WfsNamespace WfsNamespace { get; public set; }
    public string TypeName { get; public set; }
    public string LastXmlResponse { get; }
    public int TimeoutInSeconds { get; public set; }
    public IWebProxy WebProxy { get; public set; }
    public WfsV2FeatureSource(string serviceLocationUrl, string typeName);
    [CompilerGeneratedAttribute]
public void add_SendingWebRequest(EventHandler`1<SendingWebRequestEventArgs> value);
    [CompilerGeneratedAttribute]
public void remove_SendingWebRequest(EventHandler`1<SendingWebRequestEventArgs> value);
    [CompilerGeneratedAttribute]
public void add_SentWebRequest(EventHandler`1<SentWebRequestEventArgs> value);
    [CompilerGeneratedAttribute]
public void remove_SentWebRequest(EventHandler`1<SentWebRequestEventArgs> value);
    protected virtual bool CanGetBoundingBoxQuicklyCore();
    public string get_ServiceLocationUrl();
    public void set_ServiceLocationUrl(string value);
    public WfsNamespace get_WfsNamespace();
    public void set_WfsNamespace(WfsNamespace value);
    public string get_TypeName();
    public void set_TypeName(string value);
    public string get_LastXmlResponse();
    public int get_TimeoutInSeconds();
    public void set_TimeoutInSeconds(int value);
    public IWebProxy get_WebProxy();
    public void set_WebProxy(IWebProxy value);
    [CompilerGeneratedAttribute]
public void add_RequestingData(EventHandler`1<RequestingDataWfsFeatureSourceEventArgs> value);
    [CompilerGeneratedAttribute]
public void remove_RequestingData(EventHandler`1<RequestingDataWfsFeatureSourceEventArgs> value);
    protected virtual void OnRequestingData(RequestingDataWfsFeatureSourceEventArgs requestingDataWfsFeatureSourceEventArgs);
    [CompilerGeneratedAttribute]
public void add_RequestedData(EventHandler`1<RequestedDataWfsFeatureSourceEventArgs> value);
    [CompilerGeneratedAttribute]
public void remove_RequestedData(EventHandler`1<RequestedDataWfsFeatureSourceEventArgs> value);
    protected virtual void OnRequestedData(RequestedDataWfsFeatureSourceEventArgs requestedDataWfsFeatureSourceEventArgs);
    protected WebResponse SendWebRequest(WebRequest webRequest);
    protected virtual WebResponse SendWebRequestCore(WebRequest webRequest);
    protected virtual void OnSendingWebRequest(SendingWebRequestEventArgs e);
    protected virtual void OnSentWebRequest(SentWebRequestEventArgs e);
    public static string GetCapabilities(string serviceLocationUrl);
    public static string GetCapabilities(Uri serverUri);
    public static XmlDocument GetCapabilities(Uri serverUri, IWebProxy webProxy);
    public static string GetCapabilitiesStringFromXml(XmlDocument xmlDocument);
    private static void aR4=(string requestCapabilities, XmlDocument xmlDocument);
    private static XmlDocument 2yM=(string requestCapabilities);
    public static Collection`1<string> GetLayers(string serviceLocationUrl);
    public static Collection`1<string> GetLayers(Uri serverUri);
    public static Collection`1<string> GetLayers(Uri serverUri, IWebProxy webProxy);
    protected virtual void OpenCore();
    protected virtual void CloseCore();
    protected virtual RectangleShape GetBoundingBoxCore();
    protected virtual Collection`1<FeatureSourceColumn> GetColumnsCore();
    protected virtual Collection`1<Feature> GetFeaturesByIdsCore(IEnumerable`1<string> ids, IEnumerable`1<string> returningColumnNames);
    protected virtual WellKnownType GetFirstFeaturesWellKnownTypeCore();
    public Collection`1<string> GetSupportedCrs();
    public string GetDefaultCrs();
    protected virtual Collection`1<Feature> GetAllFeaturesCore(IEnumerable`1<string> returningColumnNames);
    protected virtual Collection`1<Feature> GetFeaturesInsideBoundingBoxCore(RectangleShape boundingBox, IEnumerable`1<string> returningColumnNames);
    public string GetRequestUrlForFeatures(RectangleShape boundingBox, int count, int startIndex);
    public ValueTuple`2<int, Collection`1<Feature>> GetFeatures(string requestUrl);
    private Stream GjA=(RectangleShape boundingBox, IEnumerable`1<string> returningColumnNames);
    private Stream GzA=(string requestString);
    private Feature 0CE=(XmlReader reader, IEnumerable`1<string> columnNames);
    private static string HDA=(XmlReader reader, string shapeTypeName, string coordinatesName);
    private static string HTA=(XmlReader reader, string shapeTypeName, string coordinatesName);
    private static string HjA=(XmlReader reader, string shapeTypeName, string coordinatesName);
    private static string HzA=(XmlReader reader, string shapeTypeName, string coordinatesName);
    private static string IDA=(XmlReader reader, string shapeTypeName, string coordinatesName);
    private static string ITA=(XmlReader reader, string shapeTypeName, string coordinatesName);
    private static string IjA=(string tempString);
    private string IzA=();
    private string JDA=(RectangleShape boundingBox);
    private static string JTA=(string shapeType);
    private bool JjA=(string shapeType);
    protected virtual Collection`1<Feature> GetFeaturesByColumnValueCore(string columnName, string columnValue, IEnumerable`1<string> returningColumnNames);
    private XmlReader JzA=(Stream stream);
    [CompilerGeneratedAttribute]
private bool KDA=(XElement el);
    [CompilerGeneratedAttribute]
private bool KTA=(XElement el);
}
public class ThinkGeo.Core.WindBarbStyle : Style {
    [CompilerGeneratedAttribute]
private string tSM=;
    [CompilerGeneratedAttribute]
private string tiM=;
    [CompilerGeneratedAttribute]
private DrawingLevel tyM=;
    [CompilerGeneratedAttribute]
private float uCM=;
    [CompilerGeneratedAttribute]
private GeoPen uSM=;
    [CompilerGeneratedAttribute]
private GeoBrush uiM=;
    public string WindDirectionAngleColumnName { get; public set; }
    public string WindSpeedInKnotsColumnName { get; public set; }
    public DrawingLevel DrawingLevel { get; public set; }
    public float SymbolSize { get; public set; }
    public GeoPen Pen { get; public set; }
    public GeoBrush Brush { get; public set; }
    [CompilerGeneratedAttribute]
public string get_WindDirectionAngleColumnName();
    [CompilerGeneratedAttribute]
public void set_WindDirectionAngleColumnName(string value);
    [CompilerGeneratedAttribute]
public string get_WindSpeedInKnotsColumnName();
    [CompilerGeneratedAttribute]
public void set_WindSpeedInKnotsColumnName(string value);
    [CompilerGeneratedAttribute]
public DrawingLevel get_DrawingLevel();
    [CompilerGeneratedAttribute]
public void set_DrawingLevel(DrawingLevel value);
    [CompilerGeneratedAttribute]
public float get_SymbolSize();
    [CompilerGeneratedAttribute]
public void set_SymbolSize(float value);
    [CompilerGeneratedAttribute]
public GeoPen get_Pen();
    [CompilerGeneratedAttribute]
public void set_Pen(GeoPen value);
    [CompilerGeneratedAttribute]
public GeoBrush get_Brush();
    [CompilerGeneratedAttribute]
public void set_Brush(GeoBrush value);
    protected virtual void DrawCore(IEnumerable`1<Feature> features, GeoCanvas canvas, Collection`1<SimpleCandidate> labelsInThisLayer, Collection`1<SimpleCandidate> labelsInAllLayers);
    private static BaseShape uyM=(GeoCanvas canvas, PointShape centerPoint, float radius, Vertex lineEnd, int lineLocation, GkA= windBarbType, float symbolSize, double angle);
}
public enum ThinkGeo.Core.WkbByteOrder : Enum {
    public int value__;
    public static WkbByteOrder LittleEndian;
    public static WkbByteOrder BigEndian;
}
public class ThinkGeo.Core.WkbFileFeatureLayer : FeatureLayer {
    [ObfuscationAttribute]
private static int turnCount;
    [ObfuscationAttribute]
private int progressiveDrawingRecordsCount;
    public FileAccess ReadWriteMode { get; public set; }
    public string WkbPathFilename { get; public set; }
    public int ProgressiveDrawingRecordsCount { get; public set; }
    public bool HasBoundingBox { get; }
    public WkbFileFeatureLayer(string wkbPathFilename);
    public WkbFileFeatureLayer(string wkbPathFilename, FileAccess readWriteMode);
    public FileAccess get_ReadWriteMode();
    public void set_ReadWriteMode(FileAccess value);
    public string get_WkbPathFilename();
    public void set_WkbPathFilename(string value);
    public int get_ProgressiveDrawingRecordsCount();
    public void set_ProgressiveDrawingRecordsCount(int value);
    public virtual bool get_HasBoundingBox();
    public static void CreateWkbFile(string pathFilename, WkbFileType wkbFileType, IEnumerable`1<FeatureSourceColumn> columns, IEnumerable`1<Feature> features);
    public WkbFileType GetWkbFileType();
    protected virtual void DrawCore(GeoCanvas canvas, Collection`1<SimpleCandidate> labelsInAllLayers);
    private void eiQ=(GeoCanvas canvas, RectangleShape marginWorldExtent, Collection`1<SimpleCandidate> labelsInAllLayers, ZoomLevel currentZoomLevel, Collection`1<string> columnNames, WkbFileFeatureSource wkbFileFeatureSource, Collection`1<RectangleShape> smallBoxes, Collection`1<string> ids);
    private void eyQ=(GeoCanvas canvas, RectangleShape drawingExtent, Collection`1<SimpleCandidate> labelsInAllLayers, ZoomLevel currentZoomLevel, Collection`1<string> columnNames, Collection`1<string> columnNamesForDrawing, WkbFileFeatureSource shapeFileFeatureSource, Collection`1<string> idsToDraw, Collection`1<string> fieldNamesOutsideOfSource);
    private bool XSQ=(int progressPercentage, object userState, int featuresToDraw, int featuresDrawn);
    private static void fSQ=(Collection`1<RectangleShape> smallBoxes, Collection`1<Feature> resultFeatures, Collection`1<string> columnNames);
    private static void fiQ=(Collection`1<RectangleShape> smallBoxes, Collection`1<Feature> resultFeatures, Collection`1<string> columnNames);
    private static void fyQ=(Collection`1<RectangleShape> smallBoxes, Collection`1<Feature> resultFeatures, Collection`1<string> columnNames);
    private void LjA=(GeoCanvas canvas, Collection`1<SimpleCandidate> labelsInAllLayers, ZoomLevel currentZoomLevel, Collection`1<string> columnNames, RectangleShape marginWorldExtent);
    private static BaseShape rho=(ProjectionConverter projection, BaseShape shape);
}
public class ThinkGeo.Core.WkbFileFeatureSource : FeatureSource {
    [ObfuscationAttribute]
private RectangleShape boundingBox;
    [ObfuscationAttribute]
private int columnCount;
    [ObfuscationAttribute]
private Collection`1<FeatureSourceColumn> columns;
    [ObfuscationAttribute]
private int featureCount;
    [ObfuscationAttribute]
private int headerLength;
    [ObfuscationAttribute]
private FileAccess readWriteMode;
    [ObfuscationAttribute]
private RtreeSpatialIndex spatialIndex;
    [ObfuscationAttribute]
private int version;
    [ObfuscationAttribute]
private WkbFileType wkbFileType;
    [ObfuscationAttribute]
private string wkbPathFilename;
    [ObfuscationAttribute]
private BinaryReader wkbReader;
    [ObfuscationAttribute]
private BinaryWriter wkbWriter;
    [ObfuscationAttribute]
private BinaryReader wkxReader;
    [ObfuscationAttribute]
private BinaryWriter wkxWriter;
    [ObfuscationAttribute]
private static int cacheSize;
    [ObfuscationAttribute]
private long start;
    [ObfuscationAttribute]
private long end;
    [ObfuscationAttribute]
private Byte[] cache;
    [ObfuscationAttribute]
private int simplificationAreaInPixel;
    [ObfuscationAttribute]
private Collection`1<RectangleShape> simplifiedAreas;
    public int SimplificationAreaInPixel { get; public set; }
    public Collection`1<RectangleShape> SimplifiedAreas { get; }
    public FileAccess ReadWriteMode { get; public set; }
    public string WkbPathFilename { get; public set; }
    public WkbFileFeatureSource(string wkbPathFilename);
    public WkbFileFeatureSource(string wkbPathFilename, FileAccess readWriteMode);
    public int get_SimplificationAreaInPixel();
    public void set_SimplificationAreaInPixel(int value);
    public Collection`1<RectangleShape> get_SimplifiedAreas();
    public FileAccess get_ReadWriteMode();
    public void set_ReadWriteMode(FileAccess value);
    public string get_WkbPathFilename();
    public void set_WkbPathFilename(string value);
    public WkbFileType GetWkbFileType();
    protected virtual bool CanGetBoundingBoxQuicklyCore();
    protected virtual bool CanGetCountQuicklyCore();
    protected virtual void CloseCore();
    protected virtual Collection`1<Feature> GetFeaturesOutsideBoundingBoxCore(RectangleShape boundingBox, IEnumerable`1<string> returningColumnNames);
    protected virtual TransactionResult CommitTransactionCore(TransactionBuffer transactions);
    protected virtual Collection`1<Feature> GetAllFeaturesCore(IEnumerable`1<string> returningColumnNames);
    protected virtual RectangleShape GetBoundingBoxCore();
    protected virtual Collection`1<FeatureSourceColumn> GetColumnsCore();
    protected virtual long GetCountCore();
    protected virtual Collection`1<Feature> GetFeaturesByIdsCore(IEnumerable`1<string> ids, IEnumerable`1<string> returningColumnNames);
    protected virtual Collection`1<Feature> GetFeaturesInsideBoundingBoxCore(RectangleShape boundingBox, IEnumerable`1<string> returningColumnNames);
    protected virtual WellKnownType GetFirstFeaturesWellKnownTypeCore();
    protected virtual void OpenCore();
    public Collection`1<string> GetFeatureIdsForDrawing(RectangleShape boundingBox, double screenWidth, double screenHeight);
    protected virtual Collection`1<string> GetFeatureIdsForDrawingCore(RectangleShape boundingBox, double screenWidth, double screenHeight);
    protected virtual Collection`1<string> GetFeatureIdsCore();
    public static void CreateWkbFile(string pathFilename, WkbFileType wkbFileType, IEnumerable`1<FeatureSourceColumn> columns, IEnumerable`1<Feature> features);
    private static void LzA=(WkbFileType wkbFileType, string fileNameOnly, string filePath);
    private long MDA=(string id);
    private long MTA=(string id);
    private Feature MjA=(string id, IEnumerable`1<string> returningColumnNames);
    private void Dyk=();
}
public enum ThinkGeo.Core.WkbFileType : Enum {
    public int value__;
    public static WkbFileType Point;
    public static WkbFileType Polyline;
    public static WkbFileType Polygon;
    public static WkbFileType Hybrid;
}
public enum ThinkGeo.Core.WkbShapeType : Enum {
    public int value__;
    public static WkbShapeType Point;
    public static WkbShapeType LineString;
    public static WkbShapeType Polygon;
    public static WkbShapeType Multipoint;
    public static WkbShapeType Multiline;
    public static WkbShapeType Multipolygon;
    public static WkbShapeType GeometryCollection;
}
public class ThinkGeo.Core.WmsAsyncLayer : WebBasedAsyncLayer {
    private XmlDocument VR4=;
    [ObfuscationAttribute]
private string _crs;
    [ObfuscationAttribute]
private String[] _exceptionFormats;
    [ObfuscationAttribute]
private RectangleShape _currentExtent;
    [ObfuscationAttribute]
private WmsOnlineResource[] _wmsRequests;
    [ObfuscationAttribute]
private bool _hasParsedCapabilities;
    [ObfuscationAttribute]
private Collection`1<string> _serverCrsCollection;
    [ObfuscationAttribute]
private Collection`1<string> _serverLayerNames;
    [ObfuscationAttribute]
private Collection`1<string> _serverOutputFormats;
    [ObfuscationAttribute]
private Collection`1<string> _serverFeatureInfoFormats;
    [ObfuscationAttribute]
private Collection`1<string> _serverStyleNames;
    [ObfuscationAttribute]
private string _version;
    [ObfuscationAttribute]
private int _height;
    [ObfuscationAttribute]
private int _width;
    private WmsServerLayer Vh4=;
    private Collection`1<WmsServerLayer> Vx4=;
    [ObfuscationAttribute]
private Uri _uri;
    [ObfuscationAttribute]
private WmsAxisOrder _axisOrder;
    [ObfuscationAttribute]
private string _hrefNamespace;
    [ObfuscationAttribute]
private String[] _availableHrefNamespace;
    [ObfuscationAttribute]
private bool _fastMode;
    private static object WB4=;
    [CompilerGeneratedAttribute]
private EventHandler`1<RequestedImageExceptionEventArgs> WR4=;
    [CompilerGeneratedAttribute]
private Collection`1<string> Wh4=;
    [CompilerGeneratedAttribute]
private Collection`1<string> Wx4=;
    [CompilerGeneratedAttribute]
private bool XB4=;
    [CompilerGeneratedAttribute]
private string XR4=;
    [CompilerGeneratedAttribute]
private string Xh4=;
    [CompilerGeneratedAttribute]
private Dictionary`2<string, string> OB4=;
    [CompilerGeneratedAttribute]
private TimeSpan Xx4=;
    public Collection`1<string> ActiveLayerNames { get; }
    public Collection`1<string> ActiveStyleNames { get; }
    public Uri Uri { get; public set; }
    public string Version { get; }
    public bool IsTransparent { get; public set; }
    public string OutputFormat { get; public set; }
    public string Crs { get; public set; }
    public string Exceptions { get; public set; }
    public Dictionary`2<string, string> Parameters { get; }
    public WmsAxisOrder AxisOrder { get; public set; }
    public bool FastMode { get; public set; }
    public TimeSpan CapabilitiesCacheTimeout { get; public set; }
    public bool HasBoundingBox { get; }
    public WmsAsyncLayer(Uri uri);
    public WmsAsyncLayer(Uri uri, IWebProxy webProxy);
    public WmsAsyncLayer(Uri uri, IWebProxy webProxy, string crs, WmsAxisOrder axisOrder, string version, bool fastMode);
    public WmsAsyncLayer(Collection`1<WmsServerLayer> flatWmsServerLayers);
    private static WmsAsyncLayer();
    [CompilerGeneratedAttribute]
public void add_RequestedImageException(EventHandler`1<RequestedImageExceptionEventArgs> value);
    [CompilerGeneratedAttribute]
public void remove_RequestedImageException(EventHandler`1<RequestedImageExceptionEventArgs> value);
    protected virtual void OnRequestedImageException(RequestedImageExceptionEventArgs e);
    [CompilerGeneratedAttribute]
public sealed virtual Collection`1<string> get_ActiveLayerNames();
    [CompilerGeneratedAttribute]
public sealed virtual Collection`1<string> get_ActiveStyleNames();
    public sealed virtual Uri get_Uri();
    public sealed virtual void set_Uri(Uri value);
    public sealed virtual string get_Version();
    [CompilerGeneratedAttribute]
public sealed virtual bool get_IsTransparent();
    [CompilerGeneratedAttribute]
public sealed virtual void set_IsTransparent(bool value);
    [CompilerGeneratedAttribute]
public sealed virtual string get_OutputFormat();
    [CompilerGeneratedAttribute]
public sealed virtual void set_OutputFormat(string value);
    public sealed virtual string get_Crs();
    public sealed virtual void set_Crs(string value);
    [CompilerGeneratedAttribute]
public sealed virtual string get_Exceptions();
    [CompilerGeneratedAttribute]
public sealed virtual void set_Exceptions(string value);
    [CompilerGeneratedAttribute]
public sealed virtual Dictionary`2<string, string> get_Parameters();
    public sealed virtual WmsAxisOrder get_AxisOrder();
    public sealed virtual void set_AxisOrder(WmsAxisOrder value);
    public sealed virtual bool get_FastMode();
    public sealed virtual void set_FastMode(bool value);
    [CompilerGeneratedAttribute]
public sealed virtual TimeSpan get_CapabilitiesCacheTimeout();
    [CompilerGeneratedAttribute]
public sealed virtual void set_CapabilitiesCacheTimeout(TimeSpan value);
    public virtual bool get_HasBoundingBox();
    public Collection`1<WmsServerLayer> GetServerLayers();
    public Collection`1<string> GetServerStyleNames();
    public Collection`1<string> GetServerOutputFormats();
    public Collection`1<string> GetServerCrsCollection();
    public Collection`1<string> GetServerExceptionFormats();
    public string GetServiceVersion();
    public string GetServiceBaseUrl();
    public Collection`1<string> GetServerFeatureInfoFormats();
    public string GetServerCapabilitiesXml();
    public string GetRequestUrl(RectangleShape worldExtent, int canvasWidth, int canvasHeight);
    protected virtual string GetRequestUrlCore(RectangleShape worldExtent, int canvasWidth, int canvasHeight);
    [AsyncStateMachineAttribute("ThinkGeo.Core.WmsAsyncLayer/fz8=")]
protected virtual Task OpenAsyncCore(CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("ThinkGeo.Core.WmsAsyncLayer/ZT8=")]
protected virtual Task CloseAsyncCore(CancellationToken cancellationToken);
    protected virtual RectangleShape GetBoundingBoxCore();
    [AsyncStateMachineAttribute("ThinkGeo.Core.WmsAsyncLayer/aj8=")]
protected virtual Task DrawAsyncCore(GeoCanvas canvas, Collection`1<SimpleCandidate> labelsInAllLayers);
    private bool sx0=();
    private static int YB4=(string texts, int fontSize);
    private static string xhQ=(XmlDocument xmlDocument);
    private static string YR4=(string message, int width);
    private WmsOnlineResource Yh4=();
    private void Yx4=();
    private void ZB4=(WmsServerLayer serverLayer);
    private void ZR4=(WmsServerLayer serverLayer);
    private void Zh4=(WmsServerLayer serverLayer);
    private void Zx4=(WmsServerLayer layer);
    [AsyncStateMachineAttribute("ThinkGeo.Core.WmsAsyncLayer/gD8=")]
private Task aB4=(string url, CancellationToken cancellationToken);
    private static void aR4=(string requestCapabilities, XmlDocument xmlDocument);
    [AsyncStateMachineAttribute("ThinkGeo.Core.WmsAsyncLayer/bz8=")]
private Task`1<XmlDocument> ah4=(string requestCapabilities);
    [AsyncStateMachineAttribute("ThinkGeo.Core.WmsAsyncLayer/ez8=")]
private Task`1<XmlDocument> ax4=(string requestCapabilities, IWebProxy proxy, ICredentials credentials, CancellationToken cancellationToken);
    private void bB4=(XmlDocument xmlDocument, XmlNamespaceManager namespaceManager);
    private static string bR4=(XmlNode node, string nodeName, XmlNamespaceManager namespaceManager);
    private void bh4=(XmlNode nodeCapability, XmlNamespaceManager namespaceManager);
    private void bx4=(XmlNode xmlRequestNode, XmlNamespaceManager namespaceManager);
    private WmsServerLayer cB4=(XmlNode xmlLayer, XmlNamespaceManager namespaceManager);
    private XmlAttribute cR4=(XmlNode xmlNode);
    private RectangleShape ch4=(XmlNode xmlLayer, XmlNamespaceManager namespaceManager);
    private void cx4=(XmlNode xnException, XmlNamespaceManager namespaceManager);
    private void dB4=(HttpRequestMessage httpRequestMessage);
    private static Collection`1<string> dR4=(IEnumerable`1<string> collection);
    private static Collection`1<WmsServerLayer> dR4=(IEnumerable`1<WmsServerLayer> collection);
    private void dh4=(string propertyName);
    protected virtual string BuildWmsGetFeatureInfoUri(ScreenPointF screenPointF, string infoFormat, int maxFeatures);
    [AsyncStateMachineAttribute("ThinkGeo.Core.WmsAsyncLayer/dT8=")]
public Task`1<Dictionary`2<string, Collection`1<Feature>>> GetFeatureInfoAsync(ScreenPointF screenPointF, int maxFeatures, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("ThinkGeo.Core.WmsAsyncLayer/dj8=")]
public Task`1<Dictionary`2<string, Collection`1<Feature>>> GetFeatureInfoAsync(ScreenPointF screenPointF, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("ThinkGeo.Core.WmsAsyncLayer/dz8=")]
public Task`1<Dictionary`2<string, Collection`1<Feature>>> GetFeatureInfoAsync(ScreenPointF screenPointF, string infoFormat, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("ThinkGeo.Core.WmsAsyncLayer/cj8=")]
public Task`1<Dictionary`2<string, Collection`1<Feature>>> GetFeatureInfo(ScreenPointF screenPointF, int maxFeatures, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("ThinkGeo.Core.WmsAsyncLayer/eT8=")]
public Task`1<Dictionary`2<string, Collection`1<Feature>>> GetFeatureInfoAsync(ScreenPointF screenPointF, string infoFormat, int maxFeatures, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("ThinkGeo.Core.WmsAsyncLayer/ej8=")]
protected virtual Task`1<Dictionary`2<string, Collection`1<Feature>>> GetFeatureInfoAsyncCore(ScreenPointF screenPointF, string infoFormat, int maxFeatures, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("ThinkGeo.Core.WmsAsyncLayer/Zj8=")]
protected virtual Task`1<Byte[]> DownloadImageAsyncCore(double width, double height, double scaleFactor, RectangleShape extent, GeographyUnit mapUnit, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("ThinkGeo.Core.WmsAsyncLayer/fD8=")]
internal Task`1<Dictionary`2<string, Collection`1<Feature>>> dx4=(HttpRequestMessage request, CancellationToken cancellationToken);
    internal Dictionary`2<string, Collection`1<Feature>> eB4=(XmlDocument xmlDocument);
    [DebuggerHiddenAttribute]
[CompilerGeneratedAttribute]
private Task Ah4=(CancellationToken cancellationToken);
    [CompilerGeneratedAttribute]
[DebuggerHiddenAttribute]
private Task Ax4=(CancellationToken cancellationToken);
}
public enum ThinkGeo.Core.WmsAxisOrder : Enum {
    public int value__;
    public static WmsAxisOrder Default;
    public static WmsAxisOrder XY;
    public static WmsAxisOrder YX;
}
public class ThinkGeo.Core.WmsLayerStyle : object {
    public WmsStyleLegend LengendUrl;
    public WmsOnlineResource StyleSheetUrl;
    [ObfuscationAttribute]
private string mAbstract;
    [ObfuscationAttribute]
private string name;
    [ObfuscationAttribute]
private string title;
    public string Title { get; public set; }
    public string Name { get; public set; }
    unknown string Abstract {public set; }
    public WmsLayerStyle(string name);
    public WmsLayerStyle(string name, string title);
    public string get_Title();
    public void set_Title(string value);
    public string get_Name();
    public void set_Name(string value);
    public void set_Abstract(string value);
}
[ObfuscationAttribute]
public class ThinkGeo.Core.WmsOnlineResource : ValueType {
    [ObfuscationAttribute]
private string onlineResource;
    [ObfuscationAttribute]
private string type;
    public string Type { get; public set; }
    public string OnlineResource { get; public set; }
    public WmsOnlineResource(string onlineResource, string type);
    public string get_Type();
    public void set_Type(string value);
    public string get_OnlineResource();
    public void set_OnlineResource(string value);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
}
public class ThinkGeo.Core.WmsServerLayer : object {
    [ObfuscationAttribute]
private RectangleShape boudingBox;
    [ObfuscationAttribute]
private int cascaded;
    [ObfuscationAttribute]
private WmsServerLayer[] childLayers;
    [ObfuscationAttribute]
private String[] crs;
    [ObfuscationAttribute]
private int fixedHeight;
    [ObfuscationAttribute]
private int fixedWidth;
    [ObfuscationAttribute]
private String[] keyWords;
    [ObfuscationAttribute]
private string mAbstract;
    [ObfuscationAttribute]
private double maxScale;
    [ObfuscationAttribute]
private double minScale;
    [ObfuscationAttribute]
private string name;
    [ObfuscationAttribute]
private bool noSubsets;
    [ObfuscationAttribute]
private bool opaque;
    [ObfuscationAttribute]
private bool queryable;
    [ObfuscationAttribute]
private WmsLayerStyle[] styles;
    [ObfuscationAttribute]
private string title;
    public int Cascaded { get; public set; }
    public double MinScale { get; public set; }
    public double MaxScale { get; public set; }
    public string Title { get; public set; }
    public string Name { get; public set; }
    public string Abstract { get; public set; }
    public bool Queryable { get; public set; }
    public bool Opaque { get; public set; }
    public bool NoSubsets { get; public set; }
    public int FixedWidth { get; public set; }
    public int FixedHeight { get; public set; }
    public String[] KeyWords { get; public set; }
    public WmsLayerStyle[] Styles { get; public set; }
    public String[] Crs { get; public set; }
    public WmsServerLayer[] ChildLayers { get; public set; }
    public RectangleShape BoudingBox { get; public set; }
    public int get_Cascaded();
    public void set_Cascaded(int value);
    public double get_MinScale();
    public void set_MinScale(double value);
    public double get_MaxScale();
    public void set_MaxScale(double value);
    public string get_Title();
    public void set_Title(string value);
    public string get_Name();
    public void set_Name(string value);
    public string get_Abstract();
    public void set_Abstract(string value);
    public bool get_Queryable();
    public void set_Queryable(bool value);
    public bool get_Opaque();
    public void set_Opaque(bool value);
    public bool get_NoSubsets();
    public void set_NoSubsets(bool value);
    public int get_FixedWidth();
    public void set_FixedWidth(int value);
    public int get_FixedHeight();
    public void set_FixedHeight(int value);
    public String[] get_KeyWords();
    public void set_KeyWords(String[] value);
    public WmsLayerStyle[] get_Styles();
    public void set_Styles(WmsLayerStyle[] value);
    public String[] get_Crs();
    public void set_Crs(String[] value);
    public WmsServerLayer[] get_ChildLayers();
    public void set_ChildLayers(WmsServerLayer[] value);
    public RectangleShape get_BoudingBox();
    public void set_BoudingBox(RectangleShape value);
    public WmsServerLayer Clone();
}
public class ThinkGeo.Core.WmsStyleLegend : ValueType {
    [ObfuscationAttribute]
private int height;
    [ObfuscationAttribute]
private int width;
    public WmsOnlineResource OnlineResource;
    unknown int Width {public set; }
    unknown int Height {public set; }
    public void set_Width(int value);
    public void set_Height(int value);
}
public enum ThinkGeo.Core.WmsTileType : Enum {
    public int value__;
    public static WmsTileType Default;
    public static WmsTileType MultiTile;
    public static WmsTileType SingleTile;
}
public static class ThinkGeo.Core.WmsUtil : object {
    public static string VERSION_1_3_0;
    public static string VERSION_1_1_1;
    public static string GetMap;
    private static WmsUtil();
    public static WmsAxisOrder GetAxisOrder(WmsAxisOrder axisOrder, string wmsVersion, string crs);
    public static WmsOnlineResource GetBaseUrl(WmsOnlineResource[] wmsRequests);
    public static string GetRequestUrl(IWmsEntity wmsRasterSource, string baseUrl, RectangleShape worldExtent, int canvasWidth, int canvasHeight);
    private static bool sx0=(string version);
    private static Dictionary`2<string, string> tB0=(string query);
}
public class ThinkGeo.Core.WmtsAsyncLayer : XyzTileAsyncLayer {
    [ObfuscationAttribute]
private Collection`1<Uri> serverUris;
    [ObfuscationAttribute]
private Uri serverUri;
    [ObfuscationAttribute]
private Dictionary`2<string, WmtsTileMatrixSet> tileMatrixSets;
    [ObfuscationAttribute]
private Collection`1<WmtsServerLayer> wmtsServerLayers;
    [ObfuscationAttribute]
private string activeLayerName;
    [ObfuscationAttribute]
private string activeStyleName;
    [ObfuscationAttribute]
private WmtsServerEncodingType wmtsServerEncodingType;
    [ObfuscationAttribute]
private string tileMatrixSetName;
    [ObfuscationAttribute]
private Dictionary`2<string, string> parameters;
    [ObfuscationAttribute]
private string outputFormat;
    [ObfuscationAttribute]
private double lowerScale;
    [ObfuscationAttribute]
private double upperScale;
    [ObfuscationAttribute]
private XmlDocument xmlDoc;
    [ObfuscationAttribute]
private TimeSpan capabilitesCacheTimeout;
    [ObfuscationAttribute]
private double wmtsConversionFactorForMeter;
    [ObfuscationAttribute]
private Dictionary`2<string, string> dimensions;
    [ObfuscationAttribute]
private WmtsAxisOrder axisOrder;
    [ObfuscationAttribute]
private RasterTileCache projectedTileCache;
    [ObfuscationAttribute]
private bool isCacheOnly;
    [ObfuscationAttribute]
private Dictionary`2<WmtsServerEncodingType, string> getTileEncodingTypes;
    [ObsoleteAttribute("This property is obsoleted and will be removed after v14.4. Please use ServerUri instead.")]
public Collection`1<Uri> ServerUris { get; }
    public Uri ServerUri { get; public set; }
    private Dictionary`2<string, string> ex4= { get; private set; }
    public TimeSpan CapabilitesCacheTimeout { get; public set; }
    public string ActiveLayerName { get; public set; }
    public WmtsServerEncodingType WmtsServerEncodingType { get; public set; }
    public Collection`1<WmtsServerLayer> WmtsServerLayers { get; public set; }
    public string ActiveStyleName { get; public set; }
    public Dictionary`2<string, string> Parameters { get; }
    public string OutputFormat { get; public set; }
    public double LowerScale { get; public set; }
    public double UpperScale { get; public set; }
    public string TileMatrixSetName { get; public set; }
    public WmtsAxisOrder AxisOrder { get; public set; }
    [ObsoleteAttribute("This property is obsoleted and will be removed after v14.3. Please use ProjectionConverterFromServerProjection instead. ")]
public ProjectionConverter ProjectionConverter { get; public set; }
    public RasterTileCache ProjectedTileCache { get; public set; }
    public bool IsCacheOnly { get; public set; }
    public Dictionary`2<string, WmtsTileMatrixSet> TileMatrixSets { get; }
    public bool HasBoundingBox { get; }
    public WmtsAsyncLayer(Uri serverUri);
    public WmtsAsyncLayer(Uri serverUri, IWebProxy webProxy);
    public WmtsAsyncLayer(Uri serverUri, IWebProxy webProxy, WmtsServerEncodingType wmtsServerEncodingType);
    public Collection`1<Uri> get_ServerUris();
    public Uri get_ServerUri();
    public void set_ServerUri(Uri value);
    private Dictionary`2<string, string> eR4=();
    private void eh4=(Dictionary`2<string, string> value);
    public TimeSpan get_CapabilitesCacheTimeout();
    public void set_CapabilitesCacheTimeout(TimeSpan value);
    public string get_ActiveLayerName();
    public void set_ActiveLayerName(string value);
    public WmtsServerEncodingType get_WmtsServerEncodingType();
    public void set_WmtsServerEncodingType(WmtsServerEncodingType value);
    public Collection`1<WmtsServerLayer> get_WmtsServerLayers();
    public void set_WmtsServerLayers(Collection`1<WmtsServerLayer> value);
    public string get_ActiveStyleName();
    public void set_ActiveStyleName(string value);
    public Dictionary`2<string, string> get_Parameters();
    public string get_OutputFormat();
    public void set_OutputFormat(string value);
    public double get_LowerScale();
    public void set_LowerScale(double value);
    public double get_UpperScale();
    public void set_UpperScale(double value);
    public string get_TileMatrixSetName();
    public void set_TileMatrixSetName(string value);
    public WmtsAxisOrder get_AxisOrder();
    public void set_AxisOrder(WmtsAxisOrder value);
    public ProjectionConverter get_ProjectionConverter();
    public void set_ProjectionConverter(ProjectionConverter value);
    public RasterTileCache get_ProjectedTileCache();
    public void set_ProjectedTileCache(RasterTileCache value);
    public bool get_IsCacheOnly();
    public void set_IsCacheOnly(bool value);
    public Dictionary`2<string, WmtsTileMatrixSet> get_TileMatrixSets();
    [AsyncStateMachineAttribute("ThinkGeo.Core.WmtsAsyncLayer/mj8=")]
protected virtual Task OpenAsyncCore(CancellationToken cancellationToken);
    public virtual bool get_HasBoundingBox();
    public RectangleShape GetWGS84BoundingBox();
    protected virtual RectangleShape GetBoundingBoxCore();
    public Collection`1<Uri> GetRequestUris(RectangleShape requestExtent, int canvasWidth, int canvasHeight);
    protected virtual Collection`1<Uri> GetRequestUrisCore(RectangleShape requestExtent, int canvasWidth, int canvasHeight);
    public string GetServerCapabilitiesXml();
    public Collection`1<string> GetServerLayerNames();
    public Collection`1<string> GetServerLayerStyles();
    public Collection`1<string> GetServerTileMatrixSetNames();
    public Collection`1<WmtsServerEncodingType> GetServerEncodingType();
    public Collection`1<string> GetLayerOutputFormats(string layerName);
    protected virtual Task CloseAsyncCore(CancellationToken cancellationToken);
    private Uri 8h0=();
    private Tuple`2<string, string> fB4=();
    [AsyncStateMachineAttribute("ThinkGeo.Core.WmtsAsyncLayer/jz8=")]
private Task fR4=(CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("ThinkGeo.Core.WmtsAsyncLayer/mD8=")]
private Task`1<bool> fh4=(string kvpUrl, CancellationToken cancellationToken);
    public bool RemoveCachedCapability();
    private string fx4=();
    private void bB4=(XmlElement element, XmlNamespaceManager namespaceManager);
    private void gB4=(XmlNode operationTileNode, XmlNamespaceManager namespaceManager);
    public ZoomLevelSet GetZoomLevelSet(string tileMatrixSetName);
    public TileMatrix GetTileMatrix(string tileMatrixSetName, double scale);
    private void gR4=(XmlNode node, XmlNamespaceManager namespaceManager);
    private void gh4=(T& left, T& top);
    private void gx4=(XmlNode node, XmlNamespaceManager namespaceManager);
    [AsyncStateMachineAttribute("ThinkGeo.Core.WmtsAsyncLayer/gz8=")]
protected virtual Task DrawAsyncCore(GeoCanvas canvas, Collection`1<SimpleCandidate> labelsInAllLayers);
    private int hB4=(double newWidth, RectangleShape newTileExtent, GeographyUnit mapUnit);
    protected virtual void DrawExceptionCore(GeoCanvas canvas, Exception e);
    private string hR4=(WmtsServerLayer serverLayer, string zoomLevel, long y, long x, string tileMatrixSetName, int resourceURLIndex);
    public string GetRequestUri(long x, long y, int zoomLevel);
    private string hh4=(string requestString);
    [AsyncStateMachineAttribute("ThinkGeo.Core.WmtsAsyncLayer/kz8=")]
private Task`1<CloudRasterTileInfo> hx4=(MatrixCell cell, int zoomLevelIndex, int tileSize, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("ThinkGeo.Core.WmtsAsyncLayer/lz8=")]
private Task`1<RasterTile> iB4=(int zoomLevel, long x, long y, CancellationToken cancellationToken);
    protected virtual Task`1<string> GetImageUriAsyncCore(int zoomLevel, long x, long y, float resolutionFactor);
    [DebuggerHiddenAttribute]
[CompilerGeneratedAttribute]
private Task Ah4=(CancellationToken cancellationToken);
    [CompilerGeneratedAttribute]
private bool iR4=(WmtsServerLayer l);
    [CompilerGeneratedAttribute]
private bool ih4=(WmtsServerLayer l);
    [CompilerGeneratedAttribute]
private bool ix4=(WmtsServerLayer l);
}
public enum ThinkGeo.Core.WmtsAxisOrder : Enum {
    public int value__;
    public static WmtsAxisOrder XY;
    public static WmtsAxisOrder YX;
}
public class ThinkGeo.Core.WmtsDimension : object {
    [ObfuscationAttribute]
private string defaultValue;
    [ObfuscationAttribute]
private string identifier;
    [ObfuscationAttribute]
private Collection`1<string> values;
    public string DefaultValue { get; public set; }
    public string Identifier { get; public set; }
    public Collection`1<string> Values { get; }
    public string get_DefaultValue();
    public void set_DefaultValue(string value);
    public string get_Identifier();
    public void set_Identifier(string value);
    public Collection`1<string> get_Values();
}
public class ThinkGeo.Core.WmtsRowColumnRange : object {
    [ObfuscationAttribute]
private double minTileRow;
    [ObfuscationAttribute]
private double maxTileRow;
    [ObfuscationAttribute]
private double minTileColumn;
    [ObfuscationAttribute]
private double maxTileColumn;
    [ObfuscationAttribute]
private string id;
    public double MinTileRow { get; }
    public double MaxTileRow { get; }
    public double MinTileColumn { get; }
    public double MaxTileColumn { get; }
    public string Id { get; }
    public WmtsRowColumnRange(string id, double minTileRow, double maxTileRow, double minTileColumn, double maxTileColumn);
    public double get_MinTileRow();
    public double get_MaxTileRow();
    public double get_MinTileColumn();
    public double get_MaxTileColumn();
    public string get_Id();
}
public enum ThinkGeo.Core.WmtsServerEncodingType : Enum {
    public int value__;
    public static WmtsServerEncodingType Kvp;
    public static WmtsServerEncodingType Restful;
    public static WmtsServerEncodingType Unknown;
}
public class ThinkGeo.Core.WmtsServerLayer : object {
    [ObfuscationAttribute]
private string name;
    [ObfuscationAttribute]
private RectangleShape wgs84BoundingBox;
    [ObfuscationAttribute]
private RectangleShape boundingBox;
    [ObfuscationAttribute]
private string style;
    [ObfuscationAttribute]
private Collection`1<string> formats;
    [ObfuscationAttribute]
private String[] infoFormats;
    [ObfuscationAttribute]
private String[] tileMatrixLinkNames;
    [ObfuscationAttribute]
private Collection`1<WmtsRowColumnRange> rowColumnRange;
    [ObfuscationAttribute]
private WmtsURLTemplate[] resourceURL;
    [ObfuscationAttribute]
private WmtsDimension[] dimension;
    public string Name { get; public set; }
    public RectangleShape WGS84BoundingBox { get; public set; }
    public RectangleShape BoundingBox { get; public set; }
    public string Style { get; public set; }
    public Collection`1<string> Formats { get; public set; }
    public Collection`1<WmtsRowColumnRange> RowColumnRange { get; public set; }
    public String[] InfoFormats { get; public set; }
    public String[] TileMatrixLinkNames { get; public set; }
    public WmtsDimension[] Dimension { get; public set; }
    public WmtsURLTemplate[] ResourceURL { get; public set; }
    public string get_Name();
    public void set_Name(string value);
    public RectangleShape get_WGS84BoundingBox();
    public void set_WGS84BoundingBox(RectangleShape value);
    public RectangleShape get_BoundingBox();
    public void set_BoundingBox(RectangleShape value);
    public string get_Style();
    public void set_Style(string value);
    public Collection`1<string> get_Formats();
    public void set_Formats(Collection`1<string> value);
    public Collection`1<WmtsRowColumnRange> get_RowColumnRange();
    public void set_RowColumnRange(Collection`1<WmtsRowColumnRange> value);
    public String[] get_InfoFormats();
    public void set_InfoFormats(String[] value);
    public String[] get_TileMatrixLinkNames();
    public void set_TileMatrixLinkNames(String[] value);
    public WmtsDimension[] get_Dimension();
    public void set_Dimension(WmtsDimension[] value);
    public WmtsURLTemplate[] get_ResourceURL();
    public void set_ResourceURL(WmtsURLTemplate[] value);
}
[ObsoleteAttribute("This type is obsoleted and will be removed after v14.4. Please use WmtsServerEncodingType instead")]
public enum ThinkGeo.Core.WmtsSeverEncodingType : Enum {
    public int value__;
    public static WmtsSeverEncodingType Kvp;
    public static WmtsSeverEncodingType Restful;
    [ObsoleteAttribute("This property is obsoleted and will be removed after v14.4. In most cases, you don't need to specify the WmtsServerEncodingType.")]
public static WmtsSeverEncodingType KvpRestful;
    public static WmtsSeverEncodingType Unknown;
}
public class ThinkGeo.Core.WmtsTileMatrixSet : object {
    [ObfuscationAttribute]
private string id;
    [ObfuscationAttribute]
private string crs;
    [ObfuscationAttribute]
private RectangleShape boundingBox;
    [ObfuscationAttribute]
private Collection`1<TileMatrix> tileMatrices;
    public Collection`1<TileMatrix> TileMatrices { get; }
    public string Id { get; public set; }
    public string Crs { get; public set; }
    public RectangleShape BoundingBox { get; public set; }
    public WmtsTileMatrixSet(string id, string crs);
    public Collection`1<TileMatrix> get_TileMatrices();
    public string get_Id();
    public void set_Id(string value);
    public string get_Crs();
    public void set_Crs(string value);
    public RectangleShape get_BoundingBox();
    public void set_BoundingBox(RectangleShape value);
}
public class ThinkGeo.Core.WmtsURLTemplate : object {
    [ObfuscationAttribute]
private string format;
    [ObfuscationAttribute]
private string resourceType;
    [ObfuscationAttribute]
private string template;
    public string Format { get; public set; }
    public string ResourceType { get; public set; }
    public string Template { get; public set; }
    public string get_Format();
    public void set_Format(string value);
    public string get_ResourceType();
    public void set_ResourceType(string value);
    public string get_Template();
    public void set_Template(string value);
}
public class ThinkGeo.Core.WorldFile : object {
    [ObfuscationAttribute]
private float horizontalResolution;
    [ObfuscationAttribute]
private float rotationRow;
    [ObfuscationAttribute]
private float rotationColumn;
    [ObfuscationAttribute]
private float verticalResolution;
    [ObfuscationAttribute]
private float upperLeftX;
    [ObfuscationAttribute]
private float upperLeftY;
    public float HorizontalResolution { get; }
    public float RotationRow { get; }
    public float RotationColumn { get; }
    public float VerticalResolution { get; }
    public float UpperLeftX { get; }
    public float UpperLeftY { get; }
    public WorldFile(string worldFileText);
    public WorldFile(RectangleShape worldExtent, float imageWidth, float imageHeight);
    public WorldFile(double horizontalResolution, double rotationRow, double rotationColumn, double verticalResolution, double upperLeftX, double upperLeftY);
    public WorldFile(float horizontalResolution, float rotationRow, float rotationColumn, float verticalResolution, float upperLeftX, float upperLeftY);
    public float get_HorizontalResolution();
    public float get_RotationRow();
    public float get_RotationColumn();
    public float get_VerticalResolution();
    public float get_UpperLeftX();
    public float get_UpperLeftY();
    public RectangleShape GetBoundingBox(float width, float height);
    public void Save(string pathFilename);
}
public class ThinkGeo.Core.WorldLabelingCandidate : LabelingCandidate {
    [ObfuscationAttribute]
private PointShape centerPointInWorldCoordinates;
    public PointShape CenterPointInWorldCoordinates { get; public set; }
    public WorldLabelingCandidate(string originalText);
    public WorldLabelingCandidate(string originalText, PointShape centerPointInWorldCoordinates);
    public PointShape get_CenterPointInWorldCoordinates();
    public void set_CenterPointInWorldCoordinates(PointShape value);
}
public enum ThinkGeo.Core.WrappingMode : Enum {
    public int value__;
    public static WrappingMode None;
    public static WrappingMode WrapDateline;
}
public enum ThinkGeo.Core.WrappingWorldDirection : Enum {
    public int value__;
    public static WrappingWorldDirection West;
    public static WrappingWorldDirection East;
}
internal class ThinkGeo.Core.XmlGeoSerializationFormatter : GeoSerializationFormatter {
    protected virtual void SaveCore(GeoObjectModel model, Stream stream);
    protected virtual GeoObjectModel LoadCore(Stream stream);
    private void Save(GeoObjectNode node, XmlWriter xmlWriter);
    private static void RemoveRedundant(GeoObjectNode node);
    private static GeoObjectNode Load(XmlReader xmlReader);
}
public abstract class ThinkGeo.Core.XyzTileAsyncLayer : WebBasedAsyncLayer {
    [ObfuscationAttribute]
private RasterTileCache tileCache;
    [ObfuscationAttribute]
private RasterTileCache projectedTileCache;
    [ObfuscationAttribute]
private ProjectionConverter projectionConverterFromServerProjection;
    [ObfuscationAttribute]
private int cloudTileWidth;
    [ObfuscationAttribute]
private int cloudTileHeight;
    [ObfuscationAttribute]
private RectangleShape maxExtent;
    [ObfuscationAttribute]
private GeographyUnit cloudTileMapUnit;
    public int TileWidth { get; protected set; }
    public int TileHeight { get; protected set; }
    public GeographyUnit MapUnit { get; protected set; }
    public RectangleShape MaxExtent { get; protected set; }
    public RasterTileCache TileCache { get; public set; }
    public RasterTileCache ProjectedTileCache { get; public set; }
    public ProjectionConverter ProjectionConverterFromServerProjection { get; public set; }
    public XyzTileAsyncLayer(int tileSize, GeographyUnit mapUnit, RectangleShape maxExtent);
    public int get_TileWidth();
    protected void set_TileWidth(int value);
    public int get_TileHeight();
    protected void set_TileHeight(int value);
    public GeographyUnit get_MapUnit();
    protected void set_MapUnit(GeographyUnit value);
    public RectangleShape get_MaxExtent();
    protected void set_MaxExtent(RectangleShape value);
    public virtual RasterTileCache get_TileCache();
    public virtual void set_TileCache(RasterTileCache value);
    public virtual RasterTileCache get_ProjectedTileCache();
    public virtual void set_ProjectedTileCache(RasterTileCache value);
    public virtual ProjectionConverter get_ProjectionConverterFromServerProjection();
    public virtual void set_ProjectionConverterFromServerProjection(ProjectionConverter value);
    [AsyncStateMachineAttribute("ThinkGeo.Core.XyzTileAsyncLayer/tT8=")]
public Task`1<string> GetImageUriAsync(int zoomLevel, long x, long y, float resolutionFactor);
    protected abstract virtual Task`1<string> GetImageUriAsyncCore(int zoomLevel, long x, long y, float resolutionFactor);
    protected virtual Task OpenAsyncCore(CancellationToken cancellationToken);
    protected virtual Task CloseAsyncCore(CancellationToken cancellationToken);
    protected virtual int GetTileScale();
    [AsyncStateMachineAttribute("ThinkGeo.Core.XyzTileAsyncLayer/pT8=")]
protected virtual Task DrawAsyncCore(GeoCanvas canvas, Collection`1<SimpleCandidate> labelsInAllLayers);
    private static Dictionary`2<ValueTuple`2<long, long>, MatrixCell> jB4=(TileMatrix tileMatrix, RectangleShape requestedExtent, WrappingMode wrapDateline);
    protected virtual RectangleShape GetBoundingBoxCore();
    [AsyncStateMachineAttribute("ThinkGeo.Core.XyzTileAsyncLayer/tz8=")]
private Task`1<RasterTile> iB4=(int zoomLevel, long x, long y, float resolutionFactor, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("ThinkGeo.Core.XyzTileAsyncLayer/sz8=")]
private Task`1<CloudRasterTileInfo> hx4=(MatrixCell cell, int zoomLevelIndex, float scaleFactor, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("ThinkGeo.Core.XyzTileAsyncLayer/pD8=")]
public Task`1<Byte[]> DownloadImageAsync(int zoomLevelIndex, long column, long row, float scaleFactor, CancellationToken cancellationToken);
}
public class ThinkGeo.Core.ZoomLevel : object {
    [ObfuscationAttribute]
private string name;
    [ObfuscationAttribute]
private double scale;
    [ObfuscationAttribute]
private bool isActive;
    [ObfuscationAttribute]
private ApplyUntilZoomLevel applyUntilZoomLevel;
    [ObfuscationAttribute]
private TextStyle defaultTextStyle;
    [ObfuscationAttribute]
private AreaStyle defaultAreaStyle;
    [ObfuscationAttribute]
private LineStyle defaultLineStyle;
    [ObfuscationAttribute]
private PointStyle defaultPointStyle;
    [ObfuscationAttribute]
private Collection`1<Style> customStyles;
    [ObfuscationAttribute]
private GeoColor backgroundColor;
    [ObfuscationAttribute]
private bool useLegacyLabeling;
    public bool IsActive { get; public set; }
    public double Scale { get; public set; }
    public AreaStyle DefaultAreaStyle { get; public set; }
    public LineStyle DefaultLineStyle { get; public set; }
    public PointStyle DefaultPointStyle { get; public set; }
    public TextStyle DefaultTextStyle { get; public set; }
    public ApplyUntilZoomLevel ApplyUntilZoomLevel { get; public set; }
    public string Name { get; public set; }
    public Collection`1<Style> CustomStyles { get; }
    internal GeoColor XSA= { get; internal set; }
    public bool UseLegacyLabeling { get; public set; }
    internal bool phU= { get; }
    public ZoomLevel(double scale);
    public bool get_IsActive();
    public void set_IsActive(bool value);
    public double get_Scale();
    public void set_Scale(double value);
    public AreaStyle get_DefaultAreaStyle();
    public void set_DefaultAreaStyle(AreaStyle value);
    public LineStyle get_DefaultLineStyle();
    public void set_DefaultLineStyle(LineStyle value);
    public PointStyle get_DefaultPointStyle();
    public void set_DefaultPointStyle(PointStyle value);
    public TextStyle get_DefaultTextStyle();
    public void set_DefaultTextStyle(TextStyle value);
    public ApplyUntilZoomLevel get_ApplyUntilZoomLevel();
    public void set_ApplyUntilZoomLevel(ApplyUntilZoomLevel value);
    public string get_Name();
    public void set_Name(string value);
    public Collection`1<Style> get_CustomStyles();
    internal GeoColor WyA=();
    internal void XCA=(GeoColor value);
    public bool get_UseLegacyLabeling();
    public void set_UseLegacyLabeling(bool value);
    public Collection`1<string> GetRequiredColumnNames();
    public void Draw(GeoCanvas canvas, IEnumerable`1<Feature> features, Collection`1<SimpleCandidate> currentLayerLabels, Collection`1<SimpleCandidate> allLayerLabels);
    public void Draw(GeoCanvas canvas, IEnumerable`1<BaseShape> shapes, Collection`1<SimpleCandidate> currentLayerLabels, Collection`1<SimpleCandidate> allLayerLabels);
    public bool HasValidStyles();
    protected virtual void DrawCore(GeoCanvas canvas, IEnumerable`1<Feature> features, Collection`1<SimpleCandidate> currentLayerLabels, Collection`1<SimpleCandidate> allLayerLabels);
    internal bool pBU=();
    private static void XiA=(Style style, Collection`1<string> columnNames);
    private static Collection`1<Collection`1<Feature>> XyA=(IEnumerable`1<Feature> allFeatures);
}
public class ThinkGeo.Core.ZoomLevelSet : object {
    private static int YCA=;
    private static float YSA=;
    [ObfuscationAttribute]
private string name;
    [ObfuscationAttribute]
private ZoomLevel zoomLevel01;
    [ObfuscationAttribute]
private ZoomLevel zoomLevel02;
    [ObfuscationAttribute]
private ZoomLevel zoomLevel03;
    [ObfuscationAttribute]
private ZoomLevel zoomLevel04;
    [ObfuscationAttribute]
private ZoomLevel zoomLevel05;
    [ObfuscationAttribute]
private ZoomLevel zoomLevel06;
    [ObfuscationAttribute]
private ZoomLevel zoomLevel07;
    [ObfuscationAttribute]
private ZoomLevel zoomLevel08;
    [ObfuscationAttribute]
private ZoomLevel zoomLevel09;
    [ObfuscationAttribute]
private ZoomLevel zoomLevel10;
    [ObfuscationAttribute]
private ZoomLevel zoomLevel11;
    [ObfuscationAttribute]
private ZoomLevel zoomLevel12;
    [ObfuscationAttribute]
private ZoomLevel zoomLevel13;
    [ObfuscationAttribute]
private ZoomLevel zoomLevel14;
    [ObfuscationAttribute]
private ZoomLevel zoomLevel15;
    [ObfuscationAttribute]
private ZoomLevel zoomLevel16;
    [ObfuscationAttribute]
private ZoomLevel zoomLevel17;
    [ObfuscationAttribute]
private ZoomLevel zoomLevel18;
    [ObfuscationAttribute]
private ZoomLevel zoomLevel19;
    [ObfuscationAttribute]
private ZoomLevel zoomLevel20;
    [ObfuscationAttribute]
private Collection`1<ZoomLevel> customZoomLevels;
    [CompilerGeneratedAttribute]
private int Sx4=;
    [CompilerGeneratedAttribute]
private RectangleShape fx0=;
    public int TileSize { get; public set; }
    public RectangleShape MaxExtent { get; public set; }
    public string Name { get; public set; }
    public Collection`1<ZoomLevel> CustomZoomLevels { get; }
    public ZoomLevel ZoomLevel01 { get; }
    public ZoomLevel ZoomLevel02 { get; }
    public ZoomLevel ZoomLevel03 { get; }
    public ZoomLevel ZoomLevel04 { get; }
    public ZoomLevel ZoomLevel05 { get; }
    public ZoomLevel ZoomLevel06 { get; }
    public ZoomLevel ZoomLevel07 { get; }
    public ZoomLevel ZoomLevel08 { get; }
    public ZoomLevel ZoomLevel09 { get; }
    public ZoomLevel ZoomLevel10 { get; }
    public ZoomLevel ZoomLevel11 { get; }
    public ZoomLevel ZoomLevel12 { get; }
    public ZoomLevel ZoomLevel13 { get; }
    public ZoomLevel ZoomLevel14 { get; }
    public ZoomLevel ZoomLevel15 { get; }
    public ZoomLevel ZoomLevel16 { get; }
    public ZoomLevel ZoomLevel17 { get; }
    public ZoomLevel ZoomLevel18 { get; }
    public ZoomLevel ZoomLevel19 { get; }
    public ZoomLevel ZoomLevel20 { get; }
    public ZoomLevelSet(int tileSize);
    public ZoomLevelSet(int tileSize, RectangleShape maxExtent);
    public ZoomLevelSet(int tileSize, RectangleShape maxExtent, GeographyUnit maxExtentUnit);
    [CompilerGeneratedAttribute]
public int get_TileSize();
    [CompilerGeneratedAttribute]
public void set_TileSize(int value);
    [CompilerGeneratedAttribute]
public RectangleShape get_MaxExtent();
    [CompilerGeneratedAttribute]
public void set_MaxExtent(RectangleShape value);
    public string get_Name();
    public void set_Name(string value);
    public Collection`1<ZoomLevel> get_CustomZoomLevels();
    public ZoomLevel get_ZoomLevel01();
    public ZoomLevel get_ZoomLevel02();
    public ZoomLevel get_ZoomLevel03();
    public ZoomLevel get_ZoomLevel04();
    public ZoomLevel get_ZoomLevel05();
    public ZoomLevel get_ZoomLevel06();
    public ZoomLevel get_ZoomLevel07();
    public ZoomLevel get_ZoomLevel08();
    public ZoomLevel get_ZoomLevel09();
    public ZoomLevel get_ZoomLevel10();
    public ZoomLevel get_ZoomLevel11();
    public ZoomLevel get_ZoomLevel12();
    public ZoomLevel get_ZoomLevel13();
    public ZoomLevel get_ZoomLevel14();
    public ZoomLevel get_ZoomLevel15();
    public ZoomLevel get_ZoomLevel16();
    public ZoomLevel get_ZoomLevel17();
    public ZoomLevel get_ZoomLevel18();
    public ZoomLevel get_ZoomLevel19();
    public ZoomLevel get_ZoomLevel20();
    public void Load(string styleJsonPath);
    public void Load(Uri styleJsonUri);
    public ZoomLevel GetZoomLevel(RectangleShape extent, double screenWidth, GeographyUnit mapUnit);
    public ZoomLevel GetZoomLevel(RectangleShape extent, double screenWidth, GeographyUnit mapUnit, float dpi);
    public ZoomLevel GetZoomLevelForDrawing(RectangleShape extent, double screenWidth, GeographyUnit mapUnit, float dpi);
    public ZoomLevel GetZoomLevelForDrawing(double currentScale);
    public ZoomLevel GetZoomLevelForDrawing(RectangleShape extent, double screenWidth, GeographyUnit mapUnit);
    public Collection`1<ZoomLevel> GetZoomLevels();
    public static double GetLowerZoomLevelScale(double currentScale, ZoomLevelSet zoomLevelSet);
    public static double GetHigherZoomLevelScale(double currentScale, ZoomLevelSet zoomLevelSet);
    private double YiA=(ZoomLevel zoomLevel);
    public ZoomLevel GetDefaultZoomLevelByIndex(int zoomLevelIndex);
}
public enum ThinkGeo.Core.ZoomLevelSnappingMode : Enum {
    public int value__;
    public static ZoomLevelSnappingMode Default;
    public static ZoomLevelSnappingMode SnapUp;
    public static ZoomLevelSnappingMode SnapDown;
    public static ZoomLevelSnappingMode SnapToClosest;
    public static ZoomLevelSnappingMode None;
}
public enum ThinkGeo.Core.ZoomSnapDirection : Enum {
    public int value__;
    public static ZoomSnapDirection UpperScale;
    public static ZoomSnapDirection LowerScale;
}
[CompilerGeneratedAttribute]
internal class uhM= : object {
    [DebuggerBrowsableAttribute("0")]
private <exceptionGroup>j__TPar uxM=;
    [DebuggerBrowsableAttribute("0")]
private <exception>j__TPar vBM=;
    public <exceptionGroup>j__TPar vhM= { get; }
    public <exception>j__TPar wBM= { get; }
    [DebuggerHiddenAttribute]
public uhM=(<exceptionGroup>j__TPar exceptionGroup, <exception>j__TPar exception);
    public <exceptionGroup>j__TPar vRM=();
    public <exception>j__TPar vxM=();
    [DebuggerHiddenAttribute]
public virtual bool Equals(object value);
    [DebuggerHiddenAttribute]
public virtual int GetHashCode();
    [DebuggerHiddenAttribute]
public virtual string ToString();
}
[CompilerGeneratedAttribute]
internal class wRM= : object {
    [DebuggerBrowsableAttribute("0")]
private <candidateConstructor>j__TPar whM=;
    [DebuggerBrowsableAttribute("0")]
private <rank>j__TPar wxM=;
    public <candidateConstructor>j__TPar xRM= { get; }
    public <rank>j__TPar xxM= { get; }
    [DebuggerHiddenAttribute]
public wRM=(<candidateConstructor>j__TPar candidateConstructor, <rank>j__TPar rank);
    public <candidateConstructor>j__TPar xBM=();
    public <rank>j__TPar xhM=();
    [DebuggerHiddenAttribute]
public virtual bool Equals(object value);
    [DebuggerHiddenAttribute]
public virtual int GetHashCode();
    [DebuggerHiddenAttribute]
public virtual string ToString();
}
internal class WTM=./Dg= : nTg= {
    private static int Vjc=;
    private static int Ezc=;
    private UTo= Yjc=;
    private bool /Tg=;
    private Int32[] djc=;
    private Int32[] dzc=;
    private Int32[] eDc=;
    private Int32[] eTc=;
    private Byte[] /jg=;
    private bool /zg=;
    private int ADk=;
    private int mzc=;
    public /Dg=(UTo= cinfo);
    public virtual void Ojc=();
    public virtual void njg=(Jzc=[] input_buf, Int32& in_row_group_ctr, int in_row_groups_avail, Byte[][] output_buf, Int32& out_row_ctr, int out_rows_avail);
    private void ATk=(Jzc=[] input_buf, Int32& in_row_group_ctr, Byte[][] output_buf, Int32& out_row_ctr);
    private void Ajk=(Jzc=[] input_buf, Int32& in_row_group_ctr, Byte[][] output_buf, Int32& out_row_ctr, int out_rows_avail);
    private void Azk=(Jzc=[] input_buf, int in_row_group_ctr, Byte[][] output_buf, int outRow);
    private void BDk=(Jzc=[] input_buf, int in_row_group_ctr, Byte[][] output_buf);
    private void ejc=();
    private static int bTc=(double x);
}
internal class WTM=.0DU= : 3jo= {
    private gjU= xDU=;
    public 0DU=(gjU= sp);
    public virtual void yTU=();
    public virtual bool yjU=();
    public virtual void yzU=();
}
internal class WTM=.0jU= : YjQ= {
    private bool 0zU=;
    private static short 1DU=;
    private static short 1TU=;
    private static short 1jU=;
    private static short 1zU=;
    private static short 2DU=;
    private static short 2TU=;
    private static short 2jU=;
    private static int 2zU=;
    private static int 3DU=;
    private static int 3TU=;
    private static int 3jU=;
    private bool 3zU=;
    private short 4DU=;
    private short 4TU=;
    private short 4jU=;
    private int 4zU=;
    private int 5DU=;
    private int CzQ=;
    private int 5TU=;
    private int 5jU=;
    private int 5zU=;
    private bool 6DU=;
    private int 6TU=;
    private int 6jU=;
    private int 6zU=;
    private int 7DU=;
    private 30A=[] 7TU=;
    private int 7jU=;
    private int 7zU=;
    private int 8DU=;
    private int 8TU=;
    private int 8jU=;
    private int 8zU=;
    private 4UA=[] 9DU=;
    public bool CanEncode { get; }
    public bool CanDecode { get; }
    public 0jU=(Tiff tif, Compression scheme, string name);
    public virtual bool Init();
    public virtual bool get_CanEncode();
    public virtual bool get_CanDecode();
    public virtual bool PreDecode(short plane);
    public virtual bool PreEncode(short plane);
    public virtual bool PostEncode();
    public virtual void Cleanup();
    public virtual bool bjQ=();
    public virtual bool bzQ=(Byte[] buffer, int offset, int count, short plane);
    public virtual bool cDQ=(Byte[] buffer, int offset, int count, short plane);
    public virtual bool cTQ=(Byte[] buffer, int offset, int count, short plane);
    public virtual bool cjQ=();
    public virtual bool czQ=(Byte[] buffer, int offset, int count, short plane);
    public virtual bool dDQ=(Byte[] buffer, int offset, int count, short plane);
    public virtual bool dTQ=(Byte[] buffer, int offset, int count, short plane);
    private bool 9TU=();
    private bool 9jU=(short s);
    private bool 9zU=(Byte[] buffer, int offset, int count, short plane);
    private bool /DU=(Byte[] buffer, int offset, int count, short plane);
    private bool /TU=();
    private bool /jU=(short s);
    private bool /zU=();
    private bool ADY=(Byte[] buffer, int offset, int count, short plane);
    private void ATY=();
    private static int AjY=(int n);
    private void AzY=(int c);
    private void BDY=();
    private void BTY=(Int16& _code, bool compat);
    private void BjY=(Int16& code);
    private void BzY=(Int16& code);
    private void CDY=();
}
internal class WTM=.0TU= : zDU= {
    public 0TU=(gjU= sp);
    public virtual void zjU=();
}
internal class WTM=.1Dc= : object {
    private static int 1Tc=;
    private static int 1jc=;
    private static int 1zc=;
    private H0E= 2Dc=;
    private UTo= Yjc=;
    private Byte[][][] ITQ=;
    private bool 2Tc=;
    private int lTc=;
    private Int32[][][] KDc=;
    private Int32[] 2jc=;
    private int 2zc=;
    private int 3Dc=;
    private int 3Tc=;
    private int 3jc=;
    public 1Dc=(UTo= cinfo);
    public void Ojc=(nzg= pass_mode);
    public void lzc=(Byte[][] output_buf, Int32& out_row_ctr, int out_rows_avail);
    private void 3zc=(Byte[][] output_buf, Int32& out_row_ctr, int out_rows_avail);
    private void 4Dc=(Byte[][] output_buf, Int32& out_row_ctr, int out_rows_avail);
    private void 4Tc=(Byte[][] output_buf, Int32& out_row_ctr, int out_rows_avail);
    private void 4jc=();
    private void 4zc=();
    private void 5Dc=();
    private void 5Tc=();
}
internal class WTM=.2Ds= : object {
    internal static string 2Ts=;
    private Tiff 2js=;
    private bool 2zs=;
    private bool 3Ds=;
    private YzM= 6Rk=;
    private int /Cw=;
    private int wRk=;
    private short 3Ts=;
    private short 3js=;
    private Orientation 3zs=;
    private Orientation 4Ds=;
    private jzM= 4Ts=;
    private UInt16[] 4js=;
    private UInt16[] 4zs=;
    private UInt16[] 5Ds=;
    private GetDelegate 5Ts=;
    private PutContigDelegate 5js=;
    private PutSeparateDelegate 5zs=;
    private Byte[] 6Ds=;
    private Int32[][] 6Ts=;
    private Int32[][] 6js=;
    private EDc= 6zs=;
    private mjY= 7Ds=;
    private static 4DY= 7Ts=;
    private static int Dxo=;
    private static int 7js=;
    private static int 7zs=;
    internal int 8Ds=;
    internal int 8Ts=;
    public bool 8zs= { get; }
    public YzM= 9Ts= { get; }
    public int 7y0= { get; }
    public int 8i0= { get; }
    public short 9zs= { get; }
    public short /Ts= { get; }
    public Orientation /zs= { get; }
    public Orientation Ajw= { get; public set; }
    public jzM= BDw= { get; }
    public GetDelegate Bzw= { get; public set; }
    public PutContigDelegate Cjw= { get; public set; }
    public PutSeparateDelegate DTw= { get; public set; }
    private static 2Ds=();
    public static 2Ds= qR8=(Tiff tif, bool stopOnError, String& errorMsg);
    public bool 8js=();
    public YzM= 9Ds=();
    public int 7S0=();
    public int 8C0=();
    public short 9js=();
    public short /Ds=();
    public Orientation /js=();
    public Orientation ADw=();
    public void ATw=(Orientation value);
    public jzM= Azw=();
    public GetDelegate BTw=();
    public void Bjw=(GetDelegate value);
    public PutContigDelegate CDw=();
    public void CTw=(PutContigDelegate value);
    public PutSeparateDelegate Czw=();
    public void DDw=(PutSeparateDelegate value);
    public bool Djw=(Int32[] raster, int offset, int width, int height);
    private static int Dzw=(int r, int g, int b);
    private static int EDw=(int r, int g, int b, int a);
    private static int EDw=(int rgb, int a);
    private static int ETw=(short v);
    private static int Ejw=(short r, short g, short b);
    private static int Ezw=(short r, short g, short b, short a);
    private void FDw=(int x, int i, Int32& j);
    private void FTw=(int x, int i, Int32& j);
    private static bool Fjw=(2Ds= img, Int32[] raster, int offset, int width, int height);
    private static bool Fzw=(2Ds= img, Int32[] raster, int offset, int width, int height);
    private static bool GDw=(2Ds= img, Int32[] raster, int offset, int width, int height);
    private static bool GTw=(2Ds= img, Int32[] raster, int offset, int width, int height);
    private bool Gjw=();
    private int Gzw=();
    private bool HDw=();
    private bool HTw=();
    private bool Hjw=();
    private PutContigDelegate Hzw=();
    private bool IDw=();
    private bool ITw=();
    private int Ijw=();
    private void Izw=();
    private bool JDw=();
    private bool JTw=();
    private void Gjc=(Int32& dst, int Y, int Cb, int Cr);
    private static void Jjw=(2Ds= img, Int32[] raster, int rasterOffset, int rasterShift, int x, int y, int width, int height, Byte[] buffer, int offset, int bufferShift);
    private static void Jzw=(2Ds= img, Int32[] raster, int rasterOffset, int rasterShift, int x, int y, int width, int height, Byte[] buffer, int offset, int bufferShift);
    private static void KDw=(2Ds= img, Int32[] raster, int rasterOffset, int rasterShift, int x, int y, int width, int height, Byte[] buffer, int offset, int bufferShift);
    private static void KTw=(2Ds= img, Int32[] raster, int rasterOffset, int rasterShift, int x, int y, int width, int height, Byte[] buffer, int offset, int bufferShift);
    private static void Kjw=(2Ds= img, Int32[] raster, int rasterOffset, int rasterShift, int x, int y, int width, int height, Byte[] buffer, int offset, int bufferShift);
    private static void Kzw=(2Ds= img, Int32[] raster, int rasterOffset, int rasterShift, int x, int y, int width, int height, Byte[] buffer, int offset, int bufferShift);
    private static void LDw=(2Ds= img, Int32[] raster, int rasterOffset, int rasterShift, int x, int y, int width, int height, Byte[] buffer, int offset, int bufferShift);
    private static void LTw=(2Ds= img, Int32[] raster, int rasterOffset, int rasterShift, int x, int y, int width, int height, Byte[] buffer, int offset, int bufferShift);
    private static void Ljw=(2Ds= img, Int32[] raster, int rasterOffset, int rasterShift, int x, int y, int width, int height, Byte[] buffer, int offset, int bufferShift);
    private static void Lzw=(2Ds= img, Int32[] raster, int rasterOffset, int rasterShift, int x, int y, int width, int height, Byte[] buffer, int offset, int bufferShift);
    private static void MDw=(2Ds= img, Int32[] raster, int rasterOffset, int rasterShift, int x, int y, int width, int height, Byte[] buffer, int offset, int bufferShift);
    private static void MTw=(2Ds= img, Int32[] raster, int rasterOffset, int rasterShift, int x, int y, int width, int height, Byte[] buffer, int offset, int bufferShift);
    private static void Mjw=(2Ds= img, Int32[] raster, int rasterOffset, int rasterShift, int x, int y, int width, int height, Byte[] buffer, int offset, int bufferShift);
    private static void Mzw=(2Ds= img, Int32[] raster, int rasterOffset, int rasterShift, int x, int y, int width, int height, Byte[] buffer, int offset, int bufferShift);
    private static void NDw=(2Ds= img, Int32[] raster, int rasterOffset, int rasterShift, int x, int y, int width, int height, Byte[] buffer, int offset, int bufferShift);
    private static void NTw=(2Ds= img, Int32[] raster, int rasterOffset, int rasterShift, int x, int y, int width, int height, Byte[] buffer, int offset, int bufferShift);
    private static void Njw=(2Ds= img, Int32[] raster, int rasterOffset, int rasterShift, int x, int y, int width, int height, Byte[] buffer, int offset, int bufferShift);
    private static void Nzw=(2Ds= img, Int32[] raster, int rasterOffset, int rasterShift, int x, int y, int width, int height, Byte[] buffer, int offset, int bufferShift);
    private static void ODw=(2Ds= img, Int32[] raster, int rasterOffset, int rasterShift, int x, int y, int width, int height, Byte[] buffer, int offset, int bufferShift);
    private static void OTw=(2Ds= img, Int32[] raster, int rasterOffset, int rasterShift, int x, int y, int width, int height, Byte[] buffer, int offset, int bufferShift);
    private static void Ojw=(2Ds= img, Int32[] raster, int rasterOffset, int rasterShift, int x, int y, int width, int height, Byte[] buffer, int offset, int bufferShift);
    private static void Ozw=(2Ds= img, Int32[] raster, int rasterOffset, int rasterShift, int x, int y, int width, int height, Byte[] buffer, int offset, int bufferShift);
    private static void PDw=(2Ds= img, Int32[] raster, int rasterOffset, int rasterShift, int x, int y, int width, int height, Byte[] buffer, int offset, int bufferShift);
    private static void PTw=(2Ds= img, Int32[] raster, int rasterOffset, int rasterShift, int x, int y, int width, int height, Byte[] buffer, int offset, int bufferShift);
    private static void Pjw=(2Ds= img, Int32[] raster, int rasterOffset, int rasterShift, int x, int y, int width, int height, Byte[] buffer, int offset, int bufferShift);
    private static void Pzw=(2Ds= img, Int32[] raster, int rasterOffset, int rasterShift, int x, int y, int width, int height, Byte[] buffer, int offset, int bufferShift);
    private static void QDw=(2Ds= img, Int32[] raster, int rasterOffset, int rasterShift, int x, int y, int width, int height, Byte[] buffer, int offset1, int offset2, int offset3, int offset4, int bufferShift);
    private static void QTw=(2Ds= img, Int32[] raster, int rasterOffset, int rasterShift, int x, int y, int width, int height, Byte[] buffer, int offset1, int offset2, int offset3, int offset4, int bufferShift);
    private static void Qjw=(2Ds= img, Int32[] raster, int rasterOffset, int rasterShift, int x, int y, int width, int height, Byte[] buffer, int offset1, int offset2, int offset3, int offset4, int bufferShift);
    private static void Qzw=(2Ds= img, Int32[] raster, int rasterOffset, int rasterShift, int x, int y, int width, int height, Byte[] buffer, int offset1, int offset2, int offset3, int offset4, int bufferShift);
    private static void RDw=(2Ds= img, Int32[] raster, int rasterOffset, int rasterShift, int x, int y, int width, int height, Byte[] buffer, int offset1, int offset2, int offset3, int offset4, int bufferShift);
    private static void RTw=(2Ds= img, Int32[] raster, int rasterOffset, int rasterShift, int x, int y, int width, int height, Byte[] buffer, int offset1, int offset2, int offset3, int offset4, int bufferShift);
    private static void Rjw=(2Ds= img, Int32[] raster, int rasterOffset, int rasterShift, int x, int y, int width, int height, Byte[] buffer, int offset1, int offset2, int offset3, int offset4, int bufferShift);
    private static void Rzw=(2Ds= img, Int32[] raster, int rasterOffset, int rasterShift, int x, int y, int width, int height, Byte[] buffer, int offset, int bufferShift);
}
internal class WTM=.2jY= : object {
    public TiffTag 2zY=;
    public TiffType 3DY=;
    public int 3TY=;
    public ulong 3jY=;
    public string 6xM=();
    public static int 3zY=(bool isBigTiff);
}
internal abstract class WTM=.3jo= : object {
    private Byte[] ITQ=;
    private int 3zo=;
    private int 4Do=;
    protected int 4jo= { get; }
    public abstract virtual void yTU=();
    public abstract virtual bool yjU=();
    public abstract virtual void yzU=();
    public virtual bool Sjc=(int val);
    protected void 4zo=(Byte[] buffer, int offset);
    protected int 4To=();
}
internal class WTM=.3TM= : TiffCodec {
    public static int 3jM=;
    public static int 3zM=;
    public static int 4DM=;
    public static int 4TM=;
    public static int 4jM=;
    public static int 4zM=;
    public static int 5DM=;
    public static int 5TM=;
    internal ZzM= 5jM=;
    internal ezM= 5zM=;
    internal WDM= 6DM=;
    internal int 6TM=;
    internal int 6jM=;
    internal int 6zM=;
    internal string 7DM=;
    internal int 7TM=;
    internal string 7jM=;
    internal FaxFillFunc 7zM=;
    private static int 8DM=;
    private static byte 8TM=;
    private static byte 8jM=;
    private static byte 8zM=;
    private static byte 9DM=;
    private static byte 9TM=;
    private static byte 9jM=;
    private static byte 9zM=;
    private static byte /DM=;
    private static byte /TM=;
    private static byte /jM=;
    private static byte /zM=;
    private static byte ADQ=;
    private static byte ATQ=;
    private static short AjQ=;
    private static short AzQ=;
    private static short BDQ=;
    private static short BTQ=;
    private static TiffFieldInfo[] BjQ=;
    private static TiffFieldInfo[] BzQ=;
    private static TiffFieldInfo[] CDQ=;
    private TiffTagMethods CTQ=;
    private TiffTagMethods CjQ=;
    private int CzQ=;
    private int DDQ=;
    private int DTQ=;
    private wUA= DjQ=;
    private Byte[] DzQ=;
    private int EDQ=;
    private int ETQ=;
    private int EjQ=;
    private Int32[] EzQ=;
    private int FDQ=;
    private int FTQ=;
    private int FjQ=;
    private int FzQ=;
    private int GDQ=;
    private int GTQ=;
    private int GjQ=;
    private xkA= GzQ=;
    private bool HDQ=;
    private Byte[] HTQ=;
    private int HjQ=;
    private int HzQ=;
    private int IDQ=;
    private Byte[] ITQ=;
    private int IjQ=;
    private static Int32[] IzQ=;
    private static Int32[] JDQ=;
    private static Int32[] JTQ=;
    private static Int16[] JjQ=;
    private static Int16[] JzQ=;
    private static ukA= KDQ=;
    private static ukA= KTQ=;
    private static ukA=[] KjQ=;
    private static Int32[] KzQ=;
    private static Byte[] LDQ=;
    private static Byte[] LTQ=;
    private static Byte[] LjQ=;
    public bool CanEncode { get; }
    public bool CanDecode { get; }
    public 3TM=(Tiff tif, Compression scheme, string name);
    private static 3TM=();
    private void LzQ=();
    public virtual bool Init();
    public virtual bool get_CanEncode();
    public virtual bool get_CanDecode();
    public virtual bool SetupDecode();
    public virtual bool PreDecode(short plane);
    public virtual bool DecodeRow(Byte[] buffer, int offset, int count, short plane);
    public virtual bool DecodeStrip(Byte[] buffer, int offset, int count, short plane);
    public virtual bool DecodeTile(Byte[] buffer, int offset, int count, short plane);
    public virtual bool SetupEncode();
    public virtual bool PreEncode(short plane);
    public virtual bool PostEncode();
    public virtual bool EncodeRow(Byte[] buffer, int offset, int count, short plane);
    public virtual bool EncodeStrip(Byte[] buffer, int offset, int count, short plane);
    public virtual bool EncodeTile(Byte[] buffer, int offset, int count, short plane);
    public virtual void Close();
    public virtual void Cleanup();
    private bool MDQ=();
    private void MTQ=(Int32& b1);
    private static void hig=(Int32& a, Int32& b);
    private static bool MjQ=(int offset);
    private static bool MzQ=(int offset);
    private static void NDQ=(int n, Byte[] cp, Int32& offset, byte value);
    private static void NTQ=(Byte[] buffer, int offset, Int32[] runs, int thisRunOffset, int nextRunOffset, int width);
    private static int NjQ=(Byte[] bp, int bpOffset, int bs, int be);
    private static int NzQ=(Byte[] bp, int bpOffset, int bs, int be);
    private static int ODQ=(Byte[] bp, int bpOffset, int _bs, int _be, int _color);
    private static int OTQ=(Byte[] bp, int bpOffset, int _bs, int _be, int _color);
    private bool OjQ=();
    private int OzQ=(int n);
    private void PDQ=(int n);
    private bool PTQ=(int n);
    private bool PjQ=(int n);
    private bool PzQ=(vUA=& TabEnt, int wid);
    private bool QDQ=(vUA=& TabEnt, int wid, bool useBlack);
    private bool QTQ=();
    private bool QjQ=();
    private void QzQ=(string module);
    private void RDQ=(string module);
    private void RTQ=(string module);
    private void RjQ=(string module);
    private bool RzQ=(Byte[] buffer, int offset, int count);
    private bool SDQ=(Byte[] buffer, int offset, int count);
    private bool STQ=();
    private bool SjQ=();
    private static int SzQ=(Byte[] buf, int bufOffset, int ix);
    private bool TDQ=(Byte[] buffer, int offset, int count);
    private bool TTQ=();
    private void TjQ=();
    private bool TzQ=();
    private void UDQ=();
    private void UTQ=(int bits, int length);
    private void UjQ=(ukA= te);
    private void UzQ=(int span, bool useBlack);
    private void VDQ=();
    private void VTQ=(int x);
    private void VjQ=(string module);
    private void VzQ=(string module);
    private bool WDQ=(string module);
    private bool WTQ=(string module, int b1);
    private bool WjQ=();
    private bool WzQ=();
    private bool XDQ=(Byte[] buffer, int offset, int count);
    private bool XTQ=();
    private bool XjQ=(Byte[] buffer, int offset, int count);
    private bool XzQ=(Byte[] buffer, int offset, int count);
    private bool YDQ=();
}
internal class WTM=.4DY= : object {
    internal Single[][] 4TY=;
    internal float 4jY=;
    internal float 4zY=;
    internal float 5DY=;
    internal int 5TY=;
    internal int 5jY=;
    internal int 5zY=;
    internal float 6DY=;
    internal float 6TY=;
    internal float 6jY=;
    internal float 6zY=;
    internal float 7DY=;
    internal float 7TY=;
    public 4DY=(Single[] mat0, Single[] mat1, Single[] mat2, float YCR, float YCG, float YCB, int Vrwr, int Vrwg, int Vrwb, float Y0R, float Y0G, float Y0B, float gammaR, float gammaG, float gammaB);
}
internal class WTM=.5Do= : object {
    internal int 5To=;
    internal Object[] 5jo=;
    internal int 5zo=;
    internal int 6Do=;
    public int 6zo= { get; public set; }
    public int 7To= { get; }
    public int 6To=();
    public void 6jo=(int value);
    public int 7Do=();
    public virtual void xTU=();
    public virtual void 7jo=(int msg_level);
    public virtual void xjU=();
    public virtual string 7zo=();
    public virtual void 8Do=();
    protected virtual string 8To=(int code);
}
internal class WTM=.5jc= : object {
    private I0E= 5zc=;
    private UTo= Yjc=;
    private UDs=<byte> xjc=;
    private Byte[][] ITQ=;
    private int 6Dc=;
    private int 6Tc=;
    private int 6jc=;
    public 5jc=(UTo= cinfo, bool need_full_buffer);
    public void Ojc=(nzg= pass_mode);
    public void 6zc=(Jzc=[] input_buf, Int32& in_row_group_ctr, int in_row_groups_avail, Byte[][] output_buf, Int32& out_row_ctr, int out_rows_avail);
    private void 7Dc=(Jzc=[] input_buf, Int32& in_row_group_ctr, int in_row_groups_avail, Byte[][] output_buf, Int32& out_row_ctr, int out_rows_avail);
    private void 7Tc=(Jzc=[] input_buf, Int32& in_row_group_ctr, int in_row_groups_avail, Int32& out_row_ctr);
    private void 7jc=(Byte[][] output_buf, Int32& out_row_ctr, int out_rows_avail);
}
internal class WTM=.5zw= : object {
    private static int 6Dw=;
    private static Int32[] 6Tw=;
    internal static Int32[] 6jw=;
    private static int ajw=;
    private static int azw=;
    private static int bDw=;
    private static int bTw=;
    private static int bjw=;
    private static int bzw=;
    private static int cDw=;
    private static int cTw=;
    private static int cjw=;
    private static int 6zw=;
    private static int 7Dw=;
    private static int WDw=;
    private static int 7Tw=;
    private static int 7jw=;
    private static int 7zw=;
    private static int 8Dw=;
    private static int 8Tw=;
    private static int 8jw=;
    private static int 8zw=;
    internal int DRk=;
    internal int 9Dw=;
    internal int 9Tw=;
    internal int Qx0=;
    internal Int32[] 9jw=;
    internal Int32[] 9zw=;
    internal Int32[] /Dw=;
    internal DT0= /Tw=;
    internal int /jw=;
    internal int /zw=;
    internal int AD0=;
    internal Int32[] AT0=;
    internal Byte[] mTw=;
    internal int Aj0=;
    internal int Az0=;
    internal int BD0=;
    internal object BT0=;
    internal long Bj0=;
    internal 5zw=(dz0= z, object checkfn, int w);
    private static 5zw=();
    internal void Bz0=(dz0= z, Int64[] c);
    internal int CD0=(dz0= z, int r);
    internal void CT0=(dz0= z);
    internal void Cj0=(Byte[] d, int start, int n);
    internal int Cz0=();
    internal int DD0=(dz0= z, int r);
}
[FlagsAttribute]
internal enum WTM=.7jY= : Enum {
    public int value__;
    public static 7jY= czM=;
    public static 7jY= dDM=;
    public static 7jY= 7zY=;
    public static 7jY= 8DY=;
    public static 7jY= 8TY=;
    public static 7jY= 8jY=;
    public static 7jY= 8zY=;
    public static 7jY= 9DY=;
    public static 7jY= 9TY=;
    public static 7jY= 9jY=;
    public static 7jY= 9zY=;
    public static 7jY= /DY=;
    public static 7jY= /TY=;
    public static 7jY= /jY=;
    public static 7jY= /zY=;
    public static 7jY= ADc=;
    public static 7jY= ATc=;
    public static 7jY= Ajc=;
    public static 7jY= Azc=;
}
internal class WTM=.7Tg= : object {
    private nzg= 7jg=;
    private oDk= Yjc=;
    private int 7zg=;
    private int 8Dg=;
    private int wzc=;
    private int xDc=;
    private OTk=[][] xTc=;
    private UDs=[] xjc=;
    public 7Tg=(oDk= cinfo, bool need_full_buffer);
    public virtual void Ojc=(nzg= pass_mode);
    public virtual bool kjc=(Byte[][][] input_buf);
    private bool 8Tg=(Byte[][][] input_buf);
    private bool 8jg=(Byte[][][] input_buf);
    private bool 8zg=();
    private void 0zc=();
}
internal abstract class WTM=.7zc= : object {
    private static Int32[] 8Dc=;
    private static Int32[] 8Tc=;
    protected static int 8jc=;
    protected static int 8zc=;
    protected UTo= Yjc=;
    protected bool 9Dc=;
    private static 7zc=();
    public abstract virtual void Ojc=();
    public abstract virtual bool Ozc=(OTk=[] MCU_data);
    protected static int 9Tc=(int x, int s);
    protected void 9jc=(Ijc= bitstate, Int32& get_buffer, Int32& bits_left, JTc=& br_state);
    protected static void 9zc=(Ijc=& bitstate, int get_buffer, int bits_left);
    protected void /Dc=(bool isDC, int tblno, Kjc=& dtbl);
    protected static bool /Tc=(JTc=& state, int nbits, Int32& get_buffer, Int32& bits_left);
    protected static int /jc=(int nbits, int get_buffer, Int32& bits_left);
    protected static int /zc=(int nbits, int get_buffer, int bits_left);
    protected static void ADg=(int nbits, Int32& bits_left);
    protected static bool ATg=(JTc=& state, int get_buffer, int bits_left, int nbits);
    protected static bool Ajg=(Int32& result, JTc=& state, Kjc= htbl, Int32& get_buffer, Int32& bits_left);
    protected static int Azg=(JTc=& state, int get_buffer, int bits_left, Kjc= htbl, int min_bits);
}
internal enum WTM=.8jo= : Enum {
    public int value__;
    public static 8jo= 8zo=;
    public static 8jo= 9Do=;
    public static 8jo= 9To=;
    public static 8jo= 9jo=;
    public static 8jo= 9zo=;
    public static 8jo= /Do=;
    public static 8jo= /To=;
    public static 8jo= /jo=;
    public static 8jo= /zo=;
    public static 8jo= ADs=;
    public static 8jo= ATs=;
    public static 8jo= Ajs=;
    public static 8jo= Azs=;
    public static 8jo= BDs=;
    public static 8jo= BTs=;
    public static 8jo= Bjs=;
    public static 8jo= Bzs=;
    public static 8jo= CDs=;
    public static 8jo= CTs=;
    public static 8jo= Cjs=;
    public static 8jo= Czs=;
    public static 8jo= DDs=;
    public static 8jo= DTs=;
    public static 8jo= Djs=;
    public static 8jo= Dzs=;
    public static 8jo= EDs=;
    public static 8jo= ETs=;
    public static 8jo= Ejs=;
    public static 8jo= Ezs=;
    public static 8jo= FDs=;
    public static 8jo= FTs=;
    public static 8jo= Fjs=;
    public static 8jo= Fzs=;
    public static 8jo= GDs=;
    public static 8jo= GTs=;
    public static 8jo= Gjs=;
    public static 8jo= Gzs=;
    public static 8jo= HDs=;
    public static 8jo= HTs=;
    public static 8jo= Hjs=;
    public static 8jo= Hzs=;
    public static 8jo= IDs=;
    public static 8jo= ITs=;
    public static 8jo= Ijs=;
    public static 8jo= Izs=;
    public static 8jo= JDs=;
    public static 8jo= JTs=;
    public static 8jo= Jjs=;
    public static 8jo= Jzs=;
    public static 8jo= KDs=;
    public static 8jo= KTs=;
    public static 8jo= Kjs=;
    public static 8jo= Kzs=;
}
internal class WTM=.9Dg= : 3jo= {
    private static int 9Tg=;
    private oDk= Yjc=;
    private Stream 9jg=;
    private Byte[] ITQ=;
    public 9Dg=(oDk= cinfo, Stream alreadyOpenFile);
    public virtual void yTU=();
    public virtual bool yjU=();
    public virtual void yzU=();
    private void 9zg=(int dataCount);
}
internal class WTM=.BDc= : ValueType {
    public static int BTc=;
    public static int Bjc=;
    public static int Bzc=;
    public short CDc=;
    public short CTc=;
    public ulong Cjc=;
    public short Czc=;
    public short DDc=;
    public static int 3zY=(bool isBigTiff);
}
internal abstract class WTM=.BDg= : object {
    protected static int BTg=;
    private static int Bjg=;
    protected oDk= Yjc=;
    public abstract virtual void Ojc=(bool gather_statistics);
    public abstract virtual bool Qjc=(OTk=[][] MCU_data);
    public abstract virtual void Qzc=();
    protected void Bzg=(bool isDC, int tblno, c_derived_tbl& dtbl);
    protected void CDg=(Ojk= htbl, Int64[] freq);
}
[FlagsAttribute]
internal enum WTM=.bjM= : Enum {
    public int value__;
    public static bjM= bzM=;
    public static bjM= cDM=;
    public static bjM= cTM=;
}
internal class WTM=.BTk= : SDs= {
    private static int Bjk=;
    private UTo= Yjc=;
    private Stream Bzk=;
    private Byte[] ITQ=;
    private bool CDk=;
    public BTk=(UTo= cinfo);
    public void CTk=(Stream infile);
    public virtual void zjU=();
    public virtual bool zzU=();
}
internal class WTM=.cDk= : object {
    private int cTk=;
    private int mDg=;
    private int cjk=;
    private int czk=;
    private int dDk=;
    private int dTk=;
    private int djk=;
    private int dzk=;
    internal int eDk=;
    internal int eTk=;
    internal int ejk=;
    internal int ezk=;
    internal bool fDk=;
    internal int fTk=;
    internal int fjk=;
    internal int fzk=;
    internal int gDk=;
    internal int gTk=;
    internal int gjk=;
    internal Tjs= gzk=;
    public int hjk= { get; public set; }
    public int iTk= { get; public set; }
    public int jDk= { get; public set; }
    public int jzk= { get; public set; }
    public int kjk= { get; public set; }
    public int lTk= { get; public set; }
    public int mDk= { get; public set; }
    public int mzk= { get; public set; }
    public int nTk= { get; }
    internal void njk=(cDk= ci);
    public int hDk=();
    public void hTk=(int value);
    public int hzk=();
    public void iDk=(int value);
    public int ijk=();
    public void izk=(int value);
    public int jTk=();
    public void jjk=(int value);
    public int kDk=();
    public void kTk=(int value);
    public int kzk=();
    public void lDk=(int value);
    public int ljk=();
    public void lzk=(int value);
    public int mTk=();
    public void mjk=(int value);
    public int nDk=();
    internal static cDk=[] nzk=(int length);
}
internal class WTM=.Cjk= : object {
    private oDk= Yjc=;
    private int 7zg=;
    private int 8Dg=;
    private int wzc=;
    private int xDc=;
    private UDs=[] xjc=;
    private OTk=[][] Czk=;
    public Cjk=(oDk= cinfo, UDs=[] coef_arrays);
    public virtual void Ojc=(nzg= pass_mode);
    public virtual bool kjc=(Byte[][][] input_buf);
    private void 0zc=();
}
internal enum WTM=.cjM= : Enum {
    public int value__;
    public static cjM= czM=;
    public static cjM= dDM=;
}
internal class WTM=.cT0= : object {
    private static string cj0=;
    public static int cz0=;
    public static int dD0=;
    public static int dT0=;
    public static int VTw=;
    public static int Yjw=;
    public static int Yzw=;
    public static int ZDw=;
    public static int ZTw=;
    public static int Zjw=;
    public static int Zzw=;
    public static int aDw=;
    public static int aTw=;
    public static int ajw=;
    public static int azw=;
    public static int bDw=;
    public static int bTw=;
    public static int bjw=;
    public static int bzw=;
    public static int cDw=;
    public static int cTw=;
    public static int cjw=;
    public static string dj0=();
}
internal class WTM=.CTg= : object {
    private static int Cjg=;
    private static int Czg=;
    private static int DDg=;
    private static int DTg=;
    private static int Djg=;
    private static int Dzg=;
    private static int EDg=;
    private static int ETg=;
    private static int Ejg=;
    private static int Ezg=;
    private static int FDg=;
    private static int FTg=;
    private static int Fjg=;
    private static int Fzg=;
    private static int GDg=;
    private static int GTg=;
    private static int Gjg=;
    private static int Gzg=;
    private static int HDg=;
    private static int HTg=;
    private static Int16[] Hjg=;
    private static Double[] Hzg=;
    private oDk= Yjc=;
    private bool IDg=;
    private bool ITg=;
    private Int32[][] Ijg=;
    private Single[][] Izg=;
    public CTg=(oDk= cinfo);
    private static CTg=();
    public virtual void Ojc=();
    public virtual void JDg=(int quant_tbl_no, Byte[][] sample_data, OTk=[] coef_blocks, int start_row, int start_col, int num_blocks);
    private void JTg=(int quant_tbl_no, Byte[][] sample_data, OTk=[] coef_blocks, int start_row, int start_col, int num_blocks);
    private void Jjg=(int quant_tbl_no, Byte[][] sample_data, OTk=[] coef_blocks, int start_row, int start_col, int num_blocks);
    private static void Jzg=(Single[] data);
    private static void KDg=(Int32[] data);
    private static void KTg=(Int32[] data);
    private static int Kjg=(int var, int c);
}
internal class WTM=.CTY= : TiffCodec {
    internal static int CjY=;
    internal static int CzY=;
    internal static int DDY=;
    internal static int DTY=;
    internal static int DjY=;
    internal static int DzY=;
    internal static int EDY=;
    internal static int ETY=;
    private static int EjY=;
    private static TiffFieldInfo[] EzY=;
    internal UInt32 FDY=;
    internal UInt32 FTY=;
    internal byte FjY=;
    internal bool FzY=;
    internal bool GDY=;
    internal byte GTY=;
    internal byte GjY=;
    internal byte GzY=;
    internal byte HDY=;
    internal byte HTY=;
    internal UInt32[] HjY=;
    internal UInt32[] HzY=;
    internal UInt32[] IDY=;
    internal ushort ITY=;
    internal UTo= IjY=;
    private TiffTagMethods CjQ=;
    private TiffTagMethods CTQ=;
    private UInt32 IzY=;
    private UInt32 JDY=;
    private UInt32 JTY=;
    private UInt32 JjY=;
    private UInt32 JzY=;
    private UInt32 KDY=;
    private byte KTY=;
    private byte KjY=;
    private byte KzY=;
    private bool LDY=;
    private bool LTY=;
    private Byte[][] LjY=;
    private Byte[][] LzY=;
    private Byte[][] MDY=;
    private byte MTY=;
    private bool MjY=;
    private byte MzY=;
    private UInt32 NDY=;
    private UInt32 NTY=;
    private Byte[] NjY=;
    private Byte[] NzY=;
    private Byte[] ODY=;
    private Byte[] OTY=;
    private Byte[] OjY=;
    private AEE=[] OzY=;
    private bool PDY=;
    private bool PTY=;
    private short PjY=;
    private UInt32 PzY=;
    private bool QDY=;
    private byte QTY=;
    private 5Do= QjY=;
    private SDs= QzY=;
    private bool RDY=;
    private UInt32 RTY=;
    private UInt32 RjY=;
    private UInt32 RzY=;
    private UInt32 SDY=;
    private Byte[][] STY=;
    private Byte[][] SjY=;
    private Byte[][] SzY=;
    private Byte[][][] TDY=;
    private UInt32 TTY=;
    private UInt32 TjY=;
    private UInt32 TzY=;
    private UInt32 UDY=;
    private 40A= UTY=;
    private UInt32 UjY=;
    private UInt32 UzY=;
    private UInt32 VDY=;
    private bool VTY=;
    private UInt32 VjY=;
    private ushort VzY=;
    private int WDY=;
    private Byte[] WTY=;
    private 6EA= WjY=;
    private Byte[] WzY=;
    private Byte[] XDY=;
    private bool XTY=;
    public bool CanEncode { get; }
    public bool CanDecode { get; }
    public CTY=(Tiff tif, Compression scheme, string name);
    private static CTY=();
    private void LzQ=();
    public virtual bool Init();
    public virtual bool get_CanEncode();
    public virtual bool get_CanDecode();
    public Tiff mjU=();
    public virtual bool SetupDecode();
    public virtual bool PreDecode(short plane);
    public virtual bool DecodeRow(Byte[] buffer, int offset, int count, short plane);
    public virtual bool DecodeStrip(Byte[] buffer, int offset, int count, short plane);
    public virtual bool DecodeTile(Byte[] buffer, int offset, int count, short plane);
    public virtual bool SetupEncode();
    public virtual bool PreEncode(short plane);
    public virtual bool PostEncode();
    public virtual bool EncodeRow(Byte[] buffer, int offset, int count, short plane);
    public virtual bool EncodeStrip(Byte[] buffer, int offset, int count, short plane);
    public virtual bool EncodeTile(Byte[] buffer, int offset, int count, short plane);
    public virtual void Cleanup();
    internal void XjY=(bool force);
    private bool XzY=();
    private bool YDY=(short s);
    private bool YTY=(Byte[] buf, int offset, int cc, short s);
    private bool YjY=();
    private void YzY=();
    private bool ZDY=();
    private bool ZTY=();
    private bool ZjY=(Byte[] buf, int offset, int cc);
    private bool ZzY=(Byte[] buf, int offset, int cc);
    public void aDY=();
    private bool aTY=();
    private bool ajY=(short s);
    private bool azY=();
    private void bDY=();
    private bool bTY=();
    private bool bjY=();
    private bool bzY=();
    private bool cDY=();
    private bool cTY=(byte marker_id);
    private bool cjY=();
    private bool czY=();
    private bool dDY=();
    private bool dTY=();
    private bool djY=();
    private bool dzY=(Byte& b);
    public bool eDY=(Byte& b);
    private void eTY=();
    private bool ejY=(UInt16& word);
    public bool ezY=(ushort len, Byte[] mem, int offset);
    private void fDY=(ushort len);
    internal bool fTY=(Byte[]& mem, UInt32& len);
    private void fjY=(Byte[]& mem, UInt32& len);
    private void fzY=(byte table_index, Byte[]& mem, UInt32& len);
    private void gDY=(byte table_index, Byte[]& mem, UInt32& len);
    private void gTY=(byte table_index, Byte[]& mem, UInt32& len);
    private void gjY=(Byte[]& mem, UInt32& len);
    private void gzY=(Byte[]& mem, UInt32& len);
    private void hDY=(Byte[]& mem, UInt32& len);
    private bool hTY=(Byte[]& mem, UInt32& len);
    private void hjY=(Byte[]& mem, UInt32& len);
    private void hzY=(Byte[]& mem, UInt32& len);
    private bool iDY=();
    private yDs= iTY=(bool require_image);
    private bool ijY=();
    private int izY=(Byte[] scanlines, int max_lines);
    private int jDY=(int max_lines);
}
internal class WTM=.czc= : object {
    private static int Vjc=;
    private static int Ezc=;
    private CkE= dDc=;
    private UTo= Yjc=;
    private Int32[] dTc=;
    private Int32[] djc=;
    private Int32[] dzc=;
    private Int32[] eDc=;
    private Int32[] eTc=;
    public czc=(UTo= cinfo);
    public void ajc=(Jzc=[] input_buf, Int32[] perComponentOffsets, int input_row, Byte[][] output_buf, int output_row, int num_rows);
    private void ejc=();
    private void ezc=(Jzc=[] input_buf, int input_row, Byte[][] output_buf, int output_row, int num_rows);
    private void fDc=(Jzc=[] input_buf, int input_row, Byte[][] output_buf, int output_row, int num_rows);
    private void fTc=(Jzc=[] input_buf, int input_row, Byte[][] output_buf, int output_row, int num_rows);
    private void cTc=(Jzc=[] input_buf, int input_row, Byte[][] output_buf, int output_row, int num_rows);
    private void cjc=(Jzc=[] input_buf, int input_row, Byte[][] output_buf, int output_row, int num_rows);
    private static int bTc=(double x);
}
internal class WTM=.DDk= : nTg= {
    private UTo= Yjc=;
    private Jzc=[] mTc=;
    private Int32[] dTc=;
    private Q0E=[] DTk=;
    private int Djk=;
    private int Dzk=;
    private int EDk=;
    private int mzc=;
    private Int32[] ETk=;
    private Byte[] Ejk=;
    private Byte[] Ezk=;
    public DDk=(UTo= cinfo);
    public virtual void Ojc=();
    public virtual void njg=(Jzc=[] input_buf, Int32& in_row_group_ctr, int in_row_groups_avail, Byte[][] output_buf, Int32& out_row_ctr, int out_rows_avail);
    private void FDk=(Jzc=& input_data);
    private static void FTk=();
    private void Fjk=(Jzc=& input_data);
    private void Fzk=(int downsampled_width, Jzc=& input_data);
    private void GDk=(Jzc=& input_data);
    private void GTk=(int downsampled_width, Jzc=& input_data);
    private void Gjk=(Jzc=& input_data);
    private void Gzk=(Jzc=& input_data);
}
internal class WTM=.DT0= : object {
    private static Int32[] 6Tw=;
    private static int ajw=;
    private static int azw=;
    private static int bDw=;
    private static int bTw=;
    private static int bjw=;
    private static int bzw=;
    private static int cDw=;
    private static int cTw=;
    private static int cjw=;
    private static int Dj0=;
    private static int Dz0=;
    private static int ED0=;
    private static int ET0=;
    private static int Ej0=;
    private static int Ez0=;
    private static int FD0=;
    private static int FT0=;
    private static int Fj0=;
    private static int Fz0=;
    internal int DRk=;
    internal int GD0=;
    internal Int32[] GT0=;
    internal int Gj0=;
    internal int Gz0=;
    internal int HD0=;
    internal int HT0=;
    internal int Hj0=;
    internal byte Hz0=;
    internal byte ID0=;
    internal Int32[] IT0=;
    internal int Ij0=;
    internal Int32[] Iz0=;
    internal int JD0=;
    internal DT0=(int bl, int bd, Int32[] tl, int tl_index, Int32[] td, int td_index, dz0= z);
    internal DT0=(int bl, int bd, Int32[] tl, Int32[] td, dz0= z);
    private static DT0=();
    internal int CD0=(5zw= s, dz0= z, int r);
    internal void CT0=(dz0= z);
    internal int JT0=(int bl, int bd, Int32[] tl, int tl_index, Int32[] td, int td_index, 5zw= s, dz0= z);
}
internal class WTM=.DTc= : ValueType {
    public TiffFieldInfo Djc=;
    public int siw=;
    public Byte[] Dzc=;
}
internal enum WTM=.dTM= : Enum {
    public int value__;
    public static dTM= djM=;
    public static dTM= dzM=;
    public static dTM= eDM=;
    public static dTM= eTM=;
    public static dTM= ejM=;
}
internal class WTM=.dz0= : object {
    private static int Vjw=;
    private static int eD0=;
    private static int ZTw=;
    private static int Zjw=;
    private static int Zzw=;
    private static int aDw=;
    private static int aTw=;
    private static int VDw=;
    private static int ajw=;
    private static int azw=;
    private static int bDw=;
    private static int bTw=;
    private static int bjw=;
    private static int bzw=;
    private static int cDw=;
    private static int cTw=;
    private static int cjw=;
    public Byte[] eT0=;
    public int ej0=;
    public int ez0=;
    public long fD0=;
    public Byte[] fT0=;
    public int fj0=;
    public int fz0=;
    public long gD0=;
    public string gT0=;
    internal Uzw= gj0=;
    internal Jj0= gz0=;
    internal int kzw=;
    public long hD0=;
    internal Tzw= hT0=;
    public int Oz0=();
    public int OT0=();
    public int Oz0=(int w);
    public int PD0=(int f);
    public int Oj0=();
    public int Pj0=();
    public int PT0=(Byte[] dictionary, int dictLength);
    public int 4Dw=(int level);
    public int 4Dw=(int level, int bits);
    public int 5jw=(int flush);
    public int 4zw=();
    public int 5Dw=(int level, int strategy);
    public int 5Tw=(Byte[] dictionary, int dictLength);
    internal void hj0=();
    internal int hz0=(Byte[] buf, int start, int size);
    public void CT0=();
}
internal class WTM=.EDc= : object {
    private static int ETc=;
    private static int Ejc=;
    private static int Ezc=;
    private Byte[] FDc=;
    private Int32[] FTc=;
    private Int32[] Fjc=;
    private Int32[] Fzc=;
    private Int32[] GDc=;
    private Int32[] GTc=;
    public void Lh8=(Single[] luma, Single[] refBlackWhite);
    public void Gjc=(int Y, int Cb, int Cr, Int32& r, Int32& g, Int32& b);
    private static int Gzc=(float x);
    private static int HDc=(int c, float RB, float RW, float CR);
    private static int HTc=(int f, int min, int max);
    private static int Hjc=(int f, int max);
}
[FlagsAttribute]
internal enum WTM=.ezM= : Enum {
    public int value__;
    public static ezM= fDM=;
    public static ezM= fTM=;
    public static ezM= fjM=;
    public static ezM= fzM=;
}
internal interface WTM=.fjc= {
    public abstract virtual void Ojc=(bool is_pre_scan);
    public abstract virtual void fzc=(Byte[][] input_buf, int in_row, Byte[][] output_buf, int out_row, int num_rows);
    public abstract virtual void Qzc=();
    public abstract virtual void gDc=();
}
internal enum WTM=.gDM= : Enum {
    public int value__;
    public static gDM= gTM=;
    public static gDM= gjM=;
}
internal class WTM=.gjU= : TiffCodec {
    public static int gzU=;
    public static int 4TM=;
    public static int 4jM=;
    public static int 4zM=;
    public static int 5DM=;
    internal oDk= hDU=;
    internal UTo= hTU=;
    internal Wjk= hjU=;
    internal int hzU=;
    internal int iDU=;
    internal Byte[] iTU=;
    internal int ijU=;
    internal int izU=;
    internal gzM= jDU=;
    internal iTM= jTU=;
    internal bool jjU=;
    internal int 6zM=;
    internal string 7DM=;
    internal int 7TM=;
    internal string 7jM=;
    private static TiffFieldInfo[] jzU=;
    private bool kDU=;
    private bool kTU=;
    private TiffTagMethods CjQ=;
    private TiffTagMethods CTQ=;
    private bool kjU=;
    internal 5Do= kzU=;
    private jzM= lDU=;
    private int lTU=;
    private Byte[][][] ljU=;
    private int lzU=;
    private int mDU=;
    public bool CanEncode { get; }
    public bool CanDecode { get; }
    public gjU=(Tiff tif, Compression scheme, string name);
    private static gjU=();
    private void LzQ=();
    public virtual bool Init();
    public virtual bool get_CanEncode();
    public virtual bool get_CanDecode();
    public virtual bool SetupDecode();
    public virtual bool PreDecode(short plane);
    public virtual bool DecodeRow(Byte[] buffer, int offset, int count, short plane);
    public virtual bool DecodeStrip(Byte[] buffer, int offset, int count, short plane);
    public virtual bool DecodeTile(Byte[] buffer, int offset, int count, short plane);
    public virtual bool SetupEncode();
    public virtual bool PreEncode(short plane);
    public virtual bool PostEncode();
    public virtual bool EncodeRow(Byte[] buffer, int offset, int count, short plane);
    public virtual bool EncodeStrip(Byte[] buffer, int offset, int count, short plane);
    public virtual bool EncodeTile(Byte[] buffer, int offset, int count, short plane);
    public virtual void Cleanup();
    public virtual int DefStripSize(int size);
    public virtual void DefTileSize(Int32& width, Int32& height);
    public bool mTU=(bool force_encode, bool force_decode);
    public Tiff mjU=();
    public void mzU=();
    private bool nDU=(short s);
    private bool nTU=();
    private bool njU=();
    private void nzU=();
    private bool oDU=(short s);
    private bool oTU=();
    private bool ojU=();
    private int ozU=(Byte[][] scanlines, int max_lines);
    private bool pDU=(Byte[] buffer, int offset, int count, short plane);
    private bool pTU=(Byte[] buffer, int offset, int count, short plane);
    private bool pjU=(Byte[] buffer, int offset, int count, short plane);
    private bool pzU=(Byte[] buffer, int offset, int count, short plane);
    private int qDU=(int s);
    private void qTU=(Int32& tw, Int32& th);
    private bool qjU=();
    private bool qzU=();
    private bool rDU=();
    private bool rTU=(VTs= colorspace);
    private bool rjU=(int quality, bool force_baseline);
    private bool rzU=(bool suppress);
    private bool sDU=(bool write_all_tables);
    private int sTU=(Byte[][] scanlines, int num_lines);
    private int sjU=(Byte[][][] data, int num_lines);
    private bool szU=();
    private bool tDU=();
    private yDs= tTU=(bool require_image);
    private bool tjU=();
    private int tzU=(Byte[][][] data, int max_lines);
    private bool uDU=();
    private bool uTU=();
    private bool ujU=();
    private static Byte[][] uzU=(int samplesperrow, int numrows);
    private bool vDU=(cDk=[] comp_info, int num_components);
    private void vTU=(int tblno);
    private void vjU=(int tblno);
    private void vzU=();
    private bool wDU=();
}
internal class WTM=.gTc= : object {
    private oDk= Yjc=;
    private bool gjc=;
    private bool gzc=;
    private EEE= hDc=;
    private int hTc=;
    private int hjc=;
    private int hzc=;
    public gTc=(oDk= cinfo, bool transcode_only);
    public void iDc=();
    public void iTc=();
    public void Qzc=();
    public bool ijc=();
    public bool izc=();
    private void jDc=();
    private bool jTc=();
    private void jjc=();
    private void jzc=();
    private void kDc=();
}
internal enum WTM=.gzM= : Enum {
    public int value__;
    public static gzM= hDM=;
    public static gzM= hTM=;
}
internal class WTM=.hDg= : object {
    private oDk= Yjc=;
    private int hTg=;
    public hDg=(oDk= cinfo);
    public void hjg=();
    public void hzg=();
    public void iDg=();
    public void iTg=();
    public void ijg=();
    public void izg=(int marker, int datalen);
    public void jDg=(byte val);
    private void jTg=();
    private void jjg=(8jo= code);
    private void jzg=();
    private void kDg=();
    private void kTg=(int index, bool is_ac);
    private int kjg=(int index);
    private void kzg=();
    private void lDg=(8jo= mark);
    private void lTg=(int value);
    private void Sjc=(int val);
}
internal class WTM=.HDk= : 7zc= {
    private TEE= DjQ=;
    private Ijc= MTc=;
    private BkE= Mjc=;
    private int Mzc=;
    private Kjc=[] HTk=;
    private Kjc= Hjk=;
    public HDk=(UTo= cinfo);
    public virtual void Ojc=();
    public virtual bool Ozc=(OTk=[] MCU_data);
    private bool Hzk=(OTk=[] MCU_data);
    private bool IDk=(OTk=[] MCU_data);
    private bool ITk=(OTk=[] MCU_data);
    private bool Ijk=(OTk=[] MCU_data);
    private bool PDc=();
    private static void Izk=(OTk=[] block, Int32[] newnz_pos, int num_newnz);
}
internal enum WTM=.hjM= : Enum {
    public int value__;
    public static hjM= hzM=;
    public static hjM= iDM=;
}
internal enum WTM=.Hzc= : Enum {
    public int value__;
    public static Hzc= bRQ=;
    public static Hzc= IDc=;
    public static Hzc= ITc=;
}
internal class WTM=.iD0= : IOException {
    public iD0=(string s);
}
internal class WTM=.Ijc= : ValueType {
    public int Izc=;
    public int JDc=;
}
[FlagsAttribute]
internal enum WTM=.iTM= : Enum {
    public int value__;
    public static iTM= ijM=;
    public static iTM= izM=;
    public static iTM= jDM=;
}
internal class WTM=.izQ= : TiffTagMethods {
    public virtual bool SetField(Tiff tif, TiffTag tag, FieldValue[] ap);
    public virtual FieldValue[] GetField(Tiff tif, TiffTag tag);
    public virtual void PrintDir(Tiff tif, Stream fd, TiffPrintFlags flags);
}
internal class WTM=.JDk= : BDg= {
    private static int JTk=;
    private UUE= Jjk=;
    private bool Pjc=;
    private int Jzk=;
    private int KDk=;
    private Int32[] KTk=;
    private int Kjk=;
    private int Kzk=;
    private int LDk=;
    private Char[] LTk=;
    private int Mzc=;
    private int Pzc=;
    private c_derived_tbl[] HTk=;
    private Int64[][] Ljk=;
    public JDk=(oDk= cinfo);
    public virtual void Ojc=(bool gather_statistics);
    public virtual bool Qjc=(OTk=[][] MCU_data);
    public virtual void Qzc=();
    private bool Lzk=(OTk=[][] MCU_data);
    private bool MDk=(OTk=[][] MCU_data);
    private bool MTk=(OTk=[][] MCU_data);
    private bool Mjk=(OTk=[][] MCU_data);
    private void Mzk=();
    private void NDk=();
    private void Sjc=(int val);
    private void Szc=(int code, int size);
    private void TDc=();
    private void NTk=(int tbl_no, int symbol);
    private void Njk=(int offset, int nbits);
    private void Nzk=();
    private void TTc=(int restart_num);
    private static int ODk=(int x, int shft);
}
internal class WTM=.jDQ= : YjQ= {
    public static int jTQ=;
    public static int jjQ=;
    public dz0= jzQ=;
    public int kDQ=;
    public int kTQ=;
    private static TiffFieldInfo[] kjQ=;
    private TiffTagMethods CjQ=;
    public bool CanEncode { get; }
    public bool CanDecode { get; }
    public jDQ=(Tiff tif, Compression scheme, string name);
    private static jDQ=();
    public virtual bool Init();
    public virtual bool get_CanEncode();
    public virtual bool get_CanDecode();
    public virtual bool PreDecode(short plane);
    public virtual bool PreEncode(short plane);
    public virtual bool PostEncode();
    public virtual void Cleanup();
    public virtual bool bjQ=();
    public virtual bool bzQ=(Byte[] buffer, int offset, int count, short plane);
    public virtual bool cDQ=(Byte[] buffer, int offset, int count, short plane);
    public virtual bool cTQ=(Byte[] buffer, int offset, int count, short plane);
    public virtual bool cjQ=();
    public virtual bool czQ=(Byte[] buffer, int offset, int count, short plane);
    public virtual bool dDQ=(Byte[] buffer, int offset, int count, short plane);
    public virtual bool dTQ=(Byte[] buffer, int offset, int count, short plane);
    private void kzQ=();
    private bool lDQ=(Byte[] buffer, int offset, int count, short plane);
    private bool lTQ=(Byte[] buffer, int offset, int count, short plane);
    private bool ljQ=();
    private bool lzQ=(short s);
    private bool mDQ=(short s);
    private bool mTQ=();
    private bool mjQ=();
}
internal class WTM=.Jj0= : object {
    private static int Vjw=;
    private static int YTw=;
    internal static int ZTw=;
    internal static int Zjw=;
    internal static int Zzw=;
    internal static int aDw=;
    internal static int aTw=;
    private static int djw=;
    private static int ajw=;
    private static int azw=;
    private static int bDw=;
    private static int bTw=;
    private static int bjw=;
    private static int bzw=;
    private static int cDw=;
    private static int cTw=;
    private static int cjw=;
    private static int Jz0=;
    private static int KD0=;
    private static int KT0=;
    private static int Kj0=;
    private static int Kz0=;
    private static int LD0=;
    private static int LT0=;
    private static int Lj0=;
    private static int Lz0=;
    private static int MD0=;
    private static int MT0=;
    private static int Mj0=;
    private static int 8jw=;
    private static int 8zw=;
    internal int DRk=;
    internal int lDw=;
    internal Int64[] Mz0=;
    internal long Gz0=;
    internal int ND0=;
    internal int NT0=;
    internal int Nj0=;
    internal 5zw= Nz0=;
    private static Byte[] OD0=;
    private static Jj0=();
    internal int OT0=(dz0= z);
    internal int Oj0=(dz0= z);
    internal int Oz0=(dz0= z, int w);
    internal int PD0=(dz0= z, int f);
    internal int PT0=(dz0= z, Byte[] dictionary, int dictLength);
    internal int Pj0=(dz0= z);
    internal int Pz0=(dz0= z);
}
internal class WTM=.jjY= : 5Do= {
    private CTY= xDU=;
    public jjY=(CTY= sp);
    public virtual void xTU=();
    public virtual void xjU=();
}
internal class WTM=.JTc= : ValueType {
    public int Izc=;
    public int JDc=;
    public UTo= Jjc=;
}
internal enum WTM=.jTM= : Enum {
    public int value__;
    public static jTM= jjM=;
    public static jTM= bzM=;
    public static jTM= cDM=;
}
internal class WTM=.jTY= : TiffTagMethods {
    public virtual bool SetField(Tiff tif, TiffTag tag, FieldValue[] ap);
    public virtual FieldValue[] GetField(Tiff tif, TiffTag tag);
    public virtual void PrintDir(Tiff tif, Stream fd, TiffPrintFlags flags);
}
[DefaultMemberAttribute("Item")]
internal class WTM=.Jzc= : object {
    private Byte[][] ITQ=;
    private Int32[] KDc=;
    private int KTc=;
    public Byte[] xhw= { get; }
    public Jzc=(Byte[][] buf, Int32[] funnyIndices, int funnyOffset);
    public void yhw=(Byte[][] buf, Int32[] funnyIndices, int funnyOffset);
    public Byte[] xBw=(int i);
}
internal enum WTM=.jzM= : Enum {
    public int value__;
    public static jzM= kDM=;
    public static jzM= kTM=;
    public static jzM= hTM=;
    public static jzM= kjM=;
    public static jzM= cTM=;
    public static jzM= kzM=;
    public static jzM= lDM=;
    public static jzM= lTM=;
    public static jzM= ljM=;
    public static jzM= lzM=;
    public static jzM= mDM=;
    public static jzM= mTM=;
}
internal class WTM=.jzY= : SDs= {
    protected CTY= xDU=;
    public jzY=(CTY= sp);
    public virtual void zjU=();
    public virtual bool zzU=();
    public virtual void kDY=(int num_bytes);
    public virtual bool kTY=(UTo= cinfo, int desired);
    public virtual void kjY=();
}
internal class WTM=.Kjc= : object {
    public Int32[] Kzc=;
    public Int32[] LDc=;
    public Ojk= LTc=;
    public Int32[] Ljc=;
    public Byte[] Lzc=;
}
internal interface WTM=.kTc= {
    public abstract virtual void Ojc=(nzg= pass_mode);
    public abstract virtual bool kjc=(Byte[][][] input_buf);
}
internal class WTM=.kzc= : object {
    private oDk= Yjc=;
    private int lDc=;
    private int lTc=;
    private bool ljc=;
    private Byte[][][] ITQ=;
    public kzc=(oDk= cinfo);
    public void Ojc=(nzg= pass_mode);
    public void lzc=(Byte[][] input_buf, Int32& in_row_ctr, int in_rows_avail);
}
internal class WTM=.Kzg= : object {
    private UTo= Yjc=;
    private bool LDg=;
    private bool LTg=;
    private bool Ljg=;
    private bool Lzg=;
    public Kzg=(UTo= cinfo);
    public yDs= MDg=();
    public void MTg=();
    public void yjc=();
    public void Mjg=();
    public bool Mzg=();
    public bool NDg=();
    private yDs= NTg=();
    private void Njg=();
    private void Nzg=();
    private void kDc=();
}
internal class WTM=.kzY= : TiffCodec {
    private int lDY=;
    public bool CanEncode { get; }
    public bool CanDecode { get; }
    public kzY=(Tiff tif, Compression scheme, string name);
    public virtual bool Init();
    public virtual bool get_CanEncode();
    public virtual bool get_CanDecode();
    public virtual bool DecodeRow(Byte[] buffer, int offset, int count, short plane);
    public virtual bool DecodeStrip(Byte[] buffer, int offset, int count, short plane);
    public virtual bool DecodeTile(Byte[] buffer, int offset, int count, short plane);
    public virtual bool PreEncode(short plane);
    public virtual bool EncodeRow(Byte[] buffer, int offset, int count, short plane);
    public virtual bool EncodeStrip(Byte[] buffer, int offset, int count, short plane);
    public virtual bool EncodeTile(Byte[] buffer, int offset, int count, short plane);
    private bool lTY=(short s);
    private bool ljY=(Byte[] buf, int offset, int cc, short s);
    private bool lzY=(Byte[] buffer, int offset, int count, short plane);
    private bool mDY=(Byte[] buffer, int offset, int count, short plane);
}
internal class WTM=.LDs= : object {
    private byte 2Dk=;
    private int LTs=;
    private Byte[] EDQ=;
    public byte Lzs= { get; }
    public int MTs= { get; }
    public Byte[] rxM= { get; }
    internal LDs=(byte marker, int originalDataLength, int lengthLimit);
    public byte Ljs=();
    public int MDs=();
    public Byte[] rhM=();
}
internal class WTM=.ljg= : object {
    public int lzg=;
    public Int32[] mDg=;
    public int mTg=;
    public int mjg=;
    public int mzg=;
    public int nDg=;
}
internal class WTM=.mDc= : object {
    private oDk= Yjc=;
    private Byte[][][] mTc=;
    private int mjc=;
    private int mzc=;
    private int nDc=;
    private int nTc=;
    private int njc=;
    public mDc=(oDk= cinfo);
    public void Ojc=(nzg= pass_mode);
    public void nzc=(Byte[][] input_buf, Int32& in_row_ctr, int in_rows_avail, Byte[][][] output_buf, Int32& out_row_group_ctr, int out_row_groups_avail);
    private void oDc=();
    private void oTc=(Byte[][] input_buf, Int32& in_row_ctr, int in_rows_avail, Byte[][][] output_buf, Int32& out_row_group_ctr, int out_row_groups_avail);
    private void ojc=(Byte[][] input_buf, Int32& in_row_ctr, int in_rows_avail, Byte[][][] output_buf, Int32& out_row_group_ctr, int out_row_groups_avail);
    private static void ozc=(Byte[][] image_data, int rowsOffset, int num_cols, int input_rows, int output_rows);
}
internal class WTM=.MDc= : 7zc= {
    private Ijc= MTc=;
    private BkE= Mjc=;
    private int Mzc=;
    private Kjc=[] NDc=;
    private Kjc=[] NTc=;
    private Kjc=[] Njc=;
    private Kjc=[] Nzc=;
    private Boolean[] ODc=;
    private Boolean[] OTc=;
    public MDc=(UTo= cinfo);
    public virtual void Ojc=();
    public virtual bool Ozc=(OTk=[] MCU_data);
    private bool PDc=();
}
internal enum WTM=.mjM= : Enum {
    public int value__;
    public static mjM= fDM=;
    public static mjM= mzM=;
    public static mjM= nDM=;
}
internal class WTM=.Mjs= : object {
    private int Mzs=;
    private int NDs=;
    private int NTs=;
    private int Njs=;
    [CompilerGeneratedAttribute]
private EventHandler Nzs=;
    public int Ojs= { get; public set; }
    public int PTs= { get; public set; }
    public int QDs= { get; public set; }
    public int Qzs= { get; public set; }
    [CompilerGeneratedAttribute]
public void RDs=(EventHandler value);
    [CompilerGeneratedAttribute]
public void RTs=(EventHandler value);
    public int ODs=();
    public void OTs=(int value);
    public int Ozs=();
    public void PDs=(int value);
    public int Pjs=();
    public void Pzs=(int value);
    public int QTs=();
    public void Qjs=(int value);
    public void Rzs=();
}
internal class WTM=.mjY= : object {
    public static int mzY=;
    private int nDY=;
    private float nTY=;
    private float njY=;
    private float nzY=;
    private float oDY=;
    private float oTY=;
    private float ojY=;
    private 4DY= ozY=;
    private Single[] pDY=;
    private Single[] pTY=;
    private Single[] pjY=;
    public void Lh8=(4DY= refDisplay, Single[] refWhite);
    public void pzY=(int l, int a, int b, Single& X, Single& Y, Single& Z);
    public void qDY=(float X, float Y, float Z, Int32& r, Int32& g, Int32& b);
    private static int qTY=(float R);
}
internal class WTM=.mTY= : object {
    private sealed virtual override int System.Collections.IComparer.Compare(object x, object y);
}
internal class WTM=.mzQ= : TiffTagMethods {
    public virtual bool SetField(Tiff tif, TiffTag tag, FieldValue[] ap);
    public virtual FieldValue[] GetField(Tiff tif, TiffTag tag);
}
internal class WTM=.nDQ= : TiffCodec {
    public bool CanEncode { get; }
    public bool CanDecode { get; }
    public nDQ=(Tiff tif, Compression scheme, string name);
    public virtual bool Init();
    public virtual bool get_CanEncode();
    public virtual bool get_CanDecode();
    public virtual bool DecodeRow(Byte[] buffer, int offset, int count, short plane);
    public virtual bool DecodeStrip(Byte[] buffer, int offset, int count, short plane);
    public virtual bool DecodeTile(Byte[] buffer, int offset, int count, short plane);
    public virtual bool EncodeRow(Byte[] buffer, int offset, int count, short plane);
    public virtual bool EncodeStrip(Byte[] buffer, int offset, int count, short plane);
    public virtual bool EncodeTile(Byte[] buffer, int offset, int count, short plane);
    public virtual bool Seek(int row);
    private bool nTQ=(Byte[] buffer, int offset, int count, short plane);
    private bool njQ=(Byte[] buffer, int offset, int count, short plane);
}
internal abstract class WTM=.nTg= : object {
    protected bool rzc=;
    public abstract virtual void Ojc=();
    public abstract virtual void njg=(Jzc=[] input_buf, Int32& in_row_group_ctr, int in_row_groups_avail, Byte[][] output_buf, Int32& out_row_ctr, int out_rows_avail);
    public bool sTc=();
}
internal enum WTM=.nTM= : Enum {
    public int value__;
    public static nTM= ijM=;
    public static nTM= njM=;
    public static nTM= nzM=;
}
internal enum WTM=.nzg= : Enum {
    public int value__;
    public static nzg= oDg=;
    public static nzg= oTg=;
    public static nzg= ojg=;
    public static nzg= ozg=;
}
internal class WTM=.ODg= : object {
    private static int OTg=;
    private static int Ojg=;
    private static int Dzg=;
    private static int EDg=;
    private static int ETg=;
    private static int Ejg=;
    private static int Ezg=;
    private static int FDg=;
    private static int FTg=;
    private static int Fjg=;
    private static int Fzg=;
    private static int GDg=;
    private static int GTg=;
    private static int Gjg=;
    private static int Gzg=;
    private static int HDg=;
    private static int Cjg=;
    private static int Ozg=;
    private static int PDg=;
    private static int PTg=;
    private static int Pjg=;
    private static int Pzg=;
    private static int QDg=;
    private static int QTg=;
    private static int Qjg=;
    private static int Qzg=;
    private static int RDg=;
    private static int RTg=;
    private static int Rjg=;
    private static int Rzg=;
    private static int SDg=;
    private static int STg=;
    private static int Sjg=;
    private static int Szg=;
    private static int TDg=;
    private static int TTg=;
    private static int Tjg=;
    private static int Tzg=;
    private static Int16[] Hjg=;
    private static int HTg=;
    private static Double[] Hzg=;
    private J0E=[] UDg=;
    private LkE=[] UTg=;
    private UTo= Yjc=;
    private Int32[] Ujg=;
    private Jzc= Uzg=;
    public ODg=(UTo= cinfo);
    private static ODg=();
    public void Ojc=();
    public void VDg=(int component_index, Int16[] coef_block, Jzc= output_buf, int output_row, int output_col);
    private void VTg=(int component_index, Int16[] coef_block, int output_row, int output_col);
    private static int Vjg=(int coef, int quantval);
    private void Vzg=(int component_index, Int16[] coef_block, int output_row, int output_col);
    private static int Kjg=(int var, int c);
    private static int WDg=(short coef, int quantval);
    private static int WTg=(int x, int shft);
    private static int Wjg=(int x, int n);
    private void Wzg=(int component_index, Int16[] coef_block, int output_row, int output_col);
    private static float XDg=(short coef, float quantval);
    private void XTg=(int component_index, Int16[] coef_block, int output_row, int output_col);
    private void Xjg=(int component_index, Int16[] coef_block, int output_row, int output_col);
    private void Xzg=(int component_index, Int16[] coef_block, int output_row, int output_col);
    private static int YDg=(short coef, int quantval);
}
internal class WTM=.oDk= : Wjk= {
    private static Int32[] oTk=;
    private static Int32[] ojk=;
    private static Byte[] ozk=;
    private static Byte[] pDk=;
    private static Byte[] pTk=;
    private static Byte[] pjk=;
    private static Byte[] pzk=;
    private static Byte[] qDk=;
    private static Byte[] qTk=;
    private static Byte[] qjk=;
    internal 3jo= qzk=;
    internal int JDY=;
    internal int rDk=;
    internal int rTk=;
    internal VTs= rjk=;
    internal int rzk=;
    internal int sDk=;
    internal VTs= sTk=;
    private cDk=[] sjk=;
    internal Tjs=[] szk=;
    internal Ojk=[] tDk=;
    internal Ojk=[] tTk=;
    internal int tjk=;
    internal ljg=[] tzk=;
    internal bool uDk=;
    internal bool uTk=;
    internal bool ujk=;
    internal int uzk=;
    internal XDs= vDk=;
    internal int ITY=;
    internal int vTk=;
    internal bool vjk=;
    internal byte vzk=;
    internal byte wDk=;
    internal Hzc= wTk=;
    internal short wjk=;
    internal short wzk=;
    internal bool xDk=;
    internal int xTk=;
    internal bool xjk=;
    internal int xzk=;
    internal int yDk=;
    internal int yTk=;
    internal int yjk=;
    internal Int32[] yzk=;
    internal int zDk=;
    internal int zTk=;
    internal int zjk=;
    internal Int32[] zzk=;
    internal int 0Dk=;
    internal int 0Tk=;
    internal int 0jk=;
    internal int 0zk=;
    internal gTc= 1Dk=;
    internal kzc= 1Tk=;
    internal mDc= 1jk=;
    internal kTc= 1zk=;
    internal hDg= 2Dk=;
    internal VTc= 2Tk=;
    internal rTc= 2jk=;
    internal CTg= 2zk=;
    internal BDg= 3Dk=;
    internal ljg=[] 3Tk=;
    internal int 3jk=;
    public bool Xjk= { get; }
    public 3jo= 4Tk= { get; public set; }
    public int 5Dk= { get; public set; }
    public int 5zk= { get; public set; }
    public int 6jk= { get; public set; }
    public VTs= 7Tk= { get; public set; }
    public int 8Dk= { get; public set; }
    public int 8zk= { get; public set; }
    public VTs= 9jk= { get; public set; }
    public bool /Tk= { get; public set; }
    public bool ADo= { get; public set; }
    public bool Azo= { get; public set; }
    public int Bjo= { get; public set; }
    public XDs= CTo= { get; public set; }
    public int DDo= { get; public set; }
    public int Dzo= { get; public set; }
    public bool Ejo= { get; public set; }
    public byte FTo= { get; public set; }
    public byte GDo= { get; public set; }
    public Hzc= Gzo= { get; public set; }
    public short Hjo= { get; public set; }
    public short ITo= { get; public set; }
    public bool JDo= { get; public set; }
    public int Jjo= { get; }
    public cDk=[] KDo= { get; }
    public Tjs=[] Kjo= { get; }
    public Ojk=[] LDo= { get; }
    public Ojk=[] Ljo= { get; }
    public int MDo= { get; }
    public oDk=(5Do= errorManager);
    private static oDk=();
    public virtual bool XTk=();
    public 3jo= 3zk=();
    public void 4Dk=(3jo= value);
    public int 4jk=();
    public void 4zk=(int value);
    public int 5Tk=();
    public void 5jk=(int value);
    public int 6Dk=();
    public void 6Tk=(int value);
    public VTs= 6zk=();
    public void 7Dk=(VTs= value);
    public int 7jk=();
    public void 7zk=(int value);
    public int 8Tk=();
    public void 8jk=(int value);
    public VTs= 9Dk=();
    public void 9Tk=(VTs= value);
    public bool 9zk=();
    public void /Dk=(bool value);
    public bool /jk=();
    public void /zk=(bool value);
    public bool ATo=();
    public void Ajo=(bool value);
    public int BDo=();
    public void BTo=(int value);
    public XDs= Bzo=();
    public void CDo=(XDs= value);
    public int Cjo=();
    public void Czo=(int value);
    public int DTo=();
    public void Djo=(int value);
    public bool EDo=();
    public void ETo=(bool value);
    public byte Ezo=();
    public void FDo=(byte value);
    public byte Fjo=();
    public void Fzo=(byte value);
    public Hzc= GTo=();
    public void Gjo=(Hzc= value);
    public short HDo=();
    public void HTo=(short value);
    public short Hzo=();
    public void IDo=(short value);
    public bool Ijo=();
    public void Izo=(bool value);
    public int JTo=();
    public cDk=[] Jzo=();
    public Tjs=[] KTo=();
    public Ojk=[] Kzo=();
    public Ojk=[] LTo=();
    public int Lzo=();
    public void MTo=();
    public void Mjo=(bool suppress);
    public void Mzo=();
    public void NDo=(int marker, Byte[] data);
    public void NTo=(int marker, int datalen);
    public void Njo=(byte val);
    public void Nzo=();
    public void ODo=(Stream outfile);
    public void OTo=();
    public void Ojo=(VTs= colorspace);
    public void Ozo=();
    public void PDo=(int quality, bool force_baseline);
    public void PTo=(int scale_factor, bool force_baseline);
    public void Pjo=(int which_tbl, Int32[] basic_table, int scale_factor, bool force_baseline);
    public static int Pzo=(int quality);
    public void QDo=();
    public void QTo=(bool write_all_tables);
    public int Qjo=(Byte[][] scanlines, int num_lines);
    public int Qzo=(Byte[][][] data, int num_lines);
    public void RDo=(UDs=[] coef_arrays);
    private void RTo=();
    private void Rjo=();
    private void Rzo=(bool transcode_only);
    private void SDo=(bool need_full_buffer);
    private void STo=(UDs=[] coef_arrays);
    private void Njg=();
    private void Sjo=();
    private void Szo=();
    private void TDo=(Ojk=& htblptr, Byte[] bits, Byte[] val);
    private void TTo=(Int32& scanIndex, int ci, int Ss, int Se, int Ah, int Al);
    private void Tjo=(Int32& scanIndex, int ncomps, int Ah, int Al);
    private void Tzo=(Int32& scanIndex, int ncomps, int Ss, int Se, int Ah, int Al);
    private void UDo=(int index, int id, int hsamp, int vsamp, int quant, int dctbl, int actbl);
}
internal enum WTM=.oDM= : Enum {
    public int value__;
    public static oDM= ijM=;
    public static oDM= oTM=;
    public static oDM= ojM=;
}
internal class WTM=.Ojk= : object {
    private Byte[] Ozk=;
    private Byte[] PDk=;
    private bool PTk=;
    internal Byte[] Pzk= { get; }
    internal Byte[] QTk= { get; }
    public bool RDk= { get; public set; }
    internal Byte[] Pjk=();
    internal Byte[] QDk=();
    public bool Qjk=();
    public void Qzk=(bool value);
}
[DefaultMemberAttribute("Item")]
internal class WTM=.OTk= : object {
    internal Int16[] 0BM=;
    public short xhw= { get; public set; }
    public short xBw=(int index);
    public void xRw=(int index, short value);
}
internal enum WTM=.ozM= : Enum {
    public int value__;
    public static ozM= pDM=;
    public static ozM= pTM=;
    public static ozM= pjM=;
    public static ozM= pzM=;
    public static ozM= qDM=;
    public static ozM= qTM=;
}
internal class WTM=.pDc= : object {
    private UTo= Yjc=;
    private int hTc=;
    private bool pTc=;
    private bool pjc=;
    private fjc= pzc=;
    private fjc= qDc=;
    public pDc=(UTo= cinfo);
    public void jjc=();
    public void qTc=();
    public bool qjc=();
    private void qzc=();
    private void rDc=();
}
internal class WTM=.pDg= : object {
    private static Int32[] pTg=;
    private static int pjg=;
    private static int pzg=;
    private static int qDg=;
    private static int qTg=;
    private static Byte[][] qjg=;
    private MUE= qzg=;
    private UTo= Yjc=;
    private Byte[][] rDg=;
    private int rTg=;
    private Byte[][] rjg=;
    private Int32[] rzg=;
    private bool sDg=;
    private Int32[] sTg=;
    private int sjg=;
    private Int32[][][] szg=;
    private Int16[][] tDg=;
    private bool tTg=;
    public pDg=(UTo= cinfo);
    private static pDg=();
    public virtual void Ojc=(bool is_pre_scan);
    public virtual void fzc=(Byte[][] input_buf, int in_row, Byte[][] output_buf, int out_row, int num_rows);
    public virtual void Qzc=();
    public virtual void gDc=();
    private void tjg=(Byte[][] input_buf, int in_row, Byte[][] output_buf, int out_row, int num_rows);
    private void tzg=(Byte[][] input_buf, int in_row, Byte[][] output_buf, int out_row, int num_rows);
    private void uDg=(Byte[][] input_buf, int in_row, Byte[][] output_buf, int out_row, int num_rows);
    private void uTg=(Byte[][] input_buf, int in_row, Byte[][] output_buf, int out_row, int num_rows);
    private void ujg=(Byte[][] input_buf, int in_row, Byte[][] output_buf, int out_row, int num_rows);
    private void uzg=();
    private void vDg=();
    private void vTg=();
    private void vjg=();
    private static int vzg=(int j, int maxj);
    private static int wDg=(int j, int maxj);
    private int wTg=(Int32[] Ncolors);
    private static Int32[][] wjg=(int ncolors);
}
internal class WTM=.PTc= : BDg= {
    private bool Pjc=;
    private BkE= Mjc=;
    private int Mzc=;
    private int Pzc=;
    private c_derived_tbl[] NDc=;
    private c_derived_tbl[] NTc=;
    private Int64[][] QDc=;
    private Int64[][] QTc=;
    public PTc=(oDk= cinfo);
    public virtual void Ojc=(bool gather_statistics);
    public virtual bool Qjc=(OTk=[][] MCU_data);
    public virtual void Qzc=();
    private bool RDc=(OTk=[][] MCU_data);
    private void RTc=();
    private bool Rjc=(OTk=[][] MCU_data);
    private void Rzc=();
    private bool SDc=(BkE= state, Int16[] block, int last_dc_val, c_derived_tbl dctbl, c_derived_tbl actbl);
    private void STc=(Int16[] block, int last_dc_val, Int64[] dc_counts, Int64[] ac_counts);
    private bool Sjc=(int val);
    private bool Szc=(BkE= state, int code, int size);
    private bool TDc=(BkE= state);
    private bool TTc=(BkE= state, int restart_num);
}
internal class WTM=.QD0= : object {
    private static int 6Dw=;
    private static int ajw=;
    private static int azw=;
    private static int bDw=;
    private static int bTw=;
    private static int bjw=;
    private static int bzw=;
    private static int cDw=;
    private static int cTw=;
    private static int cjw=;
    internal static int QT0=;
    internal static int Qj0=;
    internal static Int32[] Qz0=;
    internal static Int32[] RD0=;
    internal static Int32[] RT0=;
    internal static Int32[] Rj0=;
    internal static Int32[] Rz0=;
    internal static Int32[] SD0=;
    internal static int ST0=;
    private static QD0=();
    internal static int Sj0=(Int32[] b, int bindex, int n, int s, Int32[] d, Int32[] e, Int32[] t, Int32[] m, Int32[] hp, Int32[] hn, Int32[] v);
    internal static int Sz0=(Int32[] c, Int32[] bb, Int32[] tb, Int32[] hp, dz0= z);
    internal static int TD0=(int nl, int nd, Int32[] c, Int32[] bl, Int32[] bd, Int32[] tl, Int32[] td, Int32[] hp, dz0= z);
    internal static int TT0=(Int32[] bl, Int32[] bd, Int32[][] tl, Int32[][] td, dz0= z);
}
internal enum WTM=.qjM= : Enum {
    public int value__;
    public static qjM= qzM=;
    public static qjM= rDM=;
    public static qjM= rTM=;
}
internal class WTM=.qjY= : object {
    public Int32[] qzY=;
    public int rDY=;
    public int rTY=;
    public int rjY=;
    public int rzY=;
    public int sDY=;
    public int sTY=;
    public bjM= sjY=;
    public short szY=;
    public ozM= tDY=;
    public Compression tTY=;
    public jzM= tjY=;
    public qjM= tzY=;
    public cjM= uDY=;
    public Orientation uTY=;
    public short ujY=;
    public int uzY=;
    public ushort vDY=;
    public ushort vTY=;
    public double vjY=;
    public double vzY=;
    public float wDY=;
    public float wTY=;
    public oDM= wjY=;
    public mjM= wzY=;
    public float xDY=;
    public float xTY=;
    public Int16[] xjY=;
    public Int16[][] xzY=;
    public Int16[] yDY=;
    public short yTY=;
    public YzM=[] yjY=;
    public int yzY=;
    public int zDY=;
    public UInt64[] zTY=;
    public UInt64[] zjY=;
    public bool zzY=;
    public int 0DY=;
    public Int64[] 0TY=;
    public Int16[] 0jY=;
    public rjM= 0zY=;
    public Single[] 1DY=;
    public Int16[][] 1TY=;
    public int 1jY=;
    public string 1zY=;
    public int 2DY=;
    public DTc=[] 2TY=;
}
internal enum WTM=.rjM= : Enum {
    public int value__;
    public static rjM= rzM=;
    public static rjM= sDM=;
}
internal class WTM=.rTc= : object {
    private FEE=[] rjc=;
    private oDk= Yjc=;
    private bool rzc=;
    public rTc=(oDk= cinfo);
    public void sDc=(Byte[][][] input_buf, int in_row_index, Byte[][][] output_buf, int out_row_group_index);
    public bool sTc=();
    private void sjc=(int componentIndex, Byte[][] input_data, int startInputRow, Byte[][] output_data, int startOutRow);
    private void szc=(int componentIndex, Byte[][] input_data, int startInputRow, Byte[][] output_data, int startOutRow);
    private void tDc=(int componentIndex, Byte[][] input_data, int startInputRow, Byte[][] output_data, int startOutRow);
    private void tTc=(int componentIndex, Byte[][] input_data, int startInputRow, Byte[][] output_data, int startOutRow);
    private void tjc=(int componentIndex, Byte[][] input_data, int startInputRow, Byte[][] output_data, int startOutRow);
    private void tzc=(int componentIndex, Byte[][] input_data, int startInputRow, Byte[][] output_data, int startOutRow);
    private static void uDc=(Byte[][] image_data, int startInputRow, int num_rows, int input_cols, int output_cols);
}
internal static class WTM=.RTk= : object {
    public static int Rjk=;
    public static int Rzk=;
    public static int SDk=;
    public static int STk=;
    public static int Sjk=;
    public static int Szk=;
    public static int TDk=;
    public static int TTk=;
    public static int Tjk=;
    public static int Tzk=;
    public static XDs= UDk=;
    public static XDs= UTk=;
    public static int Ujk=;
    public static int Uzk=;
    public static int VDk=;
    public static int VTk=;
    public static int Vjk=;
    public static int Vzk=;
    public static int WDk=;
    public static int WTk=;
}
internal abstract class WTM=.SDs= : object {
    private Byte[] STs=;
    private int Sjs=;
    private int 3zo=;
    public abstract virtual void zjU=();
    public abstract virtual bool zzU=();
    protected void 4zo=(Byte[] buffer, int size);
    public virtual void kDY=(int num_bytes);
    public virtual bool kTY=(UTo= cinfo, int desired);
    public virtual void kjY=();
    public virtual bool Szs=(Int32& V);
    public virtual bool TDs=(Int32& V);
    public virtual int 7xM=(Byte[] dest, int amount);
    public virtual bool TTs=();
}
internal static class WTM=.sTM= : object {
    internal static int sjM=;
    internal static short szM=;
    internal static short tDM=;
    internal static short tTM=;
    internal static short tjM=;
    internal static short tzM=;
    internal static short uDM=;
    internal static short uTM=;
    internal static short ujM=;
    internal static short uzM=;
    internal static short vDM=;
    internal static short vTM=;
    internal static short vjM=;
    internal static short vzM=;
    internal static short wDM=;
    internal static short wTM=;
    internal static short wjM=;
    internal static short wzM=;
    internal static short xDM=;
    internal static short xTM=;
    internal static short xjM=;
    internal static short xzM=;
    internal static short yDM=;
    internal static short yTM=;
    internal static short yjM=;
    internal static short yzM=;
    internal static short zDM=;
    internal static short zTM=;
    internal static short zjM=;
    internal static short zzM=;
    internal static short 0DM=;
    internal static short 0TM=;
    internal static short 0jM=;
    internal static short 0zM=;
    internal static short 1DM=;
    public static short 1TM=;
    public static short 1jM=;
    public static short 1zM=;
    public static short 2DM=;
    public static short 2TM=;
}
internal class WTM=.Tj0= : object {
    private static int hDw=;
    private static int hjw=;
    private static int hTw=;
    private static int iDw=;
    private static int hzw=;
    private static int iTw=;
    internal static int Tz0=;
    internal static Int16[] UD0=;
    internal static Int16[] UT0=;
    internal static Tj0= Uj0=;
    internal static Tj0= Uz0=;
    internal static Tj0= VD0=;
    internal Int16[] VT0=;
    internal Int32[] Vj0=;
    internal int Vz0=;
    internal int WD0=;
    internal int WT0=;
    internal Tj0=(Int16[] static_tree, Int32[] extra_bits, int extra_base, int elems, int max_length);
    private static Tj0=();
}
internal class WTM=.Tjc= : object {
    public static Int32[] Tzc=;
    private static Tjc=();
    public static int UDc=(int x, int shft);
    public static int UTc=(int x, int n);
    public static int Ujc=(int a, int b);
    public static int Uzc=(int a, int b);
    public static void VDc=(Jzc= input_array, int source_row, Byte[][] output_array, int dest_row, int num_rows, int num_cols);
    public static void VDc=(Jzc= input_array, int source_row, Jzc= output_array, int dest_row, int num_rows, int num_cols);
    public static void VDc=(Byte[][] input_array, int source_row, Byte[][] output_array, int dest_row, int num_rows, int num_cols);
}
internal class WTM=.Tjs= : object {
    private bool PTk=;
    internal Int16[] Tzs=;
    public bool RDk= { get; public set; }
    public bool Qjk=();
    public void Qzk=(bool value);
}
internal class WTM=.Tzw= : object {
    private static int UDw=;
    private static int UTw=;
    internal long Ujw=(long adler, Byte[] buf, int index, int len);
}
internal class WTM=.UDs= : object {
    private Wjk= Yjc=;
    private T[][] ITQ=;
    public Wjk= Uzs= { get; public set; }
    internal UDs=(int width, int height, Z0E=<T> allocator);
    public Wjk= UTs=();
    public void Ujs=(Wjk= value);
    public T[][] VDs=(int startRow, int numberOfRows);
}
internal class WTM=.uTc= : object {
    private static int ujc=;
    private static int uzc=;
    private static int vDc=;
    private static int vTc=;
    private static int vjc=;
    private static int vzc=;
    private UTo= Yjc=;
    private bool wDc=;
    private G0E= wTc=;
    private int wjc=;
    private int wzc=;
    private int xDc=;
    private OTk=[] xTc=;
    private UDs=[] xjc=;
    private UDs=[] xzc=;
    private Int32[] yDc=;
    private int yTc=;
    public uTc=(UTo= cinfo, bool need_full_buffer);
    public void yjc=();
    public yDs= yzc=();
    public void zDc=();
    public yDs= zTc=(Jzc=[] output_buf);
    public UDs=[] zjc=();
    private yDs= zzc=(Jzc=[] output_buf);
    private yDs= 0Dc=(Jzc=[] output_buf);
    private yDs= 0Tc=(Jzc=[] output_buf);
    private bool 0jc=();
    private void 0zc=();
}
internal class WTM=.UTo= : Wjk= {
    internal SDs= Ujo=;
    internal int JDY=;
    internal int rDk=;
    internal int sDk=;
    internal VTs= sTk=;
    internal VTs= Uzo=;
    internal int VDo=;
    internal int VTo=;
    internal bool Vjo=;
    internal bool Vzo=;
    internal XDs= vDk=;
    internal bool WDo=;
    internal bool WTo=;
    internal bool Wjo=;
    internal YDs= Wzo=;
    internal bool XDo=;
    internal int XTo=;
    internal bool Xjo=;
    internal bool Xzo=;
    internal bool YDo=;
    internal int YTo=;
    internal int Yjo=;
    internal int Yzo=;
    internal int ZDo=;
    internal int ZTo=;
    internal int Zjo=;
    internal Byte[][] Zzo=;
    internal int aDo=;
    internal int aTo=;
    internal int ajo=;
    internal int azo=;
    internal int bDo=;
    internal Int32[][] bTo=;
    internal Tjs=[] szk=;
    internal Ojk=[] tDk=;
    internal Ojk=[] tTk=;
    internal int rzk=;
    private cDk=[] sjk=;
    internal bool xjk=;
    internal int ITY=;
    internal bool bjo=;
    internal byte vzk=;
    internal byte wDk=;
    internal Hzc= wTk=;
    internal short wjk=;
    internal short wzk=;
    internal bool bzo=;
    internal byte cDo=;
    internal bool ujk=;
    internal List`1<LDs=> cTo=;
    internal int xzk=;
    internal int yDk=;
    internal int cjo=;
    internal int yTk=;
    internal Byte[] czo=;
    internal int dDo=;
    internal int yjk=;
    internal Int32[] yzk=;
    internal int zDk=;
    internal int zTk=;
    internal int zjk=;
    internal Int32[] zzk=;
    internal int 0Dk=;
    internal int 0Tk=;
    internal int 0jk=;
    internal int 0zk=;
    internal int dTo=;
    internal pDc= 1Dk=;
    internal 1Dc= 1Tk=;
    internal uTc= 1zk=;
    internal 5jc= djo=;
    internal Kzg= dzo=;
    internal YTg= 2Dk=;
    internal 7zc= 3Dk=;
    internal ODg= eDo=;
    internal nTg= eTo=;
    internal czc= 2Tk=;
    internal fjc= ejo=;
    public bool Xjk= { get; }
    public SDs= fTo= { get; public set; }
    public int 5Dk= { get; }
    public int 5zk= { get; }
    public int 8zk= { get; }
    public VTs= 9jk= { get; public set; }
    public VTs= gDo= { get; public set; }
    public int gzo= { get; public set; }
    public int hjo= { get; public set; }
    public bool iTo= { get; public set; }
    public bool jDo= { get; public set; }
    public XDs= CTo= { get; public set; }
    public bool jzo= { get; public set; }
    public bool kjo= { get; public set; }
    public bool lTo= { get; public set; }
    public YDs= mDo= { get; public set; }
    public bool mzo= { get; public set; }
    public int njo= { get; public set; }
    public bool oTo= { get; public set; }
    public bool pDo= { get; public set; }
    public bool pzo= { get; public set; }
    public int qTo= { get; }
    public int qzo= { get; }
    public int rTo= { get; }
    public int rzo= { get; }
    public int sTo= { get; }
    public int tDo= { get; public set; }
    public Byte[][] tzo= { get; public set; }
    public int uTo= { get; }
    public int uzo= { get; }
    public int vTo= { get; }
    public int vzo= { get; }
    public int wTo= { get; }
    public Int32[][] wzo= { get; }
    public Hzc= Gzo= { get; }
    public short Hjo= { get; }
    public short ITo= { get; }
    public int 8Dk= { get; }
    public int Jjo= { get; }
    public int xTo= { get; }
    public cDk=[] yDo= { get; internal set; }
    public UTo=(5Do= errorManager);
    public virtual bool XTk=();
    public SDs= ezo=();
    public void fDo=(SDs= value);
    public int 4jk=();
    public int 5Tk=();
    public int 8Tk=();
    public VTs= 9Dk=();
    public void 9Tk=(VTs= value);
    public VTs= fjo=();
    public void fzo=(VTs= value);
    public int gTo=();
    public void gjo=(int value);
    public int hDo=();
    public void hTo=(int value);
    public bool hzo=();
    public void iDo=(bool value);
    public bool ijo=();
    public void izo=(bool value);
    public XDs= Bzo=();
    public void CDo=(XDs= value);
    public bool jTo=();
    public void jjo=(bool value);
    public bool kDo=();
    public void kTo=(bool value);
    public bool kzo=();
    public void lDo=(bool value);
    public YDs= ljo=();
    public void lzo=(YDs= value);
    public bool mTo=();
    public void mjo=(bool value);
    public int nDo=();
    public void nTo=(int value);
    public bool nzo=();
    public void oDo=(bool value);
    public bool ojo=();
    public void ozo=(bool value);
    public bool pTo=();
    public void pjo=(bool value);
    public int qDo=();
    public int qjo=();
    public int rDo=();
    public int rjo=();
    public int sDo=();
    public int sjo=();
    public void szo=(int value);
    public Byte[][] tTo=();
    public void tjo=(Byte[][] value);
    public int uDo=();
    public int ujo=();
    public int vDo=();
    public int vjo=();
    public int wDo=();
    public Int32[][] wjo=();
    public Hzc= GTo=();
    public short HDo=();
    public short Hzo=();
    public int 7jk=();
    public int JTo=();
    public int xDo=();
    public cDk=[] xjo=();
    internal void xzo=(cDk=[] value);
    public void yTo=(Stream infile);
    public yDs= yjo=(bool require_image);
    public bool yzo=();
    public int zDo=(Byte[][] scanlines, int max_lines);
    public bool zTo=();
    public int zjo=(Byte[][][] data, int max_lines);
    public bool zzo=();
    public bool 0Do=(int scan_number);
    public bool 0To=();
    public bool 0jo=();
    public yDs= 0zo=();
    public void 1Do=();
    public UDs=[] 1To=();
    public void 1jo=(oDk= dstinfo);
    public void 1zo=();
    public void cjg=(int marker_code, jpeg_marker_parser_method routine);
    public void czg=(int marker_code, int length_limit);
    internal bool 2Do=();
    private void RTo=();
    private void 2To=();
    private bool 2jo=();
    private void 2zo=();
    private void 3Do=();
    private yDs= 3To=();
}
internal class WTM=.Uzw= : object {
    private static int VDw=;
    private static int VTw=;
    private static int Vjw=;
    private static int Vzw=;
    private static int WDw=;
    private static int WTw=;
    private static int Wjw=;
    private static aEE=[] Wzw=;
    private static String[] XDw=;
    private static int XTw=;
    private static int Xjw=;
    private static int Xzw=;
    private static int YDw=;
    private static int YTw=;
    private static int Yjw=;
    private static int Yzw=;
    private static int ZDw=;
    private static int ZTw=;
    private static int Zjw=;
    private static int Zzw=;
    private static int aDw=;
    private static int aTw=;
    private static int ajw=;
    private static int azw=;
    private static int bDw=;
    private static int bTw=;
    private static int bjw=;
    private static int bzw=;
    private static int cDw=;
    private static int cTw=;
    private static int cjw=;
    private static int czw=;
    private static int dDw=;
    private static int dTw=;
    private static int djw=;
    private static int dzw=;
    private static int eDw=;
    private static int eTw=;
    private static int ejw=;
    private static int ezw=;
    private static int fDw=;
    private static int fTw=;
    private static int fjw=;
    private static int fzw=;
    private static int gDw=;
    private static int gTw=;
    private static int gjw=;
    private static int gzw=;
    private static int hDw=;
    private static int hTw=;
    private static int hjw=;
    private static int hzw=;
    private static int iDw=;
    private static int iTw=;
    private static int ijw=;
    private static int izw=;
    internal dz0= jDw=;
    internal int jTw=;
    internal Byte[] jjw=;
    internal int jzw=;
    internal int kDw=;
    internal int kTw=;
    internal int kjw=;
    internal byte kzw=;
    internal byte lDw=;
    internal int lTw=;
    internal int ljw=;
    internal int lzw=;
    internal int mDw=;
    internal Byte[] mTw=;
    internal int mjw=;
    internal Int16[] mzw=;
    internal Int16[] nDw=;
    internal int nTw=;
    internal int njw=;
    internal int nzw=;
    internal int oDw=;
    internal int oTw=;
    internal int ojw=;
    internal int ozw=;
    internal int pDw=;
    internal int pTw=;
    internal int pjw=;
    internal int pzw=;
    internal int qDw=;
    internal int qTw=;
    internal int qjw=;
    internal int qzw=;
    internal int /h8=;
    internal int Fhs=;
    internal int rDw=;
    internal int rTw=;
    internal Int16[] rjw=;
    internal Int16[] rzw=;
    internal Int16[] sDw=;
    internal Xz0= sTw=;
    internal Xz0= sjw=;
    internal Xz0= szw=;
    internal Int16[] tDw=;
    internal Int32[] tTw=;
    internal int tjw=;
    internal int tzw=;
    internal Byte[] uDw=;
    internal int uTw=;
    internal int ujw=;
    internal int uzw=;
    internal int vDw=;
    internal int vTw=;
    internal int vjw=;
    internal int vzw=;
    internal int wDw=;
    internal short wTw=;
    internal int wjw=;
    private static Uzw=();
    internal void wzw=();
    internal void xDw=();
    internal void xTw=();
    internal void xjw=(Int16[] tree, int k);
    internal static bool xzw=(Int16[] tree, int n, int m, Byte[] depth);
    internal void yDw=(Int16[] tree, int max_code);
    internal int yTw=();
    internal void yjw=(int lcodes, int dcodes, int blcodes);
    internal void yzw=(Int16[] tree, int max_code);
    internal void zDw=(Byte[] p, int start, int len);
    internal void zDw=(byte c);
    internal void zTw=(int w);
    internal void zjw=(int b);
    internal void zzw=(int c, Int16[] tree);
    internal void 0Dw=(int value_Renamed, int length);
    internal void 0Tw=();
    internal bool 0jw=(int dist, int lc);
    internal void 0zw=(Int16[] ltree, Int16[] dtree);
    internal void 1Dw=();
    internal void 1Tw=();
    internal void 1jw=();
    internal void 1zw=(int buf, int len, bool header);
    internal void 2Dw=(bool eof);
    internal int 2Tw=(int flush);
    internal void 2jw=(int buf, int stored_len, bool eof);
    internal void 2zw=(int buf, int stored_len, bool eof);
    internal void 3Dw=();
    internal int 3Tw=(int flush);
    internal int 3jw=(int flush);
    internal int 3zw=(int cur_match);
    internal int 4Dw=(dz0= strm, int level, int bits);
    internal int 4Dw=(dz0= strm, int level);
    internal int 4Tw=(dz0= strm, int level, int method, int windowBits, int memLevel, int strategy);
    internal int 4jw=(dz0= strm);
    internal int 4zw=();
    internal int 5Dw=(dz0= strm, int _level, int _strategy);
    internal int 5Tw=(dz0= strm, Byte[] dictionary, int dictLength);
    internal int 5jw=(dz0= strm, int flush);
}
internal class WTM=.VTc= : object {
    private static int Vjc=;
    private static int Vzc=;
    private static int Ezc=;
    private static int WDc=;
    private static int WTc=;
    private static int Wjc=;
    private static int Wzc=;
    private static int XDc=;
    private static int XTc=;
    private static int Xjc=;
    private static int Xzc=;
    private static int YDc=;
    private static int YTc=;
    private oDk= Yjc=;
    private bool Yzc=;
    private bool ZDc=;
    private bool ZTc=;
    private bool Zjc=;
    private bool Zzc=;
    private bool aDc=;
    private Int32[] aTc=;
    public VTc=(oDk= cinfo);
    public void Ojc=();
    public void ajc=(Byte[][] input_buf, int input_row, Byte[][][] output_buf, int output_row, int num_rows);
    private void azc=();
    private void bDc=();
    private static int bTc=(double x);
    private void bjc=(Byte[][] input_buf, int input_row, Byte[][][] output_buf, int output_row, int num_rows);
    private void bzc=(Byte[][] input_buf, int input_row, Byte[][][] output_buf, int output_row, int num_rows);
    private void cDc=(Byte[][] input_buf, int input_row, Byte[][][] output_buf, int output_row, int num_rows);
    private void cTc=(Byte[][] input_buf, int input_row, Byte[][][] output_buf, int output_row, int num_rows);
    private void cjc=(Byte[][] input_buf, int input_row, Byte[][][] output_buf, int output_row, int num_rows);
}
internal enum WTM=.VTs= : Enum {
    public int value__;
    public static VTs= Vjs=;
    public static VTs= Vzs=;
    public static VTs= WDs=;
    public static VTs= WTs=;
    public static VTs= Wjs=;
    public static VTs= Wzs=;
}
internal enum WTM=.WDM= : Enum {
    public int value__;
    public static WDM= WjM=;
    public static WDM= WzM=;
    public static WDM= XDM=;
}
internal class WTM=.Wj0= : object {
    public static long ZyI=(long literal);
    public static ulong ZyI=(ulong literal);
    public static float ZyI=(float literal);
    public static double ZyI=(double literal);
    public static int Wz0=(int number, int bits);
    public static int Wz0=(int number, long bits);
    public static long Wz0=(long number, int bits);
    public static long Wz0=(long number, long bits);
    public static int XD0=(Stream sourceStream, Byte[] target, int start, int count);
    public static int XD0=(TextReader sourceTextReader, Byte[] target, int start, int count);
    public static Byte[] XT0=(string sourceString);
    public static Char[] Xj0=(Byte[] byteArray);
}
internal abstract class WTM=.Wjk= : object {
    internal 5Do= kzU=;
    internal Mjs= Wzk=;
    internal VkE= XDk=;
    public bool Xjk= { get; }
    public Mjs= YTk= { get; public set; }
    public 5Do= ZDk= { get; public set; }
    public static string FRQ= { get; }
    public static string Zjk= { get; }
    public Wjk=(5Do= errorManager);
    public abstract virtual bool XTk=();
    public Mjs= Xzk=();
    public void YDk=(Mjs= value);
    public 5Do= Yjk=();
    public void Yzk=(5Do= value);
    public static string ExQ=();
    public static string ZTk=();
    public static UDs=<byte> Zzk=(int samplesPerRow, int numberOfRows);
    public static UDs=<OTk=> aDk=(int blocksPerRow, int numberOfRows);
    public static Byte[][] aTk=(int samplesPerRow, int numberOfRows);
    private static OTk=[][] ajk=(int blocksPerRow, int numberOfRows);
    public void azk=();
    public void bDk=();
    public void bTk=(ZDs= code);
    public void bTk=(ZDs= code, Object[] args);
    public void bTk=(int code, Object[] args);
    public void bjk=(ZDs= code);
    public void bjk=(ZDs= code, Object[] args);
    public void bjk=(int code, Object[] args);
    public void bzk=(int lvl, ZDs= code);
    public void bzk=(int lvl, ZDs= code, Object[] args);
    public void bzk=(int lvl, int code, Object[] args);
}
internal class WTM=.wTU= : TiffTagMethods {
    public virtual bool SetField(Tiff tif, TiffTag tag, FieldValue[] ap);
    public virtual FieldValue[] GetField(Tiff tif, TiffTag tag);
    public virtual void PrintDir(Tiff tif, Stream fd, TiffPrintFlags flags);
    private static void wjU=(Tiff tif);
}
internal class WTM=.wzg= : object {
    private static int xDg=;
    private static int xTg=;
    private static int xjg=;
    private static int xzg=;
    private static int yDg=;
    private static int yTg=;
    private static int yjg=;
    private static int yzg=;
    private static int zDg=;
    private static int zTg=;
    private static int zjg=;
    private static int zzg=;
    private static int 0Dg=;
    private static int 0Tg=;
    private static int 0jg=;
    private static int 0zg=;
    private static int 1Dg=;
    private static int 1Tg=;
    private static int 1jg=;
    private static int 1zg=;
    private static int 2Dg=;
    private static int 2Tg=;
    private MUE= qzg=;
    private bool 2jg=;
    private UTo= Yjc=;
    private Byte[][] rDg=;
    private int 2zg=;
    private UInt16[][] 3Dg=;
    private bool 3Tg=;
    private Int16[] tDg=;
    private bool tTg=;
    private Int32[] 3jg=;
    public wzg=(UTo= cinfo);
    public virtual void Ojc=(bool is_pre_scan);
    public virtual void fzc=(Byte[][] input_buf, int in_row, Byte[][] output_buf, int out_row, int num_rows);
    public virtual void Qzc=();
    public virtual void gDc=();
    private void 3zg=(Byte[][] input_buf, int in_row, int num_rows);
    private void 4Dg=(Byte[][] input_buf, int in_row, Byte[][] output_buf, int out_row, int num_rows);
    private void 4Tg=(Byte[][] input_buf, int in_row, Byte[][] output_buf, int out_row, int num_rows);
    private void 4jg=();
    private void 4zg=(N0E=[] boxlist, int boxIndex, int icolor);
    private void 5Dg=(int desired_colors);
    private int 5Tg=(N0E=[] boxlist, int numboxes, int desired_colors);
    private static int 5jg=(N0E=[] boxlist, int numboxes);
    private static int 5zg=(N0E=[] boxlist, int numboxes);
    private void 6Dg=(N0E=[] boxlist, int boxIndex);
    private void 6Tg=();
    private int 6jg=(int minc0, int minc1, int minc2, Byte[] colorlist);
    private void 6zg=(int minc0, int minc1, int minc2, int numcolors, Byte[] colorlist, Byte[] bestcolor);
    private void 7Dg=(int c0, int c1, int c2);
}
internal class WTM=.wzU= : 5Do= {
    private gjU= xDU=;
    public wzU=(gjU= sp);
    public virtual void xTU=();
    public virtual void xjU=();
}
internal enum WTM=.XDs= : Enum {
    public int value__;
    public static XDs= XTs=;
    public static XDs= Xjs=;
    public static XDs= Xzs=;
}
internal enum WTM=.XTM= : Enum {
    public int value__;
    public static XTM= XjM=;
    public static XTM= XzM=;
    public static XTM= YDM=;
    public static XTM= YTM=;
    public static XTM= YjM=;
}
internal class WTM=.Xz0= : object {
    private static int hDw=;
    private static int hjw=;
    private static int hTw=;
    private static int iDw=;
    private static int hzw=;
    private static int iTw=;
    private static int ijw=;
    internal static int Tz0=;
    internal static int izw=;
    internal static int fjw=;
    internal static int fzw=;
    internal static int gDw=;
    internal static Int32[] YD0=;
    internal static Int32[] YT0=;
    internal static Int32[] Yj0=;
    internal static Byte[] Yz0=;
    internal static int fTw=;
    internal static int ZD0=;
    internal static Byte[] ZT0=;
    internal static Byte[] Zj0=;
    internal static Int32[] Zz0=;
    internal static Int32[] aD0=;
    internal Int16[] aT0=;
    internal int aj0=;
    internal Tj0= az0=;
    private static Xz0=();
    internal static int bD0=(int dist);
    internal void bT0=(Uzw= s);
    internal void bj0=(Uzw= s);
    internal static void bz0=(Int16[] tree, int max_code, Int16[] bl_count);
    internal static int cD0=(int code, int len);
}
internal class WTM=.xzU= : 3jo= {
    private Tiff yDU=;
    public xzU=(Tiff tif);
    public virtual void yTU=();
    public virtual bool yjU=();
    public virtual void yzU=();
}
internal enum WTM=.yDs= : Enum {
    public int value__;
    public static yDs= yTs=;
    public static yDs= yjs=;
    public static yDs= yzs=;
    public static yDs= zDs=;
    public static yDs= zTs=;
    public static yDs= zjs=;
    public static yDs= zzs=;
}
internal enum WTM=.YDs= : Enum {
    public int value__;
    public static YDs= YTs=;
    public static YDs= Yjs=;
    public static YDs= Yzs=;
}
internal class WTM=.YjQ= : TiffCodec {
    public static int YzQ=;
    private static TiffFieldInfo[] ZDQ=;
    private nTM= ZTQ=;
    private int ZjQ=;
    private int ZzQ=;
    private TiffTagMethods CTQ=;
    private TiffTagMethods CjQ=;
    private TiffTagMethods aDQ=;
    private bool aTQ=;
    private bool ajQ=;
    private yUA= azQ=;
    public YjQ=(Tiff tif, Compression scheme, string name);
    private static YjQ=();
    public void bDQ=(TiffTagMethods tagMethods);
    public void bTQ=();
    public virtual bool SetupDecode();
    public virtual bool DecodeRow(Byte[] buffer, int offset, int count, short plane);
    public virtual bool DecodeStrip(Byte[] buffer, int offset, int count, short plane);
    public virtual bool DecodeTile(Byte[] buffer, int offset, int count, short plane);
    public virtual bool SetupEncode();
    public virtual bool EncodeRow(Byte[] buffer, int offset, int count, short plane);
    public virtual bool EncodeStrip(Byte[] buffer, int offset, int count, short plane);
    public virtual bool EncodeTile(Byte[] buffer, int offset, int count, short plane);
    public virtual bool bjQ=();
    public virtual bool bzQ=(Byte[] buffer, int offset, int count, short plane);
    public virtual bool cDQ=(Byte[] buffer, int offset, int count, short plane);
    public virtual bool cTQ=(Byte[] buffer, int offset, int count, short plane);
    public virtual bool cjQ=();
    public virtual bool czQ=(Byte[] buffer, int offset, int count, short plane);
    public virtual bool dDQ=(Byte[] buffer, int offset, int count, short plane);
    public virtual bool dTQ=(Byte[] buffer, int offset, int count, short plane);
    public nTM= djQ=();
    public void dzQ=(nTM= value);
    public TiffTagMethods eDQ=();
    private void eTQ=(Byte[] buffer, int offset, int count);
    private void ejQ=(Byte[] buffer, int offset, int count);
    private void ezQ=(Byte[] buffer, int offset, int count);
    private void fDQ=(Byte[] buffer, int offset, int count);
    private void fTQ=(Byte[] buffer, int offset, int count);
    private void fjQ=(Byte[] buffer, int offset, int count);
    private void fzQ=(Byte[] buffer, int offset, int count);
    private void gDQ=(Byte[] buffer, int offset, int count);
    private void gTQ=(Byte[] buffer, int offset, int count);
    private void gjQ=(Byte[] buffer, int offset, int count);
    private void gzQ=(Byte[] buffer, int offset, int count);
    private bool hDQ=(Byte[] buffer, int offset, int count, short plane);
    private bool hTQ=(Byte[] buffer, int offset, int count, short plane);
    private bool hjQ=(Byte[] buffer, int offset, int count, short plane);
    private bool hzQ=(Byte[] buffer, int offset, int count, short plane);
    private bool iDQ=();
    private bool iTQ=();
    private bool ijQ=();
}
internal class WTM=.YTg= : object {
    private static int Yjg=;
    private static int Yzg=;
    private static int ZDg=;
    private UTo= Yjc=;
    private jpeg_marker_parser_method ZTg=;
    private jpeg_marker_parser_method[] Zjg=;
    private int Zzg=;
    private Int32[] aDg=;
    private bool aTg=;
    private bool ajg=;
    private int Pzc=;
    private int azg=;
    private LDs= bDg=;
    private int bTg=;
    public YTg=(UTo= cinfo);
    public void bjg=();
    public yDs= bzg=();
    public bool cDg=();
    public bool cTg=();
    public void cjg=(int marker_code, jpeg_marker_parser_method routine);
    public void czg=(int marker_code, int length_limit);
    public bool dDg=();
    public bool dTg=();
    public int djg=();
    public int dzg=();
    public void CCw=(int count);
    private static bool eDg=(UTo= cinfo);
    private static bool eTg=(UTo= cinfo);
    private static bool ejg=(UTo= cinfo);
    private static void ezg=(UTo= cinfo, Byte[] data, int datalen, int remaining);
    private static void fDg=(UTo= cinfo, Byte[] data, int datalen, int remaining);
    private bool fTg=();
    private bool fjg=(bool is_prog);
    private bool fzg=();
    private bool gDg=();
    private bool gTg=();
    private bool gjg=();
    private bool gzg=();
}
internal class WTM=.YTQ= : TiffTagMethods {
    public virtual bool SetField(Tiff tif, TiffTag tag, FieldValue[] ap);
    public virtual FieldValue[] GetField(Tiff tif, TiffTag tag);
    public virtual void PrintDir(Tiff tif, Stream fd, TiffPrintFlags flags);
}
internal enum WTM=.YzM= : Enum {
    public int value__;
    public static YzM= ZDM=;
    public static YzM= ZTM=;
    public static YzM= ZjM=;
}
internal enum WTM=.ZDs= : Enum {
    public int value__;
    public static ZDs= ZTs=;
    public static ZDs= Zjs=;
    public static ZDs= Zzs=;
    public static ZDs= aDs=;
    public static ZDs= aTs=;
    public static ZDs= ajs=;
    public static ZDs= azs=;
    public static ZDs= bDs=;
    public static ZDs= bTs=;
    public static ZDs= bjs=;
    public static ZDs= bzs=;
    public static ZDs= cDs=;
    public static ZDs= cTs=;
    public static ZDs= cjs=;
    public static ZDs= czs=;
    public static ZDs= dDs=;
    public static ZDs= dTs=;
    public static ZDs= djs=;
    public static ZDs= dzs=;
    public static ZDs= eDs=;
    public static ZDs= eTs=;
    public static ZDs= ejs=;
    public static ZDs= ezs=;
    public static ZDs= fDs=;
    public static ZDs= fTs=;
    public static ZDs= fjs=;
    public static ZDs= fzs=;
    public static ZDs= gDs=;
    public static ZDs= gTs=;
    public static ZDs= gjs=;
    public static ZDs= gzs=;
    public static ZDs= hDs=;
    public static ZDs= hTs=;
    public static ZDs= hjs=;
    public static ZDs= hzs=;
    public static ZDs= iDs=;
    public static ZDs= iTs=;
    public static ZDs= ijs=;
    public static ZDs= izs=;
    public static ZDs= jDs=;
    public static ZDs= jTs=;
    public static ZDs= jjs=;
    public static ZDs= jzs=;
    public static ZDs= kDs=;
    public static ZDs= kTs=;
    public static ZDs= kjs=;
    public static ZDs= kzs=;
    public static ZDs= lDs=;
    public static ZDs= lTs=;
    public static ZDs= ljs=;
    public static ZDs= lzs=;
    public static ZDs= mDs=;
    public static ZDs= mTs=;
    public static ZDs= mjs=;
    public static ZDs= mzs=;
    public static ZDs= nDs=;
    public static ZDs= nTs=;
    public static ZDs= njs=;
    public static ZDs= nzs=;
    public static ZDs= oDs=;
    public static ZDs= oTs=;
    public static ZDs= ojs=;
    public static ZDs= ozs=;
    public static ZDs= pDs=;
    public static ZDs= pTs=;
    public static ZDs= pjs=;
    public static ZDs= pzs=;
    public static ZDs= qDs=;
    public static ZDs= qTs=;
    public static ZDs= qjs=;
    public static ZDs= qzs=;
    public static ZDs= rDs=;
    public static ZDs= rTs=;
    public static ZDs= rjs=;
    public static ZDs= rzs=;
    public static ZDs= sDs=;
    public static ZDs= sTs=;
    public static ZDs= sjs=;
    public static ZDs= szs=;
    public static ZDs= tDs=;
    public static ZDs= tTs=;
    public static ZDs= tjs=;
    public static ZDs= tzs=;
    public static ZDs= uDs=;
    public static ZDs= uTs=;
    public static ZDs= ujs=;
    public static ZDs= uzs=;
    public static ZDs= vDs=;
    public static ZDs= vTs=;
    public static ZDs= vjs=;
    public static ZDs= vzs=;
    public static ZDs= wDs=;
    public static ZDs= wTs=;
    public static ZDs= wjs=;
    public static ZDs= wzs=;
    public static ZDs= xDs=;
    public static ZDs= xTs=;
    public static ZDs= xjs=;
    public static ZDs= xzs=;
}
internal class WTM=.zDU= : SDs= {
    private static Byte[] zTU=;
    protected gjU= xDU=;
    public zDU=(gjU= sp);
    private static zDU=();
    public virtual void zjU=();
    public virtual bool zzU=();
}
[FlagsAttribute]
internal enum WTM=.ZzM= : Enum {
    public int value__;
    public static ZzM= aDM=;
    public static ZzM= aTM=;
    public static ZzM= ajM=;
    public static ZzM= azM=;
    public static ZzM= bDM=;
    public static ZzM= bTM=;
}
[CompilerGeneratedAttribute]
[yBM=]
internal class yRM=.yBM= : Attribute {
}
[CompilerGeneratedAttribute]
[yBM=]
internal class yxM=.yhM= : Attribute {
}
internal static class zhM=.8BM= : object {
    internal static string 8RM=(string plainText);
    internal static string 8hM=(string plainText);
    internal static string 8xM=(string plainText);
    internal static DateTime 9BM=(string formatedDate);
    internal static string 9RM=(DateTime expireTime);
}
internal class zhM=.9hM= : CxQ= {
    private static Dictionary`2<string, 9hM=> 9xM=;
    private static object /BM=;
    private static bool /RM=;
    private static Dictionary`2<string, 9hM=> /xM= { get; }
    private static 9hM=();
    public static void ABQ=(Dictionary`2<string, Collection`1<string>> licenseContents);
    private static Dictionary`2<string, 9hM=> /hM=();
    public static IEnumerable`1<KxQ=> ARQ=(Guid productId);
    private static void AhQ=(Guid productId, bBQ= nodeType, IEnumerable`1<KxQ=> source, List`1<KxQ=> licenseNodes);
    public static void AxQ=();
    private static 9hM= BBQ=(string fileLicensePathName);
    private static 9hM= BRQ=(Stream licenseStream);
    private static 9hM= BhQ=(Collection`1<string> licenseLines);
    private static void BxQ=(KxQ= node);
    private static KxQ= CBQ=(string content);
    private static IEnumerable`1<string> CRQ=(string licenseFileExtension, string searchPattern);
    private static IEnumerable`1<string> ChQ=();
}
internal enum zhM=.bBQ= : Enum {
    public int value__;
    public static bBQ= bRQ=;
    public static bBQ= bhQ=;
    public static bBQ= bxQ=;
    public static bBQ= cBQ=;
}
internal abstract class zhM=.chQ= : object {
    [CompilerGeneratedAttribute]
private chQ= cxQ=;
    protected chQ= dhQ= { get; private set; }
    protected ThinkGeoLicenseStatus[] HxQ= { get; }
    [CompilerGeneratedAttribute]
protected chQ= dBQ=();
    [CompilerGeneratedAttribute]
private void dRQ=(chQ= value);
    public virtual void IBQ=(nRQ= context);
    public chQ= dxQ=(chQ= next);
    protected abstract virtual ThinkGeoLicenseStatus[] HhQ=();
}
internal class zhM=.cRQ= : chQ= {
    protected ThinkGeoLicenseStatus[] HxQ= { get; }
    public virtual void IBQ=(nRQ= context);
    protected virtual ThinkGeoLicenseStatus[] HhQ=();
}
internal abstract class zhM=.CxQ= : object {
    [CompilerGeneratedAttribute]
private string DBQ=;
    [CompilerGeneratedAttribute]
private string DRQ=;
    private Collection`1<KxQ=> DhQ=;
    private Collection`1<KxQ=> DxQ=;
    public string EhQ= { get; public set; }
    public string FRQ= { get; public set; }
    public IEnumerable`1<KxQ=> FxQ= { get; }
    public IEnumerable`1<KxQ=> GRQ= { get; }
    public bool GxQ= { get; }
    [CompilerGeneratedAttribute]
public string EBQ=();
    [CompilerGeneratedAttribute]
public void ERQ=(string value);
    [CompilerGeneratedAttribute]
public string ExQ=();
    [CompilerGeneratedAttribute]
public void FBQ=(string value);
    public IEnumerable`1<KxQ=> FhQ=();
    public IEnumerable`1<KxQ=> GBQ=();
    public void HBQ=(KxQ= node);
    public bool GhQ=();
}
internal static class zhM=.eBQ= : object {
    private static chQ= eRQ=;
    private static eBQ=();
    public static ThinkGeoLicenseStatus IBQ=(nRQ= validationContext);
}
internal class zhM=.ehQ= : object {
    private Guid exQ=;
    private string fBQ=;
    private string fRQ=;
    private string fhQ=;
    private string fxQ=;
    internal static Collection`1<ehQ=> gBQ=;
    public Guid gxQ= { get; public set; }
    public string pRM= { get; public set; }
    internal string hxQ= { get; internal set; }
    internal string ihQ= { get; internal set; }
    internal string jRQ= { get; internal set; }
    public bool jxQ= { get; }
    public bool kRQ= { get; }
    private static ehQ=();
    public Guid gRQ=();
    public void ghQ=(Guid value);
    public string pBM=();
    public void hBQ=(string value);
    internal string hRQ=();
    internal void hhQ=(string value);
    internal string iBQ=();
    internal void iRQ=(string value);
    internal string ixQ=();
    internal void jBQ=(string value);
    public bool jhQ=();
    public bool kBQ=();
    private static Collection`1<ehQ=> khQ=();
    [CompilerGeneratedAttribute]
private bool kxQ=(ehQ= p);
}
internal class zhM=.HRQ= : chQ= {
    protected ThinkGeoLicenseStatus[] HxQ= { get; }
    public virtual void IBQ=(nRQ= context);
    protected virtual ThinkGeoLicenseStatus[] HhQ=();
    private static bool IRQ=(KxQ= productNode);
    private static Assembly IhQ=(string assemblyPath, string assemblyName);
}
internal class zhM=.IxQ= : chQ= {
    protected ThinkGeoLicenseStatus[] HxQ= { get; }
    public virtual void IBQ=(nRQ= context);
    protected virtual ThinkGeoLicenseStatus[] HhQ=();
    private static bool JBQ=(KxQ= productNode);
}
internal class zhM=.JRQ= : chQ= {
    private static string JhQ=;
    protected ThinkGeoLicenseStatus[] HxQ= { get; }
    private static JRQ=();
    public virtual void IBQ=(nRQ= context);
    private static bool JxQ=(KxQ= node);
    protected virtual ThinkGeoLicenseStatus[] HhQ=();
    private bool KBQ=(KxQ= productNode);
    private static bool KRQ=(KxQ= productNode, bool isDebug);
}
internal class zhM=.KhQ= : chQ= {
    protected ThinkGeoLicenseStatus[] HxQ= { get; }
    public virtual void IBQ=(nRQ= context);
    protected virtual ThinkGeoLicenseStatus[] HhQ=();
}
internal class zhM=.KxQ= : object {
    public static KxQ= LBQ=;
    private Guid LRQ=;
    private Version LhQ=;
    private string LxQ=;
    private string MBQ=;
    private string MRQ=;
    private ehQ= MhQ=;
    private KxQ= MxQ=;
    private KxQ= NBQ=;
    private string NRQ=;
    private DateTime NhQ=;
    private Nullable`1<DateTime> NxQ=;
    private bBQ= OBQ=;
    private CxQ= ORQ=;
    private ThinkGeoLicenseStatus OhQ=;
    private string OxQ=;
    public string PBQ=;
    public Guid PxQ= { get; public set; }
    public Version FRQ= { get; public set; }
    public string QhQ= { get; public set; }
    public string RRQ= { get; public set; }
    public string SBQ= { get; public set; }
    public ehQ= SxQ= { get; public set; }
    public KxQ= ThQ= { get; public set; }
    public KxQ= URQ= { get; public set; }
    public string VBQ= { get; public set; }
    public DateTime VxQ= { get; public set; }
    public Nullable`1<DateTime> WhQ= { get; public set; }
    public bBQ= XRQ= { get; public set; }
    public CxQ= YBQ= { get; internal set; }
    public ThinkGeoLicenseStatus YxQ= { get; public set; }
    public string ZhQ= { get; public set; }
    public string aRQ= { get; public set; }
    public bool axQ= { get; }
    private static KxQ=();
    public Guid PRQ=();
    public void PhQ=(Guid value);
    public Version ExQ=();
    public void FBQ=(Version value);
    public string QBQ=();
    public void QRQ=(string value);
    public string QxQ=();
    public void RBQ=(string value);
    public string RhQ=();
    public void RxQ=(string value);
    public ehQ= SRQ=();
    public void ShQ=(ehQ= value);
    public KxQ= TBQ=();
    public void TRQ=(KxQ= value);
    public KxQ= TxQ=();
    public void UBQ=(KxQ= value);
    public string UhQ=();
    public void UxQ=(string value);
    public DateTime VRQ=();
    public void VhQ=(DateTime value);
    public Nullable`1<DateTime> WBQ=();
    public void WRQ=(Nullable`1<DateTime> value);
    public bBQ= WxQ=();
    public void XBQ=(bBQ= value);
    public CxQ= XhQ=();
    internal void XxQ=(CxQ= value);
    public ThinkGeoLicenseStatus YRQ=();
    public void YhQ=(ThinkGeoLicenseStatus value);
    public string ZBQ=();
    public void ZRQ=(string value);
    public string ZxQ=();
    public void aBQ=(string value);
    public bool ahQ=();
}
internal class zhM=.lBQ= : object {
    private static string lRQ=;
    private zRM= lhQ=;
    private zRM= lxQ=;
    private RSACryptoServiceProvider mBQ=;
    private static lBQ=();
    private void mRQ=(string publicKeyBase64);
    public Byte[] mhQ=(Byte[] encryptedData);
    public sealed virtual void Dispose();
    public string mxQ=(string encryptedData);
}
internal class zhM=.nBQ= : chQ= {
    protected ThinkGeoLicenseStatus[] HxQ= { get; }
    public virtual void IBQ=(nRQ= context);
    private static bool JxQ=(KxQ= node);
    protected virtual ThinkGeoLicenseStatus[] HhQ=();
}
internal class zhM=.nRQ= : object {
    [CompilerGeneratedAttribute]
private KxQ= nhQ=;
    [CompilerGeneratedAttribute]
private ThinkGeoLicenseStatus nxQ=;
    [CompilerGeneratedAttribute]
private bool oBQ=;
    public KxQ= oxQ= { get; private set; }
    public ThinkGeoLicenseStatus phQ= { get; public set; }
    public bool qRQ= { get; private set; }
    public nRQ=(KxQ= productNode, bool isDebug);
    [CompilerGeneratedAttribute]
public KxQ= oRQ=();
    [CompilerGeneratedAttribute]
private void ohQ=(KxQ= value);
    [CompilerGeneratedAttribute]
public ThinkGeoLicenseStatus pBQ=();
    [CompilerGeneratedAttribute]
public void pRQ=(ThinkGeoLicenseStatus value);
    [CompilerGeneratedAttribute]
public bool pxQ=();
    [CompilerGeneratedAttribute]
private void qBQ=(bool value);
}
internal class zhM=.zRM= : object {
    private static int zxM=;
    private UInt32[] 0BM=;
    public int 0RM=;
    public zRM=(long value);
    public zRM=(ulong value);
    public zRM=(zRM= bi);
    public zRM=(string value, int radix);
    public zRM=(Byte[] inData);
    public zRM=(Byte[] inData, int inLen);
    public zRM=(UInt32[] inData);
    public static zRM= 0hM=(long value);
    public static zRM= 0hM=(ulong value);
    public static zRM= 0hM=(int value);
    public static zRM= 0hM=(UInt32 value);
    public static zRM= 0xM=(zRM= bi1, zRM= bi2);
    public static zRM= 1BM=(zRM= bi1);
    public static zRM= 1RM=(zRM= bi1, zRM= bi2);
    public static zRM= 1hM=(zRM= bi1);
    public static zRM= 1xM=(zRM= bi1, zRM= bi2);
    public static zRM= 2BM=(zRM= bi1, int shiftVal);
    private static int 2RM=(UInt32[] buffer, int shiftVal);
    public static zRM= 2hM=(zRM= bi1, int shiftVal);
    private static int 2xM=(UInt32[] buffer, int shiftVal);
    public static zRM= 3BM=(zRM= bi1);
    public static zRM= 3RM=(zRM= bi1);
    public static bool 3hM=(zRM= bi1, zRM= bi2);
    public static bool 3xM=(zRM= bi1, zRM= bi2);
    public virtual bool Equals(object o);
    public virtual int GetHashCode();
    public static bool 4BM=(zRM= bi1, zRM= bi2);
    public static bool 4RM=(zRM= bi1, zRM= bi2);
    public static bool 4hM=(zRM= bi1, zRM= bi2);
    public static bool 4xM=(zRM= bi1, zRM= bi2);
    private static void 5BM=(zRM= bi1, zRM= bi2, zRM= outQuotient, zRM= outRemainder);
    private static void 5RM=(zRM= bi1, zRM= bi2, zRM= outQuotient, zRM= outRemainder);
    public static zRM= 5hM=(zRM= bi1, zRM= bi2);
    public static zRM= 5xM=(zRM= bi1, zRM= bi2);
    public static zRM= 6BM=(zRM= bi1, zRM= bi2);
    public static zRM= 6RM=(zRM= bi1, zRM= bi2);
    public static zRM= 6hM=(zRM= bi1, zRM= bi2);
    public virtual string ToString();
    public string 6xM=(int radix);
    public zRM= 7BM=(zRM= exp, zRM= n);
    private zRM= 7RM=(zRM= x, zRM= n, zRM= constant);
    private int 7hM=();
    public Byte[] 7xM=();
}
